<!DOCTYPE html>
<html>
  <head>
    <title>Plist HTML Viewer</title>

    <meta charset="UTF-8">

    <style type="text/css">
      .CodeMirror{font-family:monospace;height:300px;color:#000;direction:ltr}.CodeMirror-lines{padding:4px 0}.CodeMirror pre{padding:0 4px}.CodeMirror-gutter-filler,.CodeMirror-scrollbar-filler{background-color:#fff}.CodeMirror-gutters{border-right:1px solid #ddd;background-color:#f7f7f7;white-space:nowrap}.CodeMirror-linenumber{padding:0 3px 0 5px;min-width:20px;text-align:right;color:#999;white-space:nowrap}.CodeMirror-guttermarker{color:#000}.CodeMirror-guttermarker-subtle{color:#999}.CodeMirror-cursor{border-left:1px solid #000;border-right:none;width:0}.CodeMirror div.CodeMirror-secondarycursor{border-left:1px solid silver}.cm-fat-cursor .CodeMirror-cursor{width:auto;border:0!important;background:#7e7}.cm-fat-cursor div.CodeMirror-cursors{z-index:1}.cm-animate-fat-cursor{width:auto;border:0;-webkit-animation:blink 1.06s steps(1) infinite;-moz-animation:blink 1.06s steps(1) infinite;animation:blink 1.06s steps(1) infinite;background-color:#7e7}@-moz-keyframes blink{50%{background-color:transparent}}@-webkit-keyframes blink{50%{background-color:transparent}}@keyframes blink{50%{background-color:transparent}}.cm-tab{display:inline-block;text-decoration:inherit}.CodeMirror-rulers{position:absolute;left:0;right:0;top:-50px;bottom:-20px;overflow:hidden}.CodeMirror-ruler{border-left:1px solid #ccc;top:0;bottom:0;position:absolute}.cm-s-default .cm-header{color:#00f}.cm-s-default .cm-quote{color:#090}.cm-negative{color:#d44}.cm-positive{color:#292}.cm-header,.cm-strong{font-weight:700}.cm-em{font-style:italic}.cm-link{text-decoration:underline}.cm-strikethrough{text-decoration:line-through}.cm-s-default .cm-keyword{color:#708}.cm-s-default .cm-atom{color:#219}.cm-s-default .cm-number{color:#164}.cm-s-default .cm-def{color:#00f}.cm-s-default .cm-variable-2{color:#05a}.cm-s-default .cm-type,.cm-s-default .cm-variable-3{color:#085}.cm-s-default .cm-comment{color:#a50}.cm-s-default .cm-string{color:#a11}.cm-s-default .cm-string-2{color:#f50}.cm-s-default .cm-meta{color:#555}.cm-s-default .cm-qualifier{color:#555}.cm-s-default .cm-builtin{color:#30a}.cm-s-default .cm-bracket{color:#997}.cm-s-default .cm-tag{color:#170}.cm-s-default .cm-attribute{color:#00c}.cm-s-default .cm-hr{color:#999}.cm-s-default .cm-link{color:#00c}.cm-s-default .cm-error{color:red}.cm-invalidchar{color:red}.CodeMirror-composing{border-bottom:2px solid}div.CodeMirror span.CodeMirror-matchingbracket{color:#0f0}div.CodeMirror span.CodeMirror-nonmatchingbracket{color:#f22}.CodeMirror-matchingtag{background:rgba(255,150,0,.3)}.CodeMirror-activeline-background{background:#e8f2ff}.CodeMirror{position:relative;overflow:hidden;background:#fff}.CodeMirror-scroll{overflow:scroll!important;margin-bottom:-30px;margin-right:-30px;padding-bottom:30px;height:100%;outline:0;position:relative}.CodeMirror-sizer{position:relative;border-right:30px solid transparent}.CodeMirror-gutter-filler,.CodeMirror-hscrollbar,.CodeMirror-scrollbar-filler,.CodeMirror-vscrollbar{position:absolute;z-index:6;display:none}.CodeMirror-vscrollbar{right:0;top:0;overflow-x:hidden;overflow-y:scroll}.CodeMirror-hscrollbar{bottom:0;left:0;overflow-y:hidden;overflow-x:scroll}.CodeMirror-scrollbar-filler{right:0;bottom:0}.CodeMirror-gutter-filler{left:0;bottom:0}.CodeMirror-gutters{position:absolute;left:0;top:0;min-height:100%;z-index:3}.CodeMirror-gutter{white-space:normal;height:100%;display:inline-block;vertical-align:top;margin-bottom:-30px}.CodeMirror-gutter-wrapper{position:absolute;z-index:4;background:0 0!important;border:none!important}.CodeMirror-gutter-background{position:absolute;top:0;bottom:0;z-index:4}.CodeMirror-gutter-elt{position:absolute;cursor:default;z-index:4}.CodeMirror-gutter-wrapper ::selection{background-color:transparent}.CodeMirror-gutter-wrapper ::-moz-selection{background-color:transparent}.CodeMirror-lines{cursor:text;min-height:1px}.CodeMirror pre{-moz-border-radius:0;-webkit-border-radius:0;border-radius:0;border-width:0;background:0 0;font-family:inherit;font-size:inherit;margin:0;white-space:pre;word-wrap:normal;line-height:inherit;color:inherit;z-index:2;position:relative;overflow:visible;-webkit-tap-highlight-color:transparent;-webkit-font-variant-ligatures:contextual;font-variant-ligatures:contextual}.CodeMirror-wrap pre{word-wrap:break-word;white-space:pre-wrap;word-break:normal}.CodeMirror-linebackground{position:absolute;left:0;right:0;top:0;bottom:0;z-index:0}.CodeMirror-linewidget{position:relative;z-index:2;overflow:auto}.CodeMirror-rtl pre{direction:rtl}.CodeMirror-code{outline:0}.CodeMirror-gutter,.CodeMirror-gutters,.CodeMirror-linenumber,.CodeMirror-scroll,.CodeMirror-sizer{-moz-box-sizing:content-box;box-sizing:content-box}.CodeMirror-measure{position:absolute;width:100%;height:0;overflow:hidden;visibility:hidden}.CodeMirror-cursor{position:absolute;pointer-events:none}.CodeMirror-measure pre{position:static}div.CodeMirror-cursors{visibility:hidden;position:relative;z-index:3}div.CodeMirror-dragcursors{visibility:visible}.CodeMirror-focused div.CodeMirror-cursors{visibility:visible}.CodeMirror-selected{background:#d9d9d9}.CodeMirror-focused .CodeMirror-selected{background:#d7d4f0}.CodeMirror-crosshair{cursor:crosshair}.CodeMirror-line::selection,.CodeMirror-line>span::selection,.CodeMirror-line>span>span::selection{background:#d7d4f0}.CodeMirror-line::-moz-selection,.CodeMirror-line>span::-moz-selection,.CodeMirror-line>span>span::-moz-selection{background:#d7d4f0}.cm-searching{background-color:#ffa;background-color:rgba(255,255,0,.4)}.cm-force-border{padding-right:.1px}@media print{.CodeMirror div.CodeMirror-cursors{visibility:hidden}}.cm-tab-wrap-hack:after{content:''}span.CodeMirror-selectedtext{background:0 0}
/*# sourceMappingURL=codemirror.min.css.map */

      .severity-low {
  background-color: #669603;
}

.severity-low:after {
  content : 'L';
}

.severity-unspecified {
  background-color: #666666;
}

.severity-unspecified:after {
  content : 'U';
}

.severity-style {
  background-color: #9932cc;
}

.severity-style:after {
  content : 'S';
}

.severity-medium {
  background-color: #a9d323;
  color: black;
}

.severity-medium:after {
  content : 'M';
}

.severity-high {
  background-color: #ffa800;
}

.severity-high:after {
  content : 'H';
}

.severity-critical {
  background-color: #e92625;
}

.severity-critical:after {
  content : 'C';
}

i[class*="severity-"] {
  line-height: normal;
  text-transform: capitalize;
  font-size: 0.8em;
  font-weight: bold;
  color: white;
  display: inline-block;
  width: 16px;
  height: 16px;
  text-align: center;
  font-family: sans-serif;
}

      html, body {
  width: 100%;
  height: 100%;
  padding: 0px;
  margin: 0px;
}

div.container {
  padding: 10px;
}

#content {
  height: 100%;
  display: block;
  overflow: hidden;
}

#content > div {
  margin: 10px;
  overflow: hidden;
  border: 1px solid #ddd;
  border-radius: 3px;
  overflow: hidden;
  height: 97%;
}

.button {
  background-color: #f1f1f1;
  text-decoration: none;
  display: inline-block;
  padding: 8px 16px;
  color: black;
  cursor: pointer;
}

.button:hover {
  background-color: #ddd;
  color: black;
}

.review-status {
  color: white;
  text-align: center;
}

.review-status-confirmed {
  background-color: #e92625;
}

.review-status-false-positive {
  background-color: grey;
}

.review-status-intentional {
  background-color: #669603;
}

      div.container {
  width: 100%;
  height: 100%;
  padding: 0px;
}

#editor-wrapper {
  margin: 10px;
}

#side-bar {
  float: left;
  width: 260px;
  margin: 0px;
}

#report-nav ul {
  list-style-type: none;
  padding: 0;
  margin: 0;
  overflow-y: auto;
  height: 100%;
}

#report-nav ul > li {
  padding: .4em;
  background-color: #fff;
  border-bottom: 1px solid rgba(0,0,0,.125);
  text-align: left;
  overflow: hidden;
  white-space: nowrap;
  text-overflow: ellipsis;
}

#report-nav ul > li.active {
  background-color: #427ea9;
  color: white;
}

#report-nav ul > li:hover {
  background-color: #427ea9;
  color: white;
  cursor: pointer;
}

#report-nav ul a {
  text-decoration: none;
}

#report-nav i[class*="severity-"] {
  margin-right: 5px;
}

.header {
  border-bottom: 1px solid lightgrey;
  font-family: monospace;
  padding: 10px;
  background-color: #fafbfc;
  border-bottom: 1px solid #e1e4e8;
  border-top-left-radius: 2px;
  border-top-right-radius: 2px;
}

#report-nav .header {
  font-weight: bold;
}

#editor-wrapper .header > div {
  padding-top: 2px;
}

#file-path,
#checker-name {
  color: #195ea2;
}

#review-status {
  padding: 0px 5px;
}

#file-path {
  font-family: monospace;
}

.check-msg {
  display: inline-block;
  padding: 3px 6px;
  margin: 1px;
  -webkit-border-radius: 5px;
  -moz-border-radius: 5px;
  border-radius: 5px;
}

.check-msg.info {
  color: #00546f;
  background-color: #bfdfe9;
  border: 1px solid #87a8b3;
}

.check-msg.error {
  background-color: #f2dede;
  color: #a94442;
  border: 1px solid #ebcccc;
}

.check-msg.macro {
  background-color: #d7dac2;
  color: #4f5c6d;
  border: 1px solid #d7dac2;
}

.check-msg.note {
  background-color: #d7d7d7;
  color: #4f5c6d;
  border: 1px solid #bfbfbf;
}

.check-msg.current {
  border: 2px dashed #3692ff;
}

.check-msg .tag {
  padding: 1px 5px;
  text-align: center;
  border-radius: 2px;
  margin-right: 5px;
  text-decoration: inherit;
}

.check-msg .tag.macro {
  background-color: #83876a;
  color: white;
  text-transform: capitalize;
}

.check-msg .tag.note {
  background-color: #9299a1;
  color: white;
  text-transform: capitalize;
}

.checker-enum {
  color: white;
  padding: 1px 5px;
  text-align: center;
  border-radius: 25px;
  margin-right: 5px;
  text-decoration: inherit;
}

.checker-enum.info {
  background-color: #427ea9;
}

.checker-enum.error {
  background-color: #a94442;
}

.arrow {
  border: solid black;
  border-width: 0 3px 3px 0;
  display: inline-block;
  padding: 3px;
  cursor: pointer;
  margin: 0px 5px;
}

.arrow:hover {
  border: solid #437ea8;
  border-width: 0 3px 3px 0;
}

.left-arrow {
  transform: rotate(135deg);
  -webkit-transform: rotate(135deg);
}

.right-arrow {
  transform: rotate(-45deg);
  -webkit-transform: rotate(-45deg);
}

    </style>

    <script type="text/javascript">
      function setNonCompatibleBrowserMessage() {
  document.body.innerHTML =
    '<h2 style="margin-left: 20px;">Your browser is not compatible with CodeChecker Viewer!</h2> \
     <p style="margin-left: 20px;">The version required for the following browsers are:</p> \
     <ul style="margin-left: 20px;"> \
     <li>Internet Explorer: version 9 or newer</li> \
     <li>Firefox: version 22.0 or newer</li> \
     </ul>';
}

// http://stackoverflow.com/questions/5916900/how-can-you-detect-the-version-of-a-browser
var browserVersion = (function(){
  var ua = navigator.userAgent, tem,
    M = ua.match(/(opera|chrome|safari|firefox|msie|trident(?=\/))\/?\s*(\d+)/i) || [];

  if (/trident/i.test(M[1])) {
    tem = /\brv[ :]+(\d+)/g.exec(ua) || [];
    return 'IE ' + (tem[1] || '');
  }

  if (M[1] === 'Chrome') {
    tem = ua.match(/\b(OPR|Edge)\/(\d+)/);
    if (tem != null) return tem.slice(1).join(' ').replace('OPR', 'Opera');
  }

  M = M[2] ? [M[1], M[2]] : [navigator.appName, navigator.appVersion, '-?'];
  if ((tem = ua.match(/version\/(\d+)/i)) != null) M.splice(1, 1, tem[1]);
    return M.join(' ');
})();

var pos = browserVersion.indexOf(' ');
var browser = browserVersion.substr(0, pos);
var version = parseInt(browserVersion.substr(pos + 1));

var browserCompatible
  = browser === 'Firefox'
  ? version >= 22
  : browser === 'IE'
  ? version >= 9
  : true;


      /* MIT License

Copyright (C) 2017 by Marijn Haverbeke <marijnh@gmail.com> and others

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
THE SOFTWARE.
 */
      !function(e,t){"object"==typeof exports&&"undefined"!=typeof module?module.exports=t():"function"==typeof define&&define.amd?define(t):e.CodeMirror=t()}(this,function(){"use strict";function e(e){return new RegExp("(^|\\s)"+e+"(?:$|\\s)\\s*")}function t(e){for(var t=e.childNodes.length;t>0;--t)e.removeChild(e.firstChild);return e}function r(e,r){return t(e).appendChild(r)}function n(e,t,r,n){var i=document.createElement(e);if(r&&(i.className=r),n&&(i.style.cssText=n),"string"==typeof t)i.appendChild(document.createTextNode(t));else if(t)for(var o=0;o<t.length;++o)i.appendChild(t[o]);return i}function i(e,t,r,i){var o=n(e,t,r,i);return o.setAttribute("role","presentation"),o}function o(e,t){if(3==t.nodeType&&(t=t.parentNode),e.contains)return e.contains(t);do{if(11==t.nodeType&&(t=t.host),t==e)return!0}while(t=t.parentNode)}function l(){var e;try{e=document.activeElement}catch(t){e=document.body||null}for(;e&&e.shadowRoot&&e.shadowRoot.activeElement;)e=e.shadowRoot.activeElement;return e}function s(t,r){var n=t.className;e(r).test(n)||(t.className+=(n?" ":"")+r)}function a(t,r){for(var n=t.split(" "),i=0;i<n.length;i++)n[i]&&!e(n[i]).test(r)&&(r+=" "+n[i]);return r}function u(e){var t=Array.prototype.slice.call(arguments,1);return function(){return e.apply(null,t)}}function c(e,t,r){t||(t={});for(var n in e)!e.hasOwnProperty(n)||!1===r&&t.hasOwnProperty(n)||(t[n]=e[n]);return t}function f(e,t,r,n,i){null==t&&-1==(t=e.search(/[^\s\u00a0]/))&&(t=e.length);for(var o=n||0,l=i||0;;){var s=e.indexOf("\t",o);if(s<0||s>=t)return l+(t-o);l+=s-o,l+=r-l%r,o=s+1}}function h(e,t){for(var r=0;r<e.length;++r)if(e[r]==t)return r;return-1}function d(e,t,r){for(var n=0,i=0;;){var o=e.indexOf("\t",n);-1==o&&(o=e.length);var l=o-n;if(o==e.length||i+l>=t)return n+Math.min(l,t-i);if(i+=o-n,i+=r-i%r,n=o+1,i>=t)return n}}function p(e){for(;Kl.length<=e;)Kl.push(g(Kl)+" ");return Kl[e]}function g(e){return e[e.length-1]}function v(e,t){for(var r=[],n=0;n<e.length;n++)r[n]=t(e[n],n);return r}function m(e,t,r){for(var n=0,i=r(t);n<e.length&&r(e[n])<=i;)n++;e.splice(n,0,t)}function y(){}function b(e,t){var r;return Object.create?r=Object.create(e):(y.prototype=e,r=new y),t&&c(t,r),r}function w(e){return/\w/.test(e)||e>""&&(e.toUpperCase()!=e.toLowerCase()||jl.test(e))}function x(e,t){return t?!!(t.source.indexOf("\\w")>-1&&w(e))||t.test(e):w(e)}function C(e){for(var t in e)if(e.hasOwnProperty(t)&&e[t])return!1;return!0}function S(e){return e.charCodeAt(0)>=768&&Xl.test(e)}function L(e,t,r){for(;(r<0?t>0:t<e.length)&&S(e.charAt(t));)t+=r;return t}function k(e,t,r){for(var n=t>r?-1:1;;){if(t==r)return t;var i=(t+r)/2,o=n<0?Math.ceil(i):Math.floor(i);if(o==t)return e(o)?t:r;e(o)?r=o:t=o+n}}function T(e,t,r){var o=this;this.input=r,o.scrollbarFiller=n("div",null,"CodeMirror-scrollbar-filler"),o.scrollbarFiller.setAttribute("cm-not-content","true"),o.gutterFiller=n("div",null,"CodeMirror-gutter-filler"),o.gutterFiller.setAttribute("cm-not-content","true"),o.lineDiv=i("div",null,"CodeMirror-code"),o.selectionDiv=n("div",null,null,"position: relative; z-index: 1"),o.cursorDiv=n("div",null,"CodeMirror-cursors"),o.measure=n("div",null,"CodeMirror-measure"),o.lineMeasure=n("div",null,"CodeMirror-measure"),o.lineSpace=i("div",[o.measure,o.lineMeasure,o.selectionDiv,o.cursorDiv,o.lineDiv],null,"position: relative; outline: none");var l=i("div",[o.lineSpace],"CodeMirror-lines");o.mover=n("div",[l],null,"position: relative"),o.sizer=n("div",[o.mover],"CodeMirror-sizer"),o.sizerWidth=null,o.heightForcer=n("div",null,null,"position: absolute; height: "+Rl+"px; width: 1px;"),o.gutters=n("div",null,"CodeMirror-gutters"),o.lineGutter=null,o.scroller=n("div",[o.sizer,o.heightForcer,o.gutters],"CodeMirror-scroll"),o.scroller.setAttribute("tabIndex","-1"),o.wrapper=n("div",[o.scrollbarFiller,o.gutterFiller,o.scroller],"CodeMirror"),gl&&vl<8&&(o.gutters.style.zIndex=-1,o.scroller.style.paddingRight=0),ml||fl&&Tl||(o.scroller.draggable=!0),e&&(e.appendChild?e.appendChild(o.wrapper):e(o.wrapper)),o.viewFrom=o.viewTo=t.first,o.reportedViewFrom=o.reportedViewTo=t.first,o.view=[],o.renderedView=null,o.externalMeasured=null,o.viewOffset=0,o.lastWrapHeight=o.lastWrapWidth=0,o.updateLineNumbers=null,o.nativeBarWidth=o.barHeight=o.barWidth=0,o.scrollbarsClipped=!1,o.lineNumWidth=o.lineNumInnerWidth=o.lineNumChars=null,o.alignWidgets=!1,o.cachedCharWidth=o.cachedTextHeight=o.cachedPaddingH=null,o.maxLine=null,o.maxLineLength=0,o.maxLineChanged=!1,o.wheelDX=o.wheelDY=o.wheelStartX=o.wheelStartY=null,o.shift=!1,o.selForContextMenu=null,o.activeTouch=null,r.init(o)}function M(e,t){if((t-=e.first)<0||t>=e.size)throw new Error("There is no line "+(t+e.first)+" in the document.");for(var r=e;!r.lines;)for(var n=0;;++n){var i=r.children[n],o=i.chunkSize();if(t<o){r=i;break}t-=o}return r.lines[t]}function N(e,t,r){var n=[],i=t.line;return e.iter(t.line,r.line+1,function(e){var o=e.text;i==r.line&&(o=o.slice(0,r.ch)),i==t.line&&(o=o.slice(t.ch)),n.push(o),++i}),n}function O(e,t,r){var n=[];return e.iter(t,r,function(e){n.push(e.text)}),n}function A(e,t){var r=t-e.height;if(r)for(var n=e;n;n=n.parent)n.height+=r}function W(e){if(null==e.parent)return null;for(var t=e.parent,r=h(t.lines,e),n=t.parent;n;t=n,n=n.parent)for(var i=0;n.children[i]!=t;++i)r+=n.children[i].chunkSize();return r+t.first}function D(e,t){var r=e.first;e:do{for(var n=0;n<e.children.length;++n){var i=e.children[n],o=i.height;if(t<o){e=i;continue e}t-=o,r+=i.chunkSize()}return r}while(!e.lines);for(var l=0;l<e.lines.length;++l){var s=e.lines[l].height;if(t<s)break;t-=s}return r+l}function H(e,t){return t>=e.first&&t<e.first+e.size}function F(e,t){return String(e.lineNumberFormatter(t+e.firstLineNumber))}function E(e,t,r){if(void 0===r&&(r=null),!(this instanceof E))return new E(e,t,r);this.line=e,this.ch=t,this.sticky=r}function P(e,t){return e.line-t.line||e.ch-t.ch}function I(e,t){return e.sticky==t.sticky&&0==P(e,t)}function z(e){return E(e.line,e.ch)}function R(e,t){return P(e,t)<0?t:e}function B(e,t){return P(e,t)<0?e:t}function G(e,t){return Math.max(e.first,Math.min(t,e.first+e.size-1))}function U(e,t){if(t.line<e.first)return E(e.first,0);var r=e.first+e.size-1;return t.line>r?E(r,M(e,r).text.length):V(t,M(e,t.line).text.length)}function V(e,t){var r=e.ch;return null==r||r>t?E(e.line,t):r<0?E(e.line,0):e}function K(e,t){for(var r=[],n=0;n<t.length;n++)r[n]=U(e,t[n]);return r}function j(){Yl=!0}function X(){_l=!0}function Y(e,t,r){this.marker=e,this.from=t,this.to=r}function _(e,t){if(e)for(var r=0;r<e.length;++r){var n=e[r];if(n.marker==t)return n}}function $(e,t){for(var r,n=0;n<e.length;++n)e[n]!=t&&(r||(r=[])).push(e[n]);return r}function q(e,t){e.markedSpans=e.markedSpans?e.markedSpans.concat([t]):[t],t.marker.attachLine(e)}function Z(e,t,r){var n;if(e)for(var i=0;i<e.length;++i){var o=e[i],l=o.marker;if(null==o.from||(l.inclusiveLeft?o.from<=t:o.from<t)||o.from==t&&"bookmark"==l.type&&(!r||!o.marker.insertLeft)){var s=null==o.to||(l.inclusiveRight?o.to>=t:o.to>t);(n||(n=[])).push(new Y(l,o.from,s?null:o.to))}}return n}function Q(e,t,r){var n;if(e)for(var i=0;i<e.length;++i){var o=e[i],l=o.marker;if(null==o.to||(l.inclusiveRight?o.to>=t:o.to>t)||o.from==t&&"bookmark"==l.type&&(!r||o.marker.insertLeft)){var s=null==o.from||(l.inclusiveLeft?o.from<=t:o.from<t);(n||(n=[])).push(new Y(l,s?null:o.from-t,null==o.to?null:o.to-t))}}return n}function J(e,t){if(t.full)return null;var r=H(e,t.from.line)&&M(e,t.from.line).markedSpans,n=H(e,t.to.line)&&M(e,t.to.line).markedSpans;if(!r&&!n)return null;var i=t.from.ch,o=t.to.ch,l=0==P(t.from,t.to),s=Z(r,i,l),a=Q(n,o,l),u=1==t.text.length,c=g(t.text).length+(u?i:0);if(s)for(var f=0;f<s.length;++f){var h=s[f];if(null==h.to){var d=_(a,h.marker);d?u&&(h.to=null==d.to?null:d.to+c):h.to=i}}if(a)for(var p=0;p<a.length;++p){var v=a[p];null!=v.to&&(v.to+=c),null==v.from?_(s,v.marker)||(v.from=c,u&&(s||(s=[])).push(v)):(v.from+=c,u&&(s||(s=[])).push(v))}s&&(s=ee(s)),a&&a!=s&&(a=ee(a));var m=[s];if(!u){var y,b=t.text.length-2;if(b>0&&s)for(var w=0;w<s.length;++w)null==s[w].to&&(y||(y=[])).push(new Y(s[w].marker,null,null));for(var x=0;x<b;++x)m.push(y);m.push(a)}return m}function ee(e){for(var t=0;t<e.length;++t){var r=e[t];null!=r.from&&r.from==r.to&&!1!==r.marker.clearWhenEmpty&&e.splice(t--,1)}return e.length?e:null}function te(e,t,r){var n=null;if(e.iter(t.line,r.line+1,function(e){if(e.markedSpans)for(var t=0;t<e.markedSpans.length;++t){var r=e.markedSpans[t].marker;!r.readOnly||n&&-1!=h(n,r)||(n||(n=[])).push(r)}}),!n)return null;for(var i=[{from:t,to:r}],o=0;o<n.length;++o)for(var l=n[o],s=l.find(0),a=0;a<i.length;++a){var u=i[a];if(!(P(u.to,s.from)<0||P(u.from,s.to)>0)){var c=[a,1],f=P(u.from,s.from),d=P(u.to,s.to);(f<0||!l.inclusiveLeft&&!f)&&c.push({from:u.from,to:s.from}),(d>0||!l.inclusiveRight&&!d)&&c.push({from:s.to,to:u.to}),i.splice.apply(i,c),a+=c.length-3}}return i}function re(e){var t=e.markedSpans;if(t){for(var r=0;r<t.length;++r)t[r].marker.detachLine(e);e.markedSpans=null}}function ne(e,t){if(t){for(var r=0;r<t.length;++r)t[r].marker.attachLine(e);e.markedSpans=t}}function ie(e){return e.inclusiveLeft?-1:0}function oe(e){return e.inclusiveRight?1:0}function le(e,t){var r=e.lines.length-t.lines.length;if(0!=r)return r;var n=e.find(),i=t.find(),o=P(n.from,i.from)||ie(e)-ie(t);if(o)return-o;var l=P(n.to,i.to)||oe(e)-oe(t);return l||t.id-e.id}function se(e,t){var r,n=_l&&e.markedSpans;if(n)for(var i=void 0,o=0;o<n.length;++o)(i=n[o]).marker.collapsed&&null==(t?i.from:i.to)&&(!r||le(r,i.marker)<0)&&(r=i.marker);return r}function ae(e){return se(e,!0)}function ue(e){return se(e,!1)}function ce(e,t,r,n,i){var o=M(e,t),l=_l&&o.markedSpans;if(l)for(var s=0;s<l.length;++s){var a=l[s];if(a.marker.collapsed){var u=a.marker.find(0),c=P(u.from,r)||ie(a.marker)-ie(i),f=P(u.to,n)||oe(a.marker)-oe(i);if(!(c>=0&&f<=0||c<=0&&f>=0)&&(c<=0&&(a.marker.inclusiveRight&&i.inclusiveLeft?P(u.to,r)>=0:P(u.to,r)>0)||c>=0&&(a.marker.inclusiveRight&&i.inclusiveLeft?P(u.from,n)<=0:P(u.from,n)<0)))return!0}}}function fe(e){for(var t;t=ae(e);)e=t.find(-1,!0).line;return e}function he(e){for(var t;t=ue(e);)e=t.find(1,!0).line;return e}function de(e){for(var t,r;t=ue(e);)e=t.find(1,!0).line,(r||(r=[])).push(e);return r}function pe(e,t){var r=M(e,t),n=fe(r);return r==n?t:W(n)}function ge(e,t){if(t>e.lastLine())return t;var r,n=M(e,t);if(!ve(e,n))return t;for(;r=ue(n);)n=r.find(1,!0).line;return W(n)+1}function ve(e,t){var r=_l&&t.markedSpans;if(r)for(var n=void 0,i=0;i<r.length;++i)if((n=r[i]).marker.collapsed){if(null==n.from)return!0;if(!n.marker.widgetNode&&0==n.from&&n.marker.inclusiveLeft&&me(e,t,n))return!0}}function me(e,t,r){if(null==r.to){var n=r.marker.find(1,!0);return me(e,n.line,_(n.line.markedSpans,r.marker))}if(r.marker.inclusiveRight&&r.to==t.text.length)return!0;for(var i=void 0,o=0;o<t.markedSpans.length;++o)if((i=t.markedSpans[o]).marker.collapsed&&!i.marker.widgetNode&&i.from==r.to&&(null==i.to||i.to!=r.from)&&(i.marker.inclusiveLeft||r.marker.inclusiveRight)&&me(e,t,i))return!0}function ye(e){for(var t=0,r=(e=fe(e)).parent,n=0;n<r.lines.length;++n){var i=r.lines[n];if(i==e)break;t+=i.height}for(var o=r.parent;o;r=o,o=r.parent)for(var l=0;l<o.children.length;++l){var s=o.children[l];if(s==r)break;t+=s.height}return t}function be(e){if(0==e.height)return 0;for(var t,r=e.text.length,n=e;t=ae(n);){var i=t.find(0,!0);n=i.from.line,r+=i.from.ch-i.to.ch}for(n=e;t=ue(n);){var o=t.find(0,!0);r-=n.text.length-o.from.ch,r+=(n=o.to.line).text.length-o.to.ch}return r}function we(e){var t=e.display,r=e.doc;t.maxLine=M(r,r.first),t.maxLineLength=be(t.maxLine),t.maxLineChanged=!0,r.iter(function(e){var r=be(e);r>t.maxLineLength&&(t.maxLineLength=r,t.maxLine=e)})}function xe(e,t,r,n){if(!e)return n(t,r,"ltr",0);for(var i=!1,o=0;o<e.length;++o){var l=e[o];(l.from<r&&l.to>t||t==r&&l.to==t)&&(n(Math.max(l.from,t),Math.min(l.to,r),1==l.level?"rtl":"ltr",o),i=!0)}i||n(t,r,"ltr")}function Ce(e,t,r){var n;$l=null;for(var i=0;i<e.length;++i){var o=e[i];if(o.from<t&&o.to>t)return i;o.to==t&&(o.from!=o.to&&"before"==r?n=i:$l=i),o.from==t&&(o.from!=o.to&&"before"!=r?n=i:$l=i)}return null!=n?n:$l}function Se(e,t){var r=e.order;return null==r&&(r=e.order=ql(e.text,t)),r}function Le(e,t){return e._handlers&&e._handlers[t]||Zl}function ke(e,t,r){if(e.removeEventListener)e.removeEventListener(t,r,!1);else if(e.detachEvent)e.detachEvent("on"+t,r);else{var n=e._handlers,i=n&&n[t];if(i){var o=h(i,r);o>-1&&(n[t]=i.slice(0,o).concat(i.slice(o+1)))}}}function Te(e,t){var r=Le(e,t);if(r.length)for(var n=Array.prototype.slice.call(arguments,2),i=0;i<r.length;++i)r[i].apply(null,n)}function Me(e,t,r){return"string"==typeof t&&(t={type:t,preventDefault:function(){this.defaultPrevented=!0}}),Te(e,r||t.type,e,t),He(t)||t.codemirrorIgnore}function Ne(e){var t=e._handlers&&e._handlers.cursorActivity;if(t)for(var r=e.curOp.cursorActivityHandlers||(e.curOp.cursorActivityHandlers=[]),n=0;n<t.length;++n)-1==h(r,t[n])&&r.push(t[n])}function Oe(e,t){return Le(e,t).length>0}function Ae(e){e.prototype.on=function(e,t){Ql(this,e,t)},e.prototype.off=function(e,t){ke(this,e,t)}}function We(e){e.preventDefault?e.preventDefault():e.returnValue=!1}function De(e){e.stopPropagation?e.stopPropagation():e.cancelBubble=!0}function He(e){return null!=e.defaultPrevented?e.defaultPrevented:0==e.returnValue}function Fe(e){We(e),De(e)}function Ee(e){return e.target||e.srcElement}function Pe(e){var t=e.which;return null==t&&(1&e.button?t=1:2&e.button?t=3:4&e.button&&(t=2)),Ml&&e.ctrlKey&&1==t&&(t=3),t}function Ie(e){if(null==Il){var t=n("span","​");r(e,n("span",[t,document.createTextNode("x")])),0!=e.firstChild.offsetHeight&&(Il=t.offsetWidth<=1&&t.offsetHeight>2&&!(gl&&vl<8))}var i=Il?n("span","​"):n("span"," ",null,"display: inline-block; width: 1px; margin-right: -1px");return i.setAttribute("cm-text",""),i}function ze(e){if(null!=zl)return zl;var n=r(e,document.createTextNode("AخA")),i=Wl(n,0,1).getBoundingClientRect(),o=Wl(n,1,2).getBoundingClientRect();return t(e),!(!i||i.left==i.right)&&(zl=o.right-i.right<3)}function Re(e){if(null!=ns)return ns;var t=r(e,n("span","x")),i=t.getBoundingClientRect(),o=Wl(t,0,1).getBoundingClientRect();return ns=Math.abs(i.left-o.left)>1}function Be(e,t){arguments.length>2&&(t.dependencies=Array.prototype.slice.call(arguments,2)),is[e]=t}function Ge(e){if("string"==typeof e&&os.hasOwnProperty(e))e=os[e];else if(e&&"string"==typeof e.name&&os.hasOwnProperty(e.name)){var t=os[e.name];"string"==typeof t&&(t={name:t}),(e=b(t,e)).name=t.name}else{if("string"==typeof e&&/^[\w\-]+\/[\w\-]+\+xml$/.test(e))return Ge("application/xml");if("string"==typeof e&&/^[\w\-]+\/[\w\-]+\+json$/.test(e))return Ge("application/json")}return"string"==typeof e?{name:e}:e||{name:"null"}}function Ue(e,t){t=Ge(t);var r=is[t.name];if(!r)return Ue(e,"text/plain");var n=r(e,t);if(ls.hasOwnProperty(t.name)){var i=ls[t.name];for(var o in i)i.hasOwnProperty(o)&&(n.hasOwnProperty(o)&&(n["_"+o]=n[o]),n[o]=i[o])}if(n.name=t.name,t.helperType&&(n.helperType=t.helperType),t.modeProps)for(var l in t.modeProps)n[l]=t.modeProps[l];return n}function Ve(e,t){c(t,ls.hasOwnProperty(e)?ls[e]:ls[e]={})}function Ke(e,t){if(!0===t)return t;if(e.copyState)return e.copyState(t);var r={};for(var n in t){var i=t[n];i instanceof Array&&(i=i.concat([])),r[n]=i}return r}function je(e,t){for(var r;e.innerMode&&(r=e.innerMode(t))&&r.mode!=e;)t=r.state,e=r.mode;return r||{mode:e,state:t}}function Xe(e,t,r){return!e.startState||e.startState(t,r)}function Ye(e,t,r,n){var i=[e.state.modeGen],o={};tt(e,t.text,e.doc.mode,r,function(e,t){return i.push(e,t)},o,n);for(var l=r.state,s=0;s<e.state.overlays.length;++s)!function(n){var l=e.state.overlays[n],s=1,a=0;r.state=!0,tt(e,t.text,l.mode,r,function(e,t){for(var r=s;a<e;){var n=i[s];n>e&&i.splice(s,1,e,i[s+1],n),s+=2,a=Math.min(e,n)}if(t)if(l.opaque)i.splice(r,s-r,e,"overlay "+t),s=r+2;else for(;r<s;r+=2){var o=i[r+1];i[r+1]=(o?o+" ":"")+"overlay "+t}},o)}(s);return r.state=l,{styles:i,classes:o.bgClass||o.textClass?o:null}}function _e(e,t,r){if(!t.styles||t.styles[0]!=e.state.modeGen){var n=$e(e,W(t)),i=t.text.length>e.options.maxHighlightLength&&Ke(e.doc.mode,n.state),o=Ye(e,t,n);i&&(n.state=i),t.stateAfter=n.save(!i),t.styles=o.styles,o.classes?t.styleClasses=o.classes:t.styleClasses&&(t.styleClasses=null),r===e.doc.highlightFrontier&&(e.doc.modeFrontier=Math.max(e.doc.modeFrontier,++e.doc.highlightFrontier))}return t.styles}function $e(e,t,r){var n=e.doc,i=e.display;if(!n.mode.startState)return new us(n,!0,t);var o=rt(e,t,r),l=o>n.first&&M(n,o-1).stateAfter,s=l?us.fromSaved(n,l,o):new us(n,Xe(n.mode),o);return n.iter(o,t,function(r){qe(e,r.text,s);var n=s.line;r.stateAfter=n==t-1||n%5==0||n>=i.viewFrom&&n<i.viewTo?s.save():null,s.nextLine()}),r&&(n.modeFrontier=s.line),s}function qe(e,t,r,n){var i=e.doc.mode,o=new ss(t,e.options.tabSize,r);for(o.start=o.pos=n||0,""==t&&Ze(i,r.state);!o.eol();)Qe(i,o,r.state),o.start=o.pos}function Ze(e,t){if(e.blankLine)return e.blankLine(t);if(e.innerMode){var r=je(e,t);return r.mode.blankLine?r.mode.blankLine(r.state):void 0}}function Qe(e,t,r,n){for(var i=0;i<10;i++){n&&(n[0]=je(e,r).mode);var o=e.token(t,r);if(t.pos>t.start)return o}throw new Error("Mode "+e.name+" failed to advance stream.")}function Je(e,t,r,n){var i,o,l=e.doc,s=l.mode,a=M(l,(t=U(l,t)).line),u=$e(e,t.line,r),c=new ss(a.text,e.options.tabSize,u);for(n&&(o=[]);(n||c.pos<t.ch)&&!c.eol();)c.start=c.pos,i=Qe(s,c,u.state),n&&o.push(new cs(c,i,Ke(l.mode,u.state)));return n?o:new cs(c,i,u.state)}function et(e,t){if(e)for(;;){var r=e.match(/(?:^|\s+)line-(background-)?(\S+)/);if(!r)break;e=e.slice(0,r.index)+e.slice(r.index+r[0].length);var n=r[1]?"bgClass":"textClass";null==t[n]?t[n]=r[2]:new RegExp("(?:^|s)"+r[2]+"(?:$|s)").test(t[n])||(t[n]+=" "+r[2])}return e}function tt(e,t,r,n,i,o,l){var s=r.flattenSpans;null==s&&(s=e.options.flattenSpans);var a,u=0,c=null,f=new ss(t,e.options.tabSize,n),h=e.options.addModeClass&&[null];for(""==t&&et(Ze(r,n.state),o);!f.eol();){if(f.pos>e.options.maxHighlightLength?(s=!1,l&&qe(e,t,n,f.pos),f.pos=t.length,a=null):a=et(Qe(r,f,n.state,h),o),h){var d=h[0].name;d&&(a="m-"+(a?d+" "+a:d))}if(!s||c!=a){for(;u<f.start;)i(u=Math.min(f.start,u+5e3),c);c=a}f.start=f.pos}for(;u<f.pos;){var p=Math.min(f.pos,u+5e3);i(p,c),u=p}}function rt(e,t,r){for(var n,i,o=e.doc,l=r?-1:t-(e.doc.mode.innerMode?1e3:100),s=t;s>l;--s){if(s<=o.first)return o.first;var a=M(o,s-1),u=a.stateAfter;if(u&&(!r||s+(u instanceof as?u.lookAhead:0)<=o.modeFrontier))return s;var c=f(a.text,null,e.options.tabSize);(null==i||n>c)&&(i=s-1,n=c)}return i}function nt(e,t){if(e.modeFrontier=Math.min(e.modeFrontier,t),!(e.highlightFrontier<t-10)){for(var r=e.first,n=t-1;n>r;n--){var i=M(e,n).stateAfter;if(i&&(!(i instanceof as)||n+i.lookAhead<t)){r=n+1;break}}e.highlightFrontier=Math.min(e.highlightFrontier,r)}}function it(e,t,r,n){e.text=t,e.stateAfter&&(e.stateAfter=null),e.styles&&(e.styles=null),null!=e.order&&(e.order=null),re(e),ne(e,r);var i=n?n(e):1;i!=e.height&&A(e,i)}function ot(e){e.parent=null,re(e)}function lt(e,t){if(!e||/^\s*$/.test(e))return null;var r=t.addModeClass?ps:ds;return r[e]||(r[e]=e.replace(/\S+/g,"cm-$&"))}function st(e,t){var r=i("span",null,null,ml?"padding-right: .1px":null),n={pre:i("pre",[r],"CodeMirror-line"),content:r,col:0,pos:0,cm:e,trailingSpace:!1,splitSpaces:(gl||ml)&&e.getOption("lineWrapping")};t.measure={};for(var o=0;o<=(t.rest?t.rest.length:0);o++){var l=o?t.rest[o-1]:t.line,s=void 0;n.pos=0,n.addToken=ut,ze(e.display.measure)&&(s=Se(l,e.doc.direction))&&(n.addToken=ft(n.addToken,s)),n.map=[],dt(l,n,_e(e,l,t!=e.display.externalMeasured&&W(l))),l.styleClasses&&(l.styleClasses.bgClass&&(n.bgClass=a(l.styleClasses.bgClass,n.bgClass||"")),l.styleClasses.textClass&&(n.textClass=a(l.styleClasses.textClass,n.textClass||""))),0==n.map.length&&n.map.push(0,0,n.content.appendChild(Ie(e.display.measure))),0==o?(t.measure.map=n.map,t.measure.cache={}):((t.measure.maps||(t.measure.maps=[])).push(n.map),(t.measure.caches||(t.measure.caches=[])).push({}))}if(ml){var u=n.content.lastChild;(/\bcm-tab\b/.test(u.className)||u.querySelector&&u.querySelector(".cm-tab"))&&(n.content.className="cm-tab-wrap-hack")}return Te(e,"renderLine",e,t.line,n.pre),n.pre.className&&(n.textClass=a(n.pre.className,n.textClass||"")),n}function at(e){var t=n("span","•","cm-invalidchar");return t.title="\\u"+e.charCodeAt(0).toString(16),t.setAttribute("aria-label",t.title),t}function ut(e,t,r,i,o,l,s){if(t){var a,u=e.splitSpaces?ct(t,e.trailingSpace):t,c=e.cm.state.specialChars,f=!1;if(c.test(t)){a=document.createDocumentFragment();for(var h=0;;){c.lastIndex=h;var d=c.exec(t),g=d?d.index-h:t.length-h;if(g){var v=document.createTextNode(u.slice(h,h+g));gl&&vl<9?a.appendChild(n("span",[v])):a.appendChild(v),e.map.push(e.pos,e.pos+g,v),e.col+=g,e.pos+=g}if(!d)break;h+=g+1;var m=void 0;if("\t"==d[0]){var y=e.cm.options.tabSize,b=y-e.col%y;(m=a.appendChild(n("span",p(b),"cm-tab"))).setAttribute("role","presentation"),m.setAttribute("cm-text","\t"),e.col+=b}else"\r"==d[0]||"\n"==d[0]?((m=a.appendChild(n("span","\r"==d[0]?"␍":"␤","cm-invalidchar"))).setAttribute("cm-text",d[0]),e.col+=1):((m=e.cm.options.specialCharPlaceholder(d[0])).setAttribute("cm-text",d[0]),gl&&vl<9?a.appendChild(n("span",[m])):a.appendChild(m),e.col+=1);e.map.push(e.pos,e.pos+1,m),e.pos++}}else e.col+=t.length,a=document.createTextNode(u),e.map.push(e.pos,e.pos+t.length,a),gl&&vl<9&&(f=!0),e.pos+=t.length;if(e.trailingSpace=32==u.charCodeAt(t.length-1),r||i||o||f||s){var w=r||"";i&&(w+=i),o&&(w+=o);var x=n("span",[a],w,s);return l&&(x.title=l),e.content.appendChild(x)}e.content.appendChild(a)}}function ct(e,t){if(e.length>1&&!/  /.test(e))return e;for(var r=t,n="",i=0;i<e.length;i++){var o=e.charAt(i);" "!=o||!r||i!=e.length-1&&32!=e.charCodeAt(i+1)||(o=" "),n+=o,r=" "==o}return n}function ft(e,t){return function(r,n,i,o,l,s,a){i=i?i+" cm-force-border":"cm-force-border";for(var u=r.pos,c=u+n.length;;){for(var f=void 0,h=0;h<t.length&&!((f=t[h]).to>u&&f.from<=u);h++);if(f.to>=c)return e(r,n,i,o,l,s,a);e(r,n.slice(0,f.to-u),i,o,null,s,a),o=null,n=n.slice(f.to-u),u=f.to}}}function ht(e,t,r,n){var i=!n&&r.widgetNode;i&&e.map.push(e.pos,e.pos+t,i),!n&&e.cm.display.input.needsContentAttribute&&(i||(i=e.content.appendChild(document.createElement("span"))),i.setAttribute("cm-marker",r.id)),i&&(e.cm.display.input.setUneditable(i),e.content.appendChild(i)),e.pos+=t,e.trailingSpace=!1}function dt(e,t,r){var n=e.markedSpans,i=e.text,o=0;if(n)for(var l,s,a,u,c,f,h,d=i.length,p=0,g=1,v="",m=0;;){if(m==p){a=u=c=f=s="",h=null,m=1/0;for(var y=[],b=void 0,w=0;w<n.length;++w){var x=n[w],C=x.marker;"bookmark"==C.type&&x.from==p&&C.widgetNode?y.push(C):x.from<=p&&(null==x.to||x.to>p||C.collapsed&&x.to==p&&x.from==p)?(null!=x.to&&x.to!=p&&m>x.to&&(m=x.to,u=""),C.className&&(a+=" "+C.className),C.css&&(s=(s?s+";":"")+C.css),C.startStyle&&x.from==p&&(c+=" "+C.startStyle),C.endStyle&&x.to==m&&(b||(b=[])).push(C.endStyle,x.to),C.title&&!f&&(f=C.title),C.collapsed&&(!h||le(h.marker,C)<0)&&(h=x)):x.from>p&&m>x.from&&(m=x.from)}if(b)for(var S=0;S<b.length;S+=2)b[S+1]==m&&(u+=" "+b[S]);if(!h||h.from==p)for(var L=0;L<y.length;++L)ht(t,0,y[L]);if(h&&(h.from||0)==p){if(ht(t,(null==h.to?d+1:h.to)-p,h.marker,null==h.from),null==h.to)return;h.to==p&&(h=!1)}}if(p>=d)break;for(var k=Math.min(d,m);;){if(v){var T=p+v.length;if(!h){var M=T>k?v.slice(0,k-p):v;t.addToken(t,M,l?l+a:a,c,p+M.length==m?u:"",f,s)}if(T>=k){v=v.slice(k-p),p=k;break}p=T,c=""}v=i.slice(o,o=r[g++]),l=lt(r[g++],t.cm.options)}}else for(var N=1;N<r.length;N+=2)t.addToken(t,i.slice(o,o=r[N]),lt(r[N+1],t.cm.options))}function pt(e,t,r){this.line=t,this.rest=de(t),this.size=this.rest?W(g(this.rest))-r+1:1,this.node=this.text=null,this.hidden=ve(e,t)}function gt(e,t,r){for(var n,i=[],o=t;o<r;o=n){var l=new pt(e.doc,M(e.doc,o),o);n=o+l.size,i.push(l)}return i}function vt(e){gs?gs.ops.push(e):e.ownsGroup=gs={ops:[e],delayedCallbacks:[]}}function mt(e){var t=e.delayedCallbacks,r=0;do{for(;r<t.length;r++)t[r].call(null);for(var n=0;n<e.ops.length;n++){var i=e.ops[n];if(i.cursorActivityHandlers)for(;i.cursorActivityCalled<i.cursorActivityHandlers.length;)i.cursorActivityHandlers[i.cursorActivityCalled++].call(null,i.cm)}}while(r<t.length)}function yt(e,t){var r=e.ownsGroup;if(r)try{mt(r)}finally{gs=null,t(r)}}function bt(e,t){var r=Le(e,t);if(r.length){var n,i=Array.prototype.slice.call(arguments,2);gs?n=gs.delayedCallbacks:vs?n=vs:(n=vs=[],setTimeout(wt,0));for(var o=0;o<r.length;++o)!function(e){n.push(function(){return r[e].apply(null,i)})}(o)}}function wt(){var e=vs;vs=null;for(var t=0;t<e.length;++t)e[t]()}function xt(e,t,r,n){for(var i=0;i<t.changes.length;i++){var o=t.changes[i];"text"==o?kt(e,t):"gutter"==o?Mt(e,t,r,n):"class"==o?Tt(e,t):"widget"==o&&Nt(e,t,n)}t.changes=null}function Ct(e){return e.node==e.text&&(e.node=n("div",null,null,"position: relative"),e.text.parentNode&&e.text.parentNode.replaceChild(e.node,e.text),e.node.appendChild(e.text),gl&&vl<8&&(e.node.style.zIndex=2)),e.node}function St(e,t){var r=t.bgClass?t.bgClass+" "+(t.line.bgClass||""):t.line.bgClass;if(r&&(r+=" CodeMirror-linebackground"),t.background)r?t.background.className=r:(t.background.parentNode.removeChild(t.background),t.background=null);else if(r){var i=Ct(t);t.background=i.insertBefore(n("div",null,r),i.firstChild),e.display.input.setUneditable(t.background)}}function Lt(e,t){var r=e.display.externalMeasured;return r&&r.line==t.line?(e.display.externalMeasured=null,t.measure=r.measure,r.built):st(e,t)}function kt(e,t){var r=t.text.className,n=Lt(e,t);t.text==t.node&&(t.node=n.pre),t.text.parentNode.replaceChild(n.pre,t.text),t.text=n.pre,n.bgClass!=t.bgClass||n.textClass!=t.textClass?(t.bgClass=n.bgClass,t.textClass=n.textClass,Tt(e,t)):r&&(t.text.className=r)}function Tt(e,t){St(e,t),t.line.wrapClass?Ct(t).className=t.line.wrapClass:t.node!=t.text&&(t.node.className="");var r=t.textClass?t.textClass+" "+(t.line.textClass||""):t.line.textClass;t.text.className=r||""}function Mt(e,t,r,i){if(t.gutter&&(t.node.removeChild(t.gutter),t.gutter=null),t.gutterBackground&&(t.node.removeChild(t.gutterBackground),t.gutterBackground=null),t.line.gutterClass){var o=Ct(t);t.gutterBackground=n("div",null,"CodeMirror-gutter-background "+t.line.gutterClass,"left: "+(e.options.fixedGutter?i.fixedPos:-i.gutterTotalWidth)+"px; width: "+i.gutterTotalWidth+"px"),e.display.input.setUneditable(t.gutterBackground),o.insertBefore(t.gutterBackground,t.text)}var l=t.line.gutterMarkers;if(e.options.lineNumbers||l){var s=Ct(t),a=t.gutter=n("div",null,"CodeMirror-gutter-wrapper","left: "+(e.options.fixedGutter?i.fixedPos:-i.gutterTotalWidth)+"px");if(e.display.input.setUneditable(a),s.insertBefore(a,t.text),t.line.gutterClass&&(a.className+=" "+t.line.gutterClass),!e.options.lineNumbers||l&&l["CodeMirror-linenumbers"]||(t.lineNumber=a.appendChild(n("div",F(e.options,r),"CodeMirror-linenumber CodeMirror-gutter-elt","left: "+i.gutterLeft["CodeMirror-linenumbers"]+"px; width: "+e.display.lineNumInnerWidth+"px"))),l)for(var u=0;u<e.options.gutters.length;++u){var c=e.options.gutters[u],f=l.hasOwnProperty(c)&&l[c];f&&a.appendChild(n("div",[f],"CodeMirror-gutter-elt","left: "+i.gutterLeft[c]+"px; width: "+i.gutterWidth[c]+"px"))}}}function Nt(e,t,r){t.alignable&&(t.alignable=null);for(var n=t.node.firstChild,i=void 0;n;n=i)i=n.nextSibling,"CodeMirror-linewidget"==n.className&&t.node.removeChild(n);At(e,t,r)}function Ot(e,t,r,n){var i=Lt(e,t);return t.text=t.node=i.pre,i.bgClass&&(t.bgClass=i.bgClass),i.textClass&&(t.textClass=i.textClass),Tt(e,t),Mt(e,t,r,n),At(e,t,n),t.node}function At(e,t,r){if(Wt(e,t.line,t,r,!0),t.rest)for(var n=0;n<t.rest.length;n++)Wt(e,t.rest[n],t,r,!1)}function Wt(e,t,r,i,o){if(t.widgets)for(var l=Ct(r),s=0,a=t.widgets;s<a.length;++s){var u=a[s],c=n("div",[u.node],"CodeMirror-linewidget");u.handleMouseEvents||c.setAttribute("cm-ignore-events","true"),Dt(u,c,r,i),e.display.input.setUneditable(c),o&&u.above?l.insertBefore(c,r.gutter||r.text):l.appendChild(c),bt(u,"redraw")}}function Dt(e,t,r,n){if(e.noHScroll){(r.alignable||(r.alignable=[])).push(t);var i=n.wrapperWidth;t.style.left=n.fixedPos+"px",e.coverGutter||(i-=n.gutterTotalWidth,t.style.paddingLeft=n.gutterTotalWidth+"px"),t.style.width=i+"px"}e.coverGutter&&(t.style.zIndex=5,t.style.position="relative",e.noHScroll||(t.style.marginLeft=-n.gutterTotalWidth+"px"))}function Ht(e){if(null!=e.height)return e.height;var t=e.doc.cm;if(!t)return 0;if(!o(document.body,e.node)){var i="position: relative;";e.coverGutter&&(i+="margin-left: -"+t.display.gutters.offsetWidth+"px;"),e.noHScroll&&(i+="width: "+t.display.wrapper.clientWidth+"px;"),r(t.display.measure,n("div",[e.node],null,i))}return e.height=e.node.parentNode.offsetHeight}function Ft(e,t){for(var r=Ee(t);r!=e.wrapper;r=r.parentNode)if(!r||1==r.nodeType&&"true"==r.getAttribute("cm-ignore-events")||r.parentNode==e.sizer&&r!=e.mover)return!0}function Et(e){return e.lineSpace.offsetTop}function Pt(e){return e.mover.offsetHeight-e.lineSpace.offsetHeight}function It(e){if(e.cachedPaddingH)return e.cachedPaddingH;var t=r(e.measure,n("pre","x")),i=window.getComputedStyle?window.getComputedStyle(t):t.currentStyle,o={left:parseInt(i.paddingLeft),right:parseInt(i.paddingRight)};return isNaN(o.left)||isNaN(o.right)||(e.cachedPaddingH=o),o}function zt(e){return Rl-e.display.nativeBarWidth}function Rt(e){return e.display.scroller.clientWidth-zt(e)-e.display.barWidth}function Bt(e){return e.display.scroller.clientHeight-zt(e)-e.display.barHeight}function Gt(e,t,r){var n=e.options.lineWrapping,i=n&&Rt(e);if(!t.measure.heights||n&&t.measure.width!=i){var o=t.measure.heights=[];if(n){t.measure.width=i;for(var l=t.text.firstChild.getClientRects(),s=0;s<l.length-1;s++){var a=l[s],u=l[s+1];Math.abs(a.bottom-u.bottom)>2&&o.push((a.bottom+u.top)/2-r.top)}}o.push(r.bottom-r.top)}}function Ut(e,t,r){if(e.line==t)return{map:e.measure.map,cache:e.measure.cache};for(var n=0;n<e.rest.length;n++)if(e.rest[n]==t)return{map:e.measure.maps[n],cache:e.measure.caches[n]};for(var i=0;i<e.rest.length;i++)if(W(e.rest[i])>r)return{map:e.measure.maps[i],cache:e.measure.caches[i],before:!0}}function Vt(e,t){var n=W(t=fe(t)),i=e.display.externalMeasured=new pt(e.doc,t,n);i.lineN=n;var o=i.built=st(e,i);return i.text=o.pre,r(e.display.lineMeasure,o.pre),i}function Kt(e,t,r,n){return Yt(e,Xt(e,t),r,n)}function jt(e,t){if(t>=e.display.viewFrom&&t<e.display.viewTo)return e.display.view[Lr(e,t)];var r=e.display.externalMeasured;return r&&t>=r.lineN&&t<r.lineN+r.size?r:void 0}function Xt(e,t){var r=W(t),n=jt(e,r);n&&!n.text?n=null:n&&n.changes&&(xt(e,n,r,br(e)),e.curOp.forceUpdate=!0),n||(n=Vt(e,t));var i=Ut(n,t,r);return{line:t,view:n,rect:null,map:i.map,cache:i.cache,before:i.before,hasHeights:!1}}function Yt(e,t,r,n,i){t.before&&(r=-1);var o,l=r+(n||"");return t.cache.hasOwnProperty(l)?o=t.cache[l]:(t.rect||(t.rect=t.view.text.getBoundingClientRect()),t.hasHeights||(Gt(e,t.view,t.rect),t.hasHeights=!0),(o=qt(e,t,r,n)).bogus||(t.cache[l]=o)),{left:o.left,right:o.right,top:i?o.rtop:o.top,bottom:i?o.rbottom:o.bottom}}function _t(e,t,r){for(var n,i,o,l,s,a,u=0;u<e.length;u+=3)if(s=e[u],a=e[u+1],t<s?(i=0,o=1,l="left"):t<a?o=(i=t-s)+1:(u==e.length-3||t==a&&e[u+3]>t)&&(i=(o=a-s)-1,t>=a&&(l="right")),null!=i){if(n=e[u+2],s==a&&r==(n.insertLeft?"left":"right")&&(l=r),"left"==r&&0==i)for(;u&&e[u-2]==e[u-3]&&e[u-1].insertLeft;)n=e[2+(u-=3)],l="left";if("right"==r&&i==a-s)for(;u<e.length-3&&e[u+3]==e[u+4]&&!e[u+5].insertLeft;)n=e[(u+=3)+2],l="right";break}return{node:n,start:i,end:o,collapse:l,coverStart:s,coverEnd:a}}function $t(e,t){var r=ms;if("left"==t)for(var n=0;n<e.length&&(r=e[n]).left==r.right;n++);else for(var i=e.length-1;i>=0&&(r=e[i]).left==r.right;i--);return r}function qt(e,t,r,n){var i,o=_t(t.map,r,n),l=o.node,s=o.start,a=o.end,u=o.collapse;if(3==l.nodeType){for(var c=0;c<4;c++){for(;s&&S(t.line.text.charAt(o.coverStart+s));)--s;for(;o.coverStart+a<o.coverEnd&&S(t.line.text.charAt(o.coverStart+a));)++a;if((i=gl&&vl<9&&0==s&&a==o.coverEnd-o.coverStart?l.parentNode.getBoundingClientRect():$t(Wl(l,s,a).getClientRects(),n)).left||i.right||0==s)break;a=s,s-=1,u="right"}gl&&vl<11&&(i=Zt(e.display.measure,i))}else{s>0&&(u=n="right");var f;i=e.options.lineWrapping&&(f=l.getClientRects()).length>1?f["right"==n?f.length-1:0]:l.getBoundingClientRect()}if(gl&&vl<9&&!s&&(!i||!i.left&&!i.right)){var h=l.parentNode.getClientRects()[0];i=h?{left:h.left,right:h.left+yr(e.display),top:h.top,bottom:h.bottom}:ms}for(var d=i.top-t.rect.top,p=i.bottom-t.rect.top,g=(d+p)/2,v=t.view.measure.heights,m=0;m<v.length-1&&!(g<v[m]);m++);var y=m?v[m-1]:0,b=v[m],w={left:("right"==u?i.right:i.left)-t.rect.left,right:("left"==u?i.left:i.right)-t.rect.left,top:y,bottom:b};return i.left||i.right||(w.bogus=!0),e.options.singleCursorHeightPerLine||(w.rtop=d,w.rbottom=p),w}function Zt(e,t){if(!window.screen||null==screen.logicalXDPI||screen.logicalXDPI==screen.deviceXDPI||!Re(e))return t;var r=screen.logicalXDPI/screen.deviceXDPI,n=screen.logicalYDPI/screen.deviceYDPI;return{left:t.left*r,right:t.right*r,top:t.top*n,bottom:t.bottom*n}}function Qt(e){if(e.measure&&(e.measure.cache={},e.measure.heights=null,e.rest))for(var t=0;t<e.rest.length;t++)e.measure.caches[t]={}}function Jt(e){e.display.externalMeasure=null,t(e.display.lineMeasure);for(var r=0;r<e.display.view.length;r++)Qt(e.display.view[r])}function er(e){Jt(e),e.display.cachedCharWidth=e.display.cachedTextHeight=e.display.cachedPaddingH=null,e.options.lineWrapping||(e.display.maxLineChanged=!0),e.display.lineNumChars=null}function tr(){return bl&&kl?-(document.body.getBoundingClientRect().left-parseInt(getComputedStyle(document.body).marginLeft)):window.pageXOffset||(document.documentElement||document.body).scrollLeft}function rr(){return bl&&kl?-(document.body.getBoundingClientRect().top-parseInt(getComputedStyle(document.body).marginTop)):window.pageYOffset||(document.documentElement||document.body).scrollTop}function nr(e){var t=0;if(e.widgets)for(var r=0;r<e.widgets.length;++r)e.widgets[r].above&&(t+=Ht(e.widgets[r]));return t}function ir(e,t,r,n,i){if(!i){var o=nr(t);r.top+=o,r.bottom+=o}if("line"==n)return r;n||(n="local");var l=ye(t);if("local"==n?l+=Et(e.display):l-=e.display.viewOffset,"page"==n||"window"==n){var s=e.display.lineSpace.getBoundingClientRect();l+=s.top+("window"==n?0:rr());var a=s.left+("window"==n?0:tr());r.left+=a,r.right+=a}return r.top+=l,r.bottom+=l,r}function or(e,t,r){if("div"==r)return t;var n=t.left,i=t.top;if("page"==r)n-=tr(),i-=rr();else if("local"==r||!r){var o=e.display.sizer.getBoundingClientRect();n+=o.left,i+=o.top}var l=e.display.lineSpace.getBoundingClientRect();return{left:n-l.left,top:i-l.top}}function lr(e,t,r,n,i){return n||(n=M(e.doc,t.line)),ir(e,n,Kt(e,n,t.ch,i),r)}function sr(e,t,r,n,i,o){function l(t,l){var s=Yt(e,i,t,l?"right":"left",o);return l?s.left=s.right:s.right=s.left,ir(e,n,s,r)}function s(e,t,r){var n=1==a[t].level;return l(r?e-1:e,n!=r)}n=n||M(e.doc,t.line),i||(i=Xt(e,n));var a=Se(n,e.doc.direction),u=t.ch,c=t.sticky;if(u>=n.text.length?(u=n.text.length,c="before"):u<=0&&(u=0,c="after"),!a)return l("before"==c?u-1:u,"before"==c);var f=Ce(a,u,c),h=$l,d=s(u,f,"before"==c);return null!=h&&(d.other=s(u,h,"before"!=c)),d}function ar(e,t){var r=0;t=U(e.doc,t),e.options.lineWrapping||(r=yr(e.display)*t.ch);var n=M(e.doc,t.line),i=ye(n)+Et(e.display);return{left:r,right:r,top:i,bottom:i+n.height}}function ur(e,t,r,n,i){var o=E(e,t,r);return o.xRel=i,n&&(o.outside=!0),o}function cr(e,t,r){var n=e.doc;if((r+=e.display.viewOffset)<0)return ur(n.first,0,null,!0,-1);var i=D(n,r),o=n.first+n.size-1;if(i>o)return ur(n.first+n.size-1,M(n,o).text.length,null,!0,1);t<0&&(t=0);for(var l=M(n,i);;){var s=pr(e,l,i,t,r),a=ue(l),u=a&&a.find(0,!0);if(!a||!(s.ch>u.from.ch||s.ch==u.from.ch&&s.xRel>0))return s;i=W(l=u.to.line)}}function fr(e,t,r,n){n-=nr(t);var i=t.text.length,o=k(function(t){return Yt(e,r,t-1).bottom<=n},i,0);return i=k(function(t){return Yt(e,r,t).top>n},o,i),{begin:o,end:i}}function hr(e,t,r,n){return r||(r=Xt(e,t)),fr(e,t,r,ir(e,t,Yt(e,r,n),"line").top)}function dr(e,t,r,n){return!(e.bottom<=r)&&(e.top>r||(n?e.left:e.right)>t)}function pr(e,t,r,n,i){i-=ye(t);var o=Xt(e,t),l=nr(t),s=0,a=t.text.length,u=!0,c=Se(t,e.doc.direction);if(c){var f=(e.options.lineWrapping?vr:gr)(e,t,r,o,c,n,i);s=(u=1!=f.level)?f.from:f.to-1,a=u?f.to:f.from-1}var h,d,p=null,g=null,v=k(function(t){var r=Yt(e,o,t);return r.top+=l,r.bottom+=l,!!dr(r,n,i,!1)&&(r.top<=i&&r.left<=n&&(p=t,g=r),!0)},s,a),m=!1;if(g){var y=n-g.left<g.right-n,b=y==u;v=p+(b?0:1),d=b?"after":"before",h=y?g.left:g.right}else{u||v!=a&&v!=s||v++,d=0==v?"after":v==t.text.length?"before":Yt(e,o,v-(u?1:0)).bottom+l<=i==u?"after":"before";var w=sr(e,E(r,v,d),"line",t,o);h=w.left,m=i<w.top||i>=w.bottom}return v=L(t.text,v,1),ur(r,v,d,m,n-h)}function gr(e,t,r,n,i,o,l){var s=k(function(s){var a=i[s],u=1!=a.level;return dr(sr(e,E(r,u?a.to:a.from,u?"before":"after"),"line",t,n),o,l,!0)},0,i.length-1),a=i[s];if(s>0){var u=1!=a.level,c=sr(e,E(r,u?a.from:a.to,u?"after":"before"),"line",t,n);dr(c,o,l,!0)&&c.top>l&&(a=i[s-1])}return a}function vr(e,t,r,n,i,o,l){for(var s=fr(e,t,n,l),a=s.begin,u=s.end,c=null,f=null,h=0;h<i.length;h++){var d=i[h];if(!(d.from>=u||d.to<=a)){var p=Yt(e,n,1!=d.level?Math.min(u,d.to)-1:Math.max(a,d.from)).right,g=p<o?o-p+1e9:p-o;(!c||f>g)&&(c=d,f=g)}}return c||(c=i[i.length-1]),c.from<a&&(c={from:a,to:c.to,level:c.level}),c.to>u&&(c={from:c.from,to:u,level:c.level}),c}function mr(e){if(null!=e.cachedTextHeight)return e.cachedTextHeight;if(null==hs){hs=n("pre");for(var i=0;i<49;++i)hs.appendChild(document.createTextNode("x")),hs.appendChild(n("br"));hs.appendChild(document.createTextNode("x"))}r(e.measure,hs);var o=hs.offsetHeight/50;return o>3&&(e.cachedTextHeight=o),t(e.measure),o||1}function yr(e){if(null!=e.cachedCharWidth)return e.cachedCharWidth;var t=n("span","xxxxxxxxxx"),i=n("pre",[t]);r(e.measure,i);var o=t.getBoundingClientRect(),l=(o.right-o.left)/10;return l>2&&(e.cachedCharWidth=l),l||10}function br(e){for(var t=e.display,r={},n={},i=t.gutters.clientLeft,o=t.gutters.firstChild,l=0;o;o=o.nextSibling,++l)r[e.options.gutters[l]]=o.offsetLeft+o.clientLeft+i,n[e.options.gutters[l]]=o.clientWidth;return{fixedPos:wr(t),gutterTotalWidth:t.gutters.offsetWidth,gutterLeft:r,gutterWidth:n,wrapperWidth:t.wrapper.clientWidth}}function wr(e){return e.scroller.getBoundingClientRect().left-e.sizer.getBoundingClientRect().left}function xr(e){var t=mr(e.display),r=e.options.lineWrapping,n=r&&Math.max(5,e.display.scroller.clientWidth/yr(e.display)-3);return function(i){if(ve(e.doc,i))return 0;var o=0;if(i.widgets)for(var l=0;l<i.widgets.length;l++)i.widgets[l].height&&(o+=i.widgets[l].height);return r?o+(Math.ceil(i.text.length/n)||1)*t:o+t}}function Cr(e){var t=e.doc,r=xr(e);t.iter(function(e){var t=r(e);t!=e.height&&A(e,t)})}function Sr(e,t,r,n){var i=e.display;if(!r&&"true"==Ee(t).getAttribute("cm-not-content"))return null;var o,l,s=i.lineSpace.getBoundingClientRect();try{o=t.clientX-s.left,l=t.clientY-s.top}catch(t){return null}var a,u=cr(e,o,l);if(n&&1==u.xRel&&(a=M(e.doc,u.line).text).length==u.ch){var c=f(a,a.length,e.options.tabSize)-a.length;u=E(u.line,Math.max(0,Math.round((o-It(e.display).left)/yr(e.display))-c))}return u}function Lr(e,t){if(t>=e.display.viewTo)return null;if((t-=e.display.viewFrom)<0)return null;for(var r=e.display.view,n=0;n<r.length;n++)if((t-=r[n].size)<0)return n}function kr(e){e.display.input.showSelection(e.display.input.prepareSelection())}function Tr(e,t){void 0===t&&(t=!0);for(var r=e.doc,n={},i=n.cursors=document.createDocumentFragment(),o=n.selection=document.createDocumentFragment(),l=0;l<r.sel.ranges.length;l++)if(t||l!=r.sel.primIndex){var s=r.sel.ranges[l];if(!(s.from().line>=e.display.viewTo||s.to().line<e.display.viewFrom)){var a=s.empty();(a||e.options.showCursorWhenSelecting)&&Mr(e,s.head,i),a||Or(e,s,o)}}return n}function Mr(e,t,r){var i=sr(e,t,"div",null,null,!e.options.singleCursorHeightPerLine),o=r.appendChild(n("div"," ","CodeMirror-cursor"));if(o.style.left=i.left+"px",o.style.top=i.top+"px",o.style.height=Math.max(0,i.bottom-i.top)*e.options.cursorHeight+"px",i.other){var l=r.appendChild(n("div"," ","CodeMirror-cursor CodeMirror-secondarycursor"));l.style.display="",l.style.left=i.other.left+"px",l.style.top=i.other.top+"px",l.style.height=.85*(i.other.bottom-i.other.top)+"px"}}function Nr(e,t){return e.top-t.top||e.left-t.left}function Or(e,t,r){function i(e,t,r,i){t<0&&(t=0),t=Math.round(t),i=Math.round(i),a.appendChild(n("div",null,"CodeMirror-selected","position: absolute; left: "+e+"px;\n                             top: "+t+"px; width: "+(null==r?f-e:r)+"px;\n                             height: "+(i-t)+"px"))}function o(t,r,n){function o(r,n){return lr(e,E(t,r),"div",u,n)}var l,a,u=M(s,t),h=u.text.length,d=Se(u,s.direction);return xe(d,r||0,null==n?h:n,function(t,s,p,g){var v=o(t,"ltr"==p?"left":"right"),m=o(s-1,"ltr"==p?"right":"left");if("ltr"==p){var y=null==r&&0==t?c:v.left,b=null==n&&s==h?f:m.right;m.top-v.top<=3?i(y,m.top,b-y,m.bottom):(i(y,v.top,null,v.bottom),v.bottom<m.top&&i(c,v.bottom,null,m.top),i(c,m.top,m.right,m.bottom))}else if(t<s){var w=null==r&&0==t?f:v.right,x=null==n&&s==h?c:m.left;if(m.top-v.top<=3)i(x,m.top,w-x,m.bottom);else{var C=c;if(g){var S=hr(e,u,null,t).end;C=o(S-(/\s/.test(u.text.charAt(S-1))?2:1),"left").left}i(C,v.top,w-C,v.bottom),v.bottom<m.top&&i(c,v.bottom,null,m.top);var L=null;d.length,L=o(hr(e,u,null,s).begin,"right").right-x,i(x,m.top,L,m.bottom)}}(!l||Nr(v,l)<0)&&(l=v),Nr(m,l)<0&&(l=m),(!a||Nr(v,a)<0)&&(a=v),Nr(m,a)<0&&(a=m)}),{start:l,end:a}}var l=e.display,s=e.doc,a=document.createDocumentFragment(),u=It(e.display),c=u.left,f=Math.max(l.sizerWidth,Rt(e)-l.sizer.offsetLeft)-u.right,h=t.from(),d=t.to();if(h.line==d.line)o(h.line,h.ch,d.ch);else{var p=M(s,h.line),g=M(s,d.line),v=fe(p)==fe(g),m=o(h.line,h.ch,v?p.text.length+1:null).end,y=o(d.line,v?0:null,d.ch).start;v&&(m.top<y.top-2?(i(m.right,m.top,null,m.bottom),i(c,y.top,y.left,y.bottom)):i(m.right,m.top,y.left-m.right,m.bottom)),m.bottom<y.top&&i(c,m.bottom,null,y.top)}r.appendChild(a)}function Ar(e){if(e.state.focused){var t=e.display;clearInterval(t.blinker);var r=!0;t.cursorDiv.style.visibility="",e.options.cursorBlinkRate>0?t.blinker=setInterval(function(){return t.cursorDiv.style.visibility=(r=!r)?"":"hidden"},e.options.cursorBlinkRate):e.options.cursorBlinkRate<0&&(t.cursorDiv.style.visibility="hidden")}}function Wr(e){e.state.focused||(e.display.input.focus(),Hr(e))}function Dr(e){e.state.delayingBlurEvent=!0,setTimeout(function(){e.state.delayingBlurEvent&&(e.state.delayingBlurEvent=!1,Fr(e))},100)}function Hr(e,t){e.state.delayingBlurEvent&&(e.state.delayingBlurEvent=!1),"nocursor"!=e.options.readOnly&&(e.state.focused||(Te(e,"focus",e,t),e.state.focused=!0,s(e.display.wrapper,"CodeMirror-focused"),e.curOp||e.display.selForContextMenu==e.doc.sel||(e.display.input.reset(),ml&&setTimeout(function(){return e.display.input.reset(!0)},20)),e.display.input.receivedFocus()),Ar(e))}function Fr(e,t){e.state.delayingBlurEvent||(e.state.focused&&(Te(e,"blur",e,t),e.state.focused=!1,Fl(e.display.wrapper,"CodeMirror-focused")),clearInterval(e.display.blinker),setTimeout(function(){e.state.focused||(e.display.shift=!1)},150))}function Er(e){for(var t=e.display,r=t.lineDiv.offsetTop,n=0;n<t.view.length;n++){var i=t.view[n],o=void 0;if(!i.hidden){if(gl&&vl<8){var l=i.node.offsetTop+i.node.offsetHeight;o=l-r,r=l}else{var s=i.node.getBoundingClientRect();o=s.bottom-s.top}var a=i.line.height-o;if(o<2&&(o=mr(t)),(a>.005||a<-.005)&&(A(i.line,o),Pr(i.line),i.rest))for(var u=0;u<i.rest.length;u++)Pr(i.rest[u])}}}function Pr(e){if(e.widgets)for(var t=0;t<e.widgets.length;++t)e.widgets[t].height=e.widgets[t].node.parentNode.offsetHeight}function Ir(e,t,r){var n=r&&null!=r.top?Math.max(0,r.top):e.scroller.scrollTop;n=Math.floor(n-Et(e));var i=r&&null!=r.bottom?r.bottom:n+e.wrapper.clientHeight,o=D(t,n),l=D(t,i);if(r&&r.ensure){var s=r.ensure.from.line,a=r.ensure.to.line;s<o?(o=s,l=D(t,ye(M(t,s))+e.wrapper.clientHeight)):Math.min(a,t.lastLine())>=l&&(o=D(t,ye(M(t,a))-e.wrapper.clientHeight),l=a)}return{from:o,to:Math.max(l,o+1)}}function zr(e){var t=e.display,r=t.view;if(t.alignWidgets||t.gutters.firstChild&&e.options.fixedGutter){for(var n=wr(t)-t.scroller.scrollLeft+e.doc.scrollLeft,i=t.gutters.offsetWidth,o=n+"px",l=0;l<r.length;l++)if(!r[l].hidden){e.options.fixedGutter&&(r[l].gutter&&(r[l].gutter.style.left=o),r[l].gutterBackground&&(r[l].gutterBackground.style.left=o));var s=r[l].alignable;if(s)for(var a=0;a<s.length;a++)s[a].style.left=o}e.options.fixedGutter&&(t.gutters.style.left=n+i+"px")}}function Rr(e){if(!e.options.lineNumbers)return!1;var t=e.doc,r=F(e.options,t.first+t.size-1),i=e.display;if(r.length!=i.lineNumChars){var o=i.measure.appendChild(n("div",[n("div",r)],"CodeMirror-linenumber CodeMirror-gutter-elt")),l=o.firstChild.offsetWidth,s=o.offsetWidth-l;return i.lineGutter.style.width="",i.lineNumInnerWidth=Math.max(l,i.lineGutter.offsetWidth-s)+1,i.lineNumWidth=i.lineNumInnerWidth+s,i.lineNumChars=i.lineNumInnerWidth?r.length:-1,i.lineGutter.style.width=i.lineNumWidth+"px",Wn(e),!0}return!1}function Br(e,t){if(!Me(e,"scrollCursorIntoView")){var r=e.display,i=r.sizer.getBoundingClientRect(),o=null;if(t.top+i.top<0?o=!0:t.bottom+i.top>(window.innerHeight||document.documentElement.clientHeight)&&(o=!1),null!=o&&!Sl){var l=n("div","​",null,"position: absolute;\n                         top: "+(t.top-r.viewOffset-Et(e.display))+"px;\n                         height: "+(t.bottom-t.top+zt(e)+r.barHeight)+"px;\n                         left: "+t.left+"px; width: "+Math.max(2,t.right-t.left)+"px;");e.display.lineSpace.appendChild(l),l.scrollIntoView(o),e.display.lineSpace.removeChild(l)}}}function Gr(e,t,r,n){null==n&&(n=0);var i;e.options.lineWrapping||t!=r||(r="before"==(t=t.ch?E(t.line,"before"==t.sticky?t.ch-1:t.ch,"after"):t).sticky?E(t.line,t.ch+1,"before"):t);for(var o=0;o<5;o++){var l=!1,s=sr(e,t),a=r&&r!=t?sr(e,r):s,u=Vr(e,i={left:Math.min(s.left,a.left),top:Math.min(s.top,a.top)-n,right:Math.max(s.left,a.left),bottom:Math.max(s.bottom,a.bottom)+n}),c=e.doc.scrollTop,f=e.doc.scrollLeft;if(null!=u.scrollTop&&(qr(e,u.scrollTop),Math.abs(e.doc.scrollTop-c)>1&&(l=!0)),null!=u.scrollLeft&&(Qr(e,u.scrollLeft),Math.abs(e.doc.scrollLeft-f)>1&&(l=!0)),!l)break}return i}function Ur(e,t){var r=Vr(e,t);null!=r.scrollTop&&qr(e,r.scrollTop),null!=r.scrollLeft&&Qr(e,r.scrollLeft)}function Vr(e,t){var r=e.display,n=mr(e.display);t.top<0&&(t.top=0);var i=e.curOp&&null!=e.curOp.scrollTop?e.curOp.scrollTop:r.scroller.scrollTop,o=Bt(e),l={};t.bottom-t.top>o&&(t.bottom=t.top+o);var s=e.doc.height+Pt(r),a=t.top<n,u=t.bottom>s-n;if(t.top<i)l.scrollTop=a?0:t.top;else if(t.bottom>i+o){var c=Math.min(t.top,(u?s:t.bottom)-o);c!=i&&(l.scrollTop=c)}var f=e.curOp&&null!=e.curOp.scrollLeft?e.curOp.scrollLeft:r.scroller.scrollLeft,h=Rt(e)-(e.options.fixedGutter?r.gutters.offsetWidth:0),d=t.right-t.left>h;return d&&(t.right=t.left+h),t.left<10?l.scrollLeft=0:t.left<f?l.scrollLeft=Math.max(0,t.left-(d?0:10)):t.right>h+f-3&&(l.scrollLeft=t.right+(d?0:10)-h),l}function Kr(e,t){null!=t&&(_r(e),e.curOp.scrollTop=(null==e.curOp.scrollTop?e.doc.scrollTop:e.curOp.scrollTop)+t)}function jr(e){_r(e);var t=e.getCursor();e.curOp.scrollToPos={from:t,to:t,margin:e.options.cursorScrollMargin}}function Xr(e,t,r){null==t&&null==r||_r(e),null!=t&&(e.curOp.scrollLeft=t),null!=r&&(e.curOp.scrollTop=r)}function Yr(e,t){_r(e),e.curOp.scrollToPos=t}function _r(e){var t=e.curOp.scrollToPos;t&&(e.curOp.scrollToPos=null,$r(e,ar(e,t.from),ar(e,t.to),t.margin))}function $r(e,t,r,n){var i=Vr(e,{left:Math.min(t.left,r.left),top:Math.min(t.top,r.top)-n,right:Math.max(t.right,r.right),bottom:Math.max(t.bottom,r.bottom)+n});Xr(e,i.scrollLeft,i.scrollTop)}function qr(e,t){Math.abs(e.doc.scrollTop-t)<2||(fl||On(e,{top:t}),Zr(e,t,!0),fl&&On(e),Cn(e,100))}function Zr(e,t,r){t=Math.min(e.display.scroller.scrollHeight-e.display.scroller.clientHeight,t),(e.display.scroller.scrollTop!=t||r)&&(e.doc.scrollTop=t,e.display.scrollbars.setScrollTop(t),e.display.scroller.scrollTop!=t&&(e.display.scroller.scrollTop=t))}function Qr(e,t,r,n){t=Math.min(t,e.display.scroller.scrollWidth-e.display.scroller.clientWidth),(r?t==e.doc.scrollLeft:Math.abs(e.doc.scrollLeft-t)<2)&&!n||(e.doc.scrollLeft=t,zr(e),e.display.scroller.scrollLeft!=t&&(e.display.scroller.scrollLeft=t),e.display.scrollbars.setScrollLeft(t))}function Jr(e){var t=e.display,r=t.gutters.offsetWidth,n=Math.round(e.doc.height+Pt(e.display));return{clientHeight:t.scroller.clientHeight,viewHeight:t.wrapper.clientHeight,scrollWidth:t.scroller.scrollWidth,clientWidth:t.scroller.clientWidth,viewWidth:t.wrapper.clientWidth,barLeft:e.options.fixedGutter?r:0,docHeight:n,scrollHeight:n+zt(e)+t.barHeight,nativeBarWidth:t.nativeBarWidth,gutterWidth:r}}function en(e,t){t||(t=Jr(e));var r=e.display.barWidth,n=e.display.barHeight;tn(e,t);for(var i=0;i<4&&r!=e.display.barWidth||n!=e.display.barHeight;i++)r!=e.display.barWidth&&e.options.lineWrapping&&Er(e),tn(e,Jr(e)),r=e.display.barWidth,n=e.display.barHeight}function tn(e,t){var r=e.display,n=r.scrollbars.update(t);r.sizer.style.paddingRight=(r.barWidth=n.right)+"px",r.sizer.style.paddingBottom=(r.barHeight=n.bottom)+"px",r.heightForcer.style.borderBottom=n.bottom+"px solid transparent",n.right&&n.bottom?(r.scrollbarFiller.style.display="block",r.scrollbarFiller.style.height=n.bottom+"px",r.scrollbarFiller.style.width=n.right+"px"):r.scrollbarFiller.style.display="",n.bottom&&e.options.coverGutterNextToScrollbar&&e.options.fixedGutter?(r.gutterFiller.style.display="block",r.gutterFiller.style.height=n.bottom+"px",r.gutterFiller.style.width=t.gutterWidth+"px"):r.gutterFiller.style.display=""}function rn(e){e.display.scrollbars&&(e.display.scrollbars.clear(),e.display.scrollbars.addClass&&Fl(e.display.wrapper,e.display.scrollbars.addClass)),e.display.scrollbars=new ws[e.options.scrollbarStyle](function(t){e.display.wrapper.insertBefore(t,e.display.scrollbarFiller),Ql(t,"mousedown",function(){e.state.focused&&setTimeout(function(){return e.display.input.focus()},0)}),t.setAttribute("cm-not-content","true")},function(t,r){"horizontal"==r?Qr(e,t):qr(e,t)},e),e.display.scrollbars.addClass&&s(e.display.wrapper,e.display.scrollbars.addClass)}function nn(e){e.curOp={cm:e,viewChanged:!1,startHeight:e.doc.height,forceUpdate:!1,updateInput:null,typing:!1,changeObjs:null,cursorActivityHandlers:null,cursorActivityCalled:0,selectionChanged:!1,updateMaxLine:!1,scrollLeft:null,scrollTop:null,scrollToPos:null,focus:!1,id:++xs},vt(e.curOp)}function on(e){yt(e.curOp,function(e){for(var t=0;t<e.ops.length;t++)e.ops[t].cm.curOp=null;ln(e)})}function ln(e){for(var t=e.ops,r=0;r<t.length;r++)sn(t[r]);for(var n=0;n<t.length;n++)an(t[n]);for(var i=0;i<t.length;i++)un(t[i]);for(var o=0;o<t.length;o++)cn(t[o]);for(var l=0;l<t.length;l++)fn(t[l])}function sn(e){var t=e.cm,r=t.display;Ln(t),e.updateMaxLine&&we(t),e.mustUpdate=e.viewChanged||e.forceUpdate||null!=e.scrollTop||e.scrollToPos&&(e.scrollToPos.from.line<r.viewFrom||e.scrollToPos.to.line>=r.viewTo)||r.maxLineChanged&&t.options.lineWrapping,e.update=e.mustUpdate&&new Cs(t,e.mustUpdate&&{top:e.scrollTop,ensure:e.scrollToPos},e.forceUpdate)}function an(e){e.updatedDisplay=e.mustUpdate&&Mn(e.cm,e.update)}function un(e){var t=e.cm,r=t.display;e.updatedDisplay&&Er(t),e.barMeasure=Jr(t),r.maxLineChanged&&!t.options.lineWrapping&&(e.adjustWidthTo=Kt(t,r.maxLine,r.maxLine.text.length).left+3,t.display.sizerWidth=e.adjustWidthTo,e.barMeasure.scrollWidth=Math.max(r.scroller.clientWidth,r.sizer.offsetLeft+e.adjustWidthTo+zt(t)+t.display.barWidth),e.maxScrollLeft=Math.max(0,r.sizer.offsetLeft+e.adjustWidthTo-Rt(t))),(e.updatedDisplay||e.selectionChanged)&&(e.preparedSelection=r.input.prepareSelection())}function cn(e){var t=e.cm;null!=e.adjustWidthTo&&(t.display.sizer.style.minWidth=e.adjustWidthTo+"px",e.maxScrollLeft<t.doc.scrollLeft&&Qr(t,Math.min(t.display.scroller.scrollLeft,e.maxScrollLeft),!0),t.display.maxLineChanged=!1);var r=e.focus&&e.focus==l();e.preparedSelection&&t.display.input.showSelection(e.preparedSelection,r),(e.updatedDisplay||e.startHeight!=t.doc.height)&&en(t,e.barMeasure),e.updatedDisplay&&Dn(t,e.barMeasure),e.selectionChanged&&Ar(t),t.state.focused&&e.updateInput&&t.display.input.reset(e.typing),r&&Wr(e.cm)}function fn(e){var t=e.cm,r=t.display,n=t.doc;e.updatedDisplay&&Nn(t,e.update),null==r.wheelStartX||null==e.scrollTop&&null==e.scrollLeft&&!e.scrollToPos||(r.wheelStartX=r.wheelStartY=null),null!=e.scrollTop&&Zr(t,e.scrollTop,e.forceScroll),null!=e.scrollLeft&&Qr(t,e.scrollLeft,!0,!0),e.scrollToPos&&Br(t,Gr(t,U(n,e.scrollToPos.from),U(n,e.scrollToPos.to),e.scrollToPos.margin));var i=e.maybeHiddenMarkers,o=e.maybeUnhiddenMarkers;if(i)for(var l=0;l<i.length;++l)i[l].lines.length||Te(i[l],"hide");if(o)for(var s=0;s<o.length;++s)o[s].lines.length&&Te(o[s],"unhide");r.wrapper.offsetHeight&&(n.scrollTop=t.display.scroller.scrollTop),e.changeObjs&&Te(t,"changes",t,e.changeObjs),e.update&&e.update.finish()}function hn(e,t){if(e.curOp)return t();nn(e);try{return t()}finally{on(e)}}function dn(e,t){return function(){if(e.curOp)return t.apply(e,arguments);nn(e);try{return t.apply(e,arguments)}finally{on(e)}}}function pn(e){return function(){if(this.curOp)return e.apply(this,arguments);nn(this);try{return e.apply(this,arguments)}finally{on(this)}}}function gn(e){return function(){var t=this.cm;if(!t||t.curOp)return e.apply(this,arguments);nn(t);try{return e.apply(this,arguments)}finally{on(t)}}}function vn(e,t,r,n){null==t&&(t=e.doc.first),null==r&&(r=e.doc.first+e.doc.size),n||(n=0);var i=e.display;if(n&&r<i.viewTo&&(null==i.updateLineNumbers||i.updateLineNumbers>t)&&(i.updateLineNumbers=t),e.curOp.viewChanged=!0,t>=i.viewTo)_l&&pe(e.doc,t)<i.viewTo&&yn(e);else if(r<=i.viewFrom)_l&&ge(e.doc,r+n)>i.viewFrom?yn(e):(i.viewFrom+=n,i.viewTo+=n);else if(t<=i.viewFrom&&r>=i.viewTo)yn(e);else if(t<=i.viewFrom){var o=bn(e,r,r+n,1);o?(i.view=i.view.slice(o.index),i.viewFrom=o.lineN,i.viewTo+=n):yn(e)}else if(r>=i.viewTo){var l=bn(e,t,t,-1);l?(i.view=i.view.slice(0,l.index),i.viewTo=l.lineN):yn(e)}else{var s=bn(e,t,t,-1),a=bn(e,r,r+n,1);s&&a?(i.view=i.view.slice(0,s.index).concat(gt(e,s.lineN,a.lineN)).concat(i.view.slice(a.index)),i.viewTo+=n):yn(e)}var u=i.externalMeasured;u&&(r<u.lineN?u.lineN+=n:t<u.lineN+u.size&&(i.externalMeasured=null))}function mn(e,t,r){e.curOp.viewChanged=!0;var n=e.display,i=e.display.externalMeasured;if(i&&t>=i.lineN&&t<i.lineN+i.size&&(n.externalMeasured=null),!(t<n.viewFrom||t>=n.viewTo)){var o=n.view[Lr(e,t)];if(null!=o.node){var l=o.changes||(o.changes=[]);-1==h(l,r)&&l.push(r)}}}function yn(e){e.display.viewFrom=e.display.viewTo=e.doc.first,e.display.view=[],e.display.viewOffset=0}function bn(e,t,r,n){var i,o=Lr(e,t),l=e.display.view;if(!_l||r==e.doc.first+e.doc.size)return{index:o,lineN:r};for(var s=e.display.viewFrom,a=0;a<o;a++)s+=l[a].size;if(s!=t){if(n>0){if(o==l.length-1)return null;i=s+l[o].size-t,o++}else i=s-t;t+=i,r+=i}for(;pe(e.doc,r)!=r;){if(o==(n<0?0:l.length-1))return null;r+=n*l[o-(n<0?1:0)].size,o+=n}return{index:o,lineN:r}}function wn(e,t,r){var n=e.display;0==n.view.length||t>=n.viewTo||r<=n.viewFrom?(n.view=gt(e,t,r),n.viewFrom=t):(n.viewFrom>t?n.view=gt(e,t,n.viewFrom).concat(n.view):n.viewFrom<t&&(n.view=n.view.slice(Lr(e,t))),n.viewFrom=t,n.viewTo<r?n.view=n.view.concat(gt(e,n.viewTo,r)):n.viewTo>r&&(n.view=n.view.slice(0,Lr(e,r)))),n.viewTo=r}function xn(e){for(var t=e.display.view,r=0,n=0;n<t.length;n++){var i=t[n];i.hidden||i.node&&!i.changes||++r}return r}function Cn(e,t){e.doc.highlightFrontier<e.display.viewTo&&e.state.highlight.set(t,u(Sn,e))}function Sn(e){var t=e.doc;if(!(t.highlightFrontier>=e.display.viewTo)){var r=+new Date+e.options.workTime,n=$e(e,t.highlightFrontier),i=[];t.iter(n.line,Math.min(t.first+t.size,e.display.viewTo+500),function(o){if(n.line>=e.display.viewFrom){var l=o.styles,s=o.text.length>e.options.maxHighlightLength?Ke(t.mode,n.state):null,a=Ye(e,o,n,!0);s&&(n.state=s),o.styles=a.styles;var u=o.styleClasses,c=a.classes;c?o.styleClasses=c:u&&(o.styleClasses=null);for(var f=!l||l.length!=o.styles.length||u!=c&&(!u||!c||u.bgClass!=c.bgClass||u.textClass!=c.textClass),h=0;!f&&h<l.length;++h)f=l[h]!=o.styles[h];f&&i.push(n.line),o.stateAfter=n.save(),n.nextLine()}else o.text.length<=e.options.maxHighlightLength&&qe(e,o.text,n),o.stateAfter=n.line%5==0?n.save():null,n.nextLine();if(+new Date>r)return Cn(e,e.options.workDelay),!0}),t.highlightFrontier=n.line,t.modeFrontier=Math.max(t.modeFrontier,n.line),i.length&&hn(e,function(){for(var t=0;t<i.length;t++)mn(e,i[t],"text")})}}function Ln(e){var t=e.display;!t.scrollbarsClipped&&t.scroller.offsetWidth&&(t.nativeBarWidth=t.scroller.offsetWidth-t.scroller.clientWidth,t.heightForcer.style.height=zt(e)+"px",t.sizer.style.marginBottom=-t.nativeBarWidth+"px",t.sizer.style.borderRightWidth=zt(e)+"px",t.scrollbarsClipped=!0)}function kn(e){if(e.hasFocus())return null;var t=l();if(!t||!o(e.display.lineDiv,t))return null;var r={activeElt:t};if(window.getSelection){var n=window.getSelection();n.anchorNode&&n.extend&&o(e.display.lineDiv,n.anchorNode)&&(r.anchorNode=n.anchorNode,r.anchorOffset=n.anchorOffset,r.focusNode=n.focusNode,r.focusOffset=n.focusOffset)}return r}function Tn(e){if(e&&e.activeElt&&e.activeElt!=l()&&(e.activeElt.focus(),e.anchorNode&&o(document.body,e.anchorNode)&&o(document.body,e.focusNode))){var t=window.getSelection(),r=document.createRange();r.setEnd(e.anchorNode,e.anchorOffset),r.collapse(!1),t.removeAllRanges(),t.addRange(r),t.extend(e.focusNode,e.focusOffset)}}function Mn(e,r){var n=e.display,i=e.doc;if(r.editorIsHidden)return yn(e),!1;if(!r.force&&r.visible.from>=n.viewFrom&&r.visible.to<=n.viewTo&&(null==n.updateLineNumbers||n.updateLineNumbers>=n.viewTo)&&n.renderedView==n.view&&0==xn(e))return!1;Rr(e)&&(yn(e),r.dims=br(e));var o=i.first+i.size,l=Math.max(r.visible.from-e.options.viewportMargin,i.first),s=Math.min(o,r.visible.to+e.options.viewportMargin);n.viewFrom<l&&l-n.viewFrom<20&&(l=Math.max(i.first,n.viewFrom)),n.viewTo>s&&n.viewTo-s<20&&(s=Math.min(o,n.viewTo)),_l&&(l=pe(e.doc,l),s=ge(e.doc,s));var a=l!=n.viewFrom||s!=n.viewTo||n.lastWrapHeight!=r.wrapperHeight||n.lastWrapWidth!=r.wrapperWidth;wn(e,l,s),n.viewOffset=ye(M(e.doc,n.viewFrom)),e.display.mover.style.top=n.viewOffset+"px";var u=xn(e);if(!a&&0==u&&!r.force&&n.renderedView==n.view&&(null==n.updateLineNumbers||n.updateLineNumbers>=n.viewTo))return!1;var c=kn(e);return u>4&&(n.lineDiv.style.display="none"),An(e,n.updateLineNumbers,r.dims),u>4&&(n.lineDiv.style.display=""),n.renderedView=n.view,Tn(c),t(n.cursorDiv),t(n.selectionDiv),n.gutters.style.height=n.sizer.style.minHeight=0,a&&(n.lastWrapHeight=r.wrapperHeight,n.lastWrapWidth=r.wrapperWidth,Cn(e,400)),n.updateLineNumbers=null,!0}function Nn(e,t){for(var r=t.viewport,n=!0;(n&&e.options.lineWrapping&&t.oldDisplayWidth!=Rt(e)||(r&&null!=r.top&&(r={top:Math.min(e.doc.height+Pt(e.display)-Bt(e),r.top)}),t.visible=Ir(e.display,e.doc,r),!(t.visible.from>=e.display.viewFrom&&t.visible.to<=e.display.viewTo)))&&Mn(e,t);n=!1){Er(e);var i=Jr(e);kr(e),en(e,i),Dn(e,i),t.force=!1}t.signal(e,"update",e),e.display.viewFrom==e.display.reportedViewFrom&&e.display.viewTo==e.display.reportedViewTo||(t.signal(e,"viewportChange",e,e.display.viewFrom,e.display.viewTo),e.display.reportedViewFrom=e.display.viewFrom,e.display.reportedViewTo=e.display.viewTo)}function On(e,t){var r=new Cs(e,t);if(Mn(e,r)){Er(e),Nn(e,r);var n=Jr(e);kr(e),en(e,n),Dn(e,n),r.finish()}}function An(e,r,n){function i(t){var r=t.nextSibling;return ml&&Ml&&e.display.currentWheelTarget==t?t.style.display="none":t.parentNode.removeChild(t),r}for(var o=e.display,l=e.options.lineNumbers,s=o.lineDiv,a=s.firstChild,u=o.view,c=o.viewFrom,f=0;f<u.length;f++){var d=u[f];if(d.hidden);else if(d.node&&d.node.parentNode==s){for(;a!=d.node;)a=i(a);var p=l&&null!=r&&r<=c&&d.lineNumber;d.changes&&(h(d.changes,"gutter")>-1&&(p=!1),xt(e,d,c,n)),p&&(t(d.lineNumber),d.lineNumber.appendChild(document.createTextNode(F(e.options,c)))),a=d.node.nextSibling}else{var g=Ot(e,d,c,n);s.insertBefore(g,a)}c+=d.size}for(;a;)a=i(a)}function Wn(e){var t=e.display.gutters.offsetWidth;e.display.sizer.style.marginLeft=t+"px"}function Dn(e,t){e.display.sizer.style.minHeight=t.docHeight+"px",e.display.heightForcer.style.top=t.docHeight+"px",e.display.gutters.style.height=t.docHeight+e.display.barHeight+zt(e)+"px"}function Hn(e){var r=e.display.gutters,i=e.options.gutters;t(r);for(var o=0;o<i.length;++o){var l=i[o],s=r.appendChild(n("div",null,"CodeMirror-gutter "+l));"CodeMirror-linenumbers"==l&&(e.display.lineGutter=s,s.style.width=(e.display.lineNumWidth||1)+"px")}r.style.display=o?"":"none",Wn(e)}function Fn(e){var t=h(e.gutters,"CodeMirror-linenumbers");-1==t&&e.lineNumbers?e.gutters=e.gutters.concat(["CodeMirror-linenumbers"]):t>-1&&!e.lineNumbers&&(e.gutters=e.gutters.slice(0),e.gutters.splice(t,1))}function En(e){var t=e.wheelDeltaX,r=e.wheelDeltaY;return null==t&&e.detail&&e.axis==e.HORIZONTAL_AXIS&&(t=e.detail),null==r&&e.detail&&e.axis==e.VERTICAL_AXIS?r=e.detail:null==r&&(r=e.wheelDelta),{x:t,y:r}}function Pn(e){var t=En(e);return t.x*=Ls,t.y*=Ls,t}function In(e,t){var r=En(t),n=r.x,i=r.y,o=e.display,l=o.scroller,s=l.scrollWidth>l.clientWidth,a=l.scrollHeight>l.clientHeight;if(n&&s||i&&a){if(i&&Ml&&ml)e:for(var u=t.target,c=o.view;u!=l;u=u.parentNode)for(var f=0;f<c.length;f++)if(c[f].node==u){e.display.currentWheelTarget=u;break e}if(n&&!fl&&!wl&&null!=Ls)return i&&a&&qr(e,Math.max(0,l.scrollTop+i*Ls)),Qr(e,Math.max(0,l.scrollLeft+n*Ls)),(!i||i&&a)&&We(t),void(o.wheelStartX=null);if(i&&null!=Ls){var h=i*Ls,d=e.doc.scrollTop,p=d+o.wrapper.clientHeight;h<0?d=Math.max(0,d+h-50):p=Math.min(e.doc.height,p+h+50),On(e,{top:d,bottom:p})}Ss<20&&(null==o.wheelStartX?(o.wheelStartX=l.scrollLeft,o.wheelStartY=l.scrollTop,o.wheelDX=n,o.wheelDY=i,setTimeout(function(){if(null!=o.wheelStartX){var e=l.scrollLeft-o.wheelStartX,t=l.scrollTop-o.wheelStartY,r=t&&o.wheelDY&&t/o.wheelDY||e&&o.wheelDX&&e/o.wheelDX;o.wheelStartX=o.wheelStartY=null,r&&(Ls=(Ls*Ss+r)/(Ss+1),++Ss)}},200)):(o.wheelDX+=n,o.wheelDY+=i))}}function zn(e,t){var r=e[t];e.sort(function(e,t){return P(e.from(),t.from())}),t=h(e,r);for(var n=1;n<e.length;n++){var i=e[n],o=e[n-1];if(P(o.to(),i.from())>=0){var l=B(o.from(),i.from()),s=R(o.to(),i.to()),a=o.empty()?i.from()==i.head:o.from()==o.head;n<=t&&--t,e.splice(--n,2,new Ts(a?s:l,a?l:s))}}return new ks(e,t)}function Rn(e,t){return new ks([new Ts(e,t||e)],0)}function Bn(e){return e.text?E(e.from.line+e.text.length-1,g(e.text).length+(1==e.text.length?e.from.ch:0)):e.to}function Gn(e,t){if(P(e,t.from)<0)return e;if(P(e,t.to)<=0)return Bn(t);var r=e.line+t.text.length-(t.to.line-t.from.line)-1,n=e.ch;return e.line==t.to.line&&(n+=Bn(t).ch-t.to.ch),E(r,n)}function Un(e,t){for(var r=[],n=0;n<e.sel.ranges.length;n++){var i=e.sel.ranges[n];r.push(new Ts(Gn(i.anchor,t),Gn(i.head,t)))}return zn(r,e.sel.primIndex)}function Vn(e,t,r){return e.line==t.line?E(r.line,e.ch-t.ch+r.ch):E(r.line+(e.line-t.line),e.ch)}function Kn(e,t,r){for(var n=[],i=E(e.first,0),o=i,l=0;l<t.length;l++){var s=t[l],a=Vn(s.from,i,o),u=Vn(Bn(s),i,o);if(i=s.to,o=u,"around"==r){var c=e.sel.ranges[l],f=P(c.head,c.anchor)<0;n[l]=new Ts(f?u:a,f?a:u)}else n[l]=new Ts(a,a)}return new ks(n,e.sel.primIndex)}function jn(e){e.doc.mode=Ue(e.options,e.doc.modeOption),Xn(e)}function Xn(e){e.doc.iter(function(e){e.stateAfter&&(e.stateAfter=null),e.styles&&(e.styles=null)}),e.doc.modeFrontier=e.doc.highlightFrontier=e.doc.first,Cn(e,100),e.state.modeGen++,e.curOp&&vn(e)}function Yn(e,t){return 0==t.from.ch&&0==t.to.ch&&""==g(t.text)&&(!e.cm||e.cm.options.wholeLineUpdateBefore)}function _n(e,t,r,n){function i(e){return r?r[e]:null}function o(e,r,i){it(e,r,i,n),bt(e,"change",e,t)}function l(e,t){for(var r=[],o=e;o<t;++o)r.push(new fs(u[o],i(o),n));return r}var s=t.from,a=t.to,u=t.text,c=M(e,s.line),f=M(e,a.line),h=g(u),d=i(u.length-1),p=a.line-s.line;if(t.full)e.insert(0,l(0,u.length)),e.remove(u.length,e.size-u.length);else if(Yn(e,t)){var v=l(0,u.length-1);o(f,f.text,d),p&&e.remove(s.line,p),v.length&&e.insert(s.line,v)}else if(c==f)if(1==u.length)o(c,c.text.slice(0,s.ch)+h+c.text.slice(a.ch),d);else{var m=l(1,u.length-1);m.push(new fs(h+c.text.slice(a.ch),d,n)),o(c,c.text.slice(0,s.ch)+u[0],i(0)),e.insert(s.line+1,m)}else if(1==u.length)o(c,c.text.slice(0,s.ch)+u[0]+f.text.slice(a.ch),i(0)),e.remove(s.line+1,p);else{o(c,c.text.slice(0,s.ch)+u[0],i(0)),o(f,h+f.text.slice(a.ch),d);var y=l(1,u.length-1);p>1&&e.remove(s.line+1,p-1),e.insert(s.line+1,y)}bt(e,"change",e,t)}function $n(e,t,r){function n(e,i,o){if(e.linked)for(var l=0;l<e.linked.length;++l){var s=e.linked[l];if(s.doc!=i){var a=o&&s.sharedHist;r&&!a||(t(s.doc,a),n(s.doc,e,a))}}}n(e,null,!0)}function qn(e,t){if(t.cm)throw new Error("This document is already in use.");e.doc=t,t.cm=e,Cr(e),jn(e),Zn(e),e.options.lineWrapping||we(e),e.options.mode=t.modeOption,vn(e)}function Zn(e){("rtl"==e.doc.direction?s:Fl)(e.display.lineDiv,"CodeMirror-rtl")}function Qn(e){hn(e,function(){Zn(e),vn(e)})}function Jn(e){this.done=[],this.undone=[],this.undoDepth=1/0,this.lastModTime=this.lastSelTime=0,this.lastOp=this.lastSelOp=null,this.lastOrigin=this.lastSelOrigin=null,this.generation=this.maxGeneration=e||1}function ei(e,t){var r={from:z(t.from),to:Bn(t),text:N(e,t.from,t.to)};return si(e,r,t.from.line,t.to.line+1),$n(e,function(e){return si(e,r,t.from.line,t.to.line+1)},!0),r}function ti(e){for(;e.length&&g(e).ranges;)e.pop()}function ri(e,t){return t?(ti(e.done),g(e.done)):e.done.length&&!g(e.done).ranges?g(e.done):e.done.length>1&&!e.done[e.done.length-2].ranges?(e.done.pop(),g(e.done)):void 0}function ni(e,t,r,n){var i=e.history;i.undone.length=0;var o,l,s=+new Date;if((i.lastOp==n||i.lastOrigin==t.origin&&t.origin&&("+"==t.origin.charAt(0)&&e.cm&&i.lastModTime>s-e.cm.options.historyEventDelay||"*"==t.origin.charAt(0)))&&(o=ri(i,i.lastOp==n)))l=g(o.changes),0==P(t.from,t.to)&&0==P(t.from,l.to)?l.to=Bn(t):o.changes.push(ei(e,t));else{var a=g(i.done);for(a&&a.ranges||li(e.sel,i.done),o={changes:[ei(e,t)],generation:i.generation},i.done.push(o);i.done.length>i.undoDepth;)i.done.shift(),i.done[0].ranges||i.done.shift()}i.done.push(r),i.generation=++i.maxGeneration,i.lastModTime=i.lastSelTime=s,i.lastOp=i.lastSelOp=n,i.lastOrigin=i.lastSelOrigin=t.origin,l||Te(e,"historyAdded")}function ii(e,t,r,n){var i=t.charAt(0);return"*"==i||"+"==i&&r.ranges.length==n.ranges.length&&r.somethingSelected()==n.somethingSelected()&&new Date-e.history.lastSelTime<=(e.cm?e.cm.options.historyEventDelay:500)}function oi(e,t,r,n){var i=e.history,o=n&&n.origin;r==i.lastSelOp||o&&i.lastSelOrigin==o&&(i.lastModTime==i.lastSelTime&&i.lastOrigin==o||ii(e,o,g(i.done),t))?i.done[i.done.length-1]=t:li(t,i.done),i.lastSelTime=+new Date,i.lastSelOrigin=o,i.lastSelOp=r,n&&!1!==n.clearRedo&&ti(i.undone)}function li(e,t){var r=g(t);r&&r.ranges&&r.equals(e)||t.push(e)}function si(e,t,r,n){var i=t["spans_"+e.id],o=0;e.iter(Math.max(e.first,r),Math.min(e.first+e.size,n),function(r){r.markedSpans&&((i||(i=t["spans_"+e.id]={}))[o]=r.markedSpans),++o})}function ai(e){if(!e)return null;for(var t,r=0;r<e.length;++r)e[r].marker.explicitlyCleared?t||(t=e.slice(0,r)):t&&t.push(e[r]);return t?t.length?t:null:e}function ui(e,t){var r=t["spans_"+e.id];if(!r)return null;for(var n=[],i=0;i<t.text.length;++i)n.push(ai(r[i]));return n}function ci(e,t){var r=ui(e,t),n=J(e,t);if(!r)return n;if(!n)return r;for(var i=0;i<r.length;++i){var o=r[i],l=n[i];if(o&&l)e:for(var s=0;s<l.length;++s){for(var a=l[s],u=0;u<o.length;++u)if(o[u].marker==a.marker)continue e;o.push(a)}else l&&(r[i]=l)}return r}function fi(e,t,r){for(var n=[],i=0;i<e.length;++i){var o=e[i];if(o.ranges)n.push(r?ks.prototype.deepCopy.call(o):o);else{var l=o.changes,s=[];n.push({changes:s});for(var a=0;a<l.length;++a){var u=l[a],c=void 0;if(s.push({from:u.from,to:u.to,text:u.text}),t)for(var f in u)(c=f.match(/^spans_(\d+)$/))&&h(t,Number(c[1]))>-1&&(g(s)[f]=u[f],delete u[f])}}}return n}function hi(e,t,r,n){if(n){var i=e.anchor;if(r){var o=P(t,i)<0;o!=P(r,i)<0?(i=t,t=r):o!=P(t,r)<0&&(t=r)}return new Ts(i,t)}return new Ts(r||t,t)}function di(e,t,r,n,i){null==i&&(i=e.cm&&(e.cm.display.shift||e.extend)),bi(e,new ks([hi(e.sel.primary(),t,r,i)],0),n)}function pi(e,t,r){for(var n=[],i=e.cm&&(e.cm.display.shift||e.extend),o=0;o<e.sel.ranges.length;o++)n[o]=hi(e.sel.ranges[o],t[o],null,i);bi(e,zn(n,e.sel.primIndex),r)}function gi(e,t,r,n){var i=e.sel.ranges.slice(0);i[t]=r,bi(e,zn(i,e.sel.primIndex),n)}function vi(e,t,r,n){bi(e,Rn(t,r),n)}function mi(e,t,r){var n={ranges:t.ranges,update:function(t){var r=this;this.ranges=[];for(var n=0;n<t.length;n++)r.ranges[n]=new Ts(U(e,t[n].anchor),U(e,t[n].head))},origin:r&&r.origin};return Te(e,"beforeSelectionChange",e,n),e.cm&&Te(e.cm,"beforeSelectionChange",e.cm,n),n.ranges!=t.ranges?zn(n.ranges,n.ranges.length-1):t}function yi(e,t,r){var n=e.history.done,i=g(n);i&&i.ranges?(n[n.length-1]=t,wi(e,t,r)):bi(e,t,r)}function bi(e,t,r){wi(e,t,r),oi(e,e.sel,e.cm?e.cm.curOp.id:NaN,r)}function wi(e,t,r){(Oe(e,"beforeSelectionChange")||e.cm&&Oe(e.cm,"beforeSelectionChange"))&&(t=mi(e,t,r)),xi(e,Si(e,t,r&&r.bias||(P(t.primary().head,e.sel.primary().head)<0?-1:1),!0)),r&&!1===r.scroll||!e.cm||jr(e.cm)}function xi(e,t){t.equals(e.sel)||(e.sel=t,e.cm&&(e.cm.curOp.updateInput=e.cm.curOp.selectionChanged=!0,Ne(e.cm)),bt(e,"cursorActivity",e))}function Ci(e){xi(e,Si(e,e.sel,null,!1))}function Si(e,t,r,n){for(var i,o=0;o<t.ranges.length;o++){var l=t.ranges[o],s=t.ranges.length==e.sel.ranges.length&&e.sel.ranges[o],a=ki(e,l.anchor,s&&s.anchor,r,n),u=ki(e,l.head,s&&s.head,r,n);(i||a!=l.anchor||u!=l.head)&&(i||(i=t.ranges.slice(0,o)),i[o]=new Ts(a,u))}return i?zn(i,t.primIndex):t}function Li(e,t,r,n,i){var o=M(e,t.line);if(o.markedSpans)for(var l=0;l<o.markedSpans.length;++l){var s=o.markedSpans[l],a=s.marker;if((null==s.from||(a.inclusiveLeft?s.from<=t.ch:s.from<t.ch))&&(null==s.to||(a.inclusiveRight?s.to>=t.ch:s.to>t.ch))){if(i&&(Te(a,"beforeCursorEnter"),a.explicitlyCleared)){if(o.markedSpans){--l;continue}break}if(!a.atomic)continue;if(r){var u=a.find(n<0?1:-1),c=void 0;if((n<0?a.inclusiveRight:a.inclusiveLeft)&&(u=Ti(e,u,-n,u&&u.line==t.line?o:null)),u&&u.line==t.line&&(c=P(u,r))&&(n<0?c<0:c>0))return Li(e,u,t,n,i)}var f=a.find(n<0?-1:1);return(n<0?a.inclusiveLeft:a.inclusiveRight)&&(f=Ti(e,f,n,f.line==t.line?o:null)),f?Li(e,f,t,n,i):null}}return t}function ki(e,t,r,n,i){var o=n||1,l=Li(e,t,r,o,i)||!i&&Li(e,t,r,o,!0)||Li(e,t,r,-o,i)||!i&&Li(e,t,r,-o,!0);return l||(e.cantEdit=!0,E(e.first,0))}function Ti(e,t,r,n){return r<0&&0==t.ch?t.line>e.first?U(e,E(t.line-1)):null:r>0&&t.ch==(n||M(e,t.line)).text.length?t.line<e.first+e.size-1?E(t.line+1,0):null:new E(t.line,t.ch+r)}function Mi(e){e.setSelection(E(e.firstLine(),0),E(e.lastLine()),Gl)}function Ni(e,t,r){var n={canceled:!1,from:t.from,to:t.to,text:t.text,origin:t.origin,cancel:function(){return n.canceled=!0}};return r&&(n.update=function(t,r,i,o){t&&(n.from=U(e,t)),r&&(n.to=U(e,r)),i&&(n.text=i),void 0!==o&&(n.origin=o)}),Te(e,"beforeChange",e,n),e.cm&&Te(e.cm,"beforeChange",e.cm,n),n.canceled?null:{from:n.from,to:n.to,text:n.text,origin:n.origin}}function Oi(e,t,r){if(e.cm){if(!e.cm.curOp)return dn(e.cm,Oi)(e,t,r);if(e.cm.state.suppressEdits)return}if(!(Oe(e,"beforeChange")||e.cm&&Oe(e.cm,"beforeChange"))||(t=Ni(e,t,!0))){var n=Yl&&!r&&te(e,t.from,t.to);if(n)for(var i=n.length-1;i>=0;--i)Ai(e,{from:n[i].from,to:n[i].to,text:i?[""]:t.text,origin:t.origin});else Ai(e,t)}}function Ai(e,t){if(1!=t.text.length||""!=t.text[0]||0!=P(t.from,t.to)){var r=Un(e,t);ni(e,t,r,e.cm?e.cm.curOp.id:NaN),Hi(e,t,r,J(e,t));var n=[];$n(e,function(e,r){r||-1!=h(n,e.history)||(zi(e.history,t),n.push(e.history)),Hi(e,t,null,J(e,t))})}}function Wi(e,t,r){if(!e.cm||!e.cm.state.suppressEdits||r){for(var n,i=e.history,o=e.sel,l="undo"==t?i.done:i.undone,s="undo"==t?i.undone:i.done,a=0;a<l.length&&(n=l[a],r?!n.ranges||n.equals(e.sel):n.ranges);a++);if(a!=l.length){for(i.lastOrigin=i.lastSelOrigin=null;(n=l.pop()).ranges;){if(li(n,s),r&&!n.equals(e.sel))return void bi(e,n,{clearRedo:!1});o=n}var u=[];li(o,s),s.push({changes:u,generation:i.generation}),i.generation=n.generation||++i.maxGeneration;for(var c=Oe(e,"beforeChange")||e.cm&&Oe(e.cm,"beforeChange"),f=n.changes.length-1;f>=0;--f){var d=function(r){var i=n.changes[r];if(i.origin=t,c&&!Ni(e,i,!1))return l.length=0,{};u.push(ei(e,i));var o=r?Un(e,i):g(l);Hi(e,i,o,ci(e,i)),!r&&e.cm&&e.cm.scrollIntoView({from:i.from,to:Bn(i)});var s=[];$n(e,function(e,t){t||-1!=h(s,e.history)||(zi(e.history,i),s.push(e.history)),Hi(e,i,null,ci(e,i))})}(f);if(d)return d.v}}}}function Di(e,t){if(0!=t&&(e.first+=t,e.sel=new ks(v(e.sel.ranges,function(e){return new Ts(E(e.anchor.line+t,e.anchor.ch),E(e.head.line+t,e.head.ch))}),e.sel.primIndex),e.cm)){vn(e.cm,e.first,e.first-t,t);for(var r=e.cm.display,n=r.viewFrom;n<r.viewTo;n++)mn(e.cm,n,"gutter")}}function Hi(e,t,r,n){if(e.cm&&!e.cm.curOp)return dn(e.cm,Hi)(e,t,r,n);if(t.to.line<e.first)Di(e,t.text.length-1-(t.to.line-t.from.line));else if(!(t.from.line>e.lastLine())){if(t.from.line<e.first){var i=t.text.length-1-(e.first-t.from.line);Di(e,i),t={from:E(e.first,0),to:E(t.to.line+i,t.to.ch),text:[g(t.text)],origin:t.origin}}var o=e.lastLine();t.to.line>o&&(t={from:t.from,to:E(o,M(e,o).text.length),text:[t.text[0]],origin:t.origin}),t.removed=N(e,t.from,t.to),r||(r=Un(e,t)),e.cm?Fi(e.cm,t,n):_n(e,t,n),wi(e,r,Gl)}}function Fi(e,t,r){var n=e.doc,i=e.display,o=t.from,l=t.to,s=!1,a=o.line;e.options.lineWrapping||(a=W(fe(M(n,o.line))),n.iter(a,l.line+1,function(e){if(e==i.maxLine)return s=!0,!0})),n.sel.contains(t.from,t.to)>-1&&Ne(e),_n(n,t,r,xr(e)),e.options.lineWrapping||(n.iter(a,o.line+t.text.length,function(e){var t=be(e);t>i.maxLineLength&&(i.maxLine=e,i.maxLineLength=t,i.maxLineChanged=!0,s=!1)}),s&&(e.curOp.updateMaxLine=!0)),nt(n,o.line),Cn(e,400);var u=t.text.length-(l.line-o.line)-1;t.full?vn(e):o.line!=l.line||1!=t.text.length||Yn(e.doc,t)?vn(e,o.line,l.line+1,u):mn(e,o.line,"text");var c=Oe(e,"changes"),f=Oe(e,"change");if(f||c){var h={from:o,to:l,text:t.text,removed:t.removed,origin:t.origin};f&&bt(e,"change",e,h),c&&(e.curOp.changeObjs||(e.curOp.changeObjs=[])).push(h)}e.display.selForContextMenu=null}function Ei(e,t,r,n,i){if(n||(n=r),P(n,r)<0){var o;r=(o=[n,r])[0],n=o[1]}"string"==typeof t&&(t=e.splitLines(t)),Oi(e,{from:r,to:n,text:t,origin:i})}function Pi(e,t,r,n){r<e.line?e.line+=n:t<e.line&&(e.line=t,e.ch=0)}function Ii(e,t,r,n){for(var i=0;i<e.length;++i){var o=e[i],l=!0;if(o.ranges){o.copied||((o=e[i]=o.deepCopy()).copied=!0);for(var s=0;s<o.ranges.length;s++)Pi(o.ranges[s].anchor,t,r,n),Pi(o.ranges[s].head,t,r,n)}else{for(var a=0;a<o.changes.length;++a){var u=o.changes[a];if(r<u.from.line)u.from=E(u.from.line+n,u.from.ch),u.to=E(u.to.line+n,u.to.ch);else if(t<=u.to.line){l=!1;break}}l||(e.splice(0,i+1),i=0)}}}function zi(e,t){var r=t.from.line,n=t.to.line,i=t.text.length-(n-r)-1;Ii(e.done,r,n,i),Ii(e.undone,r,n,i)}function Ri(e,t,r,n){var i=t,o=t;return"number"==typeof t?o=M(e,G(e,t)):i=W(t),null==i?null:(n(o,i)&&e.cm&&mn(e.cm,i,r),o)}function Bi(e){var t=this;this.lines=e,this.parent=null;for(var r=0,n=0;n<e.length;++n)e[n].parent=t,r+=e[n].height;this.height=r}function Gi(e){var t=this;this.children=e;for(var r=0,n=0,i=0;i<e.length;++i){var o=e[i];r+=o.chunkSize(),n+=o.height,o.parent=t}this.size=r,this.height=n,this.parent=null}function Ui(e,t,r){ye(t)<(e.curOp&&e.curOp.scrollTop||e.doc.scrollTop)&&Kr(e,r)}function Vi(e,t,r,n){var i=new Ms(e,r,n),o=e.cm;return o&&i.noHScroll&&(o.display.alignWidgets=!0),Ri(e,t,"widget",function(t){var r=t.widgets||(t.widgets=[]);if(null==i.insertAt?r.push(i):r.splice(Math.min(r.length-1,Math.max(0,i.insertAt)),0,i),i.line=t,o&&!ve(e,t)){var n=ye(t)<e.scrollTop;A(t,t.height+Ht(i)),n&&Kr(o,i.height),o.curOp.forceUpdate=!0}return!0}),bt(o,"lineWidgetAdded",o,i,"number"==typeof t?t:W(t)),i}function Ki(e,t,r,n,o){if(n&&n.shared)return ji(e,t,r,n,o);if(e.cm&&!e.cm.curOp)return dn(e.cm,Ki)(e,t,r,n,o);var l=new Os(e,o),s=P(t,r);if(n&&c(n,l,!1),s>0||0==s&&!1!==l.clearWhenEmpty)return l;if(l.replacedWith&&(l.collapsed=!0,l.widgetNode=i("span",[l.replacedWith],"CodeMirror-widget"),n.handleMouseEvents||l.widgetNode.setAttribute("cm-ignore-events","true"),n.insertLeft&&(l.widgetNode.insertLeft=!0)),l.collapsed){if(ce(e,t.line,t,r,l)||t.line!=r.line&&ce(e,r.line,t,r,l))throw new Error("Inserting collapsed marker partially overlapping an existing one");X()}l.addToHistory&&ni(e,{from:t,to:r,origin:"markText"},e.sel,NaN);var a,u=t.line,f=e.cm;if(e.iter(u,r.line+1,function(e){f&&l.collapsed&&!f.options.lineWrapping&&fe(e)==f.display.maxLine&&(a=!0),l.collapsed&&u!=t.line&&A(e,0),q(e,new Y(l,u==t.line?t.ch:null,u==r.line?r.ch:null)),++u}),l.collapsed&&e.iter(t.line,r.line+1,function(t){ve(e,t)&&A(t,0)}),l.clearOnEnter&&Ql(l,"beforeCursorEnter",function(){return l.clear()}),l.readOnly&&(j(),(e.history.done.length||e.history.undone.length)&&e.clearHistory()),l.collapsed&&(l.id=++Ns,l.atomic=!0),f){if(a&&(f.curOp.updateMaxLine=!0),l.collapsed)vn(f,t.line,r.line+1);else if(l.className||l.title||l.startStyle||l.endStyle||l.css)for(var h=t.line;h<=r.line;h++)mn(f,h,"text");l.atomic&&Ci(f.doc),bt(f,"markerAdded",f,l)}return l}function ji(e,t,r,n,i){(n=c(n)).shared=!1;var o=[Ki(e,t,r,n,i)],l=o[0],s=n.widgetNode;return $n(e,function(e){s&&(n.widgetNode=s.cloneNode(!0)),o.push(Ki(e,U(e,t),U(e,r),n,i));for(var a=0;a<e.linked.length;++a)if(e.linked[a].isParent)return;l=g(o)}),new As(o,l)}function Xi(e){return e.findMarks(E(e.first,0),e.clipPos(E(e.lastLine())),function(e){return e.parent})}function Yi(e,t){for(var r=0;r<t.length;r++){var n=t[r],i=n.find(),o=e.clipPos(i.from),l=e.clipPos(i.to);if(P(o,l)){var s=Ki(e,o,l,n.primary,n.primary.type);n.markers.push(s),s.parent=n}}}function _i(e){for(var t=0;t<e.length;t++)!function(t){var r=e[t],n=[r.primary.doc];$n(r.primary.doc,function(e){return n.push(e)});for(var i=0;i<r.markers.length;i++){var o=r.markers[i];-1==h(n,o.doc)&&(o.parent=null,r.markers.splice(i--,1))}}(t)}function $i(e){var t=this;if(Qi(t),!Me(t,e)&&!Ft(t.display,e)){We(e),gl&&(Hs=+new Date);var r=Sr(t,e,!0),n=e.dataTransfer.files;if(r&&!t.isReadOnly())if(n&&n.length&&window.FileReader&&window.File)for(var i=n.length,o=Array(i),l=0,s=0;s<i;++s)!function(e,n){if(!t.options.allowDropFileTypes||-1!=h(t.options.allowDropFileTypes,e.type)){var s=new FileReader;s.onload=dn(t,function(){var e=s.result;if(/[\x00-\x08\x0e-\x1f]{2}/.test(e)&&(e=""),o[n]=e,++l==i){var a={from:r=U(t.doc,r),to:r,text:t.doc.splitLines(o.join(t.doc.lineSeparator())),origin:"paste"};Oi(t.doc,a),yi(t.doc,Rn(r,Bn(a)))}}),s.readAsText(e)}}(n[s],s);else{if(t.state.draggingText&&t.doc.sel.contains(r)>-1)return t.state.draggingText(e),void setTimeout(function(){return t.display.input.focus()},20);try{var a=e.dataTransfer.getData("Text");if(a){var u;if(t.state.draggingText&&!t.state.draggingText.copy&&(u=t.listSelections()),wi(t.doc,Rn(r,r)),u)for(var c=0;c<u.length;++c)Ei(t.doc,"",u[c].anchor,u[c].head,"drag");t.replaceSelection(a,"around","paste"),t.display.input.focus()}}catch(e){}}}}function qi(e,t){if(gl&&(!e.state.draggingText||+new Date-Hs<100))Fe(t);else if(!Me(e,t)&&!Ft(e.display,t)&&(t.dataTransfer.setData("Text",e.getSelection()),t.dataTransfer.effectAllowed="copyMove",t.dataTransfer.setDragImage&&!xl)){var r=n("img",null,null,"position: fixed; left: 0; top: 0;");r.src="data:image/gif;base64,R0lGODlhAQABAAAAACH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==",wl&&(r.width=r.height=1,e.display.wrapper.appendChild(r),r._top=r.offsetTop),t.dataTransfer.setDragImage(r,0,0),wl&&r.parentNode.removeChild(r)}}function Zi(e,t){var i=Sr(e,t);if(i){var o=document.createDocumentFragment();Mr(e,i,o),e.display.dragCursor||(e.display.dragCursor=n("div",null,"CodeMirror-cursors CodeMirror-dragcursors"),e.display.lineSpace.insertBefore(e.display.dragCursor,e.display.cursorDiv)),r(e.display.dragCursor,o)}}function Qi(e){e.display.dragCursor&&(e.display.lineSpace.removeChild(e.display.dragCursor),e.display.dragCursor=null)}function Ji(e){if(document.getElementsByClassName)for(var t=document.getElementsByClassName("CodeMirror"),r=0;r<t.length;r++){var n=t[r].CodeMirror;n&&e(n)}}function eo(){Fs||(to(),Fs=!0)}function to(){var e;Ql(window,"resize",function(){null==e&&(e=setTimeout(function(){e=null,Ji(ro)},100))}),Ql(window,"blur",function(){return Ji(Fr)})}function ro(e){var t=e.display;t.lastWrapHeight==t.wrapper.clientHeight&&t.lastWrapWidth==t.wrapper.clientWidth||(t.cachedCharWidth=t.cachedTextHeight=t.cachedPaddingH=null,t.scrollbarsClipped=!1,e.setSize())}function no(e){var t=e.split(/-(?!$)/);e=t[t.length-1];for(var r,n,i,o,l=0;l<t.length-1;l++){var s=t[l];if(/^(cmd|meta|m)$/i.test(s))o=!0;else if(/^a(lt)?$/i.test(s))r=!0;else if(/^(c|ctrl|control)$/i.test(s))n=!0;else{if(!/^s(hift)?$/i.test(s))throw new Error("Unrecognized modifier name: "+s);i=!0}}return r&&(e="Alt-"+e),n&&(e="Ctrl-"+e),o&&(e="Cmd-"+e),i&&(e="Shift-"+e),e}function io(e){var t={};for(var r in e)if(e.hasOwnProperty(r)){var n=e[r];if(/^(name|fallthrough|(de|at)tach)$/.test(r))continue;if("..."==n){delete e[r];continue}for(var i=v(r.split(" "),no),o=0;o<i.length;o++){var l=void 0,s=void 0;o==i.length-1?(s=i.join(" "),l=n):(s=i.slice(0,o+1).join(" "),l="...");var a=t[s];if(a){if(a!=l)throw new Error("Inconsistent bindings for "+s)}else t[s]=l}delete e[r]}for(var u in t)e[u]=t[u];return e}function oo(e,t,r,n){var i=(t=uo(t)).call?t.call(e,n):t[e];if(!1===i)return"nothing";if("..."===i)return"multi";if(null!=i&&r(i))return"handled";if(t.fallthrough){if("[object Array]"!=Object.prototype.toString.call(t.fallthrough))return oo(e,t.fallthrough,r,n);for(var o=0;o<t.fallthrough.length;o++){var l=oo(e,t.fallthrough[o],r,n);if(l)return l}}}function lo(e){var t="string"==typeof e?e:Es[e.keyCode];return"Ctrl"==t||"Alt"==t||"Shift"==t||"Mod"==t}function so(e,t,r){var n=e;return t.altKey&&"Alt"!=n&&(e="Alt-"+e),(Dl?t.metaKey:t.ctrlKey)&&"Ctrl"!=n&&(e="Ctrl-"+e),(Dl?t.ctrlKey:t.metaKey)&&"Cmd"!=n&&(e="Cmd-"+e),!r&&t.shiftKey&&"Shift"!=n&&(e="Shift-"+e),e}function ao(e,t){if(wl&&34==e.keyCode&&e.char)return!1;var r=Es[e.keyCode];return null!=r&&!e.altGraphKey&&so(r,e,t)}function uo(e){return"string"==typeof e?Rs[e]:e}function co(e,t){for(var r=e.doc.sel.ranges,n=[],i=0;i<r.length;i++){for(var o=t(r[i]);n.length&&P(o.from,g(n).to)<=0;){var l=n.pop();if(P(l.from,o.from)<0){o.from=l.from;break}}n.push(o)}hn(e,function(){for(var t=n.length-1;t>=0;t--)Ei(e.doc,"",n[t].from,n[t].to,"+delete");jr(e)})}function fo(e,t,r){var n=L(e.text,t+r,r);return n<0||n>e.text.length?null:n}function ho(e,t,r){var n=fo(e,t.ch,r);return null==n?null:new E(t.line,n,r<0?"after":"before")}function po(e,t,r,n,i){if(e){var o=Se(r,t.doc.direction);if(o){var l,s=i<0?g(o):o[0],a=i<0==(1==s.level)?"after":"before";if(s.level>0){var u=Xt(t,r);l=i<0?r.text.length-1:0;var c=Yt(t,u,l).top;l=k(function(e){return Yt(t,u,e).top==c},i<0==(1==s.level)?s.from:s.to-1,l),"before"==a&&(l=fo(r,l,1))}else l=i<0?s.to:s.from;return new E(n,l,a)}}return new E(n,i<0?r.text.length:0,i<0?"before":"after")}function go(e,t,r,n){var i=Se(t,e.doc.direction);if(!i)return ho(t,r,n);r.ch>=t.text.length?(r.ch=t.text.length,r.sticky="before"):r.ch<=0&&(r.ch=0,r.sticky="after");var o=Ce(i,r.ch,r.sticky),l=i[o];if("ltr"==e.doc.direction&&l.level%2==0&&(n>0?l.to>r.ch:l.from<r.ch))return ho(t,r,n);var s,a=function(e,r){return fo(t,e instanceof E?e.ch:e,r)},u=function(r){return e.options.lineWrapping?(s=s||Xt(e,t),hr(e,t,s,r)):{begin:0,end:t.text.length}},c=u("before"==r.sticky?a(r,-1):r.ch);if("rtl"==e.doc.direction||1==l.level){var f=1==l.level==n<0,h=a(r,f?1:-1);if(null!=h&&(f?h<=l.to&&h<=c.end:h>=l.from&&h>=c.begin)){var d=f?"before":"after";return new E(r.line,h,d)}}var p=function(e,t,n){for(var o=function(e,t){return t?new E(r.line,a(e,1),"before"):new E(r.line,e,"after")};e>=0&&e<i.length;e+=t){var l=i[e],s=t>0==(1!=l.level),u=s?n.begin:a(n.end,-1);if(l.from<=u&&u<l.to)return o(u,s);if(u=s?l.from:a(l.to,-1),n.begin<=u&&u<n.end)return o(u,s)}},g=p(o+n,n,c);if(g)return g;var v=n>0?c.end:a(c.begin,-1);return null==v||n>0&&v==t.text.length||!(g=p(n>0?0:i.length-1,n,u(v)))?null:g}function vo(e,t){var r=M(e.doc,t),n=fe(r);return n!=r&&(t=W(n)),po(!0,e,n,t,1)}function mo(e,t){var r=M(e.doc,t),n=he(r);return n!=r&&(t=W(n)),po(!0,e,r,t,-1)}function yo(e,t){var r=vo(e,t.line),n=M(e.doc,r.line),i=Se(n,e.doc.direction);if(!i||0==i[0].level){var o=Math.max(0,n.text.search(/\S/)),l=t.line==r.line&&t.ch<=o&&t.ch;return E(r.line,l?0:o,r.sticky)}return r}function bo(e,t,r){if("string"==typeof t&&!(t=Bs[t]))return!1;e.display.input.ensurePolled();var n=e.display.shift,i=!1;try{e.isReadOnly()&&(e.state.suppressEdits=!0),r&&(e.display.shift=!1),i=t(e)!=Bl}finally{e.display.shift=n,e.state.suppressEdits=!1}return i}function wo(e,t,r){for(var n=0;n<e.state.keyMaps.length;n++){var i=oo(t,e.state.keyMaps[n],r,e);if(i)return i}return e.options.extraKeys&&oo(t,e.options.extraKeys,r,e)||oo(t,e.options.keyMap,r,e)}function xo(e,t,r,n){var i=e.state.keySeq;if(i){if(lo(t))return"handled";Gs.set(50,function(){e.state.keySeq==i&&(e.state.keySeq=null,e.display.input.reset())}),t=i+" "+t}var o=wo(e,t,n);return"multi"==o&&(e.state.keySeq=t),"handled"==o&&bt(e,"keyHandled",e,t,r),"handled"!=o&&"multi"!=o||(We(r),Ar(e)),i&&!o&&/\'$/.test(t)?(We(r),!0):!!o}function Co(e,t){var r=ao(t,!0);return!!r&&(t.shiftKey&&!e.state.keySeq?xo(e,"Shift-"+r,t,function(t){return bo(e,t,!0)})||xo(e,r,t,function(t){if("string"==typeof t?/^go[A-Z]/.test(t):t.motion)return bo(e,t)}):xo(e,r,t,function(t){return bo(e,t)}))}function So(e,t,r){return xo(e,"'"+r+"'",t,function(t){return bo(e,t,!0)})}function Lo(e){var t=this;if(t.curOp.focus=l(),!Me(t,e)){gl&&vl<11&&27==e.keyCode&&(e.returnValue=!1);var r=e.keyCode;t.display.shift=16==r||e.shiftKey;var n=Co(t,e);wl&&(Us=n?r:null,!n&&88==r&&!rs&&(Ml?e.metaKey:e.ctrlKey)&&t.replaceSelection("",null,"cut")),18!=r||/\bCodeMirror-crosshair\b/.test(t.display.lineDiv.className)||ko(t)}}function ko(e){function t(e){18!=e.keyCode&&e.altKey||(Fl(r,"CodeMirror-crosshair"),ke(document,"keyup",t),ke(document,"mouseover",t))}var r=e.display.lineDiv;s(r,"CodeMirror-crosshair"),Ql(document,"keyup",t),Ql(document,"mouseover",t)}function To(e){16==e.keyCode&&(this.doc.sel.shift=!1),Me(this,e)}function Mo(e){var t=this;if(!(Ft(t.display,e)||Me(t,e)||e.ctrlKey&&!e.altKey||Ml&&e.metaKey)){var r=e.keyCode,n=e.charCode;if(wl&&r==Us)return Us=null,void We(e);if(!wl||e.which&&!(e.which<10)||!Co(t,e)){var i=String.fromCharCode(null==n?r:n);"\b"!=i&&(So(t,e,i)||t.display.input.onKeyPress(e))}}}function No(e,t){var r=+new Date;return js&&js.compare(r,e,t)?(Ks=js=null,"triple"):Ks&&Ks.compare(r,e,t)?(js=new Vs(r,e,t),Ks=null,"double"):(Ks=new Vs(r,e,t),js=null,"single")}function Oo(e){var t=this,r=t.display;if(!(Me(t,e)||r.activeTouch&&r.input.supportsTouch()))if(r.input.ensurePolled(),r.shift=e.shiftKey,Ft(r,e))ml||(r.scroller.draggable=!1,setTimeout(function(){return r.scroller.draggable=!0},100));else if(!zo(t,e)){var n=Sr(t,e),i=Pe(e),o=n?No(n,i):"single";window.focus(),1==i&&t.state.selectingText&&t.state.selectingText(e),n&&Ao(t,i,n,o,e)||(1==i?n?Do(t,n,o,e):Ee(e)==r.scroller&&We(e):2==i?(n&&di(t.doc,n),setTimeout(function(){return r.input.focus()},20)):3==i&&(Hl?Ro(t,e):Dr(t)))}}function Ao(e,t,r,n,i){var o="Click";return"double"==n?o="Double"+o:"triple"==n&&(o="Triple"+o),o=(1==t?"Left":2==t?"Middle":"Right")+o,xo(e,so(o,i),i,function(t){if("string"==typeof t&&(t=Bs[t]),!t)return!1;var n=!1;try{e.isReadOnly()&&(e.state.suppressEdits=!0),n=t(e,r)!=Bl}finally{e.state.suppressEdits=!1}return n})}function Wo(e,t,r){var n=e.getOption("configureMouse"),i=n?n(e,t,r):{};if(null==i.unit){var o=Nl?r.shiftKey&&r.metaKey:r.altKey;i.unit=o?"rectangle":"single"==t?"char":"double"==t?"word":"line"}return(null==i.extend||e.doc.extend)&&(i.extend=e.doc.extend||r.shiftKey),null==i.addNew&&(i.addNew=Ml?r.metaKey:r.ctrlKey),null==i.moveOnDrag&&(i.moveOnDrag=!(Ml?r.altKey:r.ctrlKey)),i}function Do(e,t,r,n){gl?setTimeout(u(Wr,e),0):e.curOp.focus=l();var i,o=Wo(e,r,n),s=e.doc.sel;e.options.dragDrop&&Jl&&!e.isReadOnly()&&"single"==r&&(i=s.contains(t))>-1&&(P((i=s.ranges[i]).from(),t)<0||t.xRel>0)&&(P(i.to(),t)>0||t.xRel<0)?Ho(e,n,t,o):Eo(e,n,t,o)}function Ho(e,t,r,n){var i=e.display,o=!1,l=dn(e,function(t){ml&&(i.scroller.draggable=!1),e.state.draggingText=!1,ke(document,"mouseup",l),ke(document,"mousemove",s),ke(i.scroller,"dragstart",a),ke(i.scroller,"drop",l),o||(We(t),n.addNew||di(e.doc,r,null,null,n.extend),ml||gl&&9==vl?setTimeout(function(){document.body.focus(),i.input.focus()},20):i.input.focus())}),s=function(e){o=o||Math.abs(t.clientX-e.clientX)+Math.abs(t.clientY-e.clientY)>=10},a=function(){return o=!0};ml&&(i.scroller.draggable=!0),e.state.draggingText=l,l.copy=!n.moveOnDrag,i.scroller.dragDrop&&i.scroller.dragDrop(),Ql(document,"mouseup",l),Ql(document,"mousemove",s),Ql(i.scroller,"dragstart",a),Ql(i.scroller,"drop",l),Dr(e),setTimeout(function(){return i.input.focus()},20)}function Fo(e,t,r){if("char"==r)return new Ts(t,t);if("word"==r)return e.findWordAt(t);if("line"==r)return new Ts(E(t.line,0),U(e.doc,E(t.line+1,0)));var n=r(e,t);return new Ts(n.from,n.to)}function Eo(e,t,r,n){function i(t){if(0!=P(m,t))if(m=t,"rectangle"==n.unit){for(var i=[],o=e.options.tabSize,l=f(M(u,r.line).text,r.ch,o),s=f(M(u,t.line).text,t.ch,o),a=Math.min(l,s),g=Math.max(l,s),v=Math.min(r.line,t.line),y=Math.min(e.lastLine(),Math.max(r.line,t.line));v<=y;v++){var b=M(u,v).text,w=d(b,a,o);a==g?i.push(new Ts(E(v,w),E(v,w))):b.length>w&&i.push(new Ts(E(v,w),E(v,d(b,g,o))))}i.length||i.push(new Ts(r,r)),bi(u,zn(p.ranges.slice(0,h).concat(i),h),{origin:"*mouse",scroll:!1}),e.scrollIntoView(t)}else{var x,C=c,S=Fo(e,t,n.unit),L=C.anchor;P(S.anchor,L)>0?(x=S.head,L=B(C.from(),S.anchor)):(x=S.anchor,L=R(C.to(),S.head));var k=p.ranges.slice(0);k[h]=Po(e,new Ts(U(u,L),x)),bi(u,zn(k,h),Ul)}}function o(t){var r=++b,s=Sr(e,t,!0,"rectangle"==n.unit);if(s)if(0!=P(s,m)){e.curOp.focus=l(),i(s);var c=Ir(a,u);(s.line>=c.to||s.line<c.from)&&setTimeout(dn(e,function(){b==r&&o(t)}),150)}else{var f=t.clientY<y.top?-20:t.clientY>y.bottom?20:0;f&&setTimeout(dn(e,function(){b==r&&(a.scroller.scrollTop+=f,o(t))}),50)}}function s(t){e.state.selectingText=!1,b=1/0,We(t),a.input.focus(),ke(document,"mousemove",w),ke(document,"mouseup",x),u.history.lastSelOrigin=null}var a=e.display,u=e.doc;We(t);var c,h,p=u.sel,g=p.ranges;if(n.addNew&&!n.extend?(h=u.sel.contains(r),c=h>-1?g[h]:new Ts(r,r)):(c=u.sel.primary(),h=u.sel.primIndex),"rectangle"==n.unit)n.addNew||(c=new Ts(r,r)),r=Sr(e,t,!0,!0),h=-1;else{var v=Fo(e,r,n.unit);c=n.extend?hi(c,v.anchor,v.head,n.extend):v}n.addNew?-1==h?(h=g.length,bi(u,zn(g.concat([c]),h),{scroll:!1,origin:"*mouse"})):g.length>1&&g[h].empty()&&"char"==n.unit&&!n.extend?(bi(u,zn(g.slice(0,h).concat(g.slice(h+1)),0),{scroll:!1,origin:"*mouse"}),p=u.sel):gi(u,h,c,Ul):(h=0,bi(u,new ks([c],0),Ul),p=u.sel);var m=r,y=a.wrapper.getBoundingClientRect(),b=0,w=dn(e,function(e){Pe(e)?o(e):s(e)}),x=dn(e,s);e.state.selectingText=x,Ql(document,"mousemove",w),Ql(document,"mouseup",x)}function Po(e,t){var r=t.anchor,n=t.head,i=M(e.doc,r.line);if(0==P(r,n)&&r.sticky==n.sticky)return t;var o=Se(i);if(!o)return t;var l=Ce(o,r.ch,r.sticky),s=o[l];if(s.from!=r.ch&&s.to!=r.ch)return t;var a=l+(s.from==r.ch==(1!=s.level)?0:1);if(0==a||a==o.length)return t;var u;if(n.line!=r.line)u=(n.line-r.line)*("ltr"==e.doc.direction?1:-1)>0;else{var c=Ce(o,n.ch,n.sticky),f=c-l||(n.ch-r.ch)*(1==s.level?-1:1);u=c==a-1||c==a?f<0:f>0}var h=o[a+(u?-1:0)],d=u==(1==h.level),p=d?h.from:h.to,g=d?"after":"before";return r.ch==p&&r.sticky==g?t:new Ts(new E(r.line,p,g),n)}function Io(e,t,r,n){var i,o;if(t.touches)i=t.touches[0].clientX,o=t.touches[0].clientY;else try{i=t.clientX,o=t.clientY}catch(t){return!1}if(i>=Math.floor(e.display.gutters.getBoundingClientRect().right))return!1;n&&We(t);var l=e.display,s=l.lineDiv.getBoundingClientRect();if(o>s.bottom||!Oe(e,r))return He(t);o-=s.top-l.viewOffset;for(var a=0;a<e.options.gutters.length;++a){var u=l.gutters.childNodes[a];if(u&&u.getBoundingClientRect().right>=i)return Te(e,r,e,D(e.doc,o),e.options.gutters[a],t),He(t)}}function zo(e,t){return Io(e,t,"gutterClick",!0)}function Ro(e,t){Ft(e.display,t)||Bo(e,t)||Me(e,t,"contextmenu")||e.display.input.onContextMenu(t)}function Bo(e,t){return!!Oe(e,"gutterContextMenu")&&Io(e,t,"gutterContextMenu",!1)}function Go(e){e.display.wrapper.className=e.display.wrapper.className.replace(/\s*cm-s-\S+/g,"")+e.options.theme.replace(/(^|\s)\s*/g," cm-s-"),er(e)}function Uo(e){Hn(e),vn(e),zr(e)}function Vo(e,t,r){if(!t!=!(r&&r!=Xs)){var n=e.display.dragFunctions,i=t?Ql:ke;i(e.display.scroller,"dragstart",n.start),i(e.display.scroller,"dragenter",n.enter),i(e.display.scroller,"dragover",n.over),i(e.display.scroller,"dragleave",n.leave),i(e.display.scroller,"drop",n.drop)}}function Ko(e){e.options.lineWrapping?(s(e.display.wrapper,"CodeMirror-wrap"),e.display.sizer.style.minWidth="",e.display.sizerWidth=null):(Fl(e.display.wrapper,"CodeMirror-wrap"),we(e)),Cr(e),vn(e),er(e),setTimeout(function(){return en(e)},100)}function jo(e,t){var r=this;if(!(this instanceof jo))return new jo(e,t);this.options=t=t?c(t):{},c(Ys,t,!1),Fn(t);var n=t.value;"string"==typeof n&&(n=new Ds(n,t.mode,null,t.lineSeparator,t.direction)),this.doc=n;var i=new jo.inputStyles[t.inputStyle](this),o=this.display=new T(e,n,i);o.wrapper.CodeMirror=this,Hn(this),Go(this),t.lineWrapping&&(this.display.wrapper.className+=" CodeMirror-wrap"),rn(this),this.state={keyMaps:[],overlays:[],modeGen:0,overwrite:!1,delayingBlurEvent:!1,focused:!1,suppressEdits:!1,pasteIncoming:!1,cutIncoming:!1,selectingText:!1,draggingText:!1,highlight:new Pl,keySeq:null,specialChars:null},t.autofocus&&!Tl&&o.input.focus(),gl&&vl<11&&setTimeout(function(){return r.display.input.reset(!0)},20),Xo(this),eo(),nn(this),this.curOp.forceUpdate=!0,qn(this,n),t.autofocus&&!Tl||this.hasFocus()?setTimeout(u(Hr,this),20):Fr(this);for(var l in _s)_s.hasOwnProperty(l)&&_s[l](r,t[l],Xs);Rr(this),t.finishInit&&t.finishInit(this);for(var s=0;s<$s.length;++s)$s[s](r);on(this),ml&&t.lineWrapping&&"optimizelegibility"==getComputedStyle(o.lineDiv).textRendering&&(o.lineDiv.style.textRendering="auto")}function Xo(e){function t(){i.activeTouch&&(o=setTimeout(function(){return i.activeTouch=null},1e3),(l=i.activeTouch).end=+new Date)}function r(e){if(1!=e.touches.length)return!1;var t=e.touches[0];return t.radiusX<=1&&t.radiusY<=1}function n(e,t){if(null==t.left)return!0;var r=t.left-e.left,n=t.top-e.top;return r*r+n*n>400}var i=e.display;Ql(i.scroller,"mousedown",dn(e,Oo)),gl&&vl<11?Ql(i.scroller,"dblclick",dn(e,function(t){if(!Me(e,t)){var r=Sr(e,t);if(r&&!zo(e,t)&&!Ft(e.display,t)){We(t);var n=e.findWordAt(r);di(e.doc,n.anchor,n.head)}}})):Ql(i.scroller,"dblclick",function(t){return Me(e,t)||We(t)}),Hl||Ql(i.scroller,"contextmenu",function(t){return Ro(e,t)});var o,l={end:0};Ql(i.scroller,"touchstart",function(t){if(!Me(e,t)&&!r(t)&&!zo(e,t)){i.input.ensurePolled(),clearTimeout(o);var n=+new Date;i.activeTouch={start:n,moved:!1,prev:n-l.end<=300?l:null},1==t.touches.length&&(i.activeTouch.left=t.touches[0].pageX,i.activeTouch.top=t.touches[0].pageY)}}),Ql(i.scroller,"touchmove",function(){i.activeTouch&&(i.activeTouch.moved=!0)}),Ql(i.scroller,"touchend",function(r){var o=i.activeTouch;if(o&&!Ft(i,r)&&null!=o.left&&!o.moved&&new Date-o.start<300){var l,s=e.coordsChar(i.activeTouch,"page");l=!o.prev||n(o,o.prev)?new Ts(s,s):!o.prev.prev||n(o,o.prev.prev)?e.findWordAt(s):new Ts(E(s.line,0),U(e.doc,E(s.line+1,0))),e.setSelection(l.anchor,l.head),e.focus(),We(r)}t()}),Ql(i.scroller,"touchcancel",t),Ql(i.scroller,"scroll",function(){i.scroller.clientHeight&&(qr(e,i.scroller.scrollTop),Qr(e,i.scroller.scrollLeft,!0),Te(e,"scroll",e))}),Ql(i.scroller,"mousewheel",function(t){return In(e,t)}),Ql(i.scroller,"DOMMouseScroll",function(t){return In(e,t)}),Ql(i.wrapper,"scroll",function(){return i.wrapper.scrollTop=i.wrapper.scrollLeft=0}),i.dragFunctions={enter:function(t){Me(e,t)||Fe(t)},over:function(t){Me(e,t)||(Zi(e,t),Fe(t))},start:function(t){return qi(e,t)},drop:dn(e,$i),leave:function(t){Me(e,t)||Qi(e)}};var s=i.input.getField();Ql(s,"keyup",function(t){return To.call(e,t)}),Ql(s,"keydown",dn(e,Lo)),Ql(s,"keypress",dn(e,Mo)),Ql(s,"focus",function(t){return Hr(e,t)}),Ql(s,"blur",function(t){return Fr(e,t)})}function Yo(e,t,r,n){var i,o=e.doc;null==r&&(r="add"),"smart"==r&&(o.mode.indent?i=$e(e,t).state:r="prev");var l=e.options.tabSize,s=M(o,t),a=f(s.text,null,l);s.stateAfter&&(s.stateAfter=null);var u,c=s.text.match(/^\s*/)[0];if(n||/\S/.test(s.text)){if("smart"==r&&((u=o.mode.indent(i,s.text.slice(c.length),s.text))==Bl||u>150)){if(!n)return;r="prev"}}else u=0,r="not";"prev"==r?u=t>o.first?f(M(o,t-1).text,null,l):0:"add"==r?u=a+e.options.indentUnit:"subtract"==r?u=a-e.options.indentUnit:"number"==typeof r&&(u=a+r),u=Math.max(0,u);var h="",d=0;if(e.options.indentWithTabs)for(var g=Math.floor(u/l);g;--g)d+=l,h+="\t";if(d<u&&(h+=p(u-d)),h!=c)return Ei(o,h,E(t,0),E(t,c.length),"+input"),s.stateAfter=null,!0;for(var v=0;v<o.sel.ranges.length;v++){var m=o.sel.ranges[v];if(m.head.line==t&&m.head.ch<c.length){var y=E(t,c.length);gi(o,v,new Ts(y,y));break}}}function _o(e){qs=e}function $o(e,t,r,n,i){var o=e.doc;e.display.shift=!1,n||(n=o.sel);var l=e.state.pasteIncoming||"paste"==i,s=es(t),a=null;if(l&&n.ranges.length>1)if(qs&&qs.text.join("\n")==t){if(n.ranges.length%qs.text.length==0){a=[];for(var u=0;u<qs.text.length;u++)a.push(o.splitLines(qs.text[u]))}}else s.length==n.ranges.length&&e.options.pasteLinesPerSelection&&(a=v(s,function(e){return[e]}));for(var c,f=n.ranges.length-1;f>=0;f--){var h=n.ranges[f],d=h.from(),p=h.to();h.empty()&&(r&&r>0?d=E(d.line,d.ch-r):e.state.overwrite&&!l?p=E(p.line,Math.min(M(o,p.line).text.length,p.ch+g(s).length)):qs&&qs.lineWise&&qs.text.join("\n")==t&&(d=p=E(d.line,0))),c=e.curOp.updateInput;var m={from:d,to:p,text:a?a[f%a.length]:s,origin:i||(l?"paste":e.state.cutIncoming?"cut":"+input")};Oi(e.doc,m),bt(e,"inputRead",e,m)}t&&!l&&Zo(e,t),jr(e),e.curOp.updateInput=c,e.curOp.typing=!0,e.state.pasteIncoming=e.state.cutIncoming=!1}function qo(e,t){var r=e.clipboardData&&e.clipboardData.getData("Text");if(r)return e.preventDefault(),t.isReadOnly()||t.options.disableInput||hn(t,function(){return $o(t,r,0,null,"paste")}),!0}function Zo(e,t){if(e.options.electricChars&&e.options.smartIndent)for(var r=e.doc.sel,n=r.ranges.length-1;n>=0;n--){var i=r.ranges[n];if(!(i.head.ch>100||n&&r.ranges[n-1].head.line==i.head.line)){var o=e.getModeAt(i.head),l=!1;if(o.electricChars){for(var s=0;s<o.electricChars.length;s++)if(t.indexOf(o.electricChars.charAt(s))>-1){l=Yo(e,i.head.line,"smart");break}}else o.electricInput&&o.electricInput.test(M(e.doc,i.head.line).text.slice(0,i.head.ch))&&(l=Yo(e,i.head.line,"smart"));l&&bt(e,"electricInput",e,i.head.line)}}}function Qo(e){for(var t=[],r=[],n=0;n<e.doc.sel.ranges.length;n++){var i=e.doc.sel.ranges[n].head.line,o={anchor:E(i,0),head:E(i+1,0)};r.push(o),t.push(e.getRange(o.anchor,o.head))}return{text:t,ranges:r}}function Jo(e,t){e.setAttribute("autocorrect","off"),e.setAttribute("autocapitalize","off"),e.setAttribute("spellcheck",!!t)}function el(){var e=n("textarea",null,null,"position: absolute; bottom: -1em; padding: 0; width: 1px; height: 1em; outline: none"),t=n("div",[e],null,"overflow: hidden; position: relative; width: 3px; height: 0px;");return ml?e.style.width="1000px":e.setAttribute("wrap","off"),Ll&&(e.style.border="1px solid black"),Jo(e),t}function tl(e,t,r,n,i){function o(){var n=t.line+r;return!(n<e.first||n>=e.first+e.size)&&(t=new E(n,t.ch,t.sticky),u=M(e,n))}function l(n){var l;if(null==(l=i?go(e.cm,u,t,r):ho(u,t,r))){if(n||!o())return!1;t=po(i,e.cm,u,t.line,r)}else t=l;return!0}var s=t,a=r,u=M(e,t.line);if("char"==n)l();else if("column"==n)l(!0);else if("word"==n||"group"==n)for(var c=null,f="group"==n,h=e.cm&&e.cm.getHelper(t,"wordChars"),d=!0;!(r<0)||l(!d);d=!1){var p=u.text.charAt(t.ch)||"\n",g=x(p,h)?"w":f&&"\n"==p?"n":!f||/\s/.test(p)?null:"p";if(!f||d||g||(g="s"),c&&c!=g){r<0&&(r=1,l(),t.sticky="after");break}if(g&&(c=g),r>0&&!l(!d))break}var v=ki(e,t,s,a,!0);return I(s,v)&&(v.hitSide=!0),v}function rl(e,t,r,n){var i,o=e.doc,l=t.left;if("page"==n){var s=Math.min(e.display.wrapper.clientHeight,window.innerHeight||document.documentElement.clientHeight),a=Math.max(s-.5*mr(e.display),3);i=(r>0?t.bottom:t.top)+r*a}else"line"==n&&(i=r>0?t.bottom+3:t.top-3);for(var u;(u=cr(e,l,i)).outside;){if(r<0?i<=0:i>=o.height){u.hitSide=!0;break}i+=5*r}return u}function nl(e,t){var r=jt(e,t.line);if(!r||r.hidden)return null;var n=M(e.doc,t.line),i=Ut(r,n,t.line),o=Se(n,e.doc.direction),l="left";o&&(l=Ce(o,t.ch)%2?"right":"left");var s=_t(i.map,t.ch,l);return s.offset="right"==s.collapse?s.end:s.start,s}function il(e){for(var t=e;t;t=t.parentNode)if(/CodeMirror-gutter-wrapper/.test(t.className))return!0;return!1}function ol(e,t){return t&&(e.bad=!0),e}function ll(e,t,r,n,i){function o(e){return function(t){return t.id==e}}function l(){c&&(u+=f,c=!1)}function s(e){e&&(l(),u+=e)}function a(t){if(1==t.nodeType){var r=t.getAttribute("cm-text");if(null!=r)return void s(r||t.textContent.replace(/\u200b/g,""));var u,h=t.getAttribute("cm-marker");if(h){var d=e.findMarks(E(n,0),E(i+1,0),o(+h));return void(d.length&&(u=d[0].find(0))&&s(N(e.doc,u.from,u.to).join(f)))}if("false"==t.getAttribute("contenteditable"))return;var p=/^(pre|div|p)$/i.test(t.nodeName);p&&l();for(var g=0;g<t.childNodes.length;g++)a(t.childNodes[g]);p&&(c=!0)}else 3==t.nodeType&&s(t.nodeValue)}for(var u="",c=!1,f=e.doc.lineSeparator();a(t),t!=r;)t=t.nextSibling;return u}function sl(e,t,r){var n;if(t==e.display.lineDiv){if(!(n=e.display.lineDiv.childNodes[r]))return ol(e.clipPos(E(e.display.viewTo-1)),!0);t=null,r=0}else for(n=t;;n=n.parentNode){if(!n||n==e.display.lineDiv)return null;if(n.parentNode&&n.parentNode==e.display.lineDiv)break}for(var i=0;i<e.display.view.length;i++){var o=e.display.view[i];if(o.node==n)return al(o,t,r)}}function al(e,t,r){function n(t,r,n){for(var i=-1;i<(f?f.length:0);i++)for(var o=i<0?c.map:f[i],l=0;l<o.length;l+=3){var s=o[l+2];if(s==t||s==r){var a=W(i<0?e.line:e.rest[i]),u=o[l]+n;return(n<0||s!=t)&&(u=o[l+(n?1:0)]),E(a,u)}}}var i=e.text.firstChild,l=!1;if(!t||!o(i,t))return ol(E(W(e.line),0),!0);if(t==i&&(l=!0,t=i.childNodes[r],r=0,!t)){var s=e.rest?g(e.rest):e.line;return ol(E(W(s),s.text.length),l)}var a=3==t.nodeType?t:null,u=t;for(a||1!=t.childNodes.length||3!=t.firstChild.nodeType||(a=t.firstChild,r&&(r=a.nodeValue.length));u.parentNode!=i;)u=u.parentNode;var c=e.measure,f=c.maps,h=n(a,u,r);if(h)return ol(h,l);for(var d=u.nextSibling,p=a?a.nodeValue.length-r:0;d;d=d.nextSibling){if(h=n(d,d.firstChild,0))return ol(E(h.line,h.ch-p),l);p+=d.textContent.length}for(var v=u.previousSibling,m=r;v;v=v.previousSibling){if(h=n(v,v.firstChild,-1))return ol(E(h.line,h.ch+m),l);m+=v.textContent.length}}var ul=navigator.userAgent,cl=navigator.platform,fl=/gecko\/\d/i.test(ul),hl=/MSIE \d/.test(ul),dl=/Trident\/(?:[7-9]|\d{2,})\..*rv:(\d+)/.exec(ul),pl=/Edge\/(\d+)/.exec(ul),gl=hl||dl||pl,vl=gl&&(hl?document.documentMode||6:+(pl||dl)[1]),ml=!pl&&/WebKit\//.test(ul),yl=ml&&/Qt\/\d+\.\d+/.test(ul),bl=!pl&&/Chrome\//.test(ul),wl=/Opera\//.test(ul),xl=/Apple Computer/.test(navigator.vendor),Cl=/Mac OS X 1\d\D([8-9]|\d\d)\D/.test(ul),Sl=/PhantomJS/.test(ul),Ll=!pl&&/AppleWebKit/.test(ul)&&/Mobile\/\w+/.test(ul),kl=/Android/.test(ul),Tl=Ll||kl||/webOS|BlackBerry|Opera Mini|Opera Mobi|IEMobile/i.test(ul),Ml=Ll||/Mac/.test(cl),Nl=/\bCrOS\b/.test(ul),Ol=/win/i.test(cl),Al=wl&&ul.match(/Version\/(\d*\.\d*)/);Al&&(Al=Number(Al[1])),Al&&Al>=15&&(wl=!1,ml=!0);var Wl,Dl=Ml&&(yl||wl&&(null==Al||Al<12.11)),Hl=fl||gl&&vl>=9,Fl=function(t,r){var n=t.className,i=e(r).exec(n);if(i){var o=n.slice(i.index+i[0].length);t.className=n.slice(0,i.index)+(o?i[1]+o:"")}};Wl=document.createRange?function(e,t,r,n){var i=document.createRange();return i.setEnd(n||e,r),i.setStart(e,t),i}:function(e,t,r){var n=document.body.createTextRange();try{n.moveToElementText(e.parentNode)}catch(e){return n}return n.collapse(!0),n.moveEnd("character",r),n.moveStart("character",t),n};var El=function(e){e.select()};Ll?El=function(e){e.selectionStart=0,e.selectionEnd=e.value.length}:gl&&(El=function(e){try{e.select()}catch(e){}});var Pl=function(){this.id=null};Pl.prototype.set=function(e,t){clearTimeout(this.id),this.id=setTimeout(t,e)};var Il,zl,Rl=30,Bl={toString:function(){return"CodeMirror.Pass"}},Gl={scroll:!1},Ul={origin:"*mouse"},Vl={origin:"+move"},Kl=[""],jl=/[\u00df\u0587\u0590-\u05f4\u0600-\u06ff\u3040-\u309f\u30a0-\u30ff\u3400-\u4db5\u4e00-\u9fcc\uac00-\ud7af]/,Xl=/[\u0300-\u036f\u0483-\u0489\u0591-\u05bd\u05bf\u05c1\u05c2\u05c4\u05c5\u05c7\u0610-\u061a\u064b-\u065e\u0670\u06d6-\u06dc\u06de-\u06e4\u06e7\u06e8\u06ea-\u06ed\u0711\u0730-\u074a\u07a6-\u07b0\u07eb-\u07f3\u0816-\u0819\u081b-\u0823\u0825-\u0827\u0829-\u082d\u0900-\u0902\u093c\u0941-\u0948\u094d\u0951-\u0955\u0962\u0963\u0981\u09bc\u09be\u09c1-\u09c4\u09cd\u09d7\u09e2\u09e3\u0a01\u0a02\u0a3c\u0a41\u0a42\u0a47\u0a48\u0a4b-\u0a4d\u0a51\u0a70\u0a71\u0a75\u0a81\u0a82\u0abc\u0ac1-\u0ac5\u0ac7\u0ac8\u0acd\u0ae2\u0ae3\u0b01\u0b3c\u0b3e\u0b3f\u0b41-\u0b44\u0b4d\u0b56\u0b57\u0b62\u0b63\u0b82\u0bbe\u0bc0\u0bcd\u0bd7\u0c3e-\u0c40\u0c46-\u0c48\u0c4a-\u0c4d\u0c55\u0c56\u0c62\u0c63\u0cbc\u0cbf\u0cc2\u0cc6\u0ccc\u0ccd\u0cd5\u0cd6\u0ce2\u0ce3\u0d3e\u0d41-\u0d44\u0d4d\u0d57\u0d62\u0d63\u0dca\u0dcf\u0dd2-\u0dd4\u0dd6\u0ddf\u0e31\u0e34-\u0e3a\u0e47-\u0e4e\u0eb1\u0eb4-\u0eb9\u0ebb\u0ebc\u0ec8-\u0ecd\u0f18\u0f19\u0f35\u0f37\u0f39\u0f71-\u0f7e\u0f80-\u0f84\u0f86\u0f87\u0f90-\u0f97\u0f99-\u0fbc\u0fc6\u102d-\u1030\u1032-\u1037\u1039\u103a\u103d\u103e\u1058\u1059\u105e-\u1060\u1071-\u1074\u1082\u1085\u1086\u108d\u109d\u135f\u1712-\u1714\u1732-\u1734\u1752\u1753\u1772\u1773\u17b7-\u17bd\u17c6\u17c9-\u17d3\u17dd\u180b-\u180d\u18a9\u1920-\u1922\u1927\u1928\u1932\u1939-\u193b\u1a17\u1a18\u1a56\u1a58-\u1a5e\u1a60\u1a62\u1a65-\u1a6c\u1a73-\u1a7c\u1a7f\u1b00-\u1b03\u1b34\u1b36-\u1b3a\u1b3c\u1b42\u1b6b-\u1b73\u1b80\u1b81\u1ba2-\u1ba5\u1ba8\u1ba9\u1c2c-\u1c33\u1c36\u1c37\u1cd0-\u1cd2\u1cd4-\u1ce0\u1ce2-\u1ce8\u1ced\u1dc0-\u1de6\u1dfd-\u1dff\u200c\u200d\u20d0-\u20f0\u2cef-\u2cf1\u2de0-\u2dff\u302a-\u302f\u3099\u309a\ua66f-\ua672\ua67c\ua67d\ua6f0\ua6f1\ua802\ua806\ua80b\ua825\ua826\ua8c4\ua8e0-\ua8f1\ua926-\ua92d\ua947-\ua951\ua980-\ua982\ua9b3\ua9b6-\ua9b9\ua9bc\uaa29-\uaa2e\uaa31\uaa32\uaa35\uaa36\uaa43\uaa4c\uaab0\uaab2-\uaab4\uaab7\uaab8\uaabe\uaabf\uaac1\uabe5\uabe8\uabed\udc00-\udfff\ufb1e\ufe00-\ufe0f\ufe20-\ufe26\uff9e\uff9f]/,Yl=!1,_l=!1,$l=null,ql=function(){function e(e){return e<=247?r.charAt(e):1424<=e&&e<=1524?"R":1536<=e&&e<=1785?n.charAt(e-1536):1774<=e&&e<=2220?"r":8192<=e&&e<=8203?"w":8204==e?"b":"L"}function t(e,t,r){this.level=e,this.from=t,this.to=r}var r="bbbbbbbbbtstwsbbbbbbbbbbbbbbssstwNN%%%NNNNNN,N,N1111111111NNNNNNNLLLLLLLLLLLLLLLLLLLLLLLLLLNNNNNNLLLLLLLLLLLLLLLLLLLLLLLLLLNNNNbbbbbbsbbbbbbbbbbbbbbbbbbbbbbbbbb,N%%%%NNNNLNNNNN%%11NLNNN1LNNNNNLLLLLLLLLLLLLLLLLLLLLLLNLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLN",n="nnnnnnNNr%%r,rNNmmmmmmmmmmmrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrmmmmmmmmmmmmmmmmmmmmmnnnnnnnnnn%nnrrrmrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrmmmmmmmnNmmmmmmrrmmNmmmmrr1111111111",i=/[\u0590-\u05f4\u0600-\u06ff\u0700-\u08ac]/,o=/[stwN]/,l=/[LRr]/,s=/[Lb1n]/,a=/[1n]/;return function(r,n){var u="ltr"==n?"L":"R";if(0==r.length||"ltr"==n&&!i.test(r))return!1;for(var c=r.length,f=[],h=0;h<c;++h)f.push(e(r.charCodeAt(h)));for(var d=0,p=u;d<c;++d){var v=f[d];"m"==v?f[d]=p:p=v}for(var m=0,y=u;m<c;++m){var b=f[m];"1"==b&&"r"==y?f[m]="n":l.test(b)&&(y=b,"r"==b&&(f[m]="R"))}for(var w=1,x=f[0];w<c-1;++w){var C=f[w];"+"==C&&"1"==x&&"1"==f[w+1]?f[w]="1":","!=C||x!=f[w+1]||"1"!=x&&"n"!=x||(f[w]=x),x=C}for(var S=0;S<c;++S){var L=f[S];if(","==L)f[S]="N";else if("%"==L){var k=void 0;for(k=S+1;k<c&&"%"==f[k];++k);for(var T=S&&"!"==f[S-1]||k<c&&"1"==f[k]?"1":"N",M=S;M<k;++M)f[M]=T;S=k-1}}for(var N=0,O=u;N<c;++N){var A=f[N];"L"==O&&"1"==A?f[N]="L":l.test(A)&&(O=A)}for(var W=0;W<c;++W)if(o.test(f[W])){var D=void 0;for(D=W+1;D<c&&o.test(f[D]);++D);for(var H="L"==(W?f[W-1]:u),F=H==("L"==(D<c?f[D]:u))?H?"L":"R":u,E=W;E<D;++E)f[E]=F;W=D-1}for(var P,I=[],z=0;z<c;)if(s.test(f[z])){var R=z;for(++z;z<c&&s.test(f[z]);++z);I.push(new t(0,R,z))}else{var B=z,G=I.length;for(++z;z<c&&"L"!=f[z];++z);for(var U=B;U<z;)if(a.test(f[U])){B<U&&I.splice(G,0,new t(1,B,U));var V=U;for(++U;U<z&&a.test(f[U]);++U);I.splice(G,0,new t(2,V,U)),B=U}else++U;B<z&&I.splice(G,0,new t(1,B,z))}return 1==I[0].level&&(P=r.match(/^\s+/))&&(I[0].from=P[0].length,I.unshift(new t(0,0,P[0].length))),1==g(I).level&&(P=r.match(/\s+$/))&&(g(I).to-=P[0].length,I.push(new t(0,c-P[0].length,c))),"rtl"==n?I.reverse():I}}(),Zl=[],Ql=function(e,t,r){if(e.addEventListener)e.addEventListener(t,r,!1);else if(e.attachEvent)e.attachEvent("on"+t,r);else{var n=e._handlers||(e._handlers={});n[t]=(n[t]||Zl).concat(r)}},Jl=function(){if(gl&&vl<9)return!1;var e=n("div");return"draggable"in e||"dragDrop"in e}(),es=3!="\n\nb".split(/\n/).length?function(e){for(var t=0,r=[],n=e.length;t<=n;){var i=e.indexOf("\n",t);-1==i&&(i=e.length);var o=e.slice(t,"\r"==e.charAt(i-1)?i-1:i),l=o.indexOf("\r");-1!=l?(r.push(o.slice(0,l)),t+=l+1):(r.push(o),t=i+1)}return r}:function(e){return e.split(/\r\n?|\n/)},ts=window.getSelection?function(e){try{return e.selectionStart!=e.selectionEnd}catch(e){return!1}}:function(e){var t;try{t=e.ownerDocument.selection.createRange()}catch(e){}return!(!t||t.parentElement()!=e)&&0!=t.compareEndPoints("StartToEnd",t)},rs=function(){var e=n("div");return"oncopy"in e||(e.setAttribute("oncopy","return;"),"function"==typeof e.oncopy)}(),ns=null,is={},os={},ls={},ss=function(e,t,r){this.pos=this.start=0,this.string=e,this.tabSize=t||8,this.lastColumnPos=this.lastColumnValue=0,this.lineStart=0,this.lineOracle=r};ss.prototype.eol=function(){return this.pos>=this.string.length},ss.prototype.sol=function(){return this.pos==this.lineStart},ss.prototype.peek=function(){return this.string.charAt(this.pos)||void 0},ss.prototype.next=function(){if(this.pos<this.string.length)return this.string.charAt(this.pos++)},ss.prototype.eat=function(e){var t=this.string.charAt(this.pos);if("string"==typeof e?t==e:t&&(e.test?e.test(t):e(t)))return++this.pos,t},ss.prototype.eatWhile=function(e){for(var t=this.pos;this.eat(e););return this.pos>t},ss.prototype.eatSpace=function(){for(var e=this,t=this.pos;/[\s\u00a0]/.test(this.string.charAt(this.pos));)++e.pos;return this.pos>t},ss.prototype.skipToEnd=function(){this.pos=this.string.length},ss.prototype.skipTo=function(e){var t=this.string.indexOf(e,this.pos);if(t>-1)return this.pos=t,!0},ss.prototype.backUp=function(e){this.pos-=e},ss.prototype.column=function(){return this.lastColumnPos<this.start&&(this.lastColumnValue=f(this.string,this.start,this.tabSize,this.lastColumnPos,this.lastColumnValue),this.lastColumnPos=this.start),this.lastColumnValue-(this.lineStart?f(this.string,this.lineStart,this.tabSize):0)},ss.prototype.indentation=function(){return f(this.string,null,this.tabSize)-(this.lineStart?f(this.string,this.lineStart,this.tabSize):0)},ss.prototype.match=function(e,t,r){if("string"!=typeof e){var n=this.string.slice(this.pos).match(e);return n&&n.index>0?null:(n&&!1!==t&&(this.pos+=n[0].length),n)}var i=function(e){return r?e.toLowerCase():e};if(i(this.string.substr(this.pos,e.length))==i(e))return!1!==t&&(this.pos+=e.length),!0},ss.prototype.current=function(){return this.string.slice(this.start,this.pos)},ss.prototype.hideFirstChars=function(e,t){this.lineStart+=e;try{return t()}finally{this.lineStart-=e}},ss.prototype.lookAhead=function(e){var t=this.lineOracle;return t&&t.lookAhead(e)};var as=function(e,t){this.state=e,this.lookAhead=t},us=function(e,t,r,n){this.state=t,this.doc=e,this.line=r,this.maxLookAhead=n||0};us.prototype.lookAhead=function(e){var t=this.doc.getLine(this.line+e);return null!=t&&e>this.maxLookAhead&&(this.maxLookAhead=e),t},us.prototype.nextLine=function(){this.line++,this.maxLookAhead>0&&this.maxLookAhead--},us.fromSaved=function(e,t,r){return t instanceof as?new us(e,Ke(e.mode,t.state),r,t.lookAhead):new us(e,Ke(e.mode,t),r)},us.prototype.save=function(e){var t=!1!==e?Ke(this.doc.mode,this.state):this.state;return this.maxLookAhead>0?new as(t,this.maxLookAhead):t};var cs=function(e,t,r){this.start=e.start,this.end=e.pos,this.string=e.current(),this.type=t||null,this.state=r},fs=function(e,t,r){this.text=e,ne(this,t),this.height=r?r(this):1};fs.prototype.lineNo=function(){return W(this)},Ae(fs);var hs,ds={},ps={},gs=null,vs=null,ms={left:0,right:0,top:0,bottom:0},ys=function(e,t,r){this.cm=r;var i=this.vert=n("div",[n("div",null,null,"min-width: 1px")],"CodeMirror-vscrollbar"),o=this.horiz=n("div",[n("div",null,null,"height: 100%; min-height: 1px")],"CodeMirror-hscrollbar");e(i),e(o),Ql(i,"scroll",function(){i.clientHeight&&t(i.scrollTop,"vertical")}),Ql(o,"scroll",function(){o.clientWidth&&t(o.scrollLeft,"horizontal")}),this.checkedZeroWidth=!1,gl&&vl<8&&(this.horiz.style.minHeight=this.vert.style.minWidth="18px")};ys.prototype.update=function(e){var t=e.scrollWidth>e.clientWidth+1,r=e.scrollHeight>e.clientHeight+1,n=e.nativeBarWidth;if(r){this.vert.style.display="block",this.vert.style.bottom=t?n+"px":"0";var i=e.viewHeight-(t?n:0);this.vert.firstChild.style.height=Math.max(0,e.scrollHeight-e.clientHeight+i)+"px"}else this.vert.style.display="",this.vert.firstChild.style.height="0";if(t){this.horiz.style.display="block",this.horiz.style.right=r?n+"px":"0",this.horiz.style.left=e.barLeft+"px";var o=e.viewWidth-e.barLeft-(r?n:0);this.horiz.firstChild.style.width=Math.max(0,e.scrollWidth-e.clientWidth+o)+"px"}else this.horiz.style.display="",this.horiz.firstChild.style.width="0";return!this.checkedZeroWidth&&e.clientHeight>0&&(0==n&&this.zeroWidthHack(),this.checkedZeroWidth=!0),{right:r?n:0,bottom:t?n:0}},ys.prototype.setScrollLeft=function(e){this.horiz.scrollLeft!=e&&(this.horiz.scrollLeft=e),this.disableHoriz&&this.enableZeroWidthBar(this.horiz,this.disableHoriz,"horiz")},ys.prototype.setScrollTop=function(e){this.vert.scrollTop!=e&&(this.vert.scrollTop=e),this.disableVert&&this.enableZeroWidthBar(this.vert,this.disableVert,"vert")},ys.prototype.zeroWidthHack=function(){var e=Ml&&!Cl?"12px":"18px";this.horiz.style.height=this.vert.style.width=e,this.horiz.style.pointerEvents=this.vert.style.pointerEvents="none",this.disableHoriz=new Pl,this.disableVert=new Pl},ys.prototype.enableZeroWidthBar=function(e,t,r){function n(){var i=e.getBoundingClientRect();("vert"==r?document.elementFromPoint(i.right-1,(i.top+i.bottom)/2):document.elementFromPoint((i.right+i.left)/2,i.bottom-1))!=e?e.style.pointerEvents="none":t.set(1e3,n)}e.style.pointerEvents="auto",t.set(1e3,n)},ys.prototype.clear=function(){var e=this.horiz.parentNode;e.removeChild(this.horiz),e.removeChild(this.vert)};var bs=function(){};bs.prototype.update=function(){return{bottom:0,right:0}},bs.prototype.setScrollLeft=function(){},bs.prototype.setScrollTop=function(){},bs.prototype.clear=function(){};var ws={native:ys,null:bs},xs=0,Cs=function(e,t,r){var n=e.display;this.viewport=t,this.visible=Ir(n,e.doc,t),this.editorIsHidden=!n.wrapper.offsetWidth,this.wrapperHeight=n.wrapper.clientHeight,this.wrapperWidth=n.wrapper.clientWidth,this.oldDisplayWidth=Rt(e),this.force=r,this.dims=br(e),this.events=[]};Cs.prototype.signal=function(e,t){Oe(e,t)&&this.events.push(arguments)},Cs.prototype.finish=function(){for(var e=this,t=0;t<this.events.length;t++)Te.apply(null,e.events[t])};var Ss=0,Ls=null;gl?Ls=-.53:fl?Ls=15:bl?Ls=-.7:xl&&(Ls=-1/3);var ks=function(e,t){this.ranges=e,this.primIndex=t};ks.prototype.primary=function(){return this.ranges[this.primIndex]},ks.prototype.equals=function(e){var t=this;if(e==this)return!0;if(e.primIndex!=this.primIndex||e.ranges.length!=this.ranges.length)return!1;for(var r=0;r<this.ranges.length;r++){var n=t.ranges[r],i=e.ranges[r];if(!I(n.anchor,i.anchor)||!I(n.head,i.head))return!1}return!0},ks.prototype.deepCopy=function(){for(var e=this,t=[],r=0;r<this.ranges.length;r++)t[r]=new Ts(z(e.ranges[r].anchor),z(e.ranges[r].head));return new ks(t,this.primIndex)},ks.prototype.somethingSelected=function(){for(var e=this,t=0;t<this.ranges.length;t++)if(!e.ranges[t].empty())return!0;return!1},ks.prototype.contains=function(e,t){var r=this;t||(t=e);for(var n=0;n<this.ranges.length;n++){var i=r.ranges[n];if(P(t,i.from())>=0&&P(e,i.to())<=0)return n}return-1};var Ts=function(e,t){this.anchor=e,this.head=t};Ts.prototype.from=function(){return B(this.anchor,this.head)},Ts.prototype.to=function(){return R(this.anchor,this.head)},Ts.prototype.empty=function(){return this.head.line==this.anchor.line&&this.head.ch==this.anchor.ch},Bi.prototype={chunkSize:function(){return this.lines.length},removeInner:function(e,t){for(var r=this,n=e,i=e+t;n<i;++n){var o=r.lines[n];r.height-=o.height,ot(o),bt(o,"delete")}this.lines.splice(e,t)},collapse:function(e){e.push.apply(e,this.lines)},insertInner:function(e,t,r){var n=this;this.height+=r,this.lines=this.lines.slice(0,e).concat(t).concat(this.lines.slice(e));for(var i=0;i<t.length;++i)t[i].parent=n},iterN:function(e,t,r){for(var n=this,i=e+t;e<i;++e)if(r(n.lines[e]))return!0}},Gi.prototype={chunkSize:function(){return this.size},removeInner:function(e,t){var r=this;this.size-=t;for(var n=0;n<this.children.length;++n){var i=r.children[n],o=i.chunkSize();if(e<o){var l=Math.min(t,o-e),s=i.height;if(i.removeInner(e,l),r.height-=s-i.height,o==l&&(r.children.splice(n--,1),i.parent=null),0==(t-=l))break;e=0}else e-=o}if(this.size-t<25&&(this.children.length>1||!(this.children[0]instanceof Bi))){var a=[];this.collapse(a),this.children=[new Bi(a)],this.children[0].parent=this}},collapse:function(e){for(var t=this,r=0;r<this.children.length;++r)t.children[r].collapse(e)},insertInner:function(e,t,r){var n=this;this.size+=t.length,this.height+=r;for(var i=0;i<this.children.length;++i){var o=n.children[i],l=o.chunkSize();if(e<=l){if(o.insertInner(e,t,r),o.lines&&o.lines.length>50){for(var s=o.lines.length%25+25,a=s;a<o.lines.length;){var u=new Bi(o.lines.slice(a,a+=25));o.height-=u.height,n.children.splice(++i,0,u),u.parent=n}o.lines=o.lines.slice(0,s),n.maybeSpill()}break}e-=l}},maybeSpill:function(){if(!(this.children.length<=10)){var e=this;do{var t=new Gi(e.children.splice(e.children.length-5,5));if(e.parent){e.size-=t.size,e.height-=t.height;var r=h(e.parent.children,e);e.parent.children.splice(r+1,0,t)}else{var n=new Gi(e.children);n.parent=e,e.children=[n,t],e=n}t.parent=e.parent}while(e.children.length>10);e.parent.maybeSpill()}},iterN:function(e,t,r){for(var n=this,i=0;i<this.children.length;++i){var o=n.children[i],l=o.chunkSize();if(e<l){var s=Math.min(t,l-e);if(o.iterN(e,s,r))return!0;if(0==(t-=s))break;e=0}else e-=l}}};var Ms=function(e,t,r){var n=this;if(r)for(var i in r)r.hasOwnProperty(i)&&(n[i]=r[i]);this.doc=e,this.node=t};Ms.prototype.clear=function(){var e=this,t=this.doc.cm,r=this.line.widgets,n=this.line,i=W(n);if(null!=i&&r){for(var o=0;o<r.length;++o)r[o]==e&&r.splice(o--,1);r.length||(n.widgets=null);var l=Ht(this);A(n,Math.max(0,n.height-l)),t&&(hn(t,function(){Ui(t,n,-l),mn(t,i,"widget")}),bt(t,"lineWidgetCleared",t,this,i))}},Ms.prototype.changed=function(){var e=this,t=this.height,r=this.doc.cm,n=this.line;this.height=null;var i=Ht(this)-t;i&&(A(n,n.height+i),r&&hn(r,function(){r.curOp.forceUpdate=!0,Ui(r,n,i),bt(r,"lineWidgetChanged",r,e,W(n))}))},Ae(Ms);var Ns=0,Os=function(e,t){this.lines=[],this.type=t,this.doc=e,this.id=++Ns};Os.prototype.clear=function(){var e=this;if(!this.explicitlyCleared){var t=this.doc.cm,r=t&&!t.curOp;if(r&&nn(t),Oe(this,"clear")){var n=this.find();n&&bt(this,"clear",n.from,n.to)}for(var i=null,o=null,l=0;l<this.lines.length;++l){var s=e.lines[l],a=_(s.markedSpans,e);t&&!e.collapsed?mn(t,W(s),"text"):t&&(null!=a.to&&(o=W(s)),null!=a.from&&(i=W(s))),s.markedSpans=$(s.markedSpans,a),null==a.from&&e.collapsed&&!ve(e.doc,s)&&t&&A(s,mr(t.display))}if(t&&this.collapsed&&!t.options.lineWrapping)for(var u=0;u<this.lines.length;++u){var c=fe(e.lines[u]),f=be(c);f>t.display.maxLineLength&&(t.display.maxLine=c,t.display.maxLineLength=f,t.display.maxLineChanged=!0)}null!=i&&t&&this.collapsed&&vn(t,i,o+1),this.lines.length=0,this.explicitlyCleared=!0,this.atomic&&this.doc.cantEdit&&(this.doc.cantEdit=!1,t&&Ci(t.doc)),t&&bt(t,"markerCleared",t,this,i,o),r&&on(t),this.parent&&this.parent.clear()}},Os.prototype.find=function(e,t){var r=this;null==e&&"bookmark"==this.type&&(e=1);for(var n,i,o=0;o<this.lines.length;++o){var l=r.lines[o],s=_(l.markedSpans,r);if(null!=s.from&&(n=E(t?l:W(l),s.from),-1==e))return n;if(null!=s.to&&(i=E(t?l:W(l),s.to),1==e))return i}return n&&{from:n,to:i}},Os.prototype.changed=function(){var e=this,t=this.find(-1,!0),r=this,n=this.doc.cm;t&&n&&hn(n,function(){var i=t.line,o=W(t.line),l=jt(n,o);if(l&&(Qt(l),n.curOp.selectionChanged=n.curOp.forceUpdate=!0),n.curOp.updateMaxLine=!0,!ve(r.doc,i)&&null!=r.height){var s=r.height;r.height=null;var a=Ht(r)-s;a&&A(i,i.height+a)}bt(n,"markerChanged",n,e)})},Os.prototype.attachLine=function(e){if(!this.lines.length&&this.doc.cm){var t=this.doc.cm.curOp;t.maybeHiddenMarkers&&-1!=h(t.maybeHiddenMarkers,this)||(t.maybeUnhiddenMarkers||(t.maybeUnhiddenMarkers=[])).push(this)}this.lines.push(e)},Os.prototype.detachLine=function(e){if(this.lines.splice(h(this.lines,e),1),!this.lines.length&&this.doc.cm){var t=this.doc.cm.curOp;(t.maybeHiddenMarkers||(t.maybeHiddenMarkers=[])).push(this)}},Ae(Os);var As=function(e,t){var r=this;this.markers=e,this.primary=t;for(var n=0;n<e.length;++n)e[n].parent=r};As.prototype.clear=function(){var e=this;if(!this.explicitlyCleared){this.explicitlyCleared=!0;for(var t=0;t<this.markers.length;++t)e.markers[t].clear();bt(this,"clear")}},As.prototype.find=function(e,t){return this.primary.find(e,t)},Ae(As);var Ws=0,Ds=function(e,t,r,n,i){if(!(this instanceof Ds))return new Ds(e,t,r,n,i);null==r&&(r=0),Gi.call(this,[new Bi([new fs("",null)])]),this.first=r,this.scrollTop=this.scrollLeft=0,this.cantEdit=!1,this.cleanGeneration=1,this.modeFrontier=this.highlightFrontier=r;var o=E(r,0);this.sel=Rn(o),this.history=new Jn(null),this.id=++Ws,this.modeOption=t,this.lineSep=n,this.direction="rtl"==i?"rtl":"ltr",this.extend=!1,"string"==typeof e&&(e=this.splitLines(e)),_n(this,{from:o,to:o,text:e}),bi(this,Rn(o),Gl)};Ds.prototype=b(Gi.prototype,{constructor:Ds,iter:function(e,t,r){r?this.iterN(e-this.first,t-e,r):this.iterN(this.first,this.first+this.size,e)},insert:function(e,t){for(var r=0,n=0;n<t.length;++n)r+=t[n].height;this.insertInner(e-this.first,t,r)},remove:function(e,t){this.removeInner(e-this.first,t)},getValue:function(e){var t=O(this,this.first,this.first+this.size);return!1===e?t:t.join(e||this.lineSeparator())},setValue:gn(function(e){var t=E(this.first,0),r=this.first+this.size-1;Oi(this,{from:t,to:E(r,M(this,r).text.length),text:this.splitLines(e),origin:"setValue",full:!0},!0),this.cm&&Xr(this.cm,0,0),bi(this,Rn(t),Gl)}),replaceRange:function(e,t,r,n){Ei(this,e,t=U(this,t),r=r?U(this,r):t,n)},getRange:function(e,t,r){var n=N(this,U(this,e),U(this,t));return!1===r?n:n.join(r||this.lineSeparator())},getLine:function(e){var t=this.getLineHandle(e);return t&&t.text},getLineHandle:function(e){if(H(this,e))return M(this,e)},getLineNumber:function(e){return W(e)},getLineHandleVisualStart:function(e){return"number"==typeof e&&(e=M(this,e)),fe(e)},lineCount:function(){return this.size},firstLine:function(){return this.first},lastLine:function(){return this.first+this.size-1},clipPos:function(e){return U(this,e)},getCursor:function(e){var t=this.sel.primary();return null==e||"head"==e?t.head:"anchor"==e?t.anchor:"end"==e||"to"==e||!1===e?t.to():t.from()},listSelections:function(){return this.sel.ranges},somethingSelected:function(){return this.sel.somethingSelected()},setCursor:gn(function(e,t,r){vi(this,U(this,"number"==typeof e?E(e,t||0):e),null,r)}),setSelection:gn(function(e,t,r){vi(this,U(this,e),U(this,t||e),r)}),extendSelection:gn(function(e,t,r){di(this,U(this,e),t&&U(this,t),r)}),extendSelections:gn(function(e,t){pi(this,K(this,e),t)}),extendSelectionsBy:gn(function(e,t){pi(this,K(this,v(this.sel.ranges,e)),t)}),setSelections:gn(function(e,t,r){var n=this;if(e.length){for(var i=[],o=0;o<e.length;o++)i[o]=new Ts(U(n,e[o].anchor),U(n,e[o].head));null==t&&(t=Math.min(e.length-1,this.sel.primIndex)),bi(this,zn(i,t),r)}}),addSelection:gn(function(e,t,r){var n=this.sel.ranges.slice(0);n.push(new Ts(U(this,e),U(this,t||e))),bi(this,zn(n,n.length-1),r)}),getSelection:function(e){for(var t,r=this,n=this.sel.ranges,i=0;i<n.length;i++){var o=N(r,n[i].from(),n[i].to());t=t?t.concat(o):o}return!1===e?t:t.join(e||this.lineSeparator())},getSelections:function(e){for(var t=this,r=[],n=this.sel.ranges,i=0;i<n.length;i++){var o=N(t,n[i].from(),n[i].to());!1!==e&&(o=o.join(e||t.lineSeparator())),r[i]=o}return r},replaceSelection:function(e,t,r){for(var n=[],i=0;i<this.sel.ranges.length;i++)n[i]=e;this.replaceSelections(n,t,r||"+input")},replaceSelections:gn(function(e,t,r){for(var n=this,i=[],o=this.sel,l=0;l<o.ranges.length;l++){var s=o.ranges[l];i[l]={from:s.from(),to:s.to(),text:n.splitLines(e[l]),origin:r}}for(var a=t&&"end"!=t&&Kn(this,i,t),u=i.length-1;u>=0;u--)Oi(n,i[u]);a?yi(this,a):this.cm&&jr(this.cm)}),undo:gn(function(){Wi(this,"undo")}),redo:gn(function(){Wi(this,"redo")}),undoSelection:gn(function(){Wi(this,"undo",!0)}),redoSelection:gn(function(){Wi(this,"redo",!0)}),setExtending:function(e){this.extend=e},getExtending:function(){return this.extend},historySize:function(){for(var e=this.history,t=0,r=0,n=0;n<e.done.length;n++)e.done[n].ranges||++t;for(var i=0;i<e.undone.length;i++)e.undone[i].ranges||++r;return{undo:t,redo:r}},clearHistory:function(){this.history=new Jn(this.history.maxGeneration)},markClean:function(){this.cleanGeneration=this.changeGeneration(!0)},changeGeneration:function(e){return e&&(this.history.lastOp=this.history.lastSelOp=this.history.lastOrigin=null),this.history.generation},isClean:function(e){return this.history.generation==(e||this.cleanGeneration)},getHistory:function(){return{done:fi(this.history.done),undone:fi(this.history.undone)}},setHistory:function(e){var t=this.history=new Jn(this.history.maxGeneration);t.done=fi(e.done.slice(0),null,!0),t.undone=fi(e.undone.slice(0),null,!0)},setGutterMarker:gn(function(e,t,r){return Ri(this,e,"gutter",function(e){var n=e.gutterMarkers||(e.gutterMarkers={});return n[t]=r,!r&&C(n)&&(e.gutterMarkers=null),!0})}),clearGutter:gn(function(e){var t=this;this.iter(function(r){r.gutterMarkers&&r.gutterMarkers[e]&&Ri(t,r,"gutter",function(){return r.gutterMarkers[e]=null,C(r.gutterMarkers)&&(r.gutterMarkers=null),!0})})}),lineInfo:function(e){var t;if("number"==typeof e){if(!H(this,e))return null;if(t=e,!(e=M(this,e)))return null}else if(null==(t=W(e)))return null;return{line:t,handle:e,text:e.text,gutterMarkers:e.gutterMarkers,textClass:e.textClass,bgClass:e.bgClass,wrapClass:e.wrapClass,widgets:e.widgets}},addLineClass:gn(function(t,r,n){return Ri(this,t,"gutter"==r?"gutter":"class",function(t){var i="text"==r?"textClass":"background"==r?"bgClass":"gutter"==r?"gutterClass":"wrapClass";if(t[i]){if(e(n).test(t[i]))return!1;t[i]+=" "+n}else t[i]=n;return!0})}),removeLineClass:gn(function(t,r,n){return Ri(this,t,"gutter"==r?"gutter":"class",function(t){var i="text"==r?"textClass":"background"==r?"bgClass":"gutter"==r?"gutterClass":"wrapClass",o=t[i];if(!o)return!1;if(null==n)t[i]=null;else{var l=o.match(e(n));if(!l)return!1;var s=l.index+l[0].length;t[i]=o.slice(0,l.index)+(l.index&&s!=o.length?" ":"")+o.slice(s)||null}return!0})}),addLineWidget:gn(function(e,t,r){return Vi(this,e,t,r)}),removeLineWidget:function(e){e.clear()},markText:function(e,t,r){return Ki(this,U(this,e),U(this,t),r,r&&r.type||"range")},setBookmark:function(e,t){var r={replacedWith:t&&(null==t.nodeType?t.widget:t),insertLeft:t&&t.insertLeft,clearWhenEmpty:!1,shared:t&&t.shared,handleMouseEvents:t&&t.handleMouseEvents};return e=U(this,e),Ki(this,e,e,r,"bookmark")},findMarksAt:function(e){var t=[],r=M(this,(e=U(this,e)).line).markedSpans;if(r)for(var n=0;n<r.length;++n){var i=r[n];(null==i.from||i.from<=e.ch)&&(null==i.to||i.to>=e.ch)&&t.push(i.marker.parent||i.marker)}return t},findMarks:function(e,t,r){e=U(this,e),t=U(this,t);var n=[],i=e.line;return this.iter(e.line,t.line+1,function(o){var l=o.markedSpans;if(l)for(var s=0;s<l.length;s++){var a=l[s];null!=a.to&&i==e.line&&e.ch>=a.to||null==a.from&&i!=e.line||null!=a.from&&i==t.line&&a.from>=t.ch||r&&!r(a.marker)||n.push(a.marker.parent||a.marker)}++i}),n},getAllMarks:function(){var e=[];return this.iter(function(t){var r=t.markedSpans;if(r)for(var n=0;n<r.length;++n)null!=r[n].from&&e.push(r[n].marker)}),e},posFromIndex:function(e){var t,r=this.first,n=this.lineSeparator().length;return this.iter(function(i){var o=i.text.length+n;if(o>e)return t=e,!0;e-=o,++r}),U(this,E(r,t))},indexFromPos:function(e){var t=(e=U(this,e)).ch;if(e.line<this.first||e.ch<0)return 0;var r=this.lineSeparator().length;return this.iter(this.first,e.line,function(e){t+=e.text.length+r}),t},copy:function(e){var t=new Ds(O(this,this.first,this.first+this.size),this.modeOption,this.first,this.lineSep,this.direction);return t.scrollTop=this.scrollTop,t.scrollLeft=this.scrollLeft,t.sel=this.sel,t.extend=!1,e&&(t.history.undoDepth=this.history.undoDepth,t.setHistory(this.getHistory())),t},linkedDoc:function(e){e||(e={});var t=this.first,r=this.first+this.size;null!=e.from&&e.from>t&&(t=e.from),null!=e.to&&e.to<r&&(r=e.to);var n=new Ds(O(this,t,r),e.mode||this.modeOption,t,this.lineSep,this.direction);return e.sharedHist&&(n.history=this.history),(this.linked||(this.linked=[])).push({doc:n,sharedHist:e.sharedHist}),n.linked=[{doc:this,isParent:!0,sharedHist:e.sharedHist}],Yi(n,Xi(this)),n},unlinkDoc:function(e){var t=this;if(e instanceof jo&&(e=e.doc),this.linked)for(var r=0;r<this.linked.length;++r)if(t.linked[r].doc==e){t.linked.splice(r,1),e.unlinkDoc(t),_i(Xi(t));break}if(e.history==this.history){var n=[e.id];$n(e,function(e){return n.push(e.id)},!0),e.history=new Jn(null),e.history.done=fi(this.history.done,n),e.history.undone=fi(this.history.undone,n)}},iterLinkedDocs:function(e){$n(this,e)},getMode:function(){return this.mode},getEditor:function(){return this.cm},splitLines:function(e){return this.lineSep?e.split(this.lineSep):es(e)},lineSeparator:function(){return this.lineSep||"\n"},setDirection:gn(function(e){"rtl"!=e&&(e="ltr"),e!=this.direction&&(this.direction=e,this.iter(function(e){return e.order=null}),this.cm&&Qn(this.cm))})}),Ds.prototype.eachLine=Ds.prototype.iter;for(var Hs=0,Fs=!1,Es={3:"Enter",8:"Backspace",9:"Tab",13:"Enter",16:"Shift",17:"Ctrl",18:"Alt",19:"Pause",20:"CapsLock",27:"Esc",32:"Space",33:"PageUp",34:"PageDown",35:"End",36:"Home",37:"Left",38:"Up",39:"Right",40:"Down",44:"PrintScrn",45:"Insert",46:"Delete",59:";",61:"=",91:"Mod",92:"Mod",93:"Mod",106:"*",107:"=",109:"-",110:".",111:"/",127:"Delete",173:"-",186:";",187:"=",188:",",189:"-",190:".",191:"/",192:"`",219:"[",220:"\\",221:"]",222:"'",63232:"Up",63233:"Down",63234:"Left",63235:"Right",63272:"Delete",63273:"Home",63275:"End",63276:"PageUp",63277:"PageDown",63302:"Insert"},Ps=0;Ps<10;Ps++)Es[Ps+48]=Es[Ps+96]=String(Ps);for(var Is=65;Is<=90;Is++)Es[Is]=String.fromCharCode(Is);for(var zs=1;zs<=12;zs++)Es[zs+111]=Es[zs+63235]="F"+zs;var Rs={};Rs.basic={Left:"goCharLeft",Right:"goCharRight",Up:"goLineUp",Down:"goLineDown",End:"goLineEnd",Home:"goLineStartSmart",PageUp:"goPageUp",PageDown:"goPageDown",Delete:"delCharAfter",Backspace:"delCharBefore","Shift-Backspace":"delCharBefore",Tab:"defaultTab","Shift-Tab":"indentAuto",Enter:"newlineAndIndent",Insert:"toggleOverwrite",Esc:"singleSelection"},Rs.pcDefault={"Ctrl-A":"selectAll","Ctrl-D":"deleteLine","Ctrl-Z":"undo","Shift-Ctrl-Z":"redo","Ctrl-Y":"redo","Ctrl-Home":"goDocStart","Ctrl-End":"goDocEnd","Ctrl-Up":"goLineUp","Ctrl-Down":"goLineDown","Ctrl-Left":"goGroupLeft","Ctrl-Right":"goGroupRight","Alt-Left":"goLineStart","Alt-Right":"goLineEnd","Ctrl-Backspace":"delGroupBefore","Ctrl-Delete":"delGroupAfter","Ctrl-S":"save","Ctrl-F":"find","Ctrl-G":"findNext","Shift-Ctrl-G":"findPrev","Shift-Ctrl-F":"replace","Shift-Ctrl-R":"replaceAll","Ctrl-[":"indentLess","Ctrl-]":"indentMore","Ctrl-U":"undoSelection","Shift-Ctrl-U":"redoSelection","Alt-U":"redoSelection",fallthrough:"basic"},Rs.emacsy={"Ctrl-F":"goCharRight","Ctrl-B":"goCharLeft","Ctrl-P":"goLineUp","Ctrl-N":"goLineDown","Alt-F":"goWordRight","Alt-B":"goWordLeft","Ctrl-A":"goLineStart","Ctrl-E":"goLineEnd","Ctrl-V":"goPageDown","Shift-Ctrl-V":"goPageUp","Ctrl-D":"delCharAfter","Ctrl-H":"delCharBefore","Alt-D":"delWordAfter","Alt-Backspace":"delWordBefore","Ctrl-K":"killLine","Ctrl-T":"transposeChars","Ctrl-O":"openLine"},Rs.macDefault={"Cmd-A":"selectAll","Cmd-D":"deleteLine","Cmd-Z":"undo","Shift-Cmd-Z":"redo","Cmd-Y":"redo","Cmd-Home":"goDocStart","Cmd-Up":"goDocStart","Cmd-End":"goDocEnd","Cmd-Down":"goDocEnd","Alt-Left":"goGroupLeft","Alt-Right":"goGroupRight","Cmd-Left":"goLineLeft","Cmd-Right":"goLineRight","Alt-Backspace":"delGroupBefore","Ctrl-Alt-Backspace":"delGroupAfter","Alt-Delete":"delGroupAfter","Cmd-S":"save","Cmd-F":"find","Cmd-G":"findNext","Shift-Cmd-G":"findPrev","Cmd-Alt-F":"replace","Shift-Cmd-Alt-F":"replaceAll","Cmd-[":"indentLess","Cmd-]":"indentMore","Cmd-Backspace":"delWrappedLineLeft","Cmd-Delete":"delWrappedLineRight","Cmd-U":"undoSelection","Shift-Cmd-U":"redoSelection","Ctrl-Up":"goDocStart","Ctrl-Down":"goDocEnd",fallthrough:["basic","emacsy"]},Rs.default=Ml?Rs.macDefault:Rs.pcDefault;var Bs={selectAll:Mi,singleSelection:function(e){return e.setSelection(e.getCursor("anchor"),e.getCursor("head"),Gl)},killLine:function(e){return co(e,function(t){if(t.empty()){var r=M(e.doc,t.head.line).text.length;return t.head.ch==r&&t.head.line<e.lastLine()?{from:t.head,to:E(t.head.line+1,0)}:{from:t.head,to:E(t.head.line,r)}}return{from:t.from(),to:t.to()}})},deleteLine:function(e){return co(e,function(t){return{from:E(t.from().line,0),to:U(e.doc,E(t.to().line+1,0))}})},delLineLeft:function(e){return co(e,function(e){return{from:E(e.from().line,0),to:e.from()}})},delWrappedLineLeft:function(e){return co(e,function(t){var r=e.charCoords(t.head,"div").top+5;return{from:e.coordsChar({left:0,top:r},"div"),to:t.from()}})},delWrappedLineRight:function(e){return co(e,function(t){var r=e.charCoords(t.head,"div").top+5,n=e.coordsChar({left:e.display.lineDiv.offsetWidth+100,top:r},"div");return{from:t.from(),to:n}})},undo:function(e){return e.undo()},redo:function(e){return e.redo()},undoSelection:function(e){return e.undoSelection()},redoSelection:function(e){return e.redoSelection()},goDocStart:function(e){return e.extendSelection(E(e.firstLine(),0))},goDocEnd:function(e){return e.extendSelection(E(e.lastLine()))},goLineStart:function(e){return e.extendSelectionsBy(function(t){return vo(e,t.head.line)},{origin:"+move",bias:1})},goLineStartSmart:function(e){return e.extendSelectionsBy(function(t){return yo(e,t.head)},{origin:"+move",bias:1})},goLineEnd:function(e){return e.extendSelectionsBy(function(t){return mo(e,t.head.line)},{origin:"+move",bias:-1})},goLineRight:function(e){return e.extendSelectionsBy(function(t){var r=e.cursorCoords(t.head,"div").top+5;return e.coordsChar({left:e.display.lineDiv.offsetWidth+100,top:r},"div")},Vl)},goLineLeft:function(e){return e.extendSelectionsBy(function(t){var r=e.cursorCoords(t.head,"div").top+5;return e.coordsChar({left:0,top:r},"div")},Vl)},goLineLeftSmart:function(e){return e.extendSelectionsBy(function(t){var r=e.cursorCoords(t.head,"div").top+5,n=e.coordsChar({left:0,top:r},"div");return n.ch<e.getLine(n.line).search(/\S/)?yo(e,t.head):n},Vl)},goLineUp:function(e){return e.moveV(-1,"line")},goLineDown:function(e){return e.moveV(1,"line")},goPageUp:function(e){return e.moveV(-1,"page")},goPageDown:function(e){return e.moveV(1,"page")},goCharLeft:function(e){return e.moveH(-1,"char")},goCharRight:function(e){return e.moveH(1,"char")},goColumnLeft:function(e){return e.moveH(-1,"column")},goColumnRight:function(e){return e.moveH(1,"column")},goWordLeft:function(e){return e.moveH(-1,"word")},goGroupRight:function(e){return e.moveH(1,"group")},goGroupLeft:function(e){return e.moveH(-1,"group")},goWordRight:function(e){return e.moveH(1,"word")},delCharBefore:function(e){return e.deleteH(-1,"char")},delCharAfter:function(e){return e.deleteH(1,"char")},delWordBefore:function(e){return e.deleteH(-1,"word")},delWordAfter:function(e){return e.deleteH(1,"word")},delGroupBefore:function(e){return e.deleteH(-1,"group")},delGroupAfter:function(e){return e.deleteH(1,"group")},indentAuto:function(e){return e.indentSelection("smart")},indentMore:function(e){return e.indentSelection("add")},indentLess:function(e){return e.indentSelection("subtract")},insertTab:function(e){return e.replaceSelection("\t")},insertSoftTab:function(e){for(var t=[],r=e.listSelections(),n=e.options.tabSize,i=0;i<r.length;i++){var o=r[i].from(),l=f(e.getLine(o.line),o.ch,n);t.push(p(n-l%n))}e.replaceSelections(t)},defaultTab:function(e){e.somethingSelected()?e.indentSelection("add"):e.execCommand("insertTab")},transposeChars:function(e){return hn(e,function(){for(var t=e.listSelections(),r=[],n=0;n<t.length;n++)if(t[n].empty()){var i=t[n].head,o=M(e.doc,i.line).text;if(o)if(i.ch==o.length&&(i=new E(i.line,i.ch-1)),i.ch>0)i=new E(i.line,i.ch+1),e.replaceRange(o.charAt(i.ch-1)+o.charAt(i.ch-2),E(i.line,i.ch-2),i,"+transpose");else if(i.line>e.doc.first){var l=M(e.doc,i.line-1).text;l&&(i=new E(i.line,1),e.replaceRange(o.charAt(0)+e.doc.lineSeparator()+l.charAt(l.length-1),E(i.line-1,l.length-1),i,"+transpose"))}r.push(new Ts(i,i))}e.setSelections(r)})},newlineAndIndent:function(e){return hn(e,function(){for(var t=e.listSelections(),r=t.length-1;r>=0;r--)e.replaceRange(e.doc.lineSeparator(),t[r].anchor,t[r].head,"+input");t=e.listSelections();for(var n=0;n<t.length;n++)e.indentLine(t[n].from().line,null,!0);jr(e)})},openLine:function(e){return e.replaceSelection("\n","start")},toggleOverwrite:function(e){return e.toggleOverwrite()}},Gs=new Pl,Us=null,Vs=function(e,t,r){this.time=e,this.pos=t,this.button=r};Vs.prototype.compare=function(e,t,r){return this.time+400>e&&0==P(t,this.pos)&&r==this.button};var Ks,js,Xs={toString:function(){return"CodeMirror.Init"}},Ys={},_s={};jo.defaults=Ys,jo.optionHandlers=_s;var $s=[];jo.defineInitHook=function(e){return $s.push(e)};var qs=null,Zs=function(e){this.cm=e,this.lastAnchorNode=this.lastAnchorOffset=this.lastFocusNode=this.lastFocusOffset=null,this.polling=new Pl,this.composing=null,this.gracePeriod=!1,this.readDOMTimeout=null};Zs.prototype.init=function(e){function t(e){if(!Me(i,e)){if(i.somethingSelected())_o({lineWise:!1,text:i.getSelections()}),"cut"==e.type&&i.replaceSelection("",null,"cut");else{if(!i.options.lineWiseCopyCut)return;var t=Qo(i);_o({lineWise:!0,text:t.text}),"cut"==e.type&&i.operation(function(){i.setSelections(t.ranges,0,Gl),i.replaceSelection("",null,"cut")})}if(e.clipboardData){e.clipboardData.clearData();var r=qs.text.join("\n");if(e.clipboardData.setData("Text",r),e.clipboardData.getData("Text")==r)return void e.preventDefault()}var l=el(),s=l.firstChild;i.display.lineSpace.insertBefore(l,i.display.lineSpace.firstChild),s.value=qs.text.join("\n");var a=document.activeElement;El(s),setTimeout(function(){i.display.lineSpace.removeChild(l),a.focus(),a==o&&n.showPrimarySelection()},50)}}var r=this,n=this,i=n.cm,o=n.div=e.lineDiv;Jo(o,i.options.spellcheck),Ql(o,"paste",function(e){Me(i,e)||qo(e,i)||vl<=11&&setTimeout(dn(i,function(){return r.updateFromDOM()}),20)}),Ql(o,"compositionstart",function(e){r.composing={data:e.data,done:!1}}),Ql(o,"compositionupdate",function(e){r.composing||(r.composing={data:e.data,done:!1})}),Ql(o,"compositionend",function(e){r.composing&&(e.data!=r.composing.data&&r.readFromDOMSoon(),r.composing.done=!0)}),Ql(o,"touchstart",function(){return n.forceCompositionEnd()}),Ql(o,"input",function(){r.composing||r.readFromDOMSoon()}),Ql(o,"copy",t),Ql(o,"cut",t)},Zs.prototype.prepareSelection=function(){var e=Tr(this.cm,!1);return e.focus=this.cm.state.focused,e},Zs.prototype.showSelection=function(e,t){e&&this.cm.display.view.length&&((e.focus||t)&&this.showPrimarySelection(),this.showMultipleSelections(e))},Zs.prototype.showPrimarySelection=function(){var e=window.getSelection(),t=this.cm,r=t.doc.sel.primary(),n=r.from(),i=r.to();if(t.display.viewTo==t.display.viewFrom||n.line>=t.display.viewTo||i.line<t.display.viewFrom)e.removeAllRanges();else{var o=sl(t,e.anchorNode,e.anchorOffset),l=sl(t,e.focusNode,e.focusOffset);if(!o||o.bad||!l||l.bad||0!=P(B(o,l),n)||0!=P(R(o,l),i)){var s=t.display.view,a=n.line>=t.display.viewFrom&&nl(t,n)||{node:s[0].measure.map[2],offset:0},u=i.line<t.display.viewTo&&nl(t,i);if(!u){var c=s[s.length-1].measure,f=c.maps?c.maps[c.maps.length-1]:c.map;u={node:f[f.length-1],offset:f[f.length-2]-f[f.length-3]}}if(a&&u){var h,d=e.rangeCount&&e.getRangeAt(0);try{h=Wl(a.node,a.offset,u.offset,u.node)}catch(e){}h&&(!fl&&t.state.focused?(e.collapse(a.node,a.offset),h.collapsed||(e.removeAllRanges(),e.addRange(h))):(e.removeAllRanges(),e.addRange(h)),d&&null==e.anchorNode?e.addRange(d):fl&&this.startGracePeriod()),this.rememberSelection()}else e.removeAllRanges()}}},Zs.prototype.startGracePeriod=function(){var e=this;clearTimeout(this.gracePeriod),this.gracePeriod=setTimeout(function(){e.gracePeriod=!1,e.selectionChanged()&&e.cm.operation(function(){return e.cm.curOp.selectionChanged=!0})},20)},Zs.prototype.showMultipleSelections=function(e){r(this.cm.display.cursorDiv,e.cursors),r(this.cm.display.selectionDiv,e.selection)},Zs.prototype.rememberSelection=function(){var e=window.getSelection();this.lastAnchorNode=e.anchorNode,this.lastAnchorOffset=e.anchorOffset,this.lastFocusNode=e.focusNode,this.lastFocusOffset=e.focusOffset},Zs.prototype.selectionInEditor=function(){var e=window.getSelection();if(!e.rangeCount)return!1;var t=e.getRangeAt(0).commonAncestorContainer;return o(this.div,t)},Zs.prototype.focus=function(){"nocursor"!=this.cm.options.readOnly&&(this.selectionInEditor()||this.showSelection(this.prepareSelection(),!0),this.div.focus())},Zs.prototype.blur=function(){this.div.blur()},Zs.prototype.getField=function(){return this.div},Zs.prototype.supportsTouch=function(){return!0},Zs.prototype.receivedFocus=function(){function e(){t.cm.state.focused&&(t.pollSelection(),t.polling.set(t.cm.options.pollInterval,e))}var t=this;this.selectionInEditor()?this.pollSelection():hn(this.cm,function(){return t.cm.curOp.selectionChanged=!0}),this.polling.set(this.cm.options.pollInterval,e)},Zs.prototype.selectionChanged=function(){var e=window.getSelection();return e.anchorNode!=this.lastAnchorNode||e.anchorOffset!=this.lastAnchorOffset||e.focusNode!=this.lastFocusNode||e.focusOffset!=this.lastFocusOffset},Zs.prototype.pollSelection=function(){if(null==this.readDOMTimeout&&!this.gracePeriod&&this.selectionChanged()){var e=window.getSelection(),t=this.cm;if(kl&&bl&&this.cm.options.gutters.length&&il(e.anchorNode))return this.cm.triggerOnKeyDown({type:"keydown",keyCode:8,preventDefault:Math.abs}),this.blur(),void this.focus();if(!this.composing){this.rememberSelection();var r=sl(t,e.anchorNode,e.anchorOffset),n=sl(t,e.focusNode,e.focusOffset);r&&n&&hn(t,function(){bi(t.doc,Rn(r,n),Gl),(r.bad||n.bad)&&(t.curOp.selectionChanged=!0)})}}},Zs.prototype.pollContent=function(){null!=this.readDOMTimeout&&(clearTimeout(this.readDOMTimeout),this.readDOMTimeout=null);var e=this.cm,t=e.display,r=e.doc.sel.primary(),n=r.from(),i=r.to();if(0==n.ch&&n.line>e.firstLine()&&(n=E(n.line-1,M(e.doc,n.line-1).length)),i.ch==M(e.doc,i.line).text.length&&i.line<e.lastLine()&&(i=E(i.line+1,0)),n.line<t.viewFrom||i.line>t.viewTo-1)return!1;var o,l,s;n.line==t.viewFrom||0==(o=Lr(e,n.line))?(l=W(t.view[0].line),s=t.view[0].node):(l=W(t.view[o].line),s=t.view[o-1].node.nextSibling);var a,u,c=Lr(e,i.line);if(c==t.view.length-1?(a=t.viewTo-1,u=t.lineDiv.lastChild):(a=W(t.view[c+1].line)-1,u=t.view[c+1].node.previousSibling),!s)return!1;for(var f=e.doc.splitLines(ll(e,s,u,l,a)),h=N(e.doc,E(l,0),E(a,M(e.doc,a).text.length));f.length>1&&h.length>1;)if(g(f)==g(h))f.pop(),h.pop(),a--;else{if(f[0]!=h[0])break;f.shift(),h.shift(),l++}for(var d=0,p=0,v=f[0],m=h[0],y=Math.min(v.length,m.length);d<y&&v.charCodeAt(d)==m.charCodeAt(d);)++d;for(var b=g(f),w=g(h),x=Math.min(b.length-(1==f.length?d:0),w.length-(1==h.length?d:0));p<x&&b.charCodeAt(b.length-p-1)==w.charCodeAt(w.length-p-1);)++p;if(1==f.length&&1==h.length&&l==n.line)for(;d&&d>n.ch&&b.charCodeAt(b.length-p-1)==w.charCodeAt(w.length-p-1);)d--,p++;f[f.length-1]=b.slice(0,b.length-p).replace(/^\u200b+/,""),f[0]=f[0].slice(d).replace(/\u200b+$/,"");var C=E(l,d),S=E(a,h.length?g(h).length-p:0);return f.length>1||f[0]||P(C,S)?(Ei(e.doc,f,C,S,"+input"),!0):void 0},Zs.prototype.ensurePolled=function(){this.forceCompositionEnd()},Zs.prototype.reset=function(){this.forceCompositionEnd()},Zs.prototype.forceCompositionEnd=function(){this.composing&&(clearTimeout(this.readDOMTimeout),this.composing=null,this.updateFromDOM(),this.div.blur(),this.div.focus())},Zs.prototype.readFromDOMSoon=function(){var e=this;null==this.readDOMTimeout&&(this.readDOMTimeout=setTimeout(function(){if(e.readDOMTimeout=null,e.composing){if(!e.composing.done)return;e.composing=null}e.updateFromDOM()},80))},Zs.prototype.updateFromDOM=function(){var e=this;!this.cm.isReadOnly()&&this.pollContent()||hn(this.cm,function(){return vn(e.cm)})},Zs.prototype.setUneditable=function(e){e.contentEditable="false"},Zs.prototype.onKeyPress=function(e){0!=e.charCode&&(e.preventDefault(),this.cm.isReadOnly()||dn(this.cm,$o)(this.cm,String.fromCharCode(null==e.charCode?e.keyCode:e.charCode),0))},Zs.prototype.readOnlyChanged=function(e){this.div.contentEditable=String("nocursor"!=e)},Zs.prototype.onContextMenu=function(){},Zs.prototype.resetPosition=function(){},Zs.prototype.needsContentAttribute=!0;var Qs=function(e){this.cm=e,this.prevInput="",this.pollingFast=!1,this.polling=new Pl,this.hasSelection=!1,this.composing=null};Qs.prototype.init=function(e){function t(e){if(!Me(i,e)){if(i.somethingSelected())_o({lineWise:!1,text:i.getSelections()});else{if(!i.options.lineWiseCopyCut)return;var t=Qo(i);_o({lineWise:!0,text:t.text}),"cut"==e.type?i.setSelections(t.ranges,null,Gl):(n.prevInput="",l.value=t.text.join("\n"),El(l))}"cut"==e.type&&(i.state.cutIncoming=!0)}}var r=this,n=this,i=this.cm,o=this.wrapper=el(),l=this.textarea=o.firstChild;e.wrapper.insertBefore(o,e.wrapper.firstChild),Ll&&(l.style.width="0px"),Ql(l,"input",function(){gl&&vl>=9&&r.hasSelection&&(r.hasSelection=null),n.poll()}),Ql(l,"paste",function(e){Me(i,e)||qo(e,i)||(i.state.pasteIncoming=!0,n.fastPoll())}),Ql(l,"cut",t),Ql(l,"copy",t),Ql(e.scroller,"paste",function(t){Ft(e,t)||Me(i,t)||(i.state.pasteIncoming=!0,n.focus())}),Ql(e.lineSpace,"selectstart",function(t){Ft(e,t)||We(t)}),Ql(l,"compositionstart",function(){var e=i.getCursor("from");n.composing&&n.composing.range.clear(),n.composing={start:e,range:i.markText(e,i.getCursor("to"),{className:"CodeMirror-composing"})}}),Ql(l,"compositionend",function(){n.composing&&(n.poll(),n.composing.range.clear(),n.composing=null)})},Qs.prototype.prepareSelection=function(){var e=this.cm,t=e.display,r=e.doc,n=Tr(e);if(e.options.moveInputWithCursor){var i=sr(e,r.sel.primary().head,"div"),o=t.wrapper.getBoundingClientRect(),l=t.lineDiv.getBoundingClientRect();n.teTop=Math.max(0,Math.min(t.wrapper.clientHeight-10,i.top+l.top-o.top)),n.teLeft=Math.max(0,Math.min(t.wrapper.clientWidth-10,i.left+l.left-o.left))}return n},Qs.prototype.showSelection=function(e){var t=this.cm.display;r(t.cursorDiv,e.cursors),r(t.selectionDiv,e.selection),null!=e.teTop&&(this.wrapper.style.top=e.teTop+"px",this.wrapper.style.left=e.teLeft+"px")},Qs.prototype.reset=function(e){if(!this.contextMenuPending&&!this.composing){var t=this.cm;if(t.somethingSelected()){this.prevInput="";var r=t.getSelection();this.textarea.value=r,t.state.focused&&El(this.textarea),gl&&vl>=9&&(this.hasSelection=r)}else e||(this.prevInput=this.textarea.value="",gl&&vl>=9&&(this.hasSelection=null))}},Qs.prototype.getField=function(){return this.textarea},Qs.prototype.supportsTouch=function(){return!1},Qs.prototype.focus=function(){if("nocursor"!=this.cm.options.readOnly&&(!Tl||l()!=this.textarea))try{this.textarea.focus()}catch(e){}},Qs.prototype.blur=function(){this.textarea.blur()},Qs.prototype.resetPosition=function(){this.wrapper.style.top=this.wrapper.style.left=0},Qs.prototype.receivedFocus=function(){this.slowPoll()},Qs.prototype.slowPoll=function(){var e=this;this.pollingFast||this.polling.set(this.cm.options.pollInterval,function(){e.poll(),e.cm.state.focused&&e.slowPoll()})},Qs.prototype.fastPoll=function(){function e(){r.poll()||t?(r.pollingFast=!1,r.slowPoll()):(t=!0,r.polling.set(60,e))}var t=!1,r=this;r.pollingFast=!0,r.polling.set(20,e)},Qs.prototype.poll=function(){var e=this,t=this.cm,r=this.textarea,n=this.prevInput;if(this.contextMenuPending||!t.state.focused||ts(r)&&!n&&!this.composing||t.isReadOnly()||t.options.disableInput||t.state.keySeq)return!1;var i=r.value;if(i==n&&!t.somethingSelected())return!1;if(gl&&vl>=9&&this.hasSelection===i||Ml&&/[\uf700-\uf7ff]/.test(i))return t.display.input.reset(),!1;if(t.doc.sel==t.display.selForContextMenu){var o=i.charCodeAt(0);if(8203!=o||n||(n="​"),8666==o)return this.reset(),this.cm.execCommand("undo")}for(var l=0,s=Math.min(n.length,i.length);l<s&&n.charCodeAt(l)==i.charCodeAt(l);)++l;return hn(t,function(){$o(t,i.slice(l),n.length-l,null,e.composing?"*compose":null),i.length>1e3||i.indexOf("\n")>-1?r.value=e.prevInput="":e.prevInput=i,e.composing&&(e.composing.range.clear(),e.composing.range=t.markText(e.composing.start,t.getCursor("to"),{className:"CodeMirror-composing"}))}),!0},Qs.prototype.ensurePolled=function(){this.pollingFast&&this.poll()&&(this.pollingFast=!1)},Qs.prototype.onKeyPress=function(){gl&&vl>=9&&(this.hasSelection=null),this.fastPoll()},Qs.prototype.onContextMenu=function(e){function t(){if(null!=l.selectionStart){var e=i.somethingSelected(),t="​"+(e?l.value:"");l.value="⇚",l.value=t,n.prevInput=e?"":"​",l.selectionStart=1,l.selectionEnd=t.length,o.selForContextMenu=i.doc.sel}}function r(){if(n.contextMenuPending=!1,n.wrapper.style.cssText=c,l.style.cssText=u,gl&&vl<9&&o.scrollbars.setScrollTop(o.scroller.scrollTop=a),null!=l.selectionStart){(!gl||gl&&vl<9)&&t();var e=0,r=function(){o.selForContextMenu==i.doc.sel&&0==l.selectionStart&&l.selectionEnd>0&&"​"==n.prevInput?dn(i,Mi)(i):e++<10?o.detectingSelectAll=setTimeout(r,500):(o.selForContextMenu=null,o.input.reset())};o.detectingSelectAll=setTimeout(r,200)}}var n=this,i=n.cm,o=i.display,l=n.textarea,s=Sr(i,e),a=o.scroller.scrollTop;if(s&&!wl){i.options.resetSelectionOnContextMenu&&-1==i.doc.sel.contains(s)&&dn(i,bi)(i.doc,Rn(s),Gl);var u=l.style.cssText,c=n.wrapper.style.cssText;n.wrapper.style.cssText="position: absolute";var f=n.wrapper.getBoundingClientRect();l.style.cssText="position: absolute; width: 30px; height: 30px;\n      top: "+(e.clientY-f.top-5)+"px; left: "+(e.clientX-f.left-5)+"px;\n      z-index: 1000; background: "+(gl?"rgba(255, 255, 255, .05)":"transparent")+";\n      outline: none; border-width: 0; outline: none; overflow: hidden; opacity: .05; filter: alpha(opacity=5);";var h;if(ml&&(h=window.scrollY),o.input.focus(),ml&&window.scrollTo(null,h),o.input.reset(),i.somethingSelected()||(l.value=n.prevInput=" "),n.contextMenuPending=!0,o.selForContextMenu=i.doc.sel,clearTimeout(o.detectingSelectAll),gl&&vl>=9&&t(),Hl){Fe(e);var d=function(){ke(window,"mouseup",d),setTimeout(r,20)};Ql(window,"mouseup",d)}else setTimeout(r,50)}},Qs.prototype.readOnlyChanged=function(e){e||this.reset(),this.textarea.disabled="nocursor"==e},Qs.prototype.setUneditable=function(){},Qs.prototype.needsContentAttribute=!1,function(e){function t(t,n,i,o){e.defaults[t]=n,i&&(r[t]=o?function(e,t,r){r!=Xs&&i(e,t,r)}:i)}var r=e.optionHandlers;e.defineOption=t,e.Init=Xs,t("value","",function(e,t){return e.setValue(t)},!0),t("mode",null,function(e,t){e.doc.modeOption=t,jn(e)},!0),t("indentUnit",2,jn,!0),t("indentWithTabs",!1),t("smartIndent",!0),t("tabSize",4,function(e){Xn(e),er(e),vn(e)},!0),t("lineSeparator",null,function(e,t){if(e.doc.lineSep=t,t){var r=[],n=e.doc.first;e.doc.iter(function(e){for(var i=0;;){var o=e.text.indexOf(t,i);if(-1==o)break;i=o+t.length,r.push(E(n,o))}n++});for(var i=r.length-1;i>=0;i--)Ei(e.doc,t,r[i],E(r[i].line,r[i].ch+t.length))}}),t("specialChars",/[\u0000-\u001f\u007f-\u009f\u00ad\u061c\u200b-\u200f\u2028\u2029\ufeff]/g,function(e,t,r){e.state.specialChars=new RegExp(t.source+(t.test("\t")?"":"|\t"),"g"),r!=Xs&&e.refresh()}),t("specialCharPlaceholder",at,function(e){return e.refresh()},!0),t("electricChars",!0),t("inputStyle",Tl?"contenteditable":"textarea",function(){throw new Error("inputStyle can not (yet) be changed in a running editor")},!0),t("spellcheck",!1,function(e,t){return e.getInputField().spellcheck=t},!0),t("rtlMoveVisually",!Ol),t("wholeLineUpdateBefore",!0),t("theme","default",function(e){Go(e),Uo(e)},!0),t("keyMap","default",function(e,t,r){var n=uo(t),i=r!=Xs&&uo(r);i&&i.detach&&i.detach(e,n),n.attach&&n.attach(e,i||null)}),t("extraKeys",null),t("configureMouse",null),t("lineWrapping",!1,Ko,!0),t("gutters",[],function(e){Fn(e.options),Uo(e)},!0),t("fixedGutter",!0,function(e,t){e.display.gutters.style.left=t?wr(e.display)+"px":"0",e.refresh()},!0),t("coverGutterNextToScrollbar",!1,function(e){return en(e)},!0),t("scrollbarStyle","native",function(e){rn(e),en(e),e.display.scrollbars.setScrollTop(e.doc.scrollTop),e.display.scrollbars.setScrollLeft(e.doc.scrollLeft)},!0),t("lineNumbers",!1,function(e){Fn(e.options),Uo(e)},!0),t("firstLineNumber",1,Uo,!0),t("lineNumberFormatter",function(e){return e},Uo,!0),t("showCursorWhenSelecting",!1,kr,!0),t("resetSelectionOnContextMenu",!0),t("lineWiseCopyCut",!0),t("pasteLinesPerSelection",!0),t("readOnly",!1,function(e,t){"nocursor"==t&&(Fr(e),e.display.input.blur()),e.display.input.readOnlyChanged(t)}),t("disableInput",!1,function(e,t){t||e.display.input.reset()},!0),t("dragDrop",!0,Vo),t("allowDropFileTypes",null),t("cursorBlinkRate",530),t("cursorScrollMargin",0),t("cursorHeight",1,kr,!0),t("singleCursorHeightPerLine",!0,kr,!0),t("workTime",100),t("workDelay",100),t("flattenSpans",!0,Xn,!0),t("addModeClass",!1,Xn,!0),t("pollInterval",100),t("undoDepth",200,function(e,t){return e.doc.history.undoDepth=t}),t("historyEventDelay",1250),t("viewportMargin",10,function(e){return e.refresh()},!0),t("maxHighlightLength",1e4,Xn,!0),t("moveInputWithCursor",!0,function(e,t){t||e.display.input.resetPosition()}),t("tabindex",null,function(e,t){return e.display.input.getField().tabIndex=t||""}),t("autofocus",null),t("direction","ltr",function(e,t){return e.doc.setDirection(t)},!0)}(jo),function(e){var t=e.optionHandlers,r=e.helpers={};e.prototype={constructor:e,focus:function(){window.focus(),this.display.input.focus()},setOption:function(e,r){var n=this.options,i=n[e];n[e]==r&&"mode"!=e||(n[e]=r,t.hasOwnProperty(e)&&dn(this,t[e])(this,r,i),Te(this,"optionChange",this,e))},getOption:function(e){return this.options[e]},getDoc:function(){return this.doc},addKeyMap:function(e,t){this.state.keyMaps[t?"push":"unshift"](uo(e))},removeKeyMap:function(e){for(var t=this.state.keyMaps,r=0;r<t.length;++r)if(t[r]==e||t[r].name==e)return t.splice(r,1),!0},addOverlay:pn(function(t,r){var n=t.token?t:e.getMode(this.options,t);if(n.startState)throw new Error("Overlays may not be stateful.");m(this.state.overlays,{mode:n,modeSpec:t,opaque:r&&r.opaque,priority:r&&r.priority||0},function(e){return e.priority}),this.state.modeGen++,vn(this)}),removeOverlay:pn(function(e){for(var t=this,r=this.state.overlays,n=0;n<r.length;++n){var i=r[n].modeSpec;if(i==e||"string"==typeof e&&i.name==e)return r.splice(n,1),t.state.modeGen++,void vn(t)}}),indentLine:pn(function(e,t,r){"string"!=typeof t&&"number"!=typeof t&&(t=null==t?this.options.smartIndent?"smart":"prev":t?"add":"subtract"),H(this.doc,e)&&Yo(this,e,t,r)}),indentSelection:pn(function(e){for(var t=this,r=this.doc.sel.ranges,n=-1,i=0;i<r.length;i++){var o=r[i];if(o.empty())o.head.line>n&&(Yo(t,o.head.line,e,!0),n=o.head.line,i==t.doc.sel.primIndex&&jr(t));else{var l=o.from(),s=o.to(),a=Math.max(n,l.line);n=Math.min(t.lastLine(),s.line-(s.ch?0:1))+1;for(var u=a;u<n;++u)Yo(t,u,e);var c=t.doc.sel.ranges;0==l.ch&&r.length==c.length&&c[i].from().ch>0&&gi(t.doc,i,new Ts(l,c[i].to()),Gl)}}}),getTokenAt:function(e,t){return Je(this,e,t)},getLineTokens:function(e,t){return Je(this,E(e),t,!0)},getTokenTypeAt:function(e){e=U(this.doc,e);var t,r=_e(this,M(this.doc,e.line)),n=0,i=(r.length-1)/2,o=e.ch;if(0==o)t=r[2];else for(;;){var l=n+i>>1;if((l?r[2*l-1]:0)>=o)i=l;else{if(!(r[2*l+1]<o)){t=r[2*l+2];break}n=l+1}}var s=t?t.indexOf("overlay "):-1;return s<0?t:0==s?null:t.slice(0,s-1)},getModeAt:function(t){var r=this.doc.mode;return r.innerMode?e.innerMode(r,this.getTokenAt(t).state).mode:r},getHelper:function(e,t){return this.getHelpers(e,t)[0]},getHelpers:function(e,t){var n=this,i=[];if(!r.hasOwnProperty(t))return i;var o=r[t],l=this.getModeAt(e);if("string"==typeof l[t])o[l[t]]&&i.push(o[l[t]]);else if(l[t])for(var s=0;s<l[t].length;s++){var a=o[l[t][s]];a&&i.push(a)}else l.helperType&&o[l.helperType]?i.push(o[l.helperType]):o[l.name]&&i.push(o[l.name]);for(var u=0;u<o._global.length;u++){var c=o._global[u];c.pred(l,n)&&-1==h(i,c.val)&&i.push(c.val)}return i},getStateAfter:function(e,t){var r=this.doc;return e=G(r,null==e?r.first+r.size-1:e),$e(this,e+1,t).state},cursorCoords:function(e,t){var r,n=this.doc.sel.primary();return r=null==e?n.head:"object"==typeof e?U(this.doc,e):e?n.from():n.to(),sr(this,r,t||"page")},charCoords:function(e,t){return lr(this,U(this.doc,e),t||"page")},coordsChar:function(e,t){return e=or(this,e,t||"page"),cr(this,e.left,e.top)},lineAtHeight:function(e,t){return e=or(this,{top:e,left:0},t||"page").top,D(this.doc,e+this.display.viewOffset)},heightAtLine:function(e,t,r){var n,i=!1;if("number"==typeof e){var o=this.doc.first+this.doc.size-1;e<this.doc.first?e=this.doc.first:e>o&&(e=o,i=!0),n=M(this.doc,e)}else n=e;return ir(this,n,{top:0,left:0},t||"page",r||i).top+(i?this.doc.height-ye(n):0)},defaultTextHeight:function(){return mr(this.display)},defaultCharWidth:function(){return yr(this.display)},getViewport:function(){return{from:this.display.viewFrom,to:this.display.viewTo}},addWidget:function(e,t,r,n,i){var o=this.display,l=(e=sr(this,U(this.doc,e))).bottom,s=e.left;if(t.style.position="absolute",t.setAttribute("cm-ignore-events","true"),this.display.input.setUneditable(t),o.sizer.appendChild(t),"over"==n)l=e.top;else if("above"==n||"near"==n){var a=Math.max(o.wrapper.clientHeight,this.doc.height),u=Math.max(o.sizer.clientWidth,o.lineSpace.clientWidth);("above"==n||e.bottom+t.offsetHeight>a)&&e.top>t.offsetHeight?l=e.top-t.offsetHeight:e.bottom+t.offsetHeight<=a&&(l=e.bottom),s+t.offsetWidth>u&&(s=u-t.offsetWidth)}t.style.top=l+"px",t.style.left=t.style.right="","right"==i?(s=o.sizer.clientWidth-t.offsetWidth,t.style.right="0px"):("left"==i?s=0:"middle"==i&&(s=(o.sizer.clientWidth-t.offsetWidth)/2),t.style.left=s+"px"),r&&Ur(this,{left:s,top:l,right:s+t.offsetWidth,bottom:l+t.offsetHeight})},triggerOnKeyDown:pn(Lo),triggerOnKeyPress:pn(Mo),triggerOnKeyUp:To,triggerOnMouseDown:pn(Oo),execCommand:function(e){if(Bs.hasOwnProperty(e))return Bs[e].call(null,this)},triggerElectric:pn(function(e){Zo(this,e)}),findPosH:function(e,t,r,n){var i=this,o=1;t<0&&(o=-1,t=-t);for(var l=U(this.doc,e),s=0;s<t&&!(l=tl(i.doc,l,o,r,n)).hitSide;++s);return l},moveH:pn(function(e,t){var r=this;this.extendSelectionsBy(function(n){return r.display.shift||r.doc.extend||n.empty()?tl(r.doc,n.head,e,t,r.options.rtlMoveVisually):e<0?n.from():n.to()},Vl)}),deleteH:pn(function(e,t){var r=this.doc.sel,n=this.doc;r.somethingSelected()?n.replaceSelection("",null,"+delete"):co(this,function(r){var i=tl(n,r.head,e,t,!1);return e<0?{from:i,to:r.head}:{from:r.head,to:i}})}),findPosV:function(e,t,r,n){var i=this,o=1,l=n;t<0&&(o=-1,t=-t);for(var s=U(this.doc,e),a=0;a<t;++a){var u=sr(i,s,"div");if(null==l?l=u.left:u.left=l,(s=rl(i,u,o,r)).hitSide)break}return s},moveV:pn(function(e,t){var r=this,n=this.doc,i=[],o=!this.display.shift&&!n.extend&&n.sel.somethingSelected();if(n.extendSelectionsBy(function(l){if(o)return e<0?l.from():l.to();var s=sr(r,l.head,"div");null!=l.goalColumn&&(s.left=l.goalColumn),i.push(s.left);var a=rl(r,s,e,t);return"page"==t&&l==n.sel.primary()&&Kr(r,lr(r,a,"div").top-s.top),a},Vl),i.length)for(var l=0;l<n.sel.ranges.length;l++)n.sel.ranges[l].goalColumn=i[l]}),findWordAt:function(e){var t=M(this.doc,e.line).text,r=e.ch,n=e.ch;if(t){var i=this.getHelper(e,"wordChars");"before"!=e.sticky&&n!=t.length||!r?++n:--r;for(var o=t.charAt(r),l=x(o,i)?function(e){return x(e,i)}:/\s/.test(o)?function(e){return/\s/.test(e)}:function(e){return!/\s/.test(e)&&!x(e)};r>0&&l(t.charAt(r-1));)--r;for(;n<t.length&&l(t.charAt(n));)++n}return new Ts(E(e.line,r),E(e.line,n))},toggleOverwrite:function(e){null!=e&&e==this.state.overwrite||((this.state.overwrite=!this.state.overwrite)?s(this.display.cursorDiv,"CodeMirror-overwrite"):Fl(this.display.cursorDiv,"CodeMirror-overwrite"),Te(this,"overwriteToggle",this,this.state.overwrite))},hasFocus:function(){return this.display.input.getField()==l()},isReadOnly:function(){return!(!this.options.readOnly&&!this.doc.cantEdit)},scrollTo:pn(function(e,t){Xr(this,e,t)}),getScrollInfo:function(){var e=this.display.scroller;return{left:e.scrollLeft,top:e.scrollTop,height:e.scrollHeight-zt(this)-this.display.barHeight,width:e.scrollWidth-zt(this)-this.display.barWidth,clientHeight:Bt(this),clientWidth:Rt(this)}},scrollIntoView:pn(function(e,t){null==e?(e={from:this.doc.sel.primary().head,to:null},null==t&&(t=this.options.cursorScrollMargin)):"number"==typeof e?e={from:E(e,0),to:null}:null==e.from&&(e={from:e,to:null}),e.to||(e.to=e.from),e.margin=t||0,null!=e.from.line?Yr(this,e):$r(this,e.from,e.to,e.margin)}),setSize:pn(function(e,t){var r=this,n=function(e){return"number"==typeof e||/^\d+$/.test(String(e))?e+"px":e};null!=e&&(this.display.wrapper.style.width=n(e)),null!=t&&(this.display.wrapper.style.height=n(t)),this.options.lineWrapping&&Jt(this);var i=this.display.viewFrom;this.doc.iter(i,this.display.viewTo,function(e){if(e.widgets)for(var t=0;t<e.widgets.length;t++)if(e.widgets[t].noHScroll){mn(r,i,"widget");break}++i}),this.curOp.forceUpdate=!0,Te(this,"refresh",this)}),operation:function(e){return hn(this,e)},startOperation:function(){return nn(this)},endOperation:function(){return on(this)},refresh:pn(function(){var e=this.display.cachedTextHeight;vn(this),this.curOp.forceUpdate=!0,er(this),Xr(this,this.doc.scrollLeft,this.doc.scrollTop),Wn(this),(null==e||Math.abs(e-mr(this.display))>.5)&&Cr(this),Te(this,"refresh",this)}),swapDoc:pn(function(e){var t=this.doc;return t.cm=null,qn(this,e),er(this),this.display.input.reset(),Xr(this,e.scrollLeft,e.scrollTop),this.curOp.forceScroll=!0,bt(this,"swapDoc",this,t),t}),getInputField:function(){return this.display.input.getField()},getWrapperElement:function(){return this.display.wrapper},getScrollerElement:function(){return this.display.scroller},getGutterElement:function(){return this.display.gutters}},Ae(e),e.registerHelper=function(t,n,i){r.hasOwnProperty(t)||(r[t]=e[t]={_global:[]}),r[t][n]=i},e.registerGlobalHelper=function(t,n,i,o){e.registerHelper(t,n,o),r[t]._global.push({pred:i,val:o})}}(jo);var Js="iter insert remove copy getEditor constructor".split(" ");for(var ea in Ds.prototype)Ds.prototype.hasOwnProperty(ea)&&h(Js,ea)<0&&(jo.prototype[ea]=function(e){return function(){return e.apply(this.doc,arguments)}}(Ds.prototype[ea]));return Ae(Ds),jo.inputStyles={textarea:Qs,contenteditable:Zs},jo.defineMode=function(e){jo.defaults.mode||"null"==e||(jo.defaults.mode=e),Be.apply(this,arguments)},jo.defineMIME=function(e,t){os[e]=t},jo.defineMode("null",function(){return{token:function(e){return e.skipToEnd()}}}),jo.defineMIME("text/plain","null"),jo.defineExtension=function(e,t){jo.prototype[e]=t},jo.defineDocExtension=function(e,t){Ds.prototype[e]=t},jo.fromTextArea=function(e,t){function r(){e.value=a.getValue()}if(t=t?c(t):{},t.value=e.value,!t.tabindex&&e.tabIndex&&(t.tabindex=e.tabIndex),!t.placeholder&&e.placeholder&&(t.placeholder=e.placeholder),null==t.autofocus){var n=l();t.autofocus=n==e||null!=e.getAttribute("autofocus")&&n==document.body}var i;if(e.form&&(Ql(e.form,"submit",r),!t.leaveSubmitMethodAlone)){var o=e.form;i=o.submit;try{var s=o.submit=function(){r(),o.submit=i,o.submit(),o.submit=s}}catch(e){}}t.finishInit=function(t){t.save=r,t.getTextArea=function(){return e},t.toTextArea=function(){t.toTextArea=isNaN,r(),e.parentNode.removeChild(t.getWrapperElement()),e.style.display="",e.form&&(ke(e.form,"submit",r),"function"==typeof e.form.submit&&(e.form.submit=i))}},e.style.display="none";var a=jo(function(t){return e.parentNode.insertBefore(t,e.nextSibling)},t);return a},function(e){e.off=ke,e.on=Ql,e.wheelEventPixels=Pn,e.Doc=Ds,e.splitLines=es,e.countColumn=f,e.findColumn=d,e.isWordChar=w,e.Pass=Bl,e.signal=Te,e.Line=fs,e.changeEnd=Bn,e.scrollbarModel=ws,e.Pos=E,e.cmpPos=P,e.modes=is,e.mimeModes=os,e.resolveMode=Ge,e.getMode=Ue,e.modeExtensions=ls,e.extendMode=Ve,e.copyState=Ke,e.startState=Xe,e.innerMode=je,e.commands=Bs,e.keyMap=Rs,e.keyName=ao,e.isModifierKey=lo,e.lookupKey=oo,e.normalizeKeyMap=io,e.StringStream=ss,e.SharedTextMarker=As,e.TextMarker=Os,e.LineWidget=Ms,e.e_preventDefault=We,e.e_stopPropagation=De,e.e_stop=Fe,e.addClass=s,e.contains=o,e.rmClass=Fl,e.keyNames=Es}(jo),jo.version="5.30.0",jo});
      !function(e){"object"==typeof exports&&"object"==typeof module?e(require("../../lib/codemirror")):"function"==typeof define&&define.amd?define(["../../lib/codemirror"],e):e(CodeMirror)}(function(e){"use strict";function t(e,t,n,r,o,a){this.indented=e,this.column=t,this.type=n,this.info=r,this.align=o,this.prev=a}function n(e,n,r,o){var a=e.indented;return e.context&&"statement"==e.context.type&&"statement"!=r&&(a=e.context.indented),e.context=new t(a,n,r,o,null,e.context)}function r(e){var t=e.context.type;return")"!=t&&"]"!=t&&"}"!=t||(e.indented=e.context.indented),e.context=e.context.prev}function o(e,t,n){return"variable"==t.prevToken||"type"==t.prevToken||(!!/\S(?:[^- ]>|[*\]])\s*$|\*$/.test(e.string.slice(0,n))||(!(!t.typeAtEndOfLine||e.column()!=e.indentation())||void 0))}function a(e){for(;;){if(!e||"top"==e.type)return!0;if("}"==e.type&&"namespace"!=e.prev.info)return!1;e=e.prev}}function i(e){for(var t={},n=e.split(" "),r=0;r<n.length;++r)t[n[r]]=!0;return t}function l(e,t){return"function"==typeof e?e(t):e.propertyIsEnumerable(t)}function s(e,t){if(!t.startOfLine)return!1;for(var n,r=null;n=e.peek();){if("\\"==n&&e.match(/^.$/)){r=s;break}if("/"==n&&e.match(/^\/[\/\*]/,!1))break;e.next()}return t.tokenize=r,"meta"}function c(e,t){return"type"==t.prevToken&&"type"}function u(e){return e.eatWhile(/[\w\.']/),"number"}function d(e,t){if(e.backUp(1),e.match(/(R|u8R|uR|UR|LR)/)){var n=e.match(/"([^\s\\()]{0,16})\(/);return!!n&&(t.cpp11RawStringDelim=n[1],t.tokenize=m,m(e,t))}return e.match(/(u8|u|U|L)/)?!!e.match(/["']/,!1)&&"string":(e.next(),!1)}function f(e){var t=/(\w+)::~?(\w+)$/.exec(e);return t&&t[1]==t[2]}function p(e,t){for(var n;null!=(n=e.next());)if('"'==n&&!e.eat('"')){t.tokenize=null;break}return"string"}function m(e,t){var n=t.cpp11RawStringDelim.replace(/[^\w\s]/g,"\\$&");return e.match(new RegExp(".*?\\)"+n+'"'))?t.tokenize=null:e.skipToEnd(),"string"}function h(t,n){function r(e){if(e)for(var t in e)e.hasOwnProperty(t)&&o.push(t)}"string"==typeof t&&(t=[t]);var o=[];r(n.keywords),r(n.types),r(n.builtin),r(n.atoms),o.length&&(n.helperType=t[0],e.registerHelper("hintWords",t[0],o));for(var a=0;a<t.length;++a)e.defineMIME(t[a],n)}function g(e,t){for(var n=!1;!e.eol();){if(!n&&e.match('"""')){t.tokenize=null;break}n="\\"==e.next()&&!n}return"string"}function y(e){return function(t,n){for(var r,o=!1,a=!1;!t.eol();){if(!e&&!o&&t.match('"')){a=!0;break}if(e&&t.match('"""')){a=!0;break}r=t.next(),!o&&"$"==r&&t.match("{")&&t.skipTo("}"),o=!o&&"\\"==r&&!e}return!a&&e||(n.tokenize=null),"string"}}function x(e){return function(t,n){for(var r,o=!1,a=!1;!t.eol();){if(!o&&t.match('"')&&("single"==e||t.match('""'))){a=!0;break}if(!o&&t.match("``")){w=x(e),a=!0;break}r=t.next(),o="single"==e&&!o&&"\\"==r}return a&&(n.tokenize=null),"string"}}e.defineMode("clike",function(i,s){function c(e,t){var n=e.next();if(S[n]){var r=S[n](e,t);if(!1!==r)return r}if('"'==n||"'"==n)return t.tokenize=u(n),t.tokenize(e,t);if(D.test(n))return p=n,null;if(L.test(n)){if(e.backUp(1),e.match(I))return"number";e.next()}if("/"==n){if(e.eat("*"))return t.tokenize=d,d(e,t);if(e.eat("/"))return e.skipToEnd(),"comment"}if(F.test(n)){for(;!e.match(/^\/[\/*]/,!1)&&e.eat(F););return"operator"}if(e.eatWhile(z),P)for(;e.match(P);)e.eatWhile(z);var o=e.current();return l(x,o)?(l(w,o)&&(p="newstatement"),l(v,o)&&(m=!0),"keyword"):l(b,o)?"type":l(k,o)?(l(w,o)&&(p="newstatement"),"builtin"):l(_,o)?"atom":"variable"}function u(e){return function(t,n){for(var r,o=!1,a=!1;null!=(r=t.next());){if(r==e&&!o){a=!0;break}o=!o&&"\\"==r}return(a||!o&&!C)&&(n.tokenize=null),"string"}}function d(e,t){for(var n,r=!1;n=e.next();){if("/"==n&&r){t.tokenize=null;break}r="*"==n}return"comment"}function f(e,t){s.typeFirstDefinitions&&e.eol()&&a(t.context)&&(t.typeAtEndOfLine=o(e,t,e.pos))}var p,m,h=i.indentUnit,g=s.statementIndentUnit||h,y=s.dontAlignCalls,x=s.keywords||{},b=s.types||{},k=s.builtin||{},w=s.blockKeywords||{},v=s.defKeywords||{},_=s.atoms||{},S=s.hooks||{},C=s.multiLineStrings,T=!1!==s.indentStatements,M=!1!==s.indentSwitch,P=s.namespaceSeparator,D=s.isPunctuationChar||/[\[\]{}\(\),;\:\.]/,L=s.numberStart||/[\d\.]/,I=s.number||/^(?:0x[a-f\d]+|0b[01]+|(?:\d+\.?\d*|\.\d+)(?:e[-+]?\d+)?)(u|ll?|l|f)?/i,F=s.isOperatorChar||/[+\-*&%=<>!?|\/]/,z=s.isIdentifierChar||/[\w\$_\xa1-\uffff]/;return{startState:function(e){return{tokenize:null,context:new t((e||0)-h,0,"top",null,!1),indented:0,startOfLine:!0,prevToken:null}},token:function(e,t){var i=t.context;if(e.sol()&&(null==i.align&&(i.align=!1),t.indented=e.indentation(),t.startOfLine=!0),e.eatSpace())return f(e,t),null;p=m=null;var l=(t.tokenize||c)(e,t);if("comment"==l||"meta"==l)return l;if(null==i.align&&(i.align=!0),";"==p||":"==p||","==p&&e.match(/^\s*(?:\/\/.*)?$/,!1))for(;"statement"==t.context.type;)r(t);else if("{"==p)n(t,e.column(),"}");else if("["==p)n(t,e.column(),"]");else if("("==p)n(t,e.column(),")");else if("}"==p){for(;"statement"==i.type;)i=r(t);for("}"==i.type&&(i=r(t));"statement"==i.type;)i=r(t)}else p==i.type?r(t):T&&(("}"==i.type||"top"==i.type)&&";"!=p||"statement"==i.type&&"newstatement"==p)&&n(t,e.column(),"statement",e.current());if("variable"==l&&("def"==t.prevToken||s.typeFirstDefinitions&&o(e,t,e.start)&&a(t.context)&&e.match(/^\s*\(/,!1))&&(l="def"),S.token){var u=S.token(e,t,l);void 0!==u&&(l=u)}return"def"==l&&!1===s.styleDefs&&(l="variable"),t.startOfLine=!1,t.prevToken=m?"def":l||p,f(e,t),l},indent:function(t,n){if(t.tokenize!=c&&null!=t.tokenize||t.typeAtEndOfLine)return e.Pass;var r=t.context,o=n&&n.charAt(0);if("statement"==r.type&&"}"==o&&(r=r.prev),s.dontIndentStatements)for(;"statement"==r.type&&s.dontIndentStatements.test(r.info);)r=r.prev;if(S.indent){var a=S.indent(t,r,n);if("number"==typeof a)return a}var i=o==r.type,l=r.prev&&"switch"==r.prev.info;if(s.allmanIndentation&&/[{(]/.test(o)){for(;"top"!=r.type&&"}"!=r.type;)r=r.prev;return r.indented}return"statement"==r.type?r.indented+("{"==o?0:g):!r.align||y&&")"==r.type?")"!=r.type||i?r.indented+(i?0:h)+(i||!l||/^(?:case|default)\b/.test(n)?0:h):r.indented+g:r.column+(i?0:1)},electricInput:M?/^\s*(?:case .*?:|default:|\{\}?|\})$/:/^\s*[{}]$/,blockCommentStart:"/*",blockCommentEnd:"*/",lineComment:"//",fold:"brace"}});var b="auto if break case register continue return default do sizeof static else struct switch extern typedef union for goto while enum const volatile",k="int long char short double float unsigned signed void size_t ptrdiff_t";h(["text/x-csrc","text/x-c","text/x-chdr"],{name:"clike",keywords:i(b),types:i(k+" bool _Complex _Bool float_t double_t intptr_t intmax_t int8_t int16_t int32_t int64_t uintptr_t uintmax_t uint8_t uint16_t uint32_t uint64_t"),blockKeywords:i("case do else for if switch while struct"),defKeywords:i("struct"),typeFirstDefinitions:!0,atoms:i("null true false"),hooks:{"#":s,"*":c},modeProps:{fold:["brace","include"]}}),h(["text/x-c++src","text/x-c++hdr"],{name:"clike",keywords:i(b+" asm dynamic_cast namespace reinterpret_cast try explicit new static_cast typeid catch operator template typename class friend private this using const_cast inline public throw virtual delete mutable protected alignas alignof constexpr decltype nullptr noexcept thread_local final static_assert override"),types:i(k+" bool wchar_t"),blockKeywords:i("catch class do else finally for if struct switch try while"),defKeywords:i("class namespace struct enum union"),typeFirstDefinitions:!0,atoms:i("true false null"),dontIndentStatements:/^template$/,isIdentifierChar:/[\w\$_~\xa1-\uffff]/,hooks:{"#":s,"*":c,u:d,U:d,L:d,R:d,0:u,1:u,2:u,3:u,4:u,5:u,6:u,7:u,8:u,9:u,token:function(e,t,n){if("variable"==n&&"("==e.peek()&&(";"==t.prevToken||null==t.prevToken||"}"==t.prevToken)&&f(e.current()))return"def"}},namespaceSeparator:"::",modeProps:{fold:["brace","include"]}}),h("text/x-java",{name:"clike",keywords:i("abstract assert break case catch class const continue default do else enum extends final finally float for goto if implements import instanceof interface native new package private protected public return static strictfp super switch synchronized this throw throws transient try volatile while @interface"),types:i("byte short int long float double boolean char void Boolean Byte Character Double Float Integer Long Number Object Short String StringBuffer StringBuilder Void"),blockKeywords:i("catch class do else finally for if switch try while"),defKeywords:i("class interface package enum @interface"),typeFirstDefinitions:!0,atoms:i("true false null"),number:/^(?:0x[a-f\d_]+|0b[01_]+|(?:[\d_]+\.?\d*|\.\d+)(?:e[-+]?[\d_]+)?)(u|ll?|l|f)?/i,hooks:{"@":function(e){return!e.match("interface",!1)&&(e.eatWhile(/[\w\$_]/),"meta")}},modeProps:{fold:["brace","import"]}}),h("text/x-csharp",{name:"clike",keywords:i("abstract as async await base break case catch checked class const continue default delegate do else enum event explicit extern finally fixed for foreach goto if implicit in interface internal is lock namespace new operator out override params private protected public readonly ref return sealed sizeof stackalloc static struct switch this throw try typeof unchecked unsafe using virtual void volatile while add alias ascending descending dynamic from get global group into join let orderby partial remove select set value var yield"),types:i("Action Boolean Byte Char DateTime DateTimeOffset Decimal Double Func Guid Int16 Int32 Int64 Object SByte Single String Task TimeSpan UInt16 UInt32 UInt64 bool byte char decimal double short int long object sbyte float string ushort uint ulong"),blockKeywords:i("catch class do else finally for foreach if struct switch try while"),defKeywords:i("class interface namespace struct var"),typeFirstDefinitions:!0,atoms:i("true false null"),hooks:{"@":function(e,t){return e.eat('"')?(t.tokenize=p,p(e,t)):(e.eatWhile(/[\w\$_]/),"meta")}}}),h("text/x-scala",{name:"clike",keywords:i("abstract case catch class def do else extends final finally for forSome if implicit import lazy match new null object override package private protected return sealed super this throw trait try type val var while with yield _ assert assume require print println printf readLine readBoolean readByte readShort readChar readInt readLong readFloat readDouble"),types:i("AnyVal App Application Array BufferedIterator BigDecimal BigInt Char Console Either Enumeration Equiv Error Exception Fractional Function IndexedSeq Int Integral Iterable Iterator List Map Numeric Nil NotNull Option Ordered Ordering PartialFunction PartialOrdering Product Proxy Range Responder Seq Serializable Set Specializable Stream StringBuilder StringContext Symbol Throwable Traversable TraversableOnce Tuple Unit Vector Boolean Byte Character CharSequence Class ClassLoader Cloneable Comparable Compiler Double Exception Float Integer Long Math Number Object Package Pair Process Runtime Runnable SecurityManager Short StackTraceElement StrictMath String StringBuffer System Thread ThreadGroup ThreadLocal Throwable Triple Void"),multiLineStrings:!0,blockKeywords:i("catch class enum do else finally for forSome if match switch try while"),defKeywords:i("class enum def object package trait type val var"),atoms:i("true false null"),indentStatements:!1,indentSwitch:!1,isOperatorChar:/[+\-*&%=<>!?|\/#:@]/,hooks:{"@":function(e){return e.eatWhile(/[\w\$_]/),"meta"},'"':function(e,t){return!!e.match('""')&&(t.tokenize=g,t.tokenize(e,t))},"'":function(e){return e.eatWhile(/[\w\$_\xa1-\uffff]/),"atom"},"=":function(e,n){var r=n.context;return!("}"!=r.type||!r.align||!e.eat(">"))&&(n.context=new t(r.indented,r.column,r.type,r.info,null,r.prev),"operator")}},modeProps:{closeBrackets:{triples:'"'}}}),h("text/x-kotlin",{name:"clike",keywords:i("package as typealias class interface this super val var fun for is in This throw return break continue object if else while do try when !in !is as? file import where by get set abstract enum open inner override private public internal protected catch finally out final vararg reified dynamic companion constructor init sealed field property receiver param sparam lateinit data inline noinline tailrec external annotation crossinline const operator infix suspend"),types:i("Boolean Byte Character CharSequence Class ClassLoader Cloneable Comparable Compiler Double Exception Float Integer Long Math Number Object Package Pair Process Runtime Runnable SecurityManager Short StackTraceElement StrictMath String StringBuffer System Thread ThreadGroup ThreadLocal Throwable Triple Void"),intendSwitch:!1,indentStatements:!1,multiLineStrings:!0,number:/^(?:0x[a-f\d_]+|0b[01_]+|(?:[\d_]+\.?\d*|\.\d+)(?:e[-+]?[\d_]+)?)(u|ll?|l|f)?/i,blockKeywords:i("catch class do else finally for if where try while enum"),defKeywords:i("class val var object package interface fun"),atoms:i("true false null this"),hooks:{'"':function(e,t){return t.tokenize=y(e.match('""')),t.tokenize(e,t)}},modeProps:{closeBrackets:{triples:'"'}}}),h(["x-shader/x-vertex","x-shader/x-fragment"],{name:"clike",keywords:i("sampler1D sampler2D sampler3D samplerCube sampler1DShadow sampler2DShadow const attribute uniform varying break continue discard return for while do if else struct in out inout"),types:i("float int bool void vec2 vec3 vec4 ivec2 ivec3 ivec4 bvec2 bvec3 bvec4 mat2 mat3 mat4"),blockKeywords:i("for while do if else struct"),builtin:i("radians degrees sin cos tan asin acos atan pow exp log exp2 sqrt inversesqrt abs sign floor ceil fract mod min max clamp mix step smoothstep length distance dot cross normalize ftransform faceforward reflect refract matrixCompMult lessThan lessThanEqual greaterThan greaterThanEqual equal notEqual any all not texture1D texture1DProj texture1DLod texture1DProjLod texture2D texture2DProj texture2DLod texture2DProjLod texture3D texture3DProj texture3DLod texture3DProjLod textureCube textureCubeLod shadow1D shadow2D shadow1DProj shadow2DProj shadow1DLod shadow2DLod shadow1DProjLod shadow2DProjLod dFdx dFdy fwidth noise1 noise2 noise3 noise4"),atoms:i("true false gl_FragColor gl_SecondaryColor gl_Normal gl_Vertex gl_MultiTexCoord0 gl_MultiTexCoord1 gl_MultiTexCoord2 gl_MultiTexCoord3 gl_MultiTexCoord4 gl_MultiTexCoord5 gl_MultiTexCoord6 gl_MultiTexCoord7 gl_FogCoord gl_PointCoord gl_Position gl_PointSize gl_ClipVertex gl_FrontColor gl_BackColor gl_FrontSecondaryColor gl_BackSecondaryColor gl_TexCoord gl_FogFragCoord gl_FragCoord gl_FrontFacing gl_FragData gl_FragDepth gl_ModelViewMatrix gl_ProjectionMatrix gl_ModelViewProjectionMatrix gl_TextureMatrix gl_NormalMatrix gl_ModelViewMatrixInverse gl_ProjectionMatrixInverse gl_ModelViewProjectionMatrixInverse gl_TexureMatrixTranspose gl_ModelViewMatrixInverseTranspose gl_ProjectionMatrixInverseTranspose gl_ModelViewProjectionMatrixInverseTranspose gl_TextureMatrixInverseTranspose gl_NormalScale gl_DepthRange gl_ClipPlane gl_Point gl_FrontMaterial gl_BackMaterial gl_LightSource gl_LightModel gl_FrontLightModelProduct gl_BackLightModelProduct gl_TextureColor gl_EyePlaneS gl_EyePlaneT gl_EyePlaneR gl_EyePlaneQ gl_FogParameters gl_MaxLights gl_MaxClipPlanes gl_MaxTextureUnits gl_MaxTextureCoords gl_MaxVertexAttribs gl_MaxVertexUniformComponents gl_MaxVaryingFloats gl_MaxVertexTextureImageUnits gl_MaxTextureImageUnits gl_MaxFragmentUniformComponents gl_MaxCombineTextureImageUnits gl_MaxDrawBuffers"),indentSwitch:!1,hooks:{"#":s},modeProps:{fold:["brace","include"]}}),h("text/x-nesc",{name:"clike",keywords:i(b+"as atomic async call command component components configuration event generic implementation includes interface module new norace nx_struct nx_union post provides signal task uses abstract extends"),types:i(k),blockKeywords:i("case do else for if switch while struct"),atoms:i("null true false"),hooks:{"#":s},modeProps:{fold:["brace","include"]}}),h("text/x-objectivec",{name:"clike",keywords:i(b+"inline restrict _Bool _Complex _Imaginary BOOL Class bycopy byref id IMP in inout nil oneway out Protocol SEL self super atomic nonatomic retain copy readwrite readonly"),types:i(k),atoms:i("YES NO NULL NILL ON OFF true false"),hooks:{"@":function(e){return e.eatWhile(/[\w\$]/),"keyword"},"#":s,indent:function(e,t,n){if("statement"==t.type&&/^@\w/.test(n))return t.indented}},modeProps:{fold:"brace"}}),h("text/x-squirrel",{name:"clike",keywords:i("base break clone continue const default delete enum extends function in class foreach local resume return this throw typeof yield constructor instanceof static"),types:i(k),blockKeywords:i("case catch class else for foreach if switch try while"),defKeywords:i("function local class"),typeFirstDefinitions:!0,atoms:i("true false null"),hooks:{"#":s},modeProps:{fold:["brace","include"]}});var w=null;h("text/x-ceylon",{name:"clike",keywords:i("abstracts alias assembly assert assign break case catch class continue dynamic else exists extends finally for function given if import in interface is let module new nonempty object of out outer package return satisfies super switch then this throw try value void while"),types:function(e){var t=e.charAt(0);return t===t.toUpperCase()&&t!==t.toLowerCase()},blockKeywords:i("case catch class dynamic else finally for function if interface module new object switch try while"),defKeywords:i("class dynamic function interface module object package value"),builtin:i("abstract actual aliased annotation by default deprecated doc final formal late license native optional sealed see serializable shared suppressWarnings tagged throws variable"),isPunctuationChar:/[\[\]{}\(\),;\:\.`]/,isOperatorChar:/[+\-*&%=<>!?|^~:\/]/,numberStart:/[\d#$]/,number:/^(?:#[\da-fA-F_]+|\$[01_]+|[\d_]+[kMGTPmunpf]?|[\d_]+\.[\d_]+(?:[eE][-+]?\d+|[kMGTPmunpf]|)|)/i,multiLineStrings:!0,typeFirstDefinitions:!0,atoms:i("true false null larger smaller equal empty finished"),indentSwitch:!1,styleDefs:!1,hooks:{"@":function(e){return e.eatWhile(/[\w\$_]/),"meta"},'"':function(e,t){return t.tokenize=x(e.match('""')?"triple":"single"),t.tokenize(e,t)},"`":function(e,t){return!(!w||!e.match("`"))&&(t.tokenize=w,w=null,t.tokenize(e,t))},"'":function(e){return e.eatWhile(/[\w\$_\xa1-\uffff]/),"atom"},token:function(e,t,n){if(("variable"==n||"type"==n)&&"."==t.prevToken)return"variable-2"}},modeProps:{fold:["brace","import"],closeBrackets:{triples:'"'}}})});
      // -------------------------------------------------------------------------
//  Part of the CodeChecker project, under the Apache License v2.0 with
//  LLVM Exceptions. See LICENSE for license information.
//  SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
// -------------------------------------------------------------------------

var BugViewer = {
  _files : [],
  _reports : [],
  _lineWidgets : [],
  _navigationMenuItems : [],
  _sourceFileData : null,
  _currentReport : null,
  _lastBugEvent  : null,

  init : function (files, reports) {
    this._files = files;
    this._reports = reports;

    this.initEscapeChars();
  },

  initEscapeChars : function () {
    this.escapeChars = {
      ' ' : 'nbsp',
      '<' : 'lt',
      '>' : 'gt',
      '"' : 'quot',
      '&' : 'amp'
    };

    var regexString = '[';
    for (var key in this.escapeChars) {
      regexString += key;
    }
    regexString += ']';

    this.escapeRegExp = new RegExp( regexString, 'g');
  },

  escapeHTML : function (str) {
    var that = this;

    return str.replace(this.escapeRegExp, function (m) {
      return '&' + that.escapeChars[m] + ';';
    });
  },

  initByUrl : function () {
    if (!this._reports) return;

    var state = {};
    window.location.hash.substr(1).split('&').forEach(function (s) {
      var parts = s.split('=');
      state[parts[0]] = parts[1];
    });

    for (var key in this._reports) {
      var report = this._reports[key];
      if (report.reportHash === state['reportHash']) {
        this.navigate(report);
        return;
      }
    }

    this.navigate(this._reports[0]);
  },

  create : function () {
    this._content = document.getElementById('editor-wrapper');
    this._filepath = document.getElementById('file-path');
    this._checkerName = document.getElementById('checker-name');
    this._reviewStatusWrapper =
      document.getElementById('review-status-wrapper');
    this._reviewStatus = document.getElementById('review-status');
    this._editor = document.getElementById('editor');

    this._codeMirror = CodeMirror(this._editor, {
      mode: 'text/x-c++src',
      matchBrackets : true,
      lineNumbers : true,
      readOnly : true,
      foldGutter : true,
      extraKeys : {},
      viewportMargin : 100
    });

    this._createNavigationMenu();
  },

  navigate : function (report, item) {
    if (!item) {
      var items = this._navigationMenuItems.filter(function (navItem) {
        return navItem.report.reportHash === report.reportHash;
      });

      if (!items.length) return;

      item = items[0].widget;
    }

    this._selectedReport.classList.remove('active');
    this._selectedReport = item;
    this._selectedReport.classList.add('active');
    this.setReport(report);
  },

  _createNavigationMenu : function () {
    var that = this;

    var nav = document.getElementById('report-nav');
    var list = document.createElement('ul');
    this._reports.forEach(function (report) {
      var events = report['events'];
      var lastBugEvent = events[events.length - 1];
      var item = document.createElement('li');

      var severity = document.createElement('i');
      severity.className = 'severity-' + report.severity.toLowerCase();

      item.appendChild(severity);
      item.appendChild(document.createTextNode(lastBugEvent.message));

      item.addEventListener('click', function () {
        that.navigate(report, item);
      })
      list.appendChild(item);
      that._navigationMenuItems.push({ report : report, widget : item });
    });

    if (!this._selectedReport && list.childNodes.length) {
      this._selectedReport = list.childNodes[0];
      this._selectedReport.classList.add('active');
    }

    nav.appendChild(list);
  },

  setReport : function (report) {
    this._currentReport = report;
    var events = report['events'];
    var lastBugEvent = events[events.length - 1];
    this.setCurrentBugEvent(lastBugEvent, events.length - 1);
    this.setCheckerName(report.checkerName);
    this.setReviewStatus(report.reviewStatus);

    window.location.hash = '#reportHash=' + report.reportHash;
  },

  setCurrentBugEvent : function (event, idx) {
    this._currentBugEvent = event;
    this.setSourceFileData(this._files[event.location.file]);
    this.drawBugPath();

    this.jumpTo(event.location.line, 0);
    this.highlightBugEvent(event, idx);
  },

  highlightBugEvent : function (event, idx) {
    this._lineWidgets.forEach(function (widget) {
      var lineIdx = widget.node.getAttribute('idx');
      if (parseInt(lineIdx) === idx) {
        widget.node.classList.add('current');
      }
    });
  },

  setCheckerName : function (checkerName) {
    this._checkerName.innerHTML = checkerName;
  },

  setReviewStatus : function (status) {
    if (status) {
      var className =
        'review-status-' + status.toLowerCase().split(' ').join('-');
      this._reviewStatus.className = "review-status " + className;

      this._reviewStatus.innerHTML = status;
      this._reviewStatusWrapper.style.display = 'block';
    } else {
      this._reviewStatusWrapper.style.display = 'none';
    }
  },

  setSourceFileData : function (file) {
    if (this._sourceFileData && file.id === this._sourceFileData.id) {
      return;
    }

    this._sourceFileData = file;
    this._filepath.innerHTML = file.path;
    this._codeMirror.doc.setValue(file.content);
    this._refresh();
  },

  _refresh : function () {
    var that = this;
    setTimeout(function () {
      var fullHeight = parseInt(that._content.clientHeight);
      var headerHeight = that._filepath.clientHeight;

      that._codeMirror.setSize('auto', fullHeight - headerHeight);
      that._codeMirror.refresh();
    }, 200);
  },

  clearBubbles : function () {
    this._lineWidgets.forEach(function (widget) { widget.clear(); });
    this._lineWidgets = [];
  },

  getMessage : function (event, kind) {
    if (kind === 'macro') {
      var name = 'macro expansion' + (event.name ? ': ' + event.name : '');

      return '<span class="tag macro">' + name + '</span>'
        + this.escapeHTML(event.expansion).replace(/(?:\r\n|\r|\n)/g, '<br>');
    } else if (kind === 'note') {
      return '<span class="tag note">note</span>'
        +  this.escapeHTML(event.message).replace(/(?:\r\n|\r|\n)/g, '<br>');
    }
  },

  addExtraPathEvents : function (events, kind) {
    var that = this;

    if (!events) {
      return;
    }

    events.forEach(function (event) {
      if (event.location.file !== that._currentBugEvent.location.file) {
        return;
      }

      var left =
        that._codeMirror.defaultCharWidth() * event.location.col + 'px';

      var element = document.createElement('div');
      element.setAttribute('style', 'margin-left: ' + left);
      element.setAttribute('class', 'check-msg ' + kind);

      var msg = document.createElement('span');
      msg.innerHTML = that.getMessage(event, kind);
      element.appendChild(msg);

      that._lineWidgets.push(that._codeMirror.addLineWidget(
        event.location.line - 1, element));
    });
  },

  drawBugPath : function () {
    var that = this;

    this.clearBubbles();

    this.addExtraPathEvents(this._currentReport.macros, 'macro');
    this.addExtraPathEvents(this._currentReport.notes, 'note');

    // Processing bug path events.
    var currentEvents = this._currentReport.events;
    currentEvents.forEach(function (event, step) {
      if (event.location.file !== that._currentBugEvent.location.file)
        return;

      var left =
        that._codeMirror.defaultCharWidth() * event.location.col + 'px';
      var type = step === currentEvents.length - 1 ? 'error' : 'info';

      var element = document.createElement('div');
      element.setAttribute('style', 'margin-left: ' + left);
      element.setAttribute('class', 'check-msg ' + type);
      element.setAttribute('idx', step);

      var enumeration = document.createElement('span');
      enumeration.setAttribute('class', 'checker-enum ' + type);
      enumeration.innerHTML = step + 1;

      if (currentEvents.length > 1)
        element.appendChild(enumeration);

      var prevBugEvent = step - 1;
      if (step > 0) {
        var prevBug = document.createElement('span');
        prevBug.setAttribute('class', 'arrow left-arrow');
        prevBug.addEventListener('click', function () {
          var event = currentEvents[prevBugEvent];
          that.setCurrentBugEvent(event, prevBugEvent);
        });
        element.appendChild(prevBug);
      }

      var msg = document.createElement('span');
      msg.innerHTML = that.escapeHTML(event.message)
        .replace(/(?:\r\n|\r|\n)/g, '<br>');

      element.appendChild(msg);

      var nextBugEvent = step + 1;
      if (nextBugEvent < currentEvents.length) {
        var nextBug = document.createElement('span');
        nextBug.setAttribute('class', 'arrow right-arrow');
        nextBug.addEventListener('click', function () {
          var event = currentEvents[nextBugEvent];
          that.setCurrentBugEvent(event, nextBugEvent);
        });
        element.appendChild(nextBug);
      }


      that._lineWidgets.push(that._codeMirror.addLineWidget(
        event.location.line - 1, element));
    });
  },

  jumpTo : function (line, column) {
    var that = this;

    setTimeout(function () {
      var selPosPixel
        = that._codeMirror.charCoords({ line : line, ch : column }, 'local');
      var editorSize = {
        width  : that._editor.clientWidth,
        height : that._editor.clientHeight
      };

      that._codeMirror.scrollIntoView({
        top    : selPosPixel.top - 100,
        bottom : selPosPixel.top + editorSize.height - 150,
        left   : selPosPixel.left < editorSize.width - 100
               ? 0
               : selPosPixel.left - 50,
        right  : selPosPixel.left < editorSize.width - 100
               ? 10
               : selPosPixel.left + editorSize.width - 100
      });
    }, 0);
  }
}


      var data = {"files": {"4": {"id": 4, "path": "/home/runner/work/testcc/testcc/retdec/include/curl/multi.h", "content": "#ifndef CURLINC_MULTI_H\n#define CURLINC_MULTI_H\n/***************************************************************************\n *                                  _   _ ____  _\n *  Project                     ___| | | |  _ \\| |\n *                             / __| | | | |_) | |\n *                            | (__| |_| |  _ <| |___\n *                             \\___|\\___/|_| \\_\\_____|\n *\n * Copyright (C) 1998 - 2020, Daniel Stenberg, <daniel@haxx.se>, et al.\n *\n * This software is licensed as described in the file COPYING, which\n * you should have received as part of this distribution. The terms\n * are also available at https://curl.haxx.se/docs/copyright.html.\n *\n * You may opt to use, copy, modify, merge, publish, distribute and/or sell\n * copies of the Software, and permit persons to whom the Software is\n * furnished to do so, under the terms of the COPYING file.\n *\n * This software is distributed on an \"AS IS\" basis, WITHOUT WARRANTY OF ANY\n * KIND, either express or implied.\n *\n ***************************************************************************/\n/*\n  This is an \"external\" header file. Don't give away any internals here!\n\n  GOALS\n\n  o Enable a \"pull\" interface. The application that uses libcurl decides where\n    and when to ask libcurl to get/send data.\n\n  o Enable multiple simultaneous transfers in the same thread without making it\n    complicated for the application.\n\n  o Enable the application to select() on its own file descriptors and curl's\n    file descriptors simultaneous easily.\n\n*/\n\n/*\n * This header file should not really need to include \"curl.h\" since curl.h\n * itself includes this file and we expect user applications to do #include\n * <curl/curl.h> without the need for especially including multi.h.\n *\n * For some reason we added this include here at one point, and rather than to\n * break existing (wrongly written) libcurl applications, we leave it as-is\n * but with this warning attached.\n */\n#include \"curl.h\"\n\n#ifdef  __cplusplus\nextern \"C\" {\n#endif\n\n#if defined(BUILDING_LIBCURL) || defined(CURL_STRICTER)\ntypedef struct Curl_multi CURLM;\n#else\ntypedef void CURLM;\n#endif\n\ntypedef enum {\n  CURLM_CALL_MULTI_PERFORM = -1, /* please call curl_multi_perform() or\n                                    curl_multi_socket*() soon */\n  CURLM_OK,\n  CURLM_BAD_HANDLE,      /* the passed-in handle is not a valid CURLM handle */\n  CURLM_BAD_EASY_HANDLE, /* an easy handle was not good/valid */\n  CURLM_OUT_OF_MEMORY,   /* if you ever get this, you're in deep sh*t */\n  CURLM_INTERNAL_ERROR,  /* this is a libcurl bug */\n  CURLM_BAD_SOCKET,      /* the passed in socket argument did not match */\n  CURLM_UNKNOWN_OPTION,  /* curl_multi_setopt() with unsupported option */\n  CURLM_ADDED_ALREADY,   /* an easy handle already added to a multi handle was\n                            attempted to get added - again */\n  CURLM_RECURSIVE_API_CALL, /* an api function was called from inside a\n                               callback */\n  CURLM_WAKEUP_FAILURE,  /* wakeup is unavailable or failed */\n  CURLM_BAD_FUNCTION_ARGUMENT,  /* function called with a bad parameter */\n  CURLM_LAST\n} CURLMcode;\n\n/* just to make code nicer when using curl_multi_socket() you can now check\n   for CURLM_CALL_MULTI_SOCKET too in the same style it works for\n   curl_multi_perform() and CURLM_CALL_MULTI_PERFORM */\n#define CURLM_CALL_MULTI_SOCKET CURLM_CALL_MULTI_PERFORM\n\n/* bitmask bits for CURLMOPT_PIPELINING */\n#define CURLPIPE_NOTHING   0L\n#define CURLPIPE_HTTP1     1L\n#define CURLPIPE_MULTIPLEX 2L\n\ntypedef enum {\n  CURLMSG_NONE, /* first, not used */\n  CURLMSG_DONE, /* This easy handle has completed. 'result' contains\n                   the CURLcode of the transfer */\n  CURLMSG_LAST /* last, not used */\n} CURLMSG;\n\nstruct CURLMsg {\n  CURLMSG msg;       /* what this message means */\n  CURL *easy_handle; /* the handle it concerns */\n  union {\n    void *whatever;    /* message-specific data */\n    CURLcode result;   /* return code for transfer */\n  } data;\n};\ntypedef struct CURLMsg CURLMsg;\n\n/* Based on poll(2) structure and values.\n * We don't use pollfd and POLL* constants explicitly\n * to cover platforms without poll(). */\n#define CURL_WAIT_POLLIN    0x0001\n#define CURL_WAIT_POLLPRI   0x0002\n#define CURL_WAIT_POLLOUT   0x0004\n\nstruct curl_waitfd {\n  curl_socket_t fd;\n  short events;\n  short revents; /* not supported yet */\n};\n\n/*\n * Name:    curl_multi_init()\n *\n * Desc:    inititalize multi-style curl usage\n *\n * Returns: a new CURLM handle to use in all 'curl_multi' functions.\n */\nCURL_EXTERN CURLM *curl_multi_init(void);\n\n/*\n * Name:    curl_multi_add_handle()\n *\n * Desc:    add a standard curl handle to the multi stack\n *\n * Returns: CURLMcode type, general multi error code.\n */\nCURL_EXTERN CURLMcode curl_multi_add_handle(CURLM *multi_handle,\n                                            CURL *curl_handle);\n\n /*\n  * Name:    curl_multi_remove_handle()\n  *\n  * Desc:    removes a curl handle from the multi stack again\n  *\n  * Returns: CURLMcode type, general multi error code.\n  */\nCURL_EXTERN CURLMcode curl_multi_remove_handle(CURLM *multi_handle,\n                                               CURL *curl_handle);\n\n /*\n  * Name:    curl_multi_fdset()\n  *\n  * Desc:    Ask curl for its fd_set sets. The app can use these to select() or\n  *          poll() on. We want curl_multi_perform() called as soon as one of\n  *          them are ready.\n  *\n  * Returns: CURLMcode type, general multi error code.\n  */\nCURL_EXTERN CURLMcode curl_multi_fdset(CURLM *multi_handle,\n                                       fd_set *read_fd_set,\n                                       fd_set *write_fd_set,\n                                       fd_set *exc_fd_set,\n                                       int *max_fd);\n\n/*\n * Name:     curl_multi_wait()\n *\n * Desc:     Poll on all fds within a CURLM set as well as any\n *           additional fds passed to the function.\n *\n * Returns:  CURLMcode type, general multi error code.\n */\nCURL_EXTERN CURLMcode curl_multi_wait(CURLM *multi_handle,\n                                      struct curl_waitfd extra_fds[],\n                                      unsigned int extra_nfds,\n                                      int timeout_ms,\n                                      int *ret);\n\n/*\n * Name:     curl_multi_poll()\n *\n * Desc:     Poll on all fds within a CURLM set as well as any\n *           additional fds passed to the function.\n *\n * Returns:  CURLMcode type, general multi error code.\n */\nCURL_EXTERN CURLMcode curl_multi_poll(CURLM *multi_handle,\n                                      struct curl_waitfd extra_fds[],\n                                      unsigned int extra_nfds,\n                                      int timeout_ms,\n                                      int *ret);\n\n/*\n * Name:     curl_multi_wakeup()\n *\n * Desc:     wakes up a sleeping curl_multi_poll call.\n *\n * Returns:  CURLMcode type, general multi error code.\n */\nCURL_EXTERN CURLMcode curl_multi_wakeup(CURLM *multi_handle);\n\n /*\n  * Name:    curl_multi_perform()\n  *\n  * Desc:    When the app thinks there's data available for curl it calls this\n  *          function to read/write whatever there is right now. This returns\n  *          as soon as the reads and writes are done. This function does not\n  *          require that there actually is data available for reading or that\n  *          data can be written, it can be called just in case. It returns\n  *          the number of handles that still transfer data in the second\n  *          argument's integer-pointer.\n  *\n  * Returns: CURLMcode type, general multi error code. *NOTE* that this only\n  *          returns errors etc regarding the whole multi stack. There might\n  *          still have occurred problems on individual transfers even when\n  *          this returns OK.\n  */\nCURL_EXTERN CURLMcode curl_multi_perform(CURLM *multi_handle,\n                                         int *running_handles);\n\n /*\n  * Name:    curl_multi_cleanup()\n  *\n  * Desc:    Cleans up and removes a whole multi stack. It does not free or\n  *          touch any individual easy handles in any way. We need to define\n  *          in what state those handles will be if this function is called\n  *          in the middle of a transfer.\n  *\n  * Returns: CURLMcode type, general multi error code.\n  */\nCURL_EXTERN CURLMcode curl_multi_cleanup(CURLM *multi_handle);\n\n/*\n * Name:    curl_multi_info_read()\n *\n * Desc:    Ask the multi handle if there's any messages/informationals from\n *          the individual transfers. Messages include informationals such as\n *          error code from the transfer or just the fact that a transfer is\n *          completed. More details on these should be written down as well.\n *\n *          Repeated calls to this function will return a new struct each\n *          time, until a special \"end of msgs\" struct is returned as a signal\n *          that there is no more to get at this point.\n *\n *          The data the returned pointer points to will not survive calling\n *          curl_multi_cleanup().\n *\n *          The 'CURLMsg' struct is meant to be very simple and only contain\n *          very basic information. If more involved information is wanted,\n *          we will provide the particular \"transfer handle\" in that struct\n *          and that should/could/would be used in subsequent\n *          curl_easy_getinfo() calls (or similar). The point being that we\n *          must never expose complex structs to applications, as then we'll\n *          undoubtably get backwards compatibility problems in the future.\n *\n * Returns: A pointer to a filled-in struct, or NULL if it failed or ran out\n *          of structs. It also writes the number of messages left in the\n *          queue (after this read) in the integer the second argument points\n *          to.\n */\nCURL_EXTERN CURLMsg *curl_multi_info_read(CURLM *multi_handle,\n                                          int *msgs_in_queue);\n\n/*\n * Name:    curl_multi_strerror()\n *\n * Desc:    The curl_multi_strerror function may be used to turn a CURLMcode\n *          value into the equivalent human readable error string.  This is\n *          useful for printing meaningful error messages.\n *\n * Returns: A pointer to a null-terminated error message.\n */\nCURL_EXTERN const char *curl_multi_strerror(CURLMcode);\n\n/*\n * Name:    curl_multi_socket() and\n *          curl_multi_socket_all()\n *\n * Desc:    An alternative version of curl_multi_perform() that allows the\n *          application to pass in one of the file descriptors that have been\n *          detected to have \"action\" on them and let libcurl perform.\n *          See man page for details.\n */\n#define CURL_POLL_NONE   0\n#define CURL_POLL_IN     1\n#define CURL_POLL_OUT    2\n#define CURL_POLL_INOUT  3\n#define CURL_POLL_REMOVE 4\n\n#define CURL_SOCKET_TIMEOUT CURL_SOCKET_BAD\n\n#define CURL_CSELECT_IN   0x01\n#define CURL_CSELECT_OUT  0x02\n#define CURL_CSELECT_ERR  0x04\n\ntypedef int (*curl_socket_callback)(CURL *easy,      /* easy handle */\n                                    curl_socket_t s, /* socket */\n                                    int what,        /* see above */\n                                    void *userp,     /* private callback\n                                                        pointer */\n                                    void *socketp);  /* private socket\n                                                        pointer */\n/*\n * Name:    curl_multi_timer_callback\n *\n * Desc:    Called by libcurl whenever the library detects a change in the\n *          maximum number of milliseconds the app is allowed to wait before\n *          curl_multi_socket() or curl_multi_perform() must be called\n *          (to allow libcurl's timed events to take place).\n *\n * Returns: The callback should return zero.\n */\ntypedef int (*curl_multi_timer_callback)(CURLM *multi,    /* multi handle */\n                                         long timeout_ms, /* see above */\n                                         void *userp);    /* private callback\n                                                             pointer */\n\nCURL_EXTERN CURLMcode curl_multi_socket(CURLM *multi_handle, curl_socket_t s,\n                                        int *running_handles);\n\nCURL_EXTERN CURLMcode curl_multi_socket_action(CURLM *multi_handle,\n                                               curl_socket_t s,\n                                               int ev_bitmask,\n                                               int *running_handles);\n\nCURL_EXTERN CURLMcode curl_multi_socket_all(CURLM *multi_handle,\n                                            int *running_handles);\n\n#ifndef CURL_ALLOW_OLD_MULTI_SOCKET\n/* This macro below was added in 7.16.3 to push users who recompile to use\n   the new curl_multi_socket_action() instead of the old curl_multi_socket()\n*/\n#define curl_multi_socket(x,y,z) curl_multi_socket_action(x,y,0,z)\n#endif\n\n/*\n * Name:    curl_multi_timeout()\n *\n * Desc:    Returns the maximum number of milliseconds the app is allowed to\n *          wait before curl_multi_socket() or curl_multi_perform() must be\n *          called (to allow libcurl's timed events to take place).\n *\n * Returns: CURLM error code.\n */\nCURL_EXTERN CURLMcode curl_multi_timeout(CURLM *multi_handle,\n                                         long *milliseconds);\n\ntypedef enum {\n  /* This is the socket callback function pointer */\n  CURLOPT(CURLMOPT_SOCKETFUNCTION, CURLOPTTYPE_FUNCTIONPOINT, 1),\n\n  /* This is the argument passed to the socket callback */\n  CURLOPT(CURLMOPT_SOCKETDATA, CURLOPTTYPE_OBJECTPOINT, 2),\n\n    /* set to 1 to enable pipelining for this multi handle */\n  CURLOPT(CURLMOPT_PIPELINING, CURLOPTTYPE_LONG, 3),\n\n   /* This is the timer callback function pointer */\n  CURLOPT(CURLMOPT_TIMERFUNCTION, CURLOPTTYPE_FUNCTIONPOINT, 4),\n\n  /* This is the argument passed to the timer callback */\n  CURLOPT(CURLMOPT_TIMERDATA, CURLOPTTYPE_OBJECTPOINT, 5),\n\n  /* maximum number of entries in the connection cache */\n  CURLOPT(CURLMOPT_MAXCONNECTS, CURLOPTTYPE_LONG, 6),\n\n  /* maximum number of (pipelining) connections to one host */\n  CURLOPT(CURLMOPT_MAX_HOST_CONNECTIONS, CURLOPTTYPE_LONG, 7),\n\n  /* maximum number of requests in a pipeline */\n  CURLOPT(CURLMOPT_MAX_PIPELINE_LENGTH, CURLOPTTYPE_LONG, 8),\n\n  /* a connection with a content-length longer than this\n     will not be considered for pipelining */\n  CURLOPT(CURLMOPT_CONTENT_LENGTH_PENALTY_SIZE, CURLOPTTYPE_OFF_T, 9),\n\n  /* a connection with a chunk length longer than this\n     will not be considered for pipelining */\n  CURLOPT(CURLMOPT_CHUNK_LENGTH_PENALTY_SIZE, CURLOPTTYPE_OFF_T, 10),\n\n  /* a list of site names(+port) that are blocked from pipelining */\n  CURLOPT(CURLMOPT_PIPELINING_SITE_BL, CURLOPTTYPE_OBJECTPOINT, 11),\n\n  /* a list of server types that are blocked from pipelining */\n  CURLOPT(CURLMOPT_PIPELINING_SERVER_BL, CURLOPTTYPE_OBJECTPOINT, 12),\n\n  /* maximum number of open connections in total */\n  CURLOPT(CURLMOPT_MAX_TOTAL_CONNECTIONS, CURLOPTTYPE_LONG, 13),\n\n   /* This is the server push callback function pointer */\n  CURLOPT(CURLMOPT_PUSHFUNCTION, CURLOPTTYPE_FUNCTIONPOINT, 14),\n\n  /* This is the argument passed to the server push callback */\n  CURLOPT(CURLMOPT_PUSHDATA, CURLOPTTYPE_OBJECTPOINT, 15),\n\n  /* maximum number of concurrent streams to support on a connection */\n  CURLOPT(CURLMOPT_MAX_CONCURRENT_STREAMS, CURLOPTTYPE_LONG, 16),\n\n  CURLMOPT_LASTENTRY /* the last unused */\n} CURLMoption;\n\n\n/*\n * Name:    curl_multi_setopt()\n *\n * Desc:    Sets options for the multi handle.\n *\n * Returns: CURLM error code.\n */\nCURL_EXTERN CURLMcode curl_multi_setopt(CURLM *multi_handle,\n                                        CURLMoption option, ...);\n\n\n/*\n * Name:    curl_multi_assign()\n *\n * Desc:    This function sets an association in the multi handle between the\n *          given socket and a private pointer of the application. This is\n *          (only) useful for curl_multi_socket uses.\n *\n * Returns: CURLM error code.\n */\nCURL_EXTERN CURLMcode curl_multi_assign(CURLM *multi_handle,\n                                        curl_socket_t sockfd, void *sockp);\n\n\n/*\n * Name: curl_push_callback\n *\n * Desc: This callback gets called when a new stream is being pushed by the\n *       server. It approves or denies the new stream. It can also decide\n *       to completely fail the connection.\n *\n * Returns: CURL_PUSH_OK, CURL_PUSH_DENY or CURL_PUSH_ERROROUT\n */\n#define CURL_PUSH_OK       0\n#define CURL_PUSH_DENY     1\n#define CURL_PUSH_ERROROUT 2 /* added in 7.72.0 */\n\nstruct curl_pushheaders;  /* forward declaration only */\n\nCURL_EXTERN char *curl_pushheader_bynum(struct curl_pushheaders *h,\n                                        size_t num);\nCURL_EXTERN char *curl_pushheader_byname(struct curl_pushheaders *h,\n                                         const char *name);\n\ntypedef int (*curl_push_callback)(CURL *parent,\n                                  CURL *easy,\n                                  size_t num_headers,\n                                  struct curl_pushheaders *headers,\n                                  void *userp);\n\n#ifdef __cplusplus\n} /* end of extern \"C\" */\n#endif\n\n#endif\n"}, "5": {"id": 5, "path": "/home/runner/work/testcc/testcc/retdec/lib/multi.c", "content": "/***************************************************************************\n *                                  _   _ ____  _\n *  Project                     ___| | | |  _ \\| |\n *                             / __| | | | |_) | |\n *                            | (__| |_| |  _ <| |___\n *                             \\___|\\___/|_| \\_\\_____|\n *\n * Copyright (C) 1998 - 2020, Daniel Stenberg, <daniel@haxx.se>, et al.\n *\n * This software is licensed as described in the file COPYING, which\n * you should have received as part of this distribution. The terms\n * are also available at https://curl.haxx.se/docs/copyright.html.\n *\n * You may opt to use, copy, modify, merge, publish, distribute and/or sell\n * copies of the Software, and permit persons to whom the Software is\n * furnished to do so, under the terms of the COPYING file.\n *\n * This software is distributed on an \"AS IS\" basis, WITHOUT WARRANTY OF ANY\n * KIND, either express or implied.\n *\n ***************************************************************************/\n\n#include \"curl_setup.h\"\n\n#include <curl/curl.h>\n\n#include \"urldata.h\"\n#include \"transfer.h\"\n#include \"url.h\"\n#include \"connect.h\"\n#include \"progress.h\"\n#include \"easyif.h\"\n#include \"share.h\"\n#include \"psl.h\"\n#include \"multiif.h\"\n#include \"sendf.h\"\n#include \"timeval.h\"\n#include \"http.h\"\n#include \"select.h\"\n#include \"warnless.h\"\n#include \"speedcheck.h\"\n#include \"conncache.h\"\n#include \"multihandle.h\"\n#include \"sigpipe.h\"\n#include \"vtls/vtls.h\"\n#include \"connect.h\"\n#include \"http_proxy.h\"\n#include \"http2.h\"\n#include \"socketpair.h\"\n#include \"socks.h\"\n/* The last 3 #include files should be in this order */\n#include \"curl_printf.h\"\n#include \"curl_memory.h\"\n#include \"memdebug.h\"\n\n/*\n  CURL_SOCKET_HASH_TABLE_SIZE should be a prime number. Increasing it from 97\n  to 911 takes on a 32-bit machine 4 x 804 = 3211 more bytes.  Still, every\n  CURL handle takes 45-50 K memory, therefore this 3K are not significant.\n*/\n#ifndef CURL_SOCKET_HASH_TABLE_SIZE\n#define CURL_SOCKET_HASH_TABLE_SIZE 911\n#endif\n\n#ifndef CURL_CONNECTION_HASH_SIZE\n#define CURL_CONNECTION_HASH_SIZE 97\n#endif\n\n#define CURL_MULTI_HANDLE 0x000bab1e\n\n#define GOOD_MULTI_HANDLE(x) \\\n  ((x) && (x)->type == CURL_MULTI_HANDLE)\n\nstatic CURLMcode singlesocket(struct Curl_multi *multi,\n                              struct Curl_easy *data);\nstatic CURLMcode add_next_timeout(struct curltime now,\n                                  struct Curl_multi *multi,\n                                  struct Curl_easy *d);\nstatic CURLMcode multi_timeout(struct Curl_multi *multi,\n                               long *timeout_ms);\nstatic void process_pending_handles(struct Curl_multi *multi);\n\n#ifdef DEBUGBUILD\nstatic const char * const statename[]={\n  \"INIT\",\n  \"CONNECT_PEND\",\n  \"CONNECT\",\n  \"WAITRESOLVE\",\n  \"WAITCONNECT\",\n  \"WAITPROXYCONNECT\",\n  \"SENDPROTOCONNECT\",\n  \"PROTOCONNECT\",\n  \"DO\",\n  \"DOING\",\n  \"DO_MORE\",\n  \"DO_DONE\",\n  \"PERFORM\",\n  \"TOOFAST\",\n  \"DONE\",\n  \"COMPLETED\",\n  \"MSGSENT\",\n};\n#endif\n\n/* function pointer called once when switching TO a state */\ntypedef void (*init_multistate_func)(struct Curl_easy *data);\n\nstatic void Curl_init_completed(struct Curl_easy *data)\n{\n  /* this is a completed transfer */\n\n  /* Important: reset the conn pointer so that we don't point to memory\n     that could be freed anytime */\n  Curl_detach_connnection(data);\n  Curl_expire_clear(data); /* stop all timers */\n}\n\n/* always use this function to change state, to make debugging easier */\nstatic void mstate(struct Curl_easy *data, CURLMstate state\n#ifdef DEBUGBUILD\n                   , int lineno\n#endif\n)\n{\n  CURLMstate oldstate = data->mstate;\n  static const init_multistate_func finit[CURLM_STATE_LAST] = {\n    NULL,              /* INIT */\n    NULL,              /* CONNECT_PEND */\n    Curl_init_CONNECT, /* CONNECT */\n    NULL,              /* WAITRESOLVE */\n    NULL,              /* WAITCONNECT */\n    NULL,              /* WAITPROXYCONNECT */\n    NULL,              /* SENDPROTOCONNECT */\n    NULL,              /* PROTOCONNECT */\n    Curl_connect_free, /* DO */\n    NULL,              /* DOING */\n    NULL,              /* DO_MORE */\n    NULL,              /* DO_DONE */\n    NULL,              /* PERFORM */\n    NULL,              /* TOOFAST */\n    NULL,              /* DONE */\n    Curl_init_completed, /* COMPLETED */\n    NULL               /* MSGSENT */\n  };\n\n#if defined(DEBUGBUILD) && defined(CURL_DISABLE_VERBOSE_STRINGS)\n  (void) lineno;\n#endif\n\n  if(oldstate == state)\n    /* don't bother when the new state is the same as the old state */\n    return;\n\n  data->mstate = state;\n\n#if defined(DEBUGBUILD) && !defined(CURL_DISABLE_VERBOSE_STRINGS)\n  if(data->mstate >= CURLM_STATE_CONNECT_PEND &&\n     data->mstate < CURLM_STATE_COMPLETED) {\n    long connection_id = -5000;\n\n    if(data->conn)\n      connection_id = data->conn->connection_id;\n\n    infof(data,\n          \"STATE: %s => %s handle %p; line %d (connection #%ld)\\n\",\n          statename[oldstate], statename[data->mstate],\n          (void *)data, lineno, connection_id);\n  }\n#endif\n\n  if(state == CURLM_STATE_COMPLETED) {\n    /* changing to COMPLETED means there's one less easy handle 'alive' */\n    DEBUGASSERT(data->multi->num_alive > 0);\n    data->multi->num_alive--;\n  }\n\n  /* if this state has an init-function, run it */\n  if(finit[state])\n    finit[state](data);\n}\n\n#ifndef DEBUGBUILD\n#define multistate(x,y) mstate(x,y)\n#else\n#define multistate(x,y) mstate(x,y, __LINE__)\n#endif\n\n/*\n * We add one of these structs to the sockhash for each socket\n */\n\nstruct Curl_sh_entry {\n  struct curl_hash transfers; /* hash of transfers using this socket */\n  unsigned int action;  /* what combined action READ/WRITE this socket waits\n                           for */\n  void *socketp; /* settable by users with curl_multi_assign() */\n  unsigned int users; /* number of transfers using this */\n  unsigned int readers; /* this many transfers want to read */\n  unsigned int writers; /* this many transfers want to write */\n};\n/* bits for 'action' having no bits means this socket is not expecting any\n   action */\n#define SH_READ  1\n#define SH_WRITE 2\n\n/* look up a given socket in the socket hash, skip invalid sockets */\nstatic struct Curl_sh_entry *sh_getentry(struct curl_hash *sh,\n                                         curl_socket_t s)\n{\n  if(s != CURL_SOCKET_BAD) {\n    /* only look for proper sockets */\n    return Curl_hash_pick(sh, (char *)&s, sizeof(curl_socket_t));\n  }\n  return NULL;\n}\n\n#define TRHASH_SIZE 13\nstatic size_t trhash(void *key, size_t key_length, size_t slots_num)\n{\n  size_t keyval = (size_t)*(struct Curl_easy **)key;\n  (void) key_length;\n\n  return (keyval % slots_num);\n}\n\nstatic size_t trhash_compare(void *k1, size_t k1_len, void *k2, size_t k2_len)\n{\n  (void)k1_len;\n  (void)k2_len;\n\n  return *(struct Curl_easy **)k1 == *(struct Curl_easy **)k2;\n}\n\nstatic void trhash_dtor(void *nada)\n{\n  (void)nada;\n}\n\n\n/* make sure this socket is present in the hash for this handle */\nstatic struct Curl_sh_entry *sh_addentry(struct curl_hash *sh,\n                                         curl_socket_t s)\n{\n  struct Curl_sh_entry *there = sh_getentry(sh, s);\n  struct Curl_sh_entry *check;\n\n  if(there) {\n    /* it is present, return fine */\n    return there;\n  }\n\n  /* not present, add it */\n  check = calloc(1, sizeof(struct Curl_sh_entry));\n  if(!check)\n    return NULL; /* major failure */\n\n  if(Curl_hash_init(&check->transfers, TRHASH_SIZE, trhash,\n                    trhash_compare, trhash_dtor)) {\n    free(check);\n    return NULL;\n  }\n\n  /* make/add new hash entry */\n  if(!Curl_hash_add(sh, (char *)&s, sizeof(curl_socket_t), check)) {\n    Curl_hash_destroy(&check->transfers);\n    free(check);\n    return NULL; /* major failure */\n  }\n\n  return check; /* things are good in sockhash land */\n}\n\n\n/* delete the given socket + handle from the hash */\nstatic void sh_delentry(struct Curl_sh_entry *entry,\n                        struct curl_hash *sh, curl_socket_t s)\n{\n  Curl_hash_destroy(&entry->transfers);\n\n  /* We remove the hash entry. This will end up in a call to\n     sh_freeentry(). */\n  Curl_hash_delete(sh, (char *)&s, sizeof(curl_socket_t));\n}\n\n/*\n * free a sockhash entry\n */\nstatic void sh_freeentry(void *freethis)\n{\n  struct Curl_sh_entry *p = (struct Curl_sh_entry *) freethis;\n\n  free(p);\n}\n\nstatic size_t fd_key_compare(void *k1, size_t k1_len, void *k2, size_t k2_len)\n{\n  (void) k1_len; (void) k2_len;\n\n  return (*((curl_socket_t *) k1)) == (*((curl_socket_t *) k2));\n}\n\nstatic size_t hash_fd(void *key, size_t key_length, size_t slots_num)\n{\n  curl_socket_t fd = *((curl_socket_t *) key);\n  (void) key_length;\n\n  return (fd % slots_num);\n}\n\n/*\n * sh_init() creates a new socket hash and returns the handle for it.\n *\n * Quote from README.multi_socket:\n *\n * \"Some tests at 7000 and 9000 connections showed that the socket hash lookup\n * is somewhat of a bottle neck. Its current implementation may be a bit too\n * limiting. It simply has a fixed-size array, and on each entry in the array\n * it has a linked list with entries. So the hash only checks which list to\n * scan through. The code I had used so for used a list with merely 7 slots\n * (as that is what the DNS hash uses) but with 7000 connections that would\n * make an average of 1000 nodes in each list to run through. I upped that to\n * 97 slots (I believe a prime is suitable) and noticed a significant speed\n * increase.  I need to reconsider the hash implementation or use a rather\n * large default value like this. At 9000 connections I was still below 10us\n * per call.\"\n *\n */\nstatic int sh_init(struct curl_hash *hash, int hashsize)\n{\n  return Curl_hash_init(hash, hashsize, hash_fd, fd_key_compare,\n                        sh_freeentry);\n}\n\n/*\n * multi_addmsg()\n *\n * Called when a transfer is completed. Adds the given msg pointer to\n * the list kept in the multi handle.\n */\nstatic CURLMcode multi_addmsg(struct Curl_multi *multi,\n                              struct Curl_message *msg)\n{\n  Curl_llist_insert_next(&multi->msglist, multi->msglist.tail, msg,\n                         &msg->list);\n  return CURLM_OK;\n}\n\nstruct Curl_multi *Curl_multi_handle(int hashsize, /* socket hash */\n                                     int chashsize) /* connection hash */\n{\n  struct Curl_multi *multi = calloc(1, sizeof(struct Curl_multi));\n\n  if(!multi)\n    return NULL;\n\n  multi->type = CURL_MULTI_HANDLE;\n\n  if(Curl_mk_dnscache(&multi->hostcache))\n    goto error;\n\n  if(sh_init(&multi->sockhash, hashsize))\n    goto error;\n\n  if(Curl_conncache_init(&multi->conn_cache, chashsize))\n    goto error;\n\n  Curl_llist_init(&multi->msglist, NULL);\n  Curl_llist_init(&multi->pending, NULL);\n\n  multi->multiplexing = TRUE;\n\n  /* -1 means it not set by user, use the default value */\n  multi->maxconnects = -1;\n  multi->max_concurrent_streams = 100;\n  multi->ipv6_works = Curl_ipv6works(NULL);\n\n#ifdef USE_WINSOCK\n  multi->wsa_event = WSACreateEvent();\n  if(multi->wsa_event == WSA_INVALID_EVENT)\n    goto error;\n#else\n#ifdef ENABLE_WAKEUP\n  if(Curl_socketpair(AF_UNIX, SOCK_STREAM, 0, multi->wakeup_pair) < 0) {\n    multi->wakeup_pair[0] = CURL_SOCKET_BAD;\n    multi->wakeup_pair[1] = CURL_SOCKET_BAD;\n  }\n  else if(curlx_nonblock(multi->wakeup_pair[0], TRUE) < 0 ||\n          curlx_nonblock(multi->wakeup_pair[1], TRUE) < 0) {\n    sclose(multi->wakeup_pair[0]);\n    sclose(multi->wakeup_pair[1]);\n    multi->wakeup_pair[0] = CURL_SOCKET_BAD;\n    multi->wakeup_pair[1] = CURL_SOCKET_BAD;\n  }\n#endif\n#endif\n\n  return multi;\n\n  error:\n\n  Curl_hash_destroy(&multi->sockhash);\n  Curl_hash_destroy(&multi->hostcache);\n  Curl_conncache_destroy(&multi->conn_cache);\n  Curl_llist_destroy(&multi->msglist, NULL);\n  Curl_llist_destroy(&multi->pending, NULL);\n\n  free(multi);\n  return NULL;\n}\n\nstruct Curl_multi *curl_multi_init(void)\n{\n  return Curl_multi_handle(CURL_SOCKET_HASH_TABLE_SIZE,\n                           CURL_CONNECTION_HASH_SIZE);\n}\n\nCURLMcode curl_multi_add_handle(struct Curl_multi *multi,\n                                struct Curl_easy *data)\n{\n  /* First, make some basic checks that the CURLM handle is a good handle */\n  if(!GOOD_MULTI_HANDLE(multi))\n    return CURLM_BAD_HANDLE;\n\n  /* Verify that we got a somewhat good easy handle too */\n  if(!GOOD_EASY_HANDLE(data))\n    return CURLM_BAD_EASY_HANDLE;\n\n  /* Prevent users from adding same easy handle more than once and prevent\n     adding to more than one multi stack */\n  if(data->multi)\n    return CURLM_ADDED_ALREADY;\n\n  if(multi->in_callback)\n    return CURLM_RECURSIVE_API_CALL;\n\n  /* Initialize timeout list for this handle */\n  Curl_llist_init(&data->state.timeoutlist, NULL);\n\n  /*\n   * No failure allowed in this function beyond this point. And no\n   * modification of easy nor multi handle allowed before this except for\n   * potential multi's connection cache growing which won't be undone in this\n   * function no matter what.\n   */\n  if(data->set.errorbuffer)\n    data->set.errorbuffer[0] = 0;\n\n  /* set the easy handle */\n  multistate(data, CURLM_STATE_INIT);\n\n  /* for multi interface connections, we share DNS cache automatically if the\n     easy handle's one is currently not set. */\n  if(!data->dns.hostcache ||\n     (data->dns.hostcachetype == HCACHE_NONE)) {\n    data->dns.hostcache = &multi->hostcache;\n    data->dns.hostcachetype = HCACHE_MULTI;\n  }\n\n  /* Point to the shared or multi handle connection cache */\n  if(data->share && (data->share->specifier & (1<< CURL_LOCK_DATA_CONNECT)))\n    data->state.conn_cache = &data->share->conn_cache;\n  else\n    data->state.conn_cache = &multi->conn_cache;\n  data->state.lastconnect_id = -1;\n\n#ifdef USE_LIBPSL\n  /* Do the same for PSL. */\n  if(data->share && (data->share->specifier & (1 << CURL_LOCK_DATA_PSL)))\n    data->psl = &data->share->psl;\n  else\n    data->psl = &multi->psl;\n#endif\n\n  /* We add the new entry last in the list. */\n  data->next = NULL; /* end of the line */\n  if(multi->easyp) {\n    struct Curl_easy *last = multi->easylp;\n    last->next = data;\n    data->prev = last;\n    multi->easylp = data; /* the new last node */\n  }\n  else {\n    /* first node, make prev NULL! */\n    data->prev = NULL;\n    multi->easylp = multi->easyp = data; /* both first and last */\n  }\n\n  /* make the Curl_easy refer back to this multi handle */\n  data->multi = multi;\n\n  /* Set the timeout for this handle to expire really soon so that it will\n     be taken care of even when this handle is added in the midst of operation\n     when only the curl_multi_socket() API is used. During that flow, only\n     sockets that time-out or have actions will be dealt with. Since this\n     handle has no action yet, we make sure it times out to get things to\n     happen. */\n  Curl_expire(data, 0, EXPIRE_RUN_NOW);\n\n  /* increase the node-counter */\n  multi->num_easy++;\n\n  /* increase the alive-counter */\n  multi->num_alive++;\n\n  /* A somewhat crude work-around for a little glitch in Curl_update_timer()\n     that happens if the lastcall time is set to the same time when the handle\n     is removed as when the next handle is added, as then the check in\n     Curl_update_timer() that prevents calling the application multiple times\n     with the same timer info will not trigger and then the new handle's\n     timeout will not be notified to the app.\n\n     The work-around is thus simply to clear the 'lastcall' variable to force\n     Curl_update_timer() to always trigger a callback to the app when a new\n     easy handle is added */\n  memset(&multi->timer_lastcall, 0, sizeof(multi->timer_lastcall));\n\n  CONNCACHE_LOCK(data);\n  /* The closure handle only ever has default timeouts set. To improve the\n     state somewhat we clone the timeouts from each added handle so that the\n     closure handle always has the same timeouts as the most recently added\n     easy handle. */\n  data->state.conn_cache->closure_handle->set.timeout = data->set.timeout;\n  data->state.conn_cache->closure_handle->set.server_response_timeout =\n    data->set.server_response_timeout;\n  data->state.conn_cache->closure_handle->set.no_signal =\n    data->set.no_signal;\n  CONNCACHE_UNLOCK(data);\n\n  Curl_update_timer(multi);\n  return CURLM_OK;\n}\n\n#if 0\n/* Debug-function, used like this:\n *\n * Curl_hash_print(multi->sockhash, debug_print_sock_hash);\n *\n * Enable the hash print function first by editing hash.c\n */\nstatic void debug_print_sock_hash(void *p)\n{\n  struct Curl_sh_entry *sh = (struct Curl_sh_entry *)p;\n\n  fprintf(stderr, \" [easy %p/magic %x/socket %d]\",\n          (void *)sh->data, sh->data->magic, (int)sh->socket);\n}\n#endif\n\nstatic CURLcode multi_done(struct Curl_easy *data,\n                           CURLcode status,  /* an error if this is called\n                                                after an error was detected */\n                           bool premature)\n{\n  CURLcode result;\n  struct connectdata *conn = data->conn;\n  unsigned int i;\n\n  DEBUGF(infof(data, \"multi_done\\n\"));\n\n  if(data->state.done)\n    /* Stop if multi_done() has already been called */\n    return CURLE_OK;\n\n  conn->data = data; /* ensure the connection uses this transfer now */\n\n  /* Stop the resolver and free its own resources (but not dns_entry yet). */\n  Curl_resolver_kill(conn);\n\n  /* Cleanup possible redirect junk */\n  Curl_safefree(data->req.newurl);\n  Curl_safefree(data->req.location);\n\n  switch(status) {\n  case CURLE_ABORTED_BY_CALLBACK:\n  case CURLE_READ_ERROR:\n  case CURLE_WRITE_ERROR:\n    /* When we're aborted due to a callback return code it basically have to\n       be counted as premature as there is trouble ahead if we don't. We have\n       many callbacks and protocols work differently, we could potentially do\n       this more fine-grained in the future. */\n    premature = TRUE;\n  default:\n    break;\n  }\n\n  /* this calls the protocol-specific function pointer previously set */\n  if(conn->handler->done)\n    result = conn->handler->done(conn, status, premature);\n  else\n    result = status;\n\n  if(CURLE_ABORTED_BY_CALLBACK != result) {\n    /* avoid this if we already aborted by callback to avoid this calling\n       another callback */\n    CURLcode rc = Curl_pgrsDone(conn);\n    if(!result && rc)\n      result = CURLE_ABORTED_BY_CALLBACK;\n  }\n\n  process_pending_handles(data->multi); /* connection / multiplex */\n\n  CONNCACHE_LOCK(data);\n  Curl_detach_connnection(data);\n  if(CONN_INUSE(conn)) {\n    /* Stop if still used. */\n    /* conn->data must not remain pointing to this transfer since it is going\n       away! Find another to own it! */\n    conn->data = conn->easyq.head->ptr;\n    CONNCACHE_UNLOCK(data);\n    DEBUGF(infof(data, \"Connection still in use %zu, \"\n                 \"no more multi_done now!\\n\",\n                 conn->easyq.size));\n    return CURLE_OK;\n  }\n  conn->data = NULL; /* the connection now has no owner */\n  data->state.done = TRUE; /* called just now! */\n\n  if(conn->dns_entry) {\n    Curl_resolv_unlock(data, conn->dns_entry); /* done with this */\n    conn->dns_entry = NULL;\n  }\n  Curl_hostcache_prune(data);\n  Curl_safefree(data->state.ulbuf);\n\n  /* if the transfer was completed in a paused state there can be buffered\n     data left to free */\n  for(i = 0; i < data->state.tempcount; i++) {\n    Curl_dyn_free(&data->state.tempwrite[i].b);\n  }\n  data->state.tempcount = 0;\n\n  /* if data->set.reuse_forbid is TRUE, it means the libcurl client has\n     forced us to close this connection. This is ignored for requests taking\n     place in a NTLM/NEGOTIATE authentication handshake\n\n     if conn->bits.close is TRUE, it means that the connection should be\n     closed in spite of all our efforts to be nice, due to protocol\n     restrictions in our or the server's end\n\n     if premature is TRUE, it means this connection was said to be DONE before\n     the entire request operation is complete and thus we can't know in what\n     state it is for re-using, so we're forced to close it. In a perfect world\n     we can add code that keep track of if we really must close it here or not,\n     but currently we have no such detail knowledge.\n  */\n\n  if((data->set.reuse_forbid\n#if defined(USE_NTLM)\n      && !(conn->http_ntlm_state == NTLMSTATE_TYPE2 ||\n           conn->proxy_ntlm_state == NTLMSTATE_TYPE2)\n#endif\n#if defined(USE_SPNEGO)\n      && !(conn->http_negotiate_state == GSS_AUTHRECV ||\n           conn->proxy_negotiate_state == GSS_AUTHRECV)\n#endif\n     ) || conn->bits.close\n       || (premature && !(conn->handler->flags & PROTOPT_STREAM))) {\n    CURLcode res2;\n    connclose(conn, \"disconnecting\");\n    Curl_conncache_remove_conn(data, conn, FALSE);\n    CONNCACHE_UNLOCK(data);\n    res2 = Curl_disconnect(data, conn, premature);\n\n    /* If we had an error already, make sure we return that one. But\n       if we got a new error, return that. */\n    if(!result && res2)\n      result = res2;\n  }\n  else {\n    char buffer[256];\n    const char *host =\n#ifndef CURL_DISABLE_PROXY\n      conn->bits.socksproxy ?\n      conn->socks_proxy.host.dispname :\n      conn->bits.httpproxy ? conn->http_proxy.host.dispname :\n#endif\n      conn->bits.conn_to_host ? conn->conn_to_host.dispname :\n      conn->host.dispname;\n    /* create string before returning the connection */\n    msnprintf(buffer, sizeof(buffer),\n              \"Connection #%ld to host %s left intact\",\n              conn->connection_id, host);\n    /* the connection is no longer in use by this transfer */\n    CONNCACHE_UNLOCK(data);\n    if(Curl_conncache_return_conn(data, conn)) {\n      /* remember the most recently used connection */\n      data->state.lastconnect_id = conn->connection_id;\n      infof(data, \"%s\\n\", buffer);\n    }\n    else\n      data->state.lastconnect_id = -1;\n  }\n\n  Curl_safefree(data->state.buffer);\n  Curl_free_request_state(data);\n  return result;\n}\n\nstatic int close_connect_only(struct connectdata *conn, void *param)\n{\n  struct Curl_easy *data = param;\n\n  if(data->state.lastconnect_id != conn->connection_id)\n    return 0;\n\n  if(conn->data != data)\n    return 1;\n  conn->data = NULL;\n\n  if(!conn->bits.connect_only)\n    return 1;\n\n  connclose(conn, \"Removing connect-only easy handle\");\n  conn->bits.connect_only = FALSE;\n\n  return 1;\n}\n\nCURLMcode curl_multi_remove_handle(struct Curl_multi *multi,\n                                   struct Curl_easy *data)\n{\n  struct Curl_easy *easy = data;\n  bool premature;\n  bool easy_owns_conn;\n  struct curl_llist_element *e;\n\n  /* First, make some basic checks that the CURLM handle is a good handle */\n  if(!GOOD_MULTI_HANDLE(multi))\n    return CURLM_BAD_HANDLE;\n\n  /* Verify that we got a somewhat good easy handle too */\n  if(!GOOD_EASY_HANDLE(data))\n    return CURLM_BAD_EASY_HANDLE;\n\n  /* Prevent users from trying to remove same easy handle more than once */\n  if(!data->multi)\n    return CURLM_OK; /* it is already removed so let's say it is fine! */\n\n  /* Prevent users from trying to remove an easy handle from the wrong multi */\n  if(data->multi != multi)\n    return CURLM_BAD_EASY_HANDLE;\n\n  if(multi->in_callback)\n    return CURLM_RECURSIVE_API_CALL;\n\n  premature = (data->mstate < CURLM_STATE_COMPLETED) ? TRUE : FALSE;\n  easy_owns_conn = (data->conn && (data->conn->data == easy)) ?\n    TRUE : FALSE;\n\n  /* If the 'state' is not INIT or COMPLETED, we might need to do something\n     nice to put the easy_handle in a good known state when this returns. */\n  if(premature) {\n    /* this handle is \"alive\" so we need to count down the total number of\n       alive connections when this is removed */\n    multi->num_alive--;\n  }\n\n  if(data->conn &&\n     data->mstate > CURLM_STATE_DO &&\n     data->mstate < CURLM_STATE_COMPLETED) {\n    /* Set connection owner so that the DONE function closes it.  We can\n       safely do this here since connection is killed. */\n    data->conn->data = easy;\n    streamclose(data->conn, \"Removed with partial response\");\n    easy_owns_conn = TRUE;\n  }\n\n  if(data->conn) {\n\n    /* we must call multi_done() here (if we still own the connection) so that\n       we don't leave a half-baked one around */\n    if(easy_owns_conn) {\n\n      /* multi_done() clears the association between the easy handle and the\n         connection.\n\n         Note that this ignores the return code simply because there's\n         nothing really useful to do with it anyway! */\n      (void)multi_done(data, data->result, premature);\n    }\n  }\n\n  /* The timer must be shut down before data->multi is set to NULL, else the\n     timenode will remain in the splay tree after curl_easy_cleanup is\n     called. Do it after multi_done() in case that sets another time! */\n  Curl_expire_clear(data);\n\n  if(data->connect_queue.ptr)\n    /* the handle was in the pending list waiting for an available connection,\n       so go ahead and remove it */\n    Curl_llist_remove(&multi->pending, &data->connect_queue, NULL);\n\n  if(data->dns.hostcachetype == HCACHE_MULTI) {\n    /* stop using the multi handle's DNS cache, *after* the possible\n       multi_done() call above */\n    data->dns.hostcache = NULL;\n    data->dns.hostcachetype = HCACHE_NONE;\n  }\n\n  Curl_wildcard_dtor(&data->wildcard);\n\n  /* destroy the timeout list that is held in the easy handle, do this *after*\n     multi_done() as that may actually call Curl_expire that uses this */\n  Curl_llist_destroy(&data->state.timeoutlist, NULL);\n\n  /* change state without using multistate(), only to make singlesocket() do\n     what we want */\n  data->mstate = CURLM_STATE_COMPLETED;\n  singlesocket(multi, easy); /* to let the application know what sockets that\n                                vanish with this handle */\n\n  /* Remove the association between the connection and the handle */\n  Curl_detach_connnection(data);\n\n  if(data->state.lastconnect_id != -1) {\n    /* Mark any connect-only connection for closure */\n    Curl_conncache_foreach(data, data->state.conn_cache,\n                           data, &close_connect_only);\n  }\n\n#ifdef USE_LIBPSL\n  /* Remove the PSL association. */\n  if(data->psl == &multi->psl)\n    data->psl = NULL;\n#endif\n\n  /* as this was using a shared connection cache we clear the pointer to that\n     since we're not part of that multi handle anymore */\n  data->state.conn_cache = NULL;\n\n  data->multi = NULL; /* clear the association to this multi handle */\n\n  /* make sure there's no pending message in the queue sent from this easy\n     handle */\n\n  for(e = multi->msglist.head; e; e = e->next) {\n    struct Curl_message *msg = e->ptr;\n\n    if(msg->extmsg.easy_handle == easy) {\n      Curl_llist_remove(&multi->msglist, e, NULL);\n      /* there can only be one from this specific handle */\n      break;\n    }\n  }\n\n  /* make the previous node point to our next */\n  if(data->prev)\n    data->prev->next = data->next;\n  else\n    multi->easyp = data->next; /* point to first node */\n\n  /* make our next point to our previous node */\n  if(data->next)\n    data->next->prev = data->prev;\n  else\n    multi->easylp = data->prev; /* point to last node */\n\n  /* NOTE NOTE NOTE\n     We do not touch the easy handle here! */\n  multi->num_easy--; /* one less to care about now */\n\n  Curl_update_timer(multi);\n  return CURLM_OK;\n}\n\n/* Return TRUE if the application asked for multiplexing */\nbool Curl_multiplex_wanted(const struct Curl_multi *multi)\n{\n  return (multi && (multi->multiplexing));\n}\n\n/*\n * Curl_detach_connnection() removes the given transfer from the connection.\n *\n * This is the only function that should clear data->conn. This will\n * occasionally be called with the data->conn pointer already cleared.\n */\nvoid Curl_detach_connnection(struct Curl_easy *data)\n{\n  struct connectdata *conn = data->conn;\n  if(conn)\n    Curl_llist_remove(&conn->easyq, &data->conn_queue, NULL);\n  data->conn = NULL;\n}\n\n/*\n * Curl_attach_connnection() attaches this transfer to this connection.\n *\n * This is the only function that should assign data->conn\n */\nvoid Curl_attach_connnection(struct Curl_easy *data,\n                             struct connectdata *conn)\n{\n  DEBUGASSERT(!data->conn);\n  DEBUGASSERT(conn);\n  data->conn = conn;\n  Curl_llist_insert_next(&conn->easyq, conn->easyq.tail, data,\n                         &data->conn_queue);\n}\n\nstatic int waitconnect_getsock(struct connectdata *conn,\n                               curl_socket_t *sock)\n{\n  int i;\n  int s = 0;\n  int rc = 0;\n\n#ifdef USE_SSL\n#ifndef CURL_DISABLE_PROXY\n  if(CONNECT_FIRSTSOCKET_PROXY_SSL())\n    return Curl_ssl_getsock(conn, sock);\n#endif\n#endif\n\n  if(SOCKS_STATE(conn->cnnct.state))\n    return Curl_SOCKS_getsock(conn, sock, FIRSTSOCKET);\n\n  for(i = 0; i<2; i++) {\n    if(conn->tempsock[i] != CURL_SOCKET_BAD) {\n      sock[s] = conn->tempsock[i];\n      rc |= GETSOCK_WRITESOCK(s);\n#ifdef ENABLE_QUIC\n      if(conn->transport == TRNSPRT_QUIC)\n        /* when connecting QUIC, we want to read the socket too */\n        rc |= GETSOCK_READSOCK(s);\n#endif\n      s++;\n    }\n  }\n\n  return rc;\n}\n\nstatic int waitproxyconnect_getsock(struct connectdata *conn,\n                                    curl_socket_t *sock)\n{\n  sock[0] = conn->sock[FIRSTSOCKET];\n\n  /* when we've sent a CONNECT to a proxy, we should rather wait for the\n     socket to become readable to be able to get the response headers */\n  if(conn->connect_state)\n    return GETSOCK_READSOCK(0);\n\n  return GETSOCK_WRITESOCK(0);\n}\n\nstatic int domore_getsock(struct connectdata *conn,\n                          curl_socket_t *socks)\n{\n  if(conn && conn->handler->domore_getsock)\n    return conn->handler->domore_getsock(conn, socks);\n  return GETSOCK_BLANK;\n}\n\nstatic int doing_getsock(struct connectdata *conn,\n                         curl_socket_t *socks)\n{\n  if(conn && conn->handler->doing_getsock)\n    return conn->handler->doing_getsock(conn, socks);\n  return GETSOCK_BLANK;\n}\n\nstatic int protocol_getsock(struct connectdata *conn,\n                            curl_socket_t *socks)\n{\n  if(conn->handler->proto_getsock)\n    return conn->handler->proto_getsock(conn, socks);\n  /* Backup getsock logic. Since there is a live socket in use, we must wait\n     for it or it will be removed from watching when the multi_socket API is\n     used. */\n  socks[0] = conn->sock[FIRSTSOCKET];\n  return GETSOCK_READSOCK(0) | GETSOCK_WRITESOCK(0);\n}\n\n/* returns bitmapped flags for this handle and its sockets. The 'socks[]'\n   array contains MAX_SOCKSPEREASYHANDLE entries. */\nstatic int multi_getsock(struct Curl_easy *data,\n                         curl_socket_t *socks)\n{\n  /* The no connection case can happen when this is called from\n     curl_multi_remove_handle() => singlesocket() => multi_getsock().\n  */\n  if(!data->conn)\n    return 0;\n\n  if(data->mstate > CURLM_STATE_CONNECT &&\n     data->mstate < CURLM_STATE_COMPLETED) {\n    /* Set up ownership correctly */\n    data->conn->data = data;\n  }\n\n  switch(data->mstate) {\n  default:\n    return 0;\n\n  case CURLM_STATE_WAITRESOLVE:\n    return Curl_resolv_getsock(data->conn, socks);\n\n  case CURLM_STATE_PROTOCONNECT:\n  case CURLM_STATE_SENDPROTOCONNECT:\n    return protocol_getsock(data->conn, socks);\n\n  case CURLM_STATE_DO:\n  case CURLM_STATE_DOING:\n    return doing_getsock(data->conn, socks);\n\n  case CURLM_STATE_WAITPROXYCONNECT:\n    return waitproxyconnect_getsock(data->conn, socks);\n\n  case CURLM_STATE_WAITCONNECT:\n    return waitconnect_getsock(data->conn, socks);\n\n  case CURLM_STATE_DO_MORE:\n    return domore_getsock(data->conn, socks);\n\n  case CURLM_STATE_DO_DONE: /* since is set after DO is completed, we switch\n                               to waiting for the same as the *PERFORM\n                               states */\n  case CURLM_STATE_PERFORM:\n    return Curl_single_getsock(data->conn, socks);\n  }\n\n}\n\nCURLMcode curl_multi_fdset(struct Curl_multi *multi,\n                           fd_set *read_fd_set, fd_set *write_fd_set,\n                           fd_set *exc_fd_set, int *max_fd)\n{\n  /* Scan through all the easy handles to get the file descriptors set.\n     Some easy handles may not have connected to the remote host yet,\n     and then we must make sure that is done. */\n  struct Curl_easy *data;\n  int this_max_fd = -1;\n  curl_socket_t sockbunch[MAX_SOCKSPEREASYHANDLE];\n  int i;\n  (void)exc_fd_set; /* not used */\n\n  if(!GOOD_MULTI_HANDLE(multi))\n    return CURLM_BAD_HANDLE;\n\n  if(multi->in_callback)\n    return CURLM_RECURSIVE_API_CALL;\n\n  data = multi->easyp;\n  while(data) {\n    int bitmap = multi_getsock(data, sockbunch);\n\n    for(i = 0; i< MAX_SOCKSPEREASYHANDLE; i++) {\n      curl_socket_t s = CURL_SOCKET_BAD;\n\n      if((bitmap & GETSOCK_READSOCK(i)) && VALID_SOCK((sockbunch[i]))) {\n        FD_SET(sockbunch[i], read_fd_set);\n        s = sockbunch[i];\n      }\n      if((bitmap & GETSOCK_WRITESOCK(i)) && VALID_SOCK((sockbunch[i]))) {\n        FD_SET(sockbunch[i], write_fd_set);\n        s = sockbunch[i];\n      }\n      if(s == CURL_SOCKET_BAD)\n        /* this socket is unused, break out of loop */\n        break;\n      if((int)s > this_max_fd)\n        this_max_fd = (int)s;\n    }\n\n    data = data->next; /* check next handle */\n  }\n\n  *max_fd = this_max_fd;\n\n  return CURLM_OK;\n}\n\n#define NUM_POLLS_ON_STACK 10\n\nstatic CURLMcode Curl_multi_wait(struct Curl_multi *multi,\n                                 struct curl_waitfd extra_fds[],\n                                 unsigned int extra_nfds,\n                                 int timeout_ms,\n                                 int *ret,\n                                 bool extrawait, /* when no socket, wait */\n                                 bool use_wakeup)\n{\n  struct Curl_easy *data;\n  curl_socket_t sockbunch[MAX_SOCKSPEREASYHANDLE];\n  int bitmap;\n  unsigned int i;\n  unsigned int nfds = 0;\n  unsigned int curlfds;\n  long timeout_internal;\n  int retcode = 0;\n#ifndef USE_WINSOCK\n  struct pollfd a_few_on_stack[NUM_POLLS_ON_STACK];\n  struct pollfd *ufds = &a_few_on_stack[0];\n  bool ufds_malloc = FALSE;\n#else\n  struct pollfd pre_poll;\n  DEBUGASSERT(multi->wsa_event != WSA_INVALID_EVENT);\n#endif\n\n  if(!GOOD_MULTI_HANDLE(multi))\n    return CURLM_BAD_HANDLE;\n\n  if(multi->in_callback)\n    return CURLM_RECURSIVE_API_CALL;\n\n  if(timeout_ms < 0)\n    return CURLM_BAD_FUNCTION_ARGUMENT;\n\n  /* Count up how many fds we have from the multi handle */\n  data = multi->easyp;\n  while(data) {\n    bitmap = multi_getsock(data, sockbunch);\n\n    for(i = 0; i< MAX_SOCKSPEREASYHANDLE; i++) {\n      curl_socket_t s = CURL_SOCKET_BAD;\n\n      if(bitmap & GETSOCK_READSOCK(i)) {\n        ++nfds;\n        s = sockbunch[i];\n      }\n      if(bitmap & GETSOCK_WRITESOCK(i)) {\n        ++nfds;\n        s = sockbunch[i];\n      }\n      if(s == CURL_SOCKET_BAD) {\n        break;\n      }\n    }\n\n    data = data->next; /* check next handle */\n  }\n\n  /* If the internally desired timeout is actually shorter than requested from\n     the outside, then use the shorter time! But only if the internal timer\n     is actually larger than -1! */\n  (void)multi_timeout(multi, &timeout_internal);\n  if((timeout_internal >= 0) && (timeout_internal < (long)timeout_ms))\n    timeout_ms = (int)timeout_internal;\n\n  curlfds = nfds; /* number of internal file descriptors */\n  nfds += extra_nfds; /* add the externally provided ones */\n\n#ifdef ENABLE_WAKEUP\n#ifdef USE_WINSOCK\n  if(use_wakeup) {\n#else\n  if(use_wakeup && multi->wakeup_pair[0] != CURL_SOCKET_BAD) {\n#endif\n    ++nfds;\n  }\n#endif\n\n#ifndef USE_WINSOCK\n  if(nfds > NUM_POLLS_ON_STACK) {\n    /* 'nfds' is a 32 bit value and 'struct pollfd' is typically 8 bytes\n       big, so at 2^29 sockets this value might wrap. When a process gets\n       the capability to actually handle over 500 million sockets this\n       calculation needs a integer overflow check. */\n    ufds = malloc(nfds * sizeof(struct pollfd));\n    if(!ufds)\n      return CURLM_OUT_OF_MEMORY;\n    ufds_malloc = TRUE;\n  }\n\n  nfds = 0;\n#endif\n\n  /* only do the second loop if we found descriptors in the first stage run\n     above */\n\n  if(curlfds) {\n    /* Add the curl handles to our pollfds first */\n    data = multi->easyp;\n    while(data) {\n      bitmap = multi_getsock(data, sockbunch);\n\n      for(i = 0; i < MAX_SOCKSPEREASYHANDLE; i++) {\n        curl_socket_t s = CURL_SOCKET_BAD;\n#ifdef USE_WINSOCK\n        long mask = 0;\n#endif\n        if(bitmap & GETSOCK_READSOCK(i)) {\n#ifdef USE_WINSOCK\n          if(SOCKET_READABLE(sockbunch[i], 0) > 0)\n            timeout_ms = 0;\n          mask |= (FD_READ|FD_ACCEPT|FD_CLOSE);\n#else\n          ufds[nfds].fd = sockbunch[i];\n          ufds[nfds].events = POLLIN;\n          ++nfds;\n#endif\n          s = sockbunch[i];\n        }\n        if(bitmap & GETSOCK_WRITESOCK(i)) {\n#ifdef USE_WINSOCK\n          if(SOCKET_WRITABLE(sockbunch[i], 0) > 0)\n            timeout_ms = 0;\n          mask |= (FD_WRITE|FD_CONNECT|FD_CLOSE);\n#else\n          ufds[nfds].fd = sockbunch[i];\n          ufds[nfds].events = POLLOUT;\n          ++nfds;\n#endif\n          s = sockbunch[i];\n        }\n        if(s == CURL_SOCKET_BAD) {\n          break;\n        }\n#ifdef USE_WINSOCK\n        if(WSAEventSelect(s, multi->wsa_event, mask) != 0)\n          return CURLM_INTERNAL_ERROR;\n#endif\n      }\n\n      data = data->next; /* check next handle */\n    }\n  }\n\n  /* Add external file descriptions from poll-like struct curl_waitfd */\n  for(i = 0; i < extra_nfds; i++) {\n#ifdef USE_WINSOCK\n    long events = 0;\n    extra_fds[i].revents = 0;\n    pre_poll.fd = extra_fds[i].fd;\n    pre_poll.events = 0;\n    pre_poll.revents = 0;\n    if(extra_fds[i].events & CURL_WAIT_POLLIN) {\n      events |= (FD_READ|FD_ACCEPT|FD_CLOSE);\n      pre_poll.events |= POLLIN;\n    }\n    if(extra_fds[i].events & CURL_WAIT_POLLPRI) {\n      events |= FD_OOB;\n      pre_poll.events |= POLLPRI;\n    }\n    if(extra_fds[i].events & CURL_WAIT_POLLOUT) {\n      events |= (FD_WRITE|FD_CONNECT|FD_CLOSE);\n      pre_poll.events |= POLLOUT;\n    }\n    if(Curl_poll(&pre_poll, 1, 0) > 0) {\n      if(pre_poll.revents & POLLIN)\n        extra_fds[i].revents |= CURL_WAIT_POLLIN;\n      if(pre_poll.revents & POLLOUT)\n        extra_fds[i].revents |= CURL_WAIT_POLLOUT;\n      if(pre_poll.revents & POLLPRI)\n        extra_fds[i].revents |= CURL_WAIT_POLLPRI;\n      if(extra_fds[i].revents)\n        timeout_ms = 0;\n    }\n    if(WSAEventSelect(extra_fds[i].fd, multi->wsa_event, events) != 0)\n      return CURLM_INTERNAL_ERROR;\n#else\n    ufds[nfds].fd = extra_fds[i].fd;\n    ufds[nfds].events = 0;\n    if(extra_fds[i].events & CURL_WAIT_POLLIN)\n      ufds[nfds].events |= POLLIN;\n    if(extra_fds[i].events & CURL_WAIT_POLLPRI)\n      ufds[nfds].events |= POLLPRI;\n    if(extra_fds[i].events & CURL_WAIT_POLLOUT)\n      ufds[nfds].events |= POLLOUT;\n    ++nfds;\n#endif\n  }\n\n#ifdef ENABLE_WAKEUP\n#ifndef USE_WINSOCK\n  if(use_wakeup && multi->wakeup_pair[0] != CURL_SOCKET_BAD) {\n    ufds[nfds].fd = multi->wakeup_pair[0];\n    ufds[nfds].events = POLLIN;\n    ++nfds;\n  }\n#endif\n#endif\n\n  if(nfds) {\n    /* wait... */\n#ifdef USE_WINSOCK\n    WSAWaitForMultipleEvents(1, &multi->wsa_event, FALSE, timeout_ms, FALSE);\n#else\n    int pollrc = Curl_poll(ufds, nfds, timeout_ms);\n#endif\n\n#ifdef USE_WINSOCK\n    /* With Winsock, we have to run this unconditionally to call\n       WSAEventSelect(fd, event, 0) on all the sockets */\n    {\n      retcode = 0;\n#else\n    if(pollrc > 0) {\n      retcode = pollrc;\n#endif\n      /* copy revents results from the poll to the curl_multi_wait poll\n         struct, the bit values of the actual underlying poll() implementation\n         may not be the same as the ones in the public libcurl API! */\n      for(i = 0; i < extra_nfds; i++) {\n        unsigned short mask = 0;\n#ifdef USE_WINSOCK\n        WSANETWORKEVENTS events = {0};\n        mask = extra_fds[i].revents;\n        if(WSAEnumNetworkEvents(extra_fds[i].fd, multi->wsa_event,\n                                &events) == 0) {\n          if(events.lNetworkEvents & (FD_READ|FD_ACCEPT|FD_CLOSE))\n            mask |= CURL_WAIT_POLLIN;\n          if(events.lNetworkEvents & (FD_WRITE|FD_CONNECT|FD_CLOSE))\n            mask |= CURL_WAIT_POLLOUT;\n          if(events.lNetworkEvents & FD_OOB)\n            mask |= CURL_WAIT_POLLPRI;\n\n          if(ret && events.lNetworkEvents != 0)\n            retcode++;\n        }\n        WSAEventSelect(extra_fds[i].fd, multi->wsa_event, 0);\n#else\n        unsigned r = ufds[curlfds + i].revents;\n\n        if(r & POLLIN)\n          mask |= CURL_WAIT_POLLIN;\n        if(r & POLLOUT)\n          mask |= CURL_WAIT_POLLOUT;\n        if(r & POLLPRI)\n          mask |= CURL_WAIT_POLLPRI;\n#endif\n\n        extra_fds[i].revents = mask;\n      }\n\n#ifdef USE_WINSOCK\n      /* Count up all our own sockets that had activity,\n         and remove them from the event. */\n      if(curlfds) {\n        data = multi->easyp;\n        while(data) {\n          bitmap = multi_getsock(data, sockbunch);\n\n          for(i = 0; i < MAX_SOCKSPEREASYHANDLE; i++) {\n            if(bitmap & (GETSOCK_READSOCK(i) | GETSOCK_WRITESOCK(i))) {\n              WSANETWORKEVENTS events = {0};\n              if(WSAEnumNetworkEvents(sockbunch[i], multi->wsa_event,\n                                      &events) == 0) {\n                if(ret && events.lNetworkEvents != 0)\n                  retcode++;\n              }\n              if(ret && !timeout_ms && !events.lNetworkEvents) {\n                if((bitmap & GETSOCK_READSOCK(i)) &&\n                   SOCKET_READABLE(sockbunch[i], 0) > 0)\n                  retcode++;\n                else if((bitmap & GETSOCK_WRITESOCK(i)) &&\n                   SOCKET_WRITABLE(sockbunch[i], 0) > 0)\n                  retcode++;\n              }\n              WSAEventSelect(sockbunch[i], multi->wsa_event, 0);\n            }\n            else\n              break;\n          }\n\n          data = data->next;\n        }\n      }\n\n      WSAResetEvent(multi->wsa_event);\n#else\n#ifdef ENABLE_WAKEUP\n      if(use_wakeup && multi->wakeup_pair[0] != CURL_SOCKET_BAD) {\n        if(ufds[curlfds + extra_nfds].revents & POLLIN) {\n          char buf[64];\n          ssize_t nread;\n          while(1) {\n            /* the reading socket is non-blocking, try to read\n               data from it until it receives an error (except EINTR).\n               In normal cases it will get EAGAIN or EWOULDBLOCK\n               when there is no more data, breaking the loop. */\n            nread = sread(multi->wakeup_pair[0], buf, sizeof(buf));\n            if(nread <= 0) {\n              if(nread < 0 && EINTR == SOCKERRNO)\n                continue;\n              break;\n            }\n          }\n          /* do not count the wakeup socket into the returned value */\n          retcode--;\n        }\n      }\n#endif\n#endif\n    }\n  }\n\n#ifndef USE_WINSOCK\n  if(ufds_malloc)\n    free(ufds);\n#endif\n  if(ret)\n    *ret = retcode;\n  if(!extrawait || nfds)\n    /* if any socket was checked */\n    ;\n  else {\n    long sleep_ms = 0;\n\n    /* Avoid busy-looping when there's nothing particular to wait for */\n    if(!curl_multi_timeout(multi, &sleep_ms) && sleep_ms) {\n      if(sleep_ms > timeout_ms)\n        sleep_ms = timeout_ms;\n      /* when there are no easy handles in the multi, this holds a -1\n         timeout */\n      else if(sleep_ms < 0)\n        sleep_ms = timeout_ms;\n      Curl_wait_ms(sleep_ms);\n    }\n  }\n\n  return CURLM_OK;\n}\n\nCURLMcode curl_multi_wait(struct Curl_multi *multi,\n                          struct curl_waitfd extra_fds[],\n                          unsigned int extra_nfds,\n                          int timeout_ms,\n                          int *ret)\n{\n  return Curl_multi_wait(multi, extra_fds, extra_nfds, timeout_ms, ret, FALSE,\n                         FALSE);\n}\n\nCURLMcode curl_multi_poll(struct Curl_multi *multi,\n                          struct curl_waitfd extra_fds[],\n                          unsigned int extra_nfds,\n                          int timeout_ms,\n                          int *ret)\n{\n  return Curl_multi_wait(multi, extra_fds, extra_nfds, timeout_ms, ret, TRUE,\n                         TRUE);\n}\n\nCURLMcode curl_multi_wakeup(struct Curl_multi *multi)\n{\n  /* this function is usually called from another thread,\n     it has to be careful only to access parts of the\n     Curl_multi struct that are constant */\n\n  /* GOOD_MULTI_HANDLE can be safely called */\n  if(!GOOD_MULTI_HANDLE(multi))\n    return CURLM_BAD_HANDLE;\n\n#ifdef ENABLE_WAKEUP\n#ifdef USE_WINSOCK\n  if(WSASetEvent(multi->wsa_event))\n    return CURLM_OK;\n#else\n  /* the wakeup_pair variable is only written during init and cleanup,\n     making it safe to access from another thread after the init part\n     and before cleanup */\n  if(multi->wakeup_pair[1] != CURL_SOCKET_BAD) {\n    char buf[1];\n    buf[0] = 1;\n    while(1) {\n      /* swrite() is not thread-safe in general, because concurrent calls\n         can have their messages interleaved, but in this case the content\n         of the messages does not matter, which makes it ok to call.\n\n         The write socket is set to non-blocking, this way this function\n         cannot block, making it safe to call even from the same thread\n         that will call Curl_multi_wait(). If swrite() returns that it\n         would block, it's considered successful because it means that\n         previous calls to this function will wake up the poll(). */\n      if(swrite(multi->wakeup_pair[1], buf, sizeof(buf)) < 0) {\n        int err = SOCKERRNO;\n        int return_success;\n#ifdef USE_WINSOCK\n        return_success = WSAEWOULDBLOCK == err;\n#else\n        if(EINTR == err)\n          continue;\n        return_success = EWOULDBLOCK == err || EAGAIN == err;\n#endif\n        if(!return_success)\n          return CURLM_WAKEUP_FAILURE;\n      }\n      return CURLM_OK;\n    }\n  }\n#endif\n#endif\n  return CURLM_WAKEUP_FAILURE;\n}\n\n/*\n * multi_ischanged() is called\n *\n * Returns TRUE/FALSE whether the state is changed to trigger a CONNECT_PEND\n * => CONNECT action.\n *\n * Set 'clear' to TRUE to have it also clear the state variable.\n */\nstatic bool multi_ischanged(struct Curl_multi *multi, bool clear)\n{\n  bool retval = multi->recheckstate;\n  if(clear)\n    multi->recheckstate = FALSE;\n  return retval;\n}\n\nCURLMcode Curl_multi_add_perform(struct Curl_multi *multi,\n                                 struct Curl_easy *data,\n                                 struct connectdata *conn)\n{\n  CURLMcode rc;\n\n  if(multi->in_callback)\n    return CURLM_RECURSIVE_API_CALL;\n\n  rc = curl_multi_add_handle(multi, data);\n  if(!rc) {\n    struct SingleRequest *k = &data->req;\n\n    /* pass in NULL for 'conn' here since we don't want to init the\n       connection, only this transfer */\n    Curl_init_do(data, NULL);\n\n    /* take this handle to the perform state right away */\n    multistate(data, CURLM_STATE_PERFORM);\n    Curl_attach_connnection(data, conn);\n    k->keepon |= KEEP_RECV; /* setup to receive! */\n  }\n  return rc;\n}\n\n/*\n * do_complete is called when the DO actions are complete.\n *\n * We init chunking and trailer bits to their default values here immediately\n * before receiving any header data for the current request.\n */\nstatic void do_complete(struct connectdata *conn)\n{\n  conn->data->req.chunk = FALSE;\n  Curl_pgrsTime(conn->data, TIMER_PRETRANSFER);\n}\n\nstatic CURLcode multi_do(struct Curl_easy *data, bool *done)\n{\n  CURLcode result = CURLE_OK;\n  struct connectdata *conn = data->conn;\n\n  DEBUGASSERT(conn);\n  DEBUGASSERT(conn->handler);\n  DEBUGASSERT(conn->data == data);\n\n  if(conn->handler->do_it) {\n    /* generic protocol-specific function pointer set in curl_connect() */\n    result = conn->handler->do_it(conn, done);\n\n    if(!result && *done)\n      /* do_complete must be called after the protocol-specific DO function */\n      do_complete(conn);\n  }\n  return result;\n}\n\n/*\n * multi_do_more() is called during the DO_MORE multi state. It is basically a\n * second stage DO state which (wrongly) was introduced to support FTP's\n * second connection.\n *\n * 'complete' can return 0 for incomplete, 1 for done and -1 for go back to\n * DOING state there's more work to do!\n */\n\nstatic CURLcode multi_do_more(struct connectdata *conn, int *complete)\n{\n  CURLcode result = CURLE_OK;\n\n  *complete = 0;\n\n  if(conn->handler->do_more)\n    result = conn->handler->do_more(conn, complete);\n\n  if(!result && (*complete == 1))\n    /* do_complete must be called after the protocol-specific DO function */\n    do_complete(conn);\n\n  return result;\n}\n\n/*\n * We are doing protocol-specific connecting and this is being called over and\n * over from the multi interface until the connection phase is done on\n * protocol layer.\n */\n\nstatic CURLcode protocol_connecting(struct connectdata *conn,\n                                    bool *done)\n{\n  CURLcode result = CURLE_OK;\n\n  if(conn && conn->handler->connecting) {\n    *done = FALSE;\n    result = conn->handler->connecting(conn, done);\n  }\n  else\n    *done = TRUE;\n\n  return result;\n}\n\n/*\n * We are DOING this is being called over and over from the multi interface\n * until the DOING phase is done on protocol layer.\n */\n\nstatic CURLcode protocol_doing(struct connectdata *conn, bool *done)\n{\n  CURLcode result = CURLE_OK;\n\n  if(conn && conn->handler->doing) {\n    *done = FALSE;\n    result = conn->handler->doing(conn, done);\n  }\n  else\n    *done = TRUE;\n\n  return result;\n}\n\n/*\n * We have discovered that the TCP connection has been successful, we can now\n * proceed with some action.\n *\n */\nstatic CURLcode protocol_connect(struct connectdata *conn,\n                                 bool *protocol_done)\n{\n  CURLcode result = CURLE_OK;\n\n  DEBUGASSERT(conn);\n  DEBUGASSERT(protocol_done);\n\n  *protocol_done = FALSE;\n\n  if(conn->bits.tcpconnect[FIRSTSOCKET] && conn->bits.protoconnstart) {\n    /* We already are connected, get back. This may happen when the connect\n       worked fine in the first call, like when we connect to a local server\n       or proxy. Note that we don't know if the protocol is actually done.\n\n       Unless this protocol doesn't have any protocol-connect callback, as\n       then we know we're done. */\n    if(!conn->handler->connecting)\n      *protocol_done = TRUE;\n\n    return CURLE_OK;\n  }\n\n  if(!conn->bits.protoconnstart) {\n#ifndef CURL_DISABLE_PROXY\n    result = Curl_proxy_connect(conn, FIRSTSOCKET);\n    if(result)\n      return result;\n\n    if(CONNECT_FIRSTSOCKET_PROXY_SSL())\n      /* wait for HTTPS proxy SSL initialization to complete */\n      return CURLE_OK;\n\n    if(conn->bits.tunnel_proxy && conn->bits.httpproxy &&\n       Curl_connect_ongoing(conn))\n      /* when using an HTTP tunnel proxy, await complete tunnel establishment\n         before proceeding further. Return CURLE_OK so we'll be called again */\n      return CURLE_OK;\n#endif\n    if(conn->handler->connect_it) {\n      /* is there a protocol-specific connect() procedure? */\n\n      /* Call the protocol-specific connect function */\n      result = conn->handler->connect_it(conn, protocol_done);\n    }\n    else\n      *protocol_done = TRUE;\n\n    /* it has started, possibly even completed but that knowledge isn't stored\n       in this bit! */\n    if(!result)\n      conn->bits.protoconnstart = TRUE;\n  }\n\n  return result; /* pass back status */\n}\n\n/*\n * Curl_preconnect() is called immediately before a connect starts. When a\n * redirect is followed, this is then called multiple times during a single\n * transfer.\n */\nCURLcode Curl_preconnect(struct Curl_easy *data)\n{\n  if(!data->state.buffer) {\n    data->state.buffer = malloc(data->set.buffer_size + 1);\n    if(!data->state.buffer)\n      return CURLE_OUT_OF_MEMORY;\n  }\n  return CURLE_OK;\n}\n\n\nstatic CURLMcode multi_runsingle(struct Curl_multi *multi,\n                                 struct curltime *nowp,\n                                 struct Curl_easy *data)\n{\n  struct Curl_message *msg = NULL;\n  bool connected;\n  bool async;\n  bool protocol_connected = FALSE;\n  bool dophase_done = FALSE;\n  bool done = FALSE;\n  CURLMcode rc;\n  CURLcode result = CURLE_OK;\n  timediff_t timeout_ms;\n  timediff_t recv_timeout_ms;\n  timediff_t send_timeout_ms;\n  int control;\n\n  if(!GOOD_EASY_HANDLE(data))\n    return CURLM_BAD_EASY_HANDLE;\n\n  do {\n    /* A \"stream\" here is a logical stream if the protocol can handle that\n       (HTTP/2), or the full connection for older protocols */\n    bool stream_error = FALSE;\n    rc = CURLM_OK;\n\n    if(multi_ischanged(multi, TRUE)) {\n      DEBUGF(infof(data, \"multi changed, check CONNECT_PEND queue!\\n\"));\n      process_pending_handles(multi); /* multiplexed */\n    }\n\n    if(data->conn && data->mstate > CURLM_STATE_CONNECT &&\n       data->mstate < CURLM_STATE_COMPLETED) {\n      /* Make sure we set the connection's current owner */\n      data->conn->data = data;\n    }\n\n    if(data->conn &&\n       (data->mstate >= CURLM_STATE_CONNECT) &&\n       (data->mstate < CURLM_STATE_COMPLETED)) {\n      /* we need to wait for the connect state as only then is the start time\n         stored, but we must not check already completed handles */\n      timeout_ms = Curl_timeleft(data, nowp,\n                                 (data->mstate <= CURLM_STATE_DO)?\n                                 TRUE:FALSE);\n\n      if(timeout_ms < 0) {\n        /* Handle timed out */\n        if(data->mstate == CURLM_STATE_WAITRESOLVE)\n          failf(data, \"Resolving timed out after %\" CURL_FORMAT_TIMEDIFF_T\n                \" milliseconds\",\n                Curl_timediff(*nowp, data->progress.t_startsingle));\n        else if(data->mstate == CURLM_STATE_WAITCONNECT)\n          failf(data, \"Connection timed out after %\" CURL_FORMAT_TIMEDIFF_T\n                \" milliseconds\",\n                Curl_timediff(*nowp, data->progress.t_startsingle));\n        else {\n          struct SingleRequest *k = &data->req;\n          if(k->size != -1) {\n            failf(data, \"Operation timed out after %\" CURL_FORMAT_TIMEDIFF_T\n                  \" milliseconds with %\" CURL_FORMAT_CURL_OFF_T \" out of %\"\n                  CURL_FORMAT_CURL_OFF_T \" bytes received\",\n                  Curl_timediff(*nowp, data->progress.t_startsingle),\n                  k->bytecount, k->size);\n          }\n          else {\n            failf(data, \"Operation timed out after %\" CURL_FORMAT_TIMEDIFF_T\n                  \" milliseconds with %\" CURL_FORMAT_CURL_OFF_T\n                  \" bytes received\",\n                  Curl_timediff(*nowp, data->progress.t_startsingle),\n                  k->bytecount);\n          }\n        }\n\n        /* Force connection closed if the connection has indeed been used */\n        if(data->mstate > CURLM_STATE_DO) {\n          streamclose(data->conn, \"Disconnected with pending data\");\n          stream_error = TRUE;\n        }\n        result = CURLE_OPERATION_TIMEDOUT;\n        (void)multi_done(data, result, TRUE);\n        /* Skip the statemachine and go directly to error handling section. */\n        goto statemachine_end;\n      }\n    }\n\n    switch(data->mstate) {\n    case CURLM_STATE_INIT:\n      /* init this transfer. */\n      result = Curl_pretransfer(data);\n\n      if(!result) {\n        /* after init, go CONNECT */\n        multistate(data, CURLM_STATE_CONNECT);\n        *nowp = Curl_pgrsTime(data, TIMER_STARTOP);\n        rc = CURLM_CALL_MULTI_PERFORM;\n      }\n      break;\n\n    case CURLM_STATE_CONNECT_PEND:\n      /* We will stay here until there is a connection available. Then\n         we try again in the CURLM_STATE_CONNECT state. */\n      break;\n\n    case CURLM_STATE_CONNECT:\n      /* Connect. We want to get a connection identifier filled in. */\n      /* init this transfer. */\n      result = Curl_preconnect(data);\n      if(result)\n        break;\n\n      *nowp = Curl_pgrsTime(data, TIMER_STARTSINGLE);\n      if(data->set.timeout)\n        Curl_expire(data, data->set.timeout, EXPIRE_TIMEOUT);\n\n      if(data->set.connecttimeout)\n        Curl_expire(data, data->set.connecttimeout, EXPIRE_CONNECTTIMEOUT);\n\n      result = Curl_connect(data, &async, &protocol_connected);\n      if(CURLE_NO_CONNECTION_AVAILABLE == result) {\n        /* There was no connection available. We will go to the pending\n           state and wait for an available connection. */\n        multistate(data, CURLM_STATE_CONNECT_PEND);\n\n        /* add this handle to the list of connect-pending handles */\n        Curl_llist_insert_next(&multi->pending, multi->pending.tail, data,\n                               &data->connect_queue);\n        result = CURLE_OK;\n        break;\n      }\n      else if(data->state.previouslypending) {\n        /* this transfer comes from the pending queue so try move another */\n        infof(data, \"Transfer was pending, now try another\\n\");\n        process_pending_handles(data->multi);\n      }\n\n      if(!result) {\n        if(async)\n          /* We're now waiting for an asynchronous name lookup */\n          multistate(data, CURLM_STATE_WAITRESOLVE);\n        else {\n          /* after the connect has been sent off, go WAITCONNECT unless the\n             protocol connect is already done and we can go directly to\n             WAITDO or DO! */\n          rc = CURLM_CALL_MULTI_PERFORM;\n\n          if(protocol_connected)\n            multistate(data, CURLM_STATE_DO);\n          else {\n#ifndef CURL_DISABLE_HTTP\n            if(Curl_connect_ongoing(data->conn))\n              multistate(data, CURLM_STATE_WAITPROXYCONNECT);\n            else\n#endif\n              multistate(data, CURLM_STATE_WAITCONNECT);\n          }\n        }\n      }\n      break;\n\n    case CURLM_STATE_WAITRESOLVE:\n      /* awaiting an asynch name resolve to complete */\n    {\n      struct Curl_dns_entry *dns = NULL;\n      struct connectdata *conn = data->conn;\n      const char *hostname;\n\n      DEBUGASSERT(conn);\n#ifndef CURL_DISABLE_PROXY\n      if(conn->bits.httpproxy)\n        hostname = conn->http_proxy.host.name;\n      else\n#endif\n        if(conn->bits.conn_to_host)\n        hostname = conn->conn_to_host.name;\n      else\n        hostname = conn->host.name;\n\n      /* check if we have the name resolved by now */\n      dns = Curl_fetch_addr(conn, hostname, (int)conn->port);\n\n      if(dns) {\n#ifdef CURLRES_ASYNCH\n        conn->async.dns = dns;\n        conn->async.done = TRUE;\n#endif\n        result = CURLE_OK;\n        infof(data, \"Hostname '%s' was found in DNS cache\\n\", hostname);\n      }\n\n      if(!dns)\n        result = Curl_resolv_check(data->conn, &dns);\n\n      /* Update sockets here, because the socket(s) may have been\n         closed and the application thus needs to be told, even if it\n         is likely that the same socket(s) will again be used further\n         down.  If the name has not yet been resolved, it is likely\n         that new sockets have been opened in an attempt to contact\n         another resolver. */\n      singlesocket(multi, data);\n\n      if(dns) {\n        /* Perform the next step in the connection phase, and then move on\n           to the WAITCONNECT state */\n        result = Curl_once_resolved(data->conn, &protocol_connected);\n\n        if(result)\n          /* if Curl_once_resolved() returns failure, the connection struct\n             is already freed and gone */\n          data->conn = NULL; /* no more connection */\n        else {\n          /* call again please so that we get the next socket setup */\n          rc = CURLM_CALL_MULTI_PERFORM;\n          if(protocol_connected)\n            multistate(data, CURLM_STATE_DO);\n          else {\n#ifndef CURL_DISABLE_HTTP\n            if(Curl_connect_ongoing(data->conn))\n              multistate(data, CURLM_STATE_WAITPROXYCONNECT);\n            else\n#endif\n              multistate(data, CURLM_STATE_WAITCONNECT);\n          }\n        }\n      }\n\n      if(result) {\n        /* failure detected */\n        stream_error = TRUE;\n        break;\n      }\n    }\n    break;\n\n#ifndef CURL_DISABLE_HTTP\n    case CURLM_STATE_WAITPROXYCONNECT:\n      /* this is HTTP-specific, but sending CONNECT to a proxy is HTTP... */\n      DEBUGASSERT(data->conn);\n      result = Curl_http_connect(data->conn, &protocol_connected);\n#ifndef CURL_DISABLE_PROXY\n      if(data->conn->bits.proxy_connect_closed) {\n        rc = CURLM_CALL_MULTI_PERFORM;\n        /* connect back to proxy again */\n        result = CURLE_OK;\n        multi_done(data, CURLE_OK, FALSE);\n        multistate(data, CURLM_STATE_CONNECT);\n      }\n      else\n#endif\n        if(!result) {\n          if(\n#ifndef CURL_DISABLE_PROXY\n            (data->conn->http_proxy.proxytype != CURLPROXY_HTTPS ||\n             data->conn->bits.proxy_ssl_connected[FIRSTSOCKET]) &&\n#endif\n            Curl_connect_complete(data->conn)) {\n            rc = CURLM_CALL_MULTI_PERFORM;\n            /* initiate protocol connect phase */\n            multistate(data, CURLM_STATE_SENDPROTOCONNECT);\n          }\n        }\n      else\n        stream_error = TRUE;\n      break;\n#endif\n\n    case CURLM_STATE_WAITCONNECT:\n      /* awaiting a completion of an asynch TCP connect */\n      DEBUGASSERT(data->conn);\n      result = Curl_is_connected(data->conn, FIRSTSOCKET, &connected);\n      if(connected && !result) {\n#ifndef CURL_DISABLE_HTTP\n        if(\n#ifndef CURL_DISABLE_PROXY\n          (data->conn->http_proxy.proxytype == CURLPROXY_HTTPS &&\n           !data->conn->bits.proxy_ssl_connected[FIRSTSOCKET]) ||\n#endif\n          Curl_connect_ongoing(data->conn)) {\n          multistate(data, CURLM_STATE_WAITPROXYCONNECT);\n          break;\n        }\n#endif\n        rc = CURLM_CALL_MULTI_PERFORM;\n#ifndef CURL_DISABLE_PROXY\n        multistate(data,\n                   data->conn->bits.tunnel_proxy?\n                   CURLM_STATE_WAITPROXYCONNECT:\n                   CURLM_STATE_SENDPROTOCONNECT);\n#else\n        multistate(data, CURLM_STATE_SENDPROTOCONNECT);\n#endif\n      }\n      else if(result) {\n        /* failure detected */\n        Curl_posttransfer(data);\n        multi_done(data, result, TRUE);\n        stream_error = TRUE;\n        break;\n      }\n      break;\n\n    case CURLM_STATE_SENDPROTOCONNECT:\n      result = protocol_connect(data->conn, &protocol_connected);\n      if(!result && !protocol_connected)\n        /* switch to waiting state */\n        multistate(data, CURLM_STATE_PROTOCONNECT);\n      else if(!result) {\n        /* protocol connect has completed, go WAITDO or DO */\n        multistate(data, CURLM_STATE_DO);\n        rc = CURLM_CALL_MULTI_PERFORM;\n      }\n      else {\n        /* failure detected */\n        Curl_posttransfer(data);\n        multi_done(data, result, TRUE);\n        stream_error = TRUE;\n      }\n      break;\n\n    case CURLM_STATE_PROTOCONNECT:\n      /* protocol-specific connect phase */\n      result = protocol_connecting(data->conn, &protocol_connected);\n      if(!result && protocol_connected) {\n        /* after the connect has completed, go WAITDO or DO */\n        multistate(data, CURLM_STATE_DO);\n        rc = CURLM_CALL_MULTI_PERFORM;\n      }\n      else if(result) {\n        /* failure detected */\n        Curl_posttransfer(data);\n        multi_done(data, result, TRUE);\n        stream_error = TRUE;\n      }\n      break;\n\n    case CURLM_STATE_DO:\n      if(data->set.connect_only) {\n        /* keep connection open for application to use the socket */\n        connkeep(data->conn, \"CONNECT_ONLY\");\n        multistate(data, CURLM_STATE_DONE);\n        result = CURLE_OK;\n        rc = CURLM_CALL_MULTI_PERFORM;\n      }\n      else {\n        /* Perform the protocol's DO action */\n        result = multi_do(data, &dophase_done);\n\n        /* When multi_do() returns failure, data->conn might be NULL! */\n\n        if(!result) {\n          if(!dophase_done) {\n#ifndef CURL_DISABLE_FTP\n            /* some steps needed for wildcard matching */\n            if(data->state.wildcardmatch) {\n              struct WildcardData *wc = &data->wildcard;\n              if(wc->state == CURLWC_DONE || wc->state == CURLWC_SKIP) {\n                /* skip some states if it is important */\n                multi_done(data, CURLE_OK, FALSE);\n                multistate(data, CURLM_STATE_DONE);\n                rc = CURLM_CALL_MULTI_PERFORM;\n                break;\n              }\n            }\n#endif\n            /* DO was not completed in one function call, we must continue\n               DOING... */\n            multistate(data, CURLM_STATE_DOING);\n            rc = CURLM_OK;\n          }\n\n          /* after DO, go DO_DONE... or DO_MORE */\n          else if(data->conn->bits.do_more) {\n            /* we're supposed to do more, but we need to sit down, relax\n               and wait a little while first */\n            multistate(data, CURLM_STATE_DO_MORE);\n            rc = CURLM_OK;\n          }\n          else {\n            /* we're done with the DO, now DO_DONE */\n            multistate(data, CURLM_STATE_DO_DONE);\n            rc = CURLM_CALL_MULTI_PERFORM;\n          }\n        }\n        else if((CURLE_SEND_ERROR == result) &&\n                data->conn->bits.reuse) {\n          /*\n           * In this situation, a connection that we were trying to use\n           * may have unexpectedly died.  If possible, send the connection\n           * back to the CONNECT phase so we can try again.\n           */\n          char *newurl = NULL;\n          followtype follow = FOLLOW_NONE;\n          CURLcode drc;\n\n          drc = Curl_retry_request(data->conn, &newurl);\n          if(drc) {\n            /* a failure here pretty much implies an out of memory */\n            result = drc;\n            stream_error = TRUE;\n          }\n\n          Curl_posttransfer(data);\n          drc = multi_done(data, result, FALSE);\n\n          /* When set to retry the connection, we must to go back to\n           * the CONNECT state */\n          if(newurl) {\n            if(!drc || (drc == CURLE_SEND_ERROR)) {\n              follow = FOLLOW_RETRY;\n              drc = Curl_follow(data, newurl, follow);\n              if(!drc) {\n                multistate(data, CURLM_STATE_CONNECT);\n                rc = CURLM_CALL_MULTI_PERFORM;\n                result = CURLE_OK;\n              }\n              else {\n                /* Follow failed */\n                result = drc;\n              }\n            }\n            else {\n              /* done didn't return OK or SEND_ERROR */\n              result = drc;\n            }\n          }\n          else {\n            /* Have error handler disconnect conn if we can't retry */\n            stream_error = TRUE;\n          }\n          free(newurl);\n        }\n        else {\n          /* failure detected */\n          Curl_posttransfer(data);\n          if(data->conn)\n            multi_done(data, result, FALSE);\n          stream_error = TRUE;\n        }\n      }\n      break;\n\n    case CURLM_STATE_DOING:\n      /* we continue DOING until the DO phase is complete */\n      DEBUGASSERT(data->conn);\n      result = protocol_doing(data->conn, &dophase_done);\n      if(!result) {\n        if(dophase_done) {\n          /* after DO, go DO_DONE or DO_MORE */\n          multistate(data, data->conn->bits.do_more?\n                     CURLM_STATE_DO_MORE:\n                     CURLM_STATE_DO_DONE);\n          rc = CURLM_CALL_MULTI_PERFORM;\n        } /* dophase_done */\n      }\n      else {\n        /* failure detected */\n        Curl_posttransfer(data);\n        multi_done(data, result, FALSE);\n        stream_error = TRUE;\n      }\n      break;\n\n    case CURLM_STATE_DO_MORE:\n      /*\n       * When we are connected, DO MORE and then go DO_DONE\n       */\n      DEBUGASSERT(data->conn);\n      result = multi_do_more(data->conn, &control);\n\n      if(!result) {\n        if(control) {\n          /* if positive, advance to DO_DONE\n             if negative, go back to DOING */\n          multistate(data, control == 1?\n                     CURLM_STATE_DO_DONE:\n                     CURLM_STATE_DOING);\n          rc = CURLM_CALL_MULTI_PERFORM;\n        }\n        else\n          /* stay in DO_MORE */\n          rc = CURLM_OK;\n      }\n      else {\n        /* failure detected */\n        Curl_posttransfer(data);\n        multi_done(data, result, FALSE);\n        stream_error = TRUE;\n      }\n      break;\n\n    case CURLM_STATE_DO_DONE:\n      DEBUGASSERT(data->conn);\n      if(data->conn->bits.multiplex)\n        /* Check if we can move pending requests to send pipe */\n        process_pending_handles(multi); /*  multiplexed */\n\n      /* Only perform the transfer if there's a good socket to work with.\n         Having both BAD is a signal to skip immediately to DONE */\n      if((data->conn->sockfd != CURL_SOCKET_BAD) ||\n         (data->conn->writesockfd != CURL_SOCKET_BAD))\n        multistate(data, CURLM_STATE_PERFORM);\n      else {\n#ifndef CURL_DISABLE_FTP\n        if(data->state.wildcardmatch &&\n           ((data->conn->handler->flags & PROTOPT_WILDCARD) == 0)) {\n          data->wildcard.state = CURLWC_DONE;\n        }\n#endif\n        multistate(data, CURLM_STATE_DONE);\n      }\n      rc = CURLM_CALL_MULTI_PERFORM;\n      break;\n\n    case CURLM_STATE_TOOFAST: /* limit-rate exceeded in either direction */\n      DEBUGASSERT(data->conn);\n      /* if both rates are within spec, resume transfer */\n      if(Curl_pgrsUpdate(data->conn))\n        result = CURLE_ABORTED_BY_CALLBACK;\n      else\n        result = Curl_speedcheck(data, *nowp);\n\n      if(!result) {\n        send_timeout_ms = 0;\n        if(data->set.max_send_speed > 0)\n          send_timeout_ms =\n            Curl_pgrsLimitWaitTime(data->progress.uploaded,\n                                   data->progress.ul_limit_size,\n                                   data->set.max_send_speed,\n                                   data->progress.ul_limit_start,\n                                   *nowp);\n\n        recv_timeout_ms = 0;\n        if(data->set.max_recv_speed > 0)\n          recv_timeout_ms =\n            Curl_pgrsLimitWaitTime(data->progress.downloaded,\n                                   data->progress.dl_limit_size,\n                                   data->set.max_recv_speed,\n                                   data->progress.dl_limit_start,\n                                   *nowp);\n\n        if(!send_timeout_ms && !recv_timeout_ms) {\n          multistate(data, CURLM_STATE_PERFORM);\n          Curl_ratelimit(data, *nowp);\n        }\n        else if(send_timeout_ms >= recv_timeout_ms)\n          Curl_expire(data, send_timeout_ms, EXPIRE_TOOFAST);\n        else\n          Curl_expire(data, recv_timeout_ms, EXPIRE_TOOFAST);\n      }\n      break;\n\n    case CURLM_STATE_PERFORM:\n    {\n      char *newurl = NULL;\n      bool retry = FALSE;\n      bool comeback = FALSE;\n      DEBUGASSERT(data->state.buffer);\n      /* check if over send speed */\n      send_timeout_ms = 0;\n      if(data->set.max_send_speed > 0)\n        send_timeout_ms = Curl_pgrsLimitWaitTime(data->progress.uploaded,\n                                                 data->progress.ul_limit_size,\n                                                 data->set.max_send_speed,\n                                                 data->progress.ul_limit_start,\n                                                 *nowp);\n\n      /* check if over recv speed */\n      recv_timeout_ms = 0;\n      if(data->set.max_recv_speed > 0)\n        recv_timeout_ms = Curl_pgrsLimitWaitTime(data->progress.downloaded,\n                                                 data->progress.dl_limit_size,\n                                                 data->set.max_recv_speed,\n                                                 data->progress.dl_limit_start,\n                                                 *nowp);\n\n      if(send_timeout_ms || recv_timeout_ms) {\n        Curl_ratelimit(data, *nowp);\n        multistate(data, CURLM_STATE_TOOFAST);\n        if(send_timeout_ms >= recv_timeout_ms)\n          Curl_expire(data, send_timeout_ms, EXPIRE_TOOFAST);\n        else\n          Curl_expire(data, recv_timeout_ms, EXPIRE_TOOFAST);\n        break;\n      }\n\n      /* read/write data if it is ready to do so */\n      result = Curl_readwrite(data->conn, data, &done, &comeback);\n\n      if(done || (result == CURLE_RECV_ERROR)) {\n        /* If CURLE_RECV_ERROR happens early enough, we assume it was a race\n         * condition and the server closed the re-used connection exactly when\n         * we wanted to use it, so figure out if that is indeed the case.\n         */\n        CURLcode ret = Curl_retry_request(data->conn, &newurl);\n        if(!ret)\n          retry = (newurl)?TRUE:FALSE;\n        else if(!result)\n          result = ret;\n\n        if(retry) {\n          /* if we are to retry, set the result to OK and consider the\n             request as done */\n          result = CURLE_OK;\n          done = TRUE;\n        }\n      }\n      else if((CURLE_HTTP2_STREAM == result) &&\n              Curl_h2_http_1_1_error(data->conn)) {\n        CURLcode ret = Curl_retry_request(data->conn, &newurl);\n\n        if(!ret) {\n          infof(data, \"Downgrades to HTTP/1.1!\\n\");\n          data->set.httpversion = CURL_HTTP_VERSION_1_1;\n          /* clear the error message bit too as we ignore the one we got */\n          data->state.errorbuf = FALSE;\n          if(!newurl)\n            /* typically for HTTP_1_1_REQUIRED error on first flight */\n            newurl = strdup(data->change.url);\n          /* if we are to retry, set the result to OK and consider the request\n             as done */\n          retry = TRUE;\n          result = CURLE_OK;\n          done = TRUE;\n        }\n        else\n          result = ret;\n      }\n\n      if(result) {\n        /*\n         * The transfer phase returned error, we mark the connection to get\n         * closed to prevent being re-used. This is because we can't possibly\n         * know if the connection is in a good shape or not now.  Unless it is\n         * a protocol which uses two \"channels\" like FTP, as then the error\n         * happened in the data connection.\n         */\n\n        if(!(data->conn->handler->flags & PROTOPT_DUAL) &&\n           result != CURLE_HTTP2_STREAM)\n          streamclose(data->conn, \"Transfer returned error\");\n\n        Curl_posttransfer(data);\n        multi_done(data, result, TRUE);\n      }\n      else if(done) {\n        followtype follow = FOLLOW_NONE;\n\n        /* call this even if the readwrite function returned error */\n        Curl_posttransfer(data);\n\n        /* When we follow redirects or is set to retry the connection, we must\n           to go back to the CONNECT state */\n        if(data->req.newurl || retry) {\n          if(!retry) {\n            /* if the URL is a follow-location and not just a retried request\n               then figure out the URL here */\n            free(newurl);\n            newurl = data->req.newurl;\n            data->req.newurl = NULL;\n            follow = FOLLOW_REDIR;\n          }\n          else\n            follow = FOLLOW_RETRY;\n          (void)multi_done(data, CURLE_OK, FALSE);\n          /* multi_done() might return CURLE_GOT_NOTHING */\n          result = Curl_follow(data, newurl, follow);\n          if(!result) {\n            multistate(data, CURLM_STATE_CONNECT);\n            rc = CURLM_CALL_MULTI_PERFORM;\n          }\n          free(newurl);\n        }\n        else {\n          /* after the transfer is done, go DONE */\n\n          /* but first check to see if we got a location info even though we're\n             not following redirects */\n          if(data->req.location) {\n            free(newurl);\n            newurl = data->req.location;\n            data->req.location = NULL;\n            result = Curl_follow(data, newurl, FOLLOW_FAKE);\n            free(newurl);\n            if(result) {\n              stream_error = TRUE;\n              result = multi_done(data, result, TRUE);\n            }\n          }\n\n          if(!result) {\n            multistate(data, CURLM_STATE_DONE);\n            rc = CURLM_CALL_MULTI_PERFORM;\n          }\n        }\n      }\n      else if(comeback) {\n        /* This avoids CURLM_CALL_MULTI_PERFORM so that a very fast transfer\n           won't get stuck on this transfer at the expense of other concurrent\n           transfers */\n        Curl_expire(data, 0, EXPIRE_RUN_NOW);\n        rc = CURLM_OK;\n      }\n      break;\n    }\n\n    case CURLM_STATE_DONE:\n      /* this state is highly transient, so run another loop after this */\n      rc = CURLM_CALL_MULTI_PERFORM;\n\n      if(data->conn) {\n        CURLcode res;\n\n        if(data->conn->bits.multiplex)\n          /* Check if we can move pending requests to connection */\n          process_pending_handles(multi); /* multiplexing */\n\n        /* post-transfer command */\n        res = multi_done(data, result, FALSE);\n\n        /* allow a previously set error code take precedence */\n        if(!result)\n          result = res;\n\n        /*\n         * If there are other handles on the connection, multi_done won't set\n         * conn to NULL.  In such a case, curl_multi_remove_handle() can\n         * access free'd data, if the connection is free'd and the handle\n         * removed before we perform the processing in CURLM_STATE_COMPLETED\n         */\n        Curl_detach_connnection(data);\n      }\n\n#ifndef CURL_DISABLE_FTP\n      if(data->state.wildcardmatch) {\n        if(data->wildcard.state != CURLWC_DONE) {\n          /* if a wildcard is set and we are not ending -> lets start again\n             with CURLM_STATE_INIT */\n          multistate(data, CURLM_STATE_INIT);\n          break;\n        }\n      }\n#endif\n      /* after we have DONE what we're supposed to do, go COMPLETED, and\n         it doesn't matter what the multi_done() returned! */\n      multistate(data, CURLM_STATE_COMPLETED);\n      break;\n\n    case CURLM_STATE_COMPLETED:\n      break;\n\n    case CURLM_STATE_MSGSENT:\n      data->result = result;\n      return CURLM_OK; /* do nothing */\n\n    default:\n      return CURLM_INTERNAL_ERROR;\n    }\n    statemachine_end:\n\n    if(data->mstate < CURLM_STATE_COMPLETED) {\n      if(result) {\n        /*\n         * If an error was returned, and we aren't in completed state now,\n         * then we go to completed and consider this transfer aborted.\n         */\n\n        /* NOTE: no attempt to disconnect connections must be made\n           in the case blocks above - cleanup happens only here */\n\n        /* Check if we can move pending requests to send pipe */\n        process_pending_handles(multi); /* connection */\n\n        if(data->conn) {\n          if(stream_error) {\n            /* Don't attempt to send data over a connection that timed out */\n            bool dead_connection = result == CURLE_OPERATION_TIMEDOUT;\n            struct connectdata *conn = data->conn;\n\n            /* This is where we make sure that the conn pointer is reset.\n               We don't have to do this in every case block above where a\n               failure is detected */\n            Curl_detach_connnection(data);\n\n            /* remove connection from cache */\n            Curl_conncache_remove_conn(data, conn, TRUE);\n\n            /* disconnect properly */\n            Curl_disconnect(data, conn, dead_connection);\n          }\n        }\n        else if(data->mstate == CURLM_STATE_CONNECT) {\n          /* Curl_connect() failed */\n          (void)Curl_posttransfer(data);\n        }\n\n        multistate(data, CURLM_STATE_COMPLETED);\n        rc = CURLM_CALL_MULTI_PERFORM;\n      }\n      /* if there's still a connection to use, call the progress function */\n      else if(data->conn && Curl_pgrsUpdate(data->conn)) {\n        /* aborted due to progress callback return code must close the\n           connection */\n        result = CURLE_ABORTED_BY_CALLBACK;\n        streamclose(data->conn, \"Aborted by callback\");\n\n        /* if not yet in DONE state, go there, otherwise COMPLETED */\n        multistate(data, (data->mstate < CURLM_STATE_DONE)?\n                   CURLM_STATE_DONE: CURLM_STATE_COMPLETED);\n        rc = CURLM_CALL_MULTI_PERFORM;\n      }\n    }\n\n    if(CURLM_STATE_COMPLETED == data->mstate) {\n      if(data->set.fmultidone) {\n        /* signal via callback instead */\n        data->set.fmultidone(data, result);\n      }\n      else {\n        /* now fill in the Curl_message with this info */\n        msg = &data->msg;\n\n        msg->extmsg.msg = CURLMSG_DONE;\n        msg->extmsg.easy_handle = data;\n        msg->extmsg.data.result = result;\n\n        rc = multi_addmsg(multi, msg);\n        DEBUGASSERT(!data->conn);\n      }\n      multistate(data, CURLM_STATE_MSGSENT);\n    }\n  } while((rc == CURLM_CALL_MULTI_PERFORM) || multi_ischanged(multi, FALSE));\n\n  data->result = result;\n  return rc;\n}\n\n\nCURLMcode curl_multi_perform(struct Curl_multi *multi, int *running_handles)\n{\n  struct Curl_easy *data;\n  CURLMcode returncode = CURLM_OK;\n  struct Curl_tree *t;\n  struct curltime now = Curl_now();\n\n  if(!GOOD_MULTI_HANDLE(multi))\n    return CURLM_BAD_HANDLE;\n\n  if(multi->in_callback)\n    return CURLM_RECURSIVE_API_CALL;\n\n  data = multi->easyp;\n  while(data) {\n    CURLMcode result;\n    SIGPIPE_VARIABLE(pipe_st);\n\n    sigpipe_ignore(data, &pipe_st);\n    result = multi_runsingle(multi, &now, data);\n    sigpipe_restore(&pipe_st);\n\n    if(result)\n      returncode = result;\n\n    data = data->next; /* operate on next handle */\n  }\n\n  /*\n   * Simply remove all expired timers from the splay since handles are dealt\n   * with unconditionally by this function and curl_multi_timeout() requires\n   * that already passed/handled expire times are removed from the splay.\n   *\n   * It is important that the 'now' value is set at the entry of this function\n   * and not for the current time as it may have ticked a little while since\n   * then and then we risk this loop to remove timers that actually have not\n   * been handled!\n   */\n  do {\n    multi->timetree = Curl_splaygetbest(now, multi->timetree, &t);\n    if(t)\n      /* the removed may have another timeout in queue */\n      (void)add_next_timeout(now, multi, t->payload);\n\n  } while(t);\n\n  *running_handles = multi->num_alive;\n\n  if(CURLM_OK >= returncode)\n    Curl_update_timer(multi);\n\n  return returncode;\n}\n\nCURLMcode curl_multi_cleanup(struct Curl_multi *multi)\n{\n  struct Curl_easy *data;\n  struct Curl_easy *nextdata;\n\n  if(GOOD_MULTI_HANDLE(multi)) {\n    if(multi->in_callback)\n      return CURLM_RECURSIVE_API_CALL;\n\n    multi->type = 0; /* not good anymore */\n\n    /* Firsrt remove all remaining easy handles */\n    data = multi->easyp;\n    while(data) {\n      nextdata = data->next;\n      if(!data->state.done && data->conn)\n        /* if DONE was never called for this handle */\n        (void)multi_done(data, CURLE_OK, TRUE);\n      if(data->dns.hostcachetype == HCACHE_MULTI) {\n        /* clear out the usage of the shared DNS cache */\n        Curl_hostcache_clean(data, data->dns.hostcache);\n        data->dns.hostcache = NULL;\n        data->dns.hostcachetype = HCACHE_NONE;\n      }\n\n      /* Clear the pointer to the connection cache */\n      data->state.conn_cache = NULL;\n      data->multi = NULL; /* clear the association */\n\n#ifdef USE_LIBPSL\n      if(data->psl == &multi->psl)\n        data->psl = NULL;\n#endif\n\n      data = nextdata;\n    }\n\n    /* Close all the connections in the connection cache */\n    Curl_conncache_close_all_connections(&multi->conn_cache);\n\n    Curl_hash_destroy(&multi->sockhash);\n    Curl_conncache_destroy(&multi->conn_cache);\n    Curl_llist_destroy(&multi->msglist, NULL);\n    Curl_llist_destroy(&multi->pending, NULL);\n\n    Curl_hash_destroy(&multi->hostcache);\n    Curl_psl_destroy(&multi->psl);\n\n#ifdef USE_WINSOCK\n    WSACloseEvent(multi->wsa_event);\n#else\n#ifdef ENABLE_WAKEUP\n    sclose(multi->wakeup_pair[0]);\n    sclose(multi->wakeup_pair[1]);\n#endif\n#endif\n    free(multi);\n\n    return CURLM_OK;\n  }\n  return CURLM_BAD_HANDLE;\n}\n\n/*\n * curl_multi_info_read()\n *\n * This function is the primary way for a multi/multi_socket application to\n * figure out if a transfer has ended. We MUST make this function as fast as\n * possible as it will be polled frequently and we MUST NOT scan any lists in\n * here to figure out things. We must scale fine to thousands of handles and\n * beyond. The current design is fully O(1).\n */\n\nCURLMsg *curl_multi_info_read(struct Curl_multi *multi, int *msgs_in_queue)\n{\n  struct Curl_message *msg;\n\n  *msgs_in_queue = 0; /* default to none */\n\n  if(GOOD_MULTI_HANDLE(multi) &&\n     !multi->in_callback &&\n     Curl_llist_count(&multi->msglist)) {\n    /* there is one or more messages in the list */\n    struct curl_llist_element *e;\n\n    /* extract the head of the list to return */\n    e = multi->msglist.head;\n\n    msg = e->ptr;\n\n    /* remove the extracted entry */\n    Curl_llist_remove(&multi->msglist, e, NULL);\n\n    *msgs_in_queue = curlx_uztosi(Curl_llist_count(&multi->msglist));\n\n    return &msg->extmsg;\n  }\n  return NULL;\n}\n\n/*\n * singlesocket() checks what sockets we deal with and their \"action state\"\n * and if we have a different state in any of those sockets from last time we\n * call the callback accordingly.\n */\nstatic CURLMcode singlesocket(struct Curl_multi *multi,\n                              struct Curl_easy *data)\n{\n  curl_socket_t socks[MAX_SOCKSPEREASYHANDLE];\n  int i;\n  struct Curl_sh_entry *entry;\n  curl_socket_t s;\n  int num;\n  unsigned int curraction;\n  int actions[MAX_SOCKSPEREASYHANDLE];\n\n  for(i = 0; i< MAX_SOCKSPEREASYHANDLE; i++)\n    socks[i] = CURL_SOCKET_BAD;\n\n  /* Fill in the 'current' struct with the state as it is now: what sockets to\n     supervise and for what actions */\n  curraction = multi_getsock(data, socks);\n\n  /* We have 0 .. N sockets already and we get to know about the 0 .. M\n     sockets we should have from now on. Detect the differences, remove no\n     longer supervised ones and add new ones */\n\n  /* walk over the sockets we got right now */\n  for(i = 0; (i< MAX_SOCKSPEREASYHANDLE) &&\n        (curraction & (GETSOCK_READSOCK(i) | GETSOCK_WRITESOCK(i)));\n      i++) {\n    unsigned int action = CURL_POLL_NONE;\n    unsigned int prevaction = 0;\n    unsigned int comboaction;\n    bool sincebefore = FALSE;\n\n    s = socks[i];\n\n    /* get it from the hash */\n    entry = sh_getentry(&multi->sockhash, s);\n\n    if(curraction & GETSOCK_READSOCK(i))\n      action |= CURL_POLL_IN;\n    if(curraction & GETSOCK_WRITESOCK(i))\n      action |= CURL_POLL_OUT;\n\n    actions[i] = action;\n    if(entry) {\n      /* check if new for this transfer */\n      int j;\n      for(j = 0; j< data->numsocks; j++) {\n        if(s == data->sockets[j]) {\n          prevaction = data->actions[j];\n          sincebefore = TRUE;\n          break;\n        }\n      }\n    }\n    else {\n      /* this is a socket we didn't have before, add it to the hash! */\n      entry = sh_addentry(&multi->sockhash, s);\n      if(!entry)\n        /* fatal */\n        return CURLM_OUT_OF_MEMORY;\n    }\n    if(sincebefore && (prevaction != action)) {\n      /* Socket was used already, but different action now */\n      if(prevaction & CURL_POLL_IN)\n        entry->readers--;\n      if(prevaction & CURL_POLL_OUT)\n        entry->writers--;\n      if(action & CURL_POLL_IN)\n        entry->readers++;\n      if(action & CURL_POLL_OUT)\n        entry->writers++;\n    }\n    else if(!sincebefore) {\n      /* a new user */\n      entry->users++;\n      if(action & CURL_POLL_IN)\n        entry->readers++;\n      if(action & CURL_POLL_OUT)\n        entry->writers++;\n\n      /* add 'data' to the transfer hash on this socket! */\n      if(!Curl_hash_add(&entry->transfers, (char *)&data, /* hash key */\n                        sizeof(struct Curl_easy *), data))\n        return CURLM_OUT_OF_MEMORY;\n    }\n\n    comboaction = (entry->writers? CURL_POLL_OUT : 0) |\n      (entry->readers ? CURL_POLL_IN : 0);\n\n    /* socket existed before and has the same action set as before */\n    if(sincebefore && (entry->action == comboaction))\n      /* same, continue */\n      continue;\n\n    if(multi->socket_cb)\n      multi->socket_cb(data, s, comboaction, multi->socket_userp,\n                       entry->socketp);\n\n    entry->action = comboaction; /* store the current action state */\n  }\n\n  num = i; /* number of sockets */\n\n  /* when we've walked over all the sockets we should have right now, we must\n     make sure to detect sockets that are removed */\n  for(i = 0; i< data->numsocks; i++) {\n    int j;\n    bool stillused = FALSE;\n    s = data->sockets[i];\n    for(j = 0; j < num; j++) {\n      if(s == socks[j]) {\n        /* this is still supervised */\n        stillused = TRUE;\n        break;\n      }\n    }\n    if(stillused)\n      continue;\n\n    entry = sh_getentry(&multi->sockhash, s);\n    /* if this is NULL here, the socket has been closed and notified so\n       already by Curl_multi_closed() */\n    if(entry) {\n      int oldactions = data->actions[i];\n      /* this socket has been removed. Decrease user count */\n      entry->users--;\n      if(oldactions & CURL_POLL_OUT)\n        entry->writers--;\n      if(oldactions & CURL_POLL_IN)\n        entry->readers--;\n      if(!entry->users) {\n        if(multi->socket_cb)\n          multi->socket_cb(data, s, CURL_POLL_REMOVE,\n                           multi->socket_userp,\n                           entry->socketp);\n        sh_delentry(entry, &multi->sockhash, s);\n      }\n      else {\n        /* still users, but remove this handle as a user of this socket */\n        if(Curl_hash_delete(&entry->transfers, (char *)&data,\n                            sizeof(struct Curl_easy *))) {\n          DEBUGASSERT(NULL);\n        }\n      }\n    }\n  } /* for loop over numsocks */\n\n  memcpy(data->sockets, socks, num*sizeof(curl_socket_t));\n  memcpy(data->actions, actions, num*sizeof(int));\n  data->numsocks = num;\n  return CURLM_OK;\n}\n\nvoid Curl_updatesocket(struct Curl_easy *data)\n{\n  singlesocket(data->multi, data);\n}\n\n\n/*\n * Curl_multi_closed()\n *\n * Used by the connect code to tell the multi_socket code that one of the\n * sockets we were using is about to be closed.  This function will then\n * remove it from the sockethash for this handle to make the multi_socket API\n * behave properly, especially for the case when libcurl will create another\n * socket again and it gets the same file descriptor number.\n */\n\nvoid Curl_multi_closed(struct Curl_easy *data, curl_socket_t s)\n{\n  if(data) {\n    /* if there's still an easy handle associated with this connection */\n    struct Curl_multi *multi = data->multi;\n    if(multi) {\n      /* this is set if this connection is part of a handle that is added to\n         a multi handle, and only then this is necessary */\n      struct Curl_sh_entry *entry = sh_getentry(&multi->sockhash, s);\n\n      if(entry) {\n        if(multi->socket_cb)\n          multi->socket_cb(data, s, CURL_POLL_REMOVE,\n                           multi->socket_userp,\n                           entry->socketp);\n\n        /* now remove it from the socket hash */\n        sh_delentry(entry, &multi->sockhash, s);\n      }\n    }\n  }\n}\n\n/*\n * add_next_timeout()\n *\n * Each Curl_easy has a list of timeouts. The add_next_timeout() is called\n * when it has just been removed from the splay tree because the timeout has\n * expired. This function is then to advance in the list to pick the next\n * timeout to use (skip the already expired ones) and add this node back to\n * the splay tree again.\n *\n * The splay tree only has each sessionhandle as a single node and the nearest\n * timeout is used to sort it on.\n */\nstatic CURLMcode add_next_timeout(struct curltime now,\n                                  struct Curl_multi *multi,\n                                  struct Curl_easy *d)\n{\n  struct curltime *tv = &d->state.expiretime;\n  struct curl_llist *list = &d->state.timeoutlist;\n  struct curl_llist_element *e;\n  struct time_node *node = NULL;\n\n  /* move over the timeout list for this specific handle and remove all\n     timeouts that are now passed tense and store the next pending\n     timeout in *tv */\n  for(e = list->head; e;) {\n    struct curl_llist_element *n = e->next;\n    timediff_t diff;\n    node = (struct time_node *)e->ptr;\n    diff = Curl_timediff(node->time, now);\n    if(diff <= 0)\n      /* remove outdated entry */\n      Curl_llist_remove(list, e, NULL);\n    else\n      /* the list is sorted so get out on the first mismatch */\n      break;\n    e = n;\n  }\n  e = list->head;\n  if(!e) {\n    /* clear the expire times within the handles that we remove from the\n       splay tree */\n    tv->tv_sec = 0;\n    tv->tv_usec = 0;\n  }\n  else {\n    /* copy the first entry to 'tv' */\n    memcpy(tv, &node->time, sizeof(*tv));\n\n    /* Insert this node again into the splay.  Keep the timer in the list in\n       case we need to recompute future timers. */\n    multi->timetree = Curl_splayinsert(*tv, multi->timetree,\n                                       &d->state.timenode);\n  }\n  return CURLM_OK;\n}\n\nstatic CURLMcode multi_socket(struct Curl_multi *multi,\n                              bool checkall,\n                              curl_socket_t s,\n                              int ev_bitmask,\n                              int *running_handles)\n{\n  CURLMcode result = CURLM_OK;\n  struct Curl_easy *data = NULL;\n  struct Curl_tree *t;\n  struct curltime now = Curl_now();\n\n  if(checkall) {\n    /* *perform() deals with running_handles on its own */\n    result = curl_multi_perform(multi, running_handles);\n\n    /* walk through each easy handle and do the socket state change magic\n       and callbacks */\n    if(result != CURLM_BAD_HANDLE) {\n      data = multi->easyp;\n      while(data && !result) {\n        result = singlesocket(multi, data);\n        data = data->next;\n      }\n    }\n\n    /* or should we fall-through and do the timer-based stuff? */\n    return result;\n  }\n  if(s != CURL_SOCKET_TIMEOUT) {\n    struct Curl_sh_entry *entry = sh_getentry(&multi->sockhash, s);\n\n    if(!entry)\n      /* Unmatched socket, we can't act on it but we ignore this fact.  In\n         real-world tests it has been proved that libevent can in fact give\n         the application actions even though the socket was just previously\n         asked to get removed, so thus we better survive stray socket actions\n         and just move on. */\n      ;\n    else {\n      struct curl_hash_iterator iter;\n      struct curl_hash_element *he;\n\n      /* the socket can be shared by many transfers, iterate */\n      Curl_hash_start_iterate(&entry->transfers, &iter);\n      for(he = Curl_hash_next_element(&iter); he;\n          he = Curl_hash_next_element(&iter)) {\n        data = (struct Curl_easy *)he->ptr;\n        DEBUGASSERT(data);\n        DEBUGASSERT(data->magic == CURLEASY_MAGIC_NUMBER);\n\n        if(data->conn && !(data->conn->handler->flags & PROTOPT_DIRLOCK))\n          /* set socket event bitmask if they're not locked */\n          data->conn->cselect_bits = ev_bitmask;\n\n        Curl_expire(data, 0, EXPIRE_RUN_NOW);\n      }\n\n      /* Now we fall-through and do the timer-based stuff, since we don't want\n         to force the user to have to deal with timeouts as long as at least\n         one connection in fact has traffic. */\n\n      data = NULL; /* set data to NULL again to avoid calling\n                      multi_runsingle() in case there's no need to */\n      now = Curl_now(); /* get a newer time since the multi_runsingle() loop\n                           may have taken some time */\n    }\n  }\n  else {\n    /* Asked to run due to time-out. Clear the 'lastcall' variable to force\n       Curl_update_timer() to trigger a callback to the app again even if the\n       same timeout is still the one to run after this call. That handles the\n       case when the application asks libcurl to run the timeout\n       prematurely. */\n    memset(&multi->timer_lastcall, 0, sizeof(multi->timer_lastcall));\n  }\n\n  /*\n   * The loop following here will go on as long as there are expire-times left\n   * to process in the splay and 'data' will be re-assigned for every expired\n   * handle we deal with.\n   */\n  do {\n    /* the first loop lap 'data' can be NULL */\n    if(data) {\n      SIGPIPE_VARIABLE(pipe_st);\n\n      sigpipe_ignore(data, &pipe_st);\n      result = multi_runsingle(multi, &now, data);\n      sigpipe_restore(&pipe_st);\n\n      if(CURLM_OK >= result) {\n        /* get the socket(s) and check if the state has been changed since\n           last */\n        result = singlesocket(multi, data);\n        if(result)\n          return result;\n      }\n    }\n\n    /* Check if there's one (more) expired timer to deal with! This function\n       extracts a matching node if there is one */\n\n    multi->timetree = Curl_splaygetbest(now, multi->timetree, &t);\n    if(t) {\n      data = t->payload; /* assign this for next loop */\n      (void)add_next_timeout(now, multi, t->payload);\n    }\n\n  } while(t);\n\n  *running_handles = multi->num_alive;\n  return result;\n}\n\n#undef curl_multi_setopt\nCURLMcode curl_multi_setopt(struct Curl_multi *multi,\n                            CURLMoption option, ...)\n{\n  CURLMcode res = CURLM_OK;\n  va_list param;\n\n  if(!GOOD_MULTI_HANDLE(multi))\n    return CURLM_BAD_HANDLE;\n\n  if(multi->in_callback)\n    return CURLM_RECURSIVE_API_CALL;\n\n  va_start(param, option);\n\n  switch(option) {\n  case CURLMOPT_SOCKETFUNCTION:\n    multi->socket_cb = va_arg(param, curl_socket_callback);\n    break;\n  case CURLMOPT_SOCKETDATA:\n    multi->socket_userp = va_arg(param, void *);\n    break;\n  case CURLMOPT_PUSHFUNCTION:\n    multi->push_cb = va_arg(param, curl_push_callback);\n    break;\n  case CURLMOPT_PUSHDATA:\n    multi->push_userp = va_arg(param, void *);\n    break;\n  case CURLMOPT_PIPELINING:\n    multi->multiplexing = va_arg(param, long) & CURLPIPE_MULTIPLEX;\n    break;\n  case CURLMOPT_TIMERFUNCTION:\n    multi->timer_cb = va_arg(param, curl_multi_timer_callback);\n    break;\n  case CURLMOPT_TIMERDATA:\n    multi->timer_userp = va_arg(param, void *);\n    break;\n  case CURLMOPT_MAXCONNECTS:\n    multi->maxconnects = va_arg(param, long);\n    break;\n  case CURLMOPT_MAX_HOST_CONNECTIONS:\n    multi->max_host_connections = va_arg(param, long);\n    break;\n  case CURLMOPT_MAX_TOTAL_CONNECTIONS:\n    multi->max_total_connections = va_arg(param, long);\n    break;\n    /* options formerly used for pipelining */\n  case CURLMOPT_MAX_PIPELINE_LENGTH:\n    break;\n  case CURLMOPT_CONTENT_LENGTH_PENALTY_SIZE:\n    break;\n  case CURLMOPT_CHUNK_LENGTH_PENALTY_SIZE:\n    break;\n  case CURLMOPT_PIPELINING_SITE_BL:\n    break;\n  case CURLMOPT_PIPELINING_SERVER_BL:\n    break;\n  case CURLMOPT_MAX_CONCURRENT_STREAMS:\n    {\n      long streams = va_arg(param, long);\n      if(streams < 1)\n        streams = 100;\n      multi->max_concurrent_streams = curlx_sltoui(streams);\n    }\n    break;\n  default:\n    res = CURLM_UNKNOWN_OPTION;\n    break;\n  }\n  va_end(param);\n  return res;\n}\n\n/* we define curl_multi_socket() in the public multi.h header */\n#undef curl_multi_socket\n\nCURLMcode curl_multi_socket(struct Curl_multi *multi, curl_socket_t s,\n                            int *running_handles)\n{\n  CURLMcode result;\n  if(multi->in_callback)\n    return CURLM_RECURSIVE_API_CALL;\n  result = multi_socket(multi, FALSE, s, 0, running_handles);\n  if(CURLM_OK >= result)\n    Curl_update_timer(multi);\n  return result;\n}\n\nCURLMcode curl_multi_socket_action(struct Curl_multi *multi, curl_socket_t s,\n                                   int ev_bitmask, int *running_handles)\n{\n  CURLMcode result;\n  if(multi->in_callback)\n    return CURLM_RECURSIVE_API_CALL;\n  result = multi_socket(multi, FALSE, s, ev_bitmask, running_handles);\n  if(CURLM_OK >= result)\n    Curl_update_timer(multi);\n  return result;\n}\n\nCURLMcode curl_multi_socket_all(struct Curl_multi *multi, int *running_handles)\n\n{\n  CURLMcode result;\n  if(multi->in_callback)\n    return CURLM_RECURSIVE_API_CALL;\n  result = multi_socket(multi, TRUE, CURL_SOCKET_BAD, 0, running_handles);\n  if(CURLM_OK >= result)\n    Curl_update_timer(multi);\n  return result;\n}\n\nstatic CURLMcode multi_timeout(struct Curl_multi *multi,\n                               long *timeout_ms)\n{\n  static struct curltime tv_zero = {0, 0};\n\n  if(multi->timetree) {\n    /* we have a tree of expire times */\n    struct curltime now = Curl_now();\n\n    /* splay the lowest to the bottom */\n    multi->timetree = Curl_splay(tv_zero, multi->timetree);\n\n    if(Curl_splaycomparekeys(multi->timetree->key, now) > 0) {\n      /* some time left before expiration */\n      timediff_t diff = Curl_timediff(multi->timetree->key, now);\n      if(diff <= 0)\n        /*\n         * Since we only provide millisecond resolution on the returned value\n         * and the diff might be less than one millisecond here, we don't\n         * return zero as that may cause short bursts of busyloops on fast\n         * processors while the diff is still present but less than one\n         * millisecond! instead we return 1 until the time is ripe.\n         */\n        *timeout_ms = 1;\n      else\n        /* this should be safe even on 64 bit archs, as we don't use that\n           overly long timeouts */\n        *timeout_ms = (long)diff;\n    }\n    else\n      /* 0 means immediately */\n      *timeout_ms = 0;\n  }\n  else\n    *timeout_ms = -1;\n\n  return CURLM_OK;\n}\n\nCURLMcode curl_multi_timeout(struct Curl_multi *multi,\n                             long *timeout_ms)\n{\n  /* First, make some basic checks that the CURLM handle is a good handle */\n  if(!GOOD_MULTI_HANDLE(multi))\n    return CURLM_BAD_HANDLE;\n\n  if(multi->in_callback)\n    return CURLM_RECURSIVE_API_CALL;\n\n  return multi_timeout(multi, timeout_ms);\n}\n\n/*\n * Tell the application it should update its timers, if it subscribes to the\n * update timer callback.\n */\nvoid Curl_update_timer(struct Curl_multi *multi)\n{\n  long timeout_ms;\n\n  if(!multi->timer_cb)\n    return;\n  if(multi_timeout(multi, &timeout_ms)) {\n    return;\n  }\n  if(timeout_ms < 0) {\n    static const struct curltime none = {0, 0};\n    if(Curl_splaycomparekeys(none, multi->timer_lastcall)) {\n      multi->timer_lastcall = none;\n      /* there's no timeout now but there was one previously, tell the app to\n         disable it */\n      multi->timer_cb(multi, -1, multi->timer_userp);\n      return;\n    }\n    return;\n  }\n\n  /* When multi_timeout() is done, multi->timetree points to the node with the\n   * timeout we got the (relative) time-out time for. We can thus easily check\n   * if this is the same (fixed) time as we got in a previous call and then\n   * avoid calling the callback again. */\n  if(Curl_splaycomparekeys(multi->timetree->key, multi->timer_lastcall) == 0)\n    return;\n\n  multi->timer_lastcall = multi->timetree->key;\n\n  multi->timer_cb(multi, timeout_ms, multi->timer_userp);\n}\n\n/*\n * multi_deltimeout()\n *\n * Remove a given timestamp from the list of timeouts.\n */\nstatic void\nmulti_deltimeout(struct Curl_easy *data, expire_id eid)\n{\n  struct curl_llist_element *e;\n  struct curl_llist *timeoutlist = &data->state.timeoutlist;\n  /* find and remove the specific node from the list */\n  for(e = timeoutlist->head; e; e = e->next) {\n    struct time_node *n = (struct time_node *)e->ptr;\n    if(n->eid == eid) {\n      Curl_llist_remove(timeoutlist, e, NULL);\n      return;\n    }\n  }\n}\n\n/*\n * multi_addtimeout()\n *\n * Add a timestamp to the list of timeouts. Keep the list sorted so that head\n * of list is always the timeout nearest in time.\n *\n */\nstatic CURLMcode\nmulti_addtimeout(struct Curl_easy *data,\n                 struct curltime *stamp,\n                 expire_id eid)\n{\n  struct curl_llist_element *e;\n  struct time_node *node;\n  struct curl_llist_element *prev = NULL;\n  size_t n;\n  struct curl_llist *timeoutlist = &data->state.timeoutlist;\n\n  node = &data->state.expires[eid];\n\n  /* copy the timestamp and id */\n  memcpy(&node->time, stamp, sizeof(*stamp));\n  node->eid = eid; /* also marks it as in use */\n\n  n = Curl_llist_count(timeoutlist);\n  if(n) {\n    /* find the correct spot in the list */\n    for(e = timeoutlist->head; e; e = e->next) {\n      struct time_node *check = (struct time_node *)e->ptr;\n      timediff_t diff = Curl_timediff(check->time, node->time);\n      if(diff > 0)\n        break;\n      prev = e;\n    }\n\n  }\n  /* else\n     this is the first timeout on the list */\n\n  Curl_llist_insert_next(timeoutlist, prev, node, &node->list);\n  return CURLM_OK;\n}\n\n/*\n * Curl_expire()\n *\n * given a number of milliseconds from now to use to set the 'act before\n * this'-time for the transfer, to be extracted by curl_multi_timeout()\n *\n * The timeout will be added to a queue of timeouts if it defines a moment in\n * time that is later than the current head of queue.\n *\n * Expire replaces a former timeout using the same id if already set.\n */\nvoid Curl_expire(struct Curl_easy *data, timediff_t milli, expire_id id)\n{\n  struct Curl_multi *multi = data->multi;\n  struct curltime *nowp = &data->state.expiretime;\n  struct curltime set;\n\n  /* this is only interesting while there is still an associated multi struct\n     remaining! */\n  if(!multi)\n    return;\n\n  DEBUGASSERT(id < EXPIRE_LAST);\n\n  set = Curl_now();\n  set.tv_sec += (time_t)(milli/1000); /* might be a 64 to 32 bit conversion */\n  set.tv_usec += (unsigned int)(milli%1000)*1000;\n\n  if(set.tv_usec >= 1000000) {\n    set.tv_sec++;\n    set.tv_usec -= 1000000;\n  }\n\n  /* Remove any timer with the same id just in case. */\n  multi_deltimeout(data, id);\n\n  /* Add it to the timer list.  It must stay in the list until it has expired\n     in case we need to recompute the minimum timer later. */\n  multi_addtimeout(data, &set, id);\n\n  if(nowp->tv_sec || nowp->tv_usec) {\n    /* This means that the struct is added as a node in the splay tree.\n       Compare if the new time is earlier, and only remove-old/add-new if it\n       is. */\n    timediff_t diff = Curl_timediff(set, *nowp);\n    int rc;\n\n    if(diff > 0) {\n      /* The current splay tree entry is sooner than this new expiry time.\n         We don't need to update our splay tree entry. */\n      return;\n    }\n\n    /* Since this is an updated time, we must remove the previous entry from\n       the splay tree first and then re-add the new value */\n    rc = Curl_splayremovebyaddr(multi->timetree,\n                                &data->state.timenode,\n                                &multi->timetree);\n    if(rc)\n      infof(data, \"Internal error removing splay node = %d\\n\", rc);\n  }\n\n  /* Indicate that we are in the splay tree and insert the new timer expiry\n     value since it is our local minimum. */\n  *nowp = set;\n  data->state.timenode.payload = data;\n  multi->timetree = Curl_splayinsert(*nowp, multi->timetree,\n                                     &data->state.timenode);\n}\n\n/*\n * Curl_expire_done()\n *\n * Removes the expire timer. Marks it as done.\n *\n */\nvoid Curl_expire_done(struct Curl_easy *data, expire_id id)\n{\n  /* remove the timer, if there */\n  multi_deltimeout(data, id);\n}\n\n/*\n * Curl_expire_clear()\n *\n * Clear ALL timeout values for this handle.\n */\nvoid Curl_expire_clear(struct Curl_easy *data)\n{\n  struct Curl_multi *multi = data->multi;\n  struct curltime *nowp = &data->state.expiretime;\n\n  /* this is only interesting while there is still an associated multi struct\n     remaining! */\n  if(!multi)\n    return;\n\n  if(nowp->tv_sec || nowp->tv_usec) {\n    /* Since this is an cleared time, we must remove the previous entry from\n       the splay tree */\n    struct curl_llist *list = &data->state.timeoutlist;\n    int rc;\n\n    rc = Curl_splayremovebyaddr(multi->timetree,\n                                &data->state.timenode,\n                                &multi->timetree);\n    if(rc)\n      infof(data, \"Internal error clearing splay node = %d\\n\", rc);\n\n    /* flush the timeout list too */\n    while(list->size > 0) {\n      Curl_llist_remove(list, list->tail, NULL);\n    }\n\n#ifdef DEBUGBUILD\n    infof(data, \"Expire cleared (transfer %p)\\n\", data);\n#endif\n    nowp->tv_sec = 0;\n    nowp->tv_usec = 0;\n  }\n}\n\n\n\n\nCURLMcode curl_multi_assign(struct Curl_multi *multi, curl_socket_t s,\n                            void *hashp)\n{\n  struct Curl_sh_entry *there = NULL;\n\n  if(multi->in_callback)\n    return CURLM_RECURSIVE_API_CALL;\n\n  there = sh_getentry(&multi->sockhash, s);\n\n  if(!there)\n    return CURLM_BAD_SOCKET;\n\n  there->socketp = hashp;\n\n  return CURLM_OK;\n}\n\nsize_t Curl_multi_max_host_connections(struct Curl_multi *multi)\n{\n  return multi ? multi->max_host_connections : 0;\n}\n\nsize_t Curl_multi_max_total_connections(struct Curl_multi *multi)\n{\n  return multi ? multi->max_total_connections : 0;\n}\n\n/*\n * When information about a connection has appeared, call this!\n */\n\nvoid Curl_multiuse_state(struct connectdata *conn,\n                         int bundlestate) /* use BUNDLE_* defines */\n{\n  DEBUGASSERT(conn);\n  DEBUGASSERT(conn->bundle);\n  DEBUGASSERT(conn->data);\n  DEBUGASSERT(conn->data->multi);\n\n  conn->bundle->multiuse = bundlestate;\n  process_pending_handles(conn->data->multi);\n}\n\nstatic void process_pending_handles(struct Curl_multi *multi)\n{\n  struct curl_llist_element *e = multi->pending.head;\n  if(e) {\n    struct Curl_easy *data = e->ptr;\n\n    DEBUGASSERT(data->mstate == CURLM_STATE_CONNECT_PEND);\n\n    multistate(data, CURLM_STATE_CONNECT);\n\n    /* Remove this node from the list */\n    Curl_llist_remove(&multi->pending, e, NULL);\n\n    /* Make sure that the handle will be processed soonish. */\n    Curl_expire(data, 0, EXPIRE_RUN_NOW);\n\n    /* mark this as having been in the pending queue */\n    data->state.previouslypending = TRUE;\n  }\n}\n\nvoid Curl_set_in_callback(struct Curl_easy *data, bool value)\n{\n  /* might get called when there is no data pointer! */\n  if(data) {\n    if(data->multi_easy)\n      data->multi_easy->in_callback = value;\n    else if(data->multi)\n      data->multi->in_callback = value;\n  }\n}\n\nbool Curl_is_in_callback(struct Curl_easy *easy)\n{\n  return ((easy->multi && easy->multi->in_callback) ||\n          (easy->multi_easy && easy->multi_easy->in_callback));\n}\n\n#ifdef DEBUGBUILD\nvoid Curl_multi_dump(struct Curl_multi *multi)\n{\n  struct Curl_easy *data;\n  int i;\n  fprintf(stderr, \"* Multi status: %d handles, %d alive\\n\",\n          multi->num_easy, multi->num_alive);\n  for(data = multi->easyp; data; data = data->next) {\n    if(data->mstate < CURLM_STATE_COMPLETED) {\n      /* only display handles that are not completed */\n      fprintf(stderr, \"handle %p, state %s, %d sockets\\n\",\n              (void *)data,\n              statename[data->mstate], data->numsocks);\n      for(i = 0; i < data->numsocks; i++) {\n        curl_socket_t s = data->sockets[i];\n        struct Curl_sh_entry *entry = sh_getentry(&multi->sockhash, s);\n\n        fprintf(stderr, \"%d \", (int)s);\n        if(!entry) {\n          fprintf(stderr, \"INTERNAL CONFUSION\\n\");\n          continue;\n        }\n        fprintf(stderr, \"[%s %s] \",\n                (entry->action&CURL_POLL_IN)?\"RECVING\":\"\",\n                (entry->action&CURL_POLL_OUT)?\"SENDING\":\"\");\n      }\n      if(data->numsocks)\n        fprintf(stderr, \"\\n\");\n    }\n  }\n}\n#endif\n\nunsigned int Curl_multi_max_concurrent_streams(struct Curl_multi *multi)\n{\n  DEBUGASSERT(multi);\n  return multi->max_concurrent_streams;\n}\n"}, "38": {"id": 38, "path": "/home/runner/work/testcc/testcc/retdec/lib/urldata.h", "content": "#ifndef HEADER_CURL_URLDATA_H\n#define HEADER_CURL_URLDATA_H\n/***************************************************************************\n *                                  _   _ ____  _\n *  Project                     ___| | | |  _ \\| |\n *                             / __| | | | |_) | |\n *                            | (__| |_| |  _ <| |___\n *                             \\___|\\___/|_| \\_\\_____|\n *\n * Copyright (C) 1998 - 2020, Daniel Stenberg, <daniel@haxx.se>, et al.\n *\n * This software is licensed as described in the file COPYING, which\n * you should have received as part of this distribution. The terms\n * are also available at https://curl.haxx.se/docs/copyright.html.\n *\n * You may opt to use, copy, modify, merge, publish, distribute and/or sell\n * copies of the Software, and permit persons to whom the Software is\n * furnished to do so, under the terms of the COPYING file.\n *\n * This software is distributed on an \"AS IS\" basis, WITHOUT WARRANTY OF ANY\n * KIND, either express or implied.\n *\n ***************************************************************************/\n\n/* This file is for lib internal stuff */\n\n#include \"curl_setup.h\"\n\n#define PORT_FTP 21\n#define PORT_FTPS 990\n#define PORT_TELNET 23\n#define PORT_HTTP 80\n#define PORT_HTTPS 443\n#define PORT_DICT 2628\n#define PORT_LDAP 389\n#define PORT_LDAPS 636\n#define PORT_TFTP 69\n#define PORT_SSH 22\n#define PORT_IMAP 143\n#define PORT_IMAPS 993\n#define PORT_POP3 110\n#define PORT_POP3S 995\n#define PORT_SMB 445\n#define PORT_SMBS 445\n#define PORT_SMTP 25\n#define PORT_SMTPS 465 /* sometimes called SSMTP */\n#define PORT_RTSP 554\n#define PORT_RTMP 1935\n#define PORT_RTMPT PORT_HTTP\n#define PORT_RTMPS PORT_HTTPS\n#define PORT_GOPHER 70\n#define PORT_MQTT 1883\n\n#define DICT_MATCH \"/MATCH:\"\n#define DICT_MATCH2 \"/M:\"\n#define DICT_MATCH3 \"/FIND:\"\n#define DICT_DEFINE \"/DEFINE:\"\n#define DICT_DEFINE2 \"/D:\"\n#define DICT_DEFINE3 \"/LOOKUP:\"\n\n#define CURL_DEFAULT_USER \"anonymous\"\n#define CURL_DEFAULT_PASSWORD \"ftp@example.com\"\n\n/* Convenience defines for checking protocols or their SSL based version. Each\n   protocol handler should only ever have a single CURLPROTO_ in its protocol\n   field. */\n#define PROTO_FAMILY_HTTP (CURLPROTO_HTTP|CURLPROTO_HTTPS)\n#define PROTO_FAMILY_FTP  (CURLPROTO_FTP|CURLPROTO_FTPS)\n#define PROTO_FAMILY_POP3 (CURLPROTO_POP3|CURLPROTO_POP3S)\n#define PROTO_FAMILY_SMB  (CURLPROTO_SMB|CURLPROTO_SMBS)\n#define PROTO_FAMILY_SMTP (CURLPROTO_SMTP|CURLPROTO_SMTPS)\n#define PROTO_FAMILY_SSH  (CURLPROTO_SCP|CURLPROTO_SFTP)\n\n#define DEFAULT_CONNCACHE_SIZE 5\n\n/* length of longest IPv6 address string including the trailing null */\n#define MAX_IPADR_LEN sizeof(\"ffff:ffff:ffff:ffff:ffff:ffff:255.255.255.255\")\n\n/* Default FTP/IMAP etc response timeout in milliseconds.\n   Symbian OS panics when given a timeout much greater than 1/2 hour.\n*/\n#define RESP_TIMEOUT (120*1000)\n\n/* Max string input length is a precaution against abuse and to detect junk\n   input easier and better. */\n#define CURL_MAX_INPUT_LENGTH 8000000\n\n#include \"cookie.h\"\n#include \"psl.h\"\n#include \"formdata.h\"\n\n#ifdef HAVE_NETINET_IN_H\n#include <netinet/in.h>\n#endif\n#ifdef HAVE_NETINET_IN6_H\n#include <netinet/in6.h>\n#endif\n\n#include \"timeval.h\"\n\n#include <curl/curl.h>\n\n#include \"http_chunks.h\" /* for the structs and enum stuff */\n#include \"hostip.h\"\n#include \"hash.h\"\n#include \"splay.h\"\n#include \"dynbuf.h\"\n\n/* return the count of bytes sent, or -1 on error */\ntypedef ssize_t (Curl_send)(struct connectdata *conn, /* connection data */\n                            int sockindex,            /* socketindex */\n                            const void *buf,          /* data to write */\n                            size_t len,               /* max amount to write */\n                            CURLcode *err);           /* error to return */\n\n/* return the count of bytes read, or -1 on error */\ntypedef ssize_t (Curl_recv)(struct connectdata *conn, /* connection data */\n                            int sockindex,            /* socketindex */\n                            char *buf,                /* store data here */\n                            size_t len,               /* max amount to read */\n                            CURLcode *err);           /* error to return */\n\n#include \"mime.h\"\n#include \"imap.h\"\n#include \"pop3.h\"\n#include \"smtp.h\"\n#include \"ftp.h\"\n#include \"file.h\"\n#include \"vssh/ssh.h\"\n#include \"http.h\"\n#include \"rtsp.h\"\n#include \"smb.h\"\n#include \"mqtt.h\"\n#include \"wildcard.h\"\n#include \"multihandle.h\"\n#include \"quic.h\"\n\n#ifdef HAVE_GSSAPI\n# ifdef HAVE_GSSGNU\n#  include <gss.h>\n# elif defined HAVE_GSSAPI_GSSAPI_H\n#  include <gssapi/gssapi.h>\n# else\n#  include <gssapi.h>\n# endif\n# ifdef HAVE_GSSAPI_GSSAPI_GENERIC_H\n#  include <gssapi/gssapi_generic.h>\n# endif\n#endif\n\n#ifdef HAVE_LIBSSH2_H\n#include <libssh2.h>\n#include <libssh2_sftp.h>\n#endif /* HAVE_LIBSSH2_H */\n\n#define CURLEASY_MAGIC_NUMBER 0xc0dedbadU\n#define GOOD_EASY_HANDLE(x) \\\n  ((x) && ((x)->magic == CURLEASY_MAGIC_NUMBER))\n\n/* the type we use for storing a single boolean bit */\n#ifdef _MSC_VER\ntypedef bool bit;\n#define BIT(x) bool x\n#else\ntypedef unsigned int bit;\n#define BIT(x) bit x:1\n#endif\n\n#ifdef HAVE_GSSAPI\n/* Types needed for krb5-ftp connections */\nstruct krb5buffer {\n  void *data;\n  size_t size;\n  size_t index;\n  BIT(eof_flag);\n};\n\nenum protection_level {\n  PROT_NONE, /* first in list */\n  PROT_CLEAR,\n  PROT_SAFE,\n  PROT_CONFIDENTIAL,\n  PROT_PRIVATE,\n  PROT_CMD,\n  PROT_LAST /* last in list */\n};\n#endif\n\n/* enum for the nonblocking SSL connection state machine */\ntypedef enum {\n  ssl_connect_1,\n  ssl_connect_2,\n  ssl_connect_2_reading,\n  ssl_connect_2_writing,\n  ssl_connect_3,\n  ssl_connect_done\n} ssl_connect_state;\n\ntypedef enum {\n  ssl_connection_none,\n  ssl_connection_negotiating,\n  ssl_connection_complete\n} ssl_connection_state;\n\n/* SSL backend-specific data; declared differently by each SSL backend */\nstruct ssl_backend_data;\n\n/* struct for data related to each SSL connection */\nstruct ssl_connect_data {\n  /* Use ssl encrypted communications TRUE/FALSE, not necessarily using it atm\n     but at least asked to or meaning to use it. See 'state' for the exact\n     current state of the connection. */\n  ssl_connection_state state;\n  ssl_connect_state connecting_state;\n#if defined(USE_SSL)\n  struct ssl_backend_data *backend;\n#endif\n  BIT(use);\n};\n\nstruct ssl_primary_config {\n  long version;          /* what version the client wants to use */\n  long version_max;      /* max supported version the client wants to use*/\n  char *CApath;          /* certificate dir (doesn't work on windows) */\n  char *CAfile;          /* certificate to verify peer against */\n  char *clientcert;\n  char *random_file;     /* path to file containing \"random\" data */\n  char *egdsocket;       /* path to file containing the EGD daemon socket */\n  char *cipher_list;     /* list of ciphers to use */\n  char *cipher_list13;   /* list of TLS 1.3 cipher suites to use */\n  char *pinned_key;\n  struct curl_blob *cert_blob;\n  char *curves;          /* list of curves to use */\n  BIT(verifypeer);       /* set TRUE if this is desired */\n  BIT(verifyhost);       /* set TRUE if CN/SAN must match hostname */\n  BIT(verifystatus);     /* set TRUE if certificate status must be checked */\n  BIT(sessionid);        /* cache session IDs or not */\n};\n\nstruct ssl_config_data {\n  struct ssl_primary_config primary;\n  long certverifyresult; /* result from the certificate verification */\n  char *CRLfile;   /* CRL to check certificate revocation */\n  char *issuercert;/* optional issuer certificate filename */\n  struct curl_blob *issuercert_blob;\n  curl_ssl_ctx_callback fsslctx; /* function to initialize ssl ctx */\n  void *fsslctxp;        /* parameter for call back */\n  char *cert; /* client certificate file name */\n  struct curl_blob *cert_blob;\n  char *cert_type; /* format for certificate (default: PEM)*/\n  char *key; /* private key file name */\n  struct curl_blob *key_blob;\n  char *key_type; /* format for private key (default: PEM) */\n  char *key_passwd; /* plain text private key password */\n#ifdef USE_TLS_SRP\n  char *username; /* TLS username (for, e.g., SRP) */\n  char *password; /* TLS password (for, e.g., SRP) */\n  enum CURL_TLSAUTH authtype; /* TLS authentication type (default SRP) */\n#endif\n  BIT(certinfo);     /* gather lots of certificate info */\n  BIT(falsestart);\n  BIT(enable_beast); /* allow this flaw for interoperability's sake*/\n  BIT(no_revoke);    /* disable SSL certificate revocation checks */\n  BIT(no_partialchain); /* don't accept partial certificate chains */\n  BIT(revoke_best_effort); /* ignore SSL revocation offline/missing revocation\n                              list errors */\n  BIT(native_ca_store); /* use the native ca store of operating system */\n};\n\nstruct ssl_general_config {\n  size_t max_ssl_sessions; /* SSL session id cache size */\n};\n\n/* information stored about one single SSL session */\nstruct curl_ssl_session {\n  char *name;       /* host name for which this ID was used */\n  char *conn_to_host; /* host name for the connection (may be NULL) */\n  const char *scheme; /* protocol scheme used */\n  void *sessionid;  /* as returned from the SSL layer */\n  size_t idsize;    /* if known, otherwise 0 */\n  long age;         /* just a number, the higher the more recent */\n  int remote_port;  /* remote port */\n  int conn_to_port; /* remote port for the connection (may be -1) */\n  struct ssl_primary_config ssl_config; /* setup for this session */\n};\n\n#ifdef USE_WINDOWS_SSPI\n#include \"curl_sspi.h\"\n#endif\n\n/* Struct used for Digest challenge-response authentication */\nstruct digestdata {\n#if defined(USE_WINDOWS_SSPI)\n  BYTE *input_token;\n  size_t input_token_len;\n  CtxtHandle *http_context;\n  /* copy of user/passwd used to make the identity for http_context.\n     either may be NULL. */\n  char *user;\n  char *passwd;\n#else\n  char *nonce;\n  char *cnonce;\n  char *realm;\n  int algo;\n  char *opaque;\n  char *qop;\n  char *algorithm;\n  int nc; /* nounce count */\n  BIT(stale); /* set true for re-negotiation */\n  BIT(userhash);\n#endif\n};\n\ntypedef enum {\n  NTLMSTATE_NONE,\n  NTLMSTATE_TYPE1,\n  NTLMSTATE_TYPE2,\n  NTLMSTATE_TYPE3,\n  NTLMSTATE_LAST\n} curlntlm;\n\ntypedef enum {\n  GSS_AUTHNONE,\n  GSS_AUTHRECV,\n  GSS_AUTHSENT,\n  GSS_AUTHDONE,\n  GSS_AUTHSUCC\n} curlnegotiate;\n\n#if defined(CURL_DOES_CONVERSIONS) && defined(HAVE_ICONV)\n#include <iconv.h>\n#endif\n\n/* Struct used for GSSAPI (Kerberos V5) authentication */\n#if defined(USE_KERBEROS5)\nstruct kerberos5data {\n#if defined(USE_WINDOWS_SSPI)\n  CredHandle *credentials;\n  CtxtHandle *context;\n  TCHAR *spn;\n  SEC_WINNT_AUTH_IDENTITY identity;\n  SEC_WINNT_AUTH_IDENTITY *p_identity;\n  size_t token_max;\n  BYTE *output_token;\n#else\n  gss_ctx_id_t context;\n  gss_name_t spn;\n#endif\n};\n#endif\n\n/* Struct used for NTLM challenge-response authentication */\n#if defined(USE_NTLM)\nstruct ntlmdata {\n#ifdef USE_WINDOWS_SSPI\n/* The sslContext is used for the Schannel bindings. The\n * api is available on the Windows 7 SDK and later.\n */\n#ifdef SECPKG_ATTR_ENDPOINT_BINDINGS\n  CtxtHandle *sslContext;\n#endif\n  CredHandle *credentials;\n  CtxtHandle *context;\n  SEC_WINNT_AUTH_IDENTITY identity;\n  SEC_WINNT_AUTH_IDENTITY *p_identity;\n  size_t token_max;\n  BYTE *output_token;\n  BYTE *input_token;\n  size_t input_token_len;\n  TCHAR *spn;\n#else\n  unsigned int flags;\n  unsigned char nonce[8];\n  void *target_info; /* TargetInfo received in the ntlm type-2 message */\n  unsigned int target_info_len;\n\n#if defined(NTLM_WB_ENABLED)\n  /* used for communication with Samba's winbind daemon helper ntlm_auth */\n  curl_socket_t ntlm_auth_hlpr_socket;\n  pid_t ntlm_auth_hlpr_pid;\n  char *challenge; /* The received base64 encoded ntlm type-2 message */\n  char *response;  /* The generated base64 ntlm type-1/type-3 message */\n#endif\n#endif\n};\n#endif\n\n/* Struct used for Negotiate (SPNEGO) authentication */\n#ifdef USE_SPNEGO\nstruct negotiatedata {\n#ifdef HAVE_GSSAPI\n  OM_uint32 status;\n  gss_ctx_id_t context;\n  gss_name_t spn;\n  gss_buffer_desc output_token;\n#else\n#ifdef USE_WINDOWS_SSPI\n#ifdef SECPKG_ATTR_ENDPOINT_BINDINGS\n  CtxtHandle *sslContext;\n#endif\n  DWORD status;\n  CredHandle *credentials;\n  CtxtHandle *context;\n  SEC_WINNT_AUTH_IDENTITY identity;\n  SEC_WINNT_AUTH_IDENTITY *p_identity;\n  TCHAR *spn;\n  size_t token_max;\n  BYTE *output_token;\n  size_t output_token_length;\n#endif\n#endif\n  BIT(noauthpersist);\n  BIT(havenoauthpersist);\n  BIT(havenegdata);\n  BIT(havemultiplerequests);\n};\n#endif\n\n\n/*\n * Boolean values that concerns this connection.\n */\nstruct ConnectBits {\n  bool tcpconnect[2]; /* the TCP layer (or similar) is connected, this is set\n                         the first time on the first connect function call */\n#ifndef CURL_DISABLE_PROXY\n  bool proxy_ssl_connected[2]; /* TRUE when SSL initialization for HTTPS proxy\n                                  is complete */\n  BIT(httpproxy);  /* if set, this transfer is done through a http proxy */\n  BIT(socksproxy); /* if set, this transfer is done through a socks proxy */\n  BIT(proxy_user_passwd); /* user+password for the proxy? */\n  BIT(tunnel_proxy);  /* if CONNECT is used to \"tunnel\" through the proxy.\n                         This is implicit when SSL-protocols are used through\n                         proxies, but can also be enabled explicitly by\n                         apps */\n  BIT(proxy_connect_closed); /* TRUE if a proxy disconnected the connection\n                                in a CONNECT request with auth, so that\n                                libcurl should reconnect and continue. */\n#endif\n  /* always modify bits.close with the connclose() and connkeep() macros! */\n  BIT(close); /* if set, we close the connection after this request */\n  BIT(reuse); /* if set, this is a re-used connection */\n  BIT(altused); /* this is an alt-svc \"redirect\" */\n  BIT(conn_to_host); /* if set, this connection has a \"connect to host\"\n                        that overrides the host in the URL */\n  BIT(conn_to_port); /* if set, this connection has a \"connect to port\"\n                        that overrides the port in the URL (remote port) */\n  BIT(proxy); /* if set, this transfer is done through a proxy - any type */\n  BIT(user_passwd); /* do we use user+password for this connection? */\n  BIT(ipv6_ip); /* we communicate with a remote site specified with pure IPv6\n                   IP address */\n  BIT(ipv6);    /* we communicate with a site using an IPv6 address */\n  BIT(do_more); /* this is set TRUE if the ->curl_do_more() function is\n                   supposed to be called, after ->curl_do() */\n  BIT(protoconnstart);/* the protocol layer has STARTED its operation after\n                         the TCP layer connect */\n  BIT(retry);         /* this connection is about to get closed and then\n                         re-attempted at another connection. */\n  BIT(authneg);       /* TRUE when the auth phase has started, which means\n                         that we are creating a request with an auth header,\n                         but it is not the final request in the auth\n                         negotiation. */\n  BIT(rewindaftersend);/* TRUE when the sending couldn't be stopped even\n                          though it will be discarded. When the whole send\n                          operation is done, we must call the data rewind\n                          callback. */\n#ifndef CURL_DISABLE_FTP\n  BIT(ftp_use_epsv);  /* As set with CURLOPT_FTP_USE_EPSV, but if we find out\n                         EPSV doesn't work we disable it for the forthcoming\n                         requests */\n  BIT(ftp_use_eprt);  /* As set with CURLOPT_FTP_USE_EPRT, but if we find out\n                         EPRT doesn't work we disable it for the forthcoming\n                         requests */\n  BIT(ftp_use_data_ssl); /* Enabled SSL for the data connection */\n#endif\n  BIT(netrc);         /* name+password provided by netrc */\n  BIT(bound); /* set true if bind() has already been done on this socket/\n                 connection */\n  BIT(multiplex); /* connection is multiplexed */\n  BIT(tcp_fastopen); /* use TCP Fast Open */\n  BIT(tls_enable_npn);  /* TLS NPN extension? */\n  BIT(tls_enable_alpn); /* TLS ALPN extension? */\n  BIT(connect_only);\n  BIT(doh);\n#ifdef USE_UNIX_SOCKETS\n  BIT(abstract_unix_socket);\n#endif\n  BIT(tls_upgraded);\n  BIT(sock_accepted); /* TRUE if the SECONDARYSOCKET was created with\n                         accept() */\n  BIT(parallel_connect); /* set TRUE when a parallel connect attempt has\n                            started (happy eyeballs) */\n};\n\nstruct hostname {\n  char *rawalloc; /* allocated \"raw\" version of the name */\n  char *encalloc; /* allocated IDN-encoded version of the name */\n  char *name;     /* name to use internally, might be encoded, might be raw */\n  const char *dispname; /* name to display, as 'name' might be encoded */\n};\n\n/*\n * Flags on the keepon member of the Curl_transfer_keeper\n */\n\n#define KEEP_NONE  0\n#define KEEP_RECV  (1<<0)     /* there is or may be data to read */\n#define KEEP_SEND (1<<1)     /* there is or may be data to write */\n#define KEEP_RECV_HOLD (1<<2) /* when set, no reading should be done but there\n                                 might still be data to read */\n#define KEEP_SEND_HOLD (1<<3) /* when set, no writing should be done but there\n                                  might still be data to write */\n#define KEEP_RECV_PAUSE (1<<4) /* reading is paused */\n#define KEEP_SEND_PAUSE (1<<5) /* writing is paused */\n\n#define KEEP_RECVBITS (KEEP_RECV | KEEP_RECV_HOLD | KEEP_RECV_PAUSE)\n#define KEEP_SENDBITS (KEEP_SEND | KEEP_SEND_HOLD | KEEP_SEND_PAUSE)\n\nstruct Curl_async {\n  char *hostname;\n  int port;\n  struct Curl_dns_entry *dns;\n  int status; /* if done is TRUE, this is the status from the callback */\n  void *os_specific;  /* 'struct thread_data' for Windows */\n  BIT(done);  /* set TRUE when the lookup is complete */\n};\n\n#define FIRSTSOCKET     0\n#define SECONDARYSOCKET 1\n\n/* These function pointer types are here only to allow easier typecasting\n   within the source when we need to cast between data pointers (such as NULL)\n   and function pointers. */\ntypedef CURLcode (*Curl_do_more_func)(struct connectdata *, int *);\ntypedef CURLcode (*Curl_done_func)(struct connectdata *, CURLcode, bool);\n\nenum expect100 {\n  EXP100_SEND_DATA,           /* enough waiting, just send the body now */\n  EXP100_AWAITING_CONTINUE,   /* waiting for the 100 Continue header */\n  EXP100_SENDING_REQUEST,     /* still sending the request but will wait for\n                                 the 100 header once done with the request */\n  EXP100_FAILED               /* used on 417 Expectation Failed */\n};\n\nenum upgrade101 {\n  UPGR101_INIT,               /* default state */\n  UPGR101_REQUESTED,          /* upgrade requested */\n  UPGR101_RECEIVED,           /* response received */\n  UPGR101_WORKING             /* talking upgraded protocol */\n};\n\nenum doh_slots {\n  /* Explicit values for first two symbols so as to match hard-coded\n   * constants in existing code\n   */\n  DOH_PROBE_SLOT_IPADDR_V4 = 0, /* make 'V4' stand out for readability */\n  DOH_PROBE_SLOT_IPADDR_V6 = 1, /* 'V6' likewise */\n\n  /* Space here for (possibly build-specific) additional slot definitions */\n\n  /* for example */\n  /* #ifdef WANT_DOH_FOOBAR_TXT */\n  /*   DOH_PROBE_SLOT_FOOBAR_TXT, */\n  /* #endif */\n\n  /* AFTER all slot definitions, establish how many we have */\n  DOH_PROBE_SLOTS\n};\n\n/* one of these for each DoH request */\nstruct dnsprobe {\n  CURL *easy;\n  int dnstype;\n  unsigned char dohbuffer[512];\n  size_t dohlen;\n  struct dynbuf serverdoh;\n};\n\nstruct dohdata {\n  struct curl_slist *headers;\n  struct dnsprobe probe[DOH_PROBE_SLOTS];\n  unsigned int pending; /* still outstanding requests */\n  const char *host;\n  int port;\n};\n\n/*\n * Request specific data in the easy handle (Curl_easy).  Previously,\n * these members were on the connectdata struct but since a conn struct may\n * now be shared between different Curl_easys, we store connection-specific\n * data here. This struct only keeps stuff that's interesting for *this*\n * request, as it will be cleared between multiple ones\n */\nstruct SingleRequest {\n  curl_off_t size;        /* -1 if unknown at this point */\n  curl_off_t maxdownload; /* in bytes, the maximum amount of data to fetch,\n                             -1 means unlimited */\n  curl_off_t bytecount;         /* total number of bytes read */\n  curl_off_t writebytecount;    /* number of bytes written */\n\n  curl_off_t headerbytecount;   /* only count received headers */\n  curl_off_t deductheadercount; /* this amount of bytes doesn't count when we\n                                   check if anything has been transferred at\n                                   the end of a connection. We use this\n                                   counter to make only a 100 reply (without a\n                                   following second response code) result in a\n                                   CURLE_GOT_NOTHING error code */\n\n  struct curltime start;         /* transfer started at this time */\n  struct curltime now;           /* current time */\n  enum {\n    HEADER_NORMAL,              /* no bad header at all */\n    HEADER_PARTHEADER,          /* part of the chunk is a bad header, the rest\n                                   is normal data */\n    HEADER_ALLBAD               /* all was believed to be header */\n  } badheader;                  /* the header was deemed bad and will be\n                                   written as body */\n  int headerline;               /* counts header lines to better track the\n                                   first one */\n  char *str;                    /* within buf */\n  curl_off_t offset;            /* possible resume offset read from the\n                                   Content-Range: header */\n  int httpcode;                 /* error code from the 'HTTP/1.? XXX' or\n                                   'RTSP/1.? XXX' line */\n  struct curltime start100;      /* time stamp to wait for the 100 code from */\n  enum expect100 exp100;        /* expect 100 continue state */\n  enum upgrade101 upgr101;      /* 101 upgrade state */\n\n  /* Content unencoding stack. See sec 3.5, RFC2616. */\n  struct contenc_writer *writer_stack;\n  time_t timeofdoc;\n  long bodywrites;\n  int keepon;\n  char *location;   /* This points to an allocated version of the Location:\n                       header data */\n  char *newurl;     /* Set to the new URL to use when a redirect or a retry is\n                       wanted */\n\n  /* 'upload_present' is used to keep a byte counter of how much data there is\n     still left in the buffer, aimed for upload. */\n  ssize_t upload_present;\n\n  /* 'upload_fromhere' is used as a read-pointer when we uploaded parts of a\n     buffer, so the next read should read from where this pointer points to,\n     and the 'upload_present' contains the number of bytes available at this\n     position */\n  char *upload_fromhere;\n  void *protop;       /* Allocated protocol-specific data. Each protocol\n                         handler makes sure this points to data it needs. */\n#ifndef CURL_DISABLE_DOH\n  struct dohdata doh; /* DoH specific data for this request */\n#endif\n  BIT(header);       /* incoming data has HTTP header */\n  BIT(content_range); /* set TRUE if Content-Range: was found */\n  BIT(upload_done);  /* set to TRUE when doing chunked transfer-encoding\n                        upload and we're uploading the last chunk */\n  BIT(ignorebody);   /* we read a response-body but we ignore it! */\n  BIT(http_bodyless); /* HTTP response status code is between 100 and 199,\n                         204 or 304 */\n  BIT(chunk); /* if set, this is a chunked transfer-encoding */\n  BIT(upload_chunky); /* set TRUE if we are doing chunked transfer-encoding\n                         on upload */\n  BIT(getheader);    /* TRUE if header parsing is wanted */\n  BIT(forbidchunk);  /* used only to explicitly forbid chunk-upload for\n                        specific upload buffers. See readmoredata() in http.c\n                        for details. */\n};\n\n/*\n * Specific protocol handler.\n */\n\nstruct Curl_handler {\n  const char *scheme;        /* URL scheme name. */\n\n  /* Complement to setup_connection_internals(). */\n  CURLcode (*setup_connection)(struct connectdata *);\n\n  /* These two functions MUST be set to be protocol dependent */\n  CURLcode (*do_it)(struct connectdata *, bool *done);\n  Curl_done_func done;\n\n  /* If the curl_do() function is better made in two halves, this\n   * curl_do_more() function will be called afterwards, if set. For example\n   * for doing the FTP stuff after the PASV/PORT command.\n   */\n  Curl_do_more_func do_more;\n\n  /* This function *MAY* be set to a protocol-dependent function that is run\n   * after the connect() and everything is done, as a step in the connection.\n   * The 'done' pointer points to a bool that should be set to TRUE if the\n   * function completes before return. If it doesn't complete, the caller\n   * should call the curl_connecting() function until it is.\n   */\n  CURLcode (*connect_it)(struct connectdata *, bool *done);\n\n  /* See above. */\n  CURLcode (*connecting)(struct connectdata *, bool *done);\n  CURLcode (*doing)(struct connectdata *, bool *done);\n\n  /* Called from the multi interface during the PROTOCONNECT phase, and it\n     should then return a proper fd set */\n  int (*proto_getsock)(struct connectdata *conn,\n                       curl_socket_t *socks);\n\n  /* Called from the multi interface during the DOING phase, and it should\n     then return a proper fd set */\n  int (*doing_getsock)(struct connectdata *conn,\n                       curl_socket_t *socks);\n\n  /* Called from the multi interface during the DO_MORE phase, and it should\n     then return a proper fd set */\n  int (*domore_getsock)(struct connectdata *conn,\n                        curl_socket_t *socks);\n\n  /* Called from the multi interface during the DO_DONE, PERFORM and\n     WAITPERFORM phases, and it should then return a proper fd set. Not setting\n     this will make libcurl use the generic default one. */\n  int (*perform_getsock)(const struct connectdata *conn,\n                         curl_socket_t *socks);\n\n  /* This function *MAY* be set to a protocol-dependent function that is run\n   * by the curl_disconnect(), as a step in the disconnection.  If the handler\n   * is called because the connection has been considered dead, dead_connection\n   * is set to TRUE.\n   */\n  CURLcode (*disconnect)(struct connectdata *, bool dead_connection);\n\n  /* If used, this function gets called from transfer.c:readwrite_data() to\n     allow the protocol to do extra reads/writes */\n  CURLcode (*readwrite)(struct Curl_easy *data, struct connectdata *conn,\n                        ssize_t *nread, bool *readmore);\n\n  /* This function can perform various checks on the connection. See\n     CONNCHECK_* for more information about the checks that can be performed,\n     and CONNRESULT_* for the results that can be returned. */\n  unsigned int (*connection_check)(struct connectdata *conn,\n                                   unsigned int checks_to_perform);\n\n  long defport;           /* Default port. */\n  unsigned int protocol;  /* See CURLPROTO_* - this needs to be the single\n                             specific protocol bit */\n  unsigned int flags;     /* Extra particular characteristics, see PROTOPT_* */\n};\n\n#define PROTOPT_NONE 0             /* nothing extra */\n#define PROTOPT_SSL (1<<0)         /* uses SSL */\n#define PROTOPT_DUAL (1<<1)        /* this protocol uses two connections */\n#define PROTOPT_CLOSEACTION (1<<2) /* need action before socket close */\n/* some protocols will have to call the underlying functions without regard to\n   what exact state the socket signals. IE even if the socket says \"readable\",\n   the send function might need to be called while uploading, or vice versa.\n*/\n#define PROTOPT_DIRLOCK (1<<3)\n#define PROTOPT_NONETWORK (1<<4)   /* protocol doesn't use the network! */\n#define PROTOPT_NEEDSPWD (1<<5)    /* needs a password, and if none is set it\n                                      gets a default */\n#define PROTOPT_NOURLQUERY (1<<6)   /* protocol can't handle\n                                        url query strings (?foo=bar) ! */\n#define PROTOPT_CREDSPERREQUEST (1<<7) /* requires login credentials per\n                                          request instead of per connection */\n#define PROTOPT_ALPN_NPN (1<<8) /* set ALPN and/or NPN for this */\n#define PROTOPT_STREAM (1<<9) /* a protocol with individual logical streams */\n#define PROTOPT_URLOPTIONS (1<<10) /* allow options part in the userinfo field\n                                      of the URL */\n#define PROTOPT_PROXY_AS_HTTP (1<<11) /* allow this non-HTTP scheme over a\n                                         HTTP proxy as HTTP proxies may know\n                                         this protocol and act as a gateway */\n#define PROTOPT_WILDCARD (1<<12) /* protocol supports wildcard matching */\n#define PROTOPT_USERPWDCTRL (1<<13) /* Allow \"control bytes\" (< 32 ascii) in\n                                       user name and password */\n\n#define CONNCHECK_NONE 0                 /* No checks */\n#define CONNCHECK_ISDEAD (1<<0)          /* Check if the connection is dead. */\n#define CONNCHECK_KEEPALIVE (1<<1)       /* Perform any keepalive function. */\n\n#define CONNRESULT_NONE 0                /* No extra information. */\n#define CONNRESULT_DEAD (1<<0)           /* The connection is dead. */\n\n#ifdef USE_RECV_BEFORE_SEND_WORKAROUND\nstruct postponed_data {\n  char *buffer;          /* Temporal store for received data during\n                            sending, must be freed */\n  size_t allocated_size; /* Size of temporal store */\n  size_t recv_size;      /* Size of received data during sending */\n  size_t recv_processed; /* Size of processed part of postponed data */\n#ifdef DEBUGBUILD\n  curl_socket_t bindsock;/* Structure must be bound to specific socket,\n                            used only for DEBUGASSERT */\n#endif /* DEBUGBUILD */\n};\n#endif /* USE_RECV_BEFORE_SEND_WORKAROUND */\n\nstruct proxy_info {\n  struct hostname host;\n  long port;\n  curl_proxytype proxytype; /* what kind of proxy that is in use */\n  char *user;    /* proxy user name string, allocated */\n  char *passwd;  /* proxy password string, allocated */\n};\n\n/* struct for HTTP CONNECT state data */\nstruct http_connect_state {\n  struct dynbuf rcvbuf;\n  int keepon;\n  curl_off_t cl; /* size of content to read and ignore */\n  enum {\n    TUNNEL_INIT,    /* init/default/no tunnel state */\n    TUNNEL_CONNECT, /* CONNECT has been sent off */\n    TUNNEL_COMPLETE /* CONNECT response received completely */\n  } tunnel_state;\n  BIT(chunked_encoding);\n  BIT(close_connection);\n};\n\nstruct ldapconninfo;\n\n/* for the (SOCKS) connect state machine */\nenum connect_t {\n  CONNECT_INIT,\n  CONNECT_SOCKS_INIT, /* 1 */\n  CONNECT_SOCKS_SEND, /* 2 waiting to send more first data */\n  CONNECT_SOCKS_READ_INIT, /* 3 set up read */\n  CONNECT_SOCKS_READ, /* 4 read server response */\n  CONNECT_GSSAPI_INIT, /* 5 */\n  CONNECT_AUTH_INIT, /* 6 setup outgoing auth buffer */\n  CONNECT_AUTH_SEND, /* 7 send auth */\n  CONNECT_AUTH_READ, /* 8 read auth response */\n  CONNECT_REQ_INIT,  /* 9 init SOCKS \"request\" */\n  CONNECT_RESOLVING, /* 10 */\n  CONNECT_RESOLVED,  /* 11 */\n  CONNECT_RESOLVE_REMOTE, /* 12 */\n  CONNECT_REQ_SEND,  /* 13 */\n  CONNECT_REQ_SENDING, /* 14 */\n  CONNECT_REQ_READ,  /* 15 */\n  CONNECT_REQ_READ_MORE, /* 16 */\n  CONNECT_DONE /* 17 connected fine to the remote or the SOCKS proxy */\n};\n\n#define SOCKS_STATE(x) (((x) >= CONNECT_SOCKS_INIT) &&  \\\n                        ((x) < CONNECT_DONE))\n#define SOCKS_REQUEST_BUFSIZE 600  /* room for large user/pw (255 max each) */\n\nstruct connstate {\n  enum connect_t state;\n  unsigned char socksreq[SOCKS_REQUEST_BUFSIZE];\n\n  /* CONNECT_SOCKS_SEND */\n  ssize_t outstanding;  /* send this many bytes more */\n  unsigned char *outp; /* send from this pointer */\n};\n\n/*\n * The connectdata struct contains all fields and variables that should be\n * unique for an entire connection.\n */\nstruct connectdata {\n  /* 'data' is the CURRENT Curl_easy using this connection -- take great\n     caution that this might very well vary between different times this\n     connection is used! */\n  struct Curl_easy *data;\n  struct connstate cnnct;\n  struct curl_llist_element bundle_node; /* conncache */\n\n  /* chunk is for HTTP chunked encoding, but is in the general connectdata\n     struct only because we can do just about any protocol through a HTTP proxy\n     and a HTTP proxy may in fact respond using chunked encoding */\n  struct Curl_chunker chunk;\n\n  curl_closesocket_callback fclosesocket; /* function closing the socket(s) */\n  void *closesocket_client;\n\n  /* This is used by the connection cache logic. If this returns TRUE, this\n     handle is still used by one or more easy handles and can only used by any\n     other easy handle without careful consideration (== only for\n     multiplexing) and it cannot be used by another multi handle! */\n#define CONN_INUSE(c) ((c)->easyq.size)\n\n  /**** Fields set when inited and not modified again */\n  long connection_id; /* Contains a unique number to make it easier to\n                         track the connections in the log output */\n\n  /* 'dns_entry' is the particular host we use. This points to an entry in the\n     DNS cache and it will not get pruned while locked. It gets unlocked in\n     multi_done(). This entry will be NULL if the connection is re-used as then\n     there is no name resolve done. */\n  struct Curl_dns_entry *dns_entry;\n\n  /* 'ip_addr' is the particular IP we connected to. It points to a struct\n     within the DNS cache, so this pointer is only valid as long as the DNS\n     cache entry remains locked. It gets unlocked in multi_done() */\n  struct Curl_addrinfo *ip_addr;\n  struct Curl_addrinfo *tempaddr[2]; /* for happy eyeballs */\n\n  /* 'ip_addr_str' is the ip_addr data as a human readable string.\n     It remains available as long as the connection does, which is longer than\n     the ip_addr itself. */\n  char ip_addr_str[MAX_IPADR_LEN];\n\n  unsigned int scope_id;  /* Scope id for IPv6 */\n\n  enum {\n    TRNSPRT_TCP = 3,\n    TRNSPRT_UDP = 4,\n    TRNSPRT_QUIC = 5\n  } transport;\n\n#ifdef ENABLE_QUIC\n  struct quicsocket hequic[2]; /* two, for happy eyeballs! */\n  struct quicsocket *quic;\n#endif\n\n  struct hostname host;\n  char *hostname_resolve; /* host name to resolve to address, allocated */\n  char *secondaryhostname; /* secondary socket host name (ftp) */\n  struct hostname conn_to_host; /* the host to connect to. valid only if\n                                   bits.conn_to_host is set */\n#ifndef CURL_DISABLE_PROXY\n  struct proxy_info socks_proxy;\n  struct proxy_info http_proxy;\n#endif\n  long port;       /* which port to use locally */\n  int remote_port; /* the remote port, not the proxy port! */\n  int conn_to_port; /* the remote port to connect to. valid only if\n                       bits.conn_to_port is set */\n  unsigned short secondary_port; /* secondary socket remote port to connect to\n                                    (ftp) */\n\n  /* 'primary_ip' and 'primary_port' get filled with peer's numerical\n     ip address and port number whenever an outgoing connection is\n     *attempted* from the primary socket to a remote address. When more\n     than one address is tried for a connection these will hold data\n     for the last attempt. When the connection is actually established\n     these are updated with data which comes directly from the socket. */\n\n  char primary_ip[MAX_IPADR_LEN];\n  long primary_port;\n\n  /* 'local_ip' and 'local_port' get filled with local's numerical\n     ip address and port number whenever an outgoing connection is\n     **established** from the primary socket to a remote address. */\n\n  char local_ip[MAX_IPADR_LEN];\n  long local_port;\n\n  char *user;    /* user name string, allocated */\n  char *passwd;  /* password string, allocated */\n  char *options; /* options string, allocated */\n\n  char *sasl_authzid;     /* authorisation identity string, allocated */\n\n  int httpversion;        /* the HTTP version*10 reported by the server */\n  int rtspversion;        /* the RTSP version*10 reported by the server */\n\n  struct curltime now;     /* \"current\" time */\n  struct curltime created; /* creation time */\n  struct curltime lastused; /* when returned to the connection cache */\n  curl_socket_t sock[2]; /* two sockets, the second is used for the data\n                            transfer when doing FTP */\n  curl_socket_t tempsock[2]; /* temporary sockets for happy eyeballs */\n  int tempfamily[2]; /* family used for the temp sockets */\n  Curl_recv *recv[2];\n  Curl_send *send[2];\n\n#ifdef USE_RECV_BEFORE_SEND_WORKAROUND\n  struct postponed_data postponed[2]; /* two buffers for two sockets */\n#endif /* USE_RECV_BEFORE_SEND_WORKAROUND */\n  struct ssl_connect_data ssl[2]; /* this is for ssl-stuff */\n#ifndef CURL_DISABLE_PROXY\n  struct ssl_connect_data proxy_ssl[2]; /* this is for proxy ssl-stuff */\n#endif\n#ifdef USE_SSL\n  void *ssl_extra; /* separately allocated backend-specific data */\n#endif\n  struct ssl_primary_config ssl_config;\n#ifndef CURL_DISABLE_PROXY\n  struct ssl_primary_config proxy_ssl_config;\n#endif\n  struct ConnectBits bits;    /* various state-flags for this connection */\n\n /* connecttime: when connect() is called on the current IP address. Used to\n    be able to track when to move on to try next IP - but only when the multi\n    interface is used. */\n  struct curltime connecttime;\n  /* The two fields below get set in Curl_connecthost */\n  int num_addr; /* number of addresses to try to connect to */\n\n  /* how long time in milliseconds to spend on trying to connect to each IP\n     address, per family */\n  timediff_t timeoutms_per_addr[2];\n\n  const struct Curl_handler *handler; /* Connection's protocol handler */\n  const struct Curl_handler *given;   /* The protocol first given */\n\n  long ip_version; /* copied from the Curl_easy at creation time */\n\n  /* Protocols can use a custom keepalive mechanism to keep connections alive.\n     This allows those protocols to track the last time the keepalive mechanism\n     was used on this connection. */\n  struct curltime keepalive;\n\n  long upkeep_interval_ms;      /* Time between calls for connection upkeep. */\n\n  /**** curl_get() phase fields */\n\n  curl_socket_t sockfd;   /* socket to read from or CURL_SOCKET_BAD */\n  curl_socket_t writesockfd; /* socket to write to, it may very\n                                well be the same we read from.\n                                CURL_SOCKET_BAD disables */\n\n#ifdef HAVE_GSSAPI\n  BIT(sec_complete); /* if Kerberos is enabled for this connection */\n  enum protection_level command_prot;\n  enum protection_level data_prot;\n  enum protection_level request_data_prot;\n  size_t buffer_size;\n  struct krb5buffer in_buffer;\n  void *app_data;\n  const struct Curl_sec_client_mech *mech;\n  struct sockaddr_in local_addr;\n#endif\n\n#if defined(USE_KERBEROS5)    /* Consider moving some of the above GSS-API */\n  struct kerberos5data krb5;  /* variables into the structure definition, */\n#endif                        /* however, some of them are ftp specific. */\n\n  struct curl_llist easyq;    /* List of easy handles using this connection */\n  curl_seek_callback seek_func; /* function that seeks the input */\n  void *seek_client;            /* pointer to pass to the seek() above */\n\n  /*************** Request - specific items ************/\n#if defined(USE_WINDOWS_SSPI) && defined(SECPKG_ATTR_ENDPOINT_BINDINGS)\n  CtxtHandle *sslContext;\n#endif\n\n#if defined(USE_NTLM)\n  curlntlm http_ntlm_state;\n  curlntlm proxy_ntlm_state;\n\n  struct ntlmdata ntlm;     /* NTLM differs from other authentication schemes\n                               because it authenticates connections, not\n                               single requests! */\n  struct ntlmdata proxyntlm; /* NTLM data for proxy */\n#endif\n\n#ifdef USE_SPNEGO\n  curlnegotiate http_negotiate_state;\n  curlnegotiate proxy_negotiate_state;\n\n  struct negotiatedata negotiate; /* state data for host Negotiate auth */\n  struct negotiatedata proxyneg; /* state data for proxy Negotiate auth */\n#endif\n\n  /* data used for the asynch name resolve callback */\n  struct Curl_async async;\n\n  /* for chunked-encoded trailer */\n  struct dynbuf trailer;\n\n  union {\n    struct ftp_conn ftpc;\n    struct http_conn httpc;\n    struct ssh_conn sshc;\n    struct tftp_state_data *tftpc;\n    struct imap_conn imapc;\n    struct pop3_conn pop3c;\n    struct smtp_conn smtpc;\n    struct rtsp_conn rtspc;\n    struct smb_conn smbc;\n    void *rtmp;\n    struct ldapconninfo *ldapc;\n    struct mqtt_conn mqtt;\n  } proto;\n\n  int cselect_bits; /* bitmask of socket events */\n  int waitfor;      /* current READ/WRITE bits to wait for */\n\n#if defined(HAVE_GSSAPI) || defined(USE_WINDOWS_SSPI)\n  int socks5_gssapi_enctype;\n#endif\n\n  /* When this connection is created, store the conditions for the local end\n     bind. This is stored before the actual bind and before any connection is\n     made and will serve the purpose of being used for comparison reasons so\n     that subsequent bound-requested connections aren't accidentally re-using\n     wrong connections. */\n  char *localdev;\n  unsigned short localport;\n  int localportrange;\n  struct http_connect_state *connect_state; /* for HTTP CONNECT */\n  struct connectbundle *bundle; /* The bundle we are member of */\n  int negnpn; /* APLN or NPN TLS negotiated protocol, CURL_HTTP_VERSION* */\n#ifdef USE_UNIX_SOCKETS\n  char *unix_domain_socket;\n#endif\n};\n\n/* The end of connectdata. */\n\n/*\n * Struct to keep statistical and informational data.\n * All variables in this struct must be initialized/reset in Curl_initinfo().\n */\nstruct PureInfo {\n  int httpcode;  /* Recent HTTP, FTP, RTSP or SMTP response code */\n  int httpproxycode; /* response code from proxy when received separate */\n  int httpversion; /* the http version number X.Y = X*10+Y */\n  time_t filetime; /* If requested, this is might get set. Set to -1 if the\n                      time was unretrievable. */\n  curl_off_t header_size;  /* size of read header(s) in bytes */\n  curl_off_t request_size; /* the amount of bytes sent in the request(s) */\n  unsigned long proxyauthavail; /* what proxy auth types were announced */\n  unsigned long httpauthavail;  /* what host auth types were announced */\n  long numconnects; /* how many new connection did libcurl created */\n  char *contenttype; /* the content type of the object */\n  char *wouldredirect; /* URL this would've been redirected to if asked to */\n  curl_off_t retry_after; /* info from Retry-After: header */\n\n  /* PureInfo members 'conn_primary_ip', 'conn_primary_port', 'conn_local_ip'\n     and, 'conn_local_port' are copied over from the connectdata struct in\n     order to allow curl_easy_getinfo() to return this information even when\n     the session handle is no longer associated with a connection, and also\n     allow curl_easy_reset() to clear this information from the session handle\n     without disturbing information which is still alive, and that might be\n     reused, in the connection cache. */\n\n  char conn_primary_ip[MAX_IPADR_LEN];\n  long conn_primary_port;\n  char conn_local_ip[MAX_IPADR_LEN];\n  long conn_local_port;\n  const char *conn_scheme;\n  unsigned int conn_protocol;\n  struct curl_certinfo certs; /* info about the certs, only populated in\n                                 OpenSSL, GnuTLS, Schannel, NSS and GSKit\n                                 builds. Asked for with CURLOPT_CERTINFO\n                                 / CURLINFO_CERTINFO */\n  CURLproxycode pxcode;\n  BIT(timecond);  /* set to TRUE if the time condition didn't match, which\n                     thus made the document NOT get fetched */\n};\n\n\nstruct Progress {\n  time_t lastshow; /* time() of the last displayed progress meter or NULL to\n                      force redraw at next call */\n  curl_off_t size_dl; /* total expected size */\n  curl_off_t size_ul; /* total expected size */\n  curl_off_t downloaded; /* transferred so far */\n  curl_off_t uploaded; /* transferred so far */\n\n  curl_off_t current_speed; /* uses the currently fastest transfer */\n\n  int width; /* screen width at download start */\n  int flags; /* see progress.h */\n\n  timediff_t timespent;\n\n  curl_off_t dlspeed;\n  curl_off_t ulspeed;\n\n  timediff_t t_nslookup;\n  timediff_t t_connect;\n  timediff_t t_appconnect;\n  timediff_t t_pretransfer;\n  timediff_t t_starttransfer;\n  timediff_t t_redirect;\n\n  struct curltime start;\n  struct curltime t_startsingle;\n  struct curltime t_startop;\n  struct curltime t_acceptdata;\n\n\n  /* upload speed limit */\n  struct curltime ul_limit_start;\n  curl_off_t ul_limit_size;\n  /* download speed limit */\n  struct curltime dl_limit_start;\n  curl_off_t dl_limit_size;\n\n#define CURR_TIME (5 + 1) /* 6 entries for 5 seconds */\n\n  curl_off_t speeder[ CURR_TIME ];\n  struct curltime speeder_time[ CURR_TIME ];\n  int speeder_c;\n  BIT(callback);  /* set when progress callback is used */\n  BIT(is_t_startransfer_set);\n};\n\ntypedef enum {\n  HTTPREQ_NONE, /* first in list */\n  HTTPREQ_GET,\n  HTTPREQ_POST,\n  HTTPREQ_POST_FORM, /* we make a difference internally */\n  HTTPREQ_POST_MIME, /* we make a difference internally */\n  HTTPREQ_PUT,\n  HTTPREQ_HEAD,\n  HTTPREQ_LAST /* last in list */\n} Curl_HttpReq;\n\ntypedef enum {\n    RTSPREQ_NONE, /* first in list */\n    RTSPREQ_OPTIONS,\n    RTSPREQ_DESCRIBE,\n    RTSPREQ_ANNOUNCE,\n    RTSPREQ_SETUP,\n    RTSPREQ_PLAY,\n    RTSPREQ_PAUSE,\n    RTSPREQ_TEARDOWN,\n    RTSPREQ_GET_PARAMETER,\n    RTSPREQ_SET_PARAMETER,\n    RTSPREQ_RECORD,\n    RTSPREQ_RECEIVE,\n    RTSPREQ_LAST /* last in list */\n} Curl_RtspReq;\n\nstruct auth {\n  unsigned long want;  /* Bitmask set to the authentication methods wanted by\n                          app (with CURLOPT_HTTPAUTH or CURLOPT_PROXYAUTH). */\n  unsigned long picked;\n  unsigned long avail; /* Bitmask for what the server reports to support for\n                          this resource */\n  BIT(done);  /* TRUE when the auth phase is done and ready to do the\n                 actual request */\n  BIT(multipass); /* TRUE if this is not yet authenticated but within the\n                     auth multipass negotiation */\n  BIT(iestyle); /* TRUE if digest should be done IE-style or FALSE if it\n                   should be RFC compliant */\n};\n\nstruct Curl_http2_dep {\n  struct Curl_http2_dep *next;\n  struct Curl_easy *data;\n};\n\n/*\n * This struct is for holding data that was attempted to get sent to the user's\n * callback but is held due to pausing. One instance per type (BOTH, HEADER,\n * BODY).\n */\nstruct tempbuf {\n  struct dynbuf b;\n  int type;   /* type of the 'tempwrite' buffer as a bitmask that is used with\n                 Curl_client_write() */\n};\n\n/* Timers */\ntypedef enum {\n  EXPIRE_100_TIMEOUT,\n  EXPIRE_ASYNC_NAME,\n  EXPIRE_CONNECTTIMEOUT,\n  EXPIRE_DNS_PER_NAME, /* family1 */\n  EXPIRE_DNS_PER_NAME2, /* family2 */\n  EXPIRE_HAPPY_EYEBALLS_DNS, /* See asyn-ares.c */\n  EXPIRE_HAPPY_EYEBALLS,\n  EXPIRE_MULTI_PENDING,\n  EXPIRE_RUN_NOW,\n  EXPIRE_SPEEDCHECK,\n  EXPIRE_TIMEOUT,\n  EXPIRE_TOOFAST,\n  EXPIRE_QUIC,\n  EXPIRE_LAST /* not an actual timer, used as a marker only */\n} expire_id;\n\n\ntypedef enum {\n  TRAILERS_NONE,\n  TRAILERS_INITIALIZED,\n  TRAILERS_SENDING,\n  TRAILERS_DONE\n} trailers_state;\n\n\n/*\n * One instance for each timeout an easy handle can set.\n */\nstruct time_node {\n  struct curl_llist_element list;\n  struct curltime time;\n  expire_id eid;\n};\n\n/* individual pieces of the URL */\nstruct urlpieces {\n  char *scheme;\n  char *hostname;\n  char *port;\n  char *user;\n  char *password;\n  char *options;\n  char *path;\n  char *query;\n};\n\nstruct UrlState {\n  /* Points to the connection cache */\n  struct conncache *conn_cache;\n\n  int retrycount; /* number of retries on a new connection */\n\n  /* buffers to store authentication data in, as parsed from input options */\n  struct curltime keeps_speed; /* for the progress meter really */\n\n  long lastconnect_id; /* The last connection, -1 if undefined */\n  struct dynbuf headerb; /* buffer to store headers in */\n\n  char *buffer; /* download buffer */\n  char *ulbuf; /* allocated upload buffer or NULL */\n  curl_off_t current_speed;  /* the ProgressShow() function sets this,\n                                bytes / second */\n  char *first_host; /* host name of the first (not followed) request.\n                       if set, this should be the host name that we will\n                       sent authorization to, no else. Used to make Location:\n                       following not keep sending user+password... This is\n                       strdup() data.\n                    */\n  int first_remote_port; /* remote port of the first (not followed) request */\n  struct curl_ssl_session *session; /* array of 'max_ssl_sessions' size */\n  long sessionage;                  /* number of the most recent session */\n  unsigned int tempcount; /* number of entries in use in tempwrite, 0 - 3 */\n  struct tempbuf tempwrite[3]; /* BOTH, HEADER, BODY */\n  char *scratch; /* huge buffer[set.buffer_size*2] for upload CRLF replacing */\n  int os_errno;  /* filled in with errno whenever an error occurs */\n#ifdef HAVE_SIGNAL\n  /* storage for the previous bag^H^H^HSIGPIPE signal handler :-) */\n  void (*prev_signal)(int sig);\n#endif\n  struct digestdata digest;      /* state data for host Digest auth */\n  struct digestdata proxydigest; /* state data for proxy Digest auth */\n\n  struct auth authhost;  /* auth details for host */\n  struct auth authproxy; /* auth details for proxy */\n  void *resolver; /* resolver state, if it is used in the URL state -\n                     ares_channel f.e. */\n\n#if defined(USE_OPENSSL)\n  /* void instead of ENGINE to avoid bleeding OpenSSL into this header */\n  void *engine;\n#endif /* USE_OPENSSL */\n  struct curltime expiretime; /* set this with Curl_expire() only */\n  struct Curl_tree timenode; /* for the splay stuff */\n  struct curl_llist timeoutlist; /* list of pending timeouts */\n  struct time_node expires[EXPIRE_LAST]; /* nodes for each expire type */\n\n  /* a place to store the most recently set FTP entrypath */\n  char *most_recent_ftp_entrypath;\n\n  int httpversion;       /* the lowest HTTP version*10 reported by any server\n                            involved in this request */\n\n#if !defined(WIN32) && !defined(MSDOS) && !defined(__EMX__) && \\\n    !defined(__SYMBIAN32__)\n/* do FTP line-end conversions on most platforms */\n#define CURL_DO_LINEEND_CONV\n  /* for FTP downloads: track CRLF sequences that span blocks */\n  BIT(prev_block_had_trailing_cr);\n  /* for FTP downloads: how many CRLFs did we converted to LFs? */\n  curl_off_t crlf_conversions;\n#endif\n  char *range; /* range, if used. See README for detailed specification on\n                  this syntax. */\n  curl_off_t resume_from; /* continue [ftp] transfer from here */\n\n  /* This RTSP state information survives requests and connections */\n  long rtsp_next_client_CSeq; /* the session's next client CSeq */\n  long rtsp_next_server_CSeq; /* the session's next server CSeq */\n  long rtsp_CSeq_recv; /* most recent CSeq received */\n\n  curl_off_t infilesize; /* size of file to upload, -1 means unknown.\n                            Copied from set.filesize at start of operation */\n\n  size_t drain; /* Increased when this stream has data to read, even if its\n                   socket is not necessarily is readable. Decreased when\n                   checked. */\n\n  curl_read_callback fread_func; /* read callback/function */\n  void *in;                      /* CURLOPT_READDATA */\n\n  struct Curl_easy *stream_depends_on;\n  int stream_weight;\n  CURLU *uh; /* URL handle for the current parsed URL */\n  struct urlpieces up;\n  Curl_HttpReq httpreq; /* what kind of HTTP request (if any) is this */\n#ifndef CURL_DISABLE_HTTP\n  size_t trailers_bytes_sent;\n  struct dynbuf trailers_buf; /* a buffer containing the compiled trailing\n                                 headers */\n#endif\n  trailers_state trailers_state; /* whether we are sending trailers\n                                       and what stage are we at */\n\n  /* Dynamically allocated strings, MUST be freed before this struct is\n     killed. */\n  struct dynamically_allocated_data {\n    char *proxyuserpwd;\n    char *uagent;\n    char *accept_encoding;\n    char *userpwd;\n    char *rangeline;\n    char *ref;\n    char *host;\n    char *cookiehost;\n    char *rtsp_transport;\n    char *te; /* TE: request header */\n  } aptr;\n\n#ifdef CURLDEBUG\n  BIT(conncache_lock);\n#endif\n  /* when curl_easy_perform() is called, the multi handle is \"owned\" by\n     the easy handle so curl_easy_cleanup() on such an easy handle will\n     also close the multi handle! */\n  BIT(multi_owned_by_easy);\n\n  BIT(this_is_a_follow); /* this is a followed Location: request */\n  BIT(refused_stream); /* this was refused, try again */\n  BIT(errorbuf); /* Set to TRUE if the error buffer is already filled in.\n                    This must be set to FALSE every time _easy_perform() is\n                    called. */\n  BIT(allow_port); /* Is set.use_port allowed to take effect or not. This\n                      is always set TRUE when curl_easy_perform() is called. */\n  BIT(authproblem); /* TRUE if there's some problem authenticating */\n  /* set after initial USER failure, to prevent an authentication loop */\n  BIT(ftp_trying_alternative);\n  BIT(wildcardmatch); /* enable wildcard matching */\n  BIT(expect100header);  /* TRUE if we added Expect: 100-continue */\n  BIT(disableexpect);    /* TRUE if Expect: is disabled due to a previous\n                            417 response */\n  BIT(use_range);\n  BIT(rangestringalloc); /* the range string is malloc()'ed */\n  BIT(done); /* set to FALSE when Curl_init_do() is called and set to TRUE\n                  when multi_done() is called, to prevent multi_done() to get\n                  invoked twice when the multi interface is used. */\n  BIT(stream_depends_e); /* set or don't set the Exclusive bit */\n  BIT(previouslypending); /* this transfer WAS in the multi->pending queue */\n  BIT(cookie_engine);\n};\n\n\n/*\n * This 'DynamicStatic' struct defines dynamic states that actually change\n * values in the 'UserDefined' area, which MUST be taken into consideration\n * if the UserDefined struct is cloned or similar. You can probably just\n * copy these, but each one indicate a special action on other data.\n */\n\nstruct DynamicStatic {\n  char *url;        /* work URL, copied from UserDefined */\n  char *referer;    /* referer string */\n  struct curl_slist *cookielist; /* list of cookie files set by\n                                    curl_easy_setopt(COOKIEFILE) calls */\n  struct curl_slist *resolve; /* set to point to the set.resolve list when\n                                 this should be dealt with in pretransfer */\n  BIT(url_alloc);   /* URL string is malloc()'ed */\n  BIT(referer_alloc); /* referer string is malloc()ed */\n  BIT(wildcard_resolve); /* Set to true if any resolve change is a\n                              wildcard */\n};\n\n/*\n * This 'UserDefined' struct must only contain data that is set once to go\n * for many (perhaps) independent connections. Values that are generated or\n * calculated internally for the \"session handle\" MUST be defined within the\n * 'struct UrlState' instead. The only exceptions MUST note the changes in\n * the 'DynamicStatic' struct.\n * Character pointer fields point to dynamic storage, unless otherwise stated.\n */\n\nstruct Curl_multi;    /* declared and used only in multi.c */\n\n/*\n * This enumeration MUST not use conditional directives (#ifdefs), new\n * null terminated strings MUST be added to the enumeration immediately\n * before STRING_LASTZEROTERMINATED, binary fields immediately before\n * STRING_LAST. When doing so, ensure that the packages/OS400/chkstring.c\n * test is updated and applicable changes for EBCDIC to ASCII conversion\n * are catered for in curl_easy_setopt_ccsid()\n */\nenum dupstring {\n  STRING_CERT_ORIG,       /* client certificate file name */\n  STRING_CERT_PROXY,      /* client certificate file name */\n  STRING_CERT_TYPE_ORIG,  /* format for certificate (default: PEM)*/\n  STRING_CERT_TYPE_PROXY, /* format for certificate (default: PEM)*/\n  STRING_COOKIE,          /* HTTP cookie string to send */\n  STRING_COOKIEJAR,       /* dump all cookies to this file */\n  STRING_CUSTOMREQUEST,   /* HTTP/FTP/RTSP request/method to use */\n  STRING_DEFAULT_PROTOCOL, /* Protocol to use when the URL doesn't specify */\n  STRING_DEVICE,          /* local network interface/address to use */\n  STRING_ENCODING,        /* Accept-Encoding string */\n  STRING_FTP_ACCOUNT,     /* ftp account data */\n  STRING_FTP_ALTERNATIVE_TO_USER, /* command to send if USER/PASS fails */\n  STRING_FTPPORT,         /* port to send with the FTP PORT command */\n  STRING_KEY_ORIG,        /* private key file name */\n  STRING_KEY_PROXY,       /* private key file name */\n  STRING_KEY_PASSWD_ORIG, /* plain text private key password */\n  STRING_KEY_PASSWD_PROXY, /* plain text private key password */\n  STRING_KEY_TYPE_ORIG,   /* format for private key (default: PEM) */\n  STRING_KEY_TYPE_PROXY,  /* format for private key (default: PEM) */\n  STRING_KRB_LEVEL,       /* krb security level */\n  STRING_NETRC_FILE,      /* if not NULL, use this instead of trying to find\n                             $HOME/.netrc */\n  STRING_PROXY,           /* proxy to use */\n  STRING_PRE_PROXY,       /* pre socks proxy to use */\n  STRING_SET_RANGE,       /* range, if used */\n  STRING_SET_REFERER,     /* custom string for the HTTP referer field */\n  STRING_SET_URL,         /* what original URL to work on */\n  STRING_SSL_CAPATH_ORIG, /* CA directory name (doesn't work on windows) */\n  STRING_SSL_CAPATH_PROXY, /* CA directory name (doesn't work on windows) */\n  STRING_SSL_CAFILE_ORIG, /* certificate file to verify peer against */\n  STRING_SSL_CAFILE_PROXY, /* certificate file to verify peer against */\n  STRING_SSL_PINNEDPUBLICKEY_ORIG, /* public key file to verify peer against */\n  STRING_SSL_PINNEDPUBLICKEY_PROXY, /* public key file to verify proxy */\n  STRING_SSL_CIPHER_LIST_ORIG, /* list of ciphers to use */\n  STRING_SSL_CIPHER_LIST_PROXY, /* list of ciphers to use */\n  STRING_SSL_CIPHER13_LIST_ORIG, /* list of TLS 1.3 ciphers to use */\n  STRING_SSL_CIPHER13_LIST_PROXY, /* list of TLS 1.3 ciphers to use */\n  STRING_SSL_EGDSOCKET,   /* path to file containing the EGD daemon socket */\n  STRING_SSL_RANDOM_FILE, /* path to file containing \"random\" data */\n  STRING_USERAGENT,       /* User-Agent string */\n  STRING_SSL_CRLFILE_ORIG, /* crl file to check certificate */\n  STRING_SSL_CRLFILE_PROXY, /* crl file to check certificate */\n  STRING_SSL_ISSUERCERT_ORIG, /* issuer cert file to check certificate */\n  STRING_SSL_ISSUERCERT_PROXY, /* issuer cert file to check certificate */\n  STRING_SSL_ENGINE,      /* name of ssl engine */\n  STRING_USERNAME,        /* <username>, if used */\n  STRING_PASSWORD,        /* <password>, if used */\n  STRING_OPTIONS,         /* <options>, if used */\n  STRING_PROXYUSERNAME,   /* Proxy <username>, if used */\n  STRING_PROXYPASSWORD,   /* Proxy <password>, if used */\n  STRING_NOPROXY,         /* List of hosts which should not use the proxy, if\n                             used */\n  STRING_RTSP_SESSION_ID, /* Session ID to use */\n  STRING_RTSP_STREAM_URI, /* Stream URI for this request */\n  STRING_RTSP_TRANSPORT,  /* Transport for this session */\n\n  STRING_SSH_PRIVATE_KEY, /* path to the private key file for auth */\n  STRING_SSH_PUBLIC_KEY,  /* path to the public key file for auth */\n  STRING_SSH_HOST_PUBLIC_KEY_MD5, /* md5 of host public key in ascii hex */\n  STRING_SSH_KNOWNHOSTS,  /* file name of knownhosts file */\n\n  STRING_PROXY_SERVICE_NAME, /* Proxy service name */\n  STRING_SERVICE_NAME,    /* Service name */\n  STRING_MAIL_FROM,\n  STRING_MAIL_AUTH,\n\n  STRING_TLSAUTH_USERNAME_ORIG,  /* TLS auth <username> */\n  STRING_TLSAUTH_USERNAME_PROXY, /* TLS auth <username> */\n  STRING_TLSAUTH_PASSWORD_ORIG,  /* TLS auth <password> */\n  STRING_TLSAUTH_PASSWORD_PROXY, /* TLS auth <password> */\n\n  STRING_BEARER,                /* <bearer>, if used */\n\n  STRING_UNIX_SOCKET_PATH,      /* path to Unix socket, if used */\n\n  STRING_TARGET,                /* CURLOPT_REQUEST_TARGET */\n  STRING_DOH,                   /* CURLOPT_DOH_URL */\n\n  STRING_ALTSVC,                /* CURLOPT_ALTSVC */\n\n  STRING_SASL_AUTHZID,          /* CURLOPT_SASL_AUTHZID */\n\n  STRING_TEMP_URL,              /* temp URL storage for proxy use */\n\n  STRING_DNS_SERVERS,\n  STRING_DNS_INTERFACE,\n  STRING_DNS_LOCAL_IP4,\n  STRING_DNS_LOCAL_IP6,\n  STRING_SSL_EC_CURVES,\n\n  /* -- end of null-terminated strings -- */\n\n  STRING_LASTZEROTERMINATED,\n\n  /* -- below this are pointers to binary data that cannot be strdup'ed. --- */\n\n  STRING_COPYPOSTFIELDS,  /* if POST, set the fields' values here */\n\n\n  STRING_LAST /* not used, just an end-of-list marker */\n};\n\nenum dupblob {\n  BLOB_CERT_ORIG,\n  BLOB_CERT_PROXY,\n  BLOB_KEY_ORIG,\n  BLOB_KEY_PROXY,\n  BLOB_SSL_ISSUERCERT_ORIG,\n  BLOB_SSL_ISSUERCERT_PROXY,\n  BLOB_LAST\n};\n\n/* callback that gets called when this easy handle is completed within a multi\n   handle.  Only used for internally created transfers, like for example\n   DoH. */\ntypedef int (*multidone_func)(struct Curl_easy *easy, CURLcode result);\n\nstruct UserDefined {\n  FILE *err;         /* the stderr user data goes here */\n  void *debugdata;   /* the data that will be passed to fdebug */\n  char *errorbuffer; /* (Static) store failure messages in here */\n  long proxyport; /* If non-zero, use this port number by default. If the\n                     proxy string features a \":[port]\" that one will override\n                     this. */\n  void *out;         /* CURLOPT_WRITEDATA */\n  void *in_set;      /* CURLOPT_READDATA */\n  void *writeheader; /* write the header to this if non-NULL */\n  void *rtp_out;     /* write RTP to this if non-NULL */\n  long use_port;     /* which port to use (when not using default) */\n  unsigned long httpauth;  /* kind of HTTP authentication to use (bitmask) */\n  unsigned long proxyauth; /* kind of proxy authentication to use (bitmask) */\n  unsigned long socks5auth;/* kind of SOCKS5 authentication to use (bitmask) */\n  long followlocation; /* as in HTTP Location: */\n  long maxredirs;    /* maximum no. of http(s) redirects to follow, set to -1\n                        for infinity */\n\n  int keep_post;     /* keep POSTs as POSTs after a 30x request; each\n                        bit represents a request, from 301 to 303 */\n  void *postfields;  /* if POST, set the fields' values here */\n  curl_seek_callback seek_func;      /* function that seeks the input */\n  curl_off_t postfieldsize; /* if POST, this might have a size to use instead\n                               of strlen(), and then the data *may* be binary\n                               (contain zero bytes) */\n  unsigned short localport; /* local port number to bind to */\n  int localportrange; /* number of additional port numbers to test in case the\n                         'localport' one can't be bind()ed */\n  curl_write_callback fwrite_func;   /* function that stores the output */\n  curl_write_callback fwrite_header; /* function that stores headers */\n  curl_write_callback fwrite_rtp;    /* function that stores interleaved RTP */\n  curl_read_callback fread_func_set; /* function that reads the input */\n  curl_progress_callback fprogress; /* OLD and deprecated progress callback  */\n  curl_xferinfo_callback fxferinfo; /* progress callback */\n  curl_debug_callback fdebug;      /* function that write informational data */\n  curl_ioctl_callback ioctl_func;  /* function for I/O control */\n  curl_sockopt_callback fsockopt;  /* function for setting socket options */\n  void *sockopt_client; /* pointer to pass to the socket options callback */\n  curl_opensocket_callback fopensocket; /* function for checking/translating\n                                           the address and opening the\n                                           socket */\n  void *opensocket_client;\n  curl_closesocket_callback fclosesocket; /* function for closing the\n                                             socket */\n  void *closesocket_client;\n\n  void *seek_client;    /* pointer to pass to the seek callback */\n  /* the 3 curl_conv_callback functions below are used on non-ASCII hosts */\n  /* function to convert from the network encoding: */\n  curl_conv_callback convfromnetwork;\n  /* function to convert to the network encoding: */\n  curl_conv_callback convtonetwork;\n  /* function to convert from UTF-8 encoding: */\n  curl_conv_callback convfromutf8;\n\n  void *progress_client; /* pointer to pass to the progress callback */\n  void *ioctl_client;   /* pointer to pass to the ioctl callback */\n  long timeout;         /* in milliseconds, 0 means no timeout */\n  long connecttimeout;  /* in milliseconds, 0 means no timeout */\n  long accepttimeout;   /* in milliseconds, 0 means no timeout */\n  long happy_eyeballs_timeout; /* in milliseconds, 0 is a valid value */\n  long server_response_timeout; /* in milliseconds, 0 means no timeout */\n  long maxage_conn;     /* in seconds, max idle time to allow a connection that\n                           is to be reused */\n  long tftp_blksize;    /* in bytes, 0 means use default */\n  curl_off_t filesize;  /* size of file to upload, -1 means unknown */\n  long low_speed_limit; /* bytes/second */\n  long low_speed_time;  /* number of seconds */\n  curl_off_t max_send_speed; /* high speed limit in bytes/second for upload */\n  curl_off_t max_recv_speed; /* high speed limit in bytes/second for\n                                download */\n  curl_off_t set_resume_from;  /* continue [ftp] transfer from here */\n  struct curl_slist *headers; /* linked list of extra headers */\n  struct curl_slist *proxyheaders; /* linked list of extra CONNECT headers */\n  struct curl_httppost *httppost;  /* linked list of old POST data */\n  curl_mimepart mimepost;  /* MIME/POST data. */\n  struct curl_slist *quote;     /* after connection is established */\n  struct curl_slist *postquote; /* after the transfer */\n  struct curl_slist *prequote; /* before the transfer, after type */\n  struct curl_slist *source_quote;  /* 3rd party quote */\n  struct curl_slist *source_prequote;  /* in 3rd party transfer mode - before\n                                          the transfer on source host */\n  struct curl_slist *source_postquote; /* in 3rd party transfer mode - after\n                                          the transfer on source host */\n  struct curl_slist *telnet_options; /* linked list of telnet options */\n  struct curl_slist *resolve;     /* list of names to add/remove from\n                                     DNS cache */\n  struct curl_slist *connect_to; /* list of host:port mappings to override\n                                    the hostname and port to connect to */\n  curl_TimeCond timecondition; /* kind of time/date comparison */\n  time_t timevalue;       /* what time to compare with */\n  Curl_HttpReq method;   /* what kind of HTTP request (if any) is this */\n  long httpversion; /* when non-zero, a specific HTTP version requested to\n                       be used in the library's request(s) */\n  struct ssl_config_data ssl;  /* user defined SSL stuff */\n#ifndef CURL_DISABLE_PROXY\n  struct ssl_config_data proxy_ssl;  /* user defined SSL stuff for proxy */\n#endif\n  struct ssl_general_config general_ssl; /* general user defined SSL stuff */\n  curl_proxytype proxytype; /* what kind of proxy that is in use */\n  long dns_cache_timeout; /* DNS cache timeout */\n  long buffer_size;      /* size of receive buffer to use */\n  size_t upload_buffer_size; /* size of upload buffer to use,\n                                keep it >= CURL_MAX_WRITE_SIZE */\n  void *private_data; /* application-private data */\n  struct curl_slist *http200aliases; /* linked list of aliases for http200 */\n  long ipver; /* the CURL_IPRESOLVE_* defines in the public header file\n                 0 - whatever, 1 - v2, 2 - v6 */\n  curl_off_t max_filesize; /* Maximum file size to download */\n#ifndef CURL_DISABLE_FTP\n  curl_ftpfile ftp_filemethod; /* how to get to a file when FTP is used  */\n  curl_ftpauth ftpsslauth; /* what AUTH XXX to be attempted */\n  curl_ftpccc ftp_ccc;   /* FTP CCC options */\n#endif\n  int ftp_create_missing_dirs; /* 1 - create directories that don't exist\n                                  2 - the same but also allow MKD to fail once\n                               */\n  curl_sshkeycallback ssh_keyfunc; /* key matching callback */\n  void *ssh_keyfunc_userp;         /* custom pointer to callback */\n  enum CURL_NETRC_OPTION\n       use_netrc;        /* defined in include/curl.h */\n  curl_usessl use_ssl;   /* if AUTH TLS is to be attempted etc, for FTP or\n                            IMAP or POP3 or others! */\n  long new_file_perms;    /* Permissions to use when creating remote files */\n  long new_directory_perms; /* Permissions to use when creating remote dirs */\n  long ssh_auth_types;   /* allowed SSH auth types */\n  char *str[STRING_LAST]; /* array of strings, pointing to allocated memory */\n  struct curl_blob *blobs[BLOB_LAST];\n  unsigned int scope_id;  /* Scope id for IPv6 */\n  long allowed_protocols;\n  long redir_protocols;\n  struct curl_slist *mail_rcpt; /* linked list of mail recipients */\n  /* Common RTSP header options */\n  Curl_RtspReq rtspreq; /* RTSP request type */\n  long rtspversion; /* like httpversion, for RTSP */\n  curl_chunk_bgn_callback chunk_bgn; /* called before part of transfer\n                                        starts */\n  curl_chunk_end_callback chunk_end; /* called after part transferring\n                                        stopped */\n  curl_fnmatch_callback fnmatch; /* callback to decide which file corresponds\n                                    to pattern (e.g. if WILDCARDMATCH is on) */\n  void *fnmatch_data;\n\n  long gssapi_delegation; /* GSS-API credential delegation, see the\n                             documentation of CURLOPT_GSSAPI_DELEGATION */\n\n  long tcp_keepidle;     /* seconds in idle before sending keepalive probe */\n  long tcp_keepintvl;    /* seconds between TCP keepalive probes */\n\n  size_t maxconnects;    /* Max idle connections in the connection cache */\n\n  long expect_100_timeout; /* in milliseconds */\n  struct Curl_easy *stream_depends_on;\n  int stream_weight;\n  struct Curl_http2_dep *stream_dependents;\n\n  curl_resolver_start_callback resolver_start; /* optional callback called\n                                                  before resolver start */\n  void *resolver_start_client; /* pointer to pass to resolver start callback */\n  long upkeep_interval_ms;      /* Time between calls for connection upkeep. */\n  multidone_func fmultidone;\n  struct Curl_easy *dohfor; /* this is a DoH request for that transfer */\n  CURLU *uh; /* URL handle for the current parsed URL */\n  void *trailer_data; /* pointer to pass to trailer data callback */\n  curl_trailer_callback trailer_callback; /* trailing data callback */\n  BIT(is_fread_set); /* has read callback been set to non-NULL? */\n  BIT(is_fwrite_set); /* has write callback been set to non-NULL? */\n  BIT(free_referer); /* set TRUE if 'referer' points to a string we\n                        allocated */\n  BIT(tftp_no_options); /* do not send TFTP options requests */\n  BIT(sep_headers);     /* handle host and proxy headers separately */\n  BIT(cookiesession);   /* new cookie session? */\n  BIT(crlf);            /* convert crlf on ftp upload(?) */\n  BIT(strip_path_slash); /* strip off initial slash from path */\n  BIT(ssh_compression);            /* enable SSH compression */\n\n/* Here follows boolean settings that define how to behave during\n   this session. They are STATIC, set by libcurl users or at least initially\n   and they don't change during operations. */\n  BIT(get_filetime);     /* get the time and get of the remote file */\n  BIT(tunnel_thru_httpproxy); /* use CONNECT through a HTTP proxy */\n  BIT(prefer_ascii);     /* ASCII rather than binary */\n  BIT(ftp_append);       /* append, not overwrite, on upload */\n  BIT(ftp_list_only);    /* switch FTP command for listing directories */\n#ifndef CURL_DISABLE_FTP\n  BIT(ftp_use_port);     /* use the FTP PORT command */\n  BIT(ftp_use_epsv);     /* if EPSV is to be attempted or not */\n  BIT(ftp_use_eprt);     /* if EPRT is to be attempted or not */\n  BIT(ftp_use_pret);     /* if PRET is to be used before PASV or not */\n  BIT(ftp_skip_ip);      /* skip the IP address the FTP server passes on to\n                            us */\n#endif\n  BIT(hide_progress);    /* don't use the progress meter */\n  BIT(http_fail_on_error);  /* fail on HTTP error codes >= 400 */\n  BIT(http_keep_sending_on_error); /* for HTTP status codes >= 300 */\n  BIT(http_follow_location); /* follow HTTP redirects */\n  BIT(http_transfer_encoding); /* request compressed HTTP transfer-encoding */\n  BIT(allow_auth_to_other_hosts);\n  BIT(include_header); /* include received protocol headers in data output */\n  BIT(http_set_referer); /* is a custom referer used */\n  BIT(http_auto_referer); /* set \"correct\" referer when following\n                             location: */\n  BIT(opt_no_body);    /* as set with CURLOPT_NOBODY */\n  BIT(upload);         /* upload request */\n  BIT(verbose);        /* output verbosity */\n  BIT(krb);            /* Kerberos connection requested */\n  BIT(reuse_forbid);   /* forbidden to be reused, close after use */\n  BIT(reuse_fresh);    /* do not re-use an existing connection  */\n  BIT(no_signal);      /* do not use any signal/alarm handler */\n  BIT(tcp_nodelay);    /* whether to enable TCP_NODELAY or not */\n  BIT(ignorecl);       /* ignore content length */\n  BIT(connect_only);   /* make connection, let application use the socket */\n  BIT(http_te_skip);   /* pass the raw body data to the user, even when\n                          transfer-encoded (chunked, compressed) */\n  BIT(http_ce_skip);   /* pass the raw body data to the user, even when\n                          content-encoded (chunked, compressed) */\n  BIT(proxy_transfer_mode); /* set transfer mode (;type=<a|i>) when doing\n                               FTP via an HTTP proxy */\n#if defined(HAVE_GSSAPI) || defined(USE_WINDOWS_SSPI)\n  BIT(socks5_gssapi_nec); /* Flag to support NEC SOCKS5 server */\n#endif\n  BIT(sasl_ir);         /* Enable/disable SASL initial response */\n  BIT(wildcard_enabled); /* enable wildcard matching */\n  BIT(tcp_keepalive);  /* use TCP keepalives */\n  BIT(tcp_fastopen);   /* use TCP Fast Open */\n  BIT(ssl_enable_npn); /* TLS NPN extension? */\n  BIT(ssl_enable_alpn);/* TLS ALPN extension? */\n  BIT(path_as_is);     /* allow dotdots? */\n  BIT(pipewait);       /* wait for multiplex status before starting a new\n                          connection */\n  BIT(suppress_connect_headers); /* suppress proxy CONNECT response headers\n                                    from user callbacks */\n  BIT(dns_shuffle_addresses); /* whether to shuffle addresses before use */\n  BIT(stream_depends_e); /* set or don't set the Exclusive bit */\n  BIT(haproxyprotocol); /* whether to send HAProxy PROXY protocol v1\n                           header */\n  BIT(abstract_unix_socket);\n  BIT(disallow_username_in_url); /* disallow username in url */\n  BIT(doh); /* DNS-over-HTTPS enabled */\n  BIT(doh_get); /* use GET for DoH requests, instead of POST */\n  BIT(http09_allowed); /* allow HTTP/0.9 responses */\n  BIT(mail_rcpt_allowfails); /* allow RCPT TO command to fail for some\n                                recipients */\n};\n\nstruct Names {\n  struct curl_hash *hostcache;\n  enum {\n    HCACHE_NONE,    /* not pointing to anything */\n    HCACHE_MULTI,   /* points to a shared one in the multi handle */\n    HCACHE_SHARED   /* points to a shared one in a shared object */\n  } hostcachetype;\n};\n\n/*\n * The 'connectdata' struct MUST have all the connection oriented stuff as we\n * may have several simultaneous connections and connection structs in memory.\n *\n * The 'struct UserDefined' must only contain data that is set once to go for\n * many (perhaps) independent connections. Values that are generated or\n * calculated internally for the \"session handle\" must be defined within the\n * 'struct UrlState' instead.\n */\n\nstruct Curl_easy {\n  /* first, two fields for the linked list of these */\n  struct Curl_easy *next;\n  struct Curl_easy *prev;\n\n  struct connectdata *conn;\n  struct curl_llist_element connect_queue;\n  struct curl_llist_element conn_queue; /* list per connectdata */\n\n  CURLMstate mstate;  /* the handle's state */\n  CURLcode result;   /* previous result */\n\n  struct Curl_message msg; /* A single posted message. */\n\n  /* Array with the plain socket numbers this handle takes care of, in no\n     particular order. Note that all sockets are added to the sockhash, where\n     the state etc are also kept. This array is mostly used to detect when a\n     socket is to be removed from the hash. See singlesocket(). */\n  curl_socket_t sockets[MAX_SOCKSPEREASYHANDLE];\n  int actions[MAX_SOCKSPEREASYHANDLE]; /* action for each socket in\n                                          sockets[] */\n  int numsocks;\n\n  struct Names dns;\n  struct Curl_multi *multi;    /* if non-NULL, points to the multi handle\n                                  struct to which this \"belongs\" when used by\n                                  the multi interface */\n  struct Curl_multi *multi_easy; /* if non-NULL, points to the multi handle\n                                    struct to which this \"belongs\" when used\n                                    by the easy interface */\n  struct Curl_share *share;    /* Share, handles global variable mutexing */\n#ifdef USE_LIBPSL\n  struct PslCache *psl;        /* The associated PSL cache. */\n#endif\n  struct SingleRequest req;    /* Request-specific data */\n  struct UserDefined set;      /* values set by the libcurl user */\n  struct DynamicStatic change; /* possibly modified userdefined data */\n  struct CookieInfo *cookies;  /* the cookies, read from files and servers.\n                                  NOTE that the 'cookie' field in the\n                                  UserDefined struct defines if the \"engine\"\n                                  is to be used or not. */\n#ifdef USE_ALTSVC\n  struct altsvcinfo *asi;      /* the alt-svc cache */\n#endif\n  struct Progress progress;    /* for all the progress meter data */\n  struct UrlState state;       /* struct for fields used for state info and\n                                  other dynamic purposes */\n#ifndef CURL_DISABLE_FTP\n  struct WildcardData wildcard; /* wildcard download state info */\n#endif\n  struct PureInfo info;        /* stats, reports and info data */\n  struct curl_tlssessioninfo tsi; /* Information about the TLS session, only\n                                     valid after a client has asked for it */\n#if defined(CURL_DOES_CONVERSIONS) && defined(HAVE_ICONV)\n  iconv_t outbound_cd;         /* for translating to the network encoding */\n  iconv_t inbound_cd;          /* for translating from the network encoding */\n  iconv_t utf8_cd;             /* for translating to UTF8 */\n#endif /* CURL_DOES_CONVERSIONS && HAVE_ICONV */\n  unsigned int magic;          /* set to a CURLEASY_MAGIC_NUMBER */\n};\n\n#define LIBCURL_NAME \"libcurl\"\n\n#endif /* HEADER_CURL_URLDATA_H */\n"}, "39": {"id": 39, "path": "/home/runner/work/testcc/testcc/retdec/lib/multiif.h", "content": "#ifndef HEADER_CURL_MULTIIF_H\n#define HEADER_CURL_MULTIIF_H\n/***************************************************************************\n *                                  _   _ ____  _\n *  Project                     ___| | | |  _ \\| |\n *                             / __| | | | |_) | |\n *                            | (__| |_| |  _ <| |___\n *                             \\___|\\___/|_| \\_\\_____|\n *\n * Copyright (C) 1998 - 2020, Daniel Stenberg, <daniel@haxx.se>, et al.\n *\n * This software is licensed as described in the file COPYING, which\n * you should have received as part of this distribution. The terms\n * are also available at https://curl.haxx.se/docs/copyright.html.\n *\n * You may opt to use, copy, modify, merge, publish, distribute and/or sell\n * copies of the Software, and permit persons to whom the Software is\n * furnished to do so, under the terms of the COPYING file.\n *\n * This software is distributed on an \"AS IS\" basis, WITHOUT WARRANTY OF ANY\n * KIND, either express or implied.\n *\n ***************************************************************************/\n\n/*\n * Prototypes for library-wide functions provided by multi.c\n */\n\nvoid Curl_updatesocket(struct Curl_easy *data);\nvoid Curl_expire(struct Curl_easy *data, timediff_t milli, expire_id);\nvoid Curl_expire_clear(struct Curl_easy *data);\nvoid Curl_expire_done(struct Curl_easy *data, expire_id id);\nvoid Curl_update_timer(struct Curl_multi *multi);\nvoid Curl_attach_connnection(struct Curl_easy *data,\n                             struct connectdata *conn);\nvoid Curl_detach_connnection(struct Curl_easy *data);\nbool Curl_multiplex_wanted(const struct Curl_multi *multi);\nvoid Curl_set_in_callback(struct Curl_easy *data, bool value);\nbool Curl_is_in_callback(struct Curl_easy *easy);\nCURLcode Curl_preconnect(struct Curl_easy *data);\n\n/* Internal version of curl_multi_init() accepts size parameters for the\n   socket and connection hashes */\nstruct Curl_multi *Curl_multi_handle(int hashsize, int chashsize);\n\n/* the write bits start at bit 16 for the *getsock() bitmap */\n#define GETSOCK_WRITEBITSTART 16\n\n#define GETSOCK_BLANK 0 /* no bits set */\n\n/* set the bit for the given sock number to make the bitmap for writable */\n#define GETSOCK_WRITESOCK(x) (1 << (GETSOCK_WRITEBITSTART + (x)))\n\n/* set the bit for the given sock number to make the bitmap for readable */\n#define GETSOCK_READSOCK(x) (1 << (x))\n\n#ifdef DEBUGBUILD\n /*\n  * Curl_multi_dump is not a stable public function, this is only meant to\n  * allow easier tracking of the internal handle's state and what sockets\n  * they use. Only for research and development DEBUGBUILD enabled builds.\n  */\nvoid Curl_multi_dump(struct Curl_multi *multi);\n#endif\n\n/* Return the value of the CURLMOPT_MAX_HOST_CONNECTIONS option */\nsize_t Curl_multi_max_host_connections(struct Curl_multi *multi);\n\n/* Return the value of the CURLMOPT_MAX_TOTAL_CONNECTIONS option */\nsize_t Curl_multi_max_total_connections(struct Curl_multi *multi);\n\nvoid Curl_multiuse_state(struct connectdata *conn,\n                         int bundlestate); /* use BUNDLE_* defines */\n\n/*\n * Curl_multi_closed()\n *\n * Used by the connect code to tell the multi_socket code that one of the\n * sockets we were using is about to be closed.  This function will then\n * remove it from the sockethash for this handle to make the multi_socket API\n * behave properly, especially for the case when libcurl will create another\n * socket again and it gets the same file descriptor number.\n */\n\nvoid Curl_multi_closed(struct Curl_easy *data, curl_socket_t s);\n\n/*\n * Add a handle and move it into PERFORM state at once. For pushed streams.\n */\nCURLMcode Curl_multi_add_perform(struct Curl_multi *multi,\n                                 struct Curl_easy *data,\n                                 struct connectdata *conn);\n\n\n/* Return the value of the CURLMOPT_MAX_CONCURRENT_STREAMS option */\nunsigned int Curl_multi_max_concurrent_streams(struct Curl_multi *multi);\n\n#endif /* HEADER_CURL_MULTIIF_H */\n"}, "40": {"id": 40, "path": "/usr/include/x86_64-linux-gnu/sys/select.h", "content": "/* `fd_set' type and related macros, and `select'/`pselect' declarations.\n   Copyright (C) 1996-2018 Free Software Foundation, Inc.\n   This file is part of the GNU C Library.\n\n   The GNU C Library is free software; you can redistribute it and/or\n   modify it under the terms of the GNU Lesser General Public\n   License as published by the Free Software Foundation; either\n   version 2.1 of the License, or (at your option) any later version.\n\n   The GNU C Library is distributed in the hope that it will be useful,\n   but WITHOUT ANY WARRANTY; without even the implied warranty of\n   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n   Lesser General Public License for more details.\n\n   You should have received a copy of the GNU Lesser General Public\n   License along with the GNU C Library; if not, see\n   <http://www.gnu.org/licenses/>.  */\n\n/*\tPOSIX 1003.1g: 6.2 Select from File Descriptor Sets <sys/select.h>  */\n\n#ifndef _SYS_SELECT_H\n#define _SYS_SELECT_H\t1\n\n#include <features.h>\n\n/* Get definition of needed basic types.  */\n#include <bits/types.h>\n\n/* Get __FD_* definitions.  */\n#include <bits/select.h>\n\n/* Get sigset_t.  */\n#include <bits/types/sigset_t.h>\n\n/* Get definition of timer specification structures.  */\n#include <bits/types/time_t.h>\n#include <bits/types/struct_timeval.h>\n#ifdef __USE_XOPEN2K\n# include <bits/types/struct_timespec.h>\n#endif\n\n#ifndef __suseconds_t_defined\ntypedef __suseconds_t suseconds_t;\n# define __suseconds_t_defined\n#endif\n\n\n/* The fd_set member is required to be an array of longs.  */\ntypedef long int __fd_mask;\n\n/* Some versions of <linux/posix_types.h> define this macros.  */\n#undef\t__NFDBITS\n/* It's easier to assume 8-bit bytes than to get CHAR_BIT.  */\n#define __NFDBITS\t(8 * (int) sizeof (__fd_mask))\n#define\t__FD_ELT(d)\t((d) / __NFDBITS)\n#define\t__FD_MASK(d)\t((__fd_mask) (1UL << ((d) % __NFDBITS)))\n\n/* fd_set for select and pselect.  */\ntypedef struct\n  {\n    /* XPG4.2 requires this member name.  Otherwise avoid the name\n       from the global namespace.  */\n#ifdef __USE_XOPEN\n    __fd_mask fds_bits[__FD_SETSIZE / __NFDBITS];\n# define __FDS_BITS(set) ((set)->fds_bits)\n#else\n    __fd_mask __fds_bits[__FD_SETSIZE / __NFDBITS];\n# define __FDS_BITS(set) ((set)->__fds_bits)\n#endif\n  } fd_set;\n\n/* Maximum number of file descriptors in `fd_set'.  */\n#define\tFD_SETSIZE\t\t__FD_SETSIZE\n\n#ifdef __USE_MISC\n/* Sometimes the fd_set member is assumed to have this type.  */\ntypedef __fd_mask fd_mask;\n\n/* Number of bits per word of `fd_set' (some code assumes this is 32).  */\n# define NFDBITS\t\t__NFDBITS\n#endif\n\n\n/* Access macros for `fd_set'.  */\n#define\tFD_SET(fd, fdsetp)\t__FD_SET (fd, fdsetp)\n#define\tFD_CLR(fd, fdsetp)\t__FD_CLR (fd, fdsetp)\n#define\tFD_ISSET(fd, fdsetp)\t__FD_ISSET (fd, fdsetp)\n#define\tFD_ZERO(fdsetp)\t\t__FD_ZERO (fdsetp)\n\n\n__BEGIN_DECLS\n\n/* Check the first NFDS descriptors each in READFDS (if not NULL) for read\n   readiness, in WRITEFDS (if not NULL) for write readiness, and in EXCEPTFDS\n   (if not NULL) for exceptional conditions.  If TIMEOUT is not NULL, time out\n   after waiting the interval specified therein.  Returns the number of ready\n   descriptors, or -1 for errors.\n\n   This function is a cancellation point and therefore not marked with\n   __THROW.  */\nextern int select (int __nfds, fd_set *__restrict __readfds,\n\t\t   fd_set *__restrict __writefds,\n\t\t   fd_set *__restrict __exceptfds,\n\t\t   struct timeval *__restrict __timeout);\n\n#ifdef __USE_XOPEN2K\n/* Same as above only that the TIMEOUT value is given with higher\n   resolution and a sigmask which is been set temporarily.  This version\n   should be used.\n\n   This function is a cancellation point and therefore not marked with\n   __THROW.  */\nextern int pselect (int __nfds, fd_set *__restrict __readfds,\n\t\t    fd_set *__restrict __writefds,\n\t\t    fd_set *__restrict __exceptfds,\n\t\t    const struct timespec *__restrict __timeout,\n\t\t    const __sigset_t *__restrict __sigmask);\n#endif\n\n\n/* Define some inlines helping to catch common problems.  */\n#if __USE_FORTIFY_LEVEL > 0 && defined __GNUC__\n# include <bits/select2.h>\n#endif\n\n__END_DECLS\n\n#endif /* sys/select.h */\n"}, "41": {"id": 41, "path": "/usr/include/x86_64-linux-gnu/bits/select.h", "content": "/* Copyright (C) 1997-2018 Free Software Foundation, Inc.\n   This file is part of the GNU C Library.\n\n   The GNU C Library is free software; you can redistribute it and/or\n   modify it under the terms of the GNU Lesser General Public\n   License as published by the Free Software Foundation; either\n   version 2.1 of the License, or (at your option) any later version.\n\n   The GNU C Library is distributed in the hope that it will be useful,\n   but WITHOUT ANY WARRANTY; without even the implied warranty of\n   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n   Lesser General Public License for more details.\n\n   You should have received a copy of the GNU Lesser General Public\n   License along with the GNU C Library; if not, see\n   <http://www.gnu.org/licenses/>.  */\n\n#ifndef _SYS_SELECT_H\n# error \"Never use <bits/select.h> directly; include <sys/select.h> instead.\"\n#endif\n\n#include <bits/wordsize.h>\n\n\n#if defined __GNUC__ && __GNUC__ >= 2\n\n# if __WORDSIZE == 64\n#  define __FD_ZERO_STOS \"stosq\"\n# else\n#  define __FD_ZERO_STOS \"stosl\"\n# endif\n\n# define __FD_ZERO(fdsp) \\\n  do {\t\t\t\t\t\t\t\t\t      \\\n    int __d0, __d1;\t\t\t\t\t\t\t      \\\n    __asm__ __volatile__ (\"cld; rep; \" __FD_ZERO_STOS\t\t\t      \\\n\t\t\t  : \"=c\" (__d0), \"=D\" (__d1)\t\t\t      \\\n\t\t\t  : \"a\" (0), \"0\" (sizeof (fd_set)\t\t      \\\n\t\t\t\t\t  / sizeof (__fd_mask)),\t      \\\n\t\t\t    \"1\" (&__FDS_BITS (fdsp)[0])\t\t\t      \\\n\t\t\t  : \"memory\");\t\t\t\t\t      \\\n  } while (0)\n\n#else\t/* ! GNU CC */\n\n/* We don't use `memset' because this would require a prototype and\n   the array isn't too big.  */\n# define __FD_ZERO(set)  \\\n  do {\t\t\t\t\t\t\t\t\t      \\\n    unsigned int __i;\t\t\t\t\t\t\t      \\\n    fd_set *__arr = (set);\t\t\t\t\t\t      \\\n    for (__i = 0; __i < sizeof (fd_set) / sizeof (__fd_mask); ++__i)\t      \\\n      __FDS_BITS (__arr)[__i] = 0;\t\t\t\t\t      \\\n  } while (0)\n\n#endif\t/* GNU CC */\n\n#define __FD_SET(d, set) \\\n  ((void) (__FDS_BITS (set)[__FD_ELT (d)] |= __FD_MASK (d)))\n#define __FD_CLR(d, set) \\\n  ((void) (__FDS_BITS (set)[__FD_ELT (d)] &= ~__FD_MASK (d)))\n#define __FD_ISSET(d, set) \\\n  ((__FDS_BITS (set)[__FD_ELT (d)] & __FD_MASK (d)) != 0)\n"}, "42": {"id": 42, "path": "/usr/lib/llvm-6.0/lib/clang/6.0.0/include/stdarg.h", "content": "/*===---- stdarg.h - Variable argument handling ----------------------------===\n *\n * Copyright (c) 2008 Eli Friedman\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n * THE SOFTWARE.\n *\n *===-----------------------------------------------------------------------===\n */\n\n#ifndef __STDARG_H\n#define __STDARG_H\n\n#ifndef _VA_LIST\ntypedef __builtin_va_list va_list;\n#define _VA_LIST\n#endif\n#define va_start(ap, param) __builtin_va_start(ap, param)\n#define va_end(ap)          __builtin_va_end(ap)\n#define va_arg(ap, type)    __builtin_va_arg(ap, type)\n\n/* GCC always defines __va_copy, but does not define va_copy unless in c99 mode\n * or -ansi is not specified, since it was not part of C90.\n */\n#define __va_copy(d,s) __builtin_va_copy(d,s)\n\n#if __STDC_VERSION__ >= 199901L || __cplusplus >= 201103L || !defined(__STRICT_ANSI__)\n#define va_copy(dest, src)  __builtin_va_copy(dest, src)\n#endif\n\n#ifndef __GNUC_VA_LIST\n#define __GNUC_VA_LIST 1\ntypedef __builtin_va_list __gnuc_va_list;\n#endif\n\n#endif /* __STDARG_H */\n"}, "54": {"id": 54, "path": "/home/runner/work/testcc/testcc/retdec/lib/sigpipe.h", "content": "#ifndef HEADER_CURL_SIGPIPE_H\n#define HEADER_CURL_SIGPIPE_H\n/***************************************************************************\n *                                  _   _ ____  _\n *  Project                     ___| | | |  _ \\| |\n *                             / __| | | | |_) | |\n *                            | (__| |_| |  _ <| |___\n *                             \\___|\\___/|_| \\_\\_____|\n *\n * Copyright (C) 1998 - 2019, Daniel Stenberg, <daniel@haxx.se>, et al.\n *\n * This software is licensed as described in the file COPYING, which\n * you should have received as part of this distribution. The terms\n * are also available at https://curl.haxx.se/docs/copyright.html.\n *\n * You may opt to use, copy, modify, merge, publish, distribute and/or sell\n * copies of the Software, and permit persons to whom the Software is\n * furnished to do so, under the terms of the COPYING file.\n *\n * This software is distributed on an \"AS IS\" basis, WITHOUT WARRANTY OF ANY\n * KIND, either express or implied.\n *\n ***************************************************************************/\n#include \"curl_setup.h\"\n\n#if defined(HAVE_SIGNAL_H) && defined(HAVE_SIGACTION) &&        \\\n  (defined(USE_OPENSSL) || defined(USE_MBEDTLS))\n#include <signal.h>\n\nstruct sigpipe_ignore {\n  struct sigaction old_pipe_act;\n  bool no_signal;\n};\n\n#define SIGPIPE_VARIABLE(x) struct sigpipe_ignore x\n\n/*\n * sigpipe_ignore() makes sure we ignore SIGPIPE while running libcurl\n * internals, and then sigpipe_restore() will restore the situation when we\n * return from libcurl again.\n */\nstatic void sigpipe_ignore(struct Curl_easy *data,\n                           struct sigpipe_ignore *ig)\n{\n  /* get a local copy of no_signal because the Curl_easy might not be\n     around when we restore */\n  ig->no_signal = data->set.no_signal;\n  if(!data->set.no_signal) {\n    struct sigaction action;\n    /* first, extract the existing situation */\n    memset(&ig->old_pipe_act, 0, sizeof(struct sigaction));\n    sigaction(SIGPIPE, NULL, &ig->old_pipe_act);\n    action = ig->old_pipe_act;\n    /* ignore this signal */\n    action.sa_handler = SIG_IGN;\n    sigaction(SIGPIPE, &action, NULL);\n  }\n}\n\n/*\n * sigpipe_restore() puts back the outside world's opinion of signal handler\n * and SIGPIPE handling. It MUST only be called after a corresponding\n * sigpipe_ignore() was used.\n */\nstatic void sigpipe_restore(struct sigpipe_ignore *ig)\n{\n  if(!ig->no_signal)\n    /* restore the outside state */\n    sigaction(SIGPIPE, &ig->old_pipe_act, NULL);\n}\n\n#else\n/* for systems without sigaction */\n#define sigpipe_ignore(x,y) Curl_nop_stmt\n#define sigpipe_restore(x)  Curl_nop_stmt\n#define SIGPIPE_VARIABLE(x)\n#endif\n\n#endif /* HEADER_CURL_SIGPIPE_H */\n"}}, "reports": [{"events": [{"location": {"col": 52, "file": 4, "line": 136}, "message": "multi (fixit)"}, {"location": {"col": 11, "file": 5, "line": 417}, "message": "the definition seen here"}, {"location": {"col": 23, "file": 4, "line": 136}, "message": "differing parameters are named here: ('multi_handle', 'curl_handle'), in definition: ('multi', 'data')"}, {"location": {"col": 23, "file": 4, "line": 136}, "message": "function 'curl_multi_add_handle' has a definition with different parameter names"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/include/curl/multi.h", "reportHash": "754e9dadcbcbfa74f1485dae25165030", "checkerName": "readability-inconsistent-declaration-parameter-name", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 55, "file": 4, "line": 146}, "message": "multi (fixit)"}, {"location": {"col": 11, "file": 5, "line": 719}, "message": "the definition seen here"}, {"location": {"col": 23, "file": 4, "line": 146}, "message": "differing parameters are named here: ('multi_handle', 'curl_handle'), in definition: ('multi', 'data')"}, {"location": {"col": 23, "file": 4, "line": 146}, "message": "function 'curl_multi_remove_handle' has a definition with different parameter names"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/include/curl/multi.h", "reportHash": "d4429e44a267cfd8c295fe0be35fb5f0", "checkerName": "readability-inconsistent-declaration-parameter-name", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 47, "file": 4, "line": 158}, "message": "multi (fixit)"}, {"location": {"col": 11, "file": 5, "line": 1025}, "message": "the definition seen here"}, {"location": {"col": 23, "file": 4, "line": 158}, "message": "differing parameters are named here: ('multi_handle'), in definition: ('multi')"}, {"location": {"col": 23, "file": 4, "line": 158}, "message": "function 'curl_multi_fdset' has a definition with different parameter names"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/include/curl/multi.h", "reportHash": "d85b4ccb2259d2f906827f2e8b937d17", "checkerName": "readability-inconsistent-declaration-parameter-name", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 46, "file": 4, "line": 172}, "message": "multi (fixit)"}, {"location": {"col": 11, "file": 5, "line": 1416}, "message": "the definition seen here"}, {"location": {"col": 23, "file": 4, "line": 172}, "message": "differing parameters are named here: ('multi_handle'), in definition: ('multi')"}, {"location": {"col": 23, "file": 4, "line": 172}, "message": "function 'curl_multi_wait' has a definition with different parameter names"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/include/curl/multi.h", "reportHash": "337f8f7082ea8fb20a033c2ed1686223", "checkerName": "readability-inconsistent-declaration-parameter-name", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 46, "file": 4, "line": 186}, "message": "multi (fixit)"}, {"location": {"col": 11, "file": 5, "line": 1426}, "message": "the definition seen here"}, {"location": {"col": 23, "file": 4, "line": 186}, "message": "differing parameters are named here: ('multi_handle'), in definition: ('multi')"}, {"location": {"col": 23, "file": 4, "line": 186}, "message": "function 'curl_multi_poll' has a definition with different parameter names"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/include/curl/multi.h", "reportHash": "645bb7138b8ae1862bddb31e898b5a6c", "checkerName": "readability-inconsistent-declaration-parameter-name", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 48, "file": 4, "line": 199}, "message": "multi (fixit)"}, {"location": {"col": 11, "file": 5, "line": 1436}, "message": "the definition seen here"}, {"location": {"col": 23, "file": 4, "line": 199}, "message": "differing parameters are named here: ('multi_handle'), in definition: ('multi')"}, {"location": {"col": 23, "file": 4, "line": 199}, "message": "function 'curl_multi_wakeup' has a definition with different parameter names"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/include/curl/multi.h", "reportHash": "793c415c661290c0aa60567f869e44b9", "checkerName": "readability-inconsistent-declaration-parameter-name", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 49, "file": 4, "line": 217}, "message": "multi (fixit)"}, {"location": {"col": 11, "file": 5, "line": 2541}, "message": "the definition seen here"}, {"location": {"col": 23, "file": 4, "line": 217}, "message": "differing parameters are named here: ('multi_handle'), in definition: ('multi')"}, {"location": {"col": 23, "file": 4, "line": 217}, "message": "function 'curl_multi_perform' has a definition with different parameter names"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/include/curl/multi.h", "reportHash": "97023345926d6701a41618eb5c258c8f", "checkerName": "readability-inconsistent-declaration-parameter-name", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 49, "file": 4, "line": 230}, "message": "multi (fixit)"}, {"location": {"col": 11, "file": 5, "line": 2595}, "message": "the definition seen here"}, {"location": {"col": 23, "file": 4, "line": 230}, "message": "differing parameters are named here: ('multi_handle'), in definition: ('multi')"}, {"location": {"col": 23, "file": 4, "line": 230}, "message": "function 'curl_multi_cleanup' has a definition with different parameter names"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/include/curl/multi.h", "reportHash": "674bf7339bd515cf539e0f25e9ff05c0", "checkerName": "readability-inconsistent-declaration-parameter-name", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 50, "file": 4, "line": 260}, "message": "multi (fixit)"}, {"location": {"col": 10, "file": 5, "line": 2668}, "message": "the definition seen here"}, {"location": {"col": 22, "file": 4, "line": 260}, "message": "differing parameters are named here: ('multi_handle'), in definition: ('multi')"}, {"location": {"col": 22, "file": 4, "line": 260}, "message": "function 'curl_multi_info_read' has a definition with different parameter names"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/include/curl/multi.h", "reportHash": "737353e1d528cea6152bee868541a558", "checkerName": "readability-inconsistent-declaration-parameter-name", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 48, "file": 4, "line": 317}, "message": "multi (fixit)"}, {"location": {"col": 11, "file": 5, "line": 3137}, "message": "the definition seen here"}, {"location": {"col": 23, "file": 4, "line": 317}, "message": "differing parameters are named here: ('multi_handle'), in definition: ('multi')"}, {"location": {"col": 23, "file": 4, "line": 317}, "message": "function 'curl_multi_socket' has a definition with different parameter names"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/include/curl/multi.h", "reportHash": "b46a83568eb29d856a1ee92c1e014292", "checkerName": "readability-inconsistent-declaration-parameter-name", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 55, "file": 4, "line": 320}, "message": "multi (fixit)"}, {"location": {"col": 11, "file": 5, "line": 3149}, "message": "the definition seen here"}, {"location": {"col": 23, "file": 4, "line": 320}, "message": "differing parameters are named here: ('multi_handle'), in definition: ('multi')"}, {"location": {"col": 23, "file": 4, "line": 320}, "message": "function 'curl_multi_socket_action' has a definition with different parameter names"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/include/curl/multi.h", "reportHash": "fb52ed5c40f14cca277edf054f7b6168", "checkerName": "readability-inconsistent-declaration-parameter-name", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 52, "file": 4, "line": 325}, "message": "multi (fixit)"}, {"location": {"col": 11, "file": 5, "line": 3161}, "message": "the definition seen here"}, {"location": {"col": 23, "file": 4, "line": 325}, "message": "differing parameters are named here: ('multi_handle'), in definition: ('multi')"}, {"location": {"col": 23, "file": 4, "line": 325}, "message": "function 'curl_multi_socket_all' has a definition with different parameter names"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/include/curl/multi.h", "reportHash": "d26a9ba4ff5d3143046d00894f938379", "checkerName": "readability-inconsistent-declaration-parameter-name", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 49, "file": 4, "line": 344}, "message": "multi (fixit)"}, {"location": {"col": 11, "file": 5, "line": 3212}, "message": "the definition seen here"}, {"location": {"col": 23, "file": 4, "line": 344}, "message": "differing parameters are named here: ('multi_handle', 'milliseconds'), in definition: ('multi', 'timeout_ms')"}, {"location": {"col": 23, "file": 4, "line": 344}, "message": "function 'curl_multi_timeout' has a definition with different parameter names"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/include/curl/multi.h", "reportHash": "65ace170a18c71c4f2d3ba19350ada9f", "checkerName": "readability-inconsistent-declaration-parameter-name", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 48, "file": 4, "line": 409}, "message": "multi (fixit)"}, {"location": {"col": 11, "file": 5, "line": 3062}, "message": "the definition seen here"}, {"location": {"col": 23, "file": 4, "line": 409}, "message": "differing parameters are named here: ('multi_handle'), in definition: ('multi')"}, {"location": {"col": 23, "file": 4, "line": 409}, "message": "function 'curl_multi_setopt' has a definition with different parameter names"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/include/curl/multi.h", "reportHash": "7ea7cc0ff29e5c9996da6d4ff1a50f05", "checkerName": "readability-inconsistent-declaration-parameter-name", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 48, "file": 4, "line": 422}, "message": "multi (fixit)"}, {"location": {"col": 11, "file": 5, "line": 3450}, "message": "the definition seen here"}, {"location": {"col": 23, "file": 4, "line": 422}, "message": "differing parameters are named here: ('multi_handle', 'sockfd', 'sockp'), in definition: ('multi', 's', 'hashp')"}, {"location": {"col": 23, "file": 4, "line": 422}, "message": "function 'curl_multi_assign' has a definition with different parameter names"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/include/curl/multi.h", "reportHash": "f70631eefbda61afd582bacc1556f4e3", "checkerName": "readability-inconsistent-declaration-parameter-name", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 10, "file": 5, "line": 27}, "message": "\"conncache.h\" (fixit)"}, {"location": {"col": 1, "file": 5, "line": 27}, "message": "#includes are not sorted properly"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/lib/multi.c", "reportHash": "acb7635a1236a1bfe979ea85ff0c5de4", "checkerName": "llvm-include-order", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 10, "file": 5, "line": 52}, "message": "\"curl_memory.h\" (fixit)"}, {"location": {"col": 1, "file": 5, "line": 52}, "message": "#includes are not sorted properly"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/lib/multi.c", "reportHash": "e89b3bb7272adb784b61519eeb5e6cdf", "checkerName": "llvm-include-order", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 25, "file": 5, "line": 150}, "message": "{ (fixit)"}, {"location": {"col": 24, "file": 5, "line": 150}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/lib/multi.c", "reportHash": "7b331ee9eeb2b11b88a28f6dcfc77712", "checkerName": "google-readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 20, "file": 5, "line": 178}, "message": "{ (fixit)"}, {"location": {"col": 19, "file": 5, "line": 178}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/lib/multi.c", "reportHash": "adb930ffaa153597d65c4240585dba0c", "checkerName": "google-readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 14, "file": 5, "line": 254}, "message": "{ (fixit)"}, {"location": {"col": 13, "file": 5, "line": 254}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/lib/multi.c", "reportHash": "0d01c8a47bafe9feaed4635252250431", "checkerName": "google-readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 14, "file": 5, "line": 353}, "message": "{ (fixit)"}, {"location": {"col": 13, "file": 5, "line": 353}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/lib/multi.c", "reportHash": "1804229d3fad9a74af23ad18ff96d516", "checkerName": "readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 43, "file": 5, "line": 358}, "message": "{ (fixit)"}, {"location": {"col": 42, "file": 5, "line": 358}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/lib/multi.c", "reportHash": "e5abb29be1dcd53a0b90b2399d980d4d", "checkerName": "hicpp-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 43, "file": 5, "line": 361}, "message": "{ (fixit)"}, {"location": {"col": 42, "file": 5, "line": 361}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/lib/multi.c", "reportHash": "d9fcd7d8c5a8a88a3db49e306ea7ea9b", "checkerName": "hicpp-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 58, "file": 5, "line": 364}, "message": "{ (fixit)"}, {"location": {"col": 57, "file": 5, "line": 364}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/lib/multi.c", "reportHash": "bda27f0bafb904746e2e6c26250cbb93", "checkerName": "google-readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 33, "file": 5, "line": 421}, "message": "{ (fixit)"}, {"location": {"col": 32, "file": 5, "line": 421}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/lib/multi.c", "reportHash": "6c15bdf958ad2d42acbfb5309a7f282d", "checkerName": "readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 31, "file": 5, "line": 425}, "message": "{ (fixit)"}, {"location": {"col": 30, "file": 5, "line": 425}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/lib/multi.c", "reportHash": "ab83362e1966ebb8ff5ac8423f022a77", "checkerName": "readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 19, "file": 5, "line": 430}, "message": "{ (fixit)"}, {"location": {"col": 18, "file": 5, "line": 430}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/lib/multi.c", "reportHash": "3b233b27192ae276ca4a956f5ad1890f", "checkerName": "readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 26, "file": 5, "line": 433}, "message": "{ (fixit)"}, {"location": {"col": 25, "file": 5, "line": 433}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/lib/multi.c", "reportHash": "1ab45975c90eb0e06b9fa9a9903b132a", "checkerName": "hicpp-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 29, "file": 5, "line": 445}, "message": "{ (fixit)"}, {"location": {"col": 28, "file": 5, "line": 445}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/lib/multi.c", "reportHash": "cb92ab39faf6cf126ed058f15fbf8ea4", "checkerName": "hicpp-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 22, "file": 5, "line": 460}, "message": "use of a signed integer operand with a binary bitwise operator"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/lib/multi.c", "reportHash": "a9483b8515293704272289a7aef8ef15", "checkerName": "hicpp-signed-bitwise", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 48, "file": 5, "line": 460}, "message": "use of a signed integer operand with a binary bitwise operator"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/lib/multi.c", "reportHash": "3a333b054f6ef96b63bfa6bfec7117df", "checkerName": "hicpp-signed-bitwise", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 78, "file": 5, "line": 460}, "message": "{ (fixit)"}, {"location": {"col": 77, "file": 5, "line": 460}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/lib/multi.c", "reportHash": "fb630e03416ae402bd41f5e951c867c9", "checkerName": "hicpp-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 8, "file": 5, "line": 462}, "message": "{ (fixit)"}, {"location": {"col": 7, "file": 5, "line": 462}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/lib/multi.c", "reportHash": "faf62e1ed1bd7fe5129b2d61c6850f7c", "checkerName": "google-readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 24, "file": 5, "line": 560}, "message": "{ (fixit)"}, {"location": {"col": 23, "file": 5, "line": 560}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/lib/multi.c", "reportHash": "6afeb47d942aad2b89627795cf15d95f", "checkerName": "readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 27, "file": 5, "line": 587}, "message": "{ (fixit)"}, {"location": {"col": 26, "file": 5, "line": 587}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/lib/multi.c", "reportHash": "5c95736866c2d0e25aaa16040a24ce93", "checkerName": "hicpp-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 8, "file": 5, "line": 589}, "message": "{ (fixit)"}, {"location": {"col": 7, "file": 5, "line": 589}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/lib/multi.c", "reportHash": "faf62e1ed1bd7fe5129b2d61c6850f7c", "checkerName": "google-readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 23, "file": 5, "line": 596}, "message": "{ (fixit)"}, {"location": {"col": 22, "file": 5, "line": 596}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/lib/multi.c", "reportHash": "dab6c45a2677ed4b5c6db9892747cd77", "checkerName": "readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 27, "file": 5, "line": 657}, "message": "use of a signed integer operand with a binary bitwise operator"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/lib/multi.c", "reportHash": "a73c2a714413c3d974121d099da8295d", "checkerName": "hicpp-signed-bitwise", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 25, "file": 38, "line": 764}, "message": "expanded from macro 'PROTOPT_STREAM'"}, {"location": {"col": 50, "file": 5, "line": 657}, "message": "use of a signed integer operand with a binary bitwise operator"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/lib/multi.c", "reportHash": "ef3c64da66aec39b38a9dcbc7b767efd", "checkerName": "hicpp-signed-bitwise", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 25, "file": 5, "line": 666}, "message": "{ (fixit)"}, {"location": {"col": 24, "file": 5, "line": 666}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/lib/multi.c", "reportHash": "5886a94d898302aa68923b8ed25ac50a", "checkerName": "readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 10, "file": 5, "line": 690}, "message": "{ (fixit)"}, {"location": {"col": 9, "file": 5, "line": 690}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/lib/multi.c", "reportHash": "b3a440724c87d3ff77df05c7e913bdf4", "checkerName": "readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 57, "file": 5, "line": 703}, "message": "{ (fixit)"}, {"location": {"col": 56, "file": 5, "line": 703}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/lib/multi.c", "reportHash": "4ba3ab4aaf65c51a189b11f99c005229", "checkerName": "readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 26, "file": 5, "line": 706}, "message": "{ (fixit)"}, {"location": {"col": 25, "file": 5, "line": 706}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/lib/multi.c", "reportHash": "dc1327394a8f131d3d62dd2870c01f0b", "checkerName": "readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 32, "file": 5, "line": 710}, "message": "{ (fixit)"}, {"location": {"col": 31, "file": 5, "line": 710}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/lib/multi.c", "reportHash": "316e150f888ffa175902ae489a081aff", "checkerName": "readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 33, "file": 5, "line": 728}, "message": "{ (fixit)"}, {"location": {"col": 32, "file": 5, "line": 728}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/lib/multi.c", "reportHash": "642a73743c0fea23c820c279f8148dbc", "checkerName": "hicpp-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 31, "file": 5, "line": 732}, "message": "{ (fixit)"}, {"location": {"col": 30, "file": 5, "line": 732}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/lib/multi.c", "reportHash": "ab83362e1966ebb8ff5ac8423f022a77", "checkerName": "readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 20, "file": 5, "line": 736}, "message": "{ (fixit)"}, {"location": {"col": 19, "file": 5, "line": 736}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/lib/multi.c", "reportHash": "ec8cec516139a433119b01b2ea9890f5", "checkerName": "hicpp-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 28, "file": 5, "line": 740}, "message": "{ (fixit)"}, {"location": {"col": 27, "file": 5, "line": 740}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/lib/multi.c", "reportHash": "4b9ea2f2c68a78167f076b051a9ee469", "checkerName": "hicpp-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 26, "file": 5, "line": 743}, "message": "{ (fixit)"}, {"location": {"col": 25, "file": 5, "line": 743}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/lib/multi.c", "reportHash": "040b1c39e6e80eef64e4736d5ef43cc8", "checkerName": "google-readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 31, "file": 5, "line": 788}, "message": "{ (fixit)"}, {"location": {"col": 30, "file": 5, "line": 788}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/lib/multi.c", "reportHash": "1967677d28fb12a5358267d64e784f61", "checkerName": "readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 18, "file": 5, "line": 847}, "message": "{ (fixit)"}, {"location": {"col": 17, "file": 5, "line": 847}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/lib/multi.c", "reportHash": "41c0c83e3fe83d96c3f63a9caefd2d01", "checkerName": "hicpp-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 8, "file": 5, "line": 849}, "message": "{ (fixit)"}, {"location": {"col": 7, "file": 5, "line": 849}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/lib/multi.c", "reportHash": "faf62e1ed1bd7fe5129b2d61c6850f7c", "checkerName": "google-readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 18, "file": 5, "line": 853}, "message": "{ (fixit)"}, {"location": {"col": 17, "file": 5, "line": 853}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/lib/multi.c", "reportHash": "74f74244d83b738a83aaf52b6bcd9727", "checkerName": "hicpp-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 8, "file": 5, "line": 855}, "message": "{ (fixit)"}, {"location": {"col": 7, "file": 5, "line": 855}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/lib/multi.c", "reportHash": "faf62e1ed1bd7fe5129b2d61c6850f7c", "checkerName": "google-readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 12, "file": 5, "line": 881}, "message": "{ (fixit)"}, {"location": {"col": 11, "file": 5, "line": 881}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/lib/multi.c", "reportHash": "f7a4a5af1875c5dce3f8beac8530e037", "checkerName": "hicpp-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 39, "file": 5, "line": 910}, "message": "{ (fixit)"}, {"location": {"col": 38, "file": 5, "line": 910}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/lib/multi.c", "reportHash": "9ca11c49d43b1787739515ff9cf6c93a", "checkerName": "google-readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 38, "file": 5, "line": 915}, "message": "{ (fixit)"}, {"location": {"col": 37, "file": 5, "line": 915}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/lib/multi.c", "reportHash": "3af0443c10b4237931deceb4fd0b1ab8", "checkerName": "google-readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 31, "file": 39, "line": 52}, "message": "expanded from macro 'GETSOCK_WRITESOCK'"}, {"location": {"col": 13, "file": 5, "line": 921}, "message": "use of a signed integer operand with a binary bitwise operator"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/lib/multi.c", "reportHash": "ec6b39dd0020389c9629e05c428159f5", "checkerName": "hicpp-signed-bitwise", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 27, "file": 5, "line": 941}, "message": "{ (fixit)"}, {"location": {"col": 26, "file": 5, "line": 941}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/lib/multi.c", "reportHash": "a700a499041c2b7bd46006c153cb8ffb", "checkerName": "readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 30, "file": 39, "line": 55}, "message": "expanded from macro 'GETSOCK_READSOCK'"}, {"location": {"col": 12, "file": 5, "line": 942}, "message": "use of a signed integer operand with a binary bitwise operator"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/lib/multi.c", "reportHash": "adec67d1701f1275d2c7066877a8a4ae", "checkerName": "hicpp-signed-bitwise", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 31, "file": 39, "line": 52}, "message": "expanded from macro 'GETSOCK_WRITESOCK'"}, {"location": {"col": 10, "file": 5, "line": 944}, "message": "use of a signed integer operand with a binary bitwise operator"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/lib/multi.c", "reportHash": "b75e5d15c364a91b38ca329a6ae7ff2a", "checkerName": "hicpp-signed-bitwise", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 45, "file": 5, "line": 950}, "message": "{ (fixit)"}, {"location": {"col": 44, "file": 5, "line": 950}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/lib/multi.c", "reportHash": "9dca72d2ca361af9dcb433a9a8c7de81", "checkerName": "google-readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 44, "file": 5, "line": 958}, "message": "{ (fixit)"}, {"location": {"col": 43, "file": 5, "line": 958}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/lib/multi.c", "reportHash": "147ccc51c71ac0581b9f2c9cab38483d", "checkerName": "readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 36, "file": 5, "line": 966}, "message": "{ (fixit)"}, {"location": {"col": 35, "file": 5, "line": 966}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/lib/multi.c", "reportHash": "224b5b5de8b7184d1b32b66a5abdb535", "checkerName": "readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 30, "file": 39, "line": 55}, "message": "expanded from macro 'GETSOCK_READSOCK'"}, {"location": {"col": 10, "file": 5, "line": 972}, "message": "use of a signed integer operand with a binary bitwise operator"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/lib/multi.c", "reportHash": "d7995f6d089abf0a5a8f2cbf753992c3", "checkerName": "hicpp-signed-bitwise", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 31, "file": 39, "line": 52}, "message": "expanded from macro 'GETSOCK_WRITESOCK'"}, {"location": {"col": 32, "file": 5, "line": 972}, "message": "use of a signed integer operand with a binary bitwise operator"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/lib/multi.c", "reportHash": "67486def66395429b48135d4e3f6663d", "checkerName": "hicpp-signed-bitwise", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 19, "file": 5, "line": 983}, "message": "{ (fixit)"}, {"location": {"col": 18, "file": 5, "line": 983}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/lib/multi.c", "reportHash": "f82480621e93b78acd903dbeef8bbea4", "checkerName": "google-readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 33, "file": 5, "line": 1038}, "message": "{ (fixit)"}, {"location": {"col": 32, "file": 5, "line": 1038}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/lib/multi.c", "reportHash": "6c15bdf958ad2d42acbfb5309a7f282d", "checkerName": "readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 26, "file": 5, "line": 1041}, "message": "{ (fixit)"}, {"location": {"col": 25, "file": 5, "line": 1041}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/lib/multi.c", "reportHash": "1b45fec20291d1e3a63a55743b1761c9", "checkerName": "readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 11, "file": 5, "line": 1051}, "message": "use of a signed integer operand with a binary bitwise operator"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/lib/multi.c", "reportHash": "189c0776fbf9698a27a4e6846193e0a4", "checkerName": "hicpp-signed-bitwise", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 30, "file": 39, "line": 55}, "message": "expanded from macro 'GETSOCK_READSOCK'"}, {"location": {"col": 20, "file": 5, "line": 1051}, "message": "use of a signed integer operand with a binary bitwise operator"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/lib/multi.c", "reportHash": "61aaff5132fa895dc02e01e5c98739af", "checkerName": "hicpp-signed-bitwise", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 28, "file": 40, "line": 85}, "message": "expanded from macro 'FD_SET'"}, {"location": {"col": 46, "file": 41, "line": 59}, "message": "expanded from macro '__FD_SET'"}, {"location": {"col": 36, "file": 40, "line": 56}, "message": "expanded from macro '__FD_MASK'"}, {"location": {"col": 9, "file": 5, "line": 1052}, "message": "use of a signed integer operand with a binary bitwise operator"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/lib/multi.c", "reportHash": "8de369645f7f5445ebe5882bdf9f62fd", "checkerName": "hicpp-signed-bitwise", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 11, "file": 5, "line": 1055}, "message": "use of a signed integer operand with a binary bitwise operator"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/lib/multi.c", "reportHash": "67e52591af8d98fb51f238875acf0a73", "checkerName": "hicpp-signed-bitwise", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 31, "file": 39, "line": 52}, "message": "expanded from macro 'GETSOCK_WRITESOCK'"}, {"location": {"col": 20, "file": 5, "line": 1055}, "message": "use of a signed integer operand with a binary bitwise operator"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/lib/multi.c", "reportHash": "291677a48e30680bce0856ffda4edaff", "checkerName": "hicpp-signed-bitwise", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 28, "file": 40, "line": 85}, "message": "expanded from macro 'FD_SET'"}, {"location": {"col": 46, "file": 41, "line": 59}, "message": "expanded from macro '__FD_SET'"}, {"location": {"col": 36, "file": 40, "line": 56}, "message": "expanded from macro '__FD_MASK'"}, {"location": {"col": 9, "file": 5, "line": 1056}, "message": "use of a signed integer operand with a binary bitwise operator"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/lib/multi.c", "reportHash": "1f02426d9e32f8217e3a6b0e0b090f44", "checkerName": "hicpp-signed-bitwise", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 32, "file": 5, "line": 1059}, "message": "{ (fixit)"}, {"location": {"col": 31, "file": 5, "line": 1059}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/lib/multi.c", "reportHash": "367ad76df5d2744a9d1b06b93c95c58d", "checkerName": "google-readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 32, "file": 5, "line": 1062}, "message": "{ (fixit)"}, {"location": {"col": 31, "file": 5, "line": 1062}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/lib/multi.c", "reportHash": "0bb0be113189c6a25f2c2101eb3c7b31", "checkerName": "readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 33, "file": 5, "line": 1101}, "message": "{ (fixit)"}, {"location": {"col": 32, "file": 5, "line": 1101}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/lib/multi.c", "reportHash": "6c15bdf958ad2d42acbfb5309a7f282d", "checkerName": "readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 26, "file": 5, "line": 1104}, "message": "{ (fixit)"}, {"location": {"col": 25, "file": 5, "line": 1104}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/lib/multi.c", "reportHash": "040b1c39e6e80eef64e4736d5ef43cc8", "checkerName": "google-readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 22, "file": 5, "line": 1107}, "message": "{ (fixit)"}, {"location": {"col": 21, "file": 5, "line": 1107}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/lib/multi.c", "reportHash": "2b968cd1880ecd9e25a61d7a0a2612bc", "checkerName": "google-readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 10, "file": 5, "line": 1118}, "message": "use of a signed integer operand with a binary bitwise operator"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/lib/multi.c", "reportHash": "7754874ebe8d6f50c69fb707cbfb97f8", "checkerName": "hicpp-signed-bitwise", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 30, "file": 39, "line": 55}, "message": "expanded from macro 'GETSOCK_READSOCK'"}, {"location": {"col": 19, "file": 5, "line": 1118}, "message": "use of a signed integer operand with a binary bitwise operator"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/lib/multi.c", "reportHash": "cbc25b10d71dd1aacc144393fc65a094", "checkerName": "hicpp-signed-bitwise", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 10, "file": 5, "line": 1122}, "message": "use of a signed integer operand with a binary bitwise operator"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/lib/multi.c", "reportHash": "3688b16dfbb4a1adebf56a25c1b3770e", "checkerName": "hicpp-signed-bitwise", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 31, "file": 39, "line": 52}, "message": "expanded from macro 'GETSOCK_WRITESOCK'"}, {"location": {"col": 19, "file": 5, "line": 1122}, "message": "use of a signed integer operand with a binary bitwise operator"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/lib/multi.c", "reportHash": "bf3bcd1df23673350719772443fb36a1", "checkerName": "hicpp-signed-bitwise", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 72, "file": 5, "line": 1138}, "message": "{ (fixit)"}, {"location": {"col": 71, "file": 5, "line": 1138}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/lib/multi.c", "reportHash": "1db0a00c27d1bcc288c8c77a1269fa17", "checkerName": "google-readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 15, "file": 5, "line": 1161}, "message": "{ (fixit)"}, {"location": {"col": 14, "file": 5, "line": 1161}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/lib/multi.c", "reportHash": "d2ddf91b5cfb9d2dfd1c69957f6dfe08", "checkerName": "readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 12, "file": 5, "line": 1183}, "message": "use of a signed integer operand with a binary bitwise operator"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/lib/multi.c", "reportHash": "909d33076a773f160ce16d947f5f0dca", "checkerName": "hicpp-signed-bitwise", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 30, "file": 39, "line": 55}, "message": "expanded from macro 'GETSOCK_READSOCK'"}, {"location": {"col": 21, "file": 5, "line": 1183}, "message": "use of a signed integer operand with a binary bitwise operator"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/lib/multi.c", "reportHash": "25292cd85461c25c7218954005fc1b2d", "checkerName": "hicpp-signed-bitwise", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 12, "file": 5, "line": 1195}, "message": "use of a signed integer operand with a binary bitwise operator"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/lib/multi.c", "reportHash": "9c4b12f6cf2d865dfecd33750e74da81", "checkerName": "hicpp-signed-bitwise", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 31, "file": 39, "line": 52}, "message": "expanded from macro 'GETSOCK_WRITESOCK'"}, {"location": {"col": 21, "file": 5, "line": 1195}, "message": "use of a signed integer operand with a binary bitwise operator"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/lib/multi.c", "reportHash": "eed26353b4f2202fa3b0688c9cf38bbe", "checkerName": "hicpp-signed-bitwise", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 8, "file": 5, "line": 1255}, "message": "use of a signed integer operand with a binary bitwise operator"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/lib/multi.c", "reportHash": "ca5e01db139fb4bb1b01b4508fb91e1a", "checkerName": "hicpp-signed-bitwise", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 48, "file": 5, "line": 1255}, "message": "{ (fixit)"}, {"location": {"col": 47, "file": 5, "line": 1255}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/lib/multi.c", "reportHash": "b048232f75fa1bb75cfe0ade9c9552dd", "checkerName": "readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 8, "file": 5, "line": 1257}, "message": "use of a signed integer operand with a binary bitwise operator"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/lib/multi.c", "reportHash": "523e45d8c80655c361d4007ea46bb404", "checkerName": "hicpp-signed-bitwise", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 49, "file": 5, "line": 1257}, "message": "{ (fixit)"}, {"location": {"col": 48, "file": 5, "line": 1257}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/lib/multi.c", "reportHash": "02af0f3b7c11ff06397ed04a9b532370", "checkerName": "readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 8, "file": 5, "line": 1259}, "message": "use of a signed integer operand with a binary bitwise operator"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/lib/multi.c", "reportHash": "f3f2a5274a28b689d2662148293186b8", "checkerName": "hicpp-signed-bitwise", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 49, "file": 5, "line": 1259}, "message": "{ (fixit)"}, {"location": {"col": 48, "file": 5, "line": 1259}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/lib/multi.c", "reportHash": "3b0ee5fe57e19a92664e91041ff0584f", "checkerName": "readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 12, "file": 5, "line": 1316}, "message": "use of a signed integer operand with a binary bitwise operator"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/lib/multi.c", "reportHash": "9cc2131517637d3502c73b51028fc403", "checkerName": "hicpp-signed-bitwise", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 24, "file": 5, "line": 1316}, "message": "{ (fixit)"}, {"location": {"col": 23, "file": 5, "line": 1316}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/lib/multi.c", "reportHash": "99c0048349e17920baafcd6cb4dcab7b", "checkerName": "google-readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 12, "file": 5, "line": 1318}, "message": "use of a signed integer operand with a binary bitwise operator"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/lib/multi.c", "reportHash": "40c6d17ac49adda25d687272fe4906a2", "checkerName": "hicpp-signed-bitwise", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 25, "file": 5, "line": 1318}, "message": "{ (fixit)"}, {"location": {"col": 24, "file": 5, "line": 1318}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/lib/multi.c", "reportHash": "21dc1220822e98c66c72407dff37cdda", "checkerName": "readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 12, "file": 5, "line": 1320}, "message": "use of a signed integer operand with a binary bitwise operator"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/lib/multi.c", "reportHash": "bbffa277c9ae19ae38b02983a69556d0", "checkerName": "hicpp-signed-bitwise", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 25, "file": 5, "line": 1320}, "message": "{ (fixit)"}, {"location": {"col": 24, "file": 5, "line": 1320}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/lib/multi.c", "reportHash": "faf4c93e37b338ad7b0e4cc786120f82", "checkerName": "readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 12, "file": 5, "line": 1365}, "message": "use of a signed integer operand with a binary bitwise operator"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/lib/multi.c", "reportHash": "1f1c8fa360811e4b7061688bce7cc9e1", "checkerName": "hicpp-signed-bitwise", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 51, "file": 5, "line": 1375}, "message": "{ (fixit)"}, {"location": {"col": 50, "file": 5, "line": 1375}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/lib/multi.c", "reportHash": "09fdd9bfcbe018b388d4221c35eb6019", "checkerName": "readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 19, "file": 5, "line": 1390}, "message": "{ (fixit)"}, {"location": {"col": 18, "file": 5, "line": 1390}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/lib/multi.c", "reportHash": "e17026711c64d99a94128c95be8c2f24", "checkerName": "hicpp-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 11, "file": 5, "line": 1393}, "message": "{ (fixit)"}, {"location": {"col": 10, "file": 5, "line": 1393}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/lib/multi.c", "reportHash": "cf15dcc11820576c68fb5195f1cc43b1", "checkerName": "google-readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 26, "file": 5, "line": 1395}, "message": "{ (fixit)"}, {"location": {"col": 25, "file": 5, "line": 1395}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/lib/multi.c", "reportHash": "a34760ca524274dc439270dee2157519", "checkerName": "hicpp-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 33, "file": 5, "line": 1403}, "message": "{ (fixit)"}, {"location": {"col": 32, "file": 5, "line": 1403}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/lib/multi.c", "reportHash": "a8d88d4d9df93d716e9f8c01b4a5b1fe", "checkerName": "readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 29, "file": 5, "line": 1407}, "message": "{ (fixit)"}, {"location": {"col": 28, "file": 5, "line": 1407}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/lib/multi.c", "reportHash": "65b11d7e672413bbd322841fa7b6f3c3", "checkerName": "google-readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 33, "file": 5, "line": 1443}, "message": "{ (fixit)"}, {"location": {"col": 32, "file": 5, "line": 1443}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/lib/multi.c", "reportHash": "6c15bdf958ad2d42acbfb5309a7f282d", "checkerName": "readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 26, "file": 5, "line": 1473}, "message": "{ (fixit)"}, {"location": {"col": 25, "file": 5, "line": 1473}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/lib/multi.c", "reportHash": "10981f9be7e4b7e15c108907e55d7a27", "checkerName": "readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 29, "file": 5, "line": 1477}, "message": "{ (fixit)"}, {"location": {"col": 28, "file": 5, "line": 1477}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/lib/multi.c", "reportHash": "91a889efe1f526ec50a63e744504e264", "checkerName": "readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 13, "file": 5, "line": 1499}, "message": "{ (fixit)"}, {"location": {"col": 12, "file": 5, "line": 1499}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/lib/multi.c", "reportHash": "71f7c6f574166dd74a2e1945c2eb5a04", "checkerName": "readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 26, "file": 5, "line": 1510}, "message": "{ (fixit)"}, {"location": {"col": 25, "file": 5, "line": 1510}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/lib/multi.c", "reportHash": "1b45fec20291d1e3a63a55743b1761c9", "checkerName": "readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 21, "file": 38, "line": 508}, "message": "expanded from macro 'KEEP_RECV'"}, {"location": {"col": 18, "file": 5, "line": 1524}, "message": "use of a signed integer operand with a binary bitwise operator"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/lib/multi.c", "reportHash": "653bdd4682227847a7dc901a6ba56cbf", "checkerName": "hicpp-signed-bitwise", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 26, "file": 5, "line": 1554}, "message": "{ (fixit)"}, {"location": {"col": 25, "file": 5, "line": 1554}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/lib/multi.c", "reportHash": "4583cb72e8b874076d659a0d304d4ec6", "checkerName": "readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 30, "file": 5, "line": 1576}, "message": "{ (fixit)"}, {"location": {"col": 29, "file": 5, "line": 1576}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/lib/multi.c", "reportHash": "9fef3e156aab3513e1d63f9eb2bf2008", "checkerName": "hicpp-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 35, "file": 5, "line": 1579}, "message": "{ (fixit)"}, {"location": {"col": 34, "file": 5, "line": 1579}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/lib/multi.c", "reportHash": "0b533ebcd3ad4227d85f145970b27c9e", "checkerName": "readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 8, "file": 5, "line": 1601}, "message": "{ (fixit)"}, {"location": {"col": 7, "file": 5, "line": 1601}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/lib/multi.c", "reportHash": "0357fe533c029f55987117a0f2206d41", "checkerName": "readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 8, "file": 5, "line": 1620}, "message": "{ (fixit)"}, {"location": {"col": 7, "file": 5, "line": 1620}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/lib/multi.c", "reportHash": "faf62e1ed1bd7fe5129b2d61c6850f7c", "checkerName": "google-readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 36, "file": 5, "line": 1648}, "message": "{ (fixit)"}, {"location": {"col": 35, "file": 5, "line": 1648}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/lib/multi.c", "reportHash": "aee833348a09b60a33c51359c6a4faa3", "checkerName": "google-readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 16, "file": 5, "line": 1657}, "message": "{ (fixit)"}, {"location": {"col": 15, "file": 5, "line": 1657}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/lib/multi.c", "reportHash": "c39a44f00d8d28422fd1be76d801da58", "checkerName": "google-readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 41, "file": 5, "line": 1660}, "message": "{ (fixit)"}, {"location": {"col": 40, "file": 5, "line": 1660}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/lib/multi.c", "reportHash": "09096976692e4f5235808137ccf04895", "checkerName": "readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 36, "file": 5, "line": 1665}, "message": "{ (fixit)"}, {"location": {"col": 35, "file": 5, "line": 1665}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/lib/multi.c", "reportHash": "6f46e0727b9460b1f3d6a6f89e2296ec", "checkerName": "google-readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 10, "file": 5, "line": 1676}, "message": "{ (fixit)"}, {"location": {"col": 9, "file": 5, "line": 1676}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/lib/multi.c", "reportHash": "dd24d789d9216ee4057afddeb848a08b", "checkerName": "google-readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 17, "file": 5, "line": 1681}, "message": "{ (fixit)"}, {"location": {"col": 16, "file": 5, "line": 1681}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/lib/multi.c", "reportHash": "69871b171a7a7bb6dd7a92d131e4ebe8", "checkerName": "google-readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 29, "file": 5, "line": 1697}, "message": "{ (fixit)"}, {"location": {"col": 28, "file": 5, "line": 1697}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/lib/multi.c", "reportHash": "74b8dc2e0ce278a2ef78a69a0af34a1e", "checkerName": "google-readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 31, "file": 5, "line": 1721}, "message": "{ (fixit)"}, {"location": {"col": 30, "file": 5, "line": 1721}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/lib/multi.c", "reportHash": "e5c94a8fc7ee4c48eab6681ff0c38fd5", "checkerName": "google-readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 53, "file": 5, "line": 1752}, "message": "{ (fixit)"}, {"location": {"col": 52, "file": 5, "line": 1752}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/lib/multi.c", "reportHash": "d25ec2d9c0d8a42e8a1dda28e50c9a9c", "checkerName": "google-readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 58, "file": 5, "line": 1756}, "message": "{ (fixit)"}, {"location": {"col": 57, "file": 5, "line": 1756}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/lib/multi.c", "reportHash": "a4f129d0f3f1c9cfd1f5a72717e4421c", "checkerName": "readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 18, "file": 5, "line": 1812}, "message": "{ (fixit)"}, {"location": {"col": 17, "file": 5, "line": 1812}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/lib/multi.c", "reportHash": "ef65b0f000a9a8fb52a04e83ff4274bf", "checkerName": "google-readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 29, "file": 5, "line": 1816}, "message": "{ (fixit)"}, {"location": {"col": 28, "file": 5, "line": 1816}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/lib/multi.c", "reportHash": "ea2fec0e72af7962bbfa972ff43a950d", "checkerName": "google-readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 36, "file": 5, "line": 1819}, "message": "{ (fixit)"}, {"location": {"col": 35, "file": 5, "line": 1819}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/lib/multi.c", "reportHash": "783e889c047e05cb251969efa3934007", "checkerName": "readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 7, "file": 5, "line": 1834}, "message": "do not use 'else' after 'break'"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/lib/multi.c", "reportHash": "708e99f6a131ec5cf6699f0c41ff9912", "checkerName": "readability-else-after-return", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 19, "file": 5, "line": 1841}, "message": "{ (fixit)"}, {"location": {"col": 18, "file": 5, "line": 1841}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/lib/multi.c", "reportHash": "aa23af180df9278a0d62b93076e17d0a", "checkerName": "google-readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 34, "file": 5, "line": 1850}, "message": "{ (fixit)"}, {"location": {"col": 33, "file": 5, "line": 1850}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/lib/multi.c", "reportHash": "cb9a4682cfb851c7e985d15e02d53534", "checkerName": "google-readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 50, "file": 5, "line": 1854}, "message": "{ (fixit)"}, {"location": {"col": 49, "file": 5, "line": 1854}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/lib/multi.c", "reportHash": "0f17382cf31419513020ec203e706b40", "checkerName": "hicpp-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 18, "file": 5, "line": 1856}, "message": "{ (fixit)"}, {"location": {"col": 17, "file": 5, "line": 1856}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/lib/multi.c", "reportHash": "b85dbbe5599278b87c55b87c82d8954f", "checkerName": "google-readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 32, "file": 5, "line": 1873}, "message": "{ (fixit)"}, {"location": {"col": 31, "file": 5, "line": 1873}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/lib/multi.c", "reportHash": "cfdbcb0035ad3cfebd11c7648b8ff603", "checkerName": "hicpp-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 37, "file": 5, "line": 1877}, "message": "{ (fixit)"}, {"location": {"col": 36, "file": 5, "line": 1877}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/lib/multi.c", "reportHash": "e1082e34cca946b864467d1e11064c10", "checkerName": "google-readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 7, "file": 5, "line": 1879}, "message": "different indentation for 'if' and corresponding 'else'"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/lib/multi.c", "reportHash": "8071679b1409bfa60684b5a97b2f86ad", "checkerName": "readability-misleading-indentation", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 12, "file": 5, "line": 1879}, "message": "{ (fixit)"}, {"location": {"col": 11, "file": 5, "line": 1879}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/lib/multi.c", "reportHash": "635809d2ffbd02b7d483c54dfe7a50ec", "checkerName": "google-readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 16, "file": 5, "line": 1894}, "message": "{ (fixit)"}, {"location": {"col": 15, "file": 5, "line": 1894}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/lib/multi.c", "reportHash": "b36f7a1d2683ef3520cf5026b658b513", "checkerName": "google-readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 20, "file": 5, "line": 1910}, "message": "{ (fixit)"}, {"location": {"col": 19, "file": 5, "line": 1910}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/lib/multi.c", "reportHash": "f4e7999a960f3fd5ff5af2e34a46c127", "checkerName": "google-readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 34, "file": 5, "line": 1917}, "message": "{ (fixit)"}, {"location": {"col": 33, "file": 5, "line": 1917}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/lib/multi.c", "reportHash": "cb9a4682cfb851c7e985d15e02d53534", "checkerName": "google-readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 50, "file": 5, "line": 1921}, "message": "{ (fixit)"}, {"location": {"col": 49, "file": 5, "line": 1921}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/lib/multi.c", "reportHash": "1c90d1d4cba956058ceff427c03aa495", "checkerName": "readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 18, "file": 5, "line": 1923}, "message": "{ (fixit)"}, {"location": {"col": 17, "file": 5, "line": 1923}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/lib/multi.c", "reportHash": "62ef9bf617fa571eb8531e085c43db08", "checkerName": "readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 7, "file": 5, "line": 1965}, "message": "different indentation for 'if' and corresponding 'else'"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/lib/multi.c", "reportHash": "8071679b1409bfa60684b5a97b2f86ad", "checkerName": "readability-misleading-indentation", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 12, "file": 5, "line": 1965}, "message": "{ (fixit)"}, {"location": {"col": 11, "file": 5, "line": 1965}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/lib/multi.c", "reportHash": "5365987332e140507434b0a9d94ccac2", "checkerName": "readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 42, "file": 5, "line": 2007}, "message": "{ (fixit)"}, {"location": {"col": 41, "file": 5, "line": 2007}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/lib/multi.c", "reportHash": "b9acfc0bcab383570affb84ef42e2a4a", "checkerName": "google-readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 26, "file": 5, "line": 2138}, "message": "{ (fixit)"}, {"location": {"col": 25, "file": 5, "line": 2138}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/lib/multi.c", "reportHash": "f3a47e798855b27ac53d63df754ae21c", "checkerName": "readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 14, "file": 5, "line": 2182}, "message": "{ (fixit)"}, {"location": {"col": 13, "file": 5, "line": 2182}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/lib/multi.c", "reportHash": "e60fd14e73ead22cf1ccf4777756ae3e", "checkerName": "google-readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 38, "file": 5, "line": 2196}, "message": "{ (fixit)"}, {"location": {"col": 37, "file": 5, "line": 2196}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/lib/multi.c", "reportHash": "4ed8aa60662e33eddb67766c7bf9b689", "checkerName": "hicpp-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 56, "file": 5, "line": 2203}, "message": "{ (fixit)"}, {"location": {"col": 55, "file": 5, "line": 2203}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/lib/multi.c", "reportHash": "7baa89b167b021df6c51bc1c593c6579", "checkerName": "readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 14, "file": 5, "line": 2208}, "message": "use of a signed integer operand with a binary bitwise operator"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/lib/multi.c", "reportHash": "cfa4e760c55b09c38e5f7042bc8008d2", "checkerName": "hicpp-signed-bitwise", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 27, "file": 38, "line": 770}, "message": "expanded from macro 'PROTOPT_WILDCARD'"}, {"location": {"col": 43, "file": 5, "line": 2208}, "message": "use of a signed integer operand with a binary bitwise operator"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/lib/multi.c", "reportHash": "944a709cdf9d543b923619147a5043c9", "checkerName": "hicpp-signed-bitwise", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 39, "file": 5, "line": 2220}, "message": "{ (fixit)"}, {"location": {"col": 38, "file": 5, "line": 2220}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/lib/multi.c", "reportHash": "d05cc864a6ec8c7ba4828a32e37ba6b7", "checkerName": "google-readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 12, "file": 5, "line": 2222}, "message": "{ (fixit)"}, {"location": {"col": 11, "file": 5, "line": 2222}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/lib/multi.c", "reportHash": "635809d2ffbd02b7d483c54dfe7a50ec", "checkerName": "google-readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 42, "file": 5, "line": 2227}, "message": "{ (fixit)"}, {"location": {"col": 41, "file": 5, "line": 2227}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/lib/multi.c", "reportHash": "8178a14ba4b07a516ca6f310f49d7338", "checkerName": "google-readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 42, "file": 5, "line": 2236}, "message": "{ (fixit)"}, {"location": {"col": 41, "file": 5, "line": 2236}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/lib/multi.c", "reportHash": "019c7bfa6dc38a22c3e3e4f222868a07", "checkerName": "readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 53, "file": 5, "line": 2248}, "message": "{ (fixit)"}, {"location": {"col": 52, "file": 5, "line": 2248}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/lib/multi.c", "reportHash": "990fe5ac109c11e5f3c27976ec9e520d", "checkerName": "google-readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 14, "file": 5, "line": 2250}, "message": "{ (fixit)"}, {"location": {"col": 13, "file": 5, "line": 2250}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/lib/multi.c", "reportHash": "e60fd14e73ead22cf1ccf4777756ae3e", "checkerName": "google-readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 40, "file": 5, "line": 2263}, "message": "{ (fixit)"}, {"location": {"col": 39, "file": 5, "line": 2263}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/lib/multi.c", "reportHash": "ca200a914f988ac800c56fa7c8226b9e", "checkerName": "hicpp-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 40, "file": 5, "line": 2272}, "message": "{ (fixit)"}, {"location": {"col": 39, "file": 5, "line": 2272}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/lib/multi.c", "reportHash": "d63f98f965a3f7cf9324a2b812408763", "checkerName": "google-readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 48, "file": 5, "line": 2282}, "message": "{ (fixit)"}, {"location": {"col": 47, "file": 5, "line": 2282}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/lib/multi.c", "reportHash": "aea3ed2d5d59e015f54f886591486d3a", "checkerName": "google-readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 14, "file": 5, "line": 2284}, "message": "{ (fixit)"}, {"location": {"col": 13, "file": 5, "line": 2284}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/lib/multi.c", "reportHash": "efa1565f847e61e2b0a79e5f04ea2e12", "checkerName": "hicpp-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 18, "file": 5, "line": 2298}, "message": "{ (fixit)"}, {"location": {"col": 17, "file": 5, "line": 2298}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/lib/multi.c", "reportHash": "f26f3194a416512d06ea5af2d0de2eb0", "checkerName": "readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 26, "file": 5, "line": 2300}, "message": "{ (fixit)"}, {"location": {"col": 25, "file": 5, "line": 2300}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/lib/multi.c", "reportHash": "250c8998127ed7cd84f3730f3751c1c6", "checkerName": "readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 23, "file": 5, "line": 2319}, "message": "{ (fixit)"}, {"location": {"col": 22, "file": 5, "line": 2319}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/lib/multi.c", "reportHash": "2ffb7f851babca63cc60f04a2e6ca912", "checkerName": "readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 14, "file": 5, "line": 2328}, "message": "{ (fixit)"}, {"location": {"col": 13, "file": 5, "line": 2328}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/lib/multi.c", "reportHash": "e60fd14e73ead22cf1ccf4777756ae3e", "checkerName": "google-readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 14, "file": 5, "line": 2341}, "message": "use of a signed integer operand with a binary bitwise operator"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/lib/multi.c", "reportHash": "17ac6d4c0dd21b342c0cefda44503199", "checkerName": "hicpp-signed-bitwise", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 23, "file": 38, "line": 749}, "message": "expanded from macro 'PROTOPT_DUAL'"}, {"location": {"col": 43, "file": 5, "line": 2341}, "message": "use of a signed integer operand with a binary bitwise operator"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/lib/multi.c", "reportHash": "6e67e60c307a709cf20a5be4408e8373", "checkerName": "hicpp-signed-bitwise", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 42, "file": 5, "line": 2342}, "message": "{ (fixit)"}, {"location": {"col": 41, "file": 5, "line": 2342}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/lib/multi.c", "reportHash": "325fa21538aee0b216382b3eef43bfa6", "checkerName": "readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 16, "file": 5, "line": 2365}, "message": "{ (fixit)"}, {"location": {"col": 15, "file": 5, "line": 2365}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/lib/multi.c", "reportHash": "48bbdc0ffbedd29c78754cdb7531b101", "checkerName": "readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 40, "file": 5, "line": 2416}, "message": "{ (fixit)"}, {"location": {"col": 39, "file": 5, "line": 2416}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/lib/multi.c", "reportHash": "33cfc81164bdc114faec99bea2d68a06", "checkerName": "readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 21, "file": 5, "line": 2424}, "message": "{ (fixit)"}, {"location": {"col": 20, "file": 5, "line": 2424}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/lib/multi.c", "reportHash": "7905b997dbfe63bc725dcc94895c04e3", "checkerName": "readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 33, "file": 5, "line": 2548}, "message": "{ (fixit)"}, {"location": {"col": 32, "file": 5, "line": 2548}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/lib/multi.c", "reportHash": "6c15bdf958ad2d42acbfb5309a7f282d", "checkerName": "readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 26, "file": 5, "line": 2551}, "message": "{ (fixit)"}, {"location": {"col": 25, "file": 5, "line": 2551}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/lib/multi.c", "reportHash": "1ab45975c90eb0e06b9fa9a9903b132a", "checkerName": "hicpp-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 16, "file": 5, "line": 2563}, "message": "{ (fixit)"}, {"location": {"col": 15, "file": 5, "line": 2563}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/lib/multi.c", "reportHash": "c39a44f00d8d28422fd1be76d801da58", "checkerName": "google-readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 11, "file": 5, "line": 2581}, "message": "{ (fixit)"}, {"location": {"col": 10, "file": 5, "line": 2581}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/lib/multi.c", "reportHash": "96d6f61de79abafa819a57367f5a6c5b", "checkerName": "readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 30, "file": 5, "line": 2589}, "message": "{ (fixit)"}, {"location": {"col": 29, "file": 5, "line": 2589}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/lib/multi.c", "reportHash": "24ff275bf092e97bc9a27cb365ef65e8", "checkerName": "readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 28, "file": 5, "line": 2601}, "message": "{ (fixit)"}, {"location": {"col": 27, "file": 5, "line": 2601}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/lib/multi.c", "reportHash": "74461097246daea81588880abac348b4", "checkerName": "google-readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 43, "file": 5, "line": 2610}, "message": "{ (fixit)"}, {"location": {"col": 42, "file": 5, "line": 2610}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/lib/multi.c", "reportHash": "806491b83bf2fdd4c83c08024dd3cf6f", "checkerName": "google-readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 46, "file": 5, "line": 2711}, "message": "{ (fixit)"}, {"location": {"col": 45, "file": 5, "line": 2711}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/lib/multi.c", "reportHash": "646741fed5f9237c4ea508beb07c51a9", "checkerName": "readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 10, "file": 5, "line": 2724}, "message": "use of a signed integer operand with a binary bitwise operator"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/lib/multi.c", "reportHash": "992527e23e564c8e5eafe59f36048828", "checkerName": "hicpp-signed-bitwise", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 29, "file": 39, "line": 55}, "message": "expanded from macro 'GETSOCK_READSOCK'"}, {"location": {"col": 24, "file": 5, "line": 2724}, "message": "use of a signed integer operand with a binary bitwise operator"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/lib/multi.c", "reportHash": "c908ebe8fae23fb4808d3c55f5fe4f05", "checkerName": "hicpp-signed-bitwise", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 31, "file": 39, "line": 52}, "message": "expanded from macro 'GETSOCK_WRITESOCK'"}, {"location": {"col": 46, "file": 5, "line": 2724}, "message": "use of a signed integer operand with a binary bitwise operator"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/lib/multi.c", "reportHash": "974e7f8decb3965f3a520730b7ba9c6e", "checkerName": "hicpp-signed-bitwise", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 8, "file": 5, "line": 2736}, "message": "use of a signed integer operand with a binary bitwise operator"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/lib/multi.c", "reportHash": "6986828696c09a80dd349e33e43c5f0b", "checkerName": "hicpp-signed-bitwise", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 30, "file": 39, "line": 55}, "message": "expanded from macro 'GETSOCK_READSOCK'"}, {"location": {"col": 21, "file": 5, "line": 2736}, "message": "use of a signed integer operand with a binary bitwise operator"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/lib/multi.c", "reportHash": "af9578d193ed258c0c2bebd9be64e623", "checkerName": "hicpp-signed-bitwise", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 42, "file": 5, "line": 2736}, "message": "{ (fixit)"}, {"location": {"col": 41, "file": 5, "line": 2736}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/lib/multi.c", "reportHash": "f6d6919272ab06fde3c7df023e64515d", "checkerName": "google-readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 8, "file": 5, "line": 2738}, "message": "use of a signed integer operand with a binary bitwise operator"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/lib/multi.c", "reportHash": "2545bc1e4734b45b19ea9ee99fc368da", "checkerName": "hicpp-signed-bitwise", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 31, "file": 39, "line": 52}, "message": "expanded from macro 'GETSOCK_WRITESOCK'"}, {"location": {"col": 21, "file": 5, "line": 2738}, "message": "use of a signed integer operand with a binary bitwise operator"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/lib/multi.c", "reportHash": "e16a7ab276abcfc819819082ff2c4a54", "checkerName": "hicpp-signed-bitwise", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 43, "file": 5, "line": 2738}, "message": "{ (fixit)"}, {"location": {"col": 42, "file": 5, "line": 2738}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/lib/multi.c", "reportHash": "0de60025d00c3a8bfcdc959fbc28949d", "checkerName": "google-readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 18, "file": 5, "line": 2756}, "message": "{ (fixit)"}, {"location": {"col": 17, "file": 5, "line": 2756}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/lib/multi.c", "reportHash": "fbc1138c944eea3ebe314af58875bf16", "checkerName": "google-readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 10, "file": 5, "line": 2762}, "message": "use of a signed integer operand with a binary bitwise operator"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/lib/multi.c", "reportHash": "0940770c7551c8eacd9eaafce0b2129f", "checkerName": "hicpp-signed-bitwise", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 37, "file": 5, "line": 2762}, "message": "{ (fixit)"}, {"location": {"col": 36, "file": 5, "line": 2762}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/lib/multi.c", "reportHash": "737a99bed22751cb6524073ff6012743", "checkerName": "readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 10, "file": 5, "line": 2764}, "message": "use of a signed integer operand with a binary bitwise operator"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/lib/multi.c", "reportHash": "dc107dafeace721b9bc52c29e4a4857a", "checkerName": "hicpp-signed-bitwise", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 38, "file": 5, "line": 2764}, "message": "{ (fixit)"}, {"location": {"col": 37, "file": 5, "line": 2764}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/lib/multi.c", "reportHash": "d375c36048fc5732e914197631b3b526", "checkerName": "google-readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 10, "file": 5, "line": 2766}, "message": "use of a signed integer operand with a binary bitwise operator"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/lib/multi.c", "reportHash": "11db1f14a7c2c90d27562cc601ded7c6", "checkerName": "hicpp-signed-bitwise", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 33, "file": 5, "line": 2766}, "message": "{ (fixit)"}, {"location": {"col": 32, "file": 5, "line": 2766}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/lib/multi.c", "reportHash": "6179e4a7ebb14bf2caa9dcfd76b2c896", "checkerName": "readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 10, "file": 5, "line": 2768}, "message": "use of a signed integer operand with a binary bitwise operator"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/lib/multi.c", "reportHash": "0b55c6d25f3ed0255bd7f07164b16abe", "checkerName": "hicpp-signed-bitwise", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 34, "file": 5, "line": 2768}, "message": "{ (fixit)"}, {"location": {"col": 33, "file": 5, "line": 2768}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/lib/multi.c", "reportHash": "2330668eea545d6489fbb68681e69414", "checkerName": "readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 10, "file": 5, "line": 2774}, "message": "use of a signed integer operand with a binary bitwise operator"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/lib/multi.c", "reportHash": "11db1f14a7c2c90d27562cc601ded7c6", "checkerName": "hicpp-signed-bitwise", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 33, "file": 5, "line": 2774}, "message": "{ (fixit)"}, {"location": {"col": 32, "file": 5, "line": 2774}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/lib/multi.c", "reportHash": "2ed0f627ca232c8f6c10e73427ed9c2a", "checkerName": "hicpp-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 10, "file": 5, "line": 2776}, "message": "use of a signed integer operand with a binary bitwise operator"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/lib/multi.c", "reportHash": "0b55c6d25f3ed0255bd7f07164b16abe", "checkerName": "hicpp-signed-bitwise", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 34, "file": 5, "line": 2776}, "message": "{ (fixit)"}, {"location": {"col": 33, "file": 5, "line": 2776}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/lib/multi.c", "reportHash": "a53aa165aaa8712a187a2251b048a2a6", "checkerName": "google-readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 60, "file": 5, "line": 2781}, "message": "{ (fixit)"}, {"location": {"col": 59, "file": 5, "line": 2781}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/lib/multi.c", "reportHash": "c642d0ce84b0152d9f9d074a7ba753ed", "checkerName": "google-readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 19, "file": 5, "line": 2785}, "message": "use of a signed integer operand with a binary bitwise operator"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/lib/multi.c", "reportHash": "ad3ccb41b70b4f69ea9de2772c1e6198", "checkerName": "hicpp-signed-bitwise", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 55, "file": 5, "line": 2789}, "message": "{ (fixit)"}, {"location": {"col": 54, "file": 5, "line": 2789}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/lib/multi.c", "reportHash": "699072d54dedec3690257b60087f6bcb", "checkerName": "readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 26, "file": 5, "line": 2793}, "message": "{ (fixit)"}, {"location": {"col": 25, "file": 5, "line": 2793}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/lib/multi.c", "reportHash": "4b18df1785b01411e6aff3a01fb73a77", "checkerName": "google-readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 19, "file": 5, "line": 2815}, "message": "{ (fixit)"}, {"location": {"col": 18, "file": 5, "line": 2815}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/lib/multi.c", "reportHash": "fc9d0168bf3261b09463579fe20b7bef", "checkerName": "readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 10, "file": 5, "line": 2825}, "message": "use of a signed integer operand with a binary bitwise operator"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/lib/multi.c", "reportHash": "7a207d63c371989c9966ad46024d5d1b", "checkerName": "hicpp-signed-bitwise", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 38, "file": 5, "line": 2825}, "message": "{ (fixit)"}, {"location": {"col": 37, "file": 5, "line": 2825}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/lib/multi.c", "reportHash": "8012ed58ea0ab5875f7a6899ee1b24a4", "checkerName": "google-readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 10, "file": 5, "line": 2827}, "message": "use of a signed integer operand with a binary bitwise operator"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/lib/multi.c", "reportHash": "97ec6bbe3f20e3d19ae7c419adf1c0b5", "checkerName": "hicpp-signed-bitwise", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 37, "file": 5, "line": 2827}, "message": "{ (fixit)"}, {"location": {"col": 36, "file": 5, "line": 2827}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/lib/multi.c", "reportHash": "62f66493afdcb798470efd461569811f", "checkerName": "google-readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 30, "file": 5, "line": 2830}, "message": "{ (fixit)"}, {"location": {"col": 29, "file": 5, "line": 2830}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/lib/multi.c", "reportHash": "ef3ce111016d6ddb3f512e68e1b80777", "checkerName": "google-readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 30, "file": 5, "line": 2879}, "message": "{ (fixit)"}, {"location": {"col": 29, "file": 5, "line": 2879}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/lib/multi.c", "reportHash": "ef3ce111016d6ddb3f512e68e1b80777", "checkerName": "google-readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 19, "file": 5, "line": 2920}, "message": "{ (fixit)"}, {"location": {"col": 18, "file": 5, "line": 2920}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/lib/multi.c", "reportHash": "dd7ce4b3bbd33d8528ea24e2d8bdeae4", "checkerName": "google-readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 10, "file": 5, "line": 2923}, "message": "{ (fixit)"}, {"location": {"col": 9, "file": 5, "line": 2923}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/lib/multi.c", "reportHash": "b3a440724c87d3ff77df05c7e913bdf4", "checkerName": "readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 16, "file": 5, "line": 2978}, "message": "{ (fixit)"}, {"location": {"col": 15, "file": 5, "line": 2978}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/lib/multi.c", "reportHash": "5077e108218c68707b20774a46b976bb", "checkerName": "readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 28, "file": 5, "line": 2997}, "message": "use of a signed integer operand with a binary bitwise operator"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/lib/multi.c", "reportHash": "c733662f3d71bcd520ed9970e3185ca5", "checkerName": "hicpp-signed-bitwise", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 26, "file": 38, "line": 755}, "message": "expanded from macro 'PROTOPT_DIRLOCK'"}, {"location": {"col": 57, "file": 5, "line": 2997}, "message": "use of a signed integer operand with a binary bitwise operator"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/lib/multi.c", "reportHash": "d2da4b69f759eb3abc9f9464cf323d6d", "checkerName": "hicpp-signed-bitwise", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 75, "file": 5, "line": 2997}, "message": "{ (fixit)"}, {"location": {"col": 74, "file": 5, "line": 2997}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/lib/multi.c", "reportHash": "4c7fca140d84158ab747377d60c4bd51", "checkerName": "readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 20, "file": 5, "line": 3041}, "message": "{ (fixit)"}, {"location": {"col": 19, "file": 5, "line": 3041}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/lib/multi.c", "reportHash": "f4e7999a960f3fd5ff5af2e34a46c127", "checkerName": "google-readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 33, "file": 5, "line": 3068}, "message": "{ (fixit)"}, {"location": {"col": 32, "file": 5, "line": 3068}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/lib/multi.c", "reportHash": "6c15bdf958ad2d42acbfb5309a7f282d", "checkerName": "readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 26, "file": 5, "line": 3071}, "message": "{ (fixit)"}, {"location": {"col": 25, "file": 5, "line": 3071}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/lib/multi.c", "reportHash": "1b45fec20291d1e3a63a55743b1761c9", "checkerName": "readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 29, "file": 42, "line": 35}, "message": "expanded from macro 'va_arg'"}, {"location": {"col": 27, "file": 5, "line": 3090}, "message": "use of a signed integer operand with a binary bitwise operator"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/lib/multi.c", "reportHash": "074bdd6ee850f468f1b14585698b2a2c", "checkerName": "hicpp-signed-bitwise", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 23, "file": 5, "line": 3121}, "message": "{ (fixit)"}, {"location": {"col": 22, "file": 5, "line": 3121}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/lib/multi.c", "reportHash": "1a577fc1405928e872b8519ccf0dabe1", "checkerName": "readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 26, "file": 5, "line": 3141}, "message": "{ (fixit)"}, {"location": {"col": 25, "file": 5, "line": 3141}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/lib/multi.c", "reportHash": "1b45fec20291d1e3a63a55743b1761c9", "checkerName": "readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 26, "file": 5, "line": 3144}, "message": "{ (fixit)"}, {"location": {"col": 25, "file": 5, "line": 3144}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/lib/multi.c", "reportHash": "140aef0ab4a793661c8ed249d8e709b9", "checkerName": "readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 26, "file": 5, "line": 3153}, "message": "{ (fixit)"}, {"location": {"col": 25, "file": 5, "line": 3153}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/lib/multi.c", "reportHash": "1b45fec20291d1e3a63a55743b1761c9", "checkerName": "readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 26, "file": 5, "line": 3156}, "message": "{ (fixit)"}, {"location": {"col": 25, "file": 5, "line": 3156}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/lib/multi.c", "reportHash": "9511974380127bb10fc82db21ea35fe0", "checkerName": "google-readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 26, "file": 5, "line": 3165}, "message": "{ (fixit)"}, {"location": {"col": 25, "file": 5, "line": 3165}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/lib/multi.c", "reportHash": "1b45fec20291d1e3a63a55743b1761c9", "checkerName": "readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 26, "file": 5, "line": 3168}, "message": "{ (fixit)"}, {"location": {"col": 25, "file": 5, "line": 3168}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/lib/multi.c", "reportHash": "140aef0ab4a793661c8ed249d8e709b9", "checkerName": "readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 21, "file": 5, "line": 3188}, "message": "{ (fixit)"}, {"location": {"col": 20, "file": 5, "line": 3188}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/lib/multi.c", "reportHash": "38e92b6ecd8704262920fc7e07865a1a", "checkerName": "google-readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 12, "file": 5, "line": 3197}, "message": "{ (fixit)"}, {"location": {"col": 11, "file": 5, "line": 3197}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/lib/multi.c", "reportHash": "635809d2ffbd02b7d483c54dfe7a50ec", "checkerName": "google-readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 10, "file": 5, "line": 3202}, "message": "{ (fixit)"}, {"location": {"col": 9, "file": 5, "line": 3202}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/lib/multi.c", "reportHash": "dd24d789d9216ee4057afddeb848a08b", "checkerName": "google-readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 8, "file": 5, "line": 3206}, "message": "{ (fixit)"}, {"location": {"col": 7, "file": 5, "line": 3206}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/lib/multi.c", "reportHash": "224d346fdb36041c46afe5bec4342d22", "checkerName": "hicpp-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 33, "file": 5, "line": 3216}, "message": "{ (fixit)"}, {"location": {"col": 32, "file": 5, "line": 3216}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/lib/multi.c", "reportHash": "68234a88752477d778f432a43e1d82f5", "checkerName": "google-readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 26, "file": 5, "line": 3219}, "message": "{ (fixit)"}, {"location": {"col": 25, "file": 5, "line": 3219}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/lib/multi.c", "reportHash": "1ab45975c90eb0e06b9fa9a9903b132a", "checkerName": "hicpp-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 24, "file": 5, "line": 3233}, "message": "{ (fixit)"}, {"location": {"col": 23, "file": 5, "line": 3233}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/lib/multi.c", "reportHash": "c8300d98c47e353fbe3fe3fbaf0fe22c", "checkerName": "google-readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 79, "file": 5, "line": 3254}, "message": "{ (fixit)"}, {"location": {"col": 78, "file": 5, "line": 3254}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/lib/multi.c", "reportHash": "1df1998081d7a6942a5f40486cb82f07", "checkerName": "hicpp-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 20, "file": 5, "line": 3312}, "message": "{ (fixit)"}, {"location": {"col": 19, "file": 5, "line": 3312}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/lib/multi.c", "reportHash": "761c0a0a00a454750c4eaa244e8a431b", "checkerName": "google-readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 14, "file": 5, "line": 3344}, "message": "{ (fixit)"}, {"location": {"col": 13, "file": 5, "line": 3344}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/lib/multi.c", "reportHash": "623832a9f339829bd17874e04b6df9c5", "checkerName": "hicpp-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 12, "file": 5, "line": 3383}, "message": "{ (fixit)"}, {"location": {"col": 11, "file": 5, "line": 3383}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/lib/multi.c", "reportHash": "13ffd49963d36b0d4a15cce32e3608fc", "checkerName": "readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 14, "file": 5, "line": 3419}, "message": "{ (fixit)"}, {"location": {"col": 13, "file": 5, "line": 3419}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/lib/multi.c", "reportHash": "1804229d3fad9a74af23ad18ff96d516", "checkerName": "readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 12, "file": 5, "line": 3431}, "message": "{ (fixit)"}, {"location": {"col": 11, "file": 5, "line": 3431}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/lib/multi.c", "reportHash": "13ffd49963d36b0d4a15cce32e3608fc", "checkerName": "readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 26, "file": 5, "line": 3455}, "message": "{ (fixit)"}, {"location": {"col": 25, "file": 5, "line": 3455}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/lib/multi.c", "reportHash": "040b1c39e6e80eef64e4736d5ef43cc8", "checkerName": "google-readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 14, "file": 5, "line": 3460}, "message": "{ (fixit)"}, {"location": {"col": 13, "file": 5, "line": 3460}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/lib/multi.c", "reportHash": "8cf1767e03c12ac80ed6f1fcd19e70af", "checkerName": "hicpp-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 26, "file": 5, "line": 3519}, "message": "{ (fixit)"}, {"location": {"col": 25, "file": 5, "line": 3519}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/lib/multi.c", "reportHash": "85e3160c1b1d3ef75277ac928ab1d9d8", "checkerName": "hicpp-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 26, "file": 5, "line": 3521}, "message": "{ (fixit)"}, {"location": {"col": 25, "file": 5, "line": 3521}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/lib/multi.c", "reportHash": "f80fe9c86485c58cb281e076e793e6ca", "checkerName": "hicpp-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 70, "file": 39, "line": 30}, "message": "/*id*/ (fixit)"}, {"location": {"col": 69, "file": 39, "line": 30}, "message": "all parameters should be named in a function"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/lib/multiif.h", "reportHash": "196a17ffbcee1ea11f444bc2eeeb69ff", "checkerName": "readability-named-parameter", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 22, "file": 54, "line": 67}, "message": "{ (fixit)"}, {"location": {"col": 21, "file": 54, "line": 67}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/lib/sigpipe.h", "reportHash": "16e74b6e62ec8664dd7ecdff50ed180a", "checkerName": "readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}]};
      window.onload = function() {
        if (!browserCompatible) {
          setNonCompatibleBrowserMessage();
        } else {
          BugViewer.init(data.files, data.reports);
          BugViewer.create();
          BugViewer.initByUrl();
        }
      };
    </script>
  </head>
  <body>
  <div class="container">
    <div id="content">
      <div id="side-bar">
        <div class="header">
          <a href="index.html" class="button">&#8249; Return to List</a>
        </div>
        <div id="report-nav">
          <div class="header">Reports</div>
        </div>
      </div>
      <div id="editor-wrapper">
        <div class="header">
          <div id="file">
            <span class="label">File:</span>
            <span id="file-path"></span>
          </div>
          <div id="checker">
            <span class="label">Checker name:</span>
            <span id="checker-name"></span>
          </div>
          <div id="review-status-wrapper">
            <span class="label">Review status:</span>
            <span id="review-status"></span>
          </div>
        </div>
        <div id="editor"></div>
      </div>
    </div>
  </div>
  </body>
</html>
