<!DOCTYPE html>
<html>
  <head>
    <title>Plist HTML Viewer</title>

    <meta charset="UTF-8">

    <style type="text/css">
      .CodeMirror{font-family:monospace;height:300px;color:#000;direction:ltr}.CodeMirror-lines{padding:4px 0}.CodeMirror pre{padding:0 4px}.CodeMirror-gutter-filler,.CodeMirror-scrollbar-filler{background-color:#fff}.CodeMirror-gutters{border-right:1px solid #ddd;background-color:#f7f7f7;white-space:nowrap}.CodeMirror-linenumber{padding:0 3px 0 5px;min-width:20px;text-align:right;color:#999;white-space:nowrap}.CodeMirror-guttermarker{color:#000}.CodeMirror-guttermarker-subtle{color:#999}.CodeMirror-cursor{border-left:1px solid #000;border-right:none;width:0}.CodeMirror div.CodeMirror-secondarycursor{border-left:1px solid silver}.cm-fat-cursor .CodeMirror-cursor{width:auto;border:0!important;background:#7e7}.cm-fat-cursor div.CodeMirror-cursors{z-index:1}.cm-animate-fat-cursor{width:auto;border:0;-webkit-animation:blink 1.06s steps(1) infinite;-moz-animation:blink 1.06s steps(1) infinite;animation:blink 1.06s steps(1) infinite;background-color:#7e7}@-moz-keyframes blink{50%{background-color:transparent}}@-webkit-keyframes blink{50%{background-color:transparent}}@keyframes blink{50%{background-color:transparent}}.cm-tab{display:inline-block;text-decoration:inherit}.CodeMirror-rulers{position:absolute;left:0;right:0;top:-50px;bottom:-20px;overflow:hidden}.CodeMirror-ruler{border-left:1px solid #ccc;top:0;bottom:0;position:absolute}.cm-s-default .cm-header{color:#00f}.cm-s-default .cm-quote{color:#090}.cm-negative{color:#d44}.cm-positive{color:#292}.cm-header,.cm-strong{font-weight:700}.cm-em{font-style:italic}.cm-link{text-decoration:underline}.cm-strikethrough{text-decoration:line-through}.cm-s-default .cm-keyword{color:#708}.cm-s-default .cm-atom{color:#219}.cm-s-default .cm-number{color:#164}.cm-s-default .cm-def{color:#00f}.cm-s-default .cm-variable-2{color:#05a}.cm-s-default .cm-type,.cm-s-default .cm-variable-3{color:#085}.cm-s-default .cm-comment{color:#a50}.cm-s-default .cm-string{color:#a11}.cm-s-default .cm-string-2{color:#f50}.cm-s-default .cm-meta{color:#555}.cm-s-default .cm-qualifier{color:#555}.cm-s-default .cm-builtin{color:#30a}.cm-s-default .cm-bracket{color:#997}.cm-s-default .cm-tag{color:#170}.cm-s-default .cm-attribute{color:#00c}.cm-s-default .cm-hr{color:#999}.cm-s-default .cm-link{color:#00c}.cm-s-default .cm-error{color:red}.cm-invalidchar{color:red}.CodeMirror-composing{border-bottom:2px solid}div.CodeMirror span.CodeMirror-matchingbracket{color:#0f0}div.CodeMirror span.CodeMirror-nonmatchingbracket{color:#f22}.CodeMirror-matchingtag{background:rgba(255,150,0,.3)}.CodeMirror-activeline-background{background:#e8f2ff}.CodeMirror{position:relative;overflow:hidden;background:#fff}.CodeMirror-scroll{overflow:scroll!important;margin-bottom:-30px;margin-right:-30px;padding-bottom:30px;height:100%;outline:0;position:relative}.CodeMirror-sizer{position:relative;border-right:30px solid transparent}.CodeMirror-gutter-filler,.CodeMirror-hscrollbar,.CodeMirror-scrollbar-filler,.CodeMirror-vscrollbar{position:absolute;z-index:6;display:none}.CodeMirror-vscrollbar{right:0;top:0;overflow-x:hidden;overflow-y:scroll}.CodeMirror-hscrollbar{bottom:0;left:0;overflow-y:hidden;overflow-x:scroll}.CodeMirror-scrollbar-filler{right:0;bottom:0}.CodeMirror-gutter-filler{left:0;bottom:0}.CodeMirror-gutters{position:absolute;left:0;top:0;min-height:100%;z-index:3}.CodeMirror-gutter{white-space:normal;height:100%;display:inline-block;vertical-align:top;margin-bottom:-30px}.CodeMirror-gutter-wrapper{position:absolute;z-index:4;background:0 0!important;border:none!important}.CodeMirror-gutter-background{position:absolute;top:0;bottom:0;z-index:4}.CodeMirror-gutter-elt{position:absolute;cursor:default;z-index:4}.CodeMirror-gutter-wrapper ::selection{background-color:transparent}.CodeMirror-gutter-wrapper ::-moz-selection{background-color:transparent}.CodeMirror-lines{cursor:text;min-height:1px}.CodeMirror pre{-moz-border-radius:0;-webkit-border-radius:0;border-radius:0;border-width:0;background:0 0;font-family:inherit;font-size:inherit;margin:0;white-space:pre;word-wrap:normal;line-height:inherit;color:inherit;z-index:2;position:relative;overflow:visible;-webkit-tap-highlight-color:transparent;-webkit-font-variant-ligatures:contextual;font-variant-ligatures:contextual}.CodeMirror-wrap pre{word-wrap:break-word;white-space:pre-wrap;word-break:normal}.CodeMirror-linebackground{position:absolute;left:0;right:0;top:0;bottom:0;z-index:0}.CodeMirror-linewidget{position:relative;z-index:2;overflow:auto}.CodeMirror-rtl pre{direction:rtl}.CodeMirror-code{outline:0}.CodeMirror-gutter,.CodeMirror-gutters,.CodeMirror-linenumber,.CodeMirror-scroll,.CodeMirror-sizer{-moz-box-sizing:content-box;box-sizing:content-box}.CodeMirror-measure{position:absolute;width:100%;height:0;overflow:hidden;visibility:hidden}.CodeMirror-cursor{position:absolute;pointer-events:none}.CodeMirror-measure pre{position:static}div.CodeMirror-cursors{visibility:hidden;position:relative;z-index:3}div.CodeMirror-dragcursors{visibility:visible}.CodeMirror-focused div.CodeMirror-cursors{visibility:visible}.CodeMirror-selected{background:#d9d9d9}.CodeMirror-focused .CodeMirror-selected{background:#d7d4f0}.CodeMirror-crosshair{cursor:crosshair}.CodeMirror-line::selection,.CodeMirror-line>span::selection,.CodeMirror-line>span>span::selection{background:#d7d4f0}.CodeMirror-line::-moz-selection,.CodeMirror-line>span::-moz-selection,.CodeMirror-line>span>span::-moz-selection{background:#d7d4f0}.cm-searching{background-color:#ffa;background-color:rgba(255,255,0,.4)}.cm-force-border{padding-right:.1px}@media print{.CodeMirror div.CodeMirror-cursors{visibility:hidden}}.cm-tab-wrap-hack:after{content:''}span.CodeMirror-selectedtext{background:0 0}
/*# sourceMappingURL=codemirror.min.css.map */

      .severity-low {
  background-color: #669603;
}

.severity-low:after {
  content : 'L';
}

.severity-unspecified {
  background-color: #666666;
}

.severity-unspecified:after {
  content : 'U';
}

.severity-style {
  background-color: #9932cc;
}

.severity-style:after {
  content : 'S';
}

.severity-medium {
  background-color: #a9d323;
  color: black;
}

.severity-medium:after {
  content : 'M';
}

.severity-high {
  background-color: #ffa800;
}

.severity-high:after {
  content : 'H';
}

.severity-critical {
  background-color: #e92625;
}

.severity-critical:after {
  content : 'C';
}

i[class*="severity-"] {
  line-height: normal;
  text-transform: capitalize;
  font-size: 0.8em;
  font-weight: bold;
  color: white;
  display: inline-block;
  width: 16px;
  height: 16px;
  text-align: center;
  font-family: sans-serif;
}

      html, body {
  width: 100%;
  height: 100%;
  padding: 0px;
  margin: 0px;
}

div.container {
  padding: 10px;
}

#content {
  height: 100%;
  display: block;
  overflow: hidden;
}

#content > div {
  margin: 10px;
  overflow: hidden;
  border: 1px solid #ddd;
  border-radius: 3px;
  overflow: hidden;
  height: 97%;
}

.button {
  background-color: #f1f1f1;
  text-decoration: none;
  display: inline-block;
  padding: 8px 16px;
  color: black;
  cursor: pointer;
}

.button:hover {
  background-color: #ddd;
  color: black;
}

.review-status {
  color: white;
  text-align: center;
}

.review-status-confirmed {
  background-color: #e92625;
}

.review-status-false-positive {
  background-color: grey;
}

.review-status-intentional {
  background-color: #669603;
}

      div.container {
  width: 100%;
  height: 100%;
  padding: 0px;
}

#editor-wrapper {
  margin: 10px;
}

#side-bar {
  float: left;
  width: 260px;
  margin: 0px;
}

#report-nav ul {
  list-style-type: none;
  padding: 0;
  margin: 0;
  overflow-y: auto;
  height: 100%;
}

#report-nav ul > li {
  padding: .4em;
  background-color: #fff;
  border-bottom: 1px solid rgba(0,0,0,.125);
  text-align: left;
  overflow: hidden;
  white-space: nowrap;
  text-overflow: ellipsis;
}

#report-nav ul > li.active {
  background-color: #427ea9;
  color: white;
}

#report-nav ul > li:hover {
  background-color: #427ea9;
  color: white;
  cursor: pointer;
}

#report-nav ul a {
  text-decoration: none;
}

#report-nav i[class*="severity-"] {
  margin-right: 5px;
}

.header {
  border-bottom: 1px solid lightgrey;
  font-family: monospace;
  padding: 10px;
  background-color: #fafbfc;
  border-bottom: 1px solid #e1e4e8;
  border-top-left-radius: 2px;
  border-top-right-radius: 2px;
}

#report-nav .header {
  font-weight: bold;
}

#editor-wrapper .header > div {
  padding-top: 2px;
}

#file-path,
#checker-name {
  color: #195ea2;
}

#review-status {
  padding: 0px 5px;
}

#file-path {
  font-family: monospace;
}

.check-msg {
  display: inline-block;
  padding: 3px 6px;
  margin: 1px;
  -webkit-border-radius: 5px;
  -moz-border-radius: 5px;
  border-radius: 5px;
}

.check-msg.info {
  color: #00546f;
  background-color: #bfdfe9;
  border: 1px solid #87a8b3;
}

.check-msg.error {
  background-color: #f2dede;
  color: #a94442;
  border: 1px solid #ebcccc;
}

.check-msg.macro {
  background-color: #d7dac2;
  color: #4f5c6d;
  border: 1px solid #d7dac2;
}

.check-msg.note {
  background-color: #d7d7d7;
  color: #4f5c6d;
  border: 1px solid #bfbfbf;
}

.check-msg.current {
  border: 2px dashed #3692ff;
}

.check-msg .tag {
  padding: 1px 5px;
  text-align: center;
  border-radius: 2px;
  margin-right: 5px;
  text-decoration: inherit;
}

.check-msg .tag.macro {
  background-color: #83876a;
  color: white;
  text-transform: capitalize;
}

.check-msg .tag.note {
  background-color: #9299a1;
  color: white;
  text-transform: capitalize;
}

.checker-enum {
  color: white;
  padding: 1px 5px;
  text-align: center;
  border-radius: 25px;
  margin-right: 5px;
  text-decoration: inherit;
}

.checker-enum.info {
  background-color: #427ea9;
}

.checker-enum.error {
  background-color: #a94442;
}

.arrow {
  border: solid black;
  border-width: 0 3px 3px 0;
  display: inline-block;
  padding: 3px;
  cursor: pointer;
  margin: 0px 5px;
}

.arrow:hover {
  border: solid #437ea8;
  border-width: 0 3px 3px 0;
}

.left-arrow {
  transform: rotate(135deg);
  -webkit-transform: rotate(135deg);
}

.right-arrow {
  transform: rotate(-45deg);
  -webkit-transform: rotate(-45deg);
}

    </style>

    <script type="text/javascript">
      function setNonCompatibleBrowserMessage() {
  document.body.innerHTML =
    '<h2 style="margin-left: 20px;">Your browser is not compatible with CodeChecker Viewer!</h2> \
     <p style="margin-left: 20px;">The version required for the following browsers are:</p> \
     <ul style="margin-left: 20px;"> \
     <li>Internet Explorer: version 9 or newer</li> \
     <li>Firefox: version 22.0 or newer</li> \
     </ul>';
}

// http://stackoverflow.com/questions/5916900/how-can-you-detect-the-version-of-a-browser
var browserVersion = (function(){
  var ua = navigator.userAgent, tem,
    M = ua.match(/(opera|chrome|safari|firefox|msie|trident(?=\/))\/?\s*(\d+)/i) || [];

  if (/trident/i.test(M[1])) {
    tem = /\brv[ :]+(\d+)/g.exec(ua) || [];
    return 'IE ' + (tem[1] || '');
  }

  if (M[1] === 'Chrome') {
    tem = ua.match(/\b(OPR|Edge)\/(\d+)/);
    if (tem != null) return tem.slice(1).join(' ').replace('OPR', 'Opera');
  }

  M = M[2] ? [M[1], M[2]] : [navigator.appName, navigator.appVersion, '-?'];
  if ((tem = ua.match(/version\/(\d+)/i)) != null) M.splice(1, 1, tem[1]);
    return M.join(' ');
})();

var pos = browserVersion.indexOf(' ');
var browser = browserVersion.substr(0, pos);
var version = parseInt(browserVersion.substr(pos + 1));

var browserCompatible
  = browser === 'Firefox'
  ? version >= 22
  : browser === 'IE'
  ? version >= 9
  : true;


      /* MIT License

Copyright (C) 2017 by Marijn Haverbeke <marijnh@gmail.com> and others

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
THE SOFTWARE.
 */
      !function(e,t){"object"==typeof exports&&"undefined"!=typeof module?module.exports=t():"function"==typeof define&&define.amd?define(t):e.CodeMirror=t()}(this,function(){"use strict";function e(e){return new RegExp("(^|\\s)"+e+"(?:$|\\s)\\s*")}function t(e){for(var t=e.childNodes.length;t>0;--t)e.removeChild(e.firstChild);return e}function r(e,r){return t(e).appendChild(r)}function n(e,t,r,n){var i=document.createElement(e);if(r&&(i.className=r),n&&(i.style.cssText=n),"string"==typeof t)i.appendChild(document.createTextNode(t));else if(t)for(var o=0;o<t.length;++o)i.appendChild(t[o]);return i}function i(e,t,r,i){var o=n(e,t,r,i);return o.setAttribute("role","presentation"),o}function o(e,t){if(3==t.nodeType&&(t=t.parentNode),e.contains)return e.contains(t);do{if(11==t.nodeType&&(t=t.host),t==e)return!0}while(t=t.parentNode)}function l(){var e;try{e=document.activeElement}catch(t){e=document.body||null}for(;e&&e.shadowRoot&&e.shadowRoot.activeElement;)e=e.shadowRoot.activeElement;return e}function s(t,r){var n=t.className;e(r).test(n)||(t.className+=(n?" ":"")+r)}function a(t,r){for(var n=t.split(" "),i=0;i<n.length;i++)n[i]&&!e(n[i]).test(r)&&(r+=" "+n[i]);return r}function u(e){var t=Array.prototype.slice.call(arguments,1);return function(){return e.apply(null,t)}}function c(e,t,r){t||(t={});for(var n in e)!e.hasOwnProperty(n)||!1===r&&t.hasOwnProperty(n)||(t[n]=e[n]);return t}function f(e,t,r,n,i){null==t&&-1==(t=e.search(/[^\s\u00a0]/))&&(t=e.length);for(var o=n||0,l=i||0;;){var s=e.indexOf("\t",o);if(s<0||s>=t)return l+(t-o);l+=s-o,l+=r-l%r,o=s+1}}function h(e,t){for(var r=0;r<e.length;++r)if(e[r]==t)return r;return-1}function d(e,t,r){for(var n=0,i=0;;){var o=e.indexOf("\t",n);-1==o&&(o=e.length);var l=o-n;if(o==e.length||i+l>=t)return n+Math.min(l,t-i);if(i+=o-n,i+=r-i%r,n=o+1,i>=t)return n}}function p(e){for(;Kl.length<=e;)Kl.push(g(Kl)+" ");return Kl[e]}function g(e){return e[e.length-1]}function v(e,t){for(var r=[],n=0;n<e.length;n++)r[n]=t(e[n],n);return r}function m(e,t,r){for(var n=0,i=r(t);n<e.length&&r(e[n])<=i;)n++;e.splice(n,0,t)}function y(){}function b(e,t){var r;return Object.create?r=Object.create(e):(y.prototype=e,r=new y),t&&c(t,r),r}function w(e){return/\w/.test(e)||e>""&&(e.toUpperCase()!=e.toLowerCase()||jl.test(e))}function x(e,t){return t?!!(t.source.indexOf("\\w")>-1&&w(e))||t.test(e):w(e)}function C(e){for(var t in e)if(e.hasOwnProperty(t)&&e[t])return!1;return!0}function S(e){return e.charCodeAt(0)>=768&&Xl.test(e)}function L(e,t,r){for(;(r<0?t>0:t<e.length)&&S(e.charAt(t));)t+=r;return t}function k(e,t,r){for(var n=t>r?-1:1;;){if(t==r)return t;var i=(t+r)/2,o=n<0?Math.ceil(i):Math.floor(i);if(o==t)return e(o)?t:r;e(o)?r=o:t=o+n}}function T(e,t,r){var o=this;this.input=r,o.scrollbarFiller=n("div",null,"CodeMirror-scrollbar-filler"),o.scrollbarFiller.setAttribute("cm-not-content","true"),o.gutterFiller=n("div",null,"CodeMirror-gutter-filler"),o.gutterFiller.setAttribute("cm-not-content","true"),o.lineDiv=i("div",null,"CodeMirror-code"),o.selectionDiv=n("div",null,null,"position: relative; z-index: 1"),o.cursorDiv=n("div",null,"CodeMirror-cursors"),o.measure=n("div",null,"CodeMirror-measure"),o.lineMeasure=n("div",null,"CodeMirror-measure"),o.lineSpace=i("div",[o.measure,o.lineMeasure,o.selectionDiv,o.cursorDiv,o.lineDiv],null,"position: relative; outline: none");var l=i("div",[o.lineSpace],"CodeMirror-lines");o.mover=n("div",[l],null,"position: relative"),o.sizer=n("div",[o.mover],"CodeMirror-sizer"),o.sizerWidth=null,o.heightForcer=n("div",null,null,"position: absolute; height: "+Rl+"px; width: 1px;"),o.gutters=n("div",null,"CodeMirror-gutters"),o.lineGutter=null,o.scroller=n("div",[o.sizer,o.heightForcer,o.gutters],"CodeMirror-scroll"),o.scroller.setAttribute("tabIndex","-1"),o.wrapper=n("div",[o.scrollbarFiller,o.gutterFiller,o.scroller],"CodeMirror"),gl&&vl<8&&(o.gutters.style.zIndex=-1,o.scroller.style.paddingRight=0),ml||fl&&Tl||(o.scroller.draggable=!0),e&&(e.appendChild?e.appendChild(o.wrapper):e(o.wrapper)),o.viewFrom=o.viewTo=t.first,o.reportedViewFrom=o.reportedViewTo=t.first,o.view=[],o.renderedView=null,o.externalMeasured=null,o.viewOffset=0,o.lastWrapHeight=o.lastWrapWidth=0,o.updateLineNumbers=null,o.nativeBarWidth=o.barHeight=o.barWidth=0,o.scrollbarsClipped=!1,o.lineNumWidth=o.lineNumInnerWidth=o.lineNumChars=null,o.alignWidgets=!1,o.cachedCharWidth=o.cachedTextHeight=o.cachedPaddingH=null,o.maxLine=null,o.maxLineLength=0,o.maxLineChanged=!1,o.wheelDX=o.wheelDY=o.wheelStartX=o.wheelStartY=null,o.shift=!1,o.selForContextMenu=null,o.activeTouch=null,r.init(o)}function M(e,t){if((t-=e.first)<0||t>=e.size)throw new Error("There is no line "+(t+e.first)+" in the document.");for(var r=e;!r.lines;)for(var n=0;;++n){var i=r.children[n],o=i.chunkSize();if(t<o){r=i;break}t-=o}return r.lines[t]}function N(e,t,r){var n=[],i=t.line;return e.iter(t.line,r.line+1,function(e){var o=e.text;i==r.line&&(o=o.slice(0,r.ch)),i==t.line&&(o=o.slice(t.ch)),n.push(o),++i}),n}function O(e,t,r){var n=[];return e.iter(t,r,function(e){n.push(e.text)}),n}function A(e,t){var r=t-e.height;if(r)for(var n=e;n;n=n.parent)n.height+=r}function W(e){if(null==e.parent)return null;for(var t=e.parent,r=h(t.lines,e),n=t.parent;n;t=n,n=n.parent)for(var i=0;n.children[i]!=t;++i)r+=n.children[i].chunkSize();return r+t.first}function D(e,t){var r=e.first;e:do{for(var n=0;n<e.children.length;++n){var i=e.children[n],o=i.height;if(t<o){e=i;continue e}t-=o,r+=i.chunkSize()}return r}while(!e.lines);for(var l=0;l<e.lines.length;++l){var s=e.lines[l].height;if(t<s)break;t-=s}return r+l}function H(e,t){return t>=e.first&&t<e.first+e.size}function F(e,t){return String(e.lineNumberFormatter(t+e.firstLineNumber))}function E(e,t,r){if(void 0===r&&(r=null),!(this instanceof E))return new E(e,t,r);this.line=e,this.ch=t,this.sticky=r}function P(e,t){return e.line-t.line||e.ch-t.ch}function I(e,t){return e.sticky==t.sticky&&0==P(e,t)}function z(e){return E(e.line,e.ch)}function R(e,t){return P(e,t)<0?t:e}function B(e,t){return P(e,t)<0?e:t}function G(e,t){return Math.max(e.first,Math.min(t,e.first+e.size-1))}function U(e,t){if(t.line<e.first)return E(e.first,0);var r=e.first+e.size-1;return t.line>r?E(r,M(e,r).text.length):V(t,M(e,t.line).text.length)}function V(e,t){var r=e.ch;return null==r||r>t?E(e.line,t):r<0?E(e.line,0):e}function K(e,t){for(var r=[],n=0;n<t.length;n++)r[n]=U(e,t[n]);return r}function j(){Yl=!0}function X(){_l=!0}function Y(e,t,r){this.marker=e,this.from=t,this.to=r}function _(e,t){if(e)for(var r=0;r<e.length;++r){var n=e[r];if(n.marker==t)return n}}function $(e,t){for(var r,n=0;n<e.length;++n)e[n]!=t&&(r||(r=[])).push(e[n]);return r}function q(e,t){e.markedSpans=e.markedSpans?e.markedSpans.concat([t]):[t],t.marker.attachLine(e)}function Z(e,t,r){var n;if(e)for(var i=0;i<e.length;++i){var o=e[i],l=o.marker;if(null==o.from||(l.inclusiveLeft?o.from<=t:o.from<t)||o.from==t&&"bookmark"==l.type&&(!r||!o.marker.insertLeft)){var s=null==o.to||(l.inclusiveRight?o.to>=t:o.to>t);(n||(n=[])).push(new Y(l,o.from,s?null:o.to))}}return n}function Q(e,t,r){var n;if(e)for(var i=0;i<e.length;++i){var o=e[i],l=o.marker;if(null==o.to||(l.inclusiveRight?o.to>=t:o.to>t)||o.from==t&&"bookmark"==l.type&&(!r||o.marker.insertLeft)){var s=null==o.from||(l.inclusiveLeft?o.from<=t:o.from<t);(n||(n=[])).push(new Y(l,s?null:o.from-t,null==o.to?null:o.to-t))}}return n}function J(e,t){if(t.full)return null;var r=H(e,t.from.line)&&M(e,t.from.line).markedSpans,n=H(e,t.to.line)&&M(e,t.to.line).markedSpans;if(!r&&!n)return null;var i=t.from.ch,o=t.to.ch,l=0==P(t.from,t.to),s=Z(r,i,l),a=Q(n,o,l),u=1==t.text.length,c=g(t.text).length+(u?i:0);if(s)for(var f=0;f<s.length;++f){var h=s[f];if(null==h.to){var d=_(a,h.marker);d?u&&(h.to=null==d.to?null:d.to+c):h.to=i}}if(a)for(var p=0;p<a.length;++p){var v=a[p];null!=v.to&&(v.to+=c),null==v.from?_(s,v.marker)||(v.from=c,u&&(s||(s=[])).push(v)):(v.from+=c,u&&(s||(s=[])).push(v))}s&&(s=ee(s)),a&&a!=s&&(a=ee(a));var m=[s];if(!u){var y,b=t.text.length-2;if(b>0&&s)for(var w=0;w<s.length;++w)null==s[w].to&&(y||(y=[])).push(new Y(s[w].marker,null,null));for(var x=0;x<b;++x)m.push(y);m.push(a)}return m}function ee(e){for(var t=0;t<e.length;++t){var r=e[t];null!=r.from&&r.from==r.to&&!1!==r.marker.clearWhenEmpty&&e.splice(t--,1)}return e.length?e:null}function te(e,t,r){var n=null;if(e.iter(t.line,r.line+1,function(e){if(e.markedSpans)for(var t=0;t<e.markedSpans.length;++t){var r=e.markedSpans[t].marker;!r.readOnly||n&&-1!=h(n,r)||(n||(n=[])).push(r)}}),!n)return null;for(var i=[{from:t,to:r}],o=0;o<n.length;++o)for(var l=n[o],s=l.find(0),a=0;a<i.length;++a){var u=i[a];if(!(P(u.to,s.from)<0||P(u.from,s.to)>0)){var c=[a,1],f=P(u.from,s.from),d=P(u.to,s.to);(f<0||!l.inclusiveLeft&&!f)&&c.push({from:u.from,to:s.from}),(d>0||!l.inclusiveRight&&!d)&&c.push({from:s.to,to:u.to}),i.splice.apply(i,c),a+=c.length-3}}return i}function re(e){var t=e.markedSpans;if(t){for(var r=0;r<t.length;++r)t[r].marker.detachLine(e);e.markedSpans=null}}function ne(e,t){if(t){for(var r=0;r<t.length;++r)t[r].marker.attachLine(e);e.markedSpans=t}}function ie(e){return e.inclusiveLeft?-1:0}function oe(e){return e.inclusiveRight?1:0}function le(e,t){var r=e.lines.length-t.lines.length;if(0!=r)return r;var n=e.find(),i=t.find(),o=P(n.from,i.from)||ie(e)-ie(t);if(o)return-o;var l=P(n.to,i.to)||oe(e)-oe(t);return l||t.id-e.id}function se(e,t){var r,n=_l&&e.markedSpans;if(n)for(var i=void 0,o=0;o<n.length;++o)(i=n[o]).marker.collapsed&&null==(t?i.from:i.to)&&(!r||le(r,i.marker)<0)&&(r=i.marker);return r}function ae(e){return se(e,!0)}function ue(e){return se(e,!1)}function ce(e,t,r,n,i){var o=M(e,t),l=_l&&o.markedSpans;if(l)for(var s=0;s<l.length;++s){var a=l[s];if(a.marker.collapsed){var u=a.marker.find(0),c=P(u.from,r)||ie(a.marker)-ie(i),f=P(u.to,n)||oe(a.marker)-oe(i);if(!(c>=0&&f<=0||c<=0&&f>=0)&&(c<=0&&(a.marker.inclusiveRight&&i.inclusiveLeft?P(u.to,r)>=0:P(u.to,r)>0)||c>=0&&(a.marker.inclusiveRight&&i.inclusiveLeft?P(u.from,n)<=0:P(u.from,n)<0)))return!0}}}function fe(e){for(var t;t=ae(e);)e=t.find(-1,!0).line;return e}function he(e){for(var t;t=ue(e);)e=t.find(1,!0).line;return e}function de(e){for(var t,r;t=ue(e);)e=t.find(1,!0).line,(r||(r=[])).push(e);return r}function pe(e,t){var r=M(e,t),n=fe(r);return r==n?t:W(n)}function ge(e,t){if(t>e.lastLine())return t;var r,n=M(e,t);if(!ve(e,n))return t;for(;r=ue(n);)n=r.find(1,!0).line;return W(n)+1}function ve(e,t){var r=_l&&t.markedSpans;if(r)for(var n=void 0,i=0;i<r.length;++i)if((n=r[i]).marker.collapsed){if(null==n.from)return!0;if(!n.marker.widgetNode&&0==n.from&&n.marker.inclusiveLeft&&me(e,t,n))return!0}}function me(e,t,r){if(null==r.to){var n=r.marker.find(1,!0);return me(e,n.line,_(n.line.markedSpans,r.marker))}if(r.marker.inclusiveRight&&r.to==t.text.length)return!0;for(var i=void 0,o=0;o<t.markedSpans.length;++o)if((i=t.markedSpans[o]).marker.collapsed&&!i.marker.widgetNode&&i.from==r.to&&(null==i.to||i.to!=r.from)&&(i.marker.inclusiveLeft||r.marker.inclusiveRight)&&me(e,t,i))return!0}function ye(e){for(var t=0,r=(e=fe(e)).parent,n=0;n<r.lines.length;++n){var i=r.lines[n];if(i==e)break;t+=i.height}for(var o=r.parent;o;r=o,o=r.parent)for(var l=0;l<o.children.length;++l){var s=o.children[l];if(s==r)break;t+=s.height}return t}function be(e){if(0==e.height)return 0;for(var t,r=e.text.length,n=e;t=ae(n);){var i=t.find(0,!0);n=i.from.line,r+=i.from.ch-i.to.ch}for(n=e;t=ue(n);){var o=t.find(0,!0);r-=n.text.length-o.from.ch,r+=(n=o.to.line).text.length-o.to.ch}return r}function we(e){var t=e.display,r=e.doc;t.maxLine=M(r,r.first),t.maxLineLength=be(t.maxLine),t.maxLineChanged=!0,r.iter(function(e){var r=be(e);r>t.maxLineLength&&(t.maxLineLength=r,t.maxLine=e)})}function xe(e,t,r,n){if(!e)return n(t,r,"ltr",0);for(var i=!1,o=0;o<e.length;++o){var l=e[o];(l.from<r&&l.to>t||t==r&&l.to==t)&&(n(Math.max(l.from,t),Math.min(l.to,r),1==l.level?"rtl":"ltr",o),i=!0)}i||n(t,r,"ltr")}function Ce(e,t,r){var n;$l=null;for(var i=0;i<e.length;++i){var o=e[i];if(o.from<t&&o.to>t)return i;o.to==t&&(o.from!=o.to&&"before"==r?n=i:$l=i),o.from==t&&(o.from!=o.to&&"before"!=r?n=i:$l=i)}return null!=n?n:$l}function Se(e,t){var r=e.order;return null==r&&(r=e.order=ql(e.text,t)),r}function Le(e,t){return e._handlers&&e._handlers[t]||Zl}function ke(e,t,r){if(e.removeEventListener)e.removeEventListener(t,r,!1);else if(e.detachEvent)e.detachEvent("on"+t,r);else{var n=e._handlers,i=n&&n[t];if(i){var o=h(i,r);o>-1&&(n[t]=i.slice(0,o).concat(i.slice(o+1)))}}}function Te(e,t){var r=Le(e,t);if(r.length)for(var n=Array.prototype.slice.call(arguments,2),i=0;i<r.length;++i)r[i].apply(null,n)}function Me(e,t,r){return"string"==typeof t&&(t={type:t,preventDefault:function(){this.defaultPrevented=!0}}),Te(e,r||t.type,e,t),He(t)||t.codemirrorIgnore}function Ne(e){var t=e._handlers&&e._handlers.cursorActivity;if(t)for(var r=e.curOp.cursorActivityHandlers||(e.curOp.cursorActivityHandlers=[]),n=0;n<t.length;++n)-1==h(r,t[n])&&r.push(t[n])}function Oe(e,t){return Le(e,t).length>0}function Ae(e){e.prototype.on=function(e,t){Ql(this,e,t)},e.prototype.off=function(e,t){ke(this,e,t)}}function We(e){e.preventDefault?e.preventDefault():e.returnValue=!1}function De(e){e.stopPropagation?e.stopPropagation():e.cancelBubble=!0}function He(e){return null!=e.defaultPrevented?e.defaultPrevented:0==e.returnValue}function Fe(e){We(e),De(e)}function Ee(e){return e.target||e.srcElement}function Pe(e){var t=e.which;return null==t&&(1&e.button?t=1:2&e.button?t=3:4&e.button&&(t=2)),Ml&&e.ctrlKey&&1==t&&(t=3),t}function Ie(e){if(null==Il){var t=n("span","​");r(e,n("span",[t,document.createTextNode("x")])),0!=e.firstChild.offsetHeight&&(Il=t.offsetWidth<=1&&t.offsetHeight>2&&!(gl&&vl<8))}var i=Il?n("span","​"):n("span"," ",null,"display: inline-block; width: 1px; margin-right: -1px");return i.setAttribute("cm-text",""),i}function ze(e){if(null!=zl)return zl;var n=r(e,document.createTextNode("AخA")),i=Wl(n,0,1).getBoundingClientRect(),o=Wl(n,1,2).getBoundingClientRect();return t(e),!(!i||i.left==i.right)&&(zl=o.right-i.right<3)}function Re(e){if(null!=ns)return ns;var t=r(e,n("span","x")),i=t.getBoundingClientRect(),o=Wl(t,0,1).getBoundingClientRect();return ns=Math.abs(i.left-o.left)>1}function Be(e,t){arguments.length>2&&(t.dependencies=Array.prototype.slice.call(arguments,2)),is[e]=t}function Ge(e){if("string"==typeof e&&os.hasOwnProperty(e))e=os[e];else if(e&&"string"==typeof e.name&&os.hasOwnProperty(e.name)){var t=os[e.name];"string"==typeof t&&(t={name:t}),(e=b(t,e)).name=t.name}else{if("string"==typeof e&&/^[\w\-]+\/[\w\-]+\+xml$/.test(e))return Ge("application/xml");if("string"==typeof e&&/^[\w\-]+\/[\w\-]+\+json$/.test(e))return Ge("application/json")}return"string"==typeof e?{name:e}:e||{name:"null"}}function Ue(e,t){t=Ge(t);var r=is[t.name];if(!r)return Ue(e,"text/plain");var n=r(e,t);if(ls.hasOwnProperty(t.name)){var i=ls[t.name];for(var o in i)i.hasOwnProperty(o)&&(n.hasOwnProperty(o)&&(n["_"+o]=n[o]),n[o]=i[o])}if(n.name=t.name,t.helperType&&(n.helperType=t.helperType),t.modeProps)for(var l in t.modeProps)n[l]=t.modeProps[l];return n}function Ve(e,t){c(t,ls.hasOwnProperty(e)?ls[e]:ls[e]={})}function Ke(e,t){if(!0===t)return t;if(e.copyState)return e.copyState(t);var r={};for(var n in t){var i=t[n];i instanceof Array&&(i=i.concat([])),r[n]=i}return r}function je(e,t){for(var r;e.innerMode&&(r=e.innerMode(t))&&r.mode!=e;)t=r.state,e=r.mode;return r||{mode:e,state:t}}function Xe(e,t,r){return!e.startState||e.startState(t,r)}function Ye(e,t,r,n){var i=[e.state.modeGen],o={};tt(e,t.text,e.doc.mode,r,function(e,t){return i.push(e,t)},o,n);for(var l=r.state,s=0;s<e.state.overlays.length;++s)!function(n){var l=e.state.overlays[n],s=1,a=0;r.state=!0,tt(e,t.text,l.mode,r,function(e,t){for(var r=s;a<e;){var n=i[s];n>e&&i.splice(s,1,e,i[s+1],n),s+=2,a=Math.min(e,n)}if(t)if(l.opaque)i.splice(r,s-r,e,"overlay "+t),s=r+2;else for(;r<s;r+=2){var o=i[r+1];i[r+1]=(o?o+" ":"")+"overlay "+t}},o)}(s);return r.state=l,{styles:i,classes:o.bgClass||o.textClass?o:null}}function _e(e,t,r){if(!t.styles||t.styles[0]!=e.state.modeGen){var n=$e(e,W(t)),i=t.text.length>e.options.maxHighlightLength&&Ke(e.doc.mode,n.state),o=Ye(e,t,n);i&&(n.state=i),t.stateAfter=n.save(!i),t.styles=o.styles,o.classes?t.styleClasses=o.classes:t.styleClasses&&(t.styleClasses=null),r===e.doc.highlightFrontier&&(e.doc.modeFrontier=Math.max(e.doc.modeFrontier,++e.doc.highlightFrontier))}return t.styles}function $e(e,t,r){var n=e.doc,i=e.display;if(!n.mode.startState)return new us(n,!0,t);var o=rt(e,t,r),l=o>n.first&&M(n,o-1).stateAfter,s=l?us.fromSaved(n,l,o):new us(n,Xe(n.mode),o);return n.iter(o,t,function(r){qe(e,r.text,s);var n=s.line;r.stateAfter=n==t-1||n%5==0||n>=i.viewFrom&&n<i.viewTo?s.save():null,s.nextLine()}),r&&(n.modeFrontier=s.line),s}function qe(e,t,r,n){var i=e.doc.mode,o=new ss(t,e.options.tabSize,r);for(o.start=o.pos=n||0,""==t&&Ze(i,r.state);!o.eol();)Qe(i,o,r.state),o.start=o.pos}function Ze(e,t){if(e.blankLine)return e.blankLine(t);if(e.innerMode){var r=je(e,t);return r.mode.blankLine?r.mode.blankLine(r.state):void 0}}function Qe(e,t,r,n){for(var i=0;i<10;i++){n&&(n[0]=je(e,r).mode);var o=e.token(t,r);if(t.pos>t.start)return o}throw new Error("Mode "+e.name+" failed to advance stream.")}function Je(e,t,r,n){var i,o,l=e.doc,s=l.mode,a=M(l,(t=U(l,t)).line),u=$e(e,t.line,r),c=new ss(a.text,e.options.tabSize,u);for(n&&(o=[]);(n||c.pos<t.ch)&&!c.eol();)c.start=c.pos,i=Qe(s,c,u.state),n&&o.push(new cs(c,i,Ke(l.mode,u.state)));return n?o:new cs(c,i,u.state)}function et(e,t){if(e)for(;;){var r=e.match(/(?:^|\s+)line-(background-)?(\S+)/);if(!r)break;e=e.slice(0,r.index)+e.slice(r.index+r[0].length);var n=r[1]?"bgClass":"textClass";null==t[n]?t[n]=r[2]:new RegExp("(?:^|s)"+r[2]+"(?:$|s)").test(t[n])||(t[n]+=" "+r[2])}return e}function tt(e,t,r,n,i,o,l){var s=r.flattenSpans;null==s&&(s=e.options.flattenSpans);var a,u=0,c=null,f=new ss(t,e.options.tabSize,n),h=e.options.addModeClass&&[null];for(""==t&&et(Ze(r,n.state),o);!f.eol();){if(f.pos>e.options.maxHighlightLength?(s=!1,l&&qe(e,t,n,f.pos),f.pos=t.length,a=null):a=et(Qe(r,f,n.state,h),o),h){var d=h[0].name;d&&(a="m-"+(a?d+" "+a:d))}if(!s||c!=a){for(;u<f.start;)i(u=Math.min(f.start,u+5e3),c);c=a}f.start=f.pos}for(;u<f.pos;){var p=Math.min(f.pos,u+5e3);i(p,c),u=p}}function rt(e,t,r){for(var n,i,o=e.doc,l=r?-1:t-(e.doc.mode.innerMode?1e3:100),s=t;s>l;--s){if(s<=o.first)return o.first;var a=M(o,s-1),u=a.stateAfter;if(u&&(!r||s+(u instanceof as?u.lookAhead:0)<=o.modeFrontier))return s;var c=f(a.text,null,e.options.tabSize);(null==i||n>c)&&(i=s-1,n=c)}return i}function nt(e,t){if(e.modeFrontier=Math.min(e.modeFrontier,t),!(e.highlightFrontier<t-10)){for(var r=e.first,n=t-1;n>r;n--){var i=M(e,n).stateAfter;if(i&&(!(i instanceof as)||n+i.lookAhead<t)){r=n+1;break}}e.highlightFrontier=Math.min(e.highlightFrontier,r)}}function it(e,t,r,n){e.text=t,e.stateAfter&&(e.stateAfter=null),e.styles&&(e.styles=null),null!=e.order&&(e.order=null),re(e),ne(e,r);var i=n?n(e):1;i!=e.height&&A(e,i)}function ot(e){e.parent=null,re(e)}function lt(e,t){if(!e||/^\s*$/.test(e))return null;var r=t.addModeClass?ps:ds;return r[e]||(r[e]=e.replace(/\S+/g,"cm-$&"))}function st(e,t){var r=i("span",null,null,ml?"padding-right: .1px":null),n={pre:i("pre",[r],"CodeMirror-line"),content:r,col:0,pos:0,cm:e,trailingSpace:!1,splitSpaces:(gl||ml)&&e.getOption("lineWrapping")};t.measure={};for(var o=0;o<=(t.rest?t.rest.length:0);o++){var l=o?t.rest[o-1]:t.line,s=void 0;n.pos=0,n.addToken=ut,ze(e.display.measure)&&(s=Se(l,e.doc.direction))&&(n.addToken=ft(n.addToken,s)),n.map=[],dt(l,n,_e(e,l,t!=e.display.externalMeasured&&W(l))),l.styleClasses&&(l.styleClasses.bgClass&&(n.bgClass=a(l.styleClasses.bgClass,n.bgClass||"")),l.styleClasses.textClass&&(n.textClass=a(l.styleClasses.textClass,n.textClass||""))),0==n.map.length&&n.map.push(0,0,n.content.appendChild(Ie(e.display.measure))),0==o?(t.measure.map=n.map,t.measure.cache={}):((t.measure.maps||(t.measure.maps=[])).push(n.map),(t.measure.caches||(t.measure.caches=[])).push({}))}if(ml){var u=n.content.lastChild;(/\bcm-tab\b/.test(u.className)||u.querySelector&&u.querySelector(".cm-tab"))&&(n.content.className="cm-tab-wrap-hack")}return Te(e,"renderLine",e,t.line,n.pre),n.pre.className&&(n.textClass=a(n.pre.className,n.textClass||"")),n}function at(e){var t=n("span","•","cm-invalidchar");return t.title="\\u"+e.charCodeAt(0).toString(16),t.setAttribute("aria-label",t.title),t}function ut(e,t,r,i,o,l,s){if(t){var a,u=e.splitSpaces?ct(t,e.trailingSpace):t,c=e.cm.state.specialChars,f=!1;if(c.test(t)){a=document.createDocumentFragment();for(var h=0;;){c.lastIndex=h;var d=c.exec(t),g=d?d.index-h:t.length-h;if(g){var v=document.createTextNode(u.slice(h,h+g));gl&&vl<9?a.appendChild(n("span",[v])):a.appendChild(v),e.map.push(e.pos,e.pos+g,v),e.col+=g,e.pos+=g}if(!d)break;h+=g+1;var m=void 0;if("\t"==d[0]){var y=e.cm.options.tabSize,b=y-e.col%y;(m=a.appendChild(n("span",p(b),"cm-tab"))).setAttribute("role","presentation"),m.setAttribute("cm-text","\t"),e.col+=b}else"\r"==d[0]||"\n"==d[0]?((m=a.appendChild(n("span","\r"==d[0]?"␍":"␤","cm-invalidchar"))).setAttribute("cm-text",d[0]),e.col+=1):((m=e.cm.options.specialCharPlaceholder(d[0])).setAttribute("cm-text",d[0]),gl&&vl<9?a.appendChild(n("span",[m])):a.appendChild(m),e.col+=1);e.map.push(e.pos,e.pos+1,m),e.pos++}}else e.col+=t.length,a=document.createTextNode(u),e.map.push(e.pos,e.pos+t.length,a),gl&&vl<9&&(f=!0),e.pos+=t.length;if(e.trailingSpace=32==u.charCodeAt(t.length-1),r||i||o||f||s){var w=r||"";i&&(w+=i),o&&(w+=o);var x=n("span",[a],w,s);return l&&(x.title=l),e.content.appendChild(x)}e.content.appendChild(a)}}function ct(e,t){if(e.length>1&&!/  /.test(e))return e;for(var r=t,n="",i=0;i<e.length;i++){var o=e.charAt(i);" "!=o||!r||i!=e.length-1&&32!=e.charCodeAt(i+1)||(o=" "),n+=o,r=" "==o}return n}function ft(e,t){return function(r,n,i,o,l,s,a){i=i?i+" cm-force-border":"cm-force-border";for(var u=r.pos,c=u+n.length;;){for(var f=void 0,h=0;h<t.length&&!((f=t[h]).to>u&&f.from<=u);h++);if(f.to>=c)return e(r,n,i,o,l,s,a);e(r,n.slice(0,f.to-u),i,o,null,s,a),o=null,n=n.slice(f.to-u),u=f.to}}}function ht(e,t,r,n){var i=!n&&r.widgetNode;i&&e.map.push(e.pos,e.pos+t,i),!n&&e.cm.display.input.needsContentAttribute&&(i||(i=e.content.appendChild(document.createElement("span"))),i.setAttribute("cm-marker",r.id)),i&&(e.cm.display.input.setUneditable(i),e.content.appendChild(i)),e.pos+=t,e.trailingSpace=!1}function dt(e,t,r){var n=e.markedSpans,i=e.text,o=0;if(n)for(var l,s,a,u,c,f,h,d=i.length,p=0,g=1,v="",m=0;;){if(m==p){a=u=c=f=s="",h=null,m=1/0;for(var y=[],b=void 0,w=0;w<n.length;++w){var x=n[w],C=x.marker;"bookmark"==C.type&&x.from==p&&C.widgetNode?y.push(C):x.from<=p&&(null==x.to||x.to>p||C.collapsed&&x.to==p&&x.from==p)?(null!=x.to&&x.to!=p&&m>x.to&&(m=x.to,u=""),C.className&&(a+=" "+C.className),C.css&&(s=(s?s+";":"")+C.css),C.startStyle&&x.from==p&&(c+=" "+C.startStyle),C.endStyle&&x.to==m&&(b||(b=[])).push(C.endStyle,x.to),C.title&&!f&&(f=C.title),C.collapsed&&(!h||le(h.marker,C)<0)&&(h=x)):x.from>p&&m>x.from&&(m=x.from)}if(b)for(var S=0;S<b.length;S+=2)b[S+1]==m&&(u+=" "+b[S]);if(!h||h.from==p)for(var L=0;L<y.length;++L)ht(t,0,y[L]);if(h&&(h.from||0)==p){if(ht(t,(null==h.to?d+1:h.to)-p,h.marker,null==h.from),null==h.to)return;h.to==p&&(h=!1)}}if(p>=d)break;for(var k=Math.min(d,m);;){if(v){var T=p+v.length;if(!h){var M=T>k?v.slice(0,k-p):v;t.addToken(t,M,l?l+a:a,c,p+M.length==m?u:"",f,s)}if(T>=k){v=v.slice(k-p),p=k;break}p=T,c=""}v=i.slice(o,o=r[g++]),l=lt(r[g++],t.cm.options)}}else for(var N=1;N<r.length;N+=2)t.addToken(t,i.slice(o,o=r[N]),lt(r[N+1],t.cm.options))}function pt(e,t,r){this.line=t,this.rest=de(t),this.size=this.rest?W(g(this.rest))-r+1:1,this.node=this.text=null,this.hidden=ve(e,t)}function gt(e,t,r){for(var n,i=[],o=t;o<r;o=n){var l=new pt(e.doc,M(e.doc,o),o);n=o+l.size,i.push(l)}return i}function vt(e){gs?gs.ops.push(e):e.ownsGroup=gs={ops:[e],delayedCallbacks:[]}}function mt(e){var t=e.delayedCallbacks,r=0;do{for(;r<t.length;r++)t[r].call(null);for(var n=0;n<e.ops.length;n++){var i=e.ops[n];if(i.cursorActivityHandlers)for(;i.cursorActivityCalled<i.cursorActivityHandlers.length;)i.cursorActivityHandlers[i.cursorActivityCalled++].call(null,i.cm)}}while(r<t.length)}function yt(e,t){var r=e.ownsGroup;if(r)try{mt(r)}finally{gs=null,t(r)}}function bt(e,t){var r=Le(e,t);if(r.length){var n,i=Array.prototype.slice.call(arguments,2);gs?n=gs.delayedCallbacks:vs?n=vs:(n=vs=[],setTimeout(wt,0));for(var o=0;o<r.length;++o)!function(e){n.push(function(){return r[e].apply(null,i)})}(o)}}function wt(){var e=vs;vs=null;for(var t=0;t<e.length;++t)e[t]()}function xt(e,t,r,n){for(var i=0;i<t.changes.length;i++){var o=t.changes[i];"text"==o?kt(e,t):"gutter"==o?Mt(e,t,r,n):"class"==o?Tt(e,t):"widget"==o&&Nt(e,t,n)}t.changes=null}function Ct(e){return e.node==e.text&&(e.node=n("div",null,null,"position: relative"),e.text.parentNode&&e.text.parentNode.replaceChild(e.node,e.text),e.node.appendChild(e.text),gl&&vl<8&&(e.node.style.zIndex=2)),e.node}function St(e,t){var r=t.bgClass?t.bgClass+" "+(t.line.bgClass||""):t.line.bgClass;if(r&&(r+=" CodeMirror-linebackground"),t.background)r?t.background.className=r:(t.background.parentNode.removeChild(t.background),t.background=null);else if(r){var i=Ct(t);t.background=i.insertBefore(n("div",null,r),i.firstChild),e.display.input.setUneditable(t.background)}}function Lt(e,t){var r=e.display.externalMeasured;return r&&r.line==t.line?(e.display.externalMeasured=null,t.measure=r.measure,r.built):st(e,t)}function kt(e,t){var r=t.text.className,n=Lt(e,t);t.text==t.node&&(t.node=n.pre),t.text.parentNode.replaceChild(n.pre,t.text),t.text=n.pre,n.bgClass!=t.bgClass||n.textClass!=t.textClass?(t.bgClass=n.bgClass,t.textClass=n.textClass,Tt(e,t)):r&&(t.text.className=r)}function Tt(e,t){St(e,t),t.line.wrapClass?Ct(t).className=t.line.wrapClass:t.node!=t.text&&(t.node.className="");var r=t.textClass?t.textClass+" "+(t.line.textClass||""):t.line.textClass;t.text.className=r||""}function Mt(e,t,r,i){if(t.gutter&&(t.node.removeChild(t.gutter),t.gutter=null),t.gutterBackground&&(t.node.removeChild(t.gutterBackground),t.gutterBackground=null),t.line.gutterClass){var o=Ct(t);t.gutterBackground=n("div",null,"CodeMirror-gutter-background "+t.line.gutterClass,"left: "+(e.options.fixedGutter?i.fixedPos:-i.gutterTotalWidth)+"px; width: "+i.gutterTotalWidth+"px"),e.display.input.setUneditable(t.gutterBackground),o.insertBefore(t.gutterBackground,t.text)}var l=t.line.gutterMarkers;if(e.options.lineNumbers||l){var s=Ct(t),a=t.gutter=n("div",null,"CodeMirror-gutter-wrapper","left: "+(e.options.fixedGutter?i.fixedPos:-i.gutterTotalWidth)+"px");if(e.display.input.setUneditable(a),s.insertBefore(a,t.text),t.line.gutterClass&&(a.className+=" "+t.line.gutterClass),!e.options.lineNumbers||l&&l["CodeMirror-linenumbers"]||(t.lineNumber=a.appendChild(n("div",F(e.options,r),"CodeMirror-linenumber CodeMirror-gutter-elt","left: "+i.gutterLeft["CodeMirror-linenumbers"]+"px; width: "+e.display.lineNumInnerWidth+"px"))),l)for(var u=0;u<e.options.gutters.length;++u){var c=e.options.gutters[u],f=l.hasOwnProperty(c)&&l[c];f&&a.appendChild(n("div",[f],"CodeMirror-gutter-elt","left: "+i.gutterLeft[c]+"px; width: "+i.gutterWidth[c]+"px"))}}}function Nt(e,t,r){t.alignable&&(t.alignable=null);for(var n=t.node.firstChild,i=void 0;n;n=i)i=n.nextSibling,"CodeMirror-linewidget"==n.className&&t.node.removeChild(n);At(e,t,r)}function Ot(e,t,r,n){var i=Lt(e,t);return t.text=t.node=i.pre,i.bgClass&&(t.bgClass=i.bgClass),i.textClass&&(t.textClass=i.textClass),Tt(e,t),Mt(e,t,r,n),At(e,t,n),t.node}function At(e,t,r){if(Wt(e,t.line,t,r,!0),t.rest)for(var n=0;n<t.rest.length;n++)Wt(e,t.rest[n],t,r,!1)}function Wt(e,t,r,i,o){if(t.widgets)for(var l=Ct(r),s=0,a=t.widgets;s<a.length;++s){var u=a[s],c=n("div",[u.node],"CodeMirror-linewidget");u.handleMouseEvents||c.setAttribute("cm-ignore-events","true"),Dt(u,c,r,i),e.display.input.setUneditable(c),o&&u.above?l.insertBefore(c,r.gutter||r.text):l.appendChild(c),bt(u,"redraw")}}function Dt(e,t,r,n){if(e.noHScroll){(r.alignable||(r.alignable=[])).push(t);var i=n.wrapperWidth;t.style.left=n.fixedPos+"px",e.coverGutter||(i-=n.gutterTotalWidth,t.style.paddingLeft=n.gutterTotalWidth+"px"),t.style.width=i+"px"}e.coverGutter&&(t.style.zIndex=5,t.style.position="relative",e.noHScroll||(t.style.marginLeft=-n.gutterTotalWidth+"px"))}function Ht(e){if(null!=e.height)return e.height;var t=e.doc.cm;if(!t)return 0;if(!o(document.body,e.node)){var i="position: relative;";e.coverGutter&&(i+="margin-left: -"+t.display.gutters.offsetWidth+"px;"),e.noHScroll&&(i+="width: "+t.display.wrapper.clientWidth+"px;"),r(t.display.measure,n("div",[e.node],null,i))}return e.height=e.node.parentNode.offsetHeight}function Ft(e,t){for(var r=Ee(t);r!=e.wrapper;r=r.parentNode)if(!r||1==r.nodeType&&"true"==r.getAttribute("cm-ignore-events")||r.parentNode==e.sizer&&r!=e.mover)return!0}function Et(e){return e.lineSpace.offsetTop}function Pt(e){return e.mover.offsetHeight-e.lineSpace.offsetHeight}function It(e){if(e.cachedPaddingH)return e.cachedPaddingH;var t=r(e.measure,n("pre","x")),i=window.getComputedStyle?window.getComputedStyle(t):t.currentStyle,o={left:parseInt(i.paddingLeft),right:parseInt(i.paddingRight)};return isNaN(o.left)||isNaN(o.right)||(e.cachedPaddingH=o),o}function zt(e){return Rl-e.display.nativeBarWidth}function Rt(e){return e.display.scroller.clientWidth-zt(e)-e.display.barWidth}function Bt(e){return e.display.scroller.clientHeight-zt(e)-e.display.barHeight}function Gt(e,t,r){var n=e.options.lineWrapping,i=n&&Rt(e);if(!t.measure.heights||n&&t.measure.width!=i){var o=t.measure.heights=[];if(n){t.measure.width=i;for(var l=t.text.firstChild.getClientRects(),s=0;s<l.length-1;s++){var a=l[s],u=l[s+1];Math.abs(a.bottom-u.bottom)>2&&o.push((a.bottom+u.top)/2-r.top)}}o.push(r.bottom-r.top)}}function Ut(e,t,r){if(e.line==t)return{map:e.measure.map,cache:e.measure.cache};for(var n=0;n<e.rest.length;n++)if(e.rest[n]==t)return{map:e.measure.maps[n],cache:e.measure.caches[n]};for(var i=0;i<e.rest.length;i++)if(W(e.rest[i])>r)return{map:e.measure.maps[i],cache:e.measure.caches[i],before:!0}}function Vt(e,t){var n=W(t=fe(t)),i=e.display.externalMeasured=new pt(e.doc,t,n);i.lineN=n;var o=i.built=st(e,i);return i.text=o.pre,r(e.display.lineMeasure,o.pre),i}function Kt(e,t,r,n){return Yt(e,Xt(e,t),r,n)}function jt(e,t){if(t>=e.display.viewFrom&&t<e.display.viewTo)return e.display.view[Lr(e,t)];var r=e.display.externalMeasured;return r&&t>=r.lineN&&t<r.lineN+r.size?r:void 0}function Xt(e,t){var r=W(t),n=jt(e,r);n&&!n.text?n=null:n&&n.changes&&(xt(e,n,r,br(e)),e.curOp.forceUpdate=!0),n||(n=Vt(e,t));var i=Ut(n,t,r);return{line:t,view:n,rect:null,map:i.map,cache:i.cache,before:i.before,hasHeights:!1}}function Yt(e,t,r,n,i){t.before&&(r=-1);var o,l=r+(n||"");return t.cache.hasOwnProperty(l)?o=t.cache[l]:(t.rect||(t.rect=t.view.text.getBoundingClientRect()),t.hasHeights||(Gt(e,t.view,t.rect),t.hasHeights=!0),(o=qt(e,t,r,n)).bogus||(t.cache[l]=o)),{left:o.left,right:o.right,top:i?o.rtop:o.top,bottom:i?o.rbottom:o.bottom}}function _t(e,t,r){for(var n,i,o,l,s,a,u=0;u<e.length;u+=3)if(s=e[u],a=e[u+1],t<s?(i=0,o=1,l="left"):t<a?o=(i=t-s)+1:(u==e.length-3||t==a&&e[u+3]>t)&&(i=(o=a-s)-1,t>=a&&(l="right")),null!=i){if(n=e[u+2],s==a&&r==(n.insertLeft?"left":"right")&&(l=r),"left"==r&&0==i)for(;u&&e[u-2]==e[u-3]&&e[u-1].insertLeft;)n=e[2+(u-=3)],l="left";if("right"==r&&i==a-s)for(;u<e.length-3&&e[u+3]==e[u+4]&&!e[u+5].insertLeft;)n=e[(u+=3)+2],l="right";break}return{node:n,start:i,end:o,collapse:l,coverStart:s,coverEnd:a}}function $t(e,t){var r=ms;if("left"==t)for(var n=0;n<e.length&&(r=e[n]).left==r.right;n++);else for(var i=e.length-1;i>=0&&(r=e[i]).left==r.right;i--);return r}function qt(e,t,r,n){var i,o=_t(t.map,r,n),l=o.node,s=o.start,a=o.end,u=o.collapse;if(3==l.nodeType){for(var c=0;c<4;c++){for(;s&&S(t.line.text.charAt(o.coverStart+s));)--s;for(;o.coverStart+a<o.coverEnd&&S(t.line.text.charAt(o.coverStart+a));)++a;if((i=gl&&vl<9&&0==s&&a==o.coverEnd-o.coverStart?l.parentNode.getBoundingClientRect():$t(Wl(l,s,a).getClientRects(),n)).left||i.right||0==s)break;a=s,s-=1,u="right"}gl&&vl<11&&(i=Zt(e.display.measure,i))}else{s>0&&(u=n="right");var f;i=e.options.lineWrapping&&(f=l.getClientRects()).length>1?f["right"==n?f.length-1:0]:l.getBoundingClientRect()}if(gl&&vl<9&&!s&&(!i||!i.left&&!i.right)){var h=l.parentNode.getClientRects()[0];i=h?{left:h.left,right:h.left+yr(e.display),top:h.top,bottom:h.bottom}:ms}for(var d=i.top-t.rect.top,p=i.bottom-t.rect.top,g=(d+p)/2,v=t.view.measure.heights,m=0;m<v.length-1&&!(g<v[m]);m++);var y=m?v[m-1]:0,b=v[m],w={left:("right"==u?i.right:i.left)-t.rect.left,right:("left"==u?i.left:i.right)-t.rect.left,top:y,bottom:b};return i.left||i.right||(w.bogus=!0),e.options.singleCursorHeightPerLine||(w.rtop=d,w.rbottom=p),w}function Zt(e,t){if(!window.screen||null==screen.logicalXDPI||screen.logicalXDPI==screen.deviceXDPI||!Re(e))return t;var r=screen.logicalXDPI/screen.deviceXDPI,n=screen.logicalYDPI/screen.deviceYDPI;return{left:t.left*r,right:t.right*r,top:t.top*n,bottom:t.bottom*n}}function Qt(e){if(e.measure&&(e.measure.cache={},e.measure.heights=null,e.rest))for(var t=0;t<e.rest.length;t++)e.measure.caches[t]={}}function Jt(e){e.display.externalMeasure=null,t(e.display.lineMeasure);for(var r=0;r<e.display.view.length;r++)Qt(e.display.view[r])}function er(e){Jt(e),e.display.cachedCharWidth=e.display.cachedTextHeight=e.display.cachedPaddingH=null,e.options.lineWrapping||(e.display.maxLineChanged=!0),e.display.lineNumChars=null}function tr(){return bl&&kl?-(document.body.getBoundingClientRect().left-parseInt(getComputedStyle(document.body).marginLeft)):window.pageXOffset||(document.documentElement||document.body).scrollLeft}function rr(){return bl&&kl?-(document.body.getBoundingClientRect().top-parseInt(getComputedStyle(document.body).marginTop)):window.pageYOffset||(document.documentElement||document.body).scrollTop}function nr(e){var t=0;if(e.widgets)for(var r=0;r<e.widgets.length;++r)e.widgets[r].above&&(t+=Ht(e.widgets[r]));return t}function ir(e,t,r,n,i){if(!i){var o=nr(t);r.top+=o,r.bottom+=o}if("line"==n)return r;n||(n="local");var l=ye(t);if("local"==n?l+=Et(e.display):l-=e.display.viewOffset,"page"==n||"window"==n){var s=e.display.lineSpace.getBoundingClientRect();l+=s.top+("window"==n?0:rr());var a=s.left+("window"==n?0:tr());r.left+=a,r.right+=a}return r.top+=l,r.bottom+=l,r}function or(e,t,r){if("div"==r)return t;var n=t.left,i=t.top;if("page"==r)n-=tr(),i-=rr();else if("local"==r||!r){var o=e.display.sizer.getBoundingClientRect();n+=o.left,i+=o.top}var l=e.display.lineSpace.getBoundingClientRect();return{left:n-l.left,top:i-l.top}}function lr(e,t,r,n,i){return n||(n=M(e.doc,t.line)),ir(e,n,Kt(e,n,t.ch,i),r)}function sr(e,t,r,n,i,o){function l(t,l){var s=Yt(e,i,t,l?"right":"left",o);return l?s.left=s.right:s.right=s.left,ir(e,n,s,r)}function s(e,t,r){var n=1==a[t].level;return l(r?e-1:e,n!=r)}n=n||M(e.doc,t.line),i||(i=Xt(e,n));var a=Se(n,e.doc.direction),u=t.ch,c=t.sticky;if(u>=n.text.length?(u=n.text.length,c="before"):u<=0&&(u=0,c="after"),!a)return l("before"==c?u-1:u,"before"==c);var f=Ce(a,u,c),h=$l,d=s(u,f,"before"==c);return null!=h&&(d.other=s(u,h,"before"!=c)),d}function ar(e,t){var r=0;t=U(e.doc,t),e.options.lineWrapping||(r=yr(e.display)*t.ch);var n=M(e.doc,t.line),i=ye(n)+Et(e.display);return{left:r,right:r,top:i,bottom:i+n.height}}function ur(e,t,r,n,i){var o=E(e,t,r);return o.xRel=i,n&&(o.outside=!0),o}function cr(e,t,r){var n=e.doc;if((r+=e.display.viewOffset)<0)return ur(n.first,0,null,!0,-1);var i=D(n,r),o=n.first+n.size-1;if(i>o)return ur(n.first+n.size-1,M(n,o).text.length,null,!0,1);t<0&&(t=0);for(var l=M(n,i);;){var s=pr(e,l,i,t,r),a=ue(l),u=a&&a.find(0,!0);if(!a||!(s.ch>u.from.ch||s.ch==u.from.ch&&s.xRel>0))return s;i=W(l=u.to.line)}}function fr(e,t,r,n){n-=nr(t);var i=t.text.length,o=k(function(t){return Yt(e,r,t-1).bottom<=n},i,0);return i=k(function(t){return Yt(e,r,t).top>n},o,i),{begin:o,end:i}}function hr(e,t,r,n){return r||(r=Xt(e,t)),fr(e,t,r,ir(e,t,Yt(e,r,n),"line").top)}function dr(e,t,r,n){return!(e.bottom<=r)&&(e.top>r||(n?e.left:e.right)>t)}function pr(e,t,r,n,i){i-=ye(t);var o=Xt(e,t),l=nr(t),s=0,a=t.text.length,u=!0,c=Se(t,e.doc.direction);if(c){var f=(e.options.lineWrapping?vr:gr)(e,t,r,o,c,n,i);s=(u=1!=f.level)?f.from:f.to-1,a=u?f.to:f.from-1}var h,d,p=null,g=null,v=k(function(t){var r=Yt(e,o,t);return r.top+=l,r.bottom+=l,!!dr(r,n,i,!1)&&(r.top<=i&&r.left<=n&&(p=t,g=r),!0)},s,a),m=!1;if(g){var y=n-g.left<g.right-n,b=y==u;v=p+(b?0:1),d=b?"after":"before",h=y?g.left:g.right}else{u||v!=a&&v!=s||v++,d=0==v?"after":v==t.text.length?"before":Yt(e,o,v-(u?1:0)).bottom+l<=i==u?"after":"before";var w=sr(e,E(r,v,d),"line",t,o);h=w.left,m=i<w.top||i>=w.bottom}return v=L(t.text,v,1),ur(r,v,d,m,n-h)}function gr(e,t,r,n,i,o,l){var s=k(function(s){var a=i[s],u=1!=a.level;return dr(sr(e,E(r,u?a.to:a.from,u?"before":"after"),"line",t,n),o,l,!0)},0,i.length-1),a=i[s];if(s>0){var u=1!=a.level,c=sr(e,E(r,u?a.from:a.to,u?"after":"before"),"line",t,n);dr(c,o,l,!0)&&c.top>l&&(a=i[s-1])}return a}function vr(e,t,r,n,i,o,l){for(var s=fr(e,t,n,l),a=s.begin,u=s.end,c=null,f=null,h=0;h<i.length;h++){var d=i[h];if(!(d.from>=u||d.to<=a)){var p=Yt(e,n,1!=d.level?Math.min(u,d.to)-1:Math.max(a,d.from)).right,g=p<o?o-p+1e9:p-o;(!c||f>g)&&(c=d,f=g)}}return c||(c=i[i.length-1]),c.from<a&&(c={from:a,to:c.to,level:c.level}),c.to>u&&(c={from:c.from,to:u,level:c.level}),c}function mr(e){if(null!=e.cachedTextHeight)return e.cachedTextHeight;if(null==hs){hs=n("pre");for(var i=0;i<49;++i)hs.appendChild(document.createTextNode("x")),hs.appendChild(n("br"));hs.appendChild(document.createTextNode("x"))}r(e.measure,hs);var o=hs.offsetHeight/50;return o>3&&(e.cachedTextHeight=o),t(e.measure),o||1}function yr(e){if(null!=e.cachedCharWidth)return e.cachedCharWidth;var t=n("span","xxxxxxxxxx"),i=n("pre",[t]);r(e.measure,i);var o=t.getBoundingClientRect(),l=(o.right-o.left)/10;return l>2&&(e.cachedCharWidth=l),l||10}function br(e){for(var t=e.display,r={},n={},i=t.gutters.clientLeft,o=t.gutters.firstChild,l=0;o;o=o.nextSibling,++l)r[e.options.gutters[l]]=o.offsetLeft+o.clientLeft+i,n[e.options.gutters[l]]=o.clientWidth;return{fixedPos:wr(t),gutterTotalWidth:t.gutters.offsetWidth,gutterLeft:r,gutterWidth:n,wrapperWidth:t.wrapper.clientWidth}}function wr(e){return e.scroller.getBoundingClientRect().left-e.sizer.getBoundingClientRect().left}function xr(e){var t=mr(e.display),r=e.options.lineWrapping,n=r&&Math.max(5,e.display.scroller.clientWidth/yr(e.display)-3);return function(i){if(ve(e.doc,i))return 0;var o=0;if(i.widgets)for(var l=0;l<i.widgets.length;l++)i.widgets[l].height&&(o+=i.widgets[l].height);return r?o+(Math.ceil(i.text.length/n)||1)*t:o+t}}function Cr(e){var t=e.doc,r=xr(e);t.iter(function(e){var t=r(e);t!=e.height&&A(e,t)})}function Sr(e,t,r,n){var i=e.display;if(!r&&"true"==Ee(t).getAttribute("cm-not-content"))return null;var o,l,s=i.lineSpace.getBoundingClientRect();try{o=t.clientX-s.left,l=t.clientY-s.top}catch(t){return null}var a,u=cr(e,o,l);if(n&&1==u.xRel&&(a=M(e.doc,u.line).text).length==u.ch){var c=f(a,a.length,e.options.tabSize)-a.length;u=E(u.line,Math.max(0,Math.round((o-It(e.display).left)/yr(e.display))-c))}return u}function Lr(e,t){if(t>=e.display.viewTo)return null;if((t-=e.display.viewFrom)<0)return null;for(var r=e.display.view,n=0;n<r.length;n++)if((t-=r[n].size)<0)return n}function kr(e){e.display.input.showSelection(e.display.input.prepareSelection())}function Tr(e,t){void 0===t&&(t=!0);for(var r=e.doc,n={},i=n.cursors=document.createDocumentFragment(),o=n.selection=document.createDocumentFragment(),l=0;l<r.sel.ranges.length;l++)if(t||l!=r.sel.primIndex){var s=r.sel.ranges[l];if(!(s.from().line>=e.display.viewTo||s.to().line<e.display.viewFrom)){var a=s.empty();(a||e.options.showCursorWhenSelecting)&&Mr(e,s.head,i),a||Or(e,s,o)}}return n}function Mr(e,t,r){var i=sr(e,t,"div",null,null,!e.options.singleCursorHeightPerLine),o=r.appendChild(n("div"," ","CodeMirror-cursor"));if(o.style.left=i.left+"px",o.style.top=i.top+"px",o.style.height=Math.max(0,i.bottom-i.top)*e.options.cursorHeight+"px",i.other){var l=r.appendChild(n("div"," ","CodeMirror-cursor CodeMirror-secondarycursor"));l.style.display="",l.style.left=i.other.left+"px",l.style.top=i.other.top+"px",l.style.height=.85*(i.other.bottom-i.other.top)+"px"}}function Nr(e,t){return e.top-t.top||e.left-t.left}function Or(e,t,r){function i(e,t,r,i){t<0&&(t=0),t=Math.round(t),i=Math.round(i),a.appendChild(n("div",null,"CodeMirror-selected","position: absolute; left: "+e+"px;\n                             top: "+t+"px; width: "+(null==r?f-e:r)+"px;\n                             height: "+(i-t)+"px"))}function o(t,r,n){function o(r,n){return lr(e,E(t,r),"div",u,n)}var l,a,u=M(s,t),h=u.text.length,d=Se(u,s.direction);return xe(d,r||0,null==n?h:n,function(t,s,p,g){var v=o(t,"ltr"==p?"left":"right"),m=o(s-1,"ltr"==p?"right":"left");if("ltr"==p){var y=null==r&&0==t?c:v.left,b=null==n&&s==h?f:m.right;m.top-v.top<=3?i(y,m.top,b-y,m.bottom):(i(y,v.top,null,v.bottom),v.bottom<m.top&&i(c,v.bottom,null,m.top),i(c,m.top,m.right,m.bottom))}else if(t<s){var w=null==r&&0==t?f:v.right,x=null==n&&s==h?c:m.left;if(m.top-v.top<=3)i(x,m.top,w-x,m.bottom);else{var C=c;if(g){var S=hr(e,u,null,t).end;C=o(S-(/\s/.test(u.text.charAt(S-1))?2:1),"left").left}i(C,v.top,w-C,v.bottom),v.bottom<m.top&&i(c,v.bottom,null,m.top);var L=null;d.length,L=o(hr(e,u,null,s).begin,"right").right-x,i(x,m.top,L,m.bottom)}}(!l||Nr(v,l)<0)&&(l=v),Nr(m,l)<0&&(l=m),(!a||Nr(v,a)<0)&&(a=v),Nr(m,a)<0&&(a=m)}),{start:l,end:a}}var l=e.display,s=e.doc,a=document.createDocumentFragment(),u=It(e.display),c=u.left,f=Math.max(l.sizerWidth,Rt(e)-l.sizer.offsetLeft)-u.right,h=t.from(),d=t.to();if(h.line==d.line)o(h.line,h.ch,d.ch);else{var p=M(s,h.line),g=M(s,d.line),v=fe(p)==fe(g),m=o(h.line,h.ch,v?p.text.length+1:null).end,y=o(d.line,v?0:null,d.ch).start;v&&(m.top<y.top-2?(i(m.right,m.top,null,m.bottom),i(c,y.top,y.left,y.bottom)):i(m.right,m.top,y.left-m.right,m.bottom)),m.bottom<y.top&&i(c,m.bottom,null,y.top)}r.appendChild(a)}function Ar(e){if(e.state.focused){var t=e.display;clearInterval(t.blinker);var r=!0;t.cursorDiv.style.visibility="",e.options.cursorBlinkRate>0?t.blinker=setInterval(function(){return t.cursorDiv.style.visibility=(r=!r)?"":"hidden"},e.options.cursorBlinkRate):e.options.cursorBlinkRate<0&&(t.cursorDiv.style.visibility="hidden")}}function Wr(e){e.state.focused||(e.display.input.focus(),Hr(e))}function Dr(e){e.state.delayingBlurEvent=!0,setTimeout(function(){e.state.delayingBlurEvent&&(e.state.delayingBlurEvent=!1,Fr(e))},100)}function Hr(e,t){e.state.delayingBlurEvent&&(e.state.delayingBlurEvent=!1),"nocursor"!=e.options.readOnly&&(e.state.focused||(Te(e,"focus",e,t),e.state.focused=!0,s(e.display.wrapper,"CodeMirror-focused"),e.curOp||e.display.selForContextMenu==e.doc.sel||(e.display.input.reset(),ml&&setTimeout(function(){return e.display.input.reset(!0)},20)),e.display.input.receivedFocus()),Ar(e))}function Fr(e,t){e.state.delayingBlurEvent||(e.state.focused&&(Te(e,"blur",e,t),e.state.focused=!1,Fl(e.display.wrapper,"CodeMirror-focused")),clearInterval(e.display.blinker),setTimeout(function(){e.state.focused||(e.display.shift=!1)},150))}function Er(e){for(var t=e.display,r=t.lineDiv.offsetTop,n=0;n<t.view.length;n++){var i=t.view[n],o=void 0;if(!i.hidden){if(gl&&vl<8){var l=i.node.offsetTop+i.node.offsetHeight;o=l-r,r=l}else{var s=i.node.getBoundingClientRect();o=s.bottom-s.top}var a=i.line.height-o;if(o<2&&(o=mr(t)),(a>.005||a<-.005)&&(A(i.line,o),Pr(i.line),i.rest))for(var u=0;u<i.rest.length;u++)Pr(i.rest[u])}}}function Pr(e){if(e.widgets)for(var t=0;t<e.widgets.length;++t)e.widgets[t].height=e.widgets[t].node.parentNode.offsetHeight}function Ir(e,t,r){var n=r&&null!=r.top?Math.max(0,r.top):e.scroller.scrollTop;n=Math.floor(n-Et(e));var i=r&&null!=r.bottom?r.bottom:n+e.wrapper.clientHeight,o=D(t,n),l=D(t,i);if(r&&r.ensure){var s=r.ensure.from.line,a=r.ensure.to.line;s<o?(o=s,l=D(t,ye(M(t,s))+e.wrapper.clientHeight)):Math.min(a,t.lastLine())>=l&&(o=D(t,ye(M(t,a))-e.wrapper.clientHeight),l=a)}return{from:o,to:Math.max(l,o+1)}}function zr(e){var t=e.display,r=t.view;if(t.alignWidgets||t.gutters.firstChild&&e.options.fixedGutter){for(var n=wr(t)-t.scroller.scrollLeft+e.doc.scrollLeft,i=t.gutters.offsetWidth,o=n+"px",l=0;l<r.length;l++)if(!r[l].hidden){e.options.fixedGutter&&(r[l].gutter&&(r[l].gutter.style.left=o),r[l].gutterBackground&&(r[l].gutterBackground.style.left=o));var s=r[l].alignable;if(s)for(var a=0;a<s.length;a++)s[a].style.left=o}e.options.fixedGutter&&(t.gutters.style.left=n+i+"px")}}function Rr(e){if(!e.options.lineNumbers)return!1;var t=e.doc,r=F(e.options,t.first+t.size-1),i=e.display;if(r.length!=i.lineNumChars){var o=i.measure.appendChild(n("div",[n("div",r)],"CodeMirror-linenumber CodeMirror-gutter-elt")),l=o.firstChild.offsetWidth,s=o.offsetWidth-l;return i.lineGutter.style.width="",i.lineNumInnerWidth=Math.max(l,i.lineGutter.offsetWidth-s)+1,i.lineNumWidth=i.lineNumInnerWidth+s,i.lineNumChars=i.lineNumInnerWidth?r.length:-1,i.lineGutter.style.width=i.lineNumWidth+"px",Wn(e),!0}return!1}function Br(e,t){if(!Me(e,"scrollCursorIntoView")){var r=e.display,i=r.sizer.getBoundingClientRect(),o=null;if(t.top+i.top<0?o=!0:t.bottom+i.top>(window.innerHeight||document.documentElement.clientHeight)&&(o=!1),null!=o&&!Sl){var l=n("div","​",null,"position: absolute;\n                         top: "+(t.top-r.viewOffset-Et(e.display))+"px;\n                         height: "+(t.bottom-t.top+zt(e)+r.barHeight)+"px;\n                         left: "+t.left+"px; width: "+Math.max(2,t.right-t.left)+"px;");e.display.lineSpace.appendChild(l),l.scrollIntoView(o),e.display.lineSpace.removeChild(l)}}}function Gr(e,t,r,n){null==n&&(n=0);var i;e.options.lineWrapping||t!=r||(r="before"==(t=t.ch?E(t.line,"before"==t.sticky?t.ch-1:t.ch,"after"):t).sticky?E(t.line,t.ch+1,"before"):t);for(var o=0;o<5;o++){var l=!1,s=sr(e,t),a=r&&r!=t?sr(e,r):s,u=Vr(e,i={left:Math.min(s.left,a.left),top:Math.min(s.top,a.top)-n,right:Math.max(s.left,a.left),bottom:Math.max(s.bottom,a.bottom)+n}),c=e.doc.scrollTop,f=e.doc.scrollLeft;if(null!=u.scrollTop&&(qr(e,u.scrollTop),Math.abs(e.doc.scrollTop-c)>1&&(l=!0)),null!=u.scrollLeft&&(Qr(e,u.scrollLeft),Math.abs(e.doc.scrollLeft-f)>1&&(l=!0)),!l)break}return i}function Ur(e,t){var r=Vr(e,t);null!=r.scrollTop&&qr(e,r.scrollTop),null!=r.scrollLeft&&Qr(e,r.scrollLeft)}function Vr(e,t){var r=e.display,n=mr(e.display);t.top<0&&(t.top=0);var i=e.curOp&&null!=e.curOp.scrollTop?e.curOp.scrollTop:r.scroller.scrollTop,o=Bt(e),l={};t.bottom-t.top>o&&(t.bottom=t.top+o);var s=e.doc.height+Pt(r),a=t.top<n,u=t.bottom>s-n;if(t.top<i)l.scrollTop=a?0:t.top;else if(t.bottom>i+o){var c=Math.min(t.top,(u?s:t.bottom)-o);c!=i&&(l.scrollTop=c)}var f=e.curOp&&null!=e.curOp.scrollLeft?e.curOp.scrollLeft:r.scroller.scrollLeft,h=Rt(e)-(e.options.fixedGutter?r.gutters.offsetWidth:0),d=t.right-t.left>h;return d&&(t.right=t.left+h),t.left<10?l.scrollLeft=0:t.left<f?l.scrollLeft=Math.max(0,t.left-(d?0:10)):t.right>h+f-3&&(l.scrollLeft=t.right+(d?0:10)-h),l}function Kr(e,t){null!=t&&(_r(e),e.curOp.scrollTop=(null==e.curOp.scrollTop?e.doc.scrollTop:e.curOp.scrollTop)+t)}function jr(e){_r(e);var t=e.getCursor();e.curOp.scrollToPos={from:t,to:t,margin:e.options.cursorScrollMargin}}function Xr(e,t,r){null==t&&null==r||_r(e),null!=t&&(e.curOp.scrollLeft=t),null!=r&&(e.curOp.scrollTop=r)}function Yr(e,t){_r(e),e.curOp.scrollToPos=t}function _r(e){var t=e.curOp.scrollToPos;t&&(e.curOp.scrollToPos=null,$r(e,ar(e,t.from),ar(e,t.to),t.margin))}function $r(e,t,r,n){var i=Vr(e,{left:Math.min(t.left,r.left),top:Math.min(t.top,r.top)-n,right:Math.max(t.right,r.right),bottom:Math.max(t.bottom,r.bottom)+n});Xr(e,i.scrollLeft,i.scrollTop)}function qr(e,t){Math.abs(e.doc.scrollTop-t)<2||(fl||On(e,{top:t}),Zr(e,t,!0),fl&&On(e),Cn(e,100))}function Zr(e,t,r){t=Math.min(e.display.scroller.scrollHeight-e.display.scroller.clientHeight,t),(e.display.scroller.scrollTop!=t||r)&&(e.doc.scrollTop=t,e.display.scrollbars.setScrollTop(t),e.display.scroller.scrollTop!=t&&(e.display.scroller.scrollTop=t))}function Qr(e,t,r,n){t=Math.min(t,e.display.scroller.scrollWidth-e.display.scroller.clientWidth),(r?t==e.doc.scrollLeft:Math.abs(e.doc.scrollLeft-t)<2)&&!n||(e.doc.scrollLeft=t,zr(e),e.display.scroller.scrollLeft!=t&&(e.display.scroller.scrollLeft=t),e.display.scrollbars.setScrollLeft(t))}function Jr(e){var t=e.display,r=t.gutters.offsetWidth,n=Math.round(e.doc.height+Pt(e.display));return{clientHeight:t.scroller.clientHeight,viewHeight:t.wrapper.clientHeight,scrollWidth:t.scroller.scrollWidth,clientWidth:t.scroller.clientWidth,viewWidth:t.wrapper.clientWidth,barLeft:e.options.fixedGutter?r:0,docHeight:n,scrollHeight:n+zt(e)+t.barHeight,nativeBarWidth:t.nativeBarWidth,gutterWidth:r}}function en(e,t){t||(t=Jr(e));var r=e.display.barWidth,n=e.display.barHeight;tn(e,t);for(var i=0;i<4&&r!=e.display.barWidth||n!=e.display.barHeight;i++)r!=e.display.barWidth&&e.options.lineWrapping&&Er(e),tn(e,Jr(e)),r=e.display.barWidth,n=e.display.barHeight}function tn(e,t){var r=e.display,n=r.scrollbars.update(t);r.sizer.style.paddingRight=(r.barWidth=n.right)+"px",r.sizer.style.paddingBottom=(r.barHeight=n.bottom)+"px",r.heightForcer.style.borderBottom=n.bottom+"px solid transparent",n.right&&n.bottom?(r.scrollbarFiller.style.display="block",r.scrollbarFiller.style.height=n.bottom+"px",r.scrollbarFiller.style.width=n.right+"px"):r.scrollbarFiller.style.display="",n.bottom&&e.options.coverGutterNextToScrollbar&&e.options.fixedGutter?(r.gutterFiller.style.display="block",r.gutterFiller.style.height=n.bottom+"px",r.gutterFiller.style.width=t.gutterWidth+"px"):r.gutterFiller.style.display=""}function rn(e){e.display.scrollbars&&(e.display.scrollbars.clear(),e.display.scrollbars.addClass&&Fl(e.display.wrapper,e.display.scrollbars.addClass)),e.display.scrollbars=new ws[e.options.scrollbarStyle](function(t){e.display.wrapper.insertBefore(t,e.display.scrollbarFiller),Ql(t,"mousedown",function(){e.state.focused&&setTimeout(function(){return e.display.input.focus()},0)}),t.setAttribute("cm-not-content","true")},function(t,r){"horizontal"==r?Qr(e,t):qr(e,t)},e),e.display.scrollbars.addClass&&s(e.display.wrapper,e.display.scrollbars.addClass)}function nn(e){e.curOp={cm:e,viewChanged:!1,startHeight:e.doc.height,forceUpdate:!1,updateInput:null,typing:!1,changeObjs:null,cursorActivityHandlers:null,cursorActivityCalled:0,selectionChanged:!1,updateMaxLine:!1,scrollLeft:null,scrollTop:null,scrollToPos:null,focus:!1,id:++xs},vt(e.curOp)}function on(e){yt(e.curOp,function(e){for(var t=0;t<e.ops.length;t++)e.ops[t].cm.curOp=null;ln(e)})}function ln(e){for(var t=e.ops,r=0;r<t.length;r++)sn(t[r]);for(var n=0;n<t.length;n++)an(t[n]);for(var i=0;i<t.length;i++)un(t[i]);for(var o=0;o<t.length;o++)cn(t[o]);for(var l=0;l<t.length;l++)fn(t[l])}function sn(e){var t=e.cm,r=t.display;Ln(t),e.updateMaxLine&&we(t),e.mustUpdate=e.viewChanged||e.forceUpdate||null!=e.scrollTop||e.scrollToPos&&(e.scrollToPos.from.line<r.viewFrom||e.scrollToPos.to.line>=r.viewTo)||r.maxLineChanged&&t.options.lineWrapping,e.update=e.mustUpdate&&new Cs(t,e.mustUpdate&&{top:e.scrollTop,ensure:e.scrollToPos},e.forceUpdate)}function an(e){e.updatedDisplay=e.mustUpdate&&Mn(e.cm,e.update)}function un(e){var t=e.cm,r=t.display;e.updatedDisplay&&Er(t),e.barMeasure=Jr(t),r.maxLineChanged&&!t.options.lineWrapping&&(e.adjustWidthTo=Kt(t,r.maxLine,r.maxLine.text.length).left+3,t.display.sizerWidth=e.adjustWidthTo,e.barMeasure.scrollWidth=Math.max(r.scroller.clientWidth,r.sizer.offsetLeft+e.adjustWidthTo+zt(t)+t.display.barWidth),e.maxScrollLeft=Math.max(0,r.sizer.offsetLeft+e.adjustWidthTo-Rt(t))),(e.updatedDisplay||e.selectionChanged)&&(e.preparedSelection=r.input.prepareSelection())}function cn(e){var t=e.cm;null!=e.adjustWidthTo&&(t.display.sizer.style.minWidth=e.adjustWidthTo+"px",e.maxScrollLeft<t.doc.scrollLeft&&Qr(t,Math.min(t.display.scroller.scrollLeft,e.maxScrollLeft),!0),t.display.maxLineChanged=!1);var r=e.focus&&e.focus==l();e.preparedSelection&&t.display.input.showSelection(e.preparedSelection,r),(e.updatedDisplay||e.startHeight!=t.doc.height)&&en(t,e.barMeasure),e.updatedDisplay&&Dn(t,e.barMeasure),e.selectionChanged&&Ar(t),t.state.focused&&e.updateInput&&t.display.input.reset(e.typing),r&&Wr(e.cm)}function fn(e){var t=e.cm,r=t.display,n=t.doc;e.updatedDisplay&&Nn(t,e.update),null==r.wheelStartX||null==e.scrollTop&&null==e.scrollLeft&&!e.scrollToPos||(r.wheelStartX=r.wheelStartY=null),null!=e.scrollTop&&Zr(t,e.scrollTop,e.forceScroll),null!=e.scrollLeft&&Qr(t,e.scrollLeft,!0,!0),e.scrollToPos&&Br(t,Gr(t,U(n,e.scrollToPos.from),U(n,e.scrollToPos.to),e.scrollToPos.margin));var i=e.maybeHiddenMarkers,o=e.maybeUnhiddenMarkers;if(i)for(var l=0;l<i.length;++l)i[l].lines.length||Te(i[l],"hide");if(o)for(var s=0;s<o.length;++s)o[s].lines.length&&Te(o[s],"unhide");r.wrapper.offsetHeight&&(n.scrollTop=t.display.scroller.scrollTop),e.changeObjs&&Te(t,"changes",t,e.changeObjs),e.update&&e.update.finish()}function hn(e,t){if(e.curOp)return t();nn(e);try{return t()}finally{on(e)}}function dn(e,t){return function(){if(e.curOp)return t.apply(e,arguments);nn(e);try{return t.apply(e,arguments)}finally{on(e)}}}function pn(e){return function(){if(this.curOp)return e.apply(this,arguments);nn(this);try{return e.apply(this,arguments)}finally{on(this)}}}function gn(e){return function(){var t=this.cm;if(!t||t.curOp)return e.apply(this,arguments);nn(t);try{return e.apply(this,arguments)}finally{on(t)}}}function vn(e,t,r,n){null==t&&(t=e.doc.first),null==r&&(r=e.doc.first+e.doc.size),n||(n=0);var i=e.display;if(n&&r<i.viewTo&&(null==i.updateLineNumbers||i.updateLineNumbers>t)&&(i.updateLineNumbers=t),e.curOp.viewChanged=!0,t>=i.viewTo)_l&&pe(e.doc,t)<i.viewTo&&yn(e);else if(r<=i.viewFrom)_l&&ge(e.doc,r+n)>i.viewFrom?yn(e):(i.viewFrom+=n,i.viewTo+=n);else if(t<=i.viewFrom&&r>=i.viewTo)yn(e);else if(t<=i.viewFrom){var o=bn(e,r,r+n,1);o?(i.view=i.view.slice(o.index),i.viewFrom=o.lineN,i.viewTo+=n):yn(e)}else if(r>=i.viewTo){var l=bn(e,t,t,-1);l?(i.view=i.view.slice(0,l.index),i.viewTo=l.lineN):yn(e)}else{var s=bn(e,t,t,-1),a=bn(e,r,r+n,1);s&&a?(i.view=i.view.slice(0,s.index).concat(gt(e,s.lineN,a.lineN)).concat(i.view.slice(a.index)),i.viewTo+=n):yn(e)}var u=i.externalMeasured;u&&(r<u.lineN?u.lineN+=n:t<u.lineN+u.size&&(i.externalMeasured=null))}function mn(e,t,r){e.curOp.viewChanged=!0;var n=e.display,i=e.display.externalMeasured;if(i&&t>=i.lineN&&t<i.lineN+i.size&&(n.externalMeasured=null),!(t<n.viewFrom||t>=n.viewTo)){var o=n.view[Lr(e,t)];if(null!=o.node){var l=o.changes||(o.changes=[]);-1==h(l,r)&&l.push(r)}}}function yn(e){e.display.viewFrom=e.display.viewTo=e.doc.first,e.display.view=[],e.display.viewOffset=0}function bn(e,t,r,n){var i,o=Lr(e,t),l=e.display.view;if(!_l||r==e.doc.first+e.doc.size)return{index:o,lineN:r};for(var s=e.display.viewFrom,a=0;a<o;a++)s+=l[a].size;if(s!=t){if(n>0){if(o==l.length-1)return null;i=s+l[o].size-t,o++}else i=s-t;t+=i,r+=i}for(;pe(e.doc,r)!=r;){if(o==(n<0?0:l.length-1))return null;r+=n*l[o-(n<0?1:0)].size,o+=n}return{index:o,lineN:r}}function wn(e,t,r){var n=e.display;0==n.view.length||t>=n.viewTo||r<=n.viewFrom?(n.view=gt(e,t,r),n.viewFrom=t):(n.viewFrom>t?n.view=gt(e,t,n.viewFrom).concat(n.view):n.viewFrom<t&&(n.view=n.view.slice(Lr(e,t))),n.viewFrom=t,n.viewTo<r?n.view=n.view.concat(gt(e,n.viewTo,r)):n.viewTo>r&&(n.view=n.view.slice(0,Lr(e,r)))),n.viewTo=r}function xn(e){for(var t=e.display.view,r=0,n=0;n<t.length;n++){var i=t[n];i.hidden||i.node&&!i.changes||++r}return r}function Cn(e,t){e.doc.highlightFrontier<e.display.viewTo&&e.state.highlight.set(t,u(Sn,e))}function Sn(e){var t=e.doc;if(!(t.highlightFrontier>=e.display.viewTo)){var r=+new Date+e.options.workTime,n=$e(e,t.highlightFrontier),i=[];t.iter(n.line,Math.min(t.first+t.size,e.display.viewTo+500),function(o){if(n.line>=e.display.viewFrom){var l=o.styles,s=o.text.length>e.options.maxHighlightLength?Ke(t.mode,n.state):null,a=Ye(e,o,n,!0);s&&(n.state=s),o.styles=a.styles;var u=o.styleClasses,c=a.classes;c?o.styleClasses=c:u&&(o.styleClasses=null);for(var f=!l||l.length!=o.styles.length||u!=c&&(!u||!c||u.bgClass!=c.bgClass||u.textClass!=c.textClass),h=0;!f&&h<l.length;++h)f=l[h]!=o.styles[h];f&&i.push(n.line),o.stateAfter=n.save(),n.nextLine()}else o.text.length<=e.options.maxHighlightLength&&qe(e,o.text,n),o.stateAfter=n.line%5==0?n.save():null,n.nextLine();if(+new Date>r)return Cn(e,e.options.workDelay),!0}),t.highlightFrontier=n.line,t.modeFrontier=Math.max(t.modeFrontier,n.line),i.length&&hn(e,function(){for(var t=0;t<i.length;t++)mn(e,i[t],"text")})}}function Ln(e){var t=e.display;!t.scrollbarsClipped&&t.scroller.offsetWidth&&(t.nativeBarWidth=t.scroller.offsetWidth-t.scroller.clientWidth,t.heightForcer.style.height=zt(e)+"px",t.sizer.style.marginBottom=-t.nativeBarWidth+"px",t.sizer.style.borderRightWidth=zt(e)+"px",t.scrollbarsClipped=!0)}function kn(e){if(e.hasFocus())return null;var t=l();if(!t||!o(e.display.lineDiv,t))return null;var r={activeElt:t};if(window.getSelection){var n=window.getSelection();n.anchorNode&&n.extend&&o(e.display.lineDiv,n.anchorNode)&&(r.anchorNode=n.anchorNode,r.anchorOffset=n.anchorOffset,r.focusNode=n.focusNode,r.focusOffset=n.focusOffset)}return r}function Tn(e){if(e&&e.activeElt&&e.activeElt!=l()&&(e.activeElt.focus(),e.anchorNode&&o(document.body,e.anchorNode)&&o(document.body,e.focusNode))){var t=window.getSelection(),r=document.createRange();r.setEnd(e.anchorNode,e.anchorOffset),r.collapse(!1),t.removeAllRanges(),t.addRange(r),t.extend(e.focusNode,e.focusOffset)}}function Mn(e,r){var n=e.display,i=e.doc;if(r.editorIsHidden)return yn(e),!1;if(!r.force&&r.visible.from>=n.viewFrom&&r.visible.to<=n.viewTo&&(null==n.updateLineNumbers||n.updateLineNumbers>=n.viewTo)&&n.renderedView==n.view&&0==xn(e))return!1;Rr(e)&&(yn(e),r.dims=br(e));var o=i.first+i.size,l=Math.max(r.visible.from-e.options.viewportMargin,i.first),s=Math.min(o,r.visible.to+e.options.viewportMargin);n.viewFrom<l&&l-n.viewFrom<20&&(l=Math.max(i.first,n.viewFrom)),n.viewTo>s&&n.viewTo-s<20&&(s=Math.min(o,n.viewTo)),_l&&(l=pe(e.doc,l),s=ge(e.doc,s));var a=l!=n.viewFrom||s!=n.viewTo||n.lastWrapHeight!=r.wrapperHeight||n.lastWrapWidth!=r.wrapperWidth;wn(e,l,s),n.viewOffset=ye(M(e.doc,n.viewFrom)),e.display.mover.style.top=n.viewOffset+"px";var u=xn(e);if(!a&&0==u&&!r.force&&n.renderedView==n.view&&(null==n.updateLineNumbers||n.updateLineNumbers>=n.viewTo))return!1;var c=kn(e);return u>4&&(n.lineDiv.style.display="none"),An(e,n.updateLineNumbers,r.dims),u>4&&(n.lineDiv.style.display=""),n.renderedView=n.view,Tn(c),t(n.cursorDiv),t(n.selectionDiv),n.gutters.style.height=n.sizer.style.minHeight=0,a&&(n.lastWrapHeight=r.wrapperHeight,n.lastWrapWidth=r.wrapperWidth,Cn(e,400)),n.updateLineNumbers=null,!0}function Nn(e,t){for(var r=t.viewport,n=!0;(n&&e.options.lineWrapping&&t.oldDisplayWidth!=Rt(e)||(r&&null!=r.top&&(r={top:Math.min(e.doc.height+Pt(e.display)-Bt(e),r.top)}),t.visible=Ir(e.display,e.doc,r),!(t.visible.from>=e.display.viewFrom&&t.visible.to<=e.display.viewTo)))&&Mn(e,t);n=!1){Er(e);var i=Jr(e);kr(e),en(e,i),Dn(e,i),t.force=!1}t.signal(e,"update",e),e.display.viewFrom==e.display.reportedViewFrom&&e.display.viewTo==e.display.reportedViewTo||(t.signal(e,"viewportChange",e,e.display.viewFrom,e.display.viewTo),e.display.reportedViewFrom=e.display.viewFrom,e.display.reportedViewTo=e.display.viewTo)}function On(e,t){var r=new Cs(e,t);if(Mn(e,r)){Er(e),Nn(e,r);var n=Jr(e);kr(e),en(e,n),Dn(e,n),r.finish()}}function An(e,r,n){function i(t){var r=t.nextSibling;return ml&&Ml&&e.display.currentWheelTarget==t?t.style.display="none":t.parentNode.removeChild(t),r}for(var o=e.display,l=e.options.lineNumbers,s=o.lineDiv,a=s.firstChild,u=o.view,c=o.viewFrom,f=0;f<u.length;f++){var d=u[f];if(d.hidden);else if(d.node&&d.node.parentNode==s){for(;a!=d.node;)a=i(a);var p=l&&null!=r&&r<=c&&d.lineNumber;d.changes&&(h(d.changes,"gutter")>-1&&(p=!1),xt(e,d,c,n)),p&&(t(d.lineNumber),d.lineNumber.appendChild(document.createTextNode(F(e.options,c)))),a=d.node.nextSibling}else{var g=Ot(e,d,c,n);s.insertBefore(g,a)}c+=d.size}for(;a;)a=i(a)}function Wn(e){var t=e.display.gutters.offsetWidth;e.display.sizer.style.marginLeft=t+"px"}function Dn(e,t){e.display.sizer.style.minHeight=t.docHeight+"px",e.display.heightForcer.style.top=t.docHeight+"px",e.display.gutters.style.height=t.docHeight+e.display.barHeight+zt(e)+"px"}function Hn(e){var r=e.display.gutters,i=e.options.gutters;t(r);for(var o=0;o<i.length;++o){var l=i[o],s=r.appendChild(n("div",null,"CodeMirror-gutter "+l));"CodeMirror-linenumbers"==l&&(e.display.lineGutter=s,s.style.width=(e.display.lineNumWidth||1)+"px")}r.style.display=o?"":"none",Wn(e)}function Fn(e){var t=h(e.gutters,"CodeMirror-linenumbers");-1==t&&e.lineNumbers?e.gutters=e.gutters.concat(["CodeMirror-linenumbers"]):t>-1&&!e.lineNumbers&&(e.gutters=e.gutters.slice(0),e.gutters.splice(t,1))}function En(e){var t=e.wheelDeltaX,r=e.wheelDeltaY;return null==t&&e.detail&&e.axis==e.HORIZONTAL_AXIS&&(t=e.detail),null==r&&e.detail&&e.axis==e.VERTICAL_AXIS?r=e.detail:null==r&&(r=e.wheelDelta),{x:t,y:r}}function Pn(e){var t=En(e);return t.x*=Ls,t.y*=Ls,t}function In(e,t){var r=En(t),n=r.x,i=r.y,o=e.display,l=o.scroller,s=l.scrollWidth>l.clientWidth,a=l.scrollHeight>l.clientHeight;if(n&&s||i&&a){if(i&&Ml&&ml)e:for(var u=t.target,c=o.view;u!=l;u=u.parentNode)for(var f=0;f<c.length;f++)if(c[f].node==u){e.display.currentWheelTarget=u;break e}if(n&&!fl&&!wl&&null!=Ls)return i&&a&&qr(e,Math.max(0,l.scrollTop+i*Ls)),Qr(e,Math.max(0,l.scrollLeft+n*Ls)),(!i||i&&a)&&We(t),void(o.wheelStartX=null);if(i&&null!=Ls){var h=i*Ls,d=e.doc.scrollTop,p=d+o.wrapper.clientHeight;h<0?d=Math.max(0,d+h-50):p=Math.min(e.doc.height,p+h+50),On(e,{top:d,bottom:p})}Ss<20&&(null==o.wheelStartX?(o.wheelStartX=l.scrollLeft,o.wheelStartY=l.scrollTop,o.wheelDX=n,o.wheelDY=i,setTimeout(function(){if(null!=o.wheelStartX){var e=l.scrollLeft-o.wheelStartX,t=l.scrollTop-o.wheelStartY,r=t&&o.wheelDY&&t/o.wheelDY||e&&o.wheelDX&&e/o.wheelDX;o.wheelStartX=o.wheelStartY=null,r&&(Ls=(Ls*Ss+r)/(Ss+1),++Ss)}},200)):(o.wheelDX+=n,o.wheelDY+=i))}}function zn(e,t){var r=e[t];e.sort(function(e,t){return P(e.from(),t.from())}),t=h(e,r);for(var n=1;n<e.length;n++){var i=e[n],o=e[n-1];if(P(o.to(),i.from())>=0){var l=B(o.from(),i.from()),s=R(o.to(),i.to()),a=o.empty()?i.from()==i.head:o.from()==o.head;n<=t&&--t,e.splice(--n,2,new Ts(a?s:l,a?l:s))}}return new ks(e,t)}function Rn(e,t){return new ks([new Ts(e,t||e)],0)}function Bn(e){return e.text?E(e.from.line+e.text.length-1,g(e.text).length+(1==e.text.length?e.from.ch:0)):e.to}function Gn(e,t){if(P(e,t.from)<0)return e;if(P(e,t.to)<=0)return Bn(t);var r=e.line+t.text.length-(t.to.line-t.from.line)-1,n=e.ch;return e.line==t.to.line&&(n+=Bn(t).ch-t.to.ch),E(r,n)}function Un(e,t){for(var r=[],n=0;n<e.sel.ranges.length;n++){var i=e.sel.ranges[n];r.push(new Ts(Gn(i.anchor,t),Gn(i.head,t)))}return zn(r,e.sel.primIndex)}function Vn(e,t,r){return e.line==t.line?E(r.line,e.ch-t.ch+r.ch):E(r.line+(e.line-t.line),e.ch)}function Kn(e,t,r){for(var n=[],i=E(e.first,0),o=i,l=0;l<t.length;l++){var s=t[l],a=Vn(s.from,i,o),u=Vn(Bn(s),i,o);if(i=s.to,o=u,"around"==r){var c=e.sel.ranges[l],f=P(c.head,c.anchor)<0;n[l]=new Ts(f?u:a,f?a:u)}else n[l]=new Ts(a,a)}return new ks(n,e.sel.primIndex)}function jn(e){e.doc.mode=Ue(e.options,e.doc.modeOption),Xn(e)}function Xn(e){e.doc.iter(function(e){e.stateAfter&&(e.stateAfter=null),e.styles&&(e.styles=null)}),e.doc.modeFrontier=e.doc.highlightFrontier=e.doc.first,Cn(e,100),e.state.modeGen++,e.curOp&&vn(e)}function Yn(e,t){return 0==t.from.ch&&0==t.to.ch&&""==g(t.text)&&(!e.cm||e.cm.options.wholeLineUpdateBefore)}function _n(e,t,r,n){function i(e){return r?r[e]:null}function o(e,r,i){it(e,r,i,n),bt(e,"change",e,t)}function l(e,t){for(var r=[],o=e;o<t;++o)r.push(new fs(u[o],i(o),n));return r}var s=t.from,a=t.to,u=t.text,c=M(e,s.line),f=M(e,a.line),h=g(u),d=i(u.length-1),p=a.line-s.line;if(t.full)e.insert(0,l(0,u.length)),e.remove(u.length,e.size-u.length);else if(Yn(e,t)){var v=l(0,u.length-1);o(f,f.text,d),p&&e.remove(s.line,p),v.length&&e.insert(s.line,v)}else if(c==f)if(1==u.length)o(c,c.text.slice(0,s.ch)+h+c.text.slice(a.ch),d);else{var m=l(1,u.length-1);m.push(new fs(h+c.text.slice(a.ch),d,n)),o(c,c.text.slice(0,s.ch)+u[0],i(0)),e.insert(s.line+1,m)}else if(1==u.length)o(c,c.text.slice(0,s.ch)+u[0]+f.text.slice(a.ch),i(0)),e.remove(s.line+1,p);else{o(c,c.text.slice(0,s.ch)+u[0],i(0)),o(f,h+f.text.slice(a.ch),d);var y=l(1,u.length-1);p>1&&e.remove(s.line+1,p-1),e.insert(s.line+1,y)}bt(e,"change",e,t)}function $n(e,t,r){function n(e,i,o){if(e.linked)for(var l=0;l<e.linked.length;++l){var s=e.linked[l];if(s.doc!=i){var a=o&&s.sharedHist;r&&!a||(t(s.doc,a),n(s.doc,e,a))}}}n(e,null,!0)}function qn(e,t){if(t.cm)throw new Error("This document is already in use.");e.doc=t,t.cm=e,Cr(e),jn(e),Zn(e),e.options.lineWrapping||we(e),e.options.mode=t.modeOption,vn(e)}function Zn(e){("rtl"==e.doc.direction?s:Fl)(e.display.lineDiv,"CodeMirror-rtl")}function Qn(e){hn(e,function(){Zn(e),vn(e)})}function Jn(e){this.done=[],this.undone=[],this.undoDepth=1/0,this.lastModTime=this.lastSelTime=0,this.lastOp=this.lastSelOp=null,this.lastOrigin=this.lastSelOrigin=null,this.generation=this.maxGeneration=e||1}function ei(e,t){var r={from:z(t.from),to:Bn(t),text:N(e,t.from,t.to)};return si(e,r,t.from.line,t.to.line+1),$n(e,function(e){return si(e,r,t.from.line,t.to.line+1)},!0),r}function ti(e){for(;e.length&&g(e).ranges;)e.pop()}function ri(e,t){return t?(ti(e.done),g(e.done)):e.done.length&&!g(e.done).ranges?g(e.done):e.done.length>1&&!e.done[e.done.length-2].ranges?(e.done.pop(),g(e.done)):void 0}function ni(e,t,r,n){var i=e.history;i.undone.length=0;var o,l,s=+new Date;if((i.lastOp==n||i.lastOrigin==t.origin&&t.origin&&("+"==t.origin.charAt(0)&&e.cm&&i.lastModTime>s-e.cm.options.historyEventDelay||"*"==t.origin.charAt(0)))&&(o=ri(i,i.lastOp==n)))l=g(o.changes),0==P(t.from,t.to)&&0==P(t.from,l.to)?l.to=Bn(t):o.changes.push(ei(e,t));else{var a=g(i.done);for(a&&a.ranges||li(e.sel,i.done),o={changes:[ei(e,t)],generation:i.generation},i.done.push(o);i.done.length>i.undoDepth;)i.done.shift(),i.done[0].ranges||i.done.shift()}i.done.push(r),i.generation=++i.maxGeneration,i.lastModTime=i.lastSelTime=s,i.lastOp=i.lastSelOp=n,i.lastOrigin=i.lastSelOrigin=t.origin,l||Te(e,"historyAdded")}function ii(e,t,r,n){var i=t.charAt(0);return"*"==i||"+"==i&&r.ranges.length==n.ranges.length&&r.somethingSelected()==n.somethingSelected()&&new Date-e.history.lastSelTime<=(e.cm?e.cm.options.historyEventDelay:500)}function oi(e,t,r,n){var i=e.history,o=n&&n.origin;r==i.lastSelOp||o&&i.lastSelOrigin==o&&(i.lastModTime==i.lastSelTime&&i.lastOrigin==o||ii(e,o,g(i.done),t))?i.done[i.done.length-1]=t:li(t,i.done),i.lastSelTime=+new Date,i.lastSelOrigin=o,i.lastSelOp=r,n&&!1!==n.clearRedo&&ti(i.undone)}function li(e,t){var r=g(t);r&&r.ranges&&r.equals(e)||t.push(e)}function si(e,t,r,n){var i=t["spans_"+e.id],o=0;e.iter(Math.max(e.first,r),Math.min(e.first+e.size,n),function(r){r.markedSpans&&((i||(i=t["spans_"+e.id]={}))[o]=r.markedSpans),++o})}function ai(e){if(!e)return null;for(var t,r=0;r<e.length;++r)e[r].marker.explicitlyCleared?t||(t=e.slice(0,r)):t&&t.push(e[r]);return t?t.length?t:null:e}function ui(e,t){var r=t["spans_"+e.id];if(!r)return null;for(var n=[],i=0;i<t.text.length;++i)n.push(ai(r[i]));return n}function ci(e,t){var r=ui(e,t),n=J(e,t);if(!r)return n;if(!n)return r;for(var i=0;i<r.length;++i){var o=r[i],l=n[i];if(o&&l)e:for(var s=0;s<l.length;++s){for(var a=l[s],u=0;u<o.length;++u)if(o[u].marker==a.marker)continue e;o.push(a)}else l&&(r[i]=l)}return r}function fi(e,t,r){for(var n=[],i=0;i<e.length;++i){var o=e[i];if(o.ranges)n.push(r?ks.prototype.deepCopy.call(o):o);else{var l=o.changes,s=[];n.push({changes:s});for(var a=0;a<l.length;++a){var u=l[a],c=void 0;if(s.push({from:u.from,to:u.to,text:u.text}),t)for(var f in u)(c=f.match(/^spans_(\d+)$/))&&h(t,Number(c[1]))>-1&&(g(s)[f]=u[f],delete u[f])}}}return n}function hi(e,t,r,n){if(n){var i=e.anchor;if(r){var o=P(t,i)<0;o!=P(r,i)<0?(i=t,t=r):o!=P(t,r)<0&&(t=r)}return new Ts(i,t)}return new Ts(r||t,t)}function di(e,t,r,n,i){null==i&&(i=e.cm&&(e.cm.display.shift||e.extend)),bi(e,new ks([hi(e.sel.primary(),t,r,i)],0),n)}function pi(e,t,r){for(var n=[],i=e.cm&&(e.cm.display.shift||e.extend),o=0;o<e.sel.ranges.length;o++)n[o]=hi(e.sel.ranges[o],t[o],null,i);bi(e,zn(n,e.sel.primIndex),r)}function gi(e,t,r,n){var i=e.sel.ranges.slice(0);i[t]=r,bi(e,zn(i,e.sel.primIndex),n)}function vi(e,t,r,n){bi(e,Rn(t,r),n)}function mi(e,t,r){var n={ranges:t.ranges,update:function(t){var r=this;this.ranges=[];for(var n=0;n<t.length;n++)r.ranges[n]=new Ts(U(e,t[n].anchor),U(e,t[n].head))},origin:r&&r.origin};return Te(e,"beforeSelectionChange",e,n),e.cm&&Te(e.cm,"beforeSelectionChange",e.cm,n),n.ranges!=t.ranges?zn(n.ranges,n.ranges.length-1):t}function yi(e,t,r){var n=e.history.done,i=g(n);i&&i.ranges?(n[n.length-1]=t,wi(e,t,r)):bi(e,t,r)}function bi(e,t,r){wi(e,t,r),oi(e,e.sel,e.cm?e.cm.curOp.id:NaN,r)}function wi(e,t,r){(Oe(e,"beforeSelectionChange")||e.cm&&Oe(e.cm,"beforeSelectionChange"))&&(t=mi(e,t,r)),xi(e,Si(e,t,r&&r.bias||(P(t.primary().head,e.sel.primary().head)<0?-1:1),!0)),r&&!1===r.scroll||!e.cm||jr(e.cm)}function xi(e,t){t.equals(e.sel)||(e.sel=t,e.cm&&(e.cm.curOp.updateInput=e.cm.curOp.selectionChanged=!0,Ne(e.cm)),bt(e,"cursorActivity",e))}function Ci(e){xi(e,Si(e,e.sel,null,!1))}function Si(e,t,r,n){for(var i,o=0;o<t.ranges.length;o++){var l=t.ranges[o],s=t.ranges.length==e.sel.ranges.length&&e.sel.ranges[o],a=ki(e,l.anchor,s&&s.anchor,r,n),u=ki(e,l.head,s&&s.head,r,n);(i||a!=l.anchor||u!=l.head)&&(i||(i=t.ranges.slice(0,o)),i[o]=new Ts(a,u))}return i?zn(i,t.primIndex):t}function Li(e,t,r,n,i){var o=M(e,t.line);if(o.markedSpans)for(var l=0;l<o.markedSpans.length;++l){var s=o.markedSpans[l],a=s.marker;if((null==s.from||(a.inclusiveLeft?s.from<=t.ch:s.from<t.ch))&&(null==s.to||(a.inclusiveRight?s.to>=t.ch:s.to>t.ch))){if(i&&(Te(a,"beforeCursorEnter"),a.explicitlyCleared)){if(o.markedSpans){--l;continue}break}if(!a.atomic)continue;if(r){var u=a.find(n<0?1:-1),c=void 0;if((n<0?a.inclusiveRight:a.inclusiveLeft)&&(u=Ti(e,u,-n,u&&u.line==t.line?o:null)),u&&u.line==t.line&&(c=P(u,r))&&(n<0?c<0:c>0))return Li(e,u,t,n,i)}var f=a.find(n<0?-1:1);return(n<0?a.inclusiveLeft:a.inclusiveRight)&&(f=Ti(e,f,n,f.line==t.line?o:null)),f?Li(e,f,t,n,i):null}}return t}function ki(e,t,r,n,i){var o=n||1,l=Li(e,t,r,o,i)||!i&&Li(e,t,r,o,!0)||Li(e,t,r,-o,i)||!i&&Li(e,t,r,-o,!0);return l||(e.cantEdit=!0,E(e.first,0))}function Ti(e,t,r,n){return r<0&&0==t.ch?t.line>e.first?U(e,E(t.line-1)):null:r>0&&t.ch==(n||M(e,t.line)).text.length?t.line<e.first+e.size-1?E(t.line+1,0):null:new E(t.line,t.ch+r)}function Mi(e){e.setSelection(E(e.firstLine(),0),E(e.lastLine()),Gl)}function Ni(e,t,r){var n={canceled:!1,from:t.from,to:t.to,text:t.text,origin:t.origin,cancel:function(){return n.canceled=!0}};return r&&(n.update=function(t,r,i,o){t&&(n.from=U(e,t)),r&&(n.to=U(e,r)),i&&(n.text=i),void 0!==o&&(n.origin=o)}),Te(e,"beforeChange",e,n),e.cm&&Te(e.cm,"beforeChange",e.cm,n),n.canceled?null:{from:n.from,to:n.to,text:n.text,origin:n.origin}}function Oi(e,t,r){if(e.cm){if(!e.cm.curOp)return dn(e.cm,Oi)(e,t,r);if(e.cm.state.suppressEdits)return}if(!(Oe(e,"beforeChange")||e.cm&&Oe(e.cm,"beforeChange"))||(t=Ni(e,t,!0))){var n=Yl&&!r&&te(e,t.from,t.to);if(n)for(var i=n.length-1;i>=0;--i)Ai(e,{from:n[i].from,to:n[i].to,text:i?[""]:t.text,origin:t.origin});else Ai(e,t)}}function Ai(e,t){if(1!=t.text.length||""!=t.text[0]||0!=P(t.from,t.to)){var r=Un(e,t);ni(e,t,r,e.cm?e.cm.curOp.id:NaN),Hi(e,t,r,J(e,t));var n=[];$n(e,function(e,r){r||-1!=h(n,e.history)||(zi(e.history,t),n.push(e.history)),Hi(e,t,null,J(e,t))})}}function Wi(e,t,r){if(!e.cm||!e.cm.state.suppressEdits||r){for(var n,i=e.history,o=e.sel,l="undo"==t?i.done:i.undone,s="undo"==t?i.undone:i.done,a=0;a<l.length&&(n=l[a],r?!n.ranges||n.equals(e.sel):n.ranges);a++);if(a!=l.length){for(i.lastOrigin=i.lastSelOrigin=null;(n=l.pop()).ranges;){if(li(n,s),r&&!n.equals(e.sel))return void bi(e,n,{clearRedo:!1});o=n}var u=[];li(o,s),s.push({changes:u,generation:i.generation}),i.generation=n.generation||++i.maxGeneration;for(var c=Oe(e,"beforeChange")||e.cm&&Oe(e.cm,"beforeChange"),f=n.changes.length-1;f>=0;--f){var d=function(r){var i=n.changes[r];if(i.origin=t,c&&!Ni(e,i,!1))return l.length=0,{};u.push(ei(e,i));var o=r?Un(e,i):g(l);Hi(e,i,o,ci(e,i)),!r&&e.cm&&e.cm.scrollIntoView({from:i.from,to:Bn(i)});var s=[];$n(e,function(e,t){t||-1!=h(s,e.history)||(zi(e.history,i),s.push(e.history)),Hi(e,i,null,ci(e,i))})}(f);if(d)return d.v}}}}function Di(e,t){if(0!=t&&(e.first+=t,e.sel=new ks(v(e.sel.ranges,function(e){return new Ts(E(e.anchor.line+t,e.anchor.ch),E(e.head.line+t,e.head.ch))}),e.sel.primIndex),e.cm)){vn(e.cm,e.first,e.first-t,t);for(var r=e.cm.display,n=r.viewFrom;n<r.viewTo;n++)mn(e.cm,n,"gutter")}}function Hi(e,t,r,n){if(e.cm&&!e.cm.curOp)return dn(e.cm,Hi)(e,t,r,n);if(t.to.line<e.first)Di(e,t.text.length-1-(t.to.line-t.from.line));else if(!(t.from.line>e.lastLine())){if(t.from.line<e.first){var i=t.text.length-1-(e.first-t.from.line);Di(e,i),t={from:E(e.first,0),to:E(t.to.line+i,t.to.ch),text:[g(t.text)],origin:t.origin}}var o=e.lastLine();t.to.line>o&&(t={from:t.from,to:E(o,M(e,o).text.length),text:[t.text[0]],origin:t.origin}),t.removed=N(e,t.from,t.to),r||(r=Un(e,t)),e.cm?Fi(e.cm,t,n):_n(e,t,n),wi(e,r,Gl)}}function Fi(e,t,r){var n=e.doc,i=e.display,o=t.from,l=t.to,s=!1,a=o.line;e.options.lineWrapping||(a=W(fe(M(n,o.line))),n.iter(a,l.line+1,function(e){if(e==i.maxLine)return s=!0,!0})),n.sel.contains(t.from,t.to)>-1&&Ne(e),_n(n,t,r,xr(e)),e.options.lineWrapping||(n.iter(a,o.line+t.text.length,function(e){var t=be(e);t>i.maxLineLength&&(i.maxLine=e,i.maxLineLength=t,i.maxLineChanged=!0,s=!1)}),s&&(e.curOp.updateMaxLine=!0)),nt(n,o.line),Cn(e,400);var u=t.text.length-(l.line-o.line)-1;t.full?vn(e):o.line!=l.line||1!=t.text.length||Yn(e.doc,t)?vn(e,o.line,l.line+1,u):mn(e,o.line,"text");var c=Oe(e,"changes"),f=Oe(e,"change");if(f||c){var h={from:o,to:l,text:t.text,removed:t.removed,origin:t.origin};f&&bt(e,"change",e,h),c&&(e.curOp.changeObjs||(e.curOp.changeObjs=[])).push(h)}e.display.selForContextMenu=null}function Ei(e,t,r,n,i){if(n||(n=r),P(n,r)<0){var o;r=(o=[n,r])[0],n=o[1]}"string"==typeof t&&(t=e.splitLines(t)),Oi(e,{from:r,to:n,text:t,origin:i})}function Pi(e,t,r,n){r<e.line?e.line+=n:t<e.line&&(e.line=t,e.ch=0)}function Ii(e,t,r,n){for(var i=0;i<e.length;++i){var o=e[i],l=!0;if(o.ranges){o.copied||((o=e[i]=o.deepCopy()).copied=!0);for(var s=0;s<o.ranges.length;s++)Pi(o.ranges[s].anchor,t,r,n),Pi(o.ranges[s].head,t,r,n)}else{for(var a=0;a<o.changes.length;++a){var u=o.changes[a];if(r<u.from.line)u.from=E(u.from.line+n,u.from.ch),u.to=E(u.to.line+n,u.to.ch);else if(t<=u.to.line){l=!1;break}}l||(e.splice(0,i+1),i=0)}}}function zi(e,t){var r=t.from.line,n=t.to.line,i=t.text.length-(n-r)-1;Ii(e.done,r,n,i),Ii(e.undone,r,n,i)}function Ri(e,t,r,n){var i=t,o=t;return"number"==typeof t?o=M(e,G(e,t)):i=W(t),null==i?null:(n(o,i)&&e.cm&&mn(e.cm,i,r),o)}function Bi(e){var t=this;this.lines=e,this.parent=null;for(var r=0,n=0;n<e.length;++n)e[n].parent=t,r+=e[n].height;this.height=r}function Gi(e){var t=this;this.children=e;for(var r=0,n=0,i=0;i<e.length;++i){var o=e[i];r+=o.chunkSize(),n+=o.height,o.parent=t}this.size=r,this.height=n,this.parent=null}function Ui(e,t,r){ye(t)<(e.curOp&&e.curOp.scrollTop||e.doc.scrollTop)&&Kr(e,r)}function Vi(e,t,r,n){var i=new Ms(e,r,n),o=e.cm;return o&&i.noHScroll&&(o.display.alignWidgets=!0),Ri(e,t,"widget",function(t){var r=t.widgets||(t.widgets=[]);if(null==i.insertAt?r.push(i):r.splice(Math.min(r.length-1,Math.max(0,i.insertAt)),0,i),i.line=t,o&&!ve(e,t)){var n=ye(t)<e.scrollTop;A(t,t.height+Ht(i)),n&&Kr(o,i.height),o.curOp.forceUpdate=!0}return!0}),bt(o,"lineWidgetAdded",o,i,"number"==typeof t?t:W(t)),i}function Ki(e,t,r,n,o){if(n&&n.shared)return ji(e,t,r,n,o);if(e.cm&&!e.cm.curOp)return dn(e.cm,Ki)(e,t,r,n,o);var l=new Os(e,o),s=P(t,r);if(n&&c(n,l,!1),s>0||0==s&&!1!==l.clearWhenEmpty)return l;if(l.replacedWith&&(l.collapsed=!0,l.widgetNode=i("span",[l.replacedWith],"CodeMirror-widget"),n.handleMouseEvents||l.widgetNode.setAttribute("cm-ignore-events","true"),n.insertLeft&&(l.widgetNode.insertLeft=!0)),l.collapsed){if(ce(e,t.line,t,r,l)||t.line!=r.line&&ce(e,r.line,t,r,l))throw new Error("Inserting collapsed marker partially overlapping an existing one");X()}l.addToHistory&&ni(e,{from:t,to:r,origin:"markText"},e.sel,NaN);var a,u=t.line,f=e.cm;if(e.iter(u,r.line+1,function(e){f&&l.collapsed&&!f.options.lineWrapping&&fe(e)==f.display.maxLine&&(a=!0),l.collapsed&&u!=t.line&&A(e,0),q(e,new Y(l,u==t.line?t.ch:null,u==r.line?r.ch:null)),++u}),l.collapsed&&e.iter(t.line,r.line+1,function(t){ve(e,t)&&A(t,0)}),l.clearOnEnter&&Ql(l,"beforeCursorEnter",function(){return l.clear()}),l.readOnly&&(j(),(e.history.done.length||e.history.undone.length)&&e.clearHistory()),l.collapsed&&(l.id=++Ns,l.atomic=!0),f){if(a&&(f.curOp.updateMaxLine=!0),l.collapsed)vn(f,t.line,r.line+1);else if(l.className||l.title||l.startStyle||l.endStyle||l.css)for(var h=t.line;h<=r.line;h++)mn(f,h,"text");l.atomic&&Ci(f.doc),bt(f,"markerAdded",f,l)}return l}function ji(e,t,r,n,i){(n=c(n)).shared=!1;var o=[Ki(e,t,r,n,i)],l=o[0],s=n.widgetNode;return $n(e,function(e){s&&(n.widgetNode=s.cloneNode(!0)),o.push(Ki(e,U(e,t),U(e,r),n,i));for(var a=0;a<e.linked.length;++a)if(e.linked[a].isParent)return;l=g(o)}),new As(o,l)}function Xi(e){return e.findMarks(E(e.first,0),e.clipPos(E(e.lastLine())),function(e){return e.parent})}function Yi(e,t){for(var r=0;r<t.length;r++){var n=t[r],i=n.find(),o=e.clipPos(i.from),l=e.clipPos(i.to);if(P(o,l)){var s=Ki(e,o,l,n.primary,n.primary.type);n.markers.push(s),s.parent=n}}}function _i(e){for(var t=0;t<e.length;t++)!function(t){var r=e[t],n=[r.primary.doc];$n(r.primary.doc,function(e){return n.push(e)});for(var i=0;i<r.markers.length;i++){var o=r.markers[i];-1==h(n,o.doc)&&(o.parent=null,r.markers.splice(i--,1))}}(t)}function $i(e){var t=this;if(Qi(t),!Me(t,e)&&!Ft(t.display,e)){We(e),gl&&(Hs=+new Date);var r=Sr(t,e,!0),n=e.dataTransfer.files;if(r&&!t.isReadOnly())if(n&&n.length&&window.FileReader&&window.File)for(var i=n.length,o=Array(i),l=0,s=0;s<i;++s)!function(e,n){if(!t.options.allowDropFileTypes||-1!=h(t.options.allowDropFileTypes,e.type)){var s=new FileReader;s.onload=dn(t,function(){var e=s.result;if(/[\x00-\x08\x0e-\x1f]{2}/.test(e)&&(e=""),o[n]=e,++l==i){var a={from:r=U(t.doc,r),to:r,text:t.doc.splitLines(o.join(t.doc.lineSeparator())),origin:"paste"};Oi(t.doc,a),yi(t.doc,Rn(r,Bn(a)))}}),s.readAsText(e)}}(n[s],s);else{if(t.state.draggingText&&t.doc.sel.contains(r)>-1)return t.state.draggingText(e),void setTimeout(function(){return t.display.input.focus()},20);try{var a=e.dataTransfer.getData("Text");if(a){var u;if(t.state.draggingText&&!t.state.draggingText.copy&&(u=t.listSelections()),wi(t.doc,Rn(r,r)),u)for(var c=0;c<u.length;++c)Ei(t.doc,"",u[c].anchor,u[c].head,"drag");t.replaceSelection(a,"around","paste"),t.display.input.focus()}}catch(e){}}}}function qi(e,t){if(gl&&(!e.state.draggingText||+new Date-Hs<100))Fe(t);else if(!Me(e,t)&&!Ft(e.display,t)&&(t.dataTransfer.setData("Text",e.getSelection()),t.dataTransfer.effectAllowed="copyMove",t.dataTransfer.setDragImage&&!xl)){var r=n("img",null,null,"position: fixed; left: 0; top: 0;");r.src="data:image/gif;base64,R0lGODlhAQABAAAAACH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==",wl&&(r.width=r.height=1,e.display.wrapper.appendChild(r),r._top=r.offsetTop),t.dataTransfer.setDragImage(r,0,0),wl&&r.parentNode.removeChild(r)}}function Zi(e,t){var i=Sr(e,t);if(i){var o=document.createDocumentFragment();Mr(e,i,o),e.display.dragCursor||(e.display.dragCursor=n("div",null,"CodeMirror-cursors CodeMirror-dragcursors"),e.display.lineSpace.insertBefore(e.display.dragCursor,e.display.cursorDiv)),r(e.display.dragCursor,o)}}function Qi(e){e.display.dragCursor&&(e.display.lineSpace.removeChild(e.display.dragCursor),e.display.dragCursor=null)}function Ji(e){if(document.getElementsByClassName)for(var t=document.getElementsByClassName("CodeMirror"),r=0;r<t.length;r++){var n=t[r].CodeMirror;n&&e(n)}}function eo(){Fs||(to(),Fs=!0)}function to(){var e;Ql(window,"resize",function(){null==e&&(e=setTimeout(function(){e=null,Ji(ro)},100))}),Ql(window,"blur",function(){return Ji(Fr)})}function ro(e){var t=e.display;t.lastWrapHeight==t.wrapper.clientHeight&&t.lastWrapWidth==t.wrapper.clientWidth||(t.cachedCharWidth=t.cachedTextHeight=t.cachedPaddingH=null,t.scrollbarsClipped=!1,e.setSize())}function no(e){var t=e.split(/-(?!$)/);e=t[t.length-1];for(var r,n,i,o,l=0;l<t.length-1;l++){var s=t[l];if(/^(cmd|meta|m)$/i.test(s))o=!0;else if(/^a(lt)?$/i.test(s))r=!0;else if(/^(c|ctrl|control)$/i.test(s))n=!0;else{if(!/^s(hift)?$/i.test(s))throw new Error("Unrecognized modifier name: "+s);i=!0}}return r&&(e="Alt-"+e),n&&(e="Ctrl-"+e),o&&(e="Cmd-"+e),i&&(e="Shift-"+e),e}function io(e){var t={};for(var r in e)if(e.hasOwnProperty(r)){var n=e[r];if(/^(name|fallthrough|(de|at)tach)$/.test(r))continue;if("..."==n){delete e[r];continue}for(var i=v(r.split(" "),no),o=0;o<i.length;o++){var l=void 0,s=void 0;o==i.length-1?(s=i.join(" "),l=n):(s=i.slice(0,o+1).join(" "),l="...");var a=t[s];if(a){if(a!=l)throw new Error("Inconsistent bindings for "+s)}else t[s]=l}delete e[r]}for(var u in t)e[u]=t[u];return e}function oo(e,t,r,n){var i=(t=uo(t)).call?t.call(e,n):t[e];if(!1===i)return"nothing";if("..."===i)return"multi";if(null!=i&&r(i))return"handled";if(t.fallthrough){if("[object Array]"!=Object.prototype.toString.call(t.fallthrough))return oo(e,t.fallthrough,r,n);for(var o=0;o<t.fallthrough.length;o++){var l=oo(e,t.fallthrough[o],r,n);if(l)return l}}}function lo(e){var t="string"==typeof e?e:Es[e.keyCode];return"Ctrl"==t||"Alt"==t||"Shift"==t||"Mod"==t}function so(e,t,r){var n=e;return t.altKey&&"Alt"!=n&&(e="Alt-"+e),(Dl?t.metaKey:t.ctrlKey)&&"Ctrl"!=n&&(e="Ctrl-"+e),(Dl?t.ctrlKey:t.metaKey)&&"Cmd"!=n&&(e="Cmd-"+e),!r&&t.shiftKey&&"Shift"!=n&&(e="Shift-"+e),e}function ao(e,t){if(wl&&34==e.keyCode&&e.char)return!1;var r=Es[e.keyCode];return null!=r&&!e.altGraphKey&&so(r,e,t)}function uo(e){return"string"==typeof e?Rs[e]:e}function co(e,t){for(var r=e.doc.sel.ranges,n=[],i=0;i<r.length;i++){for(var o=t(r[i]);n.length&&P(o.from,g(n).to)<=0;){var l=n.pop();if(P(l.from,o.from)<0){o.from=l.from;break}}n.push(o)}hn(e,function(){for(var t=n.length-1;t>=0;t--)Ei(e.doc,"",n[t].from,n[t].to,"+delete");jr(e)})}function fo(e,t,r){var n=L(e.text,t+r,r);return n<0||n>e.text.length?null:n}function ho(e,t,r){var n=fo(e,t.ch,r);return null==n?null:new E(t.line,n,r<0?"after":"before")}function po(e,t,r,n,i){if(e){var o=Se(r,t.doc.direction);if(o){var l,s=i<0?g(o):o[0],a=i<0==(1==s.level)?"after":"before";if(s.level>0){var u=Xt(t,r);l=i<0?r.text.length-1:0;var c=Yt(t,u,l).top;l=k(function(e){return Yt(t,u,e).top==c},i<0==(1==s.level)?s.from:s.to-1,l),"before"==a&&(l=fo(r,l,1))}else l=i<0?s.to:s.from;return new E(n,l,a)}}return new E(n,i<0?r.text.length:0,i<0?"before":"after")}function go(e,t,r,n){var i=Se(t,e.doc.direction);if(!i)return ho(t,r,n);r.ch>=t.text.length?(r.ch=t.text.length,r.sticky="before"):r.ch<=0&&(r.ch=0,r.sticky="after");var o=Ce(i,r.ch,r.sticky),l=i[o];if("ltr"==e.doc.direction&&l.level%2==0&&(n>0?l.to>r.ch:l.from<r.ch))return ho(t,r,n);var s,a=function(e,r){return fo(t,e instanceof E?e.ch:e,r)},u=function(r){return e.options.lineWrapping?(s=s||Xt(e,t),hr(e,t,s,r)):{begin:0,end:t.text.length}},c=u("before"==r.sticky?a(r,-1):r.ch);if("rtl"==e.doc.direction||1==l.level){var f=1==l.level==n<0,h=a(r,f?1:-1);if(null!=h&&(f?h<=l.to&&h<=c.end:h>=l.from&&h>=c.begin)){var d=f?"before":"after";return new E(r.line,h,d)}}var p=function(e,t,n){for(var o=function(e,t){return t?new E(r.line,a(e,1),"before"):new E(r.line,e,"after")};e>=0&&e<i.length;e+=t){var l=i[e],s=t>0==(1!=l.level),u=s?n.begin:a(n.end,-1);if(l.from<=u&&u<l.to)return o(u,s);if(u=s?l.from:a(l.to,-1),n.begin<=u&&u<n.end)return o(u,s)}},g=p(o+n,n,c);if(g)return g;var v=n>0?c.end:a(c.begin,-1);return null==v||n>0&&v==t.text.length||!(g=p(n>0?0:i.length-1,n,u(v)))?null:g}function vo(e,t){var r=M(e.doc,t),n=fe(r);return n!=r&&(t=W(n)),po(!0,e,n,t,1)}function mo(e,t){var r=M(e.doc,t),n=he(r);return n!=r&&(t=W(n)),po(!0,e,r,t,-1)}function yo(e,t){var r=vo(e,t.line),n=M(e.doc,r.line),i=Se(n,e.doc.direction);if(!i||0==i[0].level){var o=Math.max(0,n.text.search(/\S/)),l=t.line==r.line&&t.ch<=o&&t.ch;return E(r.line,l?0:o,r.sticky)}return r}function bo(e,t,r){if("string"==typeof t&&!(t=Bs[t]))return!1;e.display.input.ensurePolled();var n=e.display.shift,i=!1;try{e.isReadOnly()&&(e.state.suppressEdits=!0),r&&(e.display.shift=!1),i=t(e)!=Bl}finally{e.display.shift=n,e.state.suppressEdits=!1}return i}function wo(e,t,r){for(var n=0;n<e.state.keyMaps.length;n++){var i=oo(t,e.state.keyMaps[n],r,e);if(i)return i}return e.options.extraKeys&&oo(t,e.options.extraKeys,r,e)||oo(t,e.options.keyMap,r,e)}function xo(e,t,r,n){var i=e.state.keySeq;if(i){if(lo(t))return"handled";Gs.set(50,function(){e.state.keySeq==i&&(e.state.keySeq=null,e.display.input.reset())}),t=i+" "+t}var o=wo(e,t,n);return"multi"==o&&(e.state.keySeq=t),"handled"==o&&bt(e,"keyHandled",e,t,r),"handled"!=o&&"multi"!=o||(We(r),Ar(e)),i&&!o&&/\'$/.test(t)?(We(r),!0):!!o}function Co(e,t){var r=ao(t,!0);return!!r&&(t.shiftKey&&!e.state.keySeq?xo(e,"Shift-"+r,t,function(t){return bo(e,t,!0)})||xo(e,r,t,function(t){if("string"==typeof t?/^go[A-Z]/.test(t):t.motion)return bo(e,t)}):xo(e,r,t,function(t){return bo(e,t)}))}function So(e,t,r){return xo(e,"'"+r+"'",t,function(t){return bo(e,t,!0)})}function Lo(e){var t=this;if(t.curOp.focus=l(),!Me(t,e)){gl&&vl<11&&27==e.keyCode&&(e.returnValue=!1);var r=e.keyCode;t.display.shift=16==r||e.shiftKey;var n=Co(t,e);wl&&(Us=n?r:null,!n&&88==r&&!rs&&(Ml?e.metaKey:e.ctrlKey)&&t.replaceSelection("",null,"cut")),18!=r||/\bCodeMirror-crosshair\b/.test(t.display.lineDiv.className)||ko(t)}}function ko(e){function t(e){18!=e.keyCode&&e.altKey||(Fl(r,"CodeMirror-crosshair"),ke(document,"keyup",t),ke(document,"mouseover",t))}var r=e.display.lineDiv;s(r,"CodeMirror-crosshair"),Ql(document,"keyup",t),Ql(document,"mouseover",t)}function To(e){16==e.keyCode&&(this.doc.sel.shift=!1),Me(this,e)}function Mo(e){var t=this;if(!(Ft(t.display,e)||Me(t,e)||e.ctrlKey&&!e.altKey||Ml&&e.metaKey)){var r=e.keyCode,n=e.charCode;if(wl&&r==Us)return Us=null,void We(e);if(!wl||e.which&&!(e.which<10)||!Co(t,e)){var i=String.fromCharCode(null==n?r:n);"\b"!=i&&(So(t,e,i)||t.display.input.onKeyPress(e))}}}function No(e,t){var r=+new Date;return js&&js.compare(r,e,t)?(Ks=js=null,"triple"):Ks&&Ks.compare(r,e,t)?(js=new Vs(r,e,t),Ks=null,"double"):(Ks=new Vs(r,e,t),js=null,"single")}function Oo(e){var t=this,r=t.display;if(!(Me(t,e)||r.activeTouch&&r.input.supportsTouch()))if(r.input.ensurePolled(),r.shift=e.shiftKey,Ft(r,e))ml||(r.scroller.draggable=!1,setTimeout(function(){return r.scroller.draggable=!0},100));else if(!zo(t,e)){var n=Sr(t,e),i=Pe(e),o=n?No(n,i):"single";window.focus(),1==i&&t.state.selectingText&&t.state.selectingText(e),n&&Ao(t,i,n,o,e)||(1==i?n?Do(t,n,o,e):Ee(e)==r.scroller&&We(e):2==i?(n&&di(t.doc,n),setTimeout(function(){return r.input.focus()},20)):3==i&&(Hl?Ro(t,e):Dr(t)))}}function Ao(e,t,r,n,i){var o="Click";return"double"==n?o="Double"+o:"triple"==n&&(o="Triple"+o),o=(1==t?"Left":2==t?"Middle":"Right")+o,xo(e,so(o,i),i,function(t){if("string"==typeof t&&(t=Bs[t]),!t)return!1;var n=!1;try{e.isReadOnly()&&(e.state.suppressEdits=!0),n=t(e,r)!=Bl}finally{e.state.suppressEdits=!1}return n})}function Wo(e,t,r){var n=e.getOption("configureMouse"),i=n?n(e,t,r):{};if(null==i.unit){var o=Nl?r.shiftKey&&r.metaKey:r.altKey;i.unit=o?"rectangle":"single"==t?"char":"double"==t?"word":"line"}return(null==i.extend||e.doc.extend)&&(i.extend=e.doc.extend||r.shiftKey),null==i.addNew&&(i.addNew=Ml?r.metaKey:r.ctrlKey),null==i.moveOnDrag&&(i.moveOnDrag=!(Ml?r.altKey:r.ctrlKey)),i}function Do(e,t,r,n){gl?setTimeout(u(Wr,e),0):e.curOp.focus=l();var i,o=Wo(e,r,n),s=e.doc.sel;e.options.dragDrop&&Jl&&!e.isReadOnly()&&"single"==r&&(i=s.contains(t))>-1&&(P((i=s.ranges[i]).from(),t)<0||t.xRel>0)&&(P(i.to(),t)>0||t.xRel<0)?Ho(e,n,t,o):Eo(e,n,t,o)}function Ho(e,t,r,n){var i=e.display,o=!1,l=dn(e,function(t){ml&&(i.scroller.draggable=!1),e.state.draggingText=!1,ke(document,"mouseup",l),ke(document,"mousemove",s),ke(i.scroller,"dragstart",a),ke(i.scroller,"drop",l),o||(We(t),n.addNew||di(e.doc,r,null,null,n.extend),ml||gl&&9==vl?setTimeout(function(){document.body.focus(),i.input.focus()},20):i.input.focus())}),s=function(e){o=o||Math.abs(t.clientX-e.clientX)+Math.abs(t.clientY-e.clientY)>=10},a=function(){return o=!0};ml&&(i.scroller.draggable=!0),e.state.draggingText=l,l.copy=!n.moveOnDrag,i.scroller.dragDrop&&i.scroller.dragDrop(),Ql(document,"mouseup",l),Ql(document,"mousemove",s),Ql(i.scroller,"dragstart",a),Ql(i.scroller,"drop",l),Dr(e),setTimeout(function(){return i.input.focus()},20)}function Fo(e,t,r){if("char"==r)return new Ts(t,t);if("word"==r)return e.findWordAt(t);if("line"==r)return new Ts(E(t.line,0),U(e.doc,E(t.line+1,0)));var n=r(e,t);return new Ts(n.from,n.to)}function Eo(e,t,r,n){function i(t){if(0!=P(m,t))if(m=t,"rectangle"==n.unit){for(var i=[],o=e.options.tabSize,l=f(M(u,r.line).text,r.ch,o),s=f(M(u,t.line).text,t.ch,o),a=Math.min(l,s),g=Math.max(l,s),v=Math.min(r.line,t.line),y=Math.min(e.lastLine(),Math.max(r.line,t.line));v<=y;v++){var b=M(u,v).text,w=d(b,a,o);a==g?i.push(new Ts(E(v,w),E(v,w))):b.length>w&&i.push(new Ts(E(v,w),E(v,d(b,g,o))))}i.length||i.push(new Ts(r,r)),bi(u,zn(p.ranges.slice(0,h).concat(i),h),{origin:"*mouse",scroll:!1}),e.scrollIntoView(t)}else{var x,C=c,S=Fo(e,t,n.unit),L=C.anchor;P(S.anchor,L)>0?(x=S.head,L=B(C.from(),S.anchor)):(x=S.anchor,L=R(C.to(),S.head));var k=p.ranges.slice(0);k[h]=Po(e,new Ts(U(u,L),x)),bi(u,zn(k,h),Ul)}}function o(t){var r=++b,s=Sr(e,t,!0,"rectangle"==n.unit);if(s)if(0!=P(s,m)){e.curOp.focus=l(),i(s);var c=Ir(a,u);(s.line>=c.to||s.line<c.from)&&setTimeout(dn(e,function(){b==r&&o(t)}),150)}else{var f=t.clientY<y.top?-20:t.clientY>y.bottom?20:0;f&&setTimeout(dn(e,function(){b==r&&(a.scroller.scrollTop+=f,o(t))}),50)}}function s(t){e.state.selectingText=!1,b=1/0,We(t),a.input.focus(),ke(document,"mousemove",w),ke(document,"mouseup",x),u.history.lastSelOrigin=null}var a=e.display,u=e.doc;We(t);var c,h,p=u.sel,g=p.ranges;if(n.addNew&&!n.extend?(h=u.sel.contains(r),c=h>-1?g[h]:new Ts(r,r)):(c=u.sel.primary(),h=u.sel.primIndex),"rectangle"==n.unit)n.addNew||(c=new Ts(r,r)),r=Sr(e,t,!0,!0),h=-1;else{var v=Fo(e,r,n.unit);c=n.extend?hi(c,v.anchor,v.head,n.extend):v}n.addNew?-1==h?(h=g.length,bi(u,zn(g.concat([c]),h),{scroll:!1,origin:"*mouse"})):g.length>1&&g[h].empty()&&"char"==n.unit&&!n.extend?(bi(u,zn(g.slice(0,h).concat(g.slice(h+1)),0),{scroll:!1,origin:"*mouse"}),p=u.sel):gi(u,h,c,Ul):(h=0,bi(u,new ks([c],0),Ul),p=u.sel);var m=r,y=a.wrapper.getBoundingClientRect(),b=0,w=dn(e,function(e){Pe(e)?o(e):s(e)}),x=dn(e,s);e.state.selectingText=x,Ql(document,"mousemove",w),Ql(document,"mouseup",x)}function Po(e,t){var r=t.anchor,n=t.head,i=M(e.doc,r.line);if(0==P(r,n)&&r.sticky==n.sticky)return t;var o=Se(i);if(!o)return t;var l=Ce(o,r.ch,r.sticky),s=o[l];if(s.from!=r.ch&&s.to!=r.ch)return t;var a=l+(s.from==r.ch==(1!=s.level)?0:1);if(0==a||a==o.length)return t;var u;if(n.line!=r.line)u=(n.line-r.line)*("ltr"==e.doc.direction?1:-1)>0;else{var c=Ce(o,n.ch,n.sticky),f=c-l||(n.ch-r.ch)*(1==s.level?-1:1);u=c==a-1||c==a?f<0:f>0}var h=o[a+(u?-1:0)],d=u==(1==h.level),p=d?h.from:h.to,g=d?"after":"before";return r.ch==p&&r.sticky==g?t:new Ts(new E(r.line,p,g),n)}function Io(e,t,r,n){var i,o;if(t.touches)i=t.touches[0].clientX,o=t.touches[0].clientY;else try{i=t.clientX,o=t.clientY}catch(t){return!1}if(i>=Math.floor(e.display.gutters.getBoundingClientRect().right))return!1;n&&We(t);var l=e.display,s=l.lineDiv.getBoundingClientRect();if(o>s.bottom||!Oe(e,r))return He(t);o-=s.top-l.viewOffset;for(var a=0;a<e.options.gutters.length;++a){var u=l.gutters.childNodes[a];if(u&&u.getBoundingClientRect().right>=i)return Te(e,r,e,D(e.doc,o),e.options.gutters[a],t),He(t)}}function zo(e,t){return Io(e,t,"gutterClick",!0)}function Ro(e,t){Ft(e.display,t)||Bo(e,t)||Me(e,t,"contextmenu")||e.display.input.onContextMenu(t)}function Bo(e,t){return!!Oe(e,"gutterContextMenu")&&Io(e,t,"gutterContextMenu",!1)}function Go(e){e.display.wrapper.className=e.display.wrapper.className.replace(/\s*cm-s-\S+/g,"")+e.options.theme.replace(/(^|\s)\s*/g," cm-s-"),er(e)}function Uo(e){Hn(e),vn(e),zr(e)}function Vo(e,t,r){if(!t!=!(r&&r!=Xs)){var n=e.display.dragFunctions,i=t?Ql:ke;i(e.display.scroller,"dragstart",n.start),i(e.display.scroller,"dragenter",n.enter),i(e.display.scroller,"dragover",n.over),i(e.display.scroller,"dragleave",n.leave),i(e.display.scroller,"drop",n.drop)}}function Ko(e){e.options.lineWrapping?(s(e.display.wrapper,"CodeMirror-wrap"),e.display.sizer.style.minWidth="",e.display.sizerWidth=null):(Fl(e.display.wrapper,"CodeMirror-wrap"),we(e)),Cr(e),vn(e),er(e),setTimeout(function(){return en(e)},100)}function jo(e,t){var r=this;if(!(this instanceof jo))return new jo(e,t);this.options=t=t?c(t):{},c(Ys,t,!1),Fn(t);var n=t.value;"string"==typeof n&&(n=new Ds(n,t.mode,null,t.lineSeparator,t.direction)),this.doc=n;var i=new jo.inputStyles[t.inputStyle](this),o=this.display=new T(e,n,i);o.wrapper.CodeMirror=this,Hn(this),Go(this),t.lineWrapping&&(this.display.wrapper.className+=" CodeMirror-wrap"),rn(this),this.state={keyMaps:[],overlays:[],modeGen:0,overwrite:!1,delayingBlurEvent:!1,focused:!1,suppressEdits:!1,pasteIncoming:!1,cutIncoming:!1,selectingText:!1,draggingText:!1,highlight:new Pl,keySeq:null,specialChars:null},t.autofocus&&!Tl&&o.input.focus(),gl&&vl<11&&setTimeout(function(){return r.display.input.reset(!0)},20),Xo(this),eo(),nn(this),this.curOp.forceUpdate=!0,qn(this,n),t.autofocus&&!Tl||this.hasFocus()?setTimeout(u(Hr,this),20):Fr(this);for(var l in _s)_s.hasOwnProperty(l)&&_s[l](r,t[l],Xs);Rr(this),t.finishInit&&t.finishInit(this);for(var s=0;s<$s.length;++s)$s[s](r);on(this),ml&&t.lineWrapping&&"optimizelegibility"==getComputedStyle(o.lineDiv).textRendering&&(o.lineDiv.style.textRendering="auto")}function Xo(e){function t(){i.activeTouch&&(o=setTimeout(function(){return i.activeTouch=null},1e3),(l=i.activeTouch).end=+new Date)}function r(e){if(1!=e.touches.length)return!1;var t=e.touches[0];return t.radiusX<=1&&t.radiusY<=1}function n(e,t){if(null==t.left)return!0;var r=t.left-e.left,n=t.top-e.top;return r*r+n*n>400}var i=e.display;Ql(i.scroller,"mousedown",dn(e,Oo)),gl&&vl<11?Ql(i.scroller,"dblclick",dn(e,function(t){if(!Me(e,t)){var r=Sr(e,t);if(r&&!zo(e,t)&&!Ft(e.display,t)){We(t);var n=e.findWordAt(r);di(e.doc,n.anchor,n.head)}}})):Ql(i.scroller,"dblclick",function(t){return Me(e,t)||We(t)}),Hl||Ql(i.scroller,"contextmenu",function(t){return Ro(e,t)});var o,l={end:0};Ql(i.scroller,"touchstart",function(t){if(!Me(e,t)&&!r(t)&&!zo(e,t)){i.input.ensurePolled(),clearTimeout(o);var n=+new Date;i.activeTouch={start:n,moved:!1,prev:n-l.end<=300?l:null},1==t.touches.length&&(i.activeTouch.left=t.touches[0].pageX,i.activeTouch.top=t.touches[0].pageY)}}),Ql(i.scroller,"touchmove",function(){i.activeTouch&&(i.activeTouch.moved=!0)}),Ql(i.scroller,"touchend",function(r){var o=i.activeTouch;if(o&&!Ft(i,r)&&null!=o.left&&!o.moved&&new Date-o.start<300){var l,s=e.coordsChar(i.activeTouch,"page");l=!o.prev||n(o,o.prev)?new Ts(s,s):!o.prev.prev||n(o,o.prev.prev)?e.findWordAt(s):new Ts(E(s.line,0),U(e.doc,E(s.line+1,0))),e.setSelection(l.anchor,l.head),e.focus(),We(r)}t()}),Ql(i.scroller,"touchcancel",t),Ql(i.scroller,"scroll",function(){i.scroller.clientHeight&&(qr(e,i.scroller.scrollTop),Qr(e,i.scroller.scrollLeft,!0),Te(e,"scroll",e))}),Ql(i.scroller,"mousewheel",function(t){return In(e,t)}),Ql(i.scroller,"DOMMouseScroll",function(t){return In(e,t)}),Ql(i.wrapper,"scroll",function(){return i.wrapper.scrollTop=i.wrapper.scrollLeft=0}),i.dragFunctions={enter:function(t){Me(e,t)||Fe(t)},over:function(t){Me(e,t)||(Zi(e,t),Fe(t))},start:function(t){return qi(e,t)},drop:dn(e,$i),leave:function(t){Me(e,t)||Qi(e)}};var s=i.input.getField();Ql(s,"keyup",function(t){return To.call(e,t)}),Ql(s,"keydown",dn(e,Lo)),Ql(s,"keypress",dn(e,Mo)),Ql(s,"focus",function(t){return Hr(e,t)}),Ql(s,"blur",function(t){return Fr(e,t)})}function Yo(e,t,r,n){var i,o=e.doc;null==r&&(r="add"),"smart"==r&&(o.mode.indent?i=$e(e,t).state:r="prev");var l=e.options.tabSize,s=M(o,t),a=f(s.text,null,l);s.stateAfter&&(s.stateAfter=null);var u,c=s.text.match(/^\s*/)[0];if(n||/\S/.test(s.text)){if("smart"==r&&((u=o.mode.indent(i,s.text.slice(c.length),s.text))==Bl||u>150)){if(!n)return;r="prev"}}else u=0,r="not";"prev"==r?u=t>o.first?f(M(o,t-1).text,null,l):0:"add"==r?u=a+e.options.indentUnit:"subtract"==r?u=a-e.options.indentUnit:"number"==typeof r&&(u=a+r),u=Math.max(0,u);var h="",d=0;if(e.options.indentWithTabs)for(var g=Math.floor(u/l);g;--g)d+=l,h+="\t";if(d<u&&(h+=p(u-d)),h!=c)return Ei(o,h,E(t,0),E(t,c.length),"+input"),s.stateAfter=null,!0;for(var v=0;v<o.sel.ranges.length;v++){var m=o.sel.ranges[v];if(m.head.line==t&&m.head.ch<c.length){var y=E(t,c.length);gi(o,v,new Ts(y,y));break}}}function _o(e){qs=e}function $o(e,t,r,n,i){var o=e.doc;e.display.shift=!1,n||(n=o.sel);var l=e.state.pasteIncoming||"paste"==i,s=es(t),a=null;if(l&&n.ranges.length>1)if(qs&&qs.text.join("\n")==t){if(n.ranges.length%qs.text.length==0){a=[];for(var u=0;u<qs.text.length;u++)a.push(o.splitLines(qs.text[u]))}}else s.length==n.ranges.length&&e.options.pasteLinesPerSelection&&(a=v(s,function(e){return[e]}));for(var c,f=n.ranges.length-1;f>=0;f--){var h=n.ranges[f],d=h.from(),p=h.to();h.empty()&&(r&&r>0?d=E(d.line,d.ch-r):e.state.overwrite&&!l?p=E(p.line,Math.min(M(o,p.line).text.length,p.ch+g(s).length)):qs&&qs.lineWise&&qs.text.join("\n")==t&&(d=p=E(d.line,0))),c=e.curOp.updateInput;var m={from:d,to:p,text:a?a[f%a.length]:s,origin:i||(l?"paste":e.state.cutIncoming?"cut":"+input")};Oi(e.doc,m),bt(e,"inputRead",e,m)}t&&!l&&Zo(e,t),jr(e),e.curOp.updateInput=c,e.curOp.typing=!0,e.state.pasteIncoming=e.state.cutIncoming=!1}function qo(e,t){var r=e.clipboardData&&e.clipboardData.getData("Text");if(r)return e.preventDefault(),t.isReadOnly()||t.options.disableInput||hn(t,function(){return $o(t,r,0,null,"paste")}),!0}function Zo(e,t){if(e.options.electricChars&&e.options.smartIndent)for(var r=e.doc.sel,n=r.ranges.length-1;n>=0;n--){var i=r.ranges[n];if(!(i.head.ch>100||n&&r.ranges[n-1].head.line==i.head.line)){var o=e.getModeAt(i.head),l=!1;if(o.electricChars){for(var s=0;s<o.electricChars.length;s++)if(t.indexOf(o.electricChars.charAt(s))>-1){l=Yo(e,i.head.line,"smart");break}}else o.electricInput&&o.electricInput.test(M(e.doc,i.head.line).text.slice(0,i.head.ch))&&(l=Yo(e,i.head.line,"smart"));l&&bt(e,"electricInput",e,i.head.line)}}}function Qo(e){for(var t=[],r=[],n=0;n<e.doc.sel.ranges.length;n++){var i=e.doc.sel.ranges[n].head.line,o={anchor:E(i,0),head:E(i+1,0)};r.push(o),t.push(e.getRange(o.anchor,o.head))}return{text:t,ranges:r}}function Jo(e,t){e.setAttribute("autocorrect","off"),e.setAttribute("autocapitalize","off"),e.setAttribute("spellcheck",!!t)}function el(){var e=n("textarea",null,null,"position: absolute; bottom: -1em; padding: 0; width: 1px; height: 1em; outline: none"),t=n("div",[e],null,"overflow: hidden; position: relative; width: 3px; height: 0px;");return ml?e.style.width="1000px":e.setAttribute("wrap","off"),Ll&&(e.style.border="1px solid black"),Jo(e),t}function tl(e,t,r,n,i){function o(){var n=t.line+r;return!(n<e.first||n>=e.first+e.size)&&(t=new E(n,t.ch,t.sticky),u=M(e,n))}function l(n){var l;if(null==(l=i?go(e.cm,u,t,r):ho(u,t,r))){if(n||!o())return!1;t=po(i,e.cm,u,t.line,r)}else t=l;return!0}var s=t,a=r,u=M(e,t.line);if("char"==n)l();else if("column"==n)l(!0);else if("word"==n||"group"==n)for(var c=null,f="group"==n,h=e.cm&&e.cm.getHelper(t,"wordChars"),d=!0;!(r<0)||l(!d);d=!1){var p=u.text.charAt(t.ch)||"\n",g=x(p,h)?"w":f&&"\n"==p?"n":!f||/\s/.test(p)?null:"p";if(!f||d||g||(g="s"),c&&c!=g){r<0&&(r=1,l(),t.sticky="after");break}if(g&&(c=g),r>0&&!l(!d))break}var v=ki(e,t,s,a,!0);return I(s,v)&&(v.hitSide=!0),v}function rl(e,t,r,n){var i,o=e.doc,l=t.left;if("page"==n){var s=Math.min(e.display.wrapper.clientHeight,window.innerHeight||document.documentElement.clientHeight),a=Math.max(s-.5*mr(e.display),3);i=(r>0?t.bottom:t.top)+r*a}else"line"==n&&(i=r>0?t.bottom+3:t.top-3);for(var u;(u=cr(e,l,i)).outside;){if(r<0?i<=0:i>=o.height){u.hitSide=!0;break}i+=5*r}return u}function nl(e,t){var r=jt(e,t.line);if(!r||r.hidden)return null;var n=M(e.doc,t.line),i=Ut(r,n,t.line),o=Se(n,e.doc.direction),l="left";o&&(l=Ce(o,t.ch)%2?"right":"left");var s=_t(i.map,t.ch,l);return s.offset="right"==s.collapse?s.end:s.start,s}function il(e){for(var t=e;t;t=t.parentNode)if(/CodeMirror-gutter-wrapper/.test(t.className))return!0;return!1}function ol(e,t){return t&&(e.bad=!0),e}function ll(e,t,r,n,i){function o(e){return function(t){return t.id==e}}function l(){c&&(u+=f,c=!1)}function s(e){e&&(l(),u+=e)}function a(t){if(1==t.nodeType){var r=t.getAttribute("cm-text");if(null!=r)return void s(r||t.textContent.replace(/\u200b/g,""));var u,h=t.getAttribute("cm-marker");if(h){var d=e.findMarks(E(n,0),E(i+1,0),o(+h));return void(d.length&&(u=d[0].find(0))&&s(N(e.doc,u.from,u.to).join(f)))}if("false"==t.getAttribute("contenteditable"))return;var p=/^(pre|div|p)$/i.test(t.nodeName);p&&l();for(var g=0;g<t.childNodes.length;g++)a(t.childNodes[g]);p&&(c=!0)}else 3==t.nodeType&&s(t.nodeValue)}for(var u="",c=!1,f=e.doc.lineSeparator();a(t),t!=r;)t=t.nextSibling;return u}function sl(e,t,r){var n;if(t==e.display.lineDiv){if(!(n=e.display.lineDiv.childNodes[r]))return ol(e.clipPos(E(e.display.viewTo-1)),!0);t=null,r=0}else for(n=t;;n=n.parentNode){if(!n||n==e.display.lineDiv)return null;if(n.parentNode&&n.parentNode==e.display.lineDiv)break}for(var i=0;i<e.display.view.length;i++){var o=e.display.view[i];if(o.node==n)return al(o,t,r)}}function al(e,t,r){function n(t,r,n){for(var i=-1;i<(f?f.length:0);i++)for(var o=i<0?c.map:f[i],l=0;l<o.length;l+=3){var s=o[l+2];if(s==t||s==r){var a=W(i<0?e.line:e.rest[i]),u=o[l]+n;return(n<0||s!=t)&&(u=o[l+(n?1:0)]),E(a,u)}}}var i=e.text.firstChild,l=!1;if(!t||!o(i,t))return ol(E(W(e.line),0),!0);if(t==i&&(l=!0,t=i.childNodes[r],r=0,!t)){var s=e.rest?g(e.rest):e.line;return ol(E(W(s),s.text.length),l)}var a=3==t.nodeType?t:null,u=t;for(a||1!=t.childNodes.length||3!=t.firstChild.nodeType||(a=t.firstChild,r&&(r=a.nodeValue.length));u.parentNode!=i;)u=u.parentNode;var c=e.measure,f=c.maps,h=n(a,u,r);if(h)return ol(h,l);for(var d=u.nextSibling,p=a?a.nodeValue.length-r:0;d;d=d.nextSibling){if(h=n(d,d.firstChild,0))return ol(E(h.line,h.ch-p),l);p+=d.textContent.length}for(var v=u.previousSibling,m=r;v;v=v.previousSibling){if(h=n(v,v.firstChild,-1))return ol(E(h.line,h.ch+m),l);m+=v.textContent.length}}var ul=navigator.userAgent,cl=navigator.platform,fl=/gecko\/\d/i.test(ul),hl=/MSIE \d/.test(ul),dl=/Trident\/(?:[7-9]|\d{2,})\..*rv:(\d+)/.exec(ul),pl=/Edge\/(\d+)/.exec(ul),gl=hl||dl||pl,vl=gl&&(hl?document.documentMode||6:+(pl||dl)[1]),ml=!pl&&/WebKit\//.test(ul),yl=ml&&/Qt\/\d+\.\d+/.test(ul),bl=!pl&&/Chrome\//.test(ul),wl=/Opera\//.test(ul),xl=/Apple Computer/.test(navigator.vendor),Cl=/Mac OS X 1\d\D([8-9]|\d\d)\D/.test(ul),Sl=/PhantomJS/.test(ul),Ll=!pl&&/AppleWebKit/.test(ul)&&/Mobile\/\w+/.test(ul),kl=/Android/.test(ul),Tl=Ll||kl||/webOS|BlackBerry|Opera Mini|Opera Mobi|IEMobile/i.test(ul),Ml=Ll||/Mac/.test(cl),Nl=/\bCrOS\b/.test(ul),Ol=/win/i.test(cl),Al=wl&&ul.match(/Version\/(\d*\.\d*)/);Al&&(Al=Number(Al[1])),Al&&Al>=15&&(wl=!1,ml=!0);var Wl,Dl=Ml&&(yl||wl&&(null==Al||Al<12.11)),Hl=fl||gl&&vl>=9,Fl=function(t,r){var n=t.className,i=e(r).exec(n);if(i){var o=n.slice(i.index+i[0].length);t.className=n.slice(0,i.index)+(o?i[1]+o:"")}};Wl=document.createRange?function(e,t,r,n){var i=document.createRange();return i.setEnd(n||e,r),i.setStart(e,t),i}:function(e,t,r){var n=document.body.createTextRange();try{n.moveToElementText(e.parentNode)}catch(e){return n}return n.collapse(!0),n.moveEnd("character",r),n.moveStart("character",t),n};var El=function(e){e.select()};Ll?El=function(e){e.selectionStart=0,e.selectionEnd=e.value.length}:gl&&(El=function(e){try{e.select()}catch(e){}});var Pl=function(){this.id=null};Pl.prototype.set=function(e,t){clearTimeout(this.id),this.id=setTimeout(t,e)};var Il,zl,Rl=30,Bl={toString:function(){return"CodeMirror.Pass"}},Gl={scroll:!1},Ul={origin:"*mouse"},Vl={origin:"+move"},Kl=[""],jl=/[\u00df\u0587\u0590-\u05f4\u0600-\u06ff\u3040-\u309f\u30a0-\u30ff\u3400-\u4db5\u4e00-\u9fcc\uac00-\ud7af]/,Xl=/[\u0300-\u036f\u0483-\u0489\u0591-\u05bd\u05bf\u05c1\u05c2\u05c4\u05c5\u05c7\u0610-\u061a\u064b-\u065e\u0670\u06d6-\u06dc\u06de-\u06e4\u06e7\u06e8\u06ea-\u06ed\u0711\u0730-\u074a\u07a6-\u07b0\u07eb-\u07f3\u0816-\u0819\u081b-\u0823\u0825-\u0827\u0829-\u082d\u0900-\u0902\u093c\u0941-\u0948\u094d\u0951-\u0955\u0962\u0963\u0981\u09bc\u09be\u09c1-\u09c4\u09cd\u09d7\u09e2\u09e3\u0a01\u0a02\u0a3c\u0a41\u0a42\u0a47\u0a48\u0a4b-\u0a4d\u0a51\u0a70\u0a71\u0a75\u0a81\u0a82\u0abc\u0ac1-\u0ac5\u0ac7\u0ac8\u0acd\u0ae2\u0ae3\u0b01\u0b3c\u0b3e\u0b3f\u0b41-\u0b44\u0b4d\u0b56\u0b57\u0b62\u0b63\u0b82\u0bbe\u0bc0\u0bcd\u0bd7\u0c3e-\u0c40\u0c46-\u0c48\u0c4a-\u0c4d\u0c55\u0c56\u0c62\u0c63\u0cbc\u0cbf\u0cc2\u0cc6\u0ccc\u0ccd\u0cd5\u0cd6\u0ce2\u0ce3\u0d3e\u0d41-\u0d44\u0d4d\u0d57\u0d62\u0d63\u0dca\u0dcf\u0dd2-\u0dd4\u0dd6\u0ddf\u0e31\u0e34-\u0e3a\u0e47-\u0e4e\u0eb1\u0eb4-\u0eb9\u0ebb\u0ebc\u0ec8-\u0ecd\u0f18\u0f19\u0f35\u0f37\u0f39\u0f71-\u0f7e\u0f80-\u0f84\u0f86\u0f87\u0f90-\u0f97\u0f99-\u0fbc\u0fc6\u102d-\u1030\u1032-\u1037\u1039\u103a\u103d\u103e\u1058\u1059\u105e-\u1060\u1071-\u1074\u1082\u1085\u1086\u108d\u109d\u135f\u1712-\u1714\u1732-\u1734\u1752\u1753\u1772\u1773\u17b7-\u17bd\u17c6\u17c9-\u17d3\u17dd\u180b-\u180d\u18a9\u1920-\u1922\u1927\u1928\u1932\u1939-\u193b\u1a17\u1a18\u1a56\u1a58-\u1a5e\u1a60\u1a62\u1a65-\u1a6c\u1a73-\u1a7c\u1a7f\u1b00-\u1b03\u1b34\u1b36-\u1b3a\u1b3c\u1b42\u1b6b-\u1b73\u1b80\u1b81\u1ba2-\u1ba5\u1ba8\u1ba9\u1c2c-\u1c33\u1c36\u1c37\u1cd0-\u1cd2\u1cd4-\u1ce0\u1ce2-\u1ce8\u1ced\u1dc0-\u1de6\u1dfd-\u1dff\u200c\u200d\u20d0-\u20f0\u2cef-\u2cf1\u2de0-\u2dff\u302a-\u302f\u3099\u309a\ua66f-\ua672\ua67c\ua67d\ua6f0\ua6f1\ua802\ua806\ua80b\ua825\ua826\ua8c4\ua8e0-\ua8f1\ua926-\ua92d\ua947-\ua951\ua980-\ua982\ua9b3\ua9b6-\ua9b9\ua9bc\uaa29-\uaa2e\uaa31\uaa32\uaa35\uaa36\uaa43\uaa4c\uaab0\uaab2-\uaab4\uaab7\uaab8\uaabe\uaabf\uaac1\uabe5\uabe8\uabed\udc00-\udfff\ufb1e\ufe00-\ufe0f\ufe20-\ufe26\uff9e\uff9f]/,Yl=!1,_l=!1,$l=null,ql=function(){function e(e){return e<=247?r.charAt(e):1424<=e&&e<=1524?"R":1536<=e&&e<=1785?n.charAt(e-1536):1774<=e&&e<=2220?"r":8192<=e&&e<=8203?"w":8204==e?"b":"L"}function t(e,t,r){this.level=e,this.from=t,this.to=r}var r="bbbbbbbbbtstwsbbbbbbbbbbbbbbssstwNN%%%NNNNNN,N,N1111111111NNNNNNNLLLLLLLLLLLLLLLLLLLLLLLLLLNNNNNNLLLLLLLLLLLLLLLLLLLLLLLLLLNNNNbbbbbbsbbbbbbbbbbbbbbbbbbbbbbbbbb,N%%%%NNNNLNNNNN%%11NLNNN1LNNNNNLLLLLLLLLLLLLLLLLLLLLLLNLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLN",n="nnnnnnNNr%%r,rNNmmmmmmmmmmmrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrmmmmmmmmmmmmmmmmmmmmmnnnnnnnnnn%nnrrrmrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrmmmmmmmnNmmmmmmrrmmNmmmmrr1111111111",i=/[\u0590-\u05f4\u0600-\u06ff\u0700-\u08ac]/,o=/[stwN]/,l=/[LRr]/,s=/[Lb1n]/,a=/[1n]/;return function(r,n){var u="ltr"==n?"L":"R";if(0==r.length||"ltr"==n&&!i.test(r))return!1;for(var c=r.length,f=[],h=0;h<c;++h)f.push(e(r.charCodeAt(h)));for(var d=0,p=u;d<c;++d){var v=f[d];"m"==v?f[d]=p:p=v}for(var m=0,y=u;m<c;++m){var b=f[m];"1"==b&&"r"==y?f[m]="n":l.test(b)&&(y=b,"r"==b&&(f[m]="R"))}for(var w=1,x=f[0];w<c-1;++w){var C=f[w];"+"==C&&"1"==x&&"1"==f[w+1]?f[w]="1":","!=C||x!=f[w+1]||"1"!=x&&"n"!=x||(f[w]=x),x=C}for(var S=0;S<c;++S){var L=f[S];if(","==L)f[S]="N";else if("%"==L){var k=void 0;for(k=S+1;k<c&&"%"==f[k];++k);for(var T=S&&"!"==f[S-1]||k<c&&"1"==f[k]?"1":"N",M=S;M<k;++M)f[M]=T;S=k-1}}for(var N=0,O=u;N<c;++N){var A=f[N];"L"==O&&"1"==A?f[N]="L":l.test(A)&&(O=A)}for(var W=0;W<c;++W)if(o.test(f[W])){var D=void 0;for(D=W+1;D<c&&o.test(f[D]);++D);for(var H="L"==(W?f[W-1]:u),F=H==("L"==(D<c?f[D]:u))?H?"L":"R":u,E=W;E<D;++E)f[E]=F;W=D-1}for(var P,I=[],z=0;z<c;)if(s.test(f[z])){var R=z;for(++z;z<c&&s.test(f[z]);++z);I.push(new t(0,R,z))}else{var B=z,G=I.length;for(++z;z<c&&"L"!=f[z];++z);for(var U=B;U<z;)if(a.test(f[U])){B<U&&I.splice(G,0,new t(1,B,U));var V=U;for(++U;U<z&&a.test(f[U]);++U);I.splice(G,0,new t(2,V,U)),B=U}else++U;B<z&&I.splice(G,0,new t(1,B,z))}return 1==I[0].level&&(P=r.match(/^\s+/))&&(I[0].from=P[0].length,I.unshift(new t(0,0,P[0].length))),1==g(I).level&&(P=r.match(/\s+$/))&&(g(I).to-=P[0].length,I.push(new t(0,c-P[0].length,c))),"rtl"==n?I.reverse():I}}(),Zl=[],Ql=function(e,t,r){if(e.addEventListener)e.addEventListener(t,r,!1);else if(e.attachEvent)e.attachEvent("on"+t,r);else{var n=e._handlers||(e._handlers={});n[t]=(n[t]||Zl).concat(r)}},Jl=function(){if(gl&&vl<9)return!1;var e=n("div");return"draggable"in e||"dragDrop"in e}(),es=3!="\n\nb".split(/\n/).length?function(e){for(var t=0,r=[],n=e.length;t<=n;){var i=e.indexOf("\n",t);-1==i&&(i=e.length);var o=e.slice(t,"\r"==e.charAt(i-1)?i-1:i),l=o.indexOf("\r");-1!=l?(r.push(o.slice(0,l)),t+=l+1):(r.push(o),t=i+1)}return r}:function(e){return e.split(/\r\n?|\n/)},ts=window.getSelection?function(e){try{return e.selectionStart!=e.selectionEnd}catch(e){return!1}}:function(e){var t;try{t=e.ownerDocument.selection.createRange()}catch(e){}return!(!t||t.parentElement()!=e)&&0!=t.compareEndPoints("StartToEnd",t)},rs=function(){var e=n("div");return"oncopy"in e||(e.setAttribute("oncopy","return;"),"function"==typeof e.oncopy)}(),ns=null,is={},os={},ls={},ss=function(e,t,r){this.pos=this.start=0,this.string=e,this.tabSize=t||8,this.lastColumnPos=this.lastColumnValue=0,this.lineStart=0,this.lineOracle=r};ss.prototype.eol=function(){return this.pos>=this.string.length},ss.prototype.sol=function(){return this.pos==this.lineStart},ss.prototype.peek=function(){return this.string.charAt(this.pos)||void 0},ss.prototype.next=function(){if(this.pos<this.string.length)return this.string.charAt(this.pos++)},ss.prototype.eat=function(e){var t=this.string.charAt(this.pos);if("string"==typeof e?t==e:t&&(e.test?e.test(t):e(t)))return++this.pos,t},ss.prototype.eatWhile=function(e){for(var t=this.pos;this.eat(e););return this.pos>t},ss.prototype.eatSpace=function(){for(var e=this,t=this.pos;/[\s\u00a0]/.test(this.string.charAt(this.pos));)++e.pos;return this.pos>t},ss.prototype.skipToEnd=function(){this.pos=this.string.length},ss.prototype.skipTo=function(e){var t=this.string.indexOf(e,this.pos);if(t>-1)return this.pos=t,!0},ss.prototype.backUp=function(e){this.pos-=e},ss.prototype.column=function(){return this.lastColumnPos<this.start&&(this.lastColumnValue=f(this.string,this.start,this.tabSize,this.lastColumnPos,this.lastColumnValue),this.lastColumnPos=this.start),this.lastColumnValue-(this.lineStart?f(this.string,this.lineStart,this.tabSize):0)},ss.prototype.indentation=function(){return f(this.string,null,this.tabSize)-(this.lineStart?f(this.string,this.lineStart,this.tabSize):0)},ss.prototype.match=function(e,t,r){if("string"!=typeof e){var n=this.string.slice(this.pos).match(e);return n&&n.index>0?null:(n&&!1!==t&&(this.pos+=n[0].length),n)}var i=function(e){return r?e.toLowerCase():e};if(i(this.string.substr(this.pos,e.length))==i(e))return!1!==t&&(this.pos+=e.length),!0},ss.prototype.current=function(){return this.string.slice(this.start,this.pos)},ss.prototype.hideFirstChars=function(e,t){this.lineStart+=e;try{return t()}finally{this.lineStart-=e}},ss.prototype.lookAhead=function(e){var t=this.lineOracle;return t&&t.lookAhead(e)};var as=function(e,t){this.state=e,this.lookAhead=t},us=function(e,t,r,n){this.state=t,this.doc=e,this.line=r,this.maxLookAhead=n||0};us.prototype.lookAhead=function(e){var t=this.doc.getLine(this.line+e);return null!=t&&e>this.maxLookAhead&&(this.maxLookAhead=e),t},us.prototype.nextLine=function(){this.line++,this.maxLookAhead>0&&this.maxLookAhead--},us.fromSaved=function(e,t,r){return t instanceof as?new us(e,Ke(e.mode,t.state),r,t.lookAhead):new us(e,Ke(e.mode,t),r)},us.prototype.save=function(e){var t=!1!==e?Ke(this.doc.mode,this.state):this.state;return this.maxLookAhead>0?new as(t,this.maxLookAhead):t};var cs=function(e,t,r){this.start=e.start,this.end=e.pos,this.string=e.current(),this.type=t||null,this.state=r},fs=function(e,t,r){this.text=e,ne(this,t),this.height=r?r(this):1};fs.prototype.lineNo=function(){return W(this)},Ae(fs);var hs,ds={},ps={},gs=null,vs=null,ms={left:0,right:0,top:0,bottom:0},ys=function(e,t,r){this.cm=r;var i=this.vert=n("div",[n("div",null,null,"min-width: 1px")],"CodeMirror-vscrollbar"),o=this.horiz=n("div",[n("div",null,null,"height: 100%; min-height: 1px")],"CodeMirror-hscrollbar");e(i),e(o),Ql(i,"scroll",function(){i.clientHeight&&t(i.scrollTop,"vertical")}),Ql(o,"scroll",function(){o.clientWidth&&t(o.scrollLeft,"horizontal")}),this.checkedZeroWidth=!1,gl&&vl<8&&(this.horiz.style.minHeight=this.vert.style.minWidth="18px")};ys.prototype.update=function(e){var t=e.scrollWidth>e.clientWidth+1,r=e.scrollHeight>e.clientHeight+1,n=e.nativeBarWidth;if(r){this.vert.style.display="block",this.vert.style.bottom=t?n+"px":"0";var i=e.viewHeight-(t?n:0);this.vert.firstChild.style.height=Math.max(0,e.scrollHeight-e.clientHeight+i)+"px"}else this.vert.style.display="",this.vert.firstChild.style.height="0";if(t){this.horiz.style.display="block",this.horiz.style.right=r?n+"px":"0",this.horiz.style.left=e.barLeft+"px";var o=e.viewWidth-e.barLeft-(r?n:0);this.horiz.firstChild.style.width=Math.max(0,e.scrollWidth-e.clientWidth+o)+"px"}else this.horiz.style.display="",this.horiz.firstChild.style.width="0";return!this.checkedZeroWidth&&e.clientHeight>0&&(0==n&&this.zeroWidthHack(),this.checkedZeroWidth=!0),{right:r?n:0,bottom:t?n:0}},ys.prototype.setScrollLeft=function(e){this.horiz.scrollLeft!=e&&(this.horiz.scrollLeft=e),this.disableHoriz&&this.enableZeroWidthBar(this.horiz,this.disableHoriz,"horiz")},ys.prototype.setScrollTop=function(e){this.vert.scrollTop!=e&&(this.vert.scrollTop=e),this.disableVert&&this.enableZeroWidthBar(this.vert,this.disableVert,"vert")},ys.prototype.zeroWidthHack=function(){var e=Ml&&!Cl?"12px":"18px";this.horiz.style.height=this.vert.style.width=e,this.horiz.style.pointerEvents=this.vert.style.pointerEvents="none",this.disableHoriz=new Pl,this.disableVert=new Pl},ys.prototype.enableZeroWidthBar=function(e,t,r){function n(){var i=e.getBoundingClientRect();("vert"==r?document.elementFromPoint(i.right-1,(i.top+i.bottom)/2):document.elementFromPoint((i.right+i.left)/2,i.bottom-1))!=e?e.style.pointerEvents="none":t.set(1e3,n)}e.style.pointerEvents="auto",t.set(1e3,n)},ys.prototype.clear=function(){var e=this.horiz.parentNode;e.removeChild(this.horiz),e.removeChild(this.vert)};var bs=function(){};bs.prototype.update=function(){return{bottom:0,right:0}},bs.prototype.setScrollLeft=function(){},bs.prototype.setScrollTop=function(){},bs.prototype.clear=function(){};var ws={native:ys,null:bs},xs=0,Cs=function(e,t,r){var n=e.display;this.viewport=t,this.visible=Ir(n,e.doc,t),this.editorIsHidden=!n.wrapper.offsetWidth,this.wrapperHeight=n.wrapper.clientHeight,this.wrapperWidth=n.wrapper.clientWidth,this.oldDisplayWidth=Rt(e),this.force=r,this.dims=br(e),this.events=[]};Cs.prototype.signal=function(e,t){Oe(e,t)&&this.events.push(arguments)},Cs.prototype.finish=function(){for(var e=this,t=0;t<this.events.length;t++)Te.apply(null,e.events[t])};var Ss=0,Ls=null;gl?Ls=-.53:fl?Ls=15:bl?Ls=-.7:xl&&(Ls=-1/3);var ks=function(e,t){this.ranges=e,this.primIndex=t};ks.prototype.primary=function(){return this.ranges[this.primIndex]},ks.prototype.equals=function(e){var t=this;if(e==this)return!0;if(e.primIndex!=this.primIndex||e.ranges.length!=this.ranges.length)return!1;for(var r=0;r<this.ranges.length;r++){var n=t.ranges[r],i=e.ranges[r];if(!I(n.anchor,i.anchor)||!I(n.head,i.head))return!1}return!0},ks.prototype.deepCopy=function(){for(var e=this,t=[],r=0;r<this.ranges.length;r++)t[r]=new Ts(z(e.ranges[r].anchor),z(e.ranges[r].head));return new ks(t,this.primIndex)},ks.prototype.somethingSelected=function(){for(var e=this,t=0;t<this.ranges.length;t++)if(!e.ranges[t].empty())return!0;return!1},ks.prototype.contains=function(e,t){var r=this;t||(t=e);for(var n=0;n<this.ranges.length;n++){var i=r.ranges[n];if(P(t,i.from())>=0&&P(e,i.to())<=0)return n}return-1};var Ts=function(e,t){this.anchor=e,this.head=t};Ts.prototype.from=function(){return B(this.anchor,this.head)},Ts.prototype.to=function(){return R(this.anchor,this.head)},Ts.prototype.empty=function(){return this.head.line==this.anchor.line&&this.head.ch==this.anchor.ch},Bi.prototype={chunkSize:function(){return this.lines.length},removeInner:function(e,t){for(var r=this,n=e,i=e+t;n<i;++n){var o=r.lines[n];r.height-=o.height,ot(o),bt(o,"delete")}this.lines.splice(e,t)},collapse:function(e){e.push.apply(e,this.lines)},insertInner:function(e,t,r){var n=this;this.height+=r,this.lines=this.lines.slice(0,e).concat(t).concat(this.lines.slice(e));for(var i=0;i<t.length;++i)t[i].parent=n},iterN:function(e,t,r){for(var n=this,i=e+t;e<i;++e)if(r(n.lines[e]))return!0}},Gi.prototype={chunkSize:function(){return this.size},removeInner:function(e,t){var r=this;this.size-=t;for(var n=0;n<this.children.length;++n){var i=r.children[n],o=i.chunkSize();if(e<o){var l=Math.min(t,o-e),s=i.height;if(i.removeInner(e,l),r.height-=s-i.height,o==l&&(r.children.splice(n--,1),i.parent=null),0==(t-=l))break;e=0}else e-=o}if(this.size-t<25&&(this.children.length>1||!(this.children[0]instanceof Bi))){var a=[];this.collapse(a),this.children=[new Bi(a)],this.children[0].parent=this}},collapse:function(e){for(var t=this,r=0;r<this.children.length;++r)t.children[r].collapse(e)},insertInner:function(e,t,r){var n=this;this.size+=t.length,this.height+=r;for(var i=0;i<this.children.length;++i){var o=n.children[i],l=o.chunkSize();if(e<=l){if(o.insertInner(e,t,r),o.lines&&o.lines.length>50){for(var s=o.lines.length%25+25,a=s;a<o.lines.length;){var u=new Bi(o.lines.slice(a,a+=25));o.height-=u.height,n.children.splice(++i,0,u),u.parent=n}o.lines=o.lines.slice(0,s),n.maybeSpill()}break}e-=l}},maybeSpill:function(){if(!(this.children.length<=10)){var e=this;do{var t=new Gi(e.children.splice(e.children.length-5,5));if(e.parent){e.size-=t.size,e.height-=t.height;var r=h(e.parent.children,e);e.parent.children.splice(r+1,0,t)}else{var n=new Gi(e.children);n.parent=e,e.children=[n,t],e=n}t.parent=e.parent}while(e.children.length>10);e.parent.maybeSpill()}},iterN:function(e,t,r){for(var n=this,i=0;i<this.children.length;++i){var o=n.children[i],l=o.chunkSize();if(e<l){var s=Math.min(t,l-e);if(o.iterN(e,s,r))return!0;if(0==(t-=s))break;e=0}else e-=l}}};var Ms=function(e,t,r){var n=this;if(r)for(var i in r)r.hasOwnProperty(i)&&(n[i]=r[i]);this.doc=e,this.node=t};Ms.prototype.clear=function(){var e=this,t=this.doc.cm,r=this.line.widgets,n=this.line,i=W(n);if(null!=i&&r){for(var o=0;o<r.length;++o)r[o]==e&&r.splice(o--,1);r.length||(n.widgets=null);var l=Ht(this);A(n,Math.max(0,n.height-l)),t&&(hn(t,function(){Ui(t,n,-l),mn(t,i,"widget")}),bt(t,"lineWidgetCleared",t,this,i))}},Ms.prototype.changed=function(){var e=this,t=this.height,r=this.doc.cm,n=this.line;this.height=null;var i=Ht(this)-t;i&&(A(n,n.height+i),r&&hn(r,function(){r.curOp.forceUpdate=!0,Ui(r,n,i),bt(r,"lineWidgetChanged",r,e,W(n))}))},Ae(Ms);var Ns=0,Os=function(e,t){this.lines=[],this.type=t,this.doc=e,this.id=++Ns};Os.prototype.clear=function(){var e=this;if(!this.explicitlyCleared){var t=this.doc.cm,r=t&&!t.curOp;if(r&&nn(t),Oe(this,"clear")){var n=this.find();n&&bt(this,"clear",n.from,n.to)}for(var i=null,o=null,l=0;l<this.lines.length;++l){var s=e.lines[l],a=_(s.markedSpans,e);t&&!e.collapsed?mn(t,W(s),"text"):t&&(null!=a.to&&(o=W(s)),null!=a.from&&(i=W(s))),s.markedSpans=$(s.markedSpans,a),null==a.from&&e.collapsed&&!ve(e.doc,s)&&t&&A(s,mr(t.display))}if(t&&this.collapsed&&!t.options.lineWrapping)for(var u=0;u<this.lines.length;++u){var c=fe(e.lines[u]),f=be(c);f>t.display.maxLineLength&&(t.display.maxLine=c,t.display.maxLineLength=f,t.display.maxLineChanged=!0)}null!=i&&t&&this.collapsed&&vn(t,i,o+1),this.lines.length=0,this.explicitlyCleared=!0,this.atomic&&this.doc.cantEdit&&(this.doc.cantEdit=!1,t&&Ci(t.doc)),t&&bt(t,"markerCleared",t,this,i,o),r&&on(t),this.parent&&this.parent.clear()}},Os.prototype.find=function(e,t){var r=this;null==e&&"bookmark"==this.type&&(e=1);for(var n,i,o=0;o<this.lines.length;++o){var l=r.lines[o],s=_(l.markedSpans,r);if(null!=s.from&&(n=E(t?l:W(l),s.from),-1==e))return n;if(null!=s.to&&(i=E(t?l:W(l),s.to),1==e))return i}return n&&{from:n,to:i}},Os.prototype.changed=function(){var e=this,t=this.find(-1,!0),r=this,n=this.doc.cm;t&&n&&hn(n,function(){var i=t.line,o=W(t.line),l=jt(n,o);if(l&&(Qt(l),n.curOp.selectionChanged=n.curOp.forceUpdate=!0),n.curOp.updateMaxLine=!0,!ve(r.doc,i)&&null!=r.height){var s=r.height;r.height=null;var a=Ht(r)-s;a&&A(i,i.height+a)}bt(n,"markerChanged",n,e)})},Os.prototype.attachLine=function(e){if(!this.lines.length&&this.doc.cm){var t=this.doc.cm.curOp;t.maybeHiddenMarkers&&-1!=h(t.maybeHiddenMarkers,this)||(t.maybeUnhiddenMarkers||(t.maybeUnhiddenMarkers=[])).push(this)}this.lines.push(e)},Os.prototype.detachLine=function(e){if(this.lines.splice(h(this.lines,e),1),!this.lines.length&&this.doc.cm){var t=this.doc.cm.curOp;(t.maybeHiddenMarkers||(t.maybeHiddenMarkers=[])).push(this)}},Ae(Os);var As=function(e,t){var r=this;this.markers=e,this.primary=t;for(var n=0;n<e.length;++n)e[n].parent=r};As.prototype.clear=function(){var e=this;if(!this.explicitlyCleared){this.explicitlyCleared=!0;for(var t=0;t<this.markers.length;++t)e.markers[t].clear();bt(this,"clear")}},As.prototype.find=function(e,t){return this.primary.find(e,t)},Ae(As);var Ws=0,Ds=function(e,t,r,n,i){if(!(this instanceof Ds))return new Ds(e,t,r,n,i);null==r&&(r=0),Gi.call(this,[new Bi([new fs("",null)])]),this.first=r,this.scrollTop=this.scrollLeft=0,this.cantEdit=!1,this.cleanGeneration=1,this.modeFrontier=this.highlightFrontier=r;var o=E(r,0);this.sel=Rn(o),this.history=new Jn(null),this.id=++Ws,this.modeOption=t,this.lineSep=n,this.direction="rtl"==i?"rtl":"ltr",this.extend=!1,"string"==typeof e&&(e=this.splitLines(e)),_n(this,{from:o,to:o,text:e}),bi(this,Rn(o),Gl)};Ds.prototype=b(Gi.prototype,{constructor:Ds,iter:function(e,t,r){r?this.iterN(e-this.first,t-e,r):this.iterN(this.first,this.first+this.size,e)},insert:function(e,t){for(var r=0,n=0;n<t.length;++n)r+=t[n].height;this.insertInner(e-this.first,t,r)},remove:function(e,t){this.removeInner(e-this.first,t)},getValue:function(e){var t=O(this,this.first,this.first+this.size);return!1===e?t:t.join(e||this.lineSeparator())},setValue:gn(function(e){var t=E(this.first,0),r=this.first+this.size-1;Oi(this,{from:t,to:E(r,M(this,r).text.length),text:this.splitLines(e),origin:"setValue",full:!0},!0),this.cm&&Xr(this.cm,0,0),bi(this,Rn(t),Gl)}),replaceRange:function(e,t,r,n){Ei(this,e,t=U(this,t),r=r?U(this,r):t,n)},getRange:function(e,t,r){var n=N(this,U(this,e),U(this,t));return!1===r?n:n.join(r||this.lineSeparator())},getLine:function(e){var t=this.getLineHandle(e);return t&&t.text},getLineHandle:function(e){if(H(this,e))return M(this,e)},getLineNumber:function(e){return W(e)},getLineHandleVisualStart:function(e){return"number"==typeof e&&(e=M(this,e)),fe(e)},lineCount:function(){return this.size},firstLine:function(){return this.first},lastLine:function(){return this.first+this.size-1},clipPos:function(e){return U(this,e)},getCursor:function(e){var t=this.sel.primary();return null==e||"head"==e?t.head:"anchor"==e?t.anchor:"end"==e||"to"==e||!1===e?t.to():t.from()},listSelections:function(){return this.sel.ranges},somethingSelected:function(){return this.sel.somethingSelected()},setCursor:gn(function(e,t,r){vi(this,U(this,"number"==typeof e?E(e,t||0):e),null,r)}),setSelection:gn(function(e,t,r){vi(this,U(this,e),U(this,t||e),r)}),extendSelection:gn(function(e,t,r){di(this,U(this,e),t&&U(this,t),r)}),extendSelections:gn(function(e,t){pi(this,K(this,e),t)}),extendSelectionsBy:gn(function(e,t){pi(this,K(this,v(this.sel.ranges,e)),t)}),setSelections:gn(function(e,t,r){var n=this;if(e.length){for(var i=[],o=0;o<e.length;o++)i[o]=new Ts(U(n,e[o].anchor),U(n,e[o].head));null==t&&(t=Math.min(e.length-1,this.sel.primIndex)),bi(this,zn(i,t),r)}}),addSelection:gn(function(e,t,r){var n=this.sel.ranges.slice(0);n.push(new Ts(U(this,e),U(this,t||e))),bi(this,zn(n,n.length-1),r)}),getSelection:function(e){for(var t,r=this,n=this.sel.ranges,i=0;i<n.length;i++){var o=N(r,n[i].from(),n[i].to());t=t?t.concat(o):o}return!1===e?t:t.join(e||this.lineSeparator())},getSelections:function(e){for(var t=this,r=[],n=this.sel.ranges,i=0;i<n.length;i++){var o=N(t,n[i].from(),n[i].to());!1!==e&&(o=o.join(e||t.lineSeparator())),r[i]=o}return r},replaceSelection:function(e,t,r){for(var n=[],i=0;i<this.sel.ranges.length;i++)n[i]=e;this.replaceSelections(n,t,r||"+input")},replaceSelections:gn(function(e,t,r){for(var n=this,i=[],o=this.sel,l=0;l<o.ranges.length;l++){var s=o.ranges[l];i[l]={from:s.from(),to:s.to(),text:n.splitLines(e[l]),origin:r}}for(var a=t&&"end"!=t&&Kn(this,i,t),u=i.length-1;u>=0;u--)Oi(n,i[u]);a?yi(this,a):this.cm&&jr(this.cm)}),undo:gn(function(){Wi(this,"undo")}),redo:gn(function(){Wi(this,"redo")}),undoSelection:gn(function(){Wi(this,"undo",!0)}),redoSelection:gn(function(){Wi(this,"redo",!0)}),setExtending:function(e){this.extend=e},getExtending:function(){return this.extend},historySize:function(){for(var e=this.history,t=0,r=0,n=0;n<e.done.length;n++)e.done[n].ranges||++t;for(var i=0;i<e.undone.length;i++)e.undone[i].ranges||++r;return{undo:t,redo:r}},clearHistory:function(){this.history=new Jn(this.history.maxGeneration)},markClean:function(){this.cleanGeneration=this.changeGeneration(!0)},changeGeneration:function(e){return e&&(this.history.lastOp=this.history.lastSelOp=this.history.lastOrigin=null),this.history.generation},isClean:function(e){return this.history.generation==(e||this.cleanGeneration)},getHistory:function(){return{done:fi(this.history.done),undone:fi(this.history.undone)}},setHistory:function(e){var t=this.history=new Jn(this.history.maxGeneration);t.done=fi(e.done.slice(0),null,!0),t.undone=fi(e.undone.slice(0),null,!0)},setGutterMarker:gn(function(e,t,r){return Ri(this,e,"gutter",function(e){var n=e.gutterMarkers||(e.gutterMarkers={});return n[t]=r,!r&&C(n)&&(e.gutterMarkers=null),!0})}),clearGutter:gn(function(e){var t=this;this.iter(function(r){r.gutterMarkers&&r.gutterMarkers[e]&&Ri(t,r,"gutter",function(){return r.gutterMarkers[e]=null,C(r.gutterMarkers)&&(r.gutterMarkers=null),!0})})}),lineInfo:function(e){var t;if("number"==typeof e){if(!H(this,e))return null;if(t=e,!(e=M(this,e)))return null}else if(null==(t=W(e)))return null;return{line:t,handle:e,text:e.text,gutterMarkers:e.gutterMarkers,textClass:e.textClass,bgClass:e.bgClass,wrapClass:e.wrapClass,widgets:e.widgets}},addLineClass:gn(function(t,r,n){return Ri(this,t,"gutter"==r?"gutter":"class",function(t){var i="text"==r?"textClass":"background"==r?"bgClass":"gutter"==r?"gutterClass":"wrapClass";if(t[i]){if(e(n).test(t[i]))return!1;t[i]+=" "+n}else t[i]=n;return!0})}),removeLineClass:gn(function(t,r,n){return Ri(this,t,"gutter"==r?"gutter":"class",function(t){var i="text"==r?"textClass":"background"==r?"bgClass":"gutter"==r?"gutterClass":"wrapClass",o=t[i];if(!o)return!1;if(null==n)t[i]=null;else{var l=o.match(e(n));if(!l)return!1;var s=l.index+l[0].length;t[i]=o.slice(0,l.index)+(l.index&&s!=o.length?" ":"")+o.slice(s)||null}return!0})}),addLineWidget:gn(function(e,t,r){return Vi(this,e,t,r)}),removeLineWidget:function(e){e.clear()},markText:function(e,t,r){return Ki(this,U(this,e),U(this,t),r,r&&r.type||"range")},setBookmark:function(e,t){var r={replacedWith:t&&(null==t.nodeType?t.widget:t),insertLeft:t&&t.insertLeft,clearWhenEmpty:!1,shared:t&&t.shared,handleMouseEvents:t&&t.handleMouseEvents};return e=U(this,e),Ki(this,e,e,r,"bookmark")},findMarksAt:function(e){var t=[],r=M(this,(e=U(this,e)).line).markedSpans;if(r)for(var n=0;n<r.length;++n){var i=r[n];(null==i.from||i.from<=e.ch)&&(null==i.to||i.to>=e.ch)&&t.push(i.marker.parent||i.marker)}return t},findMarks:function(e,t,r){e=U(this,e),t=U(this,t);var n=[],i=e.line;return this.iter(e.line,t.line+1,function(o){var l=o.markedSpans;if(l)for(var s=0;s<l.length;s++){var a=l[s];null!=a.to&&i==e.line&&e.ch>=a.to||null==a.from&&i!=e.line||null!=a.from&&i==t.line&&a.from>=t.ch||r&&!r(a.marker)||n.push(a.marker.parent||a.marker)}++i}),n},getAllMarks:function(){var e=[];return this.iter(function(t){var r=t.markedSpans;if(r)for(var n=0;n<r.length;++n)null!=r[n].from&&e.push(r[n].marker)}),e},posFromIndex:function(e){var t,r=this.first,n=this.lineSeparator().length;return this.iter(function(i){var o=i.text.length+n;if(o>e)return t=e,!0;e-=o,++r}),U(this,E(r,t))},indexFromPos:function(e){var t=(e=U(this,e)).ch;if(e.line<this.first||e.ch<0)return 0;var r=this.lineSeparator().length;return this.iter(this.first,e.line,function(e){t+=e.text.length+r}),t},copy:function(e){var t=new Ds(O(this,this.first,this.first+this.size),this.modeOption,this.first,this.lineSep,this.direction);return t.scrollTop=this.scrollTop,t.scrollLeft=this.scrollLeft,t.sel=this.sel,t.extend=!1,e&&(t.history.undoDepth=this.history.undoDepth,t.setHistory(this.getHistory())),t},linkedDoc:function(e){e||(e={});var t=this.first,r=this.first+this.size;null!=e.from&&e.from>t&&(t=e.from),null!=e.to&&e.to<r&&(r=e.to);var n=new Ds(O(this,t,r),e.mode||this.modeOption,t,this.lineSep,this.direction);return e.sharedHist&&(n.history=this.history),(this.linked||(this.linked=[])).push({doc:n,sharedHist:e.sharedHist}),n.linked=[{doc:this,isParent:!0,sharedHist:e.sharedHist}],Yi(n,Xi(this)),n},unlinkDoc:function(e){var t=this;if(e instanceof jo&&(e=e.doc),this.linked)for(var r=0;r<this.linked.length;++r)if(t.linked[r].doc==e){t.linked.splice(r,1),e.unlinkDoc(t),_i(Xi(t));break}if(e.history==this.history){var n=[e.id];$n(e,function(e){return n.push(e.id)},!0),e.history=new Jn(null),e.history.done=fi(this.history.done,n),e.history.undone=fi(this.history.undone,n)}},iterLinkedDocs:function(e){$n(this,e)},getMode:function(){return this.mode},getEditor:function(){return this.cm},splitLines:function(e){return this.lineSep?e.split(this.lineSep):es(e)},lineSeparator:function(){return this.lineSep||"\n"},setDirection:gn(function(e){"rtl"!=e&&(e="ltr"),e!=this.direction&&(this.direction=e,this.iter(function(e){return e.order=null}),this.cm&&Qn(this.cm))})}),Ds.prototype.eachLine=Ds.prototype.iter;for(var Hs=0,Fs=!1,Es={3:"Enter",8:"Backspace",9:"Tab",13:"Enter",16:"Shift",17:"Ctrl",18:"Alt",19:"Pause",20:"CapsLock",27:"Esc",32:"Space",33:"PageUp",34:"PageDown",35:"End",36:"Home",37:"Left",38:"Up",39:"Right",40:"Down",44:"PrintScrn",45:"Insert",46:"Delete",59:";",61:"=",91:"Mod",92:"Mod",93:"Mod",106:"*",107:"=",109:"-",110:".",111:"/",127:"Delete",173:"-",186:";",187:"=",188:",",189:"-",190:".",191:"/",192:"`",219:"[",220:"\\",221:"]",222:"'",63232:"Up",63233:"Down",63234:"Left",63235:"Right",63272:"Delete",63273:"Home",63275:"End",63276:"PageUp",63277:"PageDown",63302:"Insert"},Ps=0;Ps<10;Ps++)Es[Ps+48]=Es[Ps+96]=String(Ps);for(var Is=65;Is<=90;Is++)Es[Is]=String.fromCharCode(Is);for(var zs=1;zs<=12;zs++)Es[zs+111]=Es[zs+63235]="F"+zs;var Rs={};Rs.basic={Left:"goCharLeft",Right:"goCharRight",Up:"goLineUp",Down:"goLineDown",End:"goLineEnd",Home:"goLineStartSmart",PageUp:"goPageUp",PageDown:"goPageDown",Delete:"delCharAfter",Backspace:"delCharBefore","Shift-Backspace":"delCharBefore",Tab:"defaultTab","Shift-Tab":"indentAuto",Enter:"newlineAndIndent",Insert:"toggleOverwrite",Esc:"singleSelection"},Rs.pcDefault={"Ctrl-A":"selectAll","Ctrl-D":"deleteLine","Ctrl-Z":"undo","Shift-Ctrl-Z":"redo","Ctrl-Y":"redo","Ctrl-Home":"goDocStart","Ctrl-End":"goDocEnd","Ctrl-Up":"goLineUp","Ctrl-Down":"goLineDown","Ctrl-Left":"goGroupLeft","Ctrl-Right":"goGroupRight","Alt-Left":"goLineStart","Alt-Right":"goLineEnd","Ctrl-Backspace":"delGroupBefore","Ctrl-Delete":"delGroupAfter","Ctrl-S":"save","Ctrl-F":"find","Ctrl-G":"findNext","Shift-Ctrl-G":"findPrev","Shift-Ctrl-F":"replace","Shift-Ctrl-R":"replaceAll","Ctrl-[":"indentLess","Ctrl-]":"indentMore","Ctrl-U":"undoSelection","Shift-Ctrl-U":"redoSelection","Alt-U":"redoSelection",fallthrough:"basic"},Rs.emacsy={"Ctrl-F":"goCharRight","Ctrl-B":"goCharLeft","Ctrl-P":"goLineUp","Ctrl-N":"goLineDown","Alt-F":"goWordRight","Alt-B":"goWordLeft","Ctrl-A":"goLineStart","Ctrl-E":"goLineEnd","Ctrl-V":"goPageDown","Shift-Ctrl-V":"goPageUp","Ctrl-D":"delCharAfter","Ctrl-H":"delCharBefore","Alt-D":"delWordAfter","Alt-Backspace":"delWordBefore","Ctrl-K":"killLine","Ctrl-T":"transposeChars","Ctrl-O":"openLine"},Rs.macDefault={"Cmd-A":"selectAll","Cmd-D":"deleteLine","Cmd-Z":"undo","Shift-Cmd-Z":"redo","Cmd-Y":"redo","Cmd-Home":"goDocStart","Cmd-Up":"goDocStart","Cmd-End":"goDocEnd","Cmd-Down":"goDocEnd","Alt-Left":"goGroupLeft","Alt-Right":"goGroupRight","Cmd-Left":"goLineLeft","Cmd-Right":"goLineRight","Alt-Backspace":"delGroupBefore","Ctrl-Alt-Backspace":"delGroupAfter","Alt-Delete":"delGroupAfter","Cmd-S":"save","Cmd-F":"find","Cmd-G":"findNext","Shift-Cmd-G":"findPrev","Cmd-Alt-F":"replace","Shift-Cmd-Alt-F":"replaceAll","Cmd-[":"indentLess","Cmd-]":"indentMore","Cmd-Backspace":"delWrappedLineLeft","Cmd-Delete":"delWrappedLineRight","Cmd-U":"undoSelection","Shift-Cmd-U":"redoSelection","Ctrl-Up":"goDocStart","Ctrl-Down":"goDocEnd",fallthrough:["basic","emacsy"]},Rs.default=Ml?Rs.macDefault:Rs.pcDefault;var Bs={selectAll:Mi,singleSelection:function(e){return e.setSelection(e.getCursor("anchor"),e.getCursor("head"),Gl)},killLine:function(e){return co(e,function(t){if(t.empty()){var r=M(e.doc,t.head.line).text.length;return t.head.ch==r&&t.head.line<e.lastLine()?{from:t.head,to:E(t.head.line+1,0)}:{from:t.head,to:E(t.head.line,r)}}return{from:t.from(),to:t.to()}})},deleteLine:function(e){return co(e,function(t){return{from:E(t.from().line,0),to:U(e.doc,E(t.to().line+1,0))}})},delLineLeft:function(e){return co(e,function(e){return{from:E(e.from().line,0),to:e.from()}})},delWrappedLineLeft:function(e){return co(e,function(t){var r=e.charCoords(t.head,"div").top+5;return{from:e.coordsChar({left:0,top:r},"div"),to:t.from()}})},delWrappedLineRight:function(e){return co(e,function(t){var r=e.charCoords(t.head,"div").top+5,n=e.coordsChar({left:e.display.lineDiv.offsetWidth+100,top:r},"div");return{from:t.from(),to:n}})},undo:function(e){return e.undo()},redo:function(e){return e.redo()},undoSelection:function(e){return e.undoSelection()},redoSelection:function(e){return e.redoSelection()},goDocStart:function(e){return e.extendSelection(E(e.firstLine(),0))},goDocEnd:function(e){return e.extendSelection(E(e.lastLine()))},goLineStart:function(e){return e.extendSelectionsBy(function(t){return vo(e,t.head.line)},{origin:"+move",bias:1})},goLineStartSmart:function(e){return e.extendSelectionsBy(function(t){return yo(e,t.head)},{origin:"+move",bias:1})},goLineEnd:function(e){return e.extendSelectionsBy(function(t){return mo(e,t.head.line)},{origin:"+move",bias:-1})},goLineRight:function(e){return e.extendSelectionsBy(function(t){var r=e.cursorCoords(t.head,"div").top+5;return e.coordsChar({left:e.display.lineDiv.offsetWidth+100,top:r},"div")},Vl)},goLineLeft:function(e){return e.extendSelectionsBy(function(t){var r=e.cursorCoords(t.head,"div").top+5;return e.coordsChar({left:0,top:r},"div")},Vl)},goLineLeftSmart:function(e){return e.extendSelectionsBy(function(t){var r=e.cursorCoords(t.head,"div").top+5,n=e.coordsChar({left:0,top:r},"div");return n.ch<e.getLine(n.line).search(/\S/)?yo(e,t.head):n},Vl)},goLineUp:function(e){return e.moveV(-1,"line")},goLineDown:function(e){return e.moveV(1,"line")},goPageUp:function(e){return e.moveV(-1,"page")},goPageDown:function(e){return e.moveV(1,"page")},goCharLeft:function(e){return e.moveH(-1,"char")},goCharRight:function(e){return e.moveH(1,"char")},goColumnLeft:function(e){return e.moveH(-1,"column")},goColumnRight:function(e){return e.moveH(1,"column")},goWordLeft:function(e){return e.moveH(-1,"word")},goGroupRight:function(e){return e.moveH(1,"group")},goGroupLeft:function(e){return e.moveH(-1,"group")},goWordRight:function(e){return e.moveH(1,"word")},delCharBefore:function(e){return e.deleteH(-1,"char")},delCharAfter:function(e){return e.deleteH(1,"char")},delWordBefore:function(e){return e.deleteH(-1,"word")},delWordAfter:function(e){return e.deleteH(1,"word")},delGroupBefore:function(e){return e.deleteH(-1,"group")},delGroupAfter:function(e){return e.deleteH(1,"group")},indentAuto:function(e){return e.indentSelection("smart")},indentMore:function(e){return e.indentSelection("add")},indentLess:function(e){return e.indentSelection("subtract")},insertTab:function(e){return e.replaceSelection("\t")},insertSoftTab:function(e){for(var t=[],r=e.listSelections(),n=e.options.tabSize,i=0;i<r.length;i++){var o=r[i].from(),l=f(e.getLine(o.line),o.ch,n);t.push(p(n-l%n))}e.replaceSelections(t)},defaultTab:function(e){e.somethingSelected()?e.indentSelection("add"):e.execCommand("insertTab")},transposeChars:function(e){return hn(e,function(){for(var t=e.listSelections(),r=[],n=0;n<t.length;n++)if(t[n].empty()){var i=t[n].head,o=M(e.doc,i.line).text;if(o)if(i.ch==o.length&&(i=new E(i.line,i.ch-1)),i.ch>0)i=new E(i.line,i.ch+1),e.replaceRange(o.charAt(i.ch-1)+o.charAt(i.ch-2),E(i.line,i.ch-2),i,"+transpose");else if(i.line>e.doc.first){var l=M(e.doc,i.line-1).text;l&&(i=new E(i.line,1),e.replaceRange(o.charAt(0)+e.doc.lineSeparator()+l.charAt(l.length-1),E(i.line-1,l.length-1),i,"+transpose"))}r.push(new Ts(i,i))}e.setSelections(r)})},newlineAndIndent:function(e){return hn(e,function(){for(var t=e.listSelections(),r=t.length-1;r>=0;r--)e.replaceRange(e.doc.lineSeparator(),t[r].anchor,t[r].head,"+input");t=e.listSelections();for(var n=0;n<t.length;n++)e.indentLine(t[n].from().line,null,!0);jr(e)})},openLine:function(e){return e.replaceSelection("\n","start")},toggleOverwrite:function(e){return e.toggleOverwrite()}},Gs=new Pl,Us=null,Vs=function(e,t,r){this.time=e,this.pos=t,this.button=r};Vs.prototype.compare=function(e,t,r){return this.time+400>e&&0==P(t,this.pos)&&r==this.button};var Ks,js,Xs={toString:function(){return"CodeMirror.Init"}},Ys={},_s={};jo.defaults=Ys,jo.optionHandlers=_s;var $s=[];jo.defineInitHook=function(e){return $s.push(e)};var qs=null,Zs=function(e){this.cm=e,this.lastAnchorNode=this.lastAnchorOffset=this.lastFocusNode=this.lastFocusOffset=null,this.polling=new Pl,this.composing=null,this.gracePeriod=!1,this.readDOMTimeout=null};Zs.prototype.init=function(e){function t(e){if(!Me(i,e)){if(i.somethingSelected())_o({lineWise:!1,text:i.getSelections()}),"cut"==e.type&&i.replaceSelection("",null,"cut");else{if(!i.options.lineWiseCopyCut)return;var t=Qo(i);_o({lineWise:!0,text:t.text}),"cut"==e.type&&i.operation(function(){i.setSelections(t.ranges,0,Gl),i.replaceSelection("",null,"cut")})}if(e.clipboardData){e.clipboardData.clearData();var r=qs.text.join("\n");if(e.clipboardData.setData("Text",r),e.clipboardData.getData("Text")==r)return void e.preventDefault()}var l=el(),s=l.firstChild;i.display.lineSpace.insertBefore(l,i.display.lineSpace.firstChild),s.value=qs.text.join("\n");var a=document.activeElement;El(s),setTimeout(function(){i.display.lineSpace.removeChild(l),a.focus(),a==o&&n.showPrimarySelection()},50)}}var r=this,n=this,i=n.cm,o=n.div=e.lineDiv;Jo(o,i.options.spellcheck),Ql(o,"paste",function(e){Me(i,e)||qo(e,i)||vl<=11&&setTimeout(dn(i,function(){return r.updateFromDOM()}),20)}),Ql(o,"compositionstart",function(e){r.composing={data:e.data,done:!1}}),Ql(o,"compositionupdate",function(e){r.composing||(r.composing={data:e.data,done:!1})}),Ql(o,"compositionend",function(e){r.composing&&(e.data!=r.composing.data&&r.readFromDOMSoon(),r.composing.done=!0)}),Ql(o,"touchstart",function(){return n.forceCompositionEnd()}),Ql(o,"input",function(){r.composing||r.readFromDOMSoon()}),Ql(o,"copy",t),Ql(o,"cut",t)},Zs.prototype.prepareSelection=function(){var e=Tr(this.cm,!1);return e.focus=this.cm.state.focused,e},Zs.prototype.showSelection=function(e,t){e&&this.cm.display.view.length&&((e.focus||t)&&this.showPrimarySelection(),this.showMultipleSelections(e))},Zs.prototype.showPrimarySelection=function(){var e=window.getSelection(),t=this.cm,r=t.doc.sel.primary(),n=r.from(),i=r.to();if(t.display.viewTo==t.display.viewFrom||n.line>=t.display.viewTo||i.line<t.display.viewFrom)e.removeAllRanges();else{var o=sl(t,e.anchorNode,e.anchorOffset),l=sl(t,e.focusNode,e.focusOffset);if(!o||o.bad||!l||l.bad||0!=P(B(o,l),n)||0!=P(R(o,l),i)){var s=t.display.view,a=n.line>=t.display.viewFrom&&nl(t,n)||{node:s[0].measure.map[2],offset:0},u=i.line<t.display.viewTo&&nl(t,i);if(!u){var c=s[s.length-1].measure,f=c.maps?c.maps[c.maps.length-1]:c.map;u={node:f[f.length-1],offset:f[f.length-2]-f[f.length-3]}}if(a&&u){var h,d=e.rangeCount&&e.getRangeAt(0);try{h=Wl(a.node,a.offset,u.offset,u.node)}catch(e){}h&&(!fl&&t.state.focused?(e.collapse(a.node,a.offset),h.collapsed||(e.removeAllRanges(),e.addRange(h))):(e.removeAllRanges(),e.addRange(h)),d&&null==e.anchorNode?e.addRange(d):fl&&this.startGracePeriod()),this.rememberSelection()}else e.removeAllRanges()}}},Zs.prototype.startGracePeriod=function(){var e=this;clearTimeout(this.gracePeriod),this.gracePeriod=setTimeout(function(){e.gracePeriod=!1,e.selectionChanged()&&e.cm.operation(function(){return e.cm.curOp.selectionChanged=!0})},20)},Zs.prototype.showMultipleSelections=function(e){r(this.cm.display.cursorDiv,e.cursors),r(this.cm.display.selectionDiv,e.selection)},Zs.prototype.rememberSelection=function(){var e=window.getSelection();this.lastAnchorNode=e.anchorNode,this.lastAnchorOffset=e.anchorOffset,this.lastFocusNode=e.focusNode,this.lastFocusOffset=e.focusOffset},Zs.prototype.selectionInEditor=function(){var e=window.getSelection();if(!e.rangeCount)return!1;var t=e.getRangeAt(0).commonAncestorContainer;return o(this.div,t)},Zs.prototype.focus=function(){"nocursor"!=this.cm.options.readOnly&&(this.selectionInEditor()||this.showSelection(this.prepareSelection(),!0),this.div.focus())},Zs.prototype.blur=function(){this.div.blur()},Zs.prototype.getField=function(){return this.div},Zs.prototype.supportsTouch=function(){return!0},Zs.prototype.receivedFocus=function(){function e(){t.cm.state.focused&&(t.pollSelection(),t.polling.set(t.cm.options.pollInterval,e))}var t=this;this.selectionInEditor()?this.pollSelection():hn(this.cm,function(){return t.cm.curOp.selectionChanged=!0}),this.polling.set(this.cm.options.pollInterval,e)},Zs.prototype.selectionChanged=function(){var e=window.getSelection();return e.anchorNode!=this.lastAnchorNode||e.anchorOffset!=this.lastAnchorOffset||e.focusNode!=this.lastFocusNode||e.focusOffset!=this.lastFocusOffset},Zs.prototype.pollSelection=function(){if(null==this.readDOMTimeout&&!this.gracePeriod&&this.selectionChanged()){var e=window.getSelection(),t=this.cm;if(kl&&bl&&this.cm.options.gutters.length&&il(e.anchorNode))return this.cm.triggerOnKeyDown({type:"keydown",keyCode:8,preventDefault:Math.abs}),this.blur(),void this.focus();if(!this.composing){this.rememberSelection();var r=sl(t,e.anchorNode,e.anchorOffset),n=sl(t,e.focusNode,e.focusOffset);r&&n&&hn(t,function(){bi(t.doc,Rn(r,n),Gl),(r.bad||n.bad)&&(t.curOp.selectionChanged=!0)})}}},Zs.prototype.pollContent=function(){null!=this.readDOMTimeout&&(clearTimeout(this.readDOMTimeout),this.readDOMTimeout=null);var e=this.cm,t=e.display,r=e.doc.sel.primary(),n=r.from(),i=r.to();if(0==n.ch&&n.line>e.firstLine()&&(n=E(n.line-1,M(e.doc,n.line-1).length)),i.ch==M(e.doc,i.line).text.length&&i.line<e.lastLine()&&(i=E(i.line+1,0)),n.line<t.viewFrom||i.line>t.viewTo-1)return!1;var o,l,s;n.line==t.viewFrom||0==(o=Lr(e,n.line))?(l=W(t.view[0].line),s=t.view[0].node):(l=W(t.view[o].line),s=t.view[o-1].node.nextSibling);var a,u,c=Lr(e,i.line);if(c==t.view.length-1?(a=t.viewTo-1,u=t.lineDiv.lastChild):(a=W(t.view[c+1].line)-1,u=t.view[c+1].node.previousSibling),!s)return!1;for(var f=e.doc.splitLines(ll(e,s,u,l,a)),h=N(e.doc,E(l,0),E(a,M(e.doc,a).text.length));f.length>1&&h.length>1;)if(g(f)==g(h))f.pop(),h.pop(),a--;else{if(f[0]!=h[0])break;f.shift(),h.shift(),l++}for(var d=0,p=0,v=f[0],m=h[0],y=Math.min(v.length,m.length);d<y&&v.charCodeAt(d)==m.charCodeAt(d);)++d;for(var b=g(f),w=g(h),x=Math.min(b.length-(1==f.length?d:0),w.length-(1==h.length?d:0));p<x&&b.charCodeAt(b.length-p-1)==w.charCodeAt(w.length-p-1);)++p;if(1==f.length&&1==h.length&&l==n.line)for(;d&&d>n.ch&&b.charCodeAt(b.length-p-1)==w.charCodeAt(w.length-p-1);)d--,p++;f[f.length-1]=b.slice(0,b.length-p).replace(/^\u200b+/,""),f[0]=f[0].slice(d).replace(/\u200b+$/,"");var C=E(l,d),S=E(a,h.length?g(h).length-p:0);return f.length>1||f[0]||P(C,S)?(Ei(e.doc,f,C,S,"+input"),!0):void 0},Zs.prototype.ensurePolled=function(){this.forceCompositionEnd()},Zs.prototype.reset=function(){this.forceCompositionEnd()},Zs.prototype.forceCompositionEnd=function(){this.composing&&(clearTimeout(this.readDOMTimeout),this.composing=null,this.updateFromDOM(),this.div.blur(),this.div.focus())},Zs.prototype.readFromDOMSoon=function(){var e=this;null==this.readDOMTimeout&&(this.readDOMTimeout=setTimeout(function(){if(e.readDOMTimeout=null,e.composing){if(!e.composing.done)return;e.composing=null}e.updateFromDOM()},80))},Zs.prototype.updateFromDOM=function(){var e=this;!this.cm.isReadOnly()&&this.pollContent()||hn(this.cm,function(){return vn(e.cm)})},Zs.prototype.setUneditable=function(e){e.contentEditable="false"},Zs.prototype.onKeyPress=function(e){0!=e.charCode&&(e.preventDefault(),this.cm.isReadOnly()||dn(this.cm,$o)(this.cm,String.fromCharCode(null==e.charCode?e.keyCode:e.charCode),0))},Zs.prototype.readOnlyChanged=function(e){this.div.contentEditable=String("nocursor"!=e)},Zs.prototype.onContextMenu=function(){},Zs.prototype.resetPosition=function(){},Zs.prototype.needsContentAttribute=!0;var Qs=function(e){this.cm=e,this.prevInput="",this.pollingFast=!1,this.polling=new Pl,this.hasSelection=!1,this.composing=null};Qs.prototype.init=function(e){function t(e){if(!Me(i,e)){if(i.somethingSelected())_o({lineWise:!1,text:i.getSelections()});else{if(!i.options.lineWiseCopyCut)return;var t=Qo(i);_o({lineWise:!0,text:t.text}),"cut"==e.type?i.setSelections(t.ranges,null,Gl):(n.prevInput="",l.value=t.text.join("\n"),El(l))}"cut"==e.type&&(i.state.cutIncoming=!0)}}var r=this,n=this,i=this.cm,o=this.wrapper=el(),l=this.textarea=o.firstChild;e.wrapper.insertBefore(o,e.wrapper.firstChild),Ll&&(l.style.width="0px"),Ql(l,"input",function(){gl&&vl>=9&&r.hasSelection&&(r.hasSelection=null),n.poll()}),Ql(l,"paste",function(e){Me(i,e)||qo(e,i)||(i.state.pasteIncoming=!0,n.fastPoll())}),Ql(l,"cut",t),Ql(l,"copy",t),Ql(e.scroller,"paste",function(t){Ft(e,t)||Me(i,t)||(i.state.pasteIncoming=!0,n.focus())}),Ql(e.lineSpace,"selectstart",function(t){Ft(e,t)||We(t)}),Ql(l,"compositionstart",function(){var e=i.getCursor("from");n.composing&&n.composing.range.clear(),n.composing={start:e,range:i.markText(e,i.getCursor("to"),{className:"CodeMirror-composing"})}}),Ql(l,"compositionend",function(){n.composing&&(n.poll(),n.composing.range.clear(),n.composing=null)})},Qs.prototype.prepareSelection=function(){var e=this.cm,t=e.display,r=e.doc,n=Tr(e);if(e.options.moveInputWithCursor){var i=sr(e,r.sel.primary().head,"div"),o=t.wrapper.getBoundingClientRect(),l=t.lineDiv.getBoundingClientRect();n.teTop=Math.max(0,Math.min(t.wrapper.clientHeight-10,i.top+l.top-o.top)),n.teLeft=Math.max(0,Math.min(t.wrapper.clientWidth-10,i.left+l.left-o.left))}return n},Qs.prototype.showSelection=function(e){var t=this.cm.display;r(t.cursorDiv,e.cursors),r(t.selectionDiv,e.selection),null!=e.teTop&&(this.wrapper.style.top=e.teTop+"px",this.wrapper.style.left=e.teLeft+"px")},Qs.prototype.reset=function(e){if(!this.contextMenuPending&&!this.composing){var t=this.cm;if(t.somethingSelected()){this.prevInput="";var r=t.getSelection();this.textarea.value=r,t.state.focused&&El(this.textarea),gl&&vl>=9&&(this.hasSelection=r)}else e||(this.prevInput=this.textarea.value="",gl&&vl>=9&&(this.hasSelection=null))}},Qs.prototype.getField=function(){return this.textarea},Qs.prototype.supportsTouch=function(){return!1},Qs.prototype.focus=function(){if("nocursor"!=this.cm.options.readOnly&&(!Tl||l()!=this.textarea))try{this.textarea.focus()}catch(e){}},Qs.prototype.blur=function(){this.textarea.blur()},Qs.prototype.resetPosition=function(){this.wrapper.style.top=this.wrapper.style.left=0},Qs.prototype.receivedFocus=function(){this.slowPoll()},Qs.prototype.slowPoll=function(){var e=this;this.pollingFast||this.polling.set(this.cm.options.pollInterval,function(){e.poll(),e.cm.state.focused&&e.slowPoll()})},Qs.prototype.fastPoll=function(){function e(){r.poll()||t?(r.pollingFast=!1,r.slowPoll()):(t=!0,r.polling.set(60,e))}var t=!1,r=this;r.pollingFast=!0,r.polling.set(20,e)},Qs.prototype.poll=function(){var e=this,t=this.cm,r=this.textarea,n=this.prevInput;if(this.contextMenuPending||!t.state.focused||ts(r)&&!n&&!this.composing||t.isReadOnly()||t.options.disableInput||t.state.keySeq)return!1;var i=r.value;if(i==n&&!t.somethingSelected())return!1;if(gl&&vl>=9&&this.hasSelection===i||Ml&&/[\uf700-\uf7ff]/.test(i))return t.display.input.reset(),!1;if(t.doc.sel==t.display.selForContextMenu){var o=i.charCodeAt(0);if(8203!=o||n||(n="​"),8666==o)return this.reset(),this.cm.execCommand("undo")}for(var l=0,s=Math.min(n.length,i.length);l<s&&n.charCodeAt(l)==i.charCodeAt(l);)++l;return hn(t,function(){$o(t,i.slice(l),n.length-l,null,e.composing?"*compose":null),i.length>1e3||i.indexOf("\n")>-1?r.value=e.prevInput="":e.prevInput=i,e.composing&&(e.composing.range.clear(),e.composing.range=t.markText(e.composing.start,t.getCursor("to"),{className:"CodeMirror-composing"}))}),!0},Qs.prototype.ensurePolled=function(){this.pollingFast&&this.poll()&&(this.pollingFast=!1)},Qs.prototype.onKeyPress=function(){gl&&vl>=9&&(this.hasSelection=null),this.fastPoll()},Qs.prototype.onContextMenu=function(e){function t(){if(null!=l.selectionStart){var e=i.somethingSelected(),t="​"+(e?l.value:"");l.value="⇚",l.value=t,n.prevInput=e?"":"​",l.selectionStart=1,l.selectionEnd=t.length,o.selForContextMenu=i.doc.sel}}function r(){if(n.contextMenuPending=!1,n.wrapper.style.cssText=c,l.style.cssText=u,gl&&vl<9&&o.scrollbars.setScrollTop(o.scroller.scrollTop=a),null!=l.selectionStart){(!gl||gl&&vl<9)&&t();var e=0,r=function(){o.selForContextMenu==i.doc.sel&&0==l.selectionStart&&l.selectionEnd>0&&"​"==n.prevInput?dn(i,Mi)(i):e++<10?o.detectingSelectAll=setTimeout(r,500):(o.selForContextMenu=null,o.input.reset())};o.detectingSelectAll=setTimeout(r,200)}}var n=this,i=n.cm,o=i.display,l=n.textarea,s=Sr(i,e),a=o.scroller.scrollTop;if(s&&!wl){i.options.resetSelectionOnContextMenu&&-1==i.doc.sel.contains(s)&&dn(i,bi)(i.doc,Rn(s),Gl);var u=l.style.cssText,c=n.wrapper.style.cssText;n.wrapper.style.cssText="position: absolute";var f=n.wrapper.getBoundingClientRect();l.style.cssText="position: absolute; width: 30px; height: 30px;\n      top: "+(e.clientY-f.top-5)+"px; left: "+(e.clientX-f.left-5)+"px;\n      z-index: 1000; background: "+(gl?"rgba(255, 255, 255, .05)":"transparent")+";\n      outline: none; border-width: 0; outline: none; overflow: hidden; opacity: .05; filter: alpha(opacity=5);";var h;if(ml&&(h=window.scrollY),o.input.focus(),ml&&window.scrollTo(null,h),o.input.reset(),i.somethingSelected()||(l.value=n.prevInput=" "),n.contextMenuPending=!0,o.selForContextMenu=i.doc.sel,clearTimeout(o.detectingSelectAll),gl&&vl>=9&&t(),Hl){Fe(e);var d=function(){ke(window,"mouseup",d),setTimeout(r,20)};Ql(window,"mouseup",d)}else setTimeout(r,50)}},Qs.prototype.readOnlyChanged=function(e){e||this.reset(),this.textarea.disabled="nocursor"==e},Qs.prototype.setUneditable=function(){},Qs.prototype.needsContentAttribute=!1,function(e){function t(t,n,i,o){e.defaults[t]=n,i&&(r[t]=o?function(e,t,r){r!=Xs&&i(e,t,r)}:i)}var r=e.optionHandlers;e.defineOption=t,e.Init=Xs,t("value","",function(e,t){return e.setValue(t)},!0),t("mode",null,function(e,t){e.doc.modeOption=t,jn(e)},!0),t("indentUnit",2,jn,!0),t("indentWithTabs",!1),t("smartIndent",!0),t("tabSize",4,function(e){Xn(e),er(e),vn(e)},!0),t("lineSeparator",null,function(e,t){if(e.doc.lineSep=t,t){var r=[],n=e.doc.first;e.doc.iter(function(e){for(var i=0;;){var o=e.text.indexOf(t,i);if(-1==o)break;i=o+t.length,r.push(E(n,o))}n++});for(var i=r.length-1;i>=0;i--)Ei(e.doc,t,r[i],E(r[i].line,r[i].ch+t.length))}}),t("specialChars",/[\u0000-\u001f\u007f-\u009f\u00ad\u061c\u200b-\u200f\u2028\u2029\ufeff]/g,function(e,t,r){e.state.specialChars=new RegExp(t.source+(t.test("\t")?"":"|\t"),"g"),r!=Xs&&e.refresh()}),t("specialCharPlaceholder",at,function(e){return e.refresh()},!0),t("electricChars",!0),t("inputStyle",Tl?"contenteditable":"textarea",function(){throw new Error("inputStyle can not (yet) be changed in a running editor")},!0),t("spellcheck",!1,function(e,t){return e.getInputField().spellcheck=t},!0),t("rtlMoveVisually",!Ol),t("wholeLineUpdateBefore",!0),t("theme","default",function(e){Go(e),Uo(e)},!0),t("keyMap","default",function(e,t,r){var n=uo(t),i=r!=Xs&&uo(r);i&&i.detach&&i.detach(e,n),n.attach&&n.attach(e,i||null)}),t("extraKeys",null),t("configureMouse",null),t("lineWrapping",!1,Ko,!0),t("gutters",[],function(e){Fn(e.options),Uo(e)},!0),t("fixedGutter",!0,function(e,t){e.display.gutters.style.left=t?wr(e.display)+"px":"0",e.refresh()},!0),t("coverGutterNextToScrollbar",!1,function(e){return en(e)},!0),t("scrollbarStyle","native",function(e){rn(e),en(e),e.display.scrollbars.setScrollTop(e.doc.scrollTop),e.display.scrollbars.setScrollLeft(e.doc.scrollLeft)},!0),t("lineNumbers",!1,function(e){Fn(e.options),Uo(e)},!0),t("firstLineNumber",1,Uo,!0),t("lineNumberFormatter",function(e){return e},Uo,!0),t("showCursorWhenSelecting",!1,kr,!0),t("resetSelectionOnContextMenu",!0),t("lineWiseCopyCut",!0),t("pasteLinesPerSelection",!0),t("readOnly",!1,function(e,t){"nocursor"==t&&(Fr(e),e.display.input.blur()),e.display.input.readOnlyChanged(t)}),t("disableInput",!1,function(e,t){t||e.display.input.reset()},!0),t("dragDrop",!0,Vo),t("allowDropFileTypes",null),t("cursorBlinkRate",530),t("cursorScrollMargin",0),t("cursorHeight",1,kr,!0),t("singleCursorHeightPerLine",!0,kr,!0),t("workTime",100),t("workDelay",100),t("flattenSpans",!0,Xn,!0),t("addModeClass",!1,Xn,!0),t("pollInterval",100),t("undoDepth",200,function(e,t){return e.doc.history.undoDepth=t}),t("historyEventDelay",1250),t("viewportMargin",10,function(e){return e.refresh()},!0),t("maxHighlightLength",1e4,Xn,!0),t("moveInputWithCursor",!0,function(e,t){t||e.display.input.resetPosition()}),t("tabindex",null,function(e,t){return e.display.input.getField().tabIndex=t||""}),t("autofocus",null),t("direction","ltr",function(e,t){return e.doc.setDirection(t)},!0)}(jo),function(e){var t=e.optionHandlers,r=e.helpers={};e.prototype={constructor:e,focus:function(){window.focus(),this.display.input.focus()},setOption:function(e,r){var n=this.options,i=n[e];n[e]==r&&"mode"!=e||(n[e]=r,t.hasOwnProperty(e)&&dn(this,t[e])(this,r,i),Te(this,"optionChange",this,e))},getOption:function(e){return this.options[e]},getDoc:function(){return this.doc},addKeyMap:function(e,t){this.state.keyMaps[t?"push":"unshift"](uo(e))},removeKeyMap:function(e){for(var t=this.state.keyMaps,r=0;r<t.length;++r)if(t[r]==e||t[r].name==e)return t.splice(r,1),!0},addOverlay:pn(function(t,r){var n=t.token?t:e.getMode(this.options,t);if(n.startState)throw new Error("Overlays may not be stateful.");m(this.state.overlays,{mode:n,modeSpec:t,opaque:r&&r.opaque,priority:r&&r.priority||0},function(e){return e.priority}),this.state.modeGen++,vn(this)}),removeOverlay:pn(function(e){for(var t=this,r=this.state.overlays,n=0;n<r.length;++n){var i=r[n].modeSpec;if(i==e||"string"==typeof e&&i.name==e)return r.splice(n,1),t.state.modeGen++,void vn(t)}}),indentLine:pn(function(e,t,r){"string"!=typeof t&&"number"!=typeof t&&(t=null==t?this.options.smartIndent?"smart":"prev":t?"add":"subtract"),H(this.doc,e)&&Yo(this,e,t,r)}),indentSelection:pn(function(e){for(var t=this,r=this.doc.sel.ranges,n=-1,i=0;i<r.length;i++){var o=r[i];if(o.empty())o.head.line>n&&(Yo(t,o.head.line,e,!0),n=o.head.line,i==t.doc.sel.primIndex&&jr(t));else{var l=o.from(),s=o.to(),a=Math.max(n,l.line);n=Math.min(t.lastLine(),s.line-(s.ch?0:1))+1;for(var u=a;u<n;++u)Yo(t,u,e);var c=t.doc.sel.ranges;0==l.ch&&r.length==c.length&&c[i].from().ch>0&&gi(t.doc,i,new Ts(l,c[i].to()),Gl)}}}),getTokenAt:function(e,t){return Je(this,e,t)},getLineTokens:function(e,t){return Je(this,E(e),t,!0)},getTokenTypeAt:function(e){e=U(this.doc,e);var t,r=_e(this,M(this.doc,e.line)),n=0,i=(r.length-1)/2,o=e.ch;if(0==o)t=r[2];else for(;;){var l=n+i>>1;if((l?r[2*l-1]:0)>=o)i=l;else{if(!(r[2*l+1]<o)){t=r[2*l+2];break}n=l+1}}var s=t?t.indexOf("overlay "):-1;return s<0?t:0==s?null:t.slice(0,s-1)},getModeAt:function(t){var r=this.doc.mode;return r.innerMode?e.innerMode(r,this.getTokenAt(t).state).mode:r},getHelper:function(e,t){return this.getHelpers(e,t)[0]},getHelpers:function(e,t){var n=this,i=[];if(!r.hasOwnProperty(t))return i;var o=r[t],l=this.getModeAt(e);if("string"==typeof l[t])o[l[t]]&&i.push(o[l[t]]);else if(l[t])for(var s=0;s<l[t].length;s++){var a=o[l[t][s]];a&&i.push(a)}else l.helperType&&o[l.helperType]?i.push(o[l.helperType]):o[l.name]&&i.push(o[l.name]);for(var u=0;u<o._global.length;u++){var c=o._global[u];c.pred(l,n)&&-1==h(i,c.val)&&i.push(c.val)}return i},getStateAfter:function(e,t){var r=this.doc;return e=G(r,null==e?r.first+r.size-1:e),$e(this,e+1,t).state},cursorCoords:function(e,t){var r,n=this.doc.sel.primary();return r=null==e?n.head:"object"==typeof e?U(this.doc,e):e?n.from():n.to(),sr(this,r,t||"page")},charCoords:function(e,t){return lr(this,U(this.doc,e),t||"page")},coordsChar:function(e,t){return e=or(this,e,t||"page"),cr(this,e.left,e.top)},lineAtHeight:function(e,t){return e=or(this,{top:e,left:0},t||"page").top,D(this.doc,e+this.display.viewOffset)},heightAtLine:function(e,t,r){var n,i=!1;if("number"==typeof e){var o=this.doc.first+this.doc.size-1;e<this.doc.first?e=this.doc.first:e>o&&(e=o,i=!0),n=M(this.doc,e)}else n=e;return ir(this,n,{top:0,left:0},t||"page",r||i).top+(i?this.doc.height-ye(n):0)},defaultTextHeight:function(){return mr(this.display)},defaultCharWidth:function(){return yr(this.display)},getViewport:function(){return{from:this.display.viewFrom,to:this.display.viewTo}},addWidget:function(e,t,r,n,i){var o=this.display,l=(e=sr(this,U(this.doc,e))).bottom,s=e.left;if(t.style.position="absolute",t.setAttribute("cm-ignore-events","true"),this.display.input.setUneditable(t),o.sizer.appendChild(t),"over"==n)l=e.top;else if("above"==n||"near"==n){var a=Math.max(o.wrapper.clientHeight,this.doc.height),u=Math.max(o.sizer.clientWidth,o.lineSpace.clientWidth);("above"==n||e.bottom+t.offsetHeight>a)&&e.top>t.offsetHeight?l=e.top-t.offsetHeight:e.bottom+t.offsetHeight<=a&&(l=e.bottom),s+t.offsetWidth>u&&(s=u-t.offsetWidth)}t.style.top=l+"px",t.style.left=t.style.right="","right"==i?(s=o.sizer.clientWidth-t.offsetWidth,t.style.right="0px"):("left"==i?s=0:"middle"==i&&(s=(o.sizer.clientWidth-t.offsetWidth)/2),t.style.left=s+"px"),r&&Ur(this,{left:s,top:l,right:s+t.offsetWidth,bottom:l+t.offsetHeight})},triggerOnKeyDown:pn(Lo),triggerOnKeyPress:pn(Mo),triggerOnKeyUp:To,triggerOnMouseDown:pn(Oo),execCommand:function(e){if(Bs.hasOwnProperty(e))return Bs[e].call(null,this)},triggerElectric:pn(function(e){Zo(this,e)}),findPosH:function(e,t,r,n){var i=this,o=1;t<0&&(o=-1,t=-t);for(var l=U(this.doc,e),s=0;s<t&&!(l=tl(i.doc,l,o,r,n)).hitSide;++s);return l},moveH:pn(function(e,t){var r=this;this.extendSelectionsBy(function(n){return r.display.shift||r.doc.extend||n.empty()?tl(r.doc,n.head,e,t,r.options.rtlMoveVisually):e<0?n.from():n.to()},Vl)}),deleteH:pn(function(e,t){var r=this.doc.sel,n=this.doc;r.somethingSelected()?n.replaceSelection("",null,"+delete"):co(this,function(r){var i=tl(n,r.head,e,t,!1);return e<0?{from:i,to:r.head}:{from:r.head,to:i}})}),findPosV:function(e,t,r,n){var i=this,o=1,l=n;t<0&&(o=-1,t=-t);for(var s=U(this.doc,e),a=0;a<t;++a){var u=sr(i,s,"div");if(null==l?l=u.left:u.left=l,(s=rl(i,u,o,r)).hitSide)break}return s},moveV:pn(function(e,t){var r=this,n=this.doc,i=[],o=!this.display.shift&&!n.extend&&n.sel.somethingSelected();if(n.extendSelectionsBy(function(l){if(o)return e<0?l.from():l.to();var s=sr(r,l.head,"div");null!=l.goalColumn&&(s.left=l.goalColumn),i.push(s.left);var a=rl(r,s,e,t);return"page"==t&&l==n.sel.primary()&&Kr(r,lr(r,a,"div").top-s.top),a},Vl),i.length)for(var l=0;l<n.sel.ranges.length;l++)n.sel.ranges[l].goalColumn=i[l]}),findWordAt:function(e){var t=M(this.doc,e.line).text,r=e.ch,n=e.ch;if(t){var i=this.getHelper(e,"wordChars");"before"!=e.sticky&&n!=t.length||!r?++n:--r;for(var o=t.charAt(r),l=x(o,i)?function(e){return x(e,i)}:/\s/.test(o)?function(e){return/\s/.test(e)}:function(e){return!/\s/.test(e)&&!x(e)};r>0&&l(t.charAt(r-1));)--r;for(;n<t.length&&l(t.charAt(n));)++n}return new Ts(E(e.line,r),E(e.line,n))},toggleOverwrite:function(e){null!=e&&e==this.state.overwrite||((this.state.overwrite=!this.state.overwrite)?s(this.display.cursorDiv,"CodeMirror-overwrite"):Fl(this.display.cursorDiv,"CodeMirror-overwrite"),Te(this,"overwriteToggle",this,this.state.overwrite))},hasFocus:function(){return this.display.input.getField()==l()},isReadOnly:function(){return!(!this.options.readOnly&&!this.doc.cantEdit)},scrollTo:pn(function(e,t){Xr(this,e,t)}),getScrollInfo:function(){var e=this.display.scroller;return{left:e.scrollLeft,top:e.scrollTop,height:e.scrollHeight-zt(this)-this.display.barHeight,width:e.scrollWidth-zt(this)-this.display.barWidth,clientHeight:Bt(this),clientWidth:Rt(this)}},scrollIntoView:pn(function(e,t){null==e?(e={from:this.doc.sel.primary().head,to:null},null==t&&(t=this.options.cursorScrollMargin)):"number"==typeof e?e={from:E(e,0),to:null}:null==e.from&&(e={from:e,to:null}),e.to||(e.to=e.from),e.margin=t||0,null!=e.from.line?Yr(this,e):$r(this,e.from,e.to,e.margin)}),setSize:pn(function(e,t){var r=this,n=function(e){return"number"==typeof e||/^\d+$/.test(String(e))?e+"px":e};null!=e&&(this.display.wrapper.style.width=n(e)),null!=t&&(this.display.wrapper.style.height=n(t)),this.options.lineWrapping&&Jt(this);var i=this.display.viewFrom;this.doc.iter(i,this.display.viewTo,function(e){if(e.widgets)for(var t=0;t<e.widgets.length;t++)if(e.widgets[t].noHScroll){mn(r,i,"widget");break}++i}),this.curOp.forceUpdate=!0,Te(this,"refresh",this)}),operation:function(e){return hn(this,e)},startOperation:function(){return nn(this)},endOperation:function(){return on(this)},refresh:pn(function(){var e=this.display.cachedTextHeight;vn(this),this.curOp.forceUpdate=!0,er(this),Xr(this,this.doc.scrollLeft,this.doc.scrollTop),Wn(this),(null==e||Math.abs(e-mr(this.display))>.5)&&Cr(this),Te(this,"refresh",this)}),swapDoc:pn(function(e){var t=this.doc;return t.cm=null,qn(this,e),er(this),this.display.input.reset(),Xr(this,e.scrollLeft,e.scrollTop),this.curOp.forceScroll=!0,bt(this,"swapDoc",this,t),t}),getInputField:function(){return this.display.input.getField()},getWrapperElement:function(){return this.display.wrapper},getScrollerElement:function(){return this.display.scroller},getGutterElement:function(){return this.display.gutters}},Ae(e),e.registerHelper=function(t,n,i){r.hasOwnProperty(t)||(r[t]=e[t]={_global:[]}),r[t][n]=i},e.registerGlobalHelper=function(t,n,i,o){e.registerHelper(t,n,o),r[t]._global.push({pred:i,val:o})}}(jo);var Js="iter insert remove copy getEditor constructor".split(" ");for(var ea in Ds.prototype)Ds.prototype.hasOwnProperty(ea)&&h(Js,ea)<0&&(jo.prototype[ea]=function(e){return function(){return e.apply(this.doc,arguments)}}(Ds.prototype[ea]));return Ae(Ds),jo.inputStyles={textarea:Qs,contenteditable:Zs},jo.defineMode=function(e){jo.defaults.mode||"null"==e||(jo.defaults.mode=e),Be.apply(this,arguments)},jo.defineMIME=function(e,t){os[e]=t},jo.defineMode("null",function(){return{token:function(e){return e.skipToEnd()}}}),jo.defineMIME("text/plain","null"),jo.defineExtension=function(e,t){jo.prototype[e]=t},jo.defineDocExtension=function(e,t){Ds.prototype[e]=t},jo.fromTextArea=function(e,t){function r(){e.value=a.getValue()}if(t=t?c(t):{},t.value=e.value,!t.tabindex&&e.tabIndex&&(t.tabindex=e.tabIndex),!t.placeholder&&e.placeholder&&(t.placeholder=e.placeholder),null==t.autofocus){var n=l();t.autofocus=n==e||null!=e.getAttribute("autofocus")&&n==document.body}var i;if(e.form&&(Ql(e.form,"submit",r),!t.leaveSubmitMethodAlone)){var o=e.form;i=o.submit;try{var s=o.submit=function(){r(),o.submit=i,o.submit(),o.submit=s}}catch(e){}}t.finishInit=function(t){t.save=r,t.getTextArea=function(){return e},t.toTextArea=function(){t.toTextArea=isNaN,r(),e.parentNode.removeChild(t.getWrapperElement()),e.style.display="",e.form&&(ke(e.form,"submit",r),"function"==typeof e.form.submit&&(e.form.submit=i))}},e.style.display="none";var a=jo(function(t){return e.parentNode.insertBefore(t,e.nextSibling)},t);return a},function(e){e.off=ke,e.on=Ql,e.wheelEventPixels=Pn,e.Doc=Ds,e.splitLines=es,e.countColumn=f,e.findColumn=d,e.isWordChar=w,e.Pass=Bl,e.signal=Te,e.Line=fs,e.changeEnd=Bn,e.scrollbarModel=ws,e.Pos=E,e.cmpPos=P,e.modes=is,e.mimeModes=os,e.resolveMode=Ge,e.getMode=Ue,e.modeExtensions=ls,e.extendMode=Ve,e.copyState=Ke,e.startState=Xe,e.innerMode=je,e.commands=Bs,e.keyMap=Rs,e.keyName=ao,e.isModifierKey=lo,e.lookupKey=oo,e.normalizeKeyMap=io,e.StringStream=ss,e.SharedTextMarker=As,e.TextMarker=Os,e.LineWidget=Ms,e.e_preventDefault=We,e.e_stopPropagation=De,e.e_stop=Fe,e.addClass=s,e.contains=o,e.rmClass=Fl,e.keyNames=Es}(jo),jo.version="5.30.0",jo});
      !function(e){"object"==typeof exports&&"object"==typeof module?e(require("../../lib/codemirror")):"function"==typeof define&&define.amd?define(["../../lib/codemirror"],e):e(CodeMirror)}(function(e){"use strict";function t(e,t,n,r,o,a){this.indented=e,this.column=t,this.type=n,this.info=r,this.align=o,this.prev=a}function n(e,n,r,o){var a=e.indented;return e.context&&"statement"==e.context.type&&"statement"!=r&&(a=e.context.indented),e.context=new t(a,n,r,o,null,e.context)}function r(e){var t=e.context.type;return")"!=t&&"]"!=t&&"}"!=t||(e.indented=e.context.indented),e.context=e.context.prev}function o(e,t,n){return"variable"==t.prevToken||"type"==t.prevToken||(!!/\S(?:[^- ]>|[*\]])\s*$|\*$/.test(e.string.slice(0,n))||(!(!t.typeAtEndOfLine||e.column()!=e.indentation())||void 0))}function a(e){for(;;){if(!e||"top"==e.type)return!0;if("}"==e.type&&"namespace"!=e.prev.info)return!1;e=e.prev}}function i(e){for(var t={},n=e.split(" "),r=0;r<n.length;++r)t[n[r]]=!0;return t}function l(e,t){return"function"==typeof e?e(t):e.propertyIsEnumerable(t)}function s(e,t){if(!t.startOfLine)return!1;for(var n,r=null;n=e.peek();){if("\\"==n&&e.match(/^.$/)){r=s;break}if("/"==n&&e.match(/^\/[\/\*]/,!1))break;e.next()}return t.tokenize=r,"meta"}function c(e,t){return"type"==t.prevToken&&"type"}function u(e){return e.eatWhile(/[\w\.']/),"number"}function d(e,t){if(e.backUp(1),e.match(/(R|u8R|uR|UR|LR)/)){var n=e.match(/"([^\s\\()]{0,16})\(/);return!!n&&(t.cpp11RawStringDelim=n[1],t.tokenize=m,m(e,t))}return e.match(/(u8|u|U|L)/)?!!e.match(/["']/,!1)&&"string":(e.next(),!1)}function f(e){var t=/(\w+)::~?(\w+)$/.exec(e);return t&&t[1]==t[2]}function p(e,t){for(var n;null!=(n=e.next());)if('"'==n&&!e.eat('"')){t.tokenize=null;break}return"string"}function m(e,t){var n=t.cpp11RawStringDelim.replace(/[^\w\s]/g,"\\$&");return e.match(new RegExp(".*?\\)"+n+'"'))?t.tokenize=null:e.skipToEnd(),"string"}function h(t,n){function r(e){if(e)for(var t in e)e.hasOwnProperty(t)&&o.push(t)}"string"==typeof t&&(t=[t]);var o=[];r(n.keywords),r(n.types),r(n.builtin),r(n.atoms),o.length&&(n.helperType=t[0],e.registerHelper("hintWords",t[0],o));for(var a=0;a<t.length;++a)e.defineMIME(t[a],n)}function g(e,t){for(var n=!1;!e.eol();){if(!n&&e.match('"""')){t.tokenize=null;break}n="\\"==e.next()&&!n}return"string"}function y(e){return function(t,n){for(var r,o=!1,a=!1;!t.eol();){if(!e&&!o&&t.match('"')){a=!0;break}if(e&&t.match('"""')){a=!0;break}r=t.next(),!o&&"$"==r&&t.match("{")&&t.skipTo("}"),o=!o&&"\\"==r&&!e}return!a&&e||(n.tokenize=null),"string"}}function x(e){return function(t,n){for(var r,o=!1,a=!1;!t.eol();){if(!o&&t.match('"')&&("single"==e||t.match('""'))){a=!0;break}if(!o&&t.match("``")){w=x(e),a=!0;break}r=t.next(),o="single"==e&&!o&&"\\"==r}return a&&(n.tokenize=null),"string"}}e.defineMode("clike",function(i,s){function c(e,t){var n=e.next();if(S[n]){var r=S[n](e,t);if(!1!==r)return r}if('"'==n||"'"==n)return t.tokenize=u(n),t.tokenize(e,t);if(D.test(n))return p=n,null;if(L.test(n)){if(e.backUp(1),e.match(I))return"number";e.next()}if("/"==n){if(e.eat("*"))return t.tokenize=d,d(e,t);if(e.eat("/"))return e.skipToEnd(),"comment"}if(F.test(n)){for(;!e.match(/^\/[\/*]/,!1)&&e.eat(F););return"operator"}if(e.eatWhile(z),P)for(;e.match(P);)e.eatWhile(z);var o=e.current();return l(x,o)?(l(w,o)&&(p="newstatement"),l(v,o)&&(m=!0),"keyword"):l(b,o)?"type":l(k,o)?(l(w,o)&&(p="newstatement"),"builtin"):l(_,o)?"atom":"variable"}function u(e){return function(t,n){for(var r,o=!1,a=!1;null!=(r=t.next());){if(r==e&&!o){a=!0;break}o=!o&&"\\"==r}return(a||!o&&!C)&&(n.tokenize=null),"string"}}function d(e,t){for(var n,r=!1;n=e.next();){if("/"==n&&r){t.tokenize=null;break}r="*"==n}return"comment"}function f(e,t){s.typeFirstDefinitions&&e.eol()&&a(t.context)&&(t.typeAtEndOfLine=o(e,t,e.pos))}var p,m,h=i.indentUnit,g=s.statementIndentUnit||h,y=s.dontAlignCalls,x=s.keywords||{},b=s.types||{},k=s.builtin||{},w=s.blockKeywords||{},v=s.defKeywords||{},_=s.atoms||{},S=s.hooks||{},C=s.multiLineStrings,T=!1!==s.indentStatements,M=!1!==s.indentSwitch,P=s.namespaceSeparator,D=s.isPunctuationChar||/[\[\]{}\(\),;\:\.]/,L=s.numberStart||/[\d\.]/,I=s.number||/^(?:0x[a-f\d]+|0b[01]+|(?:\d+\.?\d*|\.\d+)(?:e[-+]?\d+)?)(u|ll?|l|f)?/i,F=s.isOperatorChar||/[+\-*&%=<>!?|\/]/,z=s.isIdentifierChar||/[\w\$_\xa1-\uffff]/;return{startState:function(e){return{tokenize:null,context:new t((e||0)-h,0,"top",null,!1),indented:0,startOfLine:!0,prevToken:null}},token:function(e,t){var i=t.context;if(e.sol()&&(null==i.align&&(i.align=!1),t.indented=e.indentation(),t.startOfLine=!0),e.eatSpace())return f(e,t),null;p=m=null;var l=(t.tokenize||c)(e,t);if("comment"==l||"meta"==l)return l;if(null==i.align&&(i.align=!0),";"==p||":"==p||","==p&&e.match(/^\s*(?:\/\/.*)?$/,!1))for(;"statement"==t.context.type;)r(t);else if("{"==p)n(t,e.column(),"}");else if("["==p)n(t,e.column(),"]");else if("("==p)n(t,e.column(),")");else if("}"==p){for(;"statement"==i.type;)i=r(t);for("}"==i.type&&(i=r(t));"statement"==i.type;)i=r(t)}else p==i.type?r(t):T&&(("}"==i.type||"top"==i.type)&&";"!=p||"statement"==i.type&&"newstatement"==p)&&n(t,e.column(),"statement",e.current());if("variable"==l&&("def"==t.prevToken||s.typeFirstDefinitions&&o(e,t,e.start)&&a(t.context)&&e.match(/^\s*\(/,!1))&&(l="def"),S.token){var u=S.token(e,t,l);void 0!==u&&(l=u)}return"def"==l&&!1===s.styleDefs&&(l="variable"),t.startOfLine=!1,t.prevToken=m?"def":l||p,f(e,t),l},indent:function(t,n){if(t.tokenize!=c&&null!=t.tokenize||t.typeAtEndOfLine)return e.Pass;var r=t.context,o=n&&n.charAt(0);if("statement"==r.type&&"}"==o&&(r=r.prev),s.dontIndentStatements)for(;"statement"==r.type&&s.dontIndentStatements.test(r.info);)r=r.prev;if(S.indent){var a=S.indent(t,r,n);if("number"==typeof a)return a}var i=o==r.type,l=r.prev&&"switch"==r.prev.info;if(s.allmanIndentation&&/[{(]/.test(o)){for(;"top"!=r.type&&"}"!=r.type;)r=r.prev;return r.indented}return"statement"==r.type?r.indented+("{"==o?0:g):!r.align||y&&")"==r.type?")"!=r.type||i?r.indented+(i?0:h)+(i||!l||/^(?:case|default)\b/.test(n)?0:h):r.indented+g:r.column+(i?0:1)},electricInput:M?/^\s*(?:case .*?:|default:|\{\}?|\})$/:/^\s*[{}]$/,blockCommentStart:"/*",blockCommentEnd:"*/",lineComment:"//",fold:"brace"}});var b="auto if break case register continue return default do sizeof static else struct switch extern typedef union for goto while enum const volatile",k="int long char short double float unsigned signed void size_t ptrdiff_t";h(["text/x-csrc","text/x-c","text/x-chdr"],{name:"clike",keywords:i(b),types:i(k+" bool _Complex _Bool float_t double_t intptr_t intmax_t int8_t int16_t int32_t int64_t uintptr_t uintmax_t uint8_t uint16_t uint32_t uint64_t"),blockKeywords:i("case do else for if switch while struct"),defKeywords:i("struct"),typeFirstDefinitions:!0,atoms:i("null true false"),hooks:{"#":s,"*":c},modeProps:{fold:["brace","include"]}}),h(["text/x-c++src","text/x-c++hdr"],{name:"clike",keywords:i(b+" asm dynamic_cast namespace reinterpret_cast try explicit new static_cast typeid catch operator template typename class friend private this using const_cast inline public throw virtual delete mutable protected alignas alignof constexpr decltype nullptr noexcept thread_local final static_assert override"),types:i(k+" bool wchar_t"),blockKeywords:i("catch class do else finally for if struct switch try while"),defKeywords:i("class namespace struct enum union"),typeFirstDefinitions:!0,atoms:i("true false null"),dontIndentStatements:/^template$/,isIdentifierChar:/[\w\$_~\xa1-\uffff]/,hooks:{"#":s,"*":c,u:d,U:d,L:d,R:d,0:u,1:u,2:u,3:u,4:u,5:u,6:u,7:u,8:u,9:u,token:function(e,t,n){if("variable"==n&&"("==e.peek()&&(";"==t.prevToken||null==t.prevToken||"}"==t.prevToken)&&f(e.current()))return"def"}},namespaceSeparator:"::",modeProps:{fold:["brace","include"]}}),h("text/x-java",{name:"clike",keywords:i("abstract assert break case catch class const continue default do else enum extends final finally float for goto if implements import instanceof interface native new package private protected public return static strictfp super switch synchronized this throw throws transient try volatile while @interface"),types:i("byte short int long float double boolean char void Boolean Byte Character Double Float Integer Long Number Object Short String StringBuffer StringBuilder Void"),blockKeywords:i("catch class do else finally for if switch try while"),defKeywords:i("class interface package enum @interface"),typeFirstDefinitions:!0,atoms:i("true false null"),number:/^(?:0x[a-f\d_]+|0b[01_]+|(?:[\d_]+\.?\d*|\.\d+)(?:e[-+]?[\d_]+)?)(u|ll?|l|f)?/i,hooks:{"@":function(e){return!e.match("interface",!1)&&(e.eatWhile(/[\w\$_]/),"meta")}},modeProps:{fold:["brace","import"]}}),h("text/x-csharp",{name:"clike",keywords:i("abstract as async await base break case catch checked class const continue default delegate do else enum event explicit extern finally fixed for foreach goto if implicit in interface internal is lock namespace new operator out override params private protected public readonly ref return sealed sizeof stackalloc static struct switch this throw try typeof unchecked unsafe using virtual void volatile while add alias ascending descending dynamic from get global group into join let orderby partial remove select set value var yield"),types:i("Action Boolean Byte Char DateTime DateTimeOffset Decimal Double Func Guid Int16 Int32 Int64 Object SByte Single String Task TimeSpan UInt16 UInt32 UInt64 bool byte char decimal double short int long object sbyte float string ushort uint ulong"),blockKeywords:i("catch class do else finally for foreach if struct switch try while"),defKeywords:i("class interface namespace struct var"),typeFirstDefinitions:!0,atoms:i("true false null"),hooks:{"@":function(e,t){return e.eat('"')?(t.tokenize=p,p(e,t)):(e.eatWhile(/[\w\$_]/),"meta")}}}),h("text/x-scala",{name:"clike",keywords:i("abstract case catch class def do else extends final finally for forSome if implicit import lazy match new null object override package private protected return sealed super this throw trait try type val var while with yield _ assert assume require print println printf readLine readBoolean readByte readShort readChar readInt readLong readFloat readDouble"),types:i("AnyVal App Application Array BufferedIterator BigDecimal BigInt Char Console Either Enumeration Equiv Error Exception Fractional Function IndexedSeq Int Integral Iterable Iterator List Map Numeric Nil NotNull Option Ordered Ordering PartialFunction PartialOrdering Product Proxy Range Responder Seq Serializable Set Specializable Stream StringBuilder StringContext Symbol Throwable Traversable TraversableOnce Tuple Unit Vector Boolean Byte Character CharSequence Class ClassLoader Cloneable Comparable Compiler Double Exception Float Integer Long Math Number Object Package Pair Process Runtime Runnable SecurityManager Short StackTraceElement StrictMath String StringBuffer System Thread ThreadGroup ThreadLocal Throwable Triple Void"),multiLineStrings:!0,blockKeywords:i("catch class enum do else finally for forSome if match switch try while"),defKeywords:i("class enum def object package trait type val var"),atoms:i("true false null"),indentStatements:!1,indentSwitch:!1,isOperatorChar:/[+\-*&%=<>!?|\/#:@]/,hooks:{"@":function(e){return e.eatWhile(/[\w\$_]/),"meta"},'"':function(e,t){return!!e.match('""')&&(t.tokenize=g,t.tokenize(e,t))},"'":function(e){return e.eatWhile(/[\w\$_\xa1-\uffff]/),"atom"},"=":function(e,n){var r=n.context;return!("}"!=r.type||!r.align||!e.eat(">"))&&(n.context=new t(r.indented,r.column,r.type,r.info,null,r.prev),"operator")}},modeProps:{closeBrackets:{triples:'"'}}}),h("text/x-kotlin",{name:"clike",keywords:i("package as typealias class interface this super val var fun for is in This throw return break continue object if else while do try when !in !is as? file import where by get set abstract enum open inner override private public internal protected catch finally out final vararg reified dynamic companion constructor init sealed field property receiver param sparam lateinit data inline noinline tailrec external annotation crossinline const operator infix suspend"),types:i("Boolean Byte Character CharSequence Class ClassLoader Cloneable Comparable Compiler Double Exception Float Integer Long Math Number Object Package Pair Process Runtime Runnable SecurityManager Short StackTraceElement StrictMath String StringBuffer System Thread ThreadGroup ThreadLocal Throwable Triple Void"),intendSwitch:!1,indentStatements:!1,multiLineStrings:!0,number:/^(?:0x[a-f\d_]+|0b[01_]+|(?:[\d_]+\.?\d*|\.\d+)(?:e[-+]?[\d_]+)?)(u|ll?|l|f)?/i,blockKeywords:i("catch class do else finally for if where try while enum"),defKeywords:i("class val var object package interface fun"),atoms:i("true false null this"),hooks:{'"':function(e,t){return t.tokenize=y(e.match('""')),t.tokenize(e,t)}},modeProps:{closeBrackets:{triples:'"'}}}),h(["x-shader/x-vertex","x-shader/x-fragment"],{name:"clike",keywords:i("sampler1D sampler2D sampler3D samplerCube sampler1DShadow sampler2DShadow const attribute uniform varying break continue discard return for while do if else struct in out inout"),types:i("float int bool void vec2 vec3 vec4 ivec2 ivec3 ivec4 bvec2 bvec3 bvec4 mat2 mat3 mat4"),blockKeywords:i("for while do if else struct"),builtin:i("radians degrees sin cos tan asin acos atan pow exp log exp2 sqrt inversesqrt abs sign floor ceil fract mod min max clamp mix step smoothstep length distance dot cross normalize ftransform faceforward reflect refract matrixCompMult lessThan lessThanEqual greaterThan greaterThanEqual equal notEqual any all not texture1D texture1DProj texture1DLod texture1DProjLod texture2D texture2DProj texture2DLod texture2DProjLod texture3D texture3DProj texture3DLod texture3DProjLod textureCube textureCubeLod shadow1D shadow2D shadow1DProj shadow2DProj shadow1DLod shadow2DLod shadow1DProjLod shadow2DProjLod dFdx dFdy fwidth noise1 noise2 noise3 noise4"),atoms:i("true false gl_FragColor gl_SecondaryColor gl_Normal gl_Vertex gl_MultiTexCoord0 gl_MultiTexCoord1 gl_MultiTexCoord2 gl_MultiTexCoord3 gl_MultiTexCoord4 gl_MultiTexCoord5 gl_MultiTexCoord6 gl_MultiTexCoord7 gl_FogCoord gl_PointCoord gl_Position gl_PointSize gl_ClipVertex gl_FrontColor gl_BackColor gl_FrontSecondaryColor gl_BackSecondaryColor gl_TexCoord gl_FogFragCoord gl_FragCoord gl_FrontFacing gl_FragData gl_FragDepth gl_ModelViewMatrix gl_ProjectionMatrix gl_ModelViewProjectionMatrix gl_TextureMatrix gl_NormalMatrix gl_ModelViewMatrixInverse gl_ProjectionMatrixInverse gl_ModelViewProjectionMatrixInverse gl_TexureMatrixTranspose gl_ModelViewMatrixInverseTranspose gl_ProjectionMatrixInverseTranspose gl_ModelViewProjectionMatrixInverseTranspose gl_TextureMatrixInverseTranspose gl_NormalScale gl_DepthRange gl_ClipPlane gl_Point gl_FrontMaterial gl_BackMaterial gl_LightSource gl_LightModel gl_FrontLightModelProduct gl_BackLightModelProduct gl_TextureColor gl_EyePlaneS gl_EyePlaneT gl_EyePlaneR gl_EyePlaneQ gl_FogParameters gl_MaxLights gl_MaxClipPlanes gl_MaxTextureUnits gl_MaxTextureCoords gl_MaxVertexAttribs gl_MaxVertexUniformComponents gl_MaxVaryingFloats gl_MaxVertexTextureImageUnits gl_MaxTextureImageUnits gl_MaxFragmentUniformComponents gl_MaxCombineTextureImageUnits gl_MaxDrawBuffers"),indentSwitch:!1,hooks:{"#":s},modeProps:{fold:["brace","include"]}}),h("text/x-nesc",{name:"clike",keywords:i(b+"as atomic async call command component components configuration event generic implementation includes interface module new norace nx_struct nx_union post provides signal task uses abstract extends"),types:i(k),blockKeywords:i("case do else for if switch while struct"),atoms:i("null true false"),hooks:{"#":s},modeProps:{fold:["brace","include"]}}),h("text/x-objectivec",{name:"clike",keywords:i(b+"inline restrict _Bool _Complex _Imaginary BOOL Class bycopy byref id IMP in inout nil oneway out Protocol SEL self super atomic nonatomic retain copy readwrite readonly"),types:i(k),atoms:i("YES NO NULL NILL ON OFF true false"),hooks:{"@":function(e){return e.eatWhile(/[\w\$]/),"keyword"},"#":s,indent:function(e,t,n){if("statement"==t.type&&/^@\w/.test(n))return t.indented}},modeProps:{fold:"brace"}}),h("text/x-squirrel",{name:"clike",keywords:i("base break clone continue const default delete enum extends function in class foreach local resume return this throw typeof yield constructor instanceof static"),types:i(k),blockKeywords:i("case catch class else for foreach if switch try while"),defKeywords:i("function local class"),typeFirstDefinitions:!0,atoms:i("true false null"),hooks:{"#":s},modeProps:{fold:["brace","include"]}});var w=null;h("text/x-ceylon",{name:"clike",keywords:i("abstracts alias assembly assert assign break case catch class continue dynamic else exists extends finally for function given if import in interface is let module new nonempty object of out outer package return satisfies super switch then this throw try value void while"),types:function(e){var t=e.charAt(0);return t===t.toUpperCase()&&t!==t.toLowerCase()},blockKeywords:i("case catch class dynamic else finally for function if interface module new object switch try while"),defKeywords:i("class dynamic function interface module object package value"),builtin:i("abstract actual aliased annotation by default deprecated doc final formal late license native optional sealed see serializable shared suppressWarnings tagged throws variable"),isPunctuationChar:/[\[\]{}\(\),;\:\.`]/,isOperatorChar:/[+\-*&%=<>!?|^~:\/]/,numberStart:/[\d#$]/,number:/^(?:#[\da-fA-F_]+|\$[01_]+|[\d_]+[kMGTPmunpf]?|[\d_]+\.[\d_]+(?:[eE][-+]?\d+|[kMGTPmunpf]|)|)/i,multiLineStrings:!0,typeFirstDefinitions:!0,atoms:i("true false null larger smaller equal empty finished"),indentSwitch:!1,styleDefs:!1,hooks:{"@":function(e){return e.eatWhile(/[\w\$_]/),"meta"},'"':function(e,t){return t.tokenize=x(e.match('""')?"triple":"single"),t.tokenize(e,t)},"`":function(e,t){return!(!w||!e.match("`"))&&(t.tokenize=w,w=null,t.tokenize(e,t))},"'":function(e){return e.eatWhile(/[\w\$_\xa1-\uffff]/),"atom"},token:function(e,t,n){if(("variable"==n||"type"==n)&&"."==t.prevToken)return"variable-2"}},modeProps:{fold:["brace","import"],closeBrackets:{triples:'"'}}})});
      // -------------------------------------------------------------------------
//  Part of the CodeChecker project, under the Apache License v2.0 with
//  LLVM Exceptions. See LICENSE for license information.
//  SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
// -------------------------------------------------------------------------

var BugViewer = {
  _files : [],
  _reports : [],
  _lineWidgets : [],
  _navigationMenuItems : [],
  _sourceFileData : null,
  _currentReport : null,
  _lastBugEvent  : null,

  init : function (files, reports) {
    this._files = files;
    this._reports = reports;

    this.initEscapeChars();
  },

  initEscapeChars : function () {
    this.escapeChars = {
      ' ' : 'nbsp',
      '<' : 'lt',
      '>' : 'gt',
      '"' : 'quot',
      '&' : 'amp'
    };

    var regexString = '[';
    for (var key in this.escapeChars) {
      regexString += key;
    }
    regexString += ']';

    this.escapeRegExp = new RegExp( regexString, 'g');
  },

  escapeHTML : function (str) {
    var that = this;

    return str.replace(this.escapeRegExp, function (m) {
      return '&' + that.escapeChars[m] + ';';
    });
  },

  initByUrl : function () {
    if (!this._reports) return;

    var state = {};
    window.location.hash.substr(1).split('&').forEach(function (s) {
      var parts = s.split('=');
      state[parts[0]] = parts[1];
    });

    for (var key in this._reports) {
      var report = this._reports[key];
      if (report.reportHash === state['reportHash']) {
        this.navigate(report);
        return;
      }
    }

    this.navigate(this._reports[0]);
  },

  create : function () {
    this._content = document.getElementById('editor-wrapper');
    this._filepath = document.getElementById('file-path');
    this._checkerName = document.getElementById('checker-name');
    this._reviewStatusWrapper =
      document.getElementById('review-status-wrapper');
    this._reviewStatus = document.getElementById('review-status');
    this._editor = document.getElementById('editor');

    this._codeMirror = CodeMirror(this._editor, {
      mode: 'text/x-c++src',
      matchBrackets : true,
      lineNumbers : true,
      readOnly : true,
      foldGutter : true,
      extraKeys : {},
      viewportMargin : 100
    });

    this._createNavigationMenu();
  },

  navigate : function (report, item) {
    if (!item) {
      var items = this._navigationMenuItems.filter(function (navItem) {
        return navItem.report.reportHash === report.reportHash;
      });

      if (!items.length) return;

      item = items[0].widget;
    }

    this._selectedReport.classList.remove('active');
    this._selectedReport = item;
    this._selectedReport.classList.add('active');
    this.setReport(report);
  },

  _createNavigationMenu : function () {
    var that = this;

    var nav = document.getElementById('report-nav');
    var list = document.createElement('ul');
    this._reports.forEach(function (report) {
      var events = report['events'];
      var lastBugEvent = events[events.length - 1];
      var item = document.createElement('li');

      var severity = document.createElement('i');
      severity.className = 'severity-' + report.severity.toLowerCase();

      item.appendChild(severity);
      item.appendChild(document.createTextNode(lastBugEvent.message));

      item.addEventListener('click', function () {
        that.navigate(report, item);
      })
      list.appendChild(item);
      that._navigationMenuItems.push({ report : report, widget : item });
    });

    if (!this._selectedReport && list.childNodes.length) {
      this._selectedReport = list.childNodes[0];
      this._selectedReport.classList.add('active');
    }

    nav.appendChild(list);
  },

  setReport : function (report) {
    this._currentReport = report;
    var events = report['events'];
    var lastBugEvent = events[events.length - 1];
    this.setCurrentBugEvent(lastBugEvent, events.length - 1);
    this.setCheckerName(report.checkerName);
    this.setReviewStatus(report.reviewStatus);

    window.location.hash = '#reportHash=' + report.reportHash;
  },

  setCurrentBugEvent : function (event, idx) {
    this._currentBugEvent = event;
    this.setSourceFileData(this._files[event.location.file]);
    this.drawBugPath();

    this.jumpTo(event.location.line, 0);
    this.highlightBugEvent(event, idx);
  },

  highlightBugEvent : function (event, idx) {
    this._lineWidgets.forEach(function (widget) {
      var lineIdx = widget.node.getAttribute('idx');
      if (parseInt(lineIdx) === idx) {
        widget.node.classList.add('current');
      }
    });
  },

  setCheckerName : function (checkerName) {
    this._checkerName.innerHTML = checkerName;
  },

  setReviewStatus : function (status) {
    if (status) {
      var className =
        'review-status-' + status.toLowerCase().split(' ').join('-');
      this._reviewStatus.className = "review-status " + className;

      this._reviewStatus.innerHTML = status;
      this._reviewStatusWrapper.style.display = 'block';
    } else {
      this._reviewStatusWrapper.style.display = 'none';
    }
  },

  setSourceFileData : function (file) {
    if (this._sourceFileData && file.id === this._sourceFileData.id) {
      return;
    }

    this._sourceFileData = file;
    this._filepath.innerHTML = file.path;
    this._codeMirror.doc.setValue(file.content);
    this._refresh();
  },

  _refresh : function () {
    var that = this;
    setTimeout(function () {
      var fullHeight = parseInt(that._content.clientHeight);
      var headerHeight = that._filepath.clientHeight;

      that._codeMirror.setSize('auto', fullHeight - headerHeight);
      that._codeMirror.refresh();
    }, 200);
  },

  clearBubbles : function () {
    this._lineWidgets.forEach(function (widget) { widget.clear(); });
    this._lineWidgets = [];
  },

  getMessage : function (event, kind) {
    if (kind === 'macro') {
      var name = 'macro expansion' + (event.name ? ': ' + event.name : '');

      return '<span class="tag macro">' + name + '</span>'
        + this.escapeHTML(event.expansion).replace(/(?:\r\n|\r|\n)/g, '<br>');
    } else if (kind === 'note') {
      return '<span class="tag note">note</span>'
        +  this.escapeHTML(event.message).replace(/(?:\r\n|\r|\n)/g, '<br>');
    }
  },

  addExtraPathEvents : function (events, kind) {
    var that = this;

    if (!events) {
      return;
    }

    events.forEach(function (event) {
      if (event.location.file !== that._currentBugEvent.location.file) {
        return;
      }

      var left =
        that._codeMirror.defaultCharWidth() * event.location.col + 'px';

      var element = document.createElement('div');
      element.setAttribute('style', 'margin-left: ' + left);
      element.setAttribute('class', 'check-msg ' + kind);

      var msg = document.createElement('span');
      msg.innerHTML = that.getMessage(event, kind);
      element.appendChild(msg);

      that._lineWidgets.push(that._codeMirror.addLineWidget(
        event.location.line - 1, element));
    });
  },

  drawBugPath : function () {
    var that = this;

    this.clearBubbles();

    this.addExtraPathEvents(this._currentReport.macros, 'macro');
    this.addExtraPathEvents(this._currentReport.notes, 'note');

    // Processing bug path events.
    var currentEvents = this._currentReport.events;
    currentEvents.forEach(function (event, step) {
      if (event.location.file !== that._currentBugEvent.location.file)
        return;

      var left =
        that._codeMirror.defaultCharWidth() * event.location.col + 'px';
      var type = step === currentEvents.length - 1 ? 'error' : 'info';

      var element = document.createElement('div');
      element.setAttribute('style', 'margin-left: ' + left);
      element.setAttribute('class', 'check-msg ' + type);
      element.setAttribute('idx', step);

      var enumeration = document.createElement('span');
      enumeration.setAttribute('class', 'checker-enum ' + type);
      enumeration.innerHTML = step + 1;

      if (currentEvents.length > 1)
        element.appendChild(enumeration);

      var prevBugEvent = step - 1;
      if (step > 0) {
        var prevBug = document.createElement('span');
        prevBug.setAttribute('class', 'arrow left-arrow');
        prevBug.addEventListener('click', function () {
          var event = currentEvents[prevBugEvent];
          that.setCurrentBugEvent(event, prevBugEvent);
        });
        element.appendChild(prevBug);
      }

      var msg = document.createElement('span');
      msg.innerHTML = that.escapeHTML(event.message)
        .replace(/(?:\r\n|\r|\n)/g, '<br>');

      element.appendChild(msg);

      var nextBugEvent = step + 1;
      if (nextBugEvent < currentEvents.length) {
        var nextBug = document.createElement('span');
        nextBug.setAttribute('class', 'arrow right-arrow');
        nextBug.addEventListener('click', function () {
          var event = currentEvents[nextBugEvent];
          that.setCurrentBugEvent(event, nextBugEvent);
        });
        element.appendChild(nextBug);
      }


      that._lineWidgets.push(that._codeMirror.addLineWidget(
        event.location.line - 1, element));
    });
  },

  jumpTo : function (line, column) {
    var that = this;

    setTimeout(function () {
      var selPosPixel
        = that._codeMirror.charCoords({ line : line, ch : column }, 'local');
      var editorSize = {
        width  : that._editor.clientWidth,
        height : that._editor.clientHeight
      };

      that._codeMirror.scrollIntoView({
        top    : selPosPixel.top - 100,
        bottom : selPosPixel.top + editorSize.height - 150,
        left   : selPosPixel.left < editorSize.width - 100
               ? 0
               : selPosPixel.left - 50,
        right  : selPosPixel.left < editorSize.width - 100
               ? 10
               : selPosPixel.left + editorSize.width - 100
      });
    }, 0);
  }
}


      var data = {"files": {"8": {"id": 8, "path": "/home/runner/work/testcc/testcc/retdec/lib/altsvc.h", "content": "#ifndef HEADER_CURL_ALTSVC_H\n#define HEADER_CURL_ALTSVC_H\n/***************************************************************************\n *                                  _   _ ____  _\n *  Project                     ___| | | |  _ \\| |\n *                             / __| | | | |_) | |\n *                            | (__| |_| |  _ <| |___\n *                             \\___|\\___/|_| \\_\\_____|\n *\n * Copyright (C) 2019 - 2020, Daniel Stenberg, <daniel@haxx.se>, et al.\n *\n * This software is licensed as described in the file COPYING, which\n * you should have received as part of this distribution. The terms\n * are also available at https://curl.haxx.se/docs/copyright.html.\n *\n * You may opt to use, copy, modify, merge, publish, distribute and/or sell\n * copies of the Software, and permit persons to whom the Software is\n * furnished to do so, under the terms of the COPYING file.\n *\n * This software is distributed on an \"AS IS\" basis, WITHOUT WARRANTY OF ANY\n * KIND, either express or implied.\n *\n ***************************************************************************/\n#include \"curl_setup.h\"\n\n#if !defined(CURL_DISABLE_HTTP) && defined(USE_ALTSVC)\n#include <curl/curl.h>\n#include \"llist.h\"\n\nenum alpnid {\n  ALPN_none = 0,\n  ALPN_h1 = CURLALTSVC_H1,\n  ALPN_h2 = CURLALTSVC_H2,\n  ALPN_h3 = CURLALTSVC_H3\n};\n\nstruct althost {\n  char *host;\n  unsigned short port;\n  enum alpnid alpnid;\n};\n\nstruct altsvc {\n  struct althost src;\n  struct althost dst;\n  time_t expires;\n  bool persist;\n  int prio;\n  struct curl_llist_element node;\n};\n\nstruct altsvcinfo {\n  char *filename;\n  struct curl_llist list; /* list of entries */\n  long flags; /* the publicly set bitmask */\n};\n\nconst char *Curl_alpnid2str(enum alpnid id);\nstruct altsvcinfo *Curl_altsvc_init(void);\nCURLcode Curl_altsvc_load(struct altsvcinfo *asi, const char *file);\nCURLcode Curl_altsvc_save(struct Curl_easy *data,\n                          struct altsvcinfo *asi, const char *file);\nCURLcode Curl_altsvc_ctrl(struct altsvcinfo *asi, const long ctrl);\nvoid Curl_altsvc_cleanup(struct altsvcinfo *altsvc);\nCURLcode Curl_altsvc_parse(struct Curl_easy *data,\n                           struct altsvcinfo *altsvc, const char *value,\n                           enum alpnid srcalpn, const char *srchost,\n                           unsigned short srcport);\nbool Curl_altsvc_lookup(struct altsvcinfo *asi,\n                        enum alpnid srcalpnid, const char *srchost,\n                        int srcport,\n                        struct altsvc **dstentry,\n                        const int versions); /* CURLALTSVC_H* bits */\n#else\n/* disabled */\n#define Curl_altsvc_save(a,b,c)\n#endif /* CURL_DISABLE_HTTP || USE_ALTSVC */\n#endif /* HEADER_CURL_ALTSVC_H */\n"}, "19": {"id": 19, "path": "/home/runner/work/testcc/testcc/retdec/lib/curl_ntlm_wb.h", "content": "#ifndef HEADER_CURL_NTLM_WB_H\n#define HEADER_CURL_NTLM_WB_H\n/***************************************************************************\n *                                  _   _ ____  _\n *  Project                     ___| | | |  _ \\| |\n *                             / __| | | | |_) | |\n *                            | (__| |_| |  _ <| |___\n *                             \\___|\\___/|_| \\_\\_____|\n *\n * Copyright (C) 1998 - 2019, Daniel Stenberg, <daniel@haxx.se>, et al.\n *\n * This software is licensed as described in the file COPYING, which\n * you should have received as part of this distribution. The terms\n * are also available at https://curl.haxx.se/docs/copyright.html.\n *\n * You may opt to use, copy, modify, merge, publish, distribute and/or sell\n * copies of the Software, and permit persons to whom the Software is\n * furnished to do so, under the terms of the COPYING file.\n *\n * This software is distributed on an \"AS IS\" basis, WITHOUT WARRANTY OF ANY\n * KIND, either express or implied.\n *\n ***************************************************************************/\n\n#include \"curl_setup.h\"\n\n#if !defined(CURL_DISABLE_HTTP) && defined(USE_NTLM) && \\\n    defined(NTLM_WB_ENABLED)\n\n/* this is for ntlm header input */\nCURLcode Curl_input_ntlm_wb(struct connectdata *conn, bool proxy,\n                            const char *header);\n\n/* this is for creating ntlm header output */\nCURLcode Curl_output_ntlm_wb(struct connectdata *conn, bool proxy);\n\nvoid Curl_http_auth_cleanup_ntlm_wb(struct connectdata *conn);\n\n#endif /* !CURL_DISABLE_HTTP && USE_NTLM && NTLM_WB_ENABLED */\n\n#endif /* HEADER_CURL_NTLM_WB_H */\n"}, "31": {"id": 31, "path": "/home/runner/work/testcc/testcc/retdec/lib/http.c", "content": "/***************************************************************************\n *                                  _   _ ____  _\n *  Project                     ___| | | |  _ \\| |\n *                             / __| | | | |_) | |\n *                            | (__| |_| |  _ <| |___\n *                             \\___|\\___/|_| \\_\\_____|\n *\n * Copyright (C) 1998 - 2020, Daniel Stenberg, <daniel@haxx.se>, et al.\n *\n * This software is licensed as described in the file COPYING, which\n * you should have received as part of this distribution. The terms\n * are also available at https://curl.haxx.se/docs/copyright.html.\n *\n * You may opt to use, copy, modify, merge, publish, distribute and/or sell\n * copies of the Software, and permit persons to whom the Software is\n * furnished to do so, under the terms of the COPYING file.\n *\n * This software is distributed on an \"AS IS\" basis, WITHOUT WARRANTY OF ANY\n * KIND, either express or implied.\n *\n ***************************************************************************/\n\n#include \"curl_setup.h\"\n\n#ifndef CURL_DISABLE_HTTP\n\n#ifdef HAVE_NETINET_IN_H\n#include <netinet/in.h>\n#endif\n\n#ifdef HAVE_NETDB_H\n#include <netdb.h>\n#endif\n#ifdef HAVE_ARPA_INET_H\n#include <arpa/inet.h>\n#endif\n#ifdef HAVE_NET_IF_H\n#include <net/if.h>\n#endif\n#ifdef HAVE_SYS_IOCTL_H\n#include <sys/ioctl.h>\n#endif\n\n#ifdef HAVE_SYS_PARAM_H\n#include <sys/param.h>\n#endif\n\n#include \"urldata.h\"\n#include <curl/curl.h>\n#include \"transfer.h\"\n#include \"sendf.h\"\n#include \"formdata.h\"\n#include \"mime.h\"\n#include \"progress.h\"\n#include \"curl_base64.h\"\n#include \"cookie.h\"\n#include \"vauth/vauth.h\"\n#include \"vtls/vtls.h\"\n#include \"http_digest.h\"\n#include \"http_ntlm.h\"\n#include \"curl_ntlm_wb.h\"\n#include \"http_negotiate.h\"\n#include \"url.h\"\n#include \"share.h\"\n#include \"hostip.h\"\n#include \"http.h\"\n#include \"select.h\"\n#include \"parsedate.h\" /* for the week day and month names */\n#include \"strtoofft.h\"\n#include \"multiif.h\"\n#include \"strcase.h\"\n#include \"content_encoding.h\"\n#include \"http_proxy.h\"\n#include \"warnless.h\"\n#include \"non-ascii.h\"\n#include \"http2.h\"\n#include \"connect.h\"\n#include \"strdup.h\"\n#include \"altsvc.h\"\n\n/* The last 3 #include files should be in this order */\n#include \"curl_printf.h\"\n#include \"curl_memory.h\"\n#include \"memdebug.h\"\n\n/*\n * Forward declarations.\n */\n\nstatic int http_getsock_do(struct connectdata *conn,\n                           curl_socket_t *socks);\nstatic int http_should_fail(struct connectdata *conn);\n\n#ifndef CURL_DISABLE_PROXY\nstatic CURLcode add_haproxy_protocol_header(struct connectdata *conn);\n#endif\n\n#ifdef USE_SSL\nstatic CURLcode https_connecting(struct connectdata *conn, bool *done);\nstatic int https_getsock(struct connectdata *conn,\n                         curl_socket_t *socks);\n#else\n#define https_connecting(x,y) CURLE_COULDNT_CONNECT\n#endif\nstatic CURLcode http_setup_conn(struct connectdata *conn);\n\n/*\n * HTTP handler interface.\n */\nconst struct Curl_handler Curl_handler_http = {\n  \"HTTP\",                               /* scheme */\n  http_setup_conn,                      /* setup_connection */\n  Curl_http,                            /* do_it */\n  Curl_http_done,                       /* done */\n  ZERO_NULL,                            /* do_more */\n  Curl_http_connect,                    /* connect_it */\n  ZERO_NULL,                            /* connecting */\n  ZERO_NULL,                            /* doing */\n  ZERO_NULL,                            /* proto_getsock */\n  http_getsock_do,                      /* doing_getsock */\n  ZERO_NULL,                            /* domore_getsock */\n  ZERO_NULL,                            /* perform_getsock */\n  ZERO_NULL,                            /* disconnect */\n  ZERO_NULL,                            /* readwrite */\n  ZERO_NULL,                            /* connection_check */\n  PORT_HTTP,                            /* defport */\n  CURLPROTO_HTTP,                       /* protocol */\n  PROTOPT_CREDSPERREQUEST |             /* flags */\n  PROTOPT_USERPWDCTRL\n};\n\n#ifdef USE_SSL\n/*\n * HTTPS handler interface.\n */\nconst struct Curl_handler Curl_handler_https = {\n  \"HTTPS\",                              /* scheme */\n  http_setup_conn,                      /* setup_connection */\n  Curl_http,                            /* do_it */\n  Curl_http_done,                       /* done */\n  ZERO_NULL,                            /* do_more */\n  Curl_http_connect,                    /* connect_it */\n  https_connecting,                     /* connecting */\n  ZERO_NULL,                            /* doing */\n  https_getsock,                        /* proto_getsock */\n  http_getsock_do,                      /* doing_getsock */\n  ZERO_NULL,                            /* domore_getsock */\n  ZERO_NULL,                            /* perform_getsock */\n  ZERO_NULL,                            /* disconnect */\n  ZERO_NULL,                            /* readwrite */\n  ZERO_NULL,                            /* connection_check */\n  PORT_HTTPS,                           /* defport */\n  CURLPROTO_HTTPS,                      /* protocol */\n  PROTOPT_SSL | PROTOPT_CREDSPERREQUEST | PROTOPT_ALPN_NPN | /* flags */\n  PROTOPT_USERPWDCTRL\n};\n#endif\n\nstatic CURLcode http_setup_conn(struct connectdata *conn)\n{\n  /* allocate the HTTP-specific struct for the Curl_easy, only to survive\n     during this request */\n  struct HTTP *http;\n  struct Curl_easy *data = conn->data;\n  DEBUGASSERT(data->req.protop == NULL);\n\n  http = calloc(1, sizeof(struct HTTP));\n  if(!http)\n    return CURLE_OUT_OF_MEMORY;\n\n  Curl_mime_initpart(&http->form, conn->data);\n  data->req.protop = http;\n\n  if(data->set.httpversion == CURL_HTTP_VERSION_3) {\n    if(conn->handler->flags & PROTOPT_SSL)\n      /* Only go HTTP/3 directly on HTTPS URLs. It needs a UDP socket and does\n         the QUIC dance. */\n      conn->transport = TRNSPRT_QUIC;\n    else {\n      failf(data, \"HTTP/3 requested for non-HTTPS URL\");\n      return CURLE_URL_MALFORMAT;\n    }\n  }\n  else {\n    if(!CONN_INUSE(conn))\n      /* if not already multi-using, setup connection details */\n      Curl_http2_setup_conn(conn);\n    Curl_http2_setup_req(data);\n  }\n  return CURLE_OK;\n}\n\n#ifndef CURL_DISABLE_PROXY\n/*\n * checkProxyHeaders() checks the linked list of custom proxy headers\n * if proxy headers are not available, then it will lookup into http header\n * link list\n *\n * It takes a connectdata struct as input instead of the Curl_easy simply to\n * know if this is a proxy request or not, as it then might check a different\n * header list. Provide the header prefix without colon!.\n */\nchar *Curl_checkProxyheaders(const struct connectdata *conn,\n                             const char *thisheader)\n{\n  struct curl_slist *head;\n  size_t thislen = strlen(thisheader);\n  struct Curl_easy *data = conn->data;\n\n  for(head = (conn->bits.proxy && data->set.sep_headers) ?\n        data->set.proxyheaders : data->set.headers;\n      head; head = head->next) {\n    if(strncasecompare(head->data, thisheader, thislen) &&\n       Curl_headersep(head->data[thislen]))\n      return head->data;\n  }\n\n  return NULL;\n}\n#else\n/* disabled */\n#define Curl_checkProxyheaders(x,y) NULL\n#endif\n\n/*\n * Strip off leading and trailing whitespace from the value in the\n * given HTTP header line and return a strdupped copy. Returns NULL in\n * case of allocation failure. Returns an empty string if the header value\n * consists entirely of whitespace.\n */\nchar *Curl_copy_header_value(const char *header)\n{\n  const char *start;\n  const char *end;\n  char *value;\n  size_t len;\n\n  /* Find the end of the header name */\n  while(*header && (*header != ':'))\n    ++header;\n\n  if(*header)\n    /* Skip over colon */\n    ++header;\n\n  /* Find the first non-space letter */\n  start = header;\n  while(*start && ISSPACE(*start))\n    start++;\n\n  /* data is in the host encoding so\n     use '\\r' and '\\n' instead of 0x0d and 0x0a */\n  end = strchr(start, '\\r');\n  if(!end)\n    end = strchr(start, '\\n');\n  if(!end)\n    end = strchr(start, '\\0');\n  if(!end)\n    return NULL;\n\n  /* skip all trailing space letters */\n  while((end > start) && ISSPACE(*end))\n    end--;\n\n  /* get length of the type */\n  len = end - start + 1;\n\n  value = malloc(len + 1);\n  if(!value)\n    return NULL;\n\n  memcpy(value, start, len);\n  value[len] = 0; /* null-terminate */\n\n  return value;\n}\n\n#ifndef CURL_DISABLE_HTTP_AUTH\n/*\n * http_output_basic() sets up an Authorization: header (or the proxy version)\n * for HTTP Basic authentication.\n *\n * Returns CURLcode.\n */\nstatic CURLcode http_output_basic(struct connectdata *conn, bool proxy)\n{\n  size_t size = 0;\n  char *authorization = NULL;\n  struct Curl_easy *data = conn->data;\n  char **userp;\n  const char *user;\n  const char *pwd;\n  CURLcode result;\n  char *out;\n\n  if(proxy) {\n#ifndef CURL_DISABLE_PROXY\n    userp = &data->state.aptr.proxyuserpwd;\n    user = conn->http_proxy.user;\n    pwd = conn->http_proxy.passwd;\n#else\n    return CURLE_NOT_BUILT_IN;\n#endif\n  }\n  else {\n    userp = &data->state.aptr.userpwd;\n    user = conn->user;\n    pwd = conn->passwd;\n  }\n\n  out = aprintf(\"%s:%s\", user, pwd ? pwd : \"\");\n  if(!out)\n    return CURLE_OUT_OF_MEMORY;\n\n  result = Curl_base64_encode(data, out, strlen(out), &authorization, &size);\n  if(result)\n    goto fail;\n\n  if(!authorization) {\n    result = CURLE_REMOTE_ACCESS_DENIED;\n    goto fail;\n  }\n\n  free(*userp);\n  *userp = aprintf(\"%sAuthorization: Basic %s\\r\\n\",\n                   proxy ? \"Proxy-\" : \"\",\n                   authorization);\n  free(authorization);\n  if(!*userp) {\n    result = CURLE_OUT_OF_MEMORY;\n    goto fail;\n  }\n\n  fail:\n  free(out);\n  return result;\n}\n\n/*\n * http_output_bearer() sets up an Authorization: header\n * for HTTP Bearer authentication.\n *\n * Returns CURLcode.\n */\nstatic CURLcode http_output_bearer(struct connectdata *conn)\n{\n  char **userp;\n  CURLcode result = CURLE_OK;\n  struct Curl_easy *data = conn->data;\n\n  userp = &data->state.aptr.userpwd;\n  free(*userp);\n  *userp = aprintf(\"Authorization: Bearer %s\\r\\n\",\n                   conn->data->set.str[STRING_BEARER]);\n\n  if(!*userp) {\n    result = CURLE_OUT_OF_MEMORY;\n    goto fail;\n  }\n\n  fail:\n  return result;\n}\n\n#endif\n\n/* pickoneauth() selects the most favourable authentication method from the\n * ones available and the ones we want.\n *\n * return TRUE if one was picked\n */\nstatic bool pickoneauth(struct auth *pick, unsigned long mask)\n{\n  bool picked;\n  /* only deal with authentication we want */\n  unsigned long avail = pick->avail & pick->want & mask;\n  picked = TRUE;\n\n  /* The order of these checks is highly relevant, as this will be the order\n     of preference in case of the existence of multiple accepted types. */\n  if(avail & CURLAUTH_NEGOTIATE)\n    pick->picked = CURLAUTH_NEGOTIATE;\n  else if(avail & CURLAUTH_BEARER)\n    pick->picked = CURLAUTH_BEARER;\n  else if(avail & CURLAUTH_DIGEST)\n    pick->picked = CURLAUTH_DIGEST;\n  else if(avail & CURLAUTH_NTLM)\n    pick->picked = CURLAUTH_NTLM;\n  else if(avail & CURLAUTH_NTLM_WB)\n    pick->picked = CURLAUTH_NTLM_WB;\n  else if(avail & CURLAUTH_BASIC)\n    pick->picked = CURLAUTH_BASIC;\n  else {\n    pick->picked = CURLAUTH_PICKNONE; /* we select to use nothing */\n    picked = FALSE;\n  }\n  pick->avail = CURLAUTH_NONE; /* clear it here */\n\n  return picked;\n}\n\n/*\n * http_perhapsrewind()\n *\n * If we are doing POST or PUT {\n *   If we have more data to send {\n *     If we are doing NTLM {\n *       Keep sending since we must not disconnect\n *     }\n *     else {\n *       If there is more than just a little data left to send, close\n *       the current connection by force.\n *     }\n *   }\n *   If we have sent any data {\n *     If we don't have track of all the data {\n *       call app to tell it to rewind\n *     }\n *     else {\n *       rewind internally so that the operation can restart fine\n *     }\n *   }\n * }\n */\nstatic CURLcode http_perhapsrewind(struct connectdata *conn)\n{\n  struct Curl_easy *data = conn->data;\n  struct HTTP *http = data->req.protop;\n  curl_off_t bytessent;\n  curl_off_t expectsend = -1; /* default is unknown */\n\n  if(!http)\n    /* If this is still NULL, we have not reach very far and we can safely\n       skip this rewinding stuff */\n    return CURLE_OK;\n\n  switch(data->state.httpreq) {\n  case HTTPREQ_GET:\n  case HTTPREQ_HEAD:\n    return CURLE_OK;\n  default:\n    break;\n  }\n\n  bytessent = data->req.writebytecount;\n\n  if(conn->bits.authneg) {\n    /* This is a state where we are known to be negotiating and we don't send\n       any data then. */\n    expectsend = 0;\n  }\n  else if(!conn->bits.protoconnstart) {\n    /* HTTP CONNECT in progress: there is no body */\n    expectsend = 0;\n  }\n  else {\n    /* figure out how much data we are expected to send */\n    switch(data->state.httpreq) {\n    case HTTPREQ_POST:\n    case HTTPREQ_PUT:\n      if(data->state.infilesize != -1)\n        expectsend = data->state.infilesize;\n      break;\n    case HTTPREQ_POST_FORM:\n    case HTTPREQ_POST_MIME:\n      expectsend = http->postsize;\n      break;\n    default:\n      break;\n    }\n  }\n\n  conn->bits.rewindaftersend = FALSE; /* default */\n\n  if((expectsend == -1) || (expectsend > bytessent)) {\n#if defined(USE_NTLM)\n    /* There is still data left to send */\n    if((data->state.authproxy.picked == CURLAUTH_NTLM) ||\n       (data->state.authhost.picked == CURLAUTH_NTLM) ||\n       (data->state.authproxy.picked == CURLAUTH_NTLM_WB) ||\n       (data->state.authhost.picked == CURLAUTH_NTLM_WB)) {\n      if(((expectsend - bytessent) < 2000) ||\n         (conn->http_ntlm_state != NTLMSTATE_NONE) ||\n         (conn->proxy_ntlm_state != NTLMSTATE_NONE)) {\n        /* The NTLM-negotiation has started *OR* there is just a little (<2K)\n           data left to send, keep on sending. */\n\n        /* rewind data when completely done sending! */\n        if(!conn->bits.authneg && (conn->writesockfd != CURL_SOCKET_BAD)) {\n          conn->bits.rewindaftersend = TRUE;\n          infof(data, \"Rewind stream after send\\n\");\n        }\n\n        return CURLE_OK;\n      }\n\n      if(conn->bits.close)\n        /* this is already marked to get closed */\n        return CURLE_OK;\n\n      infof(data, \"NTLM send, close instead of sending %\"\n            CURL_FORMAT_CURL_OFF_T \" bytes\\n\",\n            (curl_off_t)(expectsend - bytessent));\n    }\n#endif\n#if defined(USE_SPNEGO)\n    /* There is still data left to send */\n    if((data->state.authproxy.picked == CURLAUTH_NEGOTIATE) ||\n       (data->state.authhost.picked == CURLAUTH_NEGOTIATE)) {\n      if(((expectsend - bytessent) < 2000) ||\n         (conn->http_negotiate_state != GSS_AUTHNONE) ||\n         (conn->proxy_negotiate_state != GSS_AUTHNONE)) {\n        /* The NEGOTIATE-negotiation has started *OR*\n        there is just a little (<2K) data left to send, keep on sending. */\n\n        /* rewind data when completely done sending! */\n        if(!conn->bits.authneg && (conn->writesockfd != CURL_SOCKET_BAD)) {\n          conn->bits.rewindaftersend = TRUE;\n          infof(data, \"Rewind stream after send\\n\");\n        }\n\n        return CURLE_OK;\n      }\n\n      if(conn->bits.close)\n        /* this is already marked to get closed */\n        return CURLE_OK;\n\n      infof(data, \"NEGOTIATE send, close instead of sending %\"\n        CURL_FORMAT_CURL_OFF_T \" bytes\\n\",\n        (curl_off_t)(expectsend - bytessent));\n    }\n#endif\n\n    /* This is not NEGOTIATE/NTLM or many bytes left to send: close */\n    streamclose(conn, \"Mid-auth HTTP and much data left to send\");\n    data->req.size = 0; /* don't download any more than 0 bytes */\n\n    /* There still is data left to send, but this connection is marked for\n       closure so we can safely do the rewind right now */\n  }\n\n  if(bytessent)\n    /* we rewind now at once since if we already sent something */\n    return Curl_readrewind(conn);\n\n  return CURLE_OK;\n}\n\n/*\n * Curl_http_auth_act() gets called when all HTTP headers have been received\n * and it checks what authentication methods that are available and decides\n * which one (if any) to use. It will set 'newurl' if an auth method was\n * picked.\n */\n\nCURLcode Curl_http_auth_act(struct connectdata *conn)\n{\n  struct Curl_easy *data = conn->data;\n  bool pickhost = FALSE;\n  bool pickproxy = FALSE;\n  CURLcode result = CURLE_OK;\n  unsigned long authmask = ~0ul;\n\n  if(!data->set.str[STRING_BEARER])\n    authmask &= (unsigned long)~CURLAUTH_BEARER;\n\n  if(100 <= data->req.httpcode && 199 >= data->req.httpcode)\n    /* this is a transient response code, ignore */\n    return CURLE_OK;\n\n  if(data->state.authproblem)\n    return data->set.http_fail_on_error?CURLE_HTTP_RETURNED_ERROR:CURLE_OK;\n\n  if((conn->bits.user_passwd || data->set.str[STRING_BEARER]) &&\n     ((data->req.httpcode == 401) ||\n      (conn->bits.authneg && data->req.httpcode < 300))) {\n    pickhost = pickoneauth(&data->state.authhost, authmask);\n    if(!pickhost)\n      data->state.authproblem = TRUE;\n    if(data->state.authhost.picked == CURLAUTH_NTLM &&\n       conn->httpversion > 11) {\n      infof(data, \"Forcing HTTP/1.1 for NTLM\");\n      connclose(conn, \"Force HTTP/1.1 connection\");\n      conn->data->set.httpversion = CURL_HTTP_VERSION_1_1;\n    }\n  }\n#ifndef CURL_DISABLE_PROXY\n  if(conn->bits.proxy_user_passwd &&\n     ((data->req.httpcode == 407) ||\n      (conn->bits.authneg && data->req.httpcode < 300))) {\n    pickproxy = pickoneauth(&data->state.authproxy,\n                            authmask & ~CURLAUTH_BEARER);\n    if(!pickproxy)\n      data->state.authproblem = TRUE;\n  }\n#endif\n\n  if(pickhost || pickproxy) {\n    if((data->state.httpreq != HTTPREQ_GET) &&\n       (data->state.httpreq != HTTPREQ_HEAD) &&\n       !conn->bits.rewindaftersend) {\n      result = http_perhapsrewind(conn);\n      if(result)\n        return result;\n    }\n    /* In case this is GSS auth, the newurl field is already allocated so\n       we must make sure to free it before allocating a new one. As figured\n       out in bug #2284386 */\n    Curl_safefree(data->req.newurl);\n    data->req.newurl = strdup(data->change.url); /* clone URL */\n    if(!data->req.newurl)\n      return CURLE_OUT_OF_MEMORY;\n  }\n  else if((data->req.httpcode < 300) &&\n          (!data->state.authhost.done) &&\n          conn->bits.authneg) {\n    /* no (known) authentication available,\n       authentication is not \"done\" yet and\n       no authentication seems to be required and\n       we didn't try HEAD or GET */\n    if((data->state.httpreq != HTTPREQ_GET) &&\n       (data->state.httpreq != HTTPREQ_HEAD)) {\n      data->req.newurl = strdup(data->change.url); /* clone URL */\n      if(!data->req.newurl)\n        return CURLE_OUT_OF_MEMORY;\n      data->state.authhost.done = TRUE;\n    }\n  }\n  if(http_should_fail(conn)) {\n    failf(data, \"The requested URL returned error: %d\",\n          data->req.httpcode);\n    result = CURLE_HTTP_RETURNED_ERROR;\n  }\n\n  return result;\n}\n\n#ifndef CURL_DISABLE_HTTP_AUTH\n/*\n * Output the correct authentication header depending on the auth type\n * and whether or not it is to a proxy.\n */\nstatic CURLcode\noutput_auth_headers(struct connectdata *conn,\n                    struct auth *authstatus,\n                    const char *request,\n                    const char *path,\n                    bool proxy)\n{\n  const char *auth = NULL;\n  CURLcode result = CURLE_OK;\n  struct Curl_easy *data = conn->data;\n\n#ifdef CURL_DISABLE_CRYPTO_AUTH\n  (void)request;\n  (void)path;\n#endif\n\n#ifdef USE_SPNEGO\n  if(authstatus->picked == CURLAUTH_NEGOTIATE) {\n    auth = \"Negotiate\";\n    result = Curl_output_negotiate(conn, proxy);\n    if(result)\n      return result;\n  }\n  else\n#endif\n#ifdef USE_NTLM\n  if(authstatus->picked == CURLAUTH_NTLM) {\n    auth = \"NTLM\";\n    result = Curl_output_ntlm(conn, proxy);\n    if(result)\n      return result;\n  }\n  else\n#endif\n#if defined(USE_NTLM) && defined(NTLM_WB_ENABLED)\n  if(authstatus->picked == CURLAUTH_NTLM_WB) {\n    auth = \"NTLM_WB\";\n    result = Curl_output_ntlm_wb(conn, proxy);\n    if(result)\n      return result;\n  }\n  else\n#endif\n#ifndef CURL_DISABLE_CRYPTO_AUTH\n  if(authstatus->picked == CURLAUTH_DIGEST) {\n    auth = \"Digest\";\n    result = Curl_output_digest(conn,\n                                proxy,\n                                (const unsigned char *)request,\n                                (const unsigned char *)path);\n    if(result)\n      return result;\n  }\n  else\n#endif\n  if(authstatus->picked == CURLAUTH_BASIC) {\n    /* Basic */\n    if(\n#ifndef CURL_DISABLE_PROXY\n      (proxy && conn->bits.proxy_user_passwd &&\n       !Curl_checkProxyheaders(conn, \"Proxy-authorization\")) ||\n#endif\n      (!proxy && conn->bits.user_passwd &&\n       !Curl_checkheaders(conn, \"Authorization\"))) {\n      auth = \"Basic\";\n      result = http_output_basic(conn, proxy);\n      if(result)\n        return result;\n    }\n\n    /* NOTE: this function should set 'done' TRUE, as the other auth\n       functions work that way */\n    authstatus->done = TRUE;\n  }\n  if(authstatus->picked == CURLAUTH_BEARER) {\n    /* Bearer */\n    if((!proxy && data->set.str[STRING_BEARER] &&\n        !Curl_checkheaders(conn, \"Authorization:\"))) {\n      auth = \"Bearer\";\n      result = http_output_bearer(conn);\n      if(result)\n        return result;\n    }\n\n    /* NOTE: this function should set 'done' TRUE, as the other auth\n       functions work that way */\n    authstatus->done = TRUE;\n  }\n\n  if(auth) {\n#ifndef CURL_DISABLE_PROXY\n    infof(data, \"%s auth using %s with user '%s'\\n\",\n          proxy ? \"Proxy\" : \"Server\", auth,\n          proxy ? (conn->http_proxy.user ? conn->http_proxy.user : \"\") :\n          (conn->user ? conn->user : \"\"));\n#else\n    infof(data, \"Server auth using %s with user '%s'\\n\",\n          auth, conn->user ? conn->user : \"\");\n#endif\n    authstatus->multipass = (!authstatus->done) ? TRUE : FALSE;\n  }\n  else\n    authstatus->multipass = FALSE;\n\n  return CURLE_OK;\n}\n\n/**\n * Curl_http_output_auth() setups the authentication headers for the\n * host/proxy and the correct authentication\n * method. conn->data->state.authdone is set to TRUE when authentication is\n * done.\n *\n * @param conn all information about the current connection\n * @param request pointer to the request keyword\n * @param path pointer to the requested path; should include query part\n * @param proxytunnel boolean if this is the request setting up a \"proxy\n * tunnel\"\n *\n * @returns CURLcode\n */\nCURLcode\nCurl_http_output_auth(struct connectdata *conn,\n                      const char *request,\n                      const char *path,\n                      bool proxytunnel) /* TRUE if this is the request setting\n                                           up the proxy tunnel */\n{\n  CURLcode result = CURLE_OK;\n  struct Curl_easy *data = conn->data;\n  struct auth *authhost;\n  struct auth *authproxy;\n\n  DEBUGASSERT(data);\n\n  authhost = &data->state.authhost;\n  authproxy = &data->state.authproxy;\n\n  if(\n#ifndef CURL_DISABLE_PROXY\n    (conn->bits.httpproxy && conn->bits.proxy_user_passwd) ||\n#endif\n     conn->bits.user_passwd || data->set.str[STRING_BEARER])\n    /* continue please */;\n  else {\n    authhost->done = TRUE;\n    authproxy->done = TRUE;\n    return CURLE_OK; /* no authentication with no user or password */\n  }\n\n  if(authhost->want && !authhost->picked)\n    /* The app has selected one or more methods, but none has been picked\n       so far by a server round-trip. Then we set the picked one to the\n       want one, and if this is one single bit it'll be used instantly. */\n    authhost->picked = authhost->want;\n\n  if(authproxy->want && !authproxy->picked)\n    /* The app has selected one or more methods, but none has been picked so\n       far by a proxy round-trip. Then we set the picked one to the want one,\n       and if this is one single bit it'll be used instantly. */\n    authproxy->picked = authproxy->want;\n\n#ifndef CURL_DISABLE_PROXY\n  /* Send proxy authentication header if needed */\n  if(conn->bits.httpproxy &&\n     (conn->bits.tunnel_proxy == (bit)proxytunnel)) {\n    result = output_auth_headers(conn, authproxy, request, path, TRUE);\n    if(result)\n      return result;\n  }\n  else\n#else\n  (void)proxytunnel;\n#endif /* CURL_DISABLE_PROXY */\n    /* we have no proxy so let's pretend we're done authenticating\n       with it */\n    authproxy->done = TRUE;\n\n  /* To prevent the user+password to get sent to other than the original\n     host due to a location-follow, we do some weirdo checks here */\n  if(!data->state.this_is_a_follow ||\n     conn->bits.netrc ||\n     !data->state.first_host ||\n     data->set.allow_auth_to_other_hosts ||\n     strcasecompare(data->state.first_host, conn->host.name)) {\n    result = output_auth_headers(conn, authhost, request, path, FALSE);\n  }\n  else\n    authhost->done = TRUE;\n\n  return result;\n}\n\n#else\n/* when disabled */\nCURLcode\nCurl_http_output_auth(struct connectdata *conn,\n                      const char *request,\n                      const char *path,\n                      bool proxytunnel)\n{\n  (void)conn;\n  (void)request;\n  (void)path;\n  (void)proxytunnel;\n  return CURLE_OK;\n}\n#endif\n\n/*\n * Curl_http_input_auth() deals with Proxy-Authenticate: and WWW-Authenticate:\n * headers. They are dealt with both in the transfer.c main loop and in the\n * proxy CONNECT loop.\n */\n\nCURLcode Curl_http_input_auth(struct connectdata *conn, bool proxy,\n                              const char *auth) /* the first non-space */\n{\n  /*\n   * This resource requires authentication\n   */\n  struct Curl_easy *data = conn->data;\n\n#ifdef USE_SPNEGO\n  curlnegotiate *negstate = proxy ? &conn->proxy_negotiate_state :\n                                    &conn->http_negotiate_state;\n#endif\n  unsigned long *availp;\n  struct auth *authp;\n\n  if(proxy) {\n    availp = &data->info.proxyauthavail;\n    authp = &data->state.authproxy;\n  }\n  else {\n    availp = &data->info.httpauthavail;\n    authp = &data->state.authhost;\n  }\n\n  /*\n   * Here we check if we want the specific single authentication (using ==) and\n   * if we do, we initiate usage of it.\n   *\n   * If the provided authentication is wanted as one out of several accepted\n   * types (using &), we OR this authentication type to the authavail\n   * variable.\n   *\n   * Note:\n   *\n   * ->picked is first set to the 'want' value (one or more bits) before the\n   * request is sent, and then it is again set _after_ all response 401/407\n   * headers have been received but then only to a single preferred method\n   * (bit).\n   */\n\n  while(*auth) {\n#ifdef USE_SPNEGO\n    if(checkprefix(\"Negotiate\", auth)) {\n      if((authp->avail & CURLAUTH_NEGOTIATE) ||\n         Curl_auth_is_spnego_supported()) {\n        *availp |= CURLAUTH_NEGOTIATE;\n        authp->avail |= CURLAUTH_NEGOTIATE;\n\n        if(authp->picked == CURLAUTH_NEGOTIATE) {\n          CURLcode result = Curl_input_negotiate(conn, proxy, auth);\n          if(!result) {\n            DEBUGASSERT(!data->req.newurl);\n            data->req.newurl = strdup(data->change.url);\n            if(!data->req.newurl)\n              return CURLE_OUT_OF_MEMORY;\n            data->state.authproblem = FALSE;\n            /* we received a GSS auth token and we dealt with it fine */\n            *negstate = GSS_AUTHRECV;\n          }\n          else\n            data->state.authproblem = TRUE;\n        }\n      }\n    }\n    else\n#endif\n#ifdef USE_NTLM\n      /* NTLM support requires the SSL crypto libs */\n      if(checkprefix(\"NTLM\", auth)) {\n        if((authp->avail & CURLAUTH_NTLM) ||\n           (authp->avail & CURLAUTH_NTLM_WB) ||\n           Curl_auth_is_ntlm_supported()) {\n          *availp |= CURLAUTH_NTLM;\n          authp->avail |= CURLAUTH_NTLM;\n\n          if(authp->picked == CURLAUTH_NTLM ||\n             authp->picked == CURLAUTH_NTLM_WB) {\n            /* NTLM authentication is picked and activated */\n            CURLcode result = Curl_input_ntlm(conn, proxy, auth);\n            if(!result) {\n              data->state.authproblem = FALSE;\n#ifdef NTLM_WB_ENABLED\n              if(authp->picked == CURLAUTH_NTLM_WB) {\n                *availp &= ~CURLAUTH_NTLM;\n                authp->avail &= ~CURLAUTH_NTLM;\n                *availp |= CURLAUTH_NTLM_WB;\n                authp->avail |= CURLAUTH_NTLM_WB;\n\n                result = Curl_input_ntlm_wb(conn, proxy, auth);\n                if(result) {\n                  infof(data, \"Authentication problem. Ignoring this.\\n\");\n                  data->state.authproblem = TRUE;\n                }\n              }\n#endif\n            }\n            else {\n              infof(data, \"Authentication problem. Ignoring this.\\n\");\n              data->state.authproblem = TRUE;\n            }\n          }\n        }\n      }\n      else\n#endif\n#ifndef CURL_DISABLE_CRYPTO_AUTH\n        if(checkprefix(\"Digest\", auth)) {\n          if((authp->avail & CURLAUTH_DIGEST) != 0)\n            infof(data, \"Ignoring duplicate digest auth header.\\n\");\n          else if(Curl_auth_is_digest_supported()) {\n            CURLcode result;\n\n            *availp |= CURLAUTH_DIGEST;\n            authp->avail |= CURLAUTH_DIGEST;\n\n            /* We call this function on input Digest headers even if Digest\n             * authentication isn't activated yet, as we need to store the\n             * incoming data from this header in case we are going to use\n             * Digest */\n            result = Curl_input_digest(conn, proxy, auth);\n            if(result) {\n              infof(data, \"Authentication problem. Ignoring this.\\n\");\n              data->state.authproblem = TRUE;\n            }\n          }\n        }\n        else\n#endif\n          if(checkprefix(\"Basic\", auth)) {\n            *availp |= CURLAUTH_BASIC;\n            authp->avail |= CURLAUTH_BASIC;\n            if(authp->picked == CURLAUTH_BASIC) {\n              /* We asked for Basic authentication but got a 40X back\n                 anyway, which basically means our name+password isn't\n                 valid. */\n              authp->avail = CURLAUTH_NONE;\n              infof(data, \"Authentication problem. Ignoring this.\\n\");\n              data->state.authproblem = TRUE;\n            }\n          }\n          else\n            if(checkprefix(\"Bearer\", auth)) {\n              *availp |= CURLAUTH_BEARER;\n              authp->avail |= CURLAUTH_BEARER;\n              if(authp->picked == CURLAUTH_BEARER) {\n                /* We asked for Bearer authentication but got a 40X back\n                  anyway, which basically means our token isn't valid. */\n                authp->avail = CURLAUTH_NONE;\n                infof(data, \"Authentication problem. Ignoring this.\\n\");\n                data->state.authproblem = TRUE;\n              }\n            }\n\n    /* there may be multiple methods on one line, so keep reading */\n    while(*auth && *auth != ',') /* read up to the next comma */\n      auth++;\n    if(*auth == ',') /* if we're on a comma, skip it */\n      auth++;\n    while(*auth && ISSPACE(*auth))\n      auth++;\n  }\n\n  return CURLE_OK;\n}\n\n/**\n * http_should_fail() determines whether an HTTP response has gotten us\n * into an error state or not.\n *\n * @param conn all information about the current connection\n *\n * @retval 0 communications should continue\n *\n * @retval 1 communications should not continue\n */\nstatic int http_should_fail(struct connectdata *conn)\n{\n  struct Curl_easy *data;\n  int httpcode;\n\n  DEBUGASSERT(conn);\n  data = conn->data;\n  DEBUGASSERT(data);\n\n  httpcode = data->req.httpcode;\n\n  /*\n  ** If we haven't been asked to fail on error,\n  ** don't fail.\n  */\n  if(!data->set.http_fail_on_error)\n    return 0;\n\n  /*\n  ** Any code < 400 is never terminal.\n  */\n  if(httpcode < 400)\n    return 0;\n\n  /*\n  ** Any code >= 400 that's not 401 or 407 is always\n  ** a terminal error\n  */\n  if((httpcode != 401) && (httpcode != 407))\n    return 1;\n\n  /*\n  ** All we have left to deal with is 401 and 407\n  */\n  DEBUGASSERT((httpcode == 401) || (httpcode == 407));\n\n  /*\n  ** Examine the current authentication state to see if this\n  ** is an error.  The idea is for this function to get\n  ** called after processing all the headers in a response\n  ** message.  So, if we've been to asked to authenticate a\n  ** particular stage, and we've done it, we're OK.  But, if\n  ** we're already completely authenticated, it's not OK to\n  ** get another 401 or 407.\n  **\n  ** It is possible for authentication to go stale such that\n  ** the client needs to reauthenticate.  Once that info is\n  ** available, use it here.\n  */\n\n  /*\n  ** Either we're not authenticating, or we're supposed to\n  ** be authenticating something else.  This is an error.\n  */\n  if((httpcode == 401) && !conn->bits.user_passwd)\n    return TRUE;\n#ifndef CURL_DISABLE_PROXY\n  if((httpcode == 407) && !conn->bits.proxy_user_passwd)\n    return TRUE;\n#endif\n\n  return data->state.authproblem;\n}\n\n/*\n * readmoredata() is a \"fread() emulation\" to provide POST and/or request\n * data. It is used when a huge POST is to be made and the entire chunk wasn't\n * sent in the first send(). This function will then be called from the\n * transfer.c loop when more data is to be sent to the peer.\n *\n * Returns the amount of bytes it filled the buffer with.\n */\nstatic size_t readmoredata(char *buffer,\n                           size_t size,\n                           size_t nitems,\n                           void *userp)\n{\n  struct connectdata *conn = (struct connectdata *)userp;\n  struct HTTP *http = conn->data->req.protop;\n  size_t fullsize = size * nitems;\n\n  if(!http->postsize)\n    /* nothing to return */\n    return 0;\n\n  /* make sure that a HTTP request is never sent away chunked! */\n  conn->data->req.forbidchunk = (http->sending == HTTPSEND_REQUEST)?TRUE:FALSE;\n\n  if(http->postsize <= (curl_off_t)fullsize) {\n    memcpy(buffer, http->postdata, (size_t)http->postsize);\n    fullsize = (size_t)http->postsize;\n\n    if(http->backup.postsize) {\n      /* move backup data into focus and continue on that */\n      http->postdata = http->backup.postdata;\n      http->postsize = http->backup.postsize;\n      conn->data->state.fread_func = http->backup.fread_func;\n      conn->data->state.in = http->backup.fread_in;\n\n      http->sending++; /* move one step up */\n\n      http->backup.postsize = 0;\n    }\n    else\n      http->postsize = 0;\n\n    return fullsize;\n  }\n\n  memcpy(buffer, http->postdata, fullsize);\n  http->postdata += fullsize;\n  http->postsize -= fullsize;\n\n  return fullsize;\n}\n\n/*\n * Curl_buffer_send() sends a header buffer and frees all associated\n * memory.  Body data may be appended to the header data if desired.\n *\n * Returns CURLcode\n */\nCURLcode Curl_buffer_send(struct dynbuf *in,\n                          struct connectdata *conn,\n                          /* add the number of sent bytes to this\n                             counter */\n                          curl_off_t *bytes_written,\n                          /* how much of the buffer contains body data */\n                          size_t included_body_bytes,\n                          int socketindex)\n{\n  ssize_t amount;\n  CURLcode result;\n  char *ptr;\n  size_t size;\n  struct Curl_easy *data = conn->data;\n  struct HTTP *http = data->req.protop;\n  size_t sendsize;\n  curl_socket_t sockfd;\n  size_t headersize;\n\n  DEBUGASSERT(socketindex <= SECONDARYSOCKET);\n\n  sockfd = conn->sock[socketindex];\n\n  /* The looping below is required since we use non-blocking sockets, but due\n     to the circumstances we will just loop and try again and again etc */\n\n  ptr = Curl_dyn_ptr(in);\n  size = Curl_dyn_len(in);\n\n  headersize = size - included_body_bytes; /* the initial part that isn't body\n                                              is header */\n\n  DEBUGASSERT(size > included_body_bytes);\n\n  result = Curl_convert_to_network(data, ptr, headersize);\n  /* Curl_convert_to_network calls failf if unsuccessful */\n  if(result) {\n    /* conversion failed, free memory and return to the caller */\n    Curl_dyn_free(in);\n    return result;\n  }\n\n  if((conn->handler->flags & PROTOPT_SSL\n#ifndef CURL_DISABLE_PROXY\n      || conn->http_proxy.proxytype == CURLPROXY_HTTPS\n#endif\n       )\n     && conn->httpversion != 20) {\n    /* We never send more than CURL_MAX_WRITE_SIZE bytes in one single chunk\n       when we speak HTTPS, as if only a fraction of it is sent now, this data\n       needs to fit into the normal read-callback buffer later on and that\n       buffer is using this size.\n    */\n\n    sendsize = CURLMIN(size, CURL_MAX_WRITE_SIZE);\n\n    /* OpenSSL is very picky and we must send the SAME buffer pointer to the\n       library when we attempt to re-send this buffer. Sending the same data\n       is not enough, we must use the exact same address. For this reason, we\n       must copy the data to the uploadbuffer first, since that is the buffer\n       we will be using if this send is retried later.\n    */\n    result = Curl_get_upload_buffer(data);\n    if(result) {\n      /* malloc failed, free memory and return to the caller */\n      Curl_dyn_free(in);\n      return result;\n    }\n    memcpy(data->state.ulbuf, ptr, sendsize);\n    ptr = data->state.ulbuf;\n  }\n  else {\n#ifdef CURLDEBUG\n    /* Allow debug builds override this logic to force short initial sends */\n    char *p = getenv(\"CURL_SMALLREQSEND\");\n    if(p) {\n      size_t altsize = (size_t)strtoul(p, NULL, 10);\n      if(altsize)\n        sendsize = CURLMIN(size, altsize);\n      else\n        sendsize = size;\n    }\n    else\n#endif\n    sendsize = size;\n  }\n\n  result = Curl_write(conn, sockfd, ptr, sendsize, &amount);\n\n  if(!result) {\n    /*\n     * Note that we may not send the entire chunk at once, and we have a set\n     * number of data bytes at the end of the big buffer (out of which we may\n     * only send away a part).\n     */\n    /* how much of the header that was sent */\n    size_t headlen = (size_t)amount>headersize ? headersize : (size_t)amount;\n    size_t bodylen = amount - headlen;\n\n    if(data->set.verbose) {\n      /* this data _may_ contain binary stuff */\n      Curl_debug(data, CURLINFO_HEADER_OUT, ptr, headlen);\n      if(bodylen) {\n        /* there was body data sent beyond the initial header part, pass that\n           on to the debug callback too */\n        Curl_debug(data, CURLINFO_DATA_OUT,\n                   ptr + headlen, bodylen);\n      }\n    }\n\n    /* 'amount' can never be a very large value here so typecasting it so a\n       signed 31 bit value should not cause problems even if ssize_t is\n       64bit */\n    *bytes_written += (long)amount;\n\n    if(http) {\n      /* if we sent a piece of the body here, up the byte counter for it\n         accordingly */\n      data->req.writebytecount += bodylen;\n      Curl_pgrsSetUploadCounter(data, data->req.writebytecount);\n\n      if((size_t)amount != size) {\n        /* The whole request could not be sent in one system call. We must\n           queue it up and send it later when we get the chance. We must not\n           loop here and wait until it might work again. */\n\n        size -= amount;\n\n        ptr = Curl_dyn_ptr(in) + amount;\n\n        /* backup the currently set pointers */\n        http->backup.fread_func = data->state.fread_func;\n        http->backup.fread_in = data->state.in;\n        http->backup.postdata = http->postdata;\n        http->backup.postsize = http->postsize;\n\n        /* set the new pointers for the request-sending */\n        data->state.fread_func = (curl_read_callback)readmoredata;\n        data->state.in = (void *)conn;\n        http->postdata = ptr;\n        http->postsize = (curl_off_t)size;\n\n        http->send_buffer = *in; /* copy the whole struct */\n        http->sending = HTTPSEND_REQUEST;\n\n        return CURLE_OK;\n      }\n      http->sending = HTTPSEND_BODY;\n      /* the full buffer was sent, clean up and return */\n    }\n    else {\n      if((size_t)amount != size)\n        /* We have no continue-send mechanism now, fail. This can only happen\n           when this function is used from the CONNECT sending function. We\n           currently (stupidly) assume that the whole request is always sent\n           away in the first single chunk.\n\n           This needs FIXing.\n        */\n        return CURLE_SEND_ERROR;\n    }\n  }\n  Curl_dyn_free(in);\n\n  return result;\n}\n\n/* end of the add_buffer functions */\n/* ------------------------------------------------------------------------- */\n\n\n\n/*\n * Curl_compareheader()\n *\n * Returns TRUE if 'headerline' contains the 'header' with given 'content'.\n * Pass headers WITH the colon.\n */\nbool\nCurl_compareheader(const char *headerline, /* line to check */\n                   const char *header,  /* header keyword _with_ colon */\n                   const char *content) /* content string to find */\n{\n  /* RFC2616, section 4.2 says: \"Each header field consists of a name followed\n   * by a colon (\":\") and the field value. Field names are case-insensitive.\n   * The field value MAY be preceded by any amount of LWS, though a single SP\n   * is preferred.\" */\n\n  size_t hlen = strlen(header);\n  size_t clen;\n  size_t len;\n  const char *start;\n  const char *end;\n\n  if(!strncasecompare(headerline, header, hlen))\n    return FALSE; /* doesn't start with header */\n\n  /* pass the header */\n  start = &headerline[hlen];\n\n  /* pass all white spaces */\n  while(*start && ISSPACE(*start))\n    start++;\n\n  /* find the end of the header line */\n  end = strchr(start, '\\r'); /* lines end with CRLF */\n  if(!end) {\n    /* in case there's a non-standard compliant line here */\n    end = strchr(start, '\\n');\n\n    if(!end)\n      /* hm, there's no line ending here, use the zero byte! */\n      end = strchr(start, '\\0');\n  }\n\n  len = end-start; /* length of the content part of the input line */\n  clen = strlen(content); /* length of the word to find */\n\n  /* find the content string in the rest of the line */\n  for(; len >= clen; len--, start++) {\n    if(strncasecompare(start, content, clen))\n      return TRUE; /* match! */\n  }\n\n  return FALSE; /* no match */\n}\n\n/*\n * Curl_http_connect() performs HTTP stuff to do at connect-time, called from\n * the generic Curl_connect().\n */\nCURLcode Curl_http_connect(struct connectdata *conn, bool *done)\n{\n  CURLcode result;\n\n  /* We default to persistent connections. We set this already in this connect\n     function to make the re-use checks properly be able to check this bit. */\n  connkeep(conn, \"HTTP default\");\n\n#ifndef CURL_DISABLE_PROXY\n  /* the CONNECT procedure might not have been completed */\n  result = Curl_proxy_connect(conn, FIRSTSOCKET);\n  if(result)\n    return result;\n\n  if(conn->bits.proxy_connect_closed)\n    /* this is not an error, just part of the connection negotiation */\n    return CURLE_OK;\n\n  if(CONNECT_FIRSTSOCKET_PROXY_SSL())\n    return CURLE_OK; /* wait for HTTPS proxy SSL initialization to complete */\n\n  if(Curl_connect_ongoing(conn))\n    /* nothing else to do except wait right now - we're not done here. */\n    return CURLE_OK;\n\n  if(conn->data->set.haproxyprotocol) {\n    /* add HAProxy PROXY protocol header */\n    result = add_haproxy_protocol_header(conn);\n    if(result)\n      return result;\n  }\n#endif\n\n  if(conn->given->protocol & CURLPROTO_HTTPS) {\n    /* perform SSL initialization */\n    result = https_connecting(conn, done);\n    if(result)\n      return result;\n  }\n  else\n    *done = TRUE;\n\n  return CURLE_OK;\n}\n\n/* this returns the socket to wait for in the DO and DOING state for the multi\n   interface and then we're always _sending_ a request and thus we wait for\n   the single socket to become writable only */\nstatic int http_getsock_do(struct connectdata *conn,\n                           curl_socket_t *socks)\n{\n  /* write mode */\n  socks[0] = conn->sock[FIRSTSOCKET];\n  return GETSOCK_WRITESOCK(0);\n}\n\n#ifndef CURL_DISABLE_PROXY\nstatic CURLcode add_haproxy_protocol_header(struct connectdata *conn)\n{\n  char proxy_header[128];\n  struct dynbuf req;\n  CURLcode result;\n  char tcp_version[5];\n\n  /* Emit the correct prefix for IPv6 */\n  if(conn->bits.ipv6) {\n    strcpy(tcp_version, \"TCP6\");\n  }\n  else {\n    strcpy(tcp_version, \"TCP4\");\n  }\n\n  msnprintf(proxy_header,\n            sizeof(proxy_header),\n            \"PROXY %s %s %s %li %li\\r\\n\",\n            tcp_version,\n            conn->data->info.conn_local_ip,\n            conn->data->info.conn_primary_ip,\n            conn->data->info.conn_local_port,\n            conn->data->info.conn_primary_port);\n\n  Curl_dyn_init(&req, DYN_HAXPROXY);\n\n  result = Curl_dyn_add(&req, proxy_header);\n  if(result)\n    return result;\n\n  result = Curl_buffer_send(&req, conn, &conn->data->info.request_size,\n                            0, FIRSTSOCKET);\n\n  return result;\n}\n#endif\n\n#ifdef USE_SSL\nstatic CURLcode https_connecting(struct connectdata *conn, bool *done)\n{\n  CURLcode result;\n  DEBUGASSERT((conn) && (conn->handler->flags & PROTOPT_SSL));\n\n#ifdef ENABLE_QUIC\n  if(conn->transport == TRNSPRT_QUIC) {\n    *done = TRUE;\n    return CURLE_OK;\n  }\n#endif\n\n  /* perform SSL initialization for this socket */\n  result = Curl_ssl_connect_nonblocking(conn, FIRSTSOCKET, done);\n  if(result)\n    connclose(conn, \"Failed HTTPS connection\");\n\n  return result;\n}\n\nstatic int https_getsock(struct connectdata *conn,\n                         curl_socket_t *socks)\n{\n  if(conn->handler->flags & PROTOPT_SSL)\n    return Curl_ssl_getsock(conn, socks);\n  return GETSOCK_BLANK;\n}\n#endif /* USE_SSL */\n\n/*\n * Curl_http_done() gets called after a single HTTP request has been\n * performed.\n */\n\nCURLcode Curl_http_done(struct connectdata *conn,\n                        CURLcode status, bool premature)\n{\n  struct Curl_easy *data = conn->data;\n  struct HTTP *http = data->req.protop;\n\n  /* Clear multipass flag. If authentication isn't done yet, then it will get\n   * a chance to be set back to true when we output the next auth header */\n  data->state.authhost.multipass = FALSE;\n  data->state.authproxy.multipass = FALSE;\n\n  Curl_unencode_cleanup(conn);\n\n  /* set the proper values (possibly modified on POST) */\n  conn->seek_func = data->set.seek_func; /* restore */\n  conn->seek_client = data->set.seek_client; /* restore */\n\n  if(!http)\n    return CURLE_OK;\n\n  Curl_dyn_free(&http->send_buffer);\n  Curl_http2_done(data, premature);\n  Curl_quic_done(data, premature);\n  Curl_mime_cleanpart(&http->form);\n  Curl_dyn_reset(&data->state.headerb);\n\n  if(status)\n    return status;\n\n  if(!premature && /* this check is pointless when DONE is called before the\n                      entire operation is complete */\n     !conn->bits.retry &&\n     !data->set.connect_only &&\n     (data->req.bytecount +\n      data->req.headerbytecount -\n      data->req.deductheadercount) <= 0) {\n    /* If this connection isn't simply closed to be retried, AND nothing was\n       read from the HTTP server (that counts), this can't be right so we\n       return an error here */\n    failf(data, \"Empty reply from server\");\n    return CURLE_GOT_NOTHING;\n  }\n\n  return CURLE_OK;\n}\n\n/*\n * Determine if we should use HTTP 1.1 (OR BETTER) for this request. Reasons\n * to avoid it include:\n *\n * - if the user specifically requested HTTP 1.0\n * - if the server we are connected to only supports 1.0\n * - if any server previously contacted to handle this request only supports\n * 1.0.\n */\nstatic bool use_http_1_1plus(const struct Curl_easy *data,\n                             const struct connectdata *conn)\n{\n  if((data->state.httpversion == 10) || (conn->httpversion == 10))\n    return FALSE;\n  if((data->set.httpversion == CURL_HTTP_VERSION_1_0) &&\n     (conn->httpversion <= 10))\n    return FALSE;\n  return ((data->set.httpversion == CURL_HTTP_VERSION_NONE) ||\n          (data->set.httpversion >= CURL_HTTP_VERSION_1_1));\n}\n\nstatic const char *get_http_string(const struct Curl_easy *data,\n                                   const struct connectdata *conn)\n{\n#ifdef ENABLE_QUIC\n  if((data->set.httpversion == CURL_HTTP_VERSION_3) ||\n     (conn->httpversion == 30))\n    return \"3\";\n#endif\n\n#ifdef USE_NGHTTP2\n  if(conn->proto.httpc.h2)\n    return \"2\";\n#endif\n\n  if(use_http_1_1plus(data, conn))\n    return \"1.1\";\n\n  return \"1.0\";\n}\n\n/* check and possibly add an Expect: header */\nstatic CURLcode expect100(struct Curl_easy *data,\n                          struct connectdata *conn,\n                          struct dynbuf *req)\n{\n  CURLcode result = CURLE_OK;\n  data->state.expect100header = FALSE; /* default to false unless it is set\n                                          to TRUE below */\n  if(!data->state.disableexpect && use_http_1_1plus(data, conn) &&\n     (conn->httpversion < 20)) {\n    /* if not doing HTTP 1.0 or version 2, or disabled explicitly, we add an\n       Expect: 100-continue to the headers which actually speeds up post\n       operations (as there is one packet coming back from the web server) */\n    const char *ptr = Curl_checkheaders(conn, \"Expect\");\n    if(ptr) {\n      data->state.expect100header =\n        Curl_compareheader(ptr, \"Expect:\", \"100-continue\");\n    }\n    else {\n      result = Curl_dyn_add(req, \"Expect: 100-continue\\r\\n\");\n      if(!result)\n        data->state.expect100header = TRUE;\n    }\n  }\n\n  return result;\n}\n\nenum proxy_use {\n  HEADER_SERVER,  /* direct to server */\n  HEADER_PROXY,   /* regular request to proxy */\n  HEADER_CONNECT  /* sending CONNECT to a proxy */\n};\n\n/* used to compile the provided trailers into one buffer\n   will return an error code if one of the headers is\n   not formatted correctly */\nCURLcode Curl_http_compile_trailers(struct curl_slist *trailers,\n                                    struct dynbuf *b,\n                                    struct Curl_easy *handle)\n{\n  char *ptr = NULL;\n  CURLcode result = CURLE_OK;\n  const char *endofline_native = NULL;\n  const char *endofline_network = NULL;\n\n  if(\n#ifdef CURL_DO_LINEEND_CONV\n     (handle->set.prefer_ascii) ||\n#endif\n     (handle->set.crlf)) {\n    /* \\n will become \\r\\n later on */\n    endofline_native  = \"\\n\";\n    endofline_network = \"\\x0a\";\n  }\n  else {\n    endofline_native  = \"\\r\\n\";\n    endofline_network = \"\\x0d\\x0a\";\n  }\n\n  while(trailers) {\n    /* only add correctly formatted trailers */\n    ptr = strchr(trailers->data, ':');\n    if(ptr && *(ptr + 1) == ' ') {\n      result = Curl_dyn_add(b, trailers->data);\n      if(result)\n        return result;\n      result = Curl_dyn_add(b, endofline_native);\n      if(result)\n        return result;\n    }\n    else\n      infof(handle, \"Malformatted trailing header ! Skipping trailer.\");\n    trailers = trailers->next;\n  }\n  result = Curl_dyn_add(b, endofline_network);\n  return result;\n}\n\nCURLcode Curl_add_custom_headers(struct connectdata *conn,\n                                 bool is_connect,\n                                 struct dynbuf *req)\n{\n  char *ptr;\n  struct curl_slist *h[2];\n  struct curl_slist *headers;\n  int numlists = 1; /* by default */\n  struct Curl_easy *data = conn->data;\n  int i;\n\n#ifndef CURL_DISABLE_PROXY\n  enum proxy_use proxy;\n\n  if(is_connect)\n    proxy = HEADER_CONNECT;\n  else\n    proxy = conn->bits.httpproxy && !conn->bits.tunnel_proxy?\n      HEADER_PROXY:HEADER_SERVER;\n\n  switch(proxy) {\n  case HEADER_SERVER:\n    h[0] = data->set.headers;\n    break;\n  case HEADER_PROXY:\n    h[0] = data->set.headers;\n    if(data->set.sep_headers) {\n      h[1] = data->set.proxyheaders;\n      numlists++;\n    }\n    break;\n  case HEADER_CONNECT:\n    if(data->set.sep_headers)\n      h[0] = data->set.proxyheaders;\n    else\n      h[0] = data->set.headers;\n    break;\n  }\n#else\n  (void)is_connect;\n  h[0] = data->set.headers;\n#endif\n\n  /* loop through one or two lists */\n  for(i = 0; i < numlists; i++) {\n    headers = h[i];\n\n    while(headers) {\n      char *semicolonp = NULL;\n      ptr = strchr(headers->data, ':');\n      if(!ptr) {\n        char *optr;\n        /* no colon, semicolon? */\n        ptr = strchr(headers->data, ';');\n        if(ptr) {\n          optr = ptr;\n          ptr++; /* pass the semicolon */\n          while(*ptr && ISSPACE(*ptr))\n            ptr++;\n\n          if(*ptr) {\n            /* this may be used for something else in the future */\n            optr = NULL;\n          }\n          else {\n            if(*(--ptr) == ';') {\n              /* copy the source */\n              semicolonp = strdup(headers->data);\n              if(!semicolonp) {\n                Curl_dyn_free(req);\n                return CURLE_OUT_OF_MEMORY;\n              }\n              /* put a colon where the semicolon is */\n              semicolonp[ptr - headers->data] = ':';\n              /* point at the colon */\n              optr = &semicolonp [ptr - headers->data];\n            }\n          }\n          ptr = optr;\n        }\n      }\n      if(ptr) {\n        /* we require a colon for this to be a true header */\n\n        ptr++; /* pass the colon */\n        while(*ptr && ISSPACE(*ptr))\n          ptr++;\n\n        if(*ptr || semicolonp) {\n          /* only send this if the contents was non-blank or done special */\n          CURLcode result = CURLE_OK;\n          char *compare = semicolonp ? semicolonp : headers->data;\n\n          if(data->state.aptr.host &&\n             /* a Host: header was sent already, don't pass on any custom Host:\n                header as that will produce *two* in the same request! */\n             checkprefix(\"Host:\", compare))\n            ;\n          else if(data->state.httpreq == HTTPREQ_POST_FORM &&\n                  /* this header (extended by formdata.c) is sent later */\n                  checkprefix(\"Content-Type:\", compare))\n            ;\n          else if(data->state.httpreq == HTTPREQ_POST_MIME &&\n                  /* this header is sent later */\n                  checkprefix(\"Content-Type:\", compare))\n            ;\n          else if(conn->bits.authneg &&\n                  /* while doing auth neg, don't allow the custom length since\n                     we will force length zero then */\n                  checkprefix(\"Content-Length:\", compare))\n            ;\n          else if(data->state.aptr.te &&\n                  /* when asking for Transfer-Encoding, don't pass on a custom\n                     Connection: */\n                  checkprefix(\"Connection:\", compare))\n            ;\n          else if((conn->httpversion >= 20) &&\n                  checkprefix(\"Transfer-Encoding:\", compare))\n            /* HTTP/2 doesn't support chunked requests */\n            ;\n          else if((checkprefix(\"Authorization:\", compare) ||\n                   checkprefix(\"Cookie:\", compare)) &&\n                  /* be careful of sending this potentially sensitive header to\n                     other hosts */\n                  (data->state.this_is_a_follow &&\n                   data->state.first_host &&\n                   !data->set.allow_auth_to_other_hosts &&\n                   !strcasecompare(data->state.first_host, conn->host.name)))\n            ;\n          else {\n            result = Curl_dyn_addf(req, \"%s\\r\\n\", compare);\n          }\n          if(semicolonp)\n            free(semicolonp);\n          if(result)\n            return result;\n        }\n      }\n      headers = headers->next;\n    }\n  }\n\n  return CURLE_OK;\n}\n\n#ifndef CURL_DISABLE_PARSEDATE\nCURLcode Curl_add_timecondition(const struct connectdata *conn,\n                                struct dynbuf *req)\n{\n  struct Curl_easy *data = conn->data;\n  const struct tm *tm;\n  struct tm keeptime;\n  CURLcode result;\n  char datestr[80];\n  const char *condp;\n\n  if(data->set.timecondition == CURL_TIMECOND_NONE)\n    /* no condition was asked for */\n    return CURLE_OK;\n\n  result = Curl_gmtime(data->set.timevalue, &keeptime);\n  if(result) {\n    failf(data, \"Invalid TIMEVALUE\");\n    return result;\n  }\n  tm = &keeptime;\n\n  switch(data->set.timecondition) {\n  default:\n    return CURLE_BAD_FUNCTION_ARGUMENT;\n\n  case CURL_TIMECOND_IFMODSINCE:\n    condp = \"If-Modified-Since\";\n    break;\n  case CURL_TIMECOND_IFUNMODSINCE:\n    condp = \"If-Unmodified-Since\";\n    break;\n  case CURL_TIMECOND_LASTMOD:\n    condp = \"Last-Modified\";\n    break;\n  }\n\n  if(Curl_checkheaders(conn, condp)) {\n    /* A custom header was specified; it will be sent instead. */\n    return CURLE_OK;\n  }\n\n  /* The If-Modified-Since header family should have their times set in\n   * GMT as RFC2616 defines: \"All HTTP date/time stamps MUST be\n   * represented in Greenwich Mean Time (GMT), without exception. For the\n   * purposes of HTTP, GMT is exactly equal to UTC (Coordinated Universal\n   * Time).\" (see page 20 of RFC2616).\n   */\n\n  /* format: \"Tue, 15 Nov 1994 12:45:26 GMT\" */\n  msnprintf(datestr, sizeof(datestr),\n            \"%s: %s, %02d %s %4d %02d:%02d:%02d GMT\\r\\n\",\n            condp,\n            Curl_wkday[tm->tm_wday?tm->tm_wday-1:6],\n            tm->tm_mday,\n            Curl_month[tm->tm_mon],\n            tm->tm_year + 1900,\n            tm->tm_hour,\n            tm->tm_min,\n            tm->tm_sec);\n\n  result = Curl_dyn_add(req, datestr);\n\n  return result;\n}\n#else\n/* disabled */\nCURLcode Curl_add_timecondition(const struct connectdata *conn,\n                                struct dynbuf *req)\n{\n  (void)conn;\n  (void)req;\n  return CURLE_OK;\n}\n#endif\n\n/*\n * Curl_http() gets called from the generic multi_do() function when a HTTP\n * request is to be performed. This creates and sends a properly constructed\n * HTTP request.\n */\nCURLcode Curl_http(struct connectdata *conn, bool *done)\n{\n  struct Curl_easy *data = conn->data;\n  CURLcode result = CURLE_OK;\n  struct HTTP *http;\n  const char *path = data->state.up.path;\n  const char *query = data->state.up.query;\n  bool paste_ftp_userpwd = FALSE;\n  char ftp_typecode[sizeof(\"/;type=?\")] = \"\";\n  const char *host = conn->host.name;\n  const char *te = \"\"; /* transfer-encoding */\n  const char *ptr;\n  const char *request;\n  Curl_HttpReq httpreq = data->state.httpreq;\n#if !defined(CURL_DISABLE_COOKIES)\n  char *addcookies = NULL;\n#endif\n  curl_off_t included_body = 0;\n  const char *httpstring;\n  struct dynbuf req;\n  curl_off_t postsize = 0; /* curl_off_t to handle large file sizes */\n  char *altused = NULL;\n\n  /* Always consider the DO phase done after this function call, even if there\n     may be parts of the request that is not yet sent, since we can deal with\n     the rest of the request in the PERFORM phase. */\n  *done = TRUE;\n\n  if(conn->transport != TRNSPRT_QUIC) {\n    if(conn->httpversion < 20) { /* unless the connection is re-used and\n                                    already http2 */\n      switch(conn->negnpn) {\n      case CURL_HTTP_VERSION_2:\n        conn->httpversion = 20; /* we know we're on HTTP/2 now */\n\n        result = Curl_http2_switched(conn, NULL, 0);\n        if(result)\n          return result;\n        break;\n      case CURL_HTTP_VERSION_1_1:\n        /* continue with HTTP/1.1 when explicitly requested */\n        break;\n      default:\n        /* Check if user wants to use HTTP/2 with clear TCP*/\n#ifdef USE_NGHTTP2\n        if(conn->data->set.httpversion ==\n           CURL_HTTP_VERSION_2_PRIOR_KNOWLEDGE) {\n#ifndef CURL_DISABLE_PROXY\n          if(conn->bits.httpproxy && !conn->bits.tunnel_proxy) {\n            /* We don't support HTTP/2 proxies yet. Also it's debatable\n               whether or not this setting should apply to HTTP/2 proxies. */\n            infof(data, \"Ignoring HTTP/2 prior knowledge due to proxy\\n\");\n            break;\n          }\n#endif\n          DEBUGF(infof(data, \"HTTP/2 over clean TCP\\n\"));\n          conn->httpversion = 20;\n\n          result = Curl_http2_switched(conn, NULL, 0);\n          if(result)\n            return result;\n        }\n#endif\n        break;\n      }\n    }\n    else {\n      /* prepare for a http2 request */\n      result = Curl_http2_setup(conn);\n      if(result)\n        return result;\n    }\n  }\n  http = data->req.protop;\n  DEBUGASSERT(http);\n\n  if(!data->state.this_is_a_follow) {\n    /* Free to avoid leaking memory on multiple requests*/\n    free(data->state.first_host);\n\n    data->state.first_host = strdup(conn->host.name);\n    if(!data->state.first_host)\n      return CURLE_OUT_OF_MEMORY;\n\n    data->state.first_remote_port = conn->remote_port;\n  }\n\n  if((conn->handler->protocol&(PROTO_FAMILY_HTTP|CURLPROTO_FTP)) &&\n     data->set.upload) {\n    httpreq = HTTPREQ_PUT;\n  }\n\n  /* Now set the 'request' pointer to the proper request string */\n  if(data->set.str[STRING_CUSTOMREQUEST])\n    request = data->set.str[STRING_CUSTOMREQUEST];\n  else {\n    if(data->set.opt_no_body)\n      request = \"HEAD\";\n    else {\n      DEBUGASSERT((httpreq > HTTPREQ_NONE) && (httpreq < HTTPREQ_LAST));\n      switch(httpreq) {\n      case HTTPREQ_POST:\n      case HTTPREQ_POST_FORM:\n      case HTTPREQ_POST_MIME:\n        request = \"POST\";\n        break;\n      case HTTPREQ_PUT:\n        request = \"PUT\";\n        break;\n      default: /* this should never happen */\n      case HTTPREQ_GET:\n        request = \"GET\";\n        break;\n      case HTTPREQ_HEAD:\n        request = \"HEAD\";\n        break;\n      }\n    }\n  }\n\n  /* The User-Agent string might have been allocated in url.c already, because\n     it might have been used in the proxy connect, but if we have got a header\n     with the user-agent string specified, we erase the previously made string\n     here. */\n  if(Curl_checkheaders(conn, \"User-Agent\")) {\n    free(data->state.aptr.uagent);\n    data->state.aptr.uagent = NULL;\n  }\n\n  /* setup the authentication headers */\n  {\n    char *pq = NULL;\n    if(query && *query) {\n      pq = aprintf(\"%s?%s\", path, query);\n      if(!pq)\n        return CURLE_OUT_OF_MEMORY;\n    }\n    result = Curl_http_output_auth(conn, request, (pq ? pq : path), FALSE);\n    free(pq);\n    if(result)\n      return result;\n  }\n\n  if(((data->state.authhost.multipass && !data->state.authhost.done)\n      || (data->state.authproxy.multipass && !data->state.authproxy.done)) &&\n     (httpreq != HTTPREQ_GET) &&\n     (httpreq != HTTPREQ_HEAD)) {\n    /* Auth is required and we are not authenticated yet. Make a PUT or POST\n       with content-length zero as a \"probe\". */\n    conn->bits.authneg = TRUE;\n  }\n  else\n    conn->bits.authneg = FALSE;\n\n  Curl_safefree(data->state.aptr.ref);\n  if(data->change.referer && !Curl_checkheaders(conn, \"Referer\")) {\n    data->state.aptr.ref = aprintf(\"Referer: %s\\r\\n\", data->change.referer);\n    if(!data->state.aptr.ref)\n      return CURLE_OUT_OF_MEMORY;\n  }\n  else\n    data->state.aptr.ref = NULL;\n\n#if !defined(CURL_DISABLE_COOKIES)\n  if(data->set.str[STRING_COOKIE] && !Curl_checkheaders(conn, \"Cookie\"))\n    addcookies = data->set.str[STRING_COOKIE];\n#endif\n\n  if(!Curl_checkheaders(conn, \"Accept-Encoding\") &&\n     data->set.str[STRING_ENCODING]) {\n    Curl_safefree(data->state.aptr.accept_encoding);\n    data->state.aptr.accept_encoding =\n      aprintf(\"Accept-Encoding: %s\\r\\n\", data->set.str[STRING_ENCODING]);\n    if(!data->state.aptr.accept_encoding)\n      return CURLE_OUT_OF_MEMORY;\n  }\n  else {\n    Curl_safefree(data->state.aptr.accept_encoding);\n    data->state.aptr.accept_encoding = NULL;\n  }\n\n#ifdef HAVE_LIBZ\n  /* we only consider transfer-encoding magic if libz support is built-in */\n\n  if(!Curl_checkheaders(conn, \"TE\") &&\n     data->set.http_transfer_encoding) {\n    /* When we are to insert a TE: header in the request, we must also insert\n       TE in a Connection: header, so we need to merge the custom provided\n       Connection: header and prevent the original to get sent. Note that if\n       the user has inserted his/hers own TE: header we don't do this magic\n       but then assume that the user will handle it all! */\n    char *cptr = Curl_checkheaders(conn, \"Connection\");\n#define TE_HEADER \"TE: gzip\\r\\n\"\n\n    Curl_safefree(data->state.aptr.te);\n\n    if(cptr) {\n      cptr = Curl_copy_header_value(cptr);\n      if(!cptr)\n        return CURLE_OUT_OF_MEMORY;\n    }\n\n    /* Create the (updated) Connection: header */\n    data->state.aptr.te = aprintf(\"Connection: %s%sTE\\r\\n\" TE_HEADER,\n                                cptr ? cptr : \"\", (cptr && *cptr) ? \", \":\"\");\n\n    free(cptr);\n    if(!data->state.aptr.te)\n      return CURLE_OUT_OF_MEMORY;\n  }\n#endif\n\n  switch(httpreq) {\n  case HTTPREQ_POST_MIME:\n    http->sendit = &data->set.mimepost;\n    break;\n  case HTTPREQ_POST_FORM:\n    /* Convert the form structure into a mime structure. */\n    Curl_mime_cleanpart(&http->form);\n    result = Curl_getformdata(data, &http->form, data->set.httppost,\n                              data->state.fread_func);\n    if(result)\n      return result;\n    http->sendit = &http->form;\n    break;\n  default:\n    http->sendit = NULL;\n  }\n\n#ifndef CURL_DISABLE_MIME\n  if(http->sendit) {\n    const char *cthdr = Curl_checkheaders(conn, \"Content-Type\");\n\n    /* Read and seek body only. */\n    http->sendit->flags |= MIME_BODY_ONLY;\n\n    /* Prepare the mime structure headers & set content type. */\n\n    if(cthdr)\n      for(cthdr += 13; *cthdr == ' '; cthdr++)\n        ;\n    else if(http->sendit->kind == MIMEKIND_MULTIPART)\n      cthdr = \"multipart/form-data\";\n\n    curl_mime_headers(http->sendit, data->set.headers, 0);\n    result = Curl_mime_prepare_headers(http->sendit, cthdr,\n                                       NULL, MIMESTRATEGY_FORM);\n    curl_mime_headers(http->sendit, NULL, 0);\n    if(!result)\n      result = Curl_mime_rewind(http->sendit);\n    if(result)\n      return result;\n    http->postsize = Curl_mime_size(http->sendit);\n  }\n#endif\n\n  ptr = Curl_checkheaders(conn, \"Transfer-Encoding\");\n  if(ptr) {\n    /* Some kind of TE is requested, check if 'chunked' is chosen */\n    data->req.upload_chunky =\n      Curl_compareheader(ptr, \"Transfer-Encoding:\", \"chunked\");\n  }\n  else {\n    if((conn->handler->protocol & PROTO_FAMILY_HTTP) &&\n       (((httpreq == HTTPREQ_POST_MIME || httpreq == HTTPREQ_POST_FORM) &&\n         http->postsize < 0) ||\n        ((data->set.upload || httpreq == HTTPREQ_POST) &&\n         data->state.infilesize == -1))) {\n      if(conn->bits.authneg)\n        /* don't enable chunked during auth neg */\n        ;\n      else if(use_http_1_1plus(data, conn)) {\n        if(conn->httpversion < 20)\n          /* HTTP, upload, unknown file size and not HTTP 1.0 */\n          data->req.upload_chunky = TRUE;\n      }\n      else {\n        failf(data, \"Chunky upload is not supported by HTTP 1.0\");\n        return CURLE_UPLOAD_FAILED;\n      }\n    }\n    else {\n      /* else, no chunky upload */\n      data->req.upload_chunky = FALSE;\n    }\n\n    if(data->req.upload_chunky)\n      te = \"Transfer-Encoding: chunked\\r\\n\";\n  }\n\n  Curl_safefree(data->state.aptr.host);\n\n  ptr = Curl_checkheaders(conn, \"Host\");\n  if(ptr && (!data->state.this_is_a_follow ||\n             strcasecompare(data->state.first_host, conn->host.name))) {\n#if !defined(CURL_DISABLE_COOKIES)\n    /* If we have a given custom Host: header, we extract the host name in\n       order to possibly use it for cookie reasons later on. We only allow the\n       custom Host: header if this is NOT a redirect, as setting Host: in the\n       redirected request is being out on thin ice. Except if the host name\n       is the same as the first one! */\n    char *cookiehost = Curl_copy_header_value(ptr);\n    if(!cookiehost)\n      return CURLE_OUT_OF_MEMORY;\n    if(!*cookiehost)\n      /* ignore empty data */\n      free(cookiehost);\n    else {\n      /* If the host begins with '[', we start searching for the port after\n         the bracket has been closed */\n      if(*cookiehost == '[') {\n        char *closingbracket;\n        /* since the 'cookiehost' is an allocated memory area that will be\n           freed later we cannot simply increment the pointer */\n        memmove(cookiehost, cookiehost + 1, strlen(cookiehost) - 1);\n        closingbracket = strchr(cookiehost, ']');\n        if(closingbracket)\n          *closingbracket = 0;\n      }\n      else {\n        int startsearch = 0;\n        char *colon = strchr(cookiehost + startsearch, ':');\n        if(colon)\n          *colon = 0; /* The host must not include an embedded port number */\n      }\n      Curl_safefree(data->state.aptr.cookiehost);\n      data->state.aptr.cookiehost = cookiehost;\n    }\n#endif\n\n    if(strcmp(\"Host:\", ptr)) {\n      data->state.aptr.host = aprintf(\"Host:%s\\r\\n\", &ptr[5]);\n      if(!data->state.aptr.host)\n        return CURLE_OUT_OF_MEMORY;\n    }\n    else\n      /* when clearing the header */\n      data->state.aptr.host = NULL;\n  }\n  else {\n    /* When building Host: headers, we must put the host name within\n       [brackets] if the host name is a plain IPv6-address. RFC2732-style. */\n\n    if(((conn->given->protocol&CURLPROTO_HTTPS) &&\n        (conn->remote_port == PORT_HTTPS)) ||\n       ((conn->given->protocol&CURLPROTO_HTTP) &&\n        (conn->remote_port == PORT_HTTP)) )\n      /* if(HTTPS on port 443) OR (HTTP on port 80) then don't include\n         the port number in the host string */\n      data->state.aptr.host = aprintf(\"Host: %s%s%s\\r\\n\",\n                                    conn->bits.ipv6_ip?\"[\":\"\",\n                                    host,\n                                    conn->bits.ipv6_ip?\"]\":\"\");\n    else\n      data->state.aptr.host = aprintf(\"Host: %s%s%s:%d\\r\\n\",\n                                    conn->bits.ipv6_ip?\"[\":\"\",\n                                    host,\n                                    conn->bits.ipv6_ip?\"]\":\"\",\n                                    conn->remote_port);\n\n    if(!data->state.aptr.host)\n      /* without Host: we can't make a nice request */\n      return CURLE_OUT_OF_MEMORY;\n  }\n\n#ifndef CURL_DISABLE_PROXY\n  if(conn->bits.httpproxy && !conn->bits.tunnel_proxy) {\n    /* Using a proxy but does not tunnel through it */\n\n    /* The path sent to the proxy is in fact the entire URL. But if the remote\n       host is a IDN-name, we must make sure that the request we produce only\n       uses the encoded host name! */\n\n    /* and no fragment part */\n    CURLUcode uc;\n    CURLU *h = curl_url_dup(data->state.uh);\n    if(!h)\n      return CURLE_OUT_OF_MEMORY;\n\n    if(conn->host.dispname != conn->host.name) {\n      uc = curl_url_set(h, CURLUPART_HOST, conn->host.name, 0);\n      if(uc) {\n        curl_url_cleanup(h);\n        return CURLE_OUT_OF_MEMORY;\n      }\n    }\n    uc = curl_url_set(h, CURLUPART_FRAGMENT, NULL, 0);\n    if(uc) {\n      curl_url_cleanup(h);\n      return CURLE_OUT_OF_MEMORY;\n    }\n\n    if(strcasecompare(\"http\", data->state.up.scheme)) {\n      /* when getting HTTP, we don't want the userinfo the URL */\n      uc = curl_url_set(h, CURLUPART_USER, NULL, 0);\n      if(uc) {\n        curl_url_cleanup(h);\n        return CURLE_OUT_OF_MEMORY;\n      }\n      uc = curl_url_set(h, CURLUPART_PASSWORD, NULL, 0);\n      if(uc) {\n        curl_url_cleanup(h);\n        return CURLE_OUT_OF_MEMORY;\n      }\n    }\n    /* Extract the URL to use in the request. Store in STRING_TEMP_URL for\n       clean-up reasons if the function returns before the free() further\n       down. */\n    uc = curl_url_get(h, CURLUPART_URL, &data->set.str[STRING_TEMP_URL], 0);\n    if(uc) {\n      curl_url_cleanup(h);\n      return CURLE_OUT_OF_MEMORY;\n    }\n\n    curl_url_cleanup(h);\n\n    if(strcasecompare(\"ftp\", data->state.up.scheme)) {\n      if(data->set.proxy_transfer_mode) {\n        /* when doing ftp, append ;type=<a|i> if not present */\n        char *type = strstr(path, \";type=\");\n        if(type && type[6] && type[7] == 0) {\n          switch(Curl_raw_toupper(type[6])) {\n          case 'A':\n          case 'D':\n          case 'I':\n            break;\n          default:\n            type = NULL;\n          }\n        }\n        if(!type) {\n          char *p = ftp_typecode;\n          /* avoid sending invalid URLs like ftp://example.com;type=i if the\n           * user specified ftp://example.com without the slash */\n          if(!*data->state.up.path && path[strlen(path) - 1] != '/') {\n            *p++ = '/';\n          }\n          msnprintf(p, sizeof(ftp_typecode) - 1, \";type=%c\",\n                    data->set.prefer_ascii ? 'a' : 'i');\n        }\n      }\n      if(conn->bits.user_passwd)\n        paste_ftp_userpwd = TRUE;\n    }\n  }\n#endif /* CURL_DISABLE_PROXY */\n\n  http->p_accept = Curl_checkheaders(conn, \"Accept\")?NULL:\"Accept: */*\\r\\n\";\n\n  if((HTTPREQ_POST == httpreq || HTTPREQ_PUT == httpreq) &&\n     data->state.resume_from) {\n    /**********************************************************************\n     * Resuming upload in HTTP means that we PUT or POST and that we have\n     * got a resume_from value set. The resume value has already created\n     * a Range: header that will be passed along. We need to \"fast forward\"\n     * the file the given number of bytes and decrease the assume upload\n     * file size before we continue this venture in the dark lands of HTTP.\n     * Resuming mime/form posting at an offset > 0 has no sense and is ignored.\n     *********************************************************************/\n\n    if(data->state.resume_from < 0) {\n      /*\n       * This is meant to get the size of the present remote-file by itself.\n       * We don't support this now. Bail out!\n       */\n      data->state.resume_from = 0;\n    }\n\n    if(data->state.resume_from && !data->state.this_is_a_follow) {\n      /* do we still game? */\n\n      /* Now, let's read off the proper amount of bytes from the\n         input. */\n      int seekerr = CURL_SEEKFUNC_CANTSEEK;\n      if(conn->seek_func) {\n        Curl_set_in_callback(data, true);\n        seekerr = conn->seek_func(conn->seek_client, data->state.resume_from,\n                                  SEEK_SET);\n        Curl_set_in_callback(data, false);\n      }\n\n      if(seekerr != CURL_SEEKFUNC_OK) {\n        curl_off_t passed = 0;\n\n        if(seekerr != CURL_SEEKFUNC_CANTSEEK) {\n          failf(data, \"Could not seek stream\");\n          return CURLE_READ_ERROR;\n        }\n        /* when seekerr == CURL_SEEKFUNC_CANTSEEK (can't seek to offset) */\n        do {\n          size_t readthisamountnow =\n            (data->state.resume_from - passed > data->set.buffer_size) ?\n            (size_t)data->set.buffer_size :\n            curlx_sotouz(data->state.resume_from - passed);\n\n          size_t actuallyread =\n            data->state.fread_func(data->state.buffer, 1, readthisamountnow,\n                                   data->state.in);\n\n          passed += actuallyread;\n          if((actuallyread == 0) || (actuallyread > readthisamountnow)) {\n            /* this checks for greater-than only to make sure that the\n               CURL_READFUNC_ABORT return code still aborts */\n            failf(data, \"Could only read %\" CURL_FORMAT_CURL_OFF_T\n                  \" bytes from the input\", passed);\n            return CURLE_READ_ERROR;\n          }\n        } while(passed < data->state.resume_from);\n      }\n\n      /* now, decrease the size of the read */\n      if(data->state.infilesize>0) {\n        data->state.infilesize -= data->state.resume_from;\n\n        if(data->state.infilesize <= 0) {\n          failf(data, \"File already completely uploaded\");\n          return CURLE_PARTIAL_FILE;\n        }\n      }\n      /* we've passed, proceed as normal */\n    }\n  }\n  if(data->state.use_range) {\n    /*\n     * A range is selected. We use different headers whether we're downloading\n     * or uploading and we always let customized headers override our internal\n     * ones if any such are specified.\n     */\n    if(((httpreq == HTTPREQ_GET) || (httpreq == HTTPREQ_HEAD)) &&\n       !Curl_checkheaders(conn, \"Range\")) {\n      /* if a line like this was already allocated, free the previous one */\n      free(data->state.aptr.rangeline);\n      data->state.aptr.rangeline = aprintf(\"Range: bytes=%s\\r\\n\",\n                                         data->state.range);\n    }\n    else if((httpreq == HTTPREQ_POST || httpreq == HTTPREQ_PUT) &&\n            !Curl_checkheaders(conn, \"Content-Range\")) {\n\n      /* if a line like this was already allocated, free the previous one */\n      free(data->state.aptr.rangeline);\n\n      if(data->set.set_resume_from < 0) {\n        /* Upload resume was asked for, but we don't know the size of the\n           remote part so we tell the server (and act accordingly) that we\n           upload the whole file (again) */\n        data->state.aptr.rangeline =\n          aprintf(\"Content-Range: bytes 0-%\" CURL_FORMAT_CURL_OFF_T\n                  \"/%\" CURL_FORMAT_CURL_OFF_T \"\\r\\n\",\n                  data->state.infilesize - 1, data->state.infilesize);\n\n      }\n      else if(data->state.resume_from) {\n        /* This is because \"resume\" was selected */\n        curl_off_t total_expected_size =\n          data->state.resume_from + data->state.infilesize;\n        data->state.aptr.rangeline =\n          aprintf(\"Content-Range: bytes %s%\" CURL_FORMAT_CURL_OFF_T\n                  \"/%\" CURL_FORMAT_CURL_OFF_T \"\\r\\n\",\n                  data->state.range, total_expected_size-1,\n                  total_expected_size);\n      }\n      else {\n        /* Range was selected and then we just pass the incoming range and\n           append total size */\n        data->state.aptr.rangeline =\n          aprintf(\"Content-Range: bytes %s/%\" CURL_FORMAT_CURL_OFF_T \"\\r\\n\",\n                  data->state.range, data->state.infilesize);\n      }\n      if(!data->state.aptr.rangeline)\n        return CURLE_OUT_OF_MEMORY;\n    }\n  }\n\n  httpstring = get_http_string(data, conn);\n\n  /* initialize a dynamic send-buffer */\n  Curl_dyn_init(&req, DYN_HTTP_REQUEST);\n\n  /* add the main request stuff */\n  /* GET/HEAD/POST/PUT */\n  result = Curl_dyn_addf(&req, \"%s \", request);\n  if(result)\n    return result;\n\n  if(data->set.str[STRING_TARGET]) {\n    path = data->set.str[STRING_TARGET];\n    query = NULL;\n  }\n\n#ifndef CURL_DISABLE_PROXY\n  /* url */\n  if(conn->bits.httpproxy && !conn->bits.tunnel_proxy) {\n    char *url = data->set.str[STRING_TEMP_URL];\n    result = Curl_dyn_add(&req, url);\n    Curl_safefree(data->set.str[STRING_TEMP_URL]);\n  }\n  else\n#endif\n  if(paste_ftp_userpwd)\n    result = Curl_dyn_addf(&req, \"ftp://%s:%s@%s\", conn->user, conn->passwd,\n                           path + sizeof(\"ftp://\") - 1);\n  else {\n    result = Curl_dyn_add(&req, path);\n    if(result)\n      return result;\n    if(query)\n      result = Curl_dyn_addf(&req, \"?%s\", query);\n  }\n  if(result)\n    return result;\n\n#ifdef USE_ALTSVC\n  if(conn->bits.altused && !Curl_checkheaders(conn, \"Alt-Used\")) {\n    altused = aprintf(\"Alt-Used: %s:%d\\r\\n\",\n                      conn->conn_to_host.name, conn->conn_to_port);\n    if(!altused) {\n      Curl_dyn_free(&req);\n      return CURLE_OUT_OF_MEMORY;\n    }\n  }\n#endif\n  result =\n    Curl_dyn_addf(&req,\n                  \"%s\" /* ftp typecode (;type=x) */\n                  \" HTTP/%s\\r\\n\" /* HTTP version */\n                  \"%s\" /* host */\n                  \"%s\" /* proxyuserpwd */\n                  \"%s\" /* userpwd */\n                  \"%s\" /* range */\n                  \"%s\" /* user agent */\n                  \"%s\" /* accept */\n                  \"%s\" /* TE: */\n                  \"%s\" /* accept-encoding */\n                  \"%s\" /* referer */\n                  \"%s\" /* Proxy-Connection */\n                  \"%s\" /* transfer-encoding */\n                  \"%s\",/* Alt-Used */\n\n                  ftp_typecode,\n                  httpstring,\n                  (data->state.aptr.host?data->state.aptr.host:\"\"),\n                  data->state.aptr.proxyuserpwd?\n                  data->state.aptr.proxyuserpwd:\"\",\n                  data->state.aptr.userpwd?data->state.aptr.userpwd:\"\",\n                  (data->state.use_range && data->state.aptr.rangeline)?\n                  data->state.aptr.rangeline:\"\",\n                  (data->set.str[STRING_USERAGENT] &&\n                   *data->set.str[STRING_USERAGENT] &&\n                   data->state.aptr.uagent)?\n                  data->state.aptr.uagent:\"\",\n                  http->p_accept?http->p_accept:\"\",\n                  data->state.aptr.te?data->state.aptr.te:\"\",\n                  (data->set.str[STRING_ENCODING] &&\n                   *data->set.str[STRING_ENCODING] &&\n                   data->state.aptr.accept_encoding)?\n                  data->state.aptr.accept_encoding:\"\",\n                  (data->change.referer && data->state.aptr.ref)?\n                  data->state.aptr.ref:\"\" /* Referer: <data> */,\n#ifndef CURL_DISABLE_PROXY\n                  (conn->bits.httpproxy &&\n                   !conn->bits.tunnel_proxy &&\n                   !Curl_checkProxyheaders(conn, \"Proxy-Connection\"))?\n                  \"Proxy-Connection: Keep-Alive\\r\\n\":\"\",\n#else\n                  \"\",\n#endif\n                  te,\n                  altused ? altused : \"\"\n      );\n\n  /* clear userpwd and proxyuserpwd to avoid re-using old credentials\n   * from re-used connections */\n  Curl_safefree(data->state.aptr.userpwd);\n  Curl_safefree(data->state.aptr.proxyuserpwd);\n  free(altused);\n\n  if(result)\n    return result;\n\n  if(!(conn->handler->flags&PROTOPT_SSL) &&\n     conn->httpversion != 20 &&\n     (data->set.httpversion == CURL_HTTP_VERSION_2)) {\n    /* append HTTP2 upgrade magic stuff to the HTTP request if it isn't done\n       over SSL */\n    result = Curl_http2_request_upgrade(&req, conn);\n    if(result)\n      return result;\n  }\n\n#if !defined(CURL_DISABLE_COOKIES)\n  if(data->cookies || addcookies) {\n    struct Cookie *co = NULL; /* no cookies from start */\n    int count = 0;\n\n    if(data->cookies && data->state.cookie_engine) {\n      Curl_share_lock(data, CURL_LOCK_DATA_COOKIE, CURL_LOCK_ACCESS_SINGLE);\n      co = Curl_cookie_getlist(data->cookies,\n                               data->state.aptr.cookiehost?\n                               data->state.aptr.cookiehost:host,\n                               data->state.up.path,\n                               (conn->handler->protocol&CURLPROTO_HTTPS)?\n                               TRUE:FALSE);\n      Curl_share_unlock(data, CURL_LOCK_DATA_COOKIE);\n    }\n    if(co) {\n      struct Cookie *store = co;\n      /* now loop through all cookies that matched */\n      while(co) {\n        if(co->value) {\n          if(0 == count) {\n            result = Curl_dyn_add(&req, \"Cookie: \");\n            if(result)\n              break;\n          }\n          result = Curl_dyn_addf(&req, \"%s%s=%s\", count?\"; \":\"\",\n                                 co->name, co->value);\n          if(result)\n            break;\n          count++;\n        }\n        co = co->next; /* next cookie please */\n      }\n      Curl_cookie_freelist(store);\n    }\n    if(addcookies && !result) {\n      if(!count)\n        result = Curl_dyn_add(&req, \"Cookie: \");\n      if(!result) {\n        result = Curl_dyn_addf(&req, \"%s%s\", count?\"; \":\"\", addcookies);\n        count++;\n      }\n    }\n    if(count && !result)\n      result = Curl_dyn_add(&req, \"\\r\\n\");\n\n    if(result)\n      return result;\n  }\n#endif\n\n  result = Curl_add_timecondition(conn, &req);\n  if(result)\n    return result;\n\n  result = Curl_add_custom_headers(conn, FALSE, &req);\n  if(result)\n    return result;\n\n  http->postdata = NULL;  /* nothing to post at this point */\n  Curl_pgrsSetUploadSize(data, -1); /* upload size is unknown atm */\n\n  /* If 'authdone' is FALSE, we must not set the write socket index to the\n     Curl_transfer() call below, as we're not ready to actually upload any\n     data yet. */\n\n  switch(httpreq) {\n\n  case HTTPREQ_PUT: /* Let's PUT the data to the server! */\n\n    if(conn->bits.authneg)\n      postsize = 0;\n    else\n      postsize = data->state.infilesize;\n\n    if((postsize != -1) && !data->req.upload_chunky &&\n       (conn->bits.authneg || !Curl_checkheaders(conn, \"Content-Length\"))) {\n      /* only add Content-Length if not uploading chunked */\n      result = Curl_dyn_addf(&req, \"Content-Length: %\" CURL_FORMAT_CURL_OFF_T\n                             \"\\r\\n\", postsize);\n      if(result)\n        return result;\n    }\n\n    if(postsize != 0) {\n      result = expect100(data, conn, &req);\n      if(result)\n        return result;\n    }\n\n    /* end of headers */\n    result = Curl_dyn_add(&req, \"\\r\\n\");\n    if(result)\n      return result;\n\n    /* set the upload size to the progress meter */\n    Curl_pgrsSetUploadSize(data, postsize);\n\n    /* this sends the buffer and frees all the buffer resources */\n    result = Curl_buffer_send(&req, conn, &data->info.request_size, 0,\n                              FIRSTSOCKET);\n    if(result)\n      failf(data, \"Failed sending PUT request\");\n    else\n      /* prepare for transfer */\n      Curl_setup_transfer(data, FIRSTSOCKET, -1, TRUE,\n                          postsize?FIRSTSOCKET:-1);\n    if(result)\n      return result;\n    break;\n\n  case HTTPREQ_POST_FORM:\n  case HTTPREQ_POST_MIME:\n    /* This is form posting using mime data. */\n    if(conn->bits.authneg) {\n      /* nothing to post! */\n      result = Curl_dyn_add(&req, \"Content-Length: 0\\r\\n\\r\\n\");\n      if(result)\n        return result;\n\n      result = Curl_buffer_send(&req, conn, &data->info.request_size, 0,\n                                FIRSTSOCKET);\n      if(result)\n        failf(data, \"Failed sending POST request\");\n      else\n        /* setup variables for the upcoming transfer */\n        Curl_setup_transfer(data, FIRSTSOCKET, -1, TRUE, -1);\n      break;\n    }\n\n    data->state.infilesize = postsize = http->postsize;\n\n    /* We only set Content-Length and allow a custom Content-Length if\n       we don't upload data chunked, as RFC2616 forbids us to set both\n       kinds of headers (Transfer-Encoding: chunked and Content-Length) */\n    if(postsize != -1 && !data->req.upload_chunky &&\n       (conn->bits.authneg || !Curl_checkheaders(conn, \"Content-Length\"))) {\n      /* we allow replacing this header if not during auth negotiation,\n         although it isn't very wise to actually set your own */\n      result = Curl_dyn_addf(&req,\n                             \"Content-Length: %\" CURL_FORMAT_CURL_OFF_T\n                             \"\\r\\n\", postsize);\n      if(result)\n        return result;\n    }\n\n#ifndef CURL_DISABLE_MIME\n    /* Output mime-generated headers. */\n    {\n      struct curl_slist *hdr;\n\n      for(hdr = http->sendit->curlheaders; hdr; hdr = hdr->next) {\n        result = Curl_dyn_addf(&req, \"%s\\r\\n\", hdr->data);\n        if(result)\n          return result;\n      }\n    }\n#endif\n\n    /* For really small posts we don't use Expect: headers at all, and for\n       the somewhat bigger ones we allow the app to disable it. Just make\n       sure that the expect100header is always set to the preferred value\n       here. */\n    ptr = Curl_checkheaders(conn, \"Expect\");\n    if(ptr) {\n      data->state.expect100header =\n        Curl_compareheader(ptr, \"Expect:\", \"100-continue\");\n    }\n    else if(postsize > EXPECT_100_THRESHOLD || postsize < 0) {\n      result = expect100(data, conn, &req);\n      if(result)\n        return result;\n    }\n    else\n      data->state.expect100header = FALSE;\n\n    /* make the request end in a true CRLF */\n    result = Curl_dyn_add(&req, \"\\r\\n\");\n    if(result)\n      return result;\n\n    /* set the upload size to the progress meter */\n    Curl_pgrsSetUploadSize(data, postsize);\n\n    /* Read from mime structure. */\n    data->state.fread_func = (curl_read_callback) Curl_mime_read;\n    data->state.in = (void *) http->sendit;\n    http->sending = HTTPSEND_BODY;\n\n    /* this sends the buffer and frees all the buffer resources */\n    result = Curl_buffer_send(&req, conn, &data->info.request_size, 0,\n                              FIRSTSOCKET);\n    if(result)\n      failf(data, \"Failed sending POST request\");\n    else\n      /* prepare for transfer */\n      Curl_setup_transfer(data, FIRSTSOCKET, -1, TRUE,\n                          postsize?FIRSTSOCKET:-1);\n    if(result)\n      return result;\n\n    break;\n\n  case HTTPREQ_POST:\n    /* this is the simple POST, using x-www-form-urlencoded style */\n\n    if(conn->bits.authneg)\n      postsize = 0;\n    else\n      /* the size of the post body */\n      postsize = data->state.infilesize;\n\n    /* We only set Content-Length and allow a custom Content-Length if\n       we don't upload data chunked, as RFC2616 forbids us to set both\n       kinds of headers (Transfer-Encoding: chunked and Content-Length) */\n    if((postsize != -1) && !data->req.upload_chunky &&\n       (conn->bits.authneg || !Curl_checkheaders(conn, \"Content-Length\"))) {\n      /* we allow replacing this header if not during auth negotiation,\n         although it isn't very wise to actually set your own */\n      result = Curl_dyn_addf(&req, \"Content-Length: %\" CURL_FORMAT_CURL_OFF_T\n                             \"\\r\\n\", postsize);\n      if(result)\n        return result;\n    }\n\n    if(!Curl_checkheaders(conn, \"Content-Type\")) {\n      result = Curl_dyn_add(&req, \"Content-Type: application/\"\n                            \"x-www-form-urlencoded\\r\\n\");\n      if(result)\n        return result;\n    }\n\n    /* For really small posts we don't use Expect: headers at all, and for\n       the somewhat bigger ones we allow the app to disable it. Just make\n       sure that the expect100header is always set to the preferred value\n       here. */\n    ptr = Curl_checkheaders(conn, \"Expect\");\n    if(ptr) {\n      data->state.expect100header =\n        Curl_compareheader(ptr, \"Expect:\", \"100-continue\");\n    }\n    else if(postsize > EXPECT_100_THRESHOLD || postsize < 0) {\n      result = expect100(data, conn, &req);\n      if(result)\n        return result;\n    }\n    else\n      data->state.expect100header = FALSE;\n\n    if(data->set.postfields) {\n\n      /* In HTTP2, we send request body in DATA frame regardless of\n         its size. */\n      if(conn->httpversion != 20 &&\n         !data->state.expect100header &&\n         (postsize < MAX_INITIAL_POST_SIZE)) {\n        /* if we don't use expect: 100  AND\n           postsize is less than MAX_INITIAL_POST_SIZE\n\n           then append the post data to the HTTP request header. This limit\n           is no magic limit but only set to prevent really huge POSTs to\n           get the data duplicated with malloc() and family. */\n\n        /* end of headers! */\n        result = Curl_dyn_add(&req, \"\\r\\n\");\n        if(result)\n          return result;\n\n        if(!data->req.upload_chunky) {\n          /* We're not sending it 'chunked', append it to the request\n             already now to reduce the number if send() calls */\n          result = Curl_dyn_addn(&req, data->set.postfields,\n                                 (size_t)postsize);\n          included_body = postsize;\n        }\n        else {\n          if(postsize) {\n            /* Append the POST data chunky-style */\n            result = Curl_dyn_addf(&req, \"%x\\r\\n\", (int)postsize);\n            if(!result) {\n              result = Curl_dyn_addn(&req, data->set.postfields,\n                                     (size_t)postsize);\n              if(!result)\n                result = Curl_dyn_add(&req, \"\\r\\n\");\n              included_body = postsize + 2;\n            }\n          }\n          if(!result)\n            result = Curl_dyn_add(&req, \"\\x30\\x0d\\x0a\\x0d\\x0a\");\n          /* 0  CR  LF  CR  LF */\n          included_body += 5;\n        }\n        if(result)\n          return result;\n        /* Make sure the progress information is accurate */\n        Curl_pgrsSetUploadSize(data, postsize);\n      }\n      else {\n        /* A huge POST coming up, do data separate from the request */\n        http->postsize = postsize;\n        http->postdata = data->set.postfields;\n\n        http->sending = HTTPSEND_BODY;\n\n        data->state.fread_func = (curl_read_callback)readmoredata;\n        data->state.in = (void *)conn;\n\n        /* set the upload size to the progress meter */\n        Curl_pgrsSetUploadSize(data, http->postsize);\n\n        /* end of headers! */\n        result = Curl_dyn_add(&req, \"\\r\\n\");\n        if(result)\n          return result;\n      }\n    }\n    else {\n       /* end of headers! */\n      result = Curl_dyn_add(&req, \"\\r\\n\");\n      if(result)\n        return result;\n\n      if(data->req.upload_chunky && conn->bits.authneg) {\n        /* Chunky upload is selected and we're negotiating auth still, send\n           end-of-data only */\n        result = Curl_dyn_add(&req, (char *)\"\\x30\\x0d\\x0a\\x0d\\x0a\");\n        /* 0  CR  LF  CR  LF */\n        if(result)\n          return result;\n      }\n\n      else if(data->state.infilesize) {\n        /* set the upload size to the progress meter */\n        Curl_pgrsSetUploadSize(data, postsize?postsize:-1);\n\n        /* set the pointer to mark that we will send the post body using the\n           read callback, but only if we're not in authenticate\n           negotiation  */\n        if(!conn->bits.authneg) {\n          http->postdata = (char *)&http->postdata;\n          http->postsize = postsize;\n        }\n      }\n    }\n    /* issue the request */\n    result = Curl_buffer_send(&req, conn, &data->info.request_size,\n                              (size_t)included_body, FIRSTSOCKET);\n\n    if(result)\n      failf(data, \"Failed sending HTTP POST request\");\n    else\n      Curl_setup_transfer(data, FIRSTSOCKET, -1, TRUE,\n                          http->postdata?FIRSTSOCKET:-1);\n    break;\n\n  default:\n    result = Curl_dyn_add(&req, \"\\r\\n\");\n    if(result)\n      return result;\n\n    /* issue the request */\n    result = Curl_buffer_send(&req, conn, &data->info.request_size, 0,\n                              FIRSTSOCKET);\n\n    if(result)\n      failf(data, \"Failed sending HTTP request\");\n    else\n      /* HTTP GET/HEAD download: */\n      Curl_setup_transfer(data, FIRSTSOCKET, -1, TRUE, -1);\n  }\n  if(result)\n    return result;\n  if(!postsize && (http->sending != HTTPSEND_REQUEST))\n    data->req.upload_done = TRUE;\n\n  if(data->req.writebytecount) {\n    /* if a request-body has been sent off, we make sure this progress is noted\n       properly */\n    Curl_pgrsSetUploadCounter(data, data->req.writebytecount);\n    if(Curl_pgrsUpdate(conn))\n      result = CURLE_ABORTED_BY_CALLBACK;\n\n    if(data->req.writebytecount >= postsize) {\n      /* already sent the entire request body, mark the \"upload\" as\n         complete */\n      infof(data, \"upload completely sent off: %\" CURL_FORMAT_CURL_OFF_T\n            \" out of %\" CURL_FORMAT_CURL_OFF_T \" bytes\\n\",\n            data->req.writebytecount, postsize);\n      data->req.upload_done = TRUE;\n      data->req.keepon &= ~KEEP_SEND; /* we're done writing */\n      data->req.exp100 = EXP100_SEND_DATA; /* already sent */\n      Curl_expire_done(data, EXPIRE_100_TIMEOUT);\n    }\n  }\n\n  if((conn->httpversion == 20) && data->req.upload_chunky)\n    /* upload_chunky was set above to set up the request in a chunky fashion,\n       but is disabled here again to avoid that the chunked encoded version is\n       actually used when sending the request body over h2 */\n    data->req.upload_chunky = FALSE;\n  return result;\n}\n\ntypedef enum {\n  STATUS_UNKNOWN, /* not enough data to tell yet */\n  STATUS_DONE, /* a status line was read */\n  STATUS_BAD /* not a status line */\n} statusline;\n\n\n/* Check a string for a prefix. Check no more than 'len' bytes */\nstatic bool checkprefixmax(const char *prefix, const char *buffer, size_t len)\n{\n  size_t ch = CURLMIN(strlen(prefix), len);\n  return curl_strnequal(prefix, buffer, ch);\n}\n\n/*\n * checkhttpprefix()\n *\n * Returns TRUE if member of the list matches prefix of string\n */\nstatic statusline\ncheckhttpprefix(struct Curl_easy *data,\n                const char *s, size_t len)\n{\n  struct curl_slist *head = data->set.http200aliases;\n  statusline rc = STATUS_BAD;\n  statusline onmatch = len >= 5? STATUS_DONE : STATUS_UNKNOWN;\n#ifdef CURL_DOES_CONVERSIONS\n  /* convert from the network encoding using a scratch area */\n  char *scratch = strdup(s);\n  if(NULL == scratch) {\n    failf(data, \"Failed to allocate memory for conversion!\");\n    return FALSE; /* can't return CURLE_OUT_OF_MEMORY so return FALSE */\n  }\n  if(CURLE_OK != Curl_convert_from_network(data, scratch, strlen(s) + 1)) {\n    /* Curl_convert_from_network calls failf if unsuccessful */\n    free(scratch);\n    return FALSE; /* can't return CURLE_foobar so return FALSE */\n  }\n  s = scratch;\n#endif /* CURL_DOES_CONVERSIONS */\n\n  while(head) {\n    if(checkprefixmax(head->data, s, len)) {\n      rc = onmatch;\n      break;\n    }\n    head = head->next;\n  }\n\n  if((rc != STATUS_DONE) && (checkprefixmax(\"HTTP/\", s, len)))\n    rc = onmatch;\n\n#ifdef CURL_DOES_CONVERSIONS\n  free(scratch);\n#endif /* CURL_DOES_CONVERSIONS */\n  return rc;\n}\n\n#ifndef CURL_DISABLE_RTSP\nstatic statusline\ncheckrtspprefix(struct Curl_easy *data,\n                const char *s, size_t len)\n{\n  statusline result = STATUS_BAD;\n  statusline onmatch = len >= 5? STATUS_DONE : STATUS_UNKNOWN;\n\n#ifdef CURL_DOES_CONVERSIONS\n  /* convert from the network encoding using a scratch area */\n  char *scratch = strdup(s);\n  if(NULL == scratch) {\n    failf(data, \"Failed to allocate memory for conversion!\");\n    return FALSE; /* can't return CURLE_OUT_OF_MEMORY so return FALSE */\n  }\n  if(CURLE_OK != Curl_convert_from_network(data, scratch, strlen(s) + 1)) {\n    /* Curl_convert_from_network calls failf if unsuccessful */\n    result = FALSE; /* can't return CURLE_foobar so return FALSE */\n  }\n  else if(checkprefixmax(\"RTSP/\", scratch, len))\n    result = onmatch;\n  free(scratch);\n#else\n  (void)data; /* unused */\n  if(checkprefixmax(\"RTSP/\", s, len))\n    result = onmatch;\n#endif /* CURL_DOES_CONVERSIONS */\n\n  return result;\n}\n#endif /* CURL_DISABLE_RTSP */\n\nstatic statusline\ncheckprotoprefix(struct Curl_easy *data, struct connectdata *conn,\n                 const char *s, size_t len)\n{\n#ifndef CURL_DISABLE_RTSP\n  if(conn->handler->protocol & CURLPROTO_RTSP)\n    return checkrtspprefix(data, s, len);\n#else\n  (void)conn;\n#endif /* CURL_DISABLE_RTSP */\n\n  return checkhttpprefix(data, s, len);\n}\n\nstatic void print_http_error(struct Curl_easy *data)\n{\n  struct SingleRequest *k = &data->req;\n  char *beg = Curl_dyn_ptr(&data->state.headerb);\n\n  /* make sure that data->req.p points to the HTTP status line */\n  if(!strncmp(beg, \"HTTP\", 4)) {\n\n    /* skip to HTTP status code */\n    beg = strchr(beg, ' ');\n    if(beg && *++beg) {\n\n      /* find trailing CR */\n      char end_char = '\\r';\n      char *end = strchr(beg, end_char);\n      if(!end) {\n        /* try to find LF (workaround for non-compliant HTTP servers) */\n        end_char = '\\n';\n        end = strchr(beg, end_char);\n      }\n\n      if(end) {\n        /* temporarily replace CR or LF by NUL and print the error message */\n        *end = '\\0';\n        failf(data, \"The requested URL returned error: %s\", beg);\n\n        /* restore the previously replaced CR or LF */\n        *end = end_char;\n        return;\n      }\n    }\n  }\n\n  /* fall-back to printing the HTTP status code only */\n  failf(data, \"The requested URL returned error: %d\", k->httpcode);\n}\n\n/*\n * Read any HTTP header lines from the server and pass them to the client app.\n */\nCURLcode Curl_http_readwrite_headers(struct Curl_easy *data,\n                                     struct connectdata *conn,\n                                     ssize_t *nread,\n                                     bool *stop_reading)\n{\n  CURLcode result;\n  struct SingleRequest *k = &data->req;\n  ssize_t onread = *nread;\n  char *ostr = k->str;\n  char *headp;\n  char *str_start;\n  char *end_ptr;\n\n  /* header line within buffer loop */\n  do {\n    size_t rest_length;\n    size_t full_length;\n    int writetype;\n\n    /* str_start is start of line within buf */\n    str_start = k->str;\n\n    /* data is in network encoding so use 0x0a instead of '\\n' */\n    end_ptr = memchr(str_start, 0x0a, *nread);\n\n    if(!end_ptr) {\n      /* Not a complete header line within buffer, append the data to\n         the end of the headerbuff. */\n      result = Curl_dyn_addn(&data->state.headerb, str_start, *nread);\n      if(result)\n        return result;\n\n      if(!k->headerline) {\n        /* check if this looks like a protocol header */\n        statusline st =\n          checkprotoprefix(data, conn,\n                           Curl_dyn_ptr(&data->state.headerb),\n                           Curl_dyn_len(&data->state.headerb));\n\n        if(st == STATUS_BAD) {\n          /* this is not the beginning of a protocol first header line */\n          k->header = FALSE;\n          k->badheader = HEADER_ALLBAD;\n          streamclose(conn, \"bad HTTP: No end-of-message indicator\");\n          if(!data->set.http09_allowed) {\n            failf(data, \"Received HTTP/0.9 when not allowed\\n\");\n            return CURLE_UNSUPPORTED_PROTOCOL;\n          }\n          break;\n        }\n      }\n\n      break; /* read more and try again */\n    }\n\n    /* decrease the size of the remaining (supposed) header line */\n    rest_length = (end_ptr - k->str) + 1;\n    *nread -= (ssize_t)rest_length;\n\n    k->str = end_ptr + 1; /* move past new line */\n\n    full_length = k->str - str_start;\n\n    result = Curl_dyn_addn(&data->state.headerb, str_start, full_length);\n    if(result)\n      return result;\n\n    /****\n     * We now have a FULL header line in 'headerb'.\n     *****/\n\n    if(!k->headerline) {\n      /* the first read header */\n      statusline st = checkprotoprefix(data, conn,\n                                       Curl_dyn_ptr(&data->state.headerb),\n                                       Curl_dyn_len(&data->state.headerb));\n      if(st == STATUS_BAD) {\n        streamclose(conn, \"bad HTTP: No end-of-message indicator\");\n        /* this is not the beginning of a protocol first header line */\n        if(!data->set.http09_allowed) {\n          failf(data, \"Received HTTP/0.9 when not allowed\\n\");\n          return CURLE_UNSUPPORTED_PROTOCOL;\n        }\n        k->header = FALSE;\n        if(*nread)\n          /* since there's more, this is a partial bad header */\n          k->badheader = HEADER_PARTHEADER;\n        else {\n          /* this was all we read so it's all a bad header */\n          k->badheader = HEADER_ALLBAD;\n          *nread = onread;\n          k->str = ostr;\n          return CURLE_OK;\n        }\n        break;\n      }\n    }\n\n    /* headers are in network encoding so use 0x0a and 0x0d instead of '\\n'\n       and '\\r' */\n    headp = Curl_dyn_ptr(&data->state.headerb);\n    if((0x0a == *headp) || (0x0d == *headp)) {\n      size_t headerlen;\n      /* Zero-length header line means end of headers! */\n\n#ifdef CURL_DOES_CONVERSIONS\n      if(0x0d == *headp) {\n        *headp = '\\r'; /* replace with CR in host encoding */\n        headp++;       /* pass the CR byte */\n      }\n      if(0x0a == *headp) {\n        *headp = '\\n'; /* replace with LF in host encoding */\n        headp++;       /* pass the LF byte */\n      }\n#else\n      if('\\r' == *headp)\n        headp++; /* pass the \\r byte */\n      if('\\n' == *headp)\n        headp++; /* pass the \\n byte */\n#endif /* CURL_DOES_CONVERSIONS */\n\n      if(100 <= k->httpcode && 199 >= k->httpcode) {\n        /* \"A user agent MAY ignore unexpected 1xx status responses.\" */\n        switch(k->httpcode) {\n        case 100:\n          /*\n           * We have made a HTTP PUT or POST and this is 1.1-lingo\n           * that tells us that the server is OK with this and ready\n           * to receive the data.\n           * However, we'll get more headers now so we must get\n           * back into the header-parsing state!\n           */\n          k->header = TRUE;\n          k->headerline = 0; /* restart the header line counter */\n\n          /* if we did wait for this do enable write now! */\n          if(k->exp100 > EXP100_SEND_DATA) {\n            k->exp100 = EXP100_SEND_DATA;\n            k->keepon |= KEEP_SEND;\n            Curl_expire_done(data, EXPIRE_100_TIMEOUT);\n          }\n          break;\n        case 101:\n          /* Switching Protocols */\n          if(k->upgr101 == UPGR101_REQUESTED) {\n            /* Switching to HTTP/2 */\n            infof(data, \"Received 101\\n\");\n            k->upgr101 = UPGR101_RECEIVED;\n\n            /* we'll get more headers (HTTP/2 response) */\n            k->header = TRUE;\n            k->headerline = 0; /* restart the header line counter */\n\n            /* switch to http2 now. The bytes after response headers\n               are also processed here, otherwise they are lost. */\n            result = Curl_http2_switched(conn, k->str, *nread);\n            if(result)\n              return result;\n            *nread = 0;\n          }\n          else {\n            /* Switching to another protocol (e.g. WebSocket) */\n            k->header = FALSE; /* no more header to parse! */\n          }\n          break;\n        default:\n          /* the status code 1xx indicates a provisional response, so\n             we'll get another set of headers */\n          k->header = TRUE;\n          k->headerline = 0; /* restart the header line counter */\n          break;\n        }\n      }\n      else {\n        k->header = FALSE; /* no more header to parse! */\n\n        if((k->size == -1) && !k->chunk && !conn->bits.close &&\n           (conn->httpversion == 11) &&\n           !(conn->handler->protocol & CURLPROTO_RTSP) &&\n           data->state.httpreq != HTTPREQ_HEAD) {\n          /* On HTTP 1.1, when connection is not to get closed, but no\n             Content-Length nor Transfer-Encoding chunked have been\n             received, according to RFC2616 section 4.4 point 5, we\n             assume that the server will close the connection to\n             signal the end of the document. */\n          infof(data, \"no chunk, no close, no size. Assume close to \"\n                \"signal end\\n\");\n          streamclose(conn, \"HTTP: No end-of-message indicator\");\n        }\n      }\n\n      /* At this point we have some idea about the fate of the connection.\n         If we are closing the connection it may result auth failure. */\n#if defined(USE_NTLM)\n      if(conn->bits.close &&\n         (((data->req.httpcode == 401) &&\n           (conn->http_ntlm_state == NTLMSTATE_TYPE2)) ||\n          ((data->req.httpcode == 407) &&\n           (conn->proxy_ntlm_state == NTLMSTATE_TYPE2)))) {\n        infof(data, \"Connection closure while negotiating auth (HTTP 1.0?)\\n\");\n        data->state.authproblem = TRUE;\n      }\n#endif\n#if defined(USE_SPNEGO)\n      if(conn->bits.close &&\n        (((data->req.httpcode == 401) &&\n          (conn->http_negotiate_state == GSS_AUTHRECV)) ||\n         ((data->req.httpcode == 407) &&\n          (conn->proxy_negotiate_state == GSS_AUTHRECV)))) {\n        infof(data, \"Connection closure while negotiating auth (HTTP 1.0?)\\n\");\n        data->state.authproblem = TRUE;\n      }\n      if((conn->http_negotiate_state == GSS_AUTHDONE) &&\n         (data->req.httpcode != 401)) {\n        conn->http_negotiate_state = GSS_AUTHSUCC;\n      }\n      if((conn->proxy_negotiate_state == GSS_AUTHDONE) &&\n         (data->req.httpcode != 407)) {\n        conn->proxy_negotiate_state = GSS_AUTHSUCC;\n      }\n#endif\n      /*\n       * When all the headers have been parsed, see if we should give\n       * up and return an error.\n       */\n      if(http_should_fail(conn)) {\n        failf(data, \"The requested URL returned error: %d\",\n              k->httpcode);\n        return CURLE_HTTP_RETURNED_ERROR;\n      }\n\n      /* now, only output this if the header AND body are requested:\n       */\n      writetype = CLIENTWRITE_HEADER;\n      if(data->set.include_header)\n        writetype |= CLIENTWRITE_BODY;\n\n      headerlen = Curl_dyn_len(&data->state.headerb);\n      result = Curl_client_write(conn, writetype,\n                                 Curl_dyn_ptr(&data->state.headerb),\n                                 headerlen);\n      if(result)\n        return result;\n\n      data->info.header_size += (long)headerlen;\n      data->req.headerbytecount += (long)headerlen;\n\n      data->req.deductheadercount =\n        (100 <= k->httpcode && 199 >= k->httpcode)?data->req.headerbytecount:0;\n\n      /* Curl_http_auth_act() checks what authentication methods\n       * that are available and decides which one (if any) to\n       * use. It will set 'newurl' if an auth method was picked. */\n      result = Curl_http_auth_act(conn);\n\n      if(result)\n        return result;\n\n      if(k->httpcode >= 300) {\n        if((!conn->bits.authneg) && !conn->bits.close &&\n           !conn->bits.rewindaftersend) {\n          /*\n           * General treatment of errors when about to send data. Including :\n           * \"417 Expectation Failed\", while waiting for 100-continue.\n           *\n           * The check for close above is done simply because of something\n           * else has already deemed the connection to get closed then\n           * something else should've considered the big picture and we\n           * avoid this check.\n           *\n           * rewindaftersend indicates that something has told libcurl to\n           * continue sending even if it gets discarded\n           */\n\n          switch(data->state.httpreq) {\n          case HTTPREQ_PUT:\n          case HTTPREQ_POST:\n          case HTTPREQ_POST_FORM:\n          case HTTPREQ_POST_MIME:\n            /* We got an error response. If this happened before the whole\n             * request body has been sent we stop sending and mark the\n             * connection for closure after we've read the entire response.\n             */\n            Curl_expire_done(data, EXPIRE_100_TIMEOUT);\n            if(!k->upload_done) {\n              if((k->httpcode == 417) && data->state.expect100header) {\n                /* 417 Expectation Failed - try again without the Expect\n                   header */\n                infof(data, \"Got 417 while waiting for a 100\\n\");\n                data->state.disableexpect = TRUE;\n                DEBUGASSERT(!data->req.newurl);\n                data->req.newurl = strdup(conn->data->change.url);\n                Curl_done_sending(conn, k);\n              }\n              else if(data->set.http_keep_sending_on_error) {\n                infof(data, \"HTTP error before end of send, keep sending\\n\");\n                if(k->exp100 > EXP100_SEND_DATA) {\n                  k->exp100 = EXP100_SEND_DATA;\n                  k->keepon |= KEEP_SEND;\n                }\n              }\n              else {\n                infof(data, \"HTTP error before end of send, stop sending\\n\");\n                streamclose(conn, \"Stop sending data before everything sent\");\n                result = Curl_done_sending(conn, k);\n                if(result)\n                  return result;\n                k->upload_done = TRUE;\n                if(data->state.expect100header)\n                  k->exp100 = EXP100_FAILED;\n              }\n            }\n            break;\n\n          default: /* default label present to avoid compiler warnings */\n            break;\n          }\n        }\n\n        if(conn->bits.rewindaftersend) {\n          /* We rewind after a complete send, so thus we continue\n             sending now */\n          infof(data, \"Keep sending data to get tossed away!\\n\");\n          k->keepon |= KEEP_SEND;\n        }\n      }\n\n      if(!k->header) {\n        /*\n         * really end-of-headers.\n         *\n         * If we requested a \"no body\", this is a good time to get\n         * out and return home.\n         */\n        if(data->set.opt_no_body)\n          *stop_reading = TRUE;\n#ifndef CURL_DISABLE_RTSP\n        else if((conn->handler->protocol & CURLPROTO_RTSP) &&\n                (data->set.rtspreq == RTSPREQ_DESCRIBE) &&\n                (k->size <= -1))\n          /* Respect section 4.4 of rfc2326: If the Content-Length header is\n             absent, a length 0 must be assumed.  It will prevent libcurl from\n             hanging on DESCRIBE request that got refused for whatever\n             reason */\n          *stop_reading = TRUE;\n#endif\n        else {\n          /* If we know the expected size of this document, we set the\n             maximum download size to the size of the expected\n             document or else, we won't know when to stop reading!\n\n             Note that we set the download maximum even if we read a\n             \"Connection: close\" header, to make sure that\n             \"Content-Length: 0\" still prevents us from attempting to\n             read the (missing) response-body.\n          */\n          /* According to RFC2616 section 4.4, we MUST ignore\n             Content-Length: headers if we are now receiving data\n             using chunked Transfer-Encoding.\n          */\n          if(k->chunk)\n            k->maxdownload = k->size = -1;\n        }\n        if(-1 != k->size) {\n          /* We do this operation even if no_body is true, since this\n             data might be retrieved later with curl_easy_getinfo()\n             and its CURLINFO_CONTENT_LENGTH_DOWNLOAD option. */\n\n          Curl_pgrsSetDownloadSize(data, k->size);\n          k->maxdownload = k->size;\n        }\n\n        /* If max download size is *zero* (nothing) we already have\n           nothing and can safely return ok now!  But for HTTP/2, we'd\n           like to call http2_handle_stream_close to properly close a\n           stream.  In order to do this, we keep reading until we\n           close the stream. */\n        if(0 == k->maxdownload\n#if defined(USE_NGHTTP2)\n           && !((conn->handler->protocol & PROTO_FAMILY_HTTP) &&\n                conn->httpversion == 20)\n#endif\n           )\n          *stop_reading = TRUE;\n\n        if(*stop_reading) {\n          /* we make sure that this socket isn't read more now */\n          k->keepon &= ~KEEP_RECV;\n        }\n\n        if(data->set.verbose)\n          Curl_debug(data, CURLINFO_HEADER_IN,\n                     str_start, headerlen);\n        break;          /* exit header line loop */\n      }\n\n      /* We continue reading headers, reset the line-based header */\n      Curl_dyn_reset(&data->state.headerb);\n      continue;\n    }\n\n    /*\n     * Checks for special headers coming up.\n     */\n\n    if(!k->headerline++) {\n      /* This is the first header, it MUST be the error code line\n         or else we consider this to be the body right away! */\n      int httpversion_major;\n      int rtspversion_major;\n      int nc = 0;\n#ifdef CURL_DOES_CONVERSIONS\n#define HEADER1 scratch\n#define SCRATCHSIZE 21\n      CURLcode res;\n      char scratch[SCRATCHSIZE + 1]; /* \"HTTP/major.minor 123\" */\n      /* We can't really convert this yet because we don't know if it's the\n         1st header line or the body.  So we do a partial conversion into a\n         scratch area, leaving the data at 'headp' as-is.\n      */\n      strncpy(&scratch[0], headp, SCRATCHSIZE);\n      scratch[SCRATCHSIZE] = 0; /* null terminate */\n      res = Curl_convert_from_network(data,\n                                      &scratch[0],\n                                      SCRATCHSIZE);\n      if(res)\n        /* Curl_convert_from_network calls failf if unsuccessful */\n        return res;\n#else\n#define HEADER1 headp /* no conversion needed, just use headp */\n#endif /* CURL_DOES_CONVERSIONS */\n\n      if(conn->handler->protocol & PROTO_FAMILY_HTTP) {\n        /*\n         * https://tools.ietf.org/html/rfc7230#section-3.1.2\n         *\n         * The response code is always a three-digit number in HTTP as the spec\n         * says. We try to allow any number here, but we cannot make\n         * guarantees on future behaviors since it isn't within the protocol.\n         */\n        char separator;\n        char twoorthree[2];\n        nc = sscanf(HEADER1,\n                    \" HTTP/%1d.%1d%c%3d\",\n                    &httpversion_major,\n                    &conn->httpversion,\n                    &separator,\n                    &k->httpcode);\n\n        if(nc == 1 && httpversion_major >= 2 &&\n           2 == sscanf(HEADER1, \" HTTP/%1[23] %d\", twoorthree, &k->httpcode)) {\n          conn->httpversion = 0;\n          nc = 4;\n          separator = ' ';\n        }\n\n        if((nc == 4) && (' ' == separator)) {\n          conn->httpversion += 10 * httpversion_major;\n\n          if(k->upgr101 == UPGR101_RECEIVED) {\n            /* supposedly upgraded to http2 now */\n            if(conn->httpversion != 20)\n              infof(data, \"Lying server, not serving HTTP/2\\n\");\n          }\n          if(conn->httpversion < 20) {\n            conn->bundle->multiuse = BUNDLE_NO_MULTIUSE;\n            infof(data, \"Mark bundle as not supporting multiuse\\n\");\n          }\n        }\n        else if(!nc) {\n          /* this is the real world, not a Nirvana\n             NCSA 1.5.x returns this crap when asked for HTTP/1.1\n          */\n          nc = sscanf(HEADER1, \" HTTP %3d\", &k->httpcode);\n          conn->httpversion = 10;\n\n          /* If user has set option HTTP200ALIASES,\n             compare header line against list of aliases\n          */\n          if(!nc) {\n            statusline check =\n              checkhttpprefix(data,\n                              Curl_dyn_ptr(&data->state.headerb),\n                              Curl_dyn_len(&data->state.headerb));\n            if(check == STATUS_DONE) {\n              nc = 1;\n              k->httpcode = 200;\n              conn->httpversion = 10;\n            }\n          }\n        }\n        else {\n          failf(data, \"Unsupported HTTP version in response\");\n          return CURLE_UNSUPPORTED_PROTOCOL;\n        }\n      }\n      else if(conn->handler->protocol & CURLPROTO_RTSP) {\n        char separator;\n        nc = sscanf(HEADER1,\n                    \" RTSP/%1d.%1d%c%3d\",\n                    &rtspversion_major,\n                    &conn->rtspversion,\n                    &separator,\n                    &k->httpcode);\n        if((nc == 4) && (' ' == separator)) {\n          conn->rtspversion += 10 * rtspversion_major;\n          conn->httpversion = 11; /* For us, RTSP acts like HTTP 1.1 */\n        }\n        else {\n          nc = 0;\n        }\n      }\n\n      if(nc) {\n        data->info.httpcode = k->httpcode;\n\n        data->info.httpversion = conn->httpversion;\n        if(!data->state.httpversion ||\n           data->state.httpversion > conn->httpversion)\n          /* store the lowest server version we encounter */\n          data->state.httpversion = conn->httpversion;\n\n        /*\n         * This code executes as part of processing the header.  As a\n         * result, it's not totally clear how to interpret the\n         * response code yet as that depends on what other headers may\n         * be present.  401 and 407 may be errors, but may be OK\n         * depending on how authentication is working.  Other codes\n         * are definitely errors, so give up here.\n         */\n        if(data->state.resume_from && data->state.httpreq == HTTPREQ_GET &&\n             k->httpcode == 416) {\n          /* \"Requested Range Not Satisfiable\", just proceed and\n             pretend this is no error */\n          k->ignorebody = TRUE; /* Avoid appending error msg to good data. */\n        }\n        else if(data->set.http_fail_on_error && (k->httpcode >= 400) &&\n                ((k->httpcode != 401) || !conn->bits.user_passwd)\n#ifndef CURL_DISABLE_PROXY\n                && ((k->httpcode != 407) || !conn->bits.proxy_user_passwd)\n#endif\n          ) {\n          /* serious error, go home! */\n          print_http_error(data);\n          return CURLE_HTTP_RETURNED_ERROR;\n        }\n\n        if(conn->httpversion == 10) {\n          /* Default action for HTTP/1.0 must be to close, unless\n             we get one of those fancy headers that tell us the\n             server keeps it open for us! */\n          infof(data, \"HTTP 1.0, assume close after body\\n\");\n          connclose(conn, \"HTTP/1.0 close after body\");\n        }\n        else if(conn->httpversion == 20 ||\n                (k->upgr101 == UPGR101_REQUESTED && k->httpcode == 101)) {\n          DEBUGF(infof(data, \"HTTP/2 found, allow multiplexing\\n\"));\n          /* HTTP/2 cannot avoid multiplexing since it is a core functionality\n             of the protocol */\n          conn->bundle->multiuse = BUNDLE_MULTIPLEX;\n        }\n        else if(conn->httpversion >= 11 &&\n                !conn->bits.close) {\n          /* If HTTP version is >= 1.1 and connection is persistent */\n          DEBUGF(infof(data,\n                       \"HTTP 1.1 or later with persistent connection\\n\"));\n        }\n\n        k->http_bodyless = k->httpcode >= 100 && k->httpcode < 200;\n        switch(k->httpcode) {\n        case 304:\n          /* (quote from RFC2616, section 10.3.5): The 304 response\n           * MUST NOT contain a message-body, and thus is always\n           * terminated by the first empty line after the header\n           * fields.  */\n          if(data->set.timecondition)\n            data->info.timecond = TRUE;\n          /* FALLTHROUGH */\n        case 204:\n          /* (quote from RFC2616, section 10.2.5): The server has\n           * fulfilled the request but does not need to return an\n           * entity-body ... The 204 response MUST NOT include a\n           * message-body, and thus is always terminated by the first\n           * empty line after the header fields. */\n          k->size = 0;\n          k->maxdownload = 0;\n          k->http_bodyless = TRUE;\n          break;\n        default:\n          break;\n        }\n      }\n      else {\n        k->header = FALSE;   /* this is not a header line */\n        break;\n      }\n    }\n\n    result = Curl_convert_from_network(data, headp, strlen(headp));\n    /* Curl_convert_from_network calls failf if unsuccessful */\n    if(result)\n      return result;\n\n    /* Check for Content-Length: header lines to get size */\n    if(!k->http_bodyless &&\n       !data->set.ignorecl && checkprefix(\"Content-Length:\", headp)) {\n      curl_off_t contentlength;\n      CURLofft offt = curlx_strtoofft(headp + 15, NULL, 10, &contentlength);\n\n      if(offt == CURL_OFFT_OK) {\n        if(data->set.max_filesize &&\n           contentlength > data->set.max_filesize) {\n          failf(data, \"Maximum file size exceeded\");\n          return CURLE_FILESIZE_EXCEEDED;\n        }\n        k->size = contentlength;\n        k->maxdownload = k->size;\n        /* we set the progress download size already at this point\n           just to make it easier for apps/callbacks to extract this\n           info as soon as possible */\n        Curl_pgrsSetDownloadSize(data, k->size);\n      }\n      else if(offt == CURL_OFFT_FLOW) {\n        /* out of range */\n        if(data->set.max_filesize) {\n          failf(data, \"Maximum file size exceeded\");\n          return CURLE_FILESIZE_EXCEEDED;\n        }\n        streamclose(conn, \"overflow content-length\");\n        infof(data, \"Overflow Content-Length: value!\\n\");\n      }\n      else {\n        /* negative or just rubbish - bad HTTP */\n        failf(data, \"Invalid Content-Length: value\");\n        return CURLE_WEIRD_SERVER_REPLY;\n      }\n    }\n    /* check for Content-Type: header lines to get the MIME-type */\n    else if(checkprefix(\"Content-Type:\", headp)) {\n      char *contenttype = Curl_copy_header_value(headp);\n      if(!contenttype)\n        return CURLE_OUT_OF_MEMORY;\n      if(!*contenttype)\n        /* ignore empty data */\n        free(contenttype);\n      else {\n        Curl_safefree(data->info.contenttype);\n        data->info.contenttype = contenttype;\n      }\n    }\n#ifndef CURL_DISABLE_PROXY\n    else if((conn->httpversion == 10) &&\n            conn->bits.httpproxy &&\n            Curl_compareheader(headp, \"Proxy-Connection:\", \"keep-alive\")) {\n      /*\n       * When a HTTP/1.0 reply comes when using a proxy, the\n       * 'Proxy-Connection: keep-alive' line tells us the\n       * connection will be kept alive for our pleasure.\n       * Default action for 1.0 is to close.\n       */\n      connkeep(conn, \"Proxy-Connection keep-alive\"); /* don't close */\n      infof(data, \"HTTP/1.0 proxy connection set to keep alive!\\n\");\n    }\n    else if((conn->httpversion == 11) &&\n            conn->bits.httpproxy &&\n            Curl_compareheader(headp, \"Proxy-Connection:\", \"close\")) {\n      /*\n       * We get a HTTP/1.1 response from a proxy and it says it'll\n       * close down after this transfer.\n       */\n      connclose(conn, \"Proxy-Connection: asked to close after done\");\n      infof(data, \"HTTP/1.1 proxy connection set close!\\n\");\n    }\n#endif\n    else if((conn->httpversion == 10) &&\n            Curl_compareheader(headp, \"Connection:\", \"keep-alive\")) {\n      /*\n       * A HTTP/1.0 reply with the 'Connection: keep-alive' line\n       * tells us the connection will be kept alive for our\n       * pleasure.  Default action for 1.0 is to close.\n       *\n       * [RFC2068, section 19.7.1] */\n      connkeep(conn, \"Connection keep-alive\");\n      infof(data, \"HTTP/1.0 connection set to keep alive!\\n\");\n    }\n    else if(Curl_compareheader(headp, \"Connection:\", \"close\")) {\n      /*\n       * [RFC 2616, section 8.1.2.1]\n       * \"Connection: close\" is HTTP/1.1 language and means that\n       * the connection will close when this request has been\n       * served.\n       */\n      streamclose(conn, \"Connection: close used\");\n    }\n    else if(!k->http_bodyless && checkprefix(\"Transfer-Encoding:\", headp)) {\n      /* One or more encodings. We check for chunked and/or a compression\n         algorithm. */\n      /*\n       * [RFC 2616, section 3.6.1] A 'chunked' transfer encoding\n       * means that the server will send a series of \"chunks\". Each\n       * chunk starts with line with info (including size of the\n       * coming block) (terminated with CRLF), then a block of data\n       * with the previously mentioned size. There can be any amount\n       * of chunks, and a chunk-data set to zero signals the\n       * end-of-chunks. */\n\n      result = Curl_build_unencoding_stack(conn, headp + 18, TRUE);\n      if(result)\n        return result;\n    }\n    else if(!k->http_bodyless && checkprefix(\"Content-Encoding:\", headp) &&\n            data->set.str[STRING_ENCODING]) {\n      /*\n       * Process Content-Encoding. Look for the values: identity,\n       * gzip, deflate, compress, x-gzip and x-compress. x-gzip and\n       * x-compress are the same as gzip and compress. (Sec 3.5 RFC\n       * 2616). zlib cannot handle compress.  However, errors are\n       * handled further down when the response body is processed\n       */\n      result = Curl_build_unencoding_stack(conn, headp + 17, FALSE);\n      if(result)\n        return result;\n    }\n    else if(checkprefix(\"Retry-After:\", headp)) {\n      /* Retry-After = HTTP-date / delay-seconds */\n      curl_off_t retry_after = 0; /* zero for unknown or \"now\" */\n      time_t date = Curl_getdate_capped(&headp[12]);\n      if(-1 == date) {\n        /* not a date, try it as a decimal number */\n        (void)curlx_strtoofft(&headp[12], NULL, 10, &retry_after);\n      }\n      else\n        /* convert date to number of seconds into the future */\n        retry_after = date - time(NULL);\n      data->info.retry_after = retry_after; /* store it */\n    }\n    else if(!k->http_bodyless && checkprefix(\"Content-Range:\", headp)) {\n      /* Content-Range: bytes [num]-\n         Content-Range: bytes: [num]-\n         Content-Range: [num]-\n         Content-Range: [asterisk]/[total]\n\n         The second format was added since Sun's webserver\n         JavaWebServer/1.1.1 obviously sends the header this way!\n         The third added since some servers use that!\n         The forth means the requested range was unsatisfied.\n      */\n\n      char *ptr = headp + 14;\n\n      /* Move forward until first digit or asterisk */\n      while(*ptr && !ISDIGIT(*ptr) && *ptr != '*')\n        ptr++;\n\n      /* if it truly stopped on a digit */\n      if(ISDIGIT(*ptr)) {\n        if(!curlx_strtoofft(ptr, NULL, 10, &k->offset)) {\n          if(data->state.resume_from == k->offset)\n            /* we asked for a resume and we got it */\n            k->content_range = TRUE;\n        }\n      }\n      else\n        data->state.resume_from = 0; /* get everything */\n    }\n#if !defined(CURL_DISABLE_COOKIES)\n    else if(data->cookies && data->state.cookie_engine &&\n            checkprefix(\"Set-Cookie:\", headp)) {\n      Curl_share_lock(data, CURL_LOCK_DATA_COOKIE,\n                      CURL_LOCK_ACCESS_SINGLE);\n      Curl_cookie_add(data,\n                      data->cookies, TRUE, FALSE, headp + 11,\n                      /* If there is a custom-set Host: name, use it\n                         here, or else use real peer host name. */\n                      data->state.aptr.cookiehost?\n                      data->state.aptr.cookiehost:conn->host.name,\n                      data->state.up.path,\n                      (conn->handler->protocol&CURLPROTO_HTTPS)?\n                      TRUE:FALSE);\n      Curl_share_unlock(data, CURL_LOCK_DATA_COOKIE);\n    }\n#endif\n    else if(!k->http_bodyless && checkprefix(\"Last-Modified:\", headp) &&\n            (data->set.timecondition || data->set.get_filetime) ) {\n      k->timeofdoc = Curl_getdate_capped(headp + strlen(\"Last-Modified:\"));\n      if(data->set.get_filetime)\n        data->info.filetime = k->timeofdoc;\n    }\n    else if((checkprefix(\"WWW-Authenticate:\", headp) &&\n             (401 == k->httpcode)) ||\n            (checkprefix(\"Proxy-authenticate:\", headp) &&\n             (407 == k->httpcode))) {\n\n      bool proxy = (k->httpcode == 407) ? TRUE : FALSE;\n      char *auth = Curl_copy_header_value(headp);\n      if(!auth)\n        return CURLE_OUT_OF_MEMORY;\n\n      result = Curl_http_input_auth(conn, proxy, auth);\n\n      free(auth);\n\n      if(result)\n        return result;\n    }\n#ifdef USE_SPNEGO\n    else if(checkprefix(\"Persistent-Auth\", headp)) {\n      struct negotiatedata *negdata = &conn->negotiate;\n      struct auth *authp = &data->state.authhost;\n      if(authp->picked == CURLAUTH_NEGOTIATE) {\n        char *persistentauth = Curl_copy_header_value(headp);\n        if(!persistentauth)\n          return CURLE_OUT_OF_MEMORY;\n        negdata->noauthpersist = checkprefix(\"false\", persistentauth)?\n          TRUE:FALSE;\n        negdata->havenoauthpersist = TRUE;\n        infof(data, \"Negotiate: noauthpersist -> %d, header part: %s\",\n          negdata->noauthpersist, persistentauth);\n        free(persistentauth);\n      }\n    }\n#endif\n    else if((k->httpcode >= 300 && k->httpcode < 400) &&\n            checkprefix(\"Location:\", headp) &&\n            !data->req.location) {\n      /* this is the URL that the server advises us to use instead */\n      char *location = Curl_copy_header_value(headp);\n      if(!location)\n        return CURLE_OUT_OF_MEMORY;\n      if(!*location)\n        /* ignore empty data */\n        free(location);\n      else {\n        data->req.location = location;\n\n        if(data->set.http_follow_location) {\n          DEBUGASSERT(!data->req.newurl);\n          data->req.newurl = strdup(data->req.location); /* clone */\n          if(!data->req.newurl)\n            return CURLE_OUT_OF_MEMORY;\n\n          /* some cases of POST and PUT etc needs to rewind the data\n             stream at this point */\n          result = http_perhapsrewind(conn);\n          if(result)\n            return result;\n        }\n      }\n    }\n#ifdef USE_ALTSVC\n    /* If enabled, the header is incoming and this is over HTTPS */\n    else if(data->asi && checkprefix(\"Alt-Svc:\", headp) &&\n            ((conn->handler->flags & PROTOPT_SSL) ||\n#ifdef CURLDEBUG\n             /* allow debug builds to circumvent the HTTPS restriction */\n             getenv(\"CURL_ALTSVC_HTTP\")\n#else\n             0\n#endif\n              )) {\n      /* the ALPN of the current request */\n      enum alpnid id = (conn->httpversion == 20) ? ALPN_h2 : ALPN_h1;\n      result = Curl_altsvc_parse(data, data->asi,\n                                 &headp[ strlen(\"Alt-Svc:\") ],\n                                 id, conn->host.name,\n                                 curlx_uitous(conn->remote_port));\n      if(result)\n        return result;\n    }\n#endif\n    else if(conn->handler->protocol & CURLPROTO_RTSP) {\n      result = Curl_rtsp_parseheader(conn, headp);\n      if(result)\n        return result;\n    }\n\n    /*\n     * End of header-checks. Write them to the client.\n     */\n\n    writetype = CLIENTWRITE_HEADER;\n    if(data->set.include_header)\n      writetype |= CLIENTWRITE_BODY;\n\n    if(data->set.verbose)\n      Curl_debug(data, CURLINFO_HEADER_IN, headp,\n                 Curl_dyn_len(&data->state.headerb));\n\n    result = Curl_client_write(conn, writetype, headp,\n                               Curl_dyn_len(&data->state.headerb));\n    if(result)\n      return result;\n\n    data->info.header_size += Curl_dyn_len(&data->state.headerb);\n    data->req.headerbytecount += Curl_dyn_len(&data->state.headerb);\n\n    Curl_dyn_reset(&data->state.headerb);\n  }\n  while(*k->str); /* header line within buffer */\n\n  /* We might have reached the end of the header part here, but\n     there might be a non-header part left in the end of the read\n     buffer. */\n\n  return CURLE_OK;\n}\n\n#endif /* CURL_DISABLE_HTTP */\n"}, "0": {"id": 0, "path": "/home/runner/work/testcc/testcc/retdec/include/curl/curl.h", "content": "#ifndef CURLINC_CURL_H\n#define CURLINC_CURL_H\n/***************************************************************************\n *                                  _   _ ____  _\n *  Project                     ___| | | |  _ \\| |\n *                             / __| | | | |_) | |\n *                            | (__| |_| |  _ <| |___\n *                             \\___|\\___/|_| \\_\\_____|\n *\n * Copyright (C) 1998 - 2020, Daniel Stenberg, <daniel@haxx.se>, et al.\n *\n * This software is licensed as described in the file COPYING, which\n * you should have received as part of this distribution. The terms\n * are also available at https://curl.haxx.se/docs/copyright.html.\n *\n * You may opt to use, copy, modify, merge, publish, distribute and/or sell\n * copies of the Software, and permit persons to whom the Software is\n * furnished to do so, under the terms of the COPYING file.\n *\n * This software is distributed on an \"AS IS\" basis, WITHOUT WARRANTY OF ANY\n * KIND, either express or implied.\n *\n ***************************************************************************/\n\n/*\n * If you have libcurl problems, all docs and details are found here:\n *   https://curl.haxx.se/libcurl/\n *\n * curl-library mailing list subscription and unsubscription web interface:\n *   https://cool.haxx.se/mailman/listinfo/curl-library/\n */\n\n#ifdef CURL_NO_OLDIES\n#define CURL_STRICTER\n#endif\n\n#include \"curlver.h\"         /* libcurl version defines   */\n#include \"system.h\"          /* determine things run-time */\n\n/*\n * Define CURL_WIN32 when build target is Win32 API\n */\n\n#if (defined(_WIN32) || defined(__WIN32__) || defined(WIN32)) &&        \\\n  !defined(__SYMBIAN32__)\n#define CURL_WIN32\n#endif\n\n#include <stdio.h>\n#include <limits.h>\n\n#if defined(__FreeBSD__) && (__FreeBSD__ >= 2)\n/* Needed for __FreeBSD_version symbol definition */\n#include <osreldate.h>\n#endif\n\n/* The include stuff here below is mainly for time_t! */\n#include <sys/types.h>\n#include <time.h>\n\n#if defined(CURL_WIN32) && !defined(_WIN32_WCE) && !defined(__CYGWIN__)\n#if !(defined(_WINSOCKAPI_) || defined(_WINSOCK_H) || \\\n      defined(__LWIP_OPT_H__) || defined(LWIP_HDR_OPT_H))\n/* The check above prevents the winsock2 inclusion if winsock.h already was\n   included, since they can't co-exist without problems */\n#include <winsock2.h>\n#include <ws2tcpip.h>\n#endif\n#endif\n\n/* HP-UX systems version 9, 10 and 11 lack sys/select.h and so does oldish\n   libc5-based Linux systems. Only include it on systems that are known to\n   require it! */\n#if defined(_AIX) || defined(__NOVELL_LIBC__) || defined(__NetBSD__) || \\\n    defined(__minix) || defined(__SYMBIAN32__) || defined(__INTEGRITY) || \\\n    defined(ANDROID) || defined(__ANDROID__) || defined(__OpenBSD__) || \\\n    defined(__CYGWIN__) || \\\n   (defined(__FreeBSD_version) && (__FreeBSD_version < 800000))\n#include <sys/select.h>\n#endif\n\n#if !defined(CURL_WIN32) && !defined(_WIN32_WCE)\n#include <sys/socket.h>\n#endif\n\n#if !defined(CURL_WIN32) && !defined(__WATCOMC__) && !defined(__VXWORKS__)\n#include <sys/time.h>\n#endif\n\n#ifdef __BEOS__\n#include <support/SupportDefs.h>\n#endif\n\n/* Compatibility for non-Clang compilers */\n#ifndef __has_declspec_attribute\n#  define __has_declspec_attribute(x) 0\n#endif\n\n#ifdef  __cplusplus\nextern \"C\" {\n#endif\n\n#if defined(BUILDING_LIBCURL) || defined(CURL_STRICTER)\ntypedef struct Curl_easy CURL;\ntypedef struct Curl_share CURLSH;\n#else\ntypedef void CURL;\ntypedef void CURLSH;\n#endif\n\n/*\n * libcurl external API function linkage decorations.\n */\n\n#ifdef CURL_STATICLIB\n#  define CURL_EXTERN\n#elif defined(CURL_WIN32) || defined(__SYMBIAN32__) || \\\n     (__has_declspec_attribute(dllexport) && \\\n      __has_declspec_attribute(dllimport))\n#  if defined(BUILDING_LIBCURL)\n#    define CURL_EXTERN  __declspec(dllexport)\n#  else\n#    define CURL_EXTERN  __declspec(dllimport)\n#  endif\n#elif defined(BUILDING_LIBCURL) && defined(CURL_HIDDEN_SYMBOLS)\n#  define CURL_EXTERN CURL_EXTERN_SYMBOL\n#else\n#  define CURL_EXTERN\n#endif\n\n#ifndef curl_socket_typedef\n/* socket typedef */\n#if defined(CURL_WIN32) && !defined(__LWIP_OPT_H__) && !defined(LWIP_HDR_OPT_H)\ntypedef SOCKET curl_socket_t;\n#define CURL_SOCKET_BAD INVALID_SOCKET\n#else\ntypedef int curl_socket_t;\n#define CURL_SOCKET_BAD -1\n#endif\n#define curl_socket_typedef\n#endif /* curl_socket_typedef */\n\n/* enum for the different supported SSL backends */\ntypedef enum {\n  CURLSSLBACKEND_NONE = 0,\n  CURLSSLBACKEND_OPENSSL = 1,\n  CURLSSLBACKEND_GNUTLS = 2,\n  CURLSSLBACKEND_NSS = 3,\n  CURLSSLBACKEND_OBSOLETE4 = 4,  /* Was QSOSSL. */\n  CURLSSLBACKEND_GSKIT = 5,\n  CURLSSLBACKEND_POLARSSL = 6,\n  CURLSSLBACKEND_WOLFSSL = 7,\n  CURLSSLBACKEND_SCHANNEL = 8,\n  CURLSSLBACKEND_SECURETRANSPORT = 9,\n  CURLSSLBACKEND_AXTLS = 10, /* never used since 7.63.0 */\n  CURLSSLBACKEND_MBEDTLS = 11,\n  CURLSSLBACKEND_MESALINK = 12,\n  CURLSSLBACKEND_BEARSSL = 13\n} curl_sslbackend;\n\n/* aliases for library clones and renames */\n#define CURLSSLBACKEND_LIBRESSL CURLSSLBACKEND_OPENSSL\n#define CURLSSLBACKEND_BORINGSSL CURLSSLBACKEND_OPENSSL\n\n/* deprecated names: */\n#define CURLSSLBACKEND_CYASSL CURLSSLBACKEND_WOLFSSL\n#define CURLSSLBACKEND_DARWINSSL CURLSSLBACKEND_SECURETRANSPORT\n\nstruct curl_httppost {\n  struct curl_httppost *next;       /* next entry in the list */\n  char *name;                       /* pointer to allocated name */\n  long namelength;                  /* length of name length */\n  char *contents;                   /* pointer to allocated data contents */\n  long contentslength;              /* length of contents field, see also\n                                       CURL_HTTPPOST_LARGE */\n  char *buffer;                     /* pointer to allocated buffer contents */\n  long bufferlength;                /* length of buffer field */\n  char *contenttype;                /* Content-Type */\n  struct curl_slist *contentheader; /* list of extra headers for this form */\n  struct curl_httppost *more;       /* if one field name has more than one\n                                       file, this link should link to following\n                                       files */\n  long flags;                       /* as defined below */\n\n/* specified content is a file name */\n#define CURL_HTTPPOST_FILENAME (1<<0)\n/* specified content is a file name */\n#define CURL_HTTPPOST_READFILE (1<<1)\n/* name is only stored pointer do not free in formfree */\n#define CURL_HTTPPOST_PTRNAME (1<<2)\n/* contents is only stored pointer do not free in formfree */\n#define CURL_HTTPPOST_PTRCONTENTS (1<<3)\n/* upload file from buffer */\n#define CURL_HTTPPOST_BUFFER (1<<4)\n/* upload file from pointer contents */\n#define CURL_HTTPPOST_PTRBUFFER (1<<5)\n/* upload file contents by using the regular read callback to get the data and\n   pass the given pointer as custom pointer */\n#define CURL_HTTPPOST_CALLBACK (1<<6)\n/* use size in 'contentlen', added in 7.46.0 */\n#define CURL_HTTPPOST_LARGE (1<<7)\n\n  char *showfilename;               /* The file name to show. If not set, the\n                                       actual file name will be used (if this\n                                       is a file part) */\n  void *userp;                      /* custom pointer used for\n                                       HTTPPOST_CALLBACK posts */\n  curl_off_t contentlen;            /* alternative length of contents\n                                       field. Used if CURL_HTTPPOST_LARGE is\n                                       set. Added in 7.46.0 */\n};\n\n\n/* This is a return code for the progress callback that, when returned, will\n   signal libcurl to continue executing the default progress function */\n#define CURL_PROGRESSFUNC_CONTINUE 0x10000001\n\n/* This is the CURLOPT_PROGRESSFUNCTION callback prototype. It is now\n   considered deprecated but was the only choice up until 7.31.0 */\ntypedef int (*curl_progress_callback)(void *clientp,\n                                      double dltotal,\n                                      double dlnow,\n                                      double ultotal,\n                                      double ulnow);\n\n/* This is the CURLOPT_XFERINFOFUNCTION callback prototype. It was introduced\n   in 7.32.0, avoids the use of floating point numbers and provides more\n   detailed information. */\ntypedef int (*curl_xferinfo_callback)(void *clientp,\n                                      curl_off_t dltotal,\n                                      curl_off_t dlnow,\n                                      curl_off_t ultotal,\n                                      curl_off_t ulnow);\n\n#ifndef CURL_MAX_READ_SIZE\n  /* The maximum receive buffer size configurable via CURLOPT_BUFFERSIZE. */\n#define CURL_MAX_READ_SIZE 524288\n#endif\n\n#ifndef CURL_MAX_WRITE_SIZE\n  /* Tests have proven that 20K is a very bad buffer size for uploads on\n     Windows, while 16K for some odd reason performed a lot better.\n     We do the ifndef check to allow this value to easier be changed at build\n     time for those who feel adventurous. The practical minimum is about\n     400 bytes since libcurl uses a buffer of this size as a scratch area\n     (unrelated to network send operations). */\n#define CURL_MAX_WRITE_SIZE 16384\n#endif\n\n#ifndef CURL_MAX_HTTP_HEADER\n/* The only reason to have a max limit for this is to avoid the risk of a bad\n   server feeding libcurl with a never-ending header that will cause reallocs\n   infinitely */\n#define CURL_MAX_HTTP_HEADER (100*1024)\n#endif\n\n/* This is a magic return code for the write callback that, when returned,\n   will signal libcurl to pause receiving on the current transfer. */\n#define CURL_WRITEFUNC_PAUSE 0x10000001\n\ntypedef size_t (*curl_write_callback)(char *buffer,\n                                      size_t size,\n                                      size_t nitems,\n                                      void *outstream);\n\n/* This callback will be called when a new resolver request is made */\ntypedef int (*curl_resolver_start_callback)(void *resolver_state,\n                                            void *reserved, void *userdata);\n\n/* enumeration of file types */\ntypedef enum {\n  CURLFILETYPE_FILE = 0,\n  CURLFILETYPE_DIRECTORY,\n  CURLFILETYPE_SYMLINK,\n  CURLFILETYPE_DEVICE_BLOCK,\n  CURLFILETYPE_DEVICE_CHAR,\n  CURLFILETYPE_NAMEDPIPE,\n  CURLFILETYPE_SOCKET,\n  CURLFILETYPE_DOOR, /* is possible only on Sun Solaris now */\n\n  CURLFILETYPE_UNKNOWN /* should never occur */\n} curlfiletype;\n\n#define CURLFINFOFLAG_KNOWN_FILENAME    (1<<0)\n#define CURLFINFOFLAG_KNOWN_FILETYPE    (1<<1)\n#define CURLFINFOFLAG_KNOWN_TIME        (1<<2)\n#define CURLFINFOFLAG_KNOWN_PERM        (1<<3)\n#define CURLFINFOFLAG_KNOWN_UID         (1<<4)\n#define CURLFINFOFLAG_KNOWN_GID         (1<<5)\n#define CURLFINFOFLAG_KNOWN_SIZE        (1<<6)\n#define CURLFINFOFLAG_KNOWN_HLINKCOUNT  (1<<7)\n\n/* Information about a single file, used when doing FTP wildcard matching */\nstruct curl_fileinfo {\n  char *filename;\n  curlfiletype filetype;\n  time_t time; /* always zero! */\n  unsigned int perm;\n  int uid;\n  int gid;\n  curl_off_t size;\n  long int hardlinks;\n\n  struct {\n    /* If some of these fields is not NULL, it is a pointer to b_data. */\n    char *time;\n    char *perm;\n    char *user;\n    char *group;\n    char *target; /* pointer to the target filename of a symlink */\n  } strings;\n\n  unsigned int flags;\n\n  /* used internally */\n  char *b_data;\n  size_t b_size;\n  size_t b_used;\n};\n\n/* return codes for CURLOPT_CHUNK_BGN_FUNCTION */\n#define CURL_CHUNK_BGN_FUNC_OK      0\n#define CURL_CHUNK_BGN_FUNC_FAIL    1 /* tell the lib to end the task */\n#define CURL_CHUNK_BGN_FUNC_SKIP    2 /* skip this chunk over */\n\n/* if splitting of data transfer is enabled, this callback is called before\n   download of an individual chunk started. Note that parameter \"remains\" works\n   only for FTP wildcard downloading (for now), otherwise is not used */\ntypedef long (*curl_chunk_bgn_callback)(const void *transfer_info,\n                                        void *ptr,\n                                        int remains);\n\n/* return codes for CURLOPT_CHUNK_END_FUNCTION */\n#define CURL_CHUNK_END_FUNC_OK      0\n#define CURL_CHUNK_END_FUNC_FAIL    1 /* tell the lib to end the task */\n\n/* If splitting of data transfer is enabled this callback is called after\n   download of an individual chunk finished.\n   Note! After this callback was set then it have to be called FOR ALL chunks.\n   Even if downloading of this chunk was skipped in CHUNK_BGN_FUNC.\n   This is the reason why we don't need \"transfer_info\" parameter in this\n   callback and we are not interested in \"remains\" parameter too. */\ntypedef long (*curl_chunk_end_callback)(void *ptr);\n\n/* return codes for FNMATCHFUNCTION */\n#define CURL_FNMATCHFUNC_MATCH    0 /* string corresponds to the pattern */\n#define CURL_FNMATCHFUNC_NOMATCH  1 /* pattern doesn't match the string */\n#define CURL_FNMATCHFUNC_FAIL     2 /* an error occurred */\n\n/* callback type for wildcard downloading pattern matching. If the\n   string matches the pattern, return CURL_FNMATCHFUNC_MATCH value, etc. */\ntypedef int (*curl_fnmatch_callback)(void *ptr,\n                                     const char *pattern,\n                                     const char *string);\n\n/* These are the return codes for the seek callbacks */\n#define CURL_SEEKFUNC_OK       0\n#define CURL_SEEKFUNC_FAIL     1 /* fail the entire transfer */\n#define CURL_SEEKFUNC_CANTSEEK 2 /* tell libcurl seeking can't be done, so\n                                    libcurl might try other means instead */\ntypedef int (*curl_seek_callback)(void *instream,\n                                  curl_off_t offset,\n                                  int origin); /* 'whence' */\n\n/* This is a return code for the read callback that, when returned, will\n   signal libcurl to immediately abort the current transfer. */\n#define CURL_READFUNC_ABORT 0x10000000\n/* This is a return code for the read callback that, when returned, will\n   signal libcurl to pause sending data on the current transfer. */\n#define CURL_READFUNC_PAUSE 0x10000001\n\n/* Return code for when the trailing headers' callback has terminated\n   without any errors*/\n#define CURL_TRAILERFUNC_OK 0\n/* Return code for when was an error in the trailing header's list and we\n  want to abort the request */\n#define CURL_TRAILERFUNC_ABORT 1\n\ntypedef size_t (*curl_read_callback)(char *buffer,\n                                      size_t size,\n                                      size_t nitems,\n                                      void *instream);\n\ntypedef int (*curl_trailer_callback)(struct curl_slist **list,\n                                      void *userdata);\n\ntypedef enum {\n  CURLSOCKTYPE_IPCXN,  /* socket created for a specific IP connection */\n  CURLSOCKTYPE_ACCEPT, /* socket created by accept() call */\n  CURLSOCKTYPE_LAST    /* never use */\n} curlsocktype;\n\n/* The return code from the sockopt_callback can signal information back\n   to libcurl: */\n#define CURL_SOCKOPT_OK 0\n#define CURL_SOCKOPT_ERROR 1 /* causes libcurl to abort and return\n                                CURLE_ABORTED_BY_CALLBACK */\n#define CURL_SOCKOPT_ALREADY_CONNECTED 2\n\ntypedef int (*curl_sockopt_callback)(void *clientp,\n                                     curl_socket_t curlfd,\n                                     curlsocktype purpose);\n\nstruct curl_sockaddr {\n  int family;\n  int socktype;\n  int protocol;\n  unsigned int addrlen; /* addrlen was a socklen_t type before 7.18.0 but it\n                           turned really ugly and painful on the systems that\n                           lack this type */\n  struct sockaddr addr;\n};\n\ntypedef curl_socket_t\n(*curl_opensocket_callback)(void *clientp,\n                            curlsocktype purpose,\n                            struct curl_sockaddr *address);\n\ntypedef int\n(*curl_closesocket_callback)(void *clientp, curl_socket_t item);\n\ntypedef enum {\n  CURLIOE_OK,            /* I/O operation successful */\n  CURLIOE_UNKNOWNCMD,    /* command was unknown to callback */\n  CURLIOE_FAILRESTART,   /* failed to restart the read */\n  CURLIOE_LAST           /* never use */\n} curlioerr;\n\ntypedef enum {\n  CURLIOCMD_NOP,         /* no operation */\n  CURLIOCMD_RESTARTREAD, /* restart the read stream from start */\n  CURLIOCMD_LAST         /* never use */\n} curliocmd;\n\ntypedef curlioerr (*curl_ioctl_callback)(CURL *handle,\n                                         int cmd,\n                                         void *clientp);\n\n#ifndef CURL_DID_MEMORY_FUNC_TYPEDEFS\n/*\n * The following typedef's are signatures of malloc, free, realloc, strdup and\n * calloc respectively.  Function pointers of these types can be passed to the\n * curl_global_init_mem() function to set user defined memory management\n * callback routines.\n */\ntypedef void *(*curl_malloc_callback)(size_t size);\ntypedef void (*curl_free_callback)(void *ptr);\ntypedef void *(*curl_realloc_callback)(void *ptr, size_t size);\ntypedef char *(*curl_strdup_callback)(const char *str);\ntypedef void *(*curl_calloc_callback)(size_t nmemb, size_t size);\n\n#define CURL_DID_MEMORY_FUNC_TYPEDEFS\n#endif\n\n/* the kind of data that is passed to information_callback*/\ntypedef enum {\n  CURLINFO_TEXT = 0,\n  CURLINFO_HEADER_IN,    /* 1 */\n  CURLINFO_HEADER_OUT,   /* 2 */\n  CURLINFO_DATA_IN,      /* 3 */\n  CURLINFO_DATA_OUT,     /* 4 */\n  CURLINFO_SSL_DATA_IN,  /* 5 */\n  CURLINFO_SSL_DATA_OUT, /* 6 */\n  CURLINFO_END\n} curl_infotype;\n\ntypedef int (*curl_debug_callback)\n       (CURL *handle,      /* the handle/transfer this concerns */\n        curl_infotype type, /* what kind of data */\n        char *data,        /* points to the data */\n        size_t size,       /* size of the data pointed to */\n        void *userptr);    /* whatever the user please */\n\n/* All possible error codes from all sorts of curl functions. Future versions\n   may return other values, stay prepared.\n\n   Always add new return codes last. Never *EVER* remove any. The return\n   codes must remain the same!\n */\n\ntypedef enum {\n  CURLE_OK = 0,\n  CURLE_UNSUPPORTED_PROTOCOL,    /* 1 */\n  CURLE_FAILED_INIT,             /* 2 */\n  CURLE_URL_MALFORMAT,           /* 3 */\n  CURLE_NOT_BUILT_IN,            /* 4 - [was obsoleted in August 2007 for\n                                    7.17.0, reused in April 2011 for 7.21.5] */\n  CURLE_COULDNT_RESOLVE_PROXY,   /* 5 */\n  CURLE_COULDNT_RESOLVE_HOST,    /* 6 */\n  CURLE_COULDNT_CONNECT,         /* 7 */\n  CURLE_WEIRD_SERVER_REPLY,      /* 8 */\n  CURLE_REMOTE_ACCESS_DENIED,    /* 9 a service was denied by the server\n                                    due to lack of access - when login fails\n                                    this is not returned. */\n  CURLE_FTP_ACCEPT_FAILED,       /* 10 - [was obsoleted in April 2006 for\n                                    7.15.4, reused in Dec 2011 for 7.24.0]*/\n  CURLE_FTP_WEIRD_PASS_REPLY,    /* 11 */\n  CURLE_FTP_ACCEPT_TIMEOUT,      /* 12 - timeout occurred accepting server\n                                    [was obsoleted in August 2007 for 7.17.0,\n                                    reused in Dec 2011 for 7.24.0]*/\n  CURLE_FTP_WEIRD_PASV_REPLY,    /* 13 */\n  CURLE_FTP_WEIRD_227_FORMAT,    /* 14 */\n  CURLE_FTP_CANT_GET_HOST,       /* 15 */\n  CURLE_HTTP2,                   /* 16 - A problem in the http2 framing layer.\n                                    [was obsoleted in August 2007 for 7.17.0,\n                                    reused in July 2014 for 7.38.0] */\n  CURLE_FTP_COULDNT_SET_TYPE,    /* 17 */\n  CURLE_PARTIAL_FILE,            /* 18 */\n  CURLE_FTP_COULDNT_RETR_FILE,   /* 19 */\n  CURLE_OBSOLETE20,              /* 20 - NOT USED */\n  CURLE_QUOTE_ERROR,             /* 21 - quote command failure */\n  CURLE_HTTP_RETURNED_ERROR,     /* 22 */\n  CURLE_WRITE_ERROR,             /* 23 */\n  CURLE_OBSOLETE24,              /* 24 - NOT USED */\n  CURLE_UPLOAD_FAILED,           /* 25 - failed upload \"command\" */\n  CURLE_READ_ERROR,              /* 26 - couldn't open/read from file */\n  CURLE_OUT_OF_MEMORY,           /* 27 */\n  /* Note: CURLE_OUT_OF_MEMORY may sometimes indicate a conversion error\n           instead of a memory allocation error if CURL_DOES_CONVERSIONS\n           is defined\n  */\n  CURLE_OPERATION_TIMEDOUT,      /* 28 - the timeout time was reached */\n  CURLE_OBSOLETE29,              /* 29 - NOT USED */\n  CURLE_FTP_PORT_FAILED,         /* 30 - FTP PORT operation failed */\n  CURLE_FTP_COULDNT_USE_REST,    /* 31 - the REST command failed */\n  CURLE_OBSOLETE32,              /* 32 - NOT USED */\n  CURLE_RANGE_ERROR,             /* 33 - RANGE \"command\" didn't work */\n  CURLE_HTTP_POST_ERROR,         /* 34 */\n  CURLE_SSL_CONNECT_ERROR,       /* 35 - wrong when connecting with SSL */\n  CURLE_BAD_DOWNLOAD_RESUME,     /* 36 - couldn't resume download */\n  CURLE_FILE_COULDNT_READ_FILE,  /* 37 */\n  CURLE_LDAP_CANNOT_BIND,        /* 38 */\n  CURLE_LDAP_SEARCH_FAILED,      /* 39 */\n  CURLE_OBSOLETE40,              /* 40 - NOT USED */\n  CURLE_FUNCTION_NOT_FOUND,      /* 41 - NOT USED starting with 7.53.0 */\n  CURLE_ABORTED_BY_CALLBACK,     /* 42 */\n  CURLE_BAD_FUNCTION_ARGUMENT,   /* 43 */\n  CURLE_OBSOLETE44,              /* 44 - NOT USED */\n  CURLE_INTERFACE_FAILED,        /* 45 - CURLOPT_INTERFACE failed */\n  CURLE_OBSOLETE46,              /* 46 - NOT USED */\n  CURLE_TOO_MANY_REDIRECTS,      /* 47 - catch endless re-direct loops */\n  CURLE_UNKNOWN_OPTION,          /* 48 - User specified an unknown option */\n  CURLE_TELNET_OPTION_SYNTAX,    /* 49 - Malformed telnet option */\n  CURLE_OBSOLETE50,              /* 50 - NOT USED */\n  CURLE_OBSOLETE51,              /* 51 - NOT USED */\n  CURLE_GOT_NOTHING,             /* 52 - when this is a specific error */\n  CURLE_SSL_ENGINE_NOTFOUND,     /* 53 - SSL crypto engine not found */\n  CURLE_SSL_ENGINE_SETFAILED,    /* 54 - can not set SSL crypto engine as\n                                    default */\n  CURLE_SEND_ERROR,              /* 55 - failed sending network data */\n  CURLE_RECV_ERROR,              /* 56 - failure in receiving network data */\n  CURLE_OBSOLETE57,              /* 57 - NOT IN USE */\n  CURLE_SSL_CERTPROBLEM,         /* 58 - problem with the local certificate */\n  CURLE_SSL_CIPHER,              /* 59 - couldn't use specified cipher */\n  CURLE_PEER_FAILED_VERIFICATION, /* 60 - peer's certificate or fingerprint\n                                     wasn't verified fine */\n  CURLE_BAD_CONTENT_ENCODING,    /* 61 - Unrecognized/bad encoding */\n  CURLE_LDAP_INVALID_URL,        /* 62 - Invalid LDAP URL */\n  CURLE_FILESIZE_EXCEEDED,       /* 63 - Maximum file size exceeded */\n  CURLE_USE_SSL_FAILED,          /* 64 - Requested FTP SSL level failed */\n  CURLE_SEND_FAIL_REWIND,        /* 65 - Sending the data requires a rewind\n                                    that failed */\n  CURLE_SSL_ENGINE_INITFAILED,   /* 66 - failed to initialise ENGINE */\n  CURLE_LOGIN_DENIED,            /* 67 - user, password or similar was not\n                                    accepted and we failed to login */\n  CURLE_TFTP_NOTFOUND,           /* 68 - file not found on server */\n  CURLE_TFTP_PERM,               /* 69 - permission problem on server */\n  CURLE_REMOTE_DISK_FULL,        /* 70 - out of disk space on server */\n  CURLE_TFTP_ILLEGAL,            /* 71 - Illegal TFTP operation */\n  CURLE_TFTP_UNKNOWNID,          /* 72 - Unknown transfer ID */\n  CURLE_REMOTE_FILE_EXISTS,      /* 73 - File already exists */\n  CURLE_TFTP_NOSUCHUSER,         /* 74 - No such user */\n  CURLE_CONV_FAILED,             /* 75 - conversion failed */\n  CURLE_CONV_REQD,               /* 76 - caller must register conversion\n                                    callbacks using curl_easy_setopt options\n                                    CURLOPT_CONV_FROM_NETWORK_FUNCTION,\n                                    CURLOPT_CONV_TO_NETWORK_FUNCTION, and\n                                    CURLOPT_CONV_FROM_UTF8_FUNCTION */\n  CURLE_SSL_CACERT_BADFILE,      /* 77 - could not load CACERT file, missing\n                                    or wrong format */\n  CURLE_REMOTE_FILE_NOT_FOUND,   /* 78 - remote file not found */\n  CURLE_SSH,                     /* 79 - error from the SSH layer, somewhat\n                                    generic so the error message will be of\n                                    interest when this has happened */\n\n  CURLE_SSL_SHUTDOWN_FAILED,     /* 80 - Failed to shut down the SSL\n                                    connection */\n  CURLE_AGAIN,                   /* 81 - socket is not ready for send/recv,\n                                    wait till it's ready and try again (Added\n                                    in 7.18.2) */\n  CURLE_SSL_CRL_BADFILE,         /* 82 - could not load CRL file, missing or\n                                    wrong format (Added in 7.19.0) */\n  CURLE_SSL_ISSUER_ERROR,        /* 83 - Issuer check failed.  (Added in\n                                    7.19.0) */\n  CURLE_FTP_PRET_FAILED,         /* 84 - a PRET command failed */\n  CURLE_RTSP_CSEQ_ERROR,         /* 85 - mismatch of RTSP CSeq numbers */\n  CURLE_RTSP_SESSION_ERROR,      /* 86 - mismatch of RTSP Session Ids */\n  CURLE_FTP_BAD_FILE_LIST,       /* 87 - unable to parse FTP file list */\n  CURLE_CHUNK_FAILED,            /* 88 - chunk callback reported error */\n  CURLE_NO_CONNECTION_AVAILABLE, /* 89 - No connection available, the\n                                    session will be queued */\n  CURLE_SSL_PINNEDPUBKEYNOTMATCH, /* 90 - specified pinned public key did not\n                                     match */\n  CURLE_SSL_INVALIDCERTSTATUS,   /* 91 - invalid certificate status */\n  CURLE_HTTP2_STREAM,            /* 92 - stream error in HTTP/2 framing layer\n                                    */\n  CURLE_RECURSIVE_API_CALL,      /* 93 - an api function was called from\n                                    inside a callback */\n  CURLE_AUTH_ERROR,              /* 94 - an authentication function returned an\n                                    error */\n  CURLE_HTTP3,                   /* 95 - An HTTP/3 layer problem */\n  CURLE_QUIC_CONNECT_ERROR,      /* 96 - QUIC connection error */\n  CURLE_PROXY,                   /* 97 - proxy handshake error */\n  CURL_LAST /* never use! */\n} CURLcode;\n\n#ifndef CURL_NO_OLDIES /* define this to test if your app builds with all\n                          the obsolete stuff removed! */\n\n/* Previously obsolete error code re-used in 7.38.0 */\n#define CURLE_OBSOLETE16 CURLE_HTTP2\n\n/* Previously obsolete error codes re-used in 7.24.0 */\n#define CURLE_OBSOLETE10 CURLE_FTP_ACCEPT_FAILED\n#define CURLE_OBSOLETE12 CURLE_FTP_ACCEPT_TIMEOUT\n\n/*  compatibility with older names */\n#define CURLOPT_ENCODING CURLOPT_ACCEPT_ENCODING\n#define CURLE_FTP_WEIRD_SERVER_REPLY CURLE_WEIRD_SERVER_REPLY\n\n/* The following were added in 7.62.0 */\n#define CURLE_SSL_CACERT CURLE_PEER_FAILED_VERIFICATION\n\n/* The following were added in 7.21.5, April 2011 */\n#define CURLE_UNKNOWN_TELNET_OPTION CURLE_UNKNOWN_OPTION\n\n/* The following were added in 7.17.1 */\n/* These are scheduled to disappear by 2009 */\n#define CURLE_SSL_PEER_CERTIFICATE CURLE_PEER_FAILED_VERIFICATION\n\n/* The following were added in 7.17.0 */\n/* These are scheduled to disappear by 2009 */\n#define CURLE_OBSOLETE CURLE_OBSOLETE50 /* no one should be using this! */\n#define CURLE_BAD_PASSWORD_ENTERED CURLE_OBSOLETE46\n#define CURLE_BAD_CALLING_ORDER CURLE_OBSOLETE44\n#define CURLE_FTP_USER_PASSWORD_INCORRECT CURLE_OBSOLETE10\n#define CURLE_FTP_CANT_RECONNECT CURLE_OBSOLETE16\n#define CURLE_FTP_COULDNT_GET_SIZE CURLE_OBSOLETE32\n#define CURLE_FTP_COULDNT_SET_ASCII CURLE_OBSOLETE29\n#define CURLE_FTP_WEIRD_USER_REPLY CURLE_OBSOLETE12\n#define CURLE_FTP_WRITE_ERROR CURLE_OBSOLETE20\n#define CURLE_LIBRARY_NOT_FOUND CURLE_OBSOLETE40\n#define CURLE_MALFORMAT_USER CURLE_OBSOLETE24\n#define CURLE_SHARE_IN_USE CURLE_OBSOLETE57\n#define CURLE_URL_MALFORMAT_USER CURLE_NOT_BUILT_IN\n\n#define CURLE_FTP_ACCESS_DENIED CURLE_REMOTE_ACCESS_DENIED\n#define CURLE_FTP_COULDNT_SET_BINARY CURLE_FTP_COULDNT_SET_TYPE\n#define CURLE_FTP_QUOTE_ERROR CURLE_QUOTE_ERROR\n#define CURLE_TFTP_DISKFULL CURLE_REMOTE_DISK_FULL\n#define CURLE_TFTP_EXISTS CURLE_REMOTE_FILE_EXISTS\n#define CURLE_HTTP_RANGE_ERROR CURLE_RANGE_ERROR\n#define CURLE_FTP_SSL_FAILED CURLE_USE_SSL_FAILED\n\n/* The following were added earlier */\n\n#define CURLE_OPERATION_TIMEOUTED CURLE_OPERATION_TIMEDOUT\n\n#define CURLE_HTTP_NOT_FOUND CURLE_HTTP_RETURNED_ERROR\n#define CURLE_HTTP_PORT_FAILED CURLE_INTERFACE_FAILED\n#define CURLE_FTP_COULDNT_STOR_FILE CURLE_UPLOAD_FAILED\n\n#define CURLE_FTP_PARTIAL_FILE CURLE_PARTIAL_FILE\n#define CURLE_FTP_BAD_DOWNLOAD_RESUME CURLE_BAD_DOWNLOAD_RESUME\n\n/* This was the error code 50 in 7.7.3 and a few earlier versions, this\n   is no longer used by libcurl but is instead #defined here only to not\n   make programs break */\n#define CURLE_ALREADY_COMPLETE 99999\n\n/* Provide defines for really old option names */\n#define CURLOPT_FILE CURLOPT_WRITEDATA /* name changed in 7.9.7 */\n#define CURLOPT_INFILE CURLOPT_READDATA /* name changed in 7.9.7 */\n#define CURLOPT_WRITEHEADER CURLOPT_HEADERDATA\n\n/* Since long deprecated options with no code in the lib that does anything\n   with them. */\n#define CURLOPT_WRITEINFO CURLOPT_OBSOLETE40\n#define CURLOPT_CLOSEPOLICY CURLOPT_OBSOLETE72\n\n#endif /*!CURL_NO_OLDIES*/\n\n/*\n * Proxy error codes. Returned in CURLINFO_PROXY_ERROR if CURLE_PROXY was\n * return for the transfers.\n */\ntypedef enum {\n  CURLPX_OK,\n  CURLPX_BAD_ADDRESS_TYPE,\n  CURLPX_BAD_VERSION,\n  CURLPX_CLOSED,\n  CURLPX_GSSAPI,\n  CURLPX_GSSAPI_PERMSG,\n  CURLPX_GSSAPI_PROTECTION,\n  CURLPX_IDENTD,\n  CURLPX_IDENTD_DIFFER,\n  CURLPX_LONG_HOSTNAME,\n  CURLPX_LONG_PASSWD,\n  CURLPX_LONG_USER,\n  CURLPX_NO_AUTH,\n  CURLPX_RECV_ADDRESS,\n  CURLPX_RECV_AUTH,\n  CURLPX_RECV_CONNECT,\n  CURLPX_RECV_REQACK,\n  CURLPX_REPLY_ADDRESS_TYPE_NOT_SUPPORTED,\n  CURLPX_REPLY_COMMAND_NOT_SUPPORTED,\n  CURLPX_REPLY_CONNECTION_REFUSED,\n  CURLPX_REPLY_GENERAL_SERVER_FAILURE,\n  CURLPX_REPLY_HOST_UNREACHABLE,\n  CURLPX_REPLY_NETWORK_UNREACHABLE,\n  CURLPX_REPLY_NOT_ALLOWED,\n  CURLPX_REPLY_TTL_EXPIRED,\n  CURLPX_REPLY_UNASSIGNED,\n  CURLPX_REQUEST_FAILED,\n  CURLPX_RESOLVE_HOST,\n  CURLPX_SEND_AUTH,\n  CURLPX_SEND_CONNECT,\n  CURLPX_SEND_REQUEST,\n  CURLPX_UNKNOWN_FAIL,\n  CURLPX_UNKNOWN_MODE,\n  CURLPX_USER_REJECTED,\n  CURLPX_LAST /* never use */\n} CURLproxycode;\n\n/* This prototype applies to all conversion callbacks */\ntypedef CURLcode (*curl_conv_callback)(char *buffer, size_t length);\n\ntypedef CURLcode (*curl_ssl_ctx_callback)(CURL *curl,    /* easy handle */\n                                          void *ssl_ctx, /* actually an OpenSSL\n                                                            or WolfSSL SSL_CTX,\n                                                            or an mbedTLS\n                                                          mbedtls_ssl_config */\n                                          void *userptr);\n\ntypedef enum {\n  CURLPROXY_HTTP = 0,   /* added in 7.10, new in 7.19.4 default is to use\n                           CONNECT HTTP/1.1 */\n  CURLPROXY_HTTP_1_0 = 1,   /* added in 7.19.4, force to use CONNECT\n                               HTTP/1.0  */\n  CURLPROXY_HTTPS = 2, /* added in 7.52.0 */\n  CURLPROXY_SOCKS4 = 4, /* support added in 7.15.2, enum existed already\n                           in 7.10 */\n  CURLPROXY_SOCKS5 = 5, /* added in 7.10 */\n  CURLPROXY_SOCKS4A = 6, /* added in 7.18.0 */\n  CURLPROXY_SOCKS5_HOSTNAME = 7 /* Use the SOCKS5 protocol but pass along the\n                                   host name rather than the IP address. added\n                                   in 7.18.0 */\n} curl_proxytype;  /* this enum was added in 7.10 */\n\n/*\n * Bitmasks for CURLOPT_HTTPAUTH and CURLOPT_PROXYAUTH options:\n *\n * CURLAUTH_NONE         - No HTTP authentication\n * CURLAUTH_BASIC        - HTTP Basic authentication (default)\n * CURLAUTH_DIGEST       - HTTP Digest authentication\n * CURLAUTH_NEGOTIATE    - HTTP Negotiate (SPNEGO) authentication\n * CURLAUTH_GSSNEGOTIATE - Alias for CURLAUTH_NEGOTIATE (deprecated)\n * CURLAUTH_NTLM         - HTTP NTLM authentication\n * CURLAUTH_DIGEST_IE    - HTTP Digest authentication with IE flavour\n * CURLAUTH_NTLM_WB      - HTTP NTLM authentication delegated to winbind helper\n * CURLAUTH_BEARER       - HTTP Bearer token authentication\n * CURLAUTH_ONLY         - Use together with a single other type to force no\n *                         authentication or just that single type\n * CURLAUTH_ANY          - All fine types set\n * CURLAUTH_ANYSAFE      - All fine types except Basic\n */\n\n#define CURLAUTH_NONE         ((unsigned long)0)\n#define CURLAUTH_BASIC        (((unsigned long)1)<<0)\n#define CURLAUTH_DIGEST       (((unsigned long)1)<<1)\n#define CURLAUTH_NEGOTIATE    (((unsigned long)1)<<2)\n/* Deprecated since the advent of CURLAUTH_NEGOTIATE */\n#define CURLAUTH_GSSNEGOTIATE CURLAUTH_NEGOTIATE\n/* Used for CURLOPT_SOCKS5_AUTH to stay terminologically correct */\n#define CURLAUTH_GSSAPI CURLAUTH_NEGOTIATE\n#define CURLAUTH_NTLM         (((unsigned long)1)<<3)\n#define CURLAUTH_DIGEST_IE    (((unsigned long)1)<<4)\n#define CURLAUTH_NTLM_WB      (((unsigned long)1)<<5)\n#define CURLAUTH_BEARER       (((unsigned long)1)<<6)\n#define CURLAUTH_ONLY         (((unsigned long)1)<<31)\n#define CURLAUTH_ANY          (~CURLAUTH_DIGEST_IE)\n#define CURLAUTH_ANYSAFE      (~(CURLAUTH_BASIC|CURLAUTH_DIGEST_IE))\n\n#define CURLSSH_AUTH_ANY       ~0     /* all types supported by the server */\n#define CURLSSH_AUTH_NONE      0      /* none allowed, silly but complete */\n#define CURLSSH_AUTH_PUBLICKEY (1<<0) /* public/private key files */\n#define CURLSSH_AUTH_PASSWORD  (1<<1) /* password */\n#define CURLSSH_AUTH_HOST      (1<<2) /* host key files */\n#define CURLSSH_AUTH_KEYBOARD  (1<<3) /* keyboard interactive */\n#define CURLSSH_AUTH_AGENT     (1<<4) /* agent (ssh-agent, pageant...) */\n#define CURLSSH_AUTH_GSSAPI    (1<<5) /* gssapi (kerberos, ...) */\n#define CURLSSH_AUTH_DEFAULT CURLSSH_AUTH_ANY\n\n#define CURLGSSAPI_DELEGATION_NONE        0      /* no delegation (default) */\n#define CURLGSSAPI_DELEGATION_POLICY_FLAG (1<<0) /* if permitted by policy */\n#define CURLGSSAPI_DELEGATION_FLAG        (1<<1) /* delegate always */\n\n#define CURL_ERROR_SIZE 256\n\nenum curl_khtype {\n  CURLKHTYPE_UNKNOWN,\n  CURLKHTYPE_RSA1,\n  CURLKHTYPE_RSA,\n  CURLKHTYPE_DSS,\n  CURLKHTYPE_ECDSA,\n  CURLKHTYPE_ED25519\n};\n\nstruct curl_khkey {\n  const char *key; /* points to a null-terminated string encoded with base64\n                      if len is zero, otherwise to the \"raw\" data */\n  size_t len;\n  enum curl_khtype keytype;\n};\n\n/* this is the set of return values expected from the curl_sshkeycallback\n   callback */\nenum curl_khstat {\n  CURLKHSTAT_FINE_ADD_TO_FILE,\n  CURLKHSTAT_FINE,\n  CURLKHSTAT_REJECT, /* reject the connection, return an error */\n  CURLKHSTAT_DEFER,  /* do not accept it, but we can't answer right now so\n                        this causes a CURLE_DEFER error but otherwise the\n                        connection will be left intact etc */\n  CURLKHSTAT_FINE_REPLACE, /* accept and replace the wrong key*/\n  CURLKHSTAT_LAST    /* not for use, only a marker for last-in-list */\n};\n\n/* this is the set of status codes pass in to the callback */\nenum curl_khmatch {\n  CURLKHMATCH_OK,       /* match */\n  CURLKHMATCH_MISMATCH, /* host found, key mismatch! */\n  CURLKHMATCH_MISSING,  /* no matching host/key found */\n  CURLKHMATCH_LAST      /* not for use, only a marker for last-in-list */\n};\n\ntypedef int\n  (*curl_sshkeycallback) (CURL *easy,     /* easy handle */\n                          const struct curl_khkey *knownkey, /* known */\n                          const struct curl_khkey *foundkey, /* found */\n                          enum curl_khmatch, /* libcurl's view on the keys */\n                          void *clientp); /* custom pointer passed from app */\n\n/* parameter for the CURLOPT_USE_SSL option */\ntypedef enum {\n  CURLUSESSL_NONE,    /* do not attempt to use SSL */\n  CURLUSESSL_TRY,     /* try using SSL, proceed anyway otherwise */\n  CURLUSESSL_CONTROL, /* SSL for the control connection or fail */\n  CURLUSESSL_ALL,     /* SSL for all communication or fail */\n  CURLUSESSL_LAST     /* not an option, never use */\n} curl_usessl;\n\n/* Definition of bits for the CURLOPT_SSL_OPTIONS argument: */\n\n/* - ALLOW_BEAST tells libcurl to allow the BEAST SSL vulnerability in the\n   name of improving interoperability with older servers. Some SSL libraries\n   have introduced work-arounds for this flaw but those work-arounds sometimes\n   make the SSL communication fail. To regain functionality with those broken\n   servers, a user can this way allow the vulnerability back. */\n#define CURLSSLOPT_ALLOW_BEAST (1<<0)\n\n/* - NO_REVOKE tells libcurl to disable certificate revocation checks for those\n   SSL backends where such behavior is present. */\n#define CURLSSLOPT_NO_REVOKE (1<<1)\n\n/* - NO_PARTIALCHAIN tells libcurl to *NOT* accept a partial certificate chain\n   if possible. The OpenSSL backend has this ability. */\n#define CURLSSLOPT_NO_PARTIALCHAIN (1<<2)\n\n/* - REVOKE_BEST_EFFORT tells libcurl to ignore certificate revocation offline\n   checks and ignore missing revocation list for those SSL backends where such\n   behavior is present. */\n#define CURLSSLOPT_REVOKE_BEST_EFFORT (1<<3)\n\n/* - CURLSSLOPT_NATIVE_CA tells libcurl to use standard certificate store of\n   operating system. Currently implemented under MS-Windows. */\n#define CURLSSLOPT_NATIVE_CA (1<<4)\n\n/* The default connection attempt delay in milliseconds for happy eyeballs.\n   CURLOPT_HAPPY_EYEBALLS_TIMEOUT_MS.3 and happy-eyeballs-timeout-ms.d document\n   this value, keep them in sync. */\n#define CURL_HET_DEFAULT 200L\n\n/* The default connection upkeep interval in milliseconds. */\n#define CURL_UPKEEP_INTERVAL_DEFAULT 60000L\n\n#ifndef CURL_NO_OLDIES /* define this to test if your app builds with all\n                          the obsolete stuff removed! */\n\n/* Backwards compatibility with older names */\n/* These are scheduled to disappear by 2009 */\n\n#define CURLFTPSSL_NONE CURLUSESSL_NONE\n#define CURLFTPSSL_TRY CURLUSESSL_TRY\n#define CURLFTPSSL_CONTROL CURLUSESSL_CONTROL\n#define CURLFTPSSL_ALL CURLUSESSL_ALL\n#define CURLFTPSSL_LAST CURLUSESSL_LAST\n#define curl_ftpssl curl_usessl\n#endif /*!CURL_NO_OLDIES*/\n\n/* parameter for the CURLOPT_FTP_SSL_CCC option */\ntypedef enum {\n  CURLFTPSSL_CCC_NONE,    /* do not send CCC */\n  CURLFTPSSL_CCC_PASSIVE, /* Let the server initiate the shutdown */\n  CURLFTPSSL_CCC_ACTIVE,  /* Initiate the shutdown */\n  CURLFTPSSL_CCC_LAST     /* not an option, never use */\n} curl_ftpccc;\n\n/* parameter for the CURLOPT_FTPSSLAUTH option */\ntypedef enum {\n  CURLFTPAUTH_DEFAULT, /* let libcurl decide */\n  CURLFTPAUTH_SSL,     /* use \"AUTH SSL\" */\n  CURLFTPAUTH_TLS,     /* use \"AUTH TLS\" */\n  CURLFTPAUTH_LAST /* not an option, never use */\n} curl_ftpauth;\n\n/* parameter for the CURLOPT_FTP_CREATE_MISSING_DIRS option */\ntypedef enum {\n  CURLFTP_CREATE_DIR_NONE,  /* do NOT create missing dirs! */\n  CURLFTP_CREATE_DIR,       /* (FTP/SFTP) if CWD fails, try MKD and then CWD\n                               again if MKD succeeded, for SFTP this does\n                               similar magic */\n  CURLFTP_CREATE_DIR_RETRY, /* (FTP only) if CWD fails, try MKD and then CWD\n                               again even if MKD failed! */\n  CURLFTP_CREATE_DIR_LAST   /* not an option, never use */\n} curl_ftpcreatedir;\n\n/* parameter for the CURLOPT_FTP_FILEMETHOD option */\ntypedef enum {\n  CURLFTPMETHOD_DEFAULT,   /* let libcurl pick */\n  CURLFTPMETHOD_MULTICWD,  /* single CWD operation for each path part */\n  CURLFTPMETHOD_NOCWD,     /* no CWD at all */\n  CURLFTPMETHOD_SINGLECWD, /* one CWD to full dir, then work on file */\n  CURLFTPMETHOD_LAST       /* not an option, never use */\n} curl_ftpmethod;\n\n/* bitmask defines for CURLOPT_HEADEROPT */\n#define CURLHEADER_UNIFIED  0\n#define CURLHEADER_SEPARATE (1<<0)\n\n/* CURLALTSVC_* are bits for the CURLOPT_ALTSVC_CTRL option */\n#define CURLALTSVC_IMMEDIATELY  (1<<0)\n\n#define CURLALTSVC_READONLYFILE (1<<2)\n#define CURLALTSVC_H1           (1<<3)\n#define CURLALTSVC_H2           (1<<4)\n#define CURLALTSVC_H3           (1<<5)\n\n/* CURLPROTO_ defines are for the CURLOPT_*PROTOCOLS options */\n#define CURLPROTO_HTTP   (1<<0)\n#define CURLPROTO_HTTPS  (1<<1)\n#define CURLPROTO_FTP    (1<<2)\n#define CURLPROTO_FTPS   (1<<3)\n#define CURLPROTO_SCP    (1<<4)\n#define CURLPROTO_SFTP   (1<<5)\n#define CURLPROTO_TELNET (1<<6)\n#define CURLPROTO_LDAP   (1<<7)\n#define CURLPROTO_LDAPS  (1<<8)\n#define CURLPROTO_DICT   (1<<9)\n#define CURLPROTO_FILE   (1<<10)\n#define CURLPROTO_TFTP   (1<<11)\n#define CURLPROTO_IMAP   (1<<12)\n#define CURLPROTO_IMAPS  (1<<13)\n#define CURLPROTO_POP3   (1<<14)\n#define CURLPROTO_POP3S  (1<<15)\n#define CURLPROTO_SMTP   (1<<16)\n#define CURLPROTO_SMTPS  (1<<17)\n#define CURLPROTO_RTSP   (1<<18)\n#define CURLPROTO_RTMP   (1<<19)\n#define CURLPROTO_RTMPT  (1<<20)\n#define CURLPROTO_RTMPE  (1<<21)\n#define CURLPROTO_RTMPTE (1<<22)\n#define CURLPROTO_RTMPS  (1<<23)\n#define CURLPROTO_RTMPTS (1<<24)\n#define CURLPROTO_GOPHER (1<<25)\n#define CURLPROTO_SMB    (1<<26)\n#define CURLPROTO_SMBS   (1<<27)\n#define CURLPROTO_MQTT   (1<<28)\n#define CURLPROTO_ALL    (~0) /* enable everything */\n\n/* long may be 32 or 64 bits, but we should never depend on anything else\n   but 32 */\n#define CURLOPTTYPE_LONG          0\n#define CURLOPTTYPE_OBJECTPOINT   10000\n#define CURLOPTTYPE_FUNCTIONPOINT 20000\n#define CURLOPTTYPE_OFF_T         30000\n#define CURLOPTTYPE_BLOB          40000\n\n/* *STRINGPOINT is an alias for OBJECTPOINT to allow tools to extract the\n   string options from the header file */\n\n\n#define CURLOPT(na,t,nu) na = t + nu\n\n/* CURLOPT aliases that make no run-time difference */\n\n/* 'char *' argument to a string with a trailing zero */\n#define CURLOPTTYPE_STRINGPOINT CURLOPTTYPE_OBJECTPOINT\n\n/* 'struct curl_slist *' argument */\n#define CURLOPTTYPE_SLISTPOINT  CURLOPTTYPE_OBJECTPOINT\n\n/* 'void *' argument passed untouched to callback */\n#define CURLOPTTYPE_CBPOINT     CURLOPTTYPE_OBJECTPOINT\n\n/* 'long' argument with a set of values/bitmask */\n#define CURLOPTTYPE_VALUES      CURLOPTTYPE_LONG\n\n/*\n * All CURLOPT_* values.\n */\n\ntypedef enum {\n  /* This is the FILE * or void * the regular output should be written to. */\n  CURLOPT(CURLOPT_WRITEDATA, CURLOPTTYPE_CBPOINT, 1),\n\n  /* The full URL to get/put */\n  CURLOPT(CURLOPT_URL, CURLOPTTYPE_STRINGPOINT, 2),\n\n  /* Port number to connect to, if other than default. */\n  CURLOPT(CURLOPT_PORT, CURLOPTTYPE_LONG, 3),\n\n  /* Name of proxy to use. */\n  CURLOPT(CURLOPT_PROXY, CURLOPTTYPE_STRINGPOINT, 4),\n\n  /* \"user:password;options\" to use when fetching. */\n  CURLOPT(CURLOPT_USERPWD, CURLOPTTYPE_STRINGPOINT, 5),\n\n  /* \"user:password\" to use with proxy. */\n  CURLOPT(CURLOPT_PROXYUSERPWD, CURLOPTTYPE_STRINGPOINT, 6),\n\n  /* Range to get, specified as an ASCII string. */\n  CURLOPT(CURLOPT_RANGE, CURLOPTTYPE_STRINGPOINT, 7),\n\n  /* not used */\n\n  /* Specified file stream to upload from (use as input): */\n  CURLOPT(CURLOPT_READDATA, CURLOPTTYPE_CBPOINT, 9),\n\n  /* Buffer to receive error messages in, must be at least CURL_ERROR_SIZE\n   * bytes big. */\n  CURLOPT(CURLOPT_ERRORBUFFER, CURLOPTTYPE_OBJECTPOINT, 10),\n\n  /* Function that will be called to store the output (instead of fwrite). The\n   * parameters will use fwrite() syntax, make sure to follow them. */\n  CURLOPT(CURLOPT_WRITEFUNCTION, CURLOPTTYPE_FUNCTIONPOINT, 11),\n\n  /* Function that will be called to read the input (instead of fread). The\n   * parameters will use fread() syntax, make sure to follow them. */\n  CURLOPT(CURLOPT_READFUNCTION, CURLOPTTYPE_FUNCTIONPOINT, 12),\n\n  /* Time-out the read operation after this amount of seconds */\n  CURLOPT(CURLOPT_TIMEOUT, CURLOPTTYPE_LONG, 13),\n\n  /* If the CURLOPT_INFILE is used, this can be used to inform libcurl about\n   * how large the file being sent really is. That allows better error\n   * checking and better verifies that the upload was successful. -1 means\n   * unknown size.\n   *\n   * For large file support, there is also a _LARGE version of the key\n   * which takes an off_t type, allowing platforms with larger off_t\n   * sizes to handle larger files.  See below for INFILESIZE_LARGE.\n   */\n  CURLOPT(CURLOPT_INFILESIZE, CURLOPTTYPE_LONG, 14),\n\n  /* POST static input fields. */\n  CURLOPT(CURLOPT_POSTFIELDS, CURLOPTTYPE_OBJECTPOINT, 15),\n\n  /* Set the referrer page (needed by some CGIs) */\n  CURLOPT(CURLOPT_REFERER, CURLOPTTYPE_STRINGPOINT, 16),\n\n  /* Set the FTP PORT string (interface name, named or numerical IP address)\n     Use i.e '-' to use default address. */\n  CURLOPT(CURLOPT_FTPPORT, CURLOPTTYPE_STRINGPOINT, 17),\n\n  /* Set the User-Agent string (examined by some CGIs) */\n  CURLOPT(CURLOPT_USERAGENT, CURLOPTTYPE_STRINGPOINT, 18),\n\n  /* If the download receives less than \"low speed limit\" bytes/second\n   * during \"low speed time\" seconds, the operations is aborted.\n   * You could i.e if you have a pretty high speed connection, abort if\n   * it is less than 2000 bytes/sec during 20 seconds.\n   */\n\n  /* Set the \"low speed limit\" */\n  CURLOPT(CURLOPT_LOW_SPEED_LIMIT, CURLOPTTYPE_LONG, 19),\n\n  /* Set the \"low speed time\" */\n  CURLOPT(CURLOPT_LOW_SPEED_TIME, CURLOPTTYPE_LONG, 20),\n\n  /* Set the continuation offset.\n   *\n   * Note there is also a _LARGE version of this key which uses\n   * off_t types, allowing for large file offsets on platforms which\n   * use larger-than-32-bit off_t's.  Look below for RESUME_FROM_LARGE.\n   */\n  CURLOPT(CURLOPT_RESUME_FROM, CURLOPTTYPE_LONG, 21),\n\n  /* Set cookie in request: */\n  CURLOPT(CURLOPT_COOKIE, CURLOPTTYPE_STRINGPOINT, 22),\n\n  /* This points to a linked list of headers, struct curl_slist kind. This\n     list is also used for RTSP (in spite of its name) */\n  CURLOPT(CURLOPT_HTTPHEADER, CURLOPTTYPE_SLISTPOINT, 23),\n\n  /* This points to a linked list of post entries, struct curl_httppost */\n  CURLOPT(CURLOPT_HTTPPOST, CURLOPTTYPE_OBJECTPOINT, 24),\n\n  /* name of the file keeping your private SSL-certificate */\n  CURLOPT(CURLOPT_SSLCERT, CURLOPTTYPE_STRINGPOINT, 25),\n\n  /* password for the SSL or SSH private key */\n  CURLOPT(CURLOPT_KEYPASSWD, CURLOPTTYPE_STRINGPOINT, 26),\n\n  /* send TYPE parameter? */\n  CURLOPT(CURLOPT_CRLF, CURLOPTTYPE_LONG, 27),\n\n  /* send linked-list of QUOTE commands */\n  CURLOPT(CURLOPT_QUOTE, CURLOPTTYPE_SLISTPOINT, 28),\n\n  /* send FILE * or void * to store headers to, if you use a callback it\n     is simply passed to the callback unmodified */\n  CURLOPT(CURLOPT_HEADERDATA, CURLOPTTYPE_CBPOINT, 29),\n\n  /* point to a file to read the initial cookies from, also enables\n     \"cookie awareness\" */\n  CURLOPT(CURLOPT_COOKIEFILE, CURLOPTTYPE_STRINGPOINT, 31),\n\n  /* What version to specifically try to use.\n     See CURL_SSLVERSION defines below. */\n  CURLOPT(CURLOPT_SSLVERSION, CURLOPTTYPE_VALUES, 32),\n\n  /* What kind of HTTP time condition to use, see defines */\n  CURLOPT(CURLOPT_TIMECONDITION, CURLOPTTYPE_VALUES, 33),\n\n  /* Time to use with the above condition. Specified in number of seconds\n     since 1 Jan 1970 */\n  CURLOPT(CURLOPT_TIMEVALUE, CURLOPTTYPE_LONG, 34),\n\n  /* 35 = OBSOLETE */\n\n  /* Custom request, for customizing the get command like\n     HTTP: DELETE, TRACE and others\n     FTP: to use a different list command\n     */\n  CURLOPT(CURLOPT_CUSTOMREQUEST, CURLOPTTYPE_STRINGPOINT, 36),\n\n  /* FILE handle to use instead of stderr */\n  CURLOPT(CURLOPT_STDERR, CURLOPTTYPE_OBJECTPOINT, 37),\n\n  /* 38 is not used */\n\n  /* send linked-list of post-transfer QUOTE commands */\n  CURLOPT(CURLOPT_POSTQUOTE, CURLOPTTYPE_SLISTPOINT, 39),\n\n   /* OBSOLETE, do not use! */\n  CURLOPT(CURLOPT_OBSOLETE40, CURLOPTTYPE_OBJECTPOINT, 40),\n\n  /* talk a lot */\n  CURLOPT(CURLOPT_VERBOSE, CURLOPTTYPE_LONG, 41),\n\n  /* throw the header out too */\n  CURLOPT(CURLOPT_HEADER, CURLOPTTYPE_LONG, 42),\n\n  /* shut off the progress meter */\n  CURLOPT(CURLOPT_NOPROGRESS, CURLOPTTYPE_LONG, 43),\n\n  /* use HEAD to get http document */\n  CURLOPT(CURLOPT_NOBODY, CURLOPTTYPE_LONG, 44),\n\n  /* no output on http error codes >= 400 */\n  CURLOPT(CURLOPT_FAILONERROR, CURLOPTTYPE_LONG, 45),\n\n  /* this is an upload */\n  CURLOPT(CURLOPT_UPLOAD, CURLOPTTYPE_LONG, 46),\n\n  /* HTTP POST method */\n  CURLOPT(CURLOPT_POST, CURLOPTTYPE_LONG, 47),\n\n  /* bare names when listing directories */\n  CURLOPT(CURLOPT_DIRLISTONLY, CURLOPTTYPE_LONG, 48),\n\n  /* Append instead of overwrite on upload! */\n  CURLOPT(CURLOPT_APPEND, CURLOPTTYPE_LONG, 50),\n\n  /* Specify whether to read the user+password from the .netrc or the URL.\n   * This must be one of the CURL_NETRC_* enums below. */\n  CURLOPT(CURLOPT_NETRC, CURLOPTTYPE_VALUES, 51),\n\n  /* use Location: Luke! */\n  CURLOPT(CURLOPT_FOLLOWLOCATION, CURLOPTTYPE_LONG, 52),\n\n   /* transfer data in text/ASCII format */\n  CURLOPT(CURLOPT_TRANSFERTEXT, CURLOPTTYPE_LONG, 53),\n\n  /* HTTP PUT */\n  CURLOPT(CURLOPT_PUT, CURLOPTTYPE_LONG, 54),\n\n  /* 55 = OBSOLETE */\n\n  /* DEPRECATED\n   * Function that will be called instead of the internal progress display\n   * function. This function should be defined as the curl_progress_callback\n   * prototype defines. */\n  CURLOPT(CURLOPT_PROGRESSFUNCTION, CURLOPTTYPE_FUNCTIONPOINT, 56),\n\n  /* Data passed to the CURLOPT_PROGRESSFUNCTION and CURLOPT_XFERINFOFUNCTION\n     callbacks */\n  CURLOPT(CURLOPT_XFERINFODATA, CURLOPTTYPE_CBPOINT, 57),\n#define CURLOPT_PROGRESSDATA CURLOPT_XFERINFODATA\n\n  /* We want the referrer field set automatically when following locations */\n  CURLOPT(CURLOPT_AUTOREFERER, CURLOPTTYPE_LONG, 58),\n\n  /* Port of the proxy, can be set in the proxy string as well with:\n     \"[host]:[port]\" */\n  CURLOPT(CURLOPT_PROXYPORT, CURLOPTTYPE_LONG, 59),\n\n  /* size of the POST input data, if strlen() is not good to use */\n  CURLOPT(CURLOPT_POSTFIELDSIZE, CURLOPTTYPE_LONG, 60),\n\n  /* tunnel non-http operations through a HTTP proxy */\n  CURLOPT(CURLOPT_HTTPPROXYTUNNEL, CURLOPTTYPE_LONG, 61),\n\n  /* Set the interface string to use as outgoing network interface */\n  CURLOPT(CURLOPT_INTERFACE, CURLOPTTYPE_STRINGPOINT, 62),\n\n  /* Set the krb4/5 security level, this also enables krb4/5 awareness.  This\n   * is a string, 'clear', 'safe', 'confidential' or 'private'.  If the string\n   * is set but doesn't match one of these, 'private' will be used.  */\n  CURLOPT(CURLOPT_KRBLEVEL, CURLOPTTYPE_STRINGPOINT, 63),\n\n  /* Set if we should verify the peer in ssl handshake, set 1 to verify. */\n  CURLOPT(CURLOPT_SSL_VERIFYPEER, CURLOPTTYPE_LONG, 64),\n\n  /* The CApath or CAfile used to validate the peer certificate\n     this option is used only if SSL_VERIFYPEER is true */\n  CURLOPT(CURLOPT_CAINFO, CURLOPTTYPE_STRINGPOINT, 65),\n\n  /* 66 = OBSOLETE */\n  /* 67 = OBSOLETE */\n\n  /* Maximum number of http redirects to follow */\n  CURLOPT(CURLOPT_MAXREDIRS, CURLOPTTYPE_LONG, 68),\n\n  /* Pass a long set to 1 to get the date of the requested document (if\n     possible)! Pass a zero to shut it off. */\n  CURLOPT(CURLOPT_FILETIME, CURLOPTTYPE_LONG, 69),\n\n  /* This points to a linked list of telnet options */\n  CURLOPT(CURLOPT_TELNETOPTIONS, CURLOPTTYPE_SLISTPOINT, 70),\n\n  /* Max amount of cached alive connections */\n  CURLOPT(CURLOPT_MAXCONNECTS, CURLOPTTYPE_LONG, 71),\n\n  /* OBSOLETE, do not use! */\n  CURLOPT(CURLOPT_OBSOLETE72, CURLOPTTYPE_LONG, 72),\n\n  /* 73 = OBSOLETE */\n\n  /* Set to explicitly use a new connection for the upcoming transfer.\n     Do not use this unless you're absolutely sure of this, as it makes the\n     operation slower and is less friendly for the network. */\n  CURLOPT(CURLOPT_FRESH_CONNECT, CURLOPTTYPE_LONG, 74),\n\n  /* Set to explicitly forbid the upcoming transfer's connection to be re-used\n     when done. Do not use this unless you're absolutely sure of this, as it\n     makes the operation slower and is less friendly for the network. */\n  CURLOPT(CURLOPT_FORBID_REUSE, CURLOPTTYPE_LONG, 75),\n\n  /* Set to a file name that contains random data for libcurl to use to\n     seed the random engine when doing SSL connects. */\n  CURLOPT(CURLOPT_RANDOM_FILE, CURLOPTTYPE_STRINGPOINT, 76),\n\n  /* Set to the Entropy Gathering Daemon socket pathname */\n  CURLOPT(CURLOPT_EGDSOCKET, CURLOPTTYPE_STRINGPOINT, 77),\n\n  /* Time-out connect operations after this amount of seconds, if connects are\n     OK within this time, then fine... This only aborts the connect phase. */\n  CURLOPT(CURLOPT_CONNECTTIMEOUT, CURLOPTTYPE_LONG, 78),\n\n  /* Function that will be called to store headers (instead of fwrite). The\n   * parameters will use fwrite() syntax, make sure to follow them. */\n  CURLOPT(CURLOPT_HEADERFUNCTION, CURLOPTTYPE_FUNCTIONPOINT, 79),\n\n  /* Set this to force the HTTP request to get back to GET. Only really usable\n     if POST, PUT or a custom request have been used first.\n   */\n  CURLOPT(CURLOPT_HTTPGET, CURLOPTTYPE_LONG, 80),\n\n  /* Set if we should verify the Common name from the peer certificate in ssl\n   * handshake, set 1 to check existence, 2 to ensure that it matches the\n   * provided hostname. */\n  CURLOPT(CURLOPT_SSL_VERIFYHOST, CURLOPTTYPE_LONG, 81),\n\n  /* Specify which file name to write all known cookies in after completed\n     operation. Set file name to \"-\" (dash) to make it go to stdout. */\n  CURLOPT(CURLOPT_COOKIEJAR, CURLOPTTYPE_STRINGPOINT, 82),\n\n  /* Specify which SSL ciphers to use */\n  CURLOPT(CURLOPT_SSL_CIPHER_LIST, CURLOPTTYPE_STRINGPOINT, 83),\n\n  /* Specify which HTTP version to use! This must be set to one of the\n     CURL_HTTP_VERSION* enums set below. */\n  CURLOPT(CURLOPT_HTTP_VERSION, CURLOPTTYPE_VALUES, 84),\n\n  /* Specifically switch on or off the FTP engine's use of the EPSV command. By\n     default, that one will always be attempted before the more traditional\n     PASV command. */\n  CURLOPT(CURLOPT_FTP_USE_EPSV, CURLOPTTYPE_LONG, 85),\n\n  /* type of the file keeping your SSL-certificate (\"DER\", \"PEM\", \"ENG\") */\n  CURLOPT(CURLOPT_SSLCERTTYPE, CURLOPTTYPE_STRINGPOINT, 86),\n\n  /* name of the file keeping your private SSL-key */\n  CURLOPT(CURLOPT_SSLKEY, CURLOPTTYPE_STRINGPOINT, 87),\n\n  /* type of the file keeping your private SSL-key (\"DER\", \"PEM\", \"ENG\") */\n  CURLOPT(CURLOPT_SSLKEYTYPE, CURLOPTTYPE_STRINGPOINT, 88),\n\n  /* crypto engine for the SSL-sub system */\n  CURLOPT(CURLOPT_SSLENGINE, CURLOPTTYPE_STRINGPOINT, 89),\n\n  /* set the crypto engine for the SSL-sub system as default\n     the param has no meaning...\n   */\n  CURLOPT(CURLOPT_SSLENGINE_DEFAULT, CURLOPTTYPE_LONG, 90),\n\n  /* Non-zero value means to use the global dns cache */\n  /* DEPRECATED, do not use! */\n  CURLOPT(CURLOPT_DNS_USE_GLOBAL_CACHE, CURLOPTTYPE_LONG, 91),\n\n  /* DNS cache timeout */\n  CURLOPT(CURLOPT_DNS_CACHE_TIMEOUT, CURLOPTTYPE_LONG, 92),\n\n  /* send linked-list of pre-transfer QUOTE commands */\n  CURLOPT(CURLOPT_PREQUOTE, CURLOPTTYPE_SLISTPOINT, 93),\n\n  /* set the debug function */\n  CURLOPT(CURLOPT_DEBUGFUNCTION, CURLOPTTYPE_FUNCTIONPOINT, 94),\n\n  /* set the data for the debug function */\n  CURLOPT(CURLOPT_DEBUGDATA, CURLOPTTYPE_CBPOINT, 95),\n\n  /* mark this as start of a cookie session */\n  CURLOPT(CURLOPT_COOKIESESSION, CURLOPTTYPE_LONG, 96),\n\n  /* The CApath directory used to validate the peer certificate\n     this option is used only if SSL_VERIFYPEER is true */\n  CURLOPT(CURLOPT_CAPATH, CURLOPTTYPE_STRINGPOINT, 97),\n\n  /* Instruct libcurl to use a smaller receive buffer */\n  CURLOPT(CURLOPT_BUFFERSIZE, CURLOPTTYPE_LONG, 98),\n\n  /* Instruct libcurl to not use any signal/alarm handlers, even when using\n     timeouts. This option is useful for multi-threaded applications.\n     See libcurl-the-guide for more background information. */\n  CURLOPT(CURLOPT_NOSIGNAL, CURLOPTTYPE_LONG, 99),\n\n  /* Provide a CURLShare for mutexing non-ts data */\n  CURLOPT(CURLOPT_SHARE, CURLOPTTYPE_OBJECTPOINT, 100),\n\n  /* indicates type of proxy. accepted values are CURLPROXY_HTTP (default),\n     CURLPROXY_HTTPS, CURLPROXY_SOCKS4, CURLPROXY_SOCKS4A and\n     CURLPROXY_SOCKS5. */\n  CURLOPT(CURLOPT_PROXYTYPE, CURLOPTTYPE_VALUES, 101),\n\n  /* Set the Accept-Encoding string. Use this to tell a server you would like\n     the response to be compressed. Before 7.21.6, this was known as\n     CURLOPT_ENCODING */\n  CURLOPT(CURLOPT_ACCEPT_ENCODING, CURLOPTTYPE_STRINGPOINT, 102),\n\n  /* Set pointer to private data */\n  CURLOPT(CURLOPT_PRIVATE, CURLOPTTYPE_OBJECTPOINT, 103),\n\n  /* Set aliases for HTTP 200 in the HTTP Response header */\n  CURLOPT(CURLOPT_HTTP200ALIASES, CURLOPTTYPE_SLISTPOINT, 104),\n\n  /* Continue to send authentication (user+password) when following locations,\n     even when hostname changed. This can potentially send off the name\n     and password to whatever host the server decides. */\n  CURLOPT(CURLOPT_UNRESTRICTED_AUTH, CURLOPTTYPE_LONG, 105),\n\n  /* Specifically switch on or off the FTP engine's use of the EPRT command (\n     it also disables the LPRT attempt). By default, those ones will always be\n     attempted before the good old traditional PORT command. */\n  CURLOPT(CURLOPT_FTP_USE_EPRT, CURLOPTTYPE_LONG, 106),\n\n  /* Set this to a bitmask value to enable the particular authentications\n     methods you like. Use this in combination with CURLOPT_USERPWD.\n     Note that setting multiple bits may cause extra network round-trips. */\n  CURLOPT(CURLOPT_HTTPAUTH, CURLOPTTYPE_VALUES, 107),\n\n  /* Set the ssl context callback function, currently only for OpenSSL or\n     WolfSSL ssl_ctx, or mbedTLS mbedtls_ssl_config in the second argument.\n     The function must match the curl_ssl_ctx_callback prototype. */\n  CURLOPT(CURLOPT_SSL_CTX_FUNCTION, CURLOPTTYPE_FUNCTIONPOINT, 108),\n\n  /* Set the userdata for the ssl context callback function's third\n     argument */\n  CURLOPT(CURLOPT_SSL_CTX_DATA, CURLOPTTYPE_CBPOINT, 109),\n\n  /* FTP Option that causes missing dirs to be created on the remote server.\n     In 7.19.4 we introduced the convenience enums for this option using the\n     CURLFTP_CREATE_DIR prefix.\n  */\n  CURLOPT(CURLOPT_FTP_CREATE_MISSING_DIRS, CURLOPTTYPE_LONG, 110),\n\n  /* Set this to a bitmask value to enable the particular authentications\n     methods you like. Use this in combination with CURLOPT_PROXYUSERPWD.\n     Note that setting multiple bits may cause extra network round-trips. */\n  CURLOPT(CURLOPT_PROXYAUTH, CURLOPTTYPE_VALUES, 111),\n\n  /* FTP option that changes the timeout, in seconds, associated with\n     getting a response.  This is different from transfer timeout time and\n     essentially places a demand on the FTP server to acknowledge commands\n     in a timely manner. */\n  CURLOPT(CURLOPT_FTP_RESPONSE_TIMEOUT, CURLOPTTYPE_LONG, 112),\n#define CURLOPT_SERVER_RESPONSE_TIMEOUT CURLOPT_FTP_RESPONSE_TIMEOUT\n\n  /* Set this option to one of the CURL_IPRESOLVE_* defines (see below) to\n     tell libcurl to resolve names to those IP versions only. This only has\n     affect on systems with support for more than one, i.e IPv4 _and_ IPv6. */\n  CURLOPT(CURLOPT_IPRESOLVE, CURLOPTTYPE_VALUES, 113),\n\n  /* Set this option to limit the size of a file that will be downloaded from\n     an HTTP or FTP server.\n\n     Note there is also _LARGE version which adds large file support for\n     platforms which have larger off_t sizes.  See MAXFILESIZE_LARGE below. */\n  CURLOPT(CURLOPT_MAXFILESIZE, CURLOPTTYPE_LONG, 114),\n\n  /* See the comment for INFILESIZE above, but in short, specifies\n   * the size of the file being uploaded.  -1 means unknown.\n   */\n  CURLOPT(CURLOPT_INFILESIZE_LARGE, CURLOPTTYPE_OFF_T, 115),\n\n  /* Sets the continuation offset.  There is also a CURLOPTTYPE_LONG version\n   * of this; look above for RESUME_FROM.\n   */\n  CURLOPT(CURLOPT_RESUME_FROM_LARGE, CURLOPTTYPE_OFF_T, 116),\n\n  /* Sets the maximum size of data that will be downloaded from\n   * an HTTP or FTP server.  See MAXFILESIZE above for the LONG version.\n   */\n  CURLOPT(CURLOPT_MAXFILESIZE_LARGE, CURLOPTTYPE_OFF_T, 117),\n\n  /* Set this option to the file name of your .netrc file you want libcurl\n     to parse (using the CURLOPT_NETRC option). If not set, libcurl will do\n     a poor attempt to find the user's home directory and check for a .netrc\n     file in there. */\n  CURLOPT(CURLOPT_NETRC_FILE, CURLOPTTYPE_STRINGPOINT, 118),\n\n  /* Enable SSL/TLS for FTP, pick one of:\n     CURLUSESSL_TRY     - try using SSL, proceed anyway otherwise\n     CURLUSESSL_CONTROL - SSL for the control connection or fail\n     CURLUSESSL_ALL     - SSL for all communication or fail\n  */\n  CURLOPT(CURLOPT_USE_SSL, CURLOPTTYPE_VALUES, 119),\n\n  /* The _LARGE version of the standard POSTFIELDSIZE option */\n  CURLOPT(CURLOPT_POSTFIELDSIZE_LARGE, CURLOPTTYPE_OFF_T, 120),\n\n  /* Enable/disable the TCP Nagle algorithm */\n  CURLOPT(CURLOPT_TCP_NODELAY, CURLOPTTYPE_LONG, 121),\n\n  /* 122 OBSOLETE, used in 7.12.3. Gone in 7.13.0 */\n  /* 123 OBSOLETE. Gone in 7.16.0 */\n  /* 124 OBSOLETE, used in 7.12.3. Gone in 7.13.0 */\n  /* 125 OBSOLETE, used in 7.12.3. Gone in 7.13.0 */\n  /* 126 OBSOLETE, used in 7.12.3. Gone in 7.13.0 */\n  /* 127 OBSOLETE. Gone in 7.16.0 */\n  /* 128 OBSOLETE. Gone in 7.16.0 */\n\n  /* When FTP over SSL/TLS is selected (with CURLOPT_USE_SSL), this option\n     can be used to change libcurl's default action which is to first try\n     \"AUTH SSL\" and then \"AUTH TLS\" in this order, and proceed when a OK\n     response has been received.\n\n     Available parameters are:\n     CURLFTPAUTH_DEFAULT - let libcurl decide\n     CURLFTPAUTH_SSL     - try \"AUTH SSL\" first, then TLS\n     CURLFTPAUTH_TLS     - try \"AUTH TLS\" first, then SSL\n  */\n  CURLOPT(CURLOPT_FTPSSLAUTH, CURLOPTTYPE_VALUES, 129),\n\n  CURLOPT(CURLOPT_IOCTLFUNCTION, CURLOPTTYPE_FUNCTIONPOINT, 130),\n  CURLOPT(CURLOPT_IOCTLDATA, CURLOPTTYPE_CBPOINT, 131),\n\n  /* 132 OBSOLETE. Gone in 7.16.0 */\n  /* 133 OBSOLETE. Gone in 7.16.0 */\n\n  /* null-terminated string for pass on to the FTP server when asked for\n     \"account\" info */\n  CURLOPT(CURLOPT_FTP_ACCOUNT, CURLOPTTYPE_STRINGPOINT, 134),\n\n  /* feed cookie into cookie engine */\n  CURLOPT(CURLOPT_COOKIELIST, CURLOPTTYPE_STRINGPOINT, 135),\n\n  /* ignore Content-Length */\n  CURLOPT(CURLOPT_IGNORE_CONTENT_LENGTH, CURLOPTTYPE_LONG, 136),\n\n  /* Set to non-zero to skip the IP address received in a 227 PASV FTP server\n     response. Typically used for FTP-SSL purposes but is not restricted to\n     that. libcurl will then instead use the same IP address it used for the\n     control connection. */\n  CURLOPT(CURLOPT_FTP_SKIP_PASV_IP, CURLOPTTYPE_LONG, 137),\n\n  /* Select \"file method\" to use when doing FTP, see the curl_ftpmethod\n     above. */\n  CURLOPT(CURLOPT_FTP_FILEMETHOD, CURLOPTTYPE_VALUES, 138),\n\n  /* Local port number to bind the socket to */\n  CURLOPT(CURLOPT_LOCALPORT, CURLOPTTYPE_LONG, 139),\n\n  /* Number of ports to try, including the first one set with LOCALPORT.\n     Thus, setting it to 1 will make no additional attempts but the first.\n  */\n  CURLOPT(CURLOPT_LOCALPORTRANGE, CURLOPTTYPE_LONG, 140),\n\n  /* no transfer, set up connection and let application use the socket by\n     extracting it with CURLINFO_LASTSOCKET */\n  CURLOPT(CURLOPT_CONNECT_ONLY, CURLOPTTYPE_LONG, 141),\n\n  /* Function that will be called to convert from the\n     network encoding (instead of using the iconv calls in libcurl) */\n  CURLOPT(CURLOPT_CONV_FROM_NETWORK_FUNCTION, CURLOPTTYPE_FUNCTIONPOINT, 142),\n\n  /* Function that will be called to convert to the\n     network encoding (instead of using the iconv calls in libcurl) */\n  CURLOPT(CURLOPT_CONV_TO_NETWORK_FUNCTION, CURLOPTTYPE_FUNCTIONPOINT, 143),\n\n  /* Function that will be called to convert from UTF8\n     (instead of using the iconv calls in libcurl)\n     Note that this is used only for SSL certificate processing */\n  CURLOPT(CURLOPT_CONV_FROM_UTF8_FUNCTION, CURLOPTTYPE_FUNCTIONPOINT, 144),\n\n  /* if the connection proceeds too quickly then need to slow it down */\n  /* limit-rate: maximum number of bytes per second to send or receive */\n  CURLOPT(CURLOPT_MAX_SEND_SPEED_LARGE, CURLOPTTYPE_OFF_T, 145),\n  CURLOPT(CURLOPT_MAX_RECV_SPEED_LARGE, CURLOPTTYPE_OFF_T, 146),\n\n  /* Pointer to command string to send if USER/PASS fails. */\n  CURLOPT(CURLOPT_FTP_ALTERNATIVE_TO_USER, CURLOPTTYPE_STRINGPOINT, 147),\n\n  /* callback function for setting socket options */\n  CURLOPT(CURLOPT_SOCKOPTFUNCTION, CURLOPTTYPE_FUNCTIONPOINT, 148),\n  CURLOPT(CURLOPT_SOCKOPTDATA, CURLOPTTYPE_CBPOINT, 149),\n\n  /* set to 0 to disable session ID re-use for this transfer, default is\n     enabled (== 1) */\n  CURLOPT(CURLOPT_SSL_SESSIONID_CACHE, CURLOPTTYPE_LONG, 150),\n\n  /* allowed SSH authentication methods */\n  CURLOPT(CURLOPT_SSH_AUTH_TYPES, CURLOPTTYPE_VALUES, 151),\n\n  /* Used by scp/sftp to do public/private key authentication */\n  CURLOPT(CURLOPT_SSH_PUBLIC_KEYFILE, CURLOPTTYPE_STRINGPOINT, 152),\n  CURLOPT(CURLOPT_SSH_PRIVATE_KEYFILE, CURLOPTTYPE_STRINGPOINT, 153),\n\n  /* Send CCC (Clear Command Channel) after authentication */\n  CURLOPT(CURLOPT_FTP_SSL_CCC, CURLOPTTYPE_LONG, 154),\n\n  /* Same as TIMEOUT and CONNECTTIMEOUT, but with ms resolution */\n  CURLOPT(CURLOPT_TIMEOUT_MS, CURLOPTTYPE_LONG, 155),\n  CURLOPT(CURLOPT_CONNECTTIMEOUT_MS, CURLOPTTYPE_LONG, 156),\n\n  /* set to zero to disable the libcurl's decoding and thus pass the raw body\n     data to the application even when it is encoded/compressed */\n  CURLOPT(CURLOPT_HTTP_TRANSFER_DECODING, CURLOPTTYPE_LONG, 157),\n  CURLOPT(CURLOPT_HTTP_CONTENT_DECODING, CURLOPTTYPE_LONG, 158),\n\n  /* Permission used when creating new files and directories on the remote\n     server for protocols that support it, SFTP/SCP/FILE */\n  CURLOPT(CURLOPT_NEW_FILE_PERMS, CURLOPTTYPE_LONG, 159),\n  CURLOPT(CURLOPT_NEW_DIRECTORY_PERMS, CURLOPTTYPE_LONG, 160),\n\n  /* Set the behaviour of POST when redirecting. Values must be set to one\n     of CURL_REDIR* defines below. This used to be called CURLOPT_POST301 */\n  CURLOPT(CURLOPT_POSTREDIR, CURLOPTTYPE_VALUES, 161),\n\n  /* used by scp/sftp to verify the host's public key */\n  CURLOPT(CURLOPT_SSH_HOST_PUBLIC_KEY_MD5, CURLOPTTYPE_STRINGPOINT, 162),\n\n  /* Callback function for opening socket (instead of socket(2)). Optionally,\n     callback is able change the address or refuse to connect returning\n     CURL_SOCKET_BAD.  The callback should have type\n     curl_opensocket_callback */\n  CURLOPT(CURLOPT_OPENSOCKETFUNCTION, CURLOPTTYPE_FUNCTIONPOINT, 163),\n  CURLOPT(CURLOPT_OPENSOCKETDATA, CURLOPTTYPE_CBPOINT, 164),\n\n  /* POST volatile input fields. */\n  CURLOPT(CURLOPT_COPYPOSTFIELDS, CURLOPTTYPE_OBJECTPOINT, 165),\n\n  /* set transfer mode (;type=<a|i>) when doing FTP via an HTTP proxy */\n  CURLOPT(CURLOPT_PROXY_TRANSFER_MODE, CURLOPTTYPE_LONG, 166),\n\n  /* Callback function for seeking in the input stream */\n  CURLOPT(CURLOPT_SEEKFUNCTION, CURLOPTTYPE_FUNCTIONPOINT, 167),\n  CURLOPT(CURLOPT_SEEKDATA, CURLOPTTYPE_CBPOINT, 168),\n\n  /* CRL file */\n  CURLOPT(CURLOPT_CRLFILE, CURLOPTTYPE_STRINGPOINT, 169),\n\n  /* Issuer certificate */\n  CURLOPT(CURLOPT_ISSUERCERT, CURLOPTTYPE_STRINGPOINT, 170),\n\n  /* (IPv6) Address scope */\n  CURLOPT(CURLOPT_ADDRESS_SCOPE, CURLOPTTYPE_LONG, 171),\n\n  /* Collect certificate chain info and allow it to get retrievable with\n     CURLINFO_CERTINFO after the transfer is complete. */\n  CURLOPT(CURLOPT_CERTINFO, CURLOPTTYPE_LONG, 172),\n\n  /* \"name\" and \"pwd\" to use when fetching. */\n  CURLOPT(CURLOPT_USERNAME, CURLOPTTYPE_STRINGPOINT, 173),\n  CURLOPT(CURLOPT_PASSWORD, CURLOPTTYPE_STRINGPOINT, 174),\n\n    /* \"name\" and \"pwd\" to use with Proxy when fetching. */\n  CURLOPT(CURLOPT_PROXYUSERNAME, CURLOPTTYPE_STRINGPOINT, 175),\n  CURLOPT(CURLOPT_PROXYPASSWORD, CURLOPTTYPE_STRINGPOINT, 176),\n\n  /* Comma separated list of hostnames defining no-proxy zones. These should\n     match both hostnames directly, and hostnames within a domain. For\n     example, local.com will match local.com and www.local.com, but NOT\n     notlocal.com or www.notlocal.com. For compatibility with other\n     implementations of this, .local.com will be considered to be the same as\n     local.com. A single * is the only valid wildcard, and effectively\n     disables the use of proxy. */\n  CURLOPT(CURLOPT_NOPROXY, CURLOPTTYPE_STRINGPOINT, 177),\n\n  /* block size for TFTP transfers */\n  CURLOPT(CURLOPT_TFTP_BLKSIZE, CURLOPTTYPE_LONG, 178),\n\n  /* Socks Service */\n  /* DEPRECATED, do not use! */\n  CURLOPT(CURLOPT_SOCKS5_GSSAPI_SERVICE, CURLOPTTYPE_STRINGPOINT, 179),\n\n  /* Socks Service */\n  CURLOPT(CURLOPT_SOCKS5_GSSAPI_NEC, CURLOPTTYPE_LONG, 180),\n\n  /* set the bitmask for the protocols that are allowed to be used for the\n     transfer, which thus helps the app which takes URLs from users or other\n     external inputs and want to restrict what protocol(s) to deal\n     with. Defaults to CURLPROTO_ALL. */\n  CURLOPT(CURLOPT_PROTOCOLS, CURLOPTTYPE_LONG, 181),\n\n  /* set the bitmask for the protocols that libcurl is allowed to follow to,\n     as a subset of the CURLOPT_PROTOCOLS ones. That means the protocol needs\n     to be set in both bitmasks to be allowed to get redirected to. */\n  CURLOPT(CURLOPT_REDIR_PROTOCOLS, CURLOPTTYPE_LONG, 182),\n\n  /* set the SSH knownhost file name to use */\n  CURLOPT(CURLOPT_SSH_KNOWNHOSTS, CURLOPTTYPE_STRINGPOINT, 183),\n\n  /* set the SSH host key callback, must point to a curl_sshkeycallback\n     function */\n  CURLOPT(CURLOPT_SSH_KEYFUNCTION, CURLOPTTYPE_FUNCTIONPOINT, 184),\n\n  /* set the SSH host key callback custom pointer */\n  CURLOPT(CURLOPT_SSH_KEYDATA, CURLOPTTYPE_CBPOINT, 185),\n\n  /* set the SMTP mail originator */\n  CURLOPT(CURLOPT_MAIL_FROM, CURLOPTTYPE_STRINGPOINT, 186),\n\n  /* set the list of SMTP mail receiver(s) */\n  CURLOPT(CURLOPT_MAIL_RCPT, CURLOPTTYPE_SLISTPOINT, 187),\n\n  /* FTP: send PRET before PASV */\n  CURLOPT(CURLOPT_FTP_USE_PRET, CURLOPTTYPE_LONG, 188),\n\n  /* RTSP request method (OPTIONS, SETUP, PLAY, etc...) */\n  CURLOPT(CURLOPT_RTSP_REQUEST, CURLOPTTYPE_VALUES, 189),\n\n  /* The RTSP session identifier */\n  CURLOPT(CURLOPT_RTSP_SESSION_ID, CURLOPTTYPE_STRINGPOINT, 190),\n\n  /* The RTSP stream URI */\n  CURLOPT(CURLOPT_RTSP_STREAM_URI, CURLOPTTYPE_STRINGPOINT, 191),\n\n  /* The Transport: header to use in RTSP requests */\n  CURLOPT(CURLOPT_RTSP_TRANSPORT, CURLOPTTYPE_STRINGPOINT, 192),\n\n  /* Manually initialize the client RTSP CSeq for this handle */\n  CURLOPT(CURLOPT_RTSP_CLIENT_CSEQ, CURLOPTTYPE_LONG, 193),\n\n  /* Manually initialize the server RTSP CSeq for this handle */\n  CURLOPT(CURLOPT_RTSP_SERVER_CSEQ, CURLOPTTYPE_LONG, 194),\n\n  /* The stream to pass to INTERLEAVEFUNCTION. */\n  CURLOPT(CURLOPT_INTERLEAVEDATA, CURLOPTTYPE_CBPOINT, 195),\n\n  /* Let the application define a custom write method for RTP data */\n  CURLOPT(CURLOPT_INTERLEAVEFUNCTION, CURLOPTTYPE_FUNCTIONPOINT, 196),\n\n  /* Turn on wildcard matching */\n  CURLOPT(CURLOPT_WILDCARDMATCH, CURLOPTTYPE_LONG, 197),\n\n  /* Directory matching callback called before downloading of an\n     individual file (chunk) started */\n  CURLOPT(CURLOPT_CHUNK_BGN_FUNCTION, CURLOPTTYPE_FUNCTIONPOINT, 198),\n\n  /* Directory matching callback called after the file (chunk)\n     was downloaded, or skipped */\n  CURLOPT(CURLOPT_CHUNK_END_FUNCTION, CURLOPTTYPE_FUNCTIONPOINT, 199),\n\n  /* Change match (fnmatch-like) callback for wildcard matching */\n  CURLOPT(CURLOPT_FNMATCH_FUNCTION, CURLOPTTYPE_FUNCTIONPOINT, 200),\n\n  /* Let the application define custom chunk data pointer */\n  CURLOPT(CURLOPT_CHUNK_DATA, CURLOPTTYPE_CBPOINT, 201),\n\n  /* FNMATCH_FUNCTION user pointer */\n  CURLOPT(CURLOPT_FNMATCH_DATA, CURLOPTTYPE_CBPOINT, 202),\n\n  /* send linked-list of name:port:address sets */\n  CURLOPT(CURLOPT_RESOLVE, CURLOPTTYPE_SLISTPOINT, 203),\n\n  /* Set a username for authenticated TLS */\n  CURLOPT(CURLOPT_TLSAUTH_USERNAME, CURLOPTTYPE_STRINGPOINT, 204),\n\n  /* Set a password for authenticated TLS */\n  CURLOPT(CURLOPT_TLSAUTH_PASSWORD, CURLOPTTYPE_STRINGPOINT, 205),\n\n  /* Set authentication type for authenticated TLS */\n  CURLOPT(CURLOPT_TLSAUTH_TYPE, CURLOPTTYPE_STRINGPOINT, 206),\n\n  /* Set to 1 to enable the \"TE:\" header in HTTP requests to ask for\n     compressed transfer-encoded responses. Set to 0 to disable the use of TE:\n     in outgoing requests. The current default is 0, but it might change in a\n     future libcurl release.\n\n     libcurl will ask for the compressed methods it knows of, and if that\n     isn't any, it will not ask for transfer-encoding at all even if this\n     option is set to 1.\n\n  */\n  CURLOPT(CURLOPT_TRANSFER_ENCODING, CURLOPTTYPE_LONG, 207),\n\n  /* Callback function for closing socket (instead of close(2)). The callback\n     should have type curl_closesocket_callback */\n  CURLOPT(CURLOPT_CLOSESOCKETFUNCTION, CURLOPTTYPE_FUNCTIONPOINT, 208),\n  CURLOPT(CURLOPT_CLOSESOCKETDATA, CURLOPTTYPE_CBPOINT, 209),\n\n  /* allow GSSAPI credential delegation */\n  CURLOPT(CURLOPT_GSSAPI_DELEGATION, CURLOPTTYPE_VALUES, 210),\n\n  /* Set the name servers to use for DNS resolution */\n  CURLOPT(CURLOPT_DNS_SERVERS, CURLOPTTYPE_STRINGPOINT, 211),\n\n  /* Time-out accept operations (currently for FTP only) after this amount\n     of milliseconds. */\n  CURLOPT(CURLOPT_ACCEPTTIMEOUT_MS, CURLOPTTYPE_LONG, 212),\n\n  /* Set TCP keepalive */\n  CURLOPT(CURLOPT_TCP_KEEPALIVE, CURLOPTTYPE_LONG, 213),\n\n  /* non-universal keepalive knobs (Linux, AIX, HP-UX, more) */\n  CURLOPT(CURLOPT_TCP_KEEPIDLE, CURLOPTTYPE_LONG, 214),\n  CURLOPT(CURLOPT_TCP_KEEPINTVL, CURLOPTTYPE_LONG, 215),\n\n  /* Enable/disable specific SSL features with a bitmask, see CURLSSLOPT_* */\n  CURLOPT(CURLOPT_SSL_OPTIONS, CURLOPTTYPE_VALUES, 216),\n\n  /* Set the SMTP auth originator */\n  CURLOPT(CURLOPT_MAIL_AUTH, CURLOPTTYPE_STRINGPOINT, 217),\n\n  /* Enable/disable SASL initial response */\n  CURLOPT(CURLOPT_SASL_IR, CURLOPTTYPE_LONG, 218),\n\n  /* Function that will be called instead of the internal progress display\n   * function. This function should be defined as the curl_xferinfo_callback\n   * prototype defines. (Deprecates CURLOPT_PROGRESSFUNCTION) */\n  CURLOPT(CURLOPT_XFERINFOFUNCTION, CURLOPTTYPE_FUNCTIONPOINT, 219),\n\n  /* The XOAUTH2 bearer token */\n  CURLOPT(CURLOPT_XOAUTH2_BEARER, CURLOPTTYPE_STRINGPOINT, 220),\n\n  /* Set the interface string to use as outgoing network\n   * interface for DNS requests.\n   * Only supported by the c-ares DNS backend */\n  CURLOPT(CURLOPT_DNS_INTERFACE, CURLOPTTYPE_STRINGPOINT, 221),\n\n  /* Set the local IPv4 address to use for outgoing DNS requests.\n   * Only supported by the c-ares DNS backend */\n  CURLOPT(CURLOPT_DNS_LOCAL_IP4, CURLOPTTYPE_STRINGPOINT, 222),\n\n  /* Set the local IPv6 address to use for outgoing DNS requests.\n   * Only supported by the c-ares DNS backend */\n  CURLOPT(CURLOPT_DNS_LOCAL_IP6, CURLOPTTYPE_STRINGPOINT, 223),\n\n  /* Set authentication options directly */\n  CURLOPT(CURLOPT_LOGIN_OPTIONS, CURLOPTTYPE_STRINGPOINT, 224),\n\n  /* Enable/disable TLS NPN extension (http2 over ssl might fail without) */\n  CURLOPT(CURLOPT_SSL_ENABLE_NPN, CURLOPTTYPE_LONG, 225),\n\n  /* Enable/disable TLS ALPN extension (http2 over ssl might fail without) */\n  CURLOPT(CURLOPT_SSL_ENABLE_ALPN, CURLOPTTYPE_LONG, 226),\n\n  /* Time to wait for a response to a HTTP request containing an\n   * Expect: 100-continue header before sending the data anyway. */\n  CURLOPT(CURLOPT_EXPECT_100_TIMEOUT_MS, CURLOPTTYPE_LONG, 227),\n\n  /* This points to a linked list of headers used for proxy requests only,\n     struct curl_slist kind */\n  CURLOPT(CURLOPT_PROXYHEADER, CURLOPTTYPE_SLISTPOINT, 228),\n\n  /* Pass in a bitmask of \"header options\" */\n  CURLOPT(CURLOPT_HEADEROPT, CURLOPTTYPE_VALUES, 229),\n\n  /* The public key in DER form used to validate the peer public key\n     this option is used only if SSL_VERIFYPEER is true */\n  CURLOPT(CURLOPT_PINNEDPUBLICKEY, CURLOPTTYPE_STRINGPOINT, 230),\n\n  /* Path to Unix domain socket */\n  CURLOPT(CURLOPT_UNIX_SOCKET_PATH, CURLOPTTYPE_STRINGPOINT, 231),\n\n  /* Set if we should verify the certificate status. */\n  CURLOPT(CURLOPT_SSL_VERIFYSTATUS, CURLOPTTYPE_LONG, 232),\n\n  /* Set if we should enable TLS false start. */\n  CURLOPT(CURLOPT_SSL_FALSESTART, CURLOPTTYPE_LONG, 233),\n\n  /* Do not squash dot-dot sequences */\n  CURLOPT(CURLOPT_PATH_AS_IS, CURLOPTTYPE_LONG, 234),\n\n  /* Proxy Service Name */\n  CURLOPT(CURLOPT_PROXY_SERVICE_NAME, CURLOPTTYPE_STRINGPOINT, 235),\n\n  /* Service Name */\n  CURLOPT(CURLOPT_SERVICE_NAME, CURLOPTTYPE_STRINGPOINT, 236),\n\n  /* Wait/don't wait for pipe/mutex to clarify */\n  CURLOPT(CURLOPT_PIPEWAIT, CURLOPTTYPE_LONG, 237),\n\n  /* Set the protocol used when curl is given a URL without a protocol */\n  CURLOPT(CURLOPT_DEFAULT_PROTOCOL, CURLOPTTYPE_STRINGPOINT, 238),\n\n  /* Set stream weight, 1 - 256 (default is 16) */\n  CURLOPT(CURLOPT_STREAM_WEIGHT, CURLOPTTYPE_LONG, 239),\n\n  /* Set stream dependency on another CURL handle */\n  CURLOPT(CURLOPT_STREAM_DEPENDS, CURLOPTTYPE_OBJECTPOINT, 240),\n\n  /* Set E-xclusive stream dependency on another CURL handle */\n  CURLOPT(CURLOPT_STREAM_DEPENDS_E, CURLOPTTYPE_OBJECTPOINT, 241),\n\n  /* Do not send any tftp option requests to the server */\n  CURLOPT(CURLOPT_TFTP_NO_OPTIONS, CURLOPTTYPE_LONG, 242),\n\n  /* Linked-list of host:port:connect-to-host:connect-to-port,\n     overrides the URL's host:port (only for the network layer) */\n  CURLOPT(CURLOPT_CONNECT_TO, CURLOPTTYPE_SLISTPOINT, 243),\n\n  /* Set TCP Fast Open */\n  CURLOPT(CURLOPT_TCP_FASTOPEN, CURLOPTTYPE_LONG, 244),\n\n  /* Continue to send data if the server responds early with an\n   * HTTP status code >= 300 */\n  CURLOPT(CURLOPT_KEEP_SENDING_ON_ERROR, CURLOPTTYPE_LONG, 245),\n\n  /* The CApath or CAfile used to validate the proxy certificate\n     this option is used only if PROXY_SSL_VERIFYPEER is true */\n  CURLOPT(CURLOPT_PROXY_CAINFO, CURLOPTTYPE_STRINGPOINT, 246),\n\n  /* The CApath directory used to validate the proxy certificate\n     this option is used only if PROXY_SSL_VERIFYPEER is true */\n  CURLOPT(CURLOPT_PROXY_CAPATH, CURLOPTTYPE_STRINGPOINT, 247),\n\n  /* Set if we should verify the proxy in ssl handshake,\n     set 1 to verify. */\n  CURLOPT(CURLOPT_PROXY_SSL_VERIFYPEER, CURLOPTTYPE_LONG, 248),\n\n  /* Set if we should verify the Common name from the proxy certificate in ssl\n   * handshake, set 1 to check existence, 2 to ensure that it matches\n   * the provided hostname. */\n  CURLOPT(CURLOPT_PROXY_SSL_VERIFYHOST, CURLOPTTYPE_LONG, 249),\n\n  /* What version to specifically try to use for proxy.\n     See CURL_SSLVERSION defines below. */\n  CURLOPT(CURLOPT_PROXY_SSLVERSION, CURLOPTTYPE_VALUES, 250),\n\n  /* Set a username for authenticated TLS for proxy */\n  CURLOPT(CURLOPT_PROXY_TLSAUTH_USERNAME, CURLOPTTYPE_STRINGPOINT, 251),\n\n  /* Set a password for authenticated TLS for proxy */\n  CURLOPT(CURLOPT_PROXY_TLSAUTH_PASSWORD, CURLOPTTYPE_STRINGPOINT, 252),\n\n  /* Set authentication type for authenticated TLS for proxy */\n  CURLOPT(CURLOPT_PROXY_TLSAUTH_TYPE, CURLOPTTYPE_STRINGPOINT, 253),\n\n  /* name of the file keeping your private SSL-certificate for proxy */\n  CURLOPT(CURLOPT_PROXY_SSLCERT, CURLOPTTYPE_STRINGPOINT, 254),\n\n  /* type of the file keeping your SSL-certificate (\"DER\", \"PEM\", \"ENG\") for\n     proxy */\n  CURLOPT(CURLOPT_PROXY_SSLCERTTYPE, CURLOPTTYPE_STRINGPOINT, 255),\n\n  /* name of the file keeping your private SSL-key for proxy */\n  CURLOPT(CURLOPT_PROXY_SSLKEY, CURLOPTTYPE_STRINGPOINT, 256),\n\n  /* type of the file keeping your private SSL-key (\"DER\", \"PEM\", \"ENG\") for\n     proxy */\n  CURLOPT(CURLOPT_PROXY_SSLKEYTYPE, CURLOPTTYPE_STRINGPOINT, 257),\n\n  /* password for the SSL private key for proxy */\n  CURLOPT(CURLOPT_PROXY_KEYPASSWD, CURLOPTTYPE_STRINGPOINT, 258),\n\n  /* Specify which SSL ciphers to use for proxy */\n  CURLOPT(CURLOPT_PROXY_SSL_CIPHER_LIST, CURLOPTTYPE_STRINGPOINT, 259),\n\n  /* CRL file for proxy */\n  CURLOPT(CURLOPT_PROXY_CRLFILE, CURLOPTTYPE_STRINGPOINT, 260),\n\n  /* Enable/disable specific SSL features with a bitmask for proxy, see\n     CURLSSLOPT_* */\n  CURLOPT(CURLOPT_PROXY_SSL_OPTIONS, CURLOPTTYPE_LONG, 261),\n\n  /* Name of pre proxy to use. */\n  CURLOPT(CURLOPT_PRE_PROXY, CURLOPTTYPE_STRINGPOINT, 262),\n\n  /* The public key in DER form used to validate the proxy public key\n     this option is used only if PROXY_SSL_VERIFYPEER is true */\n  CURLOPT(CURLOPT_PROXY_PINNEDPUBLICKEY, CURLOPTTYPE_STRINGPOINT, 263),\n\n  /* Path to an abstract Unix domain socket */\n  CURLOPT(CURLOPT_ABSTRACT_UNIX_SOCKET, CURLOPTTYPE_STRINGPOINT, 264),\n\n  /* Suppress proxy CONNECT response headers from user callbacks */\n  CURLOPT(CURLOPT_SUPPRESS_CONNECT_HEADERS, CURLOPTTYPE_LONG, 265),\n\n  /* The request target, instead of extracted from the URL */\n  CURLOPT(CURLOPT_REQUEST_TARGET, CURLOPTTYPE_STRINGPOINT, 266),\n\n  /* bitmask of allowed auth methods for connections to SOCKS5 proxies */\n  CURLOPT(CURLOPT_SOCKS5_AUTH, CURLOPTTYPE_LONG, 267),\n\n  /* Enable/disable SSH compression */\n  CURLOPT(CURLOPT_SSH_COMPRESSION, CURLOPTTYPE_LONG, 268),\n\n  /* Post MIME data. */\n  CURLOPT(CURLOPT_MIMEPOST, CURLOPTTYPE_OBJECTPOINT, 269),\n\n  /* Time to use with the CURLOPT_TIMECONDITION. Specified in number of\n     seconds since 1 Jan 1970. */\n  CURLOPT(CURLOPT_TIMEVALUE_LARGE, CURLOPTTYPE_OFF_T, 270),\n\n  /* Head start in milliseconds to give happy eyeballs. */\n  CURLOPT(CURLOPT_HAPPY_EYEBALLS_TIMEOUT_MS, CURLOPTTYPE_LONG, 271),\n\n  /* Function that will be called before a resolver request is made */\n  CURLOPT(CURLOPT_RESOLVER_START_FUNCTION, CURLOPTTYPE_FUNCTIONPOINT, 272),\n\n  /* User data to pass to the resolver start callback. */\n  CURLOPT(CURLOPT_RESOLVER_START_DATA, CURLOPTTYPE_CBPOINT, 273),\n\n  /* send HAProxy PROXY protocol header? */\n  CURLOPT(CURLOPT_HAPROXYPROTOCOL, CURLOPTTYPE_LONG, 274),\n\n  /* shuffle addresses before use when DNS returns multiple */\n  CURLOPT(CURLOPT_DNS_SHUFFLE_ADDRESSES, CURLOPTTYPE_LONG, 275),\n\n  /* Specify which TLS 1.3 ciphers suites to use */\n  CURLOPT(CURLOPT_TLS13_CIPHERS, CURLOPTTYPE_STRINGPOINT, 276),\n  CURLOPT(CURLOPT_PROXY_TLS13_CIPHERS, CURLOPTTYPE_STRINGPOINT, 277),\n\n  /* Disallow specifying username/login in URL. */\n  CURLOPT(CURLOPT_DISALLOW_USERNAME_IN_URL, CURLOPTTYPE_LONG, 278),\n\n  /* DNS-over-HTTPS URL */\n  CURLOPT(CURLOPT_DOH_URL, CURLOPTTYPE_STRINGPOINT, 279),\n\n  /* Preferred buffer size to use for uploads */\n  CURLOPT(CURLOPT_UPLOAD_BUFFERSIZE, CURLOPTTYPE_LONG, 280),\n\n  /* Time in ms between connection upkeep calls for long-lived connections. */\n  CURLOPT(CURLOPT_UPKEEP_INTERVAL_MS, CURLOPTTYPE_LONG, 281),\n\n  /* Specify URL using CURL URL API. */\n  CURLOPT(CURLOPT_CURLU, CURLOPTTYPE_OBJECTPOINT, 282),\n\n  /* add trailing data just after no more data is available */\n  CURLOPT(CURLOPT_TRAILERFUNCTION, CURLOPTTYPE_FUNCTIONPOINT, 283),\n\n  /* pointer to be passed to HTTP_TRAILER_FUNCTION */\n  CURLOPT(CURLOPT_TRAILERDATA, CURLOPTTYPE_CBPOINT, 284),\n\n  /* set this to 1L to allow HTTP/0.9 responses or 0L to disallow */\n  CURLOPT(CURLOPT_HTTP09_ALLOWED, CURLOPTTYPE_LONG, 285),\n\n  /* alt-svc control bitmask */\n  CURLOPT(CURLOPT_ALTSVC_CTRL, CURLOPTTYPE_LONG, 286),\n\n  /* alt-svc cache file name to possibly read from/write to */\n  CURLOPT(CURLOPT_ALTSVC, CURLOPTTYPE_STRINGPOINT, 287),\n\n  /* maximum age of a connection to consider it for reuse (in seconds) */\n  CURLOPT(CURLOPT_MAXAGE_CONN, CURLOPTTYPE_LONG, 288),\n\n  /* SASL authorisation identity */\n  CURLOPT(CURLOPT_SASL_AUTHZID, CURLOPTTYPE_STRINGPOINT, 289),\n\n  /* allow RCPT TO command to fail for some recipients */\n  CURLOPT(CURLOPT_MAIL_RCPT_ALLLOWFAILS, CURLOPTTYPE_LONG, 290),\n\n  /* the private SSL-certificate as a \"blob\" */\n  CURLOPT(CURLOPT_SSLCERT_BLOB, CURLOPTTYPE_BLOB, 291),\n  CURLOPT(CURLOPT_SSLKEY_BLOB, CURLOPTTYPE_BLOB, 292),\n  CURLOPT(CURLOPT_PROXY_SSLCERT_BLOB, CURLOPTTYPE_BLOB, 293),\n  CURLOPT(CURLOPT_PROXY_SSLKEY_BLOB, CURLOPTTYPE_BLOB, 294),\n  CURLOPT(CURLOPT_ISSUERCERT_BLOB, CURLOPTTYPE_BLOB, 295),\n\n  /* Issuer certificate for proxy */\n  CURLOPT(CURLOPT_PROXY_ISSUERCERT, CURLOPTTYPE_STRINGPOINT, 296),\n  CURLOPT(CURLOPT_PROXY_ISSUERCERT_BLOB, CURLOPTTYPE_BLOB, 297),\n\n  /* the EC curves requested by the TLS client (RFC 8422, 5.1);\n   * OpenSSL support via 'set_groups'/'set_curves':\n   * https://www.openssl.org/docs/manmaster/man3/SSL_CTX_set1_groups.html\n   */\n  CURLOPT(CURLOPT_SSL_EC_CURVES, CURLOPTTYPE_STRINGPOINT, 298),\n\n  CURLOPT_LASTENTRY /* the last unused */\n} CURLoption;\n\n#ifndef CURL_NO_OLDIES /* define this to test if your app builds with all\n                          the obsolete stuff removed! */\n\n/* Backwards compatibility with older names */\n/* These are scheduled to disappear by 2011 */\n\n/* This was added in version 7.19.1 */\n#define CURLOPT_POST301 CURLOPT_POSTREDIR\n\n/* These are scheduled to disappear by 2009 */\n\n/* The following were added in 7.17.0 */\n#define CURLOPT_SSLKEYPASSWD CURLOPT_KEYPASSWD\n#define CURLOPT_FTPAPPEND CURLOPT_APPEND\n#define CURLOPT_FTPLISTONLY CURLOPT_DIRLISTONLY\n#define CURLOPT_FTP_SSL CURLOPT_USE_SSL\n\n/* The following were added earlier */\n\n#define CURLOPT_SSLCERTPASSWD CURLOPT_KEYPASSWD\n#define CURLOPT_KRB4LEVEL CURLOPT_KRBLEVEL\n\n#else\n/* This is set if CURL_NO_OLDIES is defined at compile-time */\n#undef CURLOPT_DNS_USE_GLOBAL_CACHE /* soon obsolete */\n#endif\n\n\n  /* Below here follows defines for the CURLOPT_IPRESOLVE option. If a host\n     name resolves addresses using more than one IP protocol version, this\n     option might be handy to force libcurl to use a specific IP version. */\n#define CURL_IPRESOLVE_WHATEVER 0 /* default, resolves addresses to all IP\n                                     versions that your system allows */\n#define CURL_IPRESOLVE_V4       1 /* resolve to IPv4 addresses */\n#define CURL_IPRESOLVE_V6       2 /* resolve to IPv6 addresses */\n\n  /* three convenient \"aliases\" that follow the name scheme better */\n#define CURLOPT_RTSPHEADER CURLOPT_HTTPHEADER\n\n  /* These enums are for use with the CURLOPT_HTTP_VERSION option. */\nenum {\n  CURL_HTTP_VERSION_NONE, /* setting this means we don't care, and that we'd\n                             like the library to choose the best possible\n                             for us! */\n  CURL_HTTP_VERSION_1_0,  /* please use HTTP 1.0 in the request */\n  CURL_HTTP_VERSION_1_1,  /* please use HTTP 1.1 in the request */\n  CURL_HTTP_VERSION_2_0,  /* please use HTTP 2 in the request */\n  CURL_HTTP_VERSION_2TLS, /* use version 2 for HTTPS, version 1.1 for HTTP */\n  CURL_HTTP_VERSION_2_PRIOR_KNOWLEDGE,  /* please use HTTP 2 without HTTP/1.1\n                                           Upgrade */\n  CURL_HTTP_VERSION_3 = 30, /* Makes use of explicit HTTP/3 without fallback.\n                               Use CURLOPT_ALTSVC to enable HTTP/3 upgrade */\n  CURL_HTTP_VERSION_LAST /* *ILLEGAL* http version */\n};\n\n/* Convenience definition simple because the name of the version is HTTP/2 and\n   not 2.0. The 2_0 version of the enum name was set while the version was\n   still planned to be 2.0 and we stick to it for compatibility. */\n#define CURL_HTTP_VERSION_2 CURL_HTTP_VERSION_2_0\n\n/*\n * Public API enums for RTSP requests\n */\nenum {\n    CURL_RTSPREQ_NONE, /* first in list */\n    CURL_RTSPREQ_OPTIONS,\n    CURL_RTSPREQ_DESCRIBE,\n    CURL_RTSPREQ_ANNOUNCE,\n    CURL_RTSPREQ_SETUP,\n    CURL_RTSPREQ_PLAY,\n    CURL_RTSPREQ_PAUSE,\n    CURL_RTSPREQ_TEARDOWN,\n    CURL_RTSPREQ_GET_PARAMETER,\n    CURL_RTSPREQ_SET_PARAMETER,\n    CURL_RTSPREQ_RECORD,\n    CURL_RTSPREQ_RECEIVE,\n    CURL_RTSPREQ_LAST /* last in list */\n};\n\n  /* These enums are for use with the CURLOPT_NETRC option. */\nenum CURL_NETRC_OPTION {\n  CURL_NETRC_IGNORED,     /* The .netrc will never be read.\n                           * This is the default. */\n  CURL_NETRC_OPTIONAL,    /* A user:password in the URL will be preferred\n                           * to one in the .netrc. */\n  CURL_NETRC_REQUIRED,    /* A user:password in the URL will be ignored.\n                           * Unless one is set programmatically, the .netrc\n                           * will be queried. */\n  CURL_NETRC_LAST\n};\n\nenum {\n  CURL_SSLVERSION_DEFAULT,\n  CURL_SSLVERSION_TLSv1, /* TLS 1.x */\n  CURL_SSLVERSION_SSLv2,\n  CURL_SSLVERSION_SSLv3,\n  CURL_SSLVERSION_TLSv1_0,\n  CURL_SSLVERSION_TLSv1_1,\n  CURL_SSLVERSION_TLSv1_2,\n  CURL_SSLVERSION_TLSv1_3,\n\n  CURL_SSLVERSION_LAST /* never use, keep last */\n};\n\nenum {\n  CURL_SSLVERSION_MAX_NONE =     0,\n  CURL_SSLVERSION_MAX_DEFAULT =  (CURL_SSLVERSION_TLSv1   << 16),\n  CURL_SSLVERSION_MAX_TLSv1_0 =  (CURL_SSLVERSION_TLSv1_0 << 16),\n  CURL_SSLVERSION_MAX_TLSv1_1 =  (CURL_SSLVERSION_TLSv1_1 << 16),\n  CURL_SSLVERSION_MAX_TLSv1_2 =  (CURL_SSLVERSION_TLSv1_2 << 16),\n  CURL_SSLVERSION_MAX_TLSv1_3 =  (CURL_SSLVERSION_TLSv1_3 << 16),\n\n  /* never use, keep last */\n  CURL_SSLVERSION_MAX_LAST =     (CURL_SSLVERSION_LAST    << 16)\n};\n\nenum CURL_TLSAUTH {\n  CURL_TLSAUTH_NONE,\n  CURL_TLSAUTH_SRP,\n  CURL_TLSAUTH_LAST /* never use, keep last */\n};\n\n/* symbols to use with CURLOPT_POSTREDIR.\n   CURL_REDIR_POST_301, CURL_REDIR_POST_302 and CURL_REDIR_POST_303\n   can be bitwise ORed so that CURL_REDIR_POST_301 | CURL_REDIR_POST_302\n   | CURL_REDIR_POST_303 == CURL_REDIR_POST_ALL */\n\n#define CURL_REDIR_GET_ALL  0\n#define CURL_REDIR_POST_301 1\n#define CURL_REDIR_POST_302 2\n#define CURL_REDIR_POST_303 4\n#define CURL_REDIR_POST_ALL \\\n    (CURL_REDIR_POST_301|CURL_REDIR_POST_302|CURL_REDIR_POST_303)\n\ntypedef enum {\n  CURL_TIMECOND_NONE,\n\n  CURL_TIMECOND_IFMODSINCE,\n  CURL_TIMECOND_IFUNMODSINCE,\n  CURL_TIMECOND_LASTMOD,\n\n  CURL_TIMECOND_LAST\n} curl_TimeCond;\n\n/* Special size_t value signaling a null-terminated string. */\n#define CURL_ZERO_TERMINATED ((size_t) -1)\n\n/* curl_strequal() and curl_strnequal() are subject for removal in a future\n   release */\nCURL_EXTERN int curl_strequal(const char *s1, const char *s2);\nCURL_EXTERN int curl_strnequal(const char *s1, const char *s2, size_t n);\n\n/* Mime/form handling support. */\ntypedef struct curl_mime      curl_mime;      /* Mime context. */\ntypedef struct curl_mimepart  curl_mimepart;  /* Mime part context. */\n\n/*\n * NAME curl_mime_init()\n *\n * DESCRIPTION\n *\n * Create a mime context and return its handle. The easy parameter is the\n * target handle.\n */\nCURL_EXTERN curl_mime *curl_mime_init(CURL *easy);\n\n/*\n * NAME curl_mime_free()\n *\n * DESCRIPTION\n *\n * release a mime handle and its substructures.\n */\nCURL_EXTERN void curl_mime_free(curl_mime *mime);\n\n/*\n * NAME curl_mime_addpart()\n *\n * DESCRIPTION\n *\n * Append a new empty part to the given mime context and return a handle to\n * the created part.\n */\nCURL_EXTERN curl_mimepart *curl_mime_addpart(curl_mime *mime);\n\n/*\n * NAME curl_mime_name()\n *\n * DESCRIPTION\n *\n * Set mime/form part name.\n */\nCURL_EXTERN CURLcode curl_mime_name(curl_mimepart *part, const char *name);\n\n/*\n * NAME curl_mime_filename()\n *\n * DESCRIPTION\n *\n * Set mime part remote file name.\n */\nCURL_EXTERN CURLcode curl_mime_filename(curl_mimepart *part,\n                                        const char *filename);\n\n/*\n * NAME curl_mime_type()\n *\n * DESCRIPTION\n *\n * Set mime part type.\n */\nCURL_EXTERN CURLcode curl_mime_type(curl_mimepart *part, const char *mimetype);\n\n/*\n * NAME curl_mime_encoder()\n *\n * DESCRIPTION\n *\n * Set mime data transfer encoder.\n */\nCURL_EXTERN CURLcode curl_mime_encoder(curl_mimepart *part,\n                                       const char *encoding);\n\n/*\n * NAME curl_mime_data()\n *\n * DESCRIPTION\n *\n * Set mime part data source from memory data,\n */\nCURL_EXTERN CURLcode curl_mime_data(curl_mimepart *part,\n                                    const char *data, size_t datasize);\n\n/*\n * NAME curl_mime_filedata()\n *\n * DESCRIPTION\n *\n * Set mime part data source from named file.\n */\nCURL_EXTERN CURLcode curl_mime_filedata(curl_mimepart *part,\n                                        const char *filename);\n\n/*\n * NAME curl_mime_data_cb()\n *\n * DESCRIPTION\n *\n * Set mime part data source from callback function.\n */\nCURL_EXTERN CURLcode curl_mime_data_cb(curl_mimepart *part,\n                                       curl_off_t datasize,\n                                       curl_read_callback readfunc,\n                                       curl_seek_callback seekfunc,\n                                       curl_free_callback freefunc,\n                                       void *arg);\n\n/*\n * NAME curl_mime_subparts()\n *\n * DESCRIPTION\n *\n * Set mime part data source from subparts.\n */\nCURL_EXTERN CURLcode curl_mime_subparts(curl_mimepart *part,\n                                        curl_mime *subparts);\n/*\n * NAME curl_mime_headers()\n *\n * DESCRIPTION\n *\n * Set mime part headers.\n */\nCURL_EXTERN CURLcode curl_mime_headers(curl_mimepart *part,\n                                       struct curl_slist *headers,\n                                       int take_ownership);\n\ntypedef enum {\n  CURLFORM_NOTHING,        /********* the first one is unused ************/\n  CURLFORM_COPYNAME,\n  CURLFORM_PTRNAME,\n  CURLFORM_NAMELENGTH,\n  CURLFORM_COPYCONTENTS,\n  CURLFORM_PTRCONTENTS,\n  CURLFORM_CONTENTSLENGTH,\n  CURLFORM_FILECONTENT,\n  CURLFORM_ARRAY,\n  CURLFORM_OBSOLETE,\n  CURLFORM_FILE,\n\n  CURLFORM_BUFFER,\n  CURLFORM_BUFFERPTR,\n  CURLFORM_BUFFERLENGTH,\n\n  CURLFORM_CONTENTTYPE,\n  CURLFORM_CONTENTHEADER,\n  CURLFORM_FILENAME,\n  CURLFORM_END,\n  CURLFORM_OBSOLETE2,\n\n  CURLFORM_STREAM,\n  CURLFORM_CONTENTLEN, /* added in 7.46.0, provide a curl_off_t length */\n\n  CURLFORM_LASTENTRY /* the last unused */\n} CURLformoption;\n\n/* structure to be used as parameter for CURLFORM_ARRAY */\nstruct curl_forms {\n  CURLformoption option;\n  const char     *value;\n};\n\n/* use this for multipart formpost building */\n/* Returns code for curl_formadd()\n *\n * Returns:\n * CURL_FORMADD_OK             on success\n * CURL_FORMADD_MEMORY         if the FormInfo allocation fails\n * CURL_FORMADD_OPTION_TWICE   if one option is given twice for one Form\n * CURL_FORMADD_NULL           if a null pointer was given for a char\n * CURL_FORMADD_MEMORY         if the allocation of a FormInfo struct failed\n * CURL_FORMADD_UNKNOWN_OPTION if an unknown option was used\n * CURL_FORMADD_INCOMPLETE     if the some FormInfo is not complete (or error)\n * CURL_FORMADD_MEMORY         if a curl_httppost struct cannot be allocated\n * CURL_FORMADD_MEMORY         if some allocation for string copying failed.\n * CURL_FORMADD_ILLEGAL_ARRAY  if an illegal option is used in an array\n *\n ***************************************************************************/\ntypedef enum {\n  CURL_FORMADD_OK, /* first, no error */\n\n  CURL_FORMADD_MEMORY,\n  CURL_FORMADD_OPTION_TWICE,\n  CURL_FORMADD_NULL,\n  CURL_FORMADD_UNKNOWN_OPTION,\n  CURL_FORMADD_INCOMPLETE,\n  CURL_FORMADD_ILLEGAL_ARRAY,\n  CURL_FORMADD_DISABLED, /* libcurl was built with this disabled */\n\n  CURL_FORMADD_LAST /* last */\n} CURLFORMcode;\n\n/*\n * NAME curl_formadd()\n *\n * DESCRIPTION\n *\n * Pretty advanced function for building multi-part formposts. Each invoke\n * adds one part that together construct a full post. Then use\n * CURLOPT_HTTPPOST to send it off to libcurl.\n */\nCURL_EXTERN CURLFORMcode curl_formadd(struct curl_httppost **httppost,\n                                      struct curl_httppost **last_post,\n                                      ...);\n\n/*\n * callback function for curl_formget()\n * The void *arg pointer will be the one passed as second argument to\n *   curl_formget().\n * The character buffer passed to it must not be freed.\n * Should return the buffer length passed to it as the argument \"len\" on\n *   success.\n */\ntypedef size_t (*curl_formget_callback)(void *arg, const char *buf,\n                                        size_t len);\n\n/*\n * NAME curl_formget()\n *\n * DESCRIPTION\n *\n * Serialize a curl_httppost struct built with curl_formadd().\n * Accepts a void pointer as second argument which will be passed to\n * the curl_formget_callback function.\n * Returns 0 on success.\n */\nCURL_EXTERN int curl_formget(struct curl_httppost *form, void *arg,\n                             curl_formget_callback append);\n/*\n * NAME curl_formfree()\n *\n * DESCRIPTION\n *\n * Free a multipart formpost previously built with curl_formadd().\n */\nCURL_EXTERN void curl_formfree(struct curl_httppost *form);\n\n/*\n * NAME curl_getenv()\n *\n * DESCRIPTION\n *\n * Returns a malloc()'ed string that MUST be curl_free()ed after usage is\n * complete. DEPRECATED - see lib/README.curlx\n */\nCURL_EXTERN char *curl_getenv(const char *variable);\n\n/*\n * NAME curl_version()\n *\n * DESCRIPTION\n *\n * Returns a static ascii string of the libcurl version.\n */\nCURL_EXTERN char *curl_version(void);\n\n/*\n * NAME curl_easy_escape()\n *\n * DESCRIPTION\n *\n * Escapes URL strings (converts all letters consider illegal in URLs to their\n * %XX versions). This function returns a new allocated string or NULL if an\n * error occurred.\n */\nCURL_EXTERN char *curl_easy_escape(CURL *handle,\n                                   const char *string,\n                                   int length);\n\n/* the previous version: */\nCURL_EXTERN char *curl_escape(const char *string,\n                              int length);\n\n\n/*\n * NAME curl_easy_unescape()\n *\n * DESCRIPTION\n *\n * Unescapes URL encoding in strings (converts all %XX codes to their 8bit\n * versions). This function returns a new allocated string or NULL if an error\n * occurred.\n * Conversion Note: On non-ASCII platforms the ASCII %XX codes are\n * converted into the host encoding.\n */\nCURL_EXTERN char *curl_easy_unescape(CURL *handle,\n                                     const char *string,\n                                     int length,\n                                     int *outlength);\n\n/* the previous version */\nCURL_EXTERN char *curl_unescape(const char *string,\n                                int length);\n\n/*\n * NAME curl_free()\n *\n * DESCRIPTION\n *\n * Provided for de-allocation in the same translation unit that did the\n * allocation. Added in libcurl 7.10\n */\nCURL_EXTERN void curl_free(void *p);\n\n/*\n * NAME curl_global_init()\n *\n * DESCRIPTION\n *\n * curl_global_init() should be invoked exactly once for each application that\n * uses libcurl and before any call of other libcurl functions.\n *\n * This function is not thread-safe!\n */\nCURL_EXTERN CURLcode curl_global_init(long flags);\n\n/*\n * NAME curl_global_init_mem()\n *\n * DESCRIPTION\n *\n * curl_global_init() or curl_global_init_mem() should be invoked exactly once\n * for each application that uses libcurl.  This function can be used to\n * initialize libcurl and set user defined memory management callback\n * functions.  Users can implement memory management routines to check for\n * memory leaks, check for mis-use of the curl library etc.  User registered\n * callback routines will be invoked by this library instead of the system\n * memory management routines like malloc, free etc.\n */\nCURL_EXTERN CURLcode curl_global_init_mem(long flags,\n                                          curl_malloc_callback m,\n                                          curl_free_callback f,\n                                          curl_realloc_callback r,\n                                          curl_strdup_callback s,\n                                          curl_calloc_callback c);\n\n/*\n * NAME curl_global_cleanup()\n *\n * DESCRIPTION\n *\n * curl_global_cleanup() should be invoked exactly once for each application\n * that uses libcurl\n */\nCURL_EXTERN void curl_global_cleanup(void);\n\n/* linked-list structure for the CURLOPT_QUOTE option (and other) */\nstruct curl_slist {\n  char *data;\n  struct curl_slist *next;\n};\n\n/*\n * NAME curl_global_sslset()\n *\n * DESCRIPTION\n *\n * When built with multiple SSL backends, curl_global_sslset() allows to\n * choose one. This function can only be called once, and it must be called\n * *before* curl_global_init().\n *\n * The backend can be identified by the id (e.g. CURLSSLBACKEND_OPENSSL). The\n * backend can also be specified via the name parameter (passing -1 as id).\n * If both id and name are specified, the name will be ignored. If neither id\n * nor name are specified, the function will fail with\n * CURLSSLSET_UNKNOWN_BACKEND and set the \"avail\" pointer to the\n * NULL-terminated list of available backends.\n *\n * Upon success, the function returns CURLSSLSET_OK.\n *\n * If the specified SSL backend is not available, the function returns\n * CURLSSLSET_UNKNOWN_BACKEND and sets the \"avail\" pointer to a NULL-terminated\n * list of available SSL backends.\n *\n * The SSL backend can be set only once. If it has already been set, a\n * subsequent attempt to change it will result in a CURLSSLSET_TOO_LATE.\n */\n\nstruct curl_ssl_backend {\n  curl_sslbackend id;\n  const char *name;\n};\ntypedef struct curl_ssl_backend curl_ssl_backend;\n\ntypedef enum {\n  CURLSSLSET_OK = 0,\n  CURLSSLSET_UNKNOWN_BACKEND,\n  CURLSSLSET_TOO_LATE,\n  CURLSSLSET_NO_BACKENDS /* libcurl was built without any SSL support */\n} CURLsslset;\n\nCURL_EXTERN CURLsslset curl_global_sslset(curl_sslbackend id, const char *name,\n                                          const curl_ssl_backend ***avail);\n\n/*\n * NAME curl_slist_append()\n *\n * DESCRIPTION\n *\n * Appends a string to a linked list. If no list exists, it will be created\n * first. Returns the new list, after appending.\n */\nCURL_EXTERN struct curl_slist *curl_slist_append(struct curl_slist *,\n                                                 const char *);\n\n/*\n * NAME curl_slist_free_all()\n *\n * DESCRIPTION\n *\n * free a previously built curl_slist.\n */\nCURL_EXTERN void curl_slist_free_all(struct curl_slist *);\n\n/*\n * NAME curl_getdate()\n *\n * DESCRIPTION\n *\n * Returns the time, in seconds since 1 Jan 1970 of the time string given in\n * the first argument. The time argument in the second parameter is unused\n * and should be set to NULL.\n */\nCURL_EXTERN time_t curl_getdate(const char *p, const time_t *unused);\n\n/* info about the certificate chain, only for OpenSSL, GnuTLS, Schannel, NSS\n   and GSKit builds. Asked for with CURLOPT_CERTINFO / CURLINFO_CERTINFO */\nstruct curl_certinfo {\n  int num_of_certs;             /* number of certificates with information */\n  struct curl_slist **certinfo; /* for each index in this array, there's a\n                                   linked list with textual information in the\n                                   format \"name: value\" */\n};\n\n/* Information about the SSL library used and the respective internal SSL\n   handle, which can be used to obtain further information regarding the\n   connection. Asked for with CURLINFO_TLS_SSL_PTR or CURLINFO_TLS_SESSION. */\nstruct curl_tlssessioninfo {\n  curl_sslbackend backend;\n  void *internals;\n};\n\n#define CURLINFO_STRING   0x100000\n#define CURLINFO_LONG     0x200000\n#define CURLINFO_DOUBLE   0x300000\n#define CURLINFO_SLIST    0x400000\n#define CURLINFO_PTR      0x400000 /* same as SLIST */\n#define CURLINFO_SOCKET   0x500000\n#define CURLINFO_OFF_T    0x600000\n#define CURLINFO_MASK     0x0fffff\n#define CURLINFO_TYPEMASK 0xf00000\n\ntypedef enum {\n  CURLINFO_NONE, /* first, never use this */\n  CURLINFO_EFFECTIVE_URL    = CURLINFO_STRING + 1,\n  CURLINFO_RESPONSE_CODE    = CURLINFO_LONG   + 2,\n  CURLINFO_TOTAL_TIME       = CURLINFO_DOUBLE + 3,\n  CURLINFO_NAMELOOKUP_TIME  = CURLINFO_DOUBLE + 4,\n  CURLINFO_CONNECT_TIME     = CURLINFO_DOUBLE + 5,\n  CURLINFO_PRETRANSFER_TIME = CURLINFO_DOUBLE + 6,\n  CURLINFO_SIZE_UPLOAD      = CURLINFO_DOUBLE + 7,\n  CURLINFO_SIZE_UPLOAD_T    = CURLINFO_OFF_T  + 7,\n  CURLINFO_SIZE_DOWNLOAD    = CURLINFO_DOUBLE + 8,\n  CURLINFO_SIZE_DOWNLOAD_T  = CURLINFO_OFF_T  + 8,\n  CURLINFO_SPEED_DOWNLOAD   = CURLINFO_DOUBLE + 9,\n  CURLINFO_SPEED_DOWNLOAD_T = CURLINFO_OFF_T  + 9,\n  CURLINFO_SPEED_UPLOAD     = CURLINFO_DOUBLE + 10,\n  CURLINFO_SPEED_UPLOAD_T   = CURLINFO_OFF_T  + 10,\n  CURLINFO_HEADER_SIZE      = CURLINFO_LONG   + 11,\n  CURLINFO_REQUEST_SIZE     = CURLINFO_LONG   + 12,\n  CURLINFO_SSL_VERIFYRESULT = CURLINFO_LONG   + 13,\n  CURLINFO_FILETIME         = CURLINFO_LONG   + 14,\n  CURLINFO_FILETIME_T       = CURLINFO_OFF_T  + 14,\n  CURLINFO_CONTENT_LENGTH_DOWNLOAD   = CURLINFO_DOUBLE + 15,\n  CURLINFO_CONTENT_LENGTH_DOWNLOAD_T = CURLINFO_OFF_T  + 15,\n  CURLINFO_CONTENT_LENGTH_UPLOAD     = CURLINFO_DOUBLE + 16,\n  CURLINFO_CONTENT_LENGTH_UPLOAD_T   = CURLINFO_OFF_T  + 16,\n  CURLINFO_STARTTRANSFER_TIME = CURLINFO_DOUBLE + 17,\n  CURLINFO_CONTENT_TYPE     = CURLINFO_STRING + 18,\n  CURLINFO_REDIRECT_TIME    = CURLINFO_DOUBLE + 19,\n  CURLINFO_REDIRECT_COUNT   = CURLINFO_LONG   + 20,\n  CURLINFO_PRIVATE          = CURLINFO_STRING + 21,\n  CURLINFO_HTTP_CONNECTCODE = CURLINFO_LONG   + 22,\n  CURLINFO_HTTPAUTH_AVAIL   = CURLINFO_LONG   + 23,\n  CURLINFO_PROXYAUTH_AVAIL  = CURLINFO_LONG   + 24,\n  CURLINFO_OS_ERRNO         = CURLINFO_LONG   + 25,\n  CURLINFO_NUM_CONNECTS     = CURLINFO_LONG   + 26,\n  CURLINFO_SSL_ENGINES      = CURLINFO_SLIST  + 27,\n  CURLINFO_COOKIELIST       = CURLINFO_SLIST  + 28,\n  CURLINFO_LASTSOCKET       = CURLINFO_LONG   + 29,\n  CURLINFO_FTP_ENTRY_PATH   = CURLINFO_STRING + 30,\n  CURLINFO_REDIRECT_URL     = CURLINFO_STRING + 31,\n  CURLINFO_PRIMARY_IP       = CURLINFO_STRING + 32,\n  CURLINFO_APPCONNECT_TIME  = CURLINFO_DOUBLE + 33,\n  CURLINFO_CERTINFO         = CURLINFO_PTR    + 34,\n  CURLINFO_CONDITION_UNMET  = CURLINFO_LONG   + 35,\n  CURLINFO_RTSP_SESSION_ID  = CURLINFO_STRING + 36,\n  CURLINFO_RTSP_CLIENT_CSEQ = CURLINFO_LONG   + 37,\n  CURLINFO_RTSP_SERVER_CSEQ = CURLINFO_LONG   + 38,\n  CURLINFO_RTSP_CSEQ_RECV   = CURLINFO_LONG   + 39,\n  CURLINFO_PRIMARY_PORT     = CURLINFO_LONG   + 40,\n  CURLINFO_LOCAL_IP         = CURLINFO_STRING + 41,\n  CURLINFO_LOCAL_PORT       = CURLINFO_LONG   + 42,\n  CURLINFO_TLS_SESSION      = CURLINFO_PTR    + 43,\n  CURLINFO_ACTIVESOCKET     = CURLINFO_SOCKET + 44,\n  CURLINFO_TLS_SSL_PTR      = CURLINFO_PTR    + 45,\n  CURLINFO_HTTP_VERSION     = CURLINFO_LONG   + 46,\n  CURLINFO_PROXY_SSL_VERIFYRESULT = CURLINFO_LONG + 47,\n  CURLINFO_PROTOCOL         = CURLINFO_LONG   + 48,\n  CURLINFO_SCHEME           = CURLINFO_STRING + 49,\n  CURLINFO_TOTAL_TIME_T     = CURLINFO_OFF_T + 50,\n  CURLINFO_NAMELOOKUP_TIME_T = CURLINFO_OFF_T + 51,\n  CURLINFO_CONNECT_TIME_T   = CURLINFO_OFF_T + 52,\n  CURLINFO_PRETRANSFER_TIME_T = CURLINFO_OFF_T + 53,\n  CURLINFO_STARTTRANSFER_TIME_T = CURLINFO_OFF_T + 54,\n  CURLINFO_REDIRECT_TIME_T  = CURLINFO_OFF_T + 55,\n  CURLINFO_APPCONNECT_TIME_T = CURLINFO_OFF_T + 56,\n  CURLINFO_RETRY_AFTER      = CURLINFO_OFF_T + 57,\n  CURLINFO_EFFECTIVE_METHOD = CURLINFO_STRING + 58,\n  CURLINFO_PROXY_ERROR      = CURLINFO_LONG + 59,\n\n  CURLINFO_LASTONE          = 59\n} CURLINFO;\n\n/* CURLINFO_RESPONSE_CODE is the new name for the option previously known as\n   CURLINFO_HTTP_CODE */\n#define CURLINFO_HTTP_CODE CURLINFO_RESPONSE_CODE\n\ntypedef enum {\n  CURLCLOSEPOLICY_NONE, /* first, never use this */\n\n  CURLCLOSEPOLICY_OLDEST,\n  CURLCLOSEPOLICY_LEAST_RECENTLY_USED,\n  CURLCLOSEPOLICY_LEAST_TRAFFIC,\n  CURLCLOSEPOLICY_SLOWEST,\n  CURLCLOSEPOLICY_CALLBACK,\n\n  CURLCLOSEPOLICY_LAST /* last, never use this */\n} curl_closepolicy;\n\n#define CURL_GLOBAL_SSL (1<<0) /* no purpose since since 7.57.0 */\n#define CURL_GLOBAL_WIN32 (1<<1)\n#define CURL_GLOBAL_ALL (CURL_GLOBAL_SSL|CURL_GLOBAL_WIN32)\n#define CURL_GLOBAL_NOTHING 0\n#define CURL_GLOBAL_DEFAULT CURL_GLOBAL_ALL\n#define CURL_GLOBAL_ACK_EINTR (1<<2)\n\n\n/*****************************************************************************\n * Setup defines, protos etc for the sharing stuff.\n */\n\n/* Different data locks for a single share */\ntypedef enum {\n  CURL_LOCK_DATA_NONE = 0,\n  /*  CURL_LOCK_DATA_SHARE is used internally to say that\n   *  the locking is just made to change the internal state of the share\n   *  itself.\n   */\n  CURL_LOCK_DATA_SHARE,\n  CURL_LOCK_DATA_COOKIE,\n  CURL_LOCK_DATA_DNS,\n  CURL_LOCK_DATA_SSL_SESSION,\n  CURL_LOCK_DATA_CONNECT,\n  CURL_LOCK_DATA_PSL,\n  CURL_LOCK_DATA_LAST\n} curl_lock_data;\n\n/* Different lock access types */\ntypedef enum {\n  CURL_LOCK_ACCESS_NONE = 0,   /* unspecified action */\n  CURL_LOCK_ACCESS_SHARED = 1, /* for read perhaps */\n  CURL_LOCK_ACCESS_SINGLE = 2, /* for write perhaps */\n  CURL_LOCK_ACCESS_LAST        /* never use */\n} curl_lock_access;\n\ntypedef void (*curl_lock_function)(CURL *handle,\n                                   curl_lock_data data,\n                                   curl_lock_access locktype,\n                                   void *userptr);\ntypedef void (*curl_unlock_function)(CURL *handle,\n                                     curl_lock_data data,\n                                     void *userptr);\n\n\ntypedef enum {\n  CURLSHE_OK,  /* all is fine */\n  CURLSHE_BAD_OPTION, /* 1 */\n  CURLSHE_IN_USE,     /* 2 */\n  CURLSHE_INVALID,    /* 3 */\n  CURLSHE_NOMEM,      /* 4 out of memory */\n  CURLSHE_NOT_BUILT_IN, /* 5 feature not present in lib */\n  CURLSHE_LAST        /* never use */\n} CURLSHcode;\n\ntypedef enum {\n  CURLSHOPT_NONE,  /* don't use */\n  CURLSHOPT_SHARE,   /* specify a data type to share */\n  CURLSHOPT_UNSHARE, /* specify which data type to stop sharing */\n  CURLSHOPT_LOCKFUNC,   /* pass in a 'curl_lock_function' pointer */\n  CURLSHOPT_UNLOCKFUNC, /* pass in a 'curl_unlock_function' pointer */\n  CURLSHOPT_USERDATA,   /* pass in a user data pointer used in the lock/unlock\n                           callback functions */\n  CURLSHOPT_LAST  /* never use */\n} CURLSHoption;\n\nCURL_EXTERN CURLSH *curl_share_init(void);\nCURL_EXTERN CURLSHcode curl_share_setopt(CURLSH *, CURLSHoption option, ...);\nCURL_EXTERN CURLSHcode curl_share_cleanup(CURLSH *);\n\n/****************************************************************************\n * Structures for querying information about the curl library at runtime.\n */\n\ntypedef enum {\n  CURLVERSION_FIRST,\n  CURLVERSION_SECOND,\n  CURLVERSION_THIRD,\n  CURLVERSION_FOURTH,\n  CURLVERSION_FIFTH,\n  CURLVERSION_SIXTH,\n  CURLVERSION_SEVENTH,\n  CURLVERSION_EIGHTH,\n  CURLVERSION_LAST /* never actually use this */\n} CURLversion;\n\n/* The 'CURLVERSION_NOW' is the symbolic name meant to be used by\n   basically all programs ever that want to get version information. It is\n   meant to be a built-in version number for what kind of struct the caller\n   expects. If the struct ever changes, we redefine the NOW to another enum\n   from above. */\n#define CURLVERSION_NOW CURLVERSION_EIGHTH\n\nstruct curl_version_info_data {\n  CURLversion age;          /* age of the returned struct */\n  const char *version;      /* LIBCURL_VERSION */\n  unsigned int version_num; /* LIBCURL_VERSION_NUM */\n  const char *host;         /* OS/host/cpu/machine when configured */\n  int features;             /* bitmask, see defines below */\n  const char *ssl_version;  /* human readable string */\n  long ssl_version_num;     /* not used anymore, always 0 */\n  const char *libz_version; /* human readable string */\n  /* protocols is terminated by an entry with a NULL protoname */\n  const char * const *protocols;\n\n  /* The fields below this were added in CURLVERSION_SECOND */\n  const char *ares;\n  int ares_num;\n\n  /* This field was added in CURLVERSION_THIRD */\n  const char *libidn;\n\n  /* These field were added in CURLVERSION_FOURTH */\n\n  /* Same as '_libiconv_version' if built with HAVE_ICONV */\n  int iconv_ver_num;\n\n  const char *libssh_version; /* human readable string */\n\n  /* These fields were added in CURLVERSION_FIFTH */\n  unsigned int brotli_ver_num; /* Numeric Brotli version\n                                  (MAJOR << 24) | (MINOR << 12) | PATCH */\n  const char *brotli_version; /* human readable string. */\n\n  /* These fields were added in CURLVERSION_SIXTH */\n  unsigned int nghttp2_ver_num; /* Numeric nghttp2 version\n                                   (MAJOR << 16) | (MINOR << 8) | PATCH */\n  const char *nghttp2_version; /* human readable string. */\n  const char *quic_version;    /* human readable quic (+ HTTP/3) library +\n                                  version or NULL */\n\n  /* These fields were added in CURLVERSION_SEVENTH */\n  const char *cainfo;          /* the built-in default CURLOPT_CAINFO, might\n                                  be NULL */\n  const char *capath;          /* the built-in default CURLOPT_CAPATH, might\n                                  be NULL */\n\n  /* These fields were added in CURLVERSION_EIGHTH */\n  unsigned int zstd_ver_num; /* Numeric Zstd version\n                                  (MAJOR << 24) | (MINOR << 12) | PATCH */\n  const char *zstd_version; /* human readable string. */\n\n};\ntypedef struct curl_version_info_data curl_version_info_data;\n\n#define CURL_VERSION_IPV6         (1<<0)  /* IPv6-enabled */\n#define CURL_VERSION_KERBEROS4    (1<<1)  /* Kerberos V4 auth is supported\n                                             (deprecated) */\n#define CURL_VERSION_SSL          (1<<2)  /* SSL options are present */\n#define CURL_VERSION_LIBZ         (1<<3)  /* libz features are present */\n#define CURL_VERSION_NTLM         (1<<4)  /* NTLM auth is supported */\n#define CURL_VERSION_GSSNEGOTIATE (1<<5)  /* Negotiate auth is supported\n                                             (deprecated) */\n#define CURL_VERSION_DEBUG        (1<<6)  /* Built with debug capabilities */\n#define CURL_VERSION_ASYNCHDNS    (1<<7)  /* Asynchronous DNS resolves */\n#define CURL_VERSION_SPNEGO       (1<<8)  /* SPNEGO auth is supported */\n#define CURL_VERSION_LARGEFILE    (1<<9)  /* Supports files larger than 2GB */\n#define CURL_VERSION_IDN          (1<<10) /* Internationized Domain Names are\n                                             supported */\n#define CURL_VERSION_SSPI         (1<<11) /* Built against Windows SSPI */\n#define CURL_VERSION_CONV         (1<<12) /* Character conversions supported */\n#define CURL_VERSION_CURLDEBUG    (1<<13) /* Debug memory tracking supported */\n#define CURL_VERSION_TLSAUTH_SRP  (1<<14) /* TLS-SRP auth is supported */\n#define CURL_VERSION_NTLM_WB      (1<<15) /* NTLM delegation to winbind helper\n                                             is supported */\n#define CURL_VERSION_HTTP2        (1<<16) /* HTTP2 support built-in */\n#define CURL_VERSION_GSSAPI       (1<<17) /* Built against a GSS-API library */\n#define CURL_VERSION_KERBEROS5    (1<<18) /* Kerberos V5 auth is supported */\n#define CURL_VERSION_UNIX_SOCKETS (1<<19) /* Unix domain sockets support */\n#define CURL_VERSION_PSL          (1<<20) /* Mozilla's Public Suffix List, used\n                                             for cookie domain verification */\n#define CURL_VERSION_HTTPS_PROXY  (1<<21) /* HTTPS-proxy support built-in */\n#define CURL_VERSION_MULTI_SSL    (1<<22) /* Multiple SSL backends available */\n#define CURL_VERSION_BROTLI       (1<<23) /* Brotli features are present. */\n#define CURL_VERSION_ALTSVC       (1<<24) /* Alt-Svc handling built-in */\n#define CURL_VERSION_HTTP3        (1<<25) /* HTTP3 support built-in */\n#define CURL_VERSION_ZSTD         (1<<26) /* zstd features are present */\n#define CURL_VERSION_UNICODE      (1<<27) /* Unicode support on Windows */\n\n /*\n * NAME curl_version_info()\n *\n * DESCRIPTION\n *\n * This function returns a pointer to a static copy of the version info\n * struct. See above.\n */\nCURL_EXTERN curl_version_info_data *curl_version_info(CURLversion);\n\n/*\n * NAME curl_easy_strerror()\n *\n * DESCRIPTION\n *\n * The curl_easy_strerror function may be used to turn a CURLcode value\n * into the equivalent human readable error string.  This is useful\n * for printing meaningful error messages.\n */\nCURL_EXTERN const char *curl_easy_strerror(CURLcode);\n\n/*\n * NAME curl_share_strerror()\n *\n * DESCRIPTION\n *\n * The curl_share_strerror function may be used to turn a CURLSHcode value\n * into the equivalent human readable error string.  This is useful\n * for printing meaningful error messages.\n */\nCURL_EXTERN const char *curl_share_strerror(CURLSHcode);\n\n/*\n * NAME curl_easy_pause()\n *\n * DESCRIPTION\n *\n * The curl_easy_pause function pauses or unpauses transfers. Select the new\n * state by setting the bitmask, use the convenience defines below.\n *\n */\nCURL_EXTERN CURLcode curl_easy_pause(CURL *handle, int bitmask);\n\n#define CURLPAUSE_RECV      (1<<0)\n#define CURLPAUSE_RECV_CONT (0)\n\n#define CURLPAUSE_SEND      (1<<2)\n#define CURLPAUSE_SEND_CONT (0)\n\n#define CURLPAUSE_ALL       (CURLPAUSE_RECV|CURLPAUSE_SEND)\n#define CURLPAUSE_CONT      (CURLPAUSE_RECV_CONT|CURLPAUSE_SEND_CONT)\n\n#ifdef  __cplusplus\n}\n#endif\n\n/* unfortunately, the easy.h and multi.h include files need options and info\n  stuff before they can be included! */\n#include \"easy.h\" /* nothing in curl is fun without the easy stuff */\n#include \"multi.h\"\n#include \"urlapi.h\"\n#include \"options.h\"\n\n/* the typechecker doesn't work in C++ (yet) */\n#if defined(__GNUC__) && defined(__GNUC_MINOR__) && \\\n    ((__GNUC__ > 4) || (__GNUC__ == 4 && __GNUC_MINOR__ >= 3)) && \\\n    !defined(__cplusplus) && !defined(CURL_DISABLE_TYPECHECK)\n#include \"typecheck-gcc.h\"\n#else\n#if defined(__STDC__) && (__STDC__ >= 1)\n/* This preprocessor magic that replaces a call with the exact same call is\n   only done to make sure application authors pass exactly three arguments\n   to these functions. */\n#define curl_easy_setopt(handle,opt,param) curl_easy_setopt(handle,opt,param)\n#define curl_easy_getinfo(handle,info,arg) curl_easy_getinfo(handle,info,arg)\n#define curl_share_setopt(share,opt,param) curl_share_setopt(share,opt,param)\n#define curl_multi_setopt(handle,opt,param) curl_multi_setopt(handle,opt,param)\n#endif /* __STDC__ >= 1 */\n#endif /* gcc >= 4.3 && !__cplusplus */\n\n#endif /* CURLINC_CURL_H */\n"}, "32": {"id": 32, "path": "/home/runner/work/testcc/testcc/retdec/lib/urldata.h", "content": "#ifndef HEADER_CURL_URLDATA_H\n#define HEADER_CURL_URLDATA_H\n/***************************************************************************\n *                                  _   _ ____  _\n *  Project                     ___| | | |  _ \\| |\n *                             / __| | | | |_) | |\n *                            | (__| |_| |  _ <| |___\n *                             \\___|\\___/|_| \\_\\_____|\n *\n * Copyright (C) 1998 - 2020, Daniel Stenberg, <daniel@haxx.se>, et al.\n *\n * This software is licensed as described in the file COPYING, which\n * you should have received as part of this distribution. The terms\n * are also available at https://curl.haxx.se/docs/copyright.html.\n *\n * You may opt to use, copy, modify, merge, publish, distribute and/or sell\n * copies of the Software, and permit persons to whom the Software is\n * furnished to do so, under the terms of the COPYING file.\n *\n * This software is distributed on an \"AS IS\" basis, WITHOUT WARRANTY OF ANY\n * KIND, either express or implied.\n *\n ***************************************************************************/\n\n/* This file is for lib internal stuff */\n\n#include \"curl_setup.h\"\n\n#define PORT_FTP 21\n#define PORT_FTPS 990\n#define PORT_TELNET 23\n#define PORT_HTTP 80\n#define PORT_HTTPS 443\n#define PORT_DICT 2628\n#define PORT_LDAP 389\n#define PORT_LDAPS 636\n#define PORT_TFTP 69\n#define PORT_SSH 22\n#define PORT_IMAP 143\n#define PORT_IMAPS 993\n#define PORT_POP3 110\n#define PORT_POP3S 995\n#define PORT_SMB 445\n#define PORT_SMBS 445\n#define PORT_SMTP 25\n#define PORT_SMTPS 465 /* sometimes called SSMTP */\n#define PORT_RTSP 554\n#define PORT_RTMP 1935\n#define PORT_RTMPT PORT_HTTP\n#define PORT_RTMPS PORT_HTTPS\n#define PORT_GOPHER 70\n#define PORT_MQTT 1883\n\n#define DICT_MATCH \"/MATCH:\"\n#define DICT_MATCH2 \"/M:\"\n#define DICT_MATCH3 \"/FIND:\"\n#define DICT_DEFINE \"/DEFINE:\"\n#define DICT_DEFINE2 \"/D:\"\n#define DICT_DEFINE3 \"/LOOKUP:\"\n\n#define CURL_DEFAULT_USER \"anonymous\"\n#define CURL_DEFAULT_PASSWORD \"ftp@example.com\"\n\n/* Convenience defines for checking protocols or their SSL based version. Each\n   protocol handler should only ever have a single CURLPROTO_ in its protocol\n   field. */\n#define PROTO_FAMILY_HTTP (CURLPROTO_HTTP|CURLPROTO_HTTPS)\n#define PROTO_FAMILY_FTP  (CURLPROTO_FTP|CURLPROTO_FTPS)\n#define PROTO_FAMILY_POP3 (CURLPROTO_POP3|CURLPROTO_POP3S)\n#define PROTO_FAMILY_SMB  (CURLPROTO_SMB|CURLPROTO_SMBS)\n#define PROTO_FAMILY_SMTP (CURLPROTO_SMTP|CURLPROTO_SMTPS)\n#define PROTO_FAMILY_SSH  (CURLPROTO_SCP|CURLPROTO_SFTP)\n\n#define DEFAULT_CONNCACHE_SIZE 5\n\n/* length of longest IPv6 address string including the trailing null */\n#define MAX_IPADR_LEN sizeof(\"ffff:ffff:ffff:ffff:ffff:ffff:255.255.255.255\")\n\n/* Default FTP/IMAP etc response timeout in milliseconds.\n   Symbian OS panics when given a timeout much greater than 1/2 hour.\n*/\n#define RESP_TIMEOUT (120*1000)\n\n/* Max string input length is a precaution against abuse and to detect junk\n   input easier and better. */\n#define CURL_MAX_INPUT_LENGTH 8000000\n\n#include \"cookie.h\"\n#include \"psl.h\"\n#include \"formdata.h\"\n\n#ifdef HAVE_NETINET_IN_H\n#include <netinet/in.h>\n#endif\n#ifdef HAVE_NETINET_IN6_H\n#include <netinet/in6.h>\n#endif\n\n#include \"timeval.h\"\n\n#include <curl/curl.h>\n\n#include \"http_chunks.h\" /* for the structs and enum stuff */\n#include \"hostip.h\"\n#include \"hash.h\"\n#include \"splay.h\"\n#include \"dynbuf.h\"\n\n/* return the count of bytes sent, or -1 on error */\ntypedef ssize_t (Curl_send)(struct connectdata *conn, /* connection data */\n                            int sockindex,            /* socketindex */\n                            const void *buf,          /* data to write */\n                            size_t len,               /* max amount to write */\n                            CURLcode *err);           /* error to return */\n\n/* return the count of bytes read, or -1 on error */\ntypedef ssize_t (Curl_recv)(struct connectdata *conn, /* connection data */\n                            int sockindex,            /* socketindex */\n                            char *buf,                /* store data here */\n                            size_t len,               /* max amount to read */\n                            CURLcode *err);           /* error to return */\n\n#include \"mime.h\"\n#include \"imap.h\"\n#include \"pop3.h\"\n#include \"smtp.h\"\n#include \"ftp.h\"\n#include \"file.h\"\n#include \"vssh/ssh.h\"\n#include \"http.h\"\n#include \"rtsp.h\"\n#include \"smb.h\"\n#include \"mqtt.h\"\n#include \"wildcard.h\"\n#include \"multihandle.h\"\n#include \"quic.h\"\n\n#ifdef HAVE_GSSAPI\n# ifdef HAVE_GSSGNU\n#  include <gss.h>\n# elif defined HAVE_GSSAPI_GSSAPI_H\n#  include <gssapi/gssapi.h>\n# else\n#  include <gssapi.h>\n# endif\n# ifdef HAVE_GSSAPI_GSSAPI_GENERIC_H\n#  include <gssapi/gssapi_generic.h>\n# endif\n#endif\n\n#ifdef HAVE_LIBSSH2_H\n#include <libssh2.h>\n#include <libssh2_sftp.h>\n#endif /* HAVE_LIBSSH2_H */\n\n#define CURLEASY_MAGIC_NUMBER 0xc0dedbadU\n#define GOOD_EASY_HANDLE(x) \\\n  ((x) && ((x)->magic == CURLEASY_MAGIC_NUMBER))\n\n/* the type we use for storing a single boolean bit */\n#ifdef _MSC_VER\ntypedef bool bit;\n#define BIT(x) bool x\n#else\ntypedef unsigned int bit;\n#define BIT(x) bit x:1\n#endif\n\n#ifdef HAVE_GSSAPI\n/* Types needed for krb5-ftp connections */\nstruct krb5buffer {\n  void *data;\n  size_t size;\n  size_t index;\n  BIT(eof_flag);\n};\n\nenum protection_level {\n  PROT_NONE, /* first in list */\n  PROT_CLEAR,\n  PROT_SAFE,\n  PROT_CONFIDENTIAL,\n  PROT_PRIVATE,\n  PROT_CMD,\n  PROT_LAST /* last in list */\n};\n#endif\n\n/* enum for the nonblocking SSL connection state machine */\ntypedef enum {\n  ssl_connect_1,\n  ssl_connect_2,\n  ssl_connect_2_reading,\n  ssl_connect_2_writing,\n  ssl_connect_3,\n  ssl_connect_done\n} ssl_connect_state;\n\ntypedef enum {\n  ssl_connection_none,\n  ssl_connection_negotiating,\n  ssl_connection_complete\n} ssl_connection_state;\n\n/* SSL backend-specific data; declared differently by each SSL backend */\nstruct ssl_backend_data;\n\n/* struct for data related to each SSL connection */\nstruct ssl_connect_data {\n  /* Use ssl encrypted communications TRUE/FALSE, not necessarily using it atm\n     but at least asked to or meaning to use it. See 'state' for the exact\n     current state of the connection. */\n  ssl_connection_state state;\n  ssl_connect_state connecting_state;\n#if defined(USE_SSL)\n  struct ssl_backend_data *backend;\n#endif\n  BIT(use);\n};\n\nstruct ssl_primary_config {\n  long version;          /* what version the client wants to use */\n  long version_max;      /* max supported version the client wants to use*/\n  char *CApath;          /* certificate dir (doesn't work on windows) */\n  char *CAfile;          /* certificate to verify peer against */\n  char *clientcert;\n  char *random_file;     /* path to file containing \"random\" data */\n  char *egdsocket;       /* path to file containing the EGD daemon socket */\n  char *cipher_list;     /* list of ciphers to use */\n  char *cipher_list13;   /* list of TLS 1.3 cipher suites to use */\n  char *pinned_key;\n  struct curl_blob *cert_blob;\n  char *curves;          /* list of curves to use */\n  BIT(verifypeer);       /* set TRUE if this is desired */\n  BIT(verifyhost);       /* set TRUE if CN/SAN must match hostname */\n  BIT(verifystatus);     /* set TRUE if certificate status must be checked */\n  BIT(sessionid);        /* cache session IDs or not */\n};\n\nstruct ssl_config_data {\n  struct ssl_primary_config primary;\n  long certverifyresult; /* result from the certificate verification */\n  char *CRLfile;   /* CRL to check certificate revocation */\n  char *issuercert;/* optional issuer certificate filename */\n  struct curl_blob *issuercert_blob;\n  curl_ssl_ctx_callback fsslctx; /* function to initialize ssl ctx */\n  void *fsslctxp;        /* parameter for call back */\n  char *cert; /* client certificate file name */\n  struct curl_blob *cert_blob;\n  char *cert_type; /* format for certificate (default: PEM)*/\n  char *key; /* private key file name */\n  struct curl_blob *key_blob;\n  char *key_type; /* format for private key (default: PEM) */\n  char *key_passwd; /* plain text private key password */\n#ifdef USE_TLS_SRP\n  char *username; /* TLS username (for, e.g., SRP) */\n  char *password; /* TLS password (for, e.g., SRP) */\n  enum CURL_TLSAUTH authtype; /* TLS authentication type (default SRP) */\n#endif\n  BIT(certinfo);     /* gather lots of certificate info */\n  BIT(falsestart);\n  BIT(enable_beast); /* allow this flaw for interoperability's sake*/\n  BIT(no_revoke);    /* disable SSL certificate revocation checks */\n  BIT(no_partialchain); /* don't accept partial certificate chains */\n  BIT(revoke_best_effort); /* ignore SSL revocation offline/missing revocation\n                              list errors */\n  BIT(native_ca_store); /* use the native ca store of operating system */\n};\n\nstruct ssl_general_config {\n  size_t max_ssl_sessions; /* SSL session id cache size */\n};\n\n/* information stored about one single SSL session */\nstruct curl_ssl_session {\n  char *name;       /* host name for which this ID was used */\n  char *conn_to_host; /* host name for the connection (may be NULL) */\n  const char *scheme; /* protocol scheme used */\n  void *sessionid;  /* as returned from the SSL layer */\n  size_t idsize;    /* if known, otherwise 0 */\n  long age;         /* just a number, the higher the more recent */\n  int remote_port;  /* remote port */\n  int conn_to_port; /* remote port for the connection (may be -1) */\n  struct ssl_primary_config ssl_config; /* setup for this session */\n};\n\n#ifdef USE_WINDOWS_SSPI\n#include \"curl_sspi.h\"\n#endif\n\n/* Struct used for Digest challenge-response authentication */\nstruct digestdata {\n#if defined(USE_WINDOWS_SSPI)\n  BYTE *input_token;\n  size_t input_token_len;\n  CtxtHandle *http_context;\n  /* copy of user/passwd used to make the identity for http_context.\n     either may be NULL. */\n  char *user;\n  char *passwd;\n#else\n  char *nonce;\n  char *cnonce;\n  char *realm;\n  int algo;\n  char *opaque;\n  char *qop;\n  char *algorithm;\n  int nc; /* nounce count */\n  BIT(stale); /* set true for re-negotiation */\n  BIT(userhash);\n#endif\n};\n\ntypedef enum {\n  NTLMSTATE_NONE,\n  NTLMSTATE_TYPE1,\n  NTLMSTATE_TYPE2,\n  NTLMSTATE_TYPE3,\n  NTLMSTATE_LAST\n} curlntlm;\n\ntypedef enum {\n  GSS_AUTHNONE,\n  GSS_AUTHRECV,\n  GSS_AUTHSENT,\n  GSS_AUTHDONE,\n  GSS_AUTHSUCC\n} curlnegotiate;\n\n#if defined(CURL_DOES_CONVERSIONS) && defined(HAVE_ICONV)\n#include <iconv.h>\n#endif\n\n/* Struct used for GSSAPI (Kerberos V5) authentication */\n#if defined(USE_KERBEROS5)\nstruct kerberos5data {\n#if defined(USE_WINDOWS_SSPI)\n  CredHandle *credentials;\n  CtxtHandle *context;\n  TCHAR *spn;\n  SEC_WINNT_AUTH_IDENTITY identity;\n  SEC_WINNT_AUTH_IDENTITY *p_identity;\n  size_t token_max;\n  BYTE *output_token;\n#else\n  gss_ctx_id_t context;\n  gss_name_t spn;\n#endif\n};\n#endif\n\n/* Struct used for NTLM challenge-response authentication */\n#if defined(USE_NTLM)\nstruct ntlmdata {\n#ifdef USE_WINDOWS_SSPI\n/* The sslContext is used for the Schannel bindings. The\n * api is available on the Windows 7 SDK and later.\n */\n#ifdef SECPKG_ATTR_ENDPOINT_BINDINGS\n  CtxtHandle *sslContext;\n#endif\n  CredHandle *credentials;\n  CtxtHandle *context;\n  SEC_WINNT_AUTH_IDENTITY identity;\n  SEC_WINNT_AUTH_IDENTITY *p_identity;\n  size_t token_max;\n  BYTE *output_token;\n  BYTE *input_token;\n  size_t input_token_len;\n  TCHAR *spn;\n#else\n  unsigned int flags;\n  unsigned char nonce[8];\n  void *target_info; /* TargetInfo received in the ntlm type-2 message */\n  unsigned int target_info_len;\n\n#if defined(NTLM_WB_ENABLED)\n  /* used for communication with Samba's winbind daemon helper ntlm_auth */\n  curl_socket_t ntlm_auth_hlpr_socket;\n  pid_t ntlm_auth_hlpr_pid;\n  char *challenge; /* The received base64 encoded ntlm type-2 message */\n  char *response;  /* The generated base64 ntlm type-1/type-3 message */\n#endif\n#endif\n};\n#endif\n\n/* Struct used for Negotiate (SPNEGO) authentication */\n#ifdef USE_SPNEGO\nstruct negotiatedata {\n#ifdef HAVE_GSSAPI\n  OM_uint32 status;\n  gss_ctx_id_t context;\n  gss_name_t spn;\n  gss_buffer_desc output_token;\n#else\n#ifdef USE_WINDOWS_SSPI\n#ifdef SECPKG_ATTR_ENDPOINT_BINDINGS\n  CtxtHandle *sslContext;\n#endif\n  DWORD status;\n  CredHandle *credentials;\n  CtxtHandle *context;\n  SEC_WINNT_AUTH_IDENTITY identity;\n  SEC_WINNT_AUTH_IDENTITY *p_identity;\n  TCHAR *spn;\n  size_t token_max;\n  BYTE *output_token;\n  size_t output_token_length;\n#endif\n#endif\n  BIT(noauthpersist);\n  BIT(havenoauthpersist);\n  BIT(havenegdata);\n  BIT(havemultiplerequests);\n};\n#endif\n\n\n/*\n * Boolean values that concerns this connection.\n */\nstruct ConnectBits {\n  bool tcpconnect[2]; /* the TCP layer (or similar) is connected, this is set\n                         the first time on the first connect function call */\n#ifndef CURL_DISABLE_PROXY\n  bool proxy_ssl_connected[2]; /* TRUE when SSL initialization for HTTPS proxy\n                                  is complete */\n  BIT(httpproxy);  /* if set, this transfer is done through a http proxy */\n  BIT(socksproxy); /* if set, this transfer is done through a socks proxy */\n  BIT(proxy_user_passwd); /* user+password for the proxy? */\n  BIT(tunnel_proxy);  /* if CONNECT is used to \"tunnel\" through the proxy.\n                         This is implicit when SSL-protocols are used through\n                         proxies, but can also be enabled explicitly by\n                         apps */\n  BIT(proxy_connect_closed); /* TRUE if a proxy disconnected the connection\n                                in a CONNECT request with auth, so that\n                                libcurl should reconnect and continue. */\n#endif\n  /* always modify bits.close with the connclose() and connkeep() macros! */\n  BIT(close); /* if set, we close the connection after this request */\n  BIT(reuse); /* if set, this is a re-used connection */\n  BIT(altused); /* this is an alt-svc \"redirect\" */\n  BIT(conn_to_host); /* if set, this connection has a \"connect to host\"\n                        that overrides the host in the URL */\n  BIT(conn_to_port); /* if set, this connection has a \"connect to port\"\n                        that overrides the port in the URL (remote port) */\n  BIT(proxy); /* if set, this transfer is done through a proxy - any type */\n  BIT(user_passwd); /* do we use user+password for this connection? */\n  BIT(ipv6_ip); /* we communicate with a remote site specified with pure IPv6\n                   IP address */\n  BIT(ipv6);    /* we communicate with a site using an IPv6 address */\n  BIT(do_more); /* this is set TRUE if the ->curl_do_more() function is\n                   supposed to be called, after ->curl_do() */\n  BIT(protoconnstart);/* the protocol layer has STARTED its operation after\n                         the TCP layer connect */\n  BIT(retry);         /* this connection is about to get closed and then\n                         re-attempted at another connection. */\n  BIT(authneg);       /* TRUE when the auth phase has started, which means\n                         that we are creating a request with an auth header,\n                         but it is not the final request in the auth\n                         negotiation. */\n  BIT(rewindaftersend);/* TRUE when the sending couldn't be stopped even\n                          though it will be discarded. When the whole send\n                          operation is done, we must call the data rewind\n                          callback. */\n#ifndef CURL_DISABLE_FTP\n  BIT(ftp_use_epsv);  /* As set with CURLOPT_FTP_USE_EPSV, but if we find out\n                         EPSV doesn't work we disable it for the forthcoming\n                         requests */\n  BIT(ftp_use_eprt);  /* As set with CURLOPT_FTP_USE_EPRT, but if we find out\n                         EPRT doesn't work we disable it for the forthcoming\n                         requests */\n  BIT(ftp_use_data_ssl); /* Enabled SSL for the data connection */\n#endif\n  BIT(netrc);         /* name+password provided by netrc */\n  BIT(bound); /* set true if bind() has already been done on this socket/\n                 connection */\n  BIT(multiplex); /* connection is multiplexed */\n  BIT(tcp_fastopen); /* use TCP Fast Open */\n  BIT(tls_enable_npn);  /* TLS NPN extension? */\n  BIT(tls_enable_alpn); /* TLS ALPN extension? */\n  BIT(connect_only);\n  BIT(doh);\n#ifdef USE_UNIX_SOCKETS\n  BIT(abstract_unix_socket);\n#endif\n  BIT(tls_upgraded);\n  BIT(sock_accepted); /* TRUE if the SECONDARYSOCKET was created with\n                         accept() */\n  BIT(parallel_connect); /* set TRUE when a parallel connect attempt has\n                            started (happy eyeballs) */\n};\n\nstruct hostname {\n  char *rawalloc; /* allocated \"raw\" version of the name */\n  char *encalloc; /* allocated IDN-encoded version of the name */\n  char *name;     /* name to use internally, might be encoded, might be raw */\n  const char *dispname; /* name to display, as 'name' might be encoded */\n};\n\n/*\n * Flags on the keepon member of the Curl_transfer_keeper\n */\n\n#define KEEP_NONE  0\n#define KEEP_RECV  (1<<0)     /* there is or may be data to read */\n#define KEEP_SEND (1<<1)     /* there is or may be data to write */\n#define KEEP_RECV_HOLD (1<<2) /* when set, no reading should be done but there\n                                 might still be data to read */\n#define KEEP_SEND_HOLD (1<<3) /* when set, no writing should be done but there\n                                  might still be data to write */\n#define KEEP_RECV_PAUSE (1<<4) /* reading is paused */\n#define KEEP_SEND_PAUSE (1<<5) /* writing is paused */\n\n#define KEEP_RECVBITS (KEEP_RECV | KEEP_RECV_HOLD | KEEP_RECV_PAUSE)\n#define KEEP_SENDBITS (KEEP_SEND | KEEP_SEND_HOLD | KEEP_SEND_PAUSE)\n\nstruct Curl_async {\n  char *hostname;\n  int port;\n  struct Curl_dns_entry *dns;\n  int status; /* if done is TRUE, this is the status from the callback */\n  void *os_specific;  /* 'struct thread_data' for Windows */\n  BIT(done);  /* set TRUE when the lookup is complete */\n};\n\n#define FIRSTSOCKET     0\n#define SECONDARYSOCKET 1\n\n/* These function pointer types are here only to allow easier typecasting\n   within the source when we need to cast between data pointers (such as NULL)\n   and function pointers. */\ntypedef CURLcode (*Curl_do_more_func)(struct connectdata *, int *);\ntypedef CURLcode (*Curl_done_func)(struct connectdata *, CURLcode, bool);\n\nenum expect100 {\n  EXP100_SEND_DATA,           /* enough waiting, just send the body now */\n  EXP100_AWAITING_CONTINUE,   /* waiting for the 100 Continue header */\n  EXP100_SENDING_REQUEST,     /* still sending the request but will wait for\n                                 the 100 header once done with the request */\n  EXP100_FAILED               /* used on 417 Expectation Failed */\n};\n\nenum upgrade101 {\n  UPGR101_INIT,               /* default state */\n  UPGR101_REQUESTED,          /* upgrade requested */\n  UPGR101_RECEIVED,           /* response received */\n  UPGR101_WORKING             /* talking upgraded protocol */\n};\n\nenum doh_slots {\n  /* Explicit values for first two symbols so as to match hard-coded\n   * constants in existing code\n   */\n  DOH_PROBE_SLOT_IPADDR_V4 = 0, /* make 'V4' stand out for readability */\n  DOH_PROBE_SLOT_IPADDR_V6 = 1, /* 'V6' likewise */\n\n  /* Space here for (possibly build-specific) additional slot definitions */\n\n  /* for example */\n  /* #ifdef WANT_DOH_FOOBAR_TXT */\n  /*   DOH_PROBE_SLOT_FOOBAR_TXT, */\n  /* #endif */\n\n  /* AFTER all slot definitions, establish how many we have */\n  DOH_PROBE_SLOTS\n};\n\n/* one of these for each DoH request */\nstruct dnsprobe {\n  CURL *easy;\n  int dnstype;\n  unsigned char dohbuffer[512];\n  size_t dohlen;\n  struct dynbuf serverdoh;\n};\n\nstruct dohdata {\n  struct curl_slist *headers;\n  struct dnsprobe probe[DOH_PROBE_SLOTS];\n  unsigned int pending; /* still outstanding requests */\n  const char *host;\n  int port;\n};\n\n/*\n * Request specific data in the easy handle (Curl_easy).  Previously,\n * these members were on the connectdata struct but since a conn struct may\n * now be shared between different Curl_easys, we store connection-specific\n * data here. This struct only keeps stuff that's interesting for *this*\n * request, as it will be cleared between multiple ones\n */\nstruct SingleRequest {\n  curl_off_t size;        /* -1 if unknown at this point */\n  curl_off_t maxdownload; /* in bytes, the maximum amount of data to fetch,\n                             -1 means unlimited */\n  curl_off_t bytecount;         /* total number of bytes read */\n  curl_off_t writebytecount;    /* number of bytes written */\n\n  curl_off_t headerbytecount;   /* only count received headers */\n  curl_off_t deductheadercount; /* this amount of bytes doesn't count when we\n                                   check if anything has been transferred at\n                                   the end of a connection. We use this\n                                   counter to make only a 100 reply (without a\n                                   following second response code) result in a\n                                   CURLE_GOT_NOTHING error code */\n\n  struct curltime start;         /* transfer started at this time */\n  struct curltime now;           /* current time */\n  enum {\n    HEADER_NORMAL,              /* no bad header at all */\n    HEADER_PARTHEADER,          /* part of the chunk is a bad header, the rest\n                                   is normal data */\n    HEADER_ALLBAD               /* all was believed to be header */\n  } badheader;                  /* the header was deemed bad and will be\n                                   written as body */\n  int headerline;               /* counts header lines to better track the\n                                   first one */\n  char *str;                    /* within buf */\n  curl_off_t offset;            /* possible resume offset read from the\n                                   Content-Range: header */\n  int httpcode;                 /* error code from the 'HTTP/1.? XXX' or\n                                   'RTSP/1.? XXX' line */\n  struct curltime start100;      /* time stamp to wait for the 100 code from */\n  enum expect100 exp100;        /* expect 100 continue state */\n  enum upgrade101 upgr101;      /* 101 upgrade state */\n\n  /* Content unencoding stack. See sec 3.5, RFC2616. */\n  struct contenc_writer *writer_stack;\n  time_t timeofdoc;\n  long bodywrites;\n  int keepon;\n  char *location;   /* This points to an allocated version of the Location:\n                       header data */\n  char *newurl;     /* Set to the new URL to use when a redirect or a retry is\n                       wanted */\n\n  /* 'upload_present' is used to keep a byte counter of how much data there is\n     still left in the buffer, aimed for upload. */\n  ssize_t upload_present;\n\n  /* 'upload_fromhere' is used as a read-pointer when we uploaded parts of a\n     buffer, so the next read should read from where this pointer points to,\n     and the 'upload_present' contains the number of bytes available at this\n     position */\n  char *upload_fromhere;\n  void *protop;       /* Allocated protocol-specific data. Each protocol\n                         handler makes sure this points to data it needs. */\n#ifndef CURL_DISABLE_DOH\n  struct dohdata doh; /* DoH specific data for this request */\n#endif\n  BIT(header);       /* incoming data has HTTP header */\n  BIT(content_range); /* set TRUE if Content-Range: was found */\n  BIT(upload_done);  /* set to TRUE when doing chunked transfer-encoding\n                        upload and we're uploading the last chunk */\n  BIT(ignorebody);   /* we read a response-body but we ignore it! */\n  BIT(http_bodyless); /* HTTP response status code is between 100 and 199,\n                         204 or 304 */\n  BIT(chunk); /* if set, this is a chunked transfer-encoding */\n  BIT(upload_chunky); /* set TRUE if we are doing chunked transfer-encoding\n                         on upload */\n  BIT(getheader);    /* TRUE if header parsing is wanted */\n  BIT(forbidchunk);  /* used only to explicitly forbid chunk-upload for\n                        specific upload buffers. See readmoredata() in http.c\n                        for details. */\n};\n\n/*\n * Specific protocol handler.\n */\n\nstruct Curl_handler {\n  const char *scheme;        /* URL scheme name. */\n\n  /* Complement to setup_connection_internals(). */\n  CURLcode (*setup_connection)(struct connectdata *);\n\n  /* These two functions MUST be set to be protocol dependent */\n  CURLcode (*do_it)(struct connectdata *, bool *done);\n  Curl_done_func done;\n\n  /* If the curl_do() function is better made in two halves, this\n   * curl_do_more() function will be called afterwards, if set. For example\n   * for doing the FTP stuff after the PASV/PORT command.\n   */\n  Curl_do_more_func do_more;\n\n  /* This function *MAY* be set to a protocol-dependent function that is run\n   * after the connect() and everything is done, as a step in the connection.\n   * The 'done' pointer points to a bool that should be set to TRUE if the\n   * function completes before return. If it doesn't complete, the caller\n   * should call the curl_connecting() function until it is.\n   */\n  CURLcode (*connect_it)(struct connectdata *, bool *done);\n\n  /* See above. */\n  CURLcode (*connecting)(struct connectdata *, bool *done);\n  CURLcode (*doing)(struct connectdata *, bool *done);\n\n  /* Called from the multi interface during the PROTOCONNECT phase, and it\n     should then return a proper fd set */\n  int (*proto_getsock)(struct connectdata *conn,\n                       curl_socket_t *socks);\n\n  /* Called from the multi interface during the DOING phase, and it should\n     then return a proper fd set */\n  int (*doing_getsock)(struct connectdata *conn,\n                       curl_socket_t *socks);\n\n  /* Called from the multi interface during the DO_MORE phase, and it should\n     then return a proper fd set */\n  int (*domore_getsock)(struct connectdata *conn,\n                        curl_socket_t *socks);\n\n  /* Called from the multi interface during the DO_DONE, PERFORM and\n     WAITPERFORM phases, and it should then return a proper fd set. Not setting\n     this will make libcurl use the generic default one. */\n  int (*perform_getsock)(const struct connectdata *conn,\n                         curl_socket_t *socks);\n\n  /* This function *MAY* be set to a protocol-dependent function that is run\n   * by the curl_disconnect(), as a step in the disconnection.  If the handler\n   * is called because the connection has been considered dead, dead_connection\n   * is set to TRUE.\n   */\n  CURLcode (*disconnect)(struct connectdata *, bool dead_connection);\n\n  /* If used, this function gets called from transfer.c:readwrite_data() to\n     allow the protocol to do extra reads/writes */\n  CURLcode (*readwrite)(struct Curl_easy *data, struct connectdata *conn,\n                        ssize_t *nread, bool *readmore);\n\n  /* This function can perform various checks on the connection. See\n     CONNCHECK_* for more information about the checks that can be performed,\n     and CONNRESULT_* for the results that can be returned. */\n  unsigned int (*connection_check)(struct connectdata *conn,\n                                   unsigned int checks_to_perform);\n\n  long defport;           /* Default port. */\n  unsigned int protocol;  /* See CURLPROTO_* - this needs to be the single\n                             specific protocol bit */\n  unsigned int flags;     /* Extra particular characteristics, see PROTOPT_* */\n};\n\n#define PROTOPT_NONE 0             /* nothing extra */\n#define PROTOPT_SSL (1<<0)         /* uses SSL */\n#define PROTOPT_DUAL (1<<1)        /* this protocol uses two connections */\n#define PROTOPT_CLOSEACTION (1<<2) /* need action before socket close */\n/* some protocols will have to call the underlying functions without regard to\n   what exact state the socket signals. IE even if the socket says \"readable\",\n   the send function might need to be called while uploading, or vice versa.\n*/\n#define PROTOPT_DIRLOCK (1<<3)\n#define PROTOPT_NONETWORK (1<<4)   /* protocol doesn't use the network! */\n#define PROTOPT_NEEDSPWD (1<<5)    /* needs a password, and if none is set it\n                                      gets a default */\n#define PROTOPT_NOURLQUERY (1<<6)   /* protocol can't handle\n                                        url query strings (?foo=bar) ! */\n#define PROTOPT_CREDSPERREQUEST (1<<7) /* requires login credentials per\n                                          request instead of per connection */\n#define PROTOPT_ALPN_NPN (1<<8) /* set ALPN and/or NPN for this */\n#define PROTOPT_STREAM (1<<9) /* a protocol with individual logical streams */\n#define PROTOPT_URLOPTIONS (1<<10) /* allow options part in the userinfo field\n                                      of the URL */\n#define PROTOPT_PROXY_AS_HTTP (1<<11) /* allow this non-HTTP scheme over a\n                                         HTTP proxy as HTTP proxies may know\n                                         this protocol and act as a gateway */\n#define PROTOPT_WILDCARD (1<<12) /* protocol supports wildcard matching */\n#define PROTOPT_USERPWDCTRL (1<<13) /* Allow \"control bytes\" (< 32 ascii) in\n                                       user name and password */\n\n#define CONNCHECK_NONE 0                 /* No checks */\n#define CONNCHECK_ISDEAD (1<<0)          /* Check if the connection is dead. */\n#define CONNCHECK_KEEPALIVE (1<<1)       /* Perform any keepalive function. */\n\n#define CONNRESULT_NONE 0                /* No extra information. */\n#define CONNRESULT_DEAD (1<<0)           /* The connection is dead. */\n\n#ifdef USE_RECV_BEFORE_SEND_WORKAROUND\nstruct postponed_data {\n  char *buffer;          /* Temporal store for received data during\n                            sending, must be freed */\n  size_t allocated_size; /* Size of temporal store */\n  size_t recv_size;      /* Size of received data during sending */\n  size_t recv_processed; /* Size of processed part of postponed data */\n#ifdef DEBUGBUILD\n  curl_socket_t bindsock;/* Structure must be bound to specific socket,\n                            used only for DEBUGASSERT */\n#endif /* DEBUGBUILD */\n};\n#endif /* USE_RECV_BEFORE_SEND_WORKAROUND */\n\nstruct proxy_info {\n  struct hostname host;\n  long port;\n  curl_proxytype proxytype; /* what kind of proxy that is in use */\n  char *user;    /* proxy user name string, allocated */\n  char *passwd;  /* proxy password string, allocated */\n};\n\n/* struct for HTTP CONNECT state data */\nstruct http_connect_state {\n  struct dynbuf rcvbuf;\n  int keepon;\n  curl_off_t cl; /* size of content to read and ignore */\n  enum {\n    TUNNEL_INIT,    /* init/default/no tunnel state */\n    TUNNEL_CONNECT, /* CONNECT has been sent off */\n    TUNNEL_COMPLETE /* CONNECT response received completely */\n  } tunnel_state;\n  BIT(chunked_encoding);\n  BIT(close_connection);\n};\n\nstruct ldapconninfo;\n\n/* for the (SOCKS) connect state machine */\nenum connect_t {\n  CONNECT_INIT,\n  CONNECT_SOCKS_INIT, /* 1 */\n  CONNECT_SOCKS_SEND, /* 2 waiting to send more first data */\n  CONNECT_SOCKS_READ_INIT, /* 3 set up read */\n  CONNECT_SOCKS_READ, /* 4 read server response */\n  CONNECT_GSSAPI_INIT, /* 5 */\n  CONNECT_AUTH_INIT, /* 6 setup outgoing auth buffer */\n  CONNECT_AUTH_SEND, /* 7 send auth */\n  CONNECT_AUTH_READ, /* 8 read auth response */\n  CONNECT_REQ_INIT,  /* 9 init SOCKS \"request\" */\n  CONNECT_RESOLVING, /* 10 */\n  CONNECT_RESOLVED,  /* 11 */\n  CONNECT_RESOLVE_REMOTE, /* 12 */\n  CONNECT_REQ_SEND,  /* 13 */\n  CONNECT_REQ_SENDING, /* 14 */\n  CONNECT_REQ_READ,  /* 15 */\n  CONNECT_REQ_READ_MORE, /* 16 */\n  CONNECT_DONE /* 17 connected fine to the remote or the SOCKS proxy */\n};\n\n#define SOCKS_STATE(x) (((x) >= CONNECT_SOCKS_INIT) &&  \\\n                        ((x) < CONNECT_DONE))\n#define SOCKS_REQUEST_BUFSIZE 600  /* room for large user/pw (255 max each) */\n\nstruct connstate {\n  enum connect_t state;\n  unsigned char socksreq[SOCKS_REQUEST_BUFSIZE];\n\n  /* CONNECT_SOCKS_SEND */\n  ssize_t outstanding;  /* send this many bytes more */\n  unsigned char *outp; /* send from this pointer */\n};\n\n/*\n * The connectdata struct contains all fields and variables that should be\n * unique for an entire connection.\n */\nstruct connectdata {\n  /* 'data' is the CURRENT Curl_easy using this connection -- take great\n     caution that this might very well vary between different times this\n     connection is used! */\n  struct Curl_easy *data;\n  struct connstate cnnct;\n  struct curl_llist_element bundle_node; /* conncache */\n\n  /* chunk is for HTTP chunked encoding, but is in the general connectdata\n     struct only because we can do just about any protocol through a HTTP proxy\n     and a HTTP proxy may in fact respond using chunked encoding */\n  struct Curl_chunker chunk;\n\n  curl_closesocket_callback fclosesocket; /* function closing the socket(s) */\n  void *closesocket_client;\n\n  /* This is used by the connection cache logic. If this returns TRUE, this\n     handle is still used by one or more easy handles and can only used by any\n     other easy handle without careful consideration (== only for\n     multiplexing) and it cannot be used by another multi handle! */\n#define CONN_INUSE(c) ((c)->easyq.size)\n\n  /**** Fields set when inited and not modified again */\n  long connection_id; /* Contains a unique number to make it easier to\n                         track the connections in the log output */\n\n  /* 'dns_entry' is the particular host we use. This points to an entry in the\n     DNS cache and it will not get pruned while locked. It gets unlocked in\n     multi_done(). This entry will be NULL if the connection is re-used as then\n     there is no name resolve done. */\n  struct Curl_dns_entry *dns_entry;\n\n  /* 'ip_addr' is the particular IP we connected to. It points to a struct\n     within the DNS cache, so this pointer is only valid as long as the DNS\n     cache entry remains locked. It gets unlocked in multi_done() */\n  struct Curl_addrinfo *ip_addr;\n  struct Curl_addrinfo *tempaddr[2]; /* for happy eyeballs */\n\n  /* 'ip_addr_str' is the ip_addr data as a human readable string.\n     It remains available as long as the connection does, which is longer than\n     the ip_addr itself. */\n  char ip_addr_str[MAX_IPADR_LEN];\n\n  unsigned int scope_id;  /* Scope id for IPv6 */\n\n  enum {\n    TRNSPRT_TCP = 3,\n    TRNSPRT_UDP = 4,\n    TRNSPRT_QUIC = 5\n  } transport;\n\n#ifdef ENABLE_QUIC\n  struct quicsocket hequic[2]; /* two, for happy eyeballs! */\n  struct quicsocket *quic;\n#endif\n\n  struct hostname host;\n  char *hostname_resolve; /* host name to resolve to address, allocated */\n  char *secondaryhostname; /* secondary socket host name (ftp) */\n  struct hostname conn_to_host; /* the host to connect to. valid only if\n                                   bits.conn_to_host is set */\n#ifndef CURL_DISABLE_PROXY\n  struct proxy_info socks_proxy;\n  struct proxy_info http_proxy;\n#endif\n  long port;       /* which port to use locally */\n  int remote_port; /* the remote port, not the proxy port! */\n  int conn_to_port; /* the remote port to connect to. valid only if\n                       bits.conn_to_port is set */\n  unsigned short secondary_port; /* secondary socket remote port to connect to\n                                    (ftp) */\n\n  /* 'primary_ip' and 'primary_port' get filled with peer's numerical\n     ip address and port number whenever an outgoing connection is\n     *attempted* from the primary socket to a remote address. When more\n     than one address is tried for a connection these will hold data\n     for the last attempt. When the connection is actually established\n     these are updated with data which comes directly from the socket. */\n\n  char primary_ip[MAX_IPADR_LEN];\n  long primary_port;\n\n  /* 'local_ip' and 'local_port' get filled with local's numerical\n     ip address and port number whenever an outgoing connection is\n     **established** from the primary socket to a remote address. */\n\n  char local_ip[MAX_IPADR_LEN];\n  long local_port;\n\n  char *user;    /* user name string, allocated */\n  char *passwd;  /* password string, allocated */\n  char *options; /* options string, allocated */\n\n  char *sasl_authzid;     /* authorisation identity string, allocated */\n\n  int httpversion;        /* the HTTP version*10 reported by the server */\n  int rtspversion;        /* the RTSP version*10 reported by the server */\n\n  struct curltime now;     /* \"current\" time */\n  struct curltime created; /* creation time */\n  struct curltime lastused; /* when returned to the connection cache */\n  curl_socket_t sock[2]; /* two sockets, the second is used for the data\n                            transfer when doing FTP */\n  curl_socket_t tempsock[2]; /* temporary sockets for happy eyeballs */\n  int tempfamily[2]; /* family used for the temp sockets */\n  Curl_recv *recv[2];\n  Curl_send *send[2];\n\n#ifdef USE_RECV_BEFORE_SEND_WORKAROUND\n  struct postponed_data postponed[2]; /* two buffers for two sockets */\n#endif /* USE_RECV_BEFORE_SEND_WORKAROUND */\n  struct ssl_connect_data ssl[2]; /* this is for ssl-stuff */\n#ifndef CURL_DISABLE_PROXY\n  struct ssl_connect_data proxy_ssl[2]; /* this is for proxy ssl-stuff */\n#endif\n#ifdef USE_SSL\n  void *ssl_extra; /* separately allocated backend-specific data */\n#endif\n  struct ssl_primary_config ssl_config;\n#ifndef CURL_DISABLE_PROXY\n  struct ssl_primary_config proxy_ssl_config;\n#endif\n  struct ConnectBits bits;    /* various state-flags for this connection */\n\n /* connecttime: when connect() is called on the current IP address. Used to\n    be able to track when to move on to try next IP - but only when the multi\n    interface is used. */\n  struct curltime connecttime;\n  /* The two fields below get set in Curl_connecthost */\n  int num_addr; /* number of addresses to try to connect to */\n\n  /* how long time in milliseconds to spend on trying to connect to each IP\n     address, per family */\n  timediff_t timeoutms_per_addr[2];\n\n  const struct Curl_handler *handler; /* Connection's protocol handler */\n  const struct Curl_handler *given;   /* The protocol first given */\n\n  long ip_version; /* copied from the Curl_easy at creation time */\n\n  /* Protocols can use a custom keepalive mechanism to keep connections alive.\n     This allows those protocols to track the last time the keepalive mechanism\n     was used on this connection. */\n  struct curltime keepalive;\n\n  long upkeep_interval_ms;      /* Time between calls for connection upkeep. */\n\n  /**** curl_get() phase fields */\n\n  curl_socket_t sockfd;   /* socket to read from or CURL_SOCKET_BAD */\n  curl_socket_t writesockfd; /* socket to write to, it may very\n                                well be the same we read from.\n                                CURL_SOCKET_BAD disables */\n\n#ifdef HAVE_GSSAPI\n  BIT(sec_complete); /* if Kerberos is enabled for this connection */\n  enum protection_level command_prot;\n  enum protection_level data_prot;\n  enum protection_level request_data_prot;\n  size_t buffer_size;\n  struct krb5buffer in_buffer;\n  void *app_data;\n  const struct Curl_sec_client_mech *mech;\n  struct sockaddr_in local_addr;\n#endif\n\n#if defined(USE_KERBEROS5)    /* Consider moving some of the above GSS-API */\n  struct kerberos5data krb5;  /* variables into the structure definition, */\n#endif                        /* however, some of them are ftp specific. */\n\n  struct curl_llist easyq;    /* List of easy handles using this connection */\n  curl_seek_callback seek_func; /* function that seeks the input */\n  void *seek_client;            /* pointer to pass to the seek() above */\n\n  /*************** Request - specific items ************/\n#if defined(USE_WINDOWS_SSPI) && defined(SECPKG_ATTR_ENDPOINT_BINDINGS)\n  CtxtHandle *sslContext;\n#endif\n\n#if defined(USE_NTLM)\n  curlntlm http_ntlm_state;\n  curlntlm proxy_ntlm_state;\n\n  struct ntlmdata ntlm;     /* NTLM differs from other authentication schemes\n                               because it authenticates connections, not\n                               single requests! */\n  struct ntlmdata proxyntlm; /* NTLM data for proxy */\n#endif\n\n#ifdef USE_SPNEGO\n  curlnegotiate http_negotiate_state;\n  curlnegotiate proxy_negotiate_state;\n\n  struct negotiatedata negotiate; /* state data for host Negotiate auth */\n  struct negotiatedata proxyneg; /* state data for proxy Negotiate auth */\n#endif\n\n  /* data used for the asynch name resolve callback */\n  struct Curl_async async;\n\n  /* for chunked-encoded trailer */\n  struct dynbuf trailer;\n\n  union {\n    struct ftp_conn ftpc;\n    struct http_conn httpc;\n    struct ssh_conn sshc;\n    struct tftp_state_data *tftpc;\n    struct imap_conn imapc;\n    struct pop3_conn pop3c;\n    struct smtp_conn smtpc;\n    struct rtsp_conn rtspc;\n    struct smb_conn smbc;\n    void *rtmp;\n    struct ldapconninfo *ldapc;\n    struct mqtt_conn mqtt;\n  } proto;\n\n  int cselect_bits; /* bitmask of socket events */\n  int waitfor;      /* current READ/WRITE bits to wait for */\n\n#if defined(HAVE_GSSAPI) || defined(USE_WINDOWS_SSPI)\n  int socks5_gssapi_enctype;\n#endif\n\n  /* When this connection is created, store the conditions for the local end\n     bind. This is stored before the actual bind and before any connection is\n     made and will serve the purpose of being used for comparison reasons so\n     that subsequent bound-requested connections aren't accidentally re-using\n     wrong connections. */\n  char *localdev;\n  unsigned short localport;\n  int localportrange;\n  struct http_connect_state *connect_state; /* for HTTP CONNECT */\n  struct connectbundle *bundle; /* The bundle we are member of */\n  int negnpn; /* APLN or NPN TLS negotiated protocol, CURL_HTTP_VERSION* */\n#ifdef USE_UNIX_SOCKETS\n  char *unix_domain_socket;\n#endif\n};\n\n/* The end of connectdata. */\n\n/*\n * Struct to keep statistical and informational data.\n * All variables in this struct must be initialized/reset in Curl_initinfo().\n */\nstruct PureInfo {\n  int httpcode;  /* Recent HTTP, FTP, RTSP or SMTP response code */\n  int httpproxycode; /* response code from proxy when received separate */\n  int httpversion; /* the http version number X.Y = X*10+Y */\n  time_t filetime; /* If requested, this is might get set. Set to -1 if the\n                      time was unretrievable. */\n  curl_off_t header_size;  /* size of read header(s) in bytes */\n  curl_off_t request_size; /* the amount of bytes sent in the request(s) */\n  unsigned long proxyauthavail; /* what proxy auth types were announced */\n  unsigned long httpauthavail;  /* what host auth types were announced */\n  long numconnects; /* how many new connection did libcurl created */\n  char *contenttype; /* the content type of the object */\n  char *wouldredirect; /* URL this would've been redirected to if asked to */\n  curl_off_t retry_after; /* info from Retry-After: header */\n\n  /* PureInfo members 'conn_primary_ip', 'conn_primary_port', 'conn_local_ip'\n     and, 'conn_local_port' are copied over from the connectdata struct in\n     order to allow curl_easy_getinfo() to return this information even when\n     the session handle is no longer associated with a connection, and also\n     allow curl_easy_reset() to clear this information from the session handle\n     without disturbing information which is still alive, and that might be\n     reused, in the connection cache. */\n\n  char conn_primary_ip[MAX_IPADR_LEN];\n  long conn_primary_port;\n  char conn_local_ip[MAX_IPADR_LEN];\n  long conn_local_port;\n  const char *conn_scheme;\n  unsigned int conn_protocol;\n  struct curl_certinfo certs; /* info about the certs, only populated in\n                                 OpenSSL, GnuTLS, Schannel, NSS and GSKit\n                                 builds. Asked for with CURLOPT_CERTINFO\n                                 / CURLINFO_CERTINFO */\n  CURLproxycode pxcode;\n  BIT(timecond);  /* set to TRUE if the time condition didn't match, which\n                     thus made the document NOT get fetched */\n};\n\n\nstruct Progress {\n  time_t lastshow; /* time() of the last displayed progress meter or NULL to\n                      force redraw at next call */\n  curl_off_t size_dl; /* total expected size */\n  curl_off_t size_ul; /* total expected size */\n  curl_off_t downloaded; /* transferred so far */\n  curl_off_t uploaded; /* transferred so far */\n\n  curl_off_t current_speed; /* uses the currently fastest transfer */\n\n  int width; /* screen width at download start */\n  int flags; /* see progress.h */\n\n  timediff_t timespent;\n\n  curl_off_t dlspeed;\n  curl_off_t ulspeed;\n\n  timediff_t t_nslookup;\n  timediff_t t_connect;\n  timediff_t t_appconnect;\n  timediff_t t_pretransfer;\n  timediff_t t_starttransfer;\n  timediff_t t_redirect;\n\n  struct curltime start;\n  struct curltime t_startsingle;\n  struct curltime t_startop;\n  struct curltime t_acceptdata;\n\n\n  /* upload speed limit */\n  struct curltime ul_limit_start;\n  curl_off_t ul_limit_size;\n  /* download speed limit */\n  struct curltime dl_limit_start;\n  curl_off_t dl_limit_size;\n\n#define CURR_TIME (5 + 1) /* 6 entries for 5 seconds */\n\n  curl_off_t speeder[ CURR_TIME ];\n  struct curltime speeder_time[ CURR_TIME ];\n  int speeder_c;\n  BIT(callback);  /* set when progress callback is used */\n  BIT(is_t_startransfer_set);\n};\n\ntypedef enum {\n  HTTPREQ_NONE, /* first in list */\n  HTTPREQ_GET,\n  HTTPREQ_POST,\n  HTTPREQ_POST_FORM, /* we make a difference internally */\n  HTTPREQ_POST_MIME, /* we make a difference internally */\n  HTTPREQ_PUT,\n  HTTPREQ_HEAD,\n  HTTPREQ_LAST /* last in list */\n} Curl_HttpReq;\n\ntypedef enum {\n    RTSPREQ_NONE, /* first in list */\n    RTSPREQ_OPTIONS,\n    RTSPREQ_DESCRIBE,\n    RTSPREQ_ANNOUNCE,\n    RTSPREQ_SETUP,\n    RTSPREQ_PLAY,\n    RTSPREQ_PAUSE,\n    RTSPREQ_TEARDOWN,\n    RTSPREQ_GET_PARAMETER,\n    RTSPREQ_SET_PARAMETER,\n    RTSPREQ_RECORD,\n    RTSPREQ_RECEIVE,\n    RTSPREQ_LAST /* last in list */\n} Curl_RtspReq;\n\nstruct auth {\n  unsigned long want;  /* Bitmask set to the authentication methods wanted by\n                          app (with CURLOPT_HTTPAUTH or CURLOPT_PROXYAUTH). */\n  unsigned long picked;\n  unsigned long avail; /* Bitmask for what the server reports to support for\n                          this resource */\n  BIT(done);  /* TRUE when the auth phase is done and ready to do the\n                 actual request */\n  BIT(multipass); /* TRUE if this is not yet authenticated but within the\n                     auth multipass negotiation */\n  BIT(iestyle); /* TRUE if digest should be done IE-style or FALSE if it\n                   should be RFC compliant */\n};\n\nstruct Curl_http2_dep {\n  struct Curl_http2_dep *next;\n  struct Curl_easy *data;\n};\n\n/*\n * This struct is for holding data that was attempted to get sent to the user's\n * callback but is held due to pausing. One instance per type (BOTH, HEADER,\n * BODY).\n */\nstruct tempbuf {\n  struct dynbuf b;\n  int type;   /* type of the 'tempwrite' buffer as a bitmask that is used with\n                 Curl_client_write() */\n};\n\n/* Timers */\ntypedef enum {\n  EXPIRE_100_TIMEOUT,\n  EXPIRE_ASYNC_NAME,\n  EXPIRE_CONNECTTIMEOUT,\n  EXPIRE_DNS_PER_NAME, /* family1 */\n  EXPIRE_DNS_PER_NAME2, /* family2 */\n  EXPIRE_HAPPY_EYEBALLS_DNS, /* See asyn-ares.c */\n  EXPIRE_HAPPY_EYEBALLS,\n  EXPIRE_MULTI_PENDING,\n  EXPIRE_RUN_NOW,\n  EXPIRE_SPEEDCHECK,\n  EXPIRE_TIMEOUT,\n  EXPIRE_TOOFAST,\n  EXPIRE_QUIC,\n  EXPIRE_LAST /* not an actual timer, used as a marker only */\n} expire_id;\n\n\ntypedef enum {\n  TRAILERS_NONE,\n  TRAILERS_INITIALIZED,\n  TRAILERS_SENDING,\n  TRAILERS_DONE\n} trailers_state;\n\n\n/*\n * One instance for each timeout an easy handle can set.\n */\nstruct time_node {\n  struct curl_llist_element list;\n  struct curltime time;\n  expire_id eid;\n};\n\n/* individual pieces of the URL */\nstruct urlpieces {\n  char *scheme;\n  char *hostname;\n  char *port;\n  char *user;\n  char *password;\n  char *options;\n  char *path;\n  char *query;\n};\n\nstruct UrlState {\n  /* Points to the connection cache */\n  struct conncache *conn_cache;\n\n  int retrycount; /* number of retries on a new connection */\n\n  /* buffers to store authentication data in, as parsed from input options */\n  struct curltime keeps_speed; /* for the progress meter really */\n\n  long lastconnect_id; /* The last connection, -1 if undefined */\n  struct dynbuf headerb; /* buffer to store headers in */\n\n  char *buffer; /* download buffer */\n  char *ulbuf; /* allocated upload buffer or NULL */\n  curl_off_t current_speed;  /* the ProgressShow() function sets this,\n                                bytes / second */\n  char *first_host; /* host name of the first (not followed) request.\n                       if set, this should be the host name that we will\n                       sent authorization to, no else. Used to make Location:\n                       following not keep sending user+password... This is\n                       strdup() data.\n                    */\n  int first_remote_port; /* remote port of the first (not followed) request */\n  struct curl_ssl_session *session; /* array of 'max_ssl_sessions' size */\n  long sessionage;                  /* number of the most recent session */\n  unsigned int tempcount; /* number of entries in use in tempwrite, 0 - 3 */\n  struct tempbuf tempwrite[3]; /* BOTH, HEADER, BODY */\n  char *scratch; /* huge buffer[set.buffer_size*2] for upload CRLF replacing */\n  int os_errno;  /* filled in with errno whenever an error occurs */\n#ifdef HAVE_SIGNAL\n  /* storage for the previous bag^H^H^HSIGPIPE signal handler :-) */\n  void (*prev_signal)(int sig);\n#endif\n  struct digestdata digest;      /* state data for host Digest auth */\n  struct digestdata proxydigest; /* state data for proxy Digest auth */\n\n  struct auth authhost;  /* auth details for host */\n  struct auth authproxy; /* auth details for proxy */\n  void *resolver; /* resolver state, if it is used in the URL state -\n                     ares_channel f.e. */\n\n#if defined(USE_OPENSSL)\n  /* void instead of ENGINE to avoid bleeding OpenSSL into this header */\n  void *engine;\n#endif /* USE_OPENSSL */\n  struct curltime expiretime; /* set this with Curl_expire() only */\n  struct Curl_tree timenode; /* for the splay stuff */\n  struct curl_llist timeoutlist; /* list of pending timeouts */\n  struct time_node expires[EXPIRE_LAST]; /* nodes for each expire type */\n\n  /* a place to store the most recently set FTP entrypath */\n  char *most_recent_ftp_entrypath;\n\n  int httpversion;       /* the lowest HTTP version*10 reported by any server\n                            involved in this request */\n\n#if !defined(WIN32) && !defined(MSDOS) && !defined(__EMX__) && \\\n    !defined(__SYMBIAN32__)\n/* do FTP line-end conversions on most platforms */\n#define CURL_DO_LINEEND_CONV\n  /* for FTP downloads: track CRLF sequences that span blocks */\n  BIT(prev_block_had_trailing_cr);\n  /* for FTP downloads: how many CRLFs did we converted to LFs? */\n  curl_off_t crlf_conversions;\n#endif\n  char *range; /* range, if used. See README for detailed specification on\n                  this syntax. */\n  curl_off_t resume_from; /* continue [ftp] transfer from here */\n\n  /* This RTSP state information survives requests and connections */\n  long rtsp_next_client_CSeq; /* the session's next client CSeq */\n  long rtsp_next_server_CSeq; /* the session's next server CSeq */\n  long rtsp_CSeq_recv; /* most recent CSeq received */\n\n  curl_off_t infilesize; /* size of file to upload, -1 means unknown.\n                            Copied from set.filesize at start of operation */\n\n  size_t drain; /* Increased when this stream has data to read, even if its\n                   socket is not necessarily is readable. Decreased when\n                   checked. */\n\n  curl_read_callback fread_func; /* read callback/function */\n  void *in;                      /* CURLOPT_READDATA */\n\n  struct Curl_easy *stream_depends_on;\n  int stream_weight;\n  CURLU *uh; /* URL handle for the current parsed URL */\n  struct urlpieces up;\n  Curl_HttpReq httpreq; /* what kind of HTTP request (if any) is this */\n#ifndef CURL_DISABLE_HTTP\n  size_t trailers_bytes_sent;\n  struct dynbuf trailers_buf; /* a buffer containing the compiled trailing\n                                 headers */\n#endif\n  trailers_state trailers_state; /* whether we are sending trailers\n                                       and what stage are we at */\n\n  /* Dynamically allocated strings, MUST be freed before this struct is\n     killed. */\n  struct dynamically_allocated_data {\n    char *proxyuserpwd;\n    char *uagent;\n    char *accept_encoding;\n    char *userpwd;\n    char *rangeline;\n    char *ref;\n    char *host;\n    char *cookiehost;\n    char *rtsp_transport;\n    char *te; /* TE: request header */\n  } aptr;\n\n#ifdef CURLDEBUG\n  BIT(conncache_lock);\n#endif\n  /* when curl_easy_perform() is called, the multi handle is \"owned\" by\n     the easy handle so curl_easy_cleanup() on such an easy handle will\n     also close the multi handle! */\n  BIT(multi_owned_by_easy);\n\n  BIT(this_is_a_follow); /* this is a followed Location: request */\n  BIT(refused_stream); /* this was refused, try again */\n  BIT(errorbuf); /* Set to TRUE if the error buffer is already filled in.\n                    This must be set to FALSE every time _easy_perform() is\n                    called. */\n  BIT(allow_port); /* Is set.use_port allowed to take effect or not. This\n                      is always set TRUE when curl_easy_perform() is called. */\n  BIT(authproblem); /* TRUE if there's some problem authenticating */\n  /* set after initial USER failure, to prevent an authentication loop */\n  BIT(ftp_trying_alternative);\n  BIT(wildcardmatch); /* enable wildcard matching */\n  BIT(expect100header);  /* TRUE if we added Expect: 100-continue */\n  BIT(disableexpect);    /* TRUE if Expect: is disabled due to a previous\n                            417 response */\n  BIT(use_range);\n  BIT(rangestringalloc); /* the range string is malloc()'ed */\n  BIT(done); /* set to FALSE when Curl_init_do() is called and set to TRUE\n                  when multi_done() is called, to prevent multi_done() to get\n                  invoked twice when the multi interface is used. */\n  BIT(stream_depends_e); /* set or don't set the Exclusive bit */\n  BIT(previouslypending); /* this transfer WAS in the multi->pending queue */\n  BIT(cookie_engine);\n};\n\n\n/*\n * This 'DynamicStatic' struct defines dynamic states that actually change\n * values in the 'UserDefined' area, which MUST be taken into consideration\n * if the UserDefined struct is cloned or similar. You can probably just\n * copy these, but each one indicate a special action on other data.\n */\n\nstruct DynamicStatic {\n  char *url;        /* work URL, copied from UserDefined */\n  char *referer;    /* referer string */\n  struct curl_slist *cookielist; /* list of cookie files set by\n                                    curl_easy_setopt(COOKIEFILE) calls */\n  struct curl_slist *resolve; /* set to point to the set.resolve list when\n                                 this should be dealt with in pretransfer */\n  BIT(url_alloc);   /* URL string is malloc()'ed */\n  BIT(referer_alloc); /* referer string is malloc()ed */\n  BIT(wildcard_resolve); /* Set to true if any resolve change is a\n                              wildcard */\n};\n\n/*\n * This 'UserDefined' struct must only contain data that is set once to go\n * for many (perhaps) independent connections. Values that are generated or\n * calculated internally for the \"session handle\" MUST be defined within the\n * 'struct UrlState' instead. The only exceptions MUST note the changes in\n * the 'DynamicStatic' struct.\n * Character pointer fields point to dynamic storage, unless otherwise stated.\n */\n\nstruct Curl_multi;    /* declared and used only in multi.c */\n\n/*\n * This enumeration MUST not use conditional directives (#ifdefs), new\n * null terminated strings MUST be added to the enumeration immediately\n * before STRING_LASTZEROTERMINATED, binary fields immediately before\n * STRING_LAST. When doing so, ensure that the packages/OS400/chkstring.c\n * test is updated and applicable changes for EBCDIC to ASCII conversion\n * are catered for in curl_easy_setopt_ccsid()\n */\nenum dupstring {\n  STRING_CERT_ORIG,       /* client certificate file name */\n  STRING_CERT_PROXY,      /* client certificate file name */\n  STRING_CERT_TYPE_ORIG,  /* format for certificate (default: PEM)*/\n  STRING_CERT_TYPE_PROXY, /* format for certificate (default: PEM)*/\n  STRING_COOKIE,          /* HTTP cookie string to send */\n  STRING_COOKIEJAR,       /* dump all cookies to this file */\n  STRING_CUSTOMREQUEST,   /* HTTP/FTP/RTSP request/method to use */\n  STRING_DEFAULT_PROTOCOL, /* Protocol to use when the URL doesn't specify */\n  STRING_DEVICE,          /* local network interface/address to use */\n  STRING_ENCODING,        /* Accept-Encoding string */\n  STRING_FTP_ACCOUNT,     /* ftp account data */\n  STRING_FTP_ALTERNATIVE_TO_USER, /* command to send if USER/PASS fails */\n  STRING_FTPPORT,         /* port to send with the FTP PORT command */\n  STRING_KEY_ORIG,        /* private key file name */\n  STRING_KEY_PROXY,       /* private key file name */\n  STRING_KEY_PASSWD_ORIG, /* plain text private key password */\n  STRING_KEY_PASSWD_PROXY, /* plain text private key password */\n  STRING_KEY_TYPE_ORIG,   /* format for private key (default: PEM) */\n  STRING_KEY_TYPE_PROXY,  /* format for private key (default: PEM) */\n  STRING_KRB_LEVEL,       /* krb security level */\n  STRING_NETRC_FILE,      /* if not NULL, use this instead of trying to find\n                             $HOME/.netrc */\n  STRING_PROXY,           /* proxy to use */\n  STRING_PRE_PROXY,       /* pre socks proxy to use */\n  STRING_SET_RANGE,       /* range, if used */\n  STRING_SET_REFERER,     /* custom string for the HTTP referer field */\n  STRING_SET_URL,         /* what original URL to work on */\n  STRING_SSL_CAPATH_ORIG, /* CA directory name (doesn't work on windows) */\n  STRING_SSL_CAPATH_PROXY, /* CA directory name (doesn't work on windows) */\n  STRING_SSL_CAFILE_ORIG, /* certificate file to verify peer against */\n  STRING_SSL_CAFILE_PROXY, /* certificate file to verify peer against */\n  STRING_SSL_PINNEDPUBLICKEY_ORIG, /* public key file to verify peer against */\n  STRING_SSL_PINNEDPUBLICKEY_PROXY, /* public key file to verify proxy */\n  STRING_SSL_CIPHER_LIST_ORIG, /* list of ciphers to use */\n  STRING_SSL_CIPHER_LIST_PROXY, /* list of ciphers to use */\n  STRING_SSL_CIPHER13_LIST_ORIG, /* list of TLS 1.3 ciphers to use */\n  STRING_SSL_CIPHER13_LIST_PROXY, /* list of TLS 1.3 ciphers to use */\n  STRING_SSL_EGDSOCKET,   /* path to file containing the EGD daemon socket */\n  STRING_SSL_RANDOM_FILE, /* path to file containing \"random\" data */\n  STRING_USERAGENT,       /* User-Agent string */\n  STRING_SSL_CRLFILE_ORIG, /* crl file to check certificate */\n  STRING_SSL_CRLFILE_PROXY, /* crl file to check certificate */\n  STRING_SSL_ISSUERCERT_ORIG, /* issuer cert file to check certificate */\n  STRING_SSL_ISSUERCERT_PROXY, /* issuer cert file to check certificate */\n  STRING_SSL_ENGINE,      /* name of ssl engine */\n  STRING_USERNAME,        /* <username>, if used */\n  STRING_PASSWORD,        /* <password>, if used */\n  STRING_OPTIONS,         /* <options>, if used */\n  STRING_PROXYUSERNAME,   /* Proxy <username>, if used */\n  STRING_PROXYPASSWORD,   /* Proxy <password>, if used */\n  STRING_NOPROXY,         /* List of hosts which should not use the proxy, if\n                             used */\n  STRING_RTSP_SESSION_ID, /* Session ID to use */\n  STRING_RTSP_STREAM_URI, /* Stream URI for this request */\n  STRING_RTSP_TRANSPORT,  /* Transport for this session */\n\n  STRING_SSH_PRIVATE_KEY, /* path to the private key file for auth */\n  STRING_SSH_PUBLIC_KEY,  /* path to the public key file for auth */\n  STRING_SSH_HOST_PUBLIC_KEY_MD5, /* md5 of host public key in ascii hex */\n  STRING_SSH_KNOWNHOSTS,  /* file name of knownhosts file */\n\n  STRING_PROXY_SERVICE_NAME, /* Proxy service name */\n  STRING_SERVICE_NAME,    /* Service name */\n  STRING_MAIL_FROM,\n  STRING_MAIL_AUTH,\n\n  STRING_TLSAUTH_USERNAME_ORIG,  /* TLS auth <username> */\n  STRING_TLSAUTH_USERNAME_PROXY, /* TLS auth <username> */\n  STRING_TLSAUTH_PASSWORD_ORIG,  /* TLS auth <password> */\n  STRING_TLSAUTH_PASSWORD_PROXY, /* TLS auth <password> */\n\n  STRING_BEARER,                /* <bearer>, if used */\n\n  STRING_UNIX_SOCKET_PATH,      /* path to Unix socket, if used */\n\n  STRING_TARGET,                /* CURLOPT_REQUEST_TARGET */\n  STRING_DOH,                   /* CURLOPT_DOH_URL */\n\n  STRING_ALTSVC,                /* CURLOPT_ALTSVC */\n\n  STRING_SASL_AUTHZID,          /* CURLOPT_SASL_AUTHZID */\n\n  STRING_TEMP_URL,              /* temp URL storage for proxy use */\n\n  STRING_DNS_SERVERS,\n  STRING_DNS_INTERFACE,\n  STRING_DNS_LOCAL_IP4,\n  STRING_DNS_LOCAL_IP6,\n  STRING_SSL_EC_CURVES,\n\n  /* -- end of null-terminated strings -- */\n\n  STRING_LASTZEROTERMINATED,\n\n  /* -- below this are pointers to binary data that cannot be strdup'ed. --- */\n\n  STRING_COPYPOSTFIELDS,  /* if POST, set the fields' values here */\n\n\n  STRING_LAST /* not used, just an end-of-list marker */\n};\n\nenum dupblob {\n  BLOB_CERT_ORIG,\n  BLOB_CERT_PROXY,\n  BLOB_KEY_ORIG,\n  BLOB_KEY_PROXY,\n  BLOB_SSL_ISSUERCERT_ORIG,\n  BLOB_SSL_ISSUERCERT_PROXY,\n  BLOB_LAST\n};\n\n/* callback that gets called when this easy handle is completed within a multi\n   handle.  Only used for internally created transfers, like for example\n   DoH. */\ntypedef int (*multidone_func)(struct Curl_easy *easy, CURLcode result);\n\nstruct UserDefined {\n  FILE *err;         /* the stderr user data goes here */\n  void *debugdata;   /* the data that will be passed to fdebug */\n  char *errorbuffer; /* (Static) store failure messages in here */\n  long proxyport; /* If non-zero, use this port number by default. If the\n                     proxy string features a \":[port]\" that one will override\n                     this. */\n  void *out;         /* CURLOPT_WRITEDATA */\n  void *in_set;      /* CURLOPT_READDATA */\n  void *writeheader; /* write the header to this if non-NULL */\n  void *rtp_out;     /* write RTP to this if non-NULL */\n  long use_port;     /* which port to use (when not using default) */\n  unsigned long httpauth;  /* kind of HTTP authentication to use (bitmask) */\n  unsigned long proxyauth; /* kind of proxy authentication to use (bitmask) */\n  unsigned long socks5auth;/* kind of SOCKS5 authentication to use (bitmask) */\n  long followlocation; /* as in HTTP Location: */\n  long maxredirs;    /* maximum no. of http(s) redirects to follow, set to -1\n                        for infinity */\n\n  int keep_post;     /* keep POSTs as POSTs after a 30x request; each\n                        bit represents a request, from 301 to 303 */\n  void *postfields;  /* if POST, set the fields' values here */\n  curl_seek_callback seek_func;      /* function that seeks the input */\n  curl_off_t postfieldsize; /* if POST, this might have a size to use instead\n                               of strlen(), and then the data *may* be binary\n                               (contain zero bytes) */\n  unsigned short localport; /* local port number to bind to */\n  int localportrange; /* number of additional port numbers to test in case the\n                         'localport' one can't be bind()ed */\n  curl_write_callback fwrite_func;   /* function that stores the output */\n  curl_write_callback fwrite_header; /* function that stores headers */\n  curl_write_callback fwrite_rtp;    /* function that stores interleaved RTP */\n  curl_read_callback fread_func_set; /* function that reads the input */\n  curl_progress_callback fprogress; /* OLD and deprecated progress callback  */\n  curl_xferinfo_callback fxferinfo; /* progress callback */\n  curl_debug_callback fdebug;      /* function that write informational data */\n  curl_ioctl_callback ioctl_func;  /* function for I/O control */\n  curl_sockopt_callback fsockopt;  /* function for setting socket options */\n  void *sockopt_client; /* pointer to pass to the socket options callback */\n  curl_opensocket_callback fopensocket; /* function for checking/translating\n                                           the address and opening the\n                                           socket */\n  void *opensocket_client;\n  curl_closesocket_callback fclosesocket; /* function for closing the\n                                             socket */\n  void *closesocket_client;\n\n  void *seek_client;    /* pointer to pass to the seek callback */\n  /* the 3 curl_conv_callback functions below are used on non-ASCII hosts */\n  /* function to convert from the network encoding: */\n  curl_conv_callback convfromnetwork;\n  /* function to convert to the network encoding: */\n  curl_conv_callback convtonetwork;\n  /* function to convert from UTF-8 encoding: */\n  curl_conv_callback convfromutf8;\n\n  void *progress_client; /* pointer to pass to the progress callback */\n  void *ioctl_client;   /* pointer to pass to the ioctl callback */\n  long timeout;         /* in milliseconds, 0 means no timeout */\n  long connecttimeout;  /* in milliseconds, 0 means no timeout */\n  long accepttimeout;   /* in milliseconds, 0 means no timeout */\n  long happy_eyeballs_timeout; /* in milliseconds, 0 is a valid value */\n  long server_response_timeout; /* in milliseconds, 0 means no timeout */\n  long maxage_conn;     /* in seconds, max idle time to allow a connection that\n                           is to be reused */\n  long tftp_blksize;    /* in bytes, 0 means use default */\n  curl_off_t filesize;  /* size of file to upload, -1 means unknown */\n  long low_speed_limit; /* bytes/second */\n  long low_speed_time;  /* number of seconds */\n  curl_off_t max_send_speed; /* high speed limit in bytes/second for upload */\n  curl_off_t max_recv_speed; /* high speed limit in bytes/second for\n                                download */\n  curl_off_t set_resume_from;  /* continue [ftp] transfer from here */\n  struct curl_slist *headers; /* linked list of extra headers */\n  struct curl_slist *proxyheaders; /* linked list of extra CONNECT headers */\n  struct curl_httppost *httppost;  /* linked list of old POST data */\n  curl_mimepart mimepost;  /* MIME/POST data. */\n  struct curl_slist *quote;     /* after connection is established */\n  struct curl_slist *postquote; /* after the transfer */\n  struct curl_slist *prequote; /* before the transfer, after type */\n  struct curl_slist *source_quote;  /* 3rd party quote */\n  struct curl_slist *source_prequote;  /* in 3rd party transfer mode - before\n                                          the transfer on source host */\n  struct curl_slist *source_postquote; /* in 3rd party transfer mode - after\n                                          the transfer on source host */\n  struct curl_slist *telnet_options; /* linked list of telnet options */\n  struct curl_slist *resolve;     /* list of names to add/remove from\n                                     DNS cache */\n  struct curl_slist *connect_to; /* list of host:port mappings to override\n                                    the hostname and port to connect to */\n  curl_TimeCond timecondition; /* kind of time/date comparison */\n  time_t timevalue;       /* what time to compare with */\n  Curl_HttpReq method;   /* what kind of HTTP request (if any) is this */\n  long httpversion; /* when non-zero, a specific HTTP version requested to\n                       be used in the library's request(s) */\n  struct ssl_config_data ssl;  /* user defined SSL stuff */\n#ifndef CURL_DISABLE_PROXY\n  struct ssl_config_data proxy_ssl;  /* user defined SSL stuff for proxy */\n#endif\n  struct ssl_general_config general_ssl; /* general user defined SSL stuff */\n  curl_proxytype proxytype; /* what kind of proxy that is in use */\n  long dns_cache_timeout; /* DNS cache timeout */\n  long buffer_size;      /* size of receive buffer to use */\n  size_t upload_buffer_size; /* size of upload buffer to use,\n                                keep it >= CURL_MAX_WRITE_SIZE */\n  void *private_data; /* application-private data */\n  struct curl_slist *http200aliases; /* linked list of aliases for http200 */\n  long ipver; /* the CURL_IPRESOLVE_* defines in the public header file\n                 0 - whatever, 1 - v2, 2 - v6 */\n  curl_off_t max_filesize; /* Maximum file size to download */\n#ifndef CURL_DISABLE_FTP\n  curl_ftpfile ftp_filemethod; /* how to get to a file when FTP is used  */\n  curl_ftpauth ftpsslauth; /* what AUTH XXX to be attempted */\n  curl_ftpccc ftp_ccc;   /* FTP CCC options */\n#endif\n  int ftp_create_missing_dirs; /* 1 - create directories that don't exist\n                                  2 - the same but also allow MKD to fail once\n                               */\n  curl_sshkeycallback ssh_keyfunc; /* key matching callback */\n  void *ssh_keyfunc_userp;         /* custom pointer to callback */\n  enum CURL_NETRC_OPTION\n       use_netrc;        /* defined in include/curl.h */\n  curl_usessl use_ssl;   /* if AUTH TLS is to be attempted etc, for FTP or\n                            IMAP or POP3 or others! */\n  long new_file_perms;    /* Permissions to use when creating remote files */\n  long new_directory_perms; /* Permissions to use when creating remote dirs */\n  long ssh_auth_types;   /* allowed SSH auth types */\n  char *str[STRING_LAST]; /* array of strings, pointing to allocated memory */\n  struct curl_blob *blobs[BLOB_LAST];\n  unsigned int scope_id;  /* Scope id for IPv6 */\n  long allowed_protocols;\n  long redir_protocols;\n  struct curl_slist *mail_rcpt; /* linked list of mail recipients */\n  /* Common RTSP header options */\n  Curl_RtspReq rtspreq; /* RTSP request type */\n  long rtspversion; /* like httpversion, for RTSP */\n  curl_chunk_bgn_callback chunk_bgn; /* called before part of transfer\n                                        starts */\n  curl_chunk_end_callback chunk_end; /* called after part transferring\n                                        stopped */\n  curl_fnmatch_callback fnmatch; /* callback to decide which file corresponds\n                                    to pattern (e.g. if WILDCARDMATCH is on) */\n  void *fnmatch_data;\n\n  long gssapi_delegation; /* GSS-API credential delegation, see the\n                             documentation of CURLOPT_GSSAPI_DELEGATION */\n\n  long tcp_keepidle;     /* seconds in idle before sending keepalive probe */\n  long tcp_keepintvl;    /* seconds between TCP keepalive probes */\n\n  size_t maxconnects;    /* Max idle connections in the connection cache */\n\n  long expect_100_timeout; /* in milliseconds */\n  struct Curl_easy *stream_depends_on;\n  int stream_weight;\n  struct Curl_http2_dep *stream_dependents;\n\n  curl_resolver_start_callback resolver_start; /* optional callback called\n                                                  before resolver start */\n  void *resolver_start_client; /* pointer to pass to resolver start callback */\n  long upkeep_interval_ms;      /* Time between calls for connection upkeep. */\n  multidone_func fmultidone;\n  struct Curl_easy *dohfor; /* this is a DoH request for that transfer */\n  CURLU *uh; /* URL handle for the current parsed URL */\n  void *trailer_data; /* pointer to pass to trailer data callback */\n  curl_trailer_callback trailer_callback; /* trailing data callback */\n  BIT(is_fread_set); /* has read callback been set to non-NULL? */\n  BIT(is_fwrite_set); /* has write callback been set to non-NULL? */\n  BIT(free_referer); /* set TRUE if 'referer' points to a string we\n                        allocated */\n  BIT(tftp_no_options); /* do not send TFTP options requests */\n  BIT(sep_headers);     /* handle host and proxy headers separately */\n  BIT(cookiesession);   /* new cookie session? */\n  BIT(crlf);            /* convert crlf on ftp upload(?) */\n  BIT(strip_path_slash); /* strip off initial slash from path */\n  BIT(ssh_compression);            /* enable SSH compression */\n\n/* Here follows boolean settings that define how to behave during\n   this session. They are STATIC, set by libcurl users or at least initially\n   and they don't change during operations. */\n  BIT(get_filetime);     /* get the time and get of the remote file */\n  BIT(tunnel_thru_httpproxy); /* use CONNECT through a HTTP proxy */\n  BIT(prefer_ascii);     /* ASCII rather than binary */\n  BIT(ftp_append);       /* append, not overwrite, on upload */\n  BIT(ftp_list_only);    /* switch FTP command for listing directories */\n#ifndef CURL_DISABLE_FTP\n  BIT(ftp_use_port);     /* use the FTP PORT command */\n  BIT(ftp_use_epsv);     /* if EPSV is to be attempted or not */\n  BIT(ftp_use_eprt);     /* if EPRT is to be attempted or not */\n  BIT(ftp_use_pret);     /* if PRET is to be used before PASV or not */\n  BIT(ftp_skip_ip);      /* skip the IP address the FTP server passes on to\n                            us */\n#endif\n  BIT(hide_progress);    /* don't use the progress meter */\n  BIT(http_fail_on_error);  /* fail on HTTP error codes >= 400 */\n  BIT(http_keep_sending_on_error); /* for HTTP status codes >= 300 */\n  BIT(http_follow_location); /* follow HTTP redirects */\n  BIT(http_transfer_encoding); /* request compressed HTTP transfer-encoding */\n  BIT(allow_auth_to_other_hosts);\n  BIT(include_header); /* include received protocol headers in data output */\n  BIT(http_set_referer); /* is a custom referer used */\n  BIT(http_auto_referer); /* set \"correct\" referer when following\n                             location: */\n  BIT(opt_no_body);    /* as set with CURLOPT_NOBODY */\n  BIT(upload);         /* upload request */\n  BIT(verbose);        /* output verbosity */\n  BIT(krb);            /* Kerberos connection requested */\n  BIT(reuse_forbid);   /* forbidden to be reused, close after use */\n  BIT(reuse_fresh);    /* do not re-use an existing connection  */\n  BIT(no_signal);      /* do not use any signal/alarm handler */\n  BIT(tcp_nodelay);    /* whether to enable TCP_NODELAY or not */\n  BIT(ignorecl);       /* ignore content length */\n  BIT(connect_only);   /* make connection, let application use the socket */\n  BIT(http_te_skip);   /* pass the raw body data to the user, even when\n                          transfer-encoded (chunked, compressed) */\n  BIT(http_ce_skip);   /* pass the raw body data to the user, even when\n                          content-encoded (chunked, compressed) */\n  BIT(proxy_transfer_mode); /* set transfer mode (;type=<a|i>) when doing\n                               FTP via an HTTP proxy */\n#if defined(HAVE_GSSAPI) || defined(USE_WINDOWS_SSPI)\n  BIT(socks5_gssapi_nec); /* Flag to support NEC SOCKS5 server */\n#endif\n  BIT(sasl_ir);         /* Enable/disable SASL initial response */\n  BIT(wildcard_enabled); /* enable wildcard matching */\n  BIT(tcp_keepalive);  /* use TCP keepalives */\n  BIT(tcp_fastopen);   /* use TCP Fast Open */\n  BIT(ssl_enable_npn); /* TLS NPN extension? */\n  BIT(ssl_enable_alpn);/* TLS ALPN extension? */\n  BIT(path_as_is);     /* allow dotdots? */\n  BIT(pipewait);       /* wait for multiplex status before starting a new\n                          connection */\n  BIT(suppress_connect_headers); /* suppress proxy CONNECT response headers\n                                    from user callbacks */\n  BIT(dns_shuffle_addresses); /* whether to shuffle addresses before use */\n  BIT(stream_depends_e); /* set or don't set the Exclusive bit */\n  BIT(haproxyprotocol); /* whether to send HAProxy PROXY protocol v1\n                           header */\n  BIT(abstract_unix_socket);\n  BIT(disallow_username_in_url); /* disallow username in url */\n  BIT(doh); /* DNS-over-HTTPS enabled */\n  BIT(doh_get); /* use GET for DoH requests, instead of POST */\n  BIT(http09_allowed); /* allow HTTP/0.9 responses */\n  BIT(mail_rcpt_allowfails); /* allow RCPT TO command to fail for some\n                                recipients */\n};\n\nstruct Names {\n  struct curl_hash *hostcache;\n  enum {\n    HCACHE_NONE,    /* not pointing to anything */\n    HCACHE_MULTI,   /* points to a shared one in the multi handle */\n    HCACHE_SHARED   /* points to a shared one in a shared object */\n  } hostcachetype;\n};\n\n/*\n * The 'connectdata' struct MUST have all the connection oriented stuff as we\n * may have several simultaneous connections and connection structs in memory.\n *\n * The 'struct UserDefined' must only contain data that is set once to go for\n * many (perhaps) independent connections. Values that are generated or\n * calculated internally for the \"session handle\" must be defined within the\n * 'struct UrlState' instead.\n */\n\nstruct Curl_easy {\n  /* first, two fields for the linked list of these */\n  struct Curl_easy *next;\n  struct Curl_easy *prev;\n\n  struct connectdata *conn;\n  struct curl_llist_element connect_queue;\n  struct curl_llist_element conn_queue; /* list per connectdata */\n\n  CURLMstate mstate;  /* the handle's state */\n  CURLcode result;   /* previous result */\n\n  struct Curl_message msg; /* A single posted message. */\n\n  /* Array with the plain socket numbers this handle takes care of, in no\n     particular order. Note that all sockets are added to the sockhash, where\n     the state etc are also kept. This array is mostly used to detect when a\n     socket is to be removed from the hash. See singlesocket(). */\n  curl_socket_t sockets[MAX_SOCKSPEREASYHANDLE];\n  int actions[MAX_SOCKSPEREASYHANDLE]; /* action for each socket in\n                                          sockets[] */\n  int numsocks;\n\n  struct Names dns;\n  struct Curl_multi *multi;    /* if non-NULL, points to the multi handle\n                                  struct to which this \"belongs\" when used by\n                                  the multi interface */\n  struct Curl_multi *multi_easy; /* if non-NULL, points to the multi handle\n                                    struct to which this \"belongs\" when used\n                                    by the easy interface */\n  struct Curl_share *share;    /* Share, handles global variable mutexing */\n#ifdef USE_LIBPSL\n  struct PslCache *psl;        /* The associated PSL cache. */\n#endif\n  struct SingleRequest req;    /* Request-specific data */\n  struct UserDefined set;      /* values set by the libcurl user */\n  struct DynamicStatic change; /* possibly modified userdefined data */\n  struct CookieInfo *cookies;  /* the cookies, read from files and servers.\n                                  NOTE that the 'cookie' field in the\n                                  UserDefined struct defines if the \"engine\"\n                                  is to be used or not. */\n#ifdef USE_ALTSVC\n  struct altsvcinfo *asi;      /* the alt-svc cache */\n#endif\n  struct Progress progress;    /* for all the progress meter data */\n  struct UrlState state;       /* struct for fields used for state info and\n                                  other dynamic purposes */\n#ifndef CURL_DISABLE_FTP\n  struct WildcardData wildcard; /* wildcard download state info */\n#endif\n  struct PureInfo info;        /* stats, reports and info data */\n  struct curl_tlssessioninfo tsi; /* Information about the TLS session, only\n                                     valid after a client has asked for it */\n#if defined(CURL_DOES_CONVERSIONS) && defined(HAVE_ICONV)\n  iconv_t outbound_cd;         /* for translating to the network encoding */\n  iconv_t inbound_cd;          /* for translating from the network encoding */\n  iconv_t utf8_cd;             /* for translating to UTF8 */\n#endif /* CURL_DOES_CONVERSIONS && HAVE_ICONV */\n  unsigned int magic;          /* set to a CURLEASY_MAGIC_NUMBER */\n};\n\n#define LIBCURL_NAME \"libcurl\"\n\n#endif /* HEADER_CURL_URLDATA_H */\n"}, "33": {"id": 33, "path": "/home/runner/work/testcc/testcc/retdec/lib/http.h", "content": "#ifndef HEADER_CURL_HTTP_H\n#define HEADER_CURL_HTTP_H\n/***************************************************************************\n *                                  _   _ ____  _\n *  Project                     ___| | | |  _ \\| |\n *                             / __| | | | |_) | |\n *                            | (__| |_| |  _ <| |___\n *                             \\___|\\___/|_| \\_\\_____|\n *\n * Copyright (C) 1998 - 2020, Daniel Stenberg, <daniel@haxx.se>, et al.\n *\n * This software is licensed as described in the file COPYING, which\n * you should have received as part of this distribution. The terms\n * are also available at https://curl.haxx.se/docs/copyright.html.\n *\n * You may opt to use, copy, modify, merge, publish, distribute and/or sell\n * copies of the Software, and permit persons to whom the Software is\n * furnished to do so, under the terms of the COPYING file.\n *\n * This software is distributed on an \"AS IS\" basis, WITHOUT WARRANTY OF ANY\n * KIND, either express or implied.\n *\n ***************************************************************************/\n#include \"curl_setup.h\"\n\n#ifndef CURL_DISABLE_HTTP\n\n#ifdef USE_NGHTTP2\n#include <nghttp2/nghttp2.h>\n#endif\n\nextern const struct Curl_handler Curl_handler_http;\n\n#ifdef USE_SSL\nextern const struct Curl_handler Curl_handler_https;\n#endif\n\n/* Header specific functions */\nbool Curl_compareheader(const char *headerline,  /* line to check */\n                        const char *header,   /* header keyword _with_ colon */\n                        const char *content); /* content string to find */\n\nchar *Curl_copy_header_value(const char *header);\n\nchar *Curl_checkProxyheaders(const struct connectdata *conn,\n                             const char *thisheader);\nCURLcode Curl_buffer_send(struct dynbuf *in,\n                          struct connectdata *conn,\n                          curl_off_t *bytes_written,\n                          size_t included_body_bytes,\n                          int socketindex);\n\nCURLcode Curl_add_timecondition(const struct connectdata *conn,\n                                struct dynbuf *buf);\nCURLcode Curl_add_custom_headers(struct connectdata *conn,\n                                 bool is_connect,\n                                 struct dynbuf *req_buffer);\nCURLcode Curl_http_compile_trailers(struct curl_slist *trailers,\n                                    struct dynbuf *buf,\n                                    struct Curl_easy *handle);\n\n/* protocol-specific functions set up to be called by the main engine */\nCURLcode Curl_http(struct connectdata *conn, bool *done);\nCURLcode Curl_http_done(struct connectdata *, CURLcode, bool premature);\nCURLcode Curl_http_connect(struct connectdata *conn, bool *done);\n\n/* These functions are in http.c */\nCURLcode Curl_http_input_auth(struct connectdata *conn, bool proxy,\n                              const char *auth);\nCURLcode Curl_http_auth_act(struct connectdata *conn);\n\n/* If only the PICKNONE bit is set, there has been a round-trip and we\n   selected to use no auth at all. Ie, we actively select no auth, as opposed\n   to not having one selected. The other CURLAUTH_* defines are present in the\n   public curl/curl.h header. */\n#define CURLAUTH_PICKNONE (1<<30) /* don't use auth */\n\n/* MAX_INITIAL_POST_SIZE indicates the number of bytes that will make the POST\n   data get included in the initial data chunk sent to the server. If the\n   data is larger than this, it will automatically get split up in multiple\n   system calls.\n\n   This value used to be fairly big (100K), but we must take into account that\n   if the server rejects the POST due for authentication reasons, this data\n   will always be unconditionally sent and thus it may not be larger than can\n   always be afforded to send twice.\n\n   It must not be greater than 64K to work on VMS.\n*/\n#ifndef MAX_INITIAL_POST_SIZE\n#define MAX_INITIAL_POST_SIZE (64*1024)\n#endif\n\n/* EXPECT_100_THRESHOLD is the request body size limit for when libcurl will\n * automatically add an \"Expect: 100-continue\" header in HTTP requests. When\n * the size is unknown, it will always add it.\n *\n */\n#ifndef EXPECT_100_THRESHOLD\n#define EXPECT_100_THRESHOLD (1024*1024)\n#endif\n\n#endif /* CURL_DISABLE_HTTP */\n\n#ifdef USE_NGHTTP3\nstruct h3out; /* see ngtcp2 */\n#endif\n\n/****************************************************************************\n * HTTP unique setup\n ***************************************************************************/\nstruct HTTP {\n  curl_mimepart *sendit;\n  curl_off_t postsize; /* off_t to handle large file sizes */\n  const char *postdata;\n\n  const char *p_pragma;      /* Pragma: string */\n  const char *p_accept;      /* Accept: string */\n\n  /* For FORM posting */\n  curl_mimepart form;\n\n  struct back {\n    curl_read_callback fread_func; /* backup storage for fread pointer */\n    void *fread_in;           /* backup storage for fread_in pointer */\n    const char *postdata;\n    curl_off_t postsize;\n  } backup;\n\n  enum {\n    HTTPSEND_NADA,    /* init */\n    HTTPSEND_REQUEST, /* sending a request */\n    HTTPSEND_BODY,    /* sending body */\n    HTTPSEND_LAST     /* never use this */\n  } sending;\n\n#ifndef CURL_DISABLE_HTTP\n  struct dynbuf send_buffer; /* used if the request couldn't be sent in one\n                                chunk, points to an allocated send_buffer\n                                struct */\n#endif\n#ifdef USE_NGHTTP2\n  /*********** for HTTP/2 we store stream-local data here *************/\n  int32_t stream_id; /* stream we are interested in */\n\n  bool bodystarted;\n  /* We store non-final and final response headers here, per-stream */\n  struct dynbuf header_recvbuf;\n  size_t nread_header_recvbuf; /* number of bytes in header_recvbuf fed into\n                                  upper layer */\n  struct dynbuf trailer_recvbuf;\n  int status_code; /* HTTP status code */\n  const uint8_t *pausedata; /* pointer to data received in on_data_chunk */\n  size_t pauselen; /* the number of bytes left in data */\n  bool close_handled; /* TRUE if stream closure is handled by libcurl */\n\n  char **push_headers;       /* allocated array */\n  size_t push_headers_used;  /* number of entries filled in */\n  size_t push_headers_alloc; /* number of entries allocated */\n#endif\n#if defined(USE_NGHTTP2) || defined(USE_NGHTTP3)\n  bool closed; /* TRUE on HTTP2 stream close */\n  char *mem;     /* points to a buffer in memory to store received data */\n  size_t len;    /* size of the buffer 'mem' points to */\n  size_t memlen; /* size of data copied to mem */\n#endif\n#if defined(USE_NGHTTP2) || defined(ENABLE_QUIC)\n  /* fields used by both HTTP/2 and HTTP/3 */\n  const uint8_t *upload_mem; /* points to a buffer to read from */\n  size_t upload_len; /* size of the buffer 'upload_mem' points to */\n  curl_off_t upload_left; /* number of bytes left to upload */\n#endif\n\n#ifdef ENABLE_QUIC\n  /*********** for HTTP/3 we store stream-local data here *************/\n  int64_t stream3_id; /* stream we are interested in */\n  bool firstheader;  /* FALSE until headers arrive */\n  bool firstbody;  /* FALSE until body arrives */\n  bool h3req;    /* FALSE until request is issued */\n  bool upload_done;\n#endif\n#ifdef USE_NGHTTP3\n  size_t unacked_window;\n  struct h3out *h3out; /* per-stream buffers for upload */\n  struct dynbuf overflow; /* excess data received during a single Curl_read */\n#endif\n};\n\n#ifdef USE_NGHTTP2\n/* h2 settings for this connection */\nstruct h2settings {\n  uint32_t max_concurrent_streams;\n  bool enable_push;\n};\n#endif\n\nstruct http_conn {\n#ifdef USE_NGHTTP2\n#define H2_BINSETTINGS_LEN 80\n  nghttp2_session *h2;\n  uint8_t binsettings[H2_BINSETTINGS_LEN];\n  size_t  binlen; /* length of the binsettings data */\n  Curl_send *send_underlying; /* underlying send Curl_send callback */\n  Curl_recv *recv_underlying; /* underlying recv Curl_recv callback */\n  char *inbuf; /* buffer to receive data from underlying socket */\n  size_t inbuflen; /* number of bytes filled in inbuf */\n  size_t nread_inbuf; /* number of bytes read from in inbuf */\n  /* We need separate buffer for transmission and reception because we\n     may call nghttp2_session_send() after the\n     nghttp2_session_mem_recv() but mem buffer is still not full. In\n     this case, we wrongly sends the content of mem buffer if we share\n     them for both cases. */\n  int32_t pause_stream_id; /* stream ID which paused\n                              nghttp2_session_mem_recv */\n  size_t drain_total; /* sum of all stream's UrlState.drain */\n\n  /* this is a hash of all individual streams (Curl_easy structs) */\n  struct h2settings settings;\n\n  /* list of settings that will be sent */\n  nghttp2_settings_entry local_settings[3];\n  size_t local_settings_num;\n  uint32_t error_code; /* HTTP/2 error code */\n#else\n  int unused; /* prevent a compiler warning */\n#endif\n};\n\nCURLcode Curl_http_readwrite_headers(struct Curl_easy *data,\n                                     struct connectdata *conn,\n                                     ssize_t *nread,\n                                     bool *stop_reading);\n\n/**\n * Curl_http_output_auth() setups the authentication headers for the\n * host/proxy and the correct authentication\n * method. conn->data->state.authdone is set to TRUE when authentication is\n * done.\n *\n * @param conn all information about the current connection\n * @param request pointer to the request keyword\n * @param path pointer to the requested path\n * @param proxytunnel boolean if this is the request setting up a \"proxy\n * tunnel\"\n *\n * @returns CURLcode\n */\nCURLcode\nCurl_http_output_auth(struct connectdata *conn,\n                      const char *request,\n                      const char *path,\n                      bool proxytunnel); /* TRUE if this is the request setting\n                                            up the proxy tunnel */\n\n#endif /* HEADER_CURL_HTTP_H */\n"}, "34": {"id": 34, "path": "/home/runner/work/testcc/testcc/retdec/lib/multiif.h", "content": "#ifndef HEADER_CURL_MULTIIF_H\n#define HEADER_CURL_MULTIIF_H\n/***************************************************************************\n *                                  _   _ ____  _\n *  Project                     ___| | | |  _ \\| |\n *                             / __| | | | |_) | |\n *                            | (__| |_| |  _ <| |___\n *                             \\___|\\___/|_| \\_\\_____|\n *\n * Copyright (C) 1998 - 2020, Daniel Stenberg, <daniel@haxx.se>, et al.\n *\n * This software is licensed as described in the file COPYING, which\n * you should have received as part of this distribution. The terms\n * are also available at https://curl.haxx.se/docs/copyright.html.\n *\n * You may opt to use, copy, modify, merge, publish, distribute and/or sell\n * copies of the Software, and permit persons to whom the Software is\n * furnished to do so, under the terms of the COPYING file.\n *\n * This software is distributed on an \"AS IS\" basis, WITHOUT WARRANTY OF ANY\n * KIND, either express or implied.\n *\n ***************************************************************************/\n\n/*\n * Prototypes for library-wide functions provided by multi.c\n */\n\nvoid Curl_updatesocket(struct Curl_easy *data);\nvoid Curl_expire(struct Curl_easy *data, timediff_t milli, expire_id);\nvoid Curl_expire_clear(struct Curl_easy *data);\nvoid Curl_expire_done(struct Curl_easy *data, expire_id id);\nvoid Curl_update_timer(struct Curl_multi *multi);\nvoid Curl_attach_connnection(struct Curl_easy *data,\n                             struct connectdata *conn);\nvoid Curl_detach_connnection(struct Curl_easy *data);\nbool Curl_multiplex_wanted(const struct Curl_multi *multi);\nvoid Curl_set_in_callback(struct Curl_easy *data, bool value);\nbool Curl_is_in_callback(struct Curl_easy *easy);\nCURLcode Curl_preconnect(struct Curl_easy *data);\n\n/* Internal version of curl_multi_init() accepts size parameters for the\n   socket and connection hashes */\nstruct Curl_multi *Curl_multi_handle(int hashsize, int chashsize);\n\n/* the write bits start at bit 16 for the *getsock() bitmap */\n#define GETSOCK_WRITEBITSTART 16\n\n#define GETSOCK_BLANK 0 /* no bits set */\n\n/* set the bit for the given sock number to make the bitmap for writable */\n#define GETSOCK_WRITESOCK(x) (1 << (GETSOCK_WRITEBITSTART + (x)))\n\n/* set the bit for the given sock number to make the bitmap for readable */\n#define GETSOCK_READSOCK(x) (1 << (x))\n\n#ifdef DEBUGBUILD\n /*\n  * Curl_multi_dump is not a stable public function, this is only meant to\n  * allow easier tracking of the internal handle's state and what sockets\n  * they use. Only for research and development DEBUGBUILD enabled builds.\n  */\nvoid Curl_multi_dump(struct Curl_multi *multi);\n#endif\n\n/* Return the value of the CURLMOPT_MAX_HOST_CONNECTIONS option */\nsize_t Curl_multi_max_host_connections(struct Curl_multi *multi);\n\n/* Return the value of the CURLMOPT_MAX_TOTAL_CONNECTIONS option */\nsize_t Curl_multi_max_total_connections(struct Curl_multi *multi);\n\nvoid Curl_multiuse_state(struct connectdata *conn,\n                         int bundlestate); /* use BUNDLE_* defines */\n\n/*\n * Curl_multi_closed()\n *\n * Used by the connect code to tell the multi_socket code that one of the\n * sockets we were using is about to be closed.  This function will then\n * remove it from the sockethash for this handle to make the multi_socket API\n * behave properly, especially for the case when libcurl will create another\n * socket again and it gets the same file descriptor number.\n */\n\nvoid Curl_multi_closed(struct Curl_easy *data, curl_socket_t s);\n\n/*\n * Add a handle and move it into PERFORM state at once. For pushed streams.\n */\nCURLMcode Curl_multi_add_perform(struct Curl_multi *multi,\n                                 struct Curl_easy *data,\n                                 struct connectdata *conn);\n\n\n/* Return the value of the CURLMOPT_MAX_CONCURRENT_STREAMS option */\nunsigned int Curl_multi_max_concurrent_streams(struct Curl_multi *multi);\n\n#endif /* HEADER_CURL_MULTIIF_H */\n"}, "35": {"id": 35, "path": "/home/runner/work/testcc/testcc/retdec/lib/mime.h", "content": "#ifndef HEADER_CURL_MIME_H\n#define HEADER_CURL_MIME_H\n/***************************************************************************\n *                                  _   _ ____  _\n *  Project                     ___| | | |  _ \\| |\n *                             / __| | | | |_) | |\n *                            | (__| |_| |  _ <| |___\n *                             \\___|\\___/|_| \\_\\_____|\n *\n * Copyright (C) 1998 - 2020, Daniel Stenberg, <daniel@haxx.se>, et al.\n *\n * This software is licensed as described in the file COPYING, which\n * you should have received as part of this distribution. The terms\n * are also available at https://curl.haxx.se/docs/copyright.html.\n *\n * You may opt to use, copy, modify, merge, publish, distribute and/or sell\n * copies of the Software, and permit persons to whom the Software is\n * furnished to do so, under the terms of the COPYING file.\n *\n * This software is distributed on an \"AS IS\" basis, WITHOUT WARRANTY OF ANY\n * KIND, either express or implied.\n *\n ***************************************************************************/\n\n#include \"curl_setup.h\"\n\n#define MIME_RAND_BOUNDARY_CHARS        16  /* Nb. of random boundary chars. */\n#define MAX_ENCODED_LINE_LENGTH         76  /* Maximum encoded line length. */\n#define ENCODING_BUFFER_SIZE            256 /* Encoding temp buffers size. */\n\n/* Part flags. */\n#define MIME_USERHEADERS_OWNER  (1 << 0)\n#define MIME_BODY_ONLY          (1 << 1)\n#define MIME_FAST_READ          (1 << 2)\n\n#define FILE_CONTENTTYPE_DEFAULT        \"application/octet-stream\"\n#define MULTIPART_CONTENTTYPE_DEFAULT   \"multipart/mixed\"\n#define DISPOSITION_DEFAULT             \"attachment\"\n\n/* Part source kinds. */\nenum mimekind {\n  MIMEKIND_NONE = 0,            /* Part not set. */\n  MIMEKIND_DATA,                /* Allocated mime data. */\n  MIMEKIND_FILE,                /* Data from file. */\n  MIMEKIND_CALLBACK,            /* Data from `read' callback. */\n  MIMEKIND_MULTIPART,           /* Data is a mime subpart. */\n  MIMEKIND_LAST\n};\n\n/* Readback state tokens. */\nenum mimestate {\n  MIMESTATE_BEGIN,              /* Readback has not yet started. */\n  MIMESTATE_CURLHEADERS,        /* In curl-generated headers. */\n  MIMESTATE_USERHEADERS,        /* In caller's supplied headers. */\n  MIMESTATE_EOH,                /* End of headers. */\n  MIMESTATE_BODY,               /* Placeholder. */\n  MIMESTATE_BOUNDARY1,          /* In boundary prefix. */\n  MIMESTATE_BOUNDARY2,          /* In boundary. */\n  MIMESTATE_CONTENT,            /* In content. */\n  MIMESTATE_END,                /* End of part reached. */\n  MIMESTATE_LAST\n};\n\n/* Mime headers strategies. */\nenum mimestrategy {\n  MIMESTRATEGY_MAIL,            /* Mime mail. */\n  MIMESTRATEGY_FORM,            /* HTTP post form. */\n  MIMESTRATEGY_LAST\n};\n\n/* Content transfer encoder. */\nstruct mime_encoder {\n  const char *   name;          /* Encoding name. */\n  size_t         (*encodefunc)(char *buffer, size_t size, bool ateof,\n                               curl_mimepart *part);  /* Encoded read. */\n  curl_off_t     (*sizefunc)(curl_mimepart *part);  /* Encoded size. */\n};\n\n/* Content transfer encoder state. */\nstruct mime_encoder_state {\n  size_t         pos;           /* Position on output line. */\n  size_t         bufbeg;        /* Next data index in input buffer. */\n  size_t         bufend;        /* First unused byte index in input buffer. */\n  char           buf[ENCODING_BUFFER_SIZE]; /* Input buffer. */\n};\n\n/* Mime readback state. */\nstruct mime_state {\n  enum mimestate state;       /* Current state token. */\n  void *ptr;                  /* State-dependent pointer. */\n  curl_off_t offset;          /* State-dependent offset. */\n};\n\n/* minimum buffer size for the boundary string */\n#define MIME_BOUNDARY_LEN (24 + MIME_RAND_BOUNDARY_CHARS + 1)\n\n/* A mime multipart. */\nstruct curl_mime {\n  struct Curl_easy *easy;          /* The associated easy handle. */\n  curl_mimepart *parent;           /* Parent part. */\n  curl_mimepart *firstpart;        /* First part. */\n  curl_mimepart *lastpart;         /* Last part. */\n  char boundary[MIME_BOUNDARY_LEN]; /* The part boundary. */\n  struct mime_state state;         /* Current readback state. */\n};\n\n/* A mime part. */\nstruct curl_mimepart {\n  struct Curl_easy *easy;          /* The associated easy handle. */\n  curl_mime *parent;               /* Parent mime structure. */\n  curl_mimepart *nextpart;         /* Forward linked list. */\n  enum mimekind kind;              /* The part kind. */\n  char *data;                      /* Memory data or file name. */\n  curl_read_callback readfunc;     /* Read function. */\n  curl_seek_callback seekfunc;     /* Seek function. */\n  curl_free_callback freefunc;     /* Argument free function. */\n  void *arg;                       /* Argument to callback functions. */\n  FILE *fp;                        /* File pointer. */\n  struct curl_slist *curlheaders;  /* Part headers. */\n  struct curl_slist *userheaders;  /* Part headers. */\n  char *mimetype;                  /* Part mime type. */\n  char *filename;                  /* Remote file name. */\n  char *name;                      /* Data name. */\n  curl_off_t datasize;             /* Expected data size. */\n  unsigned int flags;              /* Flags. */\n  struct mime_state state;         /* Current readback state. */\n  const struct mime_encoder *encoder; /* Content data encoder. */\n  struct mime_encoder_state encstate; /* Data encoder state. */\n  size_t lastreadstatus;           /* Last read callback returned status. */\n};\n\nCURLcode Curl_mime_add_header(struct curl_slist **slp, const char *fmt, ...);\n\n#if (!defined(CURL_DISABLE_HTTP) && !defined(CURL_DISABLE_MIME)) ||     \\\n  !defined(CURL_DISABLE_SMTP) || !defined(CURL_DISABLE_IMAP)\n\n/* Prototypes. */\nvoid Curl_mime_initpart(struct curl_mimepart *part, struct Curl_easy *easy);\nvoid Curl_mime_cleanpart(struct curl_mimepart *part);\nCURLcode Curl_mime_duppart(struct curl_mimepart *dst,\n                           const curl_mimepart *src);\nCURLcode Curl_mime_set_subparts(struct curl_mimepart *part,\n                                struct curl_mime *subparts,\n                                int take_ownership);\nCURLcode Curl_mime_prepare_headers(struct curl_mimepart *part,\n                                   const char *contenttype,\n                                   const char *disposition,\n                                   enum mimestrategy strategy);\ncurl_off_t Curl_mime_size(struct curl_mimepart *part);\nsize_t Curl_mime_read(char *buffer, size_t size, size_t nitems,\n                      void *instream);\nCURLcode Curl_mime_rewind(struct curl_mimepart *part);\nconst char *Curl_mime_contenttype(const char *filename);\nvoid Curl_mime_unpause(struct curl_mimepart *part);\n\n#else\n/* if disabled */\n#define Curl_mime_initpart(x,y)\n#define Curl_mime_cleanpart(x)\n#define Curl_mime_duppart(x,y) CURLE_OK /* Nothing to duplicate. Succeed */\n#define Curl_mime_set_subparts(a,b,c) CURLE_NOT_BUILT_IN\n#define Curl_mime_prepare_headers(a,b,c,d) CURLE_NOT_BUILT_IN\n#define Curl_mime_size(x) (curl_off_t) -1\n#define Curl_mime_read NULL\n#define Curl_mime_rewind(x) ((void)x, CURLE_NOT_BUILT_IN)\n#define Curl_mime_unpause(x)\n#endif\n\n\n#endif /* HEADER_CURL_MIME_H */\n"}, "36": {"id": 36, "path": "/home/runner/work/testcc/testcc/retdec/lib/sendf.h", "content": "#ifndef HEADER_CURL_SENDF_H\n#define HEADER_CURL_SENDF_H\n/***************************************************************************\n *                                  _   _ ____  _\n *  Project                     ___| | | |  _ \\| |\n *                             / __| | | | |_) | |\n *                            | (__| |_| |  _ <| |___\n *                             \\___|\\___/|_| \\_\\_____|\n *\n * Copyright (C) 1998 - 2018, Daniel Stenberg, <daniel@haxx.se>, et al.\n *\n * This software is licensed as described in the file COPYING, which\n * you should have received as part of this distribution. The terms\n * are also available at https://curl.haxx.se/docs/copyright.html.\n *\n * You may opt to use, copy, modify, merge, publish, distribute and/or sell\n * copies of the Software, and permit persons to whom the Software is\n * furnished to do so, under the terms of the COPYING file.\n *\n * This software is distributed on an \"AS IS\" basis, WITHOUT WARRANTY OF ANY\n * KIND, either express or implied.\n *\n ***************************************************************************/\n\n#include \"curl_setup.h\"\n\nCURLcode Curl_sendf(curl_socket_t sockfd, struct connectdata *,\n                    const char *fmt, ...);\nvoid Curl_infof(struct Curl_easy *, const char *fmt, ...);\nvoid Curl_failf(struct Curl_easy *, const char *fmt, ...);\n\n#if defined(CURL_DISABLE_VERBOSE_STRINGS)\n\n#if defined(HAVE_VARIADIC_MACROS_C99)\n#define infof(...)  Curl_nop_stmt\n#elif defined(HAVE_VARIADIC_MACROS_GCC)\n#define infof(x...)  Curl_nop_stmt\n#else\n#error \"missing VARIADIC macro define, fix and rebuild!\"\n#endif\n\n#else /* CURL_DISABLE_VERBOSE_STRINGS */\n\n#define infof Curl_infof\n\n#endif /* CURL_DISABLE_VERBOSE_STRINGS */\n\n#define failf Curl_failf\n\n#define CLIENTWRITE_BODY   (1<<0)\n#define CLIENTWRITE_HEADER (1<<1)\n#define CLIENTWRITE_BOTH   (CLIENTWRITE_BODY|CLIENTWRITE_HEADER)\n\nCURLcode Curl_client_write(struct connectdata *conn, int type, char *ptr,\n                           size_t len) WARN_UNUSED_RESULT;\n\nbool Curl_recv_has_postponed_data(struct connectdata *conn, int sockindex);\n\n/* internal read-function, does plain socket only */\nCURLcode Curl_read_plain(curl_socket_t sockfd,\n                         char *buf,\n                         size_t bytesfromsocket,\n                         ssize_t *n);\n\nssize_t Curl_recv_plain(struct connectdata *conn, int num, char *buf,\n                        size_t len, CURLcode *code);\nssize_t Curl_send_plain(struct connectdata *conn, int num,\n                        const void *mem, size_t len, CURLcode *code);\n\n/* internal read-function, does plain socket, SSL and krb4 */\nCURLcode Curl_read(struct connectdata *conn, curl_socket_t sockfd,\n                   char *buf, size_t buffersize,\n                   ssize_t *n);\n/* internal write-function, does plain socket, SSL, SCP, SFTP and krb4 */\nCURLcode Curl_write(struct connectdata *conn,\n                    curl_socket_t sockfd,\n                    const void *mem, size_t len,\n                    ssize_t *written);\n\n/* internal write-function, does plain sockets ONLY */\nCURLcode Curl_write_plain(struct connectdata *conn,\n                          curl_socket_t sockfd,\n                          const void *mem, size_t len,\n                          ssize_t *written);\n\n/* the function used to output verbose information */\nint Curl_debug(struct Curl_easy *data, curl_infotype type,\n               char *ptr, size_t size);\n\n\n#endif /* HEADER_CURL_SENDF_H */\n"}, "37": {"id": 37, "path": "/home/runner/work/testcc/testcc/retdec/lib/http2.h", "content": "#ifndef HEADER_CURL_HTTP2_H\n#define HEADER_CURL_HTTP2_H\n/***************************************************************************\n *                                  _   _ ____  _\n *  Project                     ___| | | |  _ \\| |\n *                             / __| | | | |_) | |\n *                            | (__| |_| |  _ <| |___\n *                             \\___|\\___/|_| \\_\\_____|\n *\n * Copyright (C) 1998 - 2020, Daniel Stenberg, <daniel@haxx.se>, et al.\n *\n * This software is licensed as described in the file COPYING, which\n * you should have received as part of this distribution. The terms\n * are also available at https://curl.haxx.se/docs/copyright.html.\n *\n * You may opt to use, copy, modify, merge, publish, distribute and/or sell\n * copies of the Software, and permit persons to whom the Software is\n * furnished to do so, under the terms of the COPYING file.\n *\n * This software is distributed on an \"AS IS\" basis, WITHOUT WARRANTY OF ANY\n * KIND, either express or implied.\n *\n ***************************************************************************/\n\n#include \"curl_setup.h\"\n\n#ifdef USE_NGHTTP2\n#include \"http.h\"\n\n/* value for MAX_CONCURRENT_STREAMS we use until we get an updated setting\n   from the peer */\n#define DEFAULT_MAX_CONCURRENT_STREAMS 13\n\n/*\n * Store nghttp2 version info in this buffer, Prefix with a space.  Return\n * total length written.\n */\nint Curl_http2_ver(char *p, size_t len);\n\nconst char *Curl_http2_strerror(uint32_t err);\n\nCURLcode Curl_http2_init(struct connectdata *conn);\nvoid Curl_http2_init_state(struct UrlState *state);\nvoid Curl_http2_init_userset(struct UserDefined *set);\nCURLcode Curl_http2_request_upgrade(struct dynbuf *req,\n                                    struct connectdata *conn);\nCURLcode Curl_http2_setup(struct connectdata *conn);\nCURLcode Curl_http2_switched(struct connectdata *conn,\n                             const char *data, size_t nread);\n/* called from http_setup_conn */\nvoid Curl_http2_setup_conn(struct connectdata *conn);\nvoid Curl_http2_setup_req(struct Curl_easy *data);\nvoid Curl_http2_done(struct Curl_easy *data, bool premature);\nCURLcode Curl_http2_done_sending(struct connectdata *conn);\nCURLcode Curl_http2_add_child(struct Curl_easy *parent,\n                              struct Curl_easy *child,\n                              bool exclusive);\nvoid Curl_http2_remove_child(struct Curl_easy *parent,\n                             struct Curl_easy *child);\nvoid Curl_http2_cleanup_dependencies(struct Curl_easy *data);\nCURLcode Curl_http2_stream_pause(struct Curl_easy *data, bool pause);\n\n/* returns true if the HTTP/2 stream error was HTTP_1_1_REQUIRED */\nbool Curl_h2_http_1_1_error(struct connectdata *conn);\n#else /* USE_NGHTTP2 */\n#define Curl_http2_request_upgrade(x,y) CURLE_UNSUPPORTED_PROTOCOL\n#define Curl_http2_setup(x) CURLE_UNSUPPORTED_PROTOCOL\n#define Curl_http2_switched(x,y,z) CURLE_UNSUPPORTED_PROTOCOL\n#define Curl_http2_setup_conn(x) Curl_nop_stmt\n#define Curl_http2_setup_req(x)\n#define Curl_http2_init_state(x)\n#define Curl_http2_init_userset(x)\n#define Curl_http2_done(x,y)\n#define Curl_http2_done_sending(x)\n#define Curl_http2_add_child(x, y, z)\n#define Curl_http2_remove_child(x, y)\n#define Curl_http2_cleanup_dependencies(x)\n#define Curl_http2_stream_pause(x, y)\n#define Curl_h2_http_1_1_error(x) 0\n#endif\n\n#endif /* HEADER_CURL_HTTP2_H */\n"}, "39": {"id": 39, "path": "/home/runner/work/testcc/testcc/retdec/lib/http_digest.h", "content": "#ifndef HEADER_CURL_HTTP_DIGEST_H\n#define HEADER_CURL_HTTP_DIGEST_H\n/***************************************************************************\n *                                  _   _ ____  _\n *  Project                     ___| | | |  _ \\| |\n *                             / __| | | | |_) | |\n *                            | (__| |_| |  _ <| |___\n *                             \\___|\\___/|_| \\_\\_____|\n *\n * Copyright (C) 1998 - 2020, Daniel Stenberg, <daniel@haxx.se>, et al.\n *\n * This software is licensed as described in the file COPYING, which\n * you should have received as part of this distribution. The terms\n * are also available at https://curl.haxx.se/docs/copyright.html.\n *\n * You may opt to use, copy, modify, merge, publish, distribute and/or sell\n * copies of the Software, and permit persons to whom the Software is\n * furnished to do so, under the terms of the COPYING file.\n *\n * This software is distributed on an \"AS IS\" basis, WITHOUT WARRANTY OF ANY\n * KIND, either express or implied.\n *\n ***************************************************************************/\n#include \"curl_setup.h\"\n\n#if !defined(CURL_DISABLE_HTTP) && !defined(CURL_DISABLE_CRYPTO_AUTH)\n\n/* this is for digest header input */\nCURLcode Curl_input_digest(struct connectdata *conn,\n                           bool proxy, const char *header);\n\n/* this is for creating digest header output */\nCURLcode Curl_output_digest(struct connectdata *conn,\n                            bool proxy,\n                            const unsigned char *request,\n                            const unsigned char *uripath);\n\nvoid Curl_http_auth_cleanup_digest(struct Curl_easy *data);\n\n#endif /* !CURL_DISABLE_HTTP && !CURL_DISABLE_CRYPTO_AUTH */\n\n#endif /* HEADER_CURL_HTTP_DIGEST_H */\n"}, "40": {"id": 40, "path": "/home/runner/work/testcc/testcc/retdec/lib/http_negotiate.h", "content": "#ifndef HEADER_CURL_HTTP_NEGOTIATE_H\n#define HEADER_CURL_HTTP_NEGOTIATE_H\n/***************************************************************************\n *                                  _   _ ____  _\n *  Project                     ___| | | |  _ \\| |\n *                             / __| | | | |_) | |\n *                            | (__| |_| |  _ <| |___\n *                             \\___|\\___/|_| \\_\\_____|\n *\n * Copyright (C) 1998 - 2020, Daniel Stenberg, <daniel@haxx.se>, et al.\n *\n * This software is licensed as described in the file COPYING, which\n * you should have received as part of this distribution. The terms\n * are also available at https://curl.haxx.se/docs/copyright.html.\n *\n * You may opt to use, copy, modify, merge, publish, distribute and/or sell\n * copies of the Software, and permit persons to whom the Software is\n * furnished to do so, under the terms of the COPYING file.\n *\n * This software is distributed on an \"AS IS\" basis, WITHOUT WARRANTY OF ANY\n * KIND, either express or implied.\n *\n ***************************************************************************/\n\n#if !defined(CURL_DISABLE_HTTP) && defined(USE_SPNEGO)\n\n/* this is for Negotiate header input */\nCURLcode Curl_input_negotiate(struct connectdata *conn, bool proxy,\n                              const char *header);\n\n/* this is for creating Negotiate header output */\nCURLcode Curl_output_negotiate(struct connectdata *conn, bool proxy);\n\nvoid Curl_http_auth_cleanup_negotiate(struct connectdata *conn);\n\n#else /* !CURL_DISABLE_HTTP && USE_SPNEGO */\n#define Curl_http_auth_cleanup_negotiate(x)\n#endif\n\n#endif /* HEADER_CURL_HTTP_NEGOTIATE_H */\n"}, "41": {"id": 41, "path": "/home/runner/work/testcc/testcc/retdec/lib/http_ntlm.h", "content": "#ifndef HEADER_CURL_HTTP_NTLM_H\n#define HEADER_CURL_HTTP_NTLM_H\n/***************************************************************************\n *                                  _   _ ____  _\n *  Project                     ___| | | |  _ \\| |\n *                             / __| | | | |_) | |\n *                            | (__| |_| |  _ <| |___\n *                             \\___|\\___/|_| \\_\\_____|\n *\n * Copyright (C) 1998 - 2020, Daniel Stenberg, <daniel@haxx.se>, et al.\n *\n * This software is licensed as described in the file COPYING, which\n * you should have received as part of this distribution. The terms\n * are also available at https://curl.haxx.se/docs/copyright.html.\n *\n * You may opt to use, copy, modify, merge, publish, distribute and/or sell\n * copies of the Software, and permit persons to whom the Software is\n * furnished to do so, under the terms of the COPYING file.\n *\n * This software is distributed on an \"AS IS\" basis, WITHOUT WARRANTY OF ANY\n * KIND, either express or implied.\n *\n ***************************************************************************/\n\n#include \"curl_setup.h\"\n\n#if !defined(CURL_DISABLE_HTTP) && defined(USE_NTLM)\n\n/* this is for ntlm header input */\nCURLcode Curl_input_ntlm(struct connectdata *conn, bool proxy,\n                         const char *header);\n\n/* this is for creating ntlm header output */\nCURLcode Curl_output_ntlm(struct connectdata *conn, bool proxy);\n\nvoid Curl_http_auth_cleanup_ntlm(struct connectdata *conn);\n\n#else /* !CURL_DISABLE_HTTP && USE_NTLM */\n#define Curl_http_auth_cleanup_ntlm(x)\n#endif\n\n#endif /* HEADER_CURL_HTTP_NTLM_H */\n"}, "42": {"id": 42, "path": "/home/runner/work/testcc/testcc/retdec/lib/http_proxy.h", "content": "#ifndef HEADER_CURL_HTTP_PROXY_H\n#define HEADER_CURL_HTTP_PROXY_H\n/***************************************************************************\n *                                  _   _ ____  _\n *  Project                     ___| | | |  _ \\| |\n *                             / __| | | | |_) | |\n *                            | (__| |_| |  _ <| |___\n *                             \\___|\\___/|_| \\_\\_____|\n *\n * Copyright (C) 1998 - 2020, Daniel Stenberg, <daniel@haxx.se>, et al.\n *\n * This software is licensed as described in the file COPYING, which\n * you should have received as part of this distribution. The terms\n * are also available at https://curl.haxx.se/docs/copyright.html.\n *\n * You may opt to use, copy, modify, merge, publish, distribute and/or sell\n * copies of the Software, and permit persons to whom the Software is\n * furnished to do so, under the terms of the COPYING file.\n *\n * This software is distributed on an \"AS IS\" basis, WITHOUT WARRANTY OF ANY\n * KIND, either express or implied.\n *\n ***************************************************************************/\n\n#include \"curl_setup.h\"\n#include \"urldata.h\"\n\n#if !defined(CURL_DISABLE_PROXY) && !defined(CURL_DISABLE_HTTP)\n/* ftp can use this as well */\nCURLcode Curl_proxyCONNECT(struct connectdata *conn,\n                           int tunnelsocket,\n                           const char *hostname, int remote_port);\n\n/* Default proxy timeout in milliseconds */\n#define PROXY_TIMEOUT (3600*1000)\n\nCURLcode Curl_proxy_connect(struct connectdata *conn, int sockindex);\n\nbool Curl_connect_complete(struct connectdata *conn);\nbool Curl_connect_ongoing(struct connectdata *conn);\n\n#else\n#define Curl_proxyCONNECT(x,y,z,w) CURLE_NOT_BUILT_IN\n#define Curl_proxy_connect(x,y) CURLE_OK\n#define Curl_connect_complete(x) CURLE_OK\n#define Curl_connect_ongoing(x) FALSE\n#endif\n\nvoid Curl_connect_free(struct Curl_easy *data);\nvoid Curl_connect_done(struct Curl_easy *data);\n\n#endif /* HEADER_CURL_HTTP_PROXY_H */\n"}, "50": {"id": 50, "path": "/home/runner/work/testcc/testcc/retdec/lib/parsedate.h", "content": "#ifndef HEADER_CURL_PARSEDATE_H\n#define HEADER_CURL_PARSEDATE_H\n/***************************************************************************\n *                                  _   _ ____  _\n *  Project                     ___| | | |  _ \\| |\n *                             / __| | | | |_) | |\n *                            | (__| |_| |  _ <| |___\n *                             \\___|\\___/|_| \\_\\_____|\n *\n * Copyright (C) 1998 - 2019, Daniel Stenberg, <daniel@haxx.se>, et al.\n *\n * This software is licensed as described in the file COPYING, which\n * you should have received as part of this distribution. The terms\n * are also available at https://curl.haxx.se/docs/copyright.html.\n *\n * You may opt to use, copy, modify, merge, publish, distribute and/or sell\n * copies of the Software, and permit persons to whom the Software is\n * furnished to do so, under the terms of the COPYING file.\n *\n * This software is distributed on an \"AS IS\" basis, WITHOUT WARRANTY OF ANY\n * KIND, either express or implied.\n *\n ***************************************************************************/\n\nextern const char * const Curl_wkday[7];\nextern const char * const Curl_month[12];\n\nCURLcode Curl_gmtime(time_t intime, struct tm *store);\n\n/* Curl_getdate_capped() differs from curl_getdate() in that this will return\n   TIME_T_MAX in case the parsed time value was too big, instead of an\n   error. */\n\ntime_t Curl_getdate_capped(const char *p);\n\n#endif /* HEADER_CURL_PARSEDATE_H */\n"}, "58": {"id": 58, "path": "/home/runner/work/testcc/testcc/retdec/lib/share.h", "content": "#ifndef HEADER_CURL_SHARE_H\n#define HEADER_CURL_SHARE_H\n/***************************************************************************\n *                                  _   _ ____  _\n *  Project                     ___| | | |  _ \\| |\n *                             / __| | | | |_) | |\n *                            | (__| |_| |  _ <| |___\n *                             \\___|\\___/|_| \\_\\_____|\n *\n * Copyright (C) 1998 - 2018, Daniel Stenberg, <daniel@haxx.se>, et al.\n *\n * This software is licensed as described in the file COPYING, which\n * you should have received as part of this distribution. The terms\n * are also available at https://curl.haxx.se/docs/copyright.html.\n *\n * You may opt to use, copy, modify, merge, publish, distribute and/or sell\n * copies of the Software, and permit persons to whom the Software is\n * furnished to do so, under the terms of the COPYING file.\n *\n * This software is distributed on an \"AS IS\" basis, WITHOUT WARRANTY OF ANY\n * KIND, either express or implied.\n *\n ***************************************************************************/\n\n#include \"curl_setup.h\"\n#include <curl/curl.h>\n#include \"cookie.h\"\n#include \"psl.h\"\n#include \"urldata.h\"\n#include \"conncache.h\"\n\n/* SalfordC says \"A structure member may not be volatile\". Hence:\n */\n#ifdef __SALFORDC__\n#define CURL_VOLATILE\n#else\n#define CURL_VOLATILE volatile\n#endif\n\n/* this struct is libcurl-private, don't export details */\nstruct Curl_share {\n  unsigned int specifier;\n  CURL_VOLATILE unsigned int dirty;\n\n  curl_lock_function lockfunc;\n  curl_unlock_function unlockfunc;\n  void *clientdata;\n  struct conncache conn_cache;\n  struct curl_hash hostcache;\n#if !defined(CURL_DISABLE_HTTP) && !defined(CURL_DISABLE_COOKIES)\n  struct CookieInfo *cookies;\n#endif\n#ifdef USE_LIBPSL\n  struct PslCache psl;\n#endif\n\n  struct curl_ssl_session *sslsession;\n  size_t max_ssl_sessions;\n  long sessionage;\n};\n\nCURLSHcode Curl_share_lock(struct Curl_easy *, curl_lock_data,\n                           curl_lock_access);\nCURLSHcode Curl_share_unlock(struct Curl_easy *, curl_lock_data);\n\n#endif /* HEADER_CURL_SHARE_H */\n"}}, "reports": [{"events": [{"location": {"col": 9, "file": 8, "line": 1}, "message": "_HOME_RUNNER_WORK_TESTCC_TESTCC_RETDEC_LIB_ALTSVC_H (fixit)"}, {"location": {"col": 9, "file": 8, "line": 1}, "message": "header guard does not follow preferred style"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/lib/altsvc.h", "reportHash": "671311195ddf0a84698b42483e324869", "checkerName": "llvm-header-guard", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 9, "file": 19, "line": 1}, "message": "_HOME_RUNNER_WORK_TESTCC_TESTCC_RETDEC_LIB_CURL_NTLM_WB_H (fixit)"}, {"location": {"col": 9, "file": 19, "line": 1}, "message": "header guard does not follow preferred style"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/lib/curl_ntlm_wb.h", "reportHash": "7061b9e96924da9011f97eff915c9206", "checkerName": "llvm-header-guard", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 10, "file": 31, "line": 48}, "message": "\"altsvc.h\" (fixit)"}, {"location": {"col": 1, "file": 31, "line": 48}, "message": "#includes are not sorted properly"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/lib/http.c", "reportHash": "0dda29421f85a2ff98d1ebaacae7d361", "checkerName": "llvm-include-order", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 10, "file": 31, "line": 82}, "message": "\"curl_memory.h\" (fixit)"}, {"location": {"col": 1, "file": 31, "line": 82}, "message": "#includes are not sorted properly"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/lib/http.c", "reportHash": "3675048580f087136eab5a6e2f5919e4", "checkerName": "llvm-include-order", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 27, "file": 0, "line": 960}, "message": "expanded from macro 'CURLPROTO_HTTP'"}, {"location": {"col": 3, "file": 31, "line": 127}, "message": "use of a signed integer operand with a binary bitwise operator"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/lib/http.c", "reportHash": "56f395f663760d257a65a5837e8c5716", "checkerName": "hicpp-signed-bitwise", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 33, "file": 32, "line": 761}, "message": "expanded from macro 'PROTOPT_CREDSPERREQUEST'"}, {"location": {"col": 3, "file": 31, "line": 128}, "message": "use of a signed integer operand with a binary bitwise operator"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/lib/http.c", "reportHash": "8503ea542cd5680332cc164ec54923ff", "checkerName": "hicpp-signed-bitwise", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 30, "file": 32, "line": 771}, "message": "expanded from macro 'PROTOPT_USERPWDCTRL'"}, {"location": {"col": 3, "file": 31, "line": 129}, "message": "use of a signed integer operand with a binary bitwise operator"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/lib/http.c", "reportHash": "2c4d74862d57a8e06a1ac6b4fae2682e", "checkerName": "hicpp-signed-bitwise", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 27, "file": 0, "line": 961}, "message": "expanded from macro 'CURLPROTO_HTTPS'"}, {"location": {"col": 3, "file": 31, "line": 153}, "message": "use of a signed integer operand with a binary bitwise operator"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/lib/http.c", "reportHash": "0e31f6a937e229cb0536baf5e84197cf", "checkerName": "hicpp-signed-bitwise", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 21, "file": 32, "line": 748}, "message": "expanded from macro 'PROTOPT_SSL'"}, {"location": {"col": 3, "file": 31, "line": 154}, "message": "use of a signed integer operand with a binary bitwise operator"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/lib/http.c", "reportHash": "ea45b4836701d9b601e7932870b9a0cf", "checkerName": "hicpp-signed-bitwise", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 34, "file": 32, "line": 761}, "message": "expanded from macro 'PROTOPT_CREDSPERREQUEST'"}, {"location": {"col": 17, "file": 31, "line": 154}, "message": "use of a signed integer operand with a binary bitwise operator"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/lib/http.c", "reportHash": "29e09cc240ebe0235ce0311ac21e301b", "checkerName": "hicpp-signed-bitwise", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 27, "file": 32, "line": 763}, "message": "expanded from macro 'PROTOPT_ALPN_NPN'"}, {"location": {"col": 43, "file": 31, "line": 154}, "message": "use of a signed integer operand with a binary bitwise operator"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/lib/http.c", "reportHash": "57e6c6754c885beaea2daaea50fab47f", "checkerName": "hicpp-signed-bitwise", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 30, "file": 32, "line": 771}, "message": "expanded from macro 'PROTOPT_USERPWDCTRL'"}, {"location": {"col": 3, "file": 31, "line": 155}, "message": "use of a signed integer operand with a binary bitwise operator"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/lib/http.c", "reportHash": "2c4d74862d57a8e06a1ac6b4fae2682e", "checkerName": "hicpp-signed-bitwise", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 13, "file": 31, "line": 168}, "message": "{ (fixit)"}, {"location": {"col": 12, "file": 31, "line": 168}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/lib/http.c", "reportHash": "d8158a3d7e588c836d2c80adfcf05174", "checkerName": "google-readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 8, "file": 31, "line": 175}, "message": "use of a signed integer operand with a binary bitwise operator"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/lib/http.c", "reportHash": "4daa2dd5bb21352475aaa7c66dce2ea9", "checkerName": "hicpp-signed-bitwise", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 22, "file": 32, "line": 748}, "message": "expanded from macro 'PROTOPT_SSL'"}, {"location": {"col": 31, "file": 31, "line": 175}, "message": "use of a signed integer operand with a binary bitwise operator"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/lib/http.c", "reportHash": "97bab3f78bea5796458cb0c8d29c6818", "checkerName": "hicpp-signed-bitwise", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 44, "file": 31, "line": 175}, "message": "{ (fixit)"}, {"location": {"col": 43, "file": 31, "line": 175}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/lib/http.c", "reportHash": "ffee7dfda0e73b079e027d2cb6075ff8", "checkerName": "google-readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 27, "file": 31, "line": 185}, "message": "{ (fixit)"}, {"location": {"col": 26, "file": 31, "line": 185}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/lib/http.c", "reportHash": "006648e88ca71423f0afeba9b6618206", "checkerName": "readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 45, "file": 31, "line": 214}, "message": "{ (fixit)"}, {"location": {"col": 44, "file": 31, "line": 214}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/lib/http.c", "reportHash": "3ecead1ba5cab02583efb5a912c21b6a", "checkerName": "google-readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 38, "file": 31, "line": 239}, "message": "{ (fixit)"}, {"location": {"col": 37, "file": 31, "line": 239}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/lib/http.c", "reportHash": "b021fc388f479813c32c1fb03dd961df", "checkerName": "google-readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 15, "file": 31, "line": 242}, "message": "{ (fixit)"}, {"location": {"col": 14, "file": 31, "line": 242}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/lib/http.c", "reportHash": "ef3efa578e15303c3aad4bf2c1e455e4", "checkerName": "google-readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 36, "file": 31, "line": 248}, "message": "{ (fixit)"}, {"location": {"col": 35, "file": 31, "line": 248}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/lib/http.c", "reportHash": "4d70c46f13de9eaea2876d4665fe363d", "checkerName": "hicpp-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 12, "file": 31, "line": 254}, "message": "{ (fixit)"}, {"location": {"col": 11, "file": 31, "line": 254}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/lib/http.c", "reportHash": "a7c621200381a92a8973fb99d516742d", "checkerName": "google-readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 12, "file": 31, "line": 256}, "message": "{ (fixit)"}, {"location": {"col": 11, "file": 31, "line": 256}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/lib/http.c", "reportHash": "a7c621200381a92a8973fb99d516742d", "checkerName": "google-readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 12, "file": 31, "line": 258}, "message": "{ (fixit)"}, {"location": {"col": 11, "file": 31, "line": 258}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/lib/http.c", "reportHash": "504d97d94105d6971aa925edfb260d47", "checkerName": "hicpp-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 41, "file": 31, "line": 262}, "message": "{ (fixit)"}, {"location": {"col": 40, "file": 31, "line": 262}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/lib/http.c", "reportHash": "042c2500c5c3d532cb3f96627de72287", "checkerName": "google-readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 14, "file": 31, "line": 269}, "message": "{ (fixit)"}, {"location": {"col": 13, "file": 31, "line": 269}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/lib/http.c", "reportHash": "c7de9a4ed251116d981622a438a09b9b", "checkerName": "google-readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 12, "file": 31, "line": 312}, "message": "{ (fixit)"}, {"location": {"col": 11, "file": 31, "line": 312}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/lib/http.c", "reportHash": "476eb78eb2c7ab6b4cb424f6ba696312", "checkerName": "readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 14, "file": 31, "line": 316}, "message": "{ (fixit)"}, {"location": {"col": 13, "file": 31, "line": 316}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/lib/http.c", "reportHash": "a93ab9f47ee766435f9a6bf318bf87b4", "checkerName": "readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 32, "file": 0, "line": 781}, "message": "expanded from macro 'CURLAUTH_NEGOTIATE'"}, {"location": {"col": 14, "file": 31, "line": 381}, "message": "use of a signed integer operand with a binary bitwise operator"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/lib/http.c", "reportHash": "2f91c83304d439d9a53dff10cfd671aa", "checkerName": "hicpp-signed-bitwise", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 34, "file": 31, "line": 381}, "message": "{ (fixit)"}, {"location": {"col": 33, "file": 31, "line": 381}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/lib/http.c", "reportHash": "166e43276a871d1ff9cc4a96d147ef2b", "checkerName": "readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 32, "file": 0, "line": 781}, "message": "expanded from macro 'CURLAUTH_NEGOTIATE'"}, {"location": {"col": 20, "file": 31, "line": 382}, "message": "use of a signed integer operand with a binary bitwise operator"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/lib/http.c", "reportHash": "b80de0aeda17685e9ca4e1feafd92ccc", "checkerName": "hicpp-signed-bitwise", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 32, "file": 0, "line": 789}, "message": "expanded from macro 'CURLAUTH_BEARER'"}, {"location": {"col": 19, "file": 31, "line": 383}, "message": "use of a signed integer operand with a binary bitwise operator"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/lib/http.c", "reportHash": "4eefa10608a0d80c560ab11492374434", "checkerName": "hicpp-signed-bitwise", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 36, "file": 31, "line": 383}, "message": "{ (fixit)"}, {"location": {"col": 35, "file": 31, "line": 383}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/lib/http.c", "reportHash": "14441a5661a0ae7f90614c5dbc70f1a8", "checkerName": "google-readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 32, "file": 0, "line": 789}, "message": "expanded from macro 'CURLAUTH_BEARER'"}, {"location": {"col": 20, "file": 31, "line": 384}, "message": "use of a signed integer operand with a binary bitwise operator"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/lib/http.c", "reportHash": "d501ed7b951728c38c5954a13b754e7f", "checkerName": "hicpp-signed-bitwise", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 32, "file": 0, "line": 780}, "message": "expanded from macro 'CURLAUTH_DIGEST'"}, {"location": {"col": 19, "file": 31, "line": 385}, "message": "use of a signed integer operand with a binary bitwise operator"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/lib/http.c", "reportHash": "02e4b847c9c5d07148c3a62fcf658d9e", "checkerName": "hicpp-signed-bitwise", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 36, "file": 31, "line": 385}, "message": "{ (fixit)"}, {"location": {"col": 35, "file": 31, "line": 385}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/lib/http.c", "reportHash": "e5d67f8b88c8847e11eb86859d2f47cf", "checkerName": "google-readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 32, "file": 0, "line": 780}, "message": "expanded from macro 'CURLAUTH_DIGEST'"}, {"location": {"col": 20, "file": 31, "line": 386}, "message": "use of a signed integer operand with a binary bitwise operator"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/lib/http.c", "reportHash": "13aa48addc8b887bca9c02bed4c365f5", "checkerName": "hicpp-signed-bitwise", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 32, "file": 0, "line": 786}, "message": "expanded from macro 'CURLAUTH_NTLM'"}, {"location": {"col": 19, "file": 31, "line": 387}, "message": "use of a signed integer operand with a binary bitwise operator"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/lib/http.c", "reportHash": "26d3600c681b113654b53ef239d2fa0b", "checkerName": "hicpp-signed-bitwise", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 34, "file": 31, "line": 387}, "message": "{ (fixit)"}, {"location": {"col": 33, "file": 31, "line": 387}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/lib/http.c", "reportHash": "a7ea2f7695567facce7c32056593f659", "checkerName": "readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 32, "file": 0, "line": 786}, "message": "expanded from macro 'CURLAUTH_NTLM'"}, {"location": {"col": 20, "file": 31, "line": 388}, "message": "use of a signed integer operand with a binary bitwise operator"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/lib/http.c", "reportHash": "d597c6a6e0bdf51ed978f5ceb700c9fa", "checkerName": "hicpp-signed-bitwise", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 32, "file": 0, "line": 788}, "message": "expanded from macro 'CURLAUTH_NTLM_WB'"}, {"location": {"col": 19, "file": 31, "line": 389}, "message": "use of a signed integer operand with a binary bitwise operator"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/lib/http.c", "reportHash": "1c6a212a6ec08f5fcd01c3a236a6197c", "checkerName": "hicpp-signed-bitwise", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 37, "file": 31, "line": 389}, "message": "{ (fixit)"}, {"location": {"col": 36, "file": 31, "line": 389}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/lib/http.c", "reportHash": "97f277cd71c0fafe778909938978b317", "checkerName": "readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 32, "file": 0, "line": 788}, "message": "expanded from macro 'CURLAUTH_NTLM_WB'"}, {"location": {"col": 20, "file": 31, "line": 390}, "message": "use of a signed integer operand with a binary bitwise operator"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/lib/http.c", "reportHash": "c511a99954796dbf4bf2e81ade6f9233", "checkerName": "hicpp-signed-bitwise", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 32, "file": 0, "line": 779}, "message": "expanded from macro 'CURLAUTH_BASIC'"}, {"location": {"col": 19, "file": 31, "line": 391}, "message": "use of a signed integer operand with a binary bitwise operator"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/lib/http.c", "reportHash": "2a101755fd94f9e01a3987afdc8ea2b2", "checkerName": "hicpp-signed-bitwise", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 35, "file": 31, "line": 391}, "message": "{ (fixit)"}, {"location": {"col": 34, "file": 31, "line": 391}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/lib/http.c", "reportHash": "4ef795144ac3f5966ea6d07b6a173939", "checkerName": "google-readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 32, "file": 0, "line": 779}, "message": "expanded from macro 'CURLAUTH_BASIC'"}, {"location": {"col": 20, "file": 31, "line": 392}, "message": "use of a signed integer operand with a binary bitwise operator"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/lib/http.c", "reportHash": "f4e5e6182fb948798d9301953e6b7a82", "checkerName": "hicpp-signed-bitwise", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 28, "file": 33, "line": 76}, "message": "expanded from macro 'CURLAUTH_PICKNONE'"}, {"location": {"col": 20, "file": 31, "line": 394}, "message": "use of a signed integer operand with a binary bitwise operator"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/lib/http.c", "reportHash": "5a3b8e2e2ff056335f062b7f8d79e619", "checkerName": "hicpp-signed-bitwise", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 13, "file": 31, "line": 432}, "message": "{ (fixit)"}, {"location": {"col": 12, "file": 31, "line": 432}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/lib/http.c", "reportHash": "a9441b80eb3b4155ff3e1703c962452f", "checkerName": "hicpp-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 40, "file": 31, "line": 461}, "message": "{ (fixit)"}, {"location": {"col": 39, "file": 31, "line": 461}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/lib/http.c", "reportHash": "524efc80e97a087daba183bd5eb6b522", "checkerName": "readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 32, "file": 0, "line": 786}, "message": "expanded from macro 'CURLAUTH_NTLM'"}, {"location": {"col": 41, "file": 31, "line": 478}, "message": "use of a signed integer operand with a binary bitwise operator"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/lib/http.c", "reportHash": "33b385a897cbbfc23a599c1b58fe1b94", "checkerName": "hicpp-signed-bitwise", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 32, "file": 0, "line": 786}, "message": "expanded from macro 'CURLAUTH_NTLM'"}, {"location": {"col": 40, "file": 31, "line": 479}, "message": "use of a signed integer operand with a binary bitwise operator"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/lib/http.c", "reportHash": "843fae992af94f6fd05ffe048bf5a516", "checkerName": "hicpp-signed-bitwise", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 32, "file": 0, "line": 788}, "message": "expanded from macro 'CURLAUTH_NTLM_WB'"}, {"location": {"col": 41, "file": 31, "line": 480}, "message": "use of a signed integer operand with a binary bitwise operator"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/lib/http.c", "reportHash": "c63914624853b573dca370800f4290c8", "checkerName": "hicpp-signed-bitwise", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 32, "file": 0, "line": 788}, "message": "expanded from macro 'CURLAUTH_NTLM_WB'"}, {"location": {"col": 40, "file": 31, "line": 481}, "message": "use of a signed integer operand with a binary bitwise operator"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/lib/http.c", "reportHash": "cd4e87a3769dddebabece4421863e8d0", "checkerName": "hicpp-signed-bitwise", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 28, "file": 31, "line": 497}, "message": "{ (fixit)"}, {"location": {"col": 27, "file": 31, "line": 497}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/lib/http.c", "reportHash": "e709c8f567a981360c1109a86887f65d", "checkerName": "google-readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 17, "file": 31, "line": 543}, "message": "{ (fixit)"}, {"location": {"col": 16, "file": 31, "line": 543}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/lib/http.c", "reportHash": "f6ad6ecaa4b40e1c614bb457214ffa04", "checkerName": "google-readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 37, "file": 31, "line": 565}, "message": "{ (fixit)"}, {"location": {"col": 36, "file": 31, "line": 565}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/lib/http.c", "reportHash": "26b827e1bd6c1e2c71a6879787bae7f9", "checkerName": "readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 17, "file": 31, "line": 566}, "message": "redundant cast to the same type"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/lib/http.c", "reportHash": "5aecdcc62c1898b7027cc2985ab70aaf", "checkerName": "google-readability-casting", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 32, "file": 0, "line": 789}, "message": "expanded from macro 'CURLAUTH_BEARER'"}, {"location": {"col": 33, "file": 31, "line": 566}, "message": "use of a signed integer operand with a binary bitwise operator"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/lib/http.c", "reportHash": "ad9db8ef17b800547ae46b3abbb9c27b", "checkerName": "hicpp-signed-bitwise", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 62, "file": 31, "line": 568}, "message": "{ (fixit)"}, {"location": {"col": 61, "file": 31, "line": 568}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/lib/http.c", "reportHash": "28ac757f1bf5f5ad56d25bf6386d9e3c", "checkerName": "google-readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 31, "file": 31, "line": 572}, "message": "{ (fixit)"}, {"location": {"col": 30, "file": 31, "line": 572}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/lib/http.c", "reportHash": "25d64471739556b571706fbd0b81228a", "checkerName": "google-readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 19, "file": 31, "line": 579}, "message": "{ (fixit)"}, {"location": {"col": 18, "file": 31, "line": 579}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/lib/http.c", "reportHash": "621949bed8df337d7eb4ea8572e0ed0e", "checkerName": "readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 32, "file": 0, "line": 786}, "message": "expanded from macro 'CURLAUTH_NTLM'"}, {"location": {"col": 39, "file": 31, "line": 581}, "message": "use of a signed integer operand with a binary bitwise operator"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/lib/http.c", "reportHash": "37b0b13bd2eda08ff2e08fe6e9aec9d4", "checkerName": "hicpp-signed-bitwise", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 32, "file": 0, "line": 789}, "message": "expanded from macro 'CURLAUTH_BEARER'"}, {"location": {"col": 41, "file": 31, "line": 593}, "message": "use of a signed integer operand with a binary bitwise operator"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/lib/http.c", "reportHash": "025bd886eceaf5e95407e7968d8d4693", "checkerName": "hicpp-signed-bitwise", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 20, "file": 31, "line": 594}, "message": "{ (fixit)"}, {"location": {"col": 19, "file": 31, "line": 594}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/lib/http.c", "reportHash": "2d2603b771940813c315ab6d6fce79c6", "checkerName": "google-readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 18, "file": 31, "line": 604}, "message": "{ (fixit)"}, {"location": {"col": 17, "file": 31, "line": 604}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/lib/http.c", "reportHash": "216d6e6a99dc4d4332c42d5e4ec3b91c", "checkerName": "hicpp-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 27, "file": 31, "line": 612}, "message": "{ (fixit)"}, {"location": {"col": 26, "file": 31, "line": 612}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/lib/http.c", "reportHash": "789ad9879e8f908e31632a7d0cc51bb2", "checkerName": "google-readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 29, "file": 31, "line": 625}, "message": "{ (fixit)"}, {"location": {"col": 28, "file": 31, "line": 625}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/lib/http.c", "reportHash": "73685bf8efb009a9efbbf508a30227e5", "checkerName": "google-readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 32, "file": 0, "line": 786}, "message": "expanded from macro 'CURLAUTH_NTLM'"}, {"location": {"col": 28, "file": 31, "line": 670}, "message": "use of a signed integer operand with a binary bitwise operator"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/lib/http.c", "reportHash": "cbde4a2b1141c1318ce2957f57f07ff9", "checkerName": "hicpp-signed-bitwise", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 16, "file": 31, "line": 673}, "message": "{ (fixit)"}, {"location": {"col": 15, "file": 31, "line": 673}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/lib/http.c", "reportHash": "7b9df5b135c0570f2596abd66d0a6ee5", "checkerName": "hicpp-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 32, "file": 0, "line": 788}, "message": "expanded from macro 'CURLAUTH_NTLM_WB'"}, {"location": {"col": 28, "file": 31, "line": 679}, "message": "use of a signed integer operand with a binary bitwise operator"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/lib/http.c", "reportHash": "6539014164e78d3610c5af04c389062d", "checkerName": "hicpp-signed-bitwise", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 16, "file": 31, "line": 682}, "message": "{ (fixit)"}, {"location": {"col": 15, "file": 31, "line": 682}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/lib/http.c", "reportHash": "4ce630d88e387bbdb14f9e2abd82c2ae", "checkerName": "google-readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 32, "file": 0, "line": 780}, "message": "expanded from macro 'CURLAUTH_DIGEST'"}, {"location": {"col": 28, "file": 31, "line": 688}, "message": "use of a signed integer operand with a binary bitwise operator"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/lib/http.c", "reportHash": "2dbb8c8187c2703c1d7b5b3e676fe84f", "checkerName": "hicpp-signed-bitwise", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 16, "file": 31, "line": 694}, "message": "{ (fixit)"}, {"location": {"col": 15, "file": 31, "line": 694}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/lib/http.c", "reportHash": "9a897382111f15ad7bb9fcd078fcebef", "checkerName": "readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 32, "file": 0, "line": 779}, "message": "expanded from macro 'CURLAUTH_BASIC'"}, {"location": {"col": 28, "file": 31, "line": 699}, "message": "use of a signed integer operand with a binary bitwise operator"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/lib/http.c", "reportHash": "6f0b9e17c4e68c2ae0c60b3511d0b6ed", "checkerName": "hicpp-signed-bitwise", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 18, "file": 31, "line": 710}, "message": "{ (fixit)"}, {"location": {"col": 17, "file": 31, "line": 710}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/lib/http.c", "reportHash": "d4c197603db9dfab817e37f9cd6b2449", "checkerName": "google-readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 3, "file": 31, "line": 670}, "message": "did you mean this line to be inside this 'if'"}, {"location": {"col": 3, "file": 31, "line": 718}, "message": "misleading indentation: statement is indented too deeply"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/lib/http.c", "reportHash": "1732746689b0a79c29df3eff4694d77c", "checkerName": "readability-misleading-indentation", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 32, "file": 0, "line": 789}, "message": "expanded from macro 'CURLAUTH_BEARER'"}, {"location": {"col": 28, "file": 31, "line": 718}, "message": "use of a signed integer operand with a binary bitwise operator"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/lib/http.c", "reportHash": "83c08bc88f8c73eda7ef98a7ba7fff8f", "checkerName": "hicpp-signed-bitwise", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 18, "file": 31, "line": 724}, "message": "{ (fixit)"}, {"location": {"col": 17, "file": 31, "line": 724}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/lib/http.c", "reportHash": "b68cb921db5434ae19d1ec0bd3ce670d", "checkerName": "readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 8, "file": 31, "line": 745}, "message": "{ (fixit)"}, {"location": {"col": 7, "file": 31, "line": 745}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/lib/http.c", "reportHash": "23a26c1e4bbe8f3e8a81e86cbfd7669b", "checkerName": "google-readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 62, "file": 31, "line": 786}, "message": "{ (fixit)"}, {"location": {"col": 61, "file": 31, "line": 786}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/lib/http.c", "reportHash": "a0d6b56652357f5162949f34bf4d39f4", "checkerName": "readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 43, "file": 31, "line": 794}, "message": "{ (fixit)"}, {"location": {"col": 42, "file": 31, "line": 794}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/lib/http.c", "reportHash": "07e8b7855b1bfc2e21dc175261b46125", "checkerName": "google-readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 45, "file": 31, "line": 800}, "message": "{ (fixit)"}, {"location": {"col": 44, "file": 31, "line": 800}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/lib/http.c", "reportHash": "68e8a8a3c853d95f1a6eb73ff3ec32bd", "checkerName": "google-readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 16, "file": 31, "line": 811}, "message": "{ (fixit)"}, {"location": {"col": 15, "file": 31, "line": 811}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/lib/http.c", "reportHash": "4ce630d88e387bbdb14f9e2abd82c2ae", "checkerName": "google-readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 8, "file": 31, "line": 814}, "message": "{ (fixit)"}, {"location": {"col": 7, "file": 31, "line": 814}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/lib/http.c", "reportHash": "43e4ac44f153d7765c3205265d303a80", "checkerName": "readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 8, "file": 31, "line": 831}, "message": "{ (fixit)"}, {"location": {"col": 7, "file": 31, "line": 831}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/lib/http.c", "reportHash": "23a26c1e4bbe8f3e8a81e86cbfd7669b", "checkerName": "google-readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 32, "file": 0, "line": 786}, "message": "expanded from macro 'CURLAUTH_NTLM'"}, {"location": {"col": 28, "file": 31, "line": 928}, "message": "use of a signed integer operand with a binary bitwise operator"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/lib/http.c", "reportHash": "be4f4cb192d0386d195ade3f0bd23ed7", "checkerName": "hicpp-signed-bitwise", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 32, "file": 0, "line": 788}, "message": "expanded from macro 'CURLAUTH_NTLM_WB'"}, {"location": {"col": 28, "file": 31, "line": 929}, "message": "use of a signed integer operand with a binary bitwise operator"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/lib/http.c", "reportHash": "ef75892f34cfd41ab729345d1a598ff4", "checkerName": "hicpp-signed-bitwise", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 32, "file": 0, "line": 786}, "message": "expanded from macro 'CURLAUTH_NTLM'"}, {"location": {"col": 22, "file": 31, "line": 931}, "message": "use of a signed integer operand with a binary bitwise operator"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/lib/http.c", "reportHash": "262fb8d160725828765b2740a63becd7", "checkerName": "hicpp-signed-bitwise", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 32, "file": 0, "line": 786}, "message": "expanded from macro 'CURLAUTH_NTLM'"}, {"location": {"col": 27, "file": 31, "line": 932}, "message": "use of a signed integer operand with a binary bitwise operator"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/lib/http.c", "reportHash": "52c253e662cd50d93931ac146e542623", "checkerName": "hicpp-signed-bitwise", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 32, "file": 0, "line": 786}, "message": "expanded from macro 'CURLAUTH_NTLM'"}, {"location": {"col": 31, "file": 31, "line": 934}, "message": "use of a signed integer operand with a binary bitwise operator"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/lib/http.c", "reportHash": "18baa34ffa86906dac72d37581d7c0e6", "checkerName": "hicpp-signed-bitwise", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 32, "file": 0, "line": 788}, "message": "expanded from macro 'CURLAUTH_NTLM_WB'"}, {"location": {"col": 31, "file": 31, "line": 935}, "message": "use of a signed integer operand with a binary bitwise operator"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/lib/http.c", "reportHash": "b45cfad470c88cb6a0570b3978c463b8", "checkerName": "hicpp-signed-bitwise", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 32, "file": 0, "line": 788}, "message": "expanded from macro 'CURLAUTH_NTLM_WB'"}, {"location": {"col": 35, "file": 31, "line": 941}, "message": "use of a signed integer operand with a binary bitwise operator"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/lib/http.c", "reportHash": "9df62bc70d928c250fee837a84678e3a", "checkerName": "hicpp-signed-bitwise", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 32, "file": 0, "line": 786}, "message": "expanded from macro 'CURLAUTH_NTLM'"}, {"location": {"col": 29, "file": 31, "line": 942}, "message": "use of a signed integer operand with a binary bitwise operator"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/lib/http.c", "reportHash": "d83cf1f4a4b4d7c51c01fcf5cfcf3218", "checkerName": "hicpp-signed-bitwise", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 32, "file": 0, "line": 786}, "message": "expanded from macro 'CURLAUTH_NTLM'"}, {"location": {"col": 34, "file": 31, "line": 943}, "message": "use of a signed integer operand with a binary bitwise operator"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/lib/http.c", "reportHash": "a3ae2dcaf66948a5960c1bfbd14304d1", "checkerName": "hicpp-signed-bitwise", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 32, "file": 0, "line": 788}, "message": "expanded from macro 'CURLAUTH_NTLM_WB'"}, {"location": {"col": 28, "file": 31, "line": 944}, "message": "use of a signed integer operand with a binary bitwise operator"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/lib/http.c", "reportHash": "cbdae503a2a972f0867412a0dbe5db7e", "checkerName": "hicpp-signed-bitwise", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 32, "file": 0, "line": 788}, "message": "expanded from macro 'CURLAUTH_NTLM_WB'"}, {"location": {"col": 33, "file": 31, "line": 945}, "message": "use of a signed integer operand with a binary bitwise operator"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/lib/http.c", "reportHash": "2d80d6a589ecc3cf88a083b4c5d2a123", "checkerName": "hicpp-signed-bitwise", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 32, "file": 0, "line": 780}, "message": "expanded from macro 'CURLAUTH_DIGEST'"}, {"location": {"col": 30, "file": 31, "line": 966}, "message": "use of a signed integer operand with a binary bitwise operator"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/lib/http.c", "reportHash": "e912d58560c15c2c9d676cf89ef4ff51", "checkerName": "hicpp-signed-bitwise", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 53, "file": 31, "line": 966}, "message": "{ (fixit)"}, {"location": {"col": 52, "file": 31, "line": 966}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/lib/http.c", "reportHash": "a6e77699ff4757f50d51f60d0db25a71", "checkerName": "google-readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 32, "file": 0, "line": 780}, "message": "expanded from macro 'CURLAUTH_DIGEST'"}, {"location": {"col": 24, "file": 31, "line": 971}, "message": "use of a signed integer operand with a binary bitwise operator"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/lib/http.c", "reportHash": "172a74affe496536a57258d397b2b5fa", "checkerName": "hicpp-signed-bitwise", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 32, "file": 0, "line": 780}, "message": "expanded from macro 'CURLAUTH_DIGEST'"}, {"location": {"col": 29, "file": 31, "line": 972}, "message": "use of a signed integer operand with a binary bitwise operator"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/lib/http.c", "reportHash": "57b761da8c906a4ce6cabffc216870cf", "checkerName": "hicpp-signed-bitwise", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 32, "file": 0, "line": 779}, "message": "expanded from macro 'CURLAUTH_BASIC'"}, {"location": {"col": 24, "file": 31, "line": 988}, "message": "use of a signed integer operand with a binary bitwise operator"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/lib/http.c", "reportHash": "ea1e2155f2d935c4c3e4cc5f8dcb05fc", "checkerName": "hicpp-signed-bitwise", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 32, "file": 0, "line": 779}, "message": "expanded from macro 'CURLAUTH_BASIC'"}, {"location": {"col": 29, "file": 31, "line": 989}, "message": "use of a signed integer operand with a binary bitwise operator"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/lib/http.c", "reportHash": "89b334b0fe73e30003ae73348656501c", "checkerName": "hicpp-signed-bitwise", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 32, "file": 0, "line": 779}, "message": "expanded from macro 'CURLAUTH_BASIC'"}, {"location": {"col": 33, "file": 31, "line": 990}, "message": "use of a signed integer operand with a binary bitwise operator"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/lib/http.c", "reportHash": "18a64c94007ff65de7466dd039ae6046", "checkerName": "hicpp-signed-bitwise", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 32, "file": 0, "line": 789}, "message": "expanded from macro 'CURLAUTH_BEARER'"}, {"location": {"col": 26, "file": 31, "line": 1001}, "message": "use of a signed integer operand with a binary bitwise operator"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/lib/http.c", "reportHash": "cbe99ba094de444458d2dd7dc7c8f994", "checkerName": "hicpp-signed-bitwise", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 32, "file": 0, "line": 789}, "message": "expanded from macro 'CURLAUTH_BEARER'"}, {"location": {"col": 31, "file": 31, "line": 1002}, "message": "use of a signed integer operand with a binary bitwise operator"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/lib/http.c", "reportHash": "e0e308d4ccfb3eff5f65b030edb730c7", "checkerName": "hicpp-signed-bitwise", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 32, "file": 0, "line": 789}, "message": "expanded from macro 'CURLAUTH_BEARER'"}, {"location": {"col": 35, "file": 31, "line": 1003}, "message": "use of a signed integer operand with a binary bitwise operator"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/lib/http.c", "reportHash": "a50299c3fe09dffcad58e46c007d0c8f", "checkerName": "hicpp-signed-bitwise", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 34, "file": 31, "line": 1013}, "message": "{ (fixit)"}, {"location": {"col": 33, "file": 31, "line": 1013}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/lib/http.c", "reportHash": "500fcddbdc70f4fd051af22e47a8f449", "checkerName": "readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 22, "file": 31, "line": 1015}, "message": "{ (fixit)"}, {"location": {"col": 21, "file": 31, "line": 1015}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/lib/http.c", "reportHash": "d3ffcebfa42cc6e60bea60a7a74842fa", "checkerName": "google-readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 36, "file": 31, "line": 1017}, "message": "{ (fixit)"}, {"location": {"col": 35, "file": 31, "line": 1017}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/lib/http.c", "reportHash": "25fab911fab2c046d6c4a110f02bbb82", "checkerName": "google-readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 37, "file": 31, "line": 1049}, "message": "{ (fixit)"}, {"location": {"col": 36, "file": 31, "line": 1049}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/lib/http.c", "reportHash": "b3559757546268b52727a35dbd803490", "checkerName": "google-readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 22, "file": 31, "line": 1055}, "message": "{ (fixit)"}, {"location": {"col": 21, "file": 31, "line": 1055}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/lib/http.c", "reportHash": "4d92d575f49b88e23f3ecbedd196e85d", "checkerName": "readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 46, "file": 31, "line": 1062}, "message": "{ (fixit)"}, {"location": {"col": 45, "file": 31, "line": 1062}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/lib/http.c", "reportHash": "05ee2122d6157cde3f9a20b0f2852ef3", "checkerName": "readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 52, "file": 31, "line": 1088}, "message": "{ (fixit)"}, {"location": {"col": 51, "file": 31, "line": 1088}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/lib/http.c", "reportHash": "f75248f12c9a67c1bf5b1206ce78d2e0", "checkerName": "readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 58, "file": 31, "line": 1091}, "message": "{ (fixit)"}, {"location": {"col": 57, "file": 31, "line": 1091}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/lib/http.c", "reportHash": "1538dcaf763f3a618f0b6b37652f2cfe", "checkerName": "readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 23, "file": 31, "line": 1115}, "message": "{ (fixit)"}, {"location": {"col": 22, "file": 31, "line": 1115}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/lib/http.c", "reportHash": "83e30317937a12daa4b2202b91f89cb1", "checkerName": "readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 10, "file": 31, "line": 1137}, "message": "{ (fixit)"}, {"location": {"col": 9, "file": 31, "line": 1137}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/lib/http.c", "reportHash": "221d6fa7db4498193dd479febf8dbf09", "checkerName": "readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 7, "file": 31, "line": 1198}, "message": "use of a signed integer operand with a binary bitwise operator"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/lib/http.c", "reportHash": "2d3f58b0ba3c73fad5fe1cc9250789f8", "checkerName": "hicpp-signed-bitwise", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 22, "file": 32, "line": 748}, "message": "expanded from macro 'PROTOPT_SSL'"}, {"location": {"col": 30, "file": 31, "line": 1198}, "message": "use of a signed integer operand with a binary bitwise operator"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/lib/http.c", "reportHash": "674b56549ddcee381393cc5027c1de4e", "checkerName": "hicpp-signed-bitwise", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 34, "file": 31, "line": 1307}, "message": "{ (fixit)"}, {"location": {"col": 33, "file": 31, "line": 1307}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/lib/http.c", "reportHash": "bd1e698405c5550fcdc755b8c8f0b3de", "checkerName": "google-readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 50, "file": 31, "line": 1350}, "message": "{ (fixit)"}, {"location": {"col": 49, "file": 31, "line": 1350}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/lib/http.c", "reportHash": "e788d51015b90d5c8c6f73dd50b72e3d", "checkerName": "google-readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 36, "file": 31, "line": 1357}, "message": "{ (fixit)"}, {"location": {"col": 35, "file": 31, "line": 1357}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/lib/http.c", "reportHash": "5837cf0fe9a517e33e2107394f4b760b", "checkerName": "readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 14, "file": 31, "line": 1366}, "message": "{ (fixit)"}, {"location": {"col": 13, "file": 31, "line": 1366}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/lib/http.c", "reportHash": "e0b62411cd6188128872418de461ef59", "checkerName": "hicpp-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 47, "file": 31, "line": 1376}, "message": "{ (fixit)"}, {"location": {"col": 46, "file": 31, "line": 1376}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/lib/http.c", "reportHash": "0e2cc56beffe7357109eb57d1c428e5a", "checkerName": "google-readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 14, "file": 31, "line": 1398}, "message": "{ (fixit)"}, {"location": {"col": 13, "file": 31, "line": 1398}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/lib/http.c", "reportHash": "855be70eef8aa771ecbb320297c3d4ba", "checkerName": "google-readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 39, "file": 31, "line": 1401}, "message": "{ (fixit)"}, {"location": {"col": 38, "file": 31, "line": 1401}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/lib/http.c", "reportHash": "ab98d38eb5b6eed2f9d34df09e4a591a", "checkerName": "readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 39, "file": 31, "line": 1405}, "message": "{ (fixit)"}, {"location": {"col": 38, "file": 31, "line": 1405}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/lib/http.c", "reportHash": "dc596e9ddfb1b36f7b4ef7fc9453a735", "checkerName": "google-readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 34, "file": 31, "line": 1408}, "message": "{ (fixit)"}, {"location": {"col": 33, "file": 31, "line": 1408}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/lib/http.c", "reportHash": "f849c2fb61cb42c35f1a644eb96244f0", "checkerName": "google-readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 16, "file": 31, "line": 1415}, "message": "{ (fixit)"}, {"location": {"col": 15, "file": 31, "line": 1415}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/lib/http.c", "reportHash": "9a897382111f15ad7bb9fcd078fcebef", "checkerName": "readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 6, "file": 31, "line": 1420}, "message": "use of a signed integer operand with a binary bitwise operator"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/lib/http.c", "reportHash": "64a86a9e3942eca0d99f584143730141", "checkerName": "hicpp-signed-bitwise", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 27, "file": 0, "line": 961}, "message": "expanded from macro 'CURLPROTO_HTTPS'"}, {"location": {"col": 30, "file": 31, "line": 1420}, "message": "use of a signed integer operand with a binary bitwise operator"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/lib/http.c", "reportHash": "91b26f001f0ecfae1d900f6625eb15e7", "checkerName": "hicpp-signed-bitwise", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 16, "file": 31, "line": 1423}, "message": "{ (fixit)"}, {"location": {"col": 15, "file": 31, "line": 1423}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/lib/http.c", "reportHash": "4ce630d88e387bbdb14f9e2abd82c2ae", "checkerName": "google-readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 8, "file": 31, "line": 1426}, "message": "{ (fixit)"}, {"location": {"col": 7, "file": 31, "line": 1426}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/lib/http.c", "reportHash": "23a26c1e4bbe8f3e8a81e86cbfd7669b", "checkerName": "google-readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 31, "file": 34, "line": 52}, "message": "expanded from macro 'GETSOCK_WRITESOCK'"}, {"location": {"col": 10, "file": 31, "line": 1440}, "message": "use of a signed integer operand with a binary bitwise operator"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/lib/http.c", "reportHash": "442fa58189db2880f1cd20dabc275f27", "checkerName": "hicpp-signed-bitwise", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 14, "file": 31, "line": 1471}, "message": "{ (fixit)"}, {"location": {"col": 13, "file": 31, "line": 1471}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/lib/http.c", "reportHash": "7351e87c0592a1e3f5b3de3e5d96da50", "checkerName": "hicpp-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 14, "file": 31, "line": 1496}, "message": "{ (fixit)"}, {"location": {"col": 13, "file": 31, "line": 1496}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/lib/http.c", "reportHash": "855be70eef8aa771ecbb320297c3d4ba", "checkerName": "google-readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 6, "file": 31, "line": 1505}, "message": "use of a signed integer operand with a binary bitwise operator"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/lib/http.c", "reportHash": "66c292af9785d0f49415009a5d3065c5", "checkerName": "hicpp-signed-bitwise", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 22, "file": 32, "line": 748}, "message": "expanded from macro 'PROTOPT_SSL'"}, {"location": {"col": 29, "file": 31, "line": 1505}, "message": "use of a signed integer operand with a binary bitwise operator"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/lib/http.c", "reportHash": "996a2fac62d27f98a3f34fa633e061a9", "checkerName": "hicpp-signed-bitwise", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 42, "file": 31, "line": 1505}, "message": "{ (fixit)"}, {"location": {"col": 41, "file": 31, "line": 1505}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/lib/http.c", "reportHash": "aeaea6ad8e01f021914602c21c2c5363", "checkerName": "hicpp-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 13, "file": 31, "line": 1533}, "message": "{ (fixit)"}, {"location": {"col": 12, "file": 31, "line": 1533}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/lib/http.c", "reportHash": "0720c9da102687fdb778f8f89c60203e", "checkerName": "readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 14, "file": 31, "line": 1542}, "message": "{ (fixit)"}, {"location": {"col": 13, "file": 31, "line": 1542}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/lib/http.c", "reportHash": "87908dbbdf6a6aa2c0d9668b4884b8b7", "checkerName": "google-readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 68, "file": 31, "line": 1574}, "message": "{ (fixit)"}, {"location": {"col": 67, "file": 31, "line": 1574}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/lib/http.c", "reportHash": "8f181c1b0860da8b35223fd7ba2b05bf", "checkerName": "google-readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 33, "file": 31, "line": 1577}, "message": "{ (fixit)"}, {"location": {"col": 32, "file": 31, "line": 1577}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/lib/http.c", "reportHash": "42c9adb69bfcb60ca3ffa99d3f087b6d", "checkerName": "google-readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 36, "file": 31, "line": 1597}, "message": "{ (fixit)"}, {"location": {"col": 35, "file": 31, "line": 1597}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/lib/http.c", "reportHash": "348bb6a839851e2ae3ffa13f630f1ede", "checkerName": "hicpp-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 19, "file": 31, "line": 1623}, "message": "{ (fixit)"}, {"location": {"col": 18, "file": 31, "line": 1623}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/lib/http.c", "reportHash": "2bd4774b506ad707c5e65dcb50d5fc24", "checkerName": "readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 18, "file": 31, "line": 1668}, "message": "{ (fixit)"}, {"location": {"col": 17, "file": 31, "line": 1668}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/lib/http.c", "reportHash": "b68cb921db5434ae19d1ec0bd3ce670d", "checkerName": "readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 18, "file": 31, "line": 1671}, "message": "{ (fixit)"}, {"location": {"col": 17, "file": 31, "line": 1671}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/lib/http.c", "reportHash": "b68cb921db5434ae19d1ec0bd3ce670d", "checkerName": "readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 10, "file": 31, "line": 1674}, "message": "{ (fixit)"}, {"location": {"col": 9, "file": 31, "line": 1674}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/lib/http.c", "reportHash": "221d6fa7db4498193dd479febf8dbf09", "checkerName": "readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 18, "file": 31, "line": 1696}, "message": "{ (fixit)"}, {"location": {"col": 17, "file": 31, "line": 1696}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/lib/http.c", "reportHash": "7acbb27e9955f09ad273104addcb0868", "checkerName": "google-readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 8, "file": 31, "line": 1698}, "message": "{ (fixit)"}, {"location": {"col": 7, "file": 31, "line": 1698}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/lib/http.c", "reportHash": "43e4ac44f153d7765c3205265d303a80", "checkerName": "readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 31, "file": 31, "line": 1714}, "message": "{ (fixit)"}, {"location": {"col": 30, "file": 31, "line": 1714}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/lib/http.c", "reportHash": "3ec6728713843786816319955819484d", "checkerName": "readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 10, "file": 31, "line": 1716}, "message": "{ (fixit)"}, {"location": {"col": 9, "file": 31, "line": 1716}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/lib/http.c", "reportHash": "221d6fa7db4498193dd479febf8dbf09", "checkerName": "readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 40, "file": 31, "line": 1739}, "message": "{ (fixit)"}, {"location": {"col": 39, "file": 31, "line": 1739}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/lib/http.c", "reportHash": "a8e03b36a873c5e844a98f5cc79c2023", "checkerName": "google-readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 38, "file": 31, "line": 1767}, "message": "{ (fixit)"}, {"location": {"col": 37, "file": 31, "line": 1767}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/lib/http.c", "reportHash": "b13b85ecd143db858cac5a7a6147a1cc", "checkerName": "google-readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 45, "file": 31, "line": 1778}, "message": "{ (fixit)"}, {"location": {"col": 44, "file": 31, "line": 1778}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/lib/http.c", "reportHash": "af1443818187f4b866b5a00cc4534fbb", "checkerName": "google-readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 58, "file": 31, "line": 1782}, "message": "{ (fixit)"}, {"location": {"col": 57, "file": 31, "line": 1782}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/lib/http.c", "reportHash": "ea7a4d699da9b4f7aad6243170302078", "checkerName": "google-readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 58, "file": 31, "line": 1786}, "message": "{ (fixit)"}, {"location": {"col": 57, "file": 31, "line": 1786}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/lib/http.c", "reportHash": "f6d9d9012232367c355d9fde0ac5fd86", "checkerName": "readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 60, "file": 31, "line": 1791}, "message": "{ (fixit)"}, {"location": {"col": 59, "file": 31, "line": 1791}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/lib/http.c", "reportHash": "2ab45e732375b8e1c946008d754dc839", "checkerName": "readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 56, "file": 31, "line": 1796}, "message": "{ (fixit)"}, {"location": {"col": 55, "file": 31, "line": 1796}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/lib/http.c", "reportHash": "eb908ad856a547b20fb1b55b2f903f56", "checkerName": "readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 63, "file": 31, "line": 1799}, "message": "{ (fixit)"}, {"location": {"col": 62, "file": 31, "line": 1799}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/lib/http.c", "reportHash": "9ed4618b12deb8b9ddac57f1227a2e13", "checkerName": "readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 79, "file": 31, "line": 1809}, "message": "{ (fixit)"}, {"location": {"col": 78, "file": 31, "line": 1809}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/lib/http.c", "reportHash": "f36233e81543ca52170288ecc1a1256c", "checkerName": "readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 26, "file": 31, "line": 1814}, "message": "{ (fixit)"}, {"location": {"col": 25, "file": 31, "line": 1814}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/lib/http.c", "reportHash": "96fc4e0e2f6b87b55d8cd7c80abb9527", "checkerName": "readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 22, "file": 31, "line": 1816}, "message": "{ (fixit)"}, {"location": {"col": 21, "file": 31, "line": 1816}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/lib/http.c", "reportHash": "a7944f8a3a0e68eb252bdbce4200998c", "checkerName": "readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 53, "file": 31, "line": 1838}, "message": "{ (fixit)"}, {"location": {"col": 52, "file": 31, "line": 1838}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/lib/http.c", "reportHash": "cce11395024cfe6bb7c74f4cd1c637d7", "checkerName": "google-readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 20, "file": 31, "line": 1944}, "message": "{ (fixit)"}, {"location": {"col": 19, "file": 31, "line": 1944}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/lib/http.c", "reportHash": "479e785cd5d8b96770d4427992a019bd", "checkerName": "google-readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 18, "file": 31, "line": 1977}, "message": "{ (fixit)"}, {"location": {"col": 17, "file": 31, "line": 1977}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/lib/http.c", "reportHash": "216d6e6a99dc4d4332c42d5e4ec3b91c", "checkerName": "hicpp-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 33, "file": 31, "line": 1989}, "message": "{ (fixit)"}, {"location": {"col": 32, "file": 31, "line": 1989}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/lib/http.c", "reportHash": "d15946ff3a5b1f1532804efa72cd8fac", "checkerName": "google-readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 7, "file": 31, "line": 1995}, "message": "use of a signed integer operand with a binary bitwise operator"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/lib/http.c", "reportHash": "46faea6a623228de394f4b5d05cedf69", "checkerName": "hicpp-signed-bitwise", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 28, "file": 32, "line": 67}, "message": "expanded from macro 'PROTO_FAMILY_HTTP'"}, {"location": {"col": 27, "file": 0, "line": 960}, "message": "expanded from macro 'CURLPROTO_HTTP'"}, {"location": {"col": 32, "file": 31, "line": 1995}, "message": "use of a signed integer operand with a binary bitwise operator"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/lib/http.c", "reportHash": "cb33d0ea004f94800bed70edeaa1fd63", "checkerName": "hicpp-signed-bitwise", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 27, "file": 0, "line": 962}, "message": "expanded from macro 'CURLPROTO_FTP'"}, {"location": {"col": 50, "file": 31, "line": 1995}, "message": "use of a signed integer operand with a binary bitwise operator"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/lib/http.c", "reportHash": "686bf50cccd19a97b39e984409195492", "checkerName": "hicpp-signed-bitwise", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 43, "file": 31, "line": 2001}, "message": "{ (fixit)"}, {"location": {"col": 42, "file": 31, "line": 2001}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/lib/http.c", "reportHash": "755b1422d8a0b3a5daf4967117e4b13c", "checkerName": "hicpp-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 31, "file": 31, "line": 2004}, "message": "{ (fixit)"}, {"location": {"col": 30, "file": 31, "line": 2004}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/lib/http.c", "reportHash": "4522672f8fafd81928defa75dd327d23", "checkerName": "google-readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 15, "file": 31, "line": 2042}, "message": "{ (fixit)"}, {"location": {"col": 14, "file": 31, "line": 2042}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/lib/http.c", "reportHash": "0a3c578205531470c45f6d7f459b7361", "checkerName": "google-readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 16, "file": 31, "line": 2047}, "message": "{ (fixit)"}, {"location": {"col": 15, "file": 31, "line": 2047}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/lib/http.c", "reportHash": "4ce630d88e387bbdb14f9e2abd82c2ae", "checkerName": "google-readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 8, "file": 31, "line": 2059}, "message": "{ (fixit)"}, {"location": {"col": 7, "file": 31, "line": 2059}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/lib/http.c", "reportHash": "23a26c1e4bbe8f3e8a81e86cbfd7669b", "checkerName": "google-readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 31, "file": 31, "line": 2065}, "message": "{ (fixit)"}, {"location": {"col": 30, "file": 31, "line": 2065}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/lib/http.c", "reportHash": "33daa5f50d8cee0ac517ed44f61a5a09", "checkerName": "hicpp-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 8, "file": 31, "line": 2068}, "message": "{ (fixit)"}, {"location": {"col": 7, "file": 31, "line": 2068}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/lib/http.c", "reportHash": "23a26c1e4bbe8f3e8a81e86cbfd7669b", "checkerName": "google-readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 74, "file": 31, "line": 2072}, "message": "{ (fixit)"}, {"location": {"col": 73, "file": 31, "line": 2072}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/lib/http.c", "reportHash": "a393634c1b1f6bcdc969c5c0b42f86b4", "checkerName": "google-readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 43, "file": 31, "line": 2081}, "message": "{ (fixit)"}, {"location": {"col": 42, "file": 31, "line": 2081}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/lib/http.c", "reportHash": "f6d739f7fa636160602441f95308c86e", "checkerName": "readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 17, "file": 31, "line": 2106}, "message": "{ (fixit)"}, {"location": {"col": 16, "file": 31, "line": 2106}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/lib/http.c", "reportHash": "7856eb8fe7e184d1fa8757dc2ce69877", "checkerName": "readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 30, "file": 31, "line": 2115}, "message": "{ (fixit)"}, {"location": {"col": 29, "file": 31, "line": 2115}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/lib/http.c", "reportHash": "e1b54f570a47565fa8f4a8992ab64268", "checkerName": "readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 16, "file": 31, "line": 2129}, "message": "{ (fixit)"}, {"location": {"col": 15, "file": 31, "line": 2129}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/lib/http.c", "reportHash": "4ce630d88e387bbdb14f9e2abd82c2ae", "checkerName": "google-readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 34, "file": 35, "line": 33}, "message": "expanded from macro 'MIME_BODY_ONLY'"}, {"location": {"col": 28, "file": 31, "line": 2142}, "message": "use of a signed integer operand with a binary bitwise operator"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/lib/http.c", "reportHash": "cb49e54b9c484d7f8da524ffdf289d0c", "checkerName": "hicpp-signed-bitwise", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 15, "file": 31, "line": 2146}, "message": "{ (fixit)"}, {"location": {"col": 14, "file": 31, "line": 2146}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/lib/http.c", "reportHash": "3eaab31607f407c256d61380e6a7ca17", "checkerName": "google-readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 48, "file": 31, "line": 2147}, "message": "{ (fixit)"}, {"location": {"col": 47, "file": 31, "line": 2147}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/lib/http.c", "reportHash": "d2ae7952f7ec6df6a364cf9fb3cf54b9", "checkerName": "google-readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 55, "file": 31, "line": 2149}, "message": "{ (fixit)"}, {"location": {"col": 54, "file": 31, "line": 2149}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/lib/http.c", "reportHash": "f9ea935311371f849055116d1303dd5e", "checkerName": "google-readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 17, "file": 31, "line": 2156}, "message": "{ (fixit)"}, {"location": {"col": 16, "file": 31, "line": 2156}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/lib/http.c", "reportHash": "5cc816e7d235c60e49a07491e285694e", "checkerName": "google-readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 16, "file": 31, "line": 2158}, "message": "{ (fixit)"}, {"location": {"col": 15, "file": 31, "line": 2158}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/lib/http.c", "reportHash": "4ce630d88e387bbdb14f9e2abd82c2ae", "checkerName": "google-readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 9, "file": 31, "line": 2171}, "message": "use of a signed integer operand with a binary bitwise operator"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/lib/http.c", "reportHash": "45f207db1f70db0bd85005c17633fb46", "checkerName": "hicpp-signed-bitwise", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 43, "file": 32, "line": 67}, "message": "expanded from macro 'PROTO_FAMILY_HTTP'"}, {"location": {"col": 27, "file": 0, "line": 961}, "message": "expanded from macro 'CURLPROTO_HTTPS'"}, {"location": {"col": 35, "file": 31, "line": 2171}, "message": "use of a signed integer operand with a binary bitwise operator"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/lib/http.c", "reportHash": "dc88b94220e668ca5e37c4b0b973975e", "checkerName": "hicpp-signed-bitwise", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 30, "file": 31, "line": 2176}, "message": "{ (fixit)"}, {"location": {"col": 29, "file": 31, "line": 2176}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/lib/http.c", "reportHash": "111f310bd5019e773a4d825278382fe9", "checkerName": "google-readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 36, "file": 31, "line": 2180}, "message": "{ (fixit)"}, {"location": {"col": 35, "file": 31, "line": 2180}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/lib/http.c", "reportHash": "8e524c5c955827f7dc59f47da18e2a21", "checkerName": "google-readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 33, "file": 31, "line": 2194}, "message": "{ (fixit)"}, {"location": {"col": 32, "file": 31, "line": 2194}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/lib/http.c", "reportHash": "b7fc54f51b3875b852ba6a9191c7b969", "checkerName": "readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 21, "file": 31, "line": 2210}, "message": "{ (fixit)"}, {"location": {"col": 20, "file": 31, "line": 2210}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/lib/http.c", "reportHash": "050a19c3b7a8a92a997d8ba9f89f7537", "checkerName": "hicpp-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 22, "file": 31, "line": 2212}, "message": "{ (fixit)"}, {"location": {"col": 21, "file": 31, "line": 2212}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/lib/http.c", "reportHash": "fbedef37285d1bfaa1988a1966bf9e1d", "checkerName": "google-readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 28, "file": 31, "line": 2224}, "message": "{ (fixit)"}, {"location": {"col": 27, "file": 31, "line": 2224}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/lib/http.c", "reportHash": "c8056eaf155834aa202e794cc1fbc030", "checkerName": "google-readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 19, "file": 31, "line": 2230}, "message": "{ (fixit)"}, {"location": {"col": 18, "file": 31, "line": 2230}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/lib/http.c", "reportHash": "9ae7cfbe7c522c3740b62974a0840f4c", "checkerName": "google-readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 29, "file": 31, "line": 2238}, "message": "!= 0 (fixit)"}, {"location": {"col": 8, "file": 31, "line": 2238}, "message": "function 'strcmp' is called without explicitly comparing result"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/lib/http.c", "reportHash": "65ea199faa5dc56c59b016ef6adb997d", "checkerName": "misc-suspicious-string-compare", "reviewStatus": null, "severity": "MEDIUM"}, {"events": [{"location": {"col": 34, "file": 31, "line": 2240}, "message": "{ (fixit)"}, {"location": {"col": 33, "file": 31, "line": 2240}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/lib/http.c", "reportHash": "afb0eb533e4d3b6ca61baa0e08f17f6d", "checkerName": "readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 10, "file": 31, "line": 2243}, "message": "{ (fixit)"}, {"location": {"col": 9, "file": 31, "line": 2243}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/lib/http.c", "reportHash": "1f09764cc0ba7bb1a42cea5b52ce41bd", "checkerName": "google-readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 10, "file": 31, "line": 2251}, "message": "use of a signed integer operand with a binary bitwise operator"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/lib/http.c", "reportHash": "a110e70d425dfee0fee85d82158c002d", "checkerName": "hicpp-signed-bitwise", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 27, "file": 0, "line": 961}, "message": "expanded from macro 'CURLPROTO_HTTPS'"}, {"location": {"col": 32, "file": 31, "line": 2251}, "message": "use of a signed integer operand with a binary bitwise operator"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/lib/http.c", "reportHash": "69ba9de1e2b2edb69ab21876f2873190", "checkerName": "hicpp-signed-bitwise", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 10, "file": 31, "line": 2253}, "message": "use of a signed integer operand with a binary bitwise operator"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/lib/http.c", "reportHash": "35a959b6e08ffedd4f452eb9c5d70f86", "checkerName": "hicpp-signed-bitwise", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 27, "file": 0, "line": 960}, "message": "expanded from macro 'CURLPROTO_HTTP'"}, {"location": {"col": 32, "file": 31, "line": 2253}, "message": "use of a signed integer operand with a binary bitwise operator"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/lib/http.c", "reportHash": "b72c372eb7d6fbc055da040876e3e65e", "checkerName": "hicpp-signed-bitwise", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 45, "file": 31, "line": 2254}, "message": "{ (fixit)"}, {"location": {"col": 44, "file": 31, "line": 2254}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/lib/http.c", "reportHash": "0f033bc7e29ad1ab9e35acf62a7ebc50", "checkerName": "google-readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 10, "file": 31, "line": 2261}, "message": "{ (fixit)"}, {"location": {"col": 9, "file": 31, "line": 2261}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/lib/http.c", "reportHash": "1f09764cc0ba7bb1a42cea5b52ce41bd", "checkerName": "google-readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 32, "file": 31, "line": 2268}, "message": "{ (fixit)"}, {"location": {"col": 31, "file": 31, "line": 2268}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/lib/http.c", "reportHash": "a4c52ea6c33b67886fa77ebf6106ec94", "checkerName": "google-readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 12, "file": 31, "line": 2284}, "message": "{ (fixit)"}, {"location": {"col": 11, "file": 31, "line": 2284}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/lib/http.c", "reportHash": "a52d36c833e4f6c1828bf1f5865d2455", "checkerName": "google-readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 34, "file": 31, "line": 2349}, "message": "{ (fixit)"}, {"location": {"col": 33, "file": 31, "line": 2349}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/lib/http.c", "reportHash": "963b0fe5ec803c98924317c01c9fbb4c", "checkerName": "readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 39, "file": 31, "line": 2476}, "message": "{ (fixit)"}, {"location": {"col": 38, "file": 31, "line": 2476}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/lib/http.c", "reportHash": "28607ce7df85c349c248161bf9944f0c", "checkerName": "google-readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 14, "file": 31, "line": 2489}, "message": "{ (fixit)"}, {"location": {"col": 13, "file": 31, "line": 2489}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/lib/http.c", "reportHash": "855be70eef8aa771ecbb320297c3d4ba", "checkerName": "google-readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 25, "file": 31, "line": 2506}, "message": "{ (fixit)"}, {"location": {"col": 24, "file": 31, "line": 2506}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/lib/http.c", "reportHash": "50caa6061151550f8e43bd94f542a1f7", "checkerName": "readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 16, "file": 31, "line": 2511}, "message": "{ (fixit)"}, {"location": {"col": 15, "file": 31, "line": 2511}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/lib/http.c", "reportHash": "9a897382111f15ad7bb9fcd078fcebef", "checkerName": "readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 15, "file": 31, "line": 2513}, "message": "{ (fixit)"}, {"location": {"col": 14, "file": 31, "line": 2513}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/lib/http.c", "reportHash": "35684cbdc33abf4b61aa96ae2e49a0af", "checkerName": "readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 3, "file": 31, "line": 2499}, "message": "did you mean this line to be inside this 'if'"}, {"location": {"col": 3, "file": 31, "line": 2516}, "message": "misleading indentation: statement is indented too deeply"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/lib/http.c", "reportHash": "d614c5bad7a9a9024e1e3e368c19c5b9", "checkerName": "readability-misleading-indentation", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 14, "file": 31, "line": 2516}, "message": "{ (fixit)"}, {"location": {"col": 13, "file": 31, "line": 2516}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/lib/http.c", "reportHash": "855be70eef8aa771ecbb320297c3d4ba", "checkerName": "google-readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 14, "file": 31, "line": 2584}, "message": "{ (fixit)"}, {"location": {"col": 13, "file": 31, "line": 2584}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/lib/http.c", "reportHash": "855be70eef8aa771ecbb320297c3d4ba", "checkerName": "google-readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 8, "file": 31, "line": 2587}, "message": "use of a signed integer operand with a binary bitwise operator"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/lib/http.c", "reportHash": "423671be77ceb2168e87b1c5c8deda8f", "checkerName": "hicpp-signed-bitwise", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 22, "file": 32, "line": 748}, "message": "expanded from macro 'PROTOPT_SSL'"}, {"location": {"col": 29, "file": 31, "line": 2587}, "message": "use of a signed integer operand with a binary bitwise operator"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/lib/http.c", "reportHash": "aba84f7f17e661bfd574c8533f6fec19", "checkerName": "hicpp-signed-bitwise", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 16, "file": 31, "line": 2593}, "message": "{ (fixit)"}, {"location": {"col": 15, "file": 31, "line": 2593}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/lib/http.c", "reportHash": "4ce630d88e387bbdb14f9e2abd82c2ae", "checkerName": "google-readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 33, "file": 31, "line": 2608}, "message": "use of a signed integer operand with a binary bitwise operator"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/lib/http.c", "reportHash": "a404002706e27019da134478fee4e6aa", "checkerName": "hicpp-signed-bitwise", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 27, "file": 0, "line": 961}, "message": "expanded from macro 'CURLPROTO_HTTPS'"}, {"location": {"col": 57, "file": 31, "line": 2608}, "message": "use of a signed integer operand with a binary bitwise operator"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/lib/http.c", "reportHash": "b4c14b6ebfcd3816899713df25b1398f", "checkerName": "hicpp-signed-bitwise", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 24, "file": 31, "line": 2619}, "message": "{ (fixit)"}, {"location": {"col": 23, "file": 31, "line": 2619}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/lib/http.c", "reportHash": "87ea472d4a872896036dcd3e96b45e2a", "checkerName": "google-readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 22, "file": 31, "line": 2624}, "message": "{ (fixit)"}, {"location": {"col": 21, "file": 31, "line": 2624}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/lib/http.c", "reportHash": "a7944f8a3a0e68eb252bdbce4200998c", "checkerName": "readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 18, "file": 31, "line": 2633}, "message": "{ (fixit)"}, {"location": {"col": 17, "file": 31, "line": 2633}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/lib/http.c", "reportHash": "d10ce01f152d5ff345d05fef190187ce", "checkerName": "google-readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 26, "file": 31, "line": 2640}, "message": "{ (fixit)"}, {"location": {"col": 25, "file": 31, "line": 2640}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/lib/http.c", "reportHash": "a429b4e7562e38da3427743d187fc123", "checkerName": "google-readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 16, "file": 31, "line": 2643}, "message": "{ (fixit)"}, {"location": {"col": 15, "file": 31, "line": 2643}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/lib/http.c", "reportHash": "4ce630d88e387bbdb14f9e2abd82c2ae", "checkerName": "google-readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 14, "file": 31, "line": 2649}, "message": "{ (fixit)"}, {"location": {"col": 13, "file": 31, "line": 2649}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/lib/http.c", "reportHash": "855be70eef8aa771ecbb320297c3d4ba", "checkerName": "google-readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 14, "file": 31, "line": 2653}, "message": "{ (fixit)"}, {"location": {"col": 13, "file": 31, "line": 2653}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/lib/http.c", "reportHash": "7351e87c0592a1e3f5b3de3e5d96da50", "checkerName": "hicpp-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 28, "file": 31, "line": 2667}, "message": "{ (fixit)"}, {"location": {"col": 27, "file": 31, "line": 2667}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/lib/http.c", "reportHash": "6231a2ef185230154e3733cbf581b75a", "checkerName": "google-readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 10, "file": 31, "line": 2669}, "message": "{ (fixit)"}, {"location": {"col": 9, "file": 31, "line": 2669}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/lib/http.c", "reportHash": "1f09764cc0ba7bb1a42cea5b52ce41bd", "checkerName": "google-readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 18, "file": 31, "line": 2677}, "message": "{ (fixit)"}, {"location": {"col": 17, "file": 31, "line": 2677}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/lib/http.c", "reportHash": "d4c197603db9dfab817e37f9cd6b2449", "checkerName": "google-readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 18, "file": 31, "line": 2683}, "message": "{ (fixit)"}, {"location": {"col": 17, "file": 31, "line": 2683}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/lib/http.c", "reportHash": "b68cb921db5434ae19d1ec0bd3ce670d", "checkerName": "readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 16, "file": 31, "line": 2689}, "message": "{ (fixit)"}, {"location": {"col": 15, "file": 31, "line": 2689}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/lib/http.c", "reportHash": "9a897382111f15ad7bb9fcd078fcebef", "checkerName": "readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 16, "file": 31, "line": 2698}, "message": "{ (fixit)"}, {"location": {"col": 15, "file": 31, "line": 2698}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/lib/http.c", "reportHash": "9a897382111f15ad7bb9fcd078fcebef", "checkerName": "readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 10, "file": 31, "line": 2700}, "message": "{ (fixit)"}, {"location": {"col": 9, "file": 31, "line": 2700}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/lib/http.c", "reportHash": "221d6fa7db4498193dd479febf8dbf09", "checkerName": "readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 16, "file": 31, "line": 2704}, "message": "{ (fixit)"}, {"location": {"col": 15, "file": 31, "line": 2704}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/lib/http.c", "reportHash": "7b9df5b135c0570f2596abd66d0a6ee5", "checkerName": "hicpp-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 18, "file": 31, "line": 2714}, "message": "{ (fixit)"}, {"location": {"col": 17, "file": 31, "line": 2714}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/lib/http.c", "reportHash": "216d6e6a99dc4d4332c42d5e4ec3b91c", "checkerName": "hicpp-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 18, "file": 31, "line": 2719}, "message": "{ (fixit)"}, {"location": {"col": 17, "file": 31, "line": 2719}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/lib/http.c", "reportHash": "b68cb921db5434ae19d1ec0bd3ce670d", "checkerName": "readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 12, "file": 31, "line": 2721}, "message": "{ (fixit)"}, {"location": {"col": 11, "file": 31, "line": 2721}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/lib/http.c", "reportHash": "bc1c9356618c8f588b2cabd831008a1e", "checkerName": "google-readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 18, "file": 31, "line": 2739}, "message": "{ (fixit)"}, {"location": {"col": 17, "file": 31, "line": 2739}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/lib/http.c", "reportHash": "d4c197603db9dfab817e37f9cd6b2449", "checkerName": "google-readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 20, "file": 31, "line": 2750}, "message": "{ (fixit)"}, {"location": {"col": 19, "file": 31, "line": 2750}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/lib/http.c", "reportHash": "479e785cd5d8b96770d4427992a019bd", "checkerName": "google-readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 18, "file": 31, "line": 2767}, "message": "{ (fixit)"}, {"location": {"col": 17, "file": 31, "line": 2767}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/lib/http.c", "reportHash": "b68cb921db5434ae19d1ec0bd3ce670d", "checkerName": "readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 10, "file": 31, "line": 2770}, "message": "{ (fixit)"}, {"location": {"col": 9, "file": 31, "line": 2770}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/lib/http.c", "reportHash": "1f09764cc0ba7bb1a42cea5b52ce41bd", "checkerName": "google-readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 16, "file": 31, "line": 2775}, "message": "{ (fixit)"}, {"location": {"col": 15, "file": 31, "line": 2775}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/lib/http.c", "reportHash": "9a897382111f15ad7bb9fcd078fcebef", "checkerName": "readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 16, "file": 31, "line": 2789}, "message": "{ (fixit)"}, {"location": {"col": 15, "file": 31, "line": 2789}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/lib/http.c", "reportHash": "9a897382111f15ad7bb9fcd078fcebef", "checkerName": "readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 10, "file": 31, "line": 2791}, "message": "{ (fixit)"}, {"location": {"col": 9, "file": 31, "line": 2791}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/lib/http.c", "reportHash": "221d6fa7db4498193dd479febf8dbf09", "checkerName": "readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 16, "file": 31, "line": 2795}, "message": "{ (fixit)"}, {"location": {"col": 15, "file": 31, "line": 2795}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/lib/http.c", "reportHash": "9a897382111f15ad7bb9fcd078fcebef", "checkerName": "readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 28, "file": 31, "line": 2803}, "message": "{ (fixit)"}, {"location": {"col": 27, "file": 31, "line": 2803}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/lib/http.c", "reportHash": "328745b7da65215b61e62af5e6de13d0", "checkerName": "readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 10, "file": 31, "line": 2805}, "message": "{ (fixit)"}, {"location": {"col": 9, "file": 31, "line": 2805}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/lib/http.c", "reportHash": "221d6fa7db4498193dd479febf8dbf09", "checkerName": "readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 18, "file": 31, "line": 2818}, "message": "{ (fixit)"}, {"location": {"col": 17, "file": 31, "line": 2818}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/lib/http.c", "reportHash": "d4c197603db9dfab817e37f9cd6b2449", "checkerName": "google-readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 18, "file": 31, "line": 2825}, "message": "{ (fixit)"}, {"location": {"col": 17, "file": 31, "line": 2825}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/lib/http.c", "reportHash": "d4c197603db9dfab817e37f9cd6b2449", "checkerName": "google-readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 18, "file": 31, "line": 2840}, "message": "{ (fixit)"}, {"location": {"col": 17, "file": 31, "line": 2840}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/lib/http.c", "reportHash": "b68cb921db5434ae19d1ec0bd3ce670d", "checkerName": "readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 10, "file": 31, "line": 2843}, "message": "{ (fixit)"}, {"location": {"col": 9, "file": 31, "line": 2843}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/lib/http.c", "reportHash": "bc06cd07b43f2969100cdacdd7ea93bd", "checkerName": "hicpp-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 20, "file": 31, "line": 2862}, "message": "{ (fixit)"}, {"location": {"col": 19, "file": 31, "line": 2862}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/lib/http.c", "reportHash": "479e785cd5d8b96770d4427992a019bd", "checkerName": "google-readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 27, "file": 31, "line": 2879}, "message": "{ (fixit)"}, {"location": {"col": 26, "file": 31, "line": 2879}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/lib/http.c", "reportHash": "cf5d66b8da9cc3f3c8d26c595da5655c", "checkerName": "hicpp-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 23, "file": 31, "line": 2884}, "message": "{ (fixit)"}, {"location": {"col": 22, "file": 31, "line": 2884}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/lib/http.c", "reportHash": "f514c41707692d5c7022ba8b6968132d", "checkerName": "google-readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 20, "file": 31, "line": 2889}, "message": "{ (fixit)"}, {"location": {"col": 19, "file": 31, "line": 2889}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/lib/http.c", "reportHash": "479e785cd5d8b96770d4427992a019bd", "checkerName": "google-readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 20, "file": 31, "line": 2909}, "message": "{ (fixit)"}, {"location": {"col": 19, "file": 31, "line": 2909}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/lib/http.c", "reportHash": "479e785cd5d8b96770d4427992a019bd", "checkerName": "google-readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 18, "file": 31, "line": 2916}, "message": "{ (fixit)"}, {"location": {"col": 17, "file": 31, "line": 2916}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/lib/http.c", "reportHash": "d4c197603db9dfab817e37f9cd6b2449", "checkerName": "google-readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 20, "file": 31, "line": 2924}, "message": "{ (fixit)"}, {"location": {"col": 19, "file": 31, "line": 2924}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/lib/http.c", "reportHash": "479e785cd5d8b96770d4427992a019bd", "checkerName": "google-readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 16, "file": 31, "line": 2945}, "message": "{ (fixit)"}, {"location": {"col": 15, "file": 31, "line": 2945}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/lib/http.c", "reportHash": "4ce630d88e387bbdb14f9e2abd82c2ae", "checkerName": "google-readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 10, "file": 31, "line": 2947}, "message": "{ (fixit)"}, {"location": {"col": 9, "file": 31, "line": 2947}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/lib/http.c", "reportHash": "221d6fa7db4498193dd479febf8dbf09", "checkerName": "readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 16, "file": 31, "line": 2954}, "message": "{ (fixit)"}, {"location": {"col": 15, "file": 31, "line": 2954}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/lib/http.c", "reportHash": "7b9df5b135c0570f2596abd66d0a6ee5", "checkerName": "hicpp-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 16, "file": 31, "line": 2961}, "message": "{ (fixit)"}, {"location": {"col": 15, "file": 31, "line": 2961}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/lib/http.c", "reportHash": "9a897382111f15ad7bb9fcd078fcebef", "checkerName": "readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 10, "file": 31, "line": 2963}, "message": "{ (fixit)"}, {"location": {"col": 9, "file": 31, "line": 2963}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/lib/http.c", "reportHash": "221d6fa7db4498193dd479febf8dbf09", "checkerName": "readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 14, "file": 31, "line": 2967}, "message": "{ (fixit)"}, {"location": {"col": 13, "file": 31, "line": 2967}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/lib/http.c", "reportHash": "a93ab9f47ee766435f9a6bf318bf87b4", "checkerName": "readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 56, "file": 31, "line": 2969}, "message": "{ (fixit)"}, {"location": {"col": 55, "file": 31, "line": 2969}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/lib/http.c", "reportHash": "8783e96381b8be68c8b345d54953363d", "checkerName": "readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 31, "file": 31, "line": 2976}, "message": "{ (fixit)"}, {"location": {"col": 30, "file": 31, "line": 2976}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/lib/http.c", "reportHash": "42b4cfddbe912390c76a105c7cac0538", "checkerName": "hicpp-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 27, "file": 31, "line": 2986}, "message": "use of a signed integer operand with a unary bitwise operator"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/lib/http.c", "reportHash": "d11312634f37e1fe31987a925f97990a", "checkerName": "hicpp-signed-bitwise", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 20, "file": 32, "line": 509}, "message": "expanded from macro 'KEEP_SEND'"}, {"location": {"col": 28, "file": 31, "line": 2986}, "message": "use of a signed integer operand with a binary bitwise operator"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/lib/http.c", "reportHash": "7cb56da05135954323851f1c7bf61ed4", "checkerName": "hicpp-signed-bitwise", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 60, "file": 31, "line": 2992}, "message": "{ (fixit)"}, {"location": {"col": 59, "file": 31, "line": 2992}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/lib/http.c", "reportHash": "35b785c62aa2a6b2ec9a0f312e45827a", "checkerName": "readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 64, "file": 31, "line": 3049}, "message": "{ (fixit)"}, {"location": {"col": 63, "file": 31, "line": 3049}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/lib/http.c", "reportHash": "26c93af4626891a37bd010892fb6c4e2", "checkerName": "google-readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 39, "file": 31, "line": 3082}, "message": "{ (fixit)"}, {"location": {"col": 38, "file": 31, "line": 3082}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/lib/http.c", "reportHash": "f20793191bc14154a977ef771b53608f", "checkerName": "google-readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 6, "file": 31, "line": 3095}, "message": "use of a signed integer operand with a binary bitwise operator"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/lib/http.c", "reportHash": "c3d11c8e6a27f9b55133c47a49d72895", "checkerName": "hicpp-signed-bitwise", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 27, "file": 0, "line": 978}, "message": "expanded from macro 'CURLPROTO_RTSP'"}, {"location": {"col": 32, "file": 31, "line": 3095}, "message": "use of a signed integer operand with a binary bitwise operator"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/lib/http.c", "reportHash": "39e1441cf9d5ea3cfde46960f58124a1", "checkerName": "hicpp-signed-bitwise", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 48, "file": 31, "line": 3095}, "message": "{ (fixit)"}, {"location": {"col": 47, "file": 31, "line": 3095}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/lib/http.c", "reportHash": "2a1d95ccf06d0c34b930d0061af26103", "checkerName": "hicpp-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 18, "file": 31, "line": 3173}, "message": "{ (fixit)"}, {"location": {"col": 17, "file": 31, "line": 3173}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/lib/http.c", "reportHash": "d4c197603db9dfab817e37f9cd6b2449", "checkerName": "google-readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 16, "file": 31, "line": 3208}, "message": "{ (fixit)"}, {"location": {"col": 15, "file": 31, "line": 3208}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/lib/http.c", "reportHash": "9a897382111f15ad7bb9fcd078fcebef", "checkerName": "readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 20, "file": 31, "line": 3228}, "message": "{ (fixit)"}, {"location": {"col": 19, "file": 31, "line": 3228}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/lib/http.c", "reportHash": "b54519b5d8450debe7b0843cf7dc971c", "checkerName": "google-readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 26, "file": 31, "line": 3259}, "message": "{ (fixit)"}, {"location": {"col": 25, "file": 31, "line": 3259}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/lib/http.c", "reportHash": "470d13f2745390505507e9c5ff2f320e", "checkerName": "google-readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 26, "file": 31, "line": 3261}, "message": "{ (fixit)"}, {"location": {"col": 25, "file": 31, "line": 3261}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/lib/http.c", "reportHash": "d9cbbbdcfca4e6f33c68a66d3febe36f", "checkerName": "readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 20, "file": 32, "line": 509}, "message": "expanded from macro 'KEEP_SEND'"}, {"location": {"col": 26, "file": 31, "line": 3282}, "message": "use of a signed integer operand with a binary bitwise operator"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/lib/http.c", "reportHash": "0c4dbe4fa22f886793055ff949803e54", "checkerName": "hicpp-signed-bitwise", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 24, "file": 31, "line": 3300}, "message": "{ (fixit)"}, {"location": {"col": 23, "file": 31, "line": 3300}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/lib/http.c", "reportHash": "138430c2fdaa55abb72ec448a7bab710", "checkerName": "hicpp-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 14, "file": 31, "line": 3322}, "message": "use of a signed integer operand with a binary bitwise operator"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/lib/http.c", "reportHash": "c1be1a73ca6b87d097e2332cd818da3d", "checkerName": "hicpp-signed-bitwise", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 27, "file": 0, "line": 978}, "message": "expanded from macro 'CURLPROTO_RTSP'"}, {"location": {"col": 40, "file": 31, "line": 3322}, "message": "use of a signed integer operand with a binary bitwise operator"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/lib/http.c", "reportHash": "9a051983795c8ca3862937d1edc80b32", "checkerName": "hicpp-signed-bitwise", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 29, "file": 36, "line": 51}, "message": "expanded from macro 'CLIENTWRITE_HEADER'"}, {"location": {"col": 19, "file": 31, "line": 3377}, "message": "use of a signed integer operand with a binary bitwise operator"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/lib/http.c", "reportHash": "ab9c077644b163d1a372ed3bff1d5b15", "checkerName": "hicpp-signed-bitwise", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 36, "file": 31, "line": 3378}, "message": "{ (fixit)"}, {"location": {"col": 35, "file": 31, "line": 3378}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/lib/http.c", "reportHash": "fbbdf9baa634ff563eaf1c45a95288fd", "checkerName": "hicpp-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 29, "file": 36, "line": 50}, "message": "expanded from macro 'CLIENTWRITE_BODY'"}, {"location": {"col": 22, "file": 31, "line": 3379}, "message": "use of a signed integer operand with a binary bitwise operator"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/lib/http.c", "reportHash": "ac5812379876afbddc76b33ac8e540f8", "checkerName": "hicpp-signed-bitwise", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 18, "file": 31, "line": 3385}, "message": "{ (fixit)"}, {"location": {"col": 17, "file": 31, "line": 3385}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/lib/http.c", "reportHash": "d4c197603db9dfab817e37f9cd6b2449", "checkerName": "google-readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 18, "file": 31, "line": 3399}, "message": "{ (fixit)"}, {"location": {"col": 17, "file": 31, "line": 3399}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/lib/http.c", "reportHash": "b68cb921db5434ae19d1ec0bd3ce670d", "checkerName": "readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 20, "file": 32, "line": 509}, "message": "expanded from macro 'KEEP_SEND'"}, {"location": {"col": 32, "file": 31, "line": 3442}, "message": "use of a signed integer operand with a binary bitwise operator"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/lib/http.c", "reportHash": "5e644c7ecef722f0a01dbac48a913aa7", "checkerName": "hicpp-signed-bitwise", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 28, "file": 31, "line": 3449}, "message": "{ (fixit)"}, {"location": {"col": 27, "file": 31, "line": 3449}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/lib/http.c", "reportHash": "e8522364db3091f34b6ad3df317ed0e2", "checkerName": "google-readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 49, "file": 31, "line": 3452}, "message": "{ (fixit)"}, {"location": {"col": 48, "file": 31, "line": 3452}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/lib/http.c", "reportHash": "157a738ab9599c6e41049a87f0d136e2", "checkerName": "google-readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 20, "file": 32, "line": 509}, "message": "expanded from macro 'KEEP_SEND'"}, {"location": {"col": 24, "file": 31, "line": 3467}, "message": "use of a signed integer operand with a binary bitwise operator"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/lib/http.c", "reportHash": "a01c05358a6e04c03a72f7860b1d78c1", "checkerName": "hicpp-signed-bitwise", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 35, "file": 31, "line": 3478}, "message": "{ (fixit)"}, {"location": {"col": 34, "file": 31, "line": 3478}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/lib/http.c", "reportHash": "621b9d12e9551a2f72bbe0429980a709", "checkerName": "readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 18, "file": 31, "line": 3481}, "message": "use of a signed integer operand with a binary bitwise operator"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/lib/http.c", "reportHash": "09cf8ec7514a3fbad141ba3e4e65f053", "checkerName": "hicpp-signed-bitwise", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 27, "file": 0, "line": 978}, "message": "expanded from macro 'CURLPROTO_RTSP'"}, {"location": {"col": 44, "file": 31, "line": 3481}, "message": "use of a signed integer operand with a binary bitwise operator"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/lib/http.c", "reportHash": "e45a8880e3e0e9c62749834cf58de829", "checkerName": "hicpp-signed-bitwise", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 34, "file": 31, "line": 3483}, "message": "{ (fixit)"}, {"location": {"col": 33, "file": 31, "line": 3483}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/lib/http.c", "reportHash": "1ae0724d0360a2a67d7b9ad08de2422d", "checkerName": "readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 24, "file": 31, "line": 3504}, "message": "{ (fixit)"}, {"location": {"col": 23, "file": 31, "line": 3504}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/lib/http.c", "reportHash": "c1fa756af570b3f140db820e1f152a29", "checkerName": "readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 24, "file": 31, "line": 3531}, "message": "use of a signed integer operand with a unary bitwise operator"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/lib/http.c", "reportHash": "1964e96a6eec0a29463f46960ce7b556", "checkerName": "hicpp-signed-bitwise", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 21, "file": 32, "line": 508}, "message": "expanded from macro 'KEEP_RECV'"}, {"location": {"col": 25, "file": 31, "line": 3531}, "message": "use of a signed integer operand with a binary bitwise operator"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/lib/http.c", "reportHash": "43b2864ef3287399482de9a650acf0a4", "checkerName": "hicpp-signed-bitwise", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 31, "file": 31, "line": 3534}, "message": "{ (fixit)"}, {"location": {"col": 30, "file": 31, "line": 3534}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/lib/http.c", "reportHash": "46b02ea19d9788d0cdc57ee22fbd08c8", "checkerName": "readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 10, "file": 31, "line": 3576}, "message": "use of a signed integer operand with a binary bitwise operator"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/lib/http.c", "reportHash": "107190490861d0445a319549d0500cf3", "checkerName": "hicpp-signed-bitwise", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 28, "file": 32, "line": 67}, "message": "expanded from macro 'PROTO_FAMILY_HTTP'"}, {"location": {"col": 26, "file": 0, "line": 960}, "message": "expanded from macro 'CURLPROTO_HTTP'"}, {"location": {"col": 36, "file": 31, "line": 3576}, "message": "use of a signed integer operand with a binary bitwise operator"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/lib/http.c", "reportHash": "d40ccc0b6ed41ae82d35cd6272bb1929", "checkerName": "hicpp-signed-bitwise", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 14, "file": 31, "line": 3586}, "message": "'sscanf' used to convert a string to an integer value, but function will not report conversion errors; consider using 'strtol' instead"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/lib/http.c", "reportHash": "9225927483392d7c36070b21ffbe4173", "checkerName": "cert-err34-c", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 17, "file": 31, "line": 3594}, "message": "'sscanf' used to convert a string to an integer value, but function will not report conversion errors; consider using 'strtol' instead"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/lib/http.c", "reportHash": "089c902fdadbe921eba91721cfd721bb", "checkerName": "cert-err34-c", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 41, "file": 31, "line": 3605}, "message": "{ (fixit)"}, {"location": {"col": 40, "file": 31, "line": 3605}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/lib/http.c", "reportHash": "ef0676ac911a01f96e61257d06bbdc9f", "checkerName": "readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 16, "file": 31, "line": 3617}, "message": "'sscanf' used to convert a string to an integer value, but function will not report conversion errors; consider using 'strtol' instead"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/lib/http.c", "reportHash": "58eeae5c40b61f0cbb3542d9531e16db", "checkerName": "cert-err34-c", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 15, "file": 31, "line": 3640}, "message": "use of a signed integer operand with a binary bitwise operator"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/lib/http.c", "reportHash": "320ead925746c6b5ce4901b363cb0eae", "checkerName": "hicpp-signed-bitwise", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 27, "file": 0, "line": 978}, "message": "expanded from macro 'CURLPROTO_RTSP'"}, {"location": {"col": 41, "file": 31, "line": 3640}, "message": "use of a signed integer operand with a binary bitwise operator"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/lib/http.c", "reportHash": "626e615f45e05ebe6dec2cc339bba0b4", "checkerName": "hicpp-signed-bitwise", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 14, "file": 31, "line": 3642}, "message": "'sscanf' used to convert a string to an integer value, but function will not report conversion errors; consider using 'strtol' instead"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/lib/http.c", "reportHash": "9225927483392d7c36070b21ffbe4173", "checkerName": "cert-err34-c", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 57, "file": 31, "line": 3662}, "message": "{ (fixit)"}, {"location": {"col": 56, "file": 31, "line": 3662}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/lib/http.c", "reportHash": "b1e8683b2ec3b89260775283a577a2bc", "checkerName": "readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 39, "file": 31, "line": 3719}, "message": "{ (fixit)"}, {"location": {"col": 38, "file": 31, "line": 3719}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/lib/http.c", "reportHash": "6e0adb10678e86466e903283b1832c02", "checkerName": "google-readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 16, "file": 31, "line": 3744}, "message": "{ (fixit)"}, {"location": {"col": 15, "file": 31, "line": 3744}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/lib/http.c", "reportHash": "4ce630d88e387bbdb14f9e2abd82c2ae", "checkerName": "google-readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 24, "file": 31, "line": 3784}, "message": "{ (fixit)"}, {"location": {"col": 23, "file": 31, "line": 3784}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/lib/http.c", "reportHash": "85acb95269cb7a5aa4ce3112fb7aef87", "checkerName": "hicpp-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 25, "file": 31, "line": 3786}, "message": "{ (fixit)"}, {"location": {"col": 24, "file": 31, "line": 3786}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/lib/http.c", "reportHash": "52ebd2ffc01d1029d62630aa94411647", "checkerName": "readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 18, "file": 31, "line": 3851}, "message": "{ (fixit)"}, {"location": {"col": 17, "file": 31, "line": 3851}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/lib/http.c", "reportHash": "b68cb921db5434ae19d1ec0bd3ce670d", "checkerName": "readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 18, "file": 31, "line": 3864}, "message": "{ (fixit)"}, {"location": {"col": 17, "file": 31, "line": 3864}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/lib/http.c", "reportHash": "b68cb921db5434ae19d1ec0bd3ce670d", "checkerName": "readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 12, "file": 31, "line": 3875}, "message": "{ (fixit)"}, {"location": {"col": 11, "file": 31, "line": 3875}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/lib/http.c", "reportHash": "064e726ca7406d28e24e0c7bc89106d8", "checkerName": "readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 52, "file": 31, "line": 3895}, "message": "{ (fixit)"}, {"location": {"col": 51, "file": 31, "line": 3895}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/lib/http.c", "reportHash": "f1f4791130272085df8c62730ca9551c", "checkerName": "hicpp-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 52, "file": 31, "line": 3901}, "message": "{ (fixit)"}, {"location": {"col": 51, "file": 31, "line": 3901}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/lib/http.c", "reportHash": "44cbe176cf861bc9a495a68131536cb5", "checkerName": "google-readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 12, "file": 31, "line": 3906}, "message": "{ (fixit)"}, {"location": {"col": 11, "file": 31, "line": 3906}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/lib/http.c", "reportHash": "064e726ca7406d28e24e0c7bc89106d8", "checkerName": "readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 24, "file": 31, "line": 3921}, "message": "use of a signed integer operand with a binary bitwise operator"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/lib/http.c", "reportHash": "a750ab93effafcabec464387ad136e60", "checkerName": "hicpp-signed-bitwise", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 27, "file": 0, "line": 961}, "message": "expanded from macro 'CURLPROTO_HTTPS'"}, {"location": {"col": 48, "file": 31, "line": 3921}, "message": "use of a signed integer operand with a binary bitwise operator"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/lib/http.c", "reportHash": "fe2a62a75bbfccbe4b4754be45090329", "checkerName": "hicpp-signed-bitwise", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 34, "file": 31, "line": 3929}, "message": "{ (fixit)"}, {"location": {"col": 33, "file": 31, "line": 3929}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/lib/http.c", "reportHash": "fe1f91fc6c41b17ace9fd1ce58427083", "checkerName": "google-readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 17, "file": 31, "line": 3939}, "message": "{ (fixit)"}, {"location": {"col": 16, "file": 31, "line": 3939}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/lib/http.c", "reportHash": "8884792f13bed5182a2059ac9be2aca6", "checkerName": "google-readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 18, "file": 31, "line": 3946}, "message": "{ (fixit)"}, {"location": {"col": 17, "file": 31, "line": 3946}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/lib/http.c", "reportHash": "d4c197603db9dfab817e37f9cd6b2449", "checkerName": "google-readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 21, "file": 31, "line": 3971}, "message": "{ (fixit)"}, {"location": {"col": 20, "file": 31, "line": 3971}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/lib/http.c", "reportHash": "6ddb3ca9ae3f651bc7c818feab455753", "checkerName": "google-readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 22, "file": 31, "line": 3973}, "message": "{ (fixit)"}, {"location": {"col": 21, "file": 31, "line": 3973}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/lib/http.c", "reportHash": "b4298e889053351e4629f484c490fcd8", "checkerName": "google-readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 33, "file": 31, "line": 3982}, "message": "{ (fixit)"}, {"location": {"col": 32, "file": 31, "line": 3982}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/lib/http.c", "reportHash": "8407453e36d3c66ab317a0a810fa7d30", "checkerName": "readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 22, "file": 31, "line": 3988}, "message": "{ (fixit)"}, {"location": {"col": 21, "file": 31, "line": 3988}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/lib/http.c", "reportHash": "a7944f8a3a0e68eb252bdbce4200998c", "checkerName": "readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 13, "file": 31, "line": 4014}, "message": "use of a signed integer operand with a binary bitwise operator"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/lib/http.c", "reportHash": "8592313532606a88716e44a34b207f64", "checkerName": "hicpp-signed-bitwise", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 27, "file": 0, "line": 978}, "message": "expanded from macro 'CURLPROTO_RTSP'"}, {"location": {"col": 39, "file": 31, "line": 4014}, "message": "use of a signed integer operand with a binary bitwise operator"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/lib/http.c", "reportHash": "21aef80fcf3f3fe8e1d7b3d853e47add", "checkerName": "hicpp-signed-bitwise", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 18, "file": 31, "line": 4016}, "message": "{ (fixit)"}, {"location": {"col": 17, "file": 31, "line": 4016}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/lib/http.c", "reportHash": "b68cb921db5434ae19d1ec0bd3ce670d", "checkerName": "readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 29, "file": 36, "line": 51}, "message": "expanded from macro 'CLIENTWRITE_HEADER'"}, {"location": {"col": 17, "file": 31, "line": 4024}, "message": "use of a signed integer operand with a binary bitwise operator"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/lib/http.c", "reportHash": "dfc8d95000346ff9cb61cf529f55c325", "checkerName": "hicpp-signed-bitwise", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 34, "file": 31, "line": 4025}, "message": "{ (fixit)"}, {"location": {"col": 33, "file": 31, "line": 4025}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/lib/http.c", "reportHash": "5231bdf830418c5dff7b42b76ca524d0", "checkerName": "readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 29, "file": 36, "line": 50}, "message": "expanded from macro 'CLIENTWRITE_BODY'"}, {"location": {"col": 20, "file": 31, "line": 4026}, "message": "use of a signed integer operand with a binary bitwise operator"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/lib/http.c", "reportHash": "7234d9acd03a81b5f18775dbe98382dc", "checkerName": "hicpp-signed-bitwise", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 27, "file": 31, "line": 4028}, "message": "{ (fixit)"}, {"location": {"col": 26, "file": 31, "line": 4028}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/lib/http.c", "reportHash": "40bcfa77f82356619c26f902b70b35e1", "checkerName": "readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 16, "file": 31, "line": 4034}, "message": "{ (fixit)"}, {"location": {"col": 15, "file": 31, "line": 4034}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/lib/http.c", "reportHash": "7b9df5b135c0570f2596abd66d0a6ee5", "checkerName": "hicpp-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 10, "file": 31, "line": 1828}, "message": "the definition seen here"}, {"location": {"col": 10, "file": 33, "line": 53}, "message": "differing parameters are named here: ('buf'), in definition: ('req')"}, {"location": {"col": 10, "file": 33, "line": 53}, "message": "function 'Curl_add_timecondition' has a definition with different parameter names"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/lib/http.h", "reportHash": "00749f82b1f123fa1e0e157eeb7c5434", "checkerName": "readability-inconsistent-declaration-parameter-name", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 10, "file": 31, "line": 1682}, "message": "the definition seen here"}, {"location": {"col": 10, "file": 33, "line": 55}, "message": "differing parameters are named here: ('req_buffer'), in definition: ('req')"}, {"location": {"col": 10, "file": 33, "line": 55}, "message": "function 'Curl_add_custom_headers' has a definition with different parameter names"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/lib/http.h", "reportHash": "83c1be45af1c685e9208d56451d4c086", "checkerName": "readability-inconsistent-declaration-parameter-name", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 10, "file": 31, "line": 1640}, "message": "the definition seen here"}, {"location": {"col": 10, "file": 33, "line": 58}, "message": "differing parameters are named here: ('buf'), in definition: ('b')"}, {"location": {"col": 10, "file": 33, "line": 58}, "message": "function 'Curl_http_compile_trailers' has a definition with different parameter names"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/lib/http.h", "reportHash": "50fb5d2f617c70f4e238a9491be90517", "checkerName": "readability-inconsistent-declaration-parameter-name", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 46, "file": 33, "line": 64}, "message": "/*conn*/  /*status*/ (fixit)"}, {"location": {"col": 45, "file": 33, "line": 64}, "message": "all parameters should be named in a function"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/lib/http.h", "reportHash": "f1f674a52f64ad147e77b68536243281", "checkerName": "readability-named-parameter", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 9, "file": 37, "line": 1}, "message": "_HOME_RUNNER_WORK_TESTCC_TESTCC_RETDEC_LIB_HTTP2_H (fixit)"}, {"location": {"col": 9, "file": 37, "line": 1}, "message": "header guard does not follow preferred style"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/lib/http2.h", "reportHash": "0cd564e33635d5849fce0ebd786c1934", "checkerName": "llvm-header-guard", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 9, "file": 39, "line": 1}, "message": "_HOME_RUNNER_WORK_TESTCC_TESTCC_RETDEC_LIB_HTTP_DIGEST_H (fixit)"}, {"location": {"col": 9, "file": 39, "line": 1}, "message": "header guard does not follow preferred style"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/lib/http_digest.h", "reportHash": "b45dcd8e7ad7fb40b791f25909044c4f", "checkerName": "llvm-header-guard", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 9, "file": 40, "line": 1}, "message": "_HOME_RUNNER_WORK_TESTCC_TESTCC_RETDEC_LIB_HTTP_NEGOTIATE_H (fixit)"}, {"location": {"col": 9, "file": 40, "line": 1}, "message": "header guard does not follow preferred style"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/lib/http_negotiate.h", "reportHash": "0ee1abb21b6a9f70af11f5382850e512", "checkerName": "llvm-header-guard", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 9, "file": 41, "line": 1}, "message": "_HOME_RUNNER_WORK_TESTCC_TESTCC_RETDEC_LIB_HTTP_NTLM_H (fixit)"}, {"location": {"col": 9, "file": 41, "line": 1}, "message": "header guard does not follow preferred style"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/lib/http_ntlm.h", "reportHash": "cb82dc4b6fff7763f214e5decd236ca2", "checkerName": "llvm-header-guard", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 9, "file": 42, "line": 1}, "message": "_HOME_RUNNER_WORK_TESTCC_TESTCC_RETDEC_LIB_HTTP_PROXY_H (fixit)"}, {"location": {"col": 9, "file": 42, "line": 1}, "message": "header guard does not follow preferred style"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/lib/http_proxy.h", "reportHash": "5f2ea57da7befbe233ff49b50d64311a", "checkerName": "llvm-header-guard", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 9, "file": 50, "line": 1}, "message": "_HOME_RUNNER_WORK_TESTCC_TESTCC_RETDEC_LIB_PARSEDATE_H (fixit)"}, {"location": {"col": 9, "file": 50, "line": 1}, "message": "header guard does not follow preferred style"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/lib/parsedate.h", "reportHash": "038e30a9f403bf1f80504963a5bdfb16", "checkerName": "llvm-header-guard", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 9, "file": 58, "line": 1}, "message": "_HOME_RUNNER_WORK_TESTCC_TESTCC_RETDEC_LIB_SHARE_H (fixit)"}, {"location": {"col": 9, "file": 58, "line": 1}, "message": "header guard does not follow preferred style"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/lib/share.h", "reportHash": "115405fb153d4940dd0842f1743e14aa", "checkerName": "llvm-header-guard", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 10, "file": 58, "line": 25}, "message": "\"conncache.h\" (fixit)"}, {"location": {"col": 1, "file": 58, "line": 25}, "message": "#includes are not sorted properly"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/lib/share.h", "reportHash": "d2575fb6f83dd625b422afd07cafa98e", "checkerName": "llvm-include-order", "reviewStatus": null, "severity": "LOW"}]};
      window.onload = function() {
        if (!browserCompatible) {
          setNonCompatibleBrowserMessage();
        } else {
          BugViewer.init(data.files, data.reports);
          BugViewer.create();
          BugViewer.initByUrl();
        }
      };
    </script>
  </head>
  <body>
  <div class="container">
    <div id="content">
      <div id="side-bar">
        <div class="header">
          <a href="index.html" class="button">&#8249; Return to List</a>
        </div>
        <div id="report-nav">
          <div class="header">Reports</div>
        </div>
      </div>
      <div id="editor-wrapper">
        <div class="header">
          <div id="file">
            <span class="label">File:</span>
            <span id="file-path"></span>
          </div>
          <div id="checker">
            <span class="label">Checker name:</span>
            <span id="checker-name"></span>
          </div>
          <div id="review-status-wrapper">
            <span class="label">Review status:</span>
            <span id="review-status"></span>
          </div>
        </div>
        <div id="editor"></div>
      </div>
    </div>
  </div>
  </body>
</html>
