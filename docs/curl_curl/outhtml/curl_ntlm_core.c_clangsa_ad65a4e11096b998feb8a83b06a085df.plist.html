<!DOCTYPE html>
<html>
  <head>
    <title>Plist HTML Viewer</title>

    <meta charset="UTF-8">

    <style type="text/css">
      .CodeMirror{font-family:monospace;height:300px;color:#000;direction:ltr}.CodeMirror-lines{padding:4px 0}.CodeMirror pre{padding:0 4px}.CodeMirror-gutter-filler,.CodeMirror-scrollbar-filler{background-color:#fff}.CodeMirror-gutters{border-right:1px solid #ddd;background-color:#f7f7f7;white-space:nowrap}.CodeMirror-linenumber{padding:0 3px 0 5px;min-width:20px;text-align:right;color:#999;white-space:nowrap}.CodeMirror-guttermarker{color:#000}.CodeMirror-guttermarker-subtle{color:#999}.CodeMirror-cursor{border-left:1px solid #000;border-right:none;width:0}.CodeMirror div.CodeMirror-secondarycursor{border-left:1px solid silver}.cm-fat-cursor .CodeMirror-cursor{width:auto;border:0!important;background:#7e7}.cm-fat-cursor div.CodeMirror-cursors{z-index:1}.cm-animate-fat-cursor{width:auto;border:0;-webkit-animation:blink 1.06s steps(1) infinite;-moz-animation:blink 1.06s steps(1) infinite;animation:blink 1.06s steps(1) infinite;background-color:#7e7}@-moz-keyframes blink{50%{background-color:transparent}}@-webkit-keyframes blink{50%{background-color:transparent}}@keyframes blink{50%{background-color:transparent}}.cm-tab{display:inline-block;text-decoration:inherit}.CodeMirror-rulers{position:absolute;left:0;right:0;top:-50px;bottom:-20px;overflow:hidden}.CodeMirror-ruler{border-left:1px solid #ccc;top:0;bottom:0;position:absolute}.cm-s-default .cm-header{color:#00f}.cm-s-default .cm-quote{color:#090}.cm-negative{color:#d44}.cm-positive{color:#292}.cm-header,.cm-strong{font-weight:700}.cm-em{font-style:italic}.cm-link{text-decoration:underline}.cm-strikethrough{text-decoration:line-through}.cm-s-default .cm-keyword{color:#708}.cm-s-default .cm-atom{color:#219}.cm-s-default .cm-number{color:#164}.cm-s-default .cm-def{color:#00f}.cm-s-default .cm-variable-2{color:#05a}.cm-s-default .cm-type,.cm-s-default .cm-variable-3{color:#085}.cm-s-default .cm-comment{color:#a50}.cm-s-default .cm-string{color:#a11}.cm-s-default .cm-string-2{color:#f50}.cm-s-default .cm-meta{color:#555}.cm-s-default .cm-qualifier{color:#555}.cm-s-default .cm-builtin{color:#30a}.cm-s-default .cm-bracket{color:#997}.cm-s-default .cm-tag{color:#170}.cm-s-default .cm-attribute{color:#00c}.cm-s-default .cm-hr{color:#999}.cm-s-default .cm-link{color:#00c}.cm-s-default .cm-error{color:red}.cm-invalidchar{color:red}.CodeMirror-composing{border-bottom:2px solid}div.CodeMirror span.CodeMirror-matchingbracket{color:#0f0}div.CodeMirror span.CodeMirror-nonmatchingbracket{color:#f22}.CodeMirror-matchingtag{background:rgba(255,150,0,.3)}.CodeMirror-activeline-background{background:#e8f2ff}.CodeMirror{position:relative;overflow:hidden;background:#fff}.CodeMirror-scroll{overflow:scroll!important;margin-bottom:-30px;margin-right:-30px;padding-bottom:30px;height:100%;outline:0;position:relative}.CodeMirror-sizer{position:relative;border-right:30px solid transparent}.CodeMirror-gutter-filler,.CodeMirror-hscrollbar,.CodeMirror-scrollbar-filler,.CodeMirror-vscrollbar{position:absolute;z-index:6;display:none}.CodeMirror-vscrollbar{right:0;top:0;overflow-x:hidden;overflow-y:scroll}.CodeMirror-hscrollbar{bottom:0;left:0;overflow-y:hidden;overflow-x:scroll}.CodeMirror-scrollbar-filler{right:0;bottom:0}.CodeMirror-gutter-filler{left:0;bottom:0}.CodeMirror-gutters{position:absolute;left:0;top:0;min-height:100%;z-index:3}.CodeMirror-gutter{white-space:normal;height:100%;display:inline-block;vertical-align:top;margin-bottom:-30px}.CodeMirror-gutter-wrapper{position:absolute;z-index:4;background:0 0!important;border:none!important}.CodeMirror-gutter-background{position:absolute;top:0;bottom:0;z-index:4}.CodeMirror-gutter-elt{position:absolute;cursor:default;z-index:4}.CodeMirror-gutter-wrapper ::selection{background-color:transparent}.CodeMirror-gutter-wrapper ::-moz-selection{background-color:transparent}.CodeMirror-lines{cursor:text;min-height:1px}.CodeMirror pre{-moz-border-radius:0;-webkit-border-radius:0;border-radius:0;border-width:0;background:0 0;font-family:inherit;font-size:inherit;margin:0;white-space:pre;word-wrap:normal;line-height:inherit;color:inherit;z-index:2;position:relative;overflow:visible;-webkit-tap-highlight-color:transparent;-webkit-font-variant-ligatures:contextual;font-variant-ligatures:contextual}.CodeMirror-wrap pre{word-wrap:break-word;white-space:pre-wrap;word-break:normal}.CodeMirror-linebackground{position:absolute;left:0;right:0;top:0;bottom:0;z-index:0}.CodeMirror-linewidget{position:relative;z-index:2;overflow:auto}.CodeMirror-rtl pre{direction:rtl}.CodeMirror-code{outline:0}.CodeMirror-gutter,.CodeMirror-gutters,.CodeMirror-linenumber,.CodeMirror-scroll,.CodeMirror-sizer{-moz-box-sizing:content-box;box-sizing:content-box}.CodeMirror-measure{position:absolute;width:100%;height:0;overflow:hidden;visibility:hidden}.CodeMirror-cursor{position:absolute;pointer-events:none}.CodeMirror-measure pre{position:static}div.CodeMirror-cursors{visibility:hidden;position:relative;z-index:3}div.CodeMirror-dragcursors{visibility:visible}.CodeMirror-focused div.CodeMirror-cursors{visibility:visible}.CodeMirror-selected{background:#d9d9d9}.CodeMirror-focused .CodeMirror-selected{background:#d7d4f0}.CodeMirror-crosshair{cursor:crosshair}.CodeMirror-line::selection,.CodeMirror-line>span::selection,.CodeMirror-line>span>span::selection{background:#d7d4f0}.CodeMirror-line::-moz-selection,.CodeMirror-line>span::-moz-selection,.CodeMirror-line>span>span::-moz-selection{background:#d7d4f0}.cm-searching{background-color:#ffa;background-color:rgba(255,255,0,.4)}.cm-force-border{padding-right:.1px}@media print{.CodeMirror div.CodeMirror-cursors{visibility:hidden}}.cm-tab-wrap-hack:after{content:''}span.CodeMirror-selectedtext{background:0 0}
/*# sourceMappingURL=codemirror.min.css.map */

      .severity-low {
  background-color: #669603;
}

.severity-low:after {
  content : 'L';
}

.severity-unspecified {
  background-color: #666666;
}

.severity-unspecified:after {
  content : 'U';
}

.severity-style {
  background-color: #9932cc;
}

.severity-style:after {
  content : 'S';
}

.severity-medium {
  background-color: #a9d323;
  color: black;
}

.severity-medium:after {
  content : 'M';
}

.severity-high {
  background-color: #ffa800;
}

.severity-high:after {
  content : 'H';
}

.severity-critical {
  background-color: #e92625;
}

.severity-critical:after {
  content : 'C';
}

i[class*="severity-"] {
  line-height: normal;
  text-transform: capitalize;
  font-size: 0.8em;
  font-weight: bold;
  color: white;
  display: inline-block;
  width: 16px;
  height: 16px;
  text-align: center;
  font-family: sans-serif;
}

      html, body {
  width: 100%;
  height: 100%;
  padding: 0px;
  margin: 0px;
}

div.container {
  padding: 10px;
}

#content {
  height: 100%;
  display: block;
  overflow: hidden;
}

#content > div {
  margin: 10px;
  overflow: hidden;
  border: 1px solid #ddd;
  border-radius: 3px;
  overflow: hidden;
  height: 97%;
}

.button {
  background-color: #f1f1f1;
  text-decoration: none;
  display: inline-block;
  padding: 8px 16px;
  color: black;
  cursor: pointer;
}

.button:hover {
  background-color: #ddd;
  color: black;
}

.review-status {
  color: white;
  text-align: center;
}

.review-status-confirmed {
  background-color: #e92625;
}

.review-status-false-positive {
  background-color: grey;
}

.review-status-intentional {
  background-color: #669603;
}

      div.container {
  width: 100%;
  height: 100%;
  padding: 0px;
}

#editor-wrapper {
  margin: 10px;
}

#side-bar {
  float: left;
  width: 260px;
  margin: 0px;
}

#report-nav ul {
  list-style-type: none;
  padding: 0;
  margin: 0;
  overflow-y: auto;
  height: 100%;
}

#report-nav ul > li {
  padding: .4em;
  background-color: #fff;
  border-bottom: 1px solid rgba(0,0,0,.125);
  text-align: left;
  overflow: hidden;
  white-space: nowrap;
  text-overflow: ellipsis;
}

#report-nav ul > li.active {
  background-color: #427ea9;
  color: white;
}

#report-nav ul > li:hover {
  background-color: #427ea9;
  color: white;
  cursor: pointer;
}

#report-nav ul a {
  text-decoration: none;
}

#report-nav i[class*="severity-"] {
  margin-right: 5px;
}

.header {
  border-bottom: 1px solid lightgrey;
  font-family: monospace;
  padding: 10px;
  background-color: #fafbfc;
  border-bottom: 1px solid #e1e4e8;
  border-top-left-radius: 2px;
  border-top-right-radius: 2px;
}

#report-nav .header {
  font-weight: bold;
}

#editor-wrapper .header > div {
  padding-top: 2px;
}

#file-path,
#checker-name {
  color: #195ea2;
}

#review-status {
  padding: 0px 5px;
}

#file-path {
  font-family: monospace;
}

.check-msg {
  display: inline-block;
  padding: 3px 6px;
  margin: 1px;
  -webkit-border-radius: 5px;
  -moz-border-radius: 5px;
  border-radius: 5px;
}

.check-msg.info {
  color: #00546f;
  background-color: #bfdfe9;
  border: 1px solid #87a8b3;
}

.check-msg.error {
  background-color: #f2dede;
  color: #a94442;
  border: 1px solid #ebcccc;
}

.check-msg.macro {
  background-color: #d7dac2;
  color: #4f5c6d;
  border: 1px solid #d7dac2;
}

.check-msg.note {
  background-color: #d7d7d7;
  color: #4f5c6d;
  border: 1px solid #bfbfbf;
}

.check-msg.current {
  border: 2px dashed #3692ff;
}

.check-msg .tag {
  padding: 1px 5px;
  text-align: center;
  border-radius: 2px;
  margin-right: 5px;
  text-decoration: inherit;
}

.check-msg .tag.macro {
  background-color: #83876a;
  color: white;
  text-transform: capitalize;
}

.check-msg .tag.note {
  background-color: #9299a1;
  color: white;
  text-transform: capitalize;
}

.checker-enum {
  color: white;
  padding: 1px 5px;
  text-align: center;
  border-radius: 25px;
  margin-right: 5px;
  text-decoration: inherit;
}

.checker-enum.info {
  background-color: #427ea9;
}

.checker-enum.error {
  background-color: #a94442;
}

.arrow {
  border: solid black;
  border-width: 0 3px 3px 0;
  display: inline-block;
  padding: 3px;
  cursor: pointer;
  margin: 0px 5px;
}

.arrow:hover {
  border: solid #437ea8;
  border-width: 0 3px 3px 0;
}

.left-arrow {
  transform: rotate(135deg);
  -webkit-transform: rotate(135deg);
}

.right-arrow {
  transform: rotate(-45deg);
  -webkit-transform: rotate(-45deg);
}

    </style>

    <script type="text/javascript">
      function setNonCompatibleBrowserMessage() {
  document.body.innerHTML =
    '<h2 style="margin-left: 20px;">Your browser is not compatible with CodeChecker Viewer!</h2> \
     <p style="margin-left: 20px;">The version required for the following browsers are:</p> \
     <ul style="margin-left: 20px;"> \
     <li>Internet Explorer: version 9 or newer</li> \
     <li>Firefox: version 22.0 or newer</li> \
     </ul>';
}

// http://stackoverflow.com/questions/5916900/how-can-you-detect-the-version-of-a-browser
var browserVersion = (function(){
  var ua = navigator.userAgent, tem,
    M = ua.match(/(opera|chrome|safari|firefox|msie|trident(?=\/))\/?\s*(\d+)/i) || [];

  if (/trident/i.test(M[1])) {
    tem = /\brv[ :]+(\d+)/g.exec(ua) || [];
    return 'IE ' + (tem[1] || '');
  }

  if (M[1] === 'Chrome') {
    tem = ua.match(/\b(OPR|Edge)\/(\d+)/);
    if (tem != null) return tem.slice(1).join(' ').replace('OPR', 'Opera');
  }

  M = M[2] ? [M[1], M[2]] : [navigator.appName, navigator.appVersion, '-?'];
  if ((tem = ua.match(/version\/(\d+)/i)) != null) M.splice(1, 1, tem[1]);
    return M.join(' ');
})();

var pos = browserVersion.indexOf(' ');
var browser = browserVersion.substr(0, pos);
var version = parseInt(browserVersion.substr(pos + 1));

var browserCompatible
  = browser === 'Firefox'
  ? version >= 22
  : browser === 'IE'
  ? version >= 9
  : true;


      /* MIT License

Copyright (C) 2017 by Marijn Haverbeke <marijnh@gmail.com> and others

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
THE SOFTWARE.
 */
      !function(e,t){"object"==typeof exports&&"undefined"!=typeof module?module.exports=t():"function"==typeof define&&define.amd?define(t):e.CodeMirror=t()}(this,function(){"use strict";function e(e){return new RegExp("(^|\\s)"+e+"(?:$|\\s)\\s*")}function t(e){for(var t=e.childNodes.length;t>0;--t)e.removeChild(e.firstChild);return e}function r(e,r){return t(e).appendChild(r)}function n(e,t,r,n){var i=document.createElement(e);if(r&&(i.className=r),n&&(i.style.cssText=n),"string"==typeof t)i.appendChild(document.createTextNode(t));else if(t)for(var o=0;o<t.length;++o)i.appendChild(t[o]);return i}function i(e,t,r,i){var o=n(e,t,r,i);return o.setAttribute("role","presentation"),o}function o(e,t){if(3==t.nodeType&&(t=t.parentNode),e.contains)return e.contains(t);do{if(11==t.nodeType&&(t=t.host),t==e)return!0}while(t=t.parentNode)}function l(){var e;try{e=document.activeElement}catch(t){e=document.body||null}for(;e&&e.shadowRoot&&e.shadowRoot.activeElement;)e=e.shadowRoot.activeElement;return e}function s(t,r){var n=t.className;e(r).test(n)||(t.className+=(n?" ":"")+r)}function a(t,r){for(var n=t.split(" "),i=0;i<n.length;i++)n[i]&&!e(n[i]).test(r)&&(r+=" "+n[i]);return r}function u(e){var t=Array.prototype.slice.call(arguments,1);return function(){return e.apply(null,t)}}function c(e,t,r){t||(t={});for(var n in e)!e.hasOwnProperty(n)||!1===r&&t.hasOwnProperty(n)||(t[n]=e[n]);return t}function f(e,t,r,n,i){null==t&&-1==(t=e.search(/[^\s\u00a0]/))&&(t=e.length);for(var o=n||0,l=i||0;;){var s=e.indexOf("\t",o);if(s<0||s>=t)return l+(t-o);l+=s-o,l+=r-l%r,o=s+1}}function h(e,t){for(var r=0;r<e.length;++r)if(e[r]==t)return r;return-1}function d(e,t,r){for(var n=0,i=0;;){var o=e.indexOf("\t",n);-1==o&&(o=e.length);var l=o-n;if(o==e.length||i+l>=t)return n+Math.min(l,t-i);if(i+=o-n,i+=r-i%r,n=o+1,i>=t)return n}}function p(e){for(;Kl.length<=e;)Kl.push(g(Kl)+" ");return Kl[e]}function g(e){return e[e.length-1]}function v(e,t){for(var r=[],n=0;n<e.length;n++)r[n]=t(e[n],n);return r}function m(e,t,r){for(var n=0,i=r(t);n<e.length&&r(e[n])<=i;)n++;e.splice(n,0,t)}function y(){}function b(e,t){var r;return Object.create?r=Object.create(e):(y.prototype=e,r=new y),t&&c(t,r),r}function w(e){return/\w/.test(e)||e>""&&(e.toUpperCase()!=e.toLowerCase()||jl.test(e))}function x(e,t){return t?!!(t.source.indexOf("\\w")>-1&&w(e))||t.test(e):w(e)}function C(e){for(var t in e)if(e.hasOwnProperty(t)&&e[t])return!1;return!0}function S(e){return e.charCodeAt(0)>=768&&Xl.test(e)}function L(e,t,r){for(;(r<0?t>0:t<e.length)&&S(e.charAt(t));)t+=r;return t}function k(e,t,r){for(var n=t>r?-1:1;;){if(t==r)return t;var i=(t+r)/2,o=n<0?Math.ceil(i):Math.floor(i);if(o==t)return e(o)?t:r;e(o)?r=o:t=o+n}}function T(e,t,r){var o=this;this.input=r,o.scrollbarFiller=n("div",null,"CodeMirror-scrollbar-filler"),o.scrollbarFiller.setAttribute("cm-not-content","true"),o.gutterFiller=n("div",null,"CodeMirror-gutter-filler"),o.gutterFiller.setAttribute("cm-not-content","true"),o.lineDiv=i("div",null,"CodeMirror-code"),o.selectionDiv=n("div",null,null,"position: relative; z-index: 1"),o.cursorDiv=n("div",null,"CodeMirror-cursors"),o.measure=n("div",null,"CodeMirror-measure"),o.lineMeasure=n("div",null,"CodeMirror-measure"),o.lineSpace=i("div",[o.measure,o.lineMeasure,o.selectionDiv,o.cursorDiv,o.lineDiv],null,"position: relative; outline: none");var l=i("div",[o.lineSpace],"CodeMirror-lines");o.mover=n("div",[l],null,"position: relative"),o.sizer=n("div",[o.mover],"CodeMirror-sizer"),o.sizerWidth=null,o.heightForcer=n("div",null,null,"position: absolute; height: "+Rl+"px; width: 1px;"),o.gutters=n("div",null,"CodeMirror-gutters"),o.lineGutter=null,o.scroller=n("div",[o.sizer,o.heightForcer,o.gutters],"CodeMirror-scroll"),o.scroller.setAttribute("tabIndex","-1"),o.wrapper=n("div",[o.scrollbarFiller,o.gutterFiller,o.scroller],"CodeMirror"),gl&&vl<8&&(o.gutters.style.zIndex=-1,o.scroller.style.paddingRight=0),ml||fl&&Tl||(o.scroller.draggable=!0),e&&(e.appendChild?e.appendChild(o.wrapper):e(o.wrapper)),o.viewFrom=o.viewTo=t.first,o.reportedViewFrom=o.reportedViewTo=t.first,o.view=[],o.renderedView=null,o.externalMeasured=null,o.viewOffset=0,o.lastWrapHeight=o.lastWrapWidth=0,o.updateLineNumbers=null,o.nativeBarWidth=o.barHeight=o.barWidth=0,o.scrollbarsClipped=!1,o.lineNumWidth=o.lineNumInnerWidth=o.lineNumChars=null,o.alignWidgets=!1,o.cachedCharWidth=o.cachedTextHeight=o.cachedPaddingH=null,o.maxLine=null,o.maxLineLength=0,o.maxLineChanged=!1,o.wheelDX=o.wheelDY=o.wheelStartX=o.wheelStartY=null,o.shift=!1,o.selForContextMenu=null,o.activeTouch=null,r.init(o)}function M(e,t){if((t-=e.first)<0||t>=e.size)throw new Error("There is no line "+(t+e.first)+" in the document.");for(var r=e;!r.lines;)for(var n=0;;++n){var i=r.children[n],o=i.chunkSize();if(t<o){r=i;break}t-=o}return r.lines[t]}function N(e,t,r){var n=[],i=t.line;return e.iter(t.line,r.line+1,function(e){var o=e.text;i==r.line&&(o=o.slice(0,r.ch)),i==t.line&&(o=o.slice(t.ch)),n.push(o),++i}),n}function O(e,t,r){var n=[];return e.iter(t,r,function(e){n.push(e.text)}),n}function A(e,t){var r=t-e.height;if(r)for(var n=e;n;n=n.parent)n.height+=r}function W(e){if(null==e.parent)return null;for(var t=e.parent,r=h(t.lines,e),n=t.parent;n;t=n,n=n.parent)for(var i=0;n.children[i]!=t;++i)r+=n.children[i].chunkSize();return r+t.first}function D(e,t){var r=e.first;e:do{for(var n=0;n<e.children.length;++n){var i=e.children[n],o=i.height;if(t<o){e=i;continue e}t-=o,r+=i.chunkSize()}return r}while(!e.lines);for(var l=0;l<e.lines.length;++l){var s=e.lines[l].height;if(t<s)break;t-=s}return r+l}function H(e,t){return t>=e.first&&t<e.first+e.size}function F(e,t){return String(e.lineNumberFormatter(t+e.firstLineNumber))}function E(e,t,r){if(void 0===r&&(r=null),!(this instanceof E))return new E(e,t,r);this.line=e,this.ch=t,this.sticky=r}function P(e,t){return e.line-t.line||e.ch-t.ch}function I(e,t){return e.sticky==t.sticky&&0==P(e,t)}function z(e){return E(e.line,e.ch)}function R(e,t){return P(e,t)<0?t:e}function B(e,t){return P(e,t)<0?e:t}function G(e,t){return Math.max(e.first,Math.min(t,e.first+e.size-1))}function U(e,t){if(t.line<e.first)return E(e.first,0);var r=e.first+e.size-1;return t.line>r?E(r,M(e,r).text.length):V(t,M(e,t.line).text.length)}function V(e,t){var r=e.ch;return null==r||r>t?E(e.line,t):r<0?E(e.line,0):e}function K(e,t){for(var r=[],n=0;n<t.length;n++)r[n]=U(e,t[n]);return r}function j(){Yl=!0}function X(){_l=!0}function Y(e,t,r){this.marker=e,this.from=t,this.to=r}function _(e,t){if(e)for(var r=0;r<e.length;++r){var n=e[r];if(n.marker==t)return n}}function $(e,t){for(var r,n=0;n<e.length;++n)e[n]!=t&&(r||(r=[])).push(e[n]);return r}function q(e,t){e.markedSpans=e.markedSpans?e.markedSpans.concat([t]):[t],t.marker.attachLine(e)}function Z(e,t,r){var n;if(e)for(var i=0;i<e.length;++i){var o=e[i],l=o.marker;if(null==o.from||(l.inclusiveLeft?o.from<=t:o.from<t)||o.from==t&&"bookmark"==l.type&&(!r||!o.marker.insertLeft)){var s=null==o.to||(l.inclusiveRight?o.to>=t:o.to>t);(n||(n=[])).push(new Y(l,o.from,s?null:o.to))}}return n}function Q(e,t,r){var n;if(e)for(var i=0;i<e.length;++i){var o=e[i],l=o.marker;if(null==o.to||(l.inclusiveRight?o.to>=t:o.to>t)||o.from==t&&"bookmark"==l.type&&(!r||o.marker.insertLeft)){var s=null==o.from||(l.inclusiveLeft?o.from<=t:o.from<t);(n||(n=[])).push(new Y(l,s?null:o.from-t,null==o.to?null:o.to-t))}}return n}function J(e,t){if(t.full)return null;var r=H(e,t.from.line)&&M(e,t.from.line).markedSpans,n=H(e,t.to.line)&&M(e,t.to.line).markedSpans;if(!r&&!n)return null;var i=t.from.ch,o=t.to.ch,l=0==P(t.from,t.to),s=Z(r,i,l),a=Q(n,o,l),u=1==t.text.length,c=g(t.text).length+(u?i:0);if(s)for(var f=0;f<s.length;++f){var h=s[f];if(null==h.to){var d=_(a,h.marker);d?u&&(h.to=null==d.to?null:d.to+c):h.to=i}}if(a)for(var p=0;p<a.length;++p){var v=a[p];null!=v.to&&(v.to+=c),null==v.from?_(s,v.marker)||(v.from=c,u&&(s||(s=[])).push(v)):(v.from+=c,u&&(s||(s=[])).push(v))}s&&(s=ee(s)),a&&a!=s&&(a=ee(a));var m=[s];if(!u){var y,b=t.text.length-2;if(b>0&&s)for(var w=0;w<s.length;++w)null==s[w].to&&(y||(y=[])).push(new Y(s[w].marker,null,null));for(var x=0;x<b;++x)m.push(y);m.push(a)}return m}function ee(e){for(var t=0;t<e.length;++t){var r=e[t];null!=r.from&&r.from==r.to&&!1!==r.marker.clearWhenEmpty&&e.splice(t--,1)}return e.length?e:null}function te(e,t,r){var n=null;if(e.iter(t.line,r.line+1,function(e){if(e.markedSpans)for(var t=0;t<e.markedSpans.length;++t){var r=e.markedSpans[t].marker;!r.readOnly||n&&-1!=h(n,r)||(n||(n=[])).push(r)}}),!n)return null;for(var i=[{from:t,to:r}],o=0;o<n.length;++o)for(var l=n[o],s=l.find(0),a=0;a<i.length;++a){var u=i[a];if(!(P(u.to,s.from)<0||P(u.from,s.to)>0)){var c=[a,1],f=P(u.from,s.from),d=P(u.to,s.to);(f<0||!l.inclusiveLeft&&!f)&&c.push({from:u.from,to:s.from}),(d>0||!l.inclusiveRight&&!d)&&c.push({from:s.to,to:u.to}),i.splice.apply(i,c),a+=c.length-3}}return i}function re(e){var t=e.markedSpans;if(t){for(var r=0;r<t.length;++r)t[r].marker.detachLine(e);e.markedSpans=null}}function ne(e,t){if(t){for(var r=0;r<t.length;++r)t[r].marker.attachLine(e);e.markedSpans=t}}function ie(e){return e.inclusiveLeft?-1:0}function oe(e){return e.inclusiveRight?1:0}function le(e,t){var r=e.lines.length-t.lines.length;if(0!=r)return r;var n=e.find(),i=t.find(),o=P(n.from,i.from)||ie(e)-ie(t);if(o)return-o;var l=P(n.to,i.to)||oe(e)-oe(t);return l||t.id-e.id}function se(e,t){var r,n=_l&&e.markedSpans;if(n)for(var i=void 0,o=0;o<n.length;++o)(i=n[o]).marker.collapsed&&null==(t?i.from:i.to)&&(!r||le(r,i.marker)<0)&&(r=i.marker);return r}function ae(e){return se(e,!0)}function ue(e){return se(e,!1)}function ce(e,t,r,n,i){var o=M(e,t),l=_l&&o.markedSpans;if(l)for(var s=0;s<l.length;++s){var a=l[s];if(a.marker.collapsed){var u=a.marker.find(0),c=P(u.from,r)||ie(a.marker)-ie(i),f=P(u.to,n)||oe(a.marker)-oe(i);if(!(c>=0&&f<=0||c<=0&&f>=0)&&(c<=0&&(a.marker.inclusiveRight&&i.inclusiveLeft?P(u.to,r)>=0:P(u.to,r)>0)||c>=0&&(a.marker.inclusiveRight&&i.inclusiveLeft?P(u.from,n)<=0:P(u.from,n)<0)))return!0}}}function fe(e){for(var t;t=ae(e);)e=t.find(-1,!0).line;return e}function he(e){for(var t;t=ue(e);)e=t.find(1,!0).line;return e}function de(e){for(var t,r;t=ue(e);)e=t.find(1,!0).line,(r||(r=[])).push(e);return r}function pe(e,t){var r=M(e,t),n=fe(r);return r==n?t:W(n)}function ge(e,t){if(t>e.lastLine())return t;var r,n=M(e,t);if(!ve(e,n))return t;for(;r=ue(n);)n=r.find(1,!0).line;return W(n)+1}function ve(e,t){var r=_l&&t.markedSpans;if(r)for(var n=void 0,i=0;i<r.length;++i)if((n=r[i]).marker.collapsed){if(null==n.from)return!0;if(!n.marker.widgetNode&&0==n.from&&n.marker.inclusiveLeft&&me(e,t,n))return!0}}function me(e,t,r){if(null==r.to){var n=r.marker.find(1,!0);return me(e,n.line,_(n.line.markedSpans,r.marker))}if(r.marker.inclusiveRight&&r.to==t.text.length)return!0;for(var i=void 0,o=0;o<t.markedSpans.length;++o)if((i=t.markedSpans[o]).marker.collapsed&&!i.marker.widgetNode&&i.from==r.to&&(null==i.to||i.to!=r.from)&&(i.marker.inclusiveLeft||r.marker.inclusiveRight)&&me(e,t,i))return!0}function ye(e){for(var t=0,r=(e=fe(e)).parent,n=0;n<r.lines.length;++n){var i=r.lines[n];if(i==e)break;t+=i.height}for(var o=r.parent;o;r=o,o=r.parent)for(var l=0;l<o.children.length;++l){var s=o.children[l];if(s==r)break;t+=s.height}return t}function be(e){if(0==e.height)return 0;for(var t,r=e.text.length,n=e;t=ae(n);){var i=t.find(0,!0);n=i.from.line,r+=i.from.ch-i.to.ch}for(n=e;t=ue(n);){var o=t.find(0,!0);r-=n.text.length-o.from.ch,r+=(n=o.to.line).text.length-o.to.ch}return r}function we(e){var t=e.display,r=e.doc;t.maxLine=M(r,r.first),t.maxLineLength=be(t.maxLine),t.maxLineChanged=!0,r.iter(function(e){var r=be(e);r>t.maxLineLength&&(t.maxLineLength=r,t.maxLine=e)})}function xe(e,t,r,n){if(!e)return n(t,r,"ltr",0);for(var i=!1,o=0;o<e.length;++o){var l=e[o];(l.from<r&&l.to>t||t==r&&l.to==t)&&(n(Math.max(l.from,t),Math.min(l.to,r),1==l.level?"rtl":"ltr",o),i=!0)}i||n(t,r,"ltr")}function Ce(e,t,r){var n;$l=null;for(var i=0;i<e.length;++i){var o=e[i];if(o.from<t&&o.to>t)return i;o.to==t&&(o.from!=o.to&&"before"==r?n=i:$l=i),o.from==t&&(o.from!=o.to&&"before"!=r?n=i:$l=i)}return null!=n?n:$l}function Se(e,t){var r=e.order;return null==r&&(r=e.order=ql(e.text,t)),r}function Le(e,t){return e._handlers&&e._handlers[t]||Zl}function ke(e,t,r){if(e.removeEventListener)e.removeEventListener(t,r,!1);else if(e.detachEvent)e.detachEvent("on"+t,r);else{var n=e._handlers,i=n&&n[t];if(i){var o=h(i,r);o>-1&&(n[t]=i.slice(0,o).concat(i.slice(o+1)))}}}function Te(e,t){var r=Le(e,t);if(r.length)for(var n=Array.prototype.slice.call(arguments,2),i=0;i<r.length;++i)r[i].apply(null,n)}function Me(e,t,r){return"string"==typeof t&&(t={type:t,preventDefault:function(){this.defaultPrevented=!0}}),Te(e,r||t.type,e,t),He(t)||t.codemirrorIgnore}function Ne(e){var t=e._handlers&&e._handlers.cursorActivity;if(t)for(var r=e.curOp.cursorActivityHandlers||(e.curOp.cursorActivityHandlers=[]),n=0;n<t.length;++n)-1==h(r,t[n])&&r.push(t[n])}function Oe(e,t){return Le(e,t).length>0}function Ae(e){e.prototype.on=function(e,t){Ql(this,e,t)},e.prototype.off=function(e,t){ke(this,e,t)}}function We(e){e.preventDefault?e.preventDefault():e.returnValue=!1}function De(e){e.stopPropagation?e.stopPropagation():e.cancelBubble=!0}function He(e){return null!=e.defaultPrevented?e.defaultPrevented:0==e.returnValue}function Fe(e){We(e),De(e)}function Ee(e){return e.target||e.srcElement}function Pe(e){var t=e.which;return null==t&&(1&e.button?t=1:2&e.button?t=3:4&e.button&&(t=2)),Ml&&e.ctrlKey&&1==t&&(t=3),t}function Ie(e){if(null==Il){var t=n("span","​");r(e,n("span",[t,document.createTextNode("x")])),0!=e.firstChild.offsetHeight&&(Il=t.offsetWidth<=1&&t.offsetHeight>2&&!(gl&&vl<8))}var i=Il?n("span","​"):n("span"," ",null,"display: inline-block; width: 1px; margin-right: -1px");return i.setAttribute("cm-text",""),i}function ze(e){if(null!=zl)return zl;var n=r(e,document.createTextNode("AخA")),i=Wl(n,0,1).getBoundingClientRect(),o=Wl(n,1,2).getBoundingClientRect();return t(e),!(!i||i.left==i.right)&&(zl=o.right-i.right<3)}function Re(e){if(null!=ns)return ns;var t=r(e,n("span","x")),i=t.getBoundingClientRect(),o=Wl(t,0,1).getBoundingClientRect();return ns=Math.abs(i.left-o.left)>1}function Be(e,t){arguments.length>2&&(t.dependencies=Array.prototype.slice.call(arguments,2)),is[e]=t}function Ge(e){if("string"==typeof e&&os.hasOwnProperty(e))e=os[e];else if(e&&"string"==typeof e.name&&os.hasOwnProperty(e.name)){var t=os[e.name];"string"==typeof t&&(t={name:t}),(e=b(t,e)).name=t.name}else{if("string"==typeof e&&/^[\w\-]+\/[\w\-]+\+xml$/.test(e))return Ge("application/xml");if("string"==typeof e&&/^[\w\-]+\/[\w\-]+\+json$/.test(e))return Ge("application/json")}return"string"==typeof e?{name:e}:e||{name:"null"}}function Ue(e,t){t=Ge(t);var r=is[t.name];if(!r)return Ue(e,"text/plain");var n=r(e,t);if(ls.hasOwnProperty(t.name)){var i=ls[t.name];for(var o in i)i.hasOwnProperty(o)&&(n.hasOwnProperty(o)&&(n["_"+o]=n[o]),n[o]=i[o])}if(n.name=t.name,t.helperType&&(n.helperType=t.helperType),t.modeProps)for(var l in t.modeProps)n[l]=t.modeProps[l];return n}function Ve(e,t){c(t,ls.hasOwnProperty(e)?ls[e]:ls[e]={})}function Ke(e,t){if(!0===t)return t;if(e.copyState)return e.copyState(t);var r={};for(var n in t){var i=t[n];i instanceof Array&&(i=i.concat([])),r[n]=i}return r}function je(e,t){for(var r;e.innerMode&&(r=e.innerMode(t))&&r.mode!=e;)t=r.state,e=r.mode;return r||{mode:e,state:t}}function Xe(e,t,r){return!e.startState||e.startState(t,r)}function Ye(e,t,r,n){var i=[e.state.modeGen],o={};tt(e,t.text,e.doc.mode,r,function(e,t){return i.push(e,t)},o,n);for(var l=r.state,s=0;s<e.state.overlays.length;++s)!function(n){var l=e.state.overlays[n],s=1,a=0;r.state=!0,tt(e,t.text,l.mode,r,function(e,t){for(var r=s;a<e;){var n=i[s];n>e&&i.splice(s,1,e,i[s+1],n),s+=2,a=Math.min(e,n)}if(t)if(l.opaque)i.splice(r,s-r,e,"overlay "+t),s=r+2;else for(;r<s;r+=2){var o=i[r+1];i[r+1]=(o?o+" ":"")+"overlay "+t}},o)}(s);return r.state=l,{styles:i,classes:o.bgClass||o.textClass?o:null}}function _e(e,t,r){if(!t.styles||t.styles[0]!=e.state.modeGen){var n=$e(e,W(t)),i=t.text.length>e.options.maxHighlightLength&&Ke(e.doc.mode,n.state),o=Ye(e,t,n);i&&(n.state=i),t.stateAfter=n.save(!i),t.styles=o.styles,o.classes?t.styleClasses=o.classes:t.styleClasses&&(t.styleClasses=null),r===e.doc.highlightFrontier&&(e.doc.modeFrontier=Math.max(e.doc.modeFrontier,++e.doc.highlightFrontier))}return t.styles}function $e(e,t,r){var n=e.doc,i=e.display;if(!n.mode.startState)return new us(n,!0,t);var o=rt(e,t,r),l=o>n.first&&M(n,o-1).stateAfter,s=l?us.fromSaved(n,l,o):new us(n,Xe(n.mode),o);return n.iter(o,t,function(r){qe(e,r.text,s);var n=s.line;r.stateAfter=n==t-1||n%5==0||n>=i.viewFrom&&n<i.viewTo?s.save():null,s.nextLine()}),r&&(n.modeFrontier=s.line),s}function qe(e,t,r,n){var i=e.doc.mode,o=new ss(t,e.options.tabSize,r);for(o.start=o.pos=n||0,""==t&&Ze(i,r.state);!o.eol();)Qe(i,o,r.state),o.start=o.pos}function Ze(e,t){if(e.blankLine)return e.blankLine(t);if(e.innerMode){var r=je(e,t);return r.mode.blankLine?r.mode.blankLine(r.state):void 0}}function Qe(e,t,r,n){for(var i=0;i<10;i++){n&&(n[0]=je(e,r).mode);var o=e.token(t,r);if(t.pos>t.start)return o}throw new Error("Mode "+e.name+" failed to advance stream.")}function Je(e,t,r,n){var i,o,l=e.doc,s=l.mode,a=M(l,(t=U(l,t)).line),u=$e(e,t.line,r),c=new ss(a.text,e.options.tabSize,u);for(n&&(o=[]);(n||c.pos<t.ch)&&!c.eol();)c.start=c.pos,i=Qe(s,c,u.state),n&&o.push(new cs(c,i,Ke(l.mode,u.state)));return n?o:new cs(c,i,u.state)}function et(e,t){if(e)for(;;){var r=e.match(/(?:^|\s+)line-(background-)?(\S+)/);if(!r)break;e=e.slice(0,r.index)+e.slice(r.index+r[0].length);var n=r[1]?"bgClass":"textClass";null==t[n]?t[n]=r[2]:new RegExp("(?:^|s)"+r[2]+"(?:$|s)").test(t[n])||(t[n]+=" "+r[2])}return e}function tt(e,t,r,n,i,o,l){var s=r.flattenSpans;null==s&&(s=e.options.flattenSpans);var a,u=0,c=null,f=new ss(t,e.options.tabSize,n),h=e.options.addModeClass&&[null];for(""==t&&et(Ze(r,n.state),o);!f.eol();){if(f.pos>e.options.maxHighlightLength?(s=!1,l&&qe(e,t,n,f.pos),f.pos=t.length,a=null):a=et(Qe(r,f,n.state,h),o),h){var d=h[0].name;d&&(a="m-"+(a?d+" "+a:d))}if(!s||c!=a){for(;u<f.start;)i(u=Math.min(f.start,u+5e3),c);c=a}f.start=f.pos}for(;u<f.pos;){var p=Math.min(f.pos,u+5e3);i(p,c),u=p}}function rt(e,t,r){for(var n,i,o=e.doc,l=r?-1:t-(e.doc.mode.innerMode?1e3:100),s=t;s>l;--s){if(s<=o.first)return o.first;var a=M(o,s-1),u=a.stateAfter;if(u&&(!r||s+(u instanceof as?u.lookAhead:0)<=o.modeFrontier))return s;var c=f(a.text,null,e.options.tabSize);(null==i||n>c)&&(i=s-1,n=c)}return i}function nt(e,t){if(e.modeFrontier=Math.min(e.modeFrontier,t),!(e.highlightFrontier<t-10)){for(var r=e.first,n=t-1;n>r;n--){var i=M(e,n).stateAfter;if(i&&(!(i instanceof as)||n+i.lookAhead<t)){r=n+1;break}}e.highlightFrontier=Math.min(e.highlightFrontier,r)}}function it(e,t,r,n){e.text=t,e.stateAfter&&(e.stateAfter=null),e.styles&&(e.styles=null),null!=e.order&&(e.order=null),re(e),ne(e,r);var i=n?n(e):1;i!=e.height&&A(e,i)}function ot(e){e.parent=null,re(e)}function lt(e,t){if(!e||/^\s*$/.test(e))return null;var r=t.addModeClass?ps:ds;return r[e]||(r[e]=e.replace(/\S+/g,"cm-$&"))}function st(e,t){var r=i("span",null,null,ml?"padding-right: .1px":null),n={pre:i("pre",[r],"CodeMirror-line"),content:r,col:0,pos:0,cm:e,trailingSpace:!1,splitSpaces:(gl||ml)&&e.getOption("lineWrapping")};t.measure={};for(var o=0;o<=(t.rest?t.rest.length:0);o++){var l=o?t.rest[o-1]:t.line,s=void 0;n.pos=0,n.addToken=ut,ze(e.display.measure)&&(s=Se(l,e.doc.direction))&&(n.addToken=ft(n.addToken,s)),n.map=[],dt(l,n,_e(e,l,t!=e.display.externalMeasured&&W(l))),l.styleClasses&&(l.styleClasses.bgClass&&(n.bgClass=a(l.styleClasses.bgClass,n.bgClass||"")),l.styleClasses.textClass&&(n.textClass=a(l.styleClasses.textClass,n.textClass||""))),0==n.map.length&&n.map.push(0,0,n.content.appendChild(Ie(e.display.measure))),0==o?(t.measure.map=n.map,t.measure.cache={}):((t.measure.maps||(t.measure.maps=[])).push(n.map),(t.measure.caches||(t.measure.caches=[])).push({}))}if(ml){var u=n.content.lastChild;(/\bcm-tab\b/.test(u.className)||u.querySelector&&u.querySelector(".cm-tab"))&&(n.content.className="cm-tab-wrap-hack")}return Te(e,"renderLine",e,t.line,n.pre),n.pre.className&&(n.textClass=a(n.pre.className,n.textClass||"")),n}function at(e){var t=n("span","•","cm-invalidchar");return t.title="\\u"+e.charCodeAt(0).toString(16),t.setAttribute("aria-label",t.title),t}function ut(e,t,r,i,o,l,s){if(t){var a,u=e.splitSpaces?ct(t,e.trailingSpace):t,c=e.cm.state.specialChars,f=!1;if(c.test(t)){a=document.createDocumentFragment();for(var h=0;;){c.lastIndex=h;var d=c.exec(t),g=d?d.index-h:t.length-h;if(g){var v=document.createTextNode(u.slice(h,h+g));gl&&vl<9?a.appendChild(n("span",[v])):a.appendChild(v),e.map.push(e.pos,e.pos+g,v),e.col+=g,e.pos+=g}if(!d)break;h+=g+1;var m=void 0;if("\t"==d[0]){var y=e.cm.options.tabSize,b=y-e.col%y;(m=a.appendChild(n("span",p(b),"cm-tab"))).setAttribute("role","presentation"),m.setAttribute("cm-text","\t"),e.col+=b}else"\r"==d[0]||"\n"==d[0]?((m=a.appendChild(n("span","\r"==d[0]?"␍":"␤","cm-invalidchar"))).setAttribute("cm-text",d[0]),e.col+=1):((m=e.cm.options.specialCharPlaceholder(d[0])).setAttribute("cm-text",d[0]),gl&&vl<9?a.appendChild(n("span",[m])):a.appendChild(m),e.col+=1);e.map.push(e.pos,e.pos+1,m),e.pos++}}else e.col+=t.length,a=document.createTextNode(u),e.map.push(e.pos,e.pos+t.length,a),gl&&vl<9&&(f=!0),e.pos+=t.length;if(e.trailingSpace=32==u.charCodeAt(t.length-1),r||i||o||f||s){var w=r||"";i&&(w+=i),o&&(w+=o);var x=n("span",[a],w,s);return l&&(x.title=l),e.content.appendChild(x)}e.content.appendChild(a)}}function ct(e,t){if(e.length>1&&!/  /.test(e))return e;for(var r=t,n="",i=0;i<e.length;i++){var o=e.charAt(i);" "!=o||!r||i!=e.length-1&&32!=e.charCodeAt(i+1)||(o=" "),n+=o,r=" "==o}return n}function ft(e,t){return function(r,n,i,o,l,s,a){i=i?i+" cm-force-border":"cm-force-border";for(var u=r.pos,c=u+n.length;;){for(var f=void 0,h=0;h<t.length&&!((f=t[h]).to>u&&f.from<=u);h++);if(f.to>=c)return e(r,n,i,o,l,s,a);e(r,n.slice(0,f.to-u),i,o,null,s,a),o=null,n=n.slice(f.to-u),u=f.to}}}function ht(e,t,r,n){var i=!n&&r.widgetNode;i&&e.map.push(e.pos,e.pos+t,i),!n&&e.cm.display.input.needsContentAttribute&&(i||(i=e.content.appendChild(document.createElement("span"))),i.setAttribute("cm-marker",r.id)),i&&(e.cm.display.input.setUneditable(i),e.content.appendChild(i)),e.pos+=t,e.trailingSpace=!1}function dt(e,t,r){var n=e.markedSpans,i=e.text,o=0;if(n)for(var l,s,a,u,c,f,h,d=i.length,p=0,g=1,v="",m=0;;){if(m==p){a=u=c=f=s="",h=null,m=1/0;for(var y=[],b=void 0,w=0;w<n.length;++w){var x=n[w],C=x.marker;"bookmark"==C.type&&x.from==p&&C.widgetNode?y.push(C):x.from<=p&&(null==x.to||x.to>p||C.collapsed&&x.to==p&&x.from==p)?(null!=x.to&&x.to!=p&&m>x.to&&(m=x.to,u=""),C.className&&(a+=" "+C.className),C.css&&(s=(s?s+";":"")+C.css),C.startStyle&&x.from==p&&(c+=" "+C.startStyle),C.endStyle&&x.to==m&&(b||(b=[])).push(C.endStyle,x.to),C.title&&!f&&(f=C.title),C.collapsed&&(!h||le(h.marker,C)<0)&&(h=x)):x.from>p&&m>x.from&&(m=x.from)}if(b)for(var S=0;S<b.length;S+=2)b[S+1]==m&&(u+=" "+b[S]);if(!h||h.from==p)for(var L=0;L<y.length;++L)ht(t,0,y[L]);if(h&&(h.from||0)==p){if(ht(t,(null==h.to?d+1:h.to)-p,h.marker,null==h.from),null==h.to)return;h.to==p&&(h=!1)}}if(p>=d)break;for(var k=Math.min(d,m);;){if(v){var T=p+v.length;if(!h){var M=T>k?v.slice(0,k-p):v;t.addToken(t,M,l?l+a:a,c,p+M.length==m?u:"",f,s)}if(T>=k){v=v.slice(k-p),p=k;break}p=T,c=""}v=i.slice(o,o=r[g++]),l=lt(r[g++],t.cm.options)}}else for(var N=1;N<r.length;N+=2)t.addToken(t,i.slice(o,o=r[N]),lt(r[N+1],t.cm.options))}function pt(e,t,r){this.line=t,this.rest=de(t),this.size=this.rest?W(g(this.rest))-r+1:1,this.node=this.text=null,this.hidden=ve(e,t)}function gt(e,t,r){for(var n,i=[],o=t;o<r;o=n){var l=new pt(e.doc,M(e.doc,o),o);n=o+l.size,i.push(l)}return i}function vt(e){gs?gs.ops.push(e):e.ownsGroup=gs={ops:[e],delayedCallbacks:[]}}function mt(e){var t=e.delayedCallbacks,r=0;do{for(;r<t.length;r++)t[r].call(null);for(var n=0;n<e.ops.length;n++){var i=e.ops[n];if(i.cursorActivityHandlers)for(;i.cursorActivityCalled<i.cursorActivityHandlers.length;)i.cursorActivityHandlers[i.cursorActivityCalled++].call(null,i.cm)}}while(r<t.length)}function yt(e,t){var r=e.ownsGroup;if(r)try{mt(r)}finally{gs=null,t(r)}}function bt(e,t){var r=Le(e,t);if(r.length){var n,i=Array.prototype.slice.call(arguments,2);gs?n=gs.delayedCallbacks:vs?n=vs:(n=vs=[],setTimeout(wt,0));for(var o=0;o<r.length;++o)!function(e){n.push(function(){return r[e].apply(null,i)})}(o)}}function wt(){var e=vs;vs=null;for(var t=0;t<e.length;++t)e[t]()}function xt(e,t,r,n){for(var i=0;i<t.changes.length;i++){var o=t.changes[i];"text"==o?kt(e,t):"gutter"==o?Mt(e,t,r,n):"class"==o?Tt(e,t):"widget"==o&&Nt(e,t,n)}t.changes=null}function Ct(e){return e.node==e.text&&(e.node=n("div",null,null,"position: relative"),e.text.parentNode&&e.text.parentNode.replaceChild(e.node,e.text),e.node.appendChild(e.text),gl&&vl<8&&(e.node.style.zIndex=2)),e.node}function St(e,t){var r=t.bgClass?t.bgClass+" "+(t.line.bgClass||""):t.line.bgClass;if(r&&(r+=" CodeMirror-linebackground"),t.background)r?t.background.className=r:(t.background.parentNode.removeChild(t.background),t.background=null);else if(r){var i=Ct(t);t.background=i.insertBefore(n("div",null,r),i.firstChild),e.display.input.setUneditable(t.background)}}function Lt(e,t){var r=e.display.externalMeasured;return r&&r.line==t.line?(e.display.externalMeasured=null,t.measure=r.measure,r.built):st(e,t)}function kt(e,t){var r=t.text.className,n=Lt(e,t);t.text==t.node&&(t.node=n.pre),t.text.parentNode.replaceChild(n.pre,t.text),t.text=n.pre,n.bgClass!=t.bgClass||n.textClass!=t.textClass?(t.bgClass=n.bgClass,t.textClass=n.textClass,Tt(e,t)):r&&(t.text.className=r)}function Tt(e,t){St(e,t),t.line.wrapClass?Ct(t).className=t.line.wrapClass:t.node!=t.text&&(t.node.className="");var r=t.textClass?t.textClass+" "+(t.line.textClass||""):t.line.textClass;t.text.className=r||""}function Mt(e,t,r,i){if(t.gutter&&(t.node.removeChild(t.gutter),t.gutter=null),t.gutterBackground&&(t.node.removeChild(t.gutterBackground),t.gutterBackground=null),t.line.gutterClass){var o=Ct(t);t.gutterBackground=n("div",null,"CodeMirror-gutter-background "+t.line.gutterClass,"left: "+(e.options.fixedGutter?i.fixedPos:-i.gutterTotalWidth)+"px; width: "+i.gutterTotalWidth+"px"),e.display.input.setUneditable(t.gutterBackground),o.insertBefore(t.gutterBackground,t.text)}var l=t.line.gutterMarkers;if(e.options.lineNumbers||l){var s=Ct(t),a=t.gutter=n("div",null,"CodeMirror-gutter-wrapper","left: "+(e.options.fixedGutter?i.fixedPos:-i.gutterTotalWidth)+"px");if(e.display.input.setUneditable(a),s.insertBefore(a,t.text),t.line.gutterClass&&(a.className+=" "+t.line.gutterClass),!e.options.lineNumbers||l&&l["CodeMirror-linenumbers"]||(t.lineNumber=a.appendChild(n("div",F(e.options,r),"CodeMirror-linenumber CodeMirror-gutter-elt","left: "+i.gutterLeft["CodeMirror-linenumbers"]+"px; width: "+e.display.lineNumInnerWidth+"px"))),l)for(var u=0;u<e.options.gutters.length;++u){var c=e.options.gutters[u],f=l.hasOwnProperty(c)&&l[c];f&&a.appendChild(n("div",[f],"CodeMirror-gutter-elt","left: "+i.gutterLeft[c]+"px; width: "+i.gutterWidth[c]+"px"))}}}function Nt(e,t,r){t.alignable&&(t.alignable=null);for(var n=t.node.firstChild,i=void 0;n;n=i)i=n.nextSibling,"CodeMirror-linewidget"==n.className&&t.node.removeChild(n);At(e,t,r)}function Ot(e,t,r,n){var i=Lt(e,t);return t.text=t.node=i.pre,i.bgClass&&(t.bgClass=i.bgClass),i.textClass&&(t.textClass=i.textClass),Tt(e,t),Mt(e,t,r,n),At(e,t,n),t.node}function At(e,t,r){if(Wt(e,t.line,t,r,!0),t.rest)for(var n=0;n<t.rest.length;n++)Wt(e,t.rest[n],t,r,!1)}function Wt(e,t,r,i,o){if(t.widgets)for(var l=Ct(r),s=0,a=t.widgets;s<a.length;++s){var u=a[s],c=n("div",[u.node],"CodeMirror-linewidget");u.handleMouseEvents||c.setAttribute("cm-ignore-events","true"),Dt(u,c,r,i),e.display.input.setUneditable(c),o&&u.above?l.insertBefore(c,r.gutter||r.text):l.appendChild(c),bt(u,"redraw")}}function Dt(e,t,r,n){if(e.noHScroll){(r.alignable||(r.alignable=[])).push(t);var i=n.wrapperWidth;t.style.left=n.fixedPos+"px",e.coverGutter||(i-=n.gutterTotalWidth,t.style.paddingLeft=n.gutterTotalWidth+"px"),t.style.width=i+"px"}e.coverGutter&&(t.style.zIndex=5,t.style.position="relative",e.noHScroll||(t.style.marginLeft=-n.gutterTotalWidth+"px"))}function Ht(e){if(null!=e.height)return e.height;var t=e.doc.cm;if(!t)return 0;if(!o(document.body,e.node)){var i="position: relative;";e.coverGutter&&(i+="margin-left: -"+t.display.gutters.offsetWidth+"px;"),e.noHScroll&&(i+="width: "+t.display.wrapper.clientWidth+"px;"),r(t.display.measure,n("div",[e.node],null,i))}return e.height=e.node.parentNode.offsetHeight}function Ft(e,t){for(var r=Ee(t);r!=e.wrapper;r=r.parentNode)if(!r||1==r.nodeType&&"true"==r.getAttribute("cm-ignore-events")||r.parentNode==e.sizer&&r!=e.mover)return!0}function Et(e){return e.lineSpace.offsetTop}function Pt(e){return e.mover.offsetHeight-e.lineSpace.offsetHeight}function It(e){if(e.cachedPaddingH)return e.cachedPaddingH;var t=r(e.measure,n("pre","x")),i=window.getComputedStyle?window.getComputedStyle(t):t.currentStyle,o={left:parseInt(i.paddingLeft),right:parseInt(i.paddingRight)};return isNaN(o.left)||isNaN(o.right)||(e.cachedPaddingH=o),o}function zt(e){return Rl-e.display.nativeBarWidth}function Rt(e){return e.display.scroller.clientWidth-zt(e)-e.display.barWidth}function Bt(e){return e.display.scroller.clientHeight-zt(e)-e.display.barHeight}function Gt(e,t,r){var n=e.options.lineWrapping,i=n&&Rt(e);if(!t.measure.heights||n&&t.measure.width!=i){var o=t.measure.heights=[];if(n){t.measure.width=i;for(var l=t.text.firstChild.getClientRects(),s=0;s<l.length-1;s++){var a=l[s],u=l[s+1];Math.abs(a.bottom-u.bottom)>2&&o.push((a.bottom+u.top)/2-r.top)}}o.push(r.bottom-r.top)}}function Ut(e,t,r){if(e.line==t)return{map:e.measure.map,cache:e.measure.cache};for(var n=0;n<e.rest.length;n++)if(e.rest[n]==t)return{map:e.measure.maps[n],cache:e.measure.caches[n]};for(var i=0;i<e.rest.length;i++)if(W(e.rest[i])>r)return{map:e.measure.maps[i],cache:e.measure.caches[i],before:!0}}function Vt(e,t){var n=W(t=fe(t)),i=e.display.externalMeasured=new pt(e.doc,t,n);i.lineN=n;var o=i.built=st(e,i);return i.text=o.pre,r(e.display.lineMeasure,o.pre),i}function Kt(e,t,r,n){return Yt(e,Xt(e,t),r,n)}function jt(e,t){if(t>=e.display.viewFrom&&t<e.display.viewTo)return e.display.view[Lr(e,t)];var r=e.display.externalMeasured;return r&&t>=r.lineN&&t<r.lineN+r.size?r:void 0}function Xt(e,t){var r=W(t),n=jt(e,r);n&&!n.text?n=null:n&&n.changes&&(xt(e,n,r,br(e)),e.curOp.forceUpdate=!0),n||(n=Vt(e,t));var i=Ut(n,t,r);return{line:t,view:n,rect:null,map:i.map,cache:i.cache,before:i.before,hasHeights:!1}}function Yt(e,t,r,n,i){t.before&&(r=-1);var o,l=r+(n||"");return t.cache.hasOwnProperty(l)?o=t.cache[l]:(t.rect||(t.rect=t.view.text.getBoundingClientRect()),t.hasHeights||(Gt(e,t.view,t.rect),t.hasHeights=!0),(o=qt(e,t,r,n)).bogus||(t.cache[l]=o)),{left:o.left,right:o.right,top:i?o.rtop:o.top,bottom:i?o.rbottom:o.bottom}}function _t(e,t,r){for(var n,i,o,l,s,a,u=0;u<e.length;u+=3)if(s=e[u],a=e[u+1],t<s?(i=0,o=1,l="left"):t<a?o=(i=t-s)+1:(u==e.length-3||t==a&&e[u+3]>t)&&(i=(o=a-s)-1,t>=a&&(l="right")),null!=i){if(n=e[u+2],s==a&&r==(n.insertLeft?"left":"right")&&(l=r),"left"==r&&0==i)for(;u&&e[u-2]==e[u-3]&&e[u-1].insertLeft;)n=e[2+(u-=3)],l="left";if("right"==r&&i==a-s)for(;u<e.length-3&&e[u+3]==e[u+4]&&!e[u+5].insertLeft;)n=e[(u+=3)+2],l="right";break}return{node:n,start:i,end:o,collapse:l,coverStart:s,coverEnd:a}}function $t(e,t){var r=ms;if("left"==t)for(var n=0;n<e.length&&(r=e[n]).left==r.right;n++);else for(var i=e.length-1;i>=0&&(r=e[i]).left==r.right;i--);return r}function qt(e,t,r,n){var i,o=_t(t.map,r,n),l=o.node,s=o.start,a=o.end,u=o.collapse;if(3==l.nodeType){for(var c=0;c<4;c++){for(;s&&S(t.line.text.charAt(o.coverStart+s));)--s;for(;o.coverStart+a<o.coverEnd&&S(t.line.text.charAt(o.coverStart+a));)++a;if((i=gl&&vl<9&&0==s&&a==o.coverEnd-o.coverStart?l.parentNode.getBoundingClientRect():$t(Wl(l,s,a).getClientRects(),n)).left||i.right||0==s)break;a=s,s-=1,u="right"}gl&&vl<11&&(i=Zt(e.display.measure,i))}else{s>0&&(u=n="right");var f;i=e.options.lineWrapping&&(f=l.getClientRects()).length>1?f["right"==n?f.length-1:0]:l.getBoundingClientRect()}if(gl&&vl<9&&!s&&(!i||!i.left&&!i.right)){var h=l.parentNode.getClientRects()[0];i=h?{left:h.left,right:h.left+yr(e.display),top:h.top,bottom:h.bottom}:ms}for(var d=i.top-t.rect.top,p=i.bottom-t.rect.top,g=(d+p)/2,v=t.view.measure.heights,m=0;m<v.length-1&&!(g<v[m]);m++);var y=m?v[m-1]:0,b=v[m],w={left:("right"==u?i.right:i.left)-t.rect.left,right:("left"==u?i.left:i.right)-t.rect.left,top:y,bottom:b};return i.left||i.right||(w.bogus=!0),e.options.singleCursorHeightPerLine||(w.rtop=d,w.rbottom=p),w}function Zt(e,t){if(!window.screen||null==screen.logicalXDPI||screen.logicalXDPI==screen.deviceXDPI||!Re(e))return t;var r=screen.logicalXDPI/screen.deviceXDPI,n=screen.logicalYDPI/screen.deviceYDPI;return{left:t.left*r,right:t.right*r,top:t.top*n,bottom:t.bottom*n}}function Qt(e){if(e.measure&&(e.measure.cache={},e.measure.heights=null,e.rest))for(var t=0;t<e.rest.length;t++)e.measure.caches[t]={}}function Jt(e){e.display.externalMeasure=null,t(e.display.lineMeasure);for(var r=0;r<e.display.view.length;r++)Qt(e.display.view[r])}function er(e){Jt(e),e.display.cachedCharWidth=e.display.cachedTextHeight=e.display.cachedPaddingH=null,e.options.lineWrapping||(e.display.maxLineChanged=!0),e.display.lineNumChars=null}function tr(){return bl&&kl?-(document.body.getBoundingClientRect().left-parseInt(getComputedStyle(document.body).marginLeft)):window.pageXOffset||(document.documentElement||document.body).scrollLeft}function rr(){return bl&&kl?-(document.body.getBoundingClientRect().top-parseInt(getComputedStyle(document.body).marginTop)):window.pageYOffset||(document.documentElement||document.body).scrollTop}function nr(e){var t=0;if(e.widgets)for(var r=0;r<e.widgets.length;++r)e.widgets[r].above&&(t+=Ht(e.widgets[r]));return t}function ir(e,t,r,n,i){if(!i){var o=nr(t);r.top+=o,r.bottom+=o}if("line"==n)return r;n||(n="local");var l=ye(t);if("local"==n?l+=Et(e.display):l-=e.display.viewOffset,"page"==n||"window"==n){var s=e.display.lineSpace.getBoundingClientRect();l+=s.top+("window"==n?0:rr());var a=s.left+("window"==n?0:tr());r.left+=a,r.right+=a}return r.top+=l,r.bottom+=l,r}function or(e,t,r){if("div"==r)return t;var n=t.left,i=t.top;if("page"==r)n-=tr(),i-=rr();else if("local"==r||!r){var o=e.display.sizer.getBoundingClientRect();n+=o.left,i+=o.top}var l=e.display.lineSpace.getBoundingClientRect();return{left:n-l.left,top:i-l.top}}function lr(e,t,r,n,i){return n||(n=M(e.doc,t.line)),ir(e,n,Kt(e,n,t.ch,i),r)}function sr(e,t,r,n,i,o){function l(t,l){var s=Yt(e,i,t,l?"right":"left",o);return l?s.left=s.right:s.right=s.left,ir(e,n,s,r)}function s(e,t,r){var n=1==a[t].level;return l(r?e-1:e,n!=r)}n=n||M(e.doc,t.line),i||(i=Xt(e,n));var a=Se(n,e.doc.direction),u=t.ch,c=t.sticky;if(u>=n.text.length?(u=n.text.length,c="before"):u<=0&&(u=0,c="after"),!a)return l("before"==c?u-1:u,"before"==c);var f=Ce(a,u,c),h=$l,d=s(u,f,"before"==c);return null!=h&&(d.other=s(u,h,"before"!=c)),d}function ar(e,t){var r=0;t=U(e.doc,t),e.options.lineWrapping||(r=yr(e.display)*t.ch);var n=M(e.doc,t.line),i=ye(n)+Et(e.display);return{left:r,right:r,top:i,bottom:i+n.height}}function ur(e,t,r,n,i){var o=E(e,t,r);return o.xRel=i,n&&(o.outside=!0),o}function cr(e,t,r){var n=e.doc;if((r+=e.display.viewOffset)<0)return ur(n.first,0,null,!0,-1);var i=D(n,r),o=n.first+n.size-1;if(i>o)return ur(n.first+n.size-1,M(n,o).text.length,null,!0,1);t<0&&(t=0);for(var l=M(n,i);;){var s=pr(e,l,i,t,r),a=ue(l),u=a&&a.find(0,!0);if(!a||!(s.ch>u.from.ch||s.ch==u.from.ch&&s.xRel>0))return s;i=W(l=u.to.line)}}function fr(e,t,r,n){n-=nr(t);var i=t.text.length,o=k(function(t){return Yt(e,r,t-1).bottom<=n},i,0);return i=k(function(t){return Yt(e,r,t).top>n},o,i),{begin:o,end:i}}function hr(e,t,r,n){return r||(r=Xt(e,t)),fr(e,t,r,ir(e,t,Yt(e,r,n),"line").top)}function dr(e,t,r,n){return!(e.bottom<=r)&&(e.top>r||(n?e.left:e.right)>t)}function pr(e,t,r,n,i){i-=ye(t);var o=Xt(e,t),l=nr(t),s=0,a=t.text.length,u=!0,c=Se(t,e.doc.direction);if(c){var f=(e.options.lineWrapping?vr:gr)(e,t,r,o,c,n,i);s=(u=1!=f.level)?f.from:f.to-1,a=u?f.to:f.from-1}var h,d,p=null,g=null,v=k(function(t){var r=Yt(e,o,t);return r.top+=l,r.bottom+=l,!!dr(r,n,i,!1)&&(r.top<=i&&r.left<=n&&(p=t,g=r),!0)},s,a),m=!1;if(g){var y=n-g.left<g.right-n,b=y==u;v=p+(b?0:1),d=b?"after":"before",h=y?g.left:g.right}else{u||v!=a&&v!=s||v++,d=0==v?"after":v==t.text.length?"before":Yt(e,o,v-(u?1:0)).bottom+l<=i==u?"after":"before";var w=sr(e,E(r,v,d),"line",t,o);h=w.left,m=i<w.top||i>=w.bottom}return v=L(t.text,v,1),ur(r,v,d,m,n-h)}function gr(e,t,r,n,i,o,l){var s=k(function(s){var a=i[s],u=1!=a.level;return dr(sr(e,E(r,u?a.to:a.from,u?"before":"after"),"line",t,n),o,l,!0)},0,i.length-1),a=i[s];if(s>0){var u=1!=a.level,c=sr(e,E(r,u?a.from:a.to,u?"after":"before"),"line",t,n);dr(c,o,l,!0)&&c.top>l&&(a=i[s-1])}return a}function vr(e,t,r,n,i,o,l){for(var s=fr(e,t,n,l),a=s.begin,u=s.end,c=null,f=null,h=0;h<i.length;h++){var d=i[h];if(!(d.from>=u||d.to<=a)){var p=Yt(e,n,1!=d.level?Math.min(u,d.to)-1:Math.max(a,d.from)).right,g=p<o?o-p+1e9:p-o;(!c||f>g)&&(c=d,f=g)}}return c||(c=i[i.length-1]),c.from<a&&(c={from:a,to:c.to,level:c.level}),c.to>u&&(c={from:c.from,to:u,level:c.level}),c}function mr(e){if(null!=e.cachedTextHeight)return e.cachedTextHeight;if(null==hs){hs=n("pre");for(var i=0;i<49;++i)hs.appendChild(document.createTextNode("x")),hs.appendChild(n("br"));hs.appendChild(document.createTextNode("x"))}r(e.measure,hs);var o=hs.offsetHeight/50;return o>3&&(e.cachedTextHeight=o),t(e.measure),o||1}function yr(e){if(null!=e.cachedCharWidth)return e.cachedCharWidth;var t=n("span","xxxxxxxxxx"),i=n("pre",[t]);r(e.measure,i);var o=t.getBoundingClientRect(),l=(o.right-o.left)/10;return l>2&&(e.cachedCharWidth=l),l||10}function br(e){for(var t=e.display,r={},n={},i=t.gutters.clientLeft,o=t.gutters.firstChild,l=0;o;o=o.nextSibling,++l)r[e.options.gutters[l]]=o.offsetLeft+o.clientLeft+i,n[e.options.gutters[l]]=o.clientWidth;return{fixedPos:wr(t),gutterTotalWidth:t.gutters.offsetWidth,gutterLeft:r,gutterWidth:n,wrapperWidth:t.wrapper.clientWidth}}function wr(e){return e.scroller.getBoundingClientRect().left-e.sizer.getBoundingClientRect().left}function xr(e){var t=mr(e.display),r=e.options.lineWrapping,n=r&&Math.max(5,e.display.scroller.clientWidth/yr(e.display)-3);return function(i){if(ve(e.doc,i))return 0;var o=0;if(i.widgets)for(var l=0;l<i.widgets.length;l++)i.widgets[l].height&&(o+=i.widgets[l].height);return r?o+(Math.ceil(i.text.length/n)||1)*t:o+t}}function Cr(e){var t=e.doc,r=xr(e);t.iter(function(e){var t=r(e);t!=e.height&&A(e,t)})}function Sr(e,t,r,n){var i=e.display;if(!r&&"true"==Ee(t).getAttribute("cm-not-content"))return null;var o,l,s=i.lineSpace.getBoundingClientRect();try{o=t.clientX-s.left,l=t.clientY-s.top}catch(t){return null}var a,u=cr(e,o,l);if(n&&1==u.xRel&&(a=M(e.doc,u.line).text).length==u.ch){var c=f(a,a.length,e.options.tabSize)-a.length;u=E(u.line,Math.max(0,Math.round((o-It(e.display).left)/yr(e.display))-c))}return u}function Lr(e,t){if(t>=e.display.viewTo)return null;if((t-=e.display.viewFrom)<0)return null;for(var r=e.display.view,n=0;n<r.length;n++)if((t-=r[n].size)<0)return n}function kr(e){e.display.input.showSelection(e.display.input.prepareSelection())}function Tr(e,t){void 0===t&&(t=!0);for(var r=e.doc,n={},i=n.cursors=document.createDocumentFragment(),o=n.selection=document.createDocumentFragment(),l=0;l<r.sel.ranges.length;l++)if(t||l!=r.sel.primIndex){var s=r.sel.ranges[l];if(!(s.from().line>=e.display.viewTo||s.to().line<e.display.viewFrom)){var a=s.empty();(a||e.options.showCursorWhenSelecting)&&Mr(e,s.head,i),a||Or(e,s,o)}}return n}function Mr(e,t,r){var i=sr(e,t,"div",null,null,!e.options.singleCursorHeightPerLine),o=r.appendChild(n("div"," ","CodeMirror-cursor"));if(o.style.left=i.left+"px",o.style.top=i.top+"px",o.style.height=Math.max(0,i.bottom-i.top)*e.options.cursorHeight+"px",i.other){var l=r.appendChild(n("div"," ","CodeMirror-cursor CodeMirror-secondarycursor"));l.style.display="",l.style.left=i.other.left+"px",l.style.top=i.other.top+"px",l.style.height=.85*(i.other.bottom-i.other.top)+"px"}}function Nr(e,t){return e.top-t.top||e.left-t.left}function Or(e,t,r){function i(e,t,r,i){t<0&&(t=0),t=Math.round(t),i=Math.round(i),a.appendChild(n("div",null,"CodeMirror-selected","position: absolute; left: "+e+"px;\n                             top: "+t+"px; width: "+(null==r?f-e:r)+"px;\n                             height: "+(i-t)+"px"))}function o(t,r,n){function o(r,n){return lr(e,E(t,r),"div",u,n)}var l,a,u=M(s,t),h=u.text.length,d=Se(u,s.direction);return xe(d,r||0,null==n?h:n,function(t,s,p,g){var v=o(t,"ltr"==p?"left":"right"),m=o(s-1,"ltr"==p?"right":"left");if("ltr"==p){var y=null==r&&0==t?c:v.left,b=null==n&&s==h?f:m.right;m.top-v.top<=3?i(y,m.top,b-y,m.bottom):(i(y,v.top,null,v.bottom),v.bottom<m.top&&i(c,v.bottom,null,m.top),i(c,m.top,m.right,m.bottom))}else if(t<s){var w=null==r&&0==t?f:v.right,x=null==n&&s==h?c:m.left;if(m.top-v.top<=3)i(x,m.top,w-x,m.bottom);else{var C=c;if(g){var S=hr(e,u,null,t).end;C=o(S-(/\s/.test(u.text.charAt(S-1))?2:1),"left").left}i(C,v.top,w-C,v.bottom),v.bottom<m.top&&i(c,v.bottom,null,m.top);var L=null;d.length,L=o(hr(e,u,null,s).begin,"right").right-x,i(x,m.top,L,m.bottom)}}(!l||Nr(v,l)<0)&&(l=v),Nr(m,l)<0&&(l=m),(!a||Nr(v,a)<0)&&(a=v),Nr(m,a)<0&&(a=m)}),{start:l,end:a}}var l=e.display,s=e.doc,a=document.createDocumentFragment(),u=It(e.display),c=u.left,f=Math.max(l.sizerWidth,Rt(e)-l.sizer.offsetLeft)-u.right,h=t.from(),d=t.to();if(h.line==d.line)o(h.line,h.ch,d.ch);else{var p=M(s,h.line),g=M(s,d.line),v=fe(p)==fe(g),m=o(h.line,h.ch,v?p.text.length+1:null).end,y=o(d.line,v?0:null,d.ch).start;v&&(m.top<y.top-2?(i(m.right,m.top,null,m.bottom),i(c,y.top,y.left,y.bottom)):i(m.right,m.top,y.left-m.right,m.bottom)),m.bottom<y.top&&i(c,m.bottom,null,y.top)}r.appendChild(a)}function Ar(e){if(e.state.focused){var t=e.display;clearInterval(t.blinker);var r=!0;t.cursorDiv.style.visibility="",e.options.cursorBlinkRate>0?t.blinker=setInterval(function(){return t.cursorDiv.style.visibility=(r=!r)?"":"hidden"},e.options.cursorBlinkRate):e.options.cursorBlinkRate<0&&(t.cursorDiv.style.visibility="hidden")}}function Wr(e){e.state.focused||(e.display.input.focus(),Hr(e))}function Dr(e){e.state.delayingBlurEvent=!0,setTimeout(function(){e.state.delayingBlurEvent&&(e.state.delayingBlurEvent=!1,Fr(e))},100)}function Hr(e,t){e.state.delayingBlurEvent&&(e.state.delayingBlurEvent=!1),"nocursor"!=e.options.readOnly&&(e.state.focused||(Te(e,"focus",e,t),e.state.focused=!0,s(e.display.wrapper,"CodeMirror-focused"),e.curOp||e.display.selForContextMenu==e.doc.sel||(e.display.input.reset(),ml&&setTimeout(function(){return e.display.input.reset(!0)},20)),e.display.input.receivedFocus()),Ar(e))}function Fr(e,t){e.state.delayingBlurEvent||(e.state.focused&&(Te(e,"blur",e,t),e.state.focused=!1,Fl(e.display.wrapper,"CodeMirror-focused")),clearInterval(e.display.blinker),setTimeout(function(){e.state.focused||(e.display.shift=!1)},150))}function Er(e){for(var t=e.display,r=t.lineDiv.offsetTop,n=0;n<t.view.length;n++){var i=t.view[n],o=void 0;if(!i.hidden){if(gl&&vl<8){var l=i.node.offsetTop+i.node.offsetHeight;o=l-r,r=l}else{var s=i.node.getBoundingClientRect();o=s.bottom-s.top}var a=i.line.height-o;if(o<2&&(o=mr(t)),(a>.005||a<-.005)&&(A(i.line,o),Pr(i.line),i.rest))for(var u=0;u<i.rest.length;u++)Pr(i.rest[u])}}}function Pr(e){if(e.widgets)for(var t=0;t<e.widgets.length;++t)e.widgets[t].height=e.widgets[t].node.parentNode.offsetHeight}function Ir(e,t,r){var n=r&&null!=r.top?Math.max(0,r.top):e.scroller.scrollTop;n=Math.floor(n-Et(e));var i=r&&null!=r.bottom?r.bottom:n+e.wrapper.clientHeight,o=D(t,n),l=D(t,i);if(r&&r.ensure){var s=r.ensure.from.line,a=r.ensure.to.line;s<o?(o=s,l=D(t,ye(M(t,s))+e.wrapper.clientHeight)):Math.min(a,t.lastLine())>=l&&(o=D(t,ye(M(t,a))-e.wrapper.clientHeight),l=a)}return{from:o,to:Math.max(l,o+1)}}function zr(e){var t=e.display,r=t.view;if(t.alignWidgets||t.gutters.firstChild&&e.options.fixedGutter){for(var n=wr(t)-t.scroller.scrollLeft+e.doc.scrollLeft,i=t.gutters.offsetWidth,o=n+"px",l=0;l<r.length;l++)if(!r[l].hidden){e.options.fixedGutter&&(r[l].gutter&&(r[l].gutter.style.left=o),r[l].gutterBackground&&(r[l].gutterBackground.style.left=o));var s=r[l].alignable;if(s)for(var a=0;a<s.length;a++)s[a].style.left=o}e.options.fixedGutter&&(t.gutters.style.left=n+i+"px")}}function Rr(e){if(!e.options.lineNumbers)return!1;var t=e.doc,r=F(e.options,t.first+t.size-1),i=e.display;if(r.length!=i.lineNumChars){var o=i.measure.appendChild(n("div",[n("div",r)],"CodeMirror-linenumber CodeMirror-gutter-elt")),l=o.firstChild.offsetWidth,s=o.offsetWidth-l;return i.lineGutter.style.width="",i.lineNumInnerWidth=Math.max(l,i.lineGutter.offsetWidth-s)+1,i.lineNumWidth=i.lineNumInnerWidth+s,i.lineNumChars=i.lineNumInnerWidth?r.length:-1,i.lineGutter.style.width=i.lineNumWidth+"px",Wn(e),!0}return!1}function Br(e,t){if(!Me(e,"scrollCursorIntoView")){var r=e.display,i=r.sizer.getBoundingClientRect(),o=null;if(t.top+i.top<0?o=!0:t.bottom+i.top>(window.innerHeight||document.documentElement.clientHeight)&&(o=!1),null!=o&&!Sl){var l=n("div","​",null,"position: absolute;\n                         top: "+(t.top-r.viewOffset-Et(e.display))+"px;\n                         height: "+(t.bottom-t.top+zt(e)+r.barHeight)+"px;\n                         left: "+t.left+"px; width: "+Math.max(2,t.right-t.left)+"px;");e.display.lineSpace.appendChild(l),l.scrollIntoView(o),e.display.lineSpace.removeChild(l)}}}function Gr(e,t,r,n){null==n&&(n=0);var i;e.options.lineWrapping||t!=r||(r="before"==(t=t.ch?E(t.line,"before"==t.sticky?t.ch-1:t.ch,"after"):t).sticky?E(t.line,t.ch+1,"before"):t);for(var o=0;o<5;o++){var l=!1,s=sr(e,t),a=r&&r!=t?sr(e,r):s,u=Vr(e,i={left:Math.min(s.left,a.left),top:Math.min(s.top,a.top)-n,right:Math.max(s.left,a.left),bottom:Math.max(s.bottom,a.bottom)+n}),c=e.doc.scrollTop,f=e.doc.scrollLeft;if(null!=u.scrollTop&&(qr(e,u.scrollTop),Math.abs(e.doc.scrollTop-c)>1&&(l=!0)),null!=u.scrollLeft&&(Qr(e,u.scrollLeft),Math.abs(e.doc.scrollLeft-f)>1&&(l=!0)),!l)break}return i}function Ur(e,t){var r=Vr(e,t);null!=r.scrollTop&&qr(e,r.scrollTop),null!=r.scrollLeft&&Qr(e,r.scrollLeft)}function Vr(e,t){var r=e.display,n=mr(e.display);t.top<0&&(t.top=0);var i=e.curOp&&null!=e.curOp.scrollTop?e.curOp.scrollTop:r.scroller.scrollTop,o=Bt(e),l={};t.bottom-t.top>o&&(t.bottom=t.top+o);var s=e.doc.height+Pt(r),a=t.top<n,u=t.bottom>s-n;if(t.top<i)l.scrollTop=a?0:t.top;else if(t.bottom>i+o){var c=Math.min(t.top,(u?s:t.bottom)-o);c!=i&&(l.scrollTop=c)}var f=e.curOp&&null!=e.curOp.scrollLeft?e.curOp.scrollLeft:r.scroller.scrollLeft,h=Rt(e)-(e.options.fixedGutter?r.gutters.offsetWidth:0),d=t.right-t.left>h;return d&&(t.right=t.left+h),t.left<10?l.scrollLeft=0:t.left<f?l.scrollLeft=Math.max(0,t.left-(d?0:10)):t.right>h+f-3&&(l.scrollLeft=t.right+(d?0:10)-h),l}function Kr(e,t){null!=t&&(_r(e),e.curOp.scrollTop=(null==e.curOp.scrollTop?e.doc.scrollTop:e.curOp.scrollTop)+t)}function jr(e){_r(e);var t=e.getCursor();e.curOp.scrollToPos={from:t,to:t,margin:e.options.cursorScrollMargin}}function Xr(e,t,r){null==t&&null==r||_r(e),null!=t&&(e.curOp.scrollLeft=t),null!=r&&(e.curOp.scrollTop=r)}function Yr(e,t){_r(e),e.curOp.scrollToPos=t}function _r(e){var t=e.curOp.scrollToPos;t&&(e.curOp.scrollToPos=null,$r(e,ar(e,t.from),ar(e,t.to),t.margin))}function $r(e,t,r,n){var i=Vr(e,{left:Math.min(t.left,r.left),top:Math.min(t.top,r.top)-n,right:Math.max(t.right,r.right),bottom:Math.max(t.bottom,r.bottom)+n});Xr(e,i.scrollLeft,i.scrollTop)}function qr(e,t){Math.abs(e.doc.scrollTop-t)<2||(fl||On(e,{top:t}),Zr(e,t,!0),fl&&On(e),Cn(e,100))}function Zr(e,t,r){t=Math.min(e.display.scroller.scrollHeight-e.display.scroller.clientHeight,t),(e.display.scroller.scrollTop!=t||r)&&(e.doc.scrollTop=t,e.display.scrollbars.setScrollTop(t),e.display.scroller.scrollTop!=t&&(e.display.scroller.scrollTop=t))}function Qr(e,t,r,n){t=Math.min(t,e.display.scroller.scrollWidth-e.display.scroller.clientWidth),(r?t==e.doc.scrollLeft:Math.abs(e.doc.scrollLeft-t)<2)&&!n||(e.doc.scrollLeft=t,zr(e),e.display.scroller.scrollLeft!=t&&(e.display.scroller.scrollLeft=t),e.display.scrollbars.setScrollLeft(t))}function Jr(e){var t=e.display,r=t.gutters.offsetWidth,n=Math.round(e.doc.height+Pt(e.display));return{clientHeight:t.scroller.clientHeight,viewHeight:t.wrapper.clientHeight,scrollWidth:t.scroller.scrollWidth,clientWidth:t.scroller.clientWidth,viewWidth:t.wrapper.clientWidth,barLeft:e.options.fixedGutter?r:0,docHeight:n,scrollHeight:n+zt(e)+t.barHeight,nativeBarWidth:t.nativeBarWidth,gutterWidth:r}}function en(e,t){t||(t=Jr(e));var r=e.display.barWidth,n=e.display.barHeight;tn(e,t);for(var i=0;i<4&&r!=e.display.barWidth||n!=e.display.barHeight;i++)r!=e.display.barWidth&&e.options.lineWrapping&&Er(e),tn(e,Jr(e)),r=e.display.barWidth,n=e.display.barHeight}function tn(e,t){var r=e.display,n=r.scrollbars.update(t);r.sizer.style.paddingRight=(r.barWidth=n.right)+"px",r.sizer.style.paddingBottom=(r.barHeight=n.bottom)+"px",r.heightForcer.style.borderBottom=n.bottom+"px solid transparent",n.right&&n.bottom?(r.scrollbarFiller.style.display="block",r.scrollbarFiller.style.height=n.bottom+"px",r.scrollbarFiller.style.width=n.right+"px"):r.scrollbarFiller.style.display="",n.bottom&&e.options.coverGutterNextToScrollbar&&e.options.fixedGutter?(r.gutterFiller.style.display="block",r.gutterFiller.style.height=n.bottom+"px",r.gutterFiller.style.width=t.gutterWidth+"px"):r.gutterFiller.style.display=""}function rn(e){e.display.scrollbars&&(e.display.scrollbars.clear(),e.display.scrollbars.addClass&&Fl(e.display.wrapper,e.display.scrollbars.addClass)),e.display.scrollbars=new ws[e.options.scrollbarStyle](function(t){e.display.wrapper.insertBefore(t,e.display.scrollbarFiller),Ql(t,"mousedown",function(){e.state.focused&&setTimeout(function(){return e.display.input.focus()},0)}),t.setAttribute("cm-not-content","true")},function(t,r){"horizontal"==r?Qr(e,t):qr(e,t)},e),e.display.scrollbars.addClass&&s(e.display.wrapper,e.display.scrollbars.addClass)}function nn(e){e.curOp={cm:e,viewChanged:!1,startHeight:e.doc.height,forceUpdate:!1,updateInput:null,typing:!1,changeObjs:null,cursorActivityHandlers:null,cursorActivityCalled:0,selectionChanged:!1,updateMaxLine:!1,scrollLeft:null,scrollTop:null,scrollToPos:null,focus:!1,id:++xs},vt(e.curOp)}function on(e){yt(e.curOp,function(e){for(var t=0;t<e.ops.length;t++)e.ops[t].cm.curOp=null;ln(e)})}function ln(e){for(var t=e.ops,r=0;r<t.length;r++)sn(t[r]);for(var n=0;n<t.length;n++)an(t[n]);for(var i=0;i<t.length;i++)un(t[i]);for(var o=0;o<t.length;o++)cn(t[o]);for(var l=0;l<t.length;l++)fn(t[l])}function sn(e){var t=e.cm,r=t.display;Ln(t),e.updateMaxLine&&we(t),e.mustUpdate=e.viewChanged||e.forceUpdate||null!=e.scrollTop||e.scrollToPos&&(e.scrollToPos.from.line<r.viewFrom||e.scrollToPos.to.line>=r.viewTo)||r.maxLineChanged&&t.options.lineWrapping,e.update=e.mustUpdate&&new Cs(t,e.mustUpdate&&{top:e.scrollTop,ensure:e.scrollToPos},e.forceUpdate)}function an(e){e.updatedDisplay=e.mustUpdate&&Mn(e.cm,e.update)}function un(e){var t=e.cm,r=t.display;e.updatedDisplay&&Er(t),e.barMeasure=Jr(t),r.maxLineChanged&&!t.options.lineWrapping&&(e.adjustWidthTo=Kt(t,r.maxLine,r.maxLine.text.length).left+3,t.display.sizerWidth=e.adjustWidthTo,e.barMeasure.scrollWidth=Math.max(r.scroller.clientWidth,r.sizer.offsetLeft+e.adjustWidthTo+zt(t)+t.display.barWidth),e.maxScrollLeft=Math.max(0,r.sizer.offsetLeft+e.adjustWidthTo-Rt(t))),(e.updatedDisplay||e.selectionChanged)&&(e.preparedSelection=r.input.prepareSelection())}function cn(e){var t=e.cm;null!=e.adjustWidthTo&&(t.display.sizer.style.minWidth=e.adjustWidthTo+"px",e.maxScrollLeft<t.doc.scrollLeft&&Qr(t,Math.min(t.display.scroller.scrollLeft,e.maxScrollLeft),!0),t.display.maxLineChanged=!1);var r=e.focus&&e.focus==l();e.preparedSelection&&t.display.input.showSelection(e.preparedSelection,r),(e.updatedDisplay||e.startHeight!=t.doc.height)&&en(t,e.barMeasure),e.updatedDisplay&&Dn(t,e.barMeasure),e.selectionChanged&&Ar(t),t.state.focused&&e.updateInput&&t.display.input.reset(e.typing),r&&Wr(e.cm)}function fn(e){var t=e.cm,r=t.display,n=t.doc;e.updatedDisplay&&Nn(t,e.update),null==r.wheelStartX||null==e.scrollTop&&null==e.scrollLeft&&!e.scrollToPos||(r.wheelStartX=r.wheelStartY=null),null!=e.scrollTop&&Zr(t,e.scrollTop,e.forceScroll),null!=e.scrollLeft&&Qr(t,e.scrollLeft,!0,!0),e.scrollToPos&&Br(t,Gr(t,U(n,e.scrollToPos.from),U(n,e.scrollToPos.to),e.scrollToPos.margin));var i=e.maybeHiddenMarkers,o=e.maybeUnhiddenMarkers;if(i)for(var l=0;l<i.length;++l)i[l].lines.length||Te(i[l],"hide");if(o)for(var s=0;s<o.length;++s)o[s].lines.length&&Te(o[s],"unhide");r.wrapper.offsetHeight&&(n.scrollTop=t.display.scroller.scrollTop),e.changeObjs&&Te(t,"changes",t,e.changeObjs),e.update&&e.update.finish()}function hn(e,t){if(e.curOp)return t();nn(e);try{return t()}finally{on(e)}}function dn(e,t){return function(){if(e.curOp)return t.apply(e,arguments);nn(e);try{return t.apply(e,arguments)}finally{on(e)}}}function pn(e){return function(){if(this.curOp)return e.apply(this,arguments);nn(this);try{return e.apply(this,arguments)}finally{on(this)}}}function gn(e){return function(){var t=this.cm;if(!t||t.curOp)return e.apply(this,arguments);nn(t);try{return e.apply(this,arguments)}finally{on(t)}}}function vn(e,t,r,n){null==t&&(t=e.doc.first),null==r&&(r=e.doc.first+e.doc.size),n||(n=0);var i=e.display;if(n&&r<i.viewTo&&(null==i.updateLineNumbers||i.updateLineNumbers>t)&&(i.updateLineNumbers=t),e.curOp.viewChanged=!0,t>=i.viewTo)_l&&pe(e.doc,t)<i.viewTo&&yn(e);else if(r<=i.viewFrom)_l&&ge(e.doc,r+n)>i.viewFrom?yn(e):(i.viewFrom+=n,i.viewTo+=n);else if(t<=i.viewFrom&&r>=i.viewTo)yn(e);else if(t<=i.viewFrom){var o=bn(e,r,r+n,1);o?(i.view=i.view.slice(o.index),i.viewFrom=o.lineN,i.viewTo+=n):yn(e)}else if(r>=i.viewTo){var l=bn(e,t,t,-1);l?(i.view=i.view.slice(0,l.index),i.viewTo=l.lineN):yn(e)}else{var s=bn(e,t,t,-1),a=bn(e,r,r+n,1);s&&a?(i.view=i.view.slice(0,s.index).concat(gt(e,s.lineN,a.lineN)).concat(i.view.slice(a.index)),i.viewTo+=n):yn(e)}var u=i.externalMeasured;u&&(r<u.lineN?u.lineN+=n:t<u.lineN+u.size&&(i.externalMeasured=null))}function mn(e,t,r){e.curOp.viewChanged=!0;var n=e.display,i=e.display.externalMeasured;if(i&&t>=i.lineN&&t<i.lineN+i.size&&(n.externalMeasured=null),!(t<n.viewFrom||t>=n.viewTo)){var o=n.view[Lr(e,t)];if(null!=o.node){var l=o.changes||(o.changes=[]);-1==h(l,r)&&l.push(r)}}}function yn(e){e.display.viewFrom=e.display.viewTo=e.doc.first,e.display.view=[],e.display.viewOffset=0}function bn(e,t,r,n){var i,o=Lr(e,t),l=e.display.view;if(!_l||r==e.doc.first+e.doc.size)return{index:o,lineN:r};for(var s=e.display.viewFrom,a=0;a<o;a++)s+=l[a].size;if(s!=t){if(n>0){if(o==l.length-1)return null;i=s+l[o].size-t,o++}else i=s-t;t+=i,r+=i}for(;pe(e.doc,r)!=r;){if(o==(n<0?0:l.length-1))return null;r+=n*l[o-(n<0?1:0)].size,o+=n}return{index:o,lineN:r}}function wn(e,t,r){var n=e.display;0==n.view.length||t>=n.viewTo||r<=n.viewFrom?(n.view=gt(e,t,r),n.viewFrom=t):(n.viewFrom>t?n.view=gt(e,t,n.viewFrom).concat(n.view):n.viewFrom<t&&(n.view=n.view.slice(Lr(e,t))),n.viewFrom=t,n.viewTo<r?n.view=n.view.concat(gt(e,n.viewTo,r)):n.viewTo>r&&(n.view=n.view.slice(0,Lr(e,r)))),n.viewTo=r}function xn(e){for(var t=e.display.view,r=0,n=0;n<t.length;n++){var i=t[n];i.hidden||i.node&&!i.changes||++r}return r}function Cn(e,t){e.doc.highlightFrontier<e.display.viewTo&&e.state.highlight.set(t,u(Sn,e))}function Sn(e){var t=e.doc;if(!(t.highlightFrontier>=e.display.viewTo)){var r=+new Date+e.options.workTime,n=$e(e,t.highlightFrontier),i=[];t.iter(n.line,Math.min(t.first+t.size,e.display.viewTo+500),function(o){if(n.line>=e.display.viewFrom){var l=o.styles,s=o.text.length>e.options.maxHighlightLength?Ke(t.mode,n.state):null,a=Ye(e,o,n,!0);s&&(n.state=s),o.styles=a.styles;var u=o.styleClasses,c=a.classes;c?o.styleClasses=c:u&&(o.styleClasses=null);for(var f=!l||l.length!=o.styles.length||u!=c&&(!u||!c||u.bgClass!=c.bgClass||u.textClass!=c.textClass),h=0;!f&&h<l.length;++h)f=l[h]!=o.styles[h];f&&i.push(n.line),o.stateAfter=n.save(),n.nextLine()}else o.text.length<=e.options.maxHighlightLength&&qe(e,o.text,n),o.stateAfter=n.line%5==0?n.save():null,n.nextLine();if(+new Date>r)return Cn(e,e.options.workDelay),!0}),t.highlightFrontier=n.line,t.modeFrontier=Math.max(t.modeFrontier,n.line),i.length&&hn(e,function(){for(var t=0;t<i.length;t++)mn(e,i[t],"text")})}}function Ln(e){var t=e.display;!t.scrollbarsClipped&&t.scroller.offsetWidth&&(t.nativeBarWidth=t.scroller.offsetWidth-t.scroller.clientWidth,t.heightForcer.style.height=zt(e)+"px",t.sizer.style.marginBottom=-t.nativeBarWidth+"px",t.sizer.style.borderRightWidth=zt(e)+"px",t.scrollbarsClipped=!0)}function kn(e){if(e.hasFocus())return null;var t=l();if(!t||!o(e.display.lineDiv,t))return null;var r={activeElt:t};if(window.getSelection){var n=window.getSelection();n.anchorNode&&n.extend&&o(e.display.lineDiv,n.anchorNode)&&(r.anchorNode=n.anchorNode,r.anchorOffset=n.anchorOffset,r.focusNode=n.focusNode,r.focusOffset=n.focusOffset)}return r}function Tn(e){if(e&&e.activeElt&&e.activeElt!=l()&&(e.activeElt.focus(),e.anchorNode&&o(document.body,e.anchorNode)&&o(document.body,e.focusNode))){var t=window.getSelection(),r=document.createRange();r.setEnd(e.anchorNode,e.anchorOffset),r.collapse(!1),t.removeAllRanges(),t.addRange(r),t.extend(e.focusNode,e.focusOffset)}}function Mn(e,r){var n=e.display,i=e.doc;if(r.editorIsHidden)return yn(e),!1;if(!r.force&&r.visible.from>=n.viewFrom&&r.visible.to<=n.viewTo&&(null==n.updateLineNumbers||n.updateLineNumbers>=n.viewTo)&&n.renderedView==n.view&&0==xn(e))return!1;Rr(e)&&(yn(e),r.dims=br(e));var o=i.first+i.size,l=Math.max(r.visible.from-e.options.viewportMargin,i.first),s=Math.min(o,r.visible.to+e.options.viewportMargin);n.viewFrom<l&&l-n.viewFrom<20&&(l=Math.max(i.first,n.viewFrom)),n.viewTo>s&&n.viewTo-s<20&&(s=Math.min(o,n.viewTo)),_l&&(l=pe(e.doc,l),s=ge(e.doc,s));var a=l!=n.viewFrom||s!=n.viewTo||n.lastWrapHeight!=r.wrapperHeight||n.lastWrapWidth!=r.wrapperWidth;wn(e,l,s),n.viewOffset=ye(M(e.doc,n.viewFrom)),e.display.mover.style.top=n.viewOffset+"px";var u=xn(e);if(!a&&0==u&&!r.force&&n.renderedView==n.view&&(null==n.updateLineNumbers||n.updateLineNumbers>=n.viewTo))return!1;var c=kn(e);return u>4&&(n.lineDiv.style.display="none"),An(e,n.updateLineNumbers,r.dims),u>4&&(n.lineDiv.style.display=""),n.renderedView=n.view,Tn(c),t(n.cursorDiv),t(n.selectionDiv),n.gutters.style.height=n.sizer.style.minHeight=0,a&&(n.lastWrapHeight=r.wrapperHeight,n.lastWrapWidth=r.wrapperWidth,Cn(e,400)),n.updateLineNumbers=null,!0}function Nn(e,t){for(var r=t.viewport,n=!0;(n&&e.options.lineWrapping&&t.oldDisplayWidth!=Rt(e)||(r&&null!=r.top&&(r={top:Math.min(e.doc.height+Pt(e.display)-Bt(e),r.top)}),t.visible=Ir(e.display,e.doc,r),!(t.visible.from>=e.display.viewFrom&&t.visible.to<=e.display.viewTo)))&&Mn(e,t);n=!1){Er(e);var i=Jr(e);kr(e),en(e,i),Dn(e,i),t.force=!1}t.signal(e,"update",e),e.display.viewFrom==e.display.reportedViewFrom&&e.display.viewTo==e.display.reportedViewTo||(t.signal(e,"viewportChange",e,e.display.viewFrom,e.display.viewTo),e.display.reportedViewFrom=e.display.viewFrom,e.display.reportedViewTo=e.display.viewTo)}function On(e,t){var r=new Cs(e,t);if(Mn(e,r)){Er(e),Nn(e,r);var n=Jr(e);kr(e),en(e,n),Dn(e,n),r.finish()}}function An(e,r,n){function i(t){var r=t.nextSibling;return ml&&Ml&&e.display.currentWheelTarget==t?t.style.display="none":t.parentNode.removeChild(t),r}for(var o=e.display,l=e.options.lineNumbers,s=o.lineDiv,a=s.firstChild,u=o.view,c=o.viewFrom,f=0;f<u.length;f++){var d=u[f];if(d.hidden);else if(d.node&&d.node.parentNode==s){for(;a!=d.node;)a=i(a);var p=l&&null!=r&&r<=c&&d.lineNumber;d.changes&&(h(d.changes,"gutter")>-1&&(p=!1),xt(e,d,c,n)),p&&(t(d.lineNumber),d.lineNumber.appendChild(document.createTextNode(F(e.options,c)))),a=d.node.nextSibling}else{var g=Ot(e,d,c,n);s.insertBefore(g,a)}c+=d.size}for(;a;)a=i(a)}function Wn(e){var t=e.display.gutters.offsetWidth;e.display.sizer.style.marginLeft=t+"px"}function Dn(e,t){e.display.sizer.style.minHeight=t.docHeight+"px",e.display.heightForcer.style.top=t.docHeight+"px",e.display.gutters.style.height=t.docHeight+e.display.barHeight+zt(e)+"px"}function Hn(e){var r=e.display.gutters,i=e.options.gutters;t(r);for(var o=0;o<i.length;++o){var l=i[o],s=r.appendChild(n("div",null,"CodeMirror-gutter "+l));"CodeMirror-linenumbers"==l&&(e.display.lineGutter=s,s.style.width=(e.display.lineNumWidth||1)+"px")}r.style.display=o?"":"none",Wn(e)}function Fn(e){var t=h(e.gutters,"CodeMirror-linenumbers");-1==t&&e.lineNumbers?e.gutters=e.gutters.concat(["CodeMirror-linenumbers"]):t>-1&&!e.lineNumbers&&(e.gutters=e.gutters.slice(0),e.gutters.splice(t,1))}function En(e){var t=e.wheelDeltaX,r=e.wheelDeltaY;return null==t&&e.detail&&e.axis==e.HORIZONTAL_AXIS&&(t=e.detail),null==r&&e.detail&&e.axis==e.VERTICAL_AXIS?r=e.detail:null==r&&(r=e.wheelDelta),{x:t,y:r}}function Pn(e){var t=En(e);return t.x*=Ls,t.y*=Ls,t}function In(e,t){var r=En(t),n=r.x,i=r.y,o=e.display,l=o.scroller,s=l.scrollWidth>l.clientWidth,a=l.scrollHeight>l.clientHeight;if(n&&s||i&&a){if(i&&Ml&&ml)e:for(var u=t.target,c=o.view;u!=l;u=u.parentNode)for(var f=0;f<c.length;f++)if(c[f].node==u){e.display.currentWheelTarget=u;break e}if(n&&!fl&&!wl&&null!=Ls)return i&&a&&qr(e,Math.max(0,l.scrollTop+i*Ls)),Qr(e,Math.max(0,l.scrollLeft+n*Ls)),(!i||i&&a)&&We(t),void(o.wheelStartX=null);if(i&&null!=Ls){var h=i*Ls,d=e.doc.scrollTop,p=d+o.wrapper.clientHeight;h<0?d=Math.max(0,d+h-50):p=Math.min(e.doc.height,p+h+50),On(e,{top:d,bottom:p})}Ss<20&&(null==o.wheelStartX?(o.wheelStartX=l.scrollLeft,o.wheelStartY=l.scrollTop,o.wheelDX=n,o.wheelDY=i,setTimeout(function(){if(null!=o.wheelStartX){var e=l.scrollLeft-o.wheelStartX,t=l.scrollTop-o.wheelStartY,r=t&&o.wheelDY&&t/o.wheelDY||e&&o.wheelDX&&e/o.wheelDX;o.wheelStartX=o.wheelStartY=null,r&&(Ls=(Ls*Ss+r)/(Ss+1),++Ss)}},200)):(o.wheelDX+=n,o.wheelDY+=i))}}function zn(e,t){var r=e[t];e.sort(function(e,t){return P(e.from(),t.from())}),t=h(e,r);for(var n=1;n<e.length;n++){var i=e[n],o=e[n-1];if(P(o.to(),i.from())>=0){var l=B(o.from(),i.from()),s=R(o.to(),i.to()),a=o.empty()?i.from()==i.head:o.from()==o.head;n<=t&&--t,e.splice(--n,2,new Ts(a?s:l,a?l:s))}}return new ks(e,t)}function Rn(e,t){return new ks([new Ts(e,t||e)],0)}function Bn(e){return e.text?E(e.from.line+e.text.length-1,g(e.text).length+(1==e.text.length?e.from.ch:0)):e.to}function Gn(e,t){if(P(e,t.from)<0)return e;if(P(e,t.to)<=0)return Bn(t);var r=e.line+t.text.length-(t.to.line-t.from.line)-1,n=e.ch;return e.line==t.to.line&&(n+=Bn(t).ch-t.to.ch),E(r,n)}function Un(e,t){for(var r=[],n=0;n<e.sel.ranges.length;n++){var i=e.sel.ranges[n];r.push(new Ts(Gn(i.anchor,t),Gn(i.head,t)))}return zn(r,e.sel.primIndex)}function Vn(e,t,r){return e.line==t.line?E(r.line,e.ch-t.ch+r.ch):E(r.line+(e.line-t.line),e.ch)}function Kn(e,t,r){for(var n=[],i=E(e.first,0),o=i,l=0;l<t.length;l++){var s=t[l],a=Vn(s.from,i,o),u=Vn(Bn(s),i,o);if(i=s.to,o=u,"around"==r){var c=e.sel.ranges[l],f=P(c.head,c.anchor)<0;n[l]=new Ts(f?u:a,f?a:u)}else n[l]=new Ts(a,a)}return new ks(n,e.sel.primIndex)}function jn(e){e.doc.mode=Ue(e.options,e.doc.modeOption),Xn(e)}function Xn(e){e.doc.iter(function(e){e.stateAfter&&(e.stateAfter=null),e.styles&&(e.styles=null)}),e.doc.modeFrontier=e.doc.highlightFrontier=e.doc.first,Cn(e,100),e.state.modeGen++,e.curOp&&vn(e)}function Yn(e,t){return 0==t.from.ch&&0==t.to.ch&&""==g(t.text)&&(!e.cm||e.cm.options.wholeLineUpdateBefore)}function _n(e,t,r,n){function i(e){return r?r[e]:null}function o(e,r,i){it(e,r,i,n),bt(e,"change",e,t)}function l(e,t){for(var r=[],o=e;o<t;++o)r.push(new fs(u[o],i(o),n));return r}var s=t.from,a=t.to,u=t.text,c=M(e,s.line),f=M(e,a.line),h=g(u),d=i(u.length-1),p=a.line-s.line;if(t.full)e.insert(0,l(0,u.length)),e.remove(u.length,e.size-u.length);else if(Yn(e,t)){var v=l(0,u.length-1);o(f,f.text,d),p&&e.remove(s.line,p),v.length&&e.insert(s.line,v)}else if(c==f)if(1==u.length)o(c,c.text.slice(0,s.ch)+h+c.text.slice(a.ch),d);else{var m=l(1,u.length-1);m.push(new fs(h+c.text.slice(a.ch),d,n)),o(c,c.text.slice(0,s.ch)+u[0],i(0)),e.insert(s.line+1,m)}else if(1==u.length)o(c,c.text.slice(0,s.ch)+u[0]+f.text.slice(a.ch),i(0)),e.remove(s.line+1,p);else{o(c,c.text.slice(0,s.ch)+u[0],i(0)),o(f,h+f.text.slice(a.ch),d);var y=l(1,u.length-1);p>1&&e.remove(s.line+1,p-1),e.insert(s.line+1,y)}bt(e,"change",e,t)}function $n(e,t,r){function n(e,i,o){if(e.linked)for(var l=0;l<e.linked.length;++l){var s=e.linked[l];if(s.doc!=i){var a=o&&s.sharedHist;r&&!a||(t(s.doc,a),n(s.doc,e,a))}}}n(e,null,!0)}function qn(e,t){if(t.cm)throw new Error("This document is already in use.");e.doc=t,t.cm=e,Cr(e),jn(e),Zn(e),e.options.lineWrapping||we(e),e.options.mode=t.modeOption,vn(e)}function Zn(e){("rtl"==e.doc.direction?s:Fl)(e.display.lineDiv,"CodeMirror-rtl")}function Qn(e){hn(e,function(){Zn(e),vn(e)})}function Jn(e){this.done=[],this.undone=[],this.undoDepth=1/0,this.lastModTime=this.lastSelTime=0,this.lastOp=this.lastSelOp=null,this.lastOrigin=this.lastSelOrigin=null,this.generation=this.maxGeneration=e||1}function ei(e,t){var r={from:z(t.from),to:Bn(t),text:N(e,t.from,t.to)};return si(e,r,t.from.line,t.to.line+1),$n(e,function(e){return si(e,r,t.from.line,t.to.line+1)},!0),r}function ti(e){for(;e.length&&g(e).ranges;)e.pop()}function ri(e,t){return t?(ti(e.done),g(e.done)):e.done.length&&!g(e.done).ranges?g(e.done):e.done.length>1&&!e.done[e.done.length-2].ranges?(e.done.pop(),g(e.done)):void 0}function ni(e,t,r,n){var i=e.history;i.undone.length=0;var o,l,s=+new Date;if((i.lastOp==n||i.lastOrigin==t.origin&&t.origin&&("+"==t.origin.charAt(0)&&e.cm&&i.lastModTime>s-e.cm.options.historyEventDelay||"*"==t.origin.charAt(0)))&&(o=ri(i,i.lastOp==n)))l=g(o.changes),0==P(t.from,t.to)&&0==P(t.from,l.to)?l.to=Bn(t):o.changes.push(ei(e,t));else{var a=g(i.done);for(a&&a.ranges||li(e.sel,i.done),o={changes:[ei(e,t)],generation:i.generation},i.done.push(o);i.done.length>i.undoDepth;)i.done.shift(),i.done[0].ranges||i.done.shift()}i.done.push(r),i.generation=++i.maxGeneration,i.lastModTime=i.lastSelTime=s,i.lastOp=i.lastSelOp=n,i.lastOrigin=i.lastSelOrigin=t.origin,l||Te(e,"historyAdded")}function ii(e,t,r,n){var i=t.charAt(0);return"*"==i||"+"==i&&r.ranges.length==n.ranges.length&&r.somethingSelected()==n.somethingSelected()&&new Date-e.history.lastSelTime<=(e.cm?e.cm.options.historyEventDelay:500)}function oi(e,t,r,n){var i=e.history,o=n&&n.origin;r==i.lastSelOp||o&&i.lastSelOrigin==o&&(i.lastModTime==i.lastSelTime&&i.lastOrigin==o||ii(e,o,g(i.done),t))?i.done[i.done.length-1]=t:li(t,i.done),i.lastSelTime=+new Date,i.lastSelOrigin=o,i.lastSelOp=r,n&&!1!==n.clearRedo&&ti(i.undone)}function li(e,t){var r=g(t);r&&r.ranges&&r.equals(e)||t.push(e)}function si(e,t,r,n){var i=t["spans_"+e.id],o=0;e.iter(Math.max(e.first,r),Math.min(e.first+e.size,n),function(r){r.markedSpans&&((i||(i=t["spans_"+e.id]={}))[o]=r.markedSpans),++o})}function ai(e){if(!e)return null;for(var t,r=0;r<e.length;++r)e[r].marker.explicitlyCleared?t||(t=e.slice(0,r)):t&&t.push(e[r]);return t?t.length?t:null:e}function ui(e,t){var r=t["spans_"+e.id];if(!r)return null;for(var n=[],i=0;i<t.text.length;++i)n.push(ai(r[i]));return n}function ci(e,t){var r=ui(e,t),n=J(e,t);if(!r)return n;if(!n)return r;for(var i=0;i<r.length;++i){var o=r[i],l=n[i];if(o&&l)e:for(var s=0;s<l.length;++s){for(var a=l[s],u=0;u<o.length;++u)if(o[u].marker==a.marker)continue e;o.push(a)}else l&&(r[i]=l)}return r}function fi(e,t,r){for(var n=[],i=0;i<e.length;++i){var o=e[i];if(o.ranges)n.push(r?ks.prototype.deepCopy.call(o):o);else{var l=o.changes,s=[];n.push({changes:s});for(var a=0;a<l.length;++a){var u=l[a],c=void 0;if(s.push({from:u.from,to:u.to,text:u.text}),t)for(var f in u)(c=f.match(/^spans_(\d+)$/))&&h(t,Number(c[1]))>-1&&(g(s)[f]=u[f],delete u[f])}}}return n}function hi(e,t,r,n){if(n){var i=e.anchor;if(r){var o=P(t,i)<0;o!=P(r,i)<0?(i=t,t=r):o!=P(t,r)<0&&(t=r)}return new Ts(i,t)}return new Ts(r||t,t)}function di(e,t,r,n,i){null==i&&(i=e.cm&&(e.cm.display.shift||e.extend)),bi(e,new ks([hi(e.sel.primary(),t,r,i)],0),n)}function pi(e,t,r){for(var n=[],i=e.cm&&(e.cm.display.shift||e.extend),o=0;o<e.sel.ranges.length;o++)n[o]=hi(e.sel.ranges[o],t[o],null,i);bi(e,zn(n,e.sel.primIndex),r)}function gi(e,t,r,n){var i=e.sel.ranges.slice(0);i[t]=r,bi(e,zn(i,e.sel.primIndex),n)}function vi(e,t,r,n){bi(e,Rn(t,r),n)}function mi(e,t,r){var n={ranges:t.ranges,update:function(t){var r=this;this.ranges=[];for(var n=0;n<t.length;n++)r.ranges[n]=new Ts(U(e,t[n].anchor),U(e,t[n].head))},origin:r&&r.origin};return Te(e,"beforeSelectionChange",e,n),e.cm&&Te(e.cm,"beforeSelectionChange",e.cm,n),n.ranges!=t.ranges?zn(n.ranges,n.ranges.length-1):t}function yi(e,t,r){var n=e.history.done,i=g(n);i&&i.ranges?(n[n.length-1]=t,wi(e,t,r)):bi(e,t,r)}function bi(e,t,r){wi(e,t,r),oi(e,e.sel,e.cm?e.cm.curOp.id:NaN,r)}function wi(e,t,r){(Oe(e,"beforeSelectionChange")||e.cm&&Oe(e.cm,"beforeSelectionChange"))&&(t=mi(e,t,r)),xi(e,Si(e,t,r&&r.bias||(P(t.primary().head,e.sel.primary().head)<0?-1:1),!0)),r&&!1===r.scroll||!e.cm||jr(e.cm)}function xi(e,t){t.equals(e.sel)||(e.sel=t,e.cm&&(e.cm.curOp.updateInput=e.cm.curOp.selectionChanged=!0,Ne(e.cm)),bt(e,"cursorActivity",e))}function Ci(e){xi(e,Si(e,e.sel,null,!1))}function Si(e,t,r,n){for(var i,o=0;o<t.ranges.length;o++){var l=t.ranges[o],s=t.ranges.length==e.sel.ranges.length&&e.sel.ranges[o],a=ki(e,l.anchor,s&&s.anchor,r,n),u=ki(e,l.head,s&&s.head,r,n);(i||a!=l.anchor||u!=l.head)&&(i||(i=t.ranges.slice(0,o)),i[o]=new Ts(a,u))}return i?zn(i,t.primIndex):t}function Li(e,t,r,n,i){var o=M(e,t.line);if(o.markedSpans)for(var l=0;l<o.markedSpans.length;++l){var s=o.markedSpans[l],a=s.marker;if((null==s.from||(a.inclusiveLeft?s.from<=t.ch:s.from<t.ch))&&(null==s.to||(a.inclusiveRight?s.to>=t.ch:s.to>t.ch))){if(i&&(Te(a,"beforeCursorEnter"),a.explicitlyCleared)){if(o.markedSpans){--l;continue}break}if(!a.atomic)continue;if(r){var u=a.find(n<0?1:-1),c=void 0;if((n<0?a.inclusiveRight:a.inclusiveLeft)&&(u=Ti(e,u,-n,u&&u.line==t.line?o:null)),u&&u.line==t.line&&(c=P(u,r))&&(n<0?c<0:c>0))return Li(e,u,t,n,i)}var f=a.find(n<0?-1:1);return(n<0?a.inclusiveLeft:a.inclusiveRight)&&(f=Ti(e,f,n,f.line==t.line?o:null)),f?Li(e,f,t,n,i):null}}return t}function ki(e,t,r,n,i){var o=n||1,l=Li(e,t,r,o,i)||!i&&Li(e,t,r,o,!0)||Li(e,t,r,-o,i)||!i&&Li(e,t,r,-o,!0);return l||(e.cantEdit=!0,E(e.first,0))}function Ti(e,t,r,n){return r<0&&0==t.ch?t.line>e.first?U(e,E(t.line-1)):null:r>0&&t.ch==(n||M(e,t.line)).text.length?t.line<e.first+e.size-1?E(t.line+1,0):null:new E(t.line,t.ch+r)}function Mi(e){e.setSelection(E(e.firstLine(),0),E(e.lastLine()),Gl)}function Ni(e,t,r){var n={canceled:!1,from:t.from,to:t.to,text:t.text,origin:t.origin,cancel:function(){return n.canceled=!0}};return r&&(n.update=function(t,r,i,o){t&&(n.from=U(e,t)),r&&(n.to=U(e,r)),i&&(n.text=i),void 0!==o&&(n.origin=o)}),Te(e,"beforeChange",e,n),e.cm&&Te(e.cm,"beforeChange",e.cm,n),n.canceled?null:{from:n.from,to:n.to,text:n.text,origin:n.origin}}function Oi(e,t,r){if(e.cm){if(!e.cm.curOp)return dn(e.cm,Oi)(e,t,r);if(e.cm.state.suppressEdits)return}if(!(Oe(e,"beforeChange")||e.cm&&Oe(e.cm,"beforeChange"))||(t=Ni(e,t,!0))){var n=Yl&&!r&&te(e,t.from,t.to);if(n)for(var i=n.length-1;i>=0;--i)Ai(e,{from:n[i].from,to:n[i].to,text:i?[""]:t.text,origin:t.origin});else Ai(e,t)}}function Ai(e,t){if(1!=t.text.length||""!=t.text[0]||0!=P(t.from,t.to)){var r=Un(e,t);ni(e,t,r,e.cm?e.cm.curOp.id:NaN),Hi(e,t,r,J(e,t));var n=[];$n(e,function(e,r){r||-1!=h(n,e.history)||(zi(e.history,t),n.push(e.history)),Hi(e,t,null,J(e,t))})}}function Wi(e,t,r){if(!e.cm||!e.cm.state.suppressEdits||r){for(var n,i=e.history,o=e.sel,l="undo"==t?i.done:i.undone,s="undo"==t?i.undone:i.done,a=0;a<l.length&&(n=l[a],r?!n.ranges||n.equals(e.sel):n.ranges);a++);if(a!=l.length){for(i.lastOrigin=i.lastSelOrigin=null;(n=l.pop()).ranges;){if(li(n,s),r&&!n.equals(e.sel))return void bi(e,n,{clearRedo:!1});o=n}var u=[];li(o,s),s.push({changes:u,generation:i.generation}),i.generation=n.generation||++i.maxGeneration;for(var c=Oe(e,"beforeChange")||e.cm&&Oe(e.cm,"beforeChange"),f=n.changes.length-1;f>=0;--f){var d=function(r){var i=n.changes[r];if(i.origin=t,c&&!Ni(e,i,!1))return l.length=0,{};u.push(ei(e,i));var o=r?Un(e,i):g(l);Hi(e,i,o,ci(e,i)),!r&&e.cm&&e.cm.scrollIntoView({from:i.from,to:Bn(i)});var s=[];$n(e,function(e,t){t||-1!=h(s,e.history)||(zi(e.history,i),s.push(e.history)),Hi(e,i,null,ci(e,i))})}(f);if(d)return d.v}}}}function Di(e,t){if(0!=t&&(e.first+=t,e.sel=new ks(v(e.sel.ranges,function(e){return new Ts(E(e.anchor.line+t,e.anchor.ch),E(e.head.line+t,e.head.ch))}),e.sel.primIndex),e.cm)){vn(e.cm,e.first,e.first-t,t);for(var r=e.cm.display,n=r.viewFrom;n<r.viewTo;n++)mn(e.cm,n,"gutter")}}function Hi(e,t,r,n){if(e.cm&&!e.cm.curOp)return dn(e.cm,Hi)(e,t,r,n);if(t.to.line<e.first)Di(e,t.text.length-1-(t.to.line-t.from.line));else if(!(t.from.line>e.lastLine())){if(t.from.line<e.first){var i=t.text.length-1-(e.first-t.from.line);Di(e,i),t={from:E(e.first,0),to:E(t.to.line+i,t.to.ch),text:[g(t.text)],origin:t.origin}}var o=e.lastLine();t.to.line>o&&(t={from:t.from,to:E(o,M(e,o).text.length),text:[t.text[0]],origin:t.origin}),t.removed=N(e,t.from,t.to),r||(r=Un(e,t)),e.cm?Fi(e.cm,t,n):_n(e,t,n),wi(e,r,Gl)}}function Fi(e,t,r){var n=e.doc,i=e.display,o=t.from,l=t.to,s=!1,a=o.line;e.options.lineWrapping||(a=W(fe(M(n,o.line))),n.iter(a,l.line+1,function(e){if(e==i.maxLine)return s=!0,!0})),n.sel.contains(t.from,t.to)>-1&&Ne(e),_n(n,t,r,xr(e)),e.options.lineWrapping||(n.iter(a,o.line+t.text.length,function(e){var t=be(e);t>i.maxLineLength&&(i.maxLine=e,i.maxLineLength=t,i.maxLineChanged=!0,s=!1)}),s&&(e.curOp.updateMaxLine=!0)),nt(n,o.line),Cn(e,400);var u=t.text.length-(l.line-o.line)-1;t.full?vn(e):o.line!=l.line||1!=t.text.length||Yn(e.doc,t)?vn(e,o.line,l.line+1,u):mn(e,o.line,"text");var c=Oe(e,"changes"),f=Oe(e,"change");if(f||c){var h={from:o,to:l,text:t.text,removed:t.removed,origin:t.origin};f&&bt(e,"change",e,h),c&&(e.curOp.changeObjs||(e.curOp.changeObjs=[])).push(h)}e.display.selForContextMenu=null}function Ei(e,t,r,n,i){if(n||(n=r),P(n,r)<0){var o;r=(o=[n,r])[0],n=o[1]}"string"==typeof t&&(t=e.splitLines(t)),Oi(e,{from:r,to:n,text:t,origin:i})}function Pi(e,t,r,n){r<e.line?e.line+=n:t<e.line&&(e.line=t,e.ch=0)}function Ii(e,t,r,n){for(var i=0;i<e.length;++i){var o=e[i],l=!0;if(o.ranges){o.copied||((o=e[i]=o.deepCopy()).copied=!0);for(var s=0;s<o.ranges.length;s++)Pi(o.ranges[s].anchor,t,r,n),Pi(o.ranges[s].head,t,r,n)}else{for(var a=0;a<o.changes.length;++a){var u=o.changes[a];if(r<u.from.line)u.from=E(u.from.line+n,u.from.ch),u.to=E(u.to.line+n,u.to.ch);else if(t<=u.to.line){l=!1;break}}l||(e.splice(0,i+1),i=0)}}}function zi(e,t){var r=t.from.line,n=t.to.line,i=t.text.length-(n-r)-1;Ii(e.done,r,n,i),Ii(e.undone,r,n,i)}function Ri(e,t,r,n){var i=t,o=t;return"number"==typeof t?o=M(e,G(e,t)):i=W(t),null==i?null:(n(o,i)&&e.cm&&mn(e.cm,i,r),o)}function Bi(e){var t=this;this.lines=e,this.parent=null;for(var r=0,n=0;n<e.length;++n)e[n].parent=t,r+=e[n].height;this.height=r}function Gi(e){var t=this;this.children=e;for(var r=0,n=0,i=0;i<e.length;++i){var o=e[i];r+=o.chunkSize(),n+=o.height,o.parent=t}this.size=r,this.height=n,this.parent=null}function Ui(e,t,r){ye(t)<(e.curOp&&e.curOp.scrollTop||e.doc.scrollTop)&&Kr(e,r)}function Vi(e,t,r,n){var i=new Ms(e,r,n),o=e.cm;return o&&i.noHScroll&&(o.display.alignWidgets=!0),Ri(e,t,"widget",function(t){var r=t.widgets||(t.widgets=[]);if(null==i.insertAt?r.push(i):r.splice(Math.min(r.length-1,Math.max(0,i.insertAt)),0,i),i.line=t,o&&!ve(e,t)){var n=ye(t)<e.scrollTop;A(t,t.height+Ht(i)),n&&Kr(o,i.height),o.curOp.forceUpdate=!0}return!0}),bt(o,"lineWidgetAdded",o,i,"number"==typeof t?t:W(t)),i}function Ki(e,t,r,n,o){if(n&&n.shared)return ji(e,t,r,n,o);if(e.cm&&!e.cm.curOp)return dn(e.cm,Ki)(e,t,r,n,o);var l=new Os(e,o),s=P(t,r);if(n&&c(n,l,!1),s>0||0==s&&!1!==l.clearWhenEmpty)return l;if(l.replacedWith&&(l.collapsed=!0,l.widgetNode=i("span",[l.replacedWith],"CodeMirror-widget"),n.handleMouseEvents||l.widgetNode.setAttribute("cm-ignore-events","true"),n.insertLeft&&(l.widgetNode.insertLeft=!0)),l.collapsed){if(ce(e,t.line,t,r,l)||t.line!=r.line&&ce(e,r.line,t,r,l))throw new Error("Inserting collapsed marker partially overlapping an existing one");X()}l.addToHistory&&ni(e,{from:t,to:r,origin:"markText"},e.sel,NaN);var a,u=t.line,f=e.cm;if(e.iter(u,r.line+1,function(e){f&&l.collapsed&&!f.options.lineWrapping&&fe(e)==f.display.maxLine&&(a=!0),l.collapsed&&u!=t.line&&A(e,0),q(e,new Y(l,u==t.line?t.ch:null,u==r.line?r.ch:null)),++u}),l.collapsed&&e.iter(t.line,r.line+1,function(t){ve(e,t)&&A(t,0)}),l.clearOnEnter&&Ql(l,"beforeCursorEnter",function(){return l.clear()}),l.readOnly&&(j(),(e.history.done.length||e.history.undone.length)&&e.clearHistory()),l.collapsed&&(l.id=++Ns,l.atomic=!0),f){if(a&&(f.curOp.updateMaxLine=!0),l.collapsed)vn(f,t.line,r.line+1);else if(l.className||l.title||l.startStyle||l.endStyle||l.css)for(var h=t.line;h<=r.line;h++)mn(f,h,"text");l.atomic&&Ci(f.doc),bt(f,"markerAdded",f,l)}return l}function ji(e,t,r,n,i){(n=c(n)).shared=!1;var o=[Ki(e,t,r,n,i)],l=o[0],s=n.widgetNode;return $n(e,function(e){s&&(n.widgetNode=s.cloneNode(!0)),o.push(Ki(e,U(e,t),U(e,r),n,i));for(var a=0;a<e.linked.length;++a)if(e.linked[a].isParent)return;l=g(o)}),new As(o,l)}function Xi(e){return e.findMarks(E(e.first,0),e.clipPos(E(e.lastLine())),function(e){return e.parent})}function Yi(e,t){for(var r=0;r<t.length;r++){var n=t[r],i=n.find(),o=e.clipPos(i.from),l=e.clipPos(i.to);if(P(o,l)){var s=Ki(e,o,l,n.primary,n.primary.type);n.markers.push(s),s.parent=n}}}function _i(e){for(var t=0;t<e.length;t++)!function(t){var r=e[t],n=[r.primary.doc];$n(r.primary.doc,function(e){return n.push(e)});for(var i=0;i<r.markers.length;i++){var o=r.markers[i];-1==h(n,o.doc)&&(o.parent=null,r.markers.splice(i--,1))}}(t)}function $i(e){var t=this;if(Qi(t),!Me(t,e)&&!Ft(t.display,e)){We(e),gl&&(Hs=+new Date);var r=Sr(t,e,!0),n=e.dataTransfer.files;if(r&&!t.isReadOnly())if(n&&n.length&&window.FileReader&&window.File)for(var i=n.length,o=Array(i),l=0,s=0;s<i;++s)!function(e,n){if(!t.options.allowDropFileTypes||-1!=h(t.options.allowDropFileTypes,e.type)){var s=new FileReader;s.onload=dn(t,function(){var e=s.result;if(/[\x00-\x08\x0e-\x1f]{2}/.test(e)&&(e=""),o[n]=e,++l==i){var a={from:r=U(t.doc,r),to:r,text:t.doc.splitLines(o.join(t.doc.lineSeparator())),origin:"paste"};Oi(t.doc,a),yi(t.doc,Rn(r,Bn(a)))}}),s.readAsText(e)}}(n[s],s);else{if(t.state.draggingText&&t.doc.sel.contains(r)>-1)return t.state.draggingText(e),void setTimeout(function(){return t.display.input.focus()},20);try{var a=e.dataTransfer.getData("Text");if(a){var u;if(t.state.draggingText&&!t.state.draggingText.copy&&(u=t.listSelections()),wi(t.doc,Rn(r,r)),u)for(var c=0;c<u.length;++c)Ei(t.doc,"",u[c].anchor,u[c].head,"drag");t.replaceSelection(a,"around","paste"),t.display.input.focus()}}catch(e){}}}}function qi(e,t){if(gl&&(!e.state.draggingText||+new Date-Hs<100))Fe(t);else if(!Me(e,t)&&!Ft(e.display,t)&&(t.dataTransfer.setData("Text",e.getSelection()),t.dataTransfer.effectAllowed="copyMove",t.dataTransfer.setDragImage&&!xl)){var r=n("img",null,null,"position: fixed; left: 0; top: 0;");r.src="data:image/gif;base64,R0lGODlhAQABAAAAACH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==",wl&&(r.width=r.height=1,e.display.wrapper.appendChild(r),r._top=r.offsetTop),t.dataTransfer.setDragImage(r,0,0),wl&&r.parentNode.removeChild(r)}}function Zi(e,t){var i=Sr(e,t);if(i){var o=document.createDocumentFragment();Mr(e,i,o),e.display.dragCursor||(e.display.dragCursor=n("div",null,"CodeMirror-cursors CodeMirror-dragcursors"),e.display.lineSpace.insertBefore(e.display.dragCursor,e.display.cursorDiv)),r(e.display.dragCursor,o)}}function Qi(e){e.display.dragCursor&&(e.display.lineSpace.removeChild(e.display.dragCursor),e.display.dragCursor=null)}function Ji(e){if(document.getElementsByClassName)for(var t=document.getElementsByClassName("CodeMirror"),r=0;r<t.length;r++){var n=t[r].CodeMirror;n&&e(n)}}function eo(){Fs||(to(),Fs=!0)}function to(){var e;Ql(window,"resize",function(){null==e&&(e=setTimeout(function(){e=null,Ji(ro)},100))}),Ql(window,"blur",function(){return Ji(Fr)})}function ro(e){var t=e.display;t.lastWrapHeight==t.wrapper.clientHeight&&t.lastWrapWidth==t.wrapper.clientWidth||(t.cachedCharWidth=t.cachedTextHeight=t.cachedPaddingH=null,t.scrollbarsClipped=!1,e.setSize())}function no(e){var t=e.split(/-(?!$)/);e=t[t.length-1];for(var r,n,i,o,l=0;l<t.length-1;l++){var s=t[l];if(/^(cmd|meta|m)$/i.test(s))o=!0;else if(/^a(lt)?$/i.test(s))r=!0;else if(/^(c|ctrl|control)$/i.test(s))n=!0;else{if(!/^s(hift)?$/i.test(s))throw new Error("Unrecognized modifier name: "+s);i=!0}}return r&&(e="Alt-"+e),n&&(e="Ctrl-"+e),o&&(e="Cmd-"+e),i&&(e="Shift-"+e),e}function io(e){var t={};for(var r in e)if(e.hasOwnProperty(r)){var n=e[r];if(/^(name|fallthrough|(de|at)tach)$/.test(r))continue;if("..."==n){delete e[r];continue}for(var i=v(r.split(" "),no),o=0;o<i.length;o++){var l=void 0,s=void 0;o==i.length-1?(s=i.join(" "),l=n):(s=i.slice(0,o+1).join(" "),l="...");var a=t[s];if(a){if(a!=l)throw new Error("Inconsistent bindings for "+s)}else t[s]=l}delete e[r]}for(var u in t)e[u]=t[u];return e}function oo(e,t,r,n){var i=(t=uo(t)).call?t.call(e,n):t[e];if(!1===i)return"nothing";if("..."===i)return"multi";if(null!=i&&r(i))return"handled";if(t.fallthrough){if("[object Array]"!=Object.prototype.toString.call(t.fallthrough))return oo(e,t.fallthrough,r,n);for(var o=0;o<t.fallthrough.length;o++){var l=oo(e,t.fallthrough[o],r,n);if(l)return l}}}function lo(e){var t="string"==typeof e?e:Es[e.keyCode];return"Ctrl"==t||"Alt"==t||"Shift"==t||"Mod"==t}function so(e,t,r){var n=e;return t.altKey&&"Alt"!=n&&(e="Alt-"+e),(Dl?t.metaKey:t.ctrlKey)&&"Ctrl"!=n&&(e="Ctrl-"+e),(Dl?t.ctrlKey:t.metaKey)&&"Cmd"!=n&&(e="Cmd-"+e),!r&&t.shiftKey&&"Shift"!=n&&(e="Shift-"+e),e}function ao(e,t){if(wl&&34==e.keyCode&&e.char)return!1;var r=Es[e.keyCode];return null!=r&&!e.altGraphKey&&so(r,e,t)}function uo(e){return"string"==typeof e?Rs[e]:e}function co(e,t){for(var r=e.doc.sel.ranges,n=[],i=0;i<r.length;i++){for(var o=t(r[i]);n.length&&P(o.from,g(n).to)<=0;){var l=n.pop();if(P(l.from,o.from)<0){o.from=l.from;break}}n.push(o)}hn(e,function(){for(var t=n.length-1;t>=0;t--)Ei(e.doc,"",n[t].from,n[t].to,"+delete");jr(e)})}function fo(e,t,r){var n=L(e.text,t+r,r);return n<0||n>e.text.length?null:n}function ho(e,t,r){var n=fo(e,t.ch,r);return null==n?null:new E(t.line,n,r<0?"after":"before")}function po(e,t,r,n,i){if(e){var o=Se(r,t.doc.direction);if(o){var l,s=i<0?g(o):o[0],a=i<0==(1==s.level)?"after":"before";if(s.level>0){var u=Xt(t,r);l=i<0?r.text.length-1:0;var c=Yt(t,u,l).top;l=k(function(e){return Yt(t,u,e).top==c},i<0==(1==s.level)?s.from:s.to-1,l),"before"==a&&(l=fo(r,l,1))}else l=i<0?s.to:s.from;return new E(n,l,a)}}return new E(n,i<0?r.text.length:0,i<0?"before":"after")}function go(e,t,r,n){var i=Se(t,e.doc.direction);if(!i)return ho(t,r,n);r.ch>=t.text.length?(r.ch=t.text.length,r.sticky="before"):r.ch<=0&&(r.ch=0,r.sticky="after");var o=Ce(i,r.ch,r.sticky),l=i[o];if("ltr"==e.doc.direction&&l.level%2==0&&(n>0?l.to>r.ch:l.from<r.ch))return ho(t,r,n);var s,a=function(e,r){return fo(t,e instanceof E?e.ch:e,r)},u=function(r){return e.options.lineWrapping?(s=s||Xt(e,t),hr(e,t,s,r)):{begin:0,end:t.text.length}},c=u("before"==r.sticky?a(r,-1):r.ch);if("rtl"==e.doc.direction||1==l.level){var f=1==l.level==n<0,h=a(r,f?1:-1);if(null!=h&&(f?h<=l.to&&h<=c.end:h>=l.from&&h>=c.begin)){var d=f?"before":"after";return new E(r.line,h,d)}}var p=function(e,t,n){for(var o=function(e,t){return t?new E(r.line,a(e,1),"before"):new E(r.line,e,"after")};e>=0&&e<i.length;e+=t){var l=i[e],s=t>0==(1!=l.level),u=s?n.begin:a(n.end,-1);if(l.from<=u&&u<l.to)return o(u,s);if(u=s?l.from:a(l.to,-1),n.begin<=u&&u<n.end)return o(u,s)}},g=p(o+n,n,c);if(g)return g;var v=n>0?c.end:a(c.begin,-1);return null==v||n>0&&v==t.text.length||!(g=p(n>0?0:i.length-1,n,u(v)))?null:g}function vo(e,t){var r=M(e.doc,t),n=fe(r);return n!=r&&(t=W(n)),po(!0,e,n,t,1)}function mo(e,t){var r=M(e.doc,t),n=he(r);return n!=r&&(t=W(n)),po(!0,e,r,t,-1)}function yo(e,t){var r=vo(e,t.line),n=M(e.doc,r.line),i=Se(n,e.doc.direction);if(!i||0==i[0].level){var o=Math.max(0,n.text.search(/\S/)),l=t.line==r.line&&t.ch<=o&&t.ch;return E(r.line,l?0:o,r.sticky)}return r}function bo(e,t,r){if("string"==typeof t&&!(t=Bs[t]))return!1;e.display.input.ensurePolled();var n=e.display.shift,i=!1;try{e.isReadOnly()&&(e.state.suppressEdits=!0),r&&(e.display.shift=!1),i=t(e)!=Bl}finally{e.display.shift=n,e.state.suppressEdits=!1}return i}function wo(e,t,r){for(var n=0;n<e.state.keyMaps.length;n++){var i=oo(t,e.state.keyMaps[n],r,e);if(i)return i}return e.options.extraKeys&&oo(t,e.options.extraKeys,r,e)||oo(t,e.options.keyMap,r,e)}function xo(e,t,r,n){var i=e.state.keySeq;if(i){if(lo(t))return"handled";Gs.set(50,function(){e.state.keySeq==i&&(e.state.keySeq=null,e.display.input.reset())}),t=i+" "+t}var o=wo(e,t,n);return"multi"==o&&(e.state.keySeq=t),"handled"==o&&bt(e,"keyHandled",e,t,r),"handled"!=o&&"multi"!=o||(We(r),Ar(e)),i&&!o&&/\'$/.test(t)?(We(r),!0):!!o}function Co(e,t){var r=ao(t,!0);return!!r&&(t.shiftKey&&!e.state.keySeq?xo(e,"Shift-"+r,t,function(t){return bo(e,t,!0)})||xo(e,r,t,function(t){if("string"==typeof t?/^go[A-Z]/.test(t):t.motion)return bo(e,t)}):xo(e,r,t,function(t){return bo(e,t)}))}function So(e,t,r){return xo(e,"'"+r+"'",t,function(t){return bo(e,t,!0)})}function Lo(e){var t=this;if(t.curOp.focus=l(),!Me(t,e)){gl&&vl<11&&27==e.keyCode&&(e.returnValue=!1);var r=e.keyCode;t.display.shift=16==r||e.shiftKey;var n=Co(t,e);wl&&(Us=n?r:null,!n&&88==r&&!rs&&(Ml?e.metaKey:e.ctrlKey)&&t.replaceSelection("",null,"cut")),18!=r||/\bCodeMirror-crosshair\b/.test(t.display.lineDiv.className)||ko(t)}}function ko(e){function t(e){18!=e.keyCode&&e.altKey||(Fl(r,"CodeMirror-crosshair"),ke(document,"keyup",t),ke(document,"mouseover",t))}var r=e.display.lineDiv;s(r,"CodeMirror-crosshair"),Ql(document,"keyup",t),Ql(document,"mouseover",t)}function To(e){16==e.keyCode&&(this.doc.sel.shift=!1),Me(this,e)}function Mo(e){var t=this;if(!(Ft(t.display,e)||Me(t,e)||e.ctrlKey&&!e.altKey||Ml&&e.metaKey)){var r=e.keyCode,n=e.charCode;if(wl&&r==Us)return Us=null,void We(e);if(!wl||e.which&&!(e.which<10)||!Co(t,e)){var i=String.fromCharCode(null==n?r:n);"\b"!=i&&(So(t,e,i)||t.display.input.onKeyPress(e))}}}function No(e,t){var r=+new Date;return js&&js.compare(r,e,t)?(Ks=js=null,"triple"):Ks&&Ks.compare(r,e,t)?(js=new Vs(r,e,t),Ks=null,"double"):(Ks=new Vs(r,e,t),js=null,"single")}function Oo(e){var t=this,r=t.display;if(!(Me(t,e)||r.activeTouch&&r.input.supportsTouch()))if(r.input.ensurePolled(),r.shift=e.shiftKey,Ft(r,e))ml||(r.scroller.draggable=!1,setTimeout(function(){return r.scroller.draggable=!0},100));else if(!zo(t,e)){var n=Sr(t,e),i=Pe(e),o=n?No(n,i):"single";window.focus(),1==i&&t.state.selectingText&&t.state.selectingText(e),n&&Ao(t,i,n,o,e)||(1==i?n?Do(t,n,o,e):Ee(e)==r.scroller&&We(e):2==i?(n&&di(t.doc,n),setTimeout(function(){return r.input.focus()},20)):3==i&&(Hl?Ro(t,e):Dr(t)))}}function Ao(e,t,r,n,i){var o="Click";return"double"==n?o="Double"+o:"triple"==n&&(o="Triple"+o),o=(1==t?"Left":2==t?"Middle":"Right")+o,xo(e,so(o,i),i,function(t){if("string"==typeof t&&(t=Bs[t]),!t)return!1;var n=!1;try{e.isReadOnly()&&(e.state.suppressEdits=!0),n=t(e,r)!=Bl}finally{e.state.suppressEdits=!1}return n})}function Wo(e,t,r){var n=e.getOption("configureMouse"),i=n?n(e,t,r):{};if(null==i.unit){var o=Nl?r.shiftKey&&r.metaKey:r.altKey;i.unit=o?"rectangle":"single"==t?"char":"double"==t?"word":"line"}return(null==i.extend||e.doc.extend)&&(i.extend=e.doc.extend||r.shiftKey),null==i.addNew&&(i.addNew=Ml?r.metaKey:r.ctrlKey),null==i.moveOnDrag&&(i.moveOnDrag=!(Ml?r.altKey:r.ctrlKey)),i}function Do(e,t,r,n){gl?setTimeout(u(Wr,e),0):e.curOp.focus=l();var i,o=Wo(e,r,n),s=e.doc.sel;e.options.dragDrop&&Jl&&!e.isReadOnly()&&"single"==r&&(i=s.contains(t))>-1&&(P((i=s.ranges[i]).from(),t)<0||t.xRel>0)&&(P(i.to(),t)>0||t.xRel<0)?Ho(e,n,t,o):Eo(e,n,t,o)}function Ho(e,t,r,n){var i=e.display,o=!1,l=dn(e,function(t){ml&&(i.scroller.draggable=!1),e.state.draggingText=!1,ke(document,"mouseup",l),ke(document,"mousemove",s),ke(i.scroller,"dragstart",a),ke(i.scroller,"drop",l),o||(We(t),n.addNew||di(e.doc,r,null,null,n.extend),ml||gl&&9==vl?setTimeout(function(){document.body.focus(),i.input.focus()},20):i.input.focus())}),s=function(e){o=o||Math.abs(t.clientX-e.clientX)+Math.abs(t.clientY-e.clientY)>=10},a=function(){return o=!0};ml&&(i.scroller.draggable=!0),e.state.draggingText=l,l.copy=!n.moveOnDrag,i.scroller.dragDrop&&i.scroller.dragDrop(),Ql(document,"mouseup",l),Ql(document,"mousemove",s),Ql(i.scroller,"dragstart",a),Ql(i.scroller,"drop",l),Dr(e),setTimeout(function(){return i.input.focus()},20)}function Fo(e,t,r){if("char"==r)return new Ts(t,t);if("word"==r)return e.findWordAt(t);if("line"==r)return new Ts(E(t.line,0),U(e.doc,E(t.line+1,0)));var n=r(e,t);return new Ts(n.from,n.to)}function Eo(e,t,r,n){function i(t){if(0!=P(m,t))if(m=t,"rectangle"==n.unit){for(var i=[],o=e.options.tabSize,l=f(M(u,r.line).text,r.ch,o),s=f(M(u,t.line).text,t.ch,o),a=Math.min(l,s),g=Math.max(l,s),v=Math.min(r.line,t.line),y=Math.min(e.lastLine(),Math.max(r.line,t.line));v<=y;v++){var b=M(u,v).text,w=d(b,a,o);a==g?i.push(new Ts(E(v,w),E(v,w))):b.length>w&&i.push(new Ts(E(v,w),E(v,d(b,g,o))))}i.length||i.push(new Ts(r,r)),bi(u,zn(p.ranges.slice(0,h).concat(i),h),{origin:"*mouse",scroll:!1}),e.scrollIntoView(t)}else{var x,C=c,S=Fo(e,t,n.unit),L=C.anchor;P(S.anchor,L)>0?(x=S.head,L=B(C.from(),S.anchor)):(x=S.anchor,L=R(C.to(),S.head));var k=p.ranges.slice(0);k[h]=Po(e,new Ts(U(u,L),x)),bi(u,zn(k,h),Ul)}}function o(t){var r=++b,s=Sr(e,t,!0,"rectangle"==n.unit);if(s)if(0!=P(s,m)){e.curOp.focus=l(),i(s);var c=Ir(a,u);(s.line>=c.to||s.line<c.from)&&setTimeout(dn(e,function(){b==r&&o(t)}),150)}else{var f=t.clientY<y.top?-20:t.clientY>y.bottom?20:0;f&&setTimeout(dn(e,function(){b==r&&(a.scroller.scrollTop+=f,o(t))}),50)}}function s(t){e.state.selectingText=!1,b=1/0,We(t),a.input.focus(),ke(document,"mousemove",w),ke(document,"mouseup",x),u.history.lastSelOrigin=null}var a=e.display,u=e.doc;We(t);var c,h,p=u.sel,g=p.ranges;if(n.addNew&&!n.extend?(h=u.sel.contains(r),c=h>-1?g[h]:new Ts(r,r)):(c=u.sel.primary(),h=u.sel.primIndex),"rectangle"==n.unit)n.addNew||(c=new Ts(r,r)),r=Sr(e,t,!0,!0),h=-1;else{var v=Fo(e,r,n.unit);c=n.extend?hi(c,v.anchor,v.head,n.extend):v}n.addNew?-1==h?(h=g.length,bi(u,zn(g.concat([c]),h),{scroll:!1,origin:"*mouse"})):g.length>1&&g[h].empty()&&"char"==n.unit&&!n.extend?(bi(u,zn(g.slice(0,h).concat(g.slice(h+1)),0),{scroll:!1,origin:"*mouse"}),p=u.sel):gi(u,h,c,Ul):(h=0,bi(u,new ks([c],0),Ul),p=u.sel);var m=r,y=a.wrapper.getBoundingClientRect(),b=0,w=dn(e,function(e){Pe(e)?o(e):s(e)}),x=dn(e,s);e.state.selectingText=x,Ql(document,"mousemove",w),Ql(document,"mouseup",x)}function Po(e,t){var r=t.anchor,n=t.head,i=M(e.doc,r.line);if(0==P(r,n)&&r.sticky==n.sticky)return t;var o=Se(i);if(!o)return t;var l=Ce(o,r.ch,r.sticky),s=o[l];if(s.from!=r.ch&&s.to!=r.ch)return t;var a=l+(s.from==r.ch==(1!=s.level)?0:1);if(0==a||a==o.length)return t;var u;if(n.line!=r.line)u=(n.line-r.line)*("ltr"==e.doc.direction?1:-1)>0;else{var c=Ce(o,n.ch,n.sticky),f=c-l||(n.ch-r.ch)*(1==s.level?-1:1);u=c==a-1||c==a?f<0:f>0}var h=o[a+(u?-1:0)],d=u==(1==h.level),p=d?h.from:h.to,g=d?"after":"before";return r.ch==p&&r.sticky==g?t:new Ts(new E(r.line,p,g),n)}function Io(e,t,r,n){var i,o;if(t.touches)i=t.touches[0].clientX,o=t.touches[0].clientY;else try{i=t.clientX,o=t.clientY}catch(t){return!1}if(i>=Math.floor(e.display.gutters.getBoundingClientRect().right))return!1;n&&We(t);var l=e.display,s=l.lineDiv.getBoundingClientRect();if(o>s.bottom||!Oe(e,r))return He(t);o-=s.top-l.viewOffset;for(var a=0;a<e.options.gutters.length;++a){var u=l.gutters.childNodes[a];if(u&&u.getBoundingClientRect().right>=i)return Te(e,r,e,D(e.doc,o),e.options.gutters[a],t),He(t)}}function zo(e,t){return Io(e,t,"gutterClick",!0)}function Ro(e,t){Ft(e.display,t)||Bo(e,t)||Me(e,t,"contextmenu")||e.display.input.onContextMenu(t)}function Bo(e,t){return!!Oe(e,"gutterContextMenu")&&Io(e,t,"gutterContextMenu",!1)}function Go(e){e.display.wrapper.className=e.display.wrapper.className.replace(/\s*cm-s-\S+/g,"")+e.options.theme.replace(/(^|\s)\s*/g," cm-s-"),er(e)}function Uo(e){Hn(e),vn(e),zr(e)}function Vo(e,t,r){if(!t!=!(r&&r!=Xs)){var n=e.display.dragFunctions,i=t?Ql:ke;i(e.display.scroller,"dragstart",n.start),i(e.display.scroller,"dragenter",n.enter),i(e.display.scroller,"dragover",n.over),i(e.display.scroller,"dragleave",n.leave),i(e.display.scroller,"drop",n.drop)}}function Ko(e){e.options.lineWrapping?(s(e.display.wrapper,"CodeMirror-wrap"),e.display.sizer.style.minWidth="",e.display.sizerWidth=null):(Fl(e.display.wrapper,"CodeMirror-wrap"),we(e)),Cr(e),vn(e),er(e),setTimeout(function(){return en(e)},100)}function jo(e,t){var r=this;if(!(this instanceof jo))return new jo(e,t);this.options=t=t?c(t):{},c(Ys,t,!1),Fn(t);var n=t.value;"string"==typeof n&&(n=new Ds(n,t.mode,null,t.lineSeparator,t.direction)),this.doc=n;var i=new jo.inputStyles[t.inputStyle](this),o=this.display=new T(e,n,i);o.wrapper.CodeMirror=this,Hn(this),Go(this),t.lineWrapping&&(this.display.wrapper.className+=" CodeMirror-wrap"),rn(this),this.state={keyMaps:[],overlays:[],modeGen:0,overwrite:!1,delayingBlurEvent:!1,focused:!1,suppressEdits:!1,pasteIncoming:!1,cutIncoming:!1,selectingText:!1,draggingText:!1,highlight:new Pl,keySeq:null,specialChars:null},t.autofocus&&!Tl&&o.input.focus(),gl&&vl<11&&setTimeout(function(){return r.display.input.reset(!0)},20),Xo(this),eo(),nn(this),this.curOp.forceUpdate=!0,qn(this,n),t.autofocus&&!Tl||this.hasFocus()?setTimeout(u(Hr,this),20):Fr(this);for(var l in _s)_s.hasOwnProperty(l)&&_s[l](r,t[l],Xs);Rr(this),t.finishInit&&t.finishInit(this);for(var s=0;s<$s.length;++s)$s[s](r);on(this),ml&&t.lineWrapping&&"optimizelegibility"==getComputedStyle(o.lineDiv).textRendering&&(o.lineDiv.style.textRendering="auto")}function Xo(e){function t(){i.activeTouch&&(o=setTimeout(function(){return i.activeTouch=null},1e3),(l=i.activeTouch).end=+new Date)}function r(e){if(1!=e.touches.length)return!1;var t=e.touches[0];return t.radiusX<=1&&t.radiusY<=1}function n(e,t){if(null==t.left)return!0;var r=t.left-e.left,n=t.top-e.top;return r*r+n*n>400}var i=e.display;Ql(i.scroller,"mousedown",dn(e,Oo)),gl&&vl<11?Ql(i.scroller,"dblclick",dn(e,function(t){if(!Me(e,t)){var r=Sr(e,t);if(r&&!zo(e,t)&&!Ft(e.display,t)){We(t);var n=e.findWordAt(r);di(e.doc,n.anchor,n.head)}}})):Ql(i.scroller,"dblclick",function(t){return Me(e,t)||We(t)}),Hl||Ql(i.scroller,"contextmenu",function(t){return Ro(e,t)});var o,l={end:0};Ql(i.scroller,"touchstart",function(t){if(!Me(e,t)&&!r(t)&&!zo(e,t)){i.input.ensurePolled(),clearTimeout(o);var n=+new Date;i.activeTouch={start:n,moved:!1,prev:n-l.end<=300?l:null},1==t.touches.length&&(i.activeTouch.left=t.touches[0].pageX,i.activeTouch.top=t.touches[0].pageY)}}),Ql(i.scroller,"touchmove",function(){i.activeTouch&&(i.activeTouch.moved=!0)}),Ql(i.scroller,"touchend",function(r){var o=i.activeTouch;if(o&&!Ft(i,r)&&null!=o.left&&!o.moved&&new Date-o.start<300){var l,s=e.coordsChar(i.activeTouch,"page");l=!o.prev||n(o,o.prev)?new Ts(s,s):!o.prev.prev||n(o,o.prev.prev)?e.findWordAt(s):new Ts(E(s.line,0),U(e.doc,E(s.line+1,0))),e.setSelection(l.anchor,l.head),e.focus(),We(r)}t()}),Ql(i.scroller,"touchcancel",t),Ql(i.scroller,"scroll",function(){i.scroller.clientHeight&&(qr(e,i.scroller.scrollTop),Qr(e,i.scroller.scrollLeft,!0),Te(e,"scroll",e))}),Ql(i.scroller,"mousewheel",function(t){return In(e,t)}),Ql(i.scroller,"DOMMouseScroll",function(t){return In(e,t)}),Ql(i.wrapper,"scroll",function(){return i.wrapper.scrollTop=i.wrapper.scrollLeft=0}),i.dragFunctions={enter:function(t){Me(e,t)||Fe(t)},over:function(t){Me(e,t)||(Zi(e,t),Fe(t))},start:function(t){return qi(e,t)},drop:dn(e,$i),leave:function(t){Me(e,t)||Qi(e)}};var s=i.input.getField();Ql(s,"keyup",function(t){return To.call(e,t)}),Ql(s,"keydown",dn(e,Lo)),Ql(s,"keypress",dn(e,Mo)),Ql(s,"focus",function(t){return Hr(e,t)}),Ql(s,"blur",function(t){return Fr(e,t)})}function Yo(e,t,r,n){var i,o=e.doc;null==r&&(r="add"),"smart"==r&&(o.mode.indent?i=$e(e,t).state:r="prev");var l=e.options.tabSize,s=M(o,t),a=f(s.text,null,l);s.stateAfter&&(s.stateAfter=null);var u,c=s.text.match(/^\s*/)[0];if(n||/\S/.test(s.text)){if("smart"==r&&((u=o.mode.indent(i,s.text.slice(c.length),s.text))==Bl||u>150)){if(!n)return;r="prev"}}else u=0,r="not";"prev"==r?u=t>o.first?f(M(o,t-1).text,null,l):0:"add"==r?u=a+e.options.indentUnit:"subtract"==r?u=a-e.options.indentUnit:"number"==typeof r&&(u=a+r),u=Math.max(0,u);var h="",d=0;if(e.options.indentWithTabs)for(var g=Math.floor(u/l);g;--g)d+=l,h+="\t";if(d<u&&(h+=p(u-d)),h!=c)return Ei(o,h,E(t,0),E(t,c.length),"+input"),s.stateAfter=null,!0;for(var v=0;v<o.sel.ranges.length;v++){var m=o.sel.ranges[v];if(m.head.line==t&&m.head.ch<c.length){var y=E(t,c.length);gi(o,v,new Ts(y,y));break}}}function _o(e){qs=e}function $o(e,t,r,n,i){var o=e.doc;e.display.shift=!1,n||(n=o.sel);var l=e.state.pasteIncoming||"paste"==i,s=es(t),a=null;if(l&&n.ranges.length>1)if(qs&&qs.text.join("\n")==t){if(n.ranges.length%qs.text.length==0){a=[];for(var u=0;u<qs.text.length;u++)a.push(o.splitLines(qs.text[u]))}}else s.length==n.ranges.length&&e.options.pasteLinesPerSelection&&(a=v(s,function(e){return[e]}));for(var c,f=n.ranges.length-1;f>=0;f--){var h=n.ranges[f],d=h.from(),p=h.to();h.empty()&&(r&&r>0?d=E(d.line,d.ch-r):e.state.overwrite&&!l?p=E(p.line,Math.min(M(o,p.line).text.length,p.ch+g(s).length)):qs&&qs.lineWise&&qs.text.join("\n")==t&&(d=p=E(d.line,0))),c=e.curOp.updateInput;var m={from:d,to:p,text:a?a[f%a.length]:s,origin:i||(l?"paste":e.state.cutIncoming?"cut":"+input")};Oi(e.doc,m),bt(e,"inputRead",e,m)}t&&!l&&Zo(e,t),jr(e),e.curOp.updateInput=c,e.curOp.typing=!0,e.state.pasteIncoming=e.state.cutIncoming=!1}function qo(e,t){var r=e.clipboardData&&e.clipboardData.getData("Text");if(r)return e.preventDefault(),t.isReadOnly()||t.options.disableInput||hn(t,function(){return $o(t,r,0,null,"paste")}),!0}function Zo(e,t){if(e.options.electricChars&&e.options.smartIndent)for(var r=e.doc.sel,n=r.ranges.length-1;n>=0;n--){var i=r.ranges[n];if(!(i.head.ch>100||n&&r.ranges[n-1].head.line==i.head.line)){var o=e.getModeAt(i.head),l=!1;if(o.electricChars){for(var s=0;s<o.electricChars.length;s++)if(t.indexOf(o.electricChars.charAt(s))>-1){l=Yo(e,i.head.line,"smart");break}}else o.electricInput&&o.electricInput.test(M(e.doc,i.head.line).text.slice(0,i.head.ch))&&(l=Yo(e,i.head.line,"smart"));l&&bt(e,"electricInput",e,i.head.line)}}}function Qo(e){for(var t=[],r=[],n=0;n<e.doc.sel.ranges.length;n++){var i=e.doc.sel.ranges[n].head.line,o={anchor:E(i,0),head:E(i+1,0)};r.push(o),t.push(e.getRange(o.anchor,o.head))}return{text:t,ranges:r}}function Jo(e,t){e.setAttribute("autocorrect","off"),e.setAttribute("autocapitalize","off"),e.setAttribute("spellcheck",!!t)}function el(){var e=n("textarea",null,null,"position: absolute; bottom: -1em; padding: 0; width: 1px; height: 1em; outline: none"),t=n("div",[e],null,"overflow: hidden; position: relative; width: 3px; height: 0px;");return ml?e.style.width="1000px":e.setAttribute("wrap","off"),Ll&&(e.style.border="1px solid black"),Jo(e),t}function tl(e,t,r,n,i){function o(){var n=t.line+r;return!(n<e.first||n>=e.first+e.size)&&(t=new E(n,t.ch,t.sticky),u=M(e,n))}function l(n){var l;if(null==(l=i?go(e.cm,u,t,r):ho(u,t,r))){if(n||!o())return!1;t=po(i,e.cm,u,t.line,r)}else t=l;return!0}var s=t,a=r,u=M(e,t.line);if("char"==n)l();else if("column"==n)l(!0);else if("word"==n||"group"==n)for(var c=null,f="group"==n,h=e.cm&&e.cm.getHelper(t,"wordChars"),d=!0;!(r<0)||l(!d);d=!1){var p=u.text.charAt(t.ch)||"\n",g=x(p,h)?"w":f&&"\n"==p?"n":!f||/\s/.test(p)?null:"p";if(!f||d||g||(g="s"),c&&c!=g){r<0&&(r=1,l(),t.sticky="after");break}if(g&&(c=g),r>0&&!l(!d))break}var v=ki(e,t,s,a,!0);return I(s,v)&&(v.hitSide=!0),v}function rl(e,t,r,n){var i,o=e.doc,l=t.left;if("page"==n){var s=Math.min(e.display.wrapper.clientHeight,window.innerHeight||document.documentElement.clientHeight),a=Math.max(s-.5*mr(e.display),3);i=(r>0?t.bottom:t.top)+r*a}else"line"==n&&(i=r>0?t.bottom+3:t.top-3);for(var u;(u=cr(e,l,i)).outside;){if(r<0?i<=0:i>=o.height){u.hitSide=!0;break}i+=5*r}return u}function nl(e,t){var r=jt(e,t.line);if(!r||r.hidden)return null;var n=M(e.doc,t.line),i=Ut(r,n,t.line),o=Se(n,e.doc.direction),l="left";o&&(l=Ce(o,t.ch)%2?"right":"left");var s=_t(i.map,t.ch,l);return s.offset="right"==s.collapse?s.end:s.start,s}function il(e){for(var t=e;t;t=t.parentNode)if(/CodeMirror-gutter-wrapper/.test(t.className))return!0;return!1}function ol(e,t){return t&&(e.bad=!0),e}function ll(e,t,r,n,i){function o(e){return function(t){return t.id==e}}function l(){c&&(u+=f,c=!1)}function s(e){e&&(l(),u+=e)}function a(t){if(1==t.nodeType){var r=t.getAttribute("cm-text");if(null!=r)return void s(r||t.textContent.replace(/\u200b/g,""));var u,h=t.getAttribute("cm-marker");if(h){var d=e.findMarks(E(n,0),E(i+1,0),o(+h));return void(d.length&&(u=d[0].find(0))&&s(N(e.doc,u.from,u.to).join(f)))}if("false"==t.getAttribute("contenteditable"))return;var p=/^(pre|div|p)$/i.test(t.nodeName);p&&l();for(var g=0;g<t.childNodes.length;g++)a(t.childNodes[g]);p&&(c=!0)}else 3==t.nodeType&&s(t.nodeValue)}for(var u="",c=!1,f=e.doc.lineSeparator();a(t),t!=r;)t=t.nextSibling;return u}function sl(e,t,r){var n;if(t==e.display.lineDiv){if(!(n=e.display.lineDiv.childNodes[r]))return ol(e.clipPos(E(e.display.viewTo-1)),!0);t=null,r=0}else for(n=t;;n=n.parentNode){if(!n||n==e.display.lineDiv)return null;if(n.parentNode&&n.parentNode==e.display.lineDiv)break}for(var i=0;i<e.display.view.length;i++){var o=e.display.view[i];if(o.node==n)return al(o,t,r)}}function al(e,t,r){function n(t,r,n){for(var i=-1;i<(f?f.length:0);i++)for(var o=i<0?c.map:f[i],l=0;l<o.length;l+=3){var s=o[l+2];if(s==t||s==r){var a=W(i<0?e.line:e.rest[i]),u=o[l]+n;return(n<0||s!=t)&&(u=o[l+(n?1:0)]),E(a,u)}}}var i=e.text.firstChild,l=!1;if(!t||!o(i,t))return ol(E(W(e.line),0),!0);if(t==i&&(l=!0,t=i.childNodes[r],r=0,!t)){var s=e.rest?g(e.rest):e.line;return ol(E(W(s),s.text.length),l)}var a=3==t.nodeType?t:null,u=t;for(a||1!=t.childNodes.length||3!=t.firstChild.nodeType||(a=t.firstChild,r&&(r=a.nodeValue.length));u.parentNode!=i;)u=u.parentNode;var c=e.measure,f=c.maps,h=n(a,u,r);if(h)return ol(h,l);for(var d=u.nextSibling,p=a?a.nodeValue.length-r:0;d;d=d.nextSibling){if(h=n(d,d.firstChild,0))return ol(E(h.line,h.ch-p),l);p+=d.textContent.length}for(var v=u.previousSibling,m=r;v;v=v.previousSibling){if(h=n(v,v.firstChild,-1))return ol(E(h.line,h.ch+m),l);m+=v.textContent.length}}var ul=navigator.userAgent,cl=navigator.platform,fl=/gecko\/\d/i.test(ul),hl=/MSIE \d/.test(ul),dl=/Trident\/(?:[7-9]|\d{2,})\..*rv:(\d+)/.exec(ul),pl=/Edge\/(\d+)/.exec(ul),gl=hl||dl||pl,vl=gl&&(hl?document.documentMode||6:+(pl||dl)[1]),ml=!pl&&/WebKit\//.test(ul),yl=ml&&/Qt\/\d+\.\d+/.test(ul),bl=!pl&&/Chrome\//.test(ul),wl=/Opera\//.test(ul),xl=/Apple Computer/.test(navigator.vendor),Cl=/Mac OS X 1\d\D([8-9]|\d\d)\D/.test(ul),Sl=/PhantomJS/.test(ul),Ll=!pl&&/AppleWebKit/.test(ul)&&/Mobile\/\w+/.test(ul),kl=/Android/.test(ul),Tl=Ll||kl||/webOS|BlackBerry|Opera Mini|Opera Mobi|IEMobile/i.test(ul),Ml=Ll||/Mac/.test(cl),Nl=/\bCrOS\b/.test(ul),Ol=/win/i.test(cl),Al=wl&&ul.match(/Version\/(\d*\.\d*)/);Al&&(Al=Number(Al[1])),Al&&Al>=15&&(wl=!1,ml=!0);var Wl,Dl=Ml&&(yl||wl&&(null==Al||Al<12.11)),Hl=fl||gl&&vl>=9,Fl=function(t,r){var n=t.className,i=e(r).exec(n);if(i){var o=n.slice(i.index+i[0].length);t.className=n.slice(0,i.index)+(o?i[1]+o:"")}};Wl=document.createRange?function(e,t,r,n){var i=document.createRange();return i.setEnd(n||e,r),i.setStart(e,t),i}:function(e,t,r){var n=document.body.createTextRange();try{n.moveToElementText(e.parentNode)}catch(e){return n}return n.collapse(!0),n.moveEnd("character",r),n.moveStart("character",t),n};var El=function(e){e.select()};Ll?El=function(e){e.selectionStart=0,e.selectionEnd=e.value.length}:gl&&(El=function(e){try{e.select()}catch(e){}});var Pl=function(){this.id=null};Pl.prototype.set=function(e,t){clearTimeout(this.id),this.id=setTimeout(t,e)};var Il,zl,Rl=30,Bl={toString:function(){return"CodeMirror.Pass"}},Gl={scroll:!1},Ul={origin:"*mouse"},Vl={origin:"+move"},Kl=[""],jl=/[\u00df\u0587\u0590-\u05f4\u0600-\u06ff\u3040-\u309f\u30a0-\u30ff\u3400-\u4db5\u4e00-\u9fcc\uac00-\ud7af]/,Xl=/[\u0300-\u036f\u0483-\u0489\u0591-\u05bd\u05bf\u05c1\u05c2\u05c4\u05c5\u05c7\u0610-\u061a\u064b-\u065e\u0670\u06d6-\u06dc\u06de-\u06e4\u06e7\u06e8\u06ea-\u06ed\u0711\u0730-\u074a\u07a6-\u07b0\u07eb-\u07f3\u0816-\u0819\u081b-\u0823\u0825-\u0827\u0829-\u082d\u0900-\u0902\u093c\u0941-\u0948\u094d\u0951-\u0955\u0962\u0963\u0981\u09bc\u09be\u09c1-\u09c4\u09cd\u09d7\u09e2\u09e3\u0a01\u0a02\u0a3c\u0a41\u0a42\u0a47\u0a48\u0a4b-\u0a4d\u0a51\u0a70\u0a71\u0a75\u0a81\u0a82\u0abc\u0ac1-\u0ac5\u0ac7\u0ac8\u0acd\u0ae2\u0ae3\u0b01\u0b3c\u0b3e\u0b3f\u0b41-\u0b44\u0b4d\u0b56\u0b57\u0b62\u0b63\u0b82\u0bbe\u0bc0\u0bcd\u0bd7\u0c3e-\u0c40\u0c46-\u0c48\u0c4a-\u0c4d\u0c55\u0c56\u0c62\u0c63\u0cbc\u0cbf\u0cc2\u0cc6\u0ccc\u0ccd\u0cd5\u0cd6\u0ce2\u0ce3\u0d3e\u0d41-\u0d44\u0d4d\u0d57\u0d62\u0d63\u0dca\u0dcf\u0dd2-\u0dd4\u0dd6\u0ddf\u0e31\u0e34-\u0e3a\u0e47-\u0e4e\u0eb1\u0eb4-\u0eb9\u0ebb\u0ebc\u0ec8-\u0ecd\u0f18\u0f19\u0f35\u0f37\u0f39\u0f71-\u0f7e\u0f80-\u0f84\u0f86\u0f87\u0f90-\u0f97\u0f99-\u0fbc\u0fc6\u102d-\u1030\u1032-\u1037\u1039\u103a\u103d\u103e\u1058\u1059\u105e-\u1060\u1071-\u1074\u1082\u1085\u1086\u108d\u109d\u135f\u1712-\u1714\u1732-\u1734\u1752\u1753\u1772\u1773\u17b7-\u17bd\u17c6\u17c9-\u17d3\u17dd\u180b-\u180d\u18a9\u1920-\u1922\u1927\u1928\u1932\u1939-\u193b\u1a17\u1a18\u1a56\u1a58-\u1a5e\u1a60\u1a62\u1a65-\u1a6c\u1a73-\u1a7c\u1a7f\u1b00-\u1b03\u1b34\u1b36-\u1b3a\u1b3c\u1b42\u1b6b-\u1b73\u1b80\u1b81\u1ba2-\u1ba5\u1ba8\u1ba9\u1c2c-\u1c33\u1c36\u1c37\u1cd0-\u1cd2\u1cd4-\u1ce0\u1ce2-\u1ce8\u1ced\u1dc0-\u1de6\u1dfd-\u1dff\u200c\u200d\u20d0-\u20f0\u2cef-\u2cf1\u2de0-\u2dff\u302a-\u302f\u3099\u309a\ua66f-\ua672\ua67c\ua67d\ua6f0\ua6f1\ua802\ua806\ua80b\ua825\ua826\ua8c4\ua8e0-\ua8f1\ua926-\ua92d\ua947-\ua951\ua980-\ua982\ua9b3\ua9b6-\ua9b9\ua9bc\uaa29-\uaa2e\uaa31\uaa32\uaa35\uaa36\uaa43\uaa4c\uaab0\uaab2-\uaab4\uaab7\uaab8\uaabe\uaabf\uaac1\uabe5\uabe8\uabed\udc00-\udfff\ufb1e\ufe00-\ufe0f\ufe20-\ufe26\uff9e\uff9f]/,Yl=!1,_l=!1,$l=null,ql=function(){function e(e){return e<=247?r.charAt(e):1424<=e&&e<=1524?"R":1536<=e&&e<=1785?n.charAt(e-1536):1774<=e&&e<=2220?"r":8192<=e&&e<=8203?"w":8204==e?"b":"L"}function t(e,t,r){this.level=e,this.from=t,this.to=r}var r="bbbbbbbbbtstwsbbbbbbbbbbbbbbssstwNN%%%NNNNNN,N,N1111111111NNNNNNNLLLLLLLLLLLLLLLLLLLLLLLLLLNNNNNNLLLLLLLLLLLLLLLLLLLLLLLLLLNNNNbbbbbbsbbbbbbbbbbbbbbbbbbbbbbbbbb,N%%%%NNNNLNNNNN%%11NLNNN1LNNNNNLLLLLLLLLLLLLLLLLLLLLLLNLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLN",n="nnnnnnNNr%%r,rNNmmmmmmmmmmmrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrmmmmmmmmmmmmmmmmmmmmmnnnnnnnnnn%nnrrrmrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrmmmmmmmnNmmmmmmrrmmNmmmmrr1111111111",i=/[\u0590-\u05f4\u0600-\u06ff\u0700-\u08ac]/,o=/[stwN]/,l=/[LRr]/,s=/[Lb1n]/,a=/[1n]/;return function(r,n){var u="ltr"==n?"L":"R";if(0==r.length||"ltr"==n&&!i.test(r))return!1;for(var c=r.length,f=[],h=0;h<c;++h)f.push(e(r.charCodeAt(h)));for(var d=0,p=u;d<c;++d){var v=f[d];"m"==v?f[d]=p:p=v}for(var m=0,y=u;m<c;++m){var b=f[m];"1"==b&&"r"==y?f[m]="n":l.test(b)&&(y=b,"r"==b&&(f[m]="R"))}for(var w=1,x=f[0];w<c-1;++w){var C=f[w];"+"==C&&"1"==x&&"1"==f[w+1]?f[w]="1":","!=C||x!=f[w+1]||"1"!=x&&"n"!=x||(f[w]=x),x=C}for(var S=0;S<c;++S){var L=f[S];if(","==L)f[S]="N";else if("%"==L){var k=void 0;for(k=S+1;k<c&&"%"==f[k];++k);for(var T=S&&"!"==f[S-1]||k<c&&"1"==f[k]?"1":"N",M=S;M<k;++M)f[M]=T;S=k-1}}for(var N=0,O=u;N<c;++N){var A=f[N];"L"==O&&"1"==A?f[N]="L":l.test(A)&&(O=A)}for(var W=0;W<c;++W)if(o.test(f[W])){var D=void 0;for(D=W+1;D<c&&o.test(f[D]);++D);for(var H="L"==(W?f[W-1]:u),F=H==("L"==(D<c?f[D]:u))?H?"L":"R":u,E=W;E<D;++E)f[E]=F;W=D-1}for(var P,I=[],z=0;z<c;)if(s.test(f[z])){var R=z;for(++z;z<c&&s.test(f[z]);++z);I.push(new t(0,R,z))}else{var B=z,G=I.length;for(++z;z<c&&"L"!=f[z];++z);for(var U=B;U<z;)if(a.test(f[U])){B<U&&I.splice(G,0,new t(1,B,U));var V=U;for(++U;U<z&&a.test(f[U]);++U);I.splice(G,0,new t(2,V,U)),B=U}else++U;B<z&&I.splice(G,0,new t(1,B,z))}return 1==I[0].level&&(P=r.match(/^\s+/))&&(I[0].from=P[0].length,I.unshift(new t(0,0,P[0].length))),1==g(I).level&&(P=r.match(/\s+$/))&&(g(I).to-=P[0].length,I.push(new t(0,c-P[0].length,c))),"rtl"==n?I.reverse():I}}(),Zl=[],Ql=function(e,t,r){if(e.addEventListener)e.addEventListener(t,r,!1);else if(e.attachEvent)e.attachEvent("on"+t,r);else{var n=e._handlers||(e._handlers={});n[t]=(n[t]||Zl).concat(r)}},Jl=function(){if(gl&&vl<9)return!1;var e=n("div");return"draggable"in e||"dragDrop"in e}(),es=3!="\n\nb".split(/\n/).length?function(e){for(var t=0,r=[],n=e.length;t<=n;){var i=e.indexOf("\n",t);-1==i&&(i=e.length);var o=e.slice(t,"\r"==e.charAt(i-1)?i-1:i),l=o.indexOf("\r");-1!=l?(r.push(o.slice(0,l)),t+=l+1):(r.push(o),t=i+1)}return r}:function(e){return e.split(/\r\n?|\n/)},ts=window.getSelection?function(e){try{return e.selectionStart!=e.selectionEnd}catch(e){return!1}}:function(e){var t;try{t=e.ownerDocument.selection.createRange()}catch(e){}return!(!t||t.parentElement()!=e)&&0!=t.compareEndPoints("StartToEnd",t)},rs=function(){var e=n("div");return"oncopy"in e||(e.setAttribute("oncopy","return;"),"function"==typeof e.oncopy)}(),ns=null,is={},os={},ls={},ss=function(e,t,r){this.pos=this.start=0,this.string=e,this.tabSize=t||8,this.lastColumnPos=this.lastColumnValue=0,this.lineStart=0,this.lineOracle=r};ss.prototype.eol=function(){return this.pos>=this.string.length},ss.prototype.sol=function(){return this.pos==this.lineStart},ss.prototype.peek=function(){return this.string.charAt(this.pos)||void 0},ss.prototype.next=function(){if(this.pos<this.string.length)return this.string.charAt(this.pos++)},ss.prototype.eat=function(e){var t=this.string.charAt(this.pos);if("string"==typeof e?t==e:t&&(e.test?e.test(t):e(t)))return++this.pos,t},ss.prototype.eatWhile=function(e){for(var t=this.pos;this.eat(e););return this.pos>t},ss.prototype.eatSpace=function(){for(var e=this,t=this.pos;/[\s\u00a0]/.test(this.string.charAt(this.pos));)++e.pos;return this.pos>t},ss.prototype.skipToEnd=function(){this.pos=this.string.length},ss.prototype.skipTo=function(e){var t=this.string.indexOf(e,this.pos);if(t>-1)return this.pos=t,!0},ss.prototype.backUp=function(e){this.pos-=e},ss.prototype.column=function(){return this.lastColumnPos<this.start&&(this.lastColumnValue=f(this.string,this.start,this.tabSize,this.lastColumnPos,this.lastColumnValue),this.lastColumnPos=this.start),this.lastColumnValue-(this.lineStart?f(this.string,this.lineStart,this.tabSize):0)},ss.prototype.indentation=function(){return f(this.string,null,this.tabSize)-(this.lineStart?f(this.string,this.lineStart,this.tabSize):0)},ss.prototype.match=function(e,t,r){if("string"!=typeof e){var n=this.string.slice(this.pos).match(e);return n&&n.index>0?null:(n&&!1!==t&&(this.pos+=n[0].length),n)}var i=function(e){return r?e.toLowerCase():e};if(i(this.string.substr(this.pos,e.length))==i(e))return!1!==t&&(this.pos+=e.length),!0},ss.prototype.current=function(){return this.string.slice(this.start,this.pos)},ss.prototype.hideFirstChars=function(e,t){this.lineStart+=e;try{return t()}finally{this.lineStart-=e}},ss.prototype.lookAhead=function(e){var t=this.lineOracle;return t&&t.lookAhead(e)};var as=function(e,t){this.state=e,this.lookAhead=t},us=function(e,t,r,n){this.state=t,this.doc=e,this.line=r,this.maxLookAhead=n||0};us.prototype.lookAhead=function(e){var t=this.doc.getLine(this.line+e);return null!=t&&e>this.maxLookAhead&&(this.maxLookAhead=e),t},us.prototype.nextLine=function(){this.line++,this.maxLookAhead>0&&this.maxLookAhead--},us.fromSaved=function(e,t,r){return t instanceof as?new us(e,Ke(e.mode,t.state),r,t.lookAhead):new us(e,Ke(e.mode,t),r)},us.prototype.save=function(e){var t=!1!==e?Ke(this.doc.mode,this.state):this.state;return this.maxLookAhead>0?new as(t,this.maxLookAhead):t};var cs=function(e,t,r){this.start=e.start,this.end=e.pos,this.string=e.current(),this.type=t||null,this.state=r},fs=function(e,t,r){this.text=e,ne(this,t),this.height=r?r(this):1};fs.prototype.lineNo=function(){return W(this)},Ae(fs);var hs,ds={},ps={},gs=null,vs=null,ms={left:0,right:0,top:0,bottom:0},ys=function(e,t,r){this.cm=r;var i=this.vert=n("div",[n("div",null,null,"min-width: 1px")],"CodeMirror-vscrollbar"),o=this.horiz=n("div",[n("div",null,null,"height: 100%; min-height: 1px")],"CodeMirror-hscrollbar");e(i),e(o),Ql(i,"scroll",function(){i.clientHeight&&t(i.scrollTop,"vertical")}),Ql(o,"scroll",function(){o.clientWidth&&t(o.scrollLeft,"horizontal")}),this.checkedZeroWidth=!1,gl&&vl<8&&(this.horiz.style.minHeight=this.vert.style.minWidth="18px")};ys.prototype.update=function(e){var t=e.scrollWidth>e.clientWidth+1,r=e.scrollHeight>e.clientHeight+1,n=e.nativeBarWidth;if(r){this.vert.style.display="block",this.vert.style.bottom=t?n+"px":"0";var i=e.viewHeight-(t?n:0);this.vert.firstChild.style.height=Math.max(0,e.scrollHeight-e.clientHeight+i)+"px"}else this.vert.style.display="",this.vert.firstChild.style.height="0";if(t){this.horiz.style.display="block",this.horiz.style.right=r?n+"px":"0",this.horiz.style.left=e.barLeft+"px";var o=e.viewWidth-e.barLeft-(r?n:0);this.horiz.firstChild.style.width=Math.max(0,e.scrollWidth-e.clientWidth+o)+"px"}else this.horiz.style.display="",this.horiz.firstChild.style.width="0";return!this.checkedZeroWidth&&e.clientHeight>0&&(0==n&&this.zeroWidthHack(),this.checkedZeroWidth=!0),{right:r?n:0,bottom:t?n:0}},ys.prototype.setScrollLeft=function(e){this.horiz.scrollLeft!=e&&(this.horiz.scrollLeft=e),this.disableHoriz&&this.enableZeroWidthBar(this.horiz,this.disableHoriz,"horiz")},ys.prototype.setScrollTop=function(e){this.vert.scrollTop!=e&&(this.vert.scrollTop=e),this.disableVert&&this.enableZeroWidthBar(this.vert,this.disableVert,"vert")},ys.prototype.zeroWidthHack=function(){var e=Ml&&!Cl?"12px":"18px";this.horiz.style.height=this.vert.style.width=e,this.horiz.style.pointerEvents=this.vert.style.pointerEvents="none",this.disableHoriz=new Pl,this.disableVert=new Pl},ys.prototype.enableZeroWidthBar=function(e,t,r){function n(){var i=e.getBoundingClientRect();("vert"==r?document.elementFromPoint(i.right-1,(i.top+i.bottom)/2):document.elementFromPoint((i.right+i.left)/2,i.bottom-1))!=e?e.style.pointerEvents="none":t.set(1e3,n)}e.style.pointerEvents="auto",t.set(1e3,n)},ys.prototype.clear=function(){var e=this.horiz.parentNode;e.removeChild(this.horiz),e.removeChild(this.vert)};var bs=function(){};bs.prototype.update=function(){return{bottom:0,right:0}},bs.prototype.setScrollLeft=function(){},bs.prototype.setScrollTop=function(){},bs.prototype.clear=function(){};var ws={native:ys,null:bs},xs=0,Cs=function(e,t,r){var n=e.display;this.viewport=t,this.visible=Ir(n,e.doc,t),this.editorIsHidden=!n.wrapper.offsetWidth,this.wrapperHeight=n.wrapper.clientHeight,this.wrapperWidth=n.wrapper.clientWidth,this.oldDisplayWidth=Rt(e),this.force=r,this.dims=br(e),this.events=[]};Cs.prototype.signal=function(e,t){Oe(e,t)&&this.events.push(arguments)},Cs.prototype.finish=function(){for(var e=this,t=0;t<this.events.length;t++)Te.apply(null,e.events[t])};var Ss=0,Ls=null;gl?Ls=-.53:fl?Ls=15:bl?Ls=-.7:xl&&(Ls=-1/3);var ks=function(e,t){this.ranges=e,this.primIndex=t};ks.prototype.primary=function(){return this.ranges[this.primIndex]},ks.prototype.equals=function(e){var t=this;if(e==this)return!0;if(e.primIndex!=this.primIndex||e.ranges.length!=this.ranges.length)return!1;for(var r=0;r<this.ranges.length;r++){var n=t.ranges[r],i=e.ranges[r];if(!I(n.anchor,i.anchor)||!I(n.head,i.head))return!1}return!0},ks.prototype.deepCopy=function(){for(var e=this,t=[],r=0;r<this.ranges.length;r++)t[r]=new Ts(z(e.ranges[r].anchor),z(e.ranges[r].head));return new ks(t,this.primIndex)},ks.prototype.somethingSelected=function(){for(var e=this,t=0;t<this.ranges.length;t++)if(!e.ranges[t].empty())return!0;return!1},ks.prototype.contains=function(e,t){var r=this;t||(t=e);for(var n=0;n<this.ranges.length;n++){var i=r.ranges[n];if(P(t,i.from())>=0&&P(e,i.to())<=0)return n}return-1};var Ts=function(e,t){this.anchor=e,this.head=t};Ts.prototype.from=function(){return B(this.anchor,this.head)},Ts.prototype.to=function(){return R(this.anchor,this.head)},Ts.prototype.empty=function(){return this.head.line==this.anchor.line&&this.head.ch==this.anchor.ch},Bi.prototype={chunkSize:function(){return this.lines.length},removeInner:function(e,t){for(var r=this,n=e,i=e+t;n<i;++n){var o=r.lines[n];r.height-=o.height,ot(o),bt(o,"delete")}this.lines.splice(e,t)},collapse:function(e){e.push.apply(e,this.lines)},insertInner:function(e,t,r){var n=this;this.height+=r,this.lines=this.lines.slice(0,e).concat(t).concat(this.lines.slice(e));for(var i=0;i<t.length;++i)t[i].parent=n},iterN:function(e,t,r){for(var n=this,i=e+t;e<i;++e)if(r(n.lines[e]))return!0}},Gi.prototype={chunkSize:function(){return this.size},removeInner:function(e,t){var r=this;this.size-=t;for(var n=0;n<this.children.length;++n){var i=r.children[n],o=i.chunkSize();if(e<o){var l=Math.min(t,o-e),s=i.height;if(i.removeInner(e,l),r.height-=s-i.height,o==l&&(r.children.splice(n--,1),i.parent=null),0==(t-=l))break;e=0}else e-=o}if(this.size-t<25&&(this.children.length>1||!(this.children[0]instanceof Bi))){var a=[];this.collapse(a),this.children=[new Bi(a)],this.children[0].parent=this}},collapse:function(e){for(var t=this,r=0;r<this.children.length;++r)t.children[r].collapse(e)},insertInner:function(e,t,r){var n=this;this.size+=t.length,this.height+=r;for(var i=0;i<this.children.length;++i){var o=n.children[i],l=o.chunkSize();if(e<=l){if(o.insertInner(e,t,r),o.lines&&o.lines.length>50){for(var s=o.lines.length%25+25,a=s;a<o.lines.length;){var u=new Bi(o.lines.slice(a,a+=25));o.height-=u.height,n.children.splice(++i,0,u),u.parent=n}o.lines=o.lines.slice(0,s),n.maybeSpill()}break}e-=l}},maybeSpill:function(){if(!(this.children.length<=10)){var e=this;do{var t=new Gi(e.children.splice(e.children.length-5,5));if(e.parent){e.size-=t.size,e.height-=t.height;var r=h(e.parent.children,e);e.parent.children.splice(r+1,0,t)}else{var n=new Gi(e.children);n.parent=e,e.children=[n,t],e=n}t.parent=e.parent}while(e.children.length>10);e.parent.maybeSpill()}},iterN:function(e,t,r){for(var n=this,i=0;i<this.children.length;++i){var o=n.children[i],l=o.chunkSize();if(e<l){var s=Math.min(t,l-e);if(o.iterN(e,s,r))return!0;if(0==(t-=s))break;e=0}else e-=l}}};var Ms=function(e,t,r){var n=this;if(r)for(var i in r)r.hasOwnProperty(i)&&(n[i]=r[i]);this.doc=e,this.node=t};Ms.prototype.clear=function(){var e=this,t=this.doc.cm,r=this.line.widgets,n=this.line,i=W(n);if(null!=i&&r){for(var o=0;o<r.length;++o)r[o]==e&&r.splice(o--,1);r.length||(n.widgets=null);var l=Ht(this);A(n,Math.max(0,n.height-l)),t&&(hn(t,function(){Ui(t,n,-l),mn(t,i,"widget")}),bt(t,"lineWidgetCleared",t,this,i))}},Ms.prototype.changed=function(){var e=this,t=this.height,r=this.doc.cm,n=this.line;this.height=null;var i=Ht(this)-t;i&&(A(n,n.height+i),r&&hn(r,function(){r.curOp.forceUpdate=!0,Ui(r,n,i),bt(r,"lineWidgetChanged",r,e,W(n))}))},Ae(Ms);var Ns=0,Os=function(e,t){this.lines=[],this.type=t,this.doc=e,this.id=++Ns};Os.prototype.clear=function(){var e=this;if(!this.explicitlyCleared){var t=this.doc.cm,r=t&&!t.curOp;if(r&&nn(t),Oe(this,"clear")){var n=this.find();n&&bt(this,"clear",n.from,n.to)}for(var i=null,o=null,l=0;l<this.lines.length;++l){var s=e.lines[l],a=_(s.markedSpans,e);t&&!e.collapsed?mn(t,W(s),"text"):t&&(null!=a.to&&(o=W(s)),null!=a.from&&(i=W(s))),s.markedSpans=$(s.markedSpans,a),null==a.from&&e.collapsed&&!ve(e.doc,s)&&t&&A(s,mr(t.display))}if(t&&this.collapsed&&!t.options.lineWrapping)for(var u=0;u<this.lines.length;++u){var c=fe(e.lines[u]),f=be(c);f>t.display.maxLineLength&&(t.display.maxLine=c,t.display.maxLineLength=f,t.display.maxLineChanged=!0)}null!=i&&t&&this.collapsed&&vn(t,i,o+1),this.lines.length=0,this.explicitlyCleared=!0,this.atomic&&this.doc.cantEdit&&(this.doc.cantEdit=!1,t&&Ci(t.doc)),t&&bt(t,"markerCleared",t,this,i,o),r&&on(t),this.parent&&this.parent.clear()}},Os.prototype.find=function(e,t){var r=this;null==e&&"bookmark"==this.type&&(e=1);for(var n,i,o=0;o<this.lines.length;++o){var l=r.lines[o],s=_(l.markedSpans,r);if(null!=s.from&&(n=E(t?l:W(l),s.from),-1==e))return n;if(null!=s.to&&(i=E(t?l:W(l),s.to),1==e))return i}return n&&{from:n,to:i}},Os.prototype.changed=function(){var e=this,t=this.find(-1,!0),r=this,n=this.doc.cm;t&&n&&hn(n,function(){var i=t.line,o=W(t.line),l=jt(n,o);if(l&&(Qt(l),n.curOp.selectionChanged=n.curOp.forceUpdate=!0),n.curOp.updateMaxLine=!0,!ve(r.doc,i)&&null!=r.height){var s=r.height;r.height=null;var a=Ht(r)-s;a&&A(i,i.height+a)}bt(n,"markerChanged",n,e)})},Os.prototype.attachLine=function(e){if(!this.lines.length&&this.doc.cm){var t=this.doc.cm.curOp;t.maybeHiddenMarkers&&-1!=h(t.maybeHiddenMarkers,this)||(t.maybeUnhiddenMarkers||(t.maybeUnhiddenMarkers=[])).push(this)}this.lines.push(e)},Os.prototype.detachLine=function(e){if(this.lines.splice(h(this.lines,e),1),!this.lines.length&&this.doc.cm){var t=this.doc.cm.curOp;(t.maybeHiddenMarkers||(t.maybeHiddenMarkers=[])).push(this)}},Ae(Os);var As=function(e,t){var r=this;this.markers=e,this.primary=t;for(var n=0;n<e.length;++n)e[n].parent=r};As.prototype.clear=function(){var e=this;if(!this.explicitlyCleared){this.explicitlyCleared=!0;for(var t=0;t<this.markers.length;++t)e.markers[t].clear();bt(this,"clear")}},As.prototype.find=function(e,t){return this.primary.find(e,t)},Ae(As);var Ws=0,Ds=function(e,t,r,n,i){if(!(this instanceof Ds))return new Ds(e,t,r,n,i);null==r&&(r=0),Gi.call(this,[new Bi([new fs("",null)])]),this.first=r,this.scrollTop=this.scrollLeft=0,this.cantEdit=!1,this.cleanGeneration=1,this.modeFrontier=this.highlightFrontier=r;var o=E(r,0);this.sel=Rn(o),this.history=new Jn(null),this.id=++Ws,this.modeOption=t,this.lineSep=n,this.direction="rtl"==i?"rtl":"ltr",this.extend=!1,"string"==typeof e&&(e=this.splitLines(e)),_n(this,{from:o,to:o,text:e}),bi(this,Rn(o),Gl)};Ds.prototype=b(Gi.prototype,{constructor:Ds,iter:function(e,t,r){r?this.iterN(e-this.first,t-e,r):this.iterN(this.first,this.first+this.size,e)},insert:function(e,t){for(var r=0,n=0;n<t.length;++n)r+=t[n].height;this.insertInner(e-this.first,t,r)},remove:function(e,t){this.removeInner(e-this.first,t)},getValue:function(e){var t=O(this,this.first,this.first+this.size);return!1===e?t:t.join(e||this.lineSeparator())},setValue:gn(function(e){var t=E(this.first,0),r=this.first+this.size-1;Oi(this,{from:t,to:E(r,M(this,r).text.length),text:this.splitLines(e),origin:"setValue",full:!0},!0),this.cm&&Xr(this.cm,0,0),bi(this,Rn(t),Gl)}),replaceRange:function(e,t,r,n){Ei(this,e,t=U(this,t),r=r?U(this,r):t,n)},getRange:function(e,t,r){var n=N(this,U(this,e),U(this,t));return!1===r?n:n.join(r||this.lineSeparator())},getLine:function(e){var t=this.getLineHandle(e);return t&&t.text},getLineHandle:function(e){if(H(this,e))return M(this,e)},getLineNumber:function(e){return W(e)},getLineHandleVisualStart:function(e){return"number"==typeof e&&(e=M(this,e)),fe(e)},lineCount:function(){return this.size},firstLine:function(){return this.first},lastLine:function(){return this.first+this.size-1},clipPos:function(e){return U(this,e)},getCursor:function(e){var t=this.sel.primary();return null==e||"head"==e?t.head:"anchor"==e?t.anchor:"end"==e||"to"==e||!1===e?t.to():t.from()},listSelections:function(){return this.sel.ranges},somethingSelected:function(){return this.sel.somethingSelected()},setCursor:gn(function(e,t,r){vi(this,U(this,"number"==typeof e?E(e,t||0):e),null,r)}),setSelection:gn(function(e,t,r){vi(this,U(this,e),U(this,t||e),r)}),extendSelection:gn(function(e,t,r){di(this,U(this,e),t&&U(this,t),r)}),extendSelections:gn(function(e,t){pi(this,K(this,e),t)}),extendSelectionsBy:gn(function(e,t){pi(this,K(this,v(this.sel.ranges,e)),t)}),setSelections:gn(function(e,t,r){var n=this;if(e.length){for(var i=[],o=0;o<e.length;o++)i[o]=new Ts(U(n,e[o].anchor),U(n,e[o].head));null==t&&(t=Math.min(e.length-1,this.sel.primIndex)),bi(this,zn(i,t),r)}}),addSelection:gn(function(e,t,r){var n=this.sel.ranges.slice(0);n.push(new Ts(U(this,e),U(this,t||e))),bi(this,zn(n,n.length-1),r)}),getSelection:function(e){for(var t,r=this,n=this.sel.ranges,i=0;i<n.length;i++){var o=N(r,n[i].from(),n[i].to());t=t?t.concat(o):o}return!1===e?t:t.join(e||this.lineSeparator())},getSelections:function(e){for(var t=this,r=[],n=this.sel.ranges,i=0;i<n.length;i++){var o=N(t,n[i].from(),n[i].to());!1!==e&&(o=o.join(e||t.lineSeparator())),r[i]=o}return r},replaceSelection:function(e,t,r){for(var n=[],i=0;i<this.sel.ranges.length;i++)n[i]=e;this.replaceSelections(n,t,r||"+input")},replaceSelections:gn(function(e,t,r){for(var n=this,i=[],o=this.sel,l=0;l<o.ranges.length;l++){var s=o.ranges[l];i[l]={from:s.from(),to:s.to(),text:n.splitLines(e[l]),origin:r}}for(var a=t&&"end"!=t&&Kn(this,i,t),u=i.length-1;u>=0;u--)Oi(n,i[u]);a?yi(this,a):this.cm&&jr(this.cm)}),undo:gn(function(){Wi(this,"undo")}),redo:gn(function(){Wi(this,"redo")}),undoSelection:gn(function(){Wi(this,"undo",!0)}),redoSelection:gn(function(){Wi(this,"redo",!0)}),setExtending:function(e){this.extend=e},getExtending:function(){return this.extend},historySize:function(){for(var e=this.history,t=0,r=0,n=0;n<e.done.length;n++)e.done[n].ranges||++t;for(var i=0;i<e.undone.length;i++)e.undone[i].ranges||++r;return{undo:t,redo:r}},clearHistory:function(){this.history=new Jn(this.history.maxGeneration)},markClean:function(){this.cleanGeneration=this.changeGeneration(!0)},changeGeneration:function(e){return e&&(this.history.lastOp=this.history.lastSelOp=this.history.lastOrigin=null),this.history.generation},isClean:function(e){return this.history.generation==(e||this.cleanGeneration)},getHistory:function(){return{done:fi(this.history.done),undone:fi(this.history.undone)}},setHistory:function(e){var t=this.history=new Jn(this.history.maxGeneration);t.done=fi(e.done.slice(0),null,!0),t.undone=fi(e.undone.slice(0),null,!0)},setGutterMarker:gn(function(e,t,r){return Ri(this,e,"gutter",function(e){var n=e.gutterMarkers||(e.gutterMarkers={});return n[t]=r,!r&&C(n)&&(e.gutterMarkers=null),!0})}),clearGutter:gn(function(e){var t=this;this.iter(function(r){r.gutterMarkers&&r.gutterMarkers[e]&&Ri(t,r,"gutter",function(){return r.gutterMarkers[e]=null,C(r.gutterMarkers)&&(r.gutterMarkers=null),!0})})}),lineInfo:function(e){var t;if("number"==typeof e){if(!H(this,e))return null;if(t=e,!(e=M(this,e)))return null}else if(null==(t=W(e)))return null;return{line:t,handle:e,text:e.text,gutterMarkers:e.gutterMarkers,textClass:e.textClass,bgClass:e.bgClass,wrapClass:e.wrapClass,widgets:e.widgets}},addLineClass:gn(function(t,r,n){return Ri(this,t,"gutter"==r?"gutter":"class",function(t){var i="text"==r?"textClass":"background"==r?"bgClass":"gutter"==r?"gutterClass":"wrapClass";if(t[i]){if(e(n).test(t[i]))return!1;t[i]+=" "+n}else t[i]=n;return!0})}),removeLineClass:gn(function(t,r,n){return Ri(this,t,"gutter"==r?"gutter":"class",function(t){var i="text"==r?"textClass":"background"==r?"bgClass":"gutter"==r?"gutterClass":"wrapClass",o=t[i];if(!o)return!1;if(null==n)t[i]=null;else{var l=o.match(e(n));if(!l)return!1;var s=l.index+l[0].length;t[i]=o.slice(0,l.index)+(l.index&&s!=o.length?" ":"")+o.slice(s)||null}return!0})}),addLineWidget:gn(function(e,t,r){return Vi(this,e,t,r)}),removeLineWidget:function(e){e.clear()},markText:function(e,t,r){return Ki(this,U(this,e),U(this,t),r,r&&r.type||"range")},setBookmark:function(e,t){var r={replacedWith:t&&(null==t.nodeType?t.widget:t),insertLeft:t&&t.insertLeft,clearWhenEmpty:!1,shared:t&&t.shared,handleMouseEvents:t&&t.handleMouseEvents};return e=U(this,e),Ki(this,e,e,r,"bookmark")},findMarksAt:function(e){var t=[],r=M(this,(e=U(this,e)).line).markedSpans;if(r)for(var n=0;n<r.length;++n){var i=r[n];(null==i.from||i.from<=e.ch)&&(null==i.to||i.to>=e.ch)&&t.push(i.marker.parent||i.marker)}return t},findMarks:function(e,t,r){e=U(this,e),t=U(this,t);var n=[],i=e.line;return this.iter(e.line,t.line+1,function(o){var l=o.markedSpans;if(l)for(var s=0;s<l.length;s++){var a=l[s];null!=a.to&&i==e.line&&e.ch>=a.to||null==a.from&&i!=e.line||null!=a.from&&i==t.line&&a.from>=t.ch||r&&!r(a.marker)||n.push(a.marker.parent||a.marker)}++i}),n},getAllMarks:function(){var e=[];return this.iter(function(t){var r=t.markedSpans;if(r)for(var n=0;n<r.length;++n)null!=r[n].from&&e.push(r[n].marker)}),e},posFromIndex:function(e){var t,r=this.first,n=this.lineSeparator().length;return this.iter(function(i){var o=i.text.length+n;if(o>e)return t=e,!0;e-=o,++r}),U(this,E(r,t))},indexFromPos:function(e){var t=(e=U(this,e)).ch;if(e.line<this.first||e.ch<0)return 0;var r=this.lineSeparator().length;return this.iter(this.first,e.line,function(e){t+=e.text.length+r}),t},copy:function(e){var t=new Ds(O(this,this.first,this.first+this.size),this.modeOption,this.first,this.lineSep,this.direction);return t.scrollTop=this.scrollTop,t.scrollLeft=this.scrollLeft,t.sel=this.sel,t.extend=!1,e&&(t.history.undoDepth=this.history.undoDepth,t.setHistory(this.getHistory())),t},linkedDoc:function(e){e||(e={});var t=this.first,r=this.first+this.size;null!=e.from&&e.from>t&&(t=e.from),null!=e.to&&e.to<r&&(r=e.to);var n=new Ds(O(this,t,r),e.mode||this.modeOption,t,this.lineSep,this.direction);return e.sharedHist&&(n.history=this.history),(this.linked||(this.linked=[])).push({doc:n,sharedHist:e.sharedHist}),n.linked=[{doc:this,isParent:!0,sharedHist:e.sharedHist}],Yi(n,Xi(this)),n},unlinkDoc:function(e){var t=this;if(e instanceof jo&&(e=e.doc),this.linked)for(var r=0;r<this.linked.length;++r)if(t.linked[r].doc==e){t.linked.splice(r,1),e.unlinkDoc(t),_i(Xi(t));break}if(e.history==this.history){var n=[e.id];$n(e,function(e){return n.push(e.id)},!0),e.history=new Jn(null),e.history.done=fi(this.history.done,n),e.history.undone=fi(this.history.undone,n)}},iterLinkedDocs:function(e){$n(this,e)},getMode:function(){return this.mode},getEditor:function(){return this.cm},splitLines:function(e){return this.lineSep?e.split(this.lineSep):es(e)},lineSeparator:function(){return this.lineSep||"\n"},setDirection:gn(function(e){"rtl"!=e&&(e="ltr"),e!=this.direction&&(this.direction=e,this.iter(function(e){return e.order=null}),this.cm&&Qn(this.cm))})}),Ds.prototype.eachLine=Ds.prototype.iter;for(var Hs=0,Fs=!1,Es={3:"Enter",8:"Backspace",9:"Tab",13:"Enter",16:"Shift",17:"Ctrl",18:"Alt",19:"Pause",20:"CapsLock",27:"Esc",32:"Space",33:"PageUp",34:"PageDown",35:"End",36:"Home",37:"Left",38:"Up",39:"Right",40:"Down",44:"PrintScrn",45:"Insert",46:"Delete",59:";",61:"=",91:"Mod",92:"Mod",93:"Mod",106:"*",107:"=",109:"-",110:".",111:"/",127:"Delete",173:"-",186:";",187:"=",188:",",189:"-",190:".",191:"/",192:"`",219:"[",220:"\\",221:"]",222:"'",63232:"Up",63233:"Down",63234:"Left",63235:"Right",63272:"Delete",63273:"Home",63275:"End",63276:"PageUp",63277:"PageDown",63302:"Insert"},Ps=0;Ps<10;Ps++)Es[Ps+48]=Es[Ps+96]=String(Ps);for(var Is=65;Is<=90;Is++)Es[Is]=String.fromCharCode(Is);for(var zs=1;zs<=12;zs++)Es[zs+111]=Es[zs+63235]="F"+zs;var Rs={};Rs.basic={Left:"goCharLeft",Right:"goCharRight",Up:"goLineUp",Down:"goLineDown",End:"goLineEnd",Home:"goLineStartSmart",PageUp:"goPageUp",PageDown:"goPageDown",Delete:"delCharAfter",Backspace:"delCharBefore","Shift-Backspace":"delCharBefore",Tab:"defaultTab","Shift-Tab":"indentAuto",Enter:"newlineAndIndent",Insert:"toggleOverwrite",Esc:"singleSelection"},Rs.pcDefault={"Ctrl-A":"selectAll","Ctrl-D":"deleteLine","Ctrl-Z":"undo","Shift-Ctrl-Z":"redo","Ctrl-Y":"redo","Ctrl-Home":"goDocStart","Ctrl-End":"goDocEnd","Ctrl-Up":"goLineUp","Ctrl-Down":"goLineDown","Ctrl-Left":"goGroupLeft","Ctrl-Right":"goGroupRight","Alt-Left":"goLineStart","Alt-Right":"goLineEnd","Ctrl-Backspace":"delGroupBefore","Ctrl-Delete":"delGroupAfter","Ctrl-S":"save","Ctrl-F":"find","Ctrl-G":"findNext","Shift-Ctrl-G":"findPrev","Shift-Ctrl-F":"replace","Shift-Ctrl-R":"replaceAll","Ctrl-[":"indentLess","Ctrl-]":"indentMore","Ctrl-U":"undoSelection","Shift-Ctrl-U":"redoSelection","Alt-U":"redoSelection",fallthrough:"basic"},Rs.emacsy={"Ctrl-F":"goCharRight","Ctrl-B":"goCharLeft","Ctrl-P":"goLineUp","Ctrl-N":"goLineDown","Alt-F":"goWordRight","Alt-B":"goWordLeft","Ctrl-A":"goLineStart","Ctrl-E":"goLineEnd","Ctrl-V":"goPageDown","Shift-Ctrl-V":"goPageUp","Ctrl-D":"delCharAfter","Ctrl-H":"delCharBefore","Alt-D":"delWordAfter","Alt-Backspace":"delWordBefore","Ctrl-K":"killLine","Ctrl-T":"transposeChars","Ctrl-O":"openLine"},Rs.macDefault={"Cmd-A":"selectAll","Cmd-D":"deleteLine","Cmd-Z":"undo","Shift-Cmd-Z":"redo","Cmd-Y":"redo","Cmd-Home":"goDocStart","Cmd-Up":"goDocStart","Cmd-End":"goDocEnd","Cmd-Down":"goDocEnd","Alt-Left":"goGroupLeft","Alt-Right":"goGroupRight","Cmd-Left":"goLineLeft","Cmd-Right":"goLineRight","Alt-Backspace":"delGroupBefore","Ctrl-Alt-Backspace":"delGroupAfter","Alt-Delete":"delGroupAfter","Cmd-S":"save","Cmd-F":"find","Cmd-G":"findNext","Shift-Cmd-G":"findPrev","Cmd-Alt-F":"replace","Shift-Cmd-Alt-F":"replaceAll","Cmd-[":"indentLess","Cmd-]":"indentMore","Cmd-Backspace":"delWrappedLineLeft","Cmd-Delete":"delWrappedLineRight","Cmd-U":"undoSelection","Shift-Cmd-U":"redoSelection","Ctrl-Up":"goDocStart","Ctrl-Down":"goDocEnd",fallthrough:["basic","emacsy"]},Rs.default=Ml?Rs.macDefault:Rs.pcDefault;var Bs={selectAll:Mi,singleSelection:function(e){return e.setSelection(e.getCursor("anchor"),e.getCursor("head"),Gl)},killLine:function(e){return co(e,function(t){if(t.empty()){var r=M(e.doc,t.head.line).text.length;return t.head.ch==r&&t.head.line<e.lastLine()?{from:t.head,to:E(t.head.line+1,0)}:{from:t.head,to:E(t.head.line,r)}}return{from:t.from(),to:t.to()}})},deleteLine:function(e){return co(e,function(t){return{from:E(t.from().line,0),to:U(e.doc,E(t.to().line+1,0))}})},delLineLeft:function(e){return co(e,function(e){return{from:E(e.from().line,0),to:e.from()}})},delWrappedLineLeft:function(e){return co(e,function(t){var r=e.charCoords(t.head,"div").top+5;return{from:e.coordsChar({left:0,top:r},"div"),to:t.from()}})},delWrappedLineRight:function(e){return co(e,function(t){var r=e.charCoords(t.head,"div").top+5,n=e.coordsChar({left:e.display.lineDiv.offsetWidth+100,top:r},"div");return{from:t.from(),to:n}})},undo:function(e){return e.undo()},redo:function(e){return e.redo()},undoSelection:function(e){return e.undoSelection()},redoSelection:function(e){return e.redoSelection()},goDocStart:function(e){return e.extendSelection(E(e.firstLine(),0))},goDocEnd:function(e){return e.extendSelection(E(e.lastLine()))},goLineStart:function(e){return e.extendSelectionsBy(function(t){return vo(e,t.head.line)},{origin:"+move",bias:1})},goLineStartSmart:function(e){return e.extendSelectionsBy(function(t){return yo(e,t.head)},{origin:"+move",bias:1})},goLineEnd:function(e){return e.extendSelectionsBy(function(t){return mo(e,t.head.line)},{origin:"+move",bias:-1})},goLineRight:function(e){return e.extendSelectionsBy(function(t){var r=e.cursorCoords(t.head,"div").top+5;return e.coordsChar({left:e.display.lineDiv.offsetWidth+100,top:r},"div")},Vl)},goLineLeft:function(e){return e.extendSelectionsBy(function(t){var r=e.cursorCoords(t.head,"div").top+5;return e.coordsChar({left:0,top:r},"div")},Vl)},goLineLeftSmart:function(e){return e.extendSelectionsBy(function(t){var r=e.cursorCoords(t.head,"div").top+5,n=e.coordsChar({left:0,top:r},"div");return n.ch<e.getLine(n.line).search(/\S/)?yo(e,t.head):n},Vl)},goLineUp:function(e){return e.moveV(-1,"line")},goLineDown:function(e){return e.moveV(1,"line")},goPageUp:function(e){return e.moveV(-1,"page")},goPageDown:function(e){return e.moveV(1,"page")},goCharLeft:function(e){return e.moveH(-1,"char")},goCharRight:function(e){return e.moveH(1,"char")},goColumnLeft:function(e){return e.moveH(-1,"column")},goColumnRight:function(e){return e.moveH(1,"column")},goWordLeft:function(e){return e.moveH(-1,"word")},goGroupRight:function(e){return e.moveH(1,"group")},goGroupLeft:function(e){return e.moveH(-1,"group")},goWordRight:function(e){return e.moveH(1,"word")},delCharBefore:function(e){return e.deleteH(-1,"char")},delCharAfter:function(e){return e.deleteH(1,"char")},delWordBefore:function(e){return e.deleteH(-1,"word")},delWordAfter:function(e){return e.deleteH(1,"word")},delGroupBefore:function(e){return e.deleteH(-1,"group")},delGroupAfter:function(e){return e.deleteH(1,"group")},indentAuto:function(e){return e.indentSelection("smart")},indentMore:function(e){return e.indentSelection("add")},indentLess:function(e){return e.indentSelection("subtract")},insertTab:function(e){return e.replaceSelection("\t")},insertSoftTab:function(e){for(var t=[],r=e.listSelections(),n=e.options.tabSize,i=0;i<r.length;i++){var o=r[i].from(),l=f(e.getLine(o.line),o.ch,n);t.push(p(n-l%n))}e.replaceSelections(t)},defaultTab:function(e){e.somethingSelected()?e.indentSelection("add"):e.execCommand("insertTab")},transposeChars:function(e){return hn(e,function(){for(var t=e.listSelections(),r=[],n=0;n<t.length;n++)if(t[n].empty()){var i=t[n].head,o=M(e.doc,i.line).text;if(o)if(i.ch==o.length&&(i=new E(i.line,i.ch-1)),i.ch>0)i=new E(i.line,i.ch+1),e.replaceRange(o.charAt(i.ch-1)+o.charAt(i.ch-2),E(i.line,i.ch-2),i,"+transpose");else if(i.line>e.doc.first){var l=M(e.doc,i.line-1).text;l&&(i=new E(i.line,1),e.replaceRange(o.charAt(0)+e.doc.lineSeparator()+l.charAt(l.length-1),E(i.line-1,l.length-1),i,"+transpose"))}r.push(new Ts(i,i))}e.setSelections(r)})},newlineAndIndent:function(e){return hn(e,function(){for(var t=e.listSelections(),r=t.length-1;r>=0;r--)e.replaceRange(e.doc.lineSeparator(),t[r].anchor,t[r].head,"+input");t=e.listSelections();for(var n=0;n<t.length;n++)e.indentLine(t[n].from().line,null,!0);jr(e)})},openLine:function(e){return e.replaceSelection("\n","start")},toggleOverwrite:function(e){return e.toggleOverwrite()}},Gs=new Pl,Us=null,Vs=function(e,t,r){this.time=e,this.pos=t,this.button=r};Vs.prototype.compare=function(e,t,r){return this.time+400>e&&0==P(t,this.pos)&&r==this.button};var Ks,js,Xs={toString:function(){return"CodeMirror.Init"}},Ys={},_s={};jo.defaults=Ys,jo.optionHandlers=_s;var $s=[];jo.defineInitHook=function(e){return $s.push(e)};var qs=null,Zs=function(e){this.cm=e,this.lastAnchorNode=this.lastAnchorOffset=this.lastFocusNode=this.lastFocusOffset=null,this.polling=new Pl,this.composing=null,this.gracePeriod=!1,this.readDOMTimeout=null};Zs.prototype.init=function(e){function t(e){if(!Me(i,e)){if(i.somethingSelected())_o({lineWise:!1,text:i.getSelections()}),"cut"==e.type&&i.replaceSelection("",null,"cut");else{if(!i.options.lineWiseCopyCut)return;var t=Qo(i);_o({lineWise:!0,text:t.text}),"cut"==e.type&&i.operation(function(){i.setSelections(t.ranges,0,Gl),i.replaceSelection("",null,"cut")})}if(e.clipboardData){e.clipboardData.clearData();var r=qs.text.join("\n");if(e.clipboardData.setData("Text",r),e.clipboardData.getData("Text")==r)return void e.preventDefault()}var l=el(),s=l.firstChild;i.display.lineSpace.insertBefore(l,i.display.lineSpace.firstChild),s.value=qs.text.join("\n");var a=document.activeElement;El(s),setTimeout(function(){i.display.lineSpace.removeChild(l),a.focus(),a==o&&n.showPrimarySelection()},50)}}var r=this,n=this,i=n.cm,o=n.div=e.lineDiv;Jo(o,i.options.spellcheck),Ql(o,"paste",function(e){Me(i,e)||qo(e,i)||vl<=11&&setTimeout(dn(i,function(){return r.updateFromDOM()}),20)}),Ql(o,"compositionstart",function(e){r.composing={data:e.data,done:!1}}),Ql(o,"compositionupdate",function(e){r.composing||(r.composing={data:e.data,done:!1})}),Ql(o,"compositionend",function(e){r.composing&&(e.data!=r.composing.data&&r.readFromDOMSoon(),r.composing.done=!0)}),Ql(o,"touchstart",function(){return n.forceCompositionEnd()}),Ql(o,"input",function(){r.composing||r.readFromDOMSoon()}),Ql(o,"copy",t),Ql(o,"cut",t)},Zs.prototype.prepareSelection=function(){var e=Tr(this.cm,!1);return e.focus=this.cm.state.focused,e},Zs.prototype.showSelection=function(e,t){e&&this.cm.display.view.length&&((e.focus||t)&&this.showPrimarySelection(),this.showMultipleSelections(e))},Zs.prototype.showPrimarySelection=function(){var e=window.getSelection(),t=this.cm,r=t.doc.sel.primary(),n=r.from(),i=r.to();if(t.display.viewTo==t.display.viewFrom||n.line>=t.display.viewTo||i.line<t.display.viewFrom)e.removeAllRanges();else{var o=sl(t,e.anchorNode,e.anchorOffset),l=sl(t,e.focusNode,e.focusOffset);if(!o||o.bad||!l||l.bad||0!=P(B(o,l),n)||0!=P(R(o,l),i)){var s=t.display.view,a=n.line>=t.display.viewFrom&&nl(t,n)||{node:s[0].measure.map[2],offset:0},u=i.line<t.display.viewTo&&nl(t,i);if(!u){var c=s[s.length-1].measure,f=c.maps?c.maps[c.maps.length-1]:c.map;u={node:f[f.length-1],offset:f[f.length-2]-f[f.length-3]}}if(a&&u){var h,d=e.rangeCount&&e.getRangeAt(0);try{h=Wl(a.node,a.offset,u.offset,u.node)}catch(e){}h&&(!fl&&t.state.focused?(e.collapse(a.node,a.offset),h.collapsed||(e.removeAllRanges(),e.addRange(h))):(e.removeAllRanges(),e.addRange(h)),d&&null==e.anchorNode?e.addRange(d):fl&&this.startGracePeriod()),this.rememberSelection()}else e.removeAllRanges()}}},Zs.prototype.startGracePeriod=function(){var e=this;clearTimeout(this.gracePeriod),this.gracePeriod=setTimeout(function(){e.gracePeriod=!1,e.selectionChanged()&&e.cm.operation(function(){return e.cm.curOp.selectionChanged=!0})},20)},Zs.prototype.showMultipleSelections=function(e){r(this.cm.display.cursorDiv,e.cursors),r(this.cm.display.selectionDiv,e.selection)},Zs.prototype.rememberSelection=function(){var e=window.getSelection();this.lastAnchorNode=e.anchorNode,this.lastAnchorOffset=e.anchorOffset,this.lastFocusNode=e.focusNode,this.lastFocusOffset=e.focusOffset},Zs.prototype.selectionInEditor=function(){var e=window.getSelection();if(!e.rangeCount)return!1;var t=e.getRangeAt(0).commonAncestorContainer;return o(this.div,t)},Zs.prototype.focus=function(){"nocursor"!=this.cm.options.readOnly&&(this.selectionInEditor()||this.showSelection(this.prepareSelection(),!0),this.div.focus())},Zs.prototype.blur=function(){this.div.blur()},Zs.prototype.getField=function(){return this.div},Zs.prototype.supportsTouch=function(){return!0},Zs.prototype.receivedFocus=function(){function e(){t.cm.state.focused&&(t.pollSelection(),t.polling.set(t.cm.options.pollInterval,e))}var t=this;this.selectionInEditor()?this.pollSelection():hn(this.cm,function(){return t.cm.curOp.selectionChanged=!0}),this.polling.set(this.cm.options.pollInterval,e)},Zs.prototype.selectionChanged=function(){var e=window.getSelection();return e.anchorNode!=this.lastAnchorNode||e.anchorOffset!=this.lastAnchorOffset||e.focusNode!=this.lastFocusNode||e.focusOffset!=this.lastFocusOffset},Zs.prototype.pollSelection=function(){if(null==this.readDOMTimeout&&!this.gracePeriod&&this.selectionChanged()){var e=window.getSelection(),t=this.cm;if(kl&&bl&&this.cm.options.gutters.length&&il(e.anchorNode))return this.cm.triggerOnKeyDown({type:"keydown",keyCode:8,preventDefault:Math.abs}),this.blur(),void this.focus();if(!this.composing){this.rememberSelection();var r=sl(t,e.anchorNode,e.anchorOffset),n=sl(t,e.focusNode,e.focusOffset);r&&n&&hn(t,function(){bi(t.doc,Rn(r,n),Gl),(r.bad||n.bad)&&(t.curOp.selectionChanged=!0)})}}},Zs.prototype.pollContent=function(){null!=this.readDOMTimeout&&(clearTimeout(this.readDOMTimeout),this.readDOMTimeout=null);var e=this.cm,t=e.display,r=e.doc.sel.primary(),n=r.from(),i=r.to();if(0==n.ch&&n.line>e.firstLine()&&(n=E(n.line-1,M(e.doc,n.line-1).length)),i.ch==M(e.doc,i.line).text.length&&i.line<e.lastLine()&&(i=E(i.line+1,0)),n.line<t.viewFrom||i.line>t.viewTo-1)return!1;var o,l,s;n.line==t.viewFrom||0==(o=Lr(e,n.line))?(l=W(t.view[0].line),s=t.view[0].node):(l=W(t.view[o].line),s=t.view[o-1].node.nextSibling);var a,u,c=Lr(e,i.line);if(c==t.view.length-1?(a=t.viewTo-1,u=t.lineDiv.lastChild):(a=W(t.view[c+1].line)-1,u=t.view[c+1].node.previousSibling),!s)return!1;for(var f=e.doc.splitLines(ll(e,s,u,l,a)),h=N(e.doc,E(l,0),E(a,M(e.doc,a).text.length));f.length>1&&h.length>1;)if(g(f)==g(h))f.pop(),h.pop(),a--;else{if(f[0]!=h[0])break;f.shift(),h.shift(),l++}for(var d=0,p=0,v=f[0],m=h[0],y=Math.min(v.length,m.length);d<y&&v.charCodeAt(d)==m.charCodeAt(d);)++d;for(var b=g(f),w=g(h),x=Math.min(b.length-(1==f.length?d:0),w.length-(1==h.length?d:0));p<x&&b.charCodeAt(b.length-p-1)==w.charCodeAt(w.length-p-1);)++p;if(1==f.length&&1==h.length&&l==n.line)for(;d&&d>n.ch&&b.charCodeAt(b.length-p-1)==w.charCodeAt(w.length-p-1);)d--,p++;f[f.length-1]=b.slice(0,b.length-p).replace(/^\u200b+/,""),f[0]=f[0].slice(d).replace(/\u200b+$/,"");var C=E(l,d),S=E(a,h.length?g(h).length-p:0);return f.length>1||f[0]||P(C,S)?(Ei(e.doc,f,C,S,"+input"),!0):void 0},Zs.prototype.ensurePolled=function(){this.forceCompositionEnd()},Zs.prototype.reset=function(){this.forceCompositionEnd()},Zs.prototype.forceCompositionEnd=function(){this.composing&&(clearTimeout(this.readDOMTimeout),this.composing=null,this.updateFromDOM(),this.div.blur(),this.div.focus())},Zs.prototype.readFromDOMSoon=function(){var e=this;null==this.readDOMTimeout&&(this.readDOMTimeout=setTimeout(function(){if(e.readDOMTimeout=null,e.composing){if(!e.composing.done)return;e.composing=null}e.updateFromDOM()},80))},Zs.prototype.updateFromDOM=function(){var e=this;!this.cm.isReadOnly()&&this.pollContent()||hn(this.cm,function(){return vn(e.cm)})},Zs.prototype.setUneditable=function(e){e.contentEditable="false"},Zs.prototype.onKeyPress=function(e){0!=e.charCode&&(e.preventDefault(),this.cm.isReadOnly()||dn(this.cm,$o)(this.cm,String.fromCharCode(null==e.charCode?e.keyCode:e.charCode),0))},Zs.prototype.readOnlyChanged=function(e){this.div.contentEditable=String("nocursor"!=e)},Zs.prototype.onContextMenu=function(){},Zs.prototype.resetPosition=function(){},Zs.prototype.needsContentAttribute=!0;var Qs=function(e){this.cm=e,this.prevInput="",this.pollingFast=!1,this.polling=new Pl,this.hasSelection=!1,this.composing=null};Qs.prototype.init=function(e){function t(e){if(!Me(i,e)){if(i.somethingSelected())_o({lineWise:!1,text:i.getSelections()});else{if(!i.options.lineWiseCopyCut)return;var t=Qo(i);_o({lineWise:!0,text:t.text}),"cut"==e.type?i.setSelections(t.ranges,null,Gl):(n.prevInput="",l.value=t.text.join("\n"),El(l))}"cut"==e.type&&(i.state.cutIncoming=!0)}}var r=this,n=this,i=this.cm,o=this.wrapper=el(),l=this.textarea=o.firstChild;e.wrapper.insertBefore(o,e.wrapper.firstChild),Ll&&(l.style.width="0px"),Ql(l,"input",function(){gl&&vl>=9&&r.hasSelection&&(r.hasSelection=null),n.poll()}),Ql(l,"paste",function(e){Me(i,e)||qo(e,i)||(i.state.pasteIncoming=!0,n.fastPoll())}),Ql(l,"cut",t),Ql(l,"copy",t),Ql(e.scroller,"paste",function(t){Ft(e,t)||Me(i,t)||(i.state.pasteIncoming=!0,n.focus())}),Ql(e.lineSpace,"selectstart",function(t){Ft(e,t)||We(t)}),Ql(l,"compositionstart",function(){var e=i.getCursor("from");n.composing&&n.composing.range.clear(),n.composing={start:e,range:i.markText(e,i.getCursor("to"),{className:"CodeMirror-composing"})}}),Ql(l,"compositionend",function(){n.composing&&(n.poll(),n.composing.range.clear(),n.composing=null)})},Qs.prototype.prepareSelection=function(){var e=this.cm,t=e.display,r=e.doc,n=Tr(e);if(e.options.moveInputWithCursor){var i=sr(e,r.sel.primary().head,"div"),o=t.wrapper.getBoundingClientRect(),l=t.lineDiv.getBoundingClientRect();n.teTop=Math.max(0,Math.min(t.wrapper.clientHeight-10,i.top+l.top-o.top)),n.teLeft=Math.max(0,Math.min(t.wrapper.clientWidth-10,i.left+l.left-o.left))}return n},Qs.prototype.showSelection=function(e){var t=this.cm.display;r(t.cursorDiv,e.cursors),r(t.selectionDiv,e.selection),null!=e.teTop&&(this.wrapper.style.top=e.teTop+"px",this.wrapper.style.left=e.teLeft+"px")},Qs.prototype.reset=function(e){if(!this.contextMenuPending&&!this.composing){var t=this.cm;if(t.somethingSelected()){this.prevInput="";var r=t.getSelection();this.textarea.value=r,t.state.focused&&El(this.textarea),gl&&vl>=9&&(this.hasSelection=r)}else e||(this.prevInput=this.textarea.value="",gl&&vl>=9&&(this.hasSelection=null))}},Qs.prototype.getField=function(){return this.textarea},Qs.prototype.supportsTouch=function(){return!1},Qs.prototype.focus=function(){if("nocursor"!=this.cm.options.readOnly&&(!Tl||l()!=this.textarea))try{this.textarea.focus()}catch(e){}},Qs.prototype.blur=function(){this.textarea.blur()},Qs.prototype.resetPosition=function(){this.wrapper.style.top=this.wrapper.style.left=0},Qs.prototype.receivedFocus=function(){this.slowPoll()},Qs.prototype.slowPoll=function(){var e=this;this.pollingFast||this.polling.set(this.cm.options.pollInterval,function(){e.poll(),e.cm.state.focused&&e.slowPoll()})},Qs.prototype.fastPoll=function(){function e(){r.poll()||t?(r.pollingFast=!1,r.slowPoll()):(t=!0,r.polling.set(60,e))}var t=!1,r=this;r.pollingFast=!0,r.polling.set(20,e)},Qs.prototype.poll=function(){var e=this,t=this.cm,r=this.textarea,n=this.prevInput;if(this.contextMenuPending||!t.state.focused||ts(r)&&!n&&!this.composing||t.isReadOnly()||t.options.disableInput||t.state.keySeq)return!1;var i=r.value;if(i==n&&!t.somethingSelected())return!1;if(gl&&vl>=9&&this.hasSelection===i||Ml&&/[\uf700-\uf7ff]/.test(i))return t.display.input.reset(),!1;if(t.doc.sel==t.display.selForContextMenu){var o=i.charCodeAt(0);if(8203!=o||n||(n="​"),8666==o)return this.reset(),this.cm.execCommand("undo")}for(var l=0,s=Math.min(n.length,i.length);l<s&&n.charCodeAt(l)==i.charCodeAt(l);)++l;return hn(t,function(){$o(t,i.slice(l),n.length-l,null,e.composing?"*compose":null),i.length>1e3||i.indexOf("\n")>-1?r.value=e.prevInput="":e.prevInput=i,e.composing&&(e.composing.range.clear(),e.composing.range=t.markText(e.composing.start,t.getCursor("to"),{className:"CodeMirror-composing"}))}),!0},Qs.prototype.ensurePolled=function(){this.pollingFast&&this.poll()&&(this.pollingFast=!1)},Qs.prototype.onKeyPress=function(){gl&&vl>=9&&(this.hasSelection=null),this.fastPoll()},Qs.prototype.onContextMenu=function(e){function t(){if(null!=l.selectionStart){var e=i.somethingSelected(),t="​"+(e?l.value:"");l.value="⇚",l.value=t,n.prevInput=e?"":"​",l.selectionStart=1,l.selectionEnd=t.length,o.selForContextMenu=i.doc.sel}}function r(){if(n.contextMenuPending=!1,n.wrapper.style.cssText=c,l.style.cssText=u,gl&&vl<9&&o.scrollbars.setScrollTop(o.scroller.scrollTop=a),null!=l.selectionStart){(!gl||gl&&vl<9)&&t();var e=0,r=function(){o.selForContextMenu==i.doc.sel&&0==l.selectionStart&&l.selectionEnd>0&&"​"==n.prevInput?dn(i,Mi)(i):e++<10?o.detectingSelectAll=setTimeout(r,500):(o.selForContextMenu=null,o.input.reset())};o.detectingSelectAll=setTimeout(r,200)}}var n=this,i=n.cm,o=i.display,l=n.textarea,s=Sr(i,e),a=o.scroller.scrollTop;if(s&&!wl){i.options.resetSelectionOnContextMenu&&-1==i.doc.sel.contains(s)&&dn(i,bi)(i.doc,Rn(s),Gl);var u=l.style.cssText,c=n.wrapper.style.cssText;n.wrapper.style.cssText="position: absolute";var f=n.wrapper.getBoundingClientRect();l.style.cssText="position: absolute; width: 30px; height: 30px;\n      top: "+(e.clientY-f.top-5)+"px; left: "+(e.clientX-f.left-5)+"px;\n      z-index: 1000; background: "+(gl?"rgba(255, 255, 255, .05)":"transparent")+";\n      outline: none; border-width: 0; outline: none; overflow: hidden; opacity: .05; filter: alpha(opacity=5);";var h;if(ml&&(h=window.scrollY),o.input.focus(),ml&&window.scrollTo(null,h),o.input.reset(),i.somethingSelected()||(l.value=n.prevInput=" "),n.contextMenuPending=!0,o.selForContextMenu=i.doc.sel,clearTimeout(o.detectingSelectAll),gl&&vl>=9&&t(),Hl){Fe(e);var d=function(){ke(window,"mouseup",d),setTimeout(r,20)};Ql(window,"mouseup",d)}else setTimeout(r,50)}},Qs.prototype.readOnlyChanged=function(e){e||this.reset(),this.textarea.disabled="nocursor"==e},Qs.prototype.setUneditable=function(){},Qs.prototype.needsContentAttribute=!1,function(e){function t(t,n,i,o){e.defaults[t]=n,i&&(r[t]=o?function(e,t,r){r!=Xs&&i(e,t,r)}:i)}var r=e.optionHandlers;e.defineOption=t,e.Init=Xs,t("value","",function(e,t){return e.setValue(t)},!0),t("mode",null,function(e,t){e.doc.modeOption=t,jn(e)},!0),t("indentUnit",2,jn,!0),t("indentWithTabs",!1),t("smartIndent",!0),t("tabSize",4,function(e){Xn(e),er(e),vn(e)},!0),t("lineSeparator",null,function(e,t){if(e.doc.lineSep=t,t){var r=[],n=e.doc.first;e.doc.iter(function(e){for(var i=0;;){var o=e.text.indexOf(t,i);if(-1==o)break;i=o+t.length,r.push(E(n,o))}n++});for(var i=r.length-1;i>=0;i--)Ei(e.doc,t,r[i],E(r[i].line,r[i].ch+t.length))}}),t("specialChars",/[\u0000-\u001f\u007f-\u009f\u00ad\u061c\u200b-\u200f\u2028\u2029\ufeff]/g,function(e,t,r){e.state.specialChars=new RegExp(t.source+(t.test("\t")?"":"|\t"),"g"),r!=Xs&&e.refresh()}),t("specialCharPlaceholder",at,function(e){return e.refresh()},!0),t("electricChars",!0),t("inputStyle",Tl?"contenteditable":"textarea",function(){throw new Error("inputStyle can not (yet) be changed in a running editor")},!0),t("spellcheck",!1,function(e,t){return e.getInputField().spellcheck=t},!0),t("rtlMoveVisually",!Ol),t("wholeLineUpdateBefore",!0),t("theme","default",function(e){Go(e),Uo(e)},!0),t("keyMap","default",function(e,t,r){var n=uo(t),i=r!=Xs&&uo(r);i&&i.detach&&i.detach(e,n),n.attach&&n.attach(e,i||null)}),t("extraKeys",null),t("configureMouse",null),t("lineWrapping",!1,Ko,!0),t("gutters",[],function(e){Fn(e.options),Uo(e)},!0),t("fixedGutter",!0,function(e,t){e.display.gutters.style.left=t?wr(e.display)+"px":"0",e.refresh()},!0),t("coverGutterNextToScrollbar",!1,function(e){return en(e)},!0),t("scrollbarStyle","native",function(e){rn(e),en(e),e.display.scrollbars.setScrollTop(e.doc.scrollTop),e.display.scrollbars.setScrollLeft(e.doc.scrollLeft)},!0),t("lineNumbers",!1,function(e){Fn(e.options),Uo(e)},!0),t("firstLineNumber",1,Uo,!0),t("lineNumberFormatter",function(e){return e},Uo,!0),t("showCursorWhenSelecting",!1,kr,!0),t("resetSelectionOnContextMenu",!0),t("lineWiseCopyCut",!0),t("pasteLinesPerSelection",!0),t("readOnly",!1,function(e,t){"nocursor"==t&&(Fr(e),e.display.input.blur()),e.display.input.readOnlyChanged(t)}),t("disableInput",!1,function(e,t){t||e.display.input.reset()},!0),t("dragDrop",!0,Vo),t("allowDropFileTypes",null),t("cursorBlinkRate",530),t("cursorScrollMargin",0),t("cursorHeight",1,kr,!0),t("singleCursorHeightPerLine",!0,kr,!0),t("workTime",100),t("workDelay",100),t("flattenSpans",!0,Xn,!0),t("addModeClass",!1,Xn,!0),t("pollInterval",100),t("undoDepth",200,function(e,t){return e.doc.history.undoDepth=t}),t("historyEventDelay",1250),t("viewportMargin",10,function(e){return e.refresh()},!0),t("maxHighlightLength",1e4,Xn,!0),t("moveInputWithCursor",!0,function(e,t){t||e.display.input.resetPosition()}),t("tabindex",null,function(e,t){return e.display.input.getField().tabIndex=t||""}),t("autofocus",null),t("direction","ltr",function(e,t){return e.doc.setDirection(t)},!0)}(jo),function(e){var t=e.optionHandlers,r=e.helpers={};e.prototype={constructor:e,focus:function(){window.focus(),this.display.input.focus()},setOption:function(e,r){var n=this.options,i=n[e];n[e]==r&&"mode"!=e||(n[e]=r,t.hasOwnProperty(e)&&dn(this,t[e])(this,r,i),Te(this,"optionChange",this,e))},getOption:function(e){return this.options[e]},getDoc:function(){return this.doc},addKeyMap:function(e,t){this.state.keyMaps[t?"push":"unshift"](uo(e))},removeKeyMap:function(e){for(var t=this.state.keyMaps,r=0;r<t.length;++r)if(t[r]==e||t[r].name==e)return t.splice(r,1),!0},addOverlay:pn(function(t,r){var n=t.token?t:e.getMode(this.options,t);if(n.startState)throw new Error("Overlays may not be stateful.");m(this.state.overlays,{mode:n,modeSpec:t,opaque:r&&r.opaque,priority:r&&r.priority||0},function(e){return e.priority}),this.state.modeGen++,vn(this)}),removeOverlay:pn(function(e){for(var t=this,r=this.state.overlays,n=0;n<r.length;++n){var i=r[n].modeSpec;if(i==e||"string"==typeof e&&i.name==e)return r.splice(n,1),t.state.modeGen++,void vn(t)}}),indentLine:pn(function(e,t,r){"string"!=typeof t&&"number"!=typeof t&&(t=null==t?this.options.smartIndent?"smart":"prev":t?"add":"subtract"),H(this.doc,e)&&Yo(this,e,t,r)}),indentSelection:pn(function(e){for(var t=this,r=this.doc.sel.ranges,n=-1,i=0;i<r.length;i++){var o=r[i];if(o.empty())o.head.line>n&&(Yo(t,o.head.line,e,!0),n=o.head.line,i==t.doc.sel.primIndex&&jr(t));else{var l=o.from(),s=o.to(),a=Math.max(n,l.line);n=Math.min(t.lastLine(),s.line-(s.ch?0:1))+1;for(var u=a;u<n;++u)Yo(t,u,e);var c=t.doc.sel.ranges;0==l.ch&&r.length==c.length&&c[i].from().ch>0&&gi(t.doc,i,new Ts(l,c[i].to()),Gl)}}}),getTokenAt:function(e,t){return Je(this,e,t)},getLineTokens:function(e,t){return Je(this,E(e),t,!0)},getTokenTypeAt:function(e){e=U(this.doc,e);var t,r=_e(this,M(this.doc,e.line)),n=0,i=(r.length-1)/2,o=e.ch;if(0==o)t=r[2];else for(;;){var l=n+i>>1;if((l?r[2*l-1]:0)>=o)i=l;else{if(!(r[2*l+1]<o)){t=r[2*l+2];break}n=l+1}}var s=t?t.indexOf("overlay "):-1;return s<0?t:0==s?null:t.slice(0,s-1)},getModeAt:function(t){var r=this.doc.mode;return r.innerMode?e.innerMode(r,this.getTokenAt(t).state).mode:r},getHelper:function(e,t){return this.getHelpers(e,t)[0]},getHelpers:function(e,t){var n=this,i=[];if(!r.hasOwnProperty(t))return i;var o=r[t],l=this.getModeAt(e);if("string"==typeof l[t])o[l[t]]&&i.push(o[l[t]]);else if(l[t])for(var s=0;s<l[t].length;s++){var a=o[l[t][s]];a&&i.push(a)}else l.helperType&&o[l.helperType]?i.push(o[l.helperType]):o[l.name]&&i.push(o[l.name]);for(var u=0;u<o._global.length;u++){var c=o._global[u];c.pred(l,n)&&-1==h(i,c.val)&&i.push(c.val)}return i},getStateAfter:function(e,t){var r=this.doc;return e=G(r,null==e?r.first+r.size-1:e),$e(this,e+1,t).state},cursorCoords:function(e,t){var r,n=this.doc.sel.primary();return r=null==e?n.head:"object"==typeof e?U(this.doc,e):e?n.from():n.to(),sr(this,r,t||"page")},charCoords:function(e,t){return lr(this,U(this.doc,e),t||"page")},coordsChar:function(e,t){return e=or(this,e,t||"page"),cr(this,e.left,e.top)},lineAtHeight:function(e,t){return e=or(this,{top:e,left:0},t||"page").top,D(this.doc,e+this.display.viewOffset)},heightAtLine:function(e,t,r){var n,i=!1;if("number"==typeof e){var o=this.doc.first+this.doc.size-1;e<this.doc.first?e=this.doc.first:e>o&&(e=o,i=!0),n=M(this.doc,e)}else n=e;return ir(this,n,{top:0,left:0},t||"page",r||i).top+(i?this.doc.height-ye(n):0)},defaultTextHeight:function(){return mr(this.display)},defaultCharWidth:function(){return yr(this.display)},getViewport:function(){return{from:this.display.viewFrom,to:this.display.viewTo}},addWidget:function(e,t,r,n,i){var o=this.display,l=(e=sr(this,U(this.doc,e))).bottom,s=e.left;if(t.style.position="absolute",t.setAttribute("cm-ignore-events","true"),this.display.input.setUneditable(t),o.sizer.appendChild(t),"over"==n)l=e.top;else if("above"==n||"near"==n){var a=Math.max(o.wrapper.clientHeight,this.doc.height),u=Math.max(o.sizer.clientWidth,o.lineSpace.clientWidth);("above"==n||e.bottom+t.offsetHeight>a)&&e.top>t.offsetHeight?l=e.top-t.offsetHeight:e.bottom+t.offsetHeight<=a&&(l=e.bottom),s+t.offsetWidth>u&&(s=u-t.offsetWidth)}t.style.top=l+"px",t.style.left=t.style.right="","right"==i?(s=o.sizer.clientWidth-t.offsetWidth,t.style.right="0px"):("left"==i?s=0:"middle"==i&&(s=(o.sizer.clientWidth-t.offsetWidth)/2),t.style.left=s+"px"),r&&Ur(this,{left:s,top:l,right:s+t.offsetWidth,bottom:l+t.offsetHeight})},triggerOnKeyDown:pn(Lo),triggerOnKeyPress:pn(Mo),triggerOnKeyUp:To,triggerOnMouseDown:pn(Oo),execCommand:function(e){if(Bs.hasOwnProperty(e))return Bs[e].call(null,this)},triggerElectric:pn(function(e){Zo(this,e)}),findPosH:function(e,t,r,n){var i=this,o=1;t<0&&(o=-1,t=-t);for(var l=U(this.doc,e),s=0;s<t&&!(l=tl(i.doc,l,o,r,n)).hitSide;++s);return l},moveH:pn(function(e,t){var r=this;this.extendSelectionsBy(function(n){return r.display.shift||r.doc.extend||n.empty()?tl(r.doc,n.head,e,t,r.options.rtlMoveVisually):e<0?n.from():n.to()},Vl)}),deleteH:pn(function(e,t){var r=this.doc.sel,n=this.doc;r.somethingSelected()?n.replaceSelection("",null,"+delete"):co(this,function(r){var i=tl(n,r.head,e,t,!1);return e<0?{from:i,to:r.head}:{from:r.head,to:i}})}),findPosV:function(e,t,r,n){var i=this,o=1,l=n;t<0&&(o=-1,t=-t);for(var s=U(this.doc,e),a=0;a<t;++a){var u=sr(i,s,"div");if(null==l?l=u.left:u.left=l,(s=rl(i,u,o,r)).hitSide)break}return s},moveV:pn(function(e,t){var r=this,n=this.doc,i=[],o=!this.display.shift&&!n.extend&&n.sel.somethingSelected();if(n.extendSelectionsBy(function(l){if(o)return e<0?l.from():l.to();var s=sr(r,l.head,"div");null!=l.goalColumn&&(s.left=l.goalColumn),i.push(s.left);var a=rl(r,s,e,t);return"page"==t&&l==n.sel.primary()&&Kr(r,lr(r,a,"div").top-s.top),a},Vl),i.length)for(var l=0;l<n.sel.ranges.length;l++)n.sel.ranges[l].goalColumn=i[l]}),findWordAt:function(e){var t=M(this.doc,e.line).text,r=e.ch,n=e.ch;if(t){var i=this.getHelper(e,"wordChars");"before"!=e.sticky&&n!=t.length||!r?++n:--r;for(var o=t.charAt(r),l=x(o,i)?function(e){return x(e,i)}:/\s/.test(o)?function(e){return/\s/.test(e)}:function(e){return!/\s/.test(e)&&!x(e)};r>0&&l(t.charAt(r-1));)--r;for(;n<t.length&&l(t.charAt(n));)++n}return new Ts(E(e.line,r),E(e.line,n))},toggleOverwrite:function(e){null!=e&&e==this.state.overwrite||((this.state.overwrite=!this.state.overwrite)?s(this.display.cursorDiv,"CodeMirror-overwrite"):Fl(this.display.cursorDiv,"CodeMirror-overwrite"),Te(this,"overwriteToggle",this,this.state.overwrite))},hasFocus:function(){return this.display.input.getField()==l()},isReadOnly:function(){return!(!this.options.readOnly&&!this.doc.cantEdit)},scrollTo:pn(function(e,t){Xr(this,e,t)}),getScrollInfo:function(){var e=this.display.scroller;return{left:e.scrollLeft,top:e.scrollTop,height:e.scrollHeight-zt(this)-this.display.barHeight,width:e.scrollWidth-zt(this)-this.display.barWidth,clientHeight:Bt(this),clientWidth:Rt(this)}},scrollIntoView:pn(function(e,t){null==e?(e={from:this.doc.sel.primary().head,to:null},null==t&&(t=this.options.cursorScrollMargin)):"number"==typeof e?e={from:E(e,0),to:null}:null==e.from&&(e={from:e,to:null}),e.to||(e.to=e.from),e.margin=t||0,null!=e.from.line?Yr(this,e):$r(this,e.from,e.to,e.margin)}),setSize:pn(function(e,t){var r=this,n=function(e){return"number"==typeof e||/^\d+$/.test(String(e))?e+"px":e};null!=e&&(this.display.wrapper.style.width=n(e)),null!=t&&(this.display.wrapper.style.height=n(t)),this.options.lineWrapping&&Jt(this);var i=this.display.viewFrom;this.doc.iter(i,this.display.viewTo,function(e){if(e.widgets)for(var t=0;t<e.widgets.length;t++)if(e.widgets[t].noHScroll){mn(r,i,"widget");break}++i}),this.curOp.forceUpdate=!0,Te(this,"refresh",this)}),operation:function(e){return hn(this,e)},startOperation:function(){return nn(this)},endOperation:function(){return on(this)},refresh:pn(function(){var e=this.display.cachedTextHeight;vn(this),this.curOp.forceUpdate=!0,er(this),Xr(this,this.doc.scrollLeft,this.doc.scrollTop),Wn(this),(null==e||Math.abs(e-mr(this.display))>.5)&&Cr(this),Te(this,"refresh",this)}),swapDoc:pn(function(e){var t=this.doc;return t.cm=null,qn(this,e),er(this),this.display.input.reset(),Xr(this,e.scrollLeft,e.scrollTop),this.curOp.forceScroll=!0,bt(this,"swapDoc",this,t),t}),getInputField:function(){return this.display.input.getField()},getWrapperElement:function(){return this.display.wrapper},getScrollerElement:function(){return this.display.scroller},getGutterElement:function(){return this.display.gutters}},Ae(e),e.registerHelper=function(t,n,i){r.hasOwnProperty(t)||(r[t]=e[t]={_global:[]}),r[t][n]=i},e.registerGlobalHelper=function(t,n,i,o){e.registerHelper(t,n,o),r[t]._global.push({pred:i,val:o})}}(jo);var Js="iter insert remove copy getEditor constructor".split(" ");for(var ea in Ds.prototype)Ds.prototype.hasOwnProperty(ea)&&h(Js,ea)<0&&(jo.prototype[ea]=function(e){return function(){return e.apply(this.doc,arguments)}}(Ds.prototype[ea]));return Ae(Ds),jo.inputStyles={textarea:Qs,contenteditable:Zs},jo.defineMode=function(e){jo.defaults.mode||"null"==e||(jo.defaults.mode=e),Be.apply(this,arguments)},jo.defineMIME=function(e,t){os[e]=t},jo.defineMode("null",function(){return{token:function(e){return e.skipToEnd()}}}),jo.defineMIME("text/plain","null"),jo.defineExtension=function(e,t){jo.prototype[e]=t},jo.defineDocExtension=function(e,t){Ds.prototype[e]=t},jo.fromTextArea=function(e,t){function r(){e.value=a.getValue()}if(t=t?c(t):{},t.value=e.value,!t.tabindex&&e.tabIndex&&(t.tabindex=e.tabIndex),!t.placeholder&&e.placeholder&&(t.placeholder=e.placeholder),null==t.autofocus){var n=l();t.autofocus=n==e||null!=e.getAttribute("autofocus")&&n==document.body}var i;if(e.form&&(Ql(e.form,"submit",r),!t.leaveSubmitMethodAlone)){var o=e.form;i=o.submit;try{var s=o.submit=function(){r(),o.submit=i,o.submit(),o.submit=s}}catch(e){}}t.finishInit=function(t){t.save=r,t.getTextArea=function(){return e},t.toTextArea=function(){t.toTextArea=isNaN,r(),e.parentNode.removeChild(t.getWrapperElement()),e.style.display="",e.form&&(ke(e.form,"submit",r),"function"==typeof e.form.submit&&(e.form.submit=i))}},e.style.display="none";var a=jo(function(t){return e.parentNode.insertBefore(t,e.nextSibling)},t);return a},function(e){e.off=ke,e.on=Ql,e.wheelEventPixels=Pn,e.Doc=Ds,e.splitLines=es,e.countColumn=f,e.findColumn=d,e.isWordChar=w,e.Pass=Bl,e.signal=Te,e.Line=fs,e.changeEnd=Bn,e.scrollbarModel=ws,e.Pos=E,e.cmpPos=P,e.modes=is,e.mimeModes=os,e.resolveMode=Ge,e.getMode=Ue,e.modeExtensions=ls,e.extendMode=Ve,e.copyState=Ke,e.startState=Xe,e.innerMode=je,e.commands=Bs,e.keyMap=Rs,e.keyName=ao,e.isModifierKey=lo,e.lookupKey=oo,e.normalizeKeyMap=io,e.StringStream=ss,e.SharedTextMarker=As,e.TextMarker=Os,e.LineWidget=Ms,e.e_preventDefault=We,e.e_stopPropagation=De,e.e_stop=Fe,e.addClass=s,e.contains=o,e.rmClass=Fl,e.keyNames=Es}(jo),jo.version="5.30.0",jo});
      !function(e){"object"==typeof exports&&"object"==typeof module?e(require("../../lib/codemirror")):"function"==typeof define&&define.amd?define(["../../lib/codemirror"],e):e(CodeMirror)}(function(e){"use strict";function t(e,t,n,r,o,a){this.indented=e,this.column=t,this.type=n,this.info=r,this.align=o,this.prev=a}function n(e,n,r,o){var a=e.indented;return e.context&&"statement"==e.context.type&&"statement"!=r&&(a=e.context.indented),e.context=new t(a,n,r,o,null,e.context)}function r(e){var t=e.context.type;return")"!=t&&"]"!=t&&"}"!=t||(e.indented=e.context.indented),e.context=e.context.prev}function o(e,t,n){return"variable"==t.prevToken||"type"==t.prevToken||(!!/\S(?:[^- ]>|[*\]])\s*$|\*$/.test(e.string.slice(0,n))||(!(!t.typeAtEndOfLine||e.column()!=e.indentation())||void 0))}function a(e){for(;;){if(!e||"top"==e.type)return!0;if("}"==e.type&&"namespace"!=e.prev.info)return!1;e=e.prev}}function i(e){for(var t={},n=e.split(" "),r=0;r<n.length;++r)t[n[r]]=!0;return t}function l(e,t){return"function"==typeof e?e(t):e.propertyIsEnumerable(t)}function s(e,t){if(!t.startOfLine)return!1;for(var n,r=null;n=e.peek();){if("\\"==n&&e.match(/^.$/)){r=s;break}if("/"==n&&e.match(/^\/[\/\*]/,!1))break;e.next()}return t.tokenize=r,"meta"}function c(e,t){return"type"==t.prevToken&&"type"}function u(e){return e.eatWhile(/[\w\.']/),"number"}function d(e,t){if(e.backUp(1),e.match(/(R|u8R|uR|UR|LR)/)){var n=e.match(/"([^\s\\()]{0,16})\(/);return!!n&&(t.cpp11RawStringDelim=n[1],t.tokenize=m,m(e,t))}return e.match(/(u8|u|U|L)/)?!!e.match(/["']/,!1)&&"string":(e.next(),!1)}function f(e){var t=/(\w+)::~?(\w+)$/.exec(e);return t&&t[1]==t[2]}function p(e,t){for(var n;null!=(n=e.next());)if('"'==n&&!e.eat('"')){t.tokenize=null;break}return"string"}function m(e,t){var n=t.cpp11RawStringDelim.replace(/[^\w\s]/g,"\\$&");return e.match(new RegExp(".*?\\)"+n+'"'))?t.tokenize=null:e.skipToEnd(),"string"}function h(t,n){function r(e){if(e)for(var t in e)e.hasOwnProperty(t)&&o.push(t)}"string"==typeof t&&(t=[t]);var o=[];r(n.keywords),r(n.types),r(n.builtin),r(n.atoms),o.length&&(n.helperType=t[0],e.registerHelper("hintWords",t[0],o));for(var a=0;a<t.length;++a)e.defineMIME(t[a],n)}function g(e,t){for(var n=!1;!e.eol();){if(!n&&e.match('"""')){t.tokenize=null;break}n="\\"==e.next()&&!n}return"string"}function y(e){return function(t,n){for(var r,o=!1,a=!1;!t.eol();){if(!e&&!o&&t.match('"')){a=!0;break}if(e&&t.match('"""')){a=!0;break}r=t.next(),!o&&"$"==r&&t.match("{")&&t.skipTo("}"),o=!o&&"\\"==r&&!e}return!a&&e||(n.tokenize=null),"string"}}function x(e){return function(t,n){for(var r,o=!1,a=!1;!t.eol();){if(!o&&t.match('"')&&("single"==e||t.match('""'))){a=!0;break}if(!o&&t.match("``")){w=x(e),a=!0;break}r=t.next(),o="single"==e&&!o&&"\\"==r}return a&&(n.tokenize=null),"string"}}e.defineMode("clike",function(i,s){function c(e,t){var n=e.next();if(S[n]){var r=S[n](e,t);if(!1!==r)return r}if('"'==n||"'"==n)return t.tokenize=u(n),t.tokenize(e,t);if(D.test(n))return p=n,null;if(L.test(n)){if(e.backUp(1),e.match(I))return"number";e.next()}if("/"==n){if(e.eat("*"))return t.tokenize=d,d(e,t);if(e.eat("/"))return e.skipToEnd(),"comment"}if(F.test(n)){for(;!e.match(/^\/[\/*]/,!1)&&e.eat(F););return"operator"}if(e.eatWhile(z),P)for(;e.match(P);)e.eatWhile(z);var o=e.current();return l(x,o)?(l(w,o)&&(p="newstatement"),l(v,o)&&(m=!0),"keyword"):l(b,o)?"type":l(k,o)?(l(w,o)&&(p="newstatement"),"builtin"):l(_,o)?"atom":"variable"}function u(e){return function(t,n){for(var r,o=!1,a=!1;null!=(r=t.next());){if(r==e&&!o){a=!0;break}o=!o&&"\\"==r}return(a||!o&&!C)&&(n.tokenize=null),"string"}}function d(e,t){for(var n,r=!1;n=e.next();){if("/"==n&&r){t.tokenize=null;break}r="*"==n}return"comment"}function f(e,t){s.typeFirstDefinitions&&e.eol()&&a(t.context)&&(t.typeAtEndOfLine=o(e,t,e.pos))}var p,m,h=i.indentUnit,g=s.statementIndentUnit||h,y=s.dontAlignCalls,x=s.keywords||{},b=s.types||{},k=s.builtin||{},w=s.blockKeywords||{},v=s.defKeywords||{},_=s.atoms||{},S=s.hooks||{},C=s.multiLineStrings,T=!1!==s.indentStatements,M=!1!==s.indentSwitch,P=s.namespaceSeparator,D=s.isPunctuationChar||/[\[\]{}\(\),;\:\.]/,L=s.numberStart||/[\d\.]/,I=s.number||/^(?:0x[a-f\d]+|0b[01]+|(?:\d+\.?\d*|\.\d+)(?:e[-+]?\d+)?)(u|ll?|l|f)?/i,F=s.isOperatorChar||/[+\-*&%=<>!?|\/]/,z=s.isIdentifierChar||/[\w\$_\xa1-\uffff]/;return{startState:function(e){return{tokenize:null,context:new t((e||0)-h,0,"top",null,!1),indented:0,startOfLine:!0,prevToken:null}},token:function(e,t){var i=t.context;if(e.sol()&&(null==i.align&&(i.align=!1),t.indented=e.indentation(),t.startOfLine=!0),e.eatSpace())return f(e,t),null;p=m=null;var l=(t.tokenize||c)(e,t);if("comment"==l||"meta"==l)return l;if(null==i.align&&(i.align=!0),";"==p||":"==p||","==p&&e.match(/^\s*(?:\/\/.*)?$/,!1))for(;"statement"==t.context.type;)r(t);else if("{"==p)n(t,e.column(),"}");else if("["==p)n(t,e.column(),"]");else if("("==p)n(t,e.column(),")");else if("}"==p){for(;"statement"==i.type;)i=r(t);for("}"==i.type&&(i=r(t));"statement"==i.type;)i=r(t)}else p==i.type?r(t):T&&(("}"==i.type||"top"==i.type)&&";"!=p||"statement"==i.type&&"newstatement"==p)&&n(t,e.column(),"statement",e.current());if("variable"==l&&("def"==t.prevToken||s.typeFirstDefinitions&&o(e,t,e.start)&&a(t.context)&&e.match(/^\s*\(/,!1))&&(l="def"),S.token){var u=S.token(e,t,l);void 0!==u&&(l=u)}return"def"==l&&!1===s.styleDefs&&(l="variable"),t.startOfLine=!1,t.prevToken=m?"def":l||p,f(e,t),l},indent:function(t,n){if(t.tokenize!=c&&null!=t.tokenize||t.typeAtEndOfLine)return e.Pass;var r=t.context,o=n&&n.charAt(0);if("statement"==r.type&&"}"==o&&(r=r.prev),s.dontIndentStatements)for(;"statement"==r.type&&s.dontIndentStatements.test(r.info);)r=r.prev;if(S.indent){var a=S.indent(t,r,n);if("number"==typeof a)return a}var i=o==r.type,l=r.prev&&"switch"==r.prev.info;if(s.allmanIndentation&&/[{(]/.test(o)){for(;"top"!=r.type&&"}"!=r.type;)r=r.prev;return r.indented}return"statement"==r.type?r.indented+("{"==o?0:g):!r.align||y&&")"==r.type?")"!=r.type||i?r.indented+(i?0:h)+(i||!l||/^(?:case|default)\b/.test(n)?0:h):r.indented+g:r.column+(i?0:1)},electricInput:M?/^\s*(?:case .*?:|default:|\{\}?|\})$/:/^\s*[{}]$/,blockCommentStart:"/*",blockCommentEnd:"*/",lineComment:"//",fold:"brace"}});var b="auto if break case register continue return default do sizeof static else struct switch extern typedef union for goto while enum const volatile",k="int long char short double float unsigned signed void size_t ptrdiff_t";h(["text/x-csrc","text/x-c","text/x-chdr"],{name:"clike",keywords:i(b),types:i(k+" bool _Complex _Bool float_t double_t intptr_t intmax_t int8_t int16_t int32_t int64_t uintptr_t uintmax_t uint8_t uint16_t uint32_t uint64_t"),blockKeywords:i("case do else for if switch while struct"),defKeywords:i("struct"),typeFirstDefinitions:!0,atoms:i("null true false"),hooks:{"#":s,"*":c},modeProps:{fold:["brace","include"]}}),h(["text/x-c++src","text/x-c++hdr"],{name:"clike",keywords:i(b+" asm dynamic_cast namespace reinterpret_cast try explicit new static_cast typeid catch operator template typename class friend private this using const_cast inline public throw virtual delete mutable protected alignas alignof constexpr decltype nullptr noexcept thread_local final static_assert override"),types:i(k+" bool wchar_t"),blockKeywords:i("catch class do else finally for if struct switch try while"),defKeywords:i("class namespace struct enum union"),typeFirstDefinitions:!0,atoms:i("true false null"),dontIndentStatements:/^template$/,isIdentifierChar:/[\w\$_~\xa1-\uffff]/,hooks:{"#":s,"*":c,u:d,U:d,L:d,R:d,0:u,1:u,2:u,3:u,4:u,5:u,6:u,7:u,8:u,9:u,token:function(e,t,n){if("variable"==n&&"("==e.peek()&&(";"==t.prevToken||null==t.prevToken||"}"==t.prevToken)&&f(e.current()))return"def"}},namespaceSeparator:"::",modeProps:{fold:["brace","include"]}}),h("text/x-java",{name:"clike",keywords:i("abstract assert break case catch class const continue default do else enum extends final finally float for goto if implements import instanceof interface native new package private protected public return static strictfp super switch synchronized this throw throws transient try volatile while @interface"),types:i("byte short int long float double boolean char void Boolean Byte Character Double Float Integer Long Number Object Short String StringBuffer StringBuilder Void"),blockKeywords:i("catch class do else finally for if switch try while"),defKeywords:i("class interface package enum @interface"),typeFirstDefinitions:!0,atoms:i("true false null"),number:/^(?:0x[a-f\d_]+|0b[01_]+|(?:[\d_]+\.?\d*|\.\d+)(?:e[-+]?[\d_]+)?)(u|ll?|l|f)?/i,hooks:{"@":function(e){return!e.match("interface",!1)&&(e.eatWhile(/[\w\$_]/),"meta")}},modeProps:{fold:["brace","import"]}}),h("text/x-csharp",{name:"clike",keywords:i("abstract as async await base break case catch checked class const continue default delegate do else enum event explicit extern finally fixed for foreach goto if implicit in interface internal is lock namespace new operator out override params private protected public readonly ref return sealed sizeof stackalloc static struct switch this throw try typeof unchecked unsafe using virtual void volatile while add alias ascending descending dynamic from get global group into join let orderby partial remove select set value var yield"),types:i("Action Boolean Byte Char DateTime DateTimeOffset Decimal Double Func Guid Int16 Int32 Int64 Object SByte Single String Task TimeSpan UInt16 UInt32 UInt64 bool byte char decimal double short int long object sbyte float string ushort uint ulong"),blockKeywords:i("catch class do else finally for foreach if struct switch try while"),defKeywords:i("class interface namespace struct var"),typeFirstDefinitions:!0,atoms:i("true false null"),hooks:{"@":function(e,t){return e.eat('"')?(t.tokenize=p,p(e,t)):(e.eatWhile(/[\w\$_]/),"meta")}}}),h("text/x-scala",{name:"clike",keywords:i("abstract case catch class def do else extends final finally for forSome if implicit import lazy match new null object override package private protected return sealed super this throw trait try type val var while with yield _ assert assume require print println printf readLine readBoolean readByte readShort readChar readInt readLong readFloat readDouble"),types:i("AnyVal App Application Array BufferedIterator BigDecimal BigInt Char Console Either Enumeration Equiv Error Exception Fractional Function IndexedSeq Int Integral Iterable Iterator List Map Numeric Nil NotNull Option Ordered Ordering PartialFunction PartialOrdering Product Proxy Range Responder Seq Serializable Set Specializable Stream StringBuilder StringContext Symbol Throwable Traversable TraversableOnce Tuple Unit Vector Boolean Byte Character CharSequence Class ClassLoader Cloneable Comparable Compiler Double Exception Float Integer Long Math Number Object Package Pair Process Runtime Runnable SecurityManager Short StackTraceElement StrictMath String StringBuffer System Thread ThreadGroup ThreadLocal Throwable Triple Void"),multiLineStrings:!0,blockKeywords:i("catch class enum do else finally for forSome if match switch try while"),defKeywords:i("class enum def object package trait type val var"),atoms:i("true false null"),indentStatements:!1,indentSwitch:!1,isOperatorChar:/[+\-*&%=<>!?|\/#:@]/,hooks:{"@":function(e){return e.eatWhile(/[\w\$_]/),"meta"},'"':function(e,t){return!!e.match('""')&&(t.tokenize=g,t.tokenize(e,t))},"'":function(e){return e.eatWhile(/[\w\$_\xa1-\uffff]/),"atom"},"=":function(e,n){var r=n.context;return!("}"!=r.type||!r.align||!e.eat(">"))&&(n.context=new t(r.indented,r.column,r.type,r.info,null,r.prev),"operator")}},modeProps:{closeBrackets:{triples:'"'}}}),h("text/x-kotlin",{name:"clike",keywords:i("package as typealias class interface this super val var fun for is in This throw return break continue object if else while do try when !in !is as? file import where by get set abstract enum open inner override private public internal protected catch finally out final vararg reified dynamic companion constructor init sealed field property receiver param sparam lateinit data inline noinline tailrec external annotation crossinline const operator infix suspend"),types:i("Boolean Byte Character CharSequence Class ClassLoader Cloneable Comparable Compiler Double Exception Float Integer Long Math Number Object Package Pair Process Runtime Runnable SecurityManager Short StackTraceElement StrictMath String StringBuffer System Thread ThreadGroup ThreadLocal Throwable Triple Void"),intendSwitch:!1,indentStatements:!1,multiLineStrings:!0,number:/^(?:0x[a-f\d_]+|0b[01_]+|(?:[\d_]+\.?\d*|\.\d+)(?:e[-+]?[\d_]+)?)(u|ll?|l|f)?/i,blockKeywords:i("catch class do else finally for if where try while enum"),defKeywords:i("class val var object package interface fun"),atoms:i("true false null this"),hooks:{'"':function(e,t){return t.tokenize=y(e.match('""')),t.tokenize(e,t)}},modeProps:{closeBrackets:{triples:'"'}}}),h(["x-shader/x-vertex","x-shader/x-fragment"],{name:"clike",keywords:i("sampler1D sampler2D sampler3D samplerCube sampler1DShadow sampler2DShadow const attribute uniform varying break continue discard return for while do if else struct in out inout"),types:i("float int bool void vec2 vec3 vec4 ivec2 ivec3 ivec4 bvec2 bvec3 bvec4 mat2 mat3 mat4"),blockKeywords:i("for while do if else struct"),builtin:i("radians degrees sin cos tan asin acos atan pow exp log exp2 sqrt inversesqrt abs sign floor ceil fract mod min max clamp mix step smoothstep length distance dot cross normalize ftransform faceforward reflect refract matrixCompMult lessThan lessThanEqual greaterThan greaterThanEqual equal notEqual any all not texture1D texture1DProj texture1DLod texture1DProjLod texture2D texture2DProj texture2DLod texture2DProjLod texture3D texture3DProj texture3DLod texture3DProjLod textureCube textureCubeLod shadow1D shadow2D shadow1DProj shadow2DProj shadow1DLod shadow2DLod shadow1DProjLod shadow2DProjLod dFdx dFdy fwidth noise1 noise2 noise3 noise4"),atoms:i("true false gl_FragColor gl_SecondaryColor gl_Normal gl_Vertex gl_MultiTexCoord0 gl_MultiTexCoord1 gl_MultiTexCoord2 gl_MultiTexCoord3 gl_MultiTexCoord4 gl_MultiTexCoord5 gl_MultiTexCoord6 gl_MultiTexCoord7 gl_FogCoord gl_PointCoord gl_Position gl_PointSize gl_ClipVertex gl_FrontColor gl_BackColor gl_FrontSecondaryColor gl_BackSecondaryColor gl_TexCoord gl_FogFragCoord gl_FragCoord gl_FrontFacing gl_FragData gl_FragDepth gl_ModelViewMatrix gl_ProjectionMatrix gl_ModelViewProjectionMatrix gl_TextureMatrix gl_NormalMatrix gl_ModelViewMatrixInverse gl_ProjectionMatrixInverse gl_ModelViewProjectionMatrixInverse gl_TexureMatrixTranspose gl_ModelViewMatrixInverseTranspose gl_ProjectionMatrixInverseTranspose gl_ModelViewProjectionMatrixInverseTranspose gl_TextureMatrixInverseTranspose gl_NormalScale gl_DepthRange gl_ClipPlane gl_Point gl_FrontMaterial gl_BackMaterial gl_LightSource gl_LightModel gl_FrontLightModelProduct gl_BackLightModelProduct gl_TextureColor gl_EyePlaneS gl_EyePlaneT gl_EyePlaneR gl_EyePlaneQ gl_FogParameters gl_MaxLights gl_MaxClipPlanes gl_MaxTextureUnits gl_MaxTextureCoords gl_MaxVertexAttribs gl_MaxVertexUniformComponents gl_MaxVaryingFloats gl_MaxVertexTextureImageUnits gl_MaxTextureImageUnits gl_MaxFragmentUniformComponents gl_MaxCombineTextureImageUnits gl_MaxDrawBuffers"),indentSwitch:!1,hooks:{"#":s},modeProps:{fold:["brace","include"]}}),h("text/x-nesc",{name:"clike",keywords:i(b+"as atomic async call command component components configuration event generic implementation includes interface module new norace nx_struct nx_union post provides signal task uses abstract extends"),types:i(k),blockKeywords:i("case do else for if switch while struct"),atoms:i("null true false"),hooks:{"#":s},modeProps:{fold:["brace","include"]}}),h("text/x-objectivec",{name:"clike",keywords:i(b+"inline restrict _Bool _Complex _Imaginary BOOL Class bycopy byref id IMP in inout nil oneway out Protocol SEL self super atomic nonatomic retain copy readwrite readonly"),types:i(k),atoms:i("YES NO NULL NILL ON OFF true false"),hooks:{"@":function(e){return e.eatWhile(/[\w\$]/),"keyword"},"#":s,indent:function(e,t,n){if("statement"==t.type&&/^@\w/.test(n))return t.indented}},modeProps:{fold:"brace"}}),h("text/x-squirrel",{name:"clike",keywords:i("base break clone continue const default delete enum extends function in class foreach local resume return this throw typeof yield constructor instanceof static"),types:i(k),blockKeywords:i("case catch class else for foreach if switch try while"),defKeywords:i("function local class"),typeFirstDefinitions:!0,atoms:i("true false null"),hooks:{"#":s},modeProps:{fold:["brace","include"]}});var w=null;h("text/x-ceylon",{name:"clike",keywords:i("abstracts alias assembly assert assign break case catch class continue dynamic else exists extends finally for function given if import in interface is let module new nonempty object of out outer package return satisfies super switch then this throw try value void while"),types:function(e){var t=e.charAt(0);return t===t.toUpperCase()&&t!==t.toLowerCase()},blockKeywords:i("case catch class dynamic else finally for function if interface module new object switch try while"),defKeywords:i("class dynamic function interface module object package value"),builtin:i("abstract actual aliased annotation by default deprecated doc final formal late license native optional sealed see serializable shared suppressWarnings tagged throws variable"),isPunctuationChar:/[\[\]{}\(\),;\:\.`]/,isOperatorChar:/[+\-*&%=<>!?|^~:\/]/,numberStart:/[\d#$]/,number:/^(?:#[\da-fA-F_]+|\$[01_]+|[\d_]+[kMGTPmunpf]?|[\d_]+\.[\d_]+(?:[eE][-+]?\d+|[kMGTPmunpf]|)|)/i,multiLineStrings:!0,typeFirstDefinitions:!0,atoms:i("true false null larger smaller equal empty finished"),indentSwitch:!1,styleDefs:!1,hooks:{"@":function(e){return e.eatWhile(/[\w\$_]/),"meta"},'"':function(e,t){return t.tokenize=x(e.match('""')?"triple":"single"),t.tokenize(e,t)},"`":function(e,t){return!(!w||!e.match("`"))&&(t.tokenize=w,w=null,t.tokenize(e,t))},"'":function(e){return e.eatWhile(/[\w\$_\xa1-\uffff]/),"atom"},token:function(e,t,n){if(("variable"==n||"type"==n)&&"."==t.prevToken)return"variable-2"}},modeProps:{fold:["brace","import"],closeBrackets:{triples:'"'}}})});
      // -------------------------------------------------------------------------
//  Part of the CodeChecker project, under the Apache License v2.0 with
//  LLVM Exceptions. See LICENSE for license information.
//  SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
// -------------------------------------------------------------------------

var BugViewer = {
  _files : [],
  _reports : [],
  _lineWidgets : [],
  _navigationMenuItems : [],
  _sourceFileData : null,
  _currentReport : null,
  _lastBugEvent  : null,

  init : function (files, reports) {
    this._files = files;
    this._reports = reports;

    this.initEscapeChars();
  },

  initEscapeChars : function () {
    this.escapeChars = {
      ' ' : 'nbsp',
      '<' : 'lt',
      '>' : 'gt',
      '"' : 'quot',
      '&' : 'amp'
    };

    var regexString = '[';
    for (var key in this.escapeChars) {
      regexString += key;
    }
    regexString += ']';

    this.escapeRegExp = new RegExp( regexString, 'g');
  },

  escapeHTML : function (str) {
    var that = this;

    return str.replace(this.escapeRegExp, function (m) {
      return '&' + that.escapeChars[m] + ';';
    });
  },

  initByUrl : function () {
    if (!this._reports) return;

    var state = {};
    window.location.hash.substr(1).split('&').forEach(function (s) {
      var parts = s.split('=');
      state[parts[0]] = parts[1];
    });

    for (var key in this._reports) {
      var report = this._reports[key];
      if (report.reportHash === state['reportHash']) {
        this.navigate(report);
        return;
      }
    }

    this.navigate(this._reports[0]);
  },

  create : function () {
    this._content = document.getElementById('editor-wrapper');
    this._filepath = document.getElementById('file-path');
    this._checkerName = document.getElementById('checker-name');
    this._reviewStatusWrapper =
      document.getElementById('review-status-wrapper');
    this._reviewStatus = document.getElementById('review-status');
    this._editor = document.getElementById('editor');

    this._codeMirror = CodeMirror(this._editor, {
      mode: 'text/x-c++src',
      matchBrackets : true,
      lineNumbers : true,
      readOnly : true,
      foldGutter : true,
      extraKeys : {},
      viewportMargin : 100
    });

    this._createNavigationMenu();
  },

  navigate : function (report, item) {
    if (!item) {
      var items = this._navigationMenuItems.filter(function (navItem) {
        return navItem.report.reportHash === report.reportHash;
      });

      if (!items.length) return;

      item = items[0].widget;
    }

    this._selectedReport.classList.remove('active');
    this._selectedReport = item;
    this._selectedReport.classList.add('active');
    this.setReport(report);
  },

  _createNavigationMenu : function () {
    var that = this;

    var nav = document.getElementById('report-nav');
    var list = document.createElement('ul');
    this._reports.forEach(function (report) {
      var events = report['events'];
      var lastBugEvent = events[events.length - 1];
      var item = document.createElement('li');

      var severity = document.createElement('i');
      severity.className = 'severity-' + report.severity.toLowerCase();

      item.appendChild(severity);
      item.appendChild(document.createTextNode(lastBugEvent.message));

      item.addEventListener('click', function () {
        that.navigate(report, item);
      })
      list.appendChild(item);
      that._navigationMenuItems.push({ report : report, widget : item });
    });

    if (!this._selectedReport && list.childNodes.length) {
      this._selectedReport = list.childNodes[0];
      this._selectedReport.classList.add('active');
    }

    nav.appendChild(list);
  },

  setReport : function (report) {
    this._currentReport = report;
    var events = report['events'];
    var lastBugEvent = events[events.length - 1];
    this.setCurrentBugEvent(lastBugEvent, events.length - 1);
    this.setCheckerName(report.checkerName);
    this.setReviewStatus(report.reviewStatus);

    window.location.hash = '#reportHash=' + report.reportHash;
  },

  setCurrentBugEvent : function (event, idx) {
    this._currentBugEvent = event;
    this.setSourceFileData(this._files[event.location.file]);
    this.drawBugPath();

    this.jumpTo(event.location.line, 0);
    this.highlightBugEvent(event, idx);
  },

  highlightBugEvent : function (event, idx) {
    this._lineWidgets.forEach(function (widget) {
      var lineIdx = widget.node.getAttribute('idx');
      if (parseInt(lineIdx) === idx) {
        widget.node.classList.add('current');
      }
    });
  },

  setCheckerName : function (checkerName) {
    this._checkerName.innerHTML = checkerName;
  },

  setReviewStatus : function (status) {
    if (status) {
      var className =
        'review-status-' + status.toLowerCase().split(' ').join('-');
      this._reviewStatus.className = "review-status " + className;

      this._reviewStatus.innerHTML = status;
      this._reviewStatusWrapper.style.display = 'block';
    } else {
      this._reviewStatusWrapper.style.display = 'none';
    }
  },

  setSourceFileData : function (file) {
    if (this._sourceFileData && file.id === this._sourceFileData.id) {
      return;
    }

    this._sourceFileData = file;
    this._filepath.innerHTML = file.path;
    this._codeMirror.doc.setValue(file.content);
    this._refresh();
  },

  _refresh : function () {
    var that = this;
    setTimeout(function () {
      var fullHeight = parseInt(that._content.clientHeight);
      var headerHeight = that._filepath.clientHeight;

      that._codeMirror.setSize('auto', fullHeight - headerHeight);
      that._codeMirror.refresh();
    }, 200);
  },

  clearBubbles : function () {
    this._lineWidgets.forEach(function (widget) { widget.clear(); });
    this._lineWidgets = [];
  },

  getMessage : function (event, kind) {
    if (kind === 'macro') {
      var name = 'macro expansion' + (event.name ? ': ' + event.name : '');

      return '<span class="tag macro">' + name + '</span>'
        + this.escapeHTML(event.expansion).replace(/(?:\r\n|\r|\n)/g, '<br>');
    } else if (kind === 'note') {
      return '<span class="tag note">note</span>'
        +  this.escapeHTML(event.message).replace(/(?:\r\n|\r|\n)/g, '<br>');
    }
  },

  addExtraPathEvents : function (events, kind) {
    var that = this;

    if (!events) {
      return;
    }

    events.forEach(function (event) {
      if (event.location.file !== that._currentBugEvent.location.file) {
        return;
      }

      var left =
        that._codeMirror.defaultCharWidth() * event.location.col + 'px';

      var element = document.createElement('div');
      element.setAttribute('style', 'margin-left: ' + left);
      element.setAttribute('class', 'check-msg ' + kind);

      var msg = document.createElement('span');
      msg.innerHTML = that.getMessage(event, kind);
      element.appendChild(msg);

      that._lineWidgets.push(that._codeMirror.addLineWidget(
        event.location.line - 1, element));
    });
  },

  drawBugPath : function () {
    var that = this;

    this.clearBubbles();

    this.addExtraPathEvents(this._currentReport.macros, 'macro');
    this.addExtraPathEvents(this._currentReport.notes, 'note');

    // Processing bug path events.
    var currentEvents = this._currentReport.events;
    currentEvents.forEach(function (event, step) {
      if (event.location.file !== that._currentBugEvent.location.file)
        return;

      var left =
        that._codeMirror.defaultCharWidth() * event.location.col + 'px';
      var type = step === currentEvents.length - 1 ? 'error' : 'info';

      var element = document.createElement('div');
      element.setAttribute('style', 'margin-left: ' + left);
      element.setAttribute('class', 'check-msg ' + type);
      element.setAttribute('idx', step);

      var enumeration = document.createElement('span');
      enumeration.setAttribute('class', 'checker-enum ' + type);
      enumeration.innerHTML = step + 1;

      if (currentEvents.length > 1)
        element.appendChild(enumeration);

      var prevBugEvent = step - 1;
      if (step > 0) {
        var prevBug = document.createElement('span');
        prevBug.setAttribute('class', 'arrow left-arrow');
        prevBug.addEventListener('click', function () {
          var event = currentEvents[prevBugEvent];
          that.setCurrentBugEvent(event, prevBugEvent);
        });
        element.appendChild(prevBug);
      }

      var msg = document.createElement('span');
      msg.innerHTML = that.escapeHTML(event.message)
        .replace(/(?:\r\n|\r|\n)/g, '<br>');

      element.appendChild(msg);

      var nextBugEvent = step + 1;
      if (nextBugEvent < currentEvents.length) {
        var nextBug = document.createElement('span');
        nextBug.setAttribute('class', 'arrow right-arrow');
        nextBug.addEventListener('click', function () {
          var event = currentEvents[nextBugEvent];
          that.setCurrentBugEvent(event, nextBugEvent);
        });
        element.appendChild(nextBug);
      }


      that._lineWidgets.push(that._codeMirror.addLineWidget(
        event.location.line - 1, element));
    });
  },

  jumpTo : function (line, column) {
    var that = this;

    setTimeout(function () {
      var selPosPixel
        = that._codeMirror.charCoords({ line : line, ch : column }, 'local');
      var editorSize = {
        width  : that._editor.clientWidth,
        height : that._editor.clientHeight
      };

      that._codeMirror.scrollIntoView({
        top    : selPosPixel.top - 100,
        bottom : selPosPixel.top + editorSize.height - 150,
        left   : selPosPixel.left < editorSize.width - 100
               ? 0
               : selPosPixel.left - 50,
        right  : selPosPixel.left < editorSize.width - 100
               ? 10
               : selPosPixel.left + editorSize.width - 100
      });
    }, 0);
  }
}


      var data = {"files": {"11": {"id": 11, "path": "/usr/include/openssl/safestack.h", "content": "/*\n * Copyright 1999-2019 The OpenSSL Project Authors. All Rights Reserved.\n *\n * Licensed under the OpenSSL license (the \"License\").  You may not use\n * this file except in compliance with the License.  You can obtain a copy\n * in the file LICENSE in the source distribution or at\n * https://www.openssl.org/source/license.html\n */\n\n#ifndef HEADER_SAFESTACK_H\n# define HEADER_SAFESTACK_H\n\n# include <openssl/stack.h>\n# include <openssl/e_os2.h>\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\n# define STACK_OF(type) struct stack_st_##type\n\n# define SKM_DEFINE_STACK_OF(t1, t2, t3) \\\n    STACK_OF(t1); \\\n    typedef int (*sk_##t1##_compfunc)(const t3 * const *a, const t3 *const *b); \\\n    typedef void (*sk_##t1##_freefunc)(t3 *a); \\\n    typedef t3 * (*sk_##t1##_copyfunc)(const t3 *a); \\\n    static ossl_unused ossl_inline int sk_##t1##_num(const STACK_OF(t1) *sk) \\\n    { \\\n        return OPENSSL_sk_num((const OPENSSL_STACK *)sk); \\\n    } \\\n    static ossl_unused ossl_inline t2 *sk_##t1##_value(const STACK_OF(t1) *sk, int idx) \\\n    { \\\n        return (t2 *)OPENSSL_sk_value((const OPENSSL_STACK *)sk, idx); \\\n    } \\\n    static ossl_unused ossl_inline STACK_OF(t1) *sk_##t1##_new(sk_##t1##_compfunc compare) \\\n    { \\\n        return (STACK_OF(t1) *)OPENSSL_sk_new((OPENSSL_sk_compfunc)compare); \\\n    } \\\n    static ossl_unused ossl_inline STACK_OF(t1) *sk_##t1##_new_null(void) \\\n    { \\\n        return (STACK_OF(t1) *)OPENSSL_sk_new_null(); \\\n    } \\\n    static ossl_unused ossl_inline STACK_OF(t1) *sk_##t1##_new_reserve(sk_##t1##_compfunc compare, int n) \\\n    { \\\n        return (STACK_OF(t1) *)OPENSSL_sk_new_reserve((OPENSSL_sk_compfunc)compare, n); \\\n    } \\\n    static ossl_unused ossl_inline int sk_##t1##_reserve(STACK_OF(t1) *sk, int n) \\\n    { \\\n        return OPENSSL_sk_reserve((OPENSSL_STACK *)sk, n); \\\n    } \\\n    static ossl_unused ossl_inline void sk_##t1##_free(STACK_OF(t1) *sk) \\\n    { \\\n        OPENSSL_sk_free((OPENSSL_STACK *)sk); \\\n    } \\\n    static ossl_unused ossl_inline void sk_##t1##_zero(STACK_OF(t1) *sk) \\\n    { \\\n        OPENSSL_sk_zero((OPENSSL_STACK *)sk); \\\n    } \\\n    static ossl_unused ossl_inline t2 *sk_##t1##_delete(STACK_OF(t1) *sk, int i) \\\n    { \\\n        return (t2 *)OPENSSL_sk_delete((OPENSSL_STACK *)sk, i); \\\n    } \\\n    static ossl_unused ossl_inline t2 *sk_##t1##_delete_ptr(STACK_OF(t1) *sk, t2 *ptr) \\\n    { \\\n        return (t2 *)OPENSSL_sk_delete_ptr((OPENSSL_STACK *)sk, \\\n                                           (const void *)ptr); \\\n    } \\\n    static ossl_unused ossl_inline int sk_##t1##_push(STACK_OF(t1) *sk, t2 *ptr) \\\n    { \\\n        return OPENSSL_sk_push((OPENSSL_STACK *)sk, (const void *)ptr); \\\n    } \\\n    static ossl_unused ossl_inline int sk_##t1##_unshift(STACK_OF(t1) *sk, t2 *ptr) \\\n    { \\\n        return OPENSSL_sk_unshift((OPENSSL_STACK *)sk, (const void *)ptr); \\\n    } \\\n    static ossl_unused ossl_inline t2 *sk_##t1##_pop(STACK_OF(t1) *sk) \\\n    { \\\n        return (t2 *)OPENSSL_sk_pop((OPENSSL_STACK *)sk); \\\n    } \\\n    static ossl_unused ossl_inline t2 *sk_##t1##_shift(STACK_OF(t1) *sk) \\\n    { \\\n        return (t2 *)OPENSSL_sk_shift((OPENSSL_STACK *)sk); \\\n    } \\\n    static ossl_unused ossl_inline void sk_##t1##_pop_free(STACK_OF(t1) *sk, sk_##t1##_freefunc freefunc) \\\n    { \\\n        OPENSSL_sk_pop_free((OPENSSL_STACK *)sk, (OPENSSL_sk_freefunc)freefunc); \\\n    } \\\n    static ossl_unused ossl_inline int sk_##t1##_insert(STACK_OF(t1) *sk, t2 *ptr, int idx) \\\n    { \\\n        return OPENSSL_sk_insert((OPENSSL_STACK *)sk, (const void *)ptr, idx); \\\n    } \\\n    static ossl_unused ossl_inline t2 *sk_##t1##_set(STACK_OF(t1) *sk, int idx, t2 *ptr) \\\n    { \\\n        return (t2 *)OPENSSL_sk_set((OPENSSL_STACK *)sk, idx, (const void *)ptr); \\\n    } \\\n    static ossl_unused ossl_inline int sk_##t1##_find(STACK_OF(t1) *sk, t2 *ptr) \\\n    { \\\n        return OPENSSL_sk_find((OPENSSL_STACK *)sk, (const void *)ptr); \\\n    } \\\n    static ossl_unused ossl_inline int sk_##t1##_find_ex(STACK_OF(t1) *sk, t2 *ptr) \\\n    { \\\n        return OPENSSL_sk_find_ex((OPENSSL_STACK *)sk, (const void *)ptr); \\\n    } \\\n    static ossl_unused ossl_inline void sk_##t1##_sort(STACK_OF(t1) *sk) \\\n    { \\\n        OPENSSL_sk_sort((OPENSSL_STACK *)sk); \\\n    } \\\n    static ossl_unused ossl_inline int sk_##t1##_is_sorted(const STACK_OF(t1) *sk) \\\n    { \\\n        return OPENSSL_sk_is_sorted((const OPENSSL_STACK *)sk); \\\n    } \\\n    static ossl_unused ossl_inline STACK_OF(t1) * sk_##t1##_dup(const STACK_OF(t1) *sk) \\\n    { \\\n        return (STACK_OF(t1) *)OPENSSL_sk_dup((const OPENSSL_STACK *)sk); \\\n    } \\\n    static ossl_unused ossl_inline STACK_OF(t1) *sk_##t1##_deep_copy(const STACK_OF(t1) *sk, \\\n                                                    sk_##t1##_copyfunc copyfunc, \\\n                                                    sk_##t1##_freefunc freefunc) \\\n    { \\\n        return (STACK_OF(t1) *)OPENSSL_sk_deep_copy((const OPENSSL_STACK *)sk, \\\n                                            (OPENSSL_sk_copyfunc)copyfunc, \\\n                                            (OPENSSL_sk_freefunc)freefunc); \\\n    } \\\n    static ossl_unused ossl_inline sk_##t1##_compfunc sk_##t1##_set_cmp_func(STACK_OF(t1) *sk, sk_##t1##_compfunc compare) \\\n    { \\\n        return (sk_##t1##_compfunc)OPENSSL_sk_set_cmp_func((OPENSSL_STACK *)sk, (OPENSSL_sk_compfunc)compare); \\\n    }\n\n# define DEFINE_SPECIAL_STACK_OF(t1, t2) SKM_DEFINE_STACK_OF(t1, t2, t2)\n# define DEFINE_STACK_OF(t) SKM_DEFINE_STACK_OF(t, t, t)\n# define DEFINE_SPECIAL_STACK_OF_CONST(t1, t2) \\\n            SKM_DEFINE_STACK_OF(t1, const t2, t2)\n# define DEFINE_STACK_OF_CONST(t) SKM_DEFINE_STACK_OF(t, const t, t)\n\n/*-\n * Strings are special: normally an lhash entry will point to a single\n * (somewhat) mutable object. In the case of strings:\n *\n * a) Instead of a single char, there is an array of chars, NUL-terminated.\n * b) The string may have be immutable.\n *\n * So, they need their own declarations. Especially important for\n * type-checking tools, such as Deputy.\n *\n * In practice, however, it appears to be hard to have a const\n * string. For now, I'm settling for dealing with the fact it is a\n * string at all.\n */\ntypedef char *OPENSSL_STRING;\ntypedef const char *OPENSSL_CSTRING;\n\n/*-\n * Confusingly, LHASH_OF(STRING) deals with char ** throughout, but\n * STACK_OF(STRING) is really more like STACK_OF(char), only, as mentioned\n * above, instead of a single char each entry is a NUL-terminated array of\n * chars. So, we have to implement STRING specially for STACK_OF. This is\n * dealt with in the autogenerated macros below.\n */\nDEFINE_SPECIAL_STACK_OF(OPENSSL_STRING, char)\nDEFINE_SPECIAL_STACK_OF_CONST(OPENSSL_CSTRING, char)\n\n/*\n * Similarly, we sometimes use a block of characters, NOT nul-terminated.\n * These should also be distinguished from \"normal\" stacks.\n */\ntypedef void *OPENSSL_BLOCK;\nDEFINE_SPECIAL_STACK_OF(OPENSSL_BLOCK, void)\n\n/*\n * If called without higher optimization (min. -xO3) the Oracle Developer\n * Studio compiler generates code for the defined (static inline) functions\n * above.\n * This would later lead to the linker complaining about missing symbols when\n * this header file is included but the resulting object is not linked against\n * the Crypto library (openssl#6912).\n */\n# ifdef __SUNPRO_C\n#  pragma weak OPENSSL_sk_num\n#  pragma weak OPENSSL_sk_value\n#  pragma weak OPENSSL_sk_new\n#  pragma weak OPENSSL_sk_new_null\n#  pragma weak OPENSSL_sk_new_reserve\n#  pragma weak OPENSSL_sk_reserve\n#  pragma weak OPENSSL_sk_free\n#  pragma weak OPENSSL_sk_zero\n#  pragma weak OPENSSL_sk_delete\n#  pragma weak OPENSSL_sk_delete_ptr\n#  pragma weak OPENSSL_sk_push\n#  pragma weak OPENSSL_sk_unshift\n#  pragma weak OPENSSL_sk_pop\n#  pragma weak OPENSSL_sk_shift\n#  pragma weak OPENSSL_sk_pop_free\n#  pragma weak OPENSSL_sk_insert\n#  pragma weak OPENSSL_sk_set\n#  pragma weak OPENSSL_sk_find\n#  pragma weak OPENSSL_sk_find_ex\n#  pragma weak OPENSSL_sk_sort\n#  pragma weak OPENSSL_sk_is_sorted\n#  pragma weak OPENSSL_sk_dup\n#  pragma weak OPENSSL_sk_deep_copy\n#  pragma weak OPENSSL_sk_set_cmp_func\n# endif /* __SUNPRO_C */\n\n# ifdef  __cplusplus\n}\n# endif\n#endif\n"}, "12": {"id": 12, "path": "/usr/include/openssl/crypto.h", "content": "/*\n * Copyright 1995-2019 The OpenSSL Project Authors. All Rights Reserved.\n * Copyright (c) 2002, Oracle and/or its affiliates. All rights reserved\n *\n * Licensed under the OpenSSL license (the \"License\").  You may not use\n * this file except in compliance with the License.  You can obtain a copy\n * in the file LICENSE in the source distribution or at\n * https://www.openssl.org/source/license.html\n */\n\n#ifndef HEADER_CRYPTO_H\n# define HEADER_CRYPTO_H\n\n# include <stdlib.h>\n# include <time.h>\n\n# include <openssl/e_os2.h>\n\n# ifndef OPENSSL_NO_STDIO\n#  include <stdio.h>\n# endif\n\n# include <openssl/safestack.h>\n# include <openssl/opensslv.h>\n# include <openssl/ossl_typ.h>\n# include <openssl/opensslconf.h>\n# include <openssl/cryptoerr.h>\n\n# ifdef CHARSET_EBCDIC\n#  include <openssl/ebcdic.h>\n# endif\n\n/*\n * Resolve problems on some operating systems with symbol names that clash\n * one way or another\n */\n# include <openssl/symhacks.h>\n\n# if OPENSSL_API_COMPAT < 0x10100000L\n#  include <openssl/opensslv.h>\n# endif\n\n#ifdef  __cplusplus\nextern \"C\" {\n#endif\n\n# if OPENSSL_API_COMPAT < 0x10100000L\n#  define SSLeay                  OpenSSL_version_num\n#  define SSLeay_version          OpenSSL_version\n#  define SSLEAY_VERSION_NUMBER   OPENSSL_VERSION_NUMBER\n#  define SSLEAY_VERSION          OPENSSL_VERSION\n#  define SSLEAY_CFLAGS           OPENSSL_CFLAGS\n#  define SSLEAY_BUILT_ON         OPENSSL_BUILT_ON\n#  define SSLEAY_PLATFORM         OPENSSL_PLATFORM\n#  define SSLEAY_DIR              OPENSSL_DIR\n\n/*\n * Old type for allocating dynamic locks. No longer used. Use the new thread\n * API instead.\n */\ntypedef struct {\n    int dummy;\n} CRYPTO_dynlock;\n\n# endif /* OPENSSL_API_COMPAT */\n\ntypedef void CRYPTO_RWLOCK;\n\nCRYPTO_RWLOCK *CRYPTO_THREAD_lock_new(void);\nint CRYPTO_THREAD_read_lock(CRYPTO_RWLOCK *lock);\nint CRYPTO_THREAD_write_lock(CRYPTO_RWLOCK *lock);\nint CRYPTO_THREAD_unlock(CRYPTO_RWLOCK *lock);\nvoid CRYPTO_THREAD_lock_free(CRYPTO_RWLOCK *lock);\n\nint CRYPTO_atomic_add(int *val, int amount, int *ret, CRYPTO_RWLOCK *lock);\n\n/*\n * The following can be used to detect memory leaks in the library. If\n * used, it turns on malloc checking\n */\n# define CRYPTO_MEM_CHECK_OFF     0x0   /* Control only */\n# define CRYPTO_MEM_CHECK_ON      0x1   /* Control and mode bit */\n# define CRYPTO_MEM_CHECK_ENABLE  0x2   /* Control and mode bit */\n# define CRYPTO_MEM_CHECK_DISABLE 0x3   /* Control only */\n\nstruct crypto_ex_data_st {\n    STACK_OF(void) *sk;\n};\nDEFINE_STACK_OF(void)\n\n/*\n * Per class, we have a STACK of function pointers.\n */\n# define CRYPTO_EX_INDEX_SSL              0\n# define CRYPTO_EX_INDEX_SSL_CTX          1\n# define CRYPTO_EX_INDEX_SSL_SESSION      2\n# define CRYPTO_EX_INDEX_X509             3\n# define CRYPTO_EX_INDEX_X509_STORE       4\n# define CRYPTO_EX_INDEX_X509_STORE_CTX   5\n# define CRYPTO_EX_INDEX_DH               6\n# define CRYPTO_EX_INDEX_DSA              7\n# define CRYPTO_EX_INDEX_EC_KEY           8\n# define CRYPTO_EX_INDEX_RSA              9\n# define CRYPTO_EX_INDEX_ENGINE          10\n# define CRYPTO_EX_INDEX_UI              11\n# define CRYPTO_EX_INDEX_BIO             12\n# define CRYPTO_EX_INDEX_APP             13\n# define CRYPTO_EX_INDEX_UI_METHOD       14\n# define CRYPTO_EX_INDEX_DRBG            15\n# define CRYPTO_EX_INDEX__COUNT          16\n\n/* No longer needed, so this is a no-op */\n#define OPENSSL_malloc_init() while(0) continue\n\nint CRYPTO_mem_ctrl(int mode);\n\n# define OPENSSL_malloc(num) \\\n        CRYPTO_malloc(num, OPENSSL_FILE, OPENSSL_LINE)\n# define OPENSSL_zalloc(num) \\\n        CRYPTO_zalloc(num, OPENSSL_FILE, OPENSSL_LINE)\n# define OPENSSL_realloc(addr, num) \\\n        CRYPTO_realloc(addr, num, OPENSSL_FILE, OPENSSL_LINE)\n# define OPENSSL_clear_realloc(addr, old_num, num) \\\n        CRYPTO_clear_realloc(addr, old_num, num, OPENSSL_FILE, OPENSSL_LINE)\n# define OPENSSL_clear_free(addr, num) \\\n        CRYPTO_clear_free(addr, num, OPENSSL_FILE, OPENSSL_LINE)\n# define OPENSSL_free(addr) \\\n        CRYPTO_free(addr, OPENSSL_FILE, OPENSSL_LINE)\n# define OPENSSL_memdup(str, s) \\\n        CRYPTO_memdup((str), s, OPENSSL_FILE, OPENSSL_LINE)\n# define OPENSSL_strdup(str) \\\n        CRYPTO_strdup(str, OPENSSL_FILE, OPENSSL_LINE)\n# define OPENSSL_strndup(str, n) \\\n        CRYPTO_strndup(str, n, OPENSSL_FILE, OPENSSL_LINE)\n# define OPENSSL_secure_malloc(num) \\\n        CRYPTO_secure_malloc(num, OPENSSL_FILE, OPENSSL_LINE)\n# define OPENSSL_secure_zalloc(num) \\\n        CRYPTO_secure_zalloc(num, OPENSSL_FILE, OPENSSL_LINE)\n# define OPENSSL_secure_free(addr) \\\n        CRYPTO_secure_free(addr, OPENSSL_FILE, OPENSSL_LINE)\n# define OPENSSL_secure_clear_free(addr, num) \\\n        CRYPTO_secure_clear_free(addr, num, OPENSSL_FILE, OPENSSL_LINE)\n# define OPENSSL_secure_actual_size(ptr) \\\n        CRYPTO_secure_actual_size(ptr)\n\nsize_t OPENSSL_strlcpy(char *dst, const char *src, size_t siz);\nsize_t OPENSSL_strlcat(char *dst, const char *src, size_t siz);\nsize_t OPENSSL_strnlen(const char *str, size_t maxlen);\nchar *OPENSSL_buf2hexstr(const unsigned char *buffer, long len);\nunsigned char *OPENSSL_hexstr2buf(const char *str, long *len);\nint OPENSSL_hexchar2int(unsigned char c);\n\n# define OPENSSL_MALLOC_MAX_NELEMS(type)  (((1U<<(sizeof(int)*8-1))-1)/sizeof(type))\n\nunsigned long OpenSSL_version_num(void);\nconst char *OpenSSL_version(int type);\n# define OPENSSL_VERSION          0\n# define OPENSSL_CFLAGS           1\n# define OPENSSL_BUILT_ON         2\n# define OPENSSL_PLATFORM         3\n# define OPENSSL_DIR              4\n# define OPENSSL_ENGINES_DIR      5\n\nint OPENSSL_issetugid(void);\n\ntypedef void CRYPTO_EX_new (void *parent, void *ptr, CRYPTO_EX_DATA *ad,\n                           int idx, long argl, void *argp);\ntypedef void CRYPTO_EX_free (void *parent, void *ptr, CRYPTO_EX_DATA *ad,\n                             int idx, long argl, void *argp);\ntypedef int CRYPTO_EX_dup (CRYPTO_EX_DATA *to, const CRYPTO_EX_DATA *from,\n                           void *from_d, int idx, long argl, void *argp);\n__owur int CRYPTO_get_ex_new_index(int class_index, long argl, void *argp,\n                            CRYPTO_EX_new *new_func, CRYPTO_EX_dup *dup_func,\n                            CRYPTO_EX_free *free_func);\n/* No longer use an index. */\nint CRYPTO_free_ex_index(int class_index, int idx);\n\n/*\n * Initialise/duplicate/free CRYPTO_EX_DATA variables corresponding to a\n * given class (invokes whatever per-class callbacks are applicable)\n */\nint CRYPTO_new_ex_data(int class_index, void *obj, CRYPTO_EX_DATA *ad);\nint CRYPTO_dup_ex_data(int class_index, CRYPTO_EX_DATA *to,\n                       const CRYPTO_EX_DATA *from);\n\nvoid CRYPTO_free_ex_data(int class_index, void *obj, CRYPTO_EX_DATA *ad);\n\n/*\n * Get/set data in a CRYPTO_EX_DATA variable corresponding to a particular\n * index (relative to the class type involved)\n */\nint CRYPTO_set_ex_data(CRYPTO_EX_DATA *ad, int idx, void *val);\nvoid *CRYPTO_get_ex_data(const CRYPTO_EX_DATA *ad, int idx);\n\n# if OPENSSL_API_COMPAT < 0x10100000L\n/*\n * This function cleans up all \"ex_data\" state. It mustn't be called under\n * potential race-conditions.\n */\n# define CRYPTO_cleanup_all_ex_data() while(0) continue\n\n/*\n * The old locking functions have been removed completely without compatibility\n * macros. This is because the old functions either could not properly report\n * errors, or the returned error values were not clearly documented.\n * Replacing the locking functions with no-ops would cause race condition\n * issues in the affected applications. It is far better for them to fail at\n * compile time.\n * On the other hand, the locking callbacks are no longer used.  Consequently,\n * the callback management functions can be safely replaced with no-op macros.\n */\n#  define CRYPTO_num_locks()            (1)\n#  define CRYPTO_set_locking_callback(func)\n#  define CRYPTO_get_locking_callback()         (NULL)\n#  define CRYPTO_set_add_lock_callback(func)\n#  define CRYPTO_get_add_lock_callback()        (NULL)\n\n/*\n * These defines where used in combination with the old locking callbacks,\n * they are not called anymore, but old code that's not called might still\n * use them.\n */\n#  define CRYPTO_LOCK             1\n#  define CRYPTO_UNLOCK           2\n#  define CRYPTO_READ             4\n#  define CRYPTO_WRITE            8\n\n/* This structure is no longer used */\ntypedef struct crypto_threadid_st {\n    int dummy;\n} CRYPTO_THREADID;\n/* Only use CRYPTO_THREADID_set_[numeric|pointer]() within callbacks */\n#  define CRYPTO_THREADID_set_numeric(id, val)\n#  define CRYPTO_THREADID_set_pointer(id, ptr)\n#  define CRYPTO_THREADID_set_callback(threadid_func)   (0)\n#  define CRYPTO_THREADID_get_callback()                (NULL)\n#  define CRYPTO_THREADID_current(id)\n#  define CRYPTO_THREADID_cmp(a, b)                     (-1)\n#  define CRYPTO_THREADID_cpy(dest, src)\n#  define CRYPTO_THREADID_hash(id)                      (0UL)\n\n#  if OPENSSL_API_COMPAT < 0x10000000L\n#   define CRYPTO_set_id_callback(func)\n#   define CRYPTO_get_id_callback()                     (NULL)\n#   define CRYPTO_thread_id()                           (0UL)\n#  endif /* OPENSSL_API_COMPAT < 0x10000000L */\n\n#  define CRYPTO_set_dynlock_create_callback(dyn_create_function)\n#  define CRYPTO_set_dynlock_lock_callback(dyn_lock_function)\n#  define CRYPTO_set_dynlock_destroy_callback(dyn_destroy_function)\n#  define CRYPTO_get_dynlock_create_callback()          (NULL)\n#  define CRYPTO_get_dynlock_lock_callback()            (NULL)\n#  define CRYPTO_get_dynlock_destroy_callback()         (NULL)\n# endif /* OPENSSL_API_COMPAT < 0x10100000L */\n\nint CRYPTO_set_mem_functions(\n        void *(*m) (size_t, const char *, int),\n        void *(*r) (void *, size_t, const char *, int),\n        void (*f) (void *, const char *, int));\nint CRYPTO_set_mem_debug(int flag);\nvoid CRYPTO_get_mem_functions(\n        void *(**m) (size_t, const char *, int),\n        void *(**r) (void *, size_t, const char *, int),\n        void (**f) (void *, const char *, int));\n\nvoid *CRYPTO_malloc(size_t num, const char *file, int line);\nvoid *CRYPTO_zalloc(size_t num, const char *file, int line);\nvoid *CRYPTO_memdup(const void *str, size_t siz, const char *file, int line);\nchar *CRYPTO_strdup(const char *str, const char *file, int line);\nchar *CRYPTO_strndup(const char *str, size_t s, const char *file, int line);\nvoid CRYPTO_free(void *ptr, const char *file, int line);\nvoid CRYPTO_clear_free(void *ptr, size_t num, const char *file, int line);\nvoid *CRYPTO_realloc(void *addr, size_t num, const char *file, int line);\nvoid *CRYPTO_clear_realloc(void *addr, size_t old_num, size_t num,\n                           const char *file, int line);\n\nint CRYPTO_secure_malloc_init(size_t sz, int minsize);\nint CRYPTO_secure_malloc_done(void);\nvoid *CRYPTO_secure_malloc(size_t num, const char *file, int line);\nvoid *CRYPTO_secure_zalloc(size_t num, const char *file, int line);\nvoid CRYPTO_secure_free(void *ptr, const char *file, int line);\nvoid CRYPTO_secure_clear_free(void *ptr, size_t num,\n                              const char *file, int line);\nint CRYPTO_secure_allocated(const void *ptr);\nint CRYPTO_secure_malloc_initialized(void);\nsize_t CRYPTO_secure_actual_size(void *ptr);\nsize_t CRYPTO_secure_used(void);\n\nvoid OPENSSL_cleanse(void *ptr, size_t len);\n\n# ifndef OPENSSL_NO_CRYPTO_MDEBUG\n#  define OPENSSL_mem_debug_push(info) \\\n        CRYPTO_mem_debug_push(info, OPENSSL_FILE, OPENSSL_LINE)\n#  define OPENSSL_mem_debug_pop() \\\n        CRYPTO_mem_debug_pop()\nint CRYPTO_mem_debug_push(const char *info, const char *file, int line);\nint CRYPTO_mem_debug_pop(void);\nvoid CRYPTO_get_alloc_counts(int *mcount, int *rcount, int *fcount);\n\n/*-\n * Debugging functions (enabled by CRYPTO_set_mem_debug(1))\n * The flag argument has the following significance:\n *   0:   called before the actual memory allocation has taken place\n *   1:   called after the actual memory allocation has taken place\n */\nvoid CRYPTO_mem_debug_malloc(void *addr, size_t num, int flag,\n        const char *file, int line);\nvoid CRYPTO_mem_debug_realloc(void *addr1, void *addr2, size_t num, int flag,\n        const char *file, int line);\nvoid CRYPTO_mem_debug_free(void *addr, int flag,\n        const char *file, int line);\n\nint CRYPTO_mem_leaks_cb(int (*cb) (const char *str, size_t len, void *u),\n                        void *u);\n#  ifndef OPENSSL_NO_STDIO\nint CRYPTO_mem_leaks_fp(FILE *);\n#  endif\nint CRYPTO_mem_leaks(BIO *bio);\n# endif\n\n/* die if we have to */\nossl_noreturn void OPENSSL_die(const char *assertion, const char *file, int line);\n# if OPENSSL_API_COMPAT < 0x10100000L\n#  define OpenSSLDie(f,l,a) OPENSSL_die((a),(f),(l))\n# endif\n# define OPENSSL_assert(e) \\\n    (void)((e) ? 0 : (OPENSSL_die(\"assertion failed: \" #e, OPENSSL_FILE, OPENSSL_LINE), 1))\n\nint OPENSSL_isservice(void);\n\nint FIPS_mode(void);\nint FIPS_mode_set(int r);\n\nvoid OPENSSL_init(void);\n# ifdef OPENSSL_SYS_UNIX\nvoid OPENSSL_fork_prepare(void);\nvoid OPENSSL_fork_parent(void);\nvoid OPENSSL_fork_child(void);\n# endif\n\nstruct tm *OPENSSL_gmtime(const time_t *timer, struct tm *result);\nint OPENSSL_gmtime_adj(struct tm *tm, int offset_day, long offset_sec);\nint OPENSSL_gmtime_diff(int *pday, int *psec,\n                        const struct tm *from, const struct tm *to);\n\n/*\n * CRYPTO_memcmp returns zero iff the |len| bytes at |a| and |b| are equal.\n * It takes an amount of time dependent on |len|, but independent of the\n * contents of |a| and |b|. Unlike memcmp, it cannot be used to put elements\n * into a defined order as the return value when a != b is undefined, other\n * than to be non-zero.\n */\nint CRYPTO_memcmp(const void * in_a, const void * in_b, size_t len);\n\n/* Standard initialisation options */\n# define OPENSSL_INIT_NO_LOAD_CRYPTO_STRINGS 0x00000001L\n# define OPENSSL_INIT_LOAD_CRYPTO_STRINGS    0x00000002L\n# define OPENSSL_INIT_ADD_ALL_CIPHERS        0x00000004L\n# define OPENSSL_INIT_ADD_ALL_DIGESTS        0x00000008L\n# define OPENSSL_INIT_NO_ADD_ALL_CIPHERS     0x00000010L\n# define OPENSSL_INIT_NO_ADD_ALL_DIGESTS     0x00000020L\n# define OPENSSL_INIT_LOAD_CONFIG            0x00000040L\n# define OPENSSL_INIT_NO_LOAD_CONFIG         0x00000080L\n# define OPENSSL_INIT_ASYNC                  0x00000100L\n# define OPENSSL_INIT_ENGINE_RDRAND          0x00000200L\n# define OPENSSL_INIT_ENGINE_DYNAMIC         0x00000400L\n# define OPENSSL_INIT_ENGINE_OPENSSL         0x00000800L\n# define OPENSSL_INIT_ENGINE_CRYPTODEV       0x00001000L\n# define OPENSSL_INIT_ENGINE_CAPI            0x00002000L\n# define OPENSSL_INIT_ENGINE_PADLOCK         0x00004000L\n# define OPENSSL_INIT_ENGINE_AFALG           0x00008000L\n/* OPENSSL_INIT_ZLIB                         0x00010000L */\n# define OPENSSL_INIT_ATFORK                 0x00020000L\n/* OPENSSL_INIT_BASE_ONLY                    0x00040000L */\n# define OPENSSL_INIT_NO_ATEXIT              0x00080000L\n/* OPENSSL_INIT flag range 0xfff00000 reserved for OPENSSL_init_ssl() */\n/* Max OPENSSL_INIT flag value is 0x80000000 */\n\n/* openssl and dasync not counted as builtin */\n# define OPENSSL_INIT_ENGINE_ALL_BUILTIN \\\n    (OPENSSL_INIT_ENGINE_RDRAND | OPENSSL_INIT_ENGINE_DYNAMIC \\\n    | OPENSSL_INIT_ENGINE_CRYPTODEV | OPENSSL_INIT_ENGINE_CAPI | \\\n    OPENSSL_INIT_ENGINE_PADLOCK)\n\n\n/* Library initialisation functions */\nvoid OPENSSL_cleanup(void);\nint OPENSSL_init_crypto(uint64_t opts, const OPENSSL_INIT_SETTINGS *settings);\nint OPENSSL_atexit(void (*handler)(void));\nvoid OPENSSL_thread_stop(void);\n\n/* Low-level control of initialization */\nOPENSSL_INIT_SETTINGS *OPENSSL_INIT_new(void);\n# ifndef OPENSSL_NO_STDIO\nint OPENSSL_INIT_set_config_filename(OPENSSL_INIT_SETTINGS *settings,\n                                     const char *config_filename);\nvoid OPENSSL_INIT_set_config_file_flags(OPENSSL_INIT_SETTINGS *settings,\n                                        unsigned long flags);\nint OPENSSL_INIT_set_config_appname(OPENSSL_INIT_SETTINGS *settings,\n                                    const char *config_appname);\n# endif\nvoid OPENSSL_INIT_free(OPENSSL_INIT_SETTINGS *settings);\n\n# if defined(OPENSSL_THREADS) && !defined(CRYPTO_TDEBUG)\n#  if defined(_WIN32)\n#   if defined(BASETYPES) || defined(_WINDEF_H)\n/* application has to include <windows.h> in order to use this */\ntypedef DWORD CRYPTO_THREAD_LOCAL;\ntypedef DWORD CRYPTO_THREAD_ID;\n\ntypedef LONG CRYPTO_ONCE;\n#    define CRYPTO_ONCE_STATIC_INIT 0\n#   endif\n#  else\n#   include <pthread.h>\ntypedef pthread_once_t CRYPTO_ONCE;\ntypedef pthread_key_t CRYPTO_THREAD_LOCAL;\ntypedef pthread_t CRYPTO_THREAD_ID;\n\n#   define CRYPTO_ONCE_STATIC_INIT PTHREAD_ONCE_INIT\n#  endif\n# endif\n\n# if !defined(CRYPTO_ONCE_STATIC_INIT)\ntypedef unsigned int CRYPTO_ONCE;\ntypedef unsigned int CRYPTO_THREAD_LOCAL;\ntypedef unsigned int CRYPTO_THREAD_ID;\n#  define CRYPTO_ONCE_STATIC_INIT 0\n# endif\n\nint CRYPTO_THREAD_run_once(CRYPTO_ONCE *once, void (*init)(void));\n\nint CRYPTO_THREAD_init_local(CRYPTO_THREAD_LOCAL *key, void (*cleanup)(void *));\nvoid *CRYPTO_THREAD_get_local(CRYPTO_THREAD_LOCAL *key);\nint CRYPTO_THREAD_set_local(CRYPTO_THREAD_LOCAL *key, void *val);\nint CRYPTO_THREAD_cleanup_local(CRYPTO_THREAD_LOCAL *key);\n\nCRYPTO_THREAD_ID CRYPTO_THREAD_get_current_id(void);\nint CRYPTO_THREAD_compare_id(CRYPTO_THREAD_ID a, CRYPTO_THREAD_ID b);\n\n\n# ifdef  __cplusplus\n}\n# endif\n#endif\n"}, "14": {"id": 14, "path": "/usr/include/openssl/bio.h", "content": "/*\n * Copyright 1995-2020 The OpenSSL Project Authors. All Rights Reserved.\n *\n * Licensed under the OpenSSL license (the \"License\").  You may not use\n * this file except in compliance with the License.  You can obtain a copy\n * in the file LICENSE in the source distribution or at\n * https://www.openssl.org/source/license.html\n */\n\n#ifndef HEADER_BIO_H\n# define HEADER_BIO_H\n\n# include <openssl/e_os2.h>\n\n# ifndef OPENSSL_NO_STDIO\n#  include <stdio.h>\n# endif\n# include <stdarg.h>\n\n# include <openssl/crypto.h>\n# include <openssl/bioerr.h>\n\n#ifdef  __cplusplus\nextern \"C\" {\n#endif\n\n/* There are the classes of BIOs */\n# define BIO_TYPE_DESCRIPTOR     0x0100 /* socket, fd, connect or accept */\n# define BIO_TYPE_FILTER         0x0200\n# define BIO_TYPE_SOURCE_SINK    0x0400\n\n/* These are the 'types' of BIOs */\n# define BIO_TYPE_NONE             0\n# define BIO_TYPE_MEM            ( 1|BIO_TYPE_SOURCE_SINK)\n# define BIO_TYPE_FILE           ( 2|BIO_TYPE_SOURCE_SINK)\n\n# define BIO_TYPE_FD             ( 4|BIO_TYPE_SOURCE_SINK|BIO_TYPE_DESCRIPTOR)\n# define BIO_TYPE_SOCKET         ( 5|BIO_TYPE_SOURCE_SINK|BIO_TYPE_DESCRIPTOR)\n# define BIO_TYPE_NULL           ( 6|BIO_TYPE_SOURCE_SINK)\n# define BIO_TYPE_SSL            ( 7|BIO_TYPE_FILTER)\n# define BIO_TYPE_MD             ( 8|BIO_TYPE_FILTER)\n# define BIO_TYPE_BUFFER         ( 9|BIO_TYPE_FILTER)\n# define BIO_TYPE_CIPHER         (10|BIO_TYPE_FILTER)\n# define BIO_TYPE_BASE64         (11|BIO_TYPE_FILTER)\n# define BIO_TYPE_CONNECT        (12|BIO_TYPE_SOURCE_SINK|BIO_TYPE_DESCRIPTOR)\n# define BIO_TYPE_ACCEPT         (13|BIO_TYPE_SOURCE_SINK|BIO_TYPE_DESCRIPTOR)\n\n# define BIO_TYPE_NBIO_TEST      (16|BIO_TYPE_FILTER)/* server proxy BIO */\n# define BIO_TYPE_NULL_FILTER    (17|BIO_TYPE_FILTER)\n# define BIO_TYPE_BIO            (19|BIO_TYPE_SOURCE_SINK)/* half a BIO pair */\n# define BIO_TYPE_LINEBUFFER     (20|BIO_TYPE_FILTER)\n# define BIO_TYPE_DGRAM          (21|BIO_TYPE_SOURCE_SINK|BIO_TYPE_DESCRIPTOR)\n# define BIO_TYPE_ASN1           (22|BIO_TYPE_FILTER)\n# define BIO_TYPE_COMP           (23|BIO_TYPE_FILTER)\n# ifndef OPENSSL_NO_SCTP\n#  define BIO_TYPE_DGRAM_SCTP    (24|BIO_TYPE_SOURCE_SINK|BIO_TYPE_DESCRIPTOR)\n# endif\n\n#define BIO_TYPE_START           128\n\n/*\n * BIO_FILENAME_READ|BIO_CLOSE to open or close on free.\n * BIO_set_fp(in,stdin,BIO_NOCLOSE);\n */\n# define BIO_NOCLOSE             0x00\n# define BIO_CLOSE               0x01\n\n/*\n * These are used in the following macros and are passed to BIO_ctrl()\n */\n# define BIO_CTRL_RESET          1/* opt - rewind/zero etc */\n# define BIO_CTRL_EOF            2/* opt - are we at the eof */\n# define BIO_CTRL_INFO           3/* opt - extra tit-bits */\n# define BIO_CTRL_SET            4/* man - set the 'IO' type */\n# define BIO_CTRL_GET            5/* man - get the 'IO' type */\n# define BIO_CTRL_PUSH           6/* opt - internal, used to signify change */\n# define BIO_CTRL_POP            7/* opt - internal, used to signify change */\n# define BIO_CTRL_GET_CLOSE      8/* man - set the 'close' on free */\n# define BIO_CTRL_SET_CLOSE      9/* man - set the 'close' on free */\n# define BIO_CTRL_PENDING        10/* opt - is their more data buffered */\n# define BIO_CTRL_FLUSH          11/* opt - 'flush' buffered output */\n# define BIO_CTRL_DUP            12/* man - extra stuff for 'duped' BIO */\n# define BIO_CTRL_WPENDING       13/* opt - number of bytes still to write */\n# define BIO_CTRL_SET_CALLBACK   14/* opt - set callback function */\n# define BIO_CTRL_GET_CALLBACK   15/* opt - set callback function */\n\n# define BIO_CTRL_PEEK           29/* BIO_f_buffer special */\n# define BIO_CTRL_SET_FILENAME   30/* BIO_s_file special */\n\n/* dgram BIO stuff */\n# define BIO_CTRL_DGRAM_CONNECT       31/* BIO dgram special */\n# define BIO_CTRL_DGRAM_SET_CONNECTED 32/* allow for an externally connected\n                                         * socket to be passed in */\n# define BIO_CTRL_DGRAM_SET_RECV_TIMEOUT 33/* setsockopt, essentially */\n# define BIO_CTRL_DGRAM_GET_RECV_TIMEOUT 34/* getsockopt, essentially */\n# define BIO_CTRL_DGRAM_SET_SEND_TIMEOUT 35/* setsockopt, essentially */\n# define BIO_CTRL_DGRAM_GET_SEND_TIMEOUT 36/* getsockopt, essentially */\n\n# define BIO_CTRL_DGRAM_GET_RECV_TIMER_EXP 37/* flag whether the last */\n# define BIO_CTRL_DGRAM_GET_SEND_TIMER_EXP 38/* I/O operation tiemd out */\n\n/* #ifdef IP_MTU_DISCOVER */\n# define BIO_CTRL_DGRAM_MTU_DISCOVER       39/* set DF bit on egress packets */\n/* #endif */\n\n# define BIO_CTRL_DGRAM_QUERY_MTU          40/* as kernel for current MTU */\n# define BIO_CTRL_DGRAM_GET_FALLBACK_MTU   47\n# define BIO_CTRL_DGRAM_GET_MTU            41/* get cached value for MTU */\n# define BIO_CTRL_DGRAM_SET_MTU            42/* set cached value for MTU.\n                                              * want to use this if asking\n                                              * the kernel fails */\n\n# define BIO_CTRL_DGRAM_MTU_EXCEEDED       43/* check whether the MTU was\n                                              * exceed in the previous write\n                                              * operation */\n\n# define BIO_CTRL_DGRAM_GET_PEER           46\n# define BIO_CTRL_DGRAM_SET_PEER           44/* Destination for the data */\n\n# define BIO_CTRL_DGRAM_SET_NEXT_TIMEOUT   45/* Next DTLS handshake timeout\n                                              * to adjust socket timeouts */\n# define BIO_CTRL_DGRAM_SET_DONT_FRAG      48\n\n# define BIO_CTRL_DGRAM_GET_MTU_OVERHEAD   49\n\n/* Deliberately outside of OPENSSL_NO_SCTP - used in bss_dgram.c */\n#  define BIO_CTRL_DGRAM_SCTP_SET_IN_HANDSHAKE    50\n# ifndef OPENSSL_NO_SCTP\n/* SCTP stuff */\n#  define BIO_CTRL_DGRAM_SCTP_ADD_AUTH_KEY                51\n#  define BIO_CTRL_DGRAM_SCTP_NEXT_AUTH_KEY               52\n#  define BIO_CTRL_DGRAM_SCTP_AUTH_CCS_RCVD               53\n#  define BIO_CTRL_DGRAM_SCTP_GET_SNDINFO         60\n#  define BIO_CTRL_DGRAM_SCTP_SET_SNDINFO         61\n#  define BIO_CTRL_DGRAM_SCTP_GET_RCVINFO         62\n#  define BIO_CTRL_DGRAM_SCTP_SET_RCVINFO         63\n#  define BIO_CTRL_DGRAM_SCTP_GET_PRINFO                  64\n#  define BIO_CTRL_DGRAM_SCTP_SET_PRINFO                  65\n#  define BIO_CTRL_DGRAM_SCTP_SAVE_SHUTDOWN               70\n# endif\n\n# define BIO_CTRL_DGRAM_SET_PEEK_MODE      71\n\n/* modifiers */\n# define BIO_FP_READ             0x02\n# define BIO_FP_WRITE            0x04\n# define BIO_FP_APPEND           0x08\n# define BIO_FP_TEXT             0x10\n\n# define BIO_FLAGS_READ          0x01\n# define BIO_FLAGS_WRITE         0x02\n# define BIO_FLAGS_IO_SPECIAL    0x04\n# define BIO_FLAGS_RWS (BIO_FLAGS_READ|BIO_FLAGS_WRITE|BIO_FLAGS_IO_SPECIAL)\n# define BIO_FLAGS_SHOULD_RETRY  0x08\n# ifndef BIO_FLAGS_UPLINK\n/*\n * \"UPLINK\" flag denotes file descriptors provided by application. It\n * defaults to 0, as most platforms don't require UPLINK interface.\n */\n#  define BIO_FLAGS_UPLINK        0\n# endif\n\n# define BIO_FLAGS_BASE64_NO_NL  0x100\n\n/*\n * This is used with memory BIOs:\n * BIO_FLAGS_MEM_RDONLY means we shouldn't free up or change the data in any way;\n * BIO_FLAGS_NONCLEAR_RST means we shouldn't clear data on reset.\n */\n# define BIO_FLAGS_MEM_RDONLY    0x200\n# define BIO_FLAGS_NONCLEAR_RST  0x400\n# define BIO_FLAGS_IN_EOF        0x800\n\ntypedef union bio_addr_st BIO_ADDR;\ntypedef struct bio_addrinfo_st BIO_ADDRINFO;\n\nint BIO_get_new_index(void);\nvoid BIO_set_flags(BIO *b, int flags);\nint BIO_test_flags(const BIO *b, int flags);\nvoid BIO_clear_flags(BIO *b, int flags);\n\n# define BIO_get_flags(b) BIO_test_flags(b, ~(0x0))\n# define BIO_set_retry_special(b) \\\n                BIO_set_flags(b, (BIO_FLAGS_IO_SPECIAL|BIO_FLAGS_SHOULD_RETRY))\n# define BIO_set_retry_read(b) \\\n                BIO_set_flags(b, (BIO_FLAGS_READ|BIO_FLAGS_SHOULD_RETRY))\n# define BIO_set_retry_write(b) \\\n                BIO_set_flags(b, (BIO_FLAGS_WRITE|BIO_FLAGS_SHOULD_RETRY))\n\n/* These are normally used internally in BIOs */\n# define BIO_clear_retry_flags(b) \\\n                BIO_clear_flags(b, (BIO_FLAGS_RWS|BIO_FLAGS_SHOULD_RETRY))\n# define BIO_get_retry_flags(b) \\\n                BIO_test_flags(b, (BIO_FLAGS_RWS|BIO_FLAGS_SHOULD_RETRY))\n\n/* These should be used by the application to tell why we should retry */\n# define BIO_should_read(a)              BIO_test_flags(a, BIO_FLAGS_READ)\n# define BIO_should_write(a)             BIO_test_flags(a, BIO_FLAGS_WRITE)\n# define BIO_should_io_special(a)        BIO_test_flags(a, BIO_FLAGS_IO_SPECIAL)\n# define BIO_retry_type(a)               BIO_test_flags(a, BIO_FLAGS_RWS)\n# define BIO_should_retry(a)             BIO_test_flags(a, BIO_FLAGS_SHOULD_RETRY)\n\n/*\n * The next three are used in conjunction with the BIO_should_io_special()\n * condition.  After this returns true, BIO *BIO_get_retry_BIO(BIO *bio, int\n * *reason); will walk the BIO stack and return the 'reason' for the special\n * and the offending BIO. Given a BIO, BIO_get_retry_reason(bio) will return\n * the code.\n */\n/*\n * Returned from the SSL bio when the certificate retrieval code had an error\n */\n# define BIO_RR_SSL_X509_LOOKUP          0x01\n/* Returned from the connect BIO when a connect would have blocked */\n# define BIO_RR_CONNECT                  0x02\n/* Returned from the accept BIO when an accept would have blocked */\n# define BIO_RR_ACCEPT                   0x03\n\n/* These are passed by the BIO callback */\n# define BIO_CB_FREE     0x01\n# define BIO_CB_READ     0x02\n# define BIO_CB_WRITE    0x03\n# define BIO_CB_PUTS     0x04\n# define BIO_CB_GETS     0x05\n# define BIO_CB_CTRL     0x06\n\n/*\n * The callback is called before and after the underling operation, The\n * BIO_CB_RETURN flag indicates if it is after the call\n */\n# define BIO_CB_RETURN   0x80\n# define BIO_CB_return(a) ((a)|BIO_CB_RETURN)\n# define BIO_cb_pre(a)   (!((a)&BIO_CB_RETURN))\n# define BIO_cb_post(a)  ((a)&BIO_CB_RETURN)\n\ntypedef long (*BIO_callback_fn)(BIO *b, int oper, const char *argp, int argi,\n                                long argl, long ret);\ntypedef long (*BIO_callback_fn_ex)(BIO *b, int oper, const char *argp,\n                                   size_t len, int argi,\n                                   long argl, int ret, size_t *processed);\nBIO_callback_fn BIO_get_callback(const BIO *b);\nvoid BIO_set_callback(BIO *b, BIO_callback_fn callback);\n\nBIO_callback_fn_ex BIO_get_callback_ex(const BIO *b);\nvoid BIO_set_callback_ex(BIO *b, BIO_callback_fn_ex callback);\n\nchar *BIO_get_callback_arg(const BIO *b);\nvoid BIO_set_callback_arg(BIO *b, char *arg);\n\ntypedef struct bio_method_st BIO_METHOD;\n\nconst char *BIO_method_name(const BIO *b);\nint BIO_method_type(const BIO *b);\n\ntypedef int BIO_info_cb(BIO *, int, int);\ntypedef BIO_info_cb bio_info_cb;  /* backward compatibility */\n\nDEFINE_STACK_OF(BIO)\n\n/* Prefix and suffix callback in ASN1 BIO */\ntypedef int asn1_ps_func (BIO *b, unsigned char **pbuf, int *plen,\n                          void *parg);\n\n# ifndef OPENSSL_NO_SCTP\n/* SCTP parameter structs */\nstruct bio_dgram_sctp_sndinfo {\n    uint16_t snd_sid;\n    uint16_t snd_flags;\n    uint32_t snd_ppid;\n    uint32_t snd_context;\n};\n\nstruct bio_dgram_sctp_rcvinfo {\n    uint16_t rcv_sid;\n    uint16_t rcv_ssn;\n    uint16_t rcv_flags;\n    uint32_t rcv_ppid;\n    uint32_t rcv_tsn;\n    uint32_t rcv_cumtsn;\n    uint32_t rcv_context;\n};\n\nstruct bio_dgram_sctp_prinfo {\n    uint16_t pr_policy;\n    uint32_t pr_value;\n};\n# endif\n\n/*\n * #define BIO_CONN_get_param_hostname BIO_ctrl\n */\n\n# define BIO_C_SET_CONNECT                       100\n# define BIO_C_DO_STATE_MACHINE                  101\n# define BIO_C_SET_NBIO                          102\n/* # define BIO_C_SET_PROXY_PARAM                   103 */\n# define BIO_C_SET_FD                            104\n# define BIO_C_GET_FD                            105\n# define BIO_C_SET_FILE_PTR                      106\n# define BIO_C_GET_FILE_PTR                      107\n# define BIO_C_SET_FILENAME                      108\n# define BIO_C_SET_SSL                           109\n# define BIO_C_GET_SSL                           110\n# define BIO_C_SET_MD                            111\n# define BIO_C_GET_MD                            112\n# define BIO_C_GET_CIPHER_STATUS                 113\n# define BIO_C_SET_BUF_MEM                       114\n# define BIO_C_GET_BUF_MEM_PTR                   115\n# define BIO_C_GET_BUFF_NUM_LINES                116\n# define BIO_C_SET_BUFF_SIZE                     117\n# define BIO_C_SET_ACCEPT                        118\n# define BIO_C_SSL_MODE                          119\n# define BIO_C_GET_MD_CTX                        120\n/* # define BIO_C_GET_PROXY_PARAM                   121 */\n# define BIO_C_SET_BUFF_READ_DATA                122/* data to read first */\n# define BIO_C_GET_CONNECT                       123\n# define BIO_C_GET_ACCEPT                        124\n# define BIO_C_SET_SSL_RENEGOTIATE_BYTES         125\n# define BIO_C_GET_SSL_NUM_RENEGOTIATES          126\n# define BIO_C_SET_SSL_RENEGOTIATE_TIMEOUT       127\n# define BIO_C_FILE_SEEK                         128\n# define BIO_C_GET_CIPHER_CTX                    129\n# define BIO_C_SET_BUF_MEM_EOF_RETURN            130/* return end of input\n                                                     * value */\n# define BIO_C_SET_BIND_MODE                     131\n# define BIO_C_GET_BIND_MODE                     132\n# define BIO_C_FILE_TELL                         133\n# define BIO_C_GET_SOCKS                         134\n# define BIO_C_SET_SOCKS                         135\n\n# define BIO_C_SET_WRITE_BUF_SIZE                136/* for BIO_s_bio */\n# define BIO_C_GET_WRITE_BUF_SIZE                137\n# define BIO_C_MAKE_BIO_PAIR                     138\n# define BIO_C_DESTROY_BIO_PAIR                  139\n# define BIO_C_GET_WRITE_GUARANTEE               140\n# define BIO_C_GET_READ_REQUEST                  141\n# define BIO_C_SHUTDOWN_WR                       142\n# define BIO_C_NREAD0                            143\n# define BIO_C_NREAD                             144\n# define BIO_C_NWRITE0                           145\n# define BIO_C_NWRITE                            146\n# define BIO_C_RESET_READ_REQUEST                147\n# define BIO_C_SET_MD_CTX                        148\n\n# define BIO_C_SET_PREFIX                        149\n# define BIO_C_GET_PREFIX                        150\n# define BIO_C_SET_SUFFIX                        151\n# define BIO_C_GET_SUFFIX                        152\n\n# define BIO_C_SET_EX_ARG                        153\n# define BIO_C_GET_EX_ARG                        154\n\n# define BIO_C_SET_CONNECT_MODE                  155\n\n# define BIO_set_app_data(s,arg)         BIO_set_ex_data(s,0,arg)\n# define BIO_get_app_data(s)             BIO_get_ex_data(s,0)\n\n# define BIO_set_nbio(b,n)             BIO_ctrl(b,BIO_C_SET_NBIO,(n),NULL)\n\n# ifndef OPENSSL_NO_SOCK\n/* IP families we support, for BIO_s_connect() and BIO_s_accept() */\n/* Note: the underlying operating system may not support some of them */\n#  define BIO_FAMILY_IPV4                         4\n#  define BIO_FAMILY_IPV6                         6\n#  define BIO_FAMILY_IPANY                        256\n\n/* BIO_s_connect() */\n#  define BIO_set_conn_hostname(b,name) BIO_ctrl(b,BIO_C_SET_CONNECT,0, \\\n                                                 (char *)(name))\n#  define BIO_set_conn_port(b,port)     BIO_ctrl(b,BIO_C_SET_CONNECT,1, \\\n                                                 (char *)(port))\n#  define BIO_set_conn_address(b,addr)  BIO_ctrl(b,BIO_C_SET_CONNECT,2, \\\n                                                 (char *)(addr))\n#  define BIO_set_conn_ip_family(b,f)   BIO_int_ctrl(b,BIO_C_SET_CONNECT,3,f)\n#  define BIO_get_conn_hostname(b)      ((const char *)BIO_ptr_ctrl(b,BIO_C_GET_CONNECT,0))\n#  define BIO_get_conn_port(b)          ((const char *)BIO_ptr_ctrl(b,BIO_C_GET_CONNECT,1))\n#  define BIO_get_conn_address(b)       ((const BIO_ADDR *)BIO_ptr_ctrl(b,BIO_C_GET_CONNECT,2))\n#  define BIO_get_conn_ip_family(b)     BIO_ctrl(b,BIO_C_GET_CONNECT,3,NULL)\n#  define BIO_set_conn_mode(b,n)        BIO_ctrl(b,BIO_C_SET_CONNECT_MODE,(n),NULL)\n\n/* BIO_s_accept() */\n#  define BIO_set_accept_name(b,name)   BIO_ctrl(b,BIO_C_SET_ACCEPT,0, \\\n                                                 (char *)(name))\n#  define BIO_set_accept_port(b,port)   BIO_ctrl(b,BIO_C_SET_ACCEPT,1, \\\n                                                 (char *)(port))\n#  define BIO_get_accept_name(b)        ((const char *)BIO_ptr_ctrl(b,BIO_C_GET_ACCEPT,0))\n#  define BIO_get_accept_port(b)        ((const char *)BIO_ptr_ctrl(b,BIO_C_GET_ACCEPT,1))\n#  define BIO_get_peer_name(b)          ((const char *)BIO_ptr_ctrl(b,BIO_C_GET_ACCEPT,2))\n#  define BIO_get_peer_port(b)          ((const char *)BIO_ptr_ctrl(b,BIO_C_GET_ACCEPT,3))\n/* #define BIO_set_nbio(b,n)    BIO_ctrl(b,BIO_C_SET_NBIO,(n),NULL) */\n#  define BIO_set_nbio_accept(b,n)      BIO_ctrl(b,BIO_C_SET_ACCEPT,2,(n)?(void *)\"a\":NULL)\n#  define BIO_set_accept_bios(b,bio)    BIO_ctrl(b,BIO_C_SET_ACCEPT,3, \\\n                                                 (char *)(bio))\n#  define BIO_set_accept_ip_family(b,f) BIO_int_ctrl(b,BIO_C_SET_ACCEPT,4,f)\n#  define BIO_get_accept_ip_family(b)   BIO_ctrl(b,BIO_C_GET_ACCEPT,4,NULL)\n\n/* Aliases kept for backward compatibility */\n#  define BIO_BIND_NORMAL                 0\n#  define BIO_BIND_REUSEADDR              BIO_SOCK_REUSEADDR\n#  define BIO_BIND_REUSEADDR_IF_UNUSED    BIO_SOCK_REUSEADDR\n#  define BIO_set_bind_mode(b,mode) BIO_ctrl(b,BIO_C_SET_BIND_MODE,mode,NULL)\n#  define BIO_get_bind_mode(b)    BIO_ctrl(b,BIO_C_GET_BIND_MODE,0,NULL)\n\n/* BIO_s_accept() and BIO_s_connect() */\n#  define BIO_do_connect(b)       BIO_do_handshake(b)\n#  define BIO_do_accept(b)        BIO_do_handshake(b)\n# endif /* OPENSSL_NO_SOCK */\n\n# define BIO_do_handshake(b)     BIO_ctrl(b,BIO_C_DO_STATE_MACHINE,0,NULL)\n\n/* BIO_s_datagram(), BIO_s_fd(), BIO_s_socket(), BIO_s_accept() and BIO_s_connect() */\n# define BIO_set_fd(b,fd,c)      BIO_int_ctrl(b,BIO_C_SET_FD,c,fd)\n# define BIO_get_fd(b,c)         BIO_ctrl(b,BIO_C_GET_FD,0,(char *)(c))\n\n/* BIO_s_file() */\n# define BIO_set_fp(b,fp,c)      BIO_ctrl(b,BIO_C_SET_FILE_PTR,c,(char *)(fp))\n# define BIO_get_fp(b,fpp)       BIO_ctrl(b,BIO_C_GET_FILE_PTR,0,(char *)(fpp))\n\n/* BIO_s_fd() and BIO_s_file() */\n# define BIO_seek(b,ofs) (int)BIO_ctrl(b,BIO_C_FILE_SEEK,ofs,NULL)\n# define BIO_tell(b)     (int)BIO_ctrl(b,BIO_C_FILE_TELL,0,NULL)\n\n/*\n * name is cast to lose const, but might be better to route through a\n * function so we can do it safely\n */\n# ifdef CONST_STRICT\n/*\n * If you are wondering why this isn't defined, its because CONST_STRICT is\n * purely a compile-time kludge to allow const to be checked.\n */\nint BIO_read_filename(BIO *b, const char *name);\n# else\n#  define BIO_read_filename(b,name) (int)BIO_ctrl(b,BIO_C_SET_FILENAME, \\\n                BIO_CLOSE|BIO_FP_READ,(char *)(name))\n# endif\n# define BIO_write_filename(b,name) (int)BIO_ctrl(b,BIO_C_SET_FILENAME, \\\n                BIO_CLOSE|BIO_FP_WRITE,name)\n# define BIO_append_filename(b,name) (int)BIO_ctrl(b,BIO_C_SET_FILENAME, \\\n                BIO_CLOSE|BIO_FP_APPEND,name)\n# define BIO_rw_filename(b,name) (int)BIO_ctrl(b,BIO_C_SET_FILENAME, \\\n                BIO_CLOSE|BIO_FP_READ|BIO_FP_WRITE,name)\n\n/*\n * WARNING WARNING, this ups the reference count on the read bio of the SSL\n * structure.  This is because the ssl read BIO is now pointed to by the\n * next_bio field in the bio.  So when you free the BIO, make sure you are\n * doing a BIO_free_all() to catch the underlying BIO.\n */\n# define BIO_set_ssl(b,ssl,c)    BIO_ctrl(b,BIO_C_SET_SSL,c,(char *)(ssl))\n# define BIO_get_ssl(b,sslp)     BIO_ctrl(b,BIO_C_GET_SSL,0,(char *)(sslp))\n# define BIO_set_ssl_mode(b,client)      BIO_ctrl(b,BIO_C_SSL_MODE,client,NULL)\n# define BIO_set_ssl_renegotiate_bytes(b,num) \\\n        BIO_ctrl(b,BIO_C_SET_SSL_RENEGOTIATE_BYTES,num,NULL)\n# define BIO_get_num_renegotiates(b) \\\n        BIO_ctrl(b,BIO_C_GET_SSL_NUM_RENEGOTIATES,0,NULL)\n# define BIO_set_ssl_renegotiate_timeout(b,seconds) \\\n        BIO_ctrl(b,BIO_C_SET_SSL_RENEGOTIATE_TIMEOUT,seconds,NULL)\n\n/* defined in evp.h */\n/* #define BIO_set_md(b,md)     BIO_ctrl(b,BIO_C_SET_MD,1,(char *)(md)) */\n\n# define BIO_get_mem_data(b,pp)  BIO_ctrl(b,BIO_CTRL_INFO,0,(char *)(pp))\n# define BIO_set_mem_buf(b,bm,c) BIO_ctrl(b,BIO_C_SET_BUF_MEM,c,(char *)(bm))\n# define BIO_get_mem_ptr(b,pp)   BIO_ctrl(b,BIO_C_GET_BUF_MEM_PTR,0, \\\n                                          (char *)(pp))\n# define BIO_set_mem_eof_return(b,v) \\\n                                BIO_ctrl(b,BIO_C_SET_BUF_MEM_EOF_RETURN,v,NULL)\n\n/* For the BIO_f_buffer() type */\n# define BIO_get_buffer_num_lines(b)     BIO_ctrl(b,BIO_C_GET_BUFF_NUM_LINES,0,NULL)\n# define BIO_set_buffer_size(b,size)     BIO_ctrl(b,BIO_C_SET_BUFF_SIZE,size,NULL)\n# define BIO_set_read_buffer_size(b,size) BIO_int_ctrl(b,BIO_C_SET_BUFF_SIZE,size,0)\n# define BIO_set_write_buffer_size(b,size) BIO_int_ctrl(b,BIO_C_SET_BUFF_SIZE,size,1)\n# define BIO_set_buffer_read_data(b,buf,num) BIO_ctrl(b,BIO_C_SET_BUFF_READ_DATA,num,buf)\n\n/* Don't use the next one unless you know what you are doing :-) */\n# define BIO_dup_state(b,ret)    BIO_ctrl(b,BIO_CTRL_DUP,0,(char *)(ret))\n\n# define BIO_reset(b)            (int)BIO_ctrl(b,BIO_CTRL_RESET,0,NULL)\n# define BIO_eof(b)              (int)BIO_ctrl(b,BIO_CTRL_EOF,0,NULL)\n# define BIO_set_close(b,c)      (int)BIO_ctrl(b,BIO_CTRL_SET_CLOSE,(c),NULL)\n# define BIO_get_close(b)        (int)BIO_ctrl(b,BIO_CTRL_GET_CLOSE,0,NULL)\n# define BIO_pending(b)          (int)BIO_ctrl(b,BIO_CTRL_PENDING,0,NULL)\n# define BIO_wpending(b)         (int)BIO_ctrl(b,BIO_CTRL_WPENDING,0,NULL)\n/* ...pending macros have inappropriate return type */\nsize_t BIO_ctrl_pending(BIO *b);\nsize_t BIO_ctrl_wpending(BIO *b);\n# define BIO_flush(b)            (int)BIO_ctrl(b,BIO_CTRL_FLUSH,0,NULL)\n# define BIO_get_info_callback(b,cbp) (int)BIO_ctrl(b,BIO_CTRL_GET_CALLBACK,0, \\\n                                                   cbp)\n# define BIO_set_info_callback(b,cb) (int)BIO_callback_ctrl(b,BIO_CTRL_SET_CALLBACK,cb)\n\n/* For the BIO_f_buffer() type */\n# define BIO_buffer_get_num_lines(b) BIO_ctrl(b,BIO_CTRL_GET,0,NULL)\n# define BIO_buffer_peek(b,s,l) BIO_ctrl(b,BIO_CTRL_PEEK,(l),(s))\n\n/* For BIO_s_bio() */\n# define BIO_set_write_buf_size(b,size) (int)BIO_ctrl(b,BIO_C_SET_WRITE_BUF_SIZE,size,NULL)\n# define BIO_get_write_buf_size(b,size) (size_t)BIO_ctrl(b,BIO_C_GET_WRITE_BUF_SIZE,size,NULL)\n# define BIO_make_bio_pair(b1,b2)   (int)BIO_ctrl(b1,BIO_C_MAKE_BIO_PAIR,0,b2)\n# define BIO_destroy_bio_pair(b)    (int)BIO_ctrl(b,BIO_C_DESTROY_BIO_PAIR,0,NULL)\n# define BIO_shutdown_wr(b) (int)BIO_ctrl(b, BIO_C_SHUTDOWN_WR, 0, NULL)\n/* macros with inappropriate type -- but ...pending macros use int too: */\n# define BIO_get_write_guarantee(b) (int)BIO_ctrl(b,BIO_C_GET_WRITE_GUARANTEE,0,NULL)\n# define BIO_get_read_request(b)    (int)BIO_ctrl(b,BIO_C_GET_READ_REQUEST,0,NULL)\nsize_t BIO_ctrl_get_write_guarantee(BIO *b);\nsize_t BIO_ctrl_get_read_request(BIO *b);\nint BIO_ctrl_reset_read_request(BIO *b);\n\n/* ctrl macros for dgram */\n# define BIO_ctrl_dgram_connect(b,peer)  \\\n                     (int)BIO_ctrl(b,BIO_CTRL_DGRAM_CONNECT,0, (char *)(peer))\n# define BIO_ctrl_set_connected(b,peer) \\\n         (int)BIO_ctrl(b, BIO_CTRL_DGRAM_SET_CONNECTED, 0, (char *)(peer))\n# define BIO_dgram_recv_timedout(b) \\\n         (int)BIO_ctrl(b, BIO_CTRL_DGRAM_GET_RECV_TIMER_EXP, 0, NULL)\n# define BIO_dgram_send_timedout(b) \\\n         (int)BIO_ctrl(b, BIO_CTRL_DGRAM_GET_SEND_TIMER_EXP, 0, NULL)\n# define BIO_dgram_get_peer(b,peer) \\\n         (int)BIO_ctrl(b, BIO_CTRL_DGRAM_GET_PEER, 0, (char *)(peer))\n# define BIO_dgram_set_peer(b,peer) \\\n         (int)BIO_ctrl(b, BIO_CTRL_DGRAM_SET_PEER, 0, (char *)(peer))\n# define BIO_dgram_get_mtu_overhead(b) \\\n         (unsigned int)BIO_ctrl((b), BIO_CTRL_DGRAM_GET_MTU_OVERHEAD, 0, NULL)\n\n#define BIO_get_ex_new_index(l, p, newf, dupf, freef) \\\n    CRYPTO_get_ex_new_index(CRYPTO_EX_INDEX_BIO, l, p, newf, dupf, freef)\nint BIO_set_ex_data(BIO *bio, int idx, void *data);\nvoid *BIO_get_ex_data(BIO *bio, int idx);\nuint64_t BIO_number_read(BIO *bio);\nuint64_t BIO_number_written(BIO *bio);\n\n/* For BIO_f_asn1() */\nint BIO_asn1_set_prefix(BIO *b, asn1_ps_func *prefix,\n                        asn1_ps_func *prefix_free);\nint BIO_asn1_get_prefix(BIO *b, asn1_ps_func **pprefix,\n                        asn1_ps_func **pprefix_free);\nint BIO_asn1_set_suffix(BIO *b, asn1_ps_func *suffix,\n                        asn1_ps_func *suffix_free);\nint BIO_asn1_get_suffix(BIO *b, asn1_ps_func **psuffix,\n                        asn1_ps_func **psuffix_free);\n\nconst BIO_METHOD *BIO_s_file(void);\nBIO *BIO_new_file(const char *filename, const char *mode);\n# ifndef OPENSSL_NO_STDIO\nBIO *BIO_new_fp(FILE *stream, int close_flag);\n# endif\nBIO *BIO_new(const BIO_METHOD *type);\nint BIO_free(BIO *a);\nvoid BIO_set_data(BIO *a, void *ptr);\nvoid *BIO_get_data(BIO *a);\nvoid BIO_set_init(BIO *a, int init);\nint BIO_get_init(BIO *a);\nvoid BIO_set_shutdown(BIO *a, int shut);\nint BIO_get_shutdown(BIO *a);\nvoid BIO_vfree(BIO *a);\nint BIO_up_ref(BIO *a);\nint BIO_read(BIO *b, void *data, int dlen);\nint BIO_read_ex(BIO *b, void *data, size_t dlen, size_t *readbytes);\nint BIO_gets(BIO *bp, char *buf, int size);\nint BIO_write(BIO *b, const void *data, int dlen);\nint BIO_write_ex(BIO *b, const void *data, size_t dlen, size_t *written);\nint BIO_puts(BIO *bp, const char *buf);\nint BIO_indent(BIO *b, int indent, int max);\nlong BIO_ctrl(BIO *bp, int cmd, long larg, void *parg);\nlong BIO_callback_ctrl(BIO *b, int cmd, BIO_info_cb *fp);\nvoid *BIO_ptr_ctrl(BIO *bp, int cmd, long larg);\nlong BIO_int_ctrl(BIO *bp, int cmd, long larg, int iarg);\nBIO *BIO_push(BIO *b, BIO *append);\nBIO *BIO_pop(BIO *b);\nvoid BIO_free_all(BIO *a);\nBIO *BIO_find_type(BIO *b, int bio_type);\nBIO *BIO_next(BIO *b);\nvoid BIO_set_next(BIO *b, BIO *next);\nBIO *BIO_get_retry_BIO(BIO *bio, int *reason);\nint BIO_get_retry_reason(BIO *bio);\nvoid BIO_set_retry_reason(BIO *bio, int reason);\nBIO *BIO_dup_chain(BIO *in);\n\nint BIO_nread0(BIO *bio, char **buf);\nint BIO_nread(BIO *bio, char **buf, int num);\nint BIO_nwrite0(BIO *bio, char **buf);\nint BIO_nwrite(BIO *bio, char **buf, int num);\n\nlong BIO_debug_callback(BIO *bio, int cmd, const char *argp, int argi,\n                        long argl, long ret);\n\nconst BIO_METHOD *BIO_s_mem(void);\nconst BIO_METHOD *BIO_s_secmem(void);\nBIO *BIO_new_mem_buf(const void *buf, int len);\n# ifndef OPENSSL_NO_SOCK\nconst BIO_METHOD *BIO_s_socket(void);\nconst BIO_METHOD *BIO_s_connect(void);\nconst BIO_METHOD *BIO_s_accept(void);\n# endif\nconst BIO_METHOD *BIO_s_fd(void);\nconst BIO_METHOD *BIO_s_log(void);\nconst BIO_METHOD *BIO_s_bio(void);\nconst BIO_METHOD *BIO_s_null(void);\nconst BIO_METHOD *BIO_f_null(void);\nconst BIO_METHOD *BIO_f_buffer(void);\nconst BIO_METHOD *BIO_f_linebuffer(void);\nconst BIO_METHOD *BIO_f_nbio_test(void);\n# ifndef OPENSSL_NO_DGRAM\nconst BIO_METHOD *BIO_s_datagram(void);\nint BIO_dgram_non_fatal_error(int error);\nBIO *BIO_new_dgram(int fd, int close_flag);\n#  ifndef OPENSSL_NO_SCTP\nconst BIO_METHOD *BIO_s_datagram_sctp(void);\nBIO *BIO_new_dgram_sctp(int fd, int close_flag);\nint BIO_dgram_is_sctp(BIO *bio);\nint BIO_dgram_sctp_notification_cb(BIO *b,\n                                   void (*handle_notifications) (BIO *bio,\n                                                                 void *context,\n                                                                 void *buf),\n                                   void *context);\nint BIO_dgram_sctp_wait_for_dry(BIO *b);\nint BIO_dgram_sctp_msg_waiting(BIO *b);\n#  endif\n# endif\n\n# ifndef OPENSSL_NO_SOCK\nint BIO_sock_should_retry(int i);\nint BIO_sock_non_fatal_error(int error);\n# endif\n\nint BIO_fd_should_retry(int i);\nint BIO_fd_non_fatal_error(int error);\nint BIO_dump_cb(int (*cb) (const void *data, size_t len, void *u),\n                void *u, const char *s, int len);\nint BIO_dump_indent_cb(int (*cb) (const void *data, size_t len, void *u),\n                       void *u, const char *s, int len, int indent);\nint BIO_dump(BIO *b, const char *bytes, int len);\nint BIO_dump_indent(BIO *b, const char *bytes, int len, int indent);\n# ifndef OPENSSL_NO_STDIO\nint BIO_dump_fp(FILE *fp, const char *s, int len);\nint BIO_dump_indent_fp(FILE *fp, const char *s, int len, int indent);\n# endif\nint BIO_hex_string(BIO *out, int indent, int width, unsigned char *data,\n                   int datalen);\n\n# ifndef OPENSSL_NO_SOCK\nBIO_ADDR *BIO_ADDR_new(void);\nint BIO_ADDR_rawmake(BIO_ADDR *ap, int family,\n                     const void *where, size_t wherelen, unsigned short port);\nvoid BIO_ADDR_free(BIO_ADDR *);\nvoid BIO_ADDR_clear(BIO_ADDR *ap);\nint BIO_ADDR_family(const BIO_ADDR *ap);\nint BIO_ADDR_rawaddress(const BIO_ADDR *ap, void *p, size_t *l);\nunsigned short BIO_ADDR_rawport(const BIO_ADDR *ap);\nchar *BIO_ADDR_hostname_string(const BIO_ADDR *ap, int numeric);\nchar *BIO_ADDR_service_string(const BIO_ADDR *ap, int numeric);\nchar *BIO_ADDR_path_string(const BIO_ADDR *ap);\n\nconst BIO_ADDRINFO *BIO_ADDRINFO_next(const BIO_ADDRINFO *bai);\nint BIO_ADDRINFO_family(const BIO_ADDRINFO *bai);\nint BIO_ADDRINFO_socktype(const BIO_ADDRINFO *bai);\nint BIO_ADDRINFO_protocol(const BIO_ADDRINFO *bai);\nconst BIO_ADDR *BIO_ADDRINFO_address(const BIO_ADDRINFO *bai);\nvoid BIO_ADDRINFO_free(BIO_ADDRINFO *bai);\n\nenum BIO_hostserv_priorities {\n    BIO_PARSE_PRIO_HOST, BIO_PARSE_PRIO_SERV\n};\nint BIO_parse_hostserv(const char *hostserv, char **host, char **service,\n                       enum BIO_hostserv_priorities hostserv_prio);\nenum BIO_lookup_type {\n    BIO_LOOKUP_CLIENT, BIO_LOOKUP_SERVER\n};\nint BIO_lookup(const char *host, const char *service,\n               enum BIO_lookup_type lookup_type,\n               int family, int socktype, BIO_ADDRINFO **res);\nint BIO_lookup_ex(const char *host, const char *service,\n                  int lookup_type, int family, int socktype, int protocol,\n                  BIO_ADDRINFO **res);\nint BIO_sock_error(int sock);\nint BIO_socket_ioctl(int fd, long type, void *arg);\nint BIO_socket_nbio(int fd, int mode);\nint BIO_sock_init(void);\n# if OPENSSL_API_COMPAT < 0x10100000L\n#  define BIO_sock_cleanup() while(0) continue\n# endif\nint BIO_set_tcp_ndelay(int sock, int turn_on);\n\nDEPRECATEDIN_1_1_0(struct hostent *BIO_gethostbyname(const char *name))\nDEPRECATEDIN_1_1_0(int BIO_get_port(const char *str, unsigned short *port_ptr))\nDEPRECATEDIN_1_1_0(int BIO_get_host_ip(const char *str, unsigned char *ip))\nDEPRECATEDIN_1_1_0(int BIO_get_accept_socket(char *host_port, int mode))\nDEPRECATEDIN_1_1_0(int BIO_accept(int sock, char **ip_port))\n\nunion BIO_sock_info_u {\n    BIO_ADDR *addr;\n};\nenum BIO_sock_info_type {\n    BIO_SOCK_INFO_ADDRESS\n};\nint BIO_sock_info(int sock,\n                  enum BIO_sock_info_type type, union BIO_sock_info_u *info);\n\n#  define BIO_SOCK_REUSEADDR    0x01\n#  define BIO_SOCK_V6_ONLY      0x02\n#  define BIO_SOCK_KEEPALIVE    0x04\n#  define BIO_SOCK_NONBLOCK     0x08\n#  define BIO_SOCK_NODELAY      0x10\n\nint BIO_socket(int domain, int socktype, int protocol, int options);\nint BIO_connect(int sock, const BIO_ADDR *addr, int options);\nint BIO_bind(int sock, const BIO_ADDR *addr, int options);\nint BIO_listen(int sock, const BIO_ADDR *addr, int options);\nint BIO_accept_ex(int accept_sock, BIO_ADDR *addr, int options);\nint BIO_closesocket(int sock);\n\nBIO *BIO_new_socket(int sock, int close_flag);\nBIO *BIO_new_connect(const char *host_port);\nBIO *BIO_new_accept(const char *host_port);\n# endif /* OPENSSL_NO_SOCK*/\n\nBIO *BIO_new_fd(int fd, int close_flag);\n\nint BIO_new_bio_pair(BIO **bio1, size_t writebuf1,\n                     BIO **bio2, size_t writebuf2);\n/*\n * If successful, returns 1 and in *bio1, *bio2 two BIO pair endpoints.\n * Otherwise returns 0 and sets *bio1 and *bio2 to NULL. Size 0 uses default\n * value.\n */\n\nvoid BIO_copy_next_retry(BIO *b);\n\n/*\n * long BIO_ghbn_ctrl(int cmd,int iarg,char *parg);\n */\n\n# define ossl_bio__attr__(x)\n# if defined(__GNUC__) && defined(__STDC_VERSION__) \\\n    && !defined(__APPLE__)\n    /*\n     * Because we support the 'z' modifier, which made its appearance in C99,\n     * we can't use __attribute__ with pre C99 dialects.\n     */\n#  if __STDC_VERSION__ >= 199901L\n#   undef ossl_bio__attr__\n#   define ossl_bio__attr__ __attribute__\n#   if __GNUC__*10 + __GNUC_MINOR__ >= 44\n#    define ossl_bio__printf__ __gnu_printf__\n#   else\n#    define ossl_bio__printf__ __printf__\n#   endif\n#  endif\n# endif\nint BIO_printf(BIO *bio, const char *format, ...)\nossl_bio__attr__((__format__(ossl_bio__printf__, 2, 3)));\nint BIO_vprintf(BIO *bio, const char *format, va_list args)\nossl_bio__attr__((__format__(ossl_bio__printf__, 2, 0)));\nint BIO_snprintf(char *buf, size_t n, const char *format, ...)\nossl_bio__attr__((__format__(ossl_bio__printf__, 3, 4)));\nint BIO_vsnprintf(char *buf, size_t n, const char *format, va_list args)\nossl_bio__attr__((__format__(ossl_bio__printf__, 3, 0)));\n# undef ossl_bio__attr__\n# undef ossl_bio__printf__\n\n\nBIO_METHOD *BIO_meth_new(int type, const char *name);\nvoid BIO_meth_free(BIO_METHOD *biom);\nint (*BIO_meth_get_write(const BIO_METHOD *biom)) (BIO *, const char *, int);\nint (*BIO_meth_get_write_ex(const BIO_METHOD *biom)) (BIO *, const char *, size_t,\n                                                size_t *);\nint BIO_meth_set_write(BIO_METHOD *biom,\n                       int (*write) (BIO *, const char *, int));\nint BIO_meth_set_write_ex(BIO_METHOD *biom,\n                       int (*bwrite) (BIO *, const char *, size_t, size_t *));\nint (*BIO_meth_get_read(const BIO_METHOD *biom)) (BIO *, char *, int);\nint (*BIO_meth_get_read_ex(const BIO_METHOD *biom)) (BIO *, char *, size_t, size_t *);\nint BIO_meth_set_read(BIO_METHOD *biom,\n                      int (*read) (BIO *, char *, int));\nint BIO_meth_set_read_ex(BIO_METHOD *biom,\n                         int (*bread) (BIO *, char *, size_t, size_t *));\nint (*BIO_meth_get_puts(const BIO_METHOD *biom)) (BIO *, const char *);\nint BIO_meth_set_puts(BIO_METHOD *biom,\n                      int (*puts) (BIO *, const char *));\nint (*BIO_meth_get_gets(const BIO_METHOD *biom)) (BIO *, char *, int);\nint BIO_meth_set_gets(BIO_METHOD *biom,\n                      int (*gets) (BIO *, char *, int));\nlong (*BIO_meth_get_ctrl(const BIO_METHOD *biom)) (BIO *, int, long, void *);\nint BIO_meth_set_ctrl(BIO_METHOD *biom,\n                      long (*ctrl) (BIO *, int, long, void *));\nint (*BIO_meth_get_create(const BIO_METHOD *bion)) (BIO *);\nint BIO_meth_set_create(BIO_METHOD *biom, int (*create) (BIO *));\nint (*BIO_meth_get_destroy(const BIO_METHOD *biom)) (BIO *);\nint BIO_meth_set_destroy(BIO_METHOD *biom, int (*destroy) (BIO *));\nlong (*BIO_meth_get_callback_ctrl(const BIO_METHOD *biom))\n                                 (BIO *, int, BIO_info_cb *);\nint BIO_meth_set_callback_ctrl(BIO_METHOD *biom,\n                               long (*callback_ctrl) (BIO *, int,\n                                                      BIO_info_cb *));\n\n# ifdef  __cplusplus\n}\n# endif\n#endif\n"}, "15": {"id": 15, "path": "/usr/include/openssl/asn1.h", "content": "/*\n * Copyright 1995-2017 The OpenSSL Project Authors. All Rights Reserved.\n *\n * Licensed under the OpenSSL license (the \"License\").  You may not use\n * this file except in compliance with the License.  You can obtain a copy\n * in the file LICENSE in the source distribution or at\n * https://www.openssl.org/source/license.html\n */\n\n#ifndef HEADER_ASN1_H\n# define HEADER_ASN1_H\n\n# include <time.h>\n# include <openssl/e_os2.h>\n# include <openssl/opensslconf.h>\n# include <openssl/bio.h>\n# include <openssl/safestack.h>\n# include <openssl/asn1err.h>\n# include <openssl/symhacks.h>\n\n# include <openssl/ossl_typ.h>\n# if OPENSSL_API_COMPAT < 0x10100000L\n#  include <openssl/bn.h>\n# endif\n\n# ifdef OPENSSL_BUILD_SHLIBCRYPTO\n#  undef OPENSSL_EXTERN\n#  define OPENSSL_EXTERN OPENSSL_EXPORT\n# endif\n\n#ifdef  __cplusplus\nextern \"C\" {\n#endif\n\n# define V_ASN1_UNIVERSAL                0x00\n# define V_ASN1_APPLICATION              0x40\n# define V_ASN1_CONTEXT_SPECIFIC         0x80\n# define V_ASN1_PRIVATE                  0xc0\n\n# define V_ASN1_CONSTRUCTED              0x20\n# define V_ASN1_PRIMITIVE_TAG            0x1f\n# define V_ASN1_PRIMATIVE_TAG /*compat*/ V_ASN1_PRIMITIVE_TAG\n\n# define V_ASN1_APP_CHOOSE               -2/* let the recipient choose */\n# define V_ASN1_OTHER                    -3/* used in ASN1_TYPE */\n# define V_ASN1_ANY                      -4/* used in ASN1 template code */\n\n# define V_ASN1_UNDEF                    -1\n/* ASN.1 tag values */\n# define V_ASN1_EOC                      0\n# define V_ASN1_BOOLEAN                  1 /**/\n# define V_ASN1_INTEGER                  2\n# define V_ASN1_BIT_STRING               3\n# define V_ASN1_OCTET_STRING             4\n# define V_ASN1_NULL                     5\n# define V_ASN1_OBJECT                   6\n# define V_ASN1_OBJECT_DESCRIPTOR        7\n# define V_ASN1_EXTERNAL                 8\n# define V_ASN1_REAL                     9\n# define V_ASN1_ENUMERATED               10\n# define V_ASN1_UTF8STRING               12\n# define V_ASN1_SEQUENCE                 16\n# define V_ASN1_SET                      17\n# define V_ASN1_NUMERICSTRING            18 /**/\n# define V_ASN1_PRINTABLESTRING          19\n# define V_ASN1_T61STRING                20\n# define V_ASN1_TELETEXSTRING            20/* alias */\n# define V_ASN1_VIDEOTEXSTRING           21 /**/\n# define V_ASN1_IA5STRING                22\n# define V_ASN1_UTCTIME                  23\n# define V_ASN1_GENERALIZEDTIME          24 /**/\n# define V_ASN1_GRAPHICSTRING            25 /**/\n# define V_ASN1_ISO64STRING              26 /**/\n# define V_ASN1_VISIBLESTRING            26/* alias */\n# define V_ASN1_GENERALSTRING            27 /**/\n# define V_ASN1_UNIVERSALSTRING          28 /**/\n# define V_ASN1_BMPSTRING                30\n\n/*\n * NB the constants below are used internally by ASN1_INTEGER\n * and ASN1_ENUMERATED to indicate the sign. They are *not* on\n * the wire tag values.\n */\n\n# define V_ASN1_NEG                      0x100\n# define V_ASN1_NEG_INTEGER              (2 | V_ASN1_NEG)\n# define V_ASN1_NEG_ENUMERATED           (10 | V_ASN1_NEG)\n\n/* For use with d2i_ASN1_type_bytes() */\n# define B_ASN1_NUMERICSTRING    0x0001\n# define B_ASN1_PRINTABLESTRING  0x0002\n# define B_ASN1_T61STRING        0x0004\n# define B_ASN1_TELETEXSTRING    0x0004\n# define B_ASN1_VIDEOTEXSTRING   0x0008\n# define B_ASN1_IA5STRING        0x0010\n# define B_ASN1_GRAPHICSTRING    0x0020\n# define B_ASN1_ISO64STRING      0x0040\n# define B_ASN1_VISIBLESTRING    0x0040\n# define B_ASN1_GENERALSTRING    0x0080\n# define B_ASN1_UNIVERSALSTRING  0x0100\n# define B_ASN1_OCTET_STRING     0x0200\n# define B_ASN1_BIT_STRING       0x0400\n# define B_ASN1_BMPSTRING        0x0800\n# define B_ASN1_UNKNOWN          0x1000\n# define B_ASN1_UTF8STRING       0x2000\n# define B_ASN1_UTCTIME          0x4000\n# define B_ASN1_GENERALIZEDTIME  0x8000\n# define B_ASN1_SEQUENCE         0x10000\n/* For use with ASN1_mbstring_copy() */\n# define MBSTRING_FLAG           0x1000\n# define MBSTRING_UTF8           (MBSTRING_FLAG)\n# define MBSTRING_ASC            (MBSTRING_FLAG|1)\n# define MBSTRING_BMP            (MBSTRING_FLAG|2)\n# define MBSTRING_UNIV           (MBSTRING_FLAG|4)\n# define SMIME_OLDMIME           0x400\n# define SMIME_CRLFEOL           0x800\n# define SMIME_STREAM            0x1000\n    struct X509_algor_st;\nDEFINE_STACK_OF(X509_ALGOR)\n\n# define ASN1_STRING_FLAG_BITS_LEFT 0x08/* Set if 0x07 has bits left value */\n/*\n * This indicates that the ASN1_STRING is not a real value but just a place\n * holder for the location where indefinite length constructed data should be\n * inserted in the memory buffer\n */\n# define ASN1_STRING_FLAG_NDEF 0x010\n\n/*\n * This flag is used by the CMS code to indicate that a string is not\n * complete and is a place holder for content when it had all been accessed.\n * The flag will be reset when content has been written to it.\n */\n\n# define ASN1_STRING_FLAG_CONT 0x020\n/*\n * This flag is used by ASN1 code to indicate an ASN1_STRING is an MSTRING\n * type.\n */\n# define ASN1_STRING_FLAG_MSTRING 0x040\n/* String is embedded and only content should be freed */\n# define ASN1_STRING_FLAG_EMBED 0x080\n/* String should be parsed in RFC 5280's time format */\n# define ASN1_STRING_FLAG_X509_TIME 0x100\n/* This is the base type that holds just about everything :-) */\nstruct asn1_string_st {\n    int length;\n    int type;\n    unsigned char *data;\n    /*\n     * The value of the following field depends on the type being held.  It\n     * is mostly being used for BIT_STRING so if the input data has a\n     * non-zero 'unused bits' value, it will be handled correctly\n     */\n    long flags;\n};\n\n/*\n * ASN1_ENCODING structure: this is used to save the received encoding of an\n * ASN1 type. This is useful to get round problems with invalid encodings\n * which can break signatures.\n */\n\ntypedef struct ASN1_ENCODING_st {\n    unsigned char *enc;         /* DER encoding */\n    long len;                   /* Length of encoding */\n    int modified;               /* set to 1 if 'enc' is invalid */\n} ASN1_ENCODING;\n\n/* Used with ASN1 LONG type: if a long is set to this it is omitted */\n# define ASN1_LONG_UNDEF 0x7fffffffL\n\n# define STABLE_FLAGS_MALLOC     0x01\n/*\n * A zero passed to ASN1_STRING_TABLE_new_add for the flags is interpreted\n * as \"don't change\" and STABLE_FLAGS_MALLOC is always set. By setting\n * STABLE_FLAGS_MALLOC only we can clear the existing value. Use the alias\n * STABLE_FLAGS_CLEAR to reflect this.\n */\n# define STABLE_FLAGS_CLEAR      STABLE_FLAGS_MALLOC\n# define STABLE_NO_MASK          0x02\n# define DIRSTRING_TYPE  \\\n (B_ASN1_PRINTABLESTRING|B_ASN1_T61STRING|B_ASN1_BMPSTRING|B_ASN1_UTF8STRING)\n# define PKCS9STRING_TYPE (DIRSTRING_TYPE|B_ASN1_IA5STRING)\n\ntypedef struct asn1_string_table_st {\n    int nid;\n    long minsize;\n    long maxsize;\n    unsigned long mask;\n    unsigned long flags;\n} ASN1_STRING_TABLE;\n\nDEFINE_STACK_OF(ASN1_STRING_TABLE)\n\n/* size limits: this stuff is taken straight from RFC2459 */\n\n# define ub_name                         32768\n# define ub_common_name                  64\n# define ub_locality_name                128\n# define ub_state_name                   128\n# define ub_organization_name            64\n# define ub_organization_unit_name       64\n# define ub_title                        64\n# define ub_email_address                128\n\n/*\n * Declarations for template structures: for full definitions see asn1t.h\n */\ntypedef struct ASN1_TEMPLATE_st ASN1_TEMPLATE;\ntypedef struct ASN1_TLC_st ASN1_TLC;\n/* This is just an opaque pointer */\ntypedef struct ASN1_VALUE_st ASN1_VALUE;\n\n/* Declare ASN1 functions: the implement macro in in asn1t.h */\n\n# define DECLARE_ASN1_FUNCTIONS(type) DECLARE_ASN1_FUNCTIONS_name(type, type)\n\n# define DECLARE_ASN1_ALLOC_FUNCTIONS(type) \\\n        DECLARE_ASN1_ALLOC_FUNCTIONS_name(type, type)\n\n# define DECLARE_ASN1_FUNCTIONS_name(type, name) \\\n        DECLARE_ASN1_ALLOC_FUNCTIONS_name(type, name) \\\n        DECLARE_ASN1_ENCODE_FUNCTIONS(type, name, name)\n\n# define DECLARE_ASN1_FUNCTIONS_fname(type, itname, name) \\\n        DECLARE_ASN1_ALLOC_FUNCTIONS_name(type, name) \\\n        DECLARE_ASN1_ENCODE_FUNCTIONS(type, itname, name)\n\n# define DECLARE_ASN1_ENCODE_FUNCTIONS(type, itname, name) \\\n        type *d2i_##name(type **a, const unsigned char **in, long len); \\\n        int i2d_##name(type *a, unsigned char **out); \\\n        DECLARE_ASN1_ITEM(itname)\n\n# define DECLARE_ASN1_ENCODE_FUNCTIONS_const(type, name) \\\n        type *d2i_##name(type **a, const unsigned char **in, long len); \\\n        int i2d_##name(const type *a, unsigned char **out); \\\n        DECLARE_ASN1_ITEM(name)\n\n# define DECLARE_ASN1_NDEF_FUNCTION(name) \\\n        int i2d_##name##_NDEF(name *a, unsigned char **out);\n\n# define DECLARE_ASN1_FUNCTIONS_const(name) \\\n        DECLARE_ASN1_ALLOC_FUNCTIONS(name) \\\n        DECLARE_ASN1_ENCODE_FUNCTIONS_const(name, name)\n\n# define DECLARE_ASN1_ALLOC_FUNCTIONS_name(type, name) \\\n        type *name##_new(void); \\\n        void name##_free(type *a);\n\n# define DECLARE_ASN1_PRINT_FUNCTION(stname) \\\n        DECLARE_ASN1_PRINT_FUNCTION_fname(stname, stname)\n\n# define DECLARE_ASN1_PRINT_FUNCTION_fname(stname, fname) \\\n        int fname##_print_ctx(BIO *out, stname *x, int indent, \\\n                                         const ASN1_PCTX *pctx);\n\n# define D2I_OF(type) type *(*)(type **,const unsigned char **,long)\n# define I2D_OF(type) int (*)(type *,unsigned char **)\n# define I2D_OF_const(type) int (*)(const type *,unsigned char **)\n\n# define CHECKED_D2I_OF(type, d2i) \\\n    ((d2i_of_void*) (1 ? d2i : ((D2I_OF(type))0)))\n# define CHECKED_I2D_OF(type, i2d) \\\n    ((i2d_of_void*) (1 ? i2d : ((I2D_OF(type))0)))\n# define CHECKED_NEW_OF(type, xnew) \\\n    ((void *(*)(void)) (1 ? xnew : ((type *(*)(void))0)))\n# define CHECKED_PTR_OF(type, p) \\\n    ((void*) (1 ? p : (type*)0))\n# define CHECKED_PPTR_OF(type, p) \\\n    ((void**) (1 ? p : (type**)0))\n\n# define TYPEDEF_D2I_OF(type) typedef type *d2i_of_##type(type **,const unsigned char **,long)\n# define TYPEDEF_I2D_OF(type) typedef int i2d_of_##type(type *,unsigned char **)\n# define TYPEDEF_D2I2D_OF(type) TYPEDEF_D2I_OF(type); TYPEDEF_I2D_OF(type)\n\nTYPEDEF_D2I2D_OF(void);\n\n/*-\n * The following macros and typedefs allow an ASN1_ITEM\n * to be embedded in a structure and referenced. Since\n * the ASN1_ITEM pointers need to be globally accessible\n * (possibly from shared libraries) they may exist in\n * different forms. On platforms that support it the\n * ASN1_ITEM structure itself will be globally exported.\n * Other platforms will export a function that returns\n * an ASN1_ITEM pointer.\n *\n * To handle both cases transparently the macros below\n * should be used instead of hard coding an ASN1_ITEM\n * pointer in a structure.\n *\n * The structure will look like this:\n *\n * typedef struct SOMETHING_st {\n *      ...\n *      ASN1_ITEM_EXP *iptr;\n *      ...\n * } SOMETHING;\n *\n * It would be initialised as e.g.:\n *\n * SOMETHING somevar = {...,ASN1_ITEM_ref(X509),...};\n *\n * and the actual pointer extracted with:\n *\n * const ASN1_ITEM *it = ASN1_ITEM_ptr(somevar.iptr);\n *\n * Finally an ASN1_ITEM pointer can be extracted from an\n * appropriate reference with: ASN1_ITEM_rptr(X509). This\n * would be used when a function takes an ASN1_ITEM * argument.\n *\n */\n\n# ifndef OPENSSL_EXPORT_VAR_AS_FUNCTION\n\n/* ASN1_ITEM pointer exported type */\ntypedef const ASN1_ITEM ASN1_ITEM_EXP;\n\n/* Macro to obtain ASN1_ITEM pointer from exported type */\n#  define ASN1_ITEM_ptr(iptr) (iptr)\n\n/* Macro to include ASN1_ITEM pointer from base type */\n#  define ASN1_ITEM_ref(iptr) (&(iptr##_it))\n\n#  define ASN1_ITEM_rptr(ref) (&(ref##_it))\n\n#  define DECLARE_ASN1_ITEM(name) \\\n        OPENSSL_EXTERN const ASN1_ITEM name##_it;\n\n# else\n\n/*\n * Platforms that can't easily handle shared global variables are declared as\n * functions returning ASN1_ITEM pointers.\n */\n\n/* ASN1_ITEM pointer exported type */\ntypedef const ASN1_ITEM *ASN1_ITEM_EXP (void);\n\n/* Macro to obtain ASN1_ITEM pointer from exported type */\n#  define ASN1_ITEM_ptr(iptr) (iptr())\n\n/* Macro to include ASN1_ITEM pointer from base type */\n#  define ASN1_ITEM_ref(iptr) (iptr##_it)\n\n#  define ASN1_ITEM_rptr(ref) (ref##_it())\n\n#  define DECLARE_ASN1_ITEM(name) \\\n        const ASN1_ITEM * name##_it(void);\n\n# endif\n\n/* Parameters used by ASN1_STRING_print_ex() */\n\n/*\n * These determine which characters to escape: RFC2253 special characters,\n * control characters and MSB set characters\n */\n\n# define ASN1_STRFLGS_ESC_2253           1\n# define ASN1_STRFLGS_ESC_CTRL           2\n# define ASN1_STRFLGS_ESC_MSB            4\n\n/*\n * This flag determines how we do escaping: normally RC2253 backslash only,\n * set this to use backslash and quote.\n */\n\n# define ASN1_STRFLGS_ESC_QUOTE          8\n\n/* These three flags are internal use only. */\n\n/* Character is a valid PrintableString character */\n# define CHARTYPE_PRINTABLESTRING        0x10\n/* Character needs escaping if it is the first character */\n# define CHARTYPE_FIRST_ESC_2253         0x20\n/* Character needs escaping if it is the last character */\n# define CHARTYPE_LAST_ESC_2253          0x40\n\n/*\n * NB the internal flags are safely reused below by flags handled at the top\n * level.\n */\n\n/*\n * If this is set we convert all character strings to UTF8 first\n */\n\n# define ASN1_STRFLGS_UTF8_CONVERT       0x10\n\n/*\n * If this is set we don't attempt to interpret content: just assume all\n * strings are 1 byte per character. This will produce some pretty odd\n * looking output!\n */\n\n# define ASN1_STRFLGS_IGNORE_TYPE        0x20\n\n/* If this is set we include the string type in the output */\n# define ASN1_STRFLGS_SHOW_TYPE          0x40\n\n/*\n * This determines which strings to display and which to 'dump' (hex dump of\n * content octets or DER encoding). We can only dump non character strings or\n * everything. If we don't dump 'unknown' they are interpreted as character\n * strings with 1 octet per character and are subject to the usual escaping\n * options.\n */\n\n# define ASN1_STRFLGS_DUMP_ALL           0x80\n# define ASN1_STRFLGS_DUMP_UNKNOWN       0x100\n\n/*\n * These determine what 'dumping' does, we can dump the content octets or the\n * DER encoding: both use the RFC2253 #XXXXX notation.\n */\n\n# define ASN1_STRFLGS_DUMP_DER           0x200\n\n/*\n * This flag specifies that RC2254 escaping shall be performed.\n */\n#define ASN1_STRFLGS_ESC_2254           0x400\n\n/*\n * All the string flags consistent with RFC2253, escaping control characters\n * isn't essential in RFC2253 but it is advisable anyway.\n */\n\n# define ASN1_STRFLGS_RFC2253    (ASN1_STRFLGS_ESC_2253 | \\\n                                ASN1_STRFLGS_ESC_CTRL | \\\n                                ASN1_STRFLGS_ESC_MSB | \\\n                                ASN1_STRFLGS_UTF8_CONVERT | \\\n                                ASN1_STRFLGS_DUMP_UNKNOWN | \\\n                                ASN1_STRFLGS_DUMP_DER)\n\nDEFINE_STACK_OF(ASN1_INTEGER)\n\nDEFINE_STACK_OF(ASN1_GENERALSTRING)\n\nDEFINE_STACK_OF(ASN1_UTF8STRING)\n\ntypedef struct asn1_type_st {\n    int type;\n    union {\n        char *ptr;\n        ASN1_BOOLEAN boolean;\n        ASN1_STRING *asn1_string;\n        ASN1_OBJECT *object;\n        ASN1_INTEGER *integer;\n        ASN1_ENUMERATED *enumerated;\n        ASN1_BIT_STRING *bit_string;\n        ASN1_OCTET_STRING *octet_string;\n        ASN1_PRINTABLESTRING *printablestring;\n        ASN1_T61STRING *t61string;\n        ASN1_IA5STRING *ia5string;\n        ASN1_GENERALSTRING *generalstring;\n        ASN1_BMPSTRING *bmpstring;\n        ASN1_UNIVERSALSTRING *universalstring;\n        ASN1_UTCTIME *utctime;\n        ASN1_GENERALIZEDTIME *generalizedtime;\n        ASN1_VISIBLESTRING *visiblestring;\n        ASN1_UTF8STRING *utf8string;\n        /*\n         * set and sequence are left complete and still contain the set or\n         * sequence bytes\n         */\n        ASN1_STRING *set;\n        ASN1_STRING *sequence;\n        ASN1_VALUE *asn1_value;\n    } value;\n} ASN1_TYPE;\n\nDEFINE_STACK_OF(ASN1_TYPE)\n\ntypedef STACK_OF(ASN1_TYPE) ASN1_SEQUENCE_ANY;\n\nDECLARE_ASN1_ENCODE_FUNCTIONS_const(ASN1_SEQUENCE_ANY, ASN1_SEQUENCE_ANY)\nDECLARE_ASN1_ENCODE_FUNCTIONS_const(ASN1_SEQUENCE_ANY, ASN1_SET_ANY)\n\n/* This is used to contain a list of bit names */\ntypedef struct BIT_STRING_BITNAME_st {\n    int bitnum;\n    const char *lname;\n    const char *sname;\n} BIT_STRING_BITNAME;\n\n# define B_ASN1_TIME \\\n                        B_ASN1_UTCTIME | \\\n                        B_ASN1_GENERALIZEDTIME\n\n# define B_ASN1_PRINTABLE \\\n                        B_ASN1_NUMERICSTRING| \\\n                        B_ASN1_PRINTABLESTRING| \\\n                        B_ASN1_T61STRING| \\\n                        B_ASN1_IA5STRING| \\\n                        B_ASN1_BIT_STRING| \\\n                        B_ASN1_UNIVERSALSTRING|\\\n                        B_ASN1_BMPSTRING|\\\n                        B_ASN1_UTF8STRING|\\\n                        B_ASN1_SEQUENCE|\\\n                        B_ASN1_UNKNOWN\n\n# define B_ASN1_DIRECTORYSTRING \\\n                        B_ASN1_PRINTABLESTRING| \\\n                        B_ASN1_TELETEXSTRING|\\\n                        B_ASN1_BMPSTRING|\\\n                        B_ASN1_UNIVERSALSTRING|\\\n                        B_ASN1_UTF8STRING\n\n# define B_ASN1_DISPLAYTEXT \\\n                        B_ASN1_IA5STRING| \\\n                        B_ASN1_VISIBLESTRING| \\\n                        B_ASN1_BMPSTRING|\\\n                        B_ASN1_UTF8STRING\n\nDECLARE_ASN1_FUNCTIONS_fname(ASN1_TYPE, ASN1_ANY, ASN1_TYPE)\n\nint ASN1_TYPE_get(const ASN1_TYPE *a);\nvoid ASN1_TYPE_set(ASN1_TYPE *a, int type, void *value);\nint ASN1_TYPE_set1(ASN1_TYPE *a, int type, const void *value);\nint ASN1_TYPE_cmp(const ASN1_TYPE *a, const ASN1_TYPE *b);\n\nASN1_TYPE *ASN1_TYPE_pack_sequence(const ASN1_ITEM *it, void *s, ASN1_TYPE **t);\nvoid *ASN1_TYPE_unpack_sequence(const ASN1_ITEM *it, const ASN1_TYPE *t);\n\nASN1_OBJECT *ASN1_OBJECT_new(void);\nvoid ASN1_OBJECT_free(ASN1_OBJECT *a);\nint i2d_ASN1_OBJECT(const ASN1_OBJECT *a, unsigned char **pp);\nASN1_OBJECT *d2i_ASN1_OBJECT(ASN1_OBJECT **a, const unsigned char **pp,\n                             long length);\n\nDECLARE_ASN1_ITEM(ASN1_OBJECT)\n\nDEFINE_STACK_OF(ASN1_OBJECT)\n\nASN1_STRING *ASN1_STRING_new(void);\nvoid ASN1_STRING_free(ASN1_STRING *a);\nvoid ASN1_STRING_clear_free(ASN1_STRING *a);\nint ASN1_STRING_copy(ASN1_STRING *dst, const ASN1_STRING *str);\nASN1_STRING *ASN1_STRING_dup(const ASN1_STRING *a);\nASN1_STRING *ASN1_STRING_type_new(int type);\nint ASN1_STRING_cmp(const ASN1_STRING *a, const ASN1_STRING *b);\n  /*\n   * Since this is used to store all sorts of things, via macros, for now,\n   * make its data void *\n   */\nint ASN1_STRING_set(ASN1_STRING *str, const void *data, int len);\nvoid ASN1_STRING_set0(ASN1_STRING *str, void *data, int len);\nint ASN1_STRING_length(const ASN1_STRING *x);\nvoid ASN1_STRING_length_set(ASN1_STRING *x, int n);\nint ASN1_STRING_type(const ASN1_STRING *x);\nDEPRECATEDIN_1_1_0(unsigned char *ASN1_STRING_data(ASN1_STRING *x))\nconst unsigned char *ASN1_STRING_get0_data(const ASN1_STRING *x);\n\nDECLARE_ASN1_FUNCTIONS(ASN1_BIT_STRING)\nint ASN1_BIT_STRING_set(ASN1_BIT_STRING *a, unsigned char *d, int length);\nint ASN1_BIT_STRING_set_bit(ASN1_BIT_STRING *a, int n, int value);\nint ASN1_BIT_STRING_get_bit(const ASN1_BIT_STRING *a, int n);\nint ASN1_BIT_STRING_check(const ASN1_BIT_STRING *a,\n                          const unsigned char *flags, int flags_len);\n\nint ASN1_BIT_STRING_name_print(BIO *out, ASN1_BIT_STRING *bs,\n                               BIT_STRING_BITNAME *tbl, int indent);\nint ASN1_BIT_STRING_num_asc(const char *name, BIT_STRING_BITNAME *tbl);\nint ASN1_BIT_STRING_set_asc(ASN1_BIT_STRING *bs, const char *name, int value,\n                            BIT_STRING_BITNAME *tbl);\n\nDECLARE_ASN1_FUNCTIONS(ASN1_INTEGER)\nASN1_INTEGER *d2i_ASN1_UINTEGER(ASN1_INTEGER **a, const unsigned char **pp,\n                                long length);\nASN1_INTEGER *ASN1_INTEGER_dup(const ASN1_INTEGER *x);\nint ASN1_INTEGER_cmp(const ASN1_INTEGER *x, const ASN1_INTEGER *y);\n\nDECLARE_ASN1_FUNCTIONS(ASN1_ENUMERATED)\n\nint ASN1_UTCTIME_check(const ASN1_UTCTIME *a);\nASN1_UTCTIME *ASN1_UTCTIME_set(ASN1_UTCTIME *s, time_t t);\nASN1_UTCTIME *ASN1_UTCTIME_adj(ASN1_UTCTIME *s, time_t t,\n                               int offset_day, long offset_sec);\nint ASN1_UTCTIME_set_string(ASN1_UTCTIME *s, const char *str);\nint ASN1_UTCTIME_cmp_time_t(const ASN1_UTCTIME *s, time_t t);\n\nint ASN1_GENERALIZEDTIME_check(const ASN1_GENERALIZEDTIME *a);\nASN1_GENERALIZEDTIME *ASN1_GENERALIZEDTIME_set(ASN1_GENERALIZEDTIME *s,\n                                               time_t t);\nASN1_GENERALIZEDTIME *ASN1_GENERALIZEDTIME_adj(ASN1_GENERALIZEDTIME *s,\n                                               time_t t, int offset_day,\n                                               long offset_sec);\nint ASN1_GENERALIZEDTIME_set_string(ASN1_GENERALIZEDTIME *s, const char *str);\n\nint ASN1_TIME_diff(int *pday, int *psec,\n                   const ASN1_TIME *from, const ASN1_TIME *to);\n\nDECLARE_ASN1_FUNCTIONS(ASN1_OCTET_STRING)\nASN1_OCTET_STRING *ASN1_OCTET_STRING_dup(const ASN1_OCTET_STRING *a);\nint ASN1_OCTET_STRING_cmp(const ASN1_OCTET_STRING *a,\n                          const ASN1_OCTET_STRING *b);\nint ASN1_OCTET_STRING_set(ASN1_OCTET_STRING *str, const unsigned char *data,\n                          int len);\n\nDECLARE_ASN1_FUNCTIONS(ASN1_VISIBLESTRING)\nDECLARE_ASN1_FUNCTIONS(ASN1_UNIVERSALSTRING)\nDECLARE_ASN1_FUNCTIONS(ASN1_UTF8STRING)\nDECLARE_ASN1_FUNCTIONS(ASN1_NULL)\nDECLARE_ASN1_FUNCTIONS(ASN1_BMPSTRING)\n\nint UTF8_getc(const unsigned char *str, int len, unsigned long *val);\nint UTF8_putc(unsigned char *str, int len, unsigned long value);\n\nDECLARE_ASN1_FUNCTIONS_name(ASN1_STRING, ASN1_PRINTABLE)\n\nDECLARE_ASN1_FUNCTIONS_name(ASN1_STRING, DIRECTORYSTRING)\nDECLARE_ASN1_FUNCTIONS_name(ASN1_STRING, DISPLAYTEXT)\nDECLARE_ASN1_FUNCTIONS(ASN1_PRINTABLESTRING)\nDECLARE_ASN1_FUNCTIONS(ASN1_T61STRING)\nDECLARE_ASN1_FUNCTIONS(ASN1_IA5STRING)\nDECLARE_ASN1_FUNCTIONS(ASN1_GENERALSTRING)\nDECLARE_ASN1_FUNCTIONS(ASN1_UTCTIME)\nDECLARE_ASN1_FUNCTIONS(ASN1_GENERALIZEDTIME)\nDECLARE_ASN1_FUNCTIONS(ASN1_TIME)\n\nDECLARE_ASN1_ITEM(ASN1_OCTET_STRING_NDEF)\n\nASN1_TIME *ASN1_TIME_set(ASN1_TIME *s, time_t t);\nASN1_TIME *ASN1_TIME_adj(ASN1_TIME *s, time_t t,\n                         int offset_day, long offset_sec);\nint ASN1_TIME_check(const ASN1_TIME *t);\nASN1_GENERALIZEDTIME *ASN1_TIME_to_generalizedtime(const ASN1_TIME *t,\n                                                   ASN1_GENERALIZEDTIME **out);\nint ASN1_TIME_set_string(ASN1_TIME *s, const char *str);\nint ASN1_TIME_set_string_X509(ASN1_TIME *s, const char *str);\nint ASN1_TIME_to_tm(const ASN1_TIME *s, struct tm *tm);\nint ASN1_TIME_normalize(ASN1_TIME *s);\nint ASN1_TIME_cmp_time_t(const ASN1_TIME *s, time_t t);\nint ASN1_TIME_compare(const ASN1_TIME *a, const ASN1_TIME *b);\n\nint i2a_ASN1_INTEGER(BIO *bp, const ASN1_INTEGER *a);\nint a2i_ASN1_INTEGER(BIO *bp, ASN1_INTEGER *bs, char *buf, int size);\nint i2a_ASN1_ENUMERATED(BIO *bp, const ASN1_ENUMERATED *a);\nint a2i_ASN1_ENUMERATED(BIO *bp, ASN1_ENUMERATED *bs, char *buf, int size);\nint i2a_ASN1_OBJECT(BIO *bp, const ASN1_OBJECT *a);\nint a2i_ASN1_STRING(BIO *bp, ASN1_STRING *bs, char *buf, int size);\nint i2a_ASN1_STRING(BIO *bp, const ASN1_STRING *a, int type);\nint i2t_ASN1_OBJECT(char *buf, int buf_len, const ASN1_OBJECT *a);\n\nint a2d_ASN1_OBJECT(unsigned char *out, int olen, const char *buf, int num);\nASN1_OBJECT *ASN1_OBJECT_create(int nid, unsigned char *data, int len,\n                                const char *sn, const char *ln);\n\nint ASN1_INTEGER_get_int64(int64_t *pr, const ASN1_INTEGER *a);\nint ASN1_INTEGER_set_int64(ASN1_INTEGER *a, int64_t r);\nint ASN1_INTEGER_get_uint64(uint64_t *pr, const ASN1_INTEGER *a);\nint ASN1_INTEGER_set_uint64(ASN1_INTEGER *a, uint64_t r);\n\nint ASN1_INTEGER_set(ASN1_INTEGER *a, long v);\nlong ASN1_INTEGER_get(const ASN1_INTEGER *a);\nASN1_INTEGER *BN_to_ASN1_INTEGER(const BIGNUM *bn, ASN1_INTEGER *ai);\nBIGNUM *ASN1_INTEGER_to_BN(const ASN1_INTEGER *ai, BIGNUM *bn);\n\nint ASN1_ENUMERATED_get_int64(int64_t *pr, const ASN1_ENUMERATED *a);\nint ASN1_ENUMERATED_set_int64(ASN1_ENUMERATED *a, int64_t r);\n\n\nint ASN1_ENUMERATED_set(ASN1_ENUMERATED *a, long v);\nlong ASN1_ENUMERATED_get(const ASN1_ENUMERATED *a);\nASN1_ENUMERATED *BN_to_ASN1_ENUMERATED(const BIGNUM *bn, ASN1_ENUMERATED *ai);\nBIGNUM *ASN1_ENUMERATED_to_BN(const ASN1_ENUMERATED *ai, BIGNUM *bn);\n\n/* General */\n/* given a string, return the correct type, max is the maximum length */\nint ASN1_PRINTABLE_type(const unsigned char *s, int max);\n\nunsigned long ASN1_tag2bit(int tag);\n\n/* SPECIALS */\nint ASN1_get_object(const unsigned char **pp, long *plength, int *ptag,\n                    int *pclass, long omax);\nint ASN1_check_infinite_end(unsigned char **p, long len);\nint ASN1_const_check_infinite_end(const unsigned char **p, long len);\nvoid ASN1_put_object(unsigned char **pp, int constructed, int length,\n                     int tag, int xclass);\nint ASN1_put_eoc(unsigned char **pp);\nint ASN1_object_size(int constructed, int length, int tag);\n\n/* Used to implement other functions */\nvoid *ASN1_dup(i2d_of_void *i2d, d2i_of_void *d2i, void *x);\n\n# define ASN1_dup_of(type,i2d,d2i,x) \\\n    ((type*)ASN1_dup(CHECKED_I2D_OF(type, i2d), \\\n                     CHECKED_D2I_OF(type, d2i), \\\n                     CHECKED_PTR_OF(type, x)))\n\n# define ASN1_dup_of_const(type,i2d,d2i,x) \\\n    ((type*)ASN1_dup(CHECKED_I2D_OF(const type, i2d), \\\n                     CHECKED_D2I_OF(type, d2i), \\\n                     CHECKED_PTR_OF(const type, x)))\n\nvoid *ASN1_item_dup(const ASN1_ITEM *it, void *x);\n\n/* ASN1 alloc/free macros for when a type is only used internally */\n\n# define M_ASN1_new_of(type) (type *)ASN1_item_new(ASN1_ITEM_rptr(type))\n# define M_ASN1_free_of(x, type) \\\n                ASN1_item_free(CHECKED_PTR_OF(type, x), ASN1_ITEM_rptr(type))\n\n# ifndef OPENSSL_NO_STDIO\nvoid *ASN1_d2i_fp(void *(*xnew) (void), d2i_of_void *d2i, FILE *in, void **x);\n\n#  define ASN1_d2i_fp_of(type,xnew,d2i,in,x) \\\n    ((type*)ASN1_d2i_fp(CHECKED_NEW_OF(type, xnew), \\\n                        CHECKED_D2I_OF(type, d2i), \\\n                        in, \\\n                        CHECKED_PPTR_OF(type, x)))\n\nvoid *ASN1_item_d2i_fp(const ASN1_ITEM *it, FILE *in, void *x);\nint ASN1_i2d_fp(i2d_of_void *i2d, FILE *out, void *x);\n\n#  define ASN1_i2d_fp_of(type,i2d,out,x) \\\n    (ASN1_i2d_fp(CHECKED_I2D_OF(type, i2d), \\\n                 out, \\\n                 CHECKED_PTR_OF(type, x)))\n\n#  define ASN1_i2d_fp_of_const(type,i2d,out,x) \\\n    (ASN1_i2d_fp(CHECKED_I2D_OF(const type, i2d), \\\n                 out, \\\n                 CHECKED_PTR_OF(const type, x)))\n\nint ASN1_item_i2d_fp(const ASN1_ITEM *it, FILE *out, void *x);\nint ASN1_STRING_print_ex_fp(FILE *fp, const ASN1_STRING *str, unsigned long flags);\n# endif\n\nint ASN1_STRING_to_UTF8(unsigned char **out, const ASN1_STRING *in);\n\nvoid *ASN1_d2i_bio(void *(*xnew) (void), d2i_of_void *d2i, BIO *in, void **x);\n\n#  define ASN1_d2i_bio_of(type,xnew,d2i,in,x) \\\n    ((type*)ASN1_d2i_bio( CHECKED_NEW_OF(type, xnew), \\\n                          CHECKED_D2I_OF(type, d2i), \\\n                          in, \\\n                          CHECKED_PPTR_OF(type, x)))\n\nvoid *ASN1_item_d2i_bio(const ASN1_ITEM *it, BIO *in, void *x);\nint ASN1_i2d_bio(i2d_of_void *i2d, BIO *out, unsigned char *x);\n\n#  define ASN1_i2d_bio_of(type,i2d,out,x) \\\n    (ASN1_i2d_bio(CHECKED_I2D_OF(type, i2d), \\\n                  out, \\\n                  CHECKED_PTR_OF(type, x)))\n\n#  define ASN1_i2d_bio_of_const(type,i2d,out,x) \\\n    (ASN1_i2d_bio(CHECKED_I2D_OF(const type, i2d), \\\n                  out, \\\n                  CHECKED_PTR_OF(const type, x)))\n\nint ASN1_item_i2d_bio(const ASN1_ITEM *it, BIO *out, void *x);\nint ASN1_UTCTIME_print(BIO *fp, const ASN1_UTCTIME *a);\nint ASN1_GENERALIZEDTIME_print(BIO *fp, const ASN1_GENERALIZEDTIME *a);\nint ASN1_TIME_print(BIO *fp, const ASN1_TIME *a);\nint ASN1_STRING_print(BIO *bp, const ASN1_STRING *v);\nint ASN1_STRING_print_ex(BIO *out, const ASN1_STRING *str, unsigned long flags);\nint ASN1_buf_print(BIO *bp, const unsigned char *buf, size_t buflen, int off);\nint ASN1_bn_print(BIO *bp, const char *number, const BIGNUM *num,\n                  unsigned char *buf, int off);\nint ASN1_parse(BIO *bp, const unsigned char *pp, long len, int indent);\nint ASN1_parse_dump(BIO *bp, const unsigned char *pp, long len, int indent,\n                    int dump);\nconst char *ASN1_tag2str(int tag);\n\n/* Used to load and write Netscape format cert */\n\nint ASN1_UNIVERSALSTRING_to_string(ASN1_UNIVERSALSTRING *s);\n\nint ASN1_TYPE_set_octetstring(ASN1_TYPE *a, unsigned char *data, int len);\nint ASN1_TYPE_get_octetstring(const ASN1_TYPE *a, unsigned char *data, int max_len);\nint ASN1_TYPE_set_int_octetstring(ASN1_TYPE *a, long num,\n                                  unsigned char *data, int len);\nint ASN1_TYPE_get_int_octetstring(const ASN1_TYPE *a, long *num,\n                                  unsigned char *data, int max_len);\n\nvoid *ASN1_item_unpack(const ASN1_STRING *oct, const ASN1_ITEM *it);\n\nASN1_STRING *ASN1_item_pack(void *obj, const ASN1_ITEM *it,\n                            ASN1_OCTET_STRING **oct);\n\nvoid ASN1_STRING_set_default_mask(unsigned long mask);\nint ASN1_STRING_set_default_mask_asc(const char *p);\nunsigned long ASN1_STRING_get_default_mask(void);\nint ASN1_mbstring_copy(ASN1_STRING **out, const unsigned char *in, int len,\n                       int inform, unsigned long mask);\nint ASN1_mbstring_ncopy(ASN1_STRING **out, const unsigned char *in, int len,\n                        int inform, unsigned long mask,\n                        long minsize, long maxsize);\n\nASN1_STRING *ASN1_STRING_set_by_NID(ASN1_STRING **out,\n                                    const unsigned char *in, int inlen,\n                                    int inform, int nid);\nASN1_STRING_TABLE *ASN1_STRING_TABLE_get(int nid);\nint ASN1_STRING_TABLE_add(int, long, long, unsigned long, unsigned long);\nvoid ASN1_STRING_TABLE_cleanup(void);\n\n/* ASN1 template functions */\n\n/* Old API compatible functions */\nASN1_VALUE *ASN1_item_new(const ASN1_ITEM *it);\nvoid ASN1_item_free(ASN1_VALUE *val, const ASN1_ITEM *it);\nASN1_VALUE *ASN1_item_d2i(ASN1_VALUE **val, const unsigned char **in,\n                          long len, const ASN1_ITEM *it);\nint ASN1_item_i2d(ASN1_VALUE *val, unsigned char **out, const ASN1_ITEM *it);\nint ASN1_item_ndef_i2d(ASN1_VALUE *val, unsigned char **out,\n                       const ASN1_ITEM *it);\n\nvoid ASN1_add_oid_module(void);\nvoid ASN1_add_stable_module(void);\n\nASN1_TYPE *ASN1_generate_nconf(const char *str, CONF *nconf);\nASN1_TYPE *ASN1_generate_v3(const char *str, X509V3_CTX *cnf);\nint ASN1_str2mask(const char *str, unsigned long *pmask);\n\n/* ASN1 Print flags */\n\n/* Indicate missing OPTIONAL fields */\n# define ASN1_PCTX_FLAGS_SHOW_ABSENT             0x001\n/* Mark start and end of SEQUENCE */\n# define ASN1_PCTX_FLAGS_SHOW_SEQUENCE           0x002\n/* Mark start and end of SEQUENCE/SET OF */\n# define ASN1_PCTX_FLAGS_SHOW_SSOF               0x004\n/* Show the ASN1 type of primitives */\n# define ASN1_PCTX_FLAGS_SHOW_TYPE               0x008\n/* Don't show ASN1 type of ANY */\n# define ASN1_PCTX_FLAGS_NO_ANY_TYPE             0x010\n/* Don't show ASN1 type of MSTRINGs */\n# define ASN1_PCTX_FLAGS_NO_MSTRING_TYPE         0x020\n/* Don't show field names in SEQUENCE */\n# define ASN1_PCTX_FLAGS_NO_FIELD_NAME           0x040\n/* Show structure names of each SEQUENCE field */\n# define ASN1_PCTX_FLAGS_SHOW_FIELD_STRUCT_NAME  0x080\n/* Don't show structure name even at top level */\n# define ASN1_PCTX_FLAGS_NO_STRUCT_NAME          0x100\n\nint ASN1_item_print(BIO *out, ASN1_VALUE *ifld, int indent,\n                    const ASN1_ITEM *it, const ASN1_PCTX *pctx);\nASN1_PCTX *ASN1_PCTX_new(void);\nvoid ASN1_PCTX_free(ASN1_PCTX *p);\nunsigned long ASN1_PCTX_get_flags(const ASN1_PCTX *p);\nvoid ASN1_PCTX_set_flags(ASN1_PCTX *p, unsigned long flags);\nunsigned long ASN1_PCTX_get_nm_flags(const ASN1_PCTX *p);\nvoid ASN1_PCTX_set_nm_flags(ASN1_PCTX *p, unsigned long flags);\nunsigned long ASN1_PCTX_get_cert_flags(const ASN1_PCTX *p);\nvoid ASN1_PCTX_set_cert_flags(ASN1_PCTX *p, unsigned long flags);\nunsigned long ASN1_PCTX_get_oid_flags(const ASN1_PCTX *p);\nvoid ASN1_PCTX_set_oid_flags(ASN1_PCTX *p, unsigned long flags);\nunsigned long ASN1_PCTX_get_str_flags(const ASN1_PCTX *p);\nvoid ASN1_PCTX_set_str_flags(ASN1_PCTX *p, unsigned long flags);\n\nASN1_SCTX *ASN1_SCTX_new(int (*scan_cb) (ASN1_SCTX *ctx));\nvoid ASN1_SCTX_free(ASN1_SCTX *p);\nconst ASN1_ITEM *ASN1_SCTX_get_item(ASN1_SCTX *p);\nconst ASN1_TEMPLATE *ASN1_SCTX_get_template(ASN1_SCTX *p);\nunsigned long ASN1_SCTX_get_flags(ASN1_SCTX *p);\nvoid ASN1_SCTX_set_app_data(ASN1_SCTX *p, void *data);\nvoid *ASN1_SCTX_get_app_data(ASN1_SCTX *p);\n\nconst BIO_METHOD *BIO_f_asn1(void);\n\nBIO *BIO_new_NDEF(BIO *out, ASN1_VALUE *val, const ASN1_ITEM *it);\n\nint i2d_ASN1_bio_stream(BIO *out, ASN1_VALUE *val, BIO *in, int flags,\n                        const ASN1_ITEM *it);\nint PEM_write_bio_ASN1_stream(BIO *out, ASN1_VALUE *val, BIO *in, int flags,\n                              const char *hdr, const ASN1_ITEM *it);\nint SMIME_write_ASN1(BIO *bio, ASN1_VALUE *val, BIO *data, int flags,\n                     int ctype_nid, int econt_nid,\n                     STACK_OF(X509_ALGOR) *mdalgs, const ASN1_ITEM *it);\nASN1_VALUE *SMIME_read_ASN1(BIO *bio, BIO **bcont, const ASN1_ITEM *it);\nint SMIME_crlf_copy(BIO *in, BIO *out, int flags);\nint SMIME_text(BIO *in, BIO *out);\n\nconst ASN1_ITEM *ASN1_ITEM_lookup(const char *name);\nconst ASN1_ITEM *ASN1_ITEM_get(size_t i);\n\n# ifdef  __cplusplus\n}\n# endif\n#endif\n"}, "16": {"id": 16, "path": "/usr/include/openssl/x509.h", "content": "/*\n * Copyright 1995-2018 The OpenSSL Project Authors. All Rights Reserved.\n * Copyright (c) 2002, Oracle and/or its affiliates. All rights reserved\n *\n * Licensed under the OpenSSL license (the \"License\").  You may not use\n * this file except in compliance with the License.  You can obtain a copy\n * in the file LICENSE in the source distribution or at\n * https://www.openssl.org/source/license.html\n */\n\n#ifndef HEADER_X509_H\n# define HEADER_X509_H\n\n# include <openssl/e_os2.h>\n# include <openssl/ossl_typ.h>\n# include <openssl/symhacks.h>\n# include <openssl/buffer.h>\n# include <openssl/evp.h>\n# include <openssl/bio.h>\n# include <openssl/asn1.h>\n# include <openssl/safestack.h>\n# include <openssl/ec.h>\n\n# if OPENSSL_API_COMPAT < 0x10100000L\n#  include <openssl/rsa.h>\n#  include <openssl/dsa.h>\n#  include <openssl/dh.h>\n# endif\n\n# include <openssl/sha.h>\n# include <openssl/x509err.h>\n\n#ifdef  __cplusplus\nextern \"C\" {\n#endif\n\n\n/* Flags for X509_get_signature_info() */\n/* Signature info is valid */\n# define X509_SIG_INFO_VALID     0x1\n/* Signature is suitable for TLS use */\n# define X509_SIG_INFO_TLS       0x2\n\n# define X509_FILETYPE_PEM       1\n# define X509_FILETYPE_ASN1      2\n# define X509_FILETYPE_DEFAULT   3\n\n# define X509v3_KU_DIGITAL_SIGNATURE     0x0080\n# define X509v3_KU_NON_REPUDIATION       0x0040\n# define X509v3_KU_KEY_ENCIPHERMENT      0x0020\n# define X509v3_KU_DATA_ENCIPHERMENT     0x0010\n# define X509v3_KU_KEY_AGREEMENT         0x0008\n# define X509v3_KU_KEY_CERT_SIGN         0x0004\n# define X509v3_KU_CRL_SIGN              0x0002\n# define X509v3_KU_ENCIPHER_ONLY         0x0001\n# define X509v3_KU_DECIPHER_ONLY         0x8000\n# define X509v3_KU_UNDEF                 0xffff\n\nstruct X509_algor_st {\n    ASN1_OBJECT *algorithm;\n    ASN1_TYPE *parameter;\n} /* X509_ALGOR */ ;\n\ntypedef STACK_OF(X509_ALGOR) X509_ALGORS;\n\ntypedef struct X509_val_st {\n    ASN1_TIME *notBefore;\n    ASN1_TIME *notAfter;\n} X509_VAL;\n\ntypedef struct X509_sig_st X509_SIG;\n\ntypedef struct X509_name_entry_st X509_NAME_ENTRY;\n\nDEFINE_STACK_OF(X509_NAME_ENTRY)\n\nDEFINE_STACK_OF(X509_NAME)\n\n# define X509_EX_V_NETSCAPE_HACK         0x8000\n# define X509_EX_V_INIT                  0x0001\ntypedef struct X509_extension_st X509_EXTENSION;\n\ntypedef STACK_OF(X509_EXTENSION) X509_EXTENSIONS;\n\nDEFINE_STACK_OF(X509_EXTENSION)\n\ntypedef struct x509_attributes_st X509_ATTRIBUTE;\n\nDEFINE_STACK_OF(X509_ATTRIBUTE)\n\ntypedef struct X509_req_info_st X509_REQ_INFO;\n\ntypedef struct X509_req_st X509_REQ;\n\ntypedef struct x509_cert_aux_st X509_CERT_AUX;\n\ntypedef struct x509_cinf_st X509_CINF;\n\nDEFINE_STACK_OF(X509)\n\n/* This is used for a table of trust checking functions */\n\ntypedef struct x509_trust_st {\n    int trust;\n    int flags;\n    int (*check_trust) (struct x509_trust_st *, X509 *, int);\n    char *name;\n    int arg1;\n    void *arg2;\n} X509_TRUST;\n\nDEFINE_STACK_OF(X509_TRUST)\n\n/* standard trust ids */\n\n# define X509_TRUST_DEFAULT      0 /* Only valid in purpose settings */\n\n# define X509_TRUST_COMPAT       1\n# define X509_TRUST_SSL_CLIENT   2\n# define X509_TRUST_SSL_SERVER   3\n# define X509_TRUST_EMAIL        4\n# define X509_TRUST_OBJECT_SIGN  5\n# define X509_TRUST_OCSP_SIGN    6\n# define X509_TRUST_OCSP_REQUEST 7\n# define X509_TRUST_TSA          8\n\n/* Keep these up to date! */\n# define X509_TRUST_MIN          1\n# define X509_TRUST_MAX          8\n\n/* trust_flags values */\n# define X509_TRUST_DYNAMIC      (1U << 0)\n# define X509_TRUST_DYNAMIC_NAME (1U << 1)\n/* No compat trust if self-signed, preempts \"DO_SS\" */\n# define X509_TRUST_NO_SS_COMPAT (1U << 2)\n/* Compat trust if no explicit accepted trust EKUs */\n# define X509_TRUST_DO_SS_COMPAT (1U << 3)\n/* Accept \"anyEKU\" as a wildcard trust OID */\n# define X509_TRUST_OK_ANY_EKU   (1U << 4)\n\n/* check_trust return codes */\n\n# define X509_TRUST_TRUSTED      1\n# define X509_TRUST_REJECTED     2\n# define X509_TRUST_UNTRUSTED    3\n\n/* Flags for X509_print_ex() */\n\n# define X509_FLAG_COMPAT                0\n# define X509_FLAG_NO_HEADER             1L\n# define X509_FLAG_NO_VERSION            (1L << 1)\n# define X509_FLAG_NO_SERIAL             (1L << 2)\n# define X509_FLAG_NO_SIGNAME            (1L << 3)\n# define X509_FLAG_NO_ISSUER             (1L << 4)\n# define X509_FLAG_NO_VALIDITY           (1L << 5)\n# define X509_FLAG_NO_SUBJECT            (1L << 6)\n# define X509_FLAG_NO_PUBKEY             (1L << 7)\n# define X509_FLAG_NO_EXTENSIONS         (1L << 8)\n# define X509_FLAG_NO_SIGDUMP            (1L << 9)\n# define X509_FLAG_NO_AUX                (1L << 10)\n# define X509_FLAG_NO_ATTRIBUTES         (1L << 11)\n# define X509_FLAG_NO_IDS                (1L << 12)\n\n/* Flags specific to X509_NAME_print_ex() */\n\n/* The field separator information */\n\n# define XN_FLAG_SEP_MASK        (0xf << 16)\n\n# define XN_FLAG_COMPAT          0/* Traditional; use old X509_NAME_print */\n# define XN_FLAG_SEP_COMMA_PLUS  (1 << 16)/* RFC2253 ,+ */\n# define XN_FLAG_SEP_CPLUS_SPC   (2 << 16)/* ,+ spaced: more readable */\n# define XN_FLAG_SEP_SPLUS_SPC   (3 << 16)/* ;+ spaced */\n# define XN_FLAG_SEP_MULTILINE   (4 << 16)/* One line per field */\n\n# define XN_FLAG_DN_REV          (1 << 20)/* Reverse DN order */\n\n/* How the field name is shown */\n\n# define XN_FLAG_FN_MASK         (0x3 << 21)\n\n# define XN_FLAG_FN_SN           0/* Object short name */\n# define XN_FLAG_FN_LN           (1 << 21)/* Object long name */\n# define XN_FLAG_FN_OID          (2 << 21)/* Always use OIDs */\n# define XN_FLAG_FN_NONE         (3 << 21)/* No field names */\n\n# define XN_FLAG_SPC_EQ          (1 << 23)/* Put spaces round '=' */\n\n/*\n * This determines if we dump fields we don't recognise: RFC2253 requires\n * this.\n */\n\n# define XN_FLAG_DUMP_UNKNOWN_FIELDS (1 << 24)\n\n# define XN_FLAG_FN_ALIGN        (1 << 25)/* Align field names to 20\n                                           * characters */\n\n/* Complete set of RFC2253 flags */\n\n# define XN_FLAG_RFC2253 (ASN1_STRFLGS_RFC2253 | \\\n                        XN_FLAG_SEP_COMMA_PLUS | \\\n                        XN_FLAG_DN_REV | \\\n                        XN_FLAG_FN_SN | \\\n                        XN_FLAG_DUMP_UNKNOWN_FIELDS)\n\n/* readable oneline form */\n\n# define XN_FLAG_ONELINE (ASN1_STRFLGS_RFC2253 | \\\n                        ASN1_STRFLGS_ESC_QUOTE | \\\n                        XN_FLAG_SEP_CPLUS_SPC | \\\n                        XN_FLAG_SPC_EQ | \\\n                        XN_FLAG_FN_SN)\n\n/* readable multiline form */\n\n# define XN_FLAG_MULTILINE (ASN1_STRFLGS_ESC_CTRL | \\\n                        ASN1_STRFLGS_ESC_MSB | \\\n                        XN_FLAG_SEP_MULTILINE | \\\n                        XN_FLAG_SPC_EQ | \\\n                        XN_FLAG_FN_LN | \\\n                        XN_FLAG_FN_ALIGN)\n\nDEFINE_STACK_OF(X509_REVOKED)\n\ntypedef struct X509_crl_info_st X509_CRL_INFO;\n\nDEFINE_STACK_OF(X509_CRL)\n\ntypedef struct private_key_st {\n    int version;\n    /* The PKCS#8 data types */\n    X509_ALGOR *enc_algor;\n    ASN1_OCTET_STRING *enc_pkey; /* encrypted pub key */\n    /* When decrypted, the following will not be NULL */\n    EVP_PKEY *dec_pkey;\n    /* used to encrypt and decrypt */\n    int key_length;\n    char *key_data;\n    int key_free;               /* true if we should auto free key_data */\n    /* expanded version of 'enc_algor' */\n    EVP_CIPHER_INFO cipher;\n} X509_PKEY;\n\ntypedef struct X509_info_st {\n    X509 *x509;\n    X509_CRL *crl;\n    X509_PKEY *x_pkey;\n    EVP_CIPHER_INFO enc_cipher;\n    int enc_len;\n    char *enc_data;\n} X509_INFO;\n\nDEFINE_STACK_OF(X509_INFO)\n\n/*\n * The next 2 structures and their 8 routines are used to manipulate Netscape's\n * spki structures - useful if you are writing a CA web page\n */\ntypedef struct Netscape_spkac_st {\n    X509_PUBKEY *pubkey;\n    ASN1_IA5STRING *challenge;  /* challenge sent in atlas >= PR2 */\n} NETSCAPE_SPKAC;\n\ntypedef struct Netscape_spki_st {\n    NETSCAPE_SPKAC *spkac;      /* signed public key and challenge */\n    X509_ALGOR sig_algor;\n    ASN1_BIT_STRING *signature;\n} NETSCAPE_SPKI;\n\n/* Netscape certificate sequence structure */\ntypedef struct Netscape_certificate_sequence {\n    ASN1_OBJECT *type;\n    STACK_OF(X509) *certs;\n} NETSCAPE_CERT_SEQUENCE;\n\n/*- Unused (and iv length is wrong)\ntypedef struct CBCParameter_st\n        {\n        unsigned char iv[8];\n        } CBC_PARAM;\n*/\n\n/* Password based encryption structure */\n\ntypedef struct PBEPARAM_st {\n    ASN1_OCTET_STRING *salt;\n    ASN1_INTEGER *iter;\n} PBEPARAM;\n\n/* Password based encryption V2 structures */\n\ntypedef struct PBE2PARAM_st {\n    X509_ALGOR *keyfunc;\n    X509_ALGOR *encryption;\n} PBE2PARAM;\n\ntypedef struct PBKDF2PARAM_st {\n/* Usually OCTET STRING but could be anything */\n    ASN1_TYPE *salt;\n    ASN1_INTEGER *iter;\n    ASN1_INTEGER *keylength;\n    X509_ALGOR *prf;\n} PBKDF2PARAM;\n\n#ifndef OPENSSL_NO_SCRYPT\ntypedef struct SCRYPT_PARAMS_st {\n    ASN1_OCTET_STRING *salt;\n    ASN1_INTEGER *costParameter;\n    ASN1_INTEGER *blockSize;\n    ASN1_INTEGER *parallelizationParameter;\n    ASN1_INTEGER *keyLength;\n} SCRYPT_PARAMS;\n#endif\n\n#ifdef  __cplusplus\n}\n#endif\n\n# include <openssl/x509_vfy.h>\n# include <openssl/pkcs7.h>\n\n#ifdef  __cplusplus\nextern \"C\" {\n#endif\n\n# define X509_EXT_PACK_UNKNOWN   1\n# define X509_EXT_PACK_STRING    2\n\n# define         X509_extract_key(x)     X509_get_pubkey(x)/*****/\n# define         X509_REQ_extract_key(a) X509_REQ_get_pubkey(a)\n# define         X509_name_cmp(a,b)      X509_NAME_cmp((a),(b))\n\nvoid X509_CRL_set_default_method(const X509_CRL_METHOD *meth);\nX509_CRL_METHOD *X509_CRL_METHOD_new(int (*crl_init) (X509_CRL *crl),\n                                     int (*crl_free) (X509_CRL *crl),\n                                     int (*crl_lookup) (X509_CRL *crl,\n                                                        X509_REVOKED **ret,\n                                                        ASN1_INTEGER *ser,\n                                                        X509_NAME *issuer),\n                                     int (*crl_verify) (X509_CRL *crl,\n                                                        EVP_PKEY *pk));\nvoid X509_CRL_METHOD_free(X509_CRL_METHOD *m);\n\nvoid X509_CRL_set_meth_data(X509_CRL *crl, void *dat);\nvoid *X509_CRL_get_meth_data(X509_CRL *crl);\n\nconst char *X509_verify_cert_error_string(long n);\n\nint X509_verify(X509 *a, EVP_PKEY *r);\n\nint X509_REQ_verify(X509_REQ *a, EVP_PKEY *r);\nint X509_CRL_verify(X509_CRL *a, EVP_PKEY *r);\nint NETSCAPE_SPKI_verify(NETSCAPE_SPKI *a, EVP_PKEY *r);\n\nNETSCAPE_SPKI *NETSCAPE_SPKI_b64_decode(const char *str, int len);\nchar *NETSCAPE_SPKI_b64_encode(NETSCAPE_SPKI *x);\nEVP_PKEY *NETSCAPE_SPKI_get_pubkey(NETSCAPE_SPKI *x);\nint NETSCAPE_SPKI_set_pubkey(NETSCAPE_SPKI *x, EVP_PKEY *pkey);\n\nint NETSCAPE_SPKI_print(BIO *out, NETSCAPE_SPKI *spki);\n\nint X509_signature_dump(BIO *bp, const ASN1_STRING *sig, int indent);\nint X509_signature_print(BIO *bp, const X509_ALGOR *alg,\n                         const ASN1_STRING *sig);\n\nint X509_sign(X509 *x, EVP_PKEY *pkey, const EVP_MD *md);\nint X509_sign_ctx(X509 *x, EVP_MD_CTX *ctx);\n# ifndef OPENSSL_NO_OCSP\nint X509_http_nbio(OCSP_REQ_CTX *rctx, X509 **pcert);\n# endif\nint X509_REQ_sign(X509_REQ *x, EVP_PKEY *pkey, const EVP_MD *md);\nint X509_REQ_sign_ctx(X509_REQ *x, EVP_MD_CTX *ctx);\nint X509_CRL_sign(X509_CRL *x, EVP_PKEY *pkey, const EVP_MD *md);\nint X509_CRL_sign_ctx(X509_CRL *x, EVP_MD_CTX *ctx);\n# ifndef OPENSSL_NO_OCSP\nint X509_CRL_http_nbio(OCSP_REQ_CTX *rctx, X509_CRL **pcrl);\n# endif\nint NETSCAPE_SPKI_sign(NETSCAPE_SPKI *x, EVP_PKEY *pkey, const EVP_MD *md);\n\nint X509_pubkey_digest(const X509 *data, const EVP_MD *type,\n                       unsigned char *md, unsigned int *len);\nint X509_digest(const X509 *data, const EVP_MD *type,\n                unsigned char *md, unsigned int *len);\nint X509_CRL_digest(const X509_CRL *data, const EVP_MD *type,\n                    unsigned char *md, unsigned int *len);\nint X509_REQ_digest(const X509_REQ *data, const EVP_MD *type,\n                    unsigned char *md, unsigned int *len);\nint X509_NAME_digest(const X509_NAME *data, const EVP_MD *type,\n                     unsigned char *md, unsigned int *len);\n\n# ifndef OPENSSL_NO_STDIO\nX509 *d2i_X509_fp(FILE *fp, X509 **x509);\nint i2d_X509_fp(FILE *fp, X509 *x509);\nX509_CRL *d2i_X509_CRL_fp(FILE *fp, X509_CRL **crl);\nint i2d_X509_CRL_fp(FILE *fp, X509_CRL *crl);\nX509_REQ *d2i_X509_REQ_fp(FILE *fp, X509_REQ **req);\nint i2d_X509_REQ_fp(FILE *fp, X509_REQ *req);\n#  ifndef OPENSSL_NO_RSA\nRSA *d2i_RSAPrivateKey_fp(FILE *fp, RSA **rsa);\nint i2d_RSAPrivateKey_fp(FILE *fp, RSA *rsa);\nRSA *d2i_RSAPublicKey_fp(FILE *fp, RSA **rsa);\nint i2d_RSAPublicKey_fp(FILE *fp, RSA *rsa);\nRSA *d2i_RSA_PUBKEY_fp(FILE *fp, RSA **rsa);\nint i2d_RSA_PUBKEY_fp(FILE *fp, RSA *rsa);\n#  endif\n#  ifndef OPENSSL_NO_DSA\nDSA *d2i_DSA_PUBKEY_fp(FILE *fp, DSA **dsa);\nint i2d_DSA_PUBKEY_fp(FILE *fp, DSA *dsa);\nDSA *d2i_DSAPrivateKey_fp(FILE *fp, DSA **dsa);\nint i2d_DSAPrivateKey_fp(FILE *fp, DSA *dsa);\n#  endif\n#  ifndef OPENSSL_NO_EC\nEC_KEY *d2i_EC_PUBKEY_fp(FILE *fp, EC_KEY **eckey);\nint i2d_EC_PUBKEY_fp(FILE *fp, EC_KEY *eckey);\nEC_KEY *d2i_ECPrivateKey_fp(FILE *fp, EC_KEY **eckey);\nint i2d_ECPrivateKey_fp(FILE *fp, EC_KEY *eckey);\n#  endif\nX509_SIG *d2i_PKCS8_fp(FILE *fp, X509_SIG **p8);\nint i2d_PKCS8_fp(FILE *fp, X509_SIG *p8);\nPKCS8_PRIV_KEY_INFO *d2i_PKCS8_PRIV_KEY_INFO_fp(FILE *fp,\n                                                PKCS8_PRIV_KEY_INFO **p8inf);\nint i2d_PKCS8_PRIV_KEY_INFO_fp(FILE *fp, PKCS8_PRIV_KEY_INFO *p8inf);\nint i2d_PKCS8PrivateKeyInfo_fp(FILE *fp, EVP_PKEY *key);\nint i2d_PrivateKey_fp(FILE *fp, EVP_PKEY *pkey);\nEVP_PKEY *d2i_PrivateKey_fp(FILE *fp, EVP_PKEY **a);\nint i2d_PUBKEY_fp(FILE *fp, EVP_PKEY *pkey);\nEVP_PKEY *d2i_PUBKEY_fp(FILE *fp, EVP_PKEY **a);\n# endif\n\nX509 *d2i_X509_bio(BIO *bp, X509 **x509);\nint i2d_X509_bio(BIO *bp, X509 *x509);\nX509_CRL *d2i_X509_CRL_bio(BIO *bp, X509_CRL **crl);\nint i2d_X509_CRL_bio(BIO *bp, X509_CRL *crl);\nX509_REQ *d2i_X509_REQ_bio(BIO *bp, X509_REQ **req);\nint i2d_X509_REQ_bio(BIO *bp, X509_REQ *req);\n#  ifndef OPENSSL_NO_RSA\nRSA *d2i_RSAPrivateKey_bio(BIO *bp, RSA **rsa);\nint i2d_RSAPrivateKey_bio(BIO *bp, RSA *rsa);\nRSA *d2i_RSAPublicKey_bio(BIO *bp, RSA **rsa);\nint i2d_RSAPublicKey_bio(BIO *bp, RSA *rsa);\nRSA *d2i_RSA_PUBKEY_bio(BIO *bp, RSA **rsa);\nint i2d_RSA_PUBKEY_bio(BIO *bp, RSA *rsa);\n#  endif\n#  ifndef OPENSSL_NO_DSA\nDSA *d2i_DSA_PUBKEY_bio(BIO *bp, DSA **dsa);\nint i2d_DSA_PUBKEY_bio(BIO *bp, DSA *dsa);\nDSA *d2i_DSAPrivateKey_bio(BIO *bp, DSA **dsa);\nint i2d_DSAPrivateKey_bio(BIO *bp, DSA *dsa);\n#  endif\n#  ifndef OPENSSL_NO_EC\nEC_KEY *d2i_EC_PUBKEY_bio(BIO *bp, EC_KEY **eckey);\nint i2d_EC_PUBKEY_bio(BIO *bp, EC_KEY *eckey);\nEC_KEY *d2i_ECPrivateKey_bio(BIO *bp, EC_KEY **eckey);\nint i2d_ECPrivateKey_bio(BIO *bp, EC_KEY *eckey);\n#  endif\nX509_SIG *d2i_PKCS8_bio(BIO *bp, X509_SIG **p8);\nint i2d_PKCS8_bio(BIO *bp, X509_SIG *p8);\nPKCS8_PRIV_KEY_INFO *d2i_PKCS8_PRIV_KEY_INFO_bio(BIO *bp,\n                                                 PKCS8_PRIV_KEY_INFO **p8inf);\nint i2d_PKCS8_PRIV_KEY_INFO_bio(BIO *bp, PKCS8_PRIV_KEY_INFO *p8inf);\nint i2d_PKCS8PrivateKeyInfo_bio(BIO *bp, EVP_PKEY *key);\nint i2d_PrivateKey_bio(BIO *bp, EVP_PKEY *pkey);\nEVP_PKEY *d2i_PrivateKey_bio(BIO *bp, EVP_PKEY **a);\nint i2d_PUBKEY_bio(BIO *bp, EVP_PKEY *pkey);\nEVP_PKEY *d2i_PUBKEY_bio(BIO *bp, EVP_PKEY **a);\n\nX509 *X509_dup(X509 *x509);\nX509_ATTRIBUTE *X509_ATTRIBUTE_dup(X509_ATTRIBUTE *xa);\nX509_EXTENSION *X509_EXTENSION_dup(X509_EXTENSION *ex);\nX509_CRL *X509_CRL_dup(X509_CRL *crl);\nX509_REVOKED *X509_REVOKED_dup(X509_REVOKED *rev);\nX509_REQ *X509_REQ_dup(X509_REQ *req);\nX509_ALGOR *X509_ALGOR_dup(X509_ALGOR *xn);\nint X509_ALGOR_set0(X509_ALGOR *alg, ASN1_OBJECT *aobj, int ptype,\n                    void *pval);\nvoid X509_ALGOR_get0(const ASN1_OBJECT **paobj, int *pptype,\n                     const void **ppval, const X509_ALGOR *algor);\nvoid X509_ALGOR_set_md(X509_ALGOR *alg, const EVP_MD *md);\nint X509_ALGOR_cmp(const X509_ALGOR *a, const X509_ALGOR *b);\n\nX509_NAME *X509_NAME_dup(X509_NAME *xn);\nX509_NAME_ENTRY *X509_NAME_ENTRY_dup(X509_NAME_ENTRY *ne);\n\nint X509_cmp_time(const ASN1_TIME *s, time_t *t);\nint X509_cmp_current_time(const ASN1_TIME *s);\nASN1_TIME *X509_time_adj(ASN1_TIME *s, long adj, time_t *t);\nASN1_TIME *X509_time_adj_ex(ASN1_TIME *s,\n                            int offset_day, long offset_sec, time_t *t);\nASN1_TIME *X509_gmtime_adj(ASN1_TIME *s, long adj);\n\nconst char *X509_get_default_cert_area(void);\nconst char *X509_get_default_cert_dir(void);\nconst char *X509_get_default_cert_file(void);\nconst char *X509_get_default_cert_dir_env(void);\nconst char *X509_get_default_cert_file_env(void);\nconst char *X509_get_default_private_dir(void);\n\nX509_REQ *X509_to_X509_REQ(X509 *x, EVP_PKEY *pkey, const EVP_MD *md);\nX509 *X509_REQ_to_X509(X509_REQ *r, int days, EVP_PKEY *pkey);\n\nDECLARE_ASN1_FUNCTIONS(X509_ALGOR)\nDECLARE_ASN1_ENCODE_FUNCTIONS(X509_ALGORS, X509_ALGORS, X509_ALGORS)\nDECLARE_ASN1_FUNCTIONS(X509_VAL)\n\nDECLARE_ASN1_FUNCTIONS(X509_PUBKEY)\n\nint X509_PUBKEY_set(X509_PUBKEY **x, EVP_PKEY *pkey);\nEVP_PKEY *X509_PUBKEY_get0(X509_PUBKEY *key);\nEVP_PKEY *X509_PUBKEY_get(X509_PUBKEY *key);\nint X509_get_pubkey_parameters(EVP_PKEY *pkey, STACK_OF(X509) *chain);\nlong X509_get_pathlen(X509 *x);\nint i2d_PUBKEY(EVP_PKEY *a, unsigned char **pp);\nEVP_PKEY *d2i_PUBKEY(EVP_PKEY **a, const unsigned char **pp, long length);\n# ifndef OPENSSL_NO_RSA\nint i2d_RSA_PUBKEY(RSA *a, unsigned char **pp);\nRSA *d2i_RSA_PUBKEY(RSA **a, const unsigned char **pp, long length);\n# endif\n# ifndef OPENSSL_NO_DSA\nint i2d_DSA_PUBKEY(DSA *a, unsigned char **pp);\nDSA *d2i_DSA_PUBKEY(DSA **a, const unsigned char **pp, long length);\n# endif\n# ifndef OPENSSL_NO_EC\nint i2d_EC_PUBKEY(EC_KEY *a, unsigned char **pp);\nEC_KEY *d2i_EC_PUBKEY(EC_KEY **a, const unsigned char **pp, long length);\n# endif\n\nDECLARE_ASN1_FUNCTIONS(X509_SIG)\nvoid X509_SIG_get0(const X509_SIG *sig, const X509_ALGOR **palg,\n                   const ASN1_OCTET_STRING **pdigest);\nvoid X509_SIG_getm(X509_SIG *sig, X509_ALGOR **palg,\n                   ASN1_OCTET_STRING **pdigest);\n\nDECLARE_ASN1_FUNCTIONS(X509_REQ_INFO)\nDECLARE_ASN1_FUNCTIONS(X509_REQ)\n\nDECLARE_ASN1_FUNCTIONS(X509_ATTRIBUTE)\nX509_ATTRIBUTE *X509_ATTRIBUTE_create(int nid, int atrtype, void *value);\n\nDECLARE_ASN1_FUNCTIONS(X509_EXTENSION)\nDECLARE_ASN1_ENCODE_FUNCTIONS(X509_EXTENSIONS, X509_EXTENSIONS, X509_EXTENSIONS)\n\nDECLARE_ASN1_FUNCTIONS(X509_NAME_ENTRY)\n\nDECLARE_ASN1_FUNCTIONS(X509_NAME)\n\nint X509_NAME_set(X509_NAME **xn, X509_NAME *name);\n\nDECLARE_ASN1_FUNCTIONS(X509_CINF)\n\nDECLARE_ASN1_FUNCTIONS(X509)\nDECLARE_ASN1_FUNCTIONS(X509_CERT_AUX)\n\n#define X509_get_ex_new_index(l, p, newf, dupf, freef) \\\n    CRYPTO_get_ex_new_index(CRYPTO_EX_INDEX_X509, l, p, newf, dupf, freef)\nint X509_set_ex_data(X509 *r, int idx, void *arg);\nvoid *X509_get_ex_data(X509 *r, int idx);\nint i2d_X509_AUX(X509 *a, unsigned char **pp);\nX509 *d2i_X509_AUX(X509 **a, const unsigned char **pp, long length);\n\nint i2d_re_X509_tbs(X509 *x, unsigned char **pp);\n\nint X509_SIG_INFO_get(const X509_SIG_INFO *siginf, int *mdnid, int *pknid,\n                      int *secbits, uint32_t *flags);\nvoid X509_SIG_INFO_set(X509_SIG_INFO *siginf, int mdnid, int pknid,\n                       int secbits, uint32_t flags);\n\nint X509_get_signature_info(X509 *x, int *mdnid, int *pknid, int *secbits,\n                            uint32_t *flags);\n\nvoid X509_get0_signature(const ASN1_BIT_STRING **psig,\n                         const X509_ALGOR **palg, const X509 *x);\nint X509_get_signature_nid(const X509 *x);\n\nint X509_trusted(const X509 *x);\nint X509_alias_set1(X509 *x, const unsigned char *name, int len);\nint X509_keyid_set1(X509 *x, const unsigned char *id, int len);\nunsigned char *X509_alias_get0(X509 *x, int *len);\nunsigned char *X509_keyid_get0(X509 *x, int *len);\nint (*X509_TRUST_set_default(int (*trust) (int, X509 *, int))) (int, X509 *,\n                                                                int);\nint X509_TRUST_set(int *t, int trust);\nint X509_add1_trust_object(X509 *x, const ASN1_OBJECT *obj);\nint X509_add1_reject_object(X509 *x, const ASN1_OBJECT *obj);\nvoid X509_trust_clear(X509 *x);\nvoid X509_reject_clear(X509 *x);\n\nSTACK_OF(ASN1_OBJECT) *X509_get0_trust_objects(X509 *x);\nSTACK_OF(ASN1_OBJECT) *X509_get0_reject_objects(X509 *x);\n\nDECLARE_ASN1_FUNCTIONS(X509_REVOKED)\nDECLARE_ASN1_FUNCTIONS(X509_CRL_INFO)\nDECLARE_ASN1_FUNCTIONS(X509_CRL)\n\nint X509_CRL_add0_revoked(X509_CRL *crl, X509_REVOKED *rev);\nint X509_CRL_get0_by_serial(X509_CRL *crl,\n                            X509_REVOKED **ret, ASN1_INTEGER *serial);\nint X509_CRL_get0_by_cert(X509_CRL *crl, X509_REVOKED **ret, X509 *x);\n\nX509_PKEY *X509_PKEY_new(void);\nvoid X509_PKEY_free(X509_PKEY *a);\n\nDECLARE_ASN1_FUNCTIONS(NETSCAPE_SPKI)\nDECLARE_ASN1_FUNCTIONS(NETSCAPE_SPKAC)\nDECLARE_ASN1_FUNCTIONS(NETSCAPE_CERT_SEQUENCE)\n\nX509_INFO *X509_INFO_new(void);\nvoid X509_INFO_free(X509_INFO *a);\nchar *X509_NAME_oneline(const X509_NAME *a, char *buf, int size);\n\nint ASN1_verify(i2d_of_void *i2d, X509_ALGOR *algor1,\n                ASN1_BIT_STRING *signature, char *data, EVP_PKEY *pkey);\n\nint ASN1_digest(i2d_of_void *i2d, const EVP_MD *type, char *data,\n                unsigned char *md, unsigned int *len);\n\nint ASN1_sign(i2d_of_void *i2d, X509_ALGOR *algor1,\n              X509_ALGOR *algor2, ASN1_BIT_STRING *signature,\n              char *data, EVP_PKEY *pkey, const EVP_MD *type);\n\nint ASN1_item_digest(const ASN1_ITEM *it, const EVP_MD *type, void *data,\n                     unsigned char *md, unsigned int *len);\n\nint ASN1_item_verify(const ASN1_ITEM *it, X509_ALGOR *algor1,\n                     ASN1_BIT_STRING *signature, void *data, EVP_PKEY *pkey);\n\nint ASN1_item_sign(const ASN1_ITEM *it, X509_ALGOR *algor1,\n                   X509_ALGOR *algor2, ASN1_BIT_STRING *signature, void *data,\n                   EVP_PKEY *pkey, const EVP_MD *type);\nint ASN1_item_sign_ctx(const ASN1_ITEM *it, X509_ALGOR *algor1,\n                       X509_ALGOR *algor2, ASN1_BIT_STRING *signature,\n                       void *asn, EVP_MD_CTX *ctx);\n\nlong X509_get_version(const X509 *x);\nint X509_set_version(X509 *x, long version);\nint X509_set_serialNumber(X509 *x, ASN1_INTEGER *serial);\nASN1_INTEGER *X509_get_serialNumber(X509 *x);\nconst ASN1_INTEGER *X509_get0_serialNumber(const X509 *x);\nint X509_set_issuer_name(X509 *x, X509_NAME *name);\nX509_NAME *X509_get_issuer_name(const X509 *a);\nint X509_set_subject_name(X509 *x, X509_NAME *name);\nX509_NAME *X509_get_subject_name(const X509 *a);\nconst ASN1_TIME * X509_get0_notBefore(const X509 *x);\nASN1_TIME *X509_getm_notBefore(const X509 *x);\nint X509_set1_notBefore(X509 *x, const ASN1_TIME *tm);\nconst ASN1_TIME *X509_get0_notAfter(const X509 *x);\nASN1_TIME *X509_getm_notAfter(const X509 *x);\nint X509_set1_notAfter(X509 *x, const ASN1_TIME *tm);\nint X509_set_pubkey(X509 *x, EVP_PKEY *pkey);\nint X509_up_ref(X509 *x);\nint X509_get_signature_type(const X509 *x);\n\n# if OPENSSL_API_COMPAT < 0x10100000L\n#  define X509_get_notBefore X509_getm_notBefore\n#  define X509_get_notAfter X509_getm_notAfter\n#  define X509_set_notBefore X509_set1_notBefore\n#  define X509_set_notAfter X509_set1_notAfter\n#endif\n\n\n/*\n * This one is only used so that a binary form can output, as in\n * i2d_X509_PUBKEY(X509_get_X509_PUBKEY(x), &buf)\n */\nX509_PUBKEY *X509_get_X509_PUBKEY(const X509 *x);\nconst STACK_OF(X509_EXTENSION) *X509_get0_extensions(const X509 *x);\nvoid X509_get0_uids(const X509 *x, const ASN1_BIT_STRING **piuid,\n                    const ASN1_BIT_STRING **psuid);\nconst X509_ALGOR *X509_get0_tbs_sigalg(const X509 *x);\n\nEVP_PKEY *X509_get0_pubkey(const X509 *x);\nEVP_PKEY *X509_get_pubkey(X509 *x);\nASN1_BIT_STRING *X509_get0_pubkey_bitstr(const X509 *x);\nint X509_certificate_type(const X509 *x, const EVP_PKEY *pubkey);\n\nlong X509_REQ_get_version(const X509_REQ *req);\nint X509_REQ_set_version(X509_REQ *x, long version);\nX509_NAME *X509_REQ_get_subject_name(const X509_REQ *req);\nint X509_REQ_set_subject_name(X509_REQ *req, X509_NAME *name);\nvoid X509_REQ_get0_signature(const X509_REQ *req, const ASN1_BIT_STRING **psig,\n                             const X509_ALGOR **palg);\nint X509_REQ_get_signature_nid(const X509_REQ *req);\nint i2d_re_X509_REQ_tbs(X509_REQ *req, unsigned char **pp);\nint X509_REQ_set_pubkey(X509_REQ *x, EVP_PKEY *pkey);\nEVP_PKEY *X509_REQ_get_pubkey(X509_REQ *req);\nEVP_PKEY *X509_REQ_get0_pubkey(X509_REQ *req);\nX509_PUBKEY *X509_REQ_get_X509_PUBKEY(X509_REQ *req);\nint X509_REQ_extension_nid(int nid);\nint *X509_REQ_get_extension_nids(void);\nvoid X509_REQ_set_extension_nids(int *nids);\nSTACK_OF(X509_EXTENSION) *X509_REQ_get_extensions(X509_REQ *req);\nint X509_REQ_add_extensions_nid(X509_REQ *req, STACK_OF(X509_EXTENSION) *exts,\n                                int nid);\nint X509_REQ_add_extensions(X509_REQ *req, STACK_OF(X509_EXTENSION) *exts);\nint X509_REQ_get_attr_count(const X509_REQ *req);\nint X509_REQ_get_attr_by_NID(const X509_REQ *req, int nid, int lastpos);\nint X509_REQ_get_attr_by_OBJ(const X509_REQ *req, const ASN1_OBJECT *obj,\n                             int lastpos);\nX509_ATTRIBUTE *X509_REQ_get_attr(const X509_REQ *req, int loc);\nX509_ATTRIBUTE *X509_REQ_delete_attr(X509_REQ *req, int loc);\nint X509_REQ_add1_attr(X509_REQ *req, X509_ATTRIBUTE *attr);\nint X509_REQ_add1_attr_by_OBJ(X509_REQ *req,\n                              const ASN1_OBJECT *obj, int type,\n                              const unsigned char *bytes, int len);\nint X509_REQ_add1_attr_by_NID(X509_REQ *req,\n                              int nid, int type,\n                              const unsigned char *bytes, int len);\nint X509_REQ_add1_attr_by_txt(X509_REQ *req,\n                              const char *attrname, int type,\n                              const unsigned char *bytes, int len);\n\nint X509_CRL_set_version(X509_CRL *x, long version);\nint X509_CRL_set_issuer_name(X509_CRL *x, X509_NAME *name);\nint X509_CRL_set1_lastUpdate(X509_CRL *x, const ASN1_TIME *tm);\nint X509_CRL_set1_nextUpdate(X509_CRL *x, const ASN1_TIME *tm);\nint X509_CRL_sort(X509_CRL *crl);\nint X509_CRL_up_ref(X509_CRL *crl);\n\n# if OPENSSL_API_COMPAT < 0x10100000L\n#  define X509_CRL_set_lastUpdate X509_CRL_set1_lastUpdate\n#  define X509_CRL_set_nextUpdate X509_CRL_set1_nextUpdate\n#endif\n\nlong X509_CRL_get_version(const X509_CRL *crl);\nconst ASN1_TIME *X509_CRL_get0_lastUpdate(const X509_CRL *crl);\nconst ASN1_TIME *X509_CRL_get0_nextUpdate(const X509_CRL *crl);\nDEPRECATEDIN_1_1_0(ASN1_TIME *X509_CRL_get_lastUpdate(X509_CRL *crl))\nDEPRECATEDIN_1_1_0(ASN1_TIME *X509_CRL_get_nextUpdate(X509_CRL *crl))\nX509_NAME *X509_CRL_get_issuer(const X509_CRL *crl);\nconst STACK_OF(X509_EXTENSION) *X509_CRL_get0_extensions(const X509_CRL *crl);\nSTACK_OF(X509_REVOKED) *X509_CRL_get_REVOKED(X509_CRL *crl);\nvoid X509_CRL_get0_signature(const X509_CRL *crl, const ASN1_BIT_STRING **psig,\n                             const X509_ALGOR **palg);\nint X509_CRL_get_signature_nid(const X509_CRL *crl);\nint i2d_re_X509_CRL_tbs(X509_CRL *req, unsigned char **pp);\n\nconst ASN1_INTEGER *X509_REVOKED_get0_serialNumber(const X509_REVOKED *x);\nint X509_REVOKED_set_serialNumber(X509_REVOKED *x, ASN1_INTEGER *serial);\nconst ASN1_TIME *X509_REVOKED_get0_revocationDate(const X509_REVOKED *x);\nint X509_REVOKED_set_revocationDate(X509_REVOKED *r, ASN1_TIME *tm);\nconst STACK_OF(X509_EXTENSION) *\nX509_REVOKED_get0_extensions(const X509_REVOKED *r);\n\nX509_CRL *X509_CRL_diff(X509_CRL *base, X509_CRL *newer,\n                        EVP_PKEY *skey, const EVP_MD *md, unsigned int flags);\n\nint X509_REQ_check_private_key(X509_REQ *x509, EVP_PKEY *pkey);\n\nint X509_check_private_key(const X509 *x509, const EVP_PKEY *pkey);\nint X509_chain_check_suiteb(int *perror_depth,\n                            X509 *x, STACK_OF(X509) *chain,\n                            unsigned long flags);\nint X509_CRL_check_suiteb(X509_CRL *crl, EVP_PKEY *pk, unsigned long flags);\nSTACK_OF(X509) *X509_chain_up_ref(STACK_OF(X509) *chain);\n\nint X509_issuer_and_serial_cmp(const X509 *a, const X509 *b);\nunsigned long X509_issuer_and_serial_hash(X509 *a);\n\nint X509_issuer_name_cmp(const X509 *a, const X509 *b);\nunsigned long X509_issuer_name_hash(X509 *a);\n\nint X509_subject_name_cmp(const X509 *a, const X509 *b);\nunsigned long X509_subject_name_hash(X509 *x);\n\n# ifndef OPENSSL_NO_MD5\nunsigned long X509_issuer_name_hash_old(X509 *a);\nunsigned long X509_subject_name_hash_old(X509 *x);\n# endif\n\nint X509_cmp(const X509 *a, const X509 *b);\nint X509_NAME_cmp(const X509_NAME *a, const X509_NAME *b);\nunsigned long X509_NAME_hash(X509_NAME *x);\nunsigned long X509_NAME_hash_old(X509_NAME *x);\n\nint X509_CRL_cmp(const X509_CRL *a, const X509_CRL *b);\nint X509_CRL_match(const X509_CRL *a, const X509_CRL *b);\nint X509_aux_print(BIO *out, X509 *x, int indent);\n# ifndef OPENSSL_NO_STDIO\nint X509_print_ex_fp(FILE *bp, X509 *x, unsigned long nmflag,\n                     unsigned long cflag);\nint X509_print_fp(FILE *bp, X509 *x);\nint X509_CRL_print_fp(FILE *bp, X509_CRL *x);\nint X509_REQ_print_fp(FILE *bp, X509_REQ *req);\nint X509_NAME_print_ex_fp(FILE *fp, const X509_NAME *nm, int indent,\n                          unsigned long flags);\n# endif\n\nint X509_NAME_print(BIO *bp, const X509_NAME *name, int obase);\nint X509_NAME_print_ex(BIO *out, const X509_NAME *nm, int indent,\n                       unsigned long flags);\nint X509_print_ex(BIO *bp, X509 *x, unsigned long nmflag,\n                  unsigned long cflag);\nint X509_print(BIO *bp, X509 *x);\nint X509_ocspid_print(BIO *bp, X509 *x);\nint X509_CRL_print_ex(BIO *out, X509_CRL *x, unsigned long nmflag);\nint X509_CRL_print(BIO *bp, X509_CRL *x);\nint X509_REQ_print_ex(BIO *bp, X509_REQ *x, unsigned long nmflag,\n                      unsigned long cflag);\nint X509_REQ_print(BIO *bp, X509_REQ *req);\n\nint X509_NAME_entry_count(const X509_NAME *name);\nint X509_NAME_get_text_by_NID(X509_NAME *name, int nid, char *buf, int len);\nint X509_NAME_get_text_by_OBJ(X509_NAME *name, const ASN1_OBJECT *obj,\n                              char *buf, int len);\n\n/*\n * NOTE: you should be passing -1, not 0 as lastpos. The functions that use\n * lastpos, search after that position on.\n */\nint X509_NAME_get_index_by_NID(X509_NAME *name, int nid, int lastpos);\nint X509_NAME_get_index_by_OBJ(X509_NAME *name, const ASN1_OBJECT *obj,\n                               int lastpos);\nX509_NAME_ENTRY *X509_NAME_get_entry(const X509_NAME *name, int loc);\nX509_NAME_ENTRY *X509_NAME_delete_entry(X509_NAME *name, int loc);\nint X509_NAME_add_entry(X509_NAME *name, const X509_NAME_ENTRY *ne,\n                        int loc, int set);\nint X509_NAME_add_entry_by_OBJ(X509_NAME *name, const ASN1_OBJECT *obj, int type,\n                               const unsigned char *bytes, int len, int loc,\n                               int set);\nint X509_NAME_add_entry_by_NID(X509_NAME *name, int nid, int type,\n                               const unsigned char *bytes, int len, int loc,\n                               int set);\nX509_NAME_ENTRY *X509_NAME_ENTRY_create_by_txt(X509_NAME_ENTRY **ne,\n                                               const char *field, int type,\n                                               const unsigned char *bytes,\n                                               int len);\nX509_NAME_ENTRY *X509_NAME_ENTRY_create_by_NID(X509_NAME_ENTRY **ne, int nid,\n                                               int type,\n                                               const unsigned char *bytes,\n                                               int len);\nint X509_NAME_add_entry_by_txt(X509_NAME *name, const char *field, int type,\n                               const unsigned char *bytes, int len, int loc,\n                               int set);\nX509_NAME_ENTRY *X509_NAME_ENTRY_create_by_OBJ(X509_NAME_ENTRY **ne,\n                                               const ASN1_OBJECT *obj, int type,\n                                               const unsigned char *bytes,\n                                               int len);\nint X509_NAME_ENTRY_set_object(X509_NAME_ENTRY *ne, const ASN1_OBJECT *obj);\nint X509_NAME_ENTRY_set_data(X509_NAME_ENTRY *ne, int type,\n                             const unsigned char *bytes, int len);\nASN1_OBJECT *X509_NAME_ENTRY_get_object(const X509_NAME_ENTRY *ne);\nASN1_STRING * X509_NAME_ENTRY_get_data(const X509_NAME_ENTRY *ne);\nint X509_NAME_ENTRY_set(const X509_NAME_ENTRY *ne);\n\nint X509_NAME_get0_der(X509_NAME *nm, const unsigned char **pder,\n                       size_t *pderlen);\n\nint X509v3_get_ext_count(const STACK_OF(X509_EXTENSION) *x);\nint X509v3_get_ext_by_NID(const STACK_OF(X509_EXTENSION) *x,\n                          int nid, int lastpos);\nint X509v3_get_ext_by_OBJ(const STACK_OF(X509_EXTENSION) *x,\n                          const ASN1_OBJECT *obj, int lastpos);\nint X509v3_get_ext_by_critical(const STACK_OF(X509_EXTENSION) *x,\n                               int crit, int lastpos);\nX509_EXTENSION *X509v3_get_ext(const STACK_OF(X509_EXTENSION) *x, int loc);\nX509_EXTENSION *X509v3_delete_ext(STACK_OF(X509_EXTENSION) *x, int loc);\nSTACK_OF(X509_EXTENSION) *X509v3_add_ext(STACK_OF(X509_EXTENSION) **x,\n                                         X509_EXTENSION *ex, int loc);\n\nint X509_get_ext_count(const X509 *x);\nint X509_get_ext_by_NID(const X509 *x, int nid, int lastpos);\nint X509_get_ext_by_OBJ(const X509 *x, const ASN1_OBJECT *obj, int lastpos);\nint X509_get_ext_by_critical(const X509 *x, int crit, int lastpos);\nX509_EXTENSION *X509_get_ext(const X509 *x, int loc);\nX509_EXTENSION *X509_delete_ext(X509 *x, int loc);\nint X509_add_ext(X509 *x, X509_EXTENSION *ex, int loc);\nvoid *X509_get_ext_d2i(const X509 *x, int nid, int *crit, int *idx);\nint X509_add1_ext_i2d(X509 *x, int nid, void *value, int crit,\n                      unsigned long flags);\n\nint X509_CRL_get_ext_count(const X509_CRL *x);\nint X509_CRL_get_ext_by_NID(const X509_CRL *x, int nid, int lastpos);\nint X509_CRL_get_ext_by_OBJ(const X509_CRL *x, const ASN1_OBJECT *obj,\n                            int lastpos);\nint X509_CRL_get_ext_by_critical(const X509_CRL *x, int crit, int lastpos);\nX509_EXTENSION *X509_CRL_get_ext(const X509_CRL *x, int loc);\nX509_EXTENSION *X509_CRL_delete_ext(X509_CRL *x, int loc);\nint X509_CRL_add_ext(X509_CRL *x, X509_EXTENSION *ex, int loc);\nvoid *X509_CRL_get_ext_d2i(const X509_CRL *x, int nid, int *crit, int *idx);\nint X509_CRL_add1_ext_i2d(X509_CRL *x, int nid, void *value, int crit,\n                          unsigned long flags);\n\nint X509_REVOKED_get_ext_count(const X509_REVOKED *x);\nint X509_REVOKED_get_ext_by_NID(const X509_REVOKED *x, int nid, int lastpos);\nint X509_REVOKED_get_ext_by_OBJ(const X509_REVOKED *x, const ASN1_OBJECT *obj,\n                                int lastpos);\nint X509_REVOKED_get_ext_by_critical(const X509_REVOKED *x, int crit,\n                                     int lastpos);\nX509_EXTENSION *X509_REVOKED_get_ext(const X509_REVOKED *x, int loc);\nX509_EXTENSION *X509_REVOKED_delete_ext(X509_REVOKED *x, int loc);\nint X509_REVOKED_add_ext(X509_REVOKED *x, X509_EXTENSION *ex, int loc);\nvoid *X509_REVOKED_get_ext_d2i(const X509_REVOKED *x, int nid, int *crit,\n                               int *idx);\nint X509_REVOKED_add1_ext_i2d(X509_REVOKED *x, int nid, void *value, int crit,\n                              unsigned long flags);\n\nX509_EXTENSION *X509_EXTENSION_create_by_NID(X509_EXTENSION **ex,\n                                             int nid, int crit,\n                                             ASN1_OCTET_STRING *data);\nX509_EXTENSION *X509_EXTENSION_create_by_OBJ(X509_EXTENSION **ex,\n                                             const ASN1_OBJECT *obj, int crit,\n                                             ASN1_OCTET_STRING *data);\nint X509_EXTENSION_set_object(X509_EXTENSION *ex, const ASN1_OBJECT *obj);\nint X509_EXTENSION_set_critical(X509_EXTENSION *ex, int crit);\nint X509_EXTENSION_set_data(X509_EXTENSION *ex, ASN1_OCTET_STRING *data);\nASN1_OBJECT *X509_EXTENSION_get_object(X509_EXTENSION *ex);\nASN1_OCTET_STRING *X509_EXTENSION_get_data(X509_EXTENSION *ne);\nint X509_EXTENSION_get_critical(const X509_EXTENSION *ex);\n\nint X509at_get_attr_count(const STACK_OF(X509_ATTRIBUTE) *x);\nint X509at_get_attr_by_NID(const STACK_OF(X509_ATTRIBUTE) *x, int nid,\n                           int lastpos);\nint X509at_get_attr_by_OBJ(const STACK_OF(X509_ATTRIBUTE) *sk,\n                           const ASN1_OBJECT *obj, int lastpos);\nX509_ATTRIBUTE *X509at_get_attr(const STACK_OF(X509_ATTRIBUTE) *x, int loc);\nX509_ATTRIBUTE *X509at_delete_attr(STACK_OF(X509_ATTRIBUTE) *x, int loc);\nSTACK_OF(X509_ATTRIBUTE) *X509at_add1_attr(STACK_OF(X509_ATTRIBUTE) **x,\n                                           X509_ATTRIBUTE *attr);\nSTACK_OF(X509_ATTRIBUTE) *X509at_add1_attr_by_OBJ(STACK_OF(X509_ATTRIBUTE)\n                                                  **x, const ASN1_OBJECT *obj,\n                                                  int type,\n                                                  const unsigned char *bytes,\n                                                  int len);\nSTACK_OF(X509_ATTRIBUTE) *X509at_add1_attr_by_NID(STACK_OF(X509_ATTRIBUTE)\n                                                  **x, int nid, int type,\n                                                  const unsigned char *bytes,\n                                                  int len);\nSTACK_OF(X509_ATTRIBUTE) *X509at_add1_attr_by_txt(STACK_OF(X509_ATTRIBUTE)\n                                                  **x, const char *attrname,\n                                                  int type,\n                                                  const unsigned char *bytes,\n                                                  int len);\nvoid *X509at_get0_data_by_OBJ(STACK_OF(X509_ATTRIBUTE) *x,\n                              const ASN1_OBJECT *obj, int lastpos, int type);\nX509_ATTRIBUTE *X509_ATTRIBUTE_create_by_NID(X509_ATTRIBUTE **attr, int nid,\n                                             int atrtype, const void *data,\n                                             int len);\nX509_ATTRIBUTE *X509_ATTRIBUTE_create_by_OBJ(X509_ATTRIBUTE **attr,\n                                             const ASN1_OBJECT *obj,\n                                             int atrtype, const void *data,\n                                             int len);\nX509_ATTRIBUTE *X509_ATTRIBUTE_create_by_txt(X509_ATTRIBUTE **attr,\n                                             const char *atrname, int type,\n                                             const unsigned char *bytes,\n                                             int len);\nint X509_ATTRIBUTE_set1_object(X509_ATTRIBUTE *attr, const ASN1_OBJECT *obj);\nint X509_ATTRIBUTE_set1_data(X509_ATTRIBUTE *attr, int attrtype,\n                             const void *data, int len);\nvoid *X509_ATTRIBUTE_get0_data(X509_ATTRIBUTE *attr, int idx, int atrtype,\n                               void *data);\nint X509_ATTRIBUTE_count(const X509_ATTRIBUTE *attr);\nASN1_OBJECT *X509_ATTRIBUTE_get0_object(X509_ATTRIBUTE *attr);\nASN1_TYPE *X509_ATTRIBUTE_get0_type(X509_ATTRIBUTE *attr, int idx);\n\nint EVP_PKEY_get_attr_count(const EVP_PKEY *key);\nint EVP_PKEY_get_attr_by_NID(const EVP_PKEY *key, int nid, int lastpos);\nint EVP_PKEY_get_attr_by_OBJ(const EVP_PKEY *key, const ASN1_OBJECT *obj,\n                             int lastpos);\nX509_ATTRIBUTE *EVP_PKEY_get_attr(const EVP_PKEY *key, int loc);\nX509_ATTRIBUTE *EVP_PKEY_delete_attr(EVP_PKEY *key, int loc);\nint EVP_PKEY_add1_attr(EVP_PKEY *key, X509_ATTRIBUTE *attr);\nint EVP_PKEY_add1_attr_by_OBJ(EVP_PKEY *key,\n                              const ASN1_OBJECT *obj, int type,\n                              const unsigned char *bytes, int len);\nint EVP_PKEY_add1_attr_by_NID(EVP_PKEY *key,\n                              int nid, int type,\n                              const unsigned char *bytes, int len);\nint EVP_PKEY_add1_attr_by_txt(EVP_PKEY *key,\n                              const char *attrname, int type,\n                              const unsigned char *bytes, int len);\n\nint X509_verify_cert(X509_STORE_CTX *ctx);\n\n/* lookup a cert from a X509 STACK */\nX509 *X509_find_by_issuer_and_serial(STACK_OF(X509) *sk, X509_NAME *name,\n                                     ASN1_INTEGER *serial);\nX509 *X509_find_by_subject(STACK_OF(X509) *sk, X509_NAME *name);\n\nDECLARE_ASN1_FUNCTIONS(PBEPARAM)\nDECLARE_ASN1_FUNCTIONS(PBE2PARAM)\nDECLARE_ASN1_FUNCTIONS(PBKDF2PARAM)\n#ifndef OPENSSL_NO_SCRYPT\nDECLARE_ASN1_FUNCTIONS(SCRYPT_PARAMS)\n#endif\n\nint PKCS5_pbe_set0_algor(X509_ALGOR *algor, int alg, int iter,\n                         const unsigned char *salt, int saltlen);\n\nX509_ALGOR *PKCS5_pbe_set(int alg, int iter,\n                          const unsigned char *salt, int saltlen);\nX509_ALGOR *PKCS5_pbe2_set(const EVP_CIPHER *cipher, int iter,\n                           unsigned char *salt, int saltlen);\nX509_ALGOR *PKCS5_pbe2_set_iv(const EVP_CIPHER *cipher, int iter,\n                              unsigned char *salt, int saltlen,\n                              unsigned char *aiv, int prf_nid);\n\n#ifndef OPENSSL_NO_SCRYPT\nX509_ALGOR *PKCS5_pbe2_set_scrypt(const EVP_CIPHER *cipher,\n                                  const unsigned char *salt, int saltlen,\n                                  unsigned char *aiv, uint64_t N, uint64_t r,\n                                  uint64_t p);\n#endif\n\nX509_ALGOR *PKCS5_pbkdf2_set(int iter, unsigned char *salt, int saltlen,\n                             int prf_nid, int keylen);\n\n/* PKCS#8 utilities */\n\nDECLARE_ASN1_FUNCTIONS(PKCS8_PRIV_KEY_INFO)\n\nEVP_PKEY *EVP_PKCS82PKEY(const PKCS8_PRIV_KEY_INFO *p8);\nPKCS8_PRIV_KEY_INFO *EVP_PKEY2PKCS8(EVP_PKEY *pkey);\n\nint PKCS8_pkey_set0(PKCS8_PRIV_KEY_INFO *priv, ASN1_OBJECT *aobj,\n                    int version, int ptype, void *pval,\n                    unsigned char *penc, int penclen);\nint PKCS8_pkey_get0(const ASN1_OBJECT **ppkalg,\n                    const unsigned char **pk, int *ppklen,\n                    const X509_ALGOR **pa, const PKCS8_PRIV_KEY_INFO *p8);\n\nconst STACK_OF(X509_ATTRIBUTE) *\nPKCS8_pkey_get0_attrs(const PKCS8_PRIV_KEY_INFO *p8);\nint PKCS8_pkey_add1_attr_by_NID(PKCS8_PRIV_KEY_INFO *p8, int nid, int type,\n                                const unsigned char *bytes, int len);\n\nint X509_PUBKEY_set0_param(X509_PUBKEY *pub, ASN1_OBJECT *aobj,\n                           int ptype, void *pval,\n                           unsigned char *penc, int penclen);\nint X509_PUBKEY_get0_param(ASN1_OBJECT **ppkalg,\n                           const unsigned char **pk, int *ppklen,\n                           X509_ALGOR **pa, X509_PUBKEY *pub);\n\nint X509_check_trust(X509 *x, int id, int flags);\nint X509_TRUST_get_count(void);\nX509_TRUST *X509_TRUST_get0(int idx);\nint X509_TRUST_get_by_id(int id);\nint X509_TRUST_add(int id, int flags, int (*ck) (X509_TRUST *, X509 *, int),\n                   const char *name, int arg1, void *arg2);\nvoid X509_TRUST_cleanup(void);\nint X509_TRUST_get_flags(const X509_TRUST *xp);\nchar *X509_TRUST_get0_name(const X509_TRUST *xp);\nint X509_TRUST_get_trust(const X509_TRUST *xp);\n\n# ifdef  __cplusplus\n}\n# endif\n#endif\n"}, "17": {"id": 17, "path": "/usr/include/openssl/lhash.h", "content": "/*\n * Copyright 1995-2020 The OpenSSL Project Authors. All Rights Reserved.\n *\n * Licensed under the OpenSSL license (the \"License\").  You may not use\n * this file except in compliance with the License.  You can obtain a copy\n * in the file LICENSE in the source distribution or at\n * https://www.openssl.org/source/license.html\n */\n\n/*\n * Header for dynamic hash table routines Author - Eric Young\n */\n\n#ifndef HEADER_LHASH_H\n# define HEADER_LHASH_H\n\n# include <openssl/e_os2.h>\n# include <openssl/bio.h>\n\n#ifdef  __cplusplus\nextern \"C\" {\n#endif\n\ntypedef struct lhash_node_st OPENSSL_LH_NODE;\ntypedef int (*OPENSSL_LH_COMPFUNC) (const void *, const void *);\ntypedef unsigned long (*OPENSSL_LH_HASHFUNC) (const void *);\ntypedef void (*OPENSSL_LH_DOALL_FUNC) (void *);\ntypedef void (*OPENSSL_LH_DOALL_FUNCARG) (void *, void *);\ntypedef struct lhash_st OPENSSL_LHASH;\n\n/*\n * Macros for declaring and implementing type-safe wrappers for LHASH\n * callbacks. This way, callbacks can be provided to LHASH structures without\n * function pointer casting and the macro-defined callbacks provide\n * per-variable casting before deferring to the underlying type-specific\n * callbacks. NB: It is possible to place a \"static\" in front of both the\n * DECLARE and IMPLEMENT macros if the functions are strictly internal.\n */\n\n/* First: \"hash\" functions */\n# define DECLARE_LHASH_HASH_FN(name, o_type) \\\n        unsigned long name##_LHASH_HASH(const void *);\n# define IMPLEMENT_LHASH_HASH_FN(name, o_type) \\\n        unsigned long name##_LHASH_HASH(const void *arg) { \\\n                const o_type *a = arg; \\\n                return name##_hash(a); }\n# define LHASH_HASH_FN(name) name##_LHASH_HASH\n\n/* Second: \"compare\" functions */\n# define DECLARE_LHASH_COMP_FN(name, o_type) \\\n        int name##_LHASH_COMP(const void *, const void *);\n# define IMPLEMENT_LHASH_COMP_FN(name, o_type) \\\n        int name##_LHASH_COMP(const void *arg1, const void *arg2) { \\\n                const o_type *a = arg1;             \\\n                const o_type *b = arg2; \\\n                return name##_cmp(a,b); }\n# define LHASH_COMP_FN(name) name##_LHASH_COMP\n\n/* Fourth: \"doall_arg\" functions */\n# define DECLARE_LHASH_DOALL_ARG_FN(name, o_type, a_type) \\\n        void name##_LHASH_DOALL_ARG(void *, void *);\n# define IMPLEMENT_LHASH_DOALL_ARG_FN(name, o_type, a_type) \\\n        void name##_LHASH_DOALL_ARG(void *arg1, void *arg2) { \\\n                o_type *a = arg1; \\\n                a_type *b = arg2; \\\n                name##_doall_arg(a, b); }\n# define LHASH_DOALL_ARG_FN(name) name##_LHASH_DOALL_ARG\n\n\n# define LH_LOAD_MULT    256\n\nint OPENSSL_LH_error(OPENSSL_LHASH *lh);\nOPENSSL_LHASH *OPENSSL_LH_new(OPENSSL_LH_HASHFUNC h, OPENSSL_LH_COMPFUNC c);\nvoid OPENSSL_LH_free(OPENSSL_LHASH *lh);\nvoid *OPENSSL_LH_insert(OPENSSL_LHASH *lh, void *data);\nvoid *OPENSSL_LH_delete(OPENSSL_LHASH *lh, const void *data);\nvoid *OPENSSL_LH_retrieve(OPENSSL_LHASH *lh, const void *data);\nvoid OPENSSL_LH_doall(OPENSSL_LHASH *lh, OPENSSL_LH_DOALL_FUNC func);\nvoid OPENSSL_LH_doall_arg(OPENSSL_LHASH *lh, OPENSSL_LH_DOALL_FUNCARG func, void *arg);\nunsigned long OPENSSL_LH_strhash(const char *c);\nunsigned long OPENSSL_LH_num_items(const OPENSSL_LHASH *lh);\nunsigned long OPENSSL_LH_get_down_load(const OPENSSL_LHASH *lh);\nvoid OPENSSL_LH_set_down_load(OPENSSL_LHASH *lh, unsigned long down_load);\n\n# ifndef OPENSSL_NO_STDIO\nvoid OPENSSL_LH_stats(const OPENSSL_LHASH *lh, FILE *fp);\nvoid OPENSSL_LH_node_stats(const OPENSSL_LHASH *lh, FILE *fp);\nvoid OPENSSL_LH_node_usage_stats(const OPENSSL_LHASH *lh, FILE *fp);\n# endif\nvoid OPENSSL_LH_stats_bio(const OPENSSL_LHASH *lh, BIO *out);\nvoid OPENSSL_LH_node_stats_bio(const OPENSSL_LHASH *lh, BIO *out);\nvoid OPENSSL_LH_node_usage_stats_bio(const OPENSSL_LHASH *lh, BIO *out);\n\n# if OPENSSL_API_COMPAT < 0x10100000L\n#  define _LHASH OPENSSL_LHASH\n#  define LHASH_NODE OPENSSL_LH_NODE\n#  define lh_error OPENSSL_LH_error\n#  define lh_new OPENSSL_LH_new\n#  define lh_free OPENSSL_LH_free\n#  define lh_insert OPENSSL_LH_insert\n#  define lh_delete OPENSSL_LH_delete\n#  define lh_retrieve OPENSSL_LH_retrieve\n#  define lh_doall OPENSSL_LH_doall\n#  define lh_doall_arg OPENSSL_LH_doall_arg\n#  define lh_strhash OPENSSL_LH_strhash\n#  define lh_num_items OPENSSL_LH_num_items\n#  ifndef OPENSSL_NO_STDIO\n#   define lh_stats OPENSSL_LH_stats\n#   define lh_node_stats OPENSSL_LH_node_stats\n#   define lh_node_usage_stats OPENSSL_LH_node_usage_stats\n#  endif\n#  define lh_stats_bio OPENSSL_LH_stats_bio\n#  define lh_node_stats_bio OPENSSL_LH_node_stats_bio\n#  define lh_node_usage_stats_bio OPENSSL_LH_node_usage_stats_bio\n# endif\n\n/* Type checking... */\n\n# define LHASH_OF(type) struct lhash_st_##type\n\n# define DEFINE_LHASH_OF(type) \\\n    LHASH_OF(type) { union lh_##type##_dummy { void* d1; unsigned long d2; int d3; } dummy; }; \\\n    static ossl_unused ossl_inline LHASH_OF(type) *lh_##type##_new(unsigned long (*hfn)(const type *), \\\n                                                                   int (*cfn)(const type *, const type *)) \\\n    { \\\n        return (LHASH_OF(type) *) \\\n            OPENSSL_LH_new((OPENSSL_LH_HASHFUNC)hfn, (OPENSSL_LH_COMPFUNC)cfn); \\\n    } \\\n    static ossl_unused ossl_inline void lh_##type##_free(LHASH_OF(type) *lh) \\\n    { \\\n        OPENSSL_LH_free((OPENSSL_LHASH *)lh); \\\n    } \\\n    static ossl_unused ossl_inline type *lh_##type##_insert(LHASH_OF(type) *lh, type *d) \\\n    { \\\n        return (type *)OPENSSL_LH_insert((OPENSSL_LHASH *)lh, d); \\\n    } \\\n    static ossl_unused ossl_inline type *lh_##type##_delete(LHASH_OF(type) *lh, const type *d) \\\n    { \\\n        return (type *)OPENSSL_LH_delete((OPENSSL_LHASH *)lh, d); \\\n    } \\\n    static ossl_unused ossl_inline type *lh_##type##_retrieve(LHASH_OF(type) *lh, const type *d) \\\n    { \\\n        return (type *)OPENSSL_LH_retrieve((OPENSSL_LHASH *)lh, d); \\\n    } \\\n    static ossl_unused ossl_inline int lh_##type##_error(LHASH_OF(type) *lh) \\\n    { \\\n        return OPENSSL_LH_error((OPENSSL_LHASH *)lh); \\\n    } \\\n    static ossl_unused ossl_inline unsigned long lh_##type##_num_items(LHASH_OF(type) *lh) \\\n    { \\\n        return OPENSSL_LH_num_items((OPENSSL_LHASH *)lh); \\\n    } \\\n    static ossl_unused ossl_inline void lh_##type##_node_stats_bio(const LHASH_OF(type) *lh, BIO *out) \\\n    { \\\n        OPENSSL_LH_node_stats_bio((const OPENSSL_LHASH *)lh, out); \\\n    } \\\n    static ossl_unused ossl_inline void lh_##type##_node_usage_stats_bio(const LHASH_OF(type) *lh, BIO *out) \\\n    { \\\n        OPENSSL_LH_node_usage_stats_bio((const OPENSSL_LHASH *)lh, out); \\\n    } \\\n    static ossl_unused ossl_inline void lh_##type##_stats_bio(const LHASH_OF(type) *lh, BIO *out) \\\n    { \\\n        OPENSSL_LH_stats_bio((const OPENSSL_LHASH *)lh, out); \\\n    } \\\n    static ossl_unused ossl_inline unsigned long lh_##type##_get_down_load(LHASH_OF(type) *lh) \\\n    { \\\n        return OPENSSL_LH_get_down_load((OPENSSL_LHASH *)lh); \\\n    } \\\n    static ossl_unused ossl_inline void lh_##type##_set_down_load(LHASH_OF(type) *lh, unsigned long dl) \\\n    { \\\n        OPENSSL_LH_set_down_load((OPENSSL_LHASH *)lh, dl); \\\n    } \\\n    static ossl_unused ossl_inline void lh_##type##_doall(LHASH_OF(type) *lh, \\\n                                                          void (*doall)(type *)) \\\n    { \\\n        OPENSSL_LH_doall((OPENSSL_LHASH *)lh, (OPENSSL_LH_DOALL_FUNC)doall); \\\n    } \\\n    LHASH_OF(type)\n\n#define IMPLEMENT_LHASH_DOALL_ARG_CONST(type, argtype) \\\n    int_implement_lhash_doall(type, argtype, const type)\n\n#define IMPLEMENT_LHASH_DOALL_ARG(type, argtype) \\\n    int_implement_lhash_doall(type, argtype, type)\n\n#define int_implement_lhash_doall(type, argtype, cbargtype) \\\n    static ossl_unused ossl_inline void \\\n        lh_##type##_doall_##argtype(LHASH_OF(type) *lh, \\\n                                   void (*fn)(cbargtype *, argtype *), \\\n                                   argtype *arg) \\\n    { \\\n        OPENSSL_LH_doall_arg((OPENSSL_LHASH *)lh, (OPENSSL_LH_DOALL_FUNCARG)fn, (void *)arg); \\\n    } \\\n    LHASH_OF(type)\n\nDEFINE_LHASH_OF(OPENSSL_STRING);\n# ifdef _MSC_VER\n/*\n * push and pop this warning:\n *   warning C4090: 'function': different 'const' qualifiers\n */\n#  pragma warning (push)\n#  pragma warning (disable: 4090)\n# endif\n\nDEFINE_LHASH_OF(OPENSSL_CSTRING);\n\n# ifdef _MSC_VER\n#  pragma warning (pop)\n# endif\n\n/*\n * If called without higher optimization (min. -xO3) the Oracle Developer\n * Studio compiler generates code for the defined (static inline) functions\n * above.\n * This would later lead to the linker complaining about missing symbols when\n * this header file is included but the resulting object is not linked against\n * the Crypto library (openssl#6912).\n */\n# ifdef __SUNPRO_C\n#  pragma weak OPENSSL_LH_new\n#  pragma weak OPENSSL_LH_free\n#  pragma weak OPENSSL_LH_insert\n#  pragma weak OPENSSL_LH_delete\n#  pragma weak OPENSSL_LH_retrieve\n#  pragma weak OPENSSL_LH_error\n#  pragma weak OPENSSL_LH_num_items\n#  pragma weak OPENSSL_LH_node_stats_bio\n#  pragma weak OPENSSL_LH_node_usage_stats_bio\n#  pragma weak OPENSSL_LH_stats_bio\n#  pragma weak OPENSSL_LH_get_down_load\n#  pragma weak OPENSSL_LH_set_down_load\n#  pragma weak OPENSSL_LH_doall\n#  pragma weak OPENSSL_LH_doall_arg\n# endif /* __SUNPRO_C */\n\n#ifdef  __cplusplus\n}\n#endif\n\n#endif\n"}, "18": {"id": 18, "path": "/usr/include/openssl/x509_vfy.h", "content": "/*\n * Copyright 1995-2019 The OpenSSL Project Authors. All Rights Reserved.\n *\n * Licensed under the OpenSSL license (the \"License\").  You may not use\n * this file except in compliance with the License.  You can obtain a copy\n * in the file LICENSE in the source distribution or at\n * https://www.openssl.org/source/license.html\n */\n\n#ifndef HEADER_X509_VFY_H\n# define HEADER_X509_VFY_H\n\n/*\n * Protect against recursion, x509.h and x509_vfy.h each include the other.\n */\n# ifndef HEADER_X509_H\n#  include <openssl/x509.h>\n# endif\n\n# include <openssl/opensslconf.h>\n# include <openssl/lhash.h>\n# include <openssl/bio.h>\n# include <openssl/crypto.h>\n# include <openssl/symhacks.h>\n\n#ifdef  __cplusplus\nextern \"C\" {\n#endif\n\n/*-\nSSL_CTX -> X509_STORE\n                -> X509_LOOKUP\n                        ->X509_LOOKUP_METHOD\n                -> X509_LOOKUP\n                        ->X509_LOOKUP_METHOD\n\nSSL     -> X509_STORE_CTX\n                ->X509_STORE\n\nThe X509_STORE holds the tables etc for verification stuff.\nA X509_STORE_CTX is used while validating a single certificate.\nThe X509_STORE has X509_LOOKUPs for looking up certs.\nThe X509_STORE then calls a function to actually verify the\ncertificate chain.\n*/\n\ntypedef enum {\n    X509_LU_NONE = 0,\n    X509_LU_X509, X509_LU_CRL\n} X509_LOOKUP_TYPE;\n\n#if OPENSSL_API_COMPAT < 0x10100000L\n#define X509_LU_RETRY   -1\n#define X509_LU_FAIL    0\n#endif\n\nDEFINE_STACK_OF(X509_LOOKUP)\nDEFINE_STACK_OF(X509_OBJECT)\nDEFINE_STACK_OF(X509_VERIFY_PARAM)\n\nint X509_STORE_set_depth(X509_STORE *store, int depth);\n\ntypedef int (*X509_STORE_CTX_verify_cb)(int, X509_STORE_CTX *);\ntypedef int (*X509_STORE_CTX_verify_fn)(X509_STORE_CTX *);\ntypedef int (*X509_STORE_CTX_get_issuer_fn)(X509 **issuer,\n                                            X509_STORE_CTX *ctx, X509 *x);\ntypedef int (*X509_STORE_CTX_check_issued_fn)(X509_STORE_CTX *ctx,\n                                              X509 *x, X509 *issuer);\ntypedef int (*X509_STORE_CTX_check_revocation_fn)(X509_STORE_CTX *ctx);\ntypedef int (*X509_STORE_CTX_get_crl_fn)(X509_STORE_CTX *ctx,\n                                         X509_CRL **crl, X509 *x);\ntypedef int (*X509_STORE_CTX_check_crl_fn)(X509_STORE_CTX *ctx, X509_CRL *crl);\ntypedef int (*X509_STORE_CTX_cert_crl_fn)(X509_STORE_CTX *ctx,\n                                          X509_CRL *crl, X509 *x);\ntypedef int (*X509_STORE_CTX_check_policy_fn)(X509_STORE_CTX *ctx);\ntypedef STACK_OF(X509) *(*X509_STORE_CTX_lookup_certs_fn)(X509_STORE_CTX *ctx,\n                                                          X509_NAME *nm);\ntypedef STACK_OF(X509_CRL) *(*X509_STORE_CTX_lookup_crls_fn)(X509_STORE_CTX *ctx,\n                                                             X509_NAME *nm);\ntypedef int (*X509_STORE_CTX_cleanup_fn)(X509_STORE_CTX *ctx);\n\n\nvoid X509_STORE_CTX_set_depth(X509_STORE_CTX *ctx, int depth);\n\n# define X509_STORE_CTX_set_app_data(ctx,data) \\\n        X509_STORE_CTX_set_ex_data(ctx,0,data)\n# define X509_STORE_CTX_get_app_data(ctx) \\\n        X509_STORE_CTX_get_ex_data(ctx,0)\n\n# define X509_L_FILE_LOAD        1\n# define X509_L_ADD_DIR          2\n\n# define X509_LOOKUP_load_file(x,name,type) \\\n                X509_LOOKUP_ctrl((x),X509_L_FILE_LOAD,(name),(long)(type),NULL)\n\n# define X509_LOOKUP_add_dir(x,name,type) \\\n                X509_LOOKUP_ctrl((x),X509_L_ADD_DIR,(name),(long)(type),NULL)\n\n# define         X509_V_OK                                       0\n# define         X509_V_ERR_UNSPECIFIED                          1\n# define         X509_V_ERR_UNABLE_TO_GET_ISSUER_CERT            2\n# define         X509_V_ERR_UNABLE_TO_GET_CRL                    3\n# define         X509_V_ERR_UNABLE_TO_DECRYPT_CERT_SIGNATURE     4\n# define         X509_V_ERR_UNABLE_TO_DECRYPT_CRL_SIGNATURE      5\n# define         X509_V_ERR_UNABLE_TO_DECODE_ISSUER_PUBLIC_KEY   6\n# define         X509_V_ERR_CERT_SIGNATURE_FAILURE               7\n# define         X509_V_ERR_CRL_SIGNATURE_FAILURE                8\n# define         X509_V_ERR_CERT_NOT_YET_VALID                   9\n# define         X509_V_ERR_CERT_HAS_EXPIRED                     10\n# define         X509_V_ERR_CRL_NOT_YET_VALID                    11\n# define         X509_V_ERR_CRL_HAS_EXPIRED                      12\n# define         X509_V_ERR_ERROR_IN_CERT_NOT_BEFORE_FIELD       13\n# define         X509_V_ERR_ERROR_IN_CERT_NOT_AFTER_FIELD        14\n# define         X509_V_ERR_ERROR_IN_CRL_LAST_UPDATE_FIELD       15\n# define         X509_V_ERR_ERROR_IN_CRL_NEXT_UPDATE_FIELD       16\n# define         X509_V_ERR_OUT_OF_MEM                           17\n# define         X509_V_ERR_DEPTH_ZERO_SELF_SIGNED_CERT          18\n# define         X509_V_ERR_SELF_SIGNED_CERT_IN_CHAIN            19\n# define         X509_V_ERR_UNABLE_TO_GET_ISSUER_CERT_LOCALLY    20\n# define         X509_V_ERR_UNABLE_TO_VERIFY_LEAF_SIGNATURE      21\n# define         X509_V_ERR_CERT_CHAIN_TOO_LONG                  22\n# define         X509_V_ERR_CERT_REVOKED                         23\n# define         X509_V_ERR_INVALID_CA                           24\n# define         X509_V_ERR_PATH_LENGTH_EXCEEDED                 25\n# define         X509_V_ERR_INVALID_PURPOSE                      26\n# define         X509_V_ERR_CERT_UNTRUSTED                       27\n# define         X509_V_ERR_CERT_REJECTED                        28\n/* These are 'informational' when looking for issuer cert */\n# define         X509_V_ERR_SUBJECT_ISSUER_MISMATCH              29\n# define         X509_V_ERR_AKID_SKID_MISMATCH                   30\n# define         X509_V_ERR_AKID_ISSUER_SERIAL_MISMATCH          31\n# define         X509_V_ERR_KEYUSAGE_NO_CERTSIGN                 32\n# define         X509_V_ERR_UNABLE_TO_GET_CRL_ISSUER             33\n# define         X509_V_ERR_UNHANDLED_CRITICAL_EXTENSION         34\n# define         X509_V_ERR_KEYUSAGE_NO_CRL_SIGN                 35\n# define         X509_V_ERR_UNHANDLED_CRITICAL_CRL_EXTENSION     36\n# define         X509_V_ERR_INVALID_NON_CA                       37\n# define         X509_V_ERR_PROXY_PATH_LENGTH_EXCEEDED           38\n# define         X509_V_ERR_KEYUSAGE_NO_DIGITAL_SIGNATURE        39\n# define         X509_V_ERR_PROXY_CERTIFICATES_NOT_ALLOWED       40\n# define         X509_V_ERR_INVALID_EXTENSION                    41\n# define         X509_V_ERR_INVALID_POLICY_EXTENSION             42\n# define         X509_V_ERR_NO_EXPLICIT_POLICY                   43\n# define         X509_V_ERR_DIFFERENT_CRL_SCOPE                  44\n# define         X509_V_ERR_UNSUPPORTED_EXTENSION_FEATURE        45\n# define         X509_V_ERR_UNNESTED_RESOURCE                    46\n# define         X509_V_ERR_PERMITTED_VIOLATION                  47\n# define         X509_V_ERR_EXCLUDED_VIOLATION                   48\n# define         X509_V_ERR_SUBTREE_MINMAX                       49\n/* The application is not happy */\n# define         X509_V_ERR_APPLICATION_VERIFICATION             50\n# define         X509_V_ERR_UNSUPPORTED_CONSTRAINT_TYPE          51\n# define         X509_V_ERR_UNSUPPORTED_CONSTRAINT_SYNTAX        52\n# define         X509_V_ERR_UNSUPPORTED_NAME_SYNTAX              53\n# define         X509_V_ERR_CRL_PATH_VALIDATION_ERROR            54\n/* Another issuer check debug option */\n# define         X509_V_ERR_PATH_LOOP                            55\n/* Suite B mode algorithm violation */\n# define         X509_V_ERR_SUITE_B_INVALID_VERSION              56\n# define         X509_V_ERR_SUITE_B_INVALID_ALGORITHM            57\n# define         X509_V_ERR_SUITE_B_INVALID_CURVE                58\n# define         X509_V_ERR_SUITE_B_INVALID_SIGNATURE_ALGORITHM  59\n# define         X509_V_ERR_SUITE_B_LOS_NOT_ALLOWED              60\n# define         X509_V_ERR_SUITE_B_CANNOT_SIGN_P_384_WITH_P_256 61\n/* Host, email and IP check errors */\n# define         X509_V_ERR_HOSTNAME_MISMATCH                    62\n# define         X509_V_ERR_EMAIL_MISMATCH                       63\n# define         X509_V_ERR_IP_ADDRESS_MISMATCH                  64\n/* DANE TLSA errors */\n# define         X509_V_ERR_DANE_NO_MATCH                        65\n/* security level errors */\n# define         X509_V_ERR_EE_KEY_TOO_SMALL                     66\n# define         X509_V_ERR_CA_KEY_TOO_SMALL                     67\n# define         X509_V_ERR_CA_MD_TOO_WEAK                       68\n/* Caller error */\n# define         X509_V_ERR_INVALID_CALL                         69\n/* Issuer lookup error */\n# define         X509_V_ERR_STORE_LOOKUP                         70\n/* Certificate transparency */\n# define         X509_V_ERR_NO_VALID_SCTS                        71\n\n# define         X509_V_ERR_PROXY_SUBJECT_NAME_VIOLATION         72\n/* OCSP status errors */\n# define         X509_V_ERR_OCSP_VERIFY_NEEDED                   73  /* Need OCSP verification */\n# define         X509_V_ERR_OCSP_VERIFY_FAILED                   74  /* Couldn't verify cert through OCSP */\n# define         X509_V_ERR_OCSP_CERT_UNKNOWN                    75  /* Certificate wasn't recognized by the OCSP responder */\n\n/* Certificate verify flags */\n\n# if OPENSSL_API_COMPAT < 0x10100000L\n#  define X509_V_FLAG_CB_ISSUER_CHECK             0x0   /* Deprecated */\n# endif\n/* Use check time instead of current time */\n# define X509_V_FLAG_USE_CHECK_TIME              0x2\n/* Lookup CRLs */\n# define X509_V_FLAG_CRL_CHECK                   0x4\n/* Lookup CRLs for whole chain */\n# define X509_V_FLAG_CRL_CHECK_ALL               0x8\n/* Ignore unhandled critical extensions */\n# define X509_V_FLAG_IGNORE_CRITICAL             0x10\n/* Disable workarounds for broken certificates */\n# define X509_V_FLAG_X509_STRICT                 0x20\n/* Enable proxy certificate validation */\n# define X509_V_FLAG_ALLOW_PROXY_CERTS           0x40\n/* Enable policy checking */\n# define X509_V_FLAG_POLICY_CHECK                0x80\n/* Policy variable require-explicit-policy */\n# define X509_V_FLAG_EXPLICIT_POLICY             0x100\n/* Policy variable inhibit-any-policy */\n# define X509_V_FLAG_INHIBIT_ANY                 0x200\n/* Policy variable inhibit-policy-mapping */\n# define X509_V_FLAG_INHIBIT_MAP                 0x400\n/* Notify callback that policy is OK */\n# define X509_V_FLAG_NOTIFY_POLICY               0x800\n/* Extended CRL features such as indirect CRLs, alternate CRL signing keys */\n# define X509_V_FLAG_EXTENDED_CRL_SUPPORT        0x1000\n/* Delta CRL support */\n# define X509_V_FLAG_USE_DELTAS                  0x2000\n/* Check self-signed CA signature */\n# define X509_V_FLAG_CHECK_SS_SIGNATURE          0x4000\n/* Use trusted store first */\n# define X509_V_FLAG_TRUSTED_FIRST               0x8000\n/* Suite B 128 bit only mode: not normally used */\n# define X509_V_FLAG_SUITEB_128_LOS_ONLY         0x10000\n/* Suite B 192 bit only mode */\n# define X509_V_FLAG_SUITEB_192_LOS              0x20000\n/* Suite B 128 bit mode allowing 192 bit algorithms */\n# define X509_V_FLAG_SUITEB_128_LOS              0x30000\n/* Allow partial chains if at least one certificate is in trusted store */\n# define X509_V_FLAG_PARTIAL_CHAIN               0x80000\n/*\n * If the initial chain is not trusted, do not attempt to build an alternative\n * chain. Alternate chain checking was introduced in 1.1.0. Setting this flag\n * will force the behaviour to match that of previous versions.\n */\n# define X509_V_FLAG_NO_ALT_CHAINS               0x100000\n/* Do not check certificate/CRL validity against current time */\n# define X509_V_FLAG_NO_CHECK_TIME               0x200000\n\n# define X509_VP_FLAG_DEFAULT                    0x1\n# define X509_VP_FLAG_OVERWRITE                  0x2\n# define X509_VP_FLAG_RESET_FLAGS                0x4\n# define X509_VP_FLAG_LOCKED                     0x8\n# define X509_VP_FLAG_ONCE                       0x10\n\n/* Internal use: mask of policy related options */\n# define X509_V_FLAG_POLICY_MASK (X509_V_FLAG_POLICY_CHECK \\\n                                | X509_V_FLAG_EXPLICIT_POLICY \\\n                                | X509_V_FLAG_INHIBIT_ANY \\\n                                | X509_V_FLAG_INHIBIT_MAP)\n\nint X509_OBJECT_idx_by_subject(STACK_OF(X509_OBJECT) *h, X509_LOOKUP_TYPE type,\n                               X509_NAME *name);\nX509_OBJECT *X509_OBJECT_retrieve_by_subject(STACK_OF(X509_OBJECT) *h,\n                                             X509_LOOKUP_TYPE type,\n                                             X509_NAME *name);\nX509_OBJECT *X509_OBJECT_retrieve_match(STACK_OF(X509_OBJECT) *h,\n                                        X509_OBJECT *x);\nint X509_OBJECT_up_ref_count(X509_OBJECT *a);\nX509_OBJECT *X509_OBJECT_new(void);\nvoid X509_OBJECT_free(X509_OBJECT *a);\nX509_LOOKUP_TYPE X509_OBJECT_get_type(const X509_OBJECT *a);\nX509 *X509_OBJECT_get0_X509(const X509_OBJECT *a);\nint X509_OBJECT_set1_X509(X509_OBJECT *a, X509 *obj);\nX509_CRL *X509_OBJECT_get0_X509_CRL(X509_OBJECT *a);\nint X509_OBJECT_set1_X509_CRL(X509_OBJECT *a, X509_CRL *obj);\nX509_STORE *X509_STORE_new(void);\nvoid X509_STORE_free(X509_STORE *v);\nint X509_STORE_lock(X509_STORE *ctx);\nint X509_STORE_unlock(X509_STORE *ctx);\nint X509_STORE_up_ref(X509_STORE *v);\nSTACK_OF(X509_OBJECT) *X509_STORE_get0_objects(X509_STORE *v);\n\nSTACK_OF(X509) *X509_STORE_CTX_get1_certs(X509_STORE_CTX *st, X509_NAME *nm);\nSTACK_OF(X509_CRL) *X509_STORE_CTX_get1_crls(X509_STORE_CTX *st, X509_NAME *nm);\nint X509_STORE_set_flags(X509_STORE *ctx, unsigned long flags);\nint X509_STORE_set_purpose(X509_STORE *ctx, int purpose);\nint X509_STORE_set_trust(X509_STORE *ctx, int trust);\nint X509_STORE_set1_param(X509_STORE *ctx, X509_VERIFY_PARAM *pm);\nX509_VERIFY_PARAM *X509_STORE_get0_param(X509_STORE *ctx);\n\nvoid X509_STORE_set_verify(X509_STORE *ctx, X509_STORE_CTX_verify_fn verify);\n#define X509_STORE_set_verify_func(ctx, func) \\\n            X509_STORE_set_verify((ctx),(func))\nvoid X509_STORE_CTX_set_verify(X509_STORE_CTX *ctx,\n                               X509_STORE_CTX_verify_fn verify);\nX509_STORE_CTX_verify_fn X509_STORE_get_verify(X509_STORE *ctx);\nvoid X509_STORE_set_verify_cb(X509_STORE *ctx,\n                              X509_STORE_CTX_verify_cb verify_cb);\n# define X509_STORE_set_verify_cb_func(ctx,func) \\\n            X509_STORE_set_verify_cb((ctx),(func))\nX509_STORE_CTX_verify_cb X509_STORE_get_verify_cb(X509_STORE *ctx);\nvoid X509_STORE_set_get_issuer(X509_STORE *ctx,\n                               X509_STORE_CTX_get_issuer_fn get_issuer);\nX509_STORE_CTX_get_issuer_fn X509_STORE_get_get_issuer(X509_STORE *ctx);\nvoid X509_STORE_set_check_issued(X509_STORE *ctx,\n                                 X509_STORE_CTX_check_issued_fn check_issued);\nX509_STORE_CTX_check_issued_fn X509_STORE_get_check_issued(X509_STORE *ctx);\nvoid X509_STORE_set_check_revocation(X509_STORE *ctx,\n                                     X509_STORE_CTX_check_revocation_fn check_revocation);\nX509_STORE_CTX_check_revocation_fn X509_STORE_get_check_revocation(X509_STORE *ctx);\nvoid X509_STORE_set_get_crl(X509_STORE *ctx,\n                            X509_STORE_CTX_get_crl_fn get_crl);\nX509_STORE_CTX_get_crl_fn X509_STORE_get_get_crl(X509_STORE *ctx);\nvoid X509_STORE_set_check_crl(X509_STORE *ctx,\n                              X509_STORE_CTX_check_crl_fn check_crl);\nX509_STORE_CTX_check_crl_fn X509_STORE_get_check_crl(X509_STORE *ctx);\nvoid X509_STORE_set_cert_crl(X509_STORE *ctx,\n                             X509_STORE_CTX_cert_crl_fn cert_crl);\nX509_STORE_CTX_cert_crl_fn X509_STORE_get_cert_crl(X509_STORE *ctx);\nvoid X509_STORE_set_check_policy(X509_STORE *ctx,\n                                 X509_STORE_CTX_check_policy_fn check_policy);\nX509_STORE_CTX_check_policy_fn X509_STORE_get_check_policy(X509_STORE *ctx);\nvoid X509_STORE_set_lookup_certs(X509_STORE *ctx,\n                                 X509_STORE_CTX_lookup_certs_fn lookup_certs);\nX509_STORE_CTX_lookup_certs_fn X509_STORE_get_lookup_certs(X509_STORE *ctx);\nvoid X509_STORE_set_lookup_crls(X509_STORE *ctx,\n                                X509_STORE_CTX_lookup_crls_fn lookup_crls);\n#define X509_STORE_set_lookup_crls_cb(ctx, func) \\\n    X509_STORE_set_lookup_crls((ctx), (func))\nX509_STORE_CTX_lookup_crls_fn X509_STORE_get_lookup_crls(X509_STORE *ctx);\nvoid X509_STORE_set_cleanup(X509_STORE *ctx,\n                            X509_STORE_CTX_cleanup_fn cleanup);\nX509_STORE_CTX_cleanup_fn X509_STORE_get_cleanup(X509_STORE *ctx);\n\n#define X509_STORE_get_ex_new_index(l, p, newf, dupf, freef) \\\n    CRYPTO_get_ex_new_index(CRYPTO_EX_INDEX_X509_STORE, l, p, newf, dupf, freef)\nint X509_STORE_set_ex_data(X509_STORE *ctx, int idx, void *data);\nvoid *X509_STORE_get_ex_data(X509_STORE *ctx, int idx);\n\nX509_STORE_CTX *X509_STORE_CTX_new(void);\n\nint X509_STORE_CTX_get1_issuer(X509 **issuer, X509_STORE_CTX *ctx, X509 *x);\n\nvoid X509_STORE_CTX_free(X509_STORE_CTX *ctx);\nint X509_STORE_CTX_init(X509_STORE_CTX *ctx, X509_STORE *store,\n                        X509 *x509, STACK_OF(X509) *chain);\nvoid X509_STORE_CTX_set0_trusted_stack(X509_STORE_CTX *ctx, STACK_OF(X509) *sk);\nvoid X509_STORE_CTX_cleanup(X509_STORE_CTX *ctx);\n\nX509_STORE *X509_STORE_CTX_get0_store(X509_STORE_CTX *ctx);\nX509 *X509_STORE_CTX_get0_cert(X509_STORE_CTX *ctx);\nSTACK_OF(X509)* X509_STORE_CTX_get0_untrusted(X509_STORE_CTX *ctx);\nvoid X509_STORE_CTX_set0_untrusted(X509_STORE_CTX *ctx, STACK_OF(X509) *sk);\nvoid X509_STORE_CTX_set_verify_cb(X509_STORE_CTX *ctx,\n                                  X509_STORE_CTX_verify_cb verify);\nX509_STORE_CTX_verify_cb X509_STORE_CTX_get_verify_cb(X509_STORE_CTX *ctx);\nX509_STORE_CTX_verify_fn X509_STORE_CTX_get_verify(X509_STORE_CTX *ctx);\nX509_STORE_CTX_get_issuer_fn X509_STORE_CTX_get_get_issuer(X509_STORE_CTX *ctx);\nX509_STORE_CTX_check_issued_fn X509_STORE_CTX_get_check_issued(X509_STORE_CTX *ctx);\nX509_STORE_CTX_check_revocation_fn X509_STORE_CTX_get_check_revocation(X509_STORE_CTX *ctx);\nX509_STORE_CTX_get_crl_fn X509_STORE_CTX_get_get_crl(X509_STORE_CTX *ctx);\nX509_STORE_CTX_check_crl_fn X509_STORE_CTX_get_check_crl(X509_STORE_CTX *ctx);\nX509_STORE_CTX_cert_crl_fn X509_STORE_CTX_get_cert_crl(X509_STORE_CTX *ctx);\nX509_STORE_CTX_check_policy_fn X509_STORE_CTX_get_check_policy(X509_STORE_CTX *ctx);\nX509_STORE_CTX_lookup_certs_fn X509_STORE_CTX_get_lookup_certs(X509_STORE_CTX *ctx);\nX509_STORE_CTX_lookup_crls_fn X509_STORE_CTX_get_lookup_crls(X509_STORE_CTX *ctx);\nX509_STORE_CTX_cleanup_fn X509_STORE_CTX_get_cleanup(X509_STORE_CTX *ctx);\n\n#if OPENSSL_API_COMPAT < 0x10100000L\n# define X509_STORE_CTX_get_chain X509_STORE_CTX_get0_chain\n# define X509_STORE_CTX_set_chain X509_STORE_CTX_set0_untrusted\n# define X509_STORE_CTX_trusted_stack X509_STORE_CTX_set0_trusted_stack\n# define X509_STORE_get_by_subject X509_STORE_CTX_get_by_subject\n# define X509_STORE_get1_certs X509_STORE_CTX_get1_certs\n# define X509_STORE_get1_crls X509_STORE_CTX_get1_crls\n/* the following macro is misspelled; use X509_STORE_get1_certs instead */\n# define X509_STORE_get1_cert X509_STORE_CTX_get1_certs\n/* the following macro is misspelled; use X509_STORE_get1_crls instead */\n# define X509_STORE_get1_crl X509_STORE_CTX_get1_crls\n#endif\n\nX509_LOOKUP *X509_STORE_add_lookup(X509_STORE *v, X509_LOOKUP_METHOD *m);\nX509_LOOKUP_METHOD *X509_LOOKUP_hash_dir(void);\nX509_LOOKUP_METHOD *X509_LOOKUP_file(void);\n\ntypedef int (*X509_LOOKUP_ctrl_fn)(X509_LOOKUP *ctx, int cmd, const char *argc,\n                                   long argl, char **ret);\ntypedef int (*X509_LOOKUP_get_by_subject_fn)(X509_LOOKUP *ctx,\n                                             X509_LOOKUP_TYPE type,\n                                             X509_NAME *name,\n                                             X509_OBJECT *ret);\ntypedef int (*X509_LOOKUP_get_by_issuer_serial_fn)(X509_LOOKUP *ctx,\n                                                   X509_LOOKUP_TYPE type,\n                                                   X509_NAME *name,\n                                                   ASN1_INTEGER *serial,\n                                                   X509_OBJECT *ret);\ntypedef int (*X509_LOOKUP_get_by_fingerprint_fn)(X509_LOOKUP *ctx,\n                                                 X509_LOOKUP_TYPE type,\n                                                 const unsigned char* bytes,\n                                                 int len,\n                                                 X509_OBJECT *ret);\ntypedef int (*X509_LOOKUP_get_by_alias_fn)(X509_LOOKUP *ctx,\n                                           X509_LOOKUP_TYPE type,\n                                           const char *str,\n                                           int len,\n                                           X509_OBJECT *ret);\n\nX509_LOOKUP_METHOD *X509_LOOKUP_meth_new(const char *name);\nvoid X509_LOOKUP_meth_free(X509_LOOKUP_METHOD *method);\n\nint X509_LOOKUP_meth_set_new_item(X509_LOOKUP_METHOD *method,\n                                  int (*new_item) (X509_LOOKUP *ctx));\nint (*X509_LOOKUP_meth_get_new_item(const X509_LOOKUP_METHOD* method))\n    (X509_LOOKUP *ctx);\n\nint X509_LOOKUP_meth_set_free(X509_LOOKUP_METHOD *method,\n                              void (*free_fn) (X509_LOOKUP *ctx));\nvoid (*X509_LOOKUP_meth_get_free(const X509_LOOKUP_METHOD* method))\n    (X509_LOOKUP *ctx);\n\nint X509_LOOKUP_meth_set_init(X509_LOOKUP_METHOD *method,\n                              int (*init) (X509_LOOKUP *ctx));\nint (*X509_LOOKUP_meth_get_init(const X509_LOOKUP_METHOD* method))\n    (X509_LOOKUP *ctx);\n\nint X509_LOOKUP_meth_set_shutdown(X509_LOOKUP_METHOD *method,\n                                  int (*shutdown) (X509_LOOKUP *ctx));\nint (*X509_LOOKUP_meth_get_shutdown(const X509_LOOKUP_METHOD* method))\n    (X509_LOOKUP *ctx);\n\nint X509_LOOKUP_meth_set_ctrl(X509_LOOKUP_METHOD *method,\n                              X509_LOOKUP_ctrl_fn ctrl_fn);\nX509_LOOKUP_ctrl_fn X509_LOOKUP_meth_get_ctrl(const X509_LOOKUP_METHOD *method);\n\nint X509_LOOKUP_meth_set_get_by_subject(X509_LOOKUP_METHOD *method,\n                                        X509_LOOKUP_get_by_subject_fn fn);\nX509_LOOKUP_get_by_subject_fn X509_LOOKUP_meth_get_get_by_subject(\n    const X509_LOOKUP_METHOD *method);\n\nint X509_LOOKUP_meth_set_get_by_issuer_serial(X509_LOOKUP_METHOD *method,\n    X509_LOOKUP_get_by_issuer_serial_fn fn);\nX509_LOOKUP_get_by_issuer_serial_fn X509_LOOKUP_meth_get_get_by_issuer_serial(\n    const X509_LOOKUP_METHOD *method);\n\nint X509_LOOKUP_meth_set_get_by_fingerprint(X509_LOOKUP_METHOD *method,\n    X509_LOOKUP_get_by_fingerprint_fn fn);\nX509_LOOKUP_get_by_fingerprint_fn X509_LOOKUP_meth_get_get_by_fingerprint(\n    const X509_LOOKUP_METHOD *method);\n\nint X509_LOOKUP_meth_set_get_by_alias(X509_LOOKUP_METHOD *method,\n                                      X509_LOOKUP_get_by_alias_fn fn);\nX509_LOOKUP_get_by_alias_fn X509_LOOKUP_meth_get_get_by_alias(\n    const X509_LOOKUP_METHOD *method);\n\n\nint X509_STORE_add_cert(X509_STORE *ctx, X509 *x);\nint X509_STORE_add_crl(X509_STORE *ctx, X509_CRL *x);\n\nint X509_STORE_CTX_get_by_subject(X509_STORE_CTX *vs, X509_LOOKUP_TYPE type,\n                                  X509_NAME *name, X509_OBJECT *ret);\nX509_OBJECT *X509_STORE_CTX_get_obj_by_subject(X509_STORE_CTX *vs,\n                                               X509_LOOKUP_TYPE type,\n                                               X509_NAME *name);\n\nint X509_LOOKUP_ctrl(X509_LOOKUP *ctx, int cmd, const char *argc,\n                     long argl, char **ret);\n\nint X509_load_cert_file(X509_LOOKUP *ctx, const char *file, int type);\nint X509_load_crl_file(X509_LOOKUP *ctx, const char *file, int type);\nint X509_load_cert_crl_file(X509_LOOKUP *ctx, const char *file, int type);\n\nX509_LOOKUP *X509_LOOKUP_new(X509_LOOKUP_METHOD *method);\nvoid X509_LOOKUP_free(X509_LOOKUP *ctx);\nint X509_LOOKUP_init(X509_LOOKUP *ctx);\nint X509_LOOKUP_by_subject(X509_LOOKUP *ctx, X509_LOOKUP_TYPE type,\n                           X509_NAME *name, X509_OBJECT *ret);\nint X509_LOOKUP_by_issuer_serial(X509_LOOKUP *ctx, X509_LOOKUP_TYPE type,\n                                 X509_NAME *name, ASN1_INTEGER *serial,\n                                 X509_OBJECT *ret);\nint X509_LOOKUP_by_fingerprint(X509_LOOKUP *ctx, X509_LOOKUP_TYPE type,\n                               const unsigned char *bytes, int len,\n                               X509_OBJECT *ret);\nint X509_LOOKUP_by_alias(X509_LOOKUP *ctx, X509_LOOKUP_TYPE type,\n                         const char *str, int len, X509_OBJECT *ret);\nint X509_LOOKUP_set_method_data(X509_LOOKUP *ctx, void *data);\nvoid *X509_LOOKUP_get_method_data(const X509_LOOKUP *ctx);\nX509_STORE *X509_LOOKUP_get_store(const X509_LOOKUP *ctx);\nint X509_LOOKUP_shutdown(X509_LOOKUP *ctx);\n\nint X509_STORE_load_locations(X509_STORE *ctx,\n                              const char *file, const char *dir);\nint X509_STORE_set_default_paths(X509_STORE *ctx);\n\n#define X509_STORE_CTX_get_ex_new_index(l, p, newf, dupf, freef) \\\n    CRYPTO_get_ex_new_index(CRYPTO_EX_INDEX_X509_STORE_CTX, l, p, newf, dupf, freef)\nint X509_STORE_CTX_set_ex_data(X509_STORE_CTX *ctx, int idx, void *data);\nvoid *X509_STORE_CTX_get_ex_data(X509_STORE_CTX *ctx, int idx);\nint X509_STORE_CTX_get_error(X509_STORE_CTX *ctx);\nvoid X509_STORE_CTX_set_error(X509_STORE_CTX *ctx, int s);\nint X509_STORE_CTX_get_error_depth(X509_STORE_CTX *ctx);\nvoid X509_STORE_CTX_set_error_depth(X509_STORE_CTX *ctx, int depth);\nX509 *X509_STORE_CTX_get_current_cert(X509_STORE_CTX *ctx);\nvoid X509_STORE_CTX_set_current_cert(X509_STORE_CTX *ctx, X509 *x);\nX509 *X509_STORE_CTX_get0_current_issuer(X509_STORE_CTX *ctx);\nX509_CRL *X509_STORE_CTX_get0_current_crl(X509_STORE_CTX *ctx);\nX509_STORE_CTX *X509_STORE_CTX_get0_parent_ctx(X509_STORE_CTX *ctx);\nSTACK_OF(X509) *X509_STORE_CTX_get0_chain(X509_STORE_CTX *ctx);\nSTACK_OF(X509) *X509_STORE_CTX_get1_chain(X509_STORE_CTX *ctx);\nvoid X509_STORE_CTX_set_cert(X509_STORE_CTX *c, X509 *x);\nvoid X509_STORE_CTX_set0_verified_chain(X509_STORE_CTX *c, STACK_OF(X509) *sk);\nvoid X509_STORE_CTX_set0_crls(X509_STORE_CTX *c, STACK_OF(X509_CRL) *sk);\nint X509_STORE_CTX_set_purpose(X509_STORE_CTX *ctx, int purpose);\nint X509_STORE_CTX_set_trust(X509_STORE_CTX *ctx, int trust);\nint X509_STORE_CTX_purpose_inherit(X509_STORE_CTX *ctx, int def_purpose,\n                                   int purpose, int trust);\nvoid X509_STORE_CTX_set_flags(X509_STORE_CTX *ctx, unsigned long flags);\nvoid X509_STORE_CTX_set_time(X509_STORE_CTX *ctx, unsigned long flags,\n                             time_t t);\n\nX509_POLICY_TREE *X509_STORE_CTX_get0_policy_tree(X509_STORE_CTX *ctx);\nint X509_STORE_CTX_get_explicit_policy(X509_STORE_CTX *ctx);\nint X509_STORE_CTX_get_num_untrusted(X509_STORE_CTX *ctx);\n\nX509_VERIFY_PARAM *X509_STORE_CTX_get0_param(X509_STORE_CTX *ctx);\nvoid X509_STORE_CTX_set0_param(X509_STORE_CTX *ctx, X509_VERIFY_PARAM *param);\nint X509_STORE_CTX_set_default(X509_STORE_CTX *ctx, const char *name);\n\n/*\n * Bridge opacity barrier between libcrypt and libssl, also needed to support\n * offline testing in test/danetest.c\n */\nvoid X509_STORE_CTX_set0_dane(X509_STORE_CTX *ctx, SSL_DANE *dane);\n#define DANE_FLAG_NO_DANE_EE_NAMECHECKS (1L << 0)\n\n/* X509_VERIFY_PARAM functions */\n\nX509_VERIFY_PARAM *X509_VERIFY_PARAM_new(void);\nvoid X509_VERIFY_PARAM_free(X509_VERIFY_PARAM *param);\nint X509_VERIFY_PARAM_inherit(X509_VERIFY_PARAM *to,\n                              const X509_VERIFY_PARAM *from);\nint X509_VERIFY_PARAM_set1(X509_VERIFY_PARAM *to,\n                           const X509_VERIFY_PARAM *from);\nint X509_VERIFY_PARAM_set1_name(X509_VERIFY_PARAM *param, const char *name);\nint X509_VERIFY_PARAM_set_flags(X509_VERIFY_PARAM *param,\n                                unsigned long flags);\nint X509_VERIFY_PARAM_clear_flags(X509_VERIFY_PARAM *param,\n                                  unsigned long flags);\nunsigned long X509_VERIFY_PARAM_get_flags(X509_VERIFY_PARAM *param);\nint X509_VERIFY_PARAM_set_purpose(X509_VERIFY_PARAM *param, int purpose);\nint X509_VERIFY_PARAM_set_trust(X509_VERIFY_PARAM *param, int trust);\nvoid X509_VERIFY_PARAM_set_depth(X509_VERIFY_PARAM *param, int depth);\nvoid X509_VERIFY_PARAM_set_auth_level(X509_VERIFY_PARAM *param, int auth_level);\ntime_t X509_VERIFY_PARAM_get_time(const X509_VERIFY_PARAM *param);\nvoid X509_VERIFY_PARAM_set_time(X509_VERIFY_PARAM *param, time_t t);\nint X509_VERIFY_PARAM_add0_policy(X509_VERIFY_PARAM *param,\n                                  ASN1_OBJECT *policy);\nint X509_VERIFY_PARAM_set1_policies(X509_VERIFY_PARAM *param,\n                                    STACK_OF(ASN1_OBJECT) *policies);\n\nint X509_VERIFY_PARAM_set_inh_flags(X509_VERIFY_PARAM *param,\n                                    uint32_t flags);\nuint32_t X509_VERIFY_PARAM_get_inh_flags(const X509_VERIFY_PARAM *param);\n\nint X509_VERIFY_PARAM_set1_host(X509_VERIFY_PARAM *param,\n                                const char *name, size_t namelen);\nint X509_VERIFY_PARAM_add1_host(X509_VERIFY_PARAM *param,\n                                const char *name, size_t namelen);\nvoid X509_VERIFY_PARAM_set_hostflags(X509_VERIFY_PARAM *param,\n                                     unsigned int flags);\nunsigned int X509_VERIFY_PARAM_get_hostflags(const X509_VERIFY_PARAM *param);\nchar *X509_VERIFY_PARAM_get0_peername(X509_VERIFY_PARAM *);\nvoid X509_VERIFY_PARAM_move_peername(X509_VERIFY_PARAM *, X509_VERIFY_PARAM *);\nint X509_VERIFY_PARAM_set1_email(X509_VERIFY_PARAM *param,\n                                 const char *email, size_t emaillen);\nint X509_VERIFY_PARAM_set1_ip(X509_VERIFY_PARAM *param,\n                              const unsigned char *ip, size_t iplen);\nint X509_VERIFY_PARAM_set1_ip_asc(X509_VERIFY_PARAM *param,\n                                  const char *ipasc);\n\nint X509_VERIFY_PARAM_get_depth(const X509_VERIFY_PARAM *param);\nint X509_VERIFY_PARAM_get_auth_level(const X509_VERIFY_PARAM *param);\nconst char *X509_VERIFY_PARAM_get0_name(const X509_VERIFY_PARAM *param);\n\nint X509_VERIFY_PARAM_add0_table(X509_VERIFY_PARAM *param);\nint X509_VERIFY_PARAM_get_count(void);\nconst X509_VERIFY_PARAM *X509_VERIFY_PARAM_get0(int id);\nconst X509_VERIFY_PARAM *X509_VERIFY_PARAM_lookup(const char *name);\nvoid X509_VERIFY_PARAM_table_cleanup(void);\n\n/* Non positive return values are errors */\n#define X509_PCY_TREE_FAILURE  -2 /* Failure to satisfy explicit policy */\n#define X509_PCY_TREE_INVALID  -1 /* Inconsistent or invalid extensions */\n#define X509_PCY_TREE_INTERNAL  0 /* Internal error, most likely malloc */\n\n/*\n * Positive return values form a bit mask, all but the first are internal to\n * the library and don't appear in results from X509_policy_check().\n */\n#define X509_PCY_TREE_VALID     1 /* The policy tree is valid */\n#define X509_PCY_TREE_EMPTY     2 /* The policy tree is empty */\n#define X509_PCY_TREE_EXPLICIT  4 /* Explicit policy required */\n\nint X509_policy_check(X509_POLICY_TREE **ptree, int *pexplicit_policy,\n                      STACK_OF(X509) *certs,\n                      STACK_OF(ASN1_OBJECT) *policy_oids, unsigned int flags);\n\nvoid X509_policy_tree_free(X509_POLICY_TREE *tree);\n\nint X509_policy_tree_level_count(const X509_POLICY_TREE *tree);\nX509_POLICY_LEVEL *X509_policy_tree_get0_level(const X509_POLICY_TREE *tree,\n                                               int i);\n\nSTACK_OF(X509_POLICY_NODE) *X509_policy_tree_get0_policies(const\n                                                           X509_POLICY_TREE\n                                                           *tree);\n\nSTACK_OF(X509_POLICY_NODE) *X509_policy_tree_get0_user_policies(const\n                                                                X509_POLICY_TREE\n                                                                *tree);\n\nint X509_policy_level_node_count(X509_POLICY_LEVEL *level);\n\nX509_POLICY_NODE *X509_policy_level_get0_node(X509_POLICY_LEVEL *level,\n                                              int i);\n\nconst ASN1_OBJECT *X509_policy_node_get0_policy(const X509_POLICY_NODE *node);\n\nSTACK_OF(POLICYQUALINFO) *X509_policy_node_get0_qualifiers(const\n                                                           X509_POLICY_NODE\n                                                           *node);\nconst X509_POLICY_NODE *X509_policy_node_get0_parent(const X509_POLICY_NODE\n                                                     *node);\n\n#ifdef  __cplusplus\n}\n#endif\n#endif\n"}, "19": {"id": 19, "path": "/usr/include/openssl/pkcs7.h", "content": "/*\n * Copyright 1995-2016 The OpenSSL Project Authors. All Rights Reserved.\n *\n * Licensed under the OpenSSL license (the \"License\").  You may not use\n * this file except in compliance with the License.  You can obtain a copy\n * in the file LICENSE in the source distribution or at\n * https://www.openssl.org/source/license.html\n */\n\n#ifndef HEADER_PKCS7_H\n# define HEADER_PKCS7_H\n\n# include <openssl/asn1.h>\n# include <openssl/bio.h>\n# include <openssl/e_os2.h>\n\n# include <openssl/symhacks.h>\n# include <openssl/ossl_typ.h>\n# include <openssl/pkcs7err.h>\n\n#ifdef  __cplusplus\nextern \"C\" {\n#endif\n\n/*-\nEncryption_ID           DES-CBC\nDigest_ID               MD5\nDigest_Encryption_ID    rsaEncryption\nKey_Encryption_ID       rsaEncryption\n*/\n\ntypedef struct pkcs7_issuer_and_serial_st {\n    X509_NAME *issuer;\n    ASN1_INTEGER *serial;\n} PKCS7_ISSUER_AND_SERIAL;\n\ntypedef struct pkcs7_signer_info_st {\n    ASN1_INTEGER *version;      /* version 1 */\n    PKCS7_ISSUER_AND_SERIAL *issuer_and_serial;\n    X509_ALGOR *digest_alg;\n    STACK_OF(X509_ATTRIBUTE) *auth_attr; /* [ 0 ] */\n    X509_ALGOR *digest_enc_alg;\n    ASN1_OCTET_STRING *enc_digest;\n    STACK_OF(X509_ATTRIBUTE) *unauth_attr; /* [ 1 ] */\n    /* The private key to sign with */\n    EVP_PKEY *pkey;\n} PKCS7_SIGNER_INFO;\n\nDEFINE_STACK_OF(PKCS7_SIGNER_INFO)\n\ntypedef struct pkcs7_recip_info_st {\n    ASN1_INTEGER *version;      /* version 0 */\n    PKCS7_ISSUER_AND_SERIAL *issuer_and_serial;\n    X509_ALGOR *key_enc_algor;\n    ASN1_OCTET_STRING *enc_key;\n    X509 *cert;                 /* get the pub-key from this */\n} PKCS7_RECIP_INFO;\n\nDEFINE_STACK_OF(PKCS7_RECIP_INFO)\n\ntypedef struct pkcs7_signed_st {\n    ASN1_INTEGER *version;      /* version 1 */\n    STACK_OF(X509_ALGOR) *md_algs; /* md used */\n    STACK_OF(X509) *cert;       /* [ 0 ] */\n    STACK_OF(X509_CRL) *crl;    /* [ 1 ] */\n    STACK_OF(PKCS7_SIGNER_INFO) *signer_info;\n    struct pkcs7_st *contents;\n} PKCS7_SIGNED;\n/*\n * The above structure is very very similar to PKCS7_SIGN_ENVELOPE. How about\n * merging the two\n */\n\ntypedef struct pkcs7_enc_content_st {\n    ASN1_OBJECT *content_type;\n    X509_ALGOR *algorithm;\n    ASN1_OCTET_STRING *enc_data; /* [ 0 ] */\n    const EVP_CIPHER *cipher;\n} PKCS7_ENC_CONTENT;\n\ntypedef struct pkcs7_enveloped_st {\n    ASN1_INTEGER *version;      /* version 0 */\n    STACK_OF(PKCS7_RECIP_INFO) *recipientinfo;\n    PKCS7_ENC_CONTENT *enc_data;\n} PKCS7_ENVELOPE;\n\ntypedef struct pkcs7_signedandenveloped_st {\n    ASN1_INTEGER *version;      /* version 1 */\n    STACK_OF(X509_ALGOR) *md_algs; /* md used */\n    STACK_OF(X509) *cert;       /* [ 0 ] */\n    STACK_OF(X509_CRL) *crl;    /* [ 1 ] */\n    STACK_OF(PKCS7_SIGNER_INFO) *signer_info;\n    PKCS7_ENC_CONTENT *enc_data;\n    STACK_OF(PKCS7_RECIP_INFO) *recipientinfo;\n} PKCS7_SIGN_ENVELOPE;\n\ntypedef struct pkcs7_digest_st {\n    ASN1_INTEGER *version;      /* version 0 */\n    X509_ALGOR *md;             /* md used */\n    struct pkcs7_st *contents;\n    ASN1_OCTET_STRING *digest;\n} PKCS7_DIGEST;\n\ntypedef struct pkcs7_encrypted_st {\n    ASN1_INTEGER *version;      /* version 0 */\n    PKCS7_ENC_CONTENT *enc_data;\n} PKCS7_ENCRYPT;\n\ntypedef struct pkcs7_st {\n    /*\n     * The following is non NULL if it contains ASN1 encoding of this\n     * structure\n     */\n    unsigned char *asn1;\n    long length;\n# define PKCS7_S_HEADER  0\n# define PKCS7_S_BODY    1\n# define PKCS7_S_TAIL    2\n    int state;                  /* used during processing */\n    int detached;\n    ASN1_OBJECT *type;\n    /* content as defined by the type */\n    /*\n     * all encryption/message digests are applied to the 'contents', leaving\n     * out the 'type' field.\n     */\n    union {\n        char *ptr;\n        /* NID_pkcs7_data */\n        ASN1_OCTET_STRING *data;\n        /* NID_pkcs7_signed */\n        PKCS7_SIGNED *sign;\n        /* NID_pkcs7_enveloped */\n        PKCS7_ENVELOPE *enveloped;\n        /* NID_pkcs7_signedAndEnveloped */\n        PKCS7_SIGN_ENVELOPE *signed_and_enveloped;\n        /* NID_pkcs7_digest */\n        PKCS7_DIGEST *digest;\n        /* NID_pkcs7_encrypted */\n        PKCS7_ENCRYPT *encrypted;\n        /* Anything else */\n        ASN1_TYPE *other;\n    } d;\n} PKCS7;\n\nDEFINE_STACK_OF(PKCS7)\n\n# define PKCS7_OP_SET_DETACHED_SIGNATURE 1\n# define PKCS7_OP_GET_DETACHED_SIGNATURE 2\n\n# define PKCS7_get_signed_attributes(si) ((si)->auth_attr)\n# define PKCS7_get_attributes(si)        ((si)->unauth_attr)\n\n# define PKCS7_type_is_signed(a) (OBJ_obj2nid((a)->type) == NID_pkcs7_signed)\n# define PKCS7_type_is_encrypted(a) (OBJ_obj2nid((a)->type) == NID_pkcs7_encrypted)\n# define PKCS7_type_is_enveloped(a) (OBJ_obj2nid((a)->type) == NID_pkcs7_enveloped)\n# define PKCS7_type_is_signedAndEnveloped(a) \\\n                (OBJ_obj2nid((a)->type) == NID_pkcs7_signedAndEnveloped)\n# define PKCS7_type_is_data(a)   (OBJ_obj2nid((a)->type) == NID_pkcs7_data)\n# define PKCS7_type_is_digest(a)   (OBJ_obj2nid((a)->type) == NID_pkcs7_digest)\n\n# define PKCS7_set_detached(p,v) \\\n                PKCS7_ctrl(p,PKCS7_OP_SET_DETACHED_SIGNATURE,v,NULL)\n# define PKCS7_get_detached(p) \\\n                PKCS7_ctrl(p,PKCS7_OP_GET_DETACHED_SIGNATURE,0,NULL)\n\n# define PKCS7_is_detached(p7) (PKCS7_type_is_signed(p7) && PKCS7_get_detached(p7))\n\n/* S/MIME related flags */\n\n# define PKCS7_TEXT              0x1\n# define PKCS7_NOCERTS           0x2\n# define PKCS7_NOSIGS            0x4\n# define PKCS7_NOCHAIN           0x8\n# define PKCS7_NOINTERN          0x10\n# define PKCS7_NOVERIFY          0x20\n# define PKCS7_DETACHED          0x40\n# define PKCS7_BINARY            0x80\n# define PKCS7_NOATTR            0x100\n# define PKCS7_NOSMIMECAP        0x200\n# define PKCS7_NOOLDMIMETYPE     0x400\n# define PKCS7_CRLFEOL           0x800\n# define PKCS7_STREAM            0x1000\n# define PKCS7_NOCRL             0x2000\n# define PKCS7_PARTIAL           0x4000\n# define PKCS7_REUSE_DIGEST      0x8000\n# define PKCS7_NO_DUAL_CONTENT   0x10000\n\n/* Flags: for compatibility with older code */\n\n# define SMIME_TEXT      PKCS7_TEXT\n# define SMIME_NOCERTS   PKCS7_NOCERTS\n# define SMIME_NOSIGS    PKCS7_NOSIGS\n# define SMIME_NOCHAIN   PKCS7_NOCHAIN\n# define SMIME_NOINTERN  PKCS7_NOINTERN\n# define SMIME_NOVERIFY  PKCS7_NOVERIFY\n# define SMIME_DETACHED  PKCS7_DETACHED\n# define SMIME_BINARY    PKCS7_BINARY\n# define SMIME_NOATTR    PKCS7_NOATTR\n\n/* CRLF ASCII canonicalisation */\n# define SMIME_ASCIICRLF         0x80000\n\nDECLARE_ASN1_FUNCTIONS(PKCS7_ISSUER_AND_SERIAL)\n\nint PKCS7_ISSUER_AND_SERIAL_digest(PKCS7_ISSUER_AND_SERIAL *data,\n                                   const EVP_MD *type, unsigned char *md,\n                                   unsigned int *len);\n# ifndef OPENSSL_NO_STDIO\nPKCS7 *d2i_PKCS7_fp(FILE *fp, PKCS7 **p7);\nint i2d_PKCS7_fp(FILE *fp, PKCS7 *p7);\n# endif\nPKCS7 *PKCS7_dup(PKCS7 *p7);\nPKCS7 *d2i_PKCS7_bio(BIO *bp, PKCS7 **p7);\nint i2d_PKCS7_bio(BIO *bp, PKCS7 *p7);\nint i2d_PKCS7_bio_stream(BIO *out, PKCS7 *p7, BIO *in, int flags);\nint PEM_write_bio_PKCS7_stream(BIO *out, PKCS7 *p7, BIO *in, int flags);\n\nDECLARE_ASN1_FUNCTIONS(PKCS7_SIGNER_INFO)\nDECLARE_ASN1_FUNCTIONS(PKCS7_RECIP_INFO)\nDECLARE_ASN1_FUNCTIONS(PKCS7_SIGNED)\nDECLARE_ASN1_FUNCTIONS(PKCS7_ENC_CONTENT)\nDECLARE_ASN1_FUNCTIONS(PKCS7_ENVELOPE)\nDECLARE_ASN1_FUNCTIONS(PKCS7_SIGN_ENVELOPE)\nDECLARE_ASN1_FUNCTIONS(PKCS7_DIGEST)\nDECLARE_ASN1_FUNCTIONS(PKCS7_ENCRYPT)\nDECLARE_ASN1_FUNCTIONS(PKCS7)\n\nDECLARE_ASN1_ITEM(PKCS7_ATTR_SIGN)\nDECLARE_ASN1_ITEM(PKCS7_ATTR_VERIFY)\n\nDECLARE_ASN1_NDEF_FUNCTION(PKCS7)\nDECLARE_ASN1_PRINT_FUNCTION(PKCS7)\n\nlong PKCS7_ctrl(PKCS7 *p7, int cmd, long larg, char *parg);\n\nint PKCS7_set_type(PKCS7 *p7, int type);\nint PKCS7_set0_type_other(PKCS7 *p7, int type, ASN1_TYPE *other);\nint PKCS7_set_content(PKCS7 *p7, PKCS7 *p7_data);\nint PKCS7_SIGNER_INFO_set(PKCS7_SIGNER_INFO *p7i, X509 *x509, EVP_PKEY *pkey,\n                          const EVP_MD *dgst);\nint PKCS7_SIGNER_INFO_sign(PKCS7_SIGNER_INFO *si);\nint PKCS7_add_signer(PKCS7 *p7, PKCS7_SIGNER_INFO *p7i);\nint PKCS7_add_certificate(PKCS7 *p7, X509 *x509);\nint PKCS7_add_crl(PKCS7 *p7, X509_CRL *x509);\nint PKCS7_content_new(PKCS7 *p7, int nid);\nint PKCS7_dataVerify(X509_STORE *cert_store, X509_STORE_CTX *ctx,\n                     BIO *bio, PKCS7 *p7, PKCS7_SIGNER_INFO *si);\nint PKCS7_signatureVerify(BIO *bio, PKCS7 *p7, PKCS7_SIGNER_INFO *si,\n                          X509 *x509);\n\nBIO *PKCS7_dataInit(PKCS7 *p7, BIO *bio);\nint PKCS7_dataFinal(PKCS7 *p7, BIO *bio);\nBIO *PKCS7_dataDecode(PKCS7 *p7, EVP_PKEY *pkey, BIO *in_bio, X509 *pcert);\n\nPKCS7_SIGNER_INFO *PKCS7_add_signature(PKCS7 *p7, X509 *x509,\n                                       EVP_PKEY *pkey, const EVP_MD *dgst);\nX509 *PKCS7_cert_from_signer_info(PKCS7 *p7, PKCS7_SIGNER_INFO *si);\nint PKCS7_set_digest(PKCS7 *p7, const EVP_MD *md);\nSTACK_OF(PKCS7_SIGNER_INFO) *PKCS7_get_signer_info(PKCS7 *p7);\n\nPKCS7_RECIP_INFO *PKCS7_add_recipient(PKCS7 *p7, X509 *x509);\nvoid PKCS7_SIGNER_INFO_get0_algs(PKCS7_SIGNER_INFO *si, EVP_PKEY **pk,\n                                 X509_ALGOR **pdig, X509_ALGOR **psig);\nvoid PKCS7_RECIP_INFO_get0_alg(PKCS7_RECIP_INFO *ri, X509_ALGOR **penc);\nint PKCS7_add_recipient_info(PKCS7 *p7, PKCS7_RECIP_INFO *ri);\nint PKCS7_RECIP_INFO_set(PKCS7_RECIP_INFO *p7i, X509 *x509);\nint PKCS7_set_cipher(PKCS7 *p7, const EVP_CIPHER *cipher);\nint PKCS7_stream(unsigned char ***boundary, PKCS7 *p7);\n\nPKCS7_ISSUER_AND_SERIAL *PKCS7_get_issuer_and_serial(PKCS7 *p7, int idx);\nASN1_OCTET_STRING *PKCS7_digest_from_attributes(STACK_OF(X509_ATTRIBUTE) *sk);\nint PKCS7_add_signed_attribute(PKCS7_SIGNER_INFO *p7si, int nid, int type,\n                               void *data);\nint PKCS7_add_attribute(PKCS7_SIGNER_INFO *p7si, int nid, int atrtype,\n                        void *value);\nASN1_TYPE *PKCS7_get_attribute(PKCS7_SIGNER_INFO *si, int nid);\nASN1_TYPE *PKCS7_get_signed_attribute(PKCS7_SIGNER_INFO *si, int nid);\nint PKCS7_set_signed_attributes(PKCS7_SIGNER_INFO *p7si,\n                                STACK_OF(X509_ATTRIBUTE) *sk);\nint PKCS7_set_attributes(PKCS7_SIGNER_INFO *p7si,\n                         STACK_OF(X509_ATTRIBUTE) *sk);\n\nPKCS7 *PKCS7_sign(X509 *signcert, EVP_PKEY *pkey, STACK_OF(X509) *certs,\n                  BIO *data, int flags);\n\nPKCS7_SIGNER_INFO *PKCS7_sign_add_signer(PKCS7 *p7,\n                                         X509 *signcert, EVP_PKEY *pkey,\n                                         const EVP_MD *md, int flags);\n\nint PKCS7_final(PKCS7 *p7, BIO *data, int flags);\nint PKCS7_verify(PKCS7 *p7, STACK_OF(X509) *certs, X509_STORE *store,\n                 BIO *indata, BIO *out, int flags);\nSTACK_OF(X509) *PKCS7_get0_signers(PKCS7 *p7, STACK_OF(X509) *certs,\n                                   int flags);\nPKCS7 *PKCS7_encrypt(STACK_OF(X509) *certs, BIO *in, const EVP_CIPHER *cipher,\n                     int flags);\nint PKCS7_decrypt(PKCS7 *p7, EVP_PKEY *pkey, X509 *cert, BIO *data,\n                  int flags);\n\nint PKCS7_add_attrib_smimecap(PKCS7_SIGNER_INFO *si,\n                              STACK_OF(X509_ALGOR) *cap);\nSTACK_OF(X509_ALGOR) *PKCS7_get_smimecap(PKCS7_SIGNER_INFO *si);\nint PKCS7_simple_smimecap(STACK_OF(X509_ALGOR) *sk, int nid, int arg);\n\nint PKCS7_add_attrib_content_type(PKCS7_SIGNER_INFO *si, ASN1_OBJECT *coid);\nint PKCS7_add0_attrib_signing_time(PKCS7_SIGNER_INFO *si, ASN1_TIME *t);\nint PKCS7_add1_attrib_digest(PKCS7_SIGNER_INFO *si,\n                             const unsigned char *md, int mdlen);\n\nint SMIME_write_PKCS7(BIO *bio, PKCS7 *p7, BIO *data, int flags);\nPKCS7 *SMIME_read_PKCS7(BIO *bio, BIO **bcont);\n\nBIO *BIO_new_PKCS7(BIO *out, PKCS7 *p7);\n\n# ifdef  __cplusplus\n}\n# endif\n#endif\n"}, "20": {"id": 20, "path": "/usr/include/openssl/ct.h", "content": "/*\n * Copyright 2016-2018 The OpenSSL Project Authors. All Rights Reserved.\n *\n * Licensed under the OpenSSL license (the \"License\").  You may not use\n * this file except in compliance with the License.  You can obtain a copy\n * in the file LICENSE in the source distribution or at\n * https://www.openssl.org/source/license.html\n */\n\n#ifndef HEADER_CT_H\n# define HEADER_CT_H\n\n# include <openssl/opensslconf.h>\n\n# ifndef OPENSSL_NO_CT\n# include <openssl/ossl_typ.h>\n# include <openssl/safestack.h>\n# include <openssl/x509.h>\n# include <openssl/cterr.h>\n# ifdef  __cplusplus\nextern \"C\" {\n# endif\n\n\n/* Minimum RSA key size, from RFC6962 */\n# define SCT_MIN_RSA_BITS 2048\n\n/* All hashes are SHA256 in v1 of Certificate Transparency */\n# define CT_V1_HASHLEN SHA256_DIGEST_LENGTH\n\ntypedef enum {\n    CT_LOG_ENTRY_TYPE_NOT_SET = -1,\n    CT_LOG_ENTRY_TYPE_X509 = 0,\n    CT_LOG_ENTRY_TYPE_PRECERT = 1\n} ct_log_entry_type_t;\n\ntypedef enum {\n    SCT_VERSION_NOT_SET = -1,\n    SCT_VERSION_V1 = 0\n} sct_version_t;\n\ntypedef enum {\n    SCT_SOURCE_UNKNOWN,\n    SCT_SOURCE_TLS_EXTENSION,\n    SCT_SOURCE_X509V3_EXTENSION,\n    SCT_SOURCE_OCSP_STAPLED_RESPONSE\n} sct_source_t;\n\ntypedef enum {\n    SCT_VALIDATION_STATUS_NOT_SET,\n    SCT_VALIDATION_STATUS_UNKNOWN_LOG,\n    SCT_VALIDATION_STATUS_VALID,\n    SCT_VALIDATION_STATUS_INVALID,\n    SCT_VALIDATION_STATUS_UNVERIFIED,\n    SCT_VALIDATION_STATUS_UNKNOWN_VERSION\n} sct_validation_status_t;\n\nDEFINE_STACK_OF(SCT)\nDEFINE_STACK_OF(CTLOG)\n\n/******************************************\n * CT policy evaluation context functions *\n ******************************************/\n\n/*\n * Creates a new, empty policy evaluation context.\n * The caller is responsible for calling CT_POLICY_EVAL_CTX_free when finished\n * with the CT_POLICY_EVAL_CTX.\n */\nCT_POLICY_EVAL_CTX *CT_POLICY_EVAL_CTX_new(void);\n\n/* Deletes a policy evaluation context and anything it owns. */\nvoid CT_POLICY_EVAL_CTX_free(CT_POLICY_EVAL_CTX *ctx);\n\n/* Gets the peer certificate that the SCTs are for */\nX509* CT_POLICY_EVAL_CTX_get0_cert(const CT_POLICY_EVAL_CTX *ctx);\n\n/*\n * Sets the certificate associated with the received SCTs.\n * Increments the reference count of cert.\n * Returns 1 on success, 0 otherwise.\n */\nint CT_POLICY_EVAL_CTX_set1_cert(CT_POLICY_EVAL_CTX *ctx, X509 *cert);\n\n/* Gets the issuer of the aforementioned certificate */\nX509* CT_POLICY_EVAL_CTX_get0_issuer(const CT_POLICY_EVAL_CTX *ctx);\n\n/*\n * Sets the issuer of the certificate associated with the received SCTs.\n * Increments the reference count of issuer.\n * Returns 1 on success, 0 otherwise.\n */\nint CT_POLICY_EVAL_CTX_set1_issuer(CT_POLICY_EVAL_CTX *ctx, X509 *issuer);\n\n/* Gets the CT logs that are trusted sources of SCTs */\nconst CTLOG_STORE *CT_POLICY_EVAL_CTX_get0_log_store(const CT_POLICY_EVAL_CTX *ctx);\n\n/* Sets the log store that is in use. It must outlive the CT_POLICY_EVAL_CTX. */\nvoid CT_POLICY_EVAL_CTX_set_shared_CTLOG_STORE(CT_POLICY_EVAL_CTX *ctx,\n                                               CTLOG_STORE *log_store);\n\n/*\n * Gets the time, in milliseconds since the Unix epoch, that will be used as the\n * current time when checking whether an SCT was issued in the future.\n * Such SCTs will fail validation, as required by RFC6962.\n */\nuint64_t CT_POLICY_EVAL_CTX_get_time(const CT_POLICY_EVAL_CTX *ctx);\n\n/*\n * Sets the time to evaluate SCTs against, in milliseconds since the Unix epoch.\n * If an SCT's timestamp is after this time, it will be interpreted as having\n * been issued in the future. RFC6962 states that \"TLS clients MUST reject SCTs\n * whose timestamp is in the future\", so an SCT will not validate in this case.\n */\nvoid CT_POLICY_EVAL_CTX_set_time(CT_POLICY_EVAL_CTX *ctx, uint64_t time_in_ms);\n\n/*****************\n * SCT functions *\n *****************/\n\n/*\n * Creates a new, blank SCT.\n * The caller is responsible for calling SCT_free when finished with the SCT.\n */\nSCT *SCT_new(void);\n\n/*\n * Creates a new SCT from some base64-encoded strings.\n * The caller is responsible for calling SCT_free when finished with the SCT.\n */\nSCT *SCT_new_from_base64(unsigned char version,\n                         const char *logid_base64,\n                         ct_log_entry_type_t entry_type,\n                         uint64_t timestamp,\n                         const char *extensions_base64,\n                         const char *signature_base64);\n\n/*\n * Frees the SCT and the underlying data structures.\n */\nvoid SCT_free(SCT *sct);\n\n/*\n * Free a stack of SCTs, and the underlying SCTs themselves.\n * Intended to be compatible with X509V3_EXT_FREE.\n */\nvoid SCT_LIST_free(STACK_OF(SCT) *a);\n\n/*\n * Returns the version of the SCT.\n */\nsct_version_t SCT_get_version(const SCT *sct);\n\n/*\n * Set the version of an SCT.\n * Returns 1 on success, 0 if the version is unrecognized.\n */\n__owur int SCT_set_version(SCT *sct, sct_version_t version);\n\n/*\n * Returns the log entry type of the SCT.\n */\nct_log_entry_type_t SCT_get_log_entry_type(const SCT *sct);\n\n/*\n * Set the log entry type of an SCT.\n * Returns 1 on success, 0 otherwise.\n */\n__owur int SCT_set_log_entry_type(SCT *sct, ct_log_entry_type_t entry_type);\n\n/*\n * Gets the ID of the log that an SCT came from.\n * Ownership of the log ID remains with the SCT.\n * Returns the length of the log ID.\n */\nsize_t SCT_get0_log_id(const SCT *sct, unsigned char **log_id);\n\n/*\n * Set the log ID of an SCT to point directly to the *log_id specified.\n * The SCT takes ownership of the specified pointer.\n * Returns 1 on success, 0 otherwise.\n */\n__owur int SCT_set0_log_id(SCT *sct, unsigned char *log_id, size_t log_id_len);\n\n/*\n * Set the log ID of an SCT.\n * This makes a copy of the log_id.\n * Returns 1 on success, 0 otherwise.\n */\n__owur int SCT_set1_log_id(SCT *sct, const unsigned char *log_id,\n                           size_t log_id_len);\n\n/*\n * Returns the timestamp for the SCT (epoch time in milliseconds).\n */\nuint64_t SCT_get_timestamp(const SCT *sct);\n\n/*\n * Set the timestamp of an SCT (epoch time in milliseconds).\n */\nvoid SCT_set_timestamp(SCT *sct, uint64_t timestamp);\n\n/*\n * Return the NID for the signature used by the SCT.\n * For CT v1, this will be either NID_sha256WithRSAEncryption or\n * NID_ecdsa_with_SHA256 (or NID_undef if incorrect/unset).\n */\nint SCT_get_signature_nid(const SCT *sct);\n\n/*\n * Set the signature type of an SCT\n * For CT v1, this should be either NID_sha256WithRSAEncryption or\n * NID_ecdsa_with_SHA256.\n * Returns 1 on success, 0 otherwise.\n */\n__owur int SCT_set_signature_nid(SCT *sct, int nid);\n\n/*\n * Set *ext to point to the extension data for the SCT. ext must not be NULL.\n * The SCT retains ownership of this pointer.\n * Returns length of the data pointed to.\n */\nsize_t SCT_get0_extensions(const SCT *sct, unsigned char **ext);\n\n/*\n * Set the extensions of an SCT to point directly to the *ext specified.\n * The SCT takes ownership of the specified pointer.\n */\nvoid SCT_set0_extensions(SCT *sct, unsigned char *ext, size_t ext_len);\n\n/*\n * Set the extensions of an SCT.\n * This takes a copy of the ext.\n * Returns 1 on success, 0 otherwise.\n */\n__owur int SCT_set1_extensions(SCT *sct, const unsigned char *ext,\n                               size_t ext_len);\n\n/*\n * Set *sig to point to the signature for the SCT. sig must not be NULL.\n * The SCT retains ownership of this pointer.\n * Returns length of the data pointed to.\n */\nsize_t SCT_get0_signature(const SCT *sct, unsigned char **sig);\n\n/*\n * Set the signature of an SCT to point directly to the *sig specified.\n * The SCT takes ownership of the specified pointer.\n */\nvoid SCT_set0_signature(SCT *sct, unsigned char *sig, size_t sig_len);\n\n/*\n * Set the signature of an SCT to be a copy of the *sig specified.\n * Returns 1 on success, 0 otherwise.\n */\n__owur int SCT_set1_signature(SCT *sct, const unsigned char *sig,\n                              size_t sig_len);\n\n/*\n * The origin of this SCT, e.g. TLS extension, OCSP response, etc.\n */\nsct_source_t SCT_get_source(const SCT *sct);\n\n/*\n * Set the origin of this SCT, e.g. TLS extension, OCSP response, etc.\n * Returns 1 on success, 0 otherwise.\n */\n__owur int SCT_set_source(SCT *sct, sct_source_t source);\n\n/*\n * Returns a text string describing the validation status of |sct|.\n */\nconst char *SCT_validation_status_string(const SCT *sct);\n\n/*\n * Pretty-prints an |sct| to |out|.\n * It will be indented by the number of spaces specified by |indent|.\n * If |logs| is not NULL, it will be used to lookup the CT log that the SCT came\n * from, so that the log name can be printed.\n */\nvoid SCT_print(const SCT *sct, BIO *out, int indent, const CTLOG_STORE *logs);\n\n/*\n * Pretty-prints an |sct_list| to |out|.\n * It will be indented by the number of spaces specified by |indent|.\n * SCTs will be delimited by |separator|.\n * If |logs| is not NULL, it will be used to lookup the CT log that each SCT\n * came from, so that the log names can be printed.\n */\nvoid SCT_LIST_print(const STACK_OF(SCT) *sct_list, BIO *out, int indent,\n                    const char *separator, const CTLOG_STORE *logs);\n\n/*\n * Gets the last result of validating this SCT.\n * If it has not been validated yet, returns SCT_VALIDATION_STATUS_NOT_SET.\n */\nsct_validation_status_t SCT_get_validation_status(const SCT *sct);\n\n/*\n * Validates the given SCT with the provided context.\n * Sets the \"validation_status\" field of the SCT.\n * Returns 1 if the SCT is valid and the signature verifies.\n * Returns 0 if the SCT is invalid or could not be verified.\n * Returns -1 if an error occurs.\n */\n__owur int SCT_validate(SCT *sct, const CT_POLICY_EVAL_CTX *ctx);\n\n/*\n * Validates the given list of SCTs with the provided context.\n * Sets the \"validation_status\" field of each SCT.\n * Returns 1 if there are no invalid SCTs and all signatures verify.\n * Returns 0 if at least one SCT is invalid or could not be verified.\n * Returns a negative integer if an error occurs.\n */\n__owur int SCT_LIST_validate(const STACK_OF(SCT) *scts,\n                             CT_POLICY_EVAL_CTX *ctx);\n\n\n/*********************************\n * SCT parsing and serialisation *\n *********************************/\n\n/*\n * Serialize (to TLS format) a stack of SCTs and return the length.\n * \"a\" must not be NULL.\n * If \"pp\" is NULL, just return the length of what would have been serialized.\n * If \"pp\" is not NULL and \"*pp\" is null, function will allocate a new pointer\n * for data that caller is responsible for freeing (only if function returns\n * successfully).\n * If \"pp\" is NULL and \"*pp\" is not NULL, caller is responsible for ensuring\n * that \"*pp\" is large enough to accept all of the serialized data.\n * Returns < 0 on error, >= 0 indicating bytes written (or would have been)\n * on success.\n */\n__owur int i2o_SCT_LIST(const STACK_OF(SCT) *a, unsigned char **pp);\n\n/*\n * Convert TLS format SCT list to a stack of SCTs.\n * If \"a\" or \"*a\" is NULL, a new stack will be created that the caller is\n * responsible for freeing (by calling SCT_LIST_free).\n * \"**pp\" and \"*pp\" must not be NULL.\n * Upon success, \"*pp\" will point to after the last bytes read, and a stack\n * will be returned.\n * Upon failure, a NULL pointer will be returned, and the position of \"*pp\" is\n * not defined.\n */\nSTACK_OF(SCT) *o2i_SCT_LIST(STACK_OF(SCT) **a, const unsigned char **pp,\n                            size_t len);\n\n/*\n * Serialize (to DER format) a stack of SCTs and return the length.\n * \"a\" must not be NULL.\n * If \"pp\" is NULL, just returns the length of what would have been serialized.\n * If \"pp\" is not NULL and \"*pp\" is null, function will allocate a new pointer\n * for data that caller is responsible for freeing (only if function returns\n * successfully).\n * If \"pp\" is NULL and \"*pp\" is not NULL, caller is responsible for ensuring\n * that \"*pp\" is large enough to accept all of the serialized data.\n * Returns < 0 on error, >= 0 indicating bytes written (or would have been)\n * on success.\n */\n__owur int i2d_SCT_LIST(const STACK_OF(SCT) *a, unsigned char **pp);\n\n/*\n * Parses an SCT list in DER format and returns it.\n * If \"a\" or \"*a\" is NULL, a new stack will be created that the caller is\n * responsible for freeing (by calling SCT_LIST_free).\n * \"**pp\" and \"*pp\" must not be NULL.\n * Upon success, \"*pp\" will point to after the last bytes read, and a stack\n * will be returned.\n * Upon failure, a NULL pointer will be returned, and the position of \"*pp\" is\n * not defined.\n */\nSTACK_OF(SCT) *d2i_SCT_LIST(STACK_OF(SCT) **a, const unsigned char **pp,\n                            long len);\n\n/*\n * Serialize (to TLS format) an |sct| and write it to |out|.\n * If |out| is null, no SCT will be output but the length will still be returned.\n * If |out| points to a null pointer, a string will be allocated to hold the\n * TLS-format SCT. It is the responsibility of the caller to free it.\n * If |out| points to an allocated string, the TLS-format SCT will be written\n * to it.\n * The length of the SCT in TLS format will be returned.\n */\n__owur int i2o_SCT(const SCT *sct, unsigned char **out);\n\n/*\n * Parses an SCT in TLS format and returns it.\n * If |psct| is not null, it will end up pointing to the parsed SCT. If it\n * already points to a non-null pointer, the pointer will be free'd.\n * |in| should be a pointer to a string containing the TLS-format SCT.\n * |in| will be advanced to the end of the SCT if parsing succeeds.\n * |len| should be the length of the SCT in |in|.\n * Returns NULL if an error occurs.\n * If the SCT is an unsupported version, only the SCT's 'sct' and 'sct_len'\n * fields will be populated (with |in| and |len| respectively).\n */\nSCT *o2i_SCT(SCT **psct, const unsigned char **in, size_t len);\n\n/********************\n * CT log functions *\n ********************/\n\n/*\n * Creates a new CT log instance with the given |public_key| and |name|.\n * Takes ownership of |public_key| but copies |name|.\n * Returns NULL if malloc fails or if |public_key| cannot be converted to DER.\n * Should be deleted by the caller using CTLOG_free when no longer needed.\n */\nCTLOG *CTLOG_new(EVP_PKEY *public_key, const char *name);\n\n/*\n * Creates a new CTLOG instance with the base64-encoded SubjectPublicKeyInfo DER\n * in |pkey_base64|. The |name| is a string to help users identify this log.\n * Returns 1 on success, 0 on failure.\n * Should be deleted by the caller using CTLOG_free when no longer needed.\n */\nint CTLOG_new_from_base64(CTLOG ** ct_log,\n                          const char *pkey_base64, const char *name);\n\n/*\n * Deletes a CT log instance and its fields.\n */\nvoid CTLOG_free(CTLOG *log);\n\n/* Gets the name of the CT log */\nconst char *CTLOG_get0_name(const CTLOG *log);\n/* Gets the ID of the CT log */\nvoid CTLOG_get0_log_id(const CTLOG *log, const uint8_t **log_id,\n                       size_t *log_id_len);\n/* Gets the public key of the CT log */\nEVP_PKEY *CTLOG_get0_public_key(const CTLOG *log);\n\n/**************************\n * CT log store functions *\n **************************/\n\n/*\n * Creates a new CT log store.\n * Should be deleted by the caller using CTLOG_STORE_free when no longer needed.\n */\nCTLOG_STORE *CTLOG_STORE_new(void);\n\n/*\n * Deletes a CT log store and all of the CT log instances held within.\n */\nvoid CTLOG_STORE_free(CTLOG_STORE *store);\n\n/*\n * Finds a CT log in the store based on its log ID.\n * Returns the CT log, or NULL if no match is found.\n */\nconst CTLOG *CTLOG_STORE_get0_log_by_id(const CTLOG_STORE *store,\n                                        const uint8_t *log_id,\n                                        size_t log_id_len);\n\n/*\n * Loads a CT log list into a |store| from a |file|.\n * Returns 1 if loading is successful, or 0 otherwise.\n */\n__owur int CTLOG_STORE_load_file(CTLOG_STORE *store, const char *file);\n\n/*\n * Loads the default CT log list into a |store|.\n * Returns 1 if loading is successful, or 0 otherwise.\n */\n__owur int CTLOG_STORE_load_default_file(CTLOG_STORE *store);\n\n#  ifdef  __cplusplus\n}\n#  endif\n# endif\n#endif\n"}, "21": {"id": 21, "path": "/usr/include/openssl/ssl.h", "content": "/*\n * Copyright 1995-2019 The OpenSSL Project Authors. All Rights Reserved.\n * Copyright (c) 2002, Oracle and/or its affiliates. All rights reserved\n * Copyright 2005 Nokia. All rights reserved.\n *\n * Licensed under the OpenSSL license (the \"License\").  You may not use\n * this file except in compliance with the License.  You can obtain a copy\n * in the file LICENSE in the source distribution or at\n * https://www.openssl.org/source/license.html\n */\n\n#ifndef HEADER_SSL_H\n# define HEADER_SSL_H\n\n# include <openssl/e_os2.h>\n# include <openssl/opensslconf.h>\n# include <openssl/comp.h>\n# include <openssl/bio.h>\n# if OPENSSL_API_COMPAT < 0x10100000L\n#  include <openssl/x509.h>\n#  include <openssl/crypto.h>\n#  include <openssl/buffer.h>\n# endif\n# include <openssl/lhash.h>\n# include <openssl/pem.h>\n# include <openssl/hmac.h>\n# include <openssl/async.h>\n\n# include <openssl/safestack.h>\n# include <openssl/symhacks.h>\n# include <openssl/ct.h>\n# include <openssl/sslerr.h>\n\n#ifdef  __cplusplus\nextern \"C\" {\n#endif\n\n/* OpenSSL version number for ASN.1 encoding of the session information */\n/*-\n * Version 0 - initial version\n * Version 1 - added the optional peer certificate\n */\n# define SSL_SESSION_ASN1_VERSION 0x0001\n\n# define SSL_MAX_SSL_SESSION_ID_LENGTH           32\n# define SSL_MAX_SID_CTX_LENGTH                  32\n\n# define SSL_MIN_RSA_MODULUS_LENGTH_IN_BYTES     (512/8)\n# define SSL_MAX_KEY_ARG_LENGTH                  8\n# define SSL_MAX_MASTER_KEY_LENGTH               48\n\n/* The maximum number of encrypt/decrypt pipelines we can support */\n# define SSL_MAX_PIPELINES  32\n\n/* text strings for the ciphers */\n\n/* These are used to specify which ciphers to use and not to use */\n\n# define SSL_TXT_LOW             \"LOW\"\n# define SSL_TXT_MEDIUM          \"MEDIUM\"\n# define SSL_TXT_HIGH            \"HIGH\"\n# define SSL_TXT_FIPS            \"FIPS\"\n\n# define SSL_TXT_aNULL           \"aNULL\"\n# define SSL_TXT_eNULL           \"eNULL\"\n# define SSL_TXT_NULL            \"NULL\"\n\n# define SSL_TXT_kRSA            \"kRSA\"\n# define SSL_TXT_kDHr            \"kDHr\"/* this cipher class has been removed */\n# define SSL_TXT_kDHd            \"kDHd\"/* this cipher class has been removed */\n# define SSL_TXT_kDH             \"kDH\"/* this cipher class has been removed */\n# define SSL_TXT_kEDH            \"kEDH\"/* alias for kDHE */\n# define SSL_TXT_kDHE            \"kDHE\"\n# define SSL_TXT_kECDHr          \"kECDHr\"/* this cipher class has been removed */\n# define SSL_TXT_kECDHe          \"kECDHe\"/* this cipher class has been removed */\n# define SSL_TXT_kECDH           \"kECDH\"/* this cipher class has been removed */\n# define SSL_TXT_kEECDH          \"kEECDH\"/* alias for kECDHE */\n# define SSL_TXT_kECDHE          \"kECDHE\"\n# define SSL_TXT_kPSK            \"kPSK\"\n# define SSL_TXT_kRSAPSK         \"kRSAPSK\"\n# define SSL_TXT_kECDHEPSK       \"kECDHEPSK\"\n# define SSL_TXT_kDHEPSK         \"kDHEPSK\"\n# define SSL_TXT_kGOST           \"kGOST\"\n# define SSL_TXT_kSRP            \"kSRP\"\n\n# define SSL_TXT_aRSA            \"aRSA\"\n# define SSL_TXT_aDSS            \"aDSS\"\n# define SSL_TXT_aDH             \"aDH\"/* this cipher class has been removed */\n# define SSL_TXT_aECDH           \"aECDH\"/* this cipher class has been removed */\n# define SSL_TXT_aECDSA          \"aECDSA\"\n# define SSL_TXT_aPSK            \"aPSK\"\n# define SSL_TXT_aGOST94         \"aGOST94\"\n# define SSL_TXT_aGOST01         \"aGOST01\"\n# define SSL_TXT_aGOST12         \"aGOST12\"\n# define SSL_TXT_aGOST           \"aGOST\"\n# define SSL_TXT_aSRP            \"aSRP\"\n\n# define SSL_TXT_DSS             \"DSS\"\n# define SSL_TXT_DH              \"DH\"\n# define SSL_TXT_DHE             \"DHE\"/* same as \"kDHE:-ADH\" */\n# define SSL_TXT_EDH             \"EDH\"/* alias for DHE */\n# define SSL_TXT_ADH             \"ADH\"\n# define SSL_TXT_RSA             \"RSA\"\n# define SSL_TXT_ECDH            \"ECDH\"\n# define SSL_TXT_EECDH           \"EECDH\"/* alias for ECDHE\" */\n# define SSL_TXT_ECDHE           \"ECDHE\"/* same as \"kECDHE:-AECDH\" */\n# define SSL_TXT_AECDH           \"AECDH\"\n# define SSL_TXT_ECDSA           \"ECDSA\"\n# define SSL_TXT_PSK             \"PSK\"\n# define SSL_TXT_SRP             \"SRP\"\n\n# define SSL_TXT_DES             \"DES\"\n# define SSL_TXT_3DES            \"3DES\"\n# define SSL_TXT_RC4             \"RC4\"\n# define SSL_TXT_RC2             \"RC2\"\n# define SSL_TXT_IDEA            \"IDEA\"\n# define SSL_TXT_SEED            \"SEED\"\n# define SSL_TXT_AES128          \"AES128\"\n# define SSL_TXT_AES256          \"AES256\"\n# define SSL_TXT_AES             \"AES\"\n# define SSL_TXT_AES_GCM         \"AESGCM\"\n# define SSL_TXT_AES_CCM         \"AESCCM\"\n# define SSL_TXT_AES_CCM_8       \"AESCCM8\"\n# define SSL_TXT_CAMELLIA128     \"CAMELLIA128\"\n# define SSL_TXT_CAMELLIA256     \"CAMELLIA256\"\n# define SSL_TXT_CAMELLIA        \"CAMELLIA\"\n# define SSL_TXT_CHACHA20        \"CHACHA20\"\n# define SSL_TXT_GOST            \"GOST89\"\n# define SSL_TXT_ARIA            \"ARIA\"\n# define SSL_TXT_ARIA_GCM        \"ARIAGCM\"\n# define SSL_TXT_ARIA128         \"ARIA128\"\n# define SSL_TXT_ARIA256         \"ARIA256\"\n\n# define SSL_TXT_MD5             \"MD5\"\n# define SSL_TXT_SHA1            \"SHA1\"\n# define SSL_TXT_SHA             \"SHA\"/* same as \"SHA1\" */\n# define SSL_TXT_GOST94          \"GOST94\"\n# define SSL_TXT_GOST89MAC       \"GOST89MAC\"\n# define SSL_TXT_GOST12          \"GOST12\"\n# define SSL_TXT_GOST89MAC12     \"GOST89MAC12\"\n# define SSL_TXT_SHA256          \"SHA256\"\n# define SSL_TXT_SHA384          \"SHA384\"\n\n# define SSL_TXT_SSLV3           \"SSLv3\"\n# define SSL_TXT_TLSV1           \"TLSv1\"\n# define SSL_TXT_TLSV1_1         \"TLSv1.1\"\n# define SSL_TXT_TLSV1_2         \"TLSv1.2\"\n\n# define SSL_TXT_ALL             \"ALL\"\n\n/*-\n * COMPLEMENTOF* definitions. These identifiers are used to (de-select)\n * ciphers normally not being used.\n * Example: \"RC4\" will activate all ciphers using RC4 including ciphers\n * without authentication, which would normally disabled by DEFAULT (due\n * the \"!ADH\" being part of default). Therefore \"RC4:!COMPLEMENTOFDEFAULT\"\n * will make sure that it is also disabled in the specific selection.\n * COMPLEMENTOF* identifiers are portable between version, as adjustments\n * to the default cipher setup will also be included here.\n *\n * COMPLEMENTOFDEFAULT does not experience the same special treatment that\n * DEFAULT gets, as only selection is being done and no sorting as needed\n * for DEFAULT.\n */\n# define SSL_TXT_CMPALL          \"COMPLEMENTOFALL\"\n# define SSL_TXT_CMPDEF          \"COMPLEMENTOFDEFAULT\"\n\n/*\n * The following cipher list is used by default. It also is substituted when\n * an application-defined cipher list string starts with 'DEFAULT'.\n * This applies to ciphersuites for TLSv1.2 and below.\n */\n# define SSL_DEFAULT_CIPHER_LIST \"ALL:!COMPLEMENTOFDEFAULT:!eNULL\"\n/* This is the default set of TLSv1.3 ciphersuites */\n# if !defined(OPENSSL_NO_CHACHA) && !defined(OPENSSL_NO_POLY1305)\n#  define TLS_DEFAULT_CIPHERSUITES \"TLS_AES_256_GCM_SHA384:\" \\\n                                   \"TLS_CHACHA20_POLY1305_SHA256:\" \\\n                                   \"TLS_AES_128_GCM_SHA256\"\n# else\n#  define TLS_DEFAULT_CIPHERSUITES \"TLS_AES_256_GCM_SHA384:\" \\\n                                   \"TLS_AES_128_GCM_SHA256\"\n#endif\n/*\n * As of OpenSSL 1.0.0, ssl_create_cipher_list() in ssl/ssl_ciph.c always\n * starts with a reasonable order, and all we have to do for DEFAULT is\n * throwing out anonymous and unencrypted ciphersuites! (The latter are not\n * actually enabled by ALL, but \"ALL:RSA\" would enable some of them.)\n */\n\n/* Used in SSL_set_shutdown()/SSL_get_shutdown(); */\n# define SSL_SENT_SHUTDOWN       1\n# define SSL_RECEIVED_SHUTDOWN   2\n\n#ifdef __cplusplus\n}\n#endif\n\n#ifdef  __cplusplus\nextern \"C\" {\n#endif\n\n# define SSL_FILETYPE_ASN1       X509_FILETYPE_ASN1\n# define SSL_FILETYPE_PEM        X509_FILETYPE_PEM\n\n/*\n * This is needed to stop compilers complaining about the 'struct ssl_st *'\n * function parameters used to prototype callbacks in SSL_CTX.\n */\ntypedef struct ssl_st *ssl_crock_st;\ntypedef struct tls_session_ticket_ext_st TLS_SESSION_TICKET_EXT;\ntypedef struct ssl_method_st SSL_METHOD;\ntypedef struct ssl_cipher_st SSL_CIPHER;\ntypedef struct ssl_session_st SSL_SESSION;\ntypedef struct tls_sigalgs_st TLS_SIGALGS;\ntypedef struct ssl_conf_ctx_st SSL_CONF_CTX;\ntypedef struct ssl_comp_st SSL_COMP;\n\nSTACK_OF(SSL_CIPHER);\nSTACK_OF(SSL_COMP);\n\n/* SRTP protection profiles for use with the use_srtp extension (RFC 5764)*/\ntypedef struct srtp_protection_profile_st {\n    const char *name;\n    unsigned long id;\n} SRTP_PROTECTION_PROFILE;\n\nDEFINE_STACK_OF(SRTP_PROTECTION_PROFILE)\n\ntypedef int (*tls_session_ticket_ext_cb_fn)(SSL *s, const unsigned char *data,\n                                            int len, void *arg);\ntypedef int (*tls_session_secret_cb_fn)(SSL *s, void *secret, int *secret_len,\n                                        STACK_OF(SSL_CIPHER) *peer_ciphers,\n                                        const SSL_CIPHER **cipher, void *arg);\n\n/* Extension context codes */\n/* This extension is only allowed in TLS */\n#define SSL_EXT_TLS_ONLY                        0x0001\n/* This extension is only allowed in DTLS */\n#define SSL_EXT_DTLS_ONLY                       0x0002\n/* Some extensions may be allowed in DTLS but we don't implement them for it */\n#define SSL_EXT_TLS_IMPLEMENTATION_ONLY         0x0004\n/* Most extensions are not defined for SSLv3 but EXT_TYPE_renegotiate is */\n#define SSL_EXT_SSL3_ALLOWED                    0x0008\n/* Extension is only defined for TLS1.2 and below */\n#define SSL_EXT_TLS1_2_AND_BELOW_ONLY           0x0010\n/* Extension is only defined for TLS1.3 and above */\n#define SSL_EXT_TLS1_3_ONLY                     0x0020\n/* Ignore this extension during parsing if we are resuming */\n#define SSL_EXT_IGNORE_ON_RESUMPTION            0x0040\n#define SSL_EXT_CLIENT_HELLO                    0x0080\n/* Really means TLS1.2 or below */\n#define SSL_EXT_TLS1_2_SERVER_HELLO             0x0100\n#define SSL_EXT_TLS1_3_SERVER_HELLO             0x0200\n#define SSL_EXT_TLS1_3_ENCRYPTED_EXTENSIONS     0x0400\n#define SSL_EXT_TLS1_3_HELLO_RETRY_REQUEST      0x0800\n#define SSL_EXT_TLS1_3_CERTIFICATE              0x1000\n#define SSL_EXT_TLS1_3_NEW_SESSION_TICKET       0x2000\n#define SSL_EXT_TLS1_3_CERTIFICATE_REQUEST      0x4000\n\n/* Typedefs for handling custom extensions */\n\ntypedef int (*custom_ext_add_cb)(SSL *s, unsigned int ext_type,\n                                 const unsigned char **out, size_t *outlen,\n                                 int *al, void *add_arg);\n\ntypedef void (*custom_ext_free_cb)(SSL *s, unsigned int ext_type,\n                                   const unsigned char *out, void *add_arg);\n\ntypedef int (*custom_ext_parse_cb)(SSL *s, unsigned int ext_type,\n                                   const unsigned char *in, size_t inlen,\n                                   int *al, void *parse_arg);\n\n\ntypedef int (*SSL_custom_ext_add_cb_ex)(SSL *s, unsigned int ext_type,\n                                        unsigned int context,\n                                        const unsigned char **out,\n                                        size_t *outlen, X509 *x,\n                                        size_t chainidx,\n                                        int *al, void *add_arg);\n\ntypedef void (*SSL_custom_ext_free_cb_ex)(SSL *s, unsigned int ext_type,\n                                          unsigned int context,\n                                          const unsigned char *out,\n                                          void *add_arg);\n\ntypedef int (*SSL_custom_ext_parse_cb_ex)(SSL *s, unsigned int ext_type,\n                                          unsigned int context,\n                                          const unsigned char *in,\n                                          size_t inlen, X509 *x,\n                                          size_t chainidx,\n                                          int *al, void *parse_arg);\n\n/* Typedef for verification callback */\ntypedef int (*SSL_verify_cb)(int preverify_ok, X509_STORE_CTX *x509_ctx);\n\n/*\n * Some values are reserved until OpenSSL 1.2.0 because they were previously\n * included in SSL_OP_ALL in a 1.1.x release.\n *\n * Reserved value (until OpenSSL 1.2.0)                  0x00000001U\n * Reserved value (until OpenSSL 1.2.0)                  0x00000002U\n */\n/* Allow initial connection to servers that don't support RI */\n# define SSL_OP_LEGACY_SERVER_CONNECT                    0x00000004U\n\n/* Reserved value (until OpenSSL 1.2.0)                  0x00000008U */\n# define SSL_OP_TLSEXT_PADDING                           0x00000010U\n/* Reserved value (until OpenSSL 1.2.0)                  0x00000020U */\n# define SSL_OP_SAFARI_ECDHE_ECDSA_BUG                   0x00000040U\n/*\n * Reserved value (until OpenSSL 1.2.0)                  0x00000080U\n * Reserved value (until OpenSSL 1.2.0)                  0x00000100U\n * Reserved value (until OpenSSL 1.2.0)                  0x00000200U\n */\n\n/* In TLSv1.3 allow a non-(ec)dhe based kex_mode */\n# define SSL_OP_ALLOW_NO_DHE_KEX                         0x00000400U\n\n/*\n * Disable SSL 3.0/TLS 1.0 CBC vulnerability workaround that was added in\n * OpenSSL 0.9.6d.  Usually (depending on the application protocol) the\n * workaround is not needed.  Unfortunately some broken SSL/TLS\n * implementations cannot handle it at all, which is why we include it in\n * SSL_OP_ALL. Added in 0.9.6e\n */\n# define SSL_OP_DONT_INSERT_EMPTY_FRAGMENTS              0x00000800U\n\n/* DTLS options */\n# define SSL_OP_NO_QUERY_MTU                             0x00001000U\n/* Turn on Cookie Exchange (on relevant for servers) */\n# define SSL_OP_COOKIE_EXCHANGE                          0x00002000U\n/* Don't use RFC4507 ticket extension */\n# define SSL_OP_NO_TICKET                                0x00004000U\n# ifndef OPENSSL_NO_DTLS1_METHOD\n/* Use Cisco's \"speshul\" version of DTLS_BAD_VER\n * (only with deprecated DTLSv1_client_method())  */\n#  define SSL_OP_CISCO_ANYCONNECT                        0x00008000U\n# endif\n\n/* As server, disallow session resumption on renegotiation */\n# define SSL_OP_NO_SESSION_RESUMPTION_ON_RENEGOTIATION   0x00010000U\n/* Don't use compression even if supported */\n# define SSL_OP_NO_COMPRESSION                           0x00020000U\n/* Permit unsafe legacy renegotiation */\n# define SSL_OP_ALLOW_UNSAFE_LEGACY_RENEGOTIATION        0x00040000U\n/* Disable encrypt-then-mac */\n# define SSL_OP_NO_ENCRYPT_THEN_MAC                      0x00080000U\n\n/*\n * Enable TLSv1.3 Compatibility mode. This is on by default. A future version\n * of OpenSSL may have this disabled by default.\n */\n# define SSL_OP_ENABLE_MIDDLEBOX_COMPAT                  0x00100000U\n\n/* Prioritize Chacha20Poly1305 when client does.\n * Modifies SSL_OP_CIPHER_SERVER_PREFERENCE */\n# define SSL_OP_PRIORITIZE_CHACHA                        0x00200000U\n\n/*\n * Set on servers to choose the cipher according to the server's preferences\n */\n# define SSL_OP_CIPHER_SERVER_PREFERENCE                 0x00400000U\n/*\n * If set, a server will allow a client to issue a SSLv3.0 version number as\n * latest version supported in the premaster secret, even when TLSv1.0\n * (version 3.1) was announced in the client hello. Normally this is\n * forbidden to prevent version rollback attacks.\n */\n# define SSL_OP_TLS_ROLLBACK_BUG                         0x00800000U\n\n/*\n * Switches off automatic TLSv1.3 anti-replay protection for early data. This\n * is a server-side option only (no effect on the client).\n */\n# define SSL_OP_NO_ANTI_REPLAY                           0x01000000U\n\n# define SSL_OP_NO_SSLv3                                 0x02000000U\n# define SSL_OP_NO_TLSv1                                 0x04000000U\n# define SSL_OP_NO_TLSv1_2                               0x08000000U\n# define SSL_OP_NO_TLSv1_1                               0x10000000U\n# define SSL_OP_NO_TLSv1_3                               0x20000000U\n\n# define SSL_OP_NO_DTLSv1                                0x04000000U\n# define SSL_OP_NO_DTLSv1_2                              0x08000000U\n\n# define SSL_OP_NO_SSL_MASK (SSL_OP_NO_SSLv3|\\\n        SSL_OP_NO_TLSv1|SSL_OP_NO_TLSv1_1|SSL_OP_NO_TLSv1_2|SSL_OP_NO_TLSv1_3)\n# define SSL_OP_NO_DTLS_MASK (SSL_OP_NO_DTLSv1|SSL_OP_NO_DTLSv1_2)\n\n/* Disallow all renegotiation */\n# define SSL_OP_NO_RENEGOTIATION                         0x40000000U\n\n/*\n * Make server add server-hello extension from early version of cryptopro\n * draft, when GOST ciphersuite is negotiated. Required for interoperability\n * with CryptoPro CSP 3.x\n */\n# define SSL_OP_CRYPTOPRO_TLSEXT_BUG                     0x80000000U\n\n/*\n * SSL_OP_ALL: various bug workarounds that should be rather harmless.\n * This used to be 0x000FFFFFL before 0.9.7.\n * This used to be 0x80000BFFU before 1.1.1.\n */\n# define SSL_OP_ALL        (SSL_OP_CRYPTOPRO_TLSEXT_BUG|\\\n                            SSL_OP_DONT_INSERT_EMPTY_FRAGMENTS|\\\n                            SSL_OP_LEGACY_SERVER_CONNECT|\\\n                            SSL_OP_TLSEXT_PADDING|\\\n                            SSL_OP_SAFARI_ECDHE_ECDSA_BUG)\n\n/* OBSOLETE OPTIONS: retained for compatibility */\n\n/* Removed from OpenSSL 1.1.0. Was 0x00000001L */\n/* Related to removed SSLv2. */\n# define SSL_OP_MICROSOFT_SESS_ID_BUG                    0x0\n/* Removed from OpenSSL 1.1.0. Was 0x00000002L */\n/* Related to removed SSLv2. */\n# define SSL_OP_NETSCAPE_CHALLENGE_BUG                   0x0\n/* Removed from OpenSSL 0.9.8q and 1.0.0c. Was 0x00000008L */\n/* Dead forever, see CVE-2010-4180 */\n# define SSL_OP_NETSCAPE_REUSE_CIPHER_CHANGE_BUG         0x0\n/* Removed from OpenSSL 1.0.1h and 1.0.2. Was 0x00000010L */\n/* Refers to ancient SSLREF and SSLv2. */\n# define SSL_OP_SSLREF2_REUSE_CERT_TYPE_BUG              0x0\n/* Removed from OpenSSL 1.1.0. Was 0x00000020 */\n# define SSL_OP_MICROSOFT_BIG_SSLV3_BUFFER               0x0\n/* Removed from OpenSSL 0.9.7h and 0.9.8b. Was 0x00000040L */\n# define SSL_OP_MSIE_SSLV2_RSA_PADDING                   0x0\n/* Removed from OpenSSL 1.1.0. Was 0x00000080 */\n/* Ancient SSLeay version. */\n# define SSL_OP_SSLEAY_080_CLIENT_DH_BUG                 0x0\n/* Removed from OpenSSL 1.1.0. Was 0x00000100L */\n# define SSL_OP_TLS_D5_BUG                               0x0\n/* Removed from OpenSSL 1.1.0. Was 0x00000200L */\n# define SSL_OP_TLS_BLOCK_PADDING_BUG                    0x0\n/* Removed from OpenSSL 1.1.0. Was 0x00080000L */\n# define SSL_OP_SINGLE_ECDH_USE                          0x0\n/* Removed from OpenSSL 1.1.0. Was 0x00100000L */\n# define SSL_OP_SINGLE_DH_USE                            0x0\n/* Removed from OpenSSL 1.0.1k and 1.0.2. Was 0x00200000L */\n# define SSL_OP_EPHEMERAL_RSA                            0x0\n/* Removed from OpenSSL 1.1.0. Was 0x01000000L */\n# define SSL_OP_NO_SSLv2                                 0x0\n/* Removed from OpenSSL 1.0.1. Was 0x08000000L */\n# define SSL_OP_PKCS1_CHECK_1                            0x0\n/* Removed from OpenSSL 1.0.1. Was 0x10000000L */\n# define SSL_OP_PKCS1_CHECK_2                            0x0\n/* Removed from OpenSSL 1.1.0. Was 0x20000000L */\n# define SSL_OP_NETSCAPE_CA_DN_BUG                       0x0\n/* Removed from OpenSSL 1.1.0. Was 0x40000000L */\n# define SSL_OP_NETSCAPE_DEMO_CIPHER_CHANGE_BUG          0x0\n\n/*\n * Allow SSL_write(..., n) to return r with 0 < r < n (i.e. report success\n * when just a single record has been written):\n */\n# define SSL_MODE_ENABLE_PARTIAL_WRITE       0x00000001U\n/*\n * Make it possible to retry SSL_write() with changed buffer location (buffer\n * contents must stay the same!); this is not the default to avoid the\n * misconception that non-blocking SSL_write() behaves like non-blocking\n * write():\n */\n# define SSL_MODE_ACCEPT_MOVING_WRITE_BUFFER 0x00000002U\n/*\n * Never bother the application with retries if the transport is blocking:\n */\n# define SSL_MODE_AUTO_RETRY 0x00000004U\n/* Don't attempt to automatically build certificate chain */\n# define SSL_MODE_NO_AUTO_CHAIN 0x00000008U\n/*\n * Save RAM by releasing read and write buffers when they're empty. (SSL3 and\n * TLS only.) Released buffers are freed.\n */\n# define SSL_MODE_RELEASE_BUFFERS 0x00000010U\n/*\n * Send the current time in the Random fields of the ClientHello and\n * ServerHello records for compatibility with hypothetical implementations\n * that require it.\n */\n# define SSL_MODE_SEND_CLIENTHELLO_TIME 0x00000020U\n# define SSL_MODE_SEND_SERVERHELLO_TIME 0x00000040U\n/*\n * Send TLS_FALLBACK_SCSV in the ClientHello. To be set only by applications\n * that reconnect with a downgraded protocol version; see\n * draft-ietf-tls-downgrade-scsv-00 for details. DO NOT ENABLE THIS if your\n * application attempts a normal handshake. Only use this in explicit\n * fallback retries, following the guidance in\n * draft-ietf-tls-downgrade-scsv-00.\n */\n# define SSL_MODE_SEND_FALLBACK_SCSV 0x00000080U\n/*\n * Support Asynchronous operation\n */\n# define SSL_MODE_ASYNC 0x00000100U\n\n/*\n * When using DTLS/SCTP, include the terminating zero in the label\n * used for computing the endpoint-pair shared secret. Required for\n * interoperability with implementations having this bug like these\n * older version of OpenSSL:\n * - OpenSSL 1.0.0 series\n * - OpenSSL 1.0.1 series\n * - OpenSSL 1.0.2 series\n * - OpenSSL 1.1.0 series\n * - OpenSSL 1.1.1 and 1.1.1a\n */\n# define SSL_MODE_DTLS_SCTP_LABEL_LENGTH_BUG 0x00000400U\n\n/* Cert related flags */\n/*\n * Many implementations ignore some aspects of the TLS standards such as\n * enforcing certificate chain algorithms. When this is set we enforce them.\n */\n# define SSL_CERT_FLAG_TLS_STRICT                0x00000001U\n\n/* Suite B modes, takes same values as certificate verify flags */\n# define SSL_CERT_FLAG_SUITEB_128_LOS_ONLY       0x10000\n/* Suite B 192 bit only mode */\n# define SSL_CERT_FLAG_SUITEB_192_LOS            0x20000\n/* Suite B 128 bit mode allowing 192 bit algorithms */\n# define SSL_CERT_FLAG_SUITEB_128_LOS            0x30000\n\n/* Perform all sorts of protocol violations for testing purposes */\n# define SSL_CERT_FLAG_BROKEN_PROTOCOL           0x10000000\n\n/* Flags for building certificate chains */\n/* Treat any existing certificates as untrusted CAs */\n# define SSL_BUILD_CHAIN_FLAG_UNTRUSTED          0x1\n/* Don't include root CA in chain */\n# define SSL_BUILD_CHAIN_FLAG_NO_ROOT            0x2\n/* Just check certificates already there */\n# define SSL_BUILD_CHAIN_FLAG_CHECK              0x4\n/* Ignore verification errors */\n# define SSL_BUILD_CHAIN_FLAG_IGNORE_ERROR       0x8\n/* Clear verification errors from queue */\n# define SSL_BUILD_CHAIN_FLAG_CLEAR_ERROR        0x10\n\n/* Flags returned by SSL_check_chain */\n/* Certificate can be used with this session */\n# define CERT_PKEY_VALID         0x1\n/* Certificate can also be used for signing */\n# define CERT_PKEY_SIGN          0x2\n/* EE certificate signing algorithm OK */\n# define CERT_PKEY_EE_SIGNATURE  0x10\n/* CA signature algorithms OK */\n# define CERT_PKEY_CA_SIGNATURE  0x20\n/* EE certificate parameters OK */\n# define CERT_PKEY_EE_PARAM      0x40\n/* CA certificate parameters OK */\n# define CERT_PKEY_CA_PARAM      0x80\n/* Signing explicitly allowed as opposed to SHA1 fallback */\n# define CERT_PKEY_EXPLICIT_SIGN 0x100\n/* Client CA issuer names match (always set for server cert) */\n# define CERT_PKEY_ISSUER_NAME   0x200\n/* Cert type matches client types (always set for server cert) */\n# define CERT_PKEY_CERT_TYPE     0x400\n/* Cert chain suitable to Suite B */\n# define CERT_PKEY_SUITEB        0x800\n\n# define SSL_CONF_FLAG_CMDLINE           0x1\n# define SSL_CONF_FLAG_FILE              0x2\n# define SSL_CONF_FLAG_CLIENT            0x4\n# define SSL_CONF_FLAG_SERVER            0x8\n# define SSL_CONF_FLAG_SHOW_ERRORS       0x10\n# define SSL_CONF_FLAG_CERTIFICATE       0x20\n# define SSL_CONF_FLAG_REQUIRE_PRIVATE   0x40\n/* Configuration value types */\n# define SSL_CONF_TYPE_UNKNOWN           0x0\n# define SSL_CONF_TYPE_STRING            0x1\n# define SSL_CONF_TYPE_FILE              0x2\n# define SSL_CONF_TYPE_DIR               0x3\n# define SSL_CONF_TYPE_NONE              0x4\n\n/* Maximum length of the application-controlled segment of a a TLSv1.3 cookie */\n# define SSL_COOKIE_LENGTH                       4096\n\n/*\n * Note: SSL[_CTX]_set_{options,mode} use |= op on the previous value, they\n * cannot be used to clear bits.\n */\n\nunsigned long SSL_CTX_get_options(const SSL_CTX *ctx);\nunsigned long SSL_get_options(const SSL *s);\nunsigned long SSL_CTX_clear_options(SSL_CTX *ctx, unsigned long op);\nunsigned long SSL_clear_options(SSL *s, unsigned long op);\nunsigned long SSL_CTX_set_options(SSL_CTX *ctx, unsigned long op);\nunsigned long SSL_set_options(SSL *s, unsigned long op);\n\n# define SSL_CTX_set_mode(ctx,op) \\\n        SSL_CTX_ctrl((ctx),SSL_CTRL_MODE,(op),NULL)\n# define SSL_CTX_clear_mode(ctx,op) \\\n        SSL_CTX_ctrl((ctx),SSL_CTRL_CLEAR_MODE,(op),NULL)\n# define SSL_CTX_get_mode(ctx) \\\n        SSL_CTX_ctrl((ctx),SSL_CTRL_MODE,0,NULL)\n# define SSL_clear_mode(ssl,op) \\\n        SSL_ctrl((ssl),SSL_CTRL_CLEAR_MODE,(op),NULL)\n# define SSL_set_mode(ssl,op) \\\n        SSL_ctrl((ssl),SSL_CTRL_MODE,(op),NULL)\n# define SSL_get_mode(ssl) \\\n        SSL_ctrl((ssl),SSL_CTRL_MODE,0,NULL)\n# define SSL_set_mtu(ssl, mtu) \\\n        SSL_ctrl((ssl),SSL_CTRL_SET_MTU,(mtu),NULL)\n# define DTLS_set_link_mtu(ssl, mtu) \\\n        SSL_ctrl((ssl),DTLS_CTRL_SET_LINK_MTU,(mtu),NULL)\n# define DTLS_get_link_min_mtu(ssl) \\\n        SSL_ctrl((ssl),DTLS_CTRL_GET_LINK_MIN_MTU,0,NULL)\n\n# define SSL_get_secure_renegotiation_support(ssl) \\\n        SSL_ctrl((ssl), SSL_CTRL_GET_RI_SUPPORT, 0, NULL)\n\n# ifndef OPENSSL_NO_HEARTBEATS\n#  define SSL_heartbeat(ssl) \\\n        SSL_ctrl((ssl),SSL_CTRL_DTLS_EXT_SEND_HEARTBEAT,0,NULL)\n# endif\n\n# define SSL_CTX_set_cert_flags(ctx,op) \\\n        SSL_CTX_ctrl((ctx),SSL_CTRL_CERT_FLAGS,(op),NULL)\n# define SSL_set_cert_flags(s,op) \\\n        SSL_ctrl((s),SSL_CTRL_CERT_FLAGS,(op),NULL)\n# define SSL_CTX_clear_cert_flags(ctx,op) \\\n        SSL_CTX_ctrl((ctx),SSL_CTRL_CLEAR_CERT_FLAGS,(op),NULL)\n# define SSL_clear_cert_flags(s,op) \\\n        SSL_ctrl((s),SSL_CTRL_CLEAR_CERT_FLAGS,(op),NULL)\n\nvoid SSL_CTX_set_msg_callback(SSL_CTX *ctx,\n                              void (*cb) (int write_p, int version,\n                                          int content_type, const void *buf,\n                                          size_t len, SSL *ssl, void *arg));\nvoid SSL_set_msg_callback(SSL *ssl,\n                          void (*cb) (int write_p, int version,\n                                      int content_type, const void *buf,\n                                      size_t len, SSL *ssl, void *arg));\n# define SSL_CTX_set_msg_callback_arg(ctx, arg) SSL_CTX_ctrl((ctx), SSL_CTRL_SET_MSG_CALLBACK_ARG, 0, (arg))\n# define SSL_set_msg_callback_arg(ssl, arg) SSL_ctrl((ssl), SSL_CTRL_SET_MSG_CALLBACK_ARG, 0, (arg))\n\n# define SSL_get_extms_support(s) \\\n        SSL_ctrl((s),SSL_CTRL_GET_EXTMS_SUPPORT,0,NULL)\n\n# ifndef OPENSSL_NO_SRP\n\n/* see tls_srp.c */\n__owur int SSL_SRP_CTX_init(SSL *s);\n__owur int SSL_CTX_SRP_CTX_init(SSL_CTX *ctx);\nint SSL_SRP_CTX_free(SSL *ctx);\nint SSL_CTX_SRP_CTX_free(SSL_CTX *ctx);\n__owur int SSL_srp_server_param_with_username(SSL *s, int *ad);\n__owur int SRP_Calc_A_param(SSL *s);\n\n# endif\n\n/* 100k max cert list */\n# define SSL_MAX_CERT_LIST_DEFAULT 1024*100\n\n# define SSL_SESSION_CACHE_MAX_SIZE_DEFAULT      (1024*20)\n\n/*\n * This callback type is used inside SSL_CTX, SSL, and in the functions that\n * set them. It is used to override the generation of SSL/TLS session IDs in\n * a server. Return value should be zero on an error, non-zero to proceed.\n * Also, callbacks should themselves check if the id they generate is unique\n * otherwise the SSL handshake will fail with an error - callbacks can do\n * this using the 'ssl' value they're passed by;\n * SSL_has_matching_session_id(ssl, id, *id_len) The length value passed in\n * is set at the maximum size the session ID can be. In SSLv3/TLSv1 it is 32\n * bytes. The callback can alter this length to be less if desired. It is\n * also an error for the callback to set the size to zero.\n */\ntypedef int (*GEN_SESSION_CB) (SSL *ssl, unsigned char *id,\n                               unsigned int *id_len);\n\n# define SSL_SESS_CACHE_OFF                      0x0000\n# define SSL_SESS_CACHE_CLIENT                   0x0001\n# define SSL_SESS_CACHE_SERVER                   0x0002\n# define SSL_SESS_CACHE_BOTH     (SSL_SESS_CACHE_CLIENT|SSL_SESS_CACHE_SERVER)\n# define SSL_SESS_CACHE_NO_AUTO_CLEAR            0x0080\n/* enough comments already ... see SSL_CTX_set_session_cache_mode(3) */\n# define SSL_SESS_CACHE_NO_INTERNAL_LOOKUP       0x0100\n# define SSL_SESS_CACHE_NO_INTERNAL_STORE        0x0200\n# define SSL_SESS_CACHE_NO_INTERNAL \\\n        (SSL_SESS_CACHE_NO_INTERNAL_LOOKUP|SSL_SESS_CACHE_NO_INTERNAL_STORE)\n\nLHASH_OF(SSL_SESSION) *SSL_CTX_sessions(SSL_CTX *ctx);\n# define SSL_CTX_sess_number(ctx) \\\n        SSL_CTX_ctrl(ctx,SSL_CTRL_SESS_NUMBER,0,NULL)\n# define SSL_CTX_sess_connect(ctx) \\\n        SSL_CTX_ctrl(ctx,SSL_CTRL_SESS_CONNECT,0,NULL)\n# define SSL_CTX_sess_connect_good(ctx) \\\n        SSL_CTX_ctrl(ctx,SSL_CTRL_SESS_CONNECT_GOOD,0,NULL)\n# define SSL_CTX_sess_connect_renegotiate(ctx) \\\n        SSL_CTX_ctrl(ctx,SSL_CTRL_SESS_CONNECT_RENEGOTIATE,0,NULL)\n# define SSL_CTX_sess_accept(ctx) \\\n        SSL_CTX_ctrl(ctx,SSL_CTRL_SESS_ACCEPT,0,NULL)\n# define SSL_CTX_sess_accept_renegotiate(ctx) \\\n        SSL_CTX_ctrl(ctx,SSL_CTRL_SESS_ACCEPT_RENEGOTIATE,0,NULL)\n# define SSL_CTX_sess_accept_good(ctx) \\\n        SSL_CTX_ctrl(ctx,SSL_CTRL_SESS_ACCEPT_GOOD,0,NULL)\n# define SSL_CTX_sess_hits(ctx) \\\n        SSL_CTX_ctrl(ctx,SSL_CTRL_SESS_HIT,0,NULL)\n# define SSL_CTX_sess_cb_hits(ctx) \\\n        SSL_CTX_ctrl(ctx,SSL_CTRL_SESS_CB_HIT,0,NULL)\n# define SSL_CTX_sess_misses(ctx) \\\n        SSL_CTX_ctrl(ctx,SSL_CTRL_SESS_MISSES,0,NULL)\n# define SSL_CTX_sess_timeouts(ctx) \\\n        SSL_CTX_ctrl(ctx,SSL_CTRL_SESS_TIMEOUTS,0,NULL)\n# define SSL_CTX_sess_cache_full(ctx) \\\n        SSL_CTX_ctrl(ctx,SSL_CTRL_SESS_CACHE_FULL,0,NULL)\n\nvoid SSL_CTX_sess_set_new_cb(SSL_CTX *ctx,\n                             int (*new_session_cb) (struct ssl_st *ssl,\n                                                    SSL_SESSION *sess));\nint (*SSL_CTX_sess_get_new_cb(SSL_CTX *ctx)) (struct ssl_st *ssl,\n                                              SSL_SESSION *sess);\nvoid SSL_CTX_sess_set_remove_cb(SSL_CTX *ctx,\n                                void (*remove_session_cb) (struct ssl_ctx_st\n                                                           *ctx,\n                                                           SSL_SESSION *sess));\nvoid (*SSL_CTX_sess_get_remove_cb(SSL_CTX *ctx)) (struct ssl_ctx_st *ctx,\n                                                  SSL_SESSION *sess);\nvoid SSL_CTX_sess_set_get_cb(SSL_CTX *ctx,\n                             SSL_SESSION *(*get_session_cb) (struct ssl_st\n                                                             *ssl,\n                                                             const unsigned char\n                                                             *data, int len,\n                                                             int *copy));\nSSL_SESSION *(*SSL_CTX_sess_get_get_cb(SSL_CTX *ctx)) (struct ssl_st *ssl,\n                                                       const unsigned char *data,\n                                                       int len, int *copy);\nvoid SSL_CTX_set_info_callback(SSL_CTX *ctx,\n                               void (*cb) (const SSL *ssl, int type, int val));\nvoid (*SSL_CTX_get_info_callback(SSL_CTX *ctx)) (const SSL *ssl, int type,\n                                                 int val);\nvoid SSL_CTX_set_client_cert_cb(SSL_CTX *ctx,\n                                int (*client_cert_cb) (SSL *ssl, X509 **x509,\n                                                       EVP_PKEY **pkey));\nint (*SSL_CTX_get_client_cert_cb(SSL_CTX *ctx)) (SSL *ssl, X509 **x509,\n                                                 EVP_PKEY **pkey);\n# ifndef OPENSSL_NO_ENGINE\n__owur int SSL_CTX_set_client_cert_engine(SSL_CTX *ctx, ENGINE *e);\n# endif\nvoid SSL_CTX_set_cookie_generate_cb(SSL_CTX *ctx,\n                                    int (*app_gen_cookie_cb) (SSL *ssl,\n                                                              unsigned char\n                                                              *cookie,\n                                                              unsigned int\n                                                              *cookie_len));\nvoid SSL_CTX_set_cookie_verify_cb(SSL_CTX *ctx,\n                                  int (*app_verify_cookie_cb) (SSL *ssl,\n                                                               const unsigned\n                                                               char *cookie,\n                                                               unsigned int\n                                                               cookie_len));\n\nvoid SSL_CTX_set_stateless_cookie_generate_cb(\n    SSL_CTX *ctx,\n    int (*gen_stateless_cookie_cb) (SSL *ssl,\n                                    unsigned char *cookie,\n                                    size_t *cookie_len));\nvoid SSL_CTX_set_stateless_cookie_verify_cb(\n    SSL_CTX *ctx,\n    int (*verify_stateless_cookie_cb) (SSL *ssl,\n                                       const unsigned char *cookie,\n                                       size_t cookie_len));\n# ifndef OPENSSL_NO_NEXTPROTONEG\n\ntypedef int (*SSL_CTX_npn_advertised_cb_func)(SSL *ssl,\n                                              const unsigned char **out,\n                                              unsigned int *outlen,\n                                              void *arg);\nvoid SSL_CTX_set_next_protos_advertised_cb(SSL_CTX *s,\n                                           SSL_CTX_npn_advertised_cb_func cb,\n                                           void *arg);\n#  define SSL_CTX_set_npn_advertised_cb SSL_CTX_set_next_protos_advertised_cb\n\ntypedef int (*SSL_CTX_npn_select_cb_func)(SSL *s,\n                                          unsigned char **out,\n                                          unsigned char *outlen,\n                                          const unsigned char *in,\n                                          unsigned int inlen,\n                                          void *arg);\nvoid SSL_CTX_set_next_proto_select_cb(SSL_CTX *s,\n                                      SSL_CTX_npn_select_cb_func cb,\n                                      void *arg);\n#  define SSL_CTX_set_npn_select_cb SSL_CTX_set_next_proto_select_cb\n\nvoid SSL_get0_next_proto_negotiated(const SSL *s, const unsigned char **data,\n                                    unsigned *len);\n#  define SSL_get0_npn_negotiated SSL_get0_next_proto_negotiated\n# endif\n\n__owur int SSL_select_next_proto(unsigned char **out, unsigned char *outlen,\n                                 const unsigned char *in, unsigned int inlen,\n                                 const unsigned char *client,\n                                 unsigned int client_len);\n\n# define OPENSSL_NPN_UNSUPPORTED 0\n# define OPENSSL_NPN_NEGOTIATED  1\n# define OPENSSL_NPN_NO_OVERLAP  2\n\n__owur int SSL_CTX_set_alpn_protos(SSL_CTX *ctx, const unsigned char *protos,\n                                   unsigned int protos_len);\n__owur int SSL_set_alpn_protos(SSL *ssl, const unsigned char *protos,\n                               unsigned int protos_len);\ntypedef int (*SSL_CTX_alpn_select_cb_func)(SSL *ssl,\n                                           const unsigned char **out,\n                                           unsigned char *outlen,\n                                           const unsigned char *in,\n                                           unsigned int inlen,\n                                           void *arg);\nvoid SSL_CTX_set_alpn_select_cb(SSL_CTX *ctx,\n                                SSL_CTX_alpn_select_cb_func cb,\n                                void *arg);\nvoid SSL_get0_alpn_selected(const SSL *ssl, const unsigned char **data,\n                            unsigned int *len);\n\n# ifndef OPENSSL_NO_PSK\n/*\n * the maximum length of the buffer given to callbacks containing the\n * resulting identity/psk\n */\n#  define PSK_MAX_IDENTITY_LEN 128\n#  define PSK_MAX_PSK_LEN 256\ntypedef unsigned int (*SSL_psk_client_cb_func)(SSL *ssl,\n                                               const char *hint,\n                                               char *identity,\n                                               unsigned int max_identity_len,\n                                               unsigned char *psk,\n                                               unsigned int max_psk_len);\nvoid SSL_CTX_set_psk_client_callback(SSL_CTX *ctx, SSL_psk_client_cb_func cb);\nvoid SSL_set_psk_client_callback(SSL *ssl, SSL_psk_client_cb_func cb);\n\ntypedef unsigned int (*SSL_psk_server_cb_func)(SSL *ssl,\n                                               const char *identity,\n                                               unsigned char *psk,\n                                               unsigned int max_psk_len);\nvoid SSL_CTX_set_psk_server_callback(SSL_CTX *ctx, SSL_psk_server_cb_func cb);\nvoid SSL_set_psk_server_callback(SSL *ssl, SSL_psk_server_cb_func cb);\n\n__owur int SSL_CTX_use_psk_identity_hint(SSL_CTX *ctx, const char *identity_hint);\n__owur int SSL_use_psk_identity_hint(SSL *s, const char *identity_hint);\nconst char *SSL_get_psk_identity_hint(const SSL *s);\nconst char *SSL_get_psk_identity(const SSL *s);\n# endif\n\ntypedef int (*SSL_psk_find_session_cb_func)(SSL *ssl,\n                                            const unsigned char *identity,\n                                            size_t identity_len,\n                                            SSL_SESSION **sess);\ntypedef int (*SSL_psk_use_session_cb_func)(SSL *ssl, const EVP_MD *md,\n                                           const unsigned char **id,\n                                           size_t *idlen,\n                                           SSL_SESSION **sess);\n\nvoid SSL_set_psk_find_session_callback(SSL *s, SSL_psk_find_session_cb_func cb);\nvoid SSL_CTX_set_psk_find_session_callback(SSL_CTX *ctx,\n                                           SSL_psk_find_session_cb_func cb);\nvoid SSL_set_psk_use_session_callback(SSL *s, SSL_psk_use_session_cb_func cb);\nvoid SSL_CTX_set_psk_use_session_callback(SSL_CTX *ctx,\n                                          SSL_psk_use_session_cb_func cb);\n\n/* Register callbacks to handle custom TLS Extensions for client or server. */\n\n__owur int SSL_CTX_has_client_custom_ext(const SSL_CTX *ctx,\n                                         unsigned int ext_type);\n\n__owur int SSL_CTX_add_client_custom_ext(SSL_CTX *ctx,\n                                         unsigned int ext_type,\n                                         custom_ext_add_cb add_cb,\n                                         custom_ext_free_cb free_cb,\n                                         void *add_arg,\n                                         custom_ext_parse_cb parse_cb,\n                                         void *parse_arg);\n\n__owur int SSL_CTX_add_server_custom_ext(SSL_CTX *ctx,\n                                         unsigned int ext_type,\n                                         custom_ext_add_cb add_cb,\n                                         custom_ext_free_cb free_cb,\n                                         void *add_arg,\n                                         custom_ext_parse_cb parse_cb,\n                                         void *parse_arg);\n\n__owur int SSL_CTX_add_custom_ext(SSL_CTX *ctx, unsigned int ext_type,\n                                  unsigned int context,\n                                  SSL_custom_ext_add_cb_ex add_cb,\n                                  SSL_custom_ext_free_cb_ex free_cb,\n                                  void *add_arg,\n                                  SSL_custom_ext_parse_cb_ex parse_cb,\n                                  void *parse_arg);\n\n__owur int SSL_extension_supported(unsigned int ext_type);\n\n# define SSL_NOTHING            1\n# define SSL_WRITING            2\n# define SSL_READING            3\n# define SSL_X509_LOOKUP        4\n# define SSL_ASYNC_PAUSED       5\n# define SSL_ASYNC_NO_JOBS      6\n# define SSL_CLIENT_HELLO_CB    7\n\n/* These will only be used when doing non-blocking IO */\n# define SSL_want_nothing(s)         (SSL_want(s) == SSL_NOTHING)\n# define SSL_want_read(s)            (SSL_want(s) == SSL_READING)\n# define SSL_want_write(s)           (SSL_want(s) == SSL_WRITING)\n# define SSL_want_x509_lookup(s)     (SSL_want(s) == SSL_X509_LOOKUP)\n# define SSL_want_async(s)           (SSL_want(s) == SSL_ASYNC_PAUSED)\n# define SSL_want_async_job(s)       (SSL_want(s) == SSL_ASYNC_NO_JOBS)\n# define SSL_want_client_hello_cb(s) (SSL_want(s) == SSL_CLIENT_HELLO_CB)\n\n# define SSL_MAC_FLAG_READ_MAC_STREAM 1\n# define SSL_MAC_FLAG_WRITE_MAC_STREAM 2\n\n/*\n * A callback for logging out TLS key material. This callback should log out\n * |line| followed by a newline.\n */\ntypedef void (*SSL_CTX_keylog_cb_func)(const SSL *ssl, const char *line);\n\n/*\n * SSL_CTX_set_keylog_callback configures a callback to log key material. This\n * is intended for debugging use with tools like Wireshark. The cb function\n * should log line followed by a newline.\n */\nvoid SSL_CTX_set_keylog_callback(SSL_CTX *ctx, SSL_CTX_keylog_cb_func cb);\n\n/*\n * SSL_CTX_get_keylog_callback returns the callback configured by\n * SSL_CTX_set_keylog_callback.\n */\nSSL_CTX_keylog_cb_func SSL_CTX_get_keylog_callback(const SSL_CTX *ctx);\n\nint SSL_CTX_set_max_early_data(SSL_CTX *ctx, uint32_t max_early_data);\nuint32_t SSL_CTX_get_max_early_data(const SSL_CTX *ctx);\nint SSL_set_max_early_data(SSL *s, uint32_t max_early_data);\nuint32_t SSL_get_max_early_data(const SSL *s);\nint SSL_CTX_set_recv_max_early_data(SSL_CTX *ctx, uint32_t recv_max_early_data);\nuint32_t SSL_CTX_get_recv_max_early_data(const SSL_CTX *ctx);\nint SSL_set_recv_max_early_data(SSL *s, uint32_t recv_max_early_data);\nuint32_t SSL_get_recv_max_early_data(const SSL *s);\n\n#ifdef __cplusplus\n}\n#endif\n\n# include <openssl/ssl2.h>\n# include <openssl/ssl3.h>\n# include <openssl/tls1.h>      /* This is mostly sslv3 with a few tweaks */\n# include <openssl/dtls1.h>     /* Datagram TLS */\n# include <openssl/srtp.h>      /* Support for the use_srtp extension */\n\n#ifdef  __cplusplus\nextern \"C\" {\n#endif\n\n/*\n * These need to be after the above set of includes due to a compiler bug\n * in VisualStudio 2015\n */\nDEFINE_STACK_OF_CONST(SSL_CIPHER)\nDEFINE_STACK_OF(SSL_COMP)\n\n/* compatibility */\n# define SSL_set_app_data(s,arg)         (SSL_set_ex_data(s,0,(char *)(arg)))\n# define SSL_get_app_data(s)             (SSL_get_ex_data(s,0))\n# define SSL_SESSION_set_app_data(s,a)   (SSL_SESSION_set_ex_data(s,0, \\\n                                                                  (char *)(a)))\n# define SSL_SESSION_get_app_data(s)     (SSL_SESSION_get_ex_data(s,0))\n# define SSL_CTX_get_app_data(ctx)       (SSL_CTX_get_ex_data(ctx,0))\n# define SSL_CTX_set_app_data(ctx,arg)   (SSL_CTX_set_ex_data(ctx,0, \\\n                                                              (char *)(arg)))\nDEPRECATEDIN_1_1_0(void SSL_set_debug(SSL *s, int debug))\n\n/* TLSv1.3 KeyUpdate message types */\n/* -1 used so that this is an invalid value for the on-the-wire protocol */\n#define SSL_KEY_UPDATE_NONE             -1\n/* Values as defined for the on-the-wire protocol */\n#define SSL_KEY_UPDATE_NOT_REQUESTED     0\n#define SSL_KEY_UPDATE_REQUESTED         1\n\n/*\n * The valid handshake states (one for each type message sent and one for each\n * type of message received). There are also two \"special\" states:\n * TLS = TLS or DTLS state\n * DTLS = DTLS specific state\n * CR/SR = Client Read/Server Read\n * CW/SW = Client Write/Server Write\n *\n * The \"special\" states are:\n * TLS_ST_BEFORE = No handshake has been initiated yet\n * TLS_ST_OK = A handshake has been successfully completed\n */\ntypedef enum {\n    TLS_ST_BEFORE,\n    TLS_ST_OK,\n    DTLS_ST_CR_HELLO_VERIFY_REQUEST,\n    TLS_ST_CR_SRVR_HELLO,\n    TLS_ST_CR_CERT,\n    TLS_ST_CR_CERT_STATUS,\n    TLS_ST_CR_KEY_EXCH,\n    TLS_ST_CR_CERT_REQ,\n    TLS_ST_CR_SRVR_DONE,\n    TLS_ST_CR_SESSION_TICKET,\n    TLS_ST_CR_CHANGE,\n    TLS_ST_CR_FINISHED,\n    TLS_ST_CW_CLNT_HELLO,\n    TLS_ST_CW_CERT,\n    TLS_ST_CW_KEY_EXCH,\n    TLS_ST_CW_CERT_VRFY,\n    TLS_ST_CW_CHANGE,\n    TLS_ST_CW_NEXT_PROTO,\n    TLS_ST_CW_FINISHED,\n    TLS_ST_SW_HELLO_REQ,\n    TLS_ST_SR_CLNT_HELLO,\n    DTLS_ST_SW_HELLO_VERIFY_REQUEST,\n    TLS_ST_SW_SRVR_HELLO,\n    TLS_ST_SW_CERT,\n    TLS_ST_SW_KEY_EXCH,\n    TLS_ST_SW_CERT_REQ,\n    TLS_ST_SW_SRVR_DONE,\n    TLS_ST_SR_CERT,\n    TLS_ST_SR_KEY_EXCH,\n    TLS_ST_SR_CERT_VRFY,\n    TLS_ST_SR_NEXT_PROTO,\n    TLS_ST_SR_CHANGE,\n    TLS_ST_SR_FINISHED,\n    TLS_ST_SW_SESSION_TICKET,\n    TLS_ST_SW_CERT_STATUS,\n    TLS_ST_SW_CHANGE,\n    TLS_ST_SW_FINISHED,\n    TLS_ST_SW_ENCRYPTED_EXTENSIONS,\n    TLS_ST_CR_ENCRYPTED_EXTENSIONS,\n    TLS_ST_CR_CERT_VRFY,\n    TLS_ST_SW_CERT_VRFY,\n    TLS_ST_CR_HELLO_REQ,\n    TLS_ST_SW_KEY_UPDATE,\n    TLS_ST_CW_KEY_UPDATE,\n    TLS_ST_SR_KEY_UPDATE,\n    TLS_ST_CR_KEY_UPDATE,\n    TLS_ST_EARLY_DATA,\n    TLS_ST_PENDING_EARLY_DATA_END,\n    TLS_ST_CW_END_OF_EARLY_DATA,\n    TLS_ST_SR_END_OF_EARLY_DATA\n} OSSL_HANDSHAKE_STATE;\n\n/*\n * Most of the following state values are no longer used and are defined to be\n * the closest equivalent value in the current state machine code. Not all\n * defines have an equivalent and are set to a dummy value (-1). SSL_ST_CONNECT\n * and SSL_ST_ACCEPT are still in use in the definition of SSL_CB_ACCEPT_LOOP,\n * SSL_CB_ACCEPT_EXIT, SSL_CB_CONNECT_LOOP and SSL_CB_CONNECT_EXIT.\n */\n\n# define SSL_ST_CONNECT                  0x1000\n# define SSL_ST_ACCEPT                   0x2000\n\n# define SSL_ST_MASK                     0x0FFF\n\n# define SSL_CB_LOOP                     0x01\n# define SSL_CB_EXIT                     0x02\n# define SSL_CB_READ                     0x04\n# define SSL_CB_WRITE                    0x08\n# define SSL_CB_ALERT                    0x4000/* used in callback */\n# define SSL_CB_READ_ALERT               (SSL_CB_ALERT|SSL_CB_READ)\n# define SSL_CB_WRITE_ALERT              (SSL_CB_ALERT|SSL_CB_WRITE)\n# define SSL_CB_ACCEPT_LOOP              (SSL_ST_ACCEPT|SSL_CB_LOOP)\n# define SSL_CB_ACCEPT_EXIT              (SSL_ST_ACCEPT|SSL_CB_EXIT)\n# define SSL_CB_CONNECT_LOOP             (SSL_ST_CONNECT|SSL_CB_LOOP)\n# define SSL_CB_CONNECT_EXIT             (SSL_ST_CONNECT|SSL_CB_EXIT)\n# define SSL_CB_HANDSHAKE_START          0x10\n# define SSL_CB_HANDSHAKE_DONE           0x20\n\n/* Is the SSL_connection established? */\n# define SSL_in_connect_init(a)          (SSL_in_init(a) && !SSL_is_server(a))\n# define SSL_in_accept_init(a)           (SSL_in_init(a) && SSL_is_server(a))\nint SSL_in_init(const SSL *s);\nint SSL_in_before(const SSL *s);\nint SSL_is_init_finished(const SSL *s);\n\n/*\n * The following 3 states are kept in ssl->rlayer.rstate when reads fail, you\n * should not need these\n */\n# define SSL_ST_READ_HEADER                      0xF0\n# define SSL_ST_READ_BODY                        0xF1\n# define SSL_ST_READ_DONE                        0xF2\n\n/*-\n * Obtain latest Finished message\n *   -- that we sent (SSL_get_finished)\n *   -- that we expected from peer (SSL_get_peer_finished).\n * Returns length (0 == no Finished so far), copies up to 'count' bytes.\n */\nsize_t SSL_get_finished(const SSL *s, void *buf, size_t count);\nsize_t SSL_get_peer_finished(const SSL *s, void *buf, size_t count);\n\n/*\n * use either SSL_VERIFY_NONE or SSL_VERIFY_PEER, the last 3 options are\n * 'ored' with SSL_VERIFY_PEER if they are desired\n */\n# define SSL_VERIFY_NONE                 0x00\n# define SSL_VERIFY_PEER                 0x01\n# define SSL_VERIFY_FAIL_IF_NO_PEER_CERT 0x02\n# define SSL_VERIFY_CLIENT_ONCE          0x04\n# define SSL_VERIFY_POST_HANDSHAKE       0x08\n\n# if OPENSSL_API_COMPAT < 0x10100000L\n#  define OpenSSL_add_ssl_algorithms()   SSL_library_init()\n#  define SSLeay_add_ssl_algorithms()    SSL_library_init()\n# endif\n\n/* More backward compatibility */\n# define SSL_get_cipher(s) \\\n                SSL_CIPHER_get_name(SSL_get_current_cipher(s))\n# define SSL_get_cipher_bits(s,np) \\\n                SSL_CIPHER_get_bits(SSL_get_current_cipher(s),np)\n# define SSL_get_cipher_version(s) \\\n                SSL_CIPHER_get_version(SSL_get_current_cipher(s))\n# define SSL_get_cipher_name(s) \\\n                SSL_CIPHER_get_name(SSL_get_current_cipher(s))\n# define SSL_get_time(a)         SSL_SESSION_get_time(a)\n# define SSL_set_time(a,b)       SSL_SESSION_set_time((a),(b))\n# define SSL_get_timeout(a)      SSL_SESSION_get_timeout(a)\n# define SSL_set_timeout(a,b)    SSL_SESSION_set_timeout((a),(b))\n\n# define d2i_SSL_SESSION_bio(bp,s_id) ASN1_d2i_bio_of(SSL_SESSION,SSL_SESSION_new,d2i_SSL_SESSION,bp,s_id)\n# define i2d_SSL_SESSION_bio(bp,s_id) ASN1_i2d_bio_of(SSL_SESSION,i2d_SSL_SESSION,bp,s_id)\n\nDECLARE_PEM_rw(SSL_SESSION, SSL_SESSION)\n# define SSL_AD_REASON_OFFSET            1000/* offset to get SSL_R_... value\n                                              * from SSL_AD_... */\n/* These alert types are for SSLv3 and TLSv1 */\n# define SSL_AD_CLOSE_NOTIFY             SSL3_AD_CLOSE_NOTIFY\n/* fatal */\n# define SSL_AD_UNEXPECTED_MESSAGE       SSL3_AD_UNEXPECTED_MESSAGE\n/* fatal */\n# define SSL_AD_BAD_RECORD_MAC           SSL3_AD_BAD_RECORD_MAC\n# define SSL_AD_DECRYPTION_FAILED        TLS1_AD_DECRYPTION_FAILED\n# define SSL_AD_RECORD_OVERFLOW          TLS1_AD_RECORD_OVERFLOW\n/* fatal */\n# define SSL_AD_DECOMPRESSION_FAILURE    SSL3_AD_DECOMPRESSION_FAILURE\n/* fatal */\n# define SSL_AD_HANDSHAKE_FAILURE        SSL3_AD_HANDSHAKE_FAILURE\n/* Not for TLS */\n# define SSL_AD_NO_CERTIFICATE           SSL3_AD_NO_CERTIFICATE\n# define SSL_AD_BAD_CERTIFICATE          SSL3_AD_BAD_CERTIFICATE\n# define SSL_AD_UNSUPPORTED_CERTIFICATE  SSL3_AD_UNSUPPORTED_CERTIFICATE\n# define SSL_AD_CERTIFICATE_REVOKED      SSL3_AD_CERTIFICATE_REVOKED\n# define SSL_AD_CERTIFICATE_EXPIRED      SSL3_AD_CERTIFICATE_EXPIRED\n# define SSL_AD_CERTIFICATE_UNKNOWN      SSL3_AD_CERTIFICATE_UNKNOWN\n/* fatal */\n# define SSL_AD_ILLEGAL_PARAMETER        SSL3_AD_ILLEGAL_PARAMETER\n/* fatal */\n# define SSL_AD_UNKNOWN_CA               TLS1_AD_UNKNOWN_CA\n/* fatal */\n# define SSL_AD_ACCESS_DENIED            TLS1_AD_ACCESS_DENIED\n/* fatal */\n# define SSL_AD_DECODE_ERROR             TLS1_AD_DECODE_ERROR\n# define SSL_AD_DECRYPT_ERROR            TLS1_AD_DECRYPT_ERROR\n/* fatal */\n# define SSL_AD_EXPORT_RESTRICTION       TLS1_AD_EXPORT_RESTRICTION\n/* fatal */\n# define SSL_AD_PROTOCOL_VERSION         TLS1_AD_PROTOCOL_VERSION\n/* fatal */\n# define SSL_AD_INSUFFICIENT_SECURITY    TLS1_AD_INSUFFICIENT_SECURITY\n/* fatal */\n# define SSL_AD_INTERNAL_ERROR           TLS1_AD_INTERNAL_ERROR\n# define SSL_AD_USER_CANCELLED           TLS1_AD_USER_CANCELLED\n# define SSL_AD_NO_RENEGOTIATION         TLS1_AD_NO_RENEGOTIATION\n# define SSL_AD_MISSING_EXTENSION        TLS13_AD_MISSING_EXTENSION\n# define SSL_AD_CERTIFICATE_REQUIRED     TLS13_AD_CERTIFICATE_REQUIRED\n# define SSL_AD_UNSUPPORTED_EXTENSION    TLS1_AD_UNSUPPORTED_EXTENSION\n# define SSL_AD_CERTIFICATE_UNOBTAINABLE TLS1_AD_CERTIFICATE_UNOBTAINABLE\n# define SSL_AD_UNRECOGNIZED_NAME        TLS1_AD_UNRECOGNIZED_NAME\n# define SSL_AD_BAD_CERTIFICATE_STATUS_RESPONSE TLS1_AD_BAD_CERTIFICATE_STATUS_RESPONSE\n# define SSL_AD_BAD_CERTIFICATE_HASH_VALUE TLS1_AD_BAD_CERTIFICATE_HASH_VALUE\n/* fatal */\n# define SSL_AD_UNKNOWN_PSK_IDENTITY     TLS1_AD_UNKNOWN_PSK_IDENTITY\n/* fatal */\n# define SSL_AD_INAPPROPRIATE_FALLBACK   TLS1_AD_INAPPROPRIATE_FALLBACK\n# define SSL_AD_NO_APPLICATION_PROTOCOL  TLS1_AD_NO_APPLICATION_PROTOCOL\n# define SSL_ERROR_NONE                  0\n# define SSL_ERROR_SSL                   1\n# define SSL_ERROR_WANT_READ             2\n# define SSL_ERROR_WANT_WRITE            3\n# define SSL_ERROR_WANT_X509_LOOKUP      4\n# define SSL_ERROR_SYSCALL               5/* look at error stack/return\n                                           * value/errno */\n# define SSL_ERROR_ZERO_RETURN           6\n# define SSL_ERROR_WANT_CONNECT          7\n# define SSL_ERROR_WANT_ACCEPT           8\n# define SSL_ERROR_WANT_ASYNC            9\n# define SSL_ERROR_WANT_ASYNC_JOB       10\n# define SSL_ERROR_WANT_CLIENT_HELLO_CB 11\n# define SSL_CTRL_SET_TMP_DH                     3\n# define SSL_CTRL_SET_TMP_ECDH                   4\n# define SSL_CTRL_SET_TMP_DH_CB                  6\n# define SSL_CTRL_GET_CLIENT_CERT_REQUEST        9\n# define SSL_CTRL_GET_NUM_RENEGOTIATIONS         10\n# define SSL_CTRL_CLEAR_NUM_RENEGOTIATIONS       11\n# define SSL_CTRL_GET_TOTAL_RENEGOTIATIONS       12\n# define SSL_CTRL_GET_FLAGS                      13\n# define SSL_CTRL_EXTRA_CHAIN_CERT               14\n# define SSL_CTRL_SET_MSG_CALLBACK               15\n# define SSL_CTRL_SET_MSG_CALLBACK_ARG           16\n/* only applies to datagram connections */\n# define SSL_CTRL_SET_MTU                17\n/* Stats */\n# define SSL_CTRL_SESS_NUMBER                    20\n# define SSL_CTRL_SESS_CONNECT                   21\n# define SSL_CTRL_SESS_CONNECT_GOOD              22\n# define SSL_CTRL_SESS_CONNECT_RENEGOTIATE       23\n# define SSL_CTRL_SESS_ACCEPT                    24\n# define SSL_CTRL_SESS_ACCEPT_GOOD               25\n# define SSL_CTRL_SESS_ACCEPT_RENEGOTIATE        26\n# define SSL_CTRL_SESS_HIT                       27\n# define SSL_CTRL_SESS_CB_HIT                    28\n# define SSL_CTRL_SESS_MISSES                    29\n# define SSL_CTRL_SESS_TIMEOUTS                  30\n# define SSL_CTRL_SESS_CACHE_FULL                31\n# define SSL_CTRL_MODE                           33\n# define SSL_CTRL_GET_READ_AHEAD                 40\n# define SSL_CTRL_SET_READ_AHEAD                 41\n# define SSL_CTRL_SET_SESS_CACHE_SIZE            42\n# define SSL_CTRL_GET_SESS_CACHE_SIZE            43\n# define SSL_CTRL_SET_SESS_CACHE_MODE            44\n# define SSL_CTRL_GET_SESS_CACHE_MODE            45\n# define SSL_CTRL_GET_MAX_CERT_LIST              50\n# define SSL_CTRL_SET_MAX_CERT_LIST              51\n# define SSL_CTRL_SET_MAX_SEND_FRAGMENT          52\n/* see tls1.h for macros based on these */\n# define SSL_CTRL_SET_TLSEXT_SERVERNAME_CB       53\n# define SSL_CTRL_SET_TLSEXT_SERVERNAME_ARG      54\n# define SSL_CTRL_SET_TLSEXT_HOSTNAME            55\n# define SSL_CTRL_SET_TLSEXT_DEBUG_CB            56\n# define SSL_CTRL_SET_TLSEXT_DEBUG_ARG           57\n# define SSL_CTRL_GET_TLSEXT_TICKET_KEYS         58\n# define SSL_CTRL_SET_TLSEXT_TICKET_KEYS         59\n/*# define SSL_CTRL_SET_TLSEXT_OPAQUE_PRF_INPUT    60 */\n/*# define SSL_CTRL_SET_TLSEXT_OPAQUE_PRF_INPUT_CB 61 */\n/*# define SSL_CTRL_SET_TLSEXT_OPAQUE_PRF_INPUT_CB_ARG 62 */\n# define SSL_CTRL_SET_TLSEXT_STATUS_REQ_CB       63\n# define SSL_CTRL_SET_TLSEXT_STATUS_REQ_CB_ARG   64\n# define SSL_CTRL_SET_TLSEXT_STATUS_REQ_TYPE     65\n# define SSL_CTRL_GET_TLSEXT_STATUS_REQ_EXTS     66\n# define SSL_CTRL_SET_TLSEXT_STATUS_REQ_EXTS     67\n# define SSL_CTRL_GET_TLSEXT_STATUS_REQ_IDS      68\n# define SSL_CTRL_SET_TLSEXT_STATUS_REQ_IDS      69\n# define SSL_CTRL_GET_TLSEXT_STATUS_REQ_OCSP_RESP        70\n# define SSL_CTRL_SET_TLSEXT_STATUS_REQ_OCSP_RESP        71\n# define SSL_CTRL_SET_TLSEXT_TICKET_KEY_CB       72\n# define SSL_CTRL_SET_TLS_EXT_SRP_USERNAME_CB    75\n# define SSL_CTRL_SET_SRP_VERIFY_PARAM_CB                76\n# define SSL_CTRL_SET_SRP_GIVE_CLIENT_PWD_CB             77\n# define SSL_CTRL_SET_SRP_ARG            78\n# define SSL_CTRL_SET_TLS_EXT_SRP_USERNAME               79\n# define SSL_CTRL_SET_TLS_EXT_SRP_STRENGTH               80\n# define SSL_CTRL_SET_TLS_EXT_SRP_PASSWORD               81\n# ifndef OPENSSL_NO_HEARTBEATS\n#  define SSL_CTRL_DTLS_EXT_SEND_HEARTBEAT               85\n#  define SSL_CTRL_GET_DTLS_EXT_HEARTBEAT_PENDING        86\n#  define SSL_CTRL_SET_DTLS_EXT_HEARTBEAT_NO_REQUESTS    87\n# endif\n# define DTLS_CTRL_GET_TIMEOUT           73\n# define DTLS_CTRL_HANDLE_TIMEOUT        74\n# define SSL_CTRL_GET_RI_SUPPORT                 76\n# define SSL_CTRL_CLEAR_MODE                     78\n# define SSL_CTRL_SET_NOT_RESUMABLE_SESS_CB      79\n# define SSL_CTRL_GET_EXTRA_CHAIN_CERTS          82\n# define SSL_CTRL_CLEAR_EXTRA_CHAIN_CERTS        83\n# define SSL_CTRL_CHAIN                          88\n# define SSL_CTRL_CHAIN_CERT                     89\n# define SSL_CTRL_GET_GROUPS                     90\n# define SSL_CTRL_SET_GROUPS                     91\n# define SSL_CTRL_SET_GROUPS_LIST                92\n# define SSL_CTRL_GET_SHARED_GROUP               93\n# define SSL_CTRL_SET_SIGALGS                    97\n# define SSL_CTRL_SET_SIGALGS_LIST               98\n# define SSL_CTRL_CERT_FLAGS                     99\n# define SSL_CTRL_CLEAR_CERT_FLAGS               100\n# define SSL_CTRL_SET_CLIENT_SIGALGS             101\n# define SSL_CTRL_SET_CLIENT_SIGALGS_LIST        102\n# define SSL_CTRL_GET_CLIENT_CERT_TYPES          103\n# define SSL_CTRL_SET_CLIENT_CERT_TYPES          104\n# define SSL_CTRL_BUILD_CERT_CHAIN               105\n# define SSL_CTRL_SET_VERIFY_CERT_STORE          106\n# define SSL_CTRL_SET_CHAIN_CERT_STORE           107\n# define SSL_CTRL_GET_PEER_SIGNATURE_NID         108\n# define SSL_CTRL_GET_PEER_TMP_KEY               109\n# define SSL_CTRL_GET_RAW_CIPHERLIST             110\n# define SSL_CTRL_GET_EC_POINT_FORMATS           111\n# define SSL_CTRL_GET_CHAIN_CERTS                115\n# define SSL_CTRL_SELECT_CURRENT_CERT            116\n# define SSL_CTRL_SET_CURRENT_CERT               117\n# define SSL_CTRL_SET_DH_AUTO                    118\n# define DTLS_CTRL_SET_LINK_MTU                  120\n# define DTLS_CTRL_GET_LINK_MIN_MTU              121\n# define SSL_CTRL_GET_EXTMS_SUPPORT              122\n# define SSL_CTRL_SET_MIN_PROTO_VERSION          123\n# define SSL_CTRL_SET_MAX_PROTO_VERSION          124\n# define SSL_CTRL_SET_SPLIT_SEND_FRAGMENT        125\n# define SSL_CTRL_SET_MAX_PIPELINES              126\n# define SSL_CTRL_GET_TLSEXT_STATUS_REQ_TYPE     127\n# define SSL_CTRL_GET_TLSEXT_STATUS_REQ_CB       128\n# define SSL_CTRL_GET_TLSEXT_STATUS_REQ_CB_ARG   129\n# define SSL_CTRL_GET_MIN_PROTO_VERSION          130\n# define SSL_CTRL_GET_MAX_PROTO_VERSION          131\n# define SSL_CTRL_GET_SIGNATURE_NID              132\n# define SSL_CTRL_GET_TMP_KEY                    133\n# define SSL_CERT_SET_FIRST                      1\n# define SSL_CERT_SET_NEXT                       2\n# define SSL_CERT_SET_SERVER                     3\n# define DTLSv1_get_timeout(ssl, arg) \\\n        SSL_ctrl(ssl,DTLS_CTRL_GET_TIMEOUT,0, (void *)(arg))\n# define DTLSv1_handle_timeout(ssl) \\\n        SSL_ctrl(ssl,DTLS_CTRL_HANDLE_TIMEOUT,0, NULL)\n# define SSL_num_renegotiations(ssl) \\\n        SSL_ctrl((ssl),SSL_CTRL_GET_NUM_RENEGOTIATIONS,0,NULL)\n# define SSL_clear_num_renegotiations(ssl) \\\n        SSL_ctrl((ssl),SSL_CTRL_CLEAR_NUM_RENEGOTIATIONS,0,NULL)\n# define SSL_total_renegotiations(ssl) \\\n        SSL_ctrl((ssl),SSL_CTRL_GET_TOTAL_RENEGOTIATIONS,0,NULL)\n# define SSL_CTX_set_tmp_dh(ctx,dh) \\\n        SSL_CTX_ctrl(ctx,SSL_CTRL_SET_TMP_DH,0,(char *)(dh))\n# define SSL_CTX_set_tmp_ecdh(ctx,ecdh) \\\n        SSL_CTX_ctrl(ctx,SSL_CTRL_SET_TMP_ECDH,0,(char *)(ecdh))\n# define SSL_CTX_set_dh_auto(ctx, onoff) \\\n        SSL_CTX_ctrl(ctx,SSL_CTRL_SET_DH_AUTO,onoff,NULL)\n# define SSL_set_dh_auto(s, onoff) \\\n        SSL_ctrl(s,SSL_CTRL_SET_DH_AUTO,onoff,NULL)\n# define SSL_set_tmp_dh(ssl,dh) \\\n        SSL_ctrl(ssl,SSL_CTRL_SET_TMP_DH,0,(char *)(dh))\n# define SSL_set_tmp_ecdh(ssl,ecdh) \\\n        SSL_ctrl(ssl,SSL_CTRL_SET_TMP_ECDH,0,(char *)(ecdh))\n# define SSL_CTX_add_extra_chain_cert(ctx,x509) \\\n        SSL_CTX_ctrl(ctx,SSL_CTRL_EXTRA_CHAIN_CERT,0,(char *)(x509))\n# define SSL_CTX_get_extra_chain_certs(ctx,px509) \\\n        SSL_CTX_ctrl(ctx,SSL_CTRL_GET_EXTRA_CHAIN_CERTS,0,px509)\n# define SSL_CTX_get_extra_chain_certs_only(ctx,px509) \\\n        SSL_CTX_ctrl(ctx,SSL_CTRL_GET_EXTRA_CHAIN_CERTS,1,px509)\n# define SSL_CTX_clear_extra_chain_certs(ctx) \\\n        SSL_CTX_ctrl(ctx,SSL_CTRL_CLEAR_EXTRA_CHAIN_CERTS,0,NULL)\n# define SSL_CTX_set0_chain(ctx,sk) \\\n        SSL_CTX_ctrl(ctx,SSL_CTRL_CHAIN,0,(char *)(sk))\n# define SSL_CTX_set1_chain(ctx,sk) \\\n        SSL_CTX_ctrl(ctx,SSL_CTRL_CHAIN,1,(char *)(sk))\n# define SSL_CTX_add0_chain_cert(ctx,x509) \\\n        SSL_CTX_ctrl(ctx,SSL_CTRL_CHAIN_CERT,0,(char *)(x509))\n# define SSL_CTX_add1_chain_cert(ctx,x509) \\\n        SSL_CTX_ctrl(ctx,SSL_CTRL_CHAIN_CERT,1,(char *)(x509))\n# define SSL_CTX_get0_chain_certs(ctx,px509) \\\n        SSL_CTX_ctrl(ctx,SSL_CTRL_GET_CHAIN_CERTS,0,px509)\n# define SSL_CTX_clear_chain_certs(ctx) \\\n        SSL_CTX_set0_chain(ctx,NULL)\n# define SSL_CTX_build_cert_chain(ctx, flags) \\\n        SSL_CTX_ctrl(ctx,SSL_CTRL_BUILD_CERT_CHAIN, flags, NULL)\n# define SSL_CTX_select_current_cert(ctx,x509) \\\n        SSL_CTX_ctrl(ctx,SSL_CTRL_SELECT_CURRENT_CERT,0,(char *)(x509))\n# define SSL_CTX_set_current_cert(ctx, op) \\\n        SSL_CTX_ctrl(ctx,SSL_CTRL_SET_CURRENT_CERT, op, NULL)\n# define SSL_CTX_set0_verify_cert_store(ctx,st) \\\n        SSL_CTX_ctrl(ctx,SSL_CTRL_SET_VERIFY_CERT_STORE,0,(char *)(st))\n# define SSL_CTX_set1_verify_cert_store(ctx,st) \\\n        SSL_CTX_ctrl(ctx,SSL_CTRL_SET_VERIFY_CERT_STORE,1,(char *)(st))\n# define SSL_CTX_set0_chain_cert_store(ctx,st) \\\n        SSL_CTX_ctrl(ctx,SSL_CTRL_SET_CHAIN_CERT_STORE,0,(char *)(st))\n# define SSL_CTX_set1_chain_cert_store(ctx,st) \\\n        SSL_CTX_ctrl(ctx,SSL_CTRL_SET_CHAIN_CERT_STORE,1,(char *)(st))\n# define SSL_set0_chain(s,sk) \\\n        SSL_ctrl(s,SSL_CTRL_CHAIN,0,(char *)(sk))\n# define SSL_set1_chain(s,sk) \\\n        SSL_ctrl(s,SSL_CTRL_CHAIN,1,(char *)(sk))\n# define SSL_add0_chain_cert(s,x509) \\\n        SSL_ctrl(s,SSL_CTRL_CHAIN_CERT,0,(char *)(x509))\n# define SSL_add1_chain_cert(s,x509) \\\n        SSL_ctrl(s,SSL_CTRL_CHAIN_CERT,1,(char *)(x509))\n# define SSL_get0_chain_certs(s,px509) \\\n        SSL_ctrl(s,SSL_CTRL_GET_CHAIN_CERTS,0,px509)\n# define SSL_clear_chain_certs(s) \\\n        SSL_set0_chain(s,NULL)\n# define SSL_build_cert_chain(s, flags) \\\n        SSL_ctrl(s,SSL_CTRL_BUILD_CERT_CHAIN, flags, NULL)\n# define SSL_select_current_cert(s,x509) \\\n        SSL_ctrl(s,SSL_CTRL_SELECT_CURRENT_CERT,0,(char *)(x509))\n# define SSL_set_current_cert(s,op) \\\n        SSL_ctrl(s,SSL_CTRL_SET_CURRENT_CERT, op, NULL)\n# define SSL_set0_verify_cert_store(s,st) \\\n        SSL_ctrl(s,SSL_CTRL_SET_VERIFY_CERT_STORE,0,(char *)(st))\n# define SSL_set1_verify_cert_store(s,st) \\\n        SSL_ctrl(s,SSL_CTRL_SET_VERIFY_CERT_STORE,1,(char *)(st))\n# define SSL_set0_chain_cert_store(s,st) \\\n        SSL_ctrl(s,SSL_CTRL_SET_CHAIN_CERT_STORE,0,(char *)(st))\n# define SSL_set1_chain_cert_store(s,st) \\\n        SSL_ctrl(s,SSL_CTRL_SET_CHAIN_CERT_STORE,1,(char *)(st))\n# define SSL_get1_groups(s, glist) \\\n        SSL_ctrl(s,SSL_CTRL_GET_GROUPS,0,(int*)(glist))\n# define SSL_CTX_set1_groups(ctx, glist, glistlen) \\\n        SSL_CTX_ctrl(ctx,SSL_CTRL_SET_GROUPS,glistlen,(char *)(glist))\n# define SSL_CTX_set1_groups_list(ctx, s) \\\n        SSL_CTX_ctrl(ctx,SSL_CTRL_SET_GROUPS_LIST,0,(char *)(s))\n# define SSL_set1_groups(s, glist, glistlen) \\\n        SSL_ctrl(s,SSL_CTRL_SET_GROUPS,glistlen,(char *)(glist))\n# define SSL_set1_groups_list(s, str) \\\n        SSL_ctrl(s,SSL_CTRL_SET_GROUPS_LIST,0,(char *)(str))\n# define SSL_get_shared_group(s, n) \\\n        SSL_ctrl(s,SSL_CTRL_GET_SHARED_GROUP,n,NULL)\n# define SSL_CTX_set1_sigalgs(ctx, slist, slistlen) \\\n        SSL_CTX_ctrl(ctx,SSL_CTRL_SET_SIGALGS,slistlen,(int *)(slist))\n# define SSL_CTX_set1_sigalgs_list(ctx, s) \\\n        SSL_CTX_ctrl(ctx,SSL_CTRL_SET_SIGALGS_LIST,0,(char *)(s))\n# define SSL_set1_sigalgs(s, slist, slistlen) \\\n        SSL_ctrl(s,SSL_CTRL_SET_SIGALGS,slistlen,(int *)(slist))\n# define SSL_set1_sigalgs_list(s, str) \\\n        SSL_ctrl(s,SSL_CTRL_SET_SIGALGS_LIST,0,(char *)(str))\n# define SSL_CTX_set1_client_sigalgs(ctx, slist, slistlen) \\\n        SSL_CTX_ctrl(ctx,SSL_CTRL_SET_CLIENT_SIGALGS,slistlen,(int *)(slist))\n# define SSL_CTX_set1_client_sigalgs_list(ctx, s) \\\n        SSL_CTX_ctrl(ctx,SSL_CTRL_SET_CLIENT_SIGALGS_LIST,0,(char *)(s))\n# define SSL_set1_client_sigalgs(s, slist, slistlen) \\\n        SSL_ctrl(s,SSL_CTRL_SET_CLIENT_SIGALGS,slistlen,(int *)(slist))\n# define SSL_set1_client_sigalgs_list(s, str) \\\n        SSL_ctrl(s,SSL_CTRL_SET_CLIENT_SIGALGS_LIST,0,(char *)(str))\n# define SSL_get0_certificate_types(s, clist) \\\n        SSL_ctrl(s, SSL_CTRL_GET_CLIENT_CERT_TYPES, 0, (char *)(clist))\n# define SSL_CTX_set1_client_certificate_types(ctx, clist, clistlen) \\\n        SSL_CTX_ctrl(ctx,SSL_CTRL_SET_CLIENT_CERT_TYPES,clistlen, \\\n                     (char *)(clist))\n# define SSL_set1_client_certificate_types(s, clist, clistlen) \\\n        SSL_ctrl(s,SSL_CTRL_SET_CLIENT_CERT_TYPES,clistlen,(char *)(clist))\n# define SSL_get_signature_nid(s, pn) \\\n        SSL_ctrl(s,SSL_CTRL_GET_SIGNATURE_NID,0,pn)\n# define SSL_get_peer_signature_nid(s, pn) \\\n        SSL_ctrl(s,SSL_CTRL_GET_PEER_SIGNATURE_NID,0,pn)\n# define SSL_get_peer_tmp_key(s, pk) \\\n        SSL_ctrl(s,SSL_CTRL_GET_PEER_TMP_KEY,0,pk)\n# define SSL_get_tmp_key(s, pk) \\\n        SSL_ctrl(s,SSL_CTRL_GET_TMP_KEY,0,pk)\n# define SSL_get0_raw_cipherlist(s, plst) \\\n        SSL_ctrl(s,SSL_CTRL_GET_RAW_CIPHERLIST,0,plst)\n# define SSL_get0_ec_point_formats(s, plst) \\\n        SSL_ctrl(s,SSL_CTRL_GET_EC_POINT_FORMATS,0,plst)\n# define SSL_CTX_set_min_proto_version(ctx, version) \\\n        SSL_CTX_ctrl(ctx, SSL_CTRL_SET_MIN_PROTO_VERSION, version, NULL)\n# define SSL_CTX_set_max_proto_version(ctx, version) \\\n        SSL_CTX_ctrl(ctx, SSL_CTRL_SET_MAX_PROTO_VERSION, version, NULL)\n# define SSL_CTX_get_min_proto_version(ctx) \\\n        SSL_CTX_ctrl(ctx, SSL_CTRL_GET_MIN_PROTO_VERSION, 0, NULL)\n# define SSL_CTX_get_max_proto_version(ctx) \\\n        SSL_CTX_ctrl(ctx, SSL_CTRL_GET_MAX_PROTO_VERSION, 0, NULL)\n# define SSL_set_min_proto_version(s, version) \\\n        SSL_ctrl(s, SSL_CTRL_SET_MIN_PROTO_VERSION, version, NULL)\n# define SSL_set_max_proto_version(s, version) \\\n        SSL_ctrl(s, SSL_CTRL_SET_MAX_PROTO_VERSION, version, NULL)\n# define SSL_get_min_proto_version(s) \\\n        SSL_ctrl(s, SSL_CTRL_GET_MIN_PROTO_VERSION, 0, NULL)\n# define SSL_get_max_proto_version(s) \\\n        SSL_ctrl(s, SSL_CTRL_GET_MAX_PROTO_VERSION, 0, NULL)\n\n/* Backwards compatibility, original 1.1.0 names */\n# define SSL_CTRL_GET_SERVER_TMP_KEY \\\n         SSL_CTRL_GET_PEER_TMP_KEY\n# define SSL_get_server_tmp_key(s, pk) \\\n         SSL_get_peer_tmp_key(s, pk)\n\n/*\n * The following symbol names are old and obsolete. They are kept\n * for compatibility reasons only and should not be used anymore.\n */\n# define SSL_CTRL_GET_CURVES           SSL_CTRL_GET_GROUPS\n# define SSL_CTRL_SET_CURVES           SSL_CTRL_SET_GROUPS\n# define SSL_CTRL_SET_CURVES_LIST      SSL_CTRL_SET_GROUPS_LIST\n# define SSL_CTRL_GET_SHARED_CURVE     SSL_CTRL_GET_SHARED_GROUP\n\n# define SSL_get1_curves               SSL_get1_groups\n# define SSL_CTX_set1_curves           SSL_CTX_set1_groups\n# define SSL_CTX_set1_curves_list      SSL_CTX_set1_groups_list\n# define SSL_set1_curves               SSL_set1_groups\n# define SSL_set1_curves_list          SSL_set1_groups_list\n# define SSL_get_shared_curve          SSL_get_shared_group\n\n\n# if OPENSSL_API_COMPAT < 0x10100000L\n/* Provide some compatibility macros for removed functionality. */\n#  define SSL_CTX_need_tmp_RSA(ctx)                0\n#  define SSL_CTX_set_tmp_rsa(ctx,rsa)             1\n#  define SSL_need_tmp_RSA(ssl)                    0\n#  define SSL_set_tmp_rsa(ssl,rsa)                 1\n#  define SSL_CTX_set_ecdh_auto(dummy, onoff)      ((onoff) != 0)\n#  define SSL_set_ecdh_auto(dummy, onoff)          ((onoff) != 0)\n/*\n * We \"pretend\" to call the callback to avoid warnings about unused static\n * functions.\n */\n#  define SSL_CTX_set_tmp_rsa_callback(ctx, cb)    while(0) (cb)(NULL, 0, 0)\n#  define SSL_set_tmp_rsa_callback(ssl, cb)        while(0) (cb)(NULL, 0, 0)\n# endif\n__owur const BIO_METHOD *BIO_f_ssl(void);\n__owur BIO *BIO_new_ssl(SSL_CTX *ctx, int client);\n__owur BIO *BIO_new_ssl_connect(SSL_CTX *ctx);\n__owur BIO *BIO_new_buffer_ssl_connect(SSL_CTX *ctx);\n__owur int BIO_ssl_copy_session_id(BIO *to, BIO *from);\nvoid BIO_ssl_shutdown(BIO *ssl_bio);\n\n__owur int SSL_CTX_set_cipher_list(SSL_CTX *, const char *str);\n__owur SSL_CTX *SSL_CTX_new(const SSL_METHOD *meth);\nint SSL_CTX_up_ref(SSL_CTX *ctx);\nvoid SSL_CTX_free(SSL_CTX *);\n__owur long SSL_CTX_set_timeout(SSL_CTX *ctx, long t);\n__owur long SSL_CTX_get_timeout(const SSL_CTX *ctx);\n__owur X509_STORE *SSL_CTX_get_cert_store(const SSL_CTX *);\nvoid SSL_CTX_set_cert_store(SSL_CTX *, X509_STORE *);\nvoid SSL_CTX_set1_cert_store(SSL_CTX *, X509_STORE *);\n__owur int SSL_want(const SSL *s);\n__owur int SSL_clear(SSL *s);\n\nvoid SSL_CTX_flush_sessions(SSL_CTX *ctx, long tm);\n\n__owur const SSL_CIPHER *SSL_get_current_cipher(const SSL *s);\n__owur const SSL_CIPHER *SSL_get_pending_cipher(const SSL *s);\n__owur int SSL_CIPHER_get_bits(const SSL_CIPHER *c, int *alg_bits);\n__owur const char *SSL_CIPHER_get_version(const SSL_CIPHER *c);\n__owur const char *SSL_CIPHER_get_name(const SSL_CIPHER *c);\n__owur const char *SSL_CIPHER_standard_name(const SSL_CIPHER *c);\n__owur const char *OPENSSL_cipher_name(const char *rfc_name);\n__owur uint32_t SSL_CIPHER_get_id(const SSL_CIPHER *c);\n__owur uint16_t SSL_CIPHER_get_protocol_id(const SSL_CIPHER *c);\n__owur int SSL_CIPHER_get_kx_nid(const SSL_CIPHER *c);\n__owur int SSL_CIPHER_get_auth_nid(const SSL_CIPHER *c);\n__owur const EVP_MD *SSL_CIPHER_get_handshake_digest(const SSL_CIPHER *c);\n__owur int SSL_CIPHER_is_aead(const SSL_CIPHER *c);\n\n__owur int SSL_get_fd(const SSL *s);\n__owur int SSL_get_rfd(const SSL *s);\n__owur int SSL_get_wfd(const SSL *s);\n__owur const char *SSL_get_cipher_list(const SSL *s, int n);\n__owur char *SSL_get_shared_ciphers(const SSL *s, char *buf, int size);\n__owur int SSL_get_read_ahead(const SSL *s);\n__owur int SSL_pending(const SSL *s);\n__owur int SSL_has_pending(const SSL *s);\n# ifndef OPENSSL_NO_SOCK\n__owur int SSL_set_fd(SSL *s, int fd);\n__owur int SSL_set_rfd(SSL *s, int fd);\n__owur int SSL_set_wfd(SSL *s, int fd);\n# endif\nvoid SSL_set0_rbio(SSL *s, BIO *rbio);\nvoid SSL_set0_wbio(SSL *s, BIO *wbio);\nvoid SSL_set_bio(SSL *s, BIO *rbio, BIO *wbio);\n__owur BIO *SSL_get_rbio(const SSL *s);\n__owur BIO *SSL_get_wbio(const SSL *s);\n__owur int SSL_set_cipher_list(SSL *s, const char *str);\n__owur int SSL_CTX_set_ciphersuites(SSL_CTX *ctx, const char *str);\n__owur int SSL_set_ciphersuites(SSL *s, const char *str);\nvoid SSL_set_read_ahead(SSL *s, int yes);\n__owur int SSL_get_verify_mode(const SSL *s);\n__owur int SSL_get_verify_depth(const SSL *s);\n__owur SSL_verify_cb SSL_get_verify_callback(const SSL *s);\nvoid SSL_set_verify(SSL *s, int mode, SSL_verify_cb callback);\nvoid SSL_set_verify_depth(SSL *s, int depth);\nvoid SSL_set_cert_cb(SSL *s, int (*cb) (SSL *ssl, void *arg), void *arg);\n# ifndef OPENSSL_NO_RSA\n__owur int SSL_use_RSAPrivateKey(SSL *ssl, RSA *rsa);\n__owur int SSL_use_RSAPrivateKey_ASN1(SSL *ssl, const unsigned char *d,\n                                      long len);\n# endif\n__owur int SSL_use_PrivateKey(SSL *ssl, EVP_PKEY *pkey);\n__owur int SSL_use_PrivateKey_ASN1(int pk, SSL *ssl, const unsigned char *d,\n                                   long len);\n__owur int SSL_use_certificate(SSL *ssl, X509 *x);\n__owur int SSL_use_certificate_ASN1(SSL *ssl, const unsigned char *d, int len);\n__owur int SSL_use_cert_and_key(SSL *ssl, X509 *x509, EVP_PKEY *privatekey,\n                                STACK_OF(X509) *chain, int override);\n\n\n/* serverinfo file format versions */\n# define SSL_SERVERINFOV1   1\n# define SSL_SERVERINFOV2   2\n\n/* Set serverinfo data for the current active cert. */\n__owur int SSL_CTX_use_serverinfo(SSL_CTX *ctx, const unsigned char *serverinfo,\n                                  size_t serverinfo_length);\n__owur int SSL_CTX_use_serverinfo_ex(SSL_CTX *ctx, unsigned int version,\n                                     const unsigned char *serverinfo,\n                                     size_t serverinfo_length);\n__owur int SSL_CTX_use_serverinfo_file(SSL_CTX *ctx, const char *file);\n\n#ifndef OPENSSL_NO_RSA\n__owur int SSL_use_RSAPrivateKey_file(SSL *ssl, const char *file, int type);\n#endif\n\n__owur int SSL_use_PrivateKey_file(SSL *ssl, const char *file, int type);\n__owur int SSL_use_certificate_file(SSL *ssl, const char *file, int type);\n\n#ifndef OPENSSL_NO_RSA\n__owur int SSL_CTX_use_RSAPrivateKey_file(SSL_CTX *ctx, const char *file,\n                                          int type);\n#endif\n__owur int SSL_CTX_use_PrivateKey_file(SSL_CTX *ctx, const char *file,\n                                       int type);\n__owur int SSL_CTX_use_certificate_file(SSL_CTX *ctx, const char *file,\n                                        int type);\n/* PEM type */\n__owur int SSL_CTX_use_certificate_chain_file(SSL_CTX *ctx, const char *file);\n__owur int SSL_use_certificate_chain_file(SSL *ssl, const char *file);\n__owur STACK_OF(X509_NAME) *SSL_load_client_CA_file(const char *file);\n__owur int SSL_add_file_cert_subjects_to_stack(STACK_OF(X509_NAME) *stackCAs,\n                                               const char *file);\nint SSL_add_dir_cert_subjects_to_stack(STACK_OF(X509_NAME) *stackCAs,\n                                       const char *dir);\n\n# if OPENSSL_API_COMPAT < 0x10100000L\n#  define SSL_load_error_strings() \\\n    OPENSSL_init_ssl(OPENSSL_INIT_LOAD_SSL_STRINGS \\\n                     | OPENSSL_INIT_LOAD_CRYPTO_STRINGS, NULL)\n# endif\n\n__owur const char *SSL_state_string(const SSL *s);\n__owur const char *SSL_rstate_string(const SSL *s);\n__owur const char *SSL_state_string_long(const SSL *s);\n__owur const char *SSL_rstate_string_long(const SSL *s);\n__owur long SSL_SESSION_get_time(const SSL_SESSION *s);\n__owur long SSL_SESSION_set_time(SSL_SESSION *s, long t);\n__owur long SSL_SESSION_get_timeout(const SSL_SESSION *s);\n__owur long SSL_SESSION_set_timeout(SSL_SESSION *s, long t);\n__owur int SSL_SESSION_get_protocol_version(const SSL_SESSION *s);\n__owur int SSL_SESSION_set_protocol_version(SSL_SESSION *s, int version);\n\n__owur const char *SSL_SESSION_get0_hostname(const SSL_SESSION *s);\n__owur int SSL_SESSION_set1_hostname(SSL_SESSION *s, const char *hostname);\nvoid SSL_SESSION_get0_alpn_selected(const SSL_SESSION *s,\n                                    const unsigned char **alpn,\n                                    size_t *len);\n__owur int SSL_SESSION_set1_alpn_selected(SSL_SESSION *s,\n                                          const unsigned char *alpn,\n                                          size_t len);\n__owur const SSL_CIPHER *SSL_SESSION_get0_cipher(const SSL_SESSION *s);\n__owur int SSL_SESSION_set_cipher(SSL_SESSION *s, const SSL_CIPHER *cipher);\n__owur int SSL_SESSION_has_ticket(const SSL_SESSION *s);\n__owur unsigned long SSL_SESSION_get_ticket_lifetime_hint(const SSL_SESSION *s);\nvoid SSL_SESSION_get0_ticket(const SSL_SESSION *s, const unsigned char **tick,\n                             size_t *len);\n__owur uint32_t SSL_SESSION_get_max_early_data(const SSL_SESSION *s);\n__owur int SSL_SESSION_set_max_early_data(SSL_SESSION *s,\n                                          uint32_t max_early_data);\n__owur int SSL_copy_session_id(SSL *to, const SSL *from);\n__owur X509 *SSL_SESSION_get0_peer(SSL_SESSION *s);\n__owur int SSL_SESSION_set1_id_context(SSL_SESSION *s,\n                                       const unsigned char *sid_ctx,\n                                       unsigned int sid_ctx_len);\n__owur int SSL_SESSION_set1_id(SSL_SESSION *s, const unsigned char *sid,\n                               unsigned int sid_len);\n__owur int SSL_SESSION_is_resumable(const SSL_SESSION *s);\n\n__owur SSL_SESSION *SSL_SESSION_new(void);\n__owur SSL_SESSION *SSL_SESSION_dup(SSL_SESSION *src);\nconst unsigned char *SSL_SESSION_get_id(const SSL_SESSION *s,\n                                        unsigned int *len);\nconst unsigned char *SSL_SESSION_get0_id_context(const SSL_SESSION *s,\n                                                 unsigned int *len);\n__owur unsigned int SSL_SESSION_get_compress_id(const SSL_SESSION *s);\n# ifndef OPENSSL_NO_STDIO\nint SSL_SESSION_print_fp(FILE *fp, const SSL_SESSION *ses);\n# endif\nint SSL_SESSION_print(BIO *fp, const SSL_SESSION *ses);\nint SSL_SESSION_print_keylog(BIO *bp, const SSL_SESSION *x);\nint SSL_SESSION_up_ref(SSL_SESSION *ses);\nvoid SSL_SESSION_free(SSL_SESSION *ses);\n__owur int i2d_SSL_SESSION(SSL_SESSION *in, unsigned char **pp);\n__owur int SSL_set_session(SSL *to, SSL_SESSION *session);\nint SSL_CTX_add_session(SSL_CTX *ctx, SSL_SESSION *session);\nint SSL_CTX_remove_session(SSL_CTX *ctx, SSL_SESSION *session);\n__owur int SSL_CTX_set_generate_session_id(SSL_CTX *ctx, GEN_SESSION_CB cb);\n__owur int SSL_set_generate_session_id(SSL *s, GEN_SESSION_CB cb);\n__owur int SSL_has_matching_session_id(const SSL *s,\n                                       const unsigned char *id,\n                                       unsigned int id_len);\nSSL_SESSION *d2i_SSL_SESSION(SSL_SESSION **a, const unsigned char **pp,\n                             long length);\n\n# ifdef HEADER_X509_H\n__owur X509 *SSL_get_peer_certificate(const SSL *s);\n# endif\n\n__owur STACK_OF(X509) *SSL_get_peer_cert_chain(const SSL *s);\n\n__owur int SSL_CTX_get_verify_mode(const SSL_CTX *ctx);\n__owur int SSL_CTX_get_verify_depth(const SSL_CTX *ctx);\n__owur SSL_verify_cb SSL_CTX_get_verify_callback(const SSL_CTX *ctx);\nvoid SSL_CTX_set_verify(SSL_CTX *ctx, int mode, SSL_verify_cb callback);\nvoid SSL_CTX_set_verify_depth(SSL_CTX *ctx, int depth);\nvoid SSL_CTX_set_cert_verify_callback(SSL_CTX *ctx,\n                                      int (*cb) (X509_STORE_CTX *, void *),\n                                      void *arg);\nvoid SSL_CTX_set_cert_cb(SSL_CTX *c, int (*cb) (SSL *ssl, void *arg),\n                         void *arg);\n# ifndef OPENSSL_NO_RSA\n__owur int SSL_CTX_use_RSAPrivateKey(SSL_CTX *ctx, RSA *rsa);\n__owur int SSL_CTX_use_RSAPrivateKey_ASN1(SSL_CTX *ctx, const unsigned char *d,\n                                          long len);\n# endif\n__owur int SSL_CTX_use_PrivateKey(SSL_CTX *ctx, EVP_PKEY *pkey);\n__owur int SSL_CTX_use_PrivateKey_ASN1(int pk, SSL_CTX *ctx,\n                                       const unsigned char *d, long len);\n__owur int SSL_CTX_use_certificate(SSL_CTX *ctx, X509 *x);\n__owur int SSL_CTX_use_certificate_ASN1(SSL_CTX *ctx, int len,\n                                        const unsigned char *d);\n__owur int SSL_CTX_use_cert_and_key(SSL_CTX *ctx, X509 *x509, EVP_PKEY *privatekey,\n                                    STACK_OF(X509) *chain, int override);\n\nvoid SSL_CTX_set_default_passwd_cb(SSL_CTX *ctx, pem_password_cb *cb);\nvoid SSL_CTX_set_default_passwd_cb_userdata(SSL_CTX *ctx, void *u);\npem_password_cb *SSL_CTX_get_default_passwd_cb(SSL_CTX *ctx);\nvoid *SSL_CTX_get_default_passwd_cb_userdata(SSL_CTX *ctx);\nvoid SSL_set_default_passwd_cb(SSL *s, pem_password_cb *cb);\nvoid SSL_set_default_passwd_cb_userdata(SSL *s, void *u);\npem_password_cb *SSL_get_default_passwd_cb(SSL *s);\nvoid *SSL_get_default_passwd_cb_userdata(SSL *s);\n\n__owur int SSL_CTX_check_private_key(const SSL_CTX *ctx);\n__owur int SSL_check_private_key(const SSL *ctx);\n\n__owur int SSL_CTX_set_session_id_context(SSL_CTX *ctx,\n                                          const unsigned char *sid_ctx,\n                                          unsigned int sid_ctx_len);\n\nSSL *SSL_new(SSL_CTX *ctx);\nint SSL_up_ref(SSL *s);\nint SSL_is_dtls(const SSL *s);\n__owur int SSL_set_session_id_context(SSL *ssl, const unsigned char *sid_ctx,\n                                      unsigned int sid_ctx_len);\n\n__owur int SSL_CTX_set_purpose(SSL_CTX *ctx, int purpose);\n__owur int SSL_set_purpose(SSL *ssl, int purpose);\n__owur int SSL_CTX_set_trust(SSL_CTX *ctx, int trust);\n__owur int SSL_set_trust(SSL *ssl, int trust);\n\n__owur int SSL_set1_host(SSL *s, const char *hostname);\n__owur int SSL_add1_host(SSL *s, const char *hostname);\n__owur const char *SSL_get0_peername(SSL *s);\nvoid SSL_set_hostflags(SSL *s, unsigned int flags);\n\n__owur int SSL_CTX_dane_enable(SSL_CTX *ctx);\n__owur int SSL_CTX_dane_mtype_set(SSL_CTX *ctx, const EVP_MD *md,\n                                  uint8_t mtype, uint8_t ord);\n__owur int SSL_dane_enable(SSL *s, const char *basedomain);\n__owur int SSL_dane_tlsa_add(SSL *s, uint8_t usage, uint8_t selector,\n                             uint8_t mtype, unsigned const char *data, size_t dlen);\n__owur int SSL_get0_dane_authority(SSL *s, X509 **mcert, EVP_PKEY **mspki);\n__owur int SSL_get0_dane_tlsa(SSL *s, uint8_t *usage, uint8_t *selector,\n                              uint8_t *mtype, unsigned const char **data,\n                              size_t *dlen);\n/*\n * Bridge opacity barrier between libcrypt and libssl, also needed to support\n * offline testing in test/danetest.c\n */\nSSL_DANE *SSL_get0_dane(SSL *ssl);\n/*\n * DANE flags\n */\nunsigned long SSL_CTX_dane_set_flags(SSL_CTX *ctx, unsigned long flags);\nunsigned long SSL_CTX_dane_clear_flags(SSL_CTX *ctx, unsigned long flags);\nunsigned long SSL_dane_set_flags(SSL *ssl, unsigned long flags);\nunsigned long SSL_dane_clear_flags(SSL *ssl, unsigned long flags);\n\n__owur int SSL_CTX_set1_param(SSL_CTX *ctx, X509_VERIFY_PARAM *vpm);\n__owur int SSL_set1_param(SSL *ssl, X509_VERIFY_PARAM *vpm);\n\n__owur X509_VERIFY_PARAM *SSL_CTX_get0_param(SSL_CTX *ctx);\n__owur X509_VERIFY_PARAM *SSL_get0_param(SSL *ssl);\n\n# ifndef OPENSSL_NO_SRP\nint SSL_CTX_set_srp_username(SSL_CTX *ctx, char *name);\nint SSL_CTX_set_srp_password(SSL_CTX *ctx, char *password);\nint SSL_CTX_set_srp_strength(SSL_CTX *ctx, int strength);\nint SSL_CTX_set_srp_client_pwd_callback(SSL_CTX *ctx,\n                                        char *(*cb) (SSL *, void *));\nint SSL_CTX_set_srp_verify_param_callback(SSL_CTX *ctx,\n                                          int (*cb) (SSL *, void *));\nint SSL_CTX_set_srp_username_callback(SSL_CTX *ctx,\n                                      int (*cb) (SSL *, int *, void *));\nint SSL_CTX_set_srp_cb_arg(SSL_CTX *ctx, void *arg);\n\nint SSL_set_srp_server_param(SSL *s, const BIGNUM *N, const BIGNUM *g,\n                             BIGNUM *sa, BIGNUM *v, char *info);\nint SSL_set_srp_server_param_pw(SSL *s, const char *user, const char *pass,\n                                const char *grp);\n\n__owur BIGNUM *SSL_get_srp_g(SSL *s);\n__owur BIGNUM *SSL_get_srp_N(SSL *s);\n\n__owur char *SSL_get_srp_username(SSL *s);\n__owur char *SSL_get_srp_userinfo(SSL *s);\n# endif\n\n/*\n * ClientHello callback and helpers.\n */\n\n# define SSL_CLIENT_HELLO_SUCCESS 1\n# define SSL_CLIENT_HELLO_ERROR   0\n# define SSL_CLIENT_HELLO_RETRY   (-1)\n\ntypedef int (*SSL_client_hello_cb_fn) (SSL *s, int *al, void *arg);\nvoid SSL_CTX_set_client_hello_cb(SSL_CTX *c, SSL_client_hello_cb_fn cb,\n                                 void *arg);\nint SSL_client_hello_isv2(SSL *s);\nunsigned int SSL_client_hello_get0_legacy_version(SSL *s);\nsize_t SSL_client_hello_get0_random(SSL *s, const unsigned char **out);\nsize_t SSL_client_hello_get0_session_id(SSL *s, const unsigned char **out);\nsize_t SSL_client_hello_get0_ciphers(SSL *s, const unsigned char **out);\nsize_t SSL_client_hello_get0_compression_methods(SSL *s,\n                                                 const unsigned char **out);\nint SSL_client_hello_get1_extensions_present(SSL *s, int **out, size_t *outlen);\nint SSL_client_hello_get0_ext(SSL *s, unsigned int type,\n                              const unsigned char **out, size_t *outlen);\n\nvoid SSL_certs_clear(SSL *s);\nvoid SSL_free(SSL *ssl);\n# ifdef OSSL_ASYNC_FD\n/*\n * Windows application developer has to include windows.h to use these.\n */\n__owur int SSL_waiting_for_async(SSL *s);\n__owur int SSL_get_all_async_fds(SSL *s, OSSL_ASYNC_FD *fds, size_t *numfds);\n__owur int SSL_get_changed_async_fds(SSL *s, OSSL_ASYNC_FD *addfd,\n                                     size_t *numaddfds, OSSL_ASYNC_FD *delfd,\n                                     size_t *numdelfds);\n# endif\n__owur int SSL_accept(SSL *ssl);\n__owur int SSL_stateless(SSL *s);\n__owur int SSL_connect(SSL *ssl);\n__owur int SSL_read(SSL *ssl, void *buf, int num);\n__owur int SSL_read_ex(SSL *ssl, void *buf, size_t num, size_t *readbytes);\n\n# define SSL_READ_EARLY_DATA_ERROR   0\n# define SSL_READ_EARLY_DATA_SUCCESS 1\n# define SSL_READ_EARLY_DATA_FINISH  2\n\n__owur int SSL_read_early_data(SSL *s, void *buf, size_t num,\n                               size_t *readbytes);\n__owur int SSL_peek(SSL *ssl, void *buf, int num);\n__owur int SSL_peek_ex(SSL *ssl, void *buf, size_t num, size_t *readbytes);\n__owur int SSL_write(SSL *ssl, const void *buf, int num);\n__owur int SSL_write_ex(SSL *s, const void *buf, size_t num, size_t *written);\n__owur int SSL_write_early_data(SSL *s, const void *buf, size_t num,\n                                size_t *written);\nlong SSL_ctrl(SSL *ssl, int cmd, long larg, void *parg);\nlong SSL_callback_ctrl(SSL *, int, void (*)(void));\nlong SSL_CTX_ctrl(SSL_CTX *ctx, int cmd, long larg, void *parg);\nlong SSL_CTX_callback_ctrl(SSL_CTX *, int, void (*)(void));\n\n# define SSL_EARLY_DATA_NOT_SENT    0\n# define SSL_EARLY_DATA_REJECTED    1\n# define SSL_EARLY_DATA_ACCEPTED    2\n\n__owur int SSL_get_early_data_status(const SSL *s);\n\n__owur int SSL_get_error(const SSL *s, int ret_code);\n__owur const char *SSL_get_version(const SSL *s);\n\n/* This sets the 'default' SSL version that SSL_new() will create */\n__owur int SSL_CTX_set_ssl_version(SSL_CTX *ctx, const SSL_METHOD *meth);\n\n# ifndef OPENSSL_NO_SSL3_METHOD\nDEPRECATEDIN_1_1_0(__owur const SSL_METHOD *SSLv3_method(void)) /* SSLv3 */\nDEPRECATEDIN_1_1_0(__owur const SSL_METHOD *SSLv3_server_method(void))\nDEPRECATEDIN_1_1_0(__owur const SSL_METHOD *SSLv3_client_method(void))\n# endif\n\n#define SSLv23_method           TLS_method\n#define SSLv23_server_method    TLS_server_method\n#define SSLv23_client_method    TLS_client_method\n\n/* Negotiate highest available SSL/TLS version */\n__owur const SSL_METHOD *TLS_method(void);\n__owur const SSL_METHOD *TLS_server_method(void);\n__owur const SSL_METHOD *TLS_client_method(void);\n\n# ifndef OPENSSL_NO_TLS1_METHOD\nDEPRECATEDIN_1_1_0(__owur const SSL_METHOD *TLSv1_method(void)) /* TLSv1.0 */\nDEPRECATEDIN_1_1_0(__owur const SSL_METHOD *TLSv1_server_method(void))\nDEPRECATEDIN_1_1_0(__owur const SSL_METHOD *TLSv1_client_method(void))\n# endif\n\n# ifndef OPENSSL_NO_TLS1_1_METHOD\nDEPRECATEDIN_1_1_0(__owur const SSL_METHOD *TLSv1_1_method(void)) /* TLSv1.1 */\nDEPRECATEDIN_1_1_0(__owur const SSL_METHOD *TLSv1_1_server_method(void))\nDEPRECATEDIN_1_1_0(__owur const SSL_METHOD *TLSv1_1_client_method(void))\n# endif\n\n# ifndef OPENSSL_NO_TLS1_2_METHOD\nDEPRECATEDIN_1_1_0(__owur const SSL_METHOD *TLSv1_2_method(void)) /* TLSv1.2 */\nDEPRECATEDIN_1_1_0(__owur const SSL_METHOD *TLSv1_2_server_method(void))\nDEPRECATEDIN_1_1_0(__owur const SSL_METHOD *TLSv1_2_client_method(void))\n# endif\n\n# ifndef OPENSSL_NO_DTLS1_METHOD\nDEPRECATEDIN_1_1_0(__owur const SSL_METHOD *DTLSv1_method(void)) /* DTLSv1.0 */\nDEPRECATEDIN_1_1_0(__owur const SSL_METHOD *DTLSv1_server_method(void))\nDEPRECATEDIN_1_1_0(__owur const SSL_METHOD *DTLSv1_client_method(void))\n# endif\n\n# ifndef OPENSSL_NO_DTLS1_2_METHOD\n/* DTLSv1.2 */\nDEPRECATEDIN_1_1_0(__owur const SSL_METHOD *DTLSv1_2_method(void))\nDEPRECATEDIN_1_1_0(__owur const SSL_METHOD *DTLSv1_2_server_method(void))\nDEPRECATEDIN_1_1_0(__owur const SSL_METHOD *DTLSv1_2_client_method(void))\n# endif\n\n__owur const SSL_METHOD *DTLS_method(void); /* DTLS 1.0 and 1.2 */\n__owur const SSL_METHOD *DTLS_server_method(void); /* DTLS 1.0 and 1.2 */\n__owur const SSL_METHOD *DTLS_client_method(void); /* DTLS 1.0 and 1.2 */\n\n__owur size_t DTLS_get_data_mtu(const SSL *s);\n\n__owur STACK_OF(SSL_CIPHER) *SSL_get_ciphers(const SSL *s);\n__owur STACK_OF(SSL_CIPHER) *SSL_CTX_get_ciphers(const SSL_CTX *ctx);\n__owur STACK_OF(SSL_CIPHER) *SSL_get_client_ciphers(const SSL *s);\n__owur STACK_OF(SSL_CIPHER) *SSL_get1_supported_ciphers(SSL *s);\n\n__owur int SSL_do_handshake(SSL *s);\nint SSL_key_update(SSL *s, int updatetype);\nint SSL_get_key_update_type(const SSL *s);\nint SSL_renegotiate(SSL *s);\nint SSL_renegotiate_abbreviated(SSL *s);\n__owur int SSL_renegotiate_pending(const SSL *s);\nint SSL_shutdown(SSL *s);\n__owur int SSL_verify_client_post_handshake(SSL *s);\nvoid SSL_CTX_set_post_handshake_auth(SSL_CTX *ctx, int val);\nvoid SSL_set_post_handshake_auth(SSL *s, int val);\n\n__owur const SSL_METHOD *SSL_CTX_get_ssl_method(const SSL_CTX *ctx);\n__owur const SSL_METHOD *SSL_get_ssl_method(const SSL *s);\n__owur int SSL_set_ssl_method(SSL *s, const SSL_METHOD *method);\n__owur const char *SSL_alert_type_string_long(int value);\n__owur const char *SSL_alert_type_string(int value);\n__owur const char *SSL_alert_desc_string_long(int value);\n__owur const char *SSL_alert_desc_string(int value);\n\nvoid SSL_set0_CA_list(SSL *s, STACK_OF(X509_NAME) *name_list);\nvoid SSL_CTX_set0_CA_list(SSL_CTX *ctx, STACK_OF(X509_NAME) *name_list);\n__owur const STACK_OF(X509_NAME) *SSL_get0_CA_list(const SSL *s);\n__owur const STACK_OF(X509_NAME) *SSL_CTX_get0_CA_list(const SSL_CTX *ctx);\n__owur int SSL_add1_to_CA_list(SSL *ssl, const X509 *x);\n__owur int SSL_CTX_add1_to_CA_list(SSL_CTX *ctx, const X509 *x);\n__owur const STACK_OF(X509_NAME) *SSL_get0_peer_CA_list(const SSL *s);\n\nvoid SSL_set_client_CA_list(SSL *s, STACK_OF(X509_NAME) *name_list);\nvoid SSL_CTX_set_client_CA_list(SSL_CTX *ctx, STACK_OF(X509_NAME) *name_list);\n__owur STACK_OF(X509_NAME) *SSL_get_client_CA_list(const SSL *s);\n__owur STACK_OF(X509_NAME) *SSL_CTX_get_client_CA_list(const SSL_CTX *s);\n__owur int SSL_add_client_CA(SSL *ssl, X509 *x);\n__owur int SSL_CTX_add_client_CA(SSL_CTX *ctx, X509 *x);\n\nvoid SSL_set_connect_state(SSL *s);\nvoid SSL_set_accept_state(SSL *s);\n\n__owur long SSL_get_default_timeout(const SSL *s);\n\n# if OPENSSL_API_COMPAT < 0x10100000L\n#  define SSL_library_init() OPENSSL_init_ssl(0, NULL)\n# endif\n\n__owur char *SSL_CIPHER_description(const SSL_CIPHER *, char *buf, int size);\n__owur STACK_OF(X509_NAME) *SSL_dup_CA_list(const STACK_OF(X509_NAME) *sk);\n\n__owur SSL *SSL_dup(SSL *ssl);\n\n__owur X509 *SSL_get_certificate(const SSL *ssl);\n/*\n * EVP_PKEY\n */\nstruct evp_pkey_st *SSL_get_privatekey(const SSL *ssl);\n\n__owur X509 *SSL_CTX_get0_certificate(const SSL_CTX *ctx);\n__owur EVP_PKEY *SSL_CTX_get0_privatekey(const SSL_CTX *ctx);\n\nvoid SSL_CTX_set_quiet_shutdown(SSL_CTX *ctx, int mode);\n__owur int SSL_CTX_get_quiet_shutdown(const SSL_CTX *ctx);\nvoid SSL_set_quiet_shutdown(SSL *ssl, int mode);\n__owur int SSL_get_quiet_shutdown(const SSL *ssl);\nvoid SSL_set_shutdown(SSL *ssl, int mode);\n__owur int SSL_get_shutdown(const SSL *ssl);\n__owur int SSL_version(const SSL *ssl);\n__owur int SSL_client_version(const SSL *s);\n__owur int SSL_CTX_set_default_verify_paths(SSL_CTX *ctx);\n__owur int SSL_CTX_set_default_verify_dir(SSL_CTX *ctx);\n__owur int SSL_CTX_set_default_verify_file(SSL_CTX *ctx);\n__owur int SSL_CTX_load_verify_locations(SSL_CTX *ctx, const char *CAfile,\n                                         const char *CApath);\n# define SSL_get0_session SSL_get_session/* just peek at pointer */\n__owur SSL_SESSION *SSL_get_session(const SSL *ssl);\n__owur SSL_SESSION *SSL_get1_session(SSL *ssl); /* obtain a reference count */\n__owur SSL_CTX *SSL_get_SSL_CTX(const SSL *ssl);\nSSL_CTX *SSL_set_SSL_CTX(SSL *ssl, SSL_CTX *ctx);\nvoid SSL_set_info_callback(SSL *ssl,\n                           void (*cb) (const SSL *ssl, int type, int val));\nvoid (*SSL_get_info_callback(const SSL *ssl)) (const SSL *ssl, int type,\n                                               int val);\n__owur OSSL_HANDSHAKE_STATE SSL_get_state(const SSL *ssl);\n\nvoid SSL_set_verify_result(SSL *ssl, long v);\n__owur long SSL_get_verify_result(const SSL *ssl);\n__owur STACK_OF(X509) *SSL_get0_verified_chain(const SSL *s);\n\n__owur size_t SSL_get_client_random(const SSL *ssl, unsigned char *out,\n                                    size_t outlen);\n__owur size_t SSL_get_server_random(const SSL *ssl, unsigned char *out,\n                                    size_t outlen);\n__owur size_t SSL_SESSION_get_master_key(const SSL_SESSION *sess,\n                                         unsigned char *out, size_t outlen);\n__owur int SSL_SESSION_set1_master_key(SSL_SESSION *sess,\n                                       const unsigned char *in, size_t len);\nuint8_t SSL_SESSION_get_max_fragment_length(const SSL_SESSION *sess);\n\n#define SSL_get_ex_new_index(l, p, newf, dupf, freef) \\\n    CRYPTO_get_ex_new_index(CRYPTO_EX_INDEX_SSL, l, p, newf, dupf, freef)\n__owur int SSL_set_ex_data(SSL *ssl, int idx, void *data);\nvoid *SSL_get_ex_data(const SSL *ssl, int idx);\n#define SSL_SESSION_get_ex_new_index(l, p, newf, dupf, freef) \\\n    CRYPTO_get_ex_new_index(CRYPTO_EX_INDEX_SSL_SESSION, l, p, newf, dupf, freef)\n__owur int SSL_SESSION_set_ex_data(SSL_SESSION *ss, int idx, void *data);\nvoid *SSL_SESSION_get_ex_data(const SSL_SESSION *ss, int idx);\n#define SSL_CTX_get_ex_new_index(l, p, newf, dupf, freef) \\\n    CRYPTO_get_ex_new_index(CRYPTO_EX_INDEX_SSL_CTX, l, p, newf, dupf, freef)\n__owur int SSL_CTX_set_ex_data(SSL_CTX *ssl, int idx, void *data);\nvoid *SSL_CTX_get_ex_data(const SSL_CTX *ssl, int idx);\n\n__owur int SSL_get_ex_data_X509_STORE_CTX_idx(void);\n\n# define SSL_CTX_sess_set_cache_size(ctx,t) \\\n        SSL_CTX_ctrl(ctx,SSL_CTRL_SET_SESS_CACHE_SIZE,t,NULL)\n# define SSL_CTX_sess_get_cache_size(ctx) \\\n        SSL_CTX_ctrl(ctx,SSL_CTRL_GET_SESS_CACHE_SIZE,0,NULL)\n# define SSL_CTX_set_session_cache_mode(ctx,m) \\\n        SSL_CTX_ctrl(ctx,SSL_CTRL_SET_SESS_CACHE_MODE,m,NULL)\n# define SSL_CTX_get_session_cache_mode(ctx) \\\n        SSL_CTX_ctrl(ctx,SSL_CTRL_GET_SESS_CACHE_MODE,0,NULL)\n\n# define SSL_CTX_get_default_read_ahead(ctx) SSL_CTX_get_read_ahead(ctx)\n# define SSL_CTX_set_default_read_ahead(ctx,m) SSL_CTX_set_read_ahead(ctx,m)\n# define SSL_CTX_get_read_ahead(ctx) \\\n        SSL_CTX_ctrl(ctx,SSL_CTRL_GET_READ_AHEAD,0,NULL)\n# define SSL_CTX_set_read_ahead(ctx,m) \\\n        SSL_CTX_ctrl(ctx,SSL_CTRL_SET_READ_AHEAD,m,NULL)\n# define SSL_CTX_get_max_cert_list(ctx) \\\n        SSL_CTX_ctrl(ctx,SSL_CTRL_GET_MAX_CERT_LIST,0,NULL)\n# define SSL_CTX_set_max_cert_list(ctx,m) \\\n        SSL_CTX_ctrl(ctx,SSL_CTRL_SET_MAX_CERT_LIST,m,NULL)\n# define SSL_get_max_cert_list(ssl) \\\n        SSL_ctrl(ssl,SSL_CTRL_GET_MAX_CERT_LIST,0,NULL)\n# define SSL_set_max_cert_list(ssl,m) \\\n        SSL_ctrl(ssl,SSL_CTRL_SET_MAX_CERT_LIST,m,NULL)\n\n# define SSL_CTX_set_max_send_fragment(ctx,m) \\\n        SSL_CTX_ctrl(ctx,SSL_CTRL_SET_MAX_SEND_FRAGMENT,m,NULL)\n# define SSL_set_max_send_fragment(ssl,m) \\\n        SSL_ctrl(ssl,SSL_CTRL_SET_MAX_SEND_FRAGMENT,m,NULL)\n# define SSL_CTX_set_split_send_fragment(ctx,m) \\\n        SSL_CTX_ctrl(ctx,SSL_CTRL_SET_SPLIT_SEND_FRAGMENT,m,NULL)\n# define SSL_set_split_send_fragment(ssl,m) \\\n        SSL_ctrl(ssl,SSL_CTRL_SET_SPLIT_SEND_FRAGMENT,m,NULL)\n# define SSL_CTX_set_max_pipelines(ctx,m) \\\n        SSL_CTX_ctrl(ctx,SSL_CTRL_SET_MAX_PIPELINES,m,NULL)\n# define SSL_set_max_pipelines(ssl,m) \\\n        SSL_ctrl(ssl,SSL_CTRL_SET_MAX_PIPELINES,m,NULL)\n\nvoid SSL_CTX_set_default_read_buffer_len(SSL_CTX *ctx, size_t len);\nvoid SSL_set_default_read_buffer_len(SSL *s, size_t len);\n\n# ifndef OPENSSL_NO_DH\n/* NB: the |keylength| is only applicable when is_export is true */\nvoid SSL_CTX_set_tmp_dh_callback(SSL_CTX *ctx,\n                                 DH *(*dh) (SSL *ssl, int is_export,\n                                            int keylength));\nvoid SSL_set_tmp_dh_callback(SSL *ssl,\n                             DH *(*dh) (SSL *ssl, int is_export,\n                                        int keylength));\n# endif\n\n__owur const COMP_METHOD *SSL_get_current_compression(const SSL *s);\n__owur const COMP_METHOD *SSL_get_current_expansion(const SSL *s);\n__owur const char *SSL_COMP_get_name(const COMP_METHOD *comp);\n__owur const char *SSL_COMP_get0_name(const SSL_COMP *comp);\n__owur int SSL_COMP_get_id(const SSL_COMP *comp);\nSTACK_OF(SSL_COMP) *SSL_COMP_get_compression_methods(void);\n__owur STACK_OF(SSL_COMP) *SSL_COMP_set0_compression_methods(STACK_OF(SSL_COMP)\n                                                             *meths);\n# if OPENSSL_API_COMPAT < 0x10100000L\n#  define SSL_COMP_free_compression_methods() while(0) continue\n# endif\n__owur int SSL_COMP_add_compression_method(int id, COMP_METHOD *cm);\n\nconst SSL_CIPHER *SSL_CIPHER_find(SSL *ssl, const unsigned char *ptr);\nint SSL_CIPHER_get_cipher_nid(const SSL_CIPHER *c);\nint SSL_CIPHER_get_digest_nid(const SSL_CIPHER *c);\nint SSL_bytes_to_cipher_list(SSL *s, const unsigned char *bytes, size_t len,\n                             int isv2format, STACK_OF(SSL_CIPHER) **sk,\n                             STACK_OF(SSL_CIPHER) **scsvs);\n\n/* TLS extensions functions */\n__owur int SSL_set_session_ticket_ext(SSL *s, void *ext_data, int ext_len);\n\n__owur int SSL_set_session_ticket_ext_cb(SSL *s,\n                                         tls_session_ticket_ext_cb_fn cb,\n                                         void *arg);\n\n/* Pre-shared secret session resumption functions */\n__owur int SSL_set_session_secret_cb(SSL *s,\n                                     tls_session_secret_cb_fn session_secret_cb,\n                                     void *arg);\n\nvoid SSL_CTX_set_not_resumable_session_callback(SSL_CTX *ctx,\n                                                int (*cb) (SSL *ssl,\n                                                           int\n                                                           is_forward_secure));\n\nvoid SSL_set_not_resumable_session_callback(SSL *ssl,\n                                            int (*cb) (SSL *ssl,\n                                                       int is_forward_secure));\n\nvoid SSL_CTX_set_record_padding_callback(SSL_CTX *ctx,\n                                         size_t (*cb) (SSL *ssl, int type,\n                                                       size_t len, void *arg));\nvoid SSL_CTX_set_record_padding_callback_arg(SSL_CTX *ctx, void *arg);\nvoid *SSL_CTX_get_record_padding_callback_arg(const SSL_CTX *ctx);\nint SSL_CTX_set_block_padding(SSL_CTX *ctx, size_t block_size);\n\nvoid SSL_set_record_padding_callback(SSL *ssl,\n                                    size_t (*cb) (SSL *ssl, int type,\n                                                  size_t len, void *arg));\nvoid SSL_set_record_padding_callback_arg(SSL *ssl, void *arg);\nvoid *SSL_get_record_padding_callback_arg(const SSL *ssl);\nint SSL_set_block_padding(SSL *ssl, size_t block_size);\n\nint SSL_set_num_tickets(SSL *s, size_t num_tickets);\nsize_t SSL_get_num_tickets(const SSL *s);\nint SSL_CTX_set_num_tickets(SSL_CTX *ctx, size_t num_tickets);\nsize_t SSL_CTX_get_num_tickets(const SSL_CTX *ctx);\n\n# if OPENSSL_API_COMPAT < 0x10100000L\n#  define SSL_cache_hit(s) SSL_session_reused(s)\n# endif\n\n__owur int SSL_session_reused(const SSL *s);\n__owur int SSL_is_server(const SSL *s);\n\n__owur __owur SSL_CONF_CTX *SSL_CONF_CTX_new(void);\nint SSL_CONF_CTX_finish(SSL_CONF_CTX *cctx);\nvoid SSL_CONF_CTX_free(SSL_CONF_CTX *cctx);\nunsigned int SSL_CONF_CTX_set_flags(SSL_CONF_CTX *cctx, unsigned int flags);\n__owur unsigned int SSL_CONF_CTX_clear_flags(SSL_CONF_CTX *cctx,\n                                             unsigned int flags);\n__owur int SSL_CONF_CTX_set1_prefix(SSL_CONF_CTX *cctx, const char *pre);\n\nvoid SSL_CONF_CTX_set_ssl(SSL_CONF_CTX *cctx, SSL *ssl);\nvoid SSL_CONF_CTX_set_ssl_ctx(SSL_CONF_CTX *cctx, SSL_CTX *ctx);\n\n__owur int SSL_CONF_cmd(SSL_CONF_CTX *cctx, const char *cmd, const char *value);\n__owur int SSL_CONF_cmd_argv(SSL_CONF_CTX *cctx, int *pargc, char ***pargv);\n__owur int SSL_CONF_cmd_value_type(SSL_CONF_CTX *cctx, const char *cmd);\n\nvoid SSL_add_ssl_module(void);\nint SSL_config(SSL *s, const char *name);\nint SSL_CTX_config(SSL_CTX *ctx, const char *name);\n\n# ifndef OPENSSL_NO_SSL_TRACE\nvoid SSL_trace(int write_p, int version, int content_type,\n               const void *buf, size_t len, SSL *ssl, void *arg);\n# endif\n\n# ifndef OPENSSL_NO_SOCK\nint DTLSv1_listen(SSL *s, BIO_ADDR *client);\n# endif\n\n# ifndef OPENSSL_NO_CT\n\n/*\n * A callback for verifying that the received SCTs are sufficient.\n * Expected to return 1 if they are sufficient, otherwise 0.\n * May return a negative integer if an error occurs.\n * A connection should be aborted if the SCTs are deemed insufficient.\n */\ntypedef int (*ssl_ct_validation_cb)(const CT_POLICY_EVAL_CTX *ctx,\n                                    const STACK_OF(SCT) *scts, void *arg);\n\n/*\n * Sets a |callback| that is invoked upon receipt of ServerHelloDone to validate\n * the received SCTs.\n * If the callback returns a non-positive result, the connection is terminated.\n * Call this function before beginning a handshake.\n * If a NULL |callback| is provided, SCT validation is disabled.\n * |arg| is arbitrary userdata that will be passed to the callback whenever it\n * is invoked. Ownership of |arg| remains with the caller.\n *\n * NOTE: A side-effect of setting a CT callback is that an OCSP stapled response\n *       will be requested.\n */\nint SSL_set_ct_validation_callback(SSL *s, ssl_ct_validation_cb callback,\n                                   void *arg);\nint SSL_CTX_set_ct_validation_callback(SSL_CTX *ctx,\n                                       ssl_ct_validation_cb callback,\n                                       void *arg);\n#define SSL_disable_ct(s) \\\n        ((void) SSL_set_validation_callback((s), NULL, NULL))\n#define SSL_CTX_disable_ct(ctx) \\\n        ((void) SSL_CTX_set_validation_callback((ctx), NULL, NULL))\n\n/*\n * The validation type enumerates the available behaviours of the built-in SSL\n * CT validation callback selected via SSL_enable_ct() and SSL_CTX_enable_ct().\n * The underlying callback is a static function in libssl.\n */\nenum {\n    SSL_CT_VALIDATION_PERMISSIVE = 0,\n    SSL_CT_VALIDATION_STRICT\n};\n\n/*\n * Enable CT by setting up a callback that implements one of the built-in\n * validation variants.  The SSL_CT_VALIDATION_PERMISSIVE variant always\n * continues the handshake, the application can make appropriate decisions at\n * handshake completion.  The SSL_CT_VALIDATION_STRICT variant requires at\n * least one valid SCT, or else handshake termination will be requested.  The\n * handshake may continue anyway if SSL_VERIFY_NONE is in effect.\n */\nint SSL_enable_ct(SSL *s, int validation_mode);\nint SSL_CTX_enable_ct(SSL_CTX *ctx, int validation_mode);\n\n/*\n * Report whether a non-NULL callback is enabled.\n */\nint SSL_ct_is_enabled(const SSL *s);\nint SSL_CTX_ct_is_enabled(const SSL_CTX *ctx);\n\n/* Gets the SCTs received from a connection */\nconst STACK_OF(SCT) *SSL_get0_peer_scts(SSL *s);\n\n/*\n * Loads the CT log list from the default location.\n * If a CTLOG_STORE has previously been set using SSL_CTX_set_ctlog_store,\n * the log information loaded from this file will be appended to the\n * CTLOG_STORE.\n * Returns 1 on success, 0 otherwise.\n */\nint SSL_CTX_set_default_ctlog_list_file(SSL_CTX *ctx);\n\n/*\n * Loads the CT log list from the specified file path.\n * If a CTLOG_STORE has previously been set using SSL_CTX_set_ctlog_store,\n * the log information loaded from this file will be appended to the\n * CTLOG_STORE.\n * Returns 1 on success, 0 otherwise.\n */\nint SSL_CTX_set_ctlog_list_file(SSL_CTX *ctx, const char *path);\n\n/*\n * Sets the CT log list used by all SSL connections created from this SSL_CTX.\n * Ownership of the CTLOG_STORE is transferred to the SSL_CTX.\n */\nvoid SSL_CTX_set0_ctlog_store(SSL_CTX *ctx, CTLOG_STORE *logs);\n\n/*\n * Gets the CT log list used by all SSL connections created from this SSL_CTX.\n * This will be NULL unless one of the following functions has been called:\n * - SSL_CTX_set_default_ctlog_list_file\n * - SSL_CTX_set_ctlog_list_file\n * - SSL_CTX_set_ctlog_store\n */\nconst CTLOG_STORE *SSL_CTX_get0_ctlog_store(const SSL_CTX *ctx);\n\n# endif /* OPENSSL_NO_CT */\n\n/* What the \"other\" parameter contains in security callback */\n/* Mask for type */\n# define SSL_SECOP_OTHER_TYPE    0xffff0000\n# define SSL_SECOP_OTHER_NONE    0\n# define SSL_SECOP_OTHER_CIPHER  (1 << 16)\n# define SSL_SECOP_OTHER_CURVE   (2 << 16)\n# define SSL_SECOP_OTHER_DH      (3 << 16)\n# define SSL_SECOP_OTHER_PKEY    (4 << 16)\n# define SSL_SECOP_OTHER_SIGALG  (5 << 16)\n# define SSL_SECOP_OTHER_CERT    (6 << 16)\n\n/* Indicated operation refers to peer key or certificate */\n# define SSL_SECOP_PEER          0x1000\n\n/* Values for \"op\" parameter in security callback */\n\n/* Called to filter ciphers */\n/* Ciphers client supports */\n# define SSL_SECOP_CIPHER_SUPPORTED      (1 | SSL_SECOP_OTHER_CIPHER)\n/* Cipher shared by client/server */\n# define SSL_SECOP_CIPHER_SHARED         (2 | SSL_SECOP_OTHER_CIPHER)\n/* Sanity check of cipher server selects */\n# define SSL_SECOP_CIPHER_CHECK          (3 | SSL_SECOP_OTHER_CIPHER)\n/* Curves supported by client */\n# define SSL_SECOP_CURVE_SUPPORTED       (4 | SSL_SECOP_OTHER_CURVE)\n/* Curves shared by client/server */\n# define SSL_SECOP_CURVE_SHARED          (5 | SSL_SECOP_OTHER_CURVE)\n/* Sanity check of curve server selects */\n# define SSL_SECOP_CURVE_CHECK           (6 | SSL_SECOP_OTHER_CURVE)\n/* Temporary DH key */\n# define SSL_SECOP_TMP_DH                (7 | SSL_SECOP_OTHER_PKEY)\n/* SSL/TLS version */\n# define SSL_SECOP_VERSION               (9 | SSL_SECOP_OTHER_NONE)\n/* Session tickets */\n# define SSL_SECOP_TICKET                (10 | SSL_SECOP_OTHER_NONE)\n/* Supported signature algorithms sent to peer */\n# define SSL_SECOP_SIGALG_SUPPORTED      (11 | SSL_SECOP_OTHER_SIGALG)\n/* Shared signature algorithm */\n# define SSL_SECOP_SIGALG_SHARED         (12 | SSL_SECOP_OTHER_SIGALG)\n/* Sanity check signature algorithm allowed */\n# define SSL_SECOP_SIGALG_CHECK          (13 | SSL_SECOP_OTHER_SIGALG)\n/* Used to get mask of supported public key signature algorithms */\n# define SSL_SECOP_SIGALG_MASK           (14 | SSL_SECOP_OTHER_SIGALG)\n/* Use to see if compression is allowed */\n# define SSL_SECOP_COMPRESSION           (15 | SSL_SECOP_OTHER_NONE)\n/* EE key in certificate */\n# define SSL_SECOP_EE_KEY                (16 | SSL_SECOP_OTHER_CERT)\n/* CA key in certificate */\n# define SSL_SECOP_CA_KEY                (17 | SSL_SECOP_OTHER_CERT)\n/* CA digest algorithm in certificate */\n# define SSL_SECOP_CA_MD                 (18 | SSL_SECOP_OTHER_CERT)\n/* Peer EE key in certificate */\n# define SSL_SECOP_PEER_EE_KEY           (SSL_SECOP_EE_KEY | SSL_SECOP_PEER)\n/* Peer CA key in certificate */\n# define SSL_SECOP_PEER_CA_KEY           (SSL_SECOP_CA_KEY | SSL_SECOP_PEER)\n/* Peer CA digest algorithm in certificate */\n# define SSL_SECOP_PEER_CA_MD            (SSL_SECOP_CA_MD | SSL_SECOP_PEER)\n\nvoid SSL_set_security_level(SSL *s, int level);\n__owur int SSL_get_security_level(const SSL *s);\nvoid SSL_set_security_callback(SSL *s,\n                               int (*cb) (const SSL *s, const SSL_CTX *ctx,\n                                          int op, int bits, int nid,\n                                          void *other, void *ex));\nint (*SSL_get_security_callback(const SSL *s)) (const SSL *s,\n                                                const SSL_CTX *ctx, int op,\n                                                int bits, int nid, void *other,\n                                                void *ex);\nvoid SSL_set0_security_ex_data(SSL *s, void *ex);\n__owur void *SSL_get0_security_ex_data(const SSL *s);\n\nvoid SSL_CTX_set_security_level(SSL_CTX *ctx, int level);\n__owur int SSL_CTX_get_security_level(const SSL_CTX *ctx);\nvoid SSL_CTX_set_security_callback(SSL_CTX *ctx,\n                                   int (*cb) (const SSL *s, const SSL_CTX *ctx,\n                                              int op, int bits, int nid,\n                                              void *other, void *ex));\nint (*SSL_CTX_get_security_callback(const SSL_CTX *ctx)) (const SSL *s,\n                                                          const SSL_CTX *ctx,\n                                                          int op, int bits,\n                                                          int nid,\n                                                          void *other,\n                                                          void *ex);\nvoid SSL_CTX_set0_security_ex_data(SSL_CTX *ctx, void *ex);\n__owur void *SSL_CTX_get0_security_ex_data(const SSL_CTX *ctx);\n\n/* OPENSSL_INIT flag 0x010000 reserved for internal use */\n# define OPENSSL_INIT_NO_LOAD_SSL_STRINGS    0x00100000L\n# define OPENSSL_INIT_LOAD_SSL_STRINGS       0x00200000L\n\n# define OPENSSL_INIT_SSL_DEFAULT \\\n        (OPENSSL_INIT_LOAD_SSL_STRINGS | OPENSSL_INIT_LOAD_CRYPTO_STRINGS)\n\nint OPENSSL_init_ssl(uint64_t opts, const OPENSSL_INIT_SETTINGS *settings);\n\n# ifndef OPENSSL_NO_UNIT_TEST\n__owur const struct openssl_ssl_test_functions *SSL_test_functions(void);\n# endif\n\n__owur int SSL_free_buffers(SSL *ssl);\n__owur int SSL_alloc_buffers(SSL *ssl);\n\n/* Status codes passed to the decrypt session ticket callback. Some of these\n * are for internal use only and are never passed to the callback. */\ntypedef int SSL_TICKET_STATUS;\n\n/* Support for ticket appdata */\n/* fatal error, malloc failure */\n# define SSL_TICKET_FATAL_ERR_MALLOC 0\n/* fatal error, either from parsing or decrypting the ticket */\n# define SSL_TICKET_FATAL_ERR_OTHER  1\n/* No ticket present */\n# define SSL_TICKET_NONE             2\n/* Empty ticket present */\n# define SSL_TICKET_EMPTY            3\n/* the ticket couldn't be decrypted */\n# define SSL_TICKET_NO_DECRYPT       4\n/* a ticket was successfully decrypted */\n# define SSL_TICKET_SUCCESS          5\n/* same as above but the ticket needs to be renewed */\n# define SSL_TICKET_SUCCESS_RENEW    6\n\n/* Return codes for the decrypt session ticket callback */\ntypedef int SSL_TICKET_RETURN;\n\n/* An error occurred */\n#define SSL_TICKET_RETURN_ABORT             0\n/* Do not use the ticket, do not send a renewed ticket to the client */\n#define SSL_TICKET_RETURN_IGNORE            1\n/* Do not use the ticket, send a renewed ticket to the client */\n#define SSL_TICKET_RETURN_IGNORE_RENEW      2\n/* Use the ticket, do not send a renewed ticket to the client */\n#define SSL_TICKET_RETURN_USE               3\n/* Use the ticket, send a renewed ticket to the client */\n#define SSL_TICKET_RETURN_USE_RENEW         4\n\ntypedef int (*SSL_CTX_generate_session_ticket_fn)(SSL *s, void *arg);\ntypedef SSL_TICKET_RETURN (*SSL_CTX_decrypt_session_ticket_fn)(SSL *s, SSL_SESSION *ss,\n                                                               const unsigned char *keyname,\n                                                               size_t keyname_length,\n                                                               SSL_TICKET_STATUS status,\n                                                               void *arg);\nint SSL_CTX_set_session_ticket_cb(SSL_CTX *ctx,\n                                  SSL_CTX_generate_session_ticket_fn gen_cb,\n                                  SSL_CTX_decrypt_session_ticket_fn dec_cb,\n                                  void *arg);\nint SSL_SESSION_set1_ticket_appdata(SSL_SESSION *ss, const void *data, size_t len);\nint SSL_SESSION_get0_ticket_appdata(SSL_SESSION *ss, void **data, size_t *len);\n\nextern const char SSL_version_str[];\n\ntypedef unsigned int (*DTLS_timer_cb)(SSL *s, unsigned int timer_us);\n\nvoid DTLS_set_timer_cb(SSL *s, DTLS_timer_cb cb);\n\n\ntypedef int (*SSL_allow_early_data_cb_fn)(SSL *s, void *arg);\nvoid SSL_CTX_set_allow_early_data_cb(SSL_CTX *ctx,\n                                     SSL_allow_early_data_cb_fn cb,\n                                     void *arg);\nvoid SSL_set_allow_early_data_cb(SSL *s,\n                                 SSL_allow_early_data_cb_fn cb,\n                                 void *arg);\n\n# ifdef  __cplusplus\n}\n# endif\n#endif\n"}, "22": {"id": 22, "path": "/home/runner/work/testcc/testcc/retdec/lib/curl_ntlm_core.c", "content": "/***************************************************************************\n *                                  _   _ ____  _\n *  Project                     ___| | | |  _ \\| |\n *                             / __| | | | |_) | |\n *                            | (__| |_| |  _ <| |___\n *                             \\___|\\___/|_| \\_\\_____|\n *\n * Copyright (C) 1998 - 2020, Daniel Stenberg, <daniel@haxx.se>, et al.\n *\n * This software is licensed as described in the file COPYING, which\n * you should have received as part of this distribution. The terms\n * are also available at https://curl.haxx.se/docs/copyright.html.\n *\n * You may opt to use, copy, modify, merge, publish, distribute and/or sell\n * copies of the Software, and permit persons to whom the Software is\n * furnished to do so, under the terms of the COPYING file.\n *\n * This software is distributed on an \"AS IS\" basis, WITHOUT WARRANTY OF ANY\n * KIND, either express or implied.\n *\n ***************************************************************************/\n\n#include \"curl_setup.h\"\n\n#if defined(USE_CURL_NTLM_CORE)\n\n/*\n * NTLM details:\n *\n * https://davenport.sourceforge.io/ntlm.html\n * https://www.innovation.ch/java/ntlm.html\n */\n\n/* Please keep the SSL backend-specific #if branches in this order:\n\n   1. USE_OPENSSL\n   2. USE_GNUTLS_NETTLE\n   3. USE_GNUTLS\n   4. USE_NSS\n   5. USE_MBEDTLS\n   6. USE_SECTRANSP\n   7. USE_OS400CRYPTO\n   8. USE_WIN32_CRYPTO\n\n   This ensures that:\n   - the same SSL branch gets activated throughout this source\n     file even if multiple backends are enabled at the same time.\n   - OpenSSL and NSS have higher priority than Windows Crypt, due\n     to issues with the latter supporting NTLM2Session responses\n     in NTLM type-3 messages.\n */\n\n#if defined(USE_OPENSSL) || defined(USE_WOLFSSL)\n\n#ifdef USE_WOLFSSL\n#include <wolfssl/options.h>\n#endif\n\n#  include <openssl/des.h>\n#  include <openssl/md5.h>\n#  include <openssl/ssl.h>\n#  include <openssl/rand.h>\n#  if (defined(OPENSSL_VERSION_NUMBER) && \\\n       (OPENSSL_VERSION_NUMBER < 0x00907001L)) && !defined(USE_WOLFSSL)\n#    define DES_key_schedule des_key_schedule\n#    define DES_cblock des_cblock\n#    define DES_set_odd_parity des_set_odd_parity\n#    define DES_set_key des_set_key\n#    define DES_ecb_encrypt des_ecb_encrypt\n#    define DESKEY(x) x\n#    define DESKEYARG(x) x\n#  else\n#    define DESKEYARG(x) *x\n#    define DESKEY(x) &x\n#  endif\n\n#elif defined(USE_GNUTLS_NETTLE)\n\n#  include <nettle/des.h>\n\n#elif defined(USE_GNUTLS)\n\n#  include <gcrypt.h>\n\n#elif defined(USE_NSS)\n\n#  include <nss.h>\n#  include <pk11pub.h>\n#  include <hasht.h>\n\n#elif defined(USE_MBEDTLS)\n\n#  include <mbedtls/des.h>\n#  include \"curl_md4.h\"\n\n#elif defined(USE_SECTRANSP)\n\n#  include <CommonCrypto/CommonCryptor.h>\n#  include <CommonCrypto/CommonDigest.h>\n\n#elif defined(USE_OS400CRYPTO)\n#  include \"cipher.mih\"  /* mih/cipher */\n#elif defined(USE_WIN32_CRYPTO)\n#  include <wincrypt.h>\n#else\n#  error \"Can't compile NTLM support without a crypto library.\"\n#endif\n\n#include \"urldata.h\"\n#include \"non-ascii.h\"\n#include \"strcase.h\"\n#include \"curl_ntlm_core.h\"\n#include \"curl_md5.h\"\n#include \"curl_hmac.h\"\n#include \"warnless.h\"\n#include \"curl_endian.h\"\n#include \"curl_des.h\"\n#include \"curl_md4.h\"\n/* The last 3 #include files should be in this order */\n#include \"curl_printf.h\"\n#include \"curl_memory.h\"\n#include \"memdebug.h\"\n\n#define NTLMv2_BLOB_SIGNATURE \"\\x01\\x01\\x00\\x00\"\n#define NTLMv2_BLOB_LEN       (44 -16 + ntlm->target_info_len + 4)\n\n/*\n* Turns a 56-bit key into being 64-bit wide.\n*/\nstatic void extend_key_56_to_64(const unsigned char *key_56, char *key)\n{\n  key[0] = key_56[0];\n  key[1] = (unsigned char)(((key_56[0] << 7) & 0xFF) | (key_56[1] >> 1));\n  key[2] = (unsigned char)(((key_56[1] << 6) & 0xFF) | (key_56[2] >> 2));\n  key[3] = (unsigned char)(((key_56[2] << 5) & 0xFF) | (key_56[3] >> 3));\n  key[4] = (unsigned char)(((key_56[3] << 4) & 0xFF) | (key_56[4] >> 4));\n  key[5] = (unsigned char)(((key_56[4] << 3) & 0xFF) | (key_56[5] >> 5));\n  key[6] = (unsigned char)(((key_56[5] << 2) & 0xFF) | (key_56[6] >> 6));\n  key[7] = (unsigned char) ((key_56[6] << 1) & 0xFF);\n}\n\n#if defined(USE_OPENSSL) || defined(USE_WOLFSSL)\n/*\n * Turns a 56 bit key into the 64 bit, odd parity key and sets the key.  The\n * key schedule ks is also set.\n */\nstatic void setup_des_key(const unsigned char *key_56,\n                          DES_key_schedule DESKEYARG(ks))\n{\n  DES_cblock key;\n\n  /* Expand the 56-bit key to 64-bits */\n  extend_key_56_to_64(key_56, (char *) &key);\n\n  /* Set the key parity to odd */\n  DES_set_odd_parity(&key);\n\n  /* Set the key */\n  DES_set_key(&key, ks);\n}\n\n#elif defined(USE_GNUTLS_NETTLE)\n\nstatic void setup_des_key(const unsigned char *key_56,\n                          struct des_ctx *des)\n{\n  char key[8];\n\n  /* Expand the 56-bit key to 64-bits */\n  extend_key_56_to_64(key_56, key);\n\n  /* Set the key parity to odd */\n  Curl_des_set_odd_parity((unsigned char *) key, sizeof(key));\n\n  /* Set the key */\n  des_set_key(des, (const uint8_t *) key);\n}\n\n#elif defined(USE_GNUTLS)\n\n/*\n * Turns a 56 bit key into the 64 bit, odd parity key and sets the key.\n */\nstatic void setup_des_key(const unsigned char *key_56,\n                          gcry_cipher_hd_t *des)\n{\n  char key[8];\n\n  /* Expand the 56-bit key to 64-bits */\n  extend_key_56_to_64(key_56, key);\n\n  /* Set the key parity to odd */\n  Curl_des_set_odd_parity((unsigned char *) key, sizeof(key));\n\n  /* Set the key */\n  gcry_cipher_setkey(*des, key, sizeof(key));\n}\n\n#elif defined(USE_NSS)\n\n/*\n * Expands a 56 bit key KEY_56 to 64 bit and encrypts 64 bit of data, using\n * the expanded key.  The caller is responsible for giving 64 bit of valid\n * data is IN and (at least) 64 bit large buffer as OUT.\n */\nstatic bool encrypt_des(const unsigned char *in, unsigned char *out,\n                        const unsigned char *key_56)\n{\n  const CK_MECHANISM_TYPE mech = CKM_DES_ECB; /* DES cipher in ECB mode */\n  char key[8];                                /* expanded 64 bit key */\n  SECItem key_item;\n  PK11SymKey *symkey = NULL;\n  SECItem *param = NULL;\n  PK11Context *ctx = NULL;\n  int out_len;                                /* not used, required by NSS */\n  bool rv = FALSE;\n\n  /* use internal slot for DES encryption (requires NSS to be initialized) */\n  PK11SlotInfo *slot = PK11_GetInternalKeySlot();\n  if(!slot)\n    return FALSE;\n\n  /* Expand the 56-bit key to 64-bits */\n  extend_key_56_to_64(key_56, key);\n\n  /* Set the key parity to odd */\n  Curl_des_set_odd_parity((unsigned char *) key, sizeof(key));\n\n  /* Import the key */\n  key_item.data = (unsigned char *)key;\n  key_item.len = sizeof(key);\n  symkey = PK11_ImportSymKey(slot, mech, PK11_OriginUnwrap, CKA_ENCRYPT,\n                             &key_item, NULL);\n  if(!symkey)\n    goto fail;\n\n  /* Create the DES encryption context */\n  param = PK11_ParamFromIV(mech, /* no IV in ECB mode */ NULL);\n  if(!param)\n    goto fail;\n  ctx = PK11_CreateContextBySymKey(mech, CKA_ENCRYPT, symkey, param);\n  if(!ctx)\n    goto fail;\n\n  /* Perform the encryption */\n  if(SECSuccess == PK11_CipherOp(ctx, out, &out_len, /* outbuflen */ 8,\n                                 (unsigned char *)in, /* inbuflen */ 8)\n      && SECSuccess == PK11_Finalize(ctx))\n    rv = /* all OK */ TRUE;\n\nfail:\n  /* cleanup */\n  if(ctx)\n    PK11_DestroyContext(ctx, PR_TRUE);\n  if(symkey)\n    PK11_FreeSymKey(symkey);\n  if(param)\n    SECITEM_FreeItem(param, PR_TRUE);\n  PK11_FreeSlot(slot);\n  return rv;\n}\n\n#elif defined(USE_MBEDTLS)\n\nstatic bool encrypt_des(const unsigned char *in, unsigned char *out,\n                        const unsigned char *key_56)\n{\n  mbedtls_des_context ctx;\n  char key[8];\n\n  /* Expand the 56-bit key to 64-bits */\n  extend_key_56_to_64(key_56, key);\n\n  /* Set the key parity to odd */\n  mbedtls_des_key_set_parity((unsigned char *) key);\n\n  /* Perform the encryption */\n  mbedtls_des_init(&ctx);\n  mbedtls_des_setkey_enc(&ctx, (unsigned char *) key);\n  return mbedtls_des_crypt_ecb(&ctx, in, out) == 0;\n}\n\n#elif defined(USE_SECTRANSP)\n\nstatic bool encrypt_des(const unsigned char *in, unsigned char *out,\n                        const unsigned char *key_56)\n{\n  char key[8];\n  size_t out_len;\n  CCCryptorStatus err;\n\n  /* Expand the 56-bit key to 64-bits */\n  extend_key_56_to_64(key_56, key);\n\n  /* Set the key parity to odd */\n  Curl_des_set_odd_parity((unsigned char *) key, sizeof(key));\n\n  /* Perform the encryption */\n  err = CCCrypt(kCCEncrypt, kCCAlgorithmDES, kCCOptionECBMode, key,\n                kCCKeySizeDES, NULL, in, 8 /* inbuflen */, out,\n                8 /* outbuflen */, &out_len);\n\n  return err == kCCSuccess;\n}\n\n#elif defined(USE_OS400CRYPTO)\n\nstatic bool encrypt_des(const unsigned char *in, unsigned char *out,\n                        const unsigned char *key_56)\n{\n  char key[8];\n  _CIPHER_Control_T ctl;\n\n  /* Setup the cipher control structure */\n  ctl.Func_ID = ENCRYPT_ONLY;\n  ctl.Data_Len = sizeof(key);\n\n  /* Expand the 56-bit key to 64-bits */\n  extend_key_56_to_64(key_56, ctl.Crypto_Key);\n\n  /* Set the key parity to odd */\n  Curl_des_set_odd_parity((unsigned char *) ctl.Crypto_Key, ctl.Data_Len);\n\n  /* Perform the encryption */\n  _CIPHER((_SPCPTR *) &out, &ctl, (_SPCPTR *) &in);\n\n  return TRUE;\n}\n\n#elif defined(USE_WIN32_CRYPTO)\n\nstatic bool encrypt_des(const unsigned char *in, unsigned char *out,\n                        const unsigned char *key_56)\n{\n  HCRYPTPROV hprov;\n  HCRYPTKEY hkey;\n  struct {\n    BLOBHEADER hdr;\n    unsigned int len;\n    char key[8];\n  } blob;\n  DWORD len = 8;\n\n  /* Acquire the crypto provider */\n  if(!CryptAcquireContext(&hprov, NULL, NULL, PROV_RSA_FULL,\n                          CRYPT_VERIFYCONTEXT | CRYPT_SILENT))\n    return FALSE;\n\n  /* Setup the key blob structure */\n  memset(&blob, 0, sizeof(blob));\n  blob.hdr.bType = PLAINTEXTKEYBLOB;\n  blob.hdr.bVersion = 2;\n  blob.hdr.aiKeyAlg = CALG_DES;\n  blob.len = sizeof(blob.key);\n\n  /* Expand the 56-bit key to 64-bits */\n  extend_key_56_to_64(key_56, blob.key);\n\n  /* Set the key parity to odd */\n  Curl_des_set_odd_parity((unsigned char *) blob.key, sizeof(blob.key));\n\n  /* Import the key */\n  if(!CryptImportKey(hprov, (BYTE *) &blob, sizeof(blob), 0, 0, &hkey)) {\n    CryptReleaseContext(hprov, 0);\n\n    return FALSE;\n  }\n\n  memcpy(out, in, 8);\n\n  /* Perform the encryption */\n  CryptEncrypt(hkey, 0, FALSE, 0, out, &len, len);\n\n  CryptDestroyKey(hkey);\n  CryptReleaseContext(hprov, 0);\n\n  return TRUE;\n}\n\n#endif /* defined(USE_WIN32_CRYPTO) */\n\n /*\n  * takes a 21 byte array and treats it as 3 56-bit DES keys. The\n  * 8 byte plaintext is encrypted with each key and the resulting 24\n  * bytes are stored in the results array.\n  */\nvoid Curl_ntlm_core_lm_resp(const unsigned char *keys,\n                            const unsigned char *plaintext,\n                            unsigned char *results)\n{\n#if defined(USE_OPENSSL) || defined(USE_WOLFSSL)\n  DES_key_schedule ks;\n\n  setup_des_key(keys, DESKEY(ks));\n  DES_ecb_encrypt((DES_cblock*) plaintext, (DES_cblock*) results,\n                  DESKEY(ks), DES_ENCRYPT);\n\n  setup_des_key(keys + 7, DESKEY(ks));\n  DES_ecb_encrypt((DES_cblock*) plaintext, (DES_cblock*) (results + 8),\n                  DESKEY(ks), DES_ENCRYPT);\n\n  setup_des_key(keys + 14, DESKEY(ks));\n  DES_ecb_encrypt((DES_cblock*) plaintext, (DES_cblock*) (results + 16),\n                  DESKEY(ks), DES_ENCRYPT);\n#elif defined(USE_GNUTLS_NETTLE)\n  struct des_ctx des;\n  setup_des_key(keys, &des);\n  des_encrypt(&des, 8, results, plaintext);\n  setup_des_key(keys + 7, &des);\n  des_encrypt(&des, 8, results + 8, plaintext);\n  setup_des_key(keys + 14, &des);\n  des_encrypt(&des, 8, results + 16, plaintext);\n#elif defined(USE_GNUTLS)\n  gcry_cipher_hd_t des;\n\n  gcry_cipher_open(&des, GCRY_CIPHER_DES, GCRY_CIPHER_MODE_ECB, 0);\n  setup_des_key(keys, &des);\n  gcry_cipher_encrypt(des, results, 8, plaintext, 8);\n  gcry_cipher_close(des);\n\n  gcry_cipher_open(&des, GCRY_CIPHER_DES, GCRY_CIPHER_MODE_ECB, 0);\n  setup_des_key(keys + 7, &des);\n  gcry_cipher_encrypt(des, results + 8, 8, plaintext, 8);\n  gcry_cipher_close(des);\n\n  gcry_cipher_open(&des, GCRY_CIPHER_DES, GCRY_CIPHER_MODE_ECB, 0);\n  setup_des_key(keys + 14, &des);\n  gcry_cipher_encrypt(des, results + 16, 8, plaintext, 8);\n  gcry_cipher_close(des);\n#elif defined(USE_NSS) || defined(USE_MBEDTLS) || defined(USE_SECTRANSP) \\\n  || defined(USE_OS400CRYPTO) || defined(USE_WIN32_CRYPTO)\n  encrypt_des(plaintext, results, keys);\n  encrypt_des(plaintext, results + 8, keys + 7);\n  encrypt_des(plaintext, results + 16, keys + 14);\n#endif\n}\n\n/*\n * Set up lanmanager hashed password\n */\nCURLcode Curl_ntlm_core_mk_lm_hash(struct Curl_easy *data,\n                                   const char *password,\n                                   unsigned char *lmbuffer /* 21 bytes */)\n{\n  CURLcode result;\n  unsigned char pw[14];\n  static const unsigned char magic[] = {\n    0x4B, 0x47, 0x53, 0x21, 0x40, 0x23, 0x24, 0x25 /* i.e. KGS!@#$% */\n  };\n  size_t len = CURLMIN(strlen(password), 14);\n\n  Curl_strntoupper((char *)pw, password, len);\n  memset(&pw[len], 0, 14 - len);\n\n  /*\n   * The LanManager hashed password needs to be created using the\n   * password in the network encoding not the host encoding.\n   */\n  result = Curl_convert_to_network(data, (char *)pw, 14);\n  if(result)\n    return result;\n\n  {\n    /* Create LanManager hashed password. */\n\n#if defined(USE_OPENSSL) || defined(USE_WOLFSSL)\n    DES_key_schedule ks;\n\n    setup_des_key(pw, DESKEY(ks));\n    DES_ecb_encrypt((DES_cblock *)magic, (DES_cblock *)lmbuffer,\n                    DESKEY(ks), DES_ENCRYPT);\n\n    setup_des_key(pw + 7, DESKEY(ks));\n    DES_ecb_encrypt((DES_cblock *)magic, (DES_cblock *)(lmbuffer + 8),\n                    DESKEY(ks), DES_ENCRYPT);\n#elif defined(USE_GNUTLS_NETTLE)\n    struct des_ctx des;\n    setup_des_key(pw, &des);\n    des_encrypt(&des, 8, lmbuffer, magic);\n    setup_des_key(pw + 7, &des);\n    des_encrypt(&des, 8, lmbuffer + 8, magic);\n#elif defined(USE_GNUTLS)\n    gcry_cipher_hd_t des;\n\n    gcry_cipher_open(&des, GCRY_CIPHER_DES, GCRY_CIPHER_MODE_ECB, 0);\n    setup_des_key(pw, &des);\n    gcry_cipher_encrypt(des, lmbuffer, 8, magic, 8);\n    gcry_cipher_close(des);\n\n    gcry_cipher_open(&des, GCRY_CIPHER_DES, GCRY_CIPHER_MODE_ECB, 0);\n    setup_des_key(pw + 7, &des);\n    gcry_cipher_encrypt(des, lmbuffer + 8, 8, magic, 8);\n    gcry_cipher_close(des);\n#elif defined(USE_NSS) || defined(USE_MBEDTLS) || defined(USE_SECTRANSP) \\\n  || defined(USE_OS400CRYPTO) || defined(USE_WIN32_CRYPTO)\n    encrypt_des(magic, lmbuffer, pw);\n    encrypt_des(magic, lmbuffer + 8, pw + 7);\n#endif\n\n    memset(lmbuffer + 16, 0, 21 - 16);\n  }\n\n  return CURLE_OK;\n}\n\n#ifdef USE_NTRESPONSES\nstatic void ascii_to_unicode_le(unsigned char *dest, const char *src,\n                                size_t srclen)\n{\n  size_t i;\n  for(i = 0; i < srclen; i++) {\n    dest[2 * i] = (unsigned char)src[i];\n    dest[2 * i + 1] = '\\0';\n  }\n}\n\n#if defined(USE_NTLM_V2) && !defined(USE_WINDOWS_SSPI)\n\nstatic void ascii_uppercase_to_unicode_le(unsigned char *dest,\n                                          const char *src, size_t srclen)\n{\n  size_t i;\n  for(i = 0; i < srclen; i++) {\n    dest[2 * i] = (unsigned char)(Curl_raw_toupper(src[i]));\n    dest[2 * i + 1] = '\\0';\n  }\n}\n\n#endif /* USE_NTLM_V2 && !USE_WINDOWS_SSPI */\n\n/*\n * Set up nt hashed passwords\n * @unittest: 1600\n */\nCURLcode Curl_ntlm_core_mk_nt_hash(struct Curl_easy *data,\n                                   const char *password,\n                                   unsigned char *ntbuffer /* 21 bytes */)\n{\n  size_t len = strlen(password);\n  unsigned char *pw;\n  CURLcode result;\n  if(len > SIZE_T_MAX/2) /* avoid integer overflow */\n    return CURLE_OUT_OF_MEMORY;\n  pw = len ? malloc(len * 2) : (unsigned char *)strdup(\"\");\n  if(!pw)\n    return CURLE_OUT_OF_MEMORY;\n\n  ascii_to_unicode_le(pw, password, len);\n\n  /*\n   * The NT hashed password needs to be created using the password in the\n   * network encoding not the host encoding.\n   */\n  result = Curl_convert_to_network(data, (char *)pw, len * 2);\n  if(result)\n    return result;\n\n  /* Create NT hashed password. */\n  Curl_md4it(ntbuffer, pw, 2 * len);\n\n  memset(ntbuffer + 16, 0, 21 - 16);\n\n  free(pw);\n\n  return CURLE_OK;\n}\n\n#if defined(USE_NTLM_V2) && !defined(USE_WINDOWS_SSPI)\n\n/* This creates the NTLMv2 hash by using NTLM hash as the key and Unicode\n * (uppercase UserName + Domain) as the data\n */\nCURLcode Curl_ntlm_core_mk_ntlmv2_hash(const char *user, size_t userlen,\n                                       const char *domain, size_t domlen,\n                                       unsigned char *ntlmhash,\n                                       unsigned char *ntlmv2hash)\n{\n  /* Unicode representation */\n  size_t identity_len;\n  unsigned char *identity;\n  CURLcode result = CURLE_OK;\n\n  /* we do the length checks below separately to avoid integer overflow risk\n     on extreme data lengths */\n  if((userlen > SIZE_T_MAX/2) ||\n     (domlen > SIZE_T_MAX/2) ||\n     ((userlen + domlen) > SIZE_T_MAX/2))\n    return CURLE_OUT_OF_MEMORY;\n\n  identity_len = (userlen + domlen) * 2;\n  identity = malloc(identity_len);\n\n  if(!identity)\n    return CURLE_OUT_OF_MEMORY;\n\n  ascii_uppercase_to_unicode_le(identity, user, userlen);\n  ascii_to_unicode_le(identity + (userlen << 1), domain, domlen);\n\n  result = Curl_hmacit(Curl_HMAC_MD5, ntlmhash, 16, identity, identity_len,\n                       ntlmv2hash);\n  free(identity);\n\n  return result;\n}\n\n/*\n * Curl_ntlm_core_mk_ntlmv2_resp()\n *\n * This creates the NTLMv2 response as set in the ntlm type-3 message.\n *\n * Parameters:\n *\n * ntlmv2hash       [in] - The ntlmv2 hash (16 bytes)\n * challenge_client [in] - The client nonce (8 bytes)\n * ntlm             [in] - The ntlm data struct being used to read TargetInfo\n                           and Server challenge received in the type-2 message\n * ntresp          [out] - The address where a pointer to newly allocated\n *                         memory holding the NTLMv2 response.\n * ntresp_len      [out] - The length of the output message.\n *\n * Returns CURLE_OK on success.\n */\nCURLcode Curl_ntlm_core_mk_ntlmv2_resp(unsigned char *ntlmv2hash,\n                                       unsigned char *challenge_client,\n                                       struct ntlmdata *ntlm,\n                                       unsigned char **ntresp,\n                                       unsigned int *ntresp_len)\n{\n/* NTLMv2 response structure :\n------------------------------------------------------------------------------\n0     HMAC MD5         16 bytes\n------BLOB--------------------------------------------------------------------\n16    Signature        0x01010000\n20    Reserved         long (0x00000000)\n24    Timestamp        LE, 64-bit signed value representing the number of\n                       tenths of a microsecond since January 1, 1601.\n32    Client Nonce     8 bytes\n40    Unknown          4 bytes\n44    Target Info      N bytes (from the type-2 message)\n44+N  Unknown          4 bytes\n------------------------------------------------------------------------------\n*/\n\n  unsigned int len = 0;\n  unsigned char *ptr = NULL;\n  unsigned char hmac_output[HMAC_MD5_LENGTH];\n  curl_off_t tw;\n\n  CURLcode result = CURLE_OK;\n\n#if CURL_SIZEOF_CURL_OFF_T < 8\n#error \"this section needs 64bit support to work\"\n#endif\n\n  /* Calculate the timestamp */\n#ifdef DEBUGBUILD\n  char *force_timestamp = getenv(\"CURL_FORCETIME\");\n  if(force_timestamp)\n    tw = CURL_OFF_T_C(11644473600) * 10000000;\n  else\n#endif\n    tw = ((curl_off_t)time(NULL) + CURL_OFF_T_C(11644473600)) * 10000000;\n\n  /* Calculate the response len */\n  len = HMAC_MD5_LENGTH + NTLMv2_BLOB_LEN;\n\n  /* Allocate the response */\n  ptr = calloc(1, len);\n  if(!ptr)\n    return CURLE_OUT_OF_MEMORY;\n\n  /* Create the BLOB structure */\n  msnprintf((char *)ptr + HMAC_MD5_LENGTH, NTLMv2_BLOB_LEN,\n            \"%c%c%c%c\"   /* NTLMv2_BLOB_SIGNATURE */\n            \"%c%c%c%c\",  /* Reserved = 0 */\n            NTLMv2_BLOB_SIGNATURE[0], NTLMv2_BLOB_SIGNATURE[1],\n            NTLMv2_BLOB_SIGNATURE[2], NTLMv2_BLOB_SIGNATURE[3],\n            0, 0, 0, 0);\n\n  Curl_write64_le(tw, ptr + 24);\n  memcpy(ptr + 32, challenge_client, 8);\n  memcpy(ptr + 44, ntlm->target_info, ntlm->target_info_len);\n\n  /* Concatenate the Type 2 challenge with the BLOB and do HMAC MD5 */\n  memcpy(ptr + 8, &ntlm->nonce[0], 8);\n  result = Curl_hmacit(Curl_HMAC_MD5, ntlmv2hash, HMAC_MD5_LENGTH, ptr + 8,\n                    NTLMv2_BLOB_LEN + 8, hmac_output);\n  if(result) {\n    free(ptr);\n    return result;\n  }\n\n  /* Concatenate the HMAC MD5 output  with the BLOB */\n  memcpy(ptr, hmac_output, HMAC_MD5_LENGTH);\n\n  /* Return the response */\n  *ntresp = ptr;\n  *ntresp_len = len;\n\n  return result;\n}\n\n/*\n * Curl_ntlm_core_mk_lmv2_resp()\n *\n * This creates the LMv2 response as used in the ntlm type-3 message.\n *\n * Parameters:\n *\n * ntlmv2hash        [in] - The ntlmv2 hash (16 bytes)\n * challenge_client  [in] - The client nonce (8 bytes)\n * challenge_client  [in] - The server challenge (8 bytes)\n * lmresp           [out] - The LMv2 response (24 bytes)\n *\n * Returns CURLE_OK on success.\n */\nCURLcode  Curl_ntlm_core_mk_lmv2_resp(unsigned char *ntlmv2hash,\n                                      unsigned char *challenge_client,\n                                      unsigned char *challenge_server,\n                                      unsigned char *lmresp)\n{\n  unsigned char data[16];\n  unsigned char hmac_output[16];\n  CURLcode result = CURLE_OK;\n\n  memcpy(&data[0], challenge_server, 8);\n  memcpy(&data[8], challenge_client, 8);\n\n  result = Curl_hmacit(Curl_HMAC_MD5, ntlmv2hash, 16, &data[0], 16,\n                       hmac_output);\n  if(result)\n    return result;\n\n  /* Concatenate the HMAC MD5 output  with the client nonce */\n  memcpy(lmresp, hmac_output, 16);\n  memcpy(lmresp + 16, challenge_client, 8);\n\n  return result;\n}\n\n#endif /* USE_NTLM_V2 && !USE_WINDOWS_SSPI */\n\n#endif /* USE_NTRESPONSES */\n\n#endif /* USE_CURL_NTLM_CORE */\n"}}, "reports": [{"events": [{"location": {"line": 159, "col": 1, "file": 11}, "message": "sk_OPENSSL_STRING_num -> Total CFGBlocks: 3 | Unreachable CFGBlocks: 0 | Exhausted Block: no | Empty WorkList: yes"}], "macros": [], "notes": [], "path": "/usr/include/openssl/safestack.h", "reportHash": "f40115e9251e30f9a67b45ae15e38ee6", "checkerName": "debug.Stats", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"line": 159, "col": 1, "file": 11}, "message": "sk_OPENSSL_STRING_value -> Total CFGBlocks: 3 | Unreachable CFGBlocks: 0 | Exhausted Block: no | Empty WorkList: yes"}], "macros": [], "notes": [], "path": "/usr/include/openssl/safestack.h", "reportHash": "fb41f7d4997262f8fea820a9967c280f", "checkerName": "debug.Stats", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"line": 159, "col": 1, "file": 11}, "message": "sk_OPENSSL_STRING_new -> Total CFGBlocks: 3 | Unreachable CFGBlocks: 0 | Exhausted Block: no | Empty WorkList: yes"}], "macros": [], "notes": [], "path": "/usr/include/openssl/safestack.h", "reportHash": "b6734b7405e8a672bb2783ea98062478", "checkerName": "debug.Stats", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"line": 159, "col": 1, "file": 11}, "message": "sk_OPENSSL_STRING_new_null -> Total CFGBlocks: 3 | Unreachable CFGBlocks: 0 | Exhausted Block: no | Empty WorkList: yes"}], "macros": [], "notes": [], "path": "/usr/include/openssl/safestack.h", "reportHash": "884da23b71debfcc45f421903883b782", "checkerName": "debug.Stats", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"line": 159, "col": 1, "file": 11}, "message": "sk_OPENSSL_STRING_new_reserve -> Total CFGBlocks: 3 | Unreachable CFGBlocks: 0 | Exhausted Block: no | Empty WorkList: yes"}], "macros": [], "notes": [], "path": "/usr/include/openssl/safestack.h", "reportHash": "5c4d3e98180b721e4799766f25650b36", "checkerName": "debug.Stats", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"line": 159, "col": 1, "file": 11}, "message": "sk_OPENSSL_STRING_reserve -> Total CFGBlocks: 3 | Unreachable CFGBlocks: 0 | Exhausted Block: no | Empty WorkList: yes"}], "macros": [], "notes": [], "path": "/usr/include/openssl/safestack.h", "reportHash": "5863eae8370fb74b1565a60e0489dda7", "checkerName": "debug.Stats", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"line": 159, "col": 1, "file": 11}, "message": "sk_OPENSSL_STRING_free -> Total CFGBlocks: 3 | Unreachable CFGBlocks: 0 | Exhausted Block: no | Empty WorkList: yes"}], "macros": [], "notes": [], "path": "/usr/include/openssl/safestack.h", "reportHash": "9961e7661a261bb6d1eb86d878f3f377", "checkerName": "debug.Stats", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"line": 159, "col": 1, "file": 11}, "message": "sk_OPENSSL_STRING_zero -> Total CFGBlocks: 3 | Unreachable CFGBlocks: 0 | Exhausted Block: no | Empty WorkList: yes"}], "macros": [], "notes": [], "path": "/usr/include/openssl/safestack.h", "reportHash": "f3df59b30d5d31456cce93ee319efa8a", "checkerName": "debug.Stats", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"line": 159, "col": 1, "file": 11}, "message": "sk_OPENSSL_STRING_delete -> Total CFGBlocks: 3 | Unreachable CFGBlocks: 0 | Exhausted Block: no | Empty WorkList: yes"}], "macros": [], "notes": [], "path": "/usr/include/openssl/safestack.h", "reportHash": "ef036b10fc768fb25d1d3c2b3651e84f", "checkerName": "debug.Stats", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"line": 159, "col": 1, "file": 11}, "message": "sk_OPENSSL_STRING_delete_ptr -> Total CFGBlocks: 3 | Unreachable CFGBlocks: 0 | Exhausted Block: no | Empty WorkList: yes"}], "macros": [], "notes": [], "path": "/usr/include/openssl/safestack.h", "reportHash": "96e079021055e28bf0cd18836a220c64", "checkerName": "debug.Stats", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"line": 159, "col": 1, "file": 11}, "message": "sk_OPENSSL_STRING_push -> Total CFGBlocks: 3 | Unreachable CFGBlocks: 0 | Exhausted Block: no | Empty WorkList: yes"}], "macros": [], "notes": [], "path": "/usr/include/openssl/safestack.h", "reportHash": "e0d865315bdbc6f09663a02f46bca852", "checkerName": "debug.Stats", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"line": 159, "col": 1, "file": 11}, "message": "sk_OPENSSL_STRING_unshift -> Total CFGBlocks: 3 | Unreachable CFGBlocks: 0 | Exhausted Block: no | Empty WorkList: yes"}], "macros": [], "notes": [], "path": "/usr/include/openssl/safestack.h", "reportHash": "67c57d54af75dd353bf22a4429064605", "checkerName": "debug.Stats", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"line": 159, "col": 1, "file": 11}, "message": "sk_OPENSSL_STRING_pop -> Total CFGBlocks: 3 | Unreachable CFGBlocks: 0 | Exhausted Block: no | Empty WorkList: yes"}], "macros": [], "notes": [], "path": "/usr/include/openssl/safestack.h", "reportHash": "21f206137fa7339662b6b83e4419db3c", "checkerName": "debug.Stats", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"line": 159, "col": 1, "file": 11}, "message": "sk_OPENSSL_STRING_shift -> Total CFGBlocks: 3 | Unreachable CFGBlocks: 0 | Exhausted Block: no | Empty WorkList: yes"}], "macros": [], "notes": [], "path": "/usr/include/openssl/safestack.h", "reportHash": "e8db409ba6caf6e06f4252f70e06a575", "checkerName": "debug.Stats", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"line": 159, "col": 1, "file": 11}, "message": "sk_OPENSSL_STRING_pop_free -> Total CFGBlocks: 3 | Unreachable CFGBlocks: 0 | Exhausted Block: no | Empty WorkList: yes"}], "macros": [], "notes": [], "path": "/usr/include/openssl/safestack.h", "reportHash": "f6ec25904c734843a4dcecee421e821b", "checkerName": "debug.Stats", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"line": 159, "col": 1, "file": 11}, "message": "sk_OPENSSL_STRING_insert -> Total CFGBlocks: 3 | Unreachable CFGBlocks: 0 | Exhausted Block: no | Empty WorkList: yes"}], "macros": [], "notes": [], "path": "/usr/include/openssl/safestack.h", "reportHash": "d6c3468e376aea7c480ced5df45a0fb1", "checkerName": "debug.Stats", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"line": 159, "col": 1, "file": 11}, "message": "sk_OPENSSL_STRING_set -> Total CFGBlocks: 3 | Unreachable CFGBlocks: 0 | Exhausted Block: no | Empty WorkList: yes"}], "macros": [], "notes": [], "path": "/usr/include/openssl/safestack.h", "reportHash": "540aae80e5054b3801f067ecd1c3ab84", "checkerName": "debug.Stats", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"line": 159, "col": 1, "file": 11}, "message": "sk_OPENSSL_STRING_find -> Total CFGBlocks: 3 | Unreachable CFGBlocks: 0 | Exhausted Block: no | Empty WorkList: yes"}], "macros": [], "notes": [], "path": "/usr/include/openssl/safestack.h", "reportHash": "b09bb2bb3ce1de16dffd5d4a82d63605", "checkerName": "debug.Stats", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"line": 159, "col": 1, "file": 11}, "message": "sk_OPENSSL_STRING_find_ex -> Total CFGBlocks: 3 | Unreachable CFGBlocks: 0 | Exhausted Block: no | Empty WorkList: yes"}], "macros": [], "notes": [], "path": "/usr/include/openssl/safestack.h", "reportHash": "8ac3f4621a5828538e2ce4702aae1f29", "checkerName": "debug.Stats", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"line": 159, "col": 1, "file": 11}, "message": "sk_OPENSSL_STRING_sort -> Total CFGBlocks: 3 | Unreachable CFGBlocks: 0 | Exhausted Block: no | Empty WorkList: yes"}], "macros": [], "notes": [], "path": "/usr/include/openssl/safestack.h", "reportHash": "e867cb67a594a13173de8242269614a2", "checkerName": "debug.Stats", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"line": 159, "col": 1, "file": 11}, "message": "sk_OPENSSL_STRING_is_sorted -> Total CFGBlocks: 3 | Unreachable CFGBlocks: 0 | Exhausted Block: no | Empty WorkList: yes"}], "macros": [], "notes": [], "path": "/usr/include/openssl/safestack.h", "reportHash": "aeadab030e78b94ea6254e771ee13a03", "checkerName": "debug.Stats", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"line": 159, "col": 1, "file": 11}, "message": "sk_OPENSSL_STRING_dup -> Total CFGBlocks: 3 | Unreachable CFGBlocks: 0 | Exhausted Block: no | Empty WorkList: yes"}], "macros": [], "notes": [], "path": "/usr/include/openssl/safestack.h", "reportHash": "51e464cba7191a0864e2d12baecfb433", "checkerName": "debug.Stats", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"line": 159, "col": 1, "file": 11}, "message": "sk_OPENSSL_STRING_deep_copy -> Total CFGBlocks: 3 | Unreachable CFGBlocks: 0 | Exhausted Block: no | Empty WorkList: yes"}], "macros": [], "notes": [], "path": "/usr/include/openssl/safestack.h", "reportHash": "980d3b1eec9a1b2b457a507e8ad2d3f1", "checkerName": "debug.Stats", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"line": 159, "col": 1, "file": 11}, "message": "sk_OPENSSL_STRING_set_cmp_func -> Total CFGBlocks: 3 | Unreachable CFGBlocks: 0 | Exhausted Block: no | Empty WorkList: yes"}], "macros": [], "notes": [], "path": "/usr/include/openssl/safestack.h", "reportHash": "f51fa206a3ce60e8d076d4f2e718f7e0", "checkerName": "debug.Stats", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"line": 160, "col": 1, "file": 11}, "message": "sk_OPENSSL_CSTRING_num -> Total CFGBlocks: 3 | Unreachable CFGBlocks: 0 | Exhausted Block: no | Empty WorkList: yes"}], "macros": [], "notes": [], "path": "/usr/include/openssl/safestack.h", "reportHash": "34fd9d6355a8c6f5187af972a658427c", "checkerName": "debug.Stats", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"line": 160, "col": 1, "file": 11}, "message": "sk_OPENSSL_CSTRING_value -> Total CFGBlocks: 3 | Unreachable CFGBlocks: 0 | Exhausted Block: no | Empty WorkList: yes"}], "macros": [], "notes": [], "path": "/usr/include/openssl/safestack.h", "reportHash": "e4b317cc5e164f03af01a28b90a667a7", "checkerName": "debug.Stats", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"line": 160, "col": 1, "file": 11}, "message": "sk_OPENSSL_CSTRING_new -> Total CFGBlocks: 3 | Unreachable CFGBlocks: 0 | Exhausted Block: no | Empty WorkList: yes"}], "macros": [], "notes": [], "path": "/usr/include/openssl/safestack.h", "reportHash": "7ea8620edebd8bde951b1005e1809887", "checkerName": "debug.Stats", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"line": 160, "col": 1, "file": 11}, "message": "sk_OPENSSL_CSTRING_new_null -> Total CFGBlocks: 3 | Unreachable CFGBlocks: 0 | Exhausted Block: no | Empty WorkList: yes"}], "macros": [], "notes": [], "path": "/usr/include/openssl/safestack.h", "reportHash": "54ae1abf9d8487600f42fdba32321d14", "checkerName": "debug.Stats", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"line": 160, "col": 1, "file": 11}, "message": "sk_OPENSSL_CSTRING_new_reserve -> Total CFGBlocks: 3 | Unreachable CFGBlocks: 0 | Exhausted Block: no | Empty WorkList: yes"}], "macros": [], "notes": [], "path": "/usr/include/openssl/safestack.h", "reportHash": "6804fe250300a4d42d09faaf11eba2de", "checkerName": "debug.Stats", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"line": 160, "col": 1, "file": 11}, "message": "sk_OPENSSL_CSTRING_reserve -> Total CFGBlocks: 3 | Unreachable CFGBlocks: 0 | Exhausted Block: no | Empty WorkList: yes"}], "macros": [], "notes": [], "path": "/usr/include/openssl/safestack.h", "reportHash": "05b2c5fc7c101fcadc2a3ab2349e48ab", "checkerName": "debug.Stats", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"line": 160, "col": 1, "file": 11}, "message": "sk_OPENSSL_CSTRING_free -> Total CFGBlocks: 3 | Unreachable CFGBlocks: 0 | Exhausted Block: no | Empty WorkList: yes"}], "macros": [], "notes": [], "path": "/usr/include/openssl/safestack.h", "reportHash": "5cf244c64d5a46af98cd78ce58ae7abf", "checkerName": "debug.Stats", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"line": 160, "col": 1, "file": 11}, "message": "sk_OPENSSL_CSTRING_zero -> Total CFGBlocks: 3 | Unreachable CFGBlocks: 0 | Exhausted Block: no | Empty WorkList: yes"}], "macros": [], "notes": [], "path": "/usr/include/openssl/safestack.h", "reportHash": "df93a71da3543b66aae119c16429e403", "checkerName": "debug.Stats", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"line": 160, "col": 1, "file": 11}, "message": "sk_OPENSSL_CSTRING_delete -> Total CFGBlocks: 3 | Unreachable CFGBlocks: 0 | Exhausted Block: no | Empty WorkList: yes"}], "macros": [], "notes": [], "path": "/usr/include/openssl/safestack.h", "reportHash": "0020bb0adc40aeb6ffb38a09d490a0b3", "checkerName": "debug.Stats", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"line": 160, "col": 1, "file": 11}, "message": "sk_OPENSSL_CSTRING_delete_ptr -> Total CFGBlocks: 3 | Unreachable CFGBlocks: 0 | Exhausted Block: no | Empty WorkList: yes"}], "macros": [], "notes": [], "path": "/usr/include/openssl/safestack.h", "reportHash": "7655a25997b91a3155c98b1d6597463d", "checkerName": "debug.Stats", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"line": 160, "col": 1, "file": 11}, "message": "sk_OPENSSL_CSTRING_push -> Total CFGBlocks: 3 | Unreachable CFGBlocks: 0 | Exhausted Block: no | Empty WorkList: yes"}], "macros": [], "notes": [], "path": "/usr/include/openssl/safestack.h", "reportHash": "466c9321866978c23fc27232192e3e89", "checkerName": "debug.Stats", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"line": 160, "col": 1, "file": 11}, "message": "sk_OPENSSL_CSTRING_unshift -> Total CFGBlocks: 3 | Unreachable CFGBlocks: 0 | Exhausted Block: no | Empty WorkList: yes"}], "macros": [], "notes": [], "path": "/usr/include/openssl/safestack.h", "reportHash": "a72ece9755417b7169441de5f1f98ded", "checkerName": "debug.Stats", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"line": 160, "col": 1, "file": 11}, "message": "sk_OPENSSL_CSTRING_pop -> Total CFGBlocks: 3 | Unreachable CFGBlocks: 0 | Exhausted Block: no | Empty WorkList: yes"}], "macros": [], "notes": [], "path": "/usr/include/openssl/safestack.h", "reportHash": "70264f3a5a1de454b23eb11f8bccf7e5", "checkerName": "debug.Stats", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"line": 160, "col": 1, "file": 11}, "message": "sk_OPENSSL_CSTRING_shift -> Total CFGBlocks: 3 | Unreachable CFGBlocks: 0 | Exhausted Block: no | Empty WorkList: yes"}], "macros": [], "notes": [], "path": "/usr/include/openssl/safestack.h", "reportHash": "9378f95a6782d00de408fb966f2eb239", "checkerName": "debug.Stats", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"line": 160, "col": 1, "file": 11}, "message": "sk_OPENSSL_CSTRING_pop_free -> Total CFGBlocks: 3 | Unreachable CFGBlocks: 0 | Exhausted Block: no | Empty WorkList: yes"}], "macros": [], "notes": [], "path": "/usr/include/openssl/safestack.h", "reportHash": "30c3a102bf2309f10b9742d37893db07", "checkerName": "debug.Stats", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"line": 160, "col": 1, "file": 11}, "message": "sk_OPENSSL_CSTRING_insert -> Total CFGBlocks: 3 | Unreachable CFGBlocks: 0 | Exhausted Block: no | Empty WorkList: yes"}], "macros": [], "notes": [], "path": "/usr/include/openssl/safestack.h", "reportHash": "e632a12bb85f18c5277451b5113a09a9", "checkerName": "debug.Stats", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"line": 160, "col": 1, "file": 11}, "message": "sk_OPENSSL_CSTRING_set -> Total CFGBlocks: 3 | Unreachable CFGBlocks: 0 | Exhausted Block: no | Empty WorkList: yes"}], "macros": [], "notes": [], "path": "/usr/include/openssl/safestack.h", "reportHash": "afb64545c72030a84e86128958b19812", "checkerName": "debug.Stats", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"line": 160, "col": 1, "file": 11}, "message": "sk_OPENSSL_CSTRING_find -> Total CFGBlocks: 3 | Unreachable CFGBlocks: 0 | Exhausted Block: no | Empty WorkList: yes"}], "macros": [], "notes": [], "path": "/usr/include/openssl/safestack.h", "reportHash": "5d7eef9ff2c404c445de8543ba6f02fe", "checkerName": "debug.Stats", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"line": 160, "col": 1, "file": 11}, "message": "sk_OPENSSL_CSTRING_find_ex -> Total CFGBlocks: 3 | Unreachable CFGBlocks: 0 | Exhausted Block: no | Empty WorkList: yes"}], "macros": [], "notes": [], "path": "/usr/include/openssl/safestack.h", "reportHash": "9f362ab2fbb1ff869e4e201ba6ae7e3d", "checkerName": "debug.Stats", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"line": 160, "col": 1, "file": 11}, "message": "sk_OPENSSL_CSTRING_sort -> Total CFGBlocks: 3 | Unreachable CFGBlocks: 0 | Exhausted Block: no | Empty WorkList: yes"}], "macros": [], "notes": [], "path": "/usr/include/openssl/safestack.h", "reportHash": "425eba23c4fb7582b649c608d2570d16", "checkerName": "debug.Stats", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"line": 160, "col": 1, "file": 11}, "message": "sk_OPENSSL_CSTRING_is_sorted -> Total CFGBlocks: 3 | Unreachable CFGBlocks: 0 | Exhausted Block: no | Empty WorkList: yes"}], "macros": [], "notes": [], "path": "/usr/include/openssl/safestack.h", "reportHash": "72e1235cf46c63e7a24d641164fefd27", "checkerName": "debug.Stats", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"line": 160, "col": 1, "file": 11}, "message": "sk_OPENSSL_CSTRING_dup -> Total CFGBlocks: 3 | Unreachable CFGBlocks: 0 | Exhausted Block: no | Empty WorkList: yes"}], "macros": [], "notes": [], "path": "/usr/include/openssl/safestack.h", "reportHash": "34e71aae4a288b18c4b934b6c39cb86d", "checkerName": "debug.Stats", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"line": 160, "col": 1, "file": 11}, "message": "sk_OPENSSL_CSTRING_deep_copy -> Total CFGBlocks: 3 | Unreachable CFGBlocks: 0 | Exhausted Block: no | Empty WorkList: yes"}], "macros": [], "notes": [], "path": "/usr/include/openssl/safestack.h", "reportHash": "0c9cafcd2f599b9f515c365798227a9a", "checkerName": "debug.Stats", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"line": 160, "col": 1, "file": 11}, "message": "sk_OPENSSL_CSTRING_set_cmp_func -> Total CFGBlocks: 3 | Unreachable CFGBlocks: 0 | Exhausted Block: no | Empty WorkList: yes"}], "macros": [], "notes": [], "path": "/usr/include/openssl/safestack.h", "reportHash": "370e676135a40b86ae7637f6623c74d0", "checkerName": "debug.Stats", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"line": 167, "col": 1, "file": 11}, "message": "sk_OPENSSL_BLOCK_num -> Total CFGBlocks: 3 | Unreachable CFGBlocks: 0 | Exhausted Block: no | Empty WorkList: yes"}], "macros": [], "notes": [], "path": "/usr/include/openssl/safestack.h", "reportHash": "f18116330f1127f59f10ab9e05c11301", "checkerName": "debug.Stats", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"line": 167, "col": 1, "file": 11}, "message": "sk_OPENSSL_BLOCK_value -> Total CFGBlocks: 3 | Unreachable CFGBlocks: 0 | Exhausted Block: no | Empty WorkList: yes"}], "macros": [], "notes": [], "path": "/usr/include/openssl/safestack.h", "reportHash": "738293c25a87c01328aa36bcd4fa26a5", "checkerName": "debug.Stats", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"line": 167, "col": 1, "file": 11}, "message": "sk_OPENSSL_BLOCK_new -> Total CFGBlocks: 3 | Unreachable CFGBlocks: 0 | Exhausted Block: no | Empty WorkList: yes"}], "macros": [], "notes": [], "path": "/usr/include/openssl/safestack.h", "reportHash": "320a1298c2e6fc1bc2f644a61ea48097", "checkerName": "debug.Stats", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"line": 167, "col": 1, "file": 11}, "message": "sk_OPENSSL_BLOCK_new_null -> Total CFGBlocks: 3 | Unreachable CFGBlocks: 0 | Exhausted Block: no | Empty WorkList: yes"}], "macros": [], "notes": [], "path": "/usr/include/openssl/safestack.h", "reportHash": "cc2efb2aed0451f498f243df4a503a1b", "checkerName": "debug.Stats", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"line": 167, "col": 1, "file": 11}, "message": "sk_OPENSSL_BLOCK_new_reserve -> Total CFGBlocks: 3 | Unreachable CFGBlocks: 0 | Exhausted Block: no | Empty WorkList: yes"}], "macros": [], "notes": [], "path": "/usr/include/openssl/safestack.h", "reportHash": "7419c0b1aac5eced794294ecde0e5bee", "checkerName": "debug.Stats", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"line": 167, "col": 1, "file": 11}, "message": "sk_OPENSSL_BLOCK_reserve -> Total CFGBlocks: 3 | Unreachable CFGBlocks: 0 | Exhausted Block: no | Empty WorkList: yes"}], "macros": [], "notes": [], "path": "/usr/include/openssl/safestack.h", "reportHash": "70ab83695dd445c8db67542f92ecc4ec", "checkerName": "debug.Stats", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"line": 167, "col": 1, "file": 11}, "message": "sk_OPENSSL_BLOCK_free -> Total CFGBlocks: 3 | Unreachable CFGBlocks: 0 | Exhausted Block: no | Empty WorkList: yes"}], "macros": [], "notes": [], "path": "/usr/include/openssl/safestack.h", "reportHash": "e5dac302ca617d8e2d50b3a5e515316d", "checkerName": "debug.Stats", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"line": 167, "col": 1, "file": 11}, "message": "sk_OPENSSL_BLOCK_zero -> Total CFGBlocks: 3 | Unreachable CFGBlocks: 0 | Exhausted Block: no | Empty WorkList: yes"}], "macros": [], "notes": [], "path": "/usr/include/openssl/safestack.h", "reportHash": "7d254a43e03eb7d6eacc2b107c6cacb1", "checkerName": "debug.Stats", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"line": 167, "col": 1, "file": 11}, "message": "sk_OPENSSL_BLOCK_delete -> Total CFGBlocks: 3 | Unreachable CFGBlocks: 0 | Exhausted Block: no | Empty WorkList: yes"}], "macros": [], "notes": [], "path": "/usr/include/openssl/safestack.h", "reportHash": "908898f35c34d7e0b5a38de854a3fd5e", "checkerName": "debug.Stats", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"line": 167, "col": 1, "file": 11}, "message": "sk_OPENSSL_BLOCK_delete_ptr -> Total CFGBlocks: 3 | Unreachable CFGBlocks: 0 | Exhausted Block: no | Empty WorkList: yes"}], "macros": [], "notes": [], "path": "/usr/include/openssl/safestack.h", "reportHash": "8180abb84235531554b4e86a969f6467", "checkerName": "debug.Stats", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"line": 167, "col": 1, "file": 11}, "message": "sk_OPENSSL_BLOCK_push -> Total CFGBlocks: 3 | Unreachable CFGBlocks: 0 | Exhausted Block: no | Empty WorkList: yes"}], "macros": [], "notes": [], "path": "/usr/include/openssl/safestack.h", "reportHash": "7a4f7cd50670113858c6488a3cb77d8c", "checkerName": "debug.Stats", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"line": 167, "col": 1, "file": 11}, "message": "sk_OPENSSL_BLOCK_unshift -> Total CFGBlocks: 3 | Unreachable CFGBlocks: 0 | Exhausted Block: no | Empty WorkList: yes"}], "macros": [], "notes": [], "path": "/usr/include/openssl/safestack.h", "reportHash": "298842f2e05af29dc067d8ec0db8db69", "checkerName": "debug.Stats", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"line": 167, "col": 1, "file": 11}, "message": "sk_OPENSSL_BLOCK_pop -> Total CFGBlocks: 3 | Unreachable CFGBlocks: 0 | Exhausted Block: no | Empty WorkList: yes"}], "macros": [], "notes": [], "path": "/usr/include/openssl/safestack.h", "reportHash": "a96795aea746c689d54dd1e925c398b3", "checkerName": "debug.Stats", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"line": 167, "col": 1, "file": 11}, "message": "sk_OPENSSL_BLOCK_shift -> Total CFGBlocks: 3 | Unreachable CFGBlocks: 0 | Exhausted Block: no | Empty WorkList: yes"}], "macros": [], "notes": [], "path": "/usr/include/openssl/safestack.h", "reportHash": "72d0f5aab8fb5c9ab03caf0d0b9af464", "checkerName": "debug.Stats", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"line": 167, "col": 1, "file": 11}, "message": "sk_OPENSSL_BLOCK_pop_free -> Total CFGBlocks: 3 | Unreachable CFGBlocks: 0 | Exhausted Block: no | Empty WorkList: yes"}], "macros": [], "notes": [], "path": "/usr/include/openssl/safestack.h", "reportHash": "48f19f51333fa0c69ce776609282e139", "checkerName": "debug.Stats", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"line": 167, "col": 1, "file": 11}, "message": "sk_OPENSSL_BLOCK_insert -> Total CFGBlocks: 3 | Unreachable CFGBlocks: 0 | Exhausted Block: no | Empty WorkList: yes"}], "macros": [], "notes": [], "path": "/usr/include/openssl/safestack.h", "reportHash": "f1e5b3d90a9d1f1867610c80f1b94790", "checkerName": "debug.Stats", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"line": 167, "col": 1, "file": 11}, "message": "sk_OPENSSL_BLOCK_set -> Total CFGBlocks: 3 | Unreachable CFGBlocks: 0 | Exhausted Block: no | Empty WorkList: yes"}], "macros": [], "notes": [], "path": "/usr/include/openssl/safestack.h", "reportHash": "17e9b427c90537936a29ed53ecf0e95d", "checkerName": "debug.Stats", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"line": 167, "col": 1, "file": 11}, "message": "sk_OPENSSL_BLOCK_find -> Total CFGBlocks: 3 | Unreachable CFGBlocks: 0 | Exhausted Block: no | Empty WorkList: yes"}], "macros": [], "notes": [], "path": "/usr/include/openssl/safestack.h", "reportHash": "a37a61529dd4d2d477518f0a80786fd8", "checkerName": "debug.Stats", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"line": 167, "col": 1, "file": 11}, "message": "sk_OPENSSL_BLOCK_find_ex -> Total CFGBlocks: 3 | Unreachable CFGBlocks: 0 | Exhausted Block: no | Empty WorkList: yes"}], "macros": [], "notes": [], "path": "/usr/include/openssl/safestack.h", "reportHash": "99e5eefbf7801e1ee45d074eecd30c58", "checkerName": "debug.Stats", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"line": 167, "col": 1, "file": 11}, "message": "sk_OPENSSL_BLOCK_sort -> Total CFGBlocks: 3 | Unreachable CFGBlocks: 0 | Exhausted Block: no | Empty WorkList: yes"}], "macros": [], "notes": [], "path": "/usr/include/openssl/safestack.h", "reportHash": "5ae6c6127d027687c2bde014def04b05", "checkerName": "debug.Stats", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"line": 167, "col": 1, "file": 11}, "message": "sk_OPENSSL_BLOCK_is_sorted -> Total CFGBlocks: 3 | Unreachable CFGBlocks: 0 | Exhausted Block: no | Empty WorkList: yes"}], "macros": [], "notes": [], "path": "/usr/include/openssl/safestack.h", "reportHash": "10027d35e426086d4ae0c7282603cdd4", "checkerName": "debug.Stats", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"line": 167, "col": 1, "file": 11}, "message": "sk_OPENSSL_BLOCK_dup -> Total CFGBlocks: 3 | Unreachable CFGBlocks: 0 | Exhausted Block: no | Empty WorkList: yes"}], "macros": [], "notes": [], "path": "/usr/include/openssl/safestack.h", "reportHash": "474ca8be82ebaf8ac182df24d17e304e", "checkerName": "debug.Stats", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"line": 167, "col": 1, "file": 11}, "message": "sk_OPENSSL_BLOCK_deep_copy -> Total CFGBlocks: 3 | Unreachable CFGBlocks: 0 | Exhausted Block: no | Empty WorkList: yes"}], "macros": [], "notes": [], "path": "/usr/include/openssl/safestack.h", "reportHash": "183a98d77aa93616f8ac41593abaf606", "checkerName": "debug.Stats", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"line": 167, "col": 1, "file": 11}, "message": "sk_OPENSSL_BLOCK_set_cmp_func -> Total CFGBlocks: 3 | Unreachable CFGBlocks: 0 | Exhausted Block: no | Empty WorkList: yes"}], "macros": [], "notes": [], "path": "/usr/include/openssl/safestack.h", "reportHash": "b6487ae723271ae647cc256ec368018a", "checkerName": "debug.Stats", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"line": 89, "col": 1, "file": 12}, "message": "sk_void_num -> Total CFGBlocks: 3 | Unreachable CFGBlocks: 0 | Exhausted Block: no | Empty WorkList: yes"}], "macros": [], "notes": [], "path": "/usr/include/openssl/crypto.h", "reportHash": "1cd1e94f749b7de84459c850ecfaef38", "checkerName": "debug.Stats", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"line": 89, "col": 1, "file": 12}, "message": "sk_void_value -> Total CFGBlocks: 3 | Unreachable CFGBlocks: 0 | Exhausted Block: no | Empty WorkList: yes"}], "macros": [], "notes": [], "path": "/usr/include/openssl/crypto.h", "reportHash": "7d3acbda1aaba587c073f591e93781a3", "checkerName": "debug.Stats", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"line": 89, "col": 1, "file": 12}, "message": "sk_void_new -> Total CFGBlocks: 3 | Unreachable CFGBlocks: 0 | Exhausted Block: no | Empty WorkList: yes"}], "macros": [], "notes": [], "path": "/usr/include/openssl/crypto.h", "reportHash": "02a7f7b8fe46ba6d6935a0bd6e36fb24", "checkerName": "debug.Stats", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"line": 89, "col": 1, "file": 12}, "message": "sk_void_new_null -> Total CFGBlocks: 3 | Unreachable CFGBlocks: 0 | Exhausted Block: no | Empty WorkList: yes"}], "macros": [], "notes": [], "path": "/usr/include/openssl/crypto.h", "reportHash": "2d9ebaa4baf71b387357fc3a8e70628f", "checkerName": "debug.Stats", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"line": 89, "col": 1, "file": 12}, "message": "sk_void_new_reserve -> Total CFGBlocks: 3 | Unreachable CFGBlocks: 0 | Exhausted Block: no | Empty WorkList: yes"}], "macros": [], "notes": [], "path": "/usr/include/openssl/crypto.h", "reportHash": "e1cc7171501bf1f952b8be15c28fec34", "checkerName": "debug.Stats", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"line": 89, "col": 1, "file": 12}, "message": "sk_void_reserve -> Total CFGBlocks: 3 | Unreachable CFGBlocks: 0 | Exhausted Block: no | Empty WorkList: yes"}], "macros": [], "notes": [], "path": "/usr/include/openssl/crypto.h", "reportHash": "2bfda5b30a9cb575e59c152b48e86288", "checkerName": "debug.Stats", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"line": 89, "col": 1, "file": 12}, "message": "sk_void_free -> Total CFGBlocks: 3 | Unreachable CFGBlocks: 0 | Exhausted Block: no | Empty WorkList: yes"}], "macros": [], "notes": [], "path": "/usr/include/openssl/crypto.h", "reportHash": "70b0eab9fd610f57a18353dbf81a0c99", "checkerName": "debug.Stats", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"line": 89, "col": 1, "file": 12}, "message": "sk_void_zero -> Total CFGBlocks: 3 | Unreachable CFGBlocks: 0 | Exhausted Block: no | Empty WorkList: yes"}], "macros": [], "notes": [], "path": "/usr/include/openssl/crypto.h", "reportHash": "aa6b01a99272f7b0baddbca8a5410b8f", "checkerName": "debug.Stats", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"line": 89, "col": 1, "file": 12}, "message": "sk_void_delete -> Total CFGBlocks: 3 | Unreachable CFGBlocks: 0 | Exhausted Block: no | Empty WorkList: yes"}], "macros": [], "notes": [], "path": "/usr/include/openssl/crypto.h", "reportHash": "6881d2065f700d93f9c93888fc6d6d0e", "checkerName": "debug.Stats", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"line": 89, "col": 1, "file": 12}, "message": "sk_void_delete_ptr -> Total CFGBlocks: 3 | Unreachable CFGBlocks: 0 | Exhausted Block: no | Empty WorkList: yes"}], "macros": [], "notes": [], "path": "/usr/include/openssl/crypto.h", "reportHash": "c59372c42a6e3a1a066370b4f01181c5", "checkerName": "debug.Stats", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"line": 89, "col": 1, "file": 12}, "message": "sk_void_push -> Total CFGBlocks: 3 | Unreachable CFGBlocks: 0 | Exhausted Block: no | Empty WorkList: yes"}], "macros": [], "notes": [], "path": "/usr/include/openssl/crypto.h", "reportHash": "b2ab78391c7cadad1f4c2cbeee649543", "checkerName": "debug.Stats", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"line": 89, "col": 1, "file": 12}, "message": "sk_void_unshift -> Total CFGBlocks: 3 | Unreachable CFGBlocks: 0 | Exhausted Block: no | Empty WorkList: yes"}], "macros": [], "notes": [], "path": "/usr/include/openssl/crypto.h", "reportHash": "d153a74d52df60a844802bed544e3714", "checkerName": "debug.Stats", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"line": 89, "col": 1, "file": 12}, "message": "sk_void_pop -> Total CFGBlocks: 3 | Unreachable CFGBlocks: 0 | Exhausted Block: no | Empty WorkList: yes"}], "macros": [], "notes": [], "path": "/usr/include/openssl/crypto.h", "reportHash": "afd14ef42ab79f016b887224e9828919", "checkerName": "debug.Stats", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"line": 89, "col": 1, "file": 12}, "message": "sk_void_shift -> Total CFGBlocks: 3 | Unreachable CFGBlocks: 0 | Exhausted Block: no | Empty WorkList: yes"}], "macros": [], "notes": [], "path": "/usr/include/openssl/crypto.h", "reportHash": "0e317995ab0638215d3c44951376b8c4", "checkerName": "debug.Stats", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"line": 89, "col": 1, "file": 12}, "message": "sk_void_pop_free -> Total CFGBlocks: 3 | Unreachable CFGBlocks: 0 | Exhausted Block: no | Empty WorkList: yes"}], "macros": [], "notes": [], "path": "/usr/include/openssl/crypto.h", "reportHash": "8be3634edf36611e82eb9cebf712bc61", "checkerName": "debug.Stats", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"line": 89, "col": 1, "file": 12}, "message": "sk_void_insert -> Total CFGBlocks: 3 | Unreachable CFGBlocks: 0 | Exhausted Block: no | Empty WorkList: yes"}], "macros": [], "notes": [], "path": "/usr/include/openssl/crypto.h", "reportHash": "bb4d2f89e17388682969b9911b78b13a", "checkerName": "debug.Stats", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"line": 89, "col": 1, "file": 12}, "message": "sk_void_set -> Total CFGBlocks: 3 | Unreachable CFGBlocks: 0 | Exhausted Block: no | Empty WorkList: yes"}], "macros": [], "notes": [], "path": "/usr/include/openssl/crypto.h", "reportHash": "a0819192224dbeafc1006e8e80919a71", "checkerName": "debug.Stats", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"line": 89, "col": 1, "file": 12}, "message": "sk_void_find -> Total CFGBlocks: 3 | Unreachable CFGBlocks: 0 | Exhausted Block: no | Empty WorkList: yes"}], "macros": [], "notes": [], "path": "/usr/include/openssl/crypto.h", "reportHash": "c7a36f68da29d8ed029f77f2065456e2", "checkerName": "debug.Stats", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"line": 89, "col": 1, "file": 12}, "message": "sk_void_find_ex -> Total CFGBlocks: 3 | Unreachable CFGBlocks: 0 | Exhausted Block: no | Empty WorkList: yes"}], "macros": [], "notes": [], "path": "/usr/include/openssl/crypto.h", "reportHash": "b2696c27ffc2a9edfb4e2f2ad882a729", "checkerName": "debug.Stats", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"line": 89, "col": 1, "file": 12}, "message": "sk_void_sort -> Total CFGBlocks: 3 | Unreachable CFGBlocks: 0 | Exhausted Block: no | Empty WorkList: yes"}], "macros": [], "notes": [], "path": "/usr/include/openssl/crypto.h", "reportHash": "0fced58cbc5373fc03388114dd72e417", "checkerName": "debug.Stats", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"line": 89, "col": 1, "file": 12}, "message": "sk_void_is_sorted -> Total CFGBlocks: 3 | Unreachable CFGBlocks: 0 | Exhausted Block: no | Empty WorkList: yes"}], "macros": [], "notes": [], "path": "/usr/include/openssl/crypto.h", "reportHash": "c0d09f414c7bcc0e2d37fc08e5a44d65", "checkerName": "debug.Stats", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"line": 89, "col": 1, "file": 12}, "message": "sk_void_dup -> Total CFGBlocks: 3 | Unreachable CFGBlocks: 0 | Exhausted Block: no | Empty WorkList: yes"}], "macros": [], "notes": [], "path": "/usr/include/openssl/crypto.h", "reportHash": "aff63969a7744ea1046b9746bffa75a4", "checkerName": "debug.Stats", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"line": 89, "col": 1, "file": 12}, "message": "sk_void_deep_copy -> Total CFGBlocks: 3 | Unreachable CFGBlocks: 0 | Exhausted Block: no | Empty WorkList: yes"}], "macros": [], "notes": [], "path": "/usr/include/openssl/crypto.h", "reportHash": "8eca149381f4b30b5ae5920b7930df85", "checkerName": "debug.Stats", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"line": 89, "col": 1, "file": 12}, "message": "sk_void_set_cmp_func -> Total CFGBlocks: 3 | Unreachable CFGBlocks: 0 | Exhausted Block: no | Empty WorkList: yes"}], "macros": [], "notes": [], "path": "/usr/include/openssl/crypto.h", "reportHash": "7b5e5bfbce1552f5e9e35f88373a2d99", "checkerName": "debug.Stats", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"line": 258, "col": 1, "file": 14}, "message": "sk_BIO_num -> Total CFGBlocks: 3 | Unreachable CFGBlocks: 0 | Exhausted Block: no | Empty WorkList: yes"}], "macros": [], "notes": [], "path": "/usr/include/openssl/bio.h", "reportHash": "be8a181302b525dad25ac175f80e9690", "checkerName": "debug.Stats", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"line": 258, "col": 1, "file": 14}, "message": "sk_BIO_value -> Total CFGBlocks: 3 | Unreachable CFGBlocks: 0 | Exhausted Block: no | Empty WorkList: yes"}], "macros": [], "notes": [], "path": "/usr/include/openssl/bio.h", "reportHash": "1870d950b6bedffcc730a323c0c5110e", "checkerName": "debug.Stats", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"line": 258, "col": 1, "file": 14}, "message": "sk_BIO_new -> Total CFGBlocks: 3 | Unreachable CFGBlocks: 0 | Exhausted Block: no | Empty WorkList: yes"}], "macros": [], "notes": [], "path": "/usr/include/openssl/bio.h", "reportHash": "c855c3fc739713694f242270432ef654", "checkerName": "debug.Stats", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"line": 258, "col": 1, "file": 14}, "message": "sk_BIO_new_null -> Total CFGBlocks: 3 | Unreachable CFGBlocks: 0 | Exhausted Block: no | Empty WorkList: yes"}], "macros": [], "notes": [], "path": "/usr/include/openssl/bio.h", "reportHash": "f673c8d17415b64d2f9478d12b916b94", "checkerName": "debug.Stats", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"line": 258, "col": 1, "file": 14}, "message": "sk_BIO_new_reserve -> Total CFGBlocks: 3 | Unreachable CFGBlocks: 0 | Exhausted Block: no | Empty WorkList: yes"}], "macros": [], "notes": [], "path": "/usr/include/openssl/bio.h", "reportHash": "edc341f2637eea997b6ee32d2d8202b4", "checkerName": "debug.Stats", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"line": 258, "col": 1, "file": 14}, "message": "sk_BIO_reserve -> Total CFGBlocks: 3 | Unreachable CFGBlocks: 0 | Exhausted Block: no | Empty WorkList: yes"}], "macros": [], "notes": [], "path": "/usr/include/openssl/bio.h", "reportHash": "6ac6c10546b999a7138fefe2539e9926", "checkerName": "debug.Stats", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"line": 258, "col": 1, "file": 14}, "message": "sk_BIO_free -> Total CFGBlocks: 3 | Unreachable CFGBlocks: 0 | Exhausted Block: no | Empty WorkList: yes"}], "macros": [], "notes": [], "path": "/usr/include/openssl/bio.h", "reportHash": "3b7b4196b39ce53619b1af7e6713d2d1", "checkerName": "debug.Stats", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"line": 258, "col": 1, "file": 14}, "message": "sk_BIO_zero -> Total CFGBlocks: 3 | Unreachable CFGBlocks: 0 | Exhausted Block: no | Empty WorkList: yes"}], "macros": [], "notes": [], "path": "/usr/include/openssl/bio.h", "reportHash": "9aa5d847267602ef363e65bf87191cea", "checkerName": "debug.Stats", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"line": 258, "col": 1, "file": 14}, "message": "sk_BIO_delete -> Total CFGBlocks: 3 | Unreachable CFGBlocks: 0 | Exhausted Block: no | Empty WorkList: yes"}], "macros": [], "notes": [], "path": "/usr/include/openssl/bio.h", "reportHash": "5c9f877cb24b3d20b1a9cafbb7103302", "checkerName": "debug.Stats", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"line": 258, "col": 1, "file": 14}, "message": "sk_BIO_delete_ptr -> Total CFGBlocks: 3 | Unreachable CFGBlocks: 0 | Exhausted Block: no | Empty WorkList: yes"}], "macros": [], "notes": [], "path": "/usr/include/openssl/bio.h", "reportHash": "6a2e86cb23eca03f033f53db34b9b68b", "checkerName": "debug.Stats", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"line": 258, "col": 1, "file": 14}, "message": "sk_BIO_push -> Total CFGBlocks: 3 | Unreachable CFGBlocks: 0 | Exhausted Block: no | Empty WorkList: yes"}], "macros": [], "notes": [], "path": "/usr/include/openssl/bio.h", "reportHash": "92d97e9d7fe2b270c1ff3cb8d4d1d6b4", "checkerName": "debug.Stats", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"line": 258, "col": 1, "file": 14}, "message": "sk_BIO_unshift -> Total CFGBlocks: 3 | Unreachable CFGBlocks: 0 | Exhausted Block: no | Empty WorkList: yes"}], "macros": [], "notes": [], "path": "/usr/include/openssl/bio.h", "reportHash": "4f548502359ab0e8087fc88fa2a934ef", "checkerName": "debug.Stats", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"line": 258, "col": 1, "file": 14}, "message": "sk_BIO_pop -> Total CFGBlocks: 3 | Unreachable CFGBlocks: 0 | Exhausted Block: no | Empty WorkList: yes"}], "macros": [], "notes": [], "path": "/usr/include/openssl/bio.h", "reportHash": "61d14529f7ab38a241bfbadbe19dbca8", "checkerName": "debug.Stats", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"line": 258, "col": 1, "file": 14}, "message": "sk_BIO_shift -> Total CFGBlocks: 3 | Unreachable CFGBlocks: 0 | Exhausted Block: no | Empty WorkList: yes"}], "macros": [], "notes": [], "path": "/usr/include/openssl/bio.h", "reportHash": "4ada196b428986dbd4c9cfd69a8c6408", "checkerName": "debug.Stats", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"line": 258, "col": 1, "file": 14}, "message": "sk_BIO_pop_free -> Total CFGBlocks: 3 | Unreachable CFGBlocks: 0 | Exhausted Block: no | Empty WorkList: yes"}], "macros": [], "notes": [], "path": "/usr/include/openssl/bio.h", "reportHash": "5ed394ff31e5fbd4c102c71065420ee8", "checkerName": "debug.Stats", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"line": 258, "col": 1, "file": 14}, "message": "sk_BIO_insert -> Total CFGBlocks: 3 | Unreachable CFGBlocks: 0 | Exhausted Block: no | Empty WorkList: yes"}], "macros": [], "notes": [], "path": "/usr/include/openssl/bio.h", "reportHash": "1c8e99249acfb684d07a78469bdae8dd", "checkerName": "debug.Stats", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"line": 258, "col": 1, "file": 14}, "message": "sk_BIO_set -> Total CFGBlocks: 3 | Unreachable CFGBlocks: 0 | Exhausted Block: no | Empty WorkList: yes"}], "macros": [], "notes": [], "path": "/usr/include/openssl/bio.h", "reportHash": "30a2a287c8e0eb163e4fb857c9970402", "checkerName": "debug.Stats", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"line": 258, "col": 1, "file": 14}, "message": "sk_BIO_find -> Total CFGBlocks: 3 | Unreachable CFGBlocks: 0 | Exhausted Block: no | Empty WorkList: yes"}], "macros": [], "notes": [], "path": "/usr/include/openssl/bio.h", "reportHash": "744cbd0528f4803a4523f568f03c1083", "checkerName": "debug.Stats", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"line": 258, "col": 1, "file": 14}, "message": "sk_BIO_find_ex -> Total CFGBlocks: 3 | Unreachable CFGBlocks: 0 | Exhausted Block: no | Empty WorkList: yes"}], "macros": [], "notes": [], "path": "/usr/include/openssl/bio.h", "reportHash": "78d6e88b315c47608ba79aa2670dd2c4", "checkerName": "debug.Stats", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"line": 258, "col": 1, "file": 14}, "message": "sk_BIO_sort -> Total CFGBlocks: 3 | Unreachable CFGBlocks: 0 | Exhausted Block: no | Empty WorkList: yes"}], "macros": [], "notes": [], "path": "/usr/include/openssl/bio.h", "reportHash": "16d563223d36e5fdd8009bfd3be5f292", "checkerName": "debug.Stats", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"line": 258, "col": 1, "file": 14}, "message": "sk_BIO_is_sorted -> Total CFGBlocks: 3 | Unreachable CFGBlocks: 0 | Exhausted Block: no | Empty WorkList: yes"}], "macros": [], "notes": [], "path": "/usr/include/openssl/bio.h", "reportHash": "49054570ae8c2d1cfac0803ec540b82e", "checkerName": "debug.Stats", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"line": 258, "col": 1, "file": 14}, "message": "sk_BIO_dup -> Total CFGBlocks: 3 | Unreachable CFGBlocks: 0 | Exhausted Block: no | Empty WorkList: yes"}], "macros": [], "notes": [], "path": "/usr/include/openssl/bio.h", "reportHash": "69173a19f36f5ce243ed40127a26eec6", "checkerName": "debug.Stats", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"line": 258, "col": 1, "file": 14}, "message": "sk_BIO_deep_copy -> Total CFGBlocks: 3 | Unreachable CFGBlocks: 0 | Exhausted Block: no | Empty WorkList: yes"}], "macros": [], "notes": [], "path": "/usr/include/openssl/bio.h", "reportHash": "cc888e8e3555bd43a9324ab0d19e8cfa", "checkerName": "debug.Stats", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"line": 258, "col": 1, "file": 14}, "message": "sk_BIO_set_cmp_func -> Total CFGBlocks: 3 | Unreachable CFGBlocks: 0 | Exhausted Block: no | Empty WorkList: yes"}], "macros": [], "notes": [], "path": "/usr/include/openssl/bio.h", "reportHash": "8999af88e1e0384bc32dd04504c86856", "checkerName": "debug.Stats", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"line": 119, "col": 1, "file": 15}, "message": "sk_X509_ALGOR_num -> Total CFGBlocks: 3 | Unreachable CFGBlocks: 0 | Exhausted Block: no | Empty WorkList: yes"}], "macros": [], "notes": [], "path": "/usr/include/openssl/asn1.h", "reportHash": "0d6459667da390e4d4f778a44fc33c32", "checkerName": "debug.Stats", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"line": 119, "col": 1, "file": 15}, "message": "sk_X509_ALGOR_value -> Total CFGBlocks: 3 | Unreachable CFGBlocks: 0 | Exhausted Block: no | Empty WorkList: yes"}], "macros": [], "notes": [], "path": "/usr/include/openssl/asn1.h", "reportHash": "a254be40422005fe8ff83f8d4c1e5910", "checkerName": "debug.Stats", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"line": 119, "col": 1, "file": 15}, "message": "sk_X509_ALGOR_new -> Total CFGBlocks: 3 | Unreachable CFGBlocks: 0 | Exhausted Block: no | Empty WorkList: yes"}], "macros": [], "notes": [], "path": "/usr/include/openssl/asn1.h", "reportHash": "c3a24b9be714b0edf8dab92830a3d687", "checkerName": "debug.Stats", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"line": 119, "col": 1, "file": 15}, "message": "sk_X509_ALGOR_new_null -> Total CFGBlocks: 3 | Unreachable CFGBlocks: 0 | Exhausted Block: no | Empty WorkList: yes"}], "macros": [], "notes": [], "path": "/usr/include/openssl/asn1.h", "reportHash": "1a1cbab6d945a3581bf5031ac6ee7655", "checkerName": "debug.Stats", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"line": 119, "col": 1, "file": 15}, "message": "sk_X509_ALGOR_new_reserve -> Total CFGBlocks: 3 | Unreachable CFGBlocks: 0 | Exhausted Block: no | Empty WorkList: yes"}], "macros": [], "notes": [], "path": "/usr/include/openssl/asn1.h", "reportHash": "8e1e2061273c65385314f8afe2c56809", "checkerName": "debug.Stats", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"line": 119, "col": 1, "file": 15}, "message": "sk_X509_ALGOR_reserve -> Total CFGBlocks: 3 | Unreachable CFGBlocks: 0 | Exhausted Block: no | Empty WorkList: yes"}], "macros": [], "notes": [], "path": "/usr/include/openssl/asn1.h", "reportHash": "8b1df0f39f26e7e25d686353eb3b28a2", "checkerName": "debug.Stats", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"line": 119, "col": 1, "file": 15}, "message": "sk_X509_ALGOR_free -> Total CFGBlocks: 3 | Unreachable CFGBlocks: 0 | Exhausted Block: no | Empty WorkList: yes"}], "macros": [], "notes": [], "path": "/usr/include/openssl/asn1.h", "reportHash": "c41cc4db98ae15b810fca8b2239f2a39", "checkerName": "debug.Stats", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"line": 119, "col": 1, "file": 15}, "message": "sk_X509_ALGOR_zero -> Total CFGBlocks: 3 | Unreachable CFGBlocks: 0 | Exhausted Block: no | Empty WorkList: yes"}], "macros": [], "notes": [], "path": "/usr/include/openssl/asn1.h", "reportHash": "87d104ef09c1404fbb4c240ca08a7638", "checkerName": "debug.Stats", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"line": 119, "col": 1, "file": 15}, "message": "sk_X509_ALGOR_delete -> Total CFGBlocks: 3 | Unreachable CFGBlocks: 0 | Exhausted Block: no | Empty WorkList: yes"}], "macros": [], "notes": [], "path": "/usr/include/openssl/asn1.h", "reportHash": "bd53a2ffeb722a290a3188046f2c3c27", "checkerName": "debug.Stats", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"line": 119, "col": 1, "file": 15}, "message": "sk_X509_ALGOR_delete_ptr -> Total CFGBlocks: 3 | Unreachable CFGBlocks: 0 | Exhausted Block: no | Empty WorkList: yes"}], "macros": [], "notes": [], "path": "/usr/include/openssl/asn1.h", "reportHash": "9346d61d6b8afb05aa7508df51f794c6", "checkerName": "debug.Stats", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"line": 119, "col": 1, "file": 15}, "message": "sk_X509_ALGOR_push -> Total CFGBlocks: 3 | Unreachable CFGBlocks: 0 | Exhausted Block: no | Empty WorkList: yes"}], "macros": [], "notes": [], "path": "/usr/include/openssl/asn1.h", "reportHash": "5a20a21c23913817c9c4ebe3d5362e53", "checkerName": "debug.Stats", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"line": 119, "col": 1, "file": 15}, "message": "sk_X509_ALGOR_unshift -> Total CFGBlocks: 3 | Unreachable CFGBlocks: 0 | Exhausted Block: no | Empty WorkList: yes"}], "macros": [], "notes": [], "path": "/usr/include/openssl/asn1.h", "reportHash": "333246bf5e8649a076ba4a21e160018f", "checkerName": "debug.Stats", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"line": 119, "col": 1, "file": 15}, "message": "sk_X509_ALGOR_pop -> Total CFGBlocks: 3 | Unreachable CFGBlocks: 0 | Exhausted Block: no | Empty WorkList: yes"}], "macros": [], "notes": [], "path": "/usr/include/openssl/asn1.h", "reportHash": "e460c3b666040327d4fc6329f105f70a", "checkerName": "debug.Stats", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"line": 119, "col": 1, "file": 15}, "message": "sk_X509_ALGOR_shift -> Total CFGBlocks: 3 | Unreachable CFGBlocks: 0 | Exhausted Block: no | Empty WorkList: yes"}], "macros": [], "notes": [], "path": "/usr/include/openssl/asn1.h", "reportHash": "3ba54b6a33815fe23b4fafcaf2162d1f", "checkerName": "debug.Stats", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"line": 119, "col": 1, "file": 15}, "message": "sk_X509_ALGOR_pop_free -> Total CFGBlocks: 3 | Unreachable CFGBlocks: 0 | Exhausted Block: no | Empty WorkList: yes"}], "macros": [], "notes": [], "path": "/usr/include/openssl/asn1.h", "reportHash": "84e30de27c3f510adecabefd1334150b", "checkerName": "debug.Stats", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"line": 119, "col": 1, "file": 15}, "message": "sk_X509_ALGOR_insert -> Total CFGBlocks: 3 | Unreachable CFGBlocks: 0 | Exhausted Block: no | Empty WorkList: yes"}], "macros": [], "notes": [], "path": "/usr/include/openssl/asn1.h", "reportHash": "99aa44add26359980100036a929ebab1", "checkerName": "debug.Stats", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"line": 119, "col": 1, "file": 15}, "message": "sk_X509_ALGOR_set -> Total CFGBlocks: 3 | Unreachable CFGBlocks: 0 | Exhausted Block: no | Empty WorkList: yes"}], "macros": [], "notes": [], "path": "/usr/include/openssl/asn1.h", "reportHash": "9108ecd84f34c2527f5fb9733db70d06", "checkerName": "debug.Stats", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"line": 119, "col": 1, "file": 15}, "message": "sk_X509_ALGOR_find -> Total CFGBlocks: 3 | Unreachable CFGBlocks: 0 | Exhausted Block: no | Empty WorkList: yes"}], "macros": [], "notes": [], "path": "/usr/include/openssl/asn1.h", "reportHash": "b7225d7ebbeeea16c75a8110f35a169c", "checkerName": "debug.Stats", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"line": 119, "col": 1, "file": 15}, "message": "sk_X509_ALGOR_find_ex -> Total CFGBlocks: 3 | Unreachable CFGBlocks: 0 | Exhausted Block: no | Empty WorkList: yes"}], "macros": [], "notes": [], "path": "/usr/include/openssl/asn1.h", "reportHash": "81bd41dc964771c527ba8f068dca325a", "checkerName": "debug.Stats", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"line": 119, "col": 1, "file": 15}, "message": "sk_X509_ALGOR_sort -> Total CFGBlocks: 3 | Unreachable CFGBlocks: 0 | Exhausted Block: no | Empty WorkList: yes"}], "macros": [], "notes": [], "path": "/usr/include/openssl/asn1.h", "reportHash": "a8701fca937a63e37a0d48c30ef59ff2", "checkerName": "debug.Stats", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"line": 119, "col": 1, "file": 15}, "message": "sk_X509_ALGOR_is_sorted -> Total CFGBlocks: 3 | Unreachable CFGBlocks: 0 | Exhausted Block: no | Empty WorkList: yes"}], "macros": [], "notes": [], "path": "/usr/include/openssl/asn1.h", "reportHash": "22bf9d7cef029e606f341a0492249085", "checkerName": "debug.Stats", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"line": 119, "col": 1, "file": 15}, "message": "sk_X509_ALGOR_dup -> Total CFGBlocks: 3 | Unreachable CFGBlocks: 0 | Exhausted Block: no | Empty WorkList: yes"}], "macros": [], "notes": [], "path": "/usr/include/openssl/asn1.h", "reportHash": "9a0a87b8ea6201b0148a01631b6fe760", "checkerName": "debug.Stats", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"line": 119, "col": 1, "file": 15}, "message": "sk_X509_ALGOR_deep_copy -> Total CFGBlocks: 3 | Unreachable CFGBlocks: 0 | Exhausted Block: no | Empty WorkList: yes"}], "macros": [], "notes": [], "path": "/usr/include/openssl/asn1.h", "reportHash": "9f3881f7d6b4a39349deb9a5a6e62eeb", "checkerName": "debug.Stats", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"line": 119, "col": 1, "file": 15}, "message": "sk_X509_ALGOR_set_cmp_func -> Total CFGBlocks: 3 | Unreachable CFGBlocks: 0 | Exhausted Block: no | Empty WorkList: yes"}], "macros": [], "notes": [], "path": "/usr/include/openssl/asn1.h", "reportHash": "18e75f8f08c2cd6df0e38176b2f09e66", "checkerName": "debug.Stats", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"line": 194, "col": 1, "file": 15}, "message": "sk_ASN1_STRING_TABLE_num -> Total CFGBlocks: 3 | Unreachable CFGBlocks: 0 | Exhausted Block: no | Empty WorkList: yes"}], "macros": [], "notes": [], "path": "/usr/include/openssl/asn1.h", "reportHash": "47ec5e2029ce93cb93504a7ffc49fe6d", "checkerName": "debug.Stats", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"line": 194, "col": 1, "file": 15}, "message": "sk_ASN1_STRING_TABLE_value -> Total CFGBlocks: 3 | Unreachable CFGBlocks: 0 | Exhausted Block: no | Empty WorkList: yes"}], "macros": [], "notes": [], "path": "/usr/include/openssl/asn1.h", "reportHash": "ef3a5e23e6f36a55eec26a9c881b5cee", "checkerName": "debug.Stats", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"line": 194, "col": 1, "file": 15}, "message": "sk_ASN1_STRING_TABLE_new -> Total CFGBlocks: 3 | Unreachable CFGBlocks: 0 | Exhausted Block: no | Empty WorkList: yes"}], "macros": [], "notes": [], "path": "/usr/include/openssl/asn1.h", "reportHash": "24753da43d331cee1985a84a643d156b", "checkerName": "debug.Stats", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"line": 194, "col": 1, "file": 15}, "message": "sk_ASN1_STRING_TABLE_new_null -> Total CFGBlocks: 3 | Unreachable CFGBlocks: 0 | Exhausted Block: no | Empty WorkList: yes"}], "macros": [], "notes": [], "path": "/usr/include/openssl/asn1.h", "reportHash": "dce57cb0c459b1bda823d144a4d279a5", "checkerName": "debug.Stats", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"line": 194, "col": 1, "file": 15}, "message": "sk_ASN1_STRING_TABLE_new_reserve -> Total CFGBlocks: 3 | Unreachable CFGBlocks: 0 | Exhausted Block: no | Empty WorkList: yes"}], "macros": [], "notes": [], "path": "/usr/include/openssl/asn1.h", "reportHash": "ecc55dd920d0721bb0b11e0582051589", "checkerName": "debug.Stats", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"line": 194, "col": 1, "file": 15}, "message": "sk_ASN1_STRING_TABLE_reserve -> Total CFGBlocks: 3 | Unreachable CFGBlocks: 0 | Exhausted Block: no | Empty WorkList: yes"}], "macros": [], "notes": [], "path": "/usr/include/openssl/asn1.h", "reportHash": "1c71cb70fcb83766ceabbf069b503918", "checkerName": "debug.Stats", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"line": 194, "col": 1, "file": 15}, "message": "sk_ASN1_STRING_TABLE_free -> Total CFGBlocks: 3 | Unreachable CFGBlocks: 0 | Exhausted Block: no | Empty WorkList: yes"}], "macros": [], "notes": [], "path": "/usr/include/openssl/asn1.h", "reportHash": "784945c6c8c17e9f63c703bf96afe61d", "checkerName": "debug.Stats", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"line": 194, "col": 1, "file": 15}, "message": "sk_ASN1_STRING_TABLE_zero -> Total CFGBlocks: 3 | Unreachable CFGBlocks: 0 | Exhausted Block: no | Empty WorkList: yes"}], "macros": [], "notes": [], "path": "/usr/include/openssl/asn1.h", "reportHash": "ef374b2979c1764df4435f67295b3eda", "checkerName": "debug.Stats", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"line": 194, "col": 1, "file": 15}, "message": "sk_ASN1_STRING_TABLE_delete -> Total CFGBlocks: 3 | Unreachable CFGBlocks: 0 | Exhausted Block: no | Empty WorkList: yes"}], "macros": [], "notes": [], "path": "/usr/include/openssl/asn1.h", "reportHash": "18b484c351ae1764bb1d3e70bcb116f8", "checkerName": "debug.Stats", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"line": 194, "col": 1, "file": 15}, "message": "sk_ASN1_STRING_TABLE_delete_ptr -> Total CFGBlocks: 3 | Unreachable CFGBlocks: 0 | Exhausted Block: no | Empty WorkList: yes"}], "macros": [], "notes": [], "path": "/usr/include/openssl/asn1.h", "reportHash": "8cdbe6866f193f829d37a5d5b8b83f49", "checkerName": "debug.Stats", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"line": 194, "col": 1, "file": 15}, "message": "sk_ASN1_STRING_TABLE_push -> Total CFGBlocks: 3 | Unreachable CFGBlocks: 0 | Exhausted Block: no | Empty WorkList: yes"}], "macros": [], "notes": [], "path": "/usr/include/openssl/asn1.h", "reportHash": "7a331829f520fec95375694df7c65e2b", "checkerName": "debug.Stats", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"line": 194, "col": 1, "file": 15}, "message": "sk_ASN1_STRING_TABLE_unshift -> Total CFGBlocks: 3 | Unreachable CFGBlocks: 0 | Exhausted Block: no | Empty WorkList: yes"}], "macros": [], "notes": [], "path": "/usr/include/openssl/asn1.h", "reportHash": "a3fc5bbb0097af4553952de2a36a664b", "checkerName": "debug.Stats", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"line": 194, "col": 1, "file": 15}, "message": "sk_ASN1_STRING_TABLE_pop -> Total CFGBlocks: 3 | Unreachable CFGBlocks: 0 | Exhausted Block: no | Empty WorkList: yes"}], "macros": [], "notes": [], "path": "/usr/include/openssl/asn1.h", "reportHash": "6015f48a04531fb3751bda5ab6ae6855", "checkerName": "debug.Stats", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"line": 194, "col": 1, "file": 15}, "message": "sk_ASN1_STRING_TABLE_shift -> Total CFGBlocks: 3 | Unreachable CFGBlocks: 0 | Exhausted Block: no | Empty WorkList: yes"}], "macros": [], "notes": [], "path": "/usr/include/openssl/asn1.h", "reportHash": "8d5c53f81333a173a7ac16ac602209d6", "checkerName": "debug.Stats", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"line": 194, "col": 1, "file": 15}, "message": "sk_ASN1_STRING_TABLE_pop_free -> Total CFGBlocks: 3 | Unreachable CFGBlocks: 0 | Exhausted Block: no | Empty WorkList: yes"}], "macros": [], "notes": [], "path": "/usr/include/openssl/asn1.h", "reportHash": "8e383202b5064c19ebcdaa4c731751d8", "checkerName": "debug.Stats", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"line": 194, "col": 1, "file": 15}, "message": "sk_ASN1_STRING_TABLE_insert -> Total CFGBlocks: 3 | Unreachable CFGBlocks: 0 | Exhausted Block: no | Empty WorkList: yes"}], "macros": [], "notes": [], "path": "/usr/include/openssl/asn1.h", "reportHash": "d566a1a1fd90e00e907c08d3a89459f0", "checkerName": "debug.Stats", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"line": 194, "col": 1, "file": 15}, "message": "sk_ASN1_STRING_TABLE_set -> Total CFGBlocks: 3 | Unreachable CFGBlocks: 0 | Exhausted Block: no | Empty WorkList: yes"}], "macros": [], "notes": [], "path": "/usr/include/openssl/asn1.h", "reportHash": "d97dda49065afba3527c279bc4598708", "checkerName": "debug.Stats", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"line": 194, "col": 1, "file": 15}, "message": "sk_ASN1_STRING_TABLE_find -> Total CFGBlocks: 3 | Unreachable CFGBlocks: 0 | Exhausted Block: no | Empty WorkList: yes"}], "macros": [], "notes": [], "path": "/usr/include/openssl/asn1.h", "reportHash": "4abe1058e6e0adbd168ac7a3225dcee6", "checkerName": "debug.Stats", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"line": 194, "col": 1, "file": 15}, "message": "sk_ASN1_STRING_TABLE_find_ex -> Total CFGBlocks: 3 | Unreachable CFGBlocks: 0 | Exhausted Block: no | Empty WorkList: yes"}], "macros": [], "notes": [], "path": "/usr/include/openssl/asn1.h", "reportHash": "ae1cd37fe9e5e7638608444c7aafc572", "checkerName": "debug.Stats", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"line": 194, "col": 1, "file": 15}, "message": "sk_ASN1_STRING_TABLE_sort -> Total CFGBlocks: 3 | Unreachable CFGBlocks: 0 | Exhausted Block: no | Empty WorkList: yes"}], "macros": [], "notes": [], "path": "/usr/include/openssl/asn1.h", "reportHash": "ad663b4a36116521cc46b1e17fed2f9f", "checkerName": "debug.Stats", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"line": 194, "col": 1, "file": 15}, "message": "sk_ASN1_STRING_TABLE_is_sorted -> Total CFGBlocks: 3 | Unreachable CFGBlocks: 0 | Exhausted Block: no | Empty WorkList: yes"}], "macros": [], "notes": [], "path": "/usr/include/openssl/asn1.h", "reportHash": "133a11660542a3f8fe2f63a4e70438d8", "checkerName": "debug.Stats", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"line": 194, "col": 1, "file": 15}, "message": "sk_ASN1_STRING_TABLE_dup -> Total CFGBlocks: 3 | Unreachable CFGBlocks: 0 | Exhausted Block: no | Empty WorkList: yes"}], "macros": [], "notes": [], "path": "/usr/include/openssl/asn1.h", "reportHash": "6164396e0ae5736d01c0439ade8f4765", "checkerName": "debug.Stats", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"line": 194, "col": 1, "file": 15}, "message": "sk_ASN1_STRING_TABLE_deep_copy -> Total CFGBlocks: 3 | Unreachable CFGBlocks: 0 | Exhausted Block: no | Empty WorkList: yes"}], "macros": [], "notes": [], "path": "/usr/include/openssl/asn1.h", "reportHash": "8be3134674ce1dfe620662f39fec2b4a", "checkerName": "debug.Stats", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"line": 194, "col": 1, "file": 15}, "message": "sk_ASN1_STRING_TABLE_set_cmp_func -> Total CFGBlocks: 3 | Unreachable CFGBlocks: 0 | Exhausted Block: no | Empty WorkList: yes"}], "macros": [], "notes": [], "path": "/usr/include/openssl/asn1.h", "reportHash": "b56f16fe7de0d30c39de41044f7a44b3", "checkerName": "debug.Stats", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"line": 438, "col": 1, "file": 15}, "message": "sk_ASN1_INTEGER_num -> Total CFGBlocks: 3 | Unreachable CFGBlocks: 0 | Exhausted Block: no | Empty WorkList: yes"}], "macros": [], "notes": [], "path": "/usr/include/openssl/asn1.h", "reportHash": "d8d4c0bcb828fa9cc2405204c25fabd1", "checkerName": "debug.Stats", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"line": 438, "col": 1, "file": 15}, "message": "sk_ASN1_INTEGER_value -> Total CFGBlocks: 3 | Unreachable CFGBlocks: 0 | Exhausted Block: no | Empty WorkList: yes"}], "macros": [], "notes": [], "path": "/usr/include/openssl/asn1.h", "reportHash": "5db3544aa7b2063cc93d4250034dedb9", "checkerName": "debug.Stats", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"line": 438, "col": 1, "file": 15}, "message": "sk_ASN1_INTEGER_new -> Total CFGBlocks: 3 | Unreachable CFGBlocks: 0 | Exhausted Block: no | Empty WorkList: yes"}], "macros": [], "notes": [], "path": "/usr/include/openssl/asn1.h", "reportHash": "1affd7ca013c8ab2c4df5c1e579d3497", "checkerName": "debug.Stats", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"line": 438, "col": 1, "file": 15}, "message": "sk_ASN1_INTEGER_new_null -> Total CFGBlocks: 3 | Unreachable CFGBlocks: 0 | Exhausted Block: no | Empty WorkList: yes"}], "macros": [], "notes": [], "path": "/usr/include/openssl/asn1.h", "reportHash": "59e42659358daa7486897bf3fb3af8bc", "checkerName": "debug.Stats", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"line": 438, "col": 1, "file": 15}, "message": "sk_ASN1_INTEGER_new_reserve -> Total CFGBlocks: 3 | Unreachable CFGBlocks: 0 | Exhausted Block: no | Empty WorkList: yes"}], "macros": [], "notes": [], "path": "/usr/include/openssl/asn1.h", "reportHash": "c576fba56e01de2cc9146c85fb6e5808", "checkerName": "debug.Stats", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"line": 438, "col": 1, "file": 15}, "message": "sk_ASN1_INTEGER_reserve -> Total CFGBlocks: 3 | Unreachable CFGBlocks: 0 | Exhausted Block: no | Empty WorkList: yes"}], "macros": [], "notes": [], "path": "/usr/include/openssl/asn1.h", "reportHash": "ddd08b54dfca72802d4416de48764d11", "checkerName": "debug.Stats", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"line": 438, "col": 1, "file": 15}, "message": "sk_ASN1_INTEGER_free -> Total CFGBlocks: 3 | Unreachable CFGBlocks: 0 | Exhausted Block: no | Empty WorkList: yes"}], "macros": [], "notes": [], "path": "/usr/include/openssl/asn1.h", "reportHash": "15fb3d7dfa8924da7bb388bf4420c73c", "checkerName": "debug.Stats", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"line": 438, "col": 1, "file": 15}, "message": "sk_ASN1_INTEGER_zero -> Total CFGBlocks: 3 | Unreachable CFGBlocks: 0 | Exhausted Block: no | Empty WorkList: yes"}], "macros": [], "notes": [], "path": "/usr/include/openssl/asn1.h", "reportHash": "b065f504fd2a0ba127b0645e615b328a", "checkerName": "debug.Stats", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"line": 438, "col": 1, "file": 15}, "message": "sk_ASN1_INTEGER_delete -> Total CFGBlocks: 3 | Unreachable CFGBlocks: 0 | Exhausted Block: no | Empty WorkList: yes"}], "macros": [], "notes": [], "path": "/usr/include/openssl/asn1.h", "reportHash": "8c7b5600d785f9c3a31d49cf1b431273", "checkerName": "debug.Stats", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"line": 438, "col": 1, "file": 15}, "message": "sk_ASN1_INTEGER_delete_ptr -> Total CFGBlocks: 3 | Unreachable CFGBlocks: 0 | Exhausted Block: no | Empty WorkList: yes"}], "macros": [], "notes": [], "path": "/usr/include/openssl/asn1.h", "reportHash": "d826d63d8926eb3bf3656ec73d73cb9b", "checkerName": "debug.Stats", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"line": 438, "col": 1, "file": 15}, "message": "sk_ASN1_INTEGER_push -> Total CFGBlocks: 3 | Unreachable CFGBlocks: 0 | Exhausted Block: no | Empty WorkList: yes"}], "macros": [], "notes": [], "path": "/usr/include/openssl/asn1.h", "reportHash": "0fa33792df701751df95977079bb6462", "checkerName": "debug.Stats", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"line": 438, "col": 1, "file": 15}, "message": "sk_ASN1_INTEGER_unshift -> Total CFGBlocks: 3 | Unreachable CFGBlocks: 0 | Exhausted Block: no | Empty WorkList: yes"}], "macros": [], "notes": [], "path": "/usr/include/openssl/asn1.h", "reportHash": "ab87256ac4231bd0f1175cc7c8ac71d1", "checkerName": "debug.Stats", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"line": 438, "col": 1, "file": 15}, "message": "sk_ASN1_INTEGER_pop -> Total CFGBlocks: 3 | Unreachable CFGBlocks: 0 | Exhausted Block: no | Empty WorkList: yes"}], "macros": [], "notes": [], "path": "/usr/include/openssl/asn1.h", "reportHash": "aa8b8824df93e066a46c81fe08e415dd", "checkerName": "debug.Stats", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"line": 438, "col": 1, "file": 15}, "message": "sk_ASN1_INTEGER_shift -> Total CFGBlocks: 3 | Unreachable CFGBlocks: 0 | Exhausted Block: no | Empty WorkList: yes"}], "macros": [], "notes": [], "path": "/usr/include/openssl/asn1.h", "reportHash": "1008b9983815d25832918200dbc4edbe", "checkerName": "debug.Stats", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"line": 438, "col": 1, "file": 15}, "message": "sk_ASN1_INTEGER_pop_free -> Total CFGBlocks: 3 | Unreachable CFGBlocks: 0 | Exhausted Block: no | Empty WorkList: yes"}], "macros": [], "notes": [], "path": "/usr/include/openssl/asn1.h", "reportHash": "d5e998364ae3b382410de06ba663f3a3", "checkerName": "debug.Stats", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"line": 438, "col": 1, "file": 15}, "message": "sk_ASN1_INTEGER_insert -> Total CFGBlocks: 3 | Unreachable CFGBlocks: 0 | Exhausted Block: no | Empty WorkList: yes"}], "macros": [], "notes": [], "path": "/usr/include/openssl/asn1.h", "reportHash": "403e9dd185bc3ec58a193aab32a99e0f", "checkerName": "debug.Stats", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"line": 438, "col": 1, "file": 15}, "message": "sk_ASN1_INTEGER_set -> Total CFGBlocks: 3 | Unreachable CFGBlocks: 0 | Exhausted Block: no | Empty WorkList: yes"}], "macros": [], "notes": [], "path": "/usr/include/openssl/asn1.h", "reportHash": "d7f1337036ba9038362e229b2ca2699c", "checkerName": "debug.Stats", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"line": 438, "col": 1, "file": 15}, "message": "sk_ASN1_INTEGER_find -> Total CFGBlocks: 3 | Unreachable CFGBlocks: 0 | Exhausted Block: no | Empty WorkList: yes"}], "macros": [], "notes": [], "path": "/usr/include/openssl/asn1.h", "reportHash": "6efeedf81956e14b0328b24b6ef1ef54", "checkerName": "debug.Stats", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"line": 438, "col": 1, "file": 15}, "message": "sk_ASN1_INTEGER_find_ex -> Total CFGBlocks: 3 | Unreachable CFGBlocks: 0 | Exhausted Block: no | Empty WorkList: yes"}], "macros": [], "notes": [], "path": "/usr/include/openssl/asn1.h", "reportHash": "a1aad93f1fcb6f177b498775fd885dbd", "checkerName": "debug.Stats", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"line": 438, "col": 1, "file": 15}, "message": "sk_ASN1_INTEGER_sort -> Total CFGBlocks: 3 | Unreachable CFGBlocks: 0 | Exhausted Block: no | Empty WorkList: yes"}], "macros": [], "notes": [], "path": "/usr/include/openssl/asn1.h", "reportHash": "c0baaf56e06bb258f8e92ac98b3a506d", "checkerName": "debug.Stats", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"line": 438, "col": 1, "file": 15}, "message": "sk_ASN1_INTEGER_is_sorted -> Total CFGBlocks: 3 | Unreachable CFGBlocks: 0 | Exhausted Block: no | Empty WorkList: yes"}], "macros": [], "notes": [], "path": "/usr/include/openssl/asn1.h", "reportHash": "060be71d6d359f2994705a55c026aaa5", "checkerName": "debug.Stats", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"line": 438, "col": 1, "file": 15}, "message": "sk_ASN1_INTEGER_dup -> Total CFGBlocks: 3 | Unreachable CFGBlocks: 0 | Exhausted Block: no | Empty WorkList: yes"}], "macros": [], "notes": [], "path": "/usr/include/openssl/asn1.h", "reportHash": "3cedfffcb1b595e09b51b0a446c2594c", "checkerName": "debug.Stats", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"line": 438, "col": 1, "file": 15}, "message": "sk_ASN1_INTEGER_deep_copy -> Total CFGBlocks: 3 | Unreachable CFGBlocks: 0 | Exhausted Block: no | Empty WorkList: yes"}], "macros": [], "notes": [], "path": "/usr/include/openssl/asn1.h", "reportHash": "bf2b416f7705ab8636551fe994a57047", "checkerName": "debug.Stats", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"line": 438, "col": 1, "file": 15}, "message": "sk_ASN1_INTEGER_set_cmp_func -> Total CFGBlocks: 3 | Unreachable CFGBlocks: 0 | Exhausted Block: no | Empty WorkList: yes"}], "macros": [], "notes": [], "path": "/usr/include/openssl/asn1.h", "reportHash": "1790ad2dd3400c3448e22611554d0026", "checkerName": "debug.Stats", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"line": 440, "col": 1, "file": 15}, "message": "sk_ASN1_GENERALSTRING_num -> Total CFGBlocks: 3 | Unreachable CFGBlocks: 0 | Exhausted Block: no | Empty WorkList: yes"}], "macros": [], "notes": [], "path": "/usr/include/openssl/asn1.h", "reportHash": "d44715999b226d64b61c0b4a2c96aa33", "checkerName": "debug.Stats", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"line": 440, "col": 1, "file": 15}, "message": "sk_ASN1_GENERALSTRING_value -> Total CFGBlocks: 3 | Unreachable CFGBlocks: 0 | Exhausted Block: no | Empty WorkList: yes"}], "macros": [], "notes": [], "path": "/usr/include/openssl/asn1.h", "reportHash": "39891a95c5f4068052311236b819a405", "checkerName": "debug.Stats", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"line": 440, "col": 1, "file": 15}, "message": "sk_ASN1_GENERALSTRING_new -> Total CFGBlocks: 3 | Unreachable CFGBlocks: 0 | Exhausted Block: no | Empty WorkList: yes"}], "macros": [], "notes": [], "path": "/usr/include/openssl/asn1.h", "reportHash": "168889e00dadc15f3091c5ef551f90b3", "checkerName": "debug.Stats", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"line": 440, "col": 1, "file": 15}, "message": "sk_ASN1_GENERALSTRING_new_null -> Total CFGBlocks: 3 | Unreachable CFGBlocks: 0 | Exhausted Block: no | Empty WorkList: yes"}], "macros": [], "notes": [], "path": "/usr/include/openssl/asn1.h", "reportHash": "afb2548115cb84910d46e210badfd763", "checkerName": "debug.Stats", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"line": 440, "col": 1, "file": 15}, "message": "sk_ASN1_GENERALSTRING_new_reserve -> Total CFGBlocks: 3 | Unreachable CFGBlocks: 0 | Exhausted Block: no | Empty WorkList: yes"}], "macros": [], "notes": [], "path": "/usr/include/openssl/asn1.h", "reportHash": "4ea1d66acf7c0be6af6a2f4a87ad7413", "checkerName": "debug.Stats", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"line": 440, "col": 1, "file": 15}, "message": "sk_ASN1_GENERALSTRING_reserve -> Total CFGBlocks: 3 | Unreachable CFGBlocks: 0 | Exhausted Block: no | Empty WorkList: yes"}], "macros": [], "notes": [], "path": "/usr/include/openssl/asn1.h", "reportHash": "7f4917fa673f520080efdaf14b9e9858", "checkerName": "debug.Stats", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"line": 440, "col": 1, "file": 15}, "message": "sk_ASN1_GENERALSTRING_free -> Total CFGBlocks: 3 | Unreachable CFGBlocks: 0 | Exhausted Block: no | Empty WorkList: yes"}], "macros": [], "notes": [], "path": "/usr/include/openssl/asn1.h", "reportHash": "e8dd1e67c360551f016234720fb799b7", "checkerName": "debug.Stats", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"line": 440, "col": 1, "file": 15}, "message": "sk_ASN1_GENERALSTRING_zero -> Total CFGBlocks: 3 | Unreachable CFGBlocks: 0 | Exhausted Block: no | Empty WorkList: yes"}], "macros": [], "notes": [], "path": "/usr/include/openssl/asn1.h", "reportHash": "c3bc0dc75846c05d7d47e97f70bff99b", "checkerName": "debug.Stats", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"line": 440, "col": 1, "file": 15}, "message": "sk_ASN1_GENERALSTRING_delete -> Total CFGBlocks: 3 | Unreachable CFGBlocks: 0 | Exhausted Block: no | Empty WorkList: yes"}], "macros": [], "notes": [], "path": "/usr/include/openssl/asn1.h", "reportHash": "06fb5b5bc529a7ef47a4bd53de86c969", "checkerName": "debug.Stats", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"line": 440, "col": 1, "file": 15}, "message": "sk_ASN1_GENERALSTRING_delete_ptr -> Total CFGBlocks: 3 | Unreachable CFGBlocks: 0 | Exhausted Block: no | Empty WorkList: yes"}], "macros": [], "notes": [], "path": "/usr/include/openssl/asn1.h", "reportHash": "bf6b2a71550fd71111dd0b0522bfeeef", "checkerName": "debug.Stats", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"line": 440, "col": 1, "file": 15}, "message": "sk_ASN1_GENERALSTRING_push -> Total CFGBlocks: 3 | Unreachable CFGBlocks: 0 | Exhausted Block: no | Empty WorkList: yes"}], "macros": [], "notes": [], "path": "/usr/include/openssl/asn1.h", "reportHash": "0e2a5a7fb34ff7011e60ed4c185973b4", "checkerName": "debug.Stats", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"line": 440, "col": 1, "file": 15}, "message": "sk_ASN1_GENERALSTRING_unshift -> Total CFGBlocks: 3 | Unreachable CFGBlocks: 0 | Exhausted Block: no | Empty WorkList: yes"}], "macros": [], "notes": [], "path": "/usr/include/openssl/asn1.h", "reportHash": "8a5b7c5f2b6ad0f989b368006fbcedb2", "checkerName": "debug.Stats", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"line": 440, "col": 1, "file": 15}, "message": "sk_ASN1_GENERALSTRING_pop -> Total CFGBlocks: 3 | Unreachable CFGBlocks: 0 | Exhausted Block: no | Empty WorkList: yes"}], "macros": [], "notes": [], "path": "/usr/include/openssl/asn1.h", "reportHash": "1cd9da7278712250e7a728d03d6e3a51", "checkerName": "debug.Stats", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"line": 440, "col": 1, "file": 15}, "message": "sk_ASN1_GENERALSTRING_shift -> Total CFGBlocks: 3 | Unreachable CFGBlocks: 0 | Exhausted Block: no | Empty WorkList: yes"}], "macros": [], "notes": [], "path": "/usr/include/openssl/asn1.h", "reportHash": "5ed2d5a8598c3dbf8c56dd08721e388a", "checkerName": "debug.Stats", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"line": 440, "col": 1, "file": 15}, "message": "sk_ASN1_GENERALSTRING_pop_free -> Total CFGBlocks: 3 | Unreachable CFGBlocks: 0 | Exhausted Block: no | Empty WorkList: yes"}], "macros": [], "notes": [], "path": "/usr/include/openssl/asn1.h", "reportHash": "8dbf9e7f778a0d9fc1883171965ae7ba", "checkerName": "debug.Stats", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"line": 440, "col": 1, "file": 15}, "message": "sk_ASN1_GENERALSTRING_insert -> Total CFGBlocks: 3 | Unreachable CFGBlocks: 0 | Exhausted Block: no | Empty WorkList: yes"}], "macros": [], "notes": [], "path": "/usr/include/openssl/asn1.h", "reportHash": "284a27292f59a2b3dce01858a97775c8", "checkerName": "debug.Stats", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"line": 440, "col": 1, "file": 15}, "message": "sk_ASN1_GENERALSTRING_set -> Total CFGBlocks: 3 | Unreachable CFGBlocks: 0 | Exhausted Block: no | Empty WorkList: yes"}], "macros": [], "notes": [], "path": "/usr/include/openssl/asn1.h", "reportHash": "a8200d057ebb358644e8e5773660ffe3", "checkerName": "debug.Stats", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"line": 440, "col": 1, "file": 15}, "message": "sk_ASN1_GENERALSTRING_find -> Total CFGBlocks: 3 | Unreachable CFGBlocks: 0 | Exhausted Block: no | Empty WorkList: yes"}], "macros": [], "notes": [], "path": "/usr/include/openssl/asn1.h", "reportHash": "f86278b4450d0be2d117caf042c25dd0", "checkerName": "debug.Stats", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"line": 440, "col": 1, "file": 15}, "message": "sk_ASN1_GENERALSTRING_find_ex -> Total CFGBlocks: 3 | Unreachable CFGBlocks: 0 | Exhausted Block: no | Empty WorkList: yes"}], "macros": [], "notes": [], "path": "/usr/include/openssl/asn1.h", "reportHash": "590d513d62870b4c6d64c408c3f7f484", "checkerName": "debug.Stats", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"line": 440, "col": 1, "file": 15}, "message": "sk_ASN1_GENERALSTRING_sort -> Total CFGBlocks: 3 | Unreachable CFGBlocks: 0 | Exhausted Block: no | Empty WorkList: yes"}], "macros": [], "notes": [], "path": "/usr/include/openssl/asn1.h", "reportHash": "39bd89b1c76191cffc6c7fe308f83da8", "checkerName": "debug.Stats", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"line": 440, "col": 1, "file": 15}, "message": "sk_ASN1_GENERALSTRING_is_sorted -> Total CFGBlocks: 3 | Unreachable CFGBlocks: 0 | Exhausted Block: no | Empty WorkList: yes"}], "macros": [], "notes": [], "path": "/usr/include/openssl/asn1.h", "reportHash": "c6e74a46595e3093e0665c4cda74274a", "checkerName": "debug.Stats", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"line": 440, "col": 1, "file": 15}, "message": "sk_ASN1_GENERALSTRING_dup -> Total CFGBlocks: 3 | Unreachable CFGBlocks: 0 | Exhausted Block: no | Empty WorkList: yes"}], "macros": [], "notes": [], "path": "/usr/include/openssl/asn1.h", "reportHash": "7abbad1a5d4c79f35131121d4db4dab5", "checkerName": "debug.Stats", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"line": 440, "col": 1, "file": 15}, "message": "sk_ASN1_GENERALSTRING_deep_copy -> Total CFGBlocks: 3 | Unreachable CFGBlocks: 0 | Exhausted Block: no | Empty WorkList: yes"}], "macros": [], "notes": [], "path": "/usr/include/openssl/asn1.h", "reportHash": "545c502edcf5c937ca8bfc5018fb1335", "checkerName": "debug.Stats", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"line": 440, "col": 1, "file": 15}, "message": "sk_ASN1_GENERALSTRING_set_cmp_func -> Total CFGBlocks: 3 | Unreachable CFGBlocks: 0 | Exhausted Block: no | Empty WorkList: yes"}], "macros": [], "notes": [], "path": "/usr/include/openssl/asn1.h", "reportHash": "bca68cc94555e0f864cbcc3a3f1af106", "checkerName": "debug.Stats", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"line": 442, "col": 1, "file": 15}, "message": "sk_ASN1_UTF8STRING_num -> Total CFGBlocks: 3 | Unreachable CFGBlocks: 0 | Exhausted Block: no | Empty WorkList: yes"}], "macros": [], "notes": [], "path": "/usr/include/openssl/asn1.h", "reportHash": "d72dd70b50b5c44860bdb2eb66129bcf", "checkerName": "debug.Stats", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"line": 442, "col": 1, "file": 15}, "message": "sk_ASN1_UTF8STRING_value -> Total CFGBlocks: 3 | Unreachable CFGBlocks: 0 | Exhausted Block: no | Empty WorkList: yes"}], "macros": [], "notes": [], "path": "/usr/include/openssl/asn1.h", "reportHash": "39521f4f37c98461f32cb52c63f1b04d", "checkerName": "debug.Stats", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"line": 442, "col": 1, "file": 15}, "message": "sk_ASN1_UTF8STRING_new -> Total CFGBlocks: 3 | Unreachable CFGBlocks: 0 | Exhausted Block: no | Empty WorkList: yes"}], "macros": [], "notes": [], "path": "/usr/include/openssl/asn1.h", "reportHash": "c182ed2e621045ee4894edab85d418b6", "checkerName": "debug.Stats", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"line": 442, "col": 1, "file": 15}, "message": "sk_ASN1_UTF8STRING_new_null -> Total CFGBlocks: 3 | Unreachable CFGBlocks: 0 | Exhausted Block: no | Empty WorkList: yes"}], "macros": [], "notes": [], "path": "/usr/include/openssl/asn1.h", "reportHash": "66d4a0508e38449ba2120b122229d281", "checkerName": "debug.Stats", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"line": 442, "col": 1, "file": 15}, "message": "sk_ASN1_UTF8STRING_new_reserve -> Total CFGBlocks: 3 | Unreachable CFGBlocks: 0 | Exhausted Block: no | Empty WorkList: yes"}], "macros": [], "notes": [], "path": "/usr/include/openssl/asn1.h", "reportHash": "3dad244cda3d75ca54eaa79716040de9", "checkerName": "debug.Stats", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"line": 442, "col": 1, "file": 15}, "message": "sk_ASN1_UTF8STRING_reserve -> Total CFGBlocks: 3 | Unreachable CFGBlocks: 0 | Exhausted Block: no | Empty WorkList: yes"}], "macros": [], "notes": [], "path": "/usr/include/openssl/asn1.h", "reportHash": "4b682f420f30010613632794bf7570db", "checkerName": "debug.Stats", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"line": 442, "col": 1, "file": 15}, "message": "sk_ASN1_UTF8STRING_free -> Total CFGBlocks: 3 | Unreachable CFGBlocks: 0 | Exhausted Block: no | Empty WorkList: yes"}], "macros": [], "notes": [], "path": "/usr/include/openssl/asn1.h", "reportHash": "71c1afcce8d537007d9d5c6ac905c327", "checkerName": "debug.Stats", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"line": 442, "col": 1, "file": 15}, "message": "sk_ASN1_UTF8STRING_zero -> Total CFGBlocks: 3 | Unreachable CFGBlocks: 0 | Exhausted Block: no | Empty WorkList: yes"}], "macros": [], "notes": [], "path": "/usr/include/openssl/asn1.h", "reportHash": "95b8ca5230032605bbb70542759f718f", "checkerName": "debug.Stats", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"line": 442, "col": 1, "file": 15}, "message": "sk_ASN1_UTF8STRING_delete -> Total CFGBlocks: 3 | Unreachable CFGBlocks: 0 | Exhausted Block: no | Empty WorkList: yes"}], "macros": [], "notes": [], "path": "/usr/include/openssl/asn1.h", "reportHash": "52837c1abd23c0ef60c6f3c865c7377d", "checkerName": "debug.Stats", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"line": 442, "col": 1, "file": 15}, "message": "sk_ASN1_UTF8STRING_delete_ptr -> Total CFGBlocks: 3 | Unreachable CFGBlocks: 0 | Exhausted Block: no | Empty WorkList: yes"}], "macros": [], "notes": [], "path": "/usr/include/openssl/asn1.h", "reportHash": "e0d874aaeb7ab364e119a0bf321d5cc7", "checkerName": "debug.Stats", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"line": 442, "col": 1, "file": 15}, "message": "sk_ASN1_UTF8STRING_push -> Total CFGBlocks: 3 | Unreachable CFGBlocks: 0 | Exhausted Block: no | Empty WorkList: yes"}], "macros": [], "notes": [], "path": "/usr/include/openssl/asn1.h", "reportHash": "ec080acfa9ae303782e34a5459bb4e09", "checkerName": "debug.Stats", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"line": 442, "col": 1, "file": 15}, "message": "sk_ASN1_UTF8STRING_unshift -> Total CFGBlocks: 3 | Unreachable CFGBlocks: 0 | Exhausted Block: no | Empty WorkList: yes"}], "macros": [], "notes": [], "path": "/usr/include/openssl/asn1.h", "reportHash": "bf4bc795bb88e8c46f1fd51caf20fc36", "checkerName": "debug.Stats", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"line": 442, "col": 1, "file": 15}, "message": "sk_ASN1_UTF8STRING_pop -> Total CFGBlocks: 3 | Unreachable CFGBlocks: 0 | Exhausted Block: no | Empty WorkList: yes"}], "macros": [], "notes": [], "path": "/usr/include/openssl/asn1.h", "reportHash": "f47d06ec61996fb718c8ff4ae4ff8dad", "checkerName": "debug.Stats", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"line": 442, "col": 1, "file": 15}, "message": "sk_ASN1_UTF8STRING_shift -> Total CFGBlocks: 3 | Unreachable CFGBlocks: 0 | Exhausted Block: no | Empty WorkList: yes"}], "macros": [], "notes": [], "path": "/usr/include/openssl/asn1.h", "reportHash": "5669a6877914b6d7ad2453f7cd60d993", "checkerName": "debug.Stats", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"line": 442, "col": 1, "file": 15}, "message": "sk_ASN1_UTF8STRING_pop_free -> Total CFGBlocks: 3 | Unreachable CFGBlocks: 0 | Exhausted Block: no | Empty WorkList: yes"}], "macros": [], "notes": [], "path": "/usr/include/openssl/asn1.h", "reportHash": "a5da982e15ea19426599d035313d2451", "checkerName": "debug.Stats", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"line": 442, "col": 1, "file": 15}, "message": "sk_ASN1_UTF8STRING_insert -> Total CFGBlocks: 3 | Unreachable CFGBlocks: 0 | Exhausted Block: no | Empty WorkList: yes"}], "macros": [], "notes": [], "path": "/usr/include/openssl/asn1.h", "reportHash": "221830907ece0ecf9080640af8c1366e", "checkerName": "debug.Stats", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"line": 442, "col": 1, "file": 15}, "message": "sk_ASN1_UTF8STRING_set -> Total CFGBlocks: 3 | Unreachable CFGBlocks: 0 | Exhausted Block: no | Empty WorkList: yes"}], "macros": [], "notes": [], "path": "/usr/include/openssl/asn1.h", "reportHash": "8a6303786477c81aeb99b0c4557498fe", "checkerName": "debug.Stats", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"line": 442, "col": 1, "file": 15}, "message": "sk_ASN1_UTF8STRING_find -> Total CFGBlocks: 3 | Unreachable CFGBlocks: 0 | Exhausted Block: no | Empty WorkList: yes"}], "macros": [], "notes": [], "path": "/usr/include/openssl/asn1.h", "reportHash": "972c7ae9989bce26dbe431f7cb3fcd43", "checkerName": "debug.Stats", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"line": 442, "col": 1, "file": 15}, "message": "sk_ASN1_UTF8STRING_find_ex -> Total CFGBlocks: 3 | Unreachable CFGBlocks: 0 | Exhausted Block: no | Empty WorkList: yes"}], "macros": [], "notes": [], "path": "/usr/include/openssl/asn1.h", "reportHash": "f11a5bb5c346d435786cf0512ec23fbb", "checkerName": "debug.Stats", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"line": 442, "col": 1, "file": 15}, "message": "sk_ASN1_UTF8STRING_sort -> Total CFGBlocks: 3 | Unreachable CFGBlocks: 0 | Exhausted Block: no | Empty WorkList: yes"}], "macros": [], "notes": [], "path": "/usr/include/openssl/asn1.h", "reportHash": "488c4aec1c36252eaab8eeba324b6be9", "checkerName": "debug.Stats", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"line": 442, "col": 1, "file": 15}, "message": "sk_ASN1_UTF8STRING_is_sorted -> Total CFGBlocks: 3 | Unreachable CFGBlocks: 0 | Exhausted Block: no | Empty WorkList: yes"}], "macros": [], "notes": [], "path": "/usr/include/openssl/asn1.h", "reportHash": "688bcc5d5d0da031d0760f6eaebb62f9", "checkerName": "debug.Stats", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"line": 442, "col": 1, "file": 15}, "message": "sk_ASN1_UTF8STRING_dup -> Total CFGBlocks: 3 | Unreachable CFGBlocks: 0 | Exhausted Block: no | Empty WorkList: yes"}], "macros": [], "notes": [], "path": "/usr/include/openssl/asn1.h", "reportHash": "2c6daf518ffdd20f2bad088d49765fc8", "checkerName": "debug.Stats", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"line": 442, "col": 1, "file": 15}, "message": "sk_ASN1_UTF8STRING_deep_copy -> Total CFGBlocks: 3 | Unreachable CFGBlocks: 0 | Exhausted Block: no | Empty WorkList: yes"}], "macros": [], "notes": [], "path": "/usr/include/openssl/asn1.h", "reportHash": "7db1197710e170e1e36c4b4d3c3b17ff", "checkerName": "debug.Stats", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"line": 442, "col": 1, "file": 15}, "message": "sk_ASN1_UTF8STRING_set_cmp_func -> Total CFGBlocks: 3 | Unreachable CFGBlocks: 0 | Exhausted Block: no | Empty WorkList: yes"}], "macros": [], "notes": [], "path": "/usr/include/openssl/asn1.h", "reportHash": "5223ad891b8ee97b8dbd66b4eb69fb27", "checkerName": "debug.Stats", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"line": 475, "col": 1, "file": 15}, "message": "sk_ASN1_TYPE_num -> Total CFGBlocks: 3 | Unreachable CFGBlocks: 0 | Exhausted Block: no | Empty WorkList: yes"}], "macros": [], "notes": [], "path": "/usr/include/openssl/asn1.h", "reportHash": "81ff446edbe2daa9662362c7adf17b14", "checkerName": "debug.Stats", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"line": 475, "col": 1, "file": 15}, "message": "sk_ASN1_TYPE_value -> Total CFGBlocks: 3 | Unreachable CFGBlocks: 0 | Exhausted Block: no | Empty WorkList: yes"}], "macros": [], "notes": [], "path": "/usr/include/openssl/asn1.h", "reportHash": "8be0541736fb795be9e5194894773c0d", "checkerName": "debug.Stats", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"line": 475, "col": 1, "file": 15}, "message": "sk_ASN1_TYPE_new -> Total CFGBlocks: 3 | Unreachable CFGBlocks: 0 | Exhausted Block: no | Empty WorkList: yes"}], "macros": [], "notes": [], "path": "/usr/include/openssl/asn1.h", "reportHash": "1623b3e7a53374817a4b14207dc075ba", "checkerName": "debug.Stats", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"line": 475, "col": 1, "file": 15}, "message": "sk_ASN1_TYPE_new_null -> Total CFGBlocks: 3 | Unreachable CFGBlocks: 0 | Exhausted Block: no | Empty WorkList: yes"}], "macros": [], "notes": [], "path": "/usr/include/openssl/asn1.h", "reportHash": "f6ea576e3b533a90b95b3499ceccebe1", "checkerName": "debug.Stats", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"line": 475, "col": 1, "file": 15}, "message": "sk_ASN1_TYPE_new_reserve -> Total CFGBlocks: 3 | Unreachable CFGBlocks: 0 | Exhausted Block: no | Empty WorkList: yes"}], "macros": [], "notes": [], "path": "/usr/include/openssl/asn1.h", "reportHash": "16b0b788a777fb1fd38aa47f47f14b32", "checkerName": "debug.Stats", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"line": 475, "col": 1, "file": 15}, "message": "sk_ASN1_TYPE_reserve -> Total CFGBlocks: 3 | Unreachable CFGBlocks: 0 | Exhausted Block: no | Empty WorkList: yes"}], "macros": [], "notes": [], "path": "/usr/include/openssl/asn1.h", "reportHash": "7a0e048faae696f89f6a80fde014ae0d", "checkerName": "debug.Stats", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"line": 475, "col": 1, "file": 15}, "message": "sk_ASN1_TYPE_free -> Total CFGBlocks: 3 | Unreachable CFGBlocks: 0 | Exhausted Block: no | Empty WorkList: yes"}], "macros": [], "notes": [], "path": "/usr/include/openssl/asn1.h", "reportHash": "3ee14e28ef9170ec3272b7b7f0c3b741", "checkerName": "debug.Stats", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"line": 475, "col": 1, "file": 15}, "message": "sk_ASN1_TYPE_zero -> Total CFGBlocks: 3 | Unreachable CFGBlocks: 0 | Exhausted Block: no | Empty WorkList: yes"}], "macros": [], "notes": [], "path": "/usr/include/openssl/asn1.h", "reportHash": "c6abdbf8df066c0e6a88c32ad115a72a", "checkerName": "debug.Stats", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"line": 475, "col": 1, "file": 15}, "message": "sk_ASN1_TYPE_delete -> Total CFGBlocks: 3 | Unreachable CFGBlocks: 0 | Exhausted Block: no | Empty WorkList: yes"}], "macros": [], "notes": [], "path": "/usr/include/openssl/asn1.h", "reportHash": "33de8b7e6ebfe2a9febc03cf9ff34301", "checkerName": "debug.Stats", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"line": 475, "col": 1, "file": 15}, "message": "sk_ASN1_TYPE_delete_ptr -> Total CFGBlocks: 3 | Unreachable CFGBlocks: 0 | Exhausted Block: no | Empty WorkList: yes"}], "macros": [], "notes": [], "path": "/usr/include/openssl/asn1.h", "reportHash": "5aba155803ab370c3f91717539296e9e", "checkerName": "debug.Stats", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"line": 475, "col": 1, "file": 15}, "message": "sk_ASN1_TYPE_push -> Total CFGBlocks: 3 | Unreachable CFGBlocks: 0 | Exhausted Block: no | Empty WorkList: yes"}], "macros": [], "notes": [], "path": "/usr/include/openssl/asn1.h", "reportHash": "dafc8aa8d84eeb407b631df4d98d1c41", "checkerName": "debug.Stats", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"line": 475, "col": 1, "file": 15}, "message": "sk_ASN1_TYPE_unshift -> Total CFGBlocks: 3 | Unreachable CFGBlocks: 0 | Exhausted Block: no | Empty WorkList: yes"}], "macros": [], "notes": [], "path": "/usr/include/openssl/asn1.h", "reportHash": "14938ff8567b230a6687d24906b5f033", "checkerName": "debug.Stats", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"line": 475, "col": 1, "file": 15}, "message": "sk_ASN1_TYPE_pop -> Total CFGBlocks: 3 | Unreachable CFGBlocks: 0 | Exhausted Block: no | Empty WorkList: yes"}], "macros": [], "notes": [], "path": "/usr/include/openssl/asn1.h", "reportHash": "7d6c1373cc68657f40a9ae4cb25dff73", "checkerName": "debug.Stats", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"line": 475, "col": 1, "file": 15}, "message": "sk_ASN1_TYPE_shift -> Total CFGBlocks: 3 | Unreachable CFGBlocks: 0 | Exhausted Block: no | Empty WorkList: yes"}], "macros": [], "notes": [], "path": "/usr/include/openssl/asn1.h", "reportHash": "25a7f6a054476121fd25fce4766e075e", "checkerName": "debug.Stats", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"line": 475, "col": 1, "file": 15}, "message": "sk_ASN1_TYPE_pop_free -> Total CFGBlocks: 3 | Unreachable CFGBlocks: 0 | Exhausted Block: no | Empty WorkList: yes"}], "macros": [], "notes": [], "path": "/usr/include/openssl/asn1.h", "reportHash": "1dd06d5071e2cf9201fff620ae304be1", "checkerName": "debug.Stats", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"line": 475, "col": 1, "file": 15}, "message": "sk_ASN1_TYPE_insert -> Total CFGBlocks: 3 | Unreachable CFGBlocks: 0 | Exhausted Block: no | Empty WorkList: yes"}], "macros": [], "notes": [], "path": "/usr/include/openssl/asn1.h", "reportHash": "44ce58401b88bf9902a9ef07589d3753", "checkerName": "debug.Stats", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"line": 475, "col": 1, "file": 15}, "message": "sk_ASN1_TYPE_set -> Total CFGBlocks: 3 | Unreachable CFGBlocks: 0 | Exhausted Block: no | Empty WorkList: yes"}], "macros": [], "notes": [], "path": "/usr/include/openssl/asn1.h", "reportHash": "373a96d804acba09ed3fb8b2a87e4408", "checkerName": "debug.Stats", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"line": 475, "col": 1, "file": 15}, "message": "sk_ASN1_TYPE_find -> Total CFGBlocks: 3 | Unreachable CFGBlocks: 0 | Exhausted Block: no | Empty WorkList: yes"}], "macros": [], "notes": [], "path": "/usr/include/openssl/asn1.h", "reportHash": "5d76ff7ef50592451f30f1a024913e5d", "checkerName": "debug.Stats", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"line": 475, "col": 1, "file": 15}, "message": "sk_ASN1_TYPE_find_ex -> Total CFGBlocks: 3 | Unreachable CFGBlocks: 0 | Exhausted Block: no | Empty WorkList: yes"}], "macros": [], "notes": [], "path": "/usr/include/openssl/asn1.h", "reportHash": "f3c566e5fb1cf2bf05afcb76533bdefe", "checkerName": "debug.Stats", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"line": 475, "col": 1, "file": 15}, "message": "sk_ASN1_TYPE_sort -> Total CFGBlocks: 3 | Unreachable CFGBlocks: 0 | Exhausted Block: no | Empty WorkList: yes"}], "macros": [], "notes": [], "path": "/usr/include/openssl/asn1.h", "reportHash": "2d2f3c91927e9bc2df46d05e5d276fa5", "checkerName": "debug.Stats", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"line": 475, "col": 1, "file": 15}, "message": "sk_ASN1_TYPE_is_sorted -> Total CFGBlocks: 3 | Unreachable CFGBlocks: 0 | Exhausted Block: no | Empty WorkList: yes"}], "macros": [], "notes": [], "path": "/usr/include/openssl/asn1.h", "reportHash": "7bee8cb606cee5e3ba4d44f4daabd5ac", "checkerName": "debug.Stats", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"line": 475, "col": 1, "file": 15}, "message": "sk_ASN1_TYPE_dup -> Total CFGBlocks: 3 | Unreachable CFGBlocks: 0 | Exhausted Block: no | Empty WorkList: yes"}], "macros": [], "notes": [], "path": "/usr/include/openssl/asn1.h", "reportHash": "b68c46c16ad81ea45d9e142d4aa48d29", "checkerName": "debug.Stats", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"line": 475, "col": 1, "file": 15}, "message": "sk_ASN1_TYPE_deep_copy -> Total CFGBlocks: 3 | Unreachable CFGBlocks: 0 | Exhausted Block: no | Empty WorkList: yes"}], "macros": [], "notes": [], "path": "/usr/include/openssl/asn1.h", "reportHash": "60e9a7943f458c68ab9076e25daa8f4d", "checkerName": "debug.Stats", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"line": 475, "col": 1, "file": 15}, "message": "sk_ASN1_TYPE_set_cmp_func -> Total CFGBlocks: 3 | Unreachable CFGBlocks: 0 | Exhausted Block: no | Empty WorkList: yes"}], "macros": [], "notes": [], "path": "/usr/include/openssl/asn1.h", "reportHash": "e559966f553ab353d3688f81c93aa429", "checkerName": "debug.Stats", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"line": 536, "col": 1, "file": 15}, "message": "sk_ASN1_OBJECT_num -> Total CFGBlocks: 3 | Unreachable CFGBlocks: 0 | Exhausted Block: no | Empty WorkList: yes"}], "macros": [], "notes": [], "path": "/usr/include/openssl/asn1.h", "reportHash": "59df547ef5e6b061cc28ccc063402d38", "checkerName": "debug.Stats", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"line": 536, "col": 1, "file": 15}, "message": "sk_ASN1_OBJECT_value -> Total CFGBlocks: 3 | Unreachable CFGBlocks: 0 | Exhausted Block: no | Empty WorkList: yes"}], "macros": [], "notes": [], "path": "/usr/include/openssl/asn1.h", "reportHash": "7dd1155e13eec3db230a304d3265a301", "checkerName": "debug.Stats", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"line": 536, "col": 1, "file": 15}, "message": "sk_ASN1_OBJECT_new -> Total CFGBlocks: 3 | Unreachable CFGBlocks: 0 | Exhausted Block: no | Empty WorkList: yes"}], "macros": [], "notes": [], "path": "/usr/include/openssl/asn1.h", "reportHash": "662ccbe6516b21ac79da4b5594d5ac2b", "checkerName": "debug.Stats", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"line": 536, "col": 1, "file": 15}, "message": "sk_ASN1_OBJECT_new_null -> Total CFGBlocks: 3 | Unreachable CFGBlocks: 0 | Exhausted Block: no | Empty WorkList: yes"}], "macros": [], "notes": [], "path": "/usr/include/openssl/asn1.h", "reportHash": "d77dd0053e557b2d0e856b4f5adee2d8", "checkerName": "debug.Stats", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"line": 536, "col": 1, "file": 15}, "message": "sk_ASN1_OBJECT_new_reserve -> Total CFGBlocks: 3 | Unreachable CFGBlocks: 0 | Exhausted Block: no | Empty WorkList: yes"}], "macros": [], "notes": [], "path": "/usr/include/openssl/asn1.h", "reportHash": "aa8cf4b1799a6cd23603bdbe5deb06eb", "checkerName": "debug.Stats", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"line": 536, "col": 1, "file": 15}, "message": "sk_ASN1_OBJECT_reserve -> Total CFGBlocks: 3 | Unreachable CFGBlocks: 0 | Exhausted Block: no | Empty WorkList: yes"}], "macros": [], "notes": [], "path": "/usr/include/openssl/asn1.h", "reportHash": "be276a23caf1818499653889da67a089", "checkerName": "debug.Stats", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"line": 536, "col": 1, "file": 15}, "message": "sk_ASN1_OBJECT_free -> Total CFGBlocks: 3 | Unreachable CFGBlocks: 0 | Exhausted Block: no | Empty WorkList: yes"}], "macros": [], "notes": [], "path": "/usr/include/openssl/asn1.h", "reportHash": "39657c6383b1caa2e065171e1a079c67", "checkerName": "debug.Stats", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"line": 536, "col": 1, "file": 15}, "message": "sk_ASN1_OBJECT_zero -> Total CFGBlocks: 3 | Unreachable CFGBlocks: 0 | Exhausted Block: no | Empty WorkList: yes"}], "macros": [], "notes": [], "path": "/usr/include/openssl/asn1.h", "reportHash": "aed8740e1eb14d389c89e50cb785cad4", "checkerName": "debug.Stats", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"line": 536, "col": 1, "file": 15}, "message": "sk_ASN1_OBJECT_delete -> Total CFGBlocks: 3 | Unreachable CFGBlocks: 0 | Exhausted Block: no | Empty WorkList: yes"}], "macros": [], "notes": [], "path": "/usr/include/openssl/asn1.h", "reportHash": "15fff7f5c7808b26c25d248dea27dc54", "checkerName": "debug.Stats", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"line": 536, "col": 1, "file": 15}, "message": "sk_ASN1_OBJECT_delete_ptr -> Total CFGBlocks: 3 | Unreachable CFGBlocks: 0 | Exhausted Block: no | Empty WorkList: yes"}], "macros": [], "notes": [], "path": "/usr/include/openssl/asn1.h", "reportHash": "c04b5fb4ccce7a71e6ef736a517411b2", "checkerName": "debug.Stats", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"line": 536, "col": 1, "file": 15}, "message": "sk_ASN1_OBJECT_push -> Total CFGBlocks: 3 | Unreachable CFGBlocks: 0 | Exhausted Block: no | Empty WorkList: yes"}], "macros": [], "notes": [], "path": "/usr/include/openssl/asn1.h", "reportHash": "00a2c61ea9fff9081aa8aeea182f3c77", "checkerName": "debug.Stats", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"line": 536, "col": 1, "file": 15}, "message": "sk_ASN1_OBJECT_unshift -> Total CFGBlocks: 3 | Unreachable CFGBlocks: 0 | Exhausted Block: no | Empty WorkList: yes"}], "macros": [], "notes": [], "path": "/usr/include/openssl/asn1.h", "reportHash": "fadfb1d22849b68415f87e3778d28e8d", "checkerName": "debug.Stats", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"line": 536, "col": 1, "file": 15}, "message": "sk_ASN1_OBJECT_pop -> Total CFGBlocks: 3 | Unreachable CFGBlocks: 0 | Exhausted Block: no | Empty WorkList: yes"}], "macros": [], "notes": [], "path": "/usr/include/openssl/asn1.h", "reportHash": "ae31a37ba30b3ff716f0389d581b08eb", "checkerName": "debug.Stats", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"line": 536, "col": 1, "file": 15}, "message": "sk_ASN1_OBJECT_shift -> Total CFGBlocks: 3 | Unreachable CFGBlocks: 0 | Exhausted Block: no | Empty WorkList: yes"}], "macros": [], "notes": [], "path": "/usr/include/openssl/asn1.h", "reportHash": "0dd6d667a96b1875d85efb7cf95a33af", "checkerName": "debug.Stats", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"line": 536, "col": 1, "file": 15}, "message": "sk_ASN1_OBJECT_pop_free -> Total CFGBlocks: 3 | Unreachable CFGBlocks: 0 | Exhausted Block: no | Empty WorkList: yes"}], "macros": [], "notes": [], "path": "/usr/include/openssl/asn1.h", "reportHash": "b09e672c81ecda2a07596bcc854933c6", "checkerName": "debug.Stats", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"line": 536, "col": 1, "file": 15}, "message": "sk_ASN1_OBJECT_insert -> Total CFGBlocks: 3 | Unreachable CFGBlocks: 0 | Exhausted Block: no | Empty WorkList: yes"}], "macros": [], "notes": [], "path": "/usr/include/openssl/asn1.h", "reportHash": "a1f3ae1774d202496f56bd56cc017e21", "checkerName": "debug.Stats", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"line": 536, "col": 1, "file": 15}, "message": "sk_ASN1_OBJECT_set -> Total CFGBlocks: 3 | Unreachable CFGBlocks: 0 | Exhausted Block: no | Empty WorkList: yes"}], "macros": [], "notes": [], "path": "/usr/include/openssl/asn1.h", "reportHash": "ae22d0737e8d01bdf2ea96488d93024a", "checkerName": "debug.Stats", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"line": 536, "col": 1, "file": 15}, "message": "sk_ASN1_OBJECT_find -> Total CFGBlocks: 3 | Unreachable CFGBlocks: 0 | Exhausted Block: no | Empty WorkList: yes"}], "macros": [], "notes": [], "path": "/usr/include/openssl/asn1.h", "reportHash": "cc062480726bc7105993526d50529a5a", "checkerName": "debug.Stats", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"line": 536, "col": 1, "file": 15}, "message": "sk_ASN1_OBJECT_find_ex -> Total CFGBlocks: 3 | Unreachable CFGBlocks: 0 | Exhausted Block: no | Empty WorkList: yes"}], "macros": [], "notes": [], "path": "/usr/include/openssl/asn1.h", "reportHash": "b79b6ca10c2c89e7cd0a117470f12692", "checkerName": "debug.Stats", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"line": 536, "col": 1, "file": 15}, "message": "sk_ASN1_OBJECT_sort -> Total CFGBlocks: 3 | Unreachable CFGBlocks: 0 | Exhausted Block: no | Empty WorkList: yes"}], "macros": [], "notes": [], "path": "/usr/include/openssl/asn1.h", "reportHash": "d68248f76de62534714fe0b1bc2b60b9", "checkerName": "debug.Stats", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"line": 536, "col": 1, "file": 15}, "message": "sk_ASN1_OBJECT_is_sorted -> Total CFGBlocks: 3 | Unreachable CFGBlocks: 0 | Exhausted Block: no | Empty WorkList: yes"}], "macros": [], "notes": [], "path": "/usr/include/openssl/asn1.h", "reportHash": "55e51641b6ca8c7b0f6d7e755a4fb411", "checkerName": "debug.Stats", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"line": 536, "col": 1, "file": 15}, "message": "sk_ASN1_OBJECT_dup -> Total CFGBlocks: 3 | Unreachable CFGBlocks: 0 | Exhausted Block: no | Empty WorkList: yes"}], "macros": [], "notes": [], "path": "/usr/include/openssl/asn1.h", "reportHash": "bed5e00ab725422698ffa088cd661bab", "checkerName": "debug.Stats", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"line": 536, "col": 1, "file": 15}, "message": "sk_ASN1_OBJECT_deep_copy -> Total CFGBlocks: 3 | Unreachable CFGBlocks: 0 | Exhausted Block: no | Empty WorkList: yes"}], "macros": [], "notes": [], "path": "/usr/include/openssl/asn1.h", "reportHash": "7007ba74918b65ee07b8779b2cc010ff", "checkerName": "debug.Stats", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"line": 536, "col": 1, "file": 15}, "message": "sk_ASN1_OBJECT_set_cmp_func -> Total CFGBlocks: 3 | Unreachable CFGBlocks: 0 | Exhausted Block: no | Empty WorkList: yes"}], "macros": [], "notes": [], "path": "/usr/include/openssl/asn1.h", "reportHash": "f039ae1e9678bb1ff7659680da8fc5fa", "checkerName": "debug.Stats", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"line": 75, "col": 1, "file": 16}, "message": "sk_X509_NAME_ENTRY_num -> Total CFGBlocks: 3 | Unreachable CFGBlocks: 0 | Exhausted Block: no | Empty WorkList: yes"}], "macros": [], "notes": [], "path": "/usr/include/openssl/x509.h", "reportHash": "f5a825c2eab5cc302906b1db045c2fdc", "checkerName": "debug.Stats", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"line": 75, "col": 1, "file": 16}, "message": "sk_X509_NAME_ENTRY_value -> Total CFGBlocks: 3 | Unreachable CFGBlocks: 0 | Exhausted Block: no | Empty WorkList: yes"}], "macros": [], "notes": [], "path": "/usr/include/openssl/x509.h", "reportHash": "42d72304bdddd96a23b20f38283b817f", "checkerName": "debug.Stats", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"line": 75, "col": 1, "file": 16}, "message": "sk_X509_NAME_ENTRY_new -> Total CFGBlocks: 3 | Unreachable CFGBlocks: 0 | Exhausted Block: no | Empty WorkList: yes"}], "macros": [], "notes": [], "path": "/usr/include/openssl/x509.h", "reportHash": "b9beab8485f60143e567bbe69e7924b2", "checkerName": "debug.Stats", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"line": 75, "col": 1, "file": 16}, "message": "sk_X509_NAME_ENTRY_new_null -> Total CFGBlocks: 3 | Unreachable CFGBlocks: 0 | Exhausted Block: no | Empty WorkList: yes"}], "macros": [], "notes": [], "path": "/usr/include/openssl/x509.h", "reportHash": "b3309916814b17be4d3a546f5d244fc0", "checkerName": "debug.Stats", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"line": 75, "col": 1, "file": 16}, "message": "sk_X509_NAME_ENTRY_new_reserve -> Total CFGBlocks: 3 | Unreachable CFGBlocks: 0 | Exhausted Block: no | Empty WorkList: yes"}], "macros": [], "notes": [], "path": "/usr/include/openssl/x509.h", "reportHash": "d17b98db2fc03519718cee8a9b573891", "checkerName": "debug.Stats", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"line": 75, "col": 1, "file": 16}, "message": "sk_X509_NAME_ENTRY_reserve -> Total CFGBlocks: 3 | Unreachable CFGBlocks: 0 | Exhausted Block: no | Empty WorkList: yes"}], "macros": [], "notes": [], "path": "/usr/include/openssl/x509.h", "reportHash": "6c45cf3492686d4bc6c9002d114760c2", "checkerName": "debug.Stats", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"line": 75, "col": 1, "file": 16}, "message": "sk_X509_NAME_ENTRY_free -> Total CFGBlocks: 3 | Unreachable CFGBlocks: 0 | Exhausted Block: no | Empty WorkList: yes"}], "macros": [], "notes": [], "path": "/usr/include/openssl/x509.h", "reportHash": "bbcbf384e2601c986dee69d28ff0f4ad", "checkerName": "debug.Stats", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"line": 75, "col": 1, "file": 16}, "message": "sk_X509_NAME_ENTRY_zero -> Total CFGBlocks: 3 | Unreachable CFGBlocks: 0 | Exhausted Block: no | Empty WorkList: yes"}], "macros": [], "notes": [], "path": "/usr/include/openssl/x509.h", "reportHash": "03f4367b8a561db23acee914aaad2f3f", "checkerName": "debug.Stats", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"line": 75, "col": 1, "file": 16}, "message": "sk_X509_NAME_ENTRY_delete -> Total CFGBlocks: 3 | Unreachable CFGBlocks: 0 | Exhausted Block: no | Empty WorkList: yes"}], "macros": [], "notes": [], "path": "/usr/include/openssl/x509.h", "reportHash": "673b98f8e36fec749d833600304c6d9d", "checkerName": "debug.Stats", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"line": 75, "col": 1, "file": 16}, "message": "sk_X509_NAME_ENTRY_delete_ptr -> Total CFGBlocks: 3 | Unreachable CFGBlocks: 0 | Exhausted Block: no | Empty WorkList: yes"}], "macros": [], "notes": [], "path": "/usr/include/openssl/x509.h", "reportHash": "1a9e998fad402a6ba453a38384f2cdb6", "checkerName": "debug.Stats", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"line": 75, "col": 1, "file": 16}, "message": "sk_X509_NAME_ENTRY_push -> Total CFGBlocks: 3 | Unreachable CFGBlocks: 0 | Exhausted Block: no | Empty WorkList: yes"}], "macros": [], "notes": [], "path": "/usr/include/openssl/x509.h", "reportHash": "dec59c6865f889457215758ce50431b6", "checkerName": "debug.Stats", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"line": 75, "col": 1, "file": 16}, "message": "sk_X509_NAME_ENTRY_unshift -> Total CFGBlocks: 3 | Unreachable CFGBlocks: 0 | Exhausted Block: no | Empty WorkList: yes"}], "macros": [], "notes": [], "path": "/usr/include/openssl/x509.h", "reportHash": "bc7f9ef3d59f2fad4e9646b8f808a80b", "checkerName": "debug.Stats", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"line": 75, "col": 1, "file": 16}, "message": "sk_X509_NAME_ENTRY_pop -> Total CFGBlocks: 3 | Unreachable CFGBlocks: 0 | Exhausted Block: no | Empty WorkList: yes"}], "macros": [], "notes": [], "path": "/usr/include/openssl/x509.h", "reportHash": "c204dcbb2741f7f886109fba5f1b3871", "checkerName": "debug.Stats", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"line": 75, "col": 1, "file": 16}, "message": "sk_X509_NAME_ENTRY_shift -> Total CFGBlocks: 3 | Unreachable CFGBlocks: 0 | Exhausted Block: no | Empty WorkList: yes"}], "macros": [], "notes": [], "path": "/usr/include/openssl/x509.h", "reportHash": "57d836d5dc715f4b9d0f23e949620e82", "checkerName": "debug.Stats", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"line": 75, "col": 1, "file": 16}, "message": "sk_X509_NAME_ENTRY_pop_free -> Total CFGBlocks: 3 | Unreachable CFGBlocks: 0 | Exhausted Block: no | Empty WorkList: yes"}], "macros": [], "notes": [], "path": "/usr/include/openssl/x509.h", "reportHash": "e839d76bb14a7a0f3737a5d17c7e7ca9", "checkerName": "debug.Stats", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"line": 75, "col": 1, "file": 16}, "message": "sk_X509_NAME_ENTRY_insert -> Total CFGBlocks: 3 | Unreachable CFGBlocks: 0 | Exhausted Block: no | Empty WorkList: yes"}], "macros": [], "notes": [], "path": "/usr/include/openssl/x509.h", "reportHash": "dbe56ee353694570d53e40f24623c82b", "checkerName": "debug.Stats", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"line": 75, "col": 1, "file": 16}, "message": "sk_X509_NAME_ENTRY_set -> Total CFGBlocks: 3 | Unreachable CFGBlocks: 0 | Exhausted Block: no | Empty WorkList: yes"}], "macros": [], "notes": [], "path": "/usr/include/openssl/x509.h", "reportHash": "8b7c1a283016edcd9215019f207e10d5", "checkerName": "debug.Stats", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"line": 75, "col": 1, "file": 16}, "message": "sk_X509_NAME_ENTRY_find -> Total CFGBlocks: 3 | Unreachable CFGBlocks: 0 | Exhausted Block: no | Empty WorkList: yes"}], "macros": [], "notes": [], "path": "/usr/include/openssl/x509.h", "reportHash": "dc08930a919d093c2c8b8751ec0df165", "checkerName": "debug.Stats", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"line": 75, "col": 1, "file": 16}, "message": "sk_X509_NAME_ENTRY_find_ex -> Total CFGBlocks: 3 | Unreachable CFGBlocks: 0 | Exhausted Block: no | Empty WorkList: yes"}], "macros": [], "notes": [], "path": "/usr/include/openssl/x509.h", "reportHash": "917a8291c1a38baadaadac3b63c4775d", "checkerName": "debug.Stats", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"line": 75, "col": 1, "file": 16}, "message": "sk_X509_NAME_ENTRY_sort -> Total CFGBlocks: 3 | Unreachable CFGBlocks: 0 | Exhausted Block: no | Empty WorkList: yes"}], "macros": [], "notes": [], "path": "/usr/include/openssl/x509.h", "reportHash": "1969b7441338d4e19fab26be72b48c0b", "checkerName": "debug.Stats", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"line": 75, "col": 1, "file": 16}, "message": "sk_X509_NAME_ENTRY_is_sorted -> Total CFGBlocks: 3 | Unreachable CFGBlocks: 0 | Exhausted Block: no | Empty WorkList: yes"}], "macros": [], "notes": [], "path": "/usr/include/openssl/x509.h", "reportHash": "425993dc3cbcdaa3b892a970e830c998", "checkerName": "debug.Stats", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"line": 75, "col": 1, "file": 16}, "message": "sk_X509_NAME_ENTRY_dup -> Total CFGBlocks: 3 | Unreachable CFGBlocks: 0 | Exhausted Block: no | Empty WorkList: yes"}], "macros": [], "notes": [], "path": "/usr/include/openssl/x509.h", "reportHash": "d3170cb0dec72b1a3e9b8fe7f2653490", "checkerName": "debug.Stats", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"line": 75, "col": 1, "file": 16}, "message": "sk_X509_NAME_ENTRY_deep_copy -> Total CFGBlocks: 3 | Unreachable CFGBlocks: 0 | Exhausted Block: no | Empty WorkList: yes"}], "macros": [], "notes": [], "path": "/usr/include/openssl/x509.h", "reportHash": "72d409eea517160894bc8da839b5f2db", "checkerName": "debug.Stats", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"line": 75, "col": 1, "file": 16}, "message": "sk_X509_NAME_ENTRY_set_cmp_func -> Total CFGBlocks: 3 | Unreachable CFGBlocks: 0 | Exhausted Block: no | Empty WorkList: yes"}], "macros": [], "notes": [], "path": "/usr/include/openssl/x509.h", "reportHash": "22631ed1fc2d4fdf6345403f8a7448cd", "checkerName": "debug.Stats", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"line": 77, "col": 1, "file": 16}, "message": "sk_X509_NAME_num -> Total CFGBlocks: 3 | Unreachable CFGBlocks: 0 | Exhausted Block: no | Empty WorkList: yes"}], "macros": [], "notes": [], "path": "/usr/include/openssl/x509.h", "reportHash": "0fbfd1f9674b705f4f2a5dfd9c2208e5", "checkerName": "debug.Stats", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"line": 77, "col": 1, "file": 16}, "message": "sk_X509_NAME_value -> Total CFGBlocks: 3 | Unreachable CFGBlocks: 0 | Exhausted Block: no | Empty WorkList: yes"}], "macros": [], "notes": [], "path": "/usr/include/openssl/x509.h", "reportHash": "6f48ebb2429e2873a49498b5a0bc7a64", "checkerName": "debug.Stats", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"line": 77, "col": 1, "file": 16}, "message": "sk_X509_NAME_new -> Total CFGBlocks: 3 | Unreachable CFGBlocks: 0 | Exhausted Block: no | Empty WorkList: yes"}], "macros": [], "notes": [], "path": "/usr/include/openssl/x509.h", "reportHash": "78ed784763b58752c6d9b82b4c0b92ec", "checkerName": "debug.Stats", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"line": 77, "col": 1, "file": 16}, "message": "sk_X509_NAME_new_null -> Total CFGBlocks: 3 | Unreachable CFGBlocks: 0 | Exhausted Block: no | Empty WorkList: yes"}], "macros": [], "notes": [], "path": "/usr/include/openssl/x509.h", "reportHash": "3bf7c77c770d3dc52268822d5d64a46d", "checkerName": "debug.Stats", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"line": 77, "col": 1, "file": 16}, "message": "sk_X509_NAME_new_reserve -> Total CFGBlocks: 3 | Unreachable CFGBlocks: 0 | Exhausted Block: no | Empty WorkList: yes"}], "macros": [], "notes": [], "path": "/usr/include/openssl/x509.h", "reportHash": "2a9d73ca27defa8b4f110ce1dbafa8fe", "checkerName": "debug.Stats", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"line": 77, "col": 1, "file": 16}, "message": "sk_X509_NAME_reserve -> Total CFGBlocks: 3 | Unreachable CFGBlocks: 0 | Exhausted Block: no | Empty WorkList: yes"}], "macros": [], "notes": [], "path": "/usr/include/openssl/x509.h", "reportHash": "135f87fc48e999f59faf5145e638b35b", "checkerName": "debug.Stats", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"line": 77, "col": 1, "file": 16}, "message": "sk_X509_NAME_free -> Total CFGBlocks: 3 | Unreachable CFGBlocks: 0 | Exhausted Block: no | Empty WorkList: yes"}], "macros": [], "notes": [], "path": "/usr/include/openssl/x509.h", "reportHash": "7927a133bfc591c82e86ba0eaab8abe5", "checkerName": "debug.Stats", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"line": 77, "col": 1, "file": 16}, "message": "sk_X509_NAME_zero -> Total CFGBlocks: 3 | Unreachable CFGBlocks: 0 | Exhausted Block: no | Empty WorkList: yes"}], "macros": [], "notes": [], "path": "/usr/include/openssl/x509.h", "reportHash": "f35c51cf45db3ae2f3f052ccd9c254ca", "checkerName": "debug.Stats", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"line": 77, "col": 1, "file": 16}, "message": "sk_X509_NAME_delete -> Total CFGBlocks: 3 | Unreachable CFGBlocks: 0 | Exhausted Block: no | Empty WorkList: yes"}], "macros": [], "notes": [], "path": "/usr/include/openssl/x509.h", "reportHash": "c23d47648f096c545f6e12614475fbf0", "checkerName": "debug.Stats", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"line": 77, "col": 1, "file": 16}, "message": "sk_X509_NAME_delete_ptr -> Total CFGBlocks: 3 | Unreachable CFGBlocks: 0 | Exhausted Block: no | Empty WorkList: yes"}], "macros": [], "notes": [], "path": "/usr/include/openssl/x509.h", "reportHash": "19ca4be1c3a384717dd5a3586da2b705", "checkerName": "debug.Stats", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"line": 77, "col": 1, "file": 16}, "message": "sk_X509_NAME_push -> Total CFGBlocks: 3 | Unreachable CFGBlocks: 0 | Exhausted Block: no | Empty WorkList: yes"}], "macros": [], "notes": [], "path": "/usr/include/openssl/x509.h", "reportHash": "1acd37088bf2628d5c5b7e25e6356c0e", "checkerName": "debug.Stats", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"line": 77, "col": 1, "file": 16}, "message": "sk_X509_NAME_unshift -> Total CFGBlocks: 3 | Unreachable CFGBlocks: 0 | Exhausted Block: no | Empty WorkList: yes"}], "macros": [], "notes": [], "path": "/usr/include/openssl/x509.h", "reportHash": "ce2e3243012af6565a6accd8a5318c82", "checkerName": "debug.Stats", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"line": 77, "col": 1, "file": 16}, "message": "sk_X509_NAME_pop -> Total CFGBlocks: 3 | Unreachable CFGBlocks: 0 | Exhausted Block: no | Empty WorkList: yes"}], "macros": [], "notes": [], "path": "/usr/include/openssl/x509.h", "reportHash": "3b08b95fb0699b0c533d7643cbb98d16", "checkerName": "debug.Stats", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"line": 77, "col": 1, "file": 16}, "message": "sk_X509_NAME_shift -> Total CFGBlocks: 3 | Unreachable CFGBlocks: 0 | Exhausted Block: no | Empty WorkList: yes"}], "macros": [], "notes": [], "path": "/usr/include/openssl/x509.h", "reportHash": "2560f1ef4b6e45d1cf80d844fd48daba", "checkerName": "debug.Stats", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"line": 77, "col": 1, "file": 16}, "message": "sk_X509_NAME_pop_free -> Total CFGBlocks: 3 | Unreachable CFGBlocks: 0 | Exhausted Block: no | Empty WorkList: yes"}], "macros": [], "notes": [], "path": "/usr/include/openssl/x509.h", "reportHash": "0d6ccd4a3b7cbea25b14a3298fd3d413", "checkerName": "debug.Stats", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"line": 77, "col": 1, "file": 16}, "message": "sk_X509_NAME_insert -> Total CFGBlocks: 3 | Unreachable CFGBlocks: 0 | Exhausted Block: no | Empty WorkList: yes"}], "macros": [], "notes": [], "path": "/usr/include/openssl/x509.h", "reportHash": "5dce0bdf78f333753f15eaa23a31387e", "checkerName": "debug.Stats", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"line": 77, "col": 1, "file": 16}, "message": "sk_X509_NAME_set -> Total CFGBlocks: 3 | Unreachable CFGBlocks: 0 | Exhausted Block: no | Empty WorkList: yes"}], "macros": [], "notes": [], "path": "/usr/include/openssl/x509.h", "reportHash": "86d222a0cc1eb74096b405f0fd5eb9ab", "checkerName": "debug.Stats", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"line": 77, "col": 1, "file": 16}, "message": "sk_X509_NAME_find -> Total CFGBlocks: 3 | Unreachable CFGBlocks: 0 | Exhausted Block: no | Empty WorkList: yes"}], "macros": [], "notes": [], "path": "/usr/include/openssl/x509.h", "reportHash": "75ac76798de58641e9723a76f3b95ee0", "checkerName": "debug.Stats", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"line": 77, "col": 1, "file": 16}, "message": "sk_X509_NAME_find_ex -> Total CFGBlocks: 3 | Unreachable CFGBlocks: 0 | Exhausted Block: no | Empty WorkList: yes"}], "macros": [], "notes": [], "path": "/usr/include/openssl/x509.h", "reportHash": "2c9c52ca436aebe86ddafd9ea1d1f3f1", "checkerName": "debug.Stats", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"line": 77, "col": 1, "file": 16}, "message": "sk_X509_NAME_sort -> Total CFGBlocks: 3 | Unreachable CFGBlocks: 0 | Exhausted Block: no | Empty WorkList: yes"}], "macros": [], "notes": [], "path": "/usr/include/openssl/x509.h", "reportHash": "9fdfd63a19b2ec7b24435a167a33eeec", "checkerName": "debug.Stats", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"line": 77, "col": 1, "file": 16}, "message": "sk_X509_NAME_is_sorted -> Total CFGBlocks: 3 | Unreachable CFGBlocks: 0 | Exhausted Block: no | Empty WorkList: yes"}], "macros": [], "notes": [], "path": "/usr/include/openssl/x509.h", "reportHash": "9669a017c2c7f9e6ba76f39d82239452", "checkerName": "debug.Stats", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"line": 77, "col": 1, "file": 16}, "message": "sk_X509_NAME_dup -> Total CFGBlocks: 3 | Unreachable CFGBlocks: 0 | Exhausted Block: no | Empty WorkList: yes"}], "macros": [], "notes": [], "path": "/usr/include/openssl/x509.h", "reportHash": "08575eabfd60e1a3550a08d02bf98baa", "checkerName": "debug.Stats", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"line": 77, "col": 1, "file": 16}, "message": "sk_X509_NAME_deep_copy -> Total CFGBlocks: 3 | Unreachable CFGBlocks: 0 | Exhausted Block: no | Empty WorkList: yes"}], "macros": [], "notes": [], "path": "/usr/include/openssl/x509.h", "reportHash": "6c2f34e877e06168419fc3293ad7eba6", "checkerName": "debug.Stats", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"line": 77, "col": 1, "file": 16}, "message": "sk_X509_NAME_set_cmp_func -> Total CFGBlocks: 3 | Unreachable CFGBlocks: 0 | Exhausted Block: no | Empty WorkList: yes"}], "macros": [], "notes": [], "path": "/usr/include/openssl/x509.h", "reportHash": "2f2722d77e2fe2517fa4ef085c0647ba", "checkerName": "debug.Stats", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"line": 85, "col": 1, "file": 16}, "message": "sk_X509_EXTENSION_num -> Total CFGBlocks: 3 | Unreachable CFGBlocks: 0 | Exhausted Block: no | Empty WorkList: yes"}], "macros": [], "notes": [], "path": "/usr/include/openssl/x509.h", "reportHash": "80b0f184e47056949797f91eb76d112e", "checkerName": "debug.Stats", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"line": 85, "col": 1, "file": 16}, "message": "sk_X509_EXTENSION_value -> Total CFGBlocks: 3 | Unreachable CFGBlocks: 0 | Exhausted Block: no | Empty WorkList: yes"}], "macros": [], "notes": [], "path": "/usr/include/openssl/x509.h", "reportHash": "657f170cd213cecc208ae4008c4c0d91", "checkerName": "debug.Stats", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"line": 85, "col": 1, "file": 16}, "message": "sk_X509_EXTENSION_new -> Total CFGBlocks: 3 | Unreachable CFGBlocks: 0 | Exhausted Block: no | Empty WorkList: yes"}], "macros": [], "notes": [], "path": "/usr/include/openssl/x509.h", "reportHash": "3a648b72525b2d2881bef88495ef9241", "checkerName": "debug.Stats", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"line": 85, "col": 1, "file": 16}, "message": "sk_X509_EXTENSION_new_null -> Total CFGBlocks: 3 | Unreachable CFGBlocks: 0 | Exhausted Block: no | Empty WorkList: yes"}], "macros": [], "notes": [], "path": "/usr/include/openssl/x509.h", "reportHash": "b6cc0975eda33213a6284bf74bab8232", "checkerName": "debug.Stats", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"line": 85, "col": 1, "file": 16}, "message": "sk_X509_EXTENSION_new_reserve -> Total CFGBlocks: 3 | Unreachable CFGBlocks: 0 | Exhausted Block: no | Empty WorkList: yes"}], "macros": [], "notes": [], "path": "/usr/include/openssl/x509.h", "reportHash": "df4c6c6b3283272172b0776b3c676154", "checkerName": "debug.Stats", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"line": 85, "col": 1, "file": 16}, "message": "sk_X509_EXTENSION_reserve -> Total CFGBlocks: 3 | Unreachable CFGBlocks: 0 | Exhausted Block: no | Empty WorkList: yes"}], "macros": [], "notes": [], "path": "/usr/include/openssl/x509.h", "reportHash": "e9b37089e75ea6411623957410fd59bc", "checkerName": "debug.Stats", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"line": 85, "col": 1, "file": 16}, "message": "sk_X509_EXTENSION_free -> Total CFGBlocks: 3 | Unreachable CFGBlocks: 0 | Exhausted Block: no | Empty WorkList: yes"}], "macros": [], "notes": [], "path": "/usr/include/openssl/x509.h", "reportHash": "203b7e6ee38a509622c11a73cabb5fde", "checkerName": "debug.Stats", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"line": 85, "col": 1, "file": 16}, "message": "sk_X509_EXTENSION_zero -> Total CFGBlocks: 3 | Unreachable CFGBlocks: 0 | Exhausted Block: no | Empty WorkList: yes"}], "macros": [], "notes": [], "path": "/usr/include/openssl/x509.h", "reportHash": "3b9269fa7f5cb4e88b7b8b4b9824c7f2", "checkerName": "debug.Stats", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"line": 85, "col": 1, "file": 16}, "message": "sk_X509_EXTENSION_delete -> Total CFGBlocks: 3 | Unreachable CFGBlocks: 0 | Exhausted Block: no | Empty WorkList: yes"}], "macros": [], "notes": [], "path": "/usr/include/openssl/x509.h", "reportHash": "2c24648fce9a038a3e15d93aaa7c310b", "checkerName": "debug.Stats", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"line": 85, "col": 1, "file": 16}, "message": "sk_X509_EXTENSION_delete_ptr -> Total CFGBlocks: 3 | Unreachable CFGBlocks: 0 | Exhausted Block: no | Empty WorkList: yes"}], "macros": [], "notes": [], "path": "/usr/include/openssl/x509.h", "reportHash": "1fcd0cc761e3439fd1cc8f600c7c5111", "checkerName": "debug.Stats", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"line": 85, "col": 1, "file": 16}, "message": "sk_X509_EXTENSION_push -> Total CFGBlocks: 3 | Unreachable CFGBlocks: 0 | Exhausted Block: no | Empty WorkList: yes"}], "macros": [], "notes": [], "path": "/usr/include/openssl/x509.h", "reportHash": "f00ef18b9a95290534215c83fb677496", "checkerName": "debug.Stats", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"line": 85, "col": 1, "file": 16}, "message": "sk_X509_EXTENSION_unshift -> Total CFGBlocks: 3 | Unreachable CFGBlocks: 0 | Exhausted Block: no | Empty WorkList: yes"}], "macros": [], "notes": [], "path": "/usr/include/openssl/x509.h", "reportHash": "6ae72f09cfd5abfb344dd94fd67748c9", "checkerName": "debug.Stats", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"line": 85, "col": 1, "file": 16}, "message": "sk_X509_EXTENSION_pop -> Total CFGBlocks: 3 | Unreachable CFGBlocks: 0 | Exhausted Block: no | Empty WorkList: yes"}], "macros": [], "notes": [], "path": "/usr/include/openssl/x509.h", "reportHash": "a38b36eb2554d1a3278042418e3f10d2", "checkerName": "debug.Stats", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"line": 85, "col": 1, "file": 16}, "message": "sk_X509_EXTENSION_shift -> Total CFGBlocks: 3 | Unreachable CFGBlocks: 0 | Exhausted Block: no | Empty WorkList: yes"}], "macros": [], "notes": [], "path": "/usr/include/openssl/x509.h", "reportHash": "c599fd97a1470cb371674cc514c0102f", "checkerName": "debug.Stats", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"line": 85, "col": 1, "file": 16}, "message": "sk_X509_EXTENSION_pop_free -> Total CFGBlocks: 3 | Unreachable CFGBlocks: 0 | Exhausted Block: no | Empty WorkList: yes"}], "macros": [], "notes": [], "path": "/usr/include/openssl/x509.h", "reportHash": "562153f33ebe6ace07629aebebfdd652", "checkerName": "debug.Stats", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"line": 85, "col": 1, "file": 16}, "message": "sk_X509_EXTENSION_insert -> Total CFGBlocks: 3 | Unreachable CFGBlocks: 0 | Exhausted Block: no | Empty WorkList: yes"}], "macros": [], "notes": [], "path": "/usr/include/openssl/x509.h", "reportHash": "1a2c7ffca74dc3d5aaca49b4f8e2c275", "checkerName": "debug.Stats", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"line": 85, "col": 1, "file": 16}, "message": "sk_X509_EXTENSION_set -> Total CFGBlocks: 3 | Unreachable CFGBlocks: 0 | Exhausted Block: no | Empty WorkList: yes"}], "macros": [], "notes": [], "path": "/usr/include/openssl/x509.h", "reportHash": "a3891da982023870e65177001f85c82d", "checkerName": "debug.Stats", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"line": 85, "col": 1, "file": 16}, "message": "sk_X509_EXTENSION_find -> Total CFGBlocks: 3 | Unreachable CFGBlocks: 0 | Exhausted Block: no | Empty WorkList: yes"}], "macros": [], "notes": [], "path": "/usr/include/openssl/x509.h", "reportHash": "ec37685fafe1d22975939d8fe53615f2", "checkerName": "debug.Stats", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"line": 85, "col": 1, "file": 16}, "message": "sk_X509_EXTENSION_find_ex -> Total CFGBlocks: 3 | Unreachable CFGBlocks: 0 | Exhausted Block: no | Empty WorkList: yes"}], "macros": [], "notes": [], "path": "/usr/include/openssl/x509.h", "reportHash": "f49355452c6387e55af370d1a84bfeed", "checkerName": "debug.Stats", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"line": 85, "col": 1, "file": 16}, "message": "sk_X509_EXTENSION_sort -> Total CFGBlocks: 3 | Unreachable CFGBlocks: 0 | Exhausted Block: no | Empty WorkList: yes"}], "macros": [], "notes": [], "path": "/usr/include/openssl/x509.h", "reportHash": "66e3d6f3cdc055523f0440abbe07ca11", "checkerName": "debug.Stats", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"line": 85, "col": 1, "file": 16}, "message": "sk_X509_EXTENSION_is_sorted -> Total CFGBlocks: 3 | Unreachable CFGBlocks: 0 | Exhausted Block: no | Empty WorkList: yes"}], "macros": [], "notes": [], "path": "/usr/include/openssl/x509.h", "reportHash": "654baee5f932d780e9c5be985001b4cb", "checkerName": "debug.Stats", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"line": 85, "col": 1, "file": 16}, "message": "sk_X509_EXTENSION_dup -> Total CFGBlocks: 3 | Unreachable CFGBlocks: 0 | Exhausted Block: no | Empty WorkList: yes"}], "macros": [], "notes": [], "path": "/usr/include/openssl/x509.h", "reportHash": "a4e34002c168f7e99210c681aa836e3d", "checkerName": "debug.Stats", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"line": 85, "col": 1, "file": 16}, "message": "sk_X509_EXTENSION_deep_copy -> Total CFGBlocks: 3 | Unreachable CFGBlocks: 0 | Exhausted Block: no | Empty WorkList: yes"}], "macros": [], "notes": [], "path": "/usr/include/openssl/x509.h", "reportHash": "6c091d86d4b3c77814cef7946bee331d", "checkerName": "debug.Stats", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"line": 85, "col": 1, "file": 16}, "message": "sk_X509_EXTENSION_set_cmp_func -> Total CFGBlocks: 3 | Unreachable CFGBlocks: 0 | Exhausted Block: no | Empty WorkList: yes"}], "macros": [], "notes": [], "path": "/usr/include/openssl/x509.h", "reportHash": "a5f7221e8fba5d3c67e808565d4cbc67", "checkerName": "debug.Stats", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"line": 89, "col": 1, "file": 16}, "message": "sk_X509_ATTRIBUTE_num -> Total CFGBlocks: 3 | Unreachable CFGBlocks: 0 | Exhausted Block: no | Empty WorkList: yes"}], "macros": [], "notes": [], "path": "/usr/include/openssl/x509.h", "reportHash": "ceb98a8e8d71d49ce71ad9f01fdadc38", "checkerName": "debug.Stats", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"line": 89, "col": 1, "file": 16}, "message": "sk_X509_ATTRIBUTE_value -> Total CFGBlocks: 3 | Unreachable CFGBlocks: 0 | Exhausted Block: no | Empty WorkList: yes"}], "macros": [], "notes": [], "path": "/usr/include/openssl/x509.h", "reportHash": "99e261fcdf1f23de0ef5dcabce7cae08", "checkerName": "debug.Stats", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"line": 89, "col": 1, "file": 16}, "message": "sk_X509_ATTRIBUTE_new -> Total CFGBlocks: 3 | Unreachable CFGBlocks: 0 | Exhausted Block: no | Empty WorkList: yes"}], "macros": [], "notes": [], "path": "/usr/include/openssl/x509.h", "reportHash": "f60466587049893d42c78dbdd593f7e6", "checkerName": "debug.Stats", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"line": 89, "col": 1, "file": 16}, "message": "sk_X509_ATTRIBUTE_new_null -> Total CFGBlocks: 3 | Unreachable CFGBlocks: 0 | Exhausted Block: no | Empty WorkList: yes"}], "macros": [], "notes": [], "path": "/usr/include/openssl/x509.h", "reportHash": "0e528c01c63a398b1e78bf242f479f49", "checkerName": "debug.Stats", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"line": 89, "col": 1, "file": 16}, "message": "sk_X509_ATTRIBUTE_new_reserve -> Total CFGBlocks: 3 | Unreachable CFGBlocks: 0 | Exhausted Block: no | Empty WorkList: yes"}], "macros": [], "notes": [], "path": "/usr/include/openssl/x509.h", "reportHash": "efffee2a286a7eefd0bb7e9f1a670112", "checkerName": "debug.Stats", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"line": 89, "col": 1, "file": 16}, "message": "sk_X509_ATTRIBUTE_reserve -> Total CFGBlocks: 3 | Unreachable CFGBlocks: 0 | Exhausted Block: no | Empty WorkList: yes"}], "macros": [], "notes": [], "path": "/usr/include/openssl/x509.h", "reportHash": "ffc17f7c12bd152435f5c3828e24e9ea", "checkerName": "debug.Stats", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"line": 89, "col": 1, "file": 16}, "message": "sk_X509_ATTRIBUTE_free -> Total CFGBlocks: 3 | Unreachable CFGBlocks: 0 | Exhausted Block: no | Empty WorkList: yes"}], "macros": [], "notes": [], "path": "/usr/include/openssl/x509.h", "reportHash": "e63cdd376c8d393740c530d24eccd802", "checkerName": "debug.Stats", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"line": 89, "col": 1, "file": 16}, "message": "sk_X509_ATTRIBUTE_zero -> Total CFGBlocks: 3 | Unreachable CFGBlocks: 0 | Exhausted Block: no | Empty WorkList: yes"}], "macros": [], "notes": [], "path": "/usr/include/openssl/x509.h", "reportHash": "ed0f2c5209cde84e2ea080a60dee89be", "checkerName": "debug.Stats", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"line": 89, "col": 1, "file": 16}, "message": "sk_X509_ATTRIBUTE_delete -> Total CFGBlocks: 3 | Unreachable CFGBlocks: 0 | Exhausted Block: no | Empty WorkList: yes"}], "macros": [], "notes": [], "path": "/usr/include/openssl/x509.h", "reportHash": "50dfe5952b2fc4a0278763cf6500c7f9", "checkerName": "debug.Stats", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"line": 89, "col": 1, "file": 16}, "message": "sk_X509_ATTRIBUTE_delete_ptr -> Total CFGBlocks: 3 | Unreachable CFGBlocks: 0 | Exhausted Block: no | Empty WorkList: yes"}], "macros": [], "notes": [], "path": "/usr/include/openssl/x509.h", "reportHash": "7240812e1993ee4f7c91781e1ac0489d", "checkerName": "debug.Stats", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"line": 89, "col": 1, "file": 16}, "message": "sk_X509_ATTRIBUTE_push -> Total CFGBlocks: 3 | Unreachable CFGBlocks: 0 | Exhausted Block: no | Empty WorkList: yes"}], "macros": [], "notes": [], "path": "/usr/include/openssl/x509.h", "reportHash": "0b32e78ce1419fd099a5f80ec47a274b", "checkerName": "debug.Stats", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"line": 89, "col": 1, "file": 16}, "message": "sk_X509_ATTRIBUTE_unshift -> Total CFGBlocks: 3 | Unreachable CFGBlocks: 0 | Exhausted Block: no | Empty WorkList: yes"}], "macros": [], "notes": [], "path": "/usr/include/openssl/x509.h", "reportHash": "d9aa799746ee92c808660a80cffdf81b", "checkerName": "debug.Stats", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"line": 89, "col": 1, "file": 16}, "message": "sk_X509_ATTRIBUTE_pop -> Total CFGBlocks: 3 | Unreachable CFGBlocks: 0 | Exhausted Block: no | Empty WorkList: yes"}], "macros": [], "notes": [], "path": "/usr/include/openssl/x509.h", "reportHash": "c2423bc8cbadc06bc78c8fe218deccbc", "checkerName": "debug.Stats", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"line": 89, "col": 1, "file": 16}, "message": "sk_X509_ATTRIBUTE_shift -> Total CFGBlocks: 3 | Unreachable CFGBlocks: 0 | Exhausted Block: no | Empty WorkList: yes"}], "macros": [], "notes": [], "path": "/usr/include/openssl/x509.h", "reportHash": "4c05545bc69d07de4478ac765dfabd1d", "checkerName": "debug.Stats", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"line": 89, "col": 1, "file": 16}, "message": "sk_X509_ATTRIBUTE_pop_free -> Total CFGBlocks: 3 | Unreachable CFGBlocks: 0 | Exhausted Block: no | Empty WorkList: yes"}], "macros": [], "notes": [], "path": "/usr/include/openssl/x509.h", "reportHash": "25d8fe663a6ded3fde99ffdca27c1822", "checkerName": "debug.Stats", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"line": 89, "col": 1, "file": 16}, "message": "sk_X509_ATTRIBUTE_insert -> Total CFGBlocks: 3 | Unreachable CFGBlocks: 0 | Exhausted Block: no | Empty WorkList: yes"}], "macros": [], "notes": [], "path": "/usr/include/openssl/x509.h", "reportHash": "724d252e6a7b58bdfded5c4c0a18fb1b", "checkerName": "debug.Stats", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"line": 89, "col": 1, "file": 16}, "message": "sk_X509_ATTRIBUTE_set -> Total CFGBlocks: 3 | Unreachable CFGBlocks: 0 | Exhausted Block: no | Empty WorkList: yes"}], "macros": [], "notes": [], "path": "/usr/include/openssl/x509.h", "reportHash": "7add459c64b9a9df7b75a197ff9dbbe3", "checkerName": "debug.Stats", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"line": 89, "col": 1, "file": 16}, "message": "sk_X509_ATTRIBUTE_find -> Total CFGBlocks: 3 | Unreachable CFGBlocks: 0 | Exhausted Block: no | Empty WorkList: yes"}], "macros": [], "notes": [], "path": "/usr/include/openssl/x509.h", "reportHash": "5bfebf817ffd74ca902f7f1271171139", "checkerName": "debug.Stats", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"line": 89, "col": 1, "file": 16}, "message": "sk_X509_ATTRIBUTE_find_ex -> Total CFGBlocks: 3 | Unreachable CFGBlocks: 0 | Exhausted Block: no | Empty WorkList: yes"}], "macros": [], "notes": [], "path": "/usr/include/openssl/x509.h", "reportHash": "b39d9d76c3e8c832eb2b8bd205320687", "checkerName": "debug.Stats", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"line": 89, "col": 1, "file": 16}, "message": "sk_X509_ATTRIBUTE_sort -> Total CFGBlocks: 3 | Unreachable CFGBlocks: 0 | Exhausted Block: no | Empty WorkList: yes"}], "macros": [], "notes": [], "path": "/usr/include/openssl/x509.h", "reportHash": "675a28ca7b642ca9a39e8a6671fced0e", "checkerName": "debug.Stats", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"line": 89, "col": 1, "file": 16}, "message": "sk_X509_ATTRIBUTE_is_sorted -> Total CFGBlocks: 3 | Unreachable CFGBlocks: 0 | Exhausted Block: no | Empty WorkList: yes"}], "macros": [], "notes": [], "path": "/usr/include/openssl/x509.h", "reportHash": "ae1ffc6cfcc0243756d3cd92a340596b", "checkerName": "debug.Stats", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"line": 89, "col": 1, "file": 16}, "message": "sk_X509_ATTRIBUTE_dup -> Total CFGBlocks: 3 | Unreachable CFGBlocks: 0 | Exhausted Block: no | Empty WorkList: yes"}], "macros": [], "notes": [], "path": "/usr/include/openssl/x509.h", "reportHash": "c2dd532eeb763654433c0e14ba82f068", "checkerName": "debug.Stats", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"line": 89, "col": 1, "file": 16}, "message": "sk_X509_ATTRIBUTE_deep_copy -> Total CFGBlocks: 3 | Unreachable CFGBlocks: 0 | Exhausted Block: no | Empty WorkList: yes"}], "macros": [], "notes": [], "path": "/usr/include/openssl/x509.h", "reportHash": "c8131aef61abcb858f4dc0bef632d166", "checkerName": "debug.Stats", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"line": 89, "col": 1, "file": 16}, "message": "sk_X509_ATTRIBUTE_set_cmp_func -> Total CFGBlocks: 3 | Unreachable CFGBlocks: 0 | Exhausted Block: no | Empty WorkList: yes"}], "macros": [], "notes": [], "path": "/usr/include/openssl/x509.h", "reportHash": "756a9a79fbcce392d6389fc1ca7b7813", "checkerName": "debug.Stats", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"line": 99, "col": 1, "file": 16}, "message": "sk_X509_num -> Total CFGBlocks: 3 | Unreachable CFGBlocks: 0 | Exhausted Block: no | Empty WorkList: yes"}], "macros": [], "notes": [], "path": "/usr/include/openssl/x509.h", "reportHash": "72fd8b458f2f48d4e894c5b511026dd5", "checkerName": "debug.Stats", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"line": 99, "col": 1, "file": 16}, "message": "sk_X509_value -> Total CFGBlocks: 3 | Unreachable CFGBlocks: 0 | Exhausted Block: no | Empty WorkList: yes"}], "macros": [], "notes": [], "path": "/usr/include/openssl/x509.h", "reportHash": "1d6c31f6ff709a13c438384f246b7bca", "checkerName": "debug.Stats", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"line": 99, "col": 1, "file": 16}, "message": "sk_X509_new -> Total CFGBlocks: 3 | Unreachable CFGBlocks: 0 | Exhausted Block: no | Empty WorkList: yes"}], "macros": [], "notes": [], "path": "/usr/include/openssl/x509.h", "reportHash": "d3fb7712337bde8d799573c692fec108", "checkerName": "debug.Stats", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"line": 99, "col": 1, "file": 16}, "message": "sk_X509_new_null -> Total CFGBlocks: 3 | Unreachable CFGBlocks: 0 | Exhausted Block: no | Empty WorkList: yes"}], "macros": [], "notes": [], "path": "/usr/include/openssl/x509.h", "reportHash": "6c1922ca44c0f49839fa2928a6b7cc79", "checkerName": "debug.Stats", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"line": 99, "col": 1, "file": 16}, "message": "sk_X509_new_reserve -> Total CFGBlocks: 3 | Unreachable CFGBlocks: 0 | Exhausted Block: no | Empty WorkList: yes"}], "macros": [], "notes": [], "path": "/usr/include/openssl/x509.h", "reportHash": "9b3b16d2b45ad975011831ee7a2d093b", "checkerName": "debug.Stats", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"line": 99, "col": 1, "file": 16}, "message": "sk_X509_reserve -> Total CFGBlocks: 3 | Unreachable CFGBlocks: 0 | Exhausted Block: no | Empty WorkList: yes"}], "macros": [], "notes": [], "path": "/usr/include/openssl/x509.h", "reportHash": "b0807e1d8305aeb1ba8543fc4ced3fc6", "checkerName": "debug.Stats", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"line": 99, "col": 1, "file": 16}, "message": "sk_X509_free -> Total CFGBlocks: 3 | Unreachable CFGBlocks: 0 | Exhausted Block: no | Empty WorkList: yes"}], "macros": [], "notes": [], "path": "/usr/include/openssl/x509.h", "reportHash": "fc277b5a6108fb355c1b1660580a68f7", "checkerName": "debug.Stats", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"line": 99, "col": 1, "file": 16}, "message": "sk_X509_zero -> Total CFGBlocks: 3 | Unreachable CFGBlocks: 0 | Exhausted Block: no | Empty WorkList: yes"}], "macros": [], "notes": [], "path": "/usr/include/openssl/x509.h", "reportHash": "461dbfa5fc5a7b939b58bb7fd98c6951", "checkerName": "debug.Stats", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"line": 99, "col": 1, "file": 16}, "message": "sk_X509_delete -> Total CFGBlocks: 3 | Unreachable CFGBlocks: 0 | Exhausted Block: no | Empty WorkList: yes"}], "macros": [], "notes": [], "path": "/usr/include/openssl/x509.h", "reportHash": "a079cfba43466b8142491aef3912bc03", "checkerName": "debug.Stats", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"line": 99, "col": 1, "file": 16}, "message": "sk_X509_delete_ptr -> Total CFGBlocks: 3 | Unreachable CFGBlocks: 0 | Exhausted Block: no | Empty WorkList: yes"}], "macros": [], "notes": [], "path": "/usr/include/openssl/x509.h", "reportHash": "d512d2bcc769e36b8cc1b62a98dde1cd", "checkerName": "debug.Stats", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"line": 99, "col": 1, "file": 16}, "message": "sk_X509_push -> Total CFGBlocks: 3 | Unreachable CFGBlocks: 0 | Exhausted Block: no | Empty WorkList: yes"}], "macros": [], "notes": [], "path": "/usr/include/openssl/x509.h", "reportHash": "acc84a3d9401d93f3edc856ffbea40eb", "checkerName": "debug.Stats", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"line": 99, "col": 1, "file": 16}, "message": "sk_X509_unshift -> Total CFGBlocks: 3 | Unreachable CFGBlocks: 0 | Exhausted Block: no | Empty WorkList: yes"}], "macros": [], "notes": [], "path": "/usr/include/openssl/x509.h", "reportHash": "a888ef4a6ce3ec19e154b9467997b53a", "checkerName": "debug.Stats", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"line": 99, "col": 1, "file": 16}, "message": "sk_X509_pop -> Total CFGBlocks: 3 | Unreachable CFGBlocks: 0 | Exhausted Block: no | Empty WorkList: yes"}], "macros": [], "notes": [], "path": "/usr/include/openssl/x509.h", "reportHash": "7a2f1cc51c7fc07f0a289078738dfe13", "checkerName": "debug.Stats", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"line": 99, "col": 1, "file": 16}, "message": "sk_X509_shift -> Total CFGBlocks: 3 | Unreachable CFGBlocks: 0 | Exhausted Block: no | Empty WorkList: yes"}], "macros": [], "notes": [], "path": "/usr/include/openssl/x509.h", "reportHash": "35967cbdbf7bba905d548a2cc4e6034e", "checkerName": "debug.Stats", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"line": 99, "col": 1, "file": 16}, "message": "sk_X509_pop_free -> Total CFGBlocks: 3 | Unreachable CFGBlocks: 0 | Exhausted Block: no | Empty WorkList: yes"}], "macros": [], "notes": [], "path": "/usr/include/openssl/x509.h", "reportHash": "5f321d49fbb88ed2af68c805dcf506b0", "checkerName": "debug.Stats", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"line": 99, "col": 1, "file": 16}, "message": "sk_X509_insert -> Total CFGBlocks: 3 | Unreachable CFGBlocks: 0 | Exhausted Block: no | Empty WorkList: yes"}], "macros": [], "notes": [], "path": "/usr/include/openssl/x509.h", "reportHash": "0f7bec0d90a5f9dbe9cd5abfea0ec77b", "checkerName": "debug.Stats", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"line": 99, "col": 1, "file": 16}, "message": "sk_X509_set -> Total CFGBlocks: 3 | Unreachable CFGBlocks: 0 | Exhausted Block: no | Empty WorkList: yes"}], "macros": [], "notes": [], "path": "/usr/include/openssl/x509.h", "reportHash": "3b8a47a5c40fe864c568391e683e060b", "checkerName": "debug.Stats", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"line": 99, "col": 1, "file": 16}, "message": "sk_X509_find -> Total CFGBlocks: 3 | Unreachable CFGBlocks: 0 | Exhausted Block: no | Empty WorkList: yes"}], "macros": [], "notes": [], "path": "/usr/include/openssl/x509.h", "reportHash": "d9aac5a3356248b74503bed2fa3582ec", "checkerName": "debug.Stats", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"line": 99, "col": 1, "file": 16}, "message": "sk_X509_find_ex -> Total CFGBlocks: 3 | Unreachable CFGBlocks: 0 | Exhausted Block: no | Empty WorkList: yes"}], "macros": [], "notes": [], "path": "/usr/include/openssl/x509.h", "reportHash": "5884e559473fe171e6f136a60e0c9a9d", "checkerName": "debug.Stats", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"line": 99, "col": 1, "file": 16}, "message": "sk_X509_sort -> Total CFGBlocks: 3 | Unreachable CFGBlocks: 0 | Exhausted Block: no | Empty WorkList: yes"}], "macros": [], "notes": [], "path": "/usr/include/openssl/x509.h", "reportHash": "afd100bc37710be1af7487e49a81c31e", "checkerName": "debug.Stats", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"line": 99, "col": 1, "file": 16}, "message": "sk_X509_is_sorted -> Total CFGBlocks: 3 | Unreachable CFGBlocks: 0 | Exhausted Block: no | Empty WorkList: yes"}], "macros": [], "notes": [], "path": "/usr/include/openssl/x509.h", "reportHash": "43709e2cda7548f37e51af3439f66caf", "checkerName": "debug.Stats", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"line": 99, "col": 1, "file": 16}, "message": "sk_X509_dup -> Total CFGBlocks: 3 | Unreachable CFGBlocks: 0 | Exhausted Block: no | Empty WorkList: yes"}], "macros": [], "notes": [], "path": "/usr/include/openssl/x509.h", "reportHash": "7d77796d9979278b94d4900a3b5b5701", "checkerName": "debug.Stats", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"line": 99, "col": 1, "file": 16}, "message": "sk_X509_deep_copy -> Total CFGBlocks: 3 | Unreachable CFGBlocks: 0 | Exhausted Block: no | Empty WorkList: yes"}], "macros": [], "notes": [], "path": "/usr/include/openssl/x509.h", "reportHash": "343e1e2cb3a02018a3c3064b42644923", "checkerName": "debug.Stats", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"line": 99, "col": 1, "file": 16}, "message": "sk_X509_set_cmp_func -> Total CFGBlocks: 3 | Unreachable CFGBlocks: 0 | Exhausted Block: no | Empty WorkList: yes"}], "macros": [], "notes": [], "path": "/usr/include/openssl/x509.h", "reportHash": "ab8353e66a08888f24441b685c1a6928", "checkerName": "debug.Stats", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"line": 112, "col": 1, "file": 16}, "message": "sk_X509_TRUST_num -> Total CFGBlocks: 3 | Unreachable CFGBlocks: 0 | Exhausted Block: no | Empty WorkList: yes"}], "macros": [], "notes": [], "path": "/usr/include/openssl/x509.h", "reportHash": "81fec347a5ecbc0068df372f18ba3257", "checkerName": "debug.Stats", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"line": 112, "col": 1, "file": 16}, "message": "sk_X509_TRUST_value -> Total CFGBlocks: 3 | Unreachable CFGBlocks: 0 | Exhausted Block: no | Empty WorkList: yes"}], "macros": [], "notes": [], "path": "/usr/include/openssl/x509.h", "reportHash": "ef98a13e4e3f89f2bac63b7d35bd1480", "checkerName": "debug.Stats", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"line": 112, "col": 1, "file": 16}, "message": "sk_X509_TRUST_new -> Total CFGBlocks: 3 | Unreachable CFGBlocks: 0 | Exhausted Block: no | Empty WorkList: yes"}], "macros": [], "notes": [], "path": "/usr/include/openssl/x509.h", "reportHash": "7f614ebcd0ec21ebf1fca6f130abfdcd", "checkerName": "debug.Stats", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"line": 112, "col": 1, "file": 16}, "message": "sk_X509_TRUST_new_null -> Total CFGBlocks: 3 | Unreachable CFGBlocks: 0 | Exhausted Block: no | Empty WorkList: yes"}], "macros": [], "notes": [], "path": "/usr/include/openssl/x509.h", "reportHash": "995b58c30fe34f2564b1c524caa43161", "checkerName": "debug.Stats", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"line": 112, "col": 1, "file": 16}, "message": "sk_X509_TRUST_new_reserve -> Total CFGBlocks: 3 | Unreachable CFGBlocks: 0 | Exhausted Block: no | Empty WorkList: yes"}], "macros": [], "notes": [], "path": "/usr/include/openssl/x509.h", "reportHash": "b18be837aeaf1d7455120f76e3df9d4d", "checkerName": "debug.Stats", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"line": 112, "col": 1, "file": 16}, "message": "sk_X509_TRUST_reserve -> Total CFGBlocks: 3 | Unreachable CFGBlocks: 0 | Exhausted Block: no | Empty WorkList: yes"}], "macros": [], "notes": [], "path": "/usr/include/openssl/x509.h", "reportHash": "926d6bacc1eb61cb4b35e7e618575194", "checkerName": "debug.Stats", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"line": 112, "col": 1, "file": 16}, "message": "sk_X509_TRUST_free -> Total CFGBlocks: 3 | Unreachable CFGBlocks: 0 | Exhausted Block: no | Empty WorkList: yes"}], "macros": [], "notes": [], "path": "/usr/include/openssl/x509.h", "reportHash": "85399eab2ec921af0daf1630bd128a25", "checkerName": "debug.Stats", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"line": 112, "col": 1, "file": 16}, "message": "sk_X509_TRUST_zero -> Total CFGBlocks: 3 | Unreachable CFGBlocks: 0 | Exhausted Block: no | Empty WorkList: yes"}], "macros": [], "notes": [], "path": "/usr/include/openssl/x509.h", "reportHash": "686190b0410d3a6ae141ea1416a8c8b0", "checkerName": "debug.Stats", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"line": 112, "col": 1, "file": 16}, "message": "sk_X509_TRUST_delete -> Total CFGBlocks: 3 | Unreachable CFGBlocks: 0 | Exhausted Block: no | Empty WorkList: yes"}], "macros": [], "notes": [], "path": "/usr/include/openssl/x509.h", "reportHash": "5c26f735af630ede8d16fe59175dfb38", "checkerName": "debug.Stats", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"line": 112, "col": 1, "file": 16}, "message": "sk_X509_TRUST_delete_ptr -> Total CFGBlocks: 3 | Unreachable CFGBlocks: 0 | Exhausted Block: no | Empty WorkList: yes"}], "macros": [], "notes": [], "path": "/usr/include/openssl/x509.h", "reportHash": "261081619d2f6a422b7ac6241ef26b99", "checkerName": "debug.Stats", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"line": 112, "col": 1, "file": 16}, "message": "sk_X509_TRUST_push -> Total CFGBlocks: 3 | Unreachable CFGBlocks: 0 | Exhausted Block: no | Empty WorkList: yes"}], "macros": [], "notes": [], "path": "/usr/include/openssl/x509.h", "reportHash": "bf8a9904e346c28b8341821cc9879c65", "checkerName": "debug.Stats", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"line": 112, "col": 1, "file": 16}, "message": "sk_X509_TRUST_unshift -> Total CFGBlocks: 3 | Unreachable CFGBlocks: 0 | Exhausted Block: no | Empty WorkList: yes"}], "macros": [], "notes": [], "path": "/usr/include/openssl/x509.h", "reportHash": "6a80c0e3de0fdbfe1737b7a8b3584f7b", "checkerName": "debug.Stats", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"line": 112, "col": 1, "file": 16}, "message": "sk_X509_TRUST_pop -> Total CFGBlocks: 3 | Unreachable CFGBlocks: 0 | Exhausted Block: no | Empty WorkList: yes"}], "macros": [], "notes": [], "path": "/usr/include/openssl/x509.h", "reportHash": "7345aa594c690d7dec6cda15adfb899e", "checkerName": "debug.Stats", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"line": 112, "col": 1, "file": 16}, "message": "sk_X509_TRUST_shift -> Total CFGBlocks: 3 | Unreachable CFGBlocks: 0 | Exhausted Block: no | Empty WorkList: yes"}], "macros": [], "notes": [], "path": "/usr/include/openssl/x509.h", "reportHash": "77a8da9b523be821c85d4965f79a44e4", "checkerName": "debug.Stats", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"line": 112, "col": 1, "file": 16}, "message": "sk_X509_TRUST_pop_free -> Total CFGBlocks: 3 | Unreachable CFGBlocks: 0 | Exhausted Block: no | Empty WorkList: yes"}], "macros": [], "notes": [], "path": "/usr/include/openssl/x509.h", "reportHash": "43607b0330791fa84bf2b9f48edbaa6e", "checkerName": "debug.Stats", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"line": 112, "col": 1, "file": 16}, "message": "sk_X509_TRUST_insert -> Total CFGBlocks: 3 | Unreachable CFGBlocks: 0 | Exhausted Block: no | Empty WorkList: yes"}], "macros": [], "notes": [], "path": "/usr/include/openssl/x509.h", "reportHash": "69f5124954772e7dde91122c0d7225d0", "checkerName": "debug.Stats", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"line": 112, "col": 1, "file": 16}, "message": "sk_X509_TRUST_set -> Total CFGBlocks: 3 | Unreachable CFGBlocks: 0 | Exhausted Block: no | Empty WorkList: yes"}], "macros": [], "notes": [], "path": "/usr/include/openssl/x509.h", "reportHash": "b1bbf1a8aaf31b5618d5c5ef2dae06fc", "checkerName": "debug.Stats", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"line": 112, "col": 1, "file": 16}, "message": "sk_X509_TRUST_find -> Total CFGBlocks: 3 | Unreachable CFGBlocks: 0 | Exhausted Block: no | Empty WorkList: yes"}], "macros": [], "notes": [], "path": "/usr/include/openssl/x509.h", "reportHash": "249724e8f300a8161446891a79c3f8c5", "checkerName": "debug.Stats", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"line": 112, "col": 1, "file": 16}, "message": "sk_X509_TRUST_find_ex -> Total CFGBlocks: 3 | Unreachable CFGBlocks: 0 | Exhausted Block: no | Empty WorkList: yes"}], "macros": [], "notes": [], "path": "/usr/include/openssl/x509.h", "reportHash": "4bd6400ed383425958b9e39a5e0b4cbd", "checkerName": "debug.Stats", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"line": 112, "col": 1, "file": 16}, "message": "sk_X509_TRUST_sort -> Total CFGBlocks: 3 | Unreachable CFGBlocks: 0 | Exhausted Block: no | Empty WorkList: yes"}], "macros": [], "notes": [], "path": "/usr/include/openssl/x509.h", "reportHash": "e080226d48dc50f61a9151ac6e927c91", "checkerName": "debug.Stats", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"line": 112, "col": 1, "file": 16}, "message": "sk_X509_TRUST_is_sorted -> Total CFGBlocks: 3 | Unreachable CFGBlocks: 0 | Exhausted Block: no | Empty WorkList: yes"}], "macros": [], "notes": [], "path": "/usr/include/openssl/x509.h", "reportHash": "5e83ce1be9042041117fac146f5c66b3", "checkerName": "debug.Stats", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"line": 112, "col": 1, "file": 16}, "message": "sk_X509_TRUST_dup -> Total CFGBlocks: 3 | Unreachable CFGBlocks: 0 | Exhausted Block: no | Empty WorkList: yes"}], "macros": [], "notes": [], "path": "/usr/include/openssl/x509.h", "reportHash": "f9ce018a8172830cb9bb7842fff76c06", "checkerName": "debug.Stats", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"line": 112, "col": 1, "file": 16}, "message": "sk_X509_TRUST_deep_copy -> Total CFGBlocks: 3 | Unreachable CFGBlocks: 0 | Exhausted Block: no | Empty WorkList: yes"}], "macros": [], "notes": [], "path": "/usr/include/openssl/x509.h", "reportHash": "8bd4d3977da01025b401471c5243974d", "checkerName": "debug.Stats", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"line": 112, "col": 1, "file": 16}, "message": "sk_X509_TRUST_set_cmp_func -> Total CFGBlocks: 3 | Unreachable CFGBlocks: 0 | Exhausted Block: no | Empty WorkList: yes"}], "macros": [], "notes": [], "path": "/usr/include/openssl/x509.h", "reportHash": "a01ee789147bdf7ba3c0bfd82be6f515", "checkerName": "debug.Stats", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"line": 224, "col": 1, "file": 16}, "message": "sk_X509_REVOKED_num -> Total CFGBlocks: 3 | Unreachable CFGBlocks: 0 | Exhausted Block: no | Empty WorkList: yes"}], "macros": [], "notes": [], "path": "/usr/include/openssl/x509.h", "reportHash": "b598e23ae5bf0541ff0000d8bbb37fbf", "checkerName": "debug.Stats", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"line": 224, "col": 1, "file": 16}, "message": "sk_X509_REVOKED_value -> Total CFGBlocks: 3 | Unreachable CFGBlocks: 0 | Exhausted Block: no | Empty WorkList: yes"}], "macros": [], "notes": [], "path": "/usr/include/openssl/x509.h", "reportHash": "f2c16e532de4e351ebd88fecd0f12dd0", "checkerName": "debug.Stats", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"line": 224, "col": 1, "file": 16}, "message": "sk_X509_REVOKED_new -> Total CFGBlocks: 3 | Unreachable CFGBlocks: 0 | Exhausted Block: no | Empty WorkList: yes"}], "macros": [], "notes": [], "path": "/usr/include/openssl/x509.h", "reportHash": "ad2186b3ea9518faa798c0d268603ee1", "checkerName": "debug.Stats", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"line": 224, "col": 1, "file": 16}, "message": "sk_X509_REVOKED_new_null -> Total CFGBlocks: 3 | Unreachable CFGBlocks: 0 | Exhausted Block: no | Empty WorkList: yes"}], "macros": [], "notes": [], "path": "/usr/include/openssl/x509.h", "reportHash": "dd6640d45bae425cb16e4a9c40055379", "checkerName": "debug.Stats", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"line": 224, "col": 1, "file": 16}, "message": "sk_X509_REVOKED_new_reserve -> Total CFGBlocks: 3 | Unreachable CFGBlocks: 0 | Exhausted Block: no | Empty WorkList: yes"}], "macros": [], "notes": [], "path": "/usr/include/openssl/x509.h", "reportHash": "aaa5d6a3aa1761c4ba85794cbbb72c2f", "checkerName": "debug.Stats", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"line": 224, "col": 1, "file": 16}, "message": "sk_X509_REVOKED_reserve -> Total CFGBlocks: 3 | Unreachable CFGBlocks: 0 | Exhausted Block: no | Empty WorkList: yes"}], "macros": [], "notes": [], "path": "/usr/include/openssl/x509.h", "reportHash": "6b8b167a1f8a1d43a1e8d6c7c119a73d", "checkerName": "debug.Stats", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"line": 224, "col": 1, "file": 16}, "message": "sk_X509_REVOKED_free -> Total CFGBlocks: 3 | Unreachable CFGBlocks: 0 | Exhausted Block: no | Empty WorkList: yes"}], "macros": [], "notes": [], "path": "/usr/include/openssl/x509.h", "reportHash": "2d78738ec061fd41b6fe81cd7291af8c", "checkerName": "debug.Stats", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"line": 224, "col": 1, "file": 16}, "message": "sk_X509_REVOKED_zero -> Total CFGBlocks: 3 | Unreachable CFGBlocks: 0 | Exhausted Block: no | Empty WorkList: yes"}], "macros": [], "notes": [], "path": "/usr/include/openssl/x509.h", "reportHash": "65b325e5eb3806a18d9a63f5c8c1a9c1", "checkerName": "debug.Stats", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"line": 224, "col": 1, "file": 16}, "message": "sk_X509_REVOKED_delete -> Total CFGBlocks: 3 | Unreachable CFGBlocks: 0 | Exhausted Block: no | Empty WorkList: yes"}], "macros": [], "notes": [], "path": "/usr/include/openssl/x509.h", "reportHash": "7b499f19fb2219e569d051bb6a0ed2a3", "checkerName": "debug.Stats", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"line": 224, "col": 1, "file": 16}, "message": "sk_X509_REVOKED_delete_ptr -> Total CFGBlocks: 3 | Unreachable CFGBlocks: 0 | Exhausted Block: no | Empty WorkList: yes"}], "macros": [], "notes": [], "path": "/usr/include/openssl/x509.h", "reportHash": "86d1add8c89cfd82ddc1a89cdd9c14cc", "checkerName": "debug.Stats", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"line": 224, "col": 1, "file": 16}, "message": "sk_X509_REVOKED_push -> Total CFGBlocks: 3 | Unreachable CFGBlocks: 0 | Exhausted Block: no | Empty WorkList: yes"}], "macros": [], "notes": [], "path": "/usr/include/openssl/x509.h", "reportHash": "62510d8a4f18856c0684c11d11cb4708", "checkerName": "debug.Stats", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"line": 224, "col": 1, "file": 16}, "message": "sk_X509_REVOKED_unshift -> Total CFGBlocks: 3 | Unreachable CFGBlocks: 0 | Exhausted Block: no | Empty WorkList: yes"}], "macros": [], "notes": [], "path": "/usr/include/openssl/x509.h", "reportHash": "4c2a6414c7ce620b3031f75b2abd240e", "checkerName": "debug.Stats", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"line": 224, "col": 1, "file": 16}, "message": "sk_X509_REVOKED_pop -> Total CFGBlocks: 3 | Unreachable CFGBlocks: 0 | Exhausted Block: no | Empty WorkList: yes"}], "macros": [], "notes": [], "path": "/usr/include/openssl/x509.h", "reportHash": "d46605244d0b689caaa64d216c8425f4", "checkerName": "debug.Stats", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"line": 224, "col": 1, "file": 16}, "message": "sk_X509_REVOKED_shift -> Total CFGBlocks: 3 | Unreachable CFGBlocks: 0 | Exhausted Block: no | Empty WorkList: yes"}], "macros": [], "notes": [], "path": "/usr/include/openssl/x509.h", "reportHash": "870e846b8e2bb9a1097381cfdb465c6d", "checkerName": "debug.Stats", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"line": 224, "col": 1, "file": 16}, "message": "sk_X509_REVOKED_pop_free -> Total CFGBlocks: 3 | Unreachable CFGBlocks: 0 | Exhausted Block: no | Empty WorkList: yes"}], "macros": [], "notes": [], "path": "/usr/include/openssl/x509.h", "reportHash": "82f21f4f8635a05c8639a13b855f2dd3", "checkerName": "debug.Stats", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"line": 224, "col": 1, "file": 16}, "message": "sk_X509_REVOKED_insert -> Total CFGBlocks: 3 | Unreachable CFGBlocks: 0 | Exhausted Block: no | Empty WorkList: yes"}], "macros": [], "notes": [], "path": "/usr/include/openssl/x509.h", "reportHash": "b3240f91e48c57eea4bfc6a94e341e1f", "checkerName": "debug.Stats", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"line": 224, "col": 1, "file": 16}, "message": "sk_X509_REVOKED_set -> Total CFGBlocks: 3 | Unreachable CFGBlocks: 0 | Exhausted Block: no | Empty WorkList: yes"}], "macros": [], "notes": [], "path": "/usr/include/openssl/x509.h", "reportHash": "7d1a12f3dc4bb92d3f5a7a8d24d0279e", "checkerName": "debug.Stats", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"line": 224, "col": 1, "file": 16}, "message": "sk_X509_REVOKED_find -> Total CFGBlocks: 3 | Unreachable CFGBlocks: 0 | Exhausted Block: no | Empty WorkList: yes"}], "macros": [], "notes": [], "path": "/usr/include/openssl/x509.h", "reportHash": "a9d9c568e2c4fab747ca38681511370d", "checkerName": "debug.Stats", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"line": 224, "col": 1, "file": 16}, "message": "sk_X509_REVOKED_find_ex -> Total CFGBlocks: 3 | Unreachable CFGBlocks: 0 | Exhausted Block: no | Empty WorkList: yes"}], "macros": [], "notes": [], "path": "/usr/include/openssl/x509.h", "reportHash": "d2b36fd928ffc635235c27abe5550b04", "checkerName": "debug.Stats", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"line": 224, "col": 1, "file": 16}, "message": "sk_X509_REVOKED_sort -> Total CFGBlocks: 3 | Unreachable CFGBlocks: 0 | Exhausted Block: no | Empty WorkList: yes"}], "macros": [], "notes": [], "path": "/usr/include/openssl/x509.h", "reportHash": "b923d681bd92337b74c87bc87a5d3f70", "checkerName": "debug.Stats", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"line": 224, "col": 1, "file": 16}, "message": "sk_X509_REVOKED_is_sorted -> Total CFGBlocks: 3 | Unreachable CFGBlocks: 0 | Exhausted Block: no | Empty WorkList: yes"}], "macros": [], "notes": [], "path": "/usr/include/openssl/x509.h", "reportHash": "21d14835422a95488af4eedf924dc157", "checkerName": "debug.Stats", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"line": 224, "col": 1, "file": 16}, "message": "sk_X509_REVOKED_dup -> Total CFGBlocks: 3 | Unreachable CFGBlocks: 0 | Exhausted Block: no | Empty WorkList: yes"}], "macros": [], "notes": [], "path": "/usr/include/openssl/x509.h", "reportHash": "5a452e8897bfb8f9b7a305856c8260d1", "checkerName": "debug.Stats", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"line": 224, "col": 1, "file": 16}, "message": "sk_X509_REVOKED_deep_copy -> Total CFGBlocks: 3 | Unreachable CFGBlocks: 0 | Exhausted Block: no | Empty WorkList: yes"}], "macros": [], "notes": [], "path": "/usr/include/openssl/x509.h", "reportHash": "ef13b4b805f13ab558e1d79f483844fb", "checkerName": "debug.Stats", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"line": 224, "col": 1, "file": 16}, "message": "sk_X509_REVOKED_set_cmp_func -> Total CFGBlocks: 3 | Unreachable CFGBlocks: 0 | Exhausted Block: no | Empty WorkList: yes"}], "macros": [], "notes": [], "path": "/usr/include/openssl/x509.h", "reportHash": "ccc3c0a4568a914cfc4c3e0438c6b6c3", "checkerName": "debug.Stats", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"line": 228, "col": 1, "file": 16}, "message": "sk_X509_CRL_num -> Total CFGBlocks: 3 | Unreachable CFGBlocks: 0 | Exhausted Block: no | Empty WorkList: yes"}], "macros": [], "notes": [], "path": "/usr/include/openssl/x509.h", "reportHash": "9396938b60c10a8d361c7be68f8c720e", "checkerName": "debug.Stats", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"line": 228, "col": 1, "file": 16}, "message": "sk_X509_CRL_value -> Total CFGBlocks: 3 | Unreachable CFGBlocks: 0 | Exhausted Block: no | Empty WorkList: yes"}], "macros": [], "notes": [], "path": "/usr/include/openssl/x509.h", "reportHash": "56f1b5d916850f11489b4eeed7e3eabd", "checkerName": "debug.Stats", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"line": 228, "col": 1, "file": 16}, "message": "sk_X509_CRL_new -> Total CFGBlocks: 3 | Unreachable CFGBlocks: 0 | Exhausted Block: no | Empty WorkList: yes"}], "macros": [], "notes": [], "path": "/usr/include/openssl/x509.h", "reportHash": "2b8734e95c8886ca18a5a5c373572b4f", "checkerName": "debug.Stats", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"line": 228, "col": 1, "file": 16}, "message": "sk_X509_CRL_new_null -> Total CFGBlocks: 3 | Unreachable CFGBlocks: 0 | Exhausted Block: no | Empty WorkList: yes"}], "macros": [], "notes": [], "path": "/usr/include/openssl/x509.h", "reportHash": "e7f95aa93e3d3ab938bdf7f8ebf0710d", "checkerName": "debug.Stats", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"line": 228, "col": 1, "file": 16}, "message": "sk_X509_CRL_new_reserve -> Total CFGBlocks: 3 | Unreachable CFGBlocks: 0 | Exhausted Block: no | Empty WorkList: yes"}], "macros": [], "notes": [], "path": "/usr/include/openssl/x509.h", "reportHash": "19cb913d473b6989a4253c774a862578", "checkerName": "debug.Stats", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"line": 228, "col": 1, "file": 16}, "message": "sk_X509_CRL_reserve -> Total CFGBlocks: 3 | Unreachable CFGBlocks: 0 | Exhausted Block: no | Empty WorkList: yes"}], "macros": [], "notes": [], "path": "/usr/include/openssl/x509.h", "reportHash": "33df7d6429c04d39138d05e6f4303207", "checkerName": "debug.Stats", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"line": 228, "col": 1, "file": 16}, "message": "sk_X509_CRL_free -> Total CFGBlocks: 3 | Unreachable CFGBlocks: 0 | Exhausted Block: no | Empty WorkList: yes"}], "macros": [], "notes": [], "path": "/usr/include/openssl/x509.h", "reportHash": "34e28d85cf2d637f688007f337a14c52", "checkerName": "debug.Stats", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"line": 228, "col": 1, "file": 16}, "message": "sk_X509_CRL_zero -> Total CFGBlocks: 3 | Unreachable CFGBlocks: 0 | Exhausted Block: no | Empty WorkList: yes"}], "macros": [], "notes": [], "path": "/usr/include/openssl/x509.h", "reportHash": "f62cd614638b2ba39439def0da58bb68", "checkerName": "debug.Stats", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"line": 228, "col": 1, "file": 16}, "message": "sk_X509_CRL_delete -> Total CFGBlocks: 3 | Unreachable CFGBlocks: 0 | Exhausted Block: no | Empty WorkList: yes"}], "macros": [], "notes": [], "path": "/usr/include/openssl/x509.h", "reportHash": "c58f662f2cbc0aa6098e0da592e261e3", "checkerName": "debug.Stats", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"line": 228, "col": 1, "file": 16}, "message": "sk_X509_CRL_delete_ptr -> Total CFGBlocks: 3 | Unreachable CFGBlocks: 0 | Exhausted Block: no | Empty WorkList: yes"}], "macros": [], "notes": [], "path": "/usr/include/openssl/x509.h", "reportHash": "8a04d4d9fc703ae2892ee08223690956", "checkerName": "debug.Stats", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"line": 228, "col": 1, "file": 16}, "message": "sk_X509_CRL_push -> Total CFGBlocks: 3 | Unreachable CFGBlocks: 0 | Exhausted Block: no | Empty WorkList: yes"}], "macros": [], "notes": [], "path": "/usr/include/openssl/x509.h", "reportHash": "18d48313476cac1629d21e26c5fa008c", "checkerName": "debug.Stats", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"line": 228, "col": 1, "file": 16}, "message": "sk_X509_CRL_unshift -> Total CFGBlocks: 3 | Unreachable CFGBlocks: 0 | Exhausted Block: no | Empty WorkList: yes"}], "macros": [], "notes": [], "path": "/usr/include/openssl/x509.h", "reportHash": "6678e65fb5a158973cfa7ca46a8930b0", "checkerName": "debug.Stats", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"line": 228, "col": 1, "file": 16}, "message": "sk_X509_CRL_pop -> Total CFGBlocks: 3 | Unreachable CFGBlocks: 0 | Exhausted Block: no | Empty WorkList: yes"}], "macros": [], "notes": [], "path": "/usr/include/openssl/x509.h", "reportHash": "1286395249d13110f612ae11a75f84d6", "checkerName": "debug.Stats", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"line": 228, "col": 1, "file": 16}, "message": "sk_X509_CRL_shift -> Total CFGBlocks: 3 | Unreachable CFGBlocks: 0 | Exhausted Block: no | Empty WorkList: yes"}], "macros": [], "notes": [], "path": "/usr/include/openssl/x509.h", "reportHash": "b47090ba32e6594af946e3517f8effe8", "checkerName": "debug.Stats", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"line": 228, "col": 1, "file": 16}, "message": "sk_X509_CRL_pop_free -> Total CFGBlocks: 3 | Unreachable CFGBlocks: 0 | Exhausted Block: no | Empty WorkList: yes"}], "macros": [], "notes": [], "path": "/usr/include/openssl/x509.h", "reportHash": "f0e053260b64f55a5db0d2d18386d674", "checkerName": "debug.Stats", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"line": 228, "col": 1, "file": 16}, "message": "sk_X509_CRL_insert -> Total CFGBlocks: 3 | Unreachable CFGBlocks: 0 | Exhausted Block: no | Empty WorkList: yes"}], "macros": [], "notes": [], "path": "/usr/include/openssl/x509.h", "reportHash": "92b7c398b91a12e7beeca0ba018a2cc5", "checkerName": "debug.Stats", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"line": 228, "col": 1, "file": 16}, "message": "sk_X509_CRL_set -> Total CFGBlocks: 3 | Unreachable CFGBlocks: 0 | Exhausted Block: no | Empty WorkList: yes"}], "macros": [], "notes": [], "path": "/usr/include/openssl/x509.h", "reportHash": "6fe47527ad9725159d9020270402cfeb", "checkerName": "debug.Stats", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"line": 228, "col": 1, "file": 16}, "message": "sk_X509_CRL_find -> Total CFGBlocks: 3 | Unreachable CFGBlocks: 0 | Exhausted Block: no | Empty WorkList: yes"}], "macros": [], "notes": [], "path": "/usr/include/openssl/x509.h", "reportHash": "bd7bdb93385107ae4271be915362cbb2", "checkerName": "debug.Stats", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"line": 228, "col": 1, "file": 16}, "message": "sk_X509_CRL_find_ex -> Total CFGBlocks: 3 | Unreachable CFGBlocks: 0 | Exhausted Block: no | Empty WorkList: yes"}], "macros": [], "notes": [], "path": "/usr/include/openssl/x509.h", "reportHash": "ebc5e865de3c155bc9cc6ae8e50156f7", "checkerName": "debug.Stats", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"line": 228, "col": 1, "file": 16}, "message": "sk_X509_CRL_sort -> Total CFGBlocks: 3 | Unreachable CFGBlocks: 0 | Exhausted Block: no | Empty WorkList: yes"}], "macros": [], "notes": [], "path": "/usr/include/openssl/x509.h", "reportHash": "9d7fe6c217ee22fa7d698920bafe9027", "checkerName": "debug.Stats", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"line": 228, "col": 1, "file": 16}, "message": "sk_X509_CRL_is_sorted -> Total CFGBlocks: 3 | Unreachable CFGBlocks: 0 | Exhausted Block: no | Empty WorkList: yes"}], "macros": [], "notes": [], "path": "/usr/include/openssl/x509.h", "reportHash": "6cb4fafa9d3b23e05f68af882875796c", "checkerName": "debug.Stats", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"line": 228, "col": 1, "file": 16}, "message": "sk_X509_CRL_dup -> Total CFGBlocks: 3 | Unreachable CFGBlocks: 0 | Exhausted Block: no | Empty WorkList: yes"}], "macros": [], "notes": [], "path": "/usr/include/openssl/x509.h", "reportHash": "8acbd52f722ac342bb762812d746711e", "checkerName": "debug.Stats", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"line": 228, "col": 1, "file": 16}, "message": "sk_X509_CRL_deep_copy -> Total CFGBlocks: 3 | Unreachable CFGBlocks: 0 | Exhausted Block: no | Empty WorkList: yes"}], "macros": [], "notes": [], "path": "/usr/include/openssl/x509.h", "reportHash": "e113de3a721a61299d5f8578a699492e", "checkerName": "debug.Stats", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"line": 228, "col": 1, "file": 16}, "message": "sk_X509_CRL_set_cmp_func -> Total CFGBlocks: 3 | Unreachable CFGBlocks: 0 | Exhausted Block: no | Empty WorkList: yes"}], "macros": [], "notes": [], "path": "/usr/include/openssl/x509.h", "reportHash": "d9d3e2a56ac80a21b7bed6adb9616c35", "checkerName": "debug.Stats", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"line": 254, "col": 1, "file": 16}, "message": "sk_X509_INFO_num -> Total CFGBlocks: 3 | Unreachable CFGBlocks: 0 | Exhausted Block: no | Empty WorkList: yes"}], "macros": [], "notes": [], "path": "/usr/include/openssl/x509.h", "reportHash": "7ac298894a25273ed8de7d7ba0c3863b", "checkerName": "debug.Stats", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"line": 254, "col": 1, "file": 16}, "message": "sk_X509_INFO_value -> Total CFGBlocks: 3 | Unreachable CFGBlocks: 0 | Exhausted Block: no | Empty WorkList: yes"}], "macros": [], "notes": [], "path": "/usr/include/openssl/x509.h", "reportHash": "314800c84d344f10280c0d9a8a38bb22", "checkerName": "debug.Stats", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"line": 254, "col": 1, "file": 16}, "message": "sk_X509_INFO_new -> Total CFGBlocks: 3 | Unreachable CFGBlocks: 0 | Exhausted Block: no | Empty WorkList: yes"}], "macros": [], "notes": [], "path": "/usr/include/openssl/x509.h", "reportHash": "c439c51899eadc169a821d4e5b776e87", "checkerName": "debug.Stats", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"line": 254, "col": 1, "file": 16}, "message": "sk_X509_INFO_new_null -> Total CFGBlocks: 3 | Unreachable CFGBlocks: 0 | Exhausted Block: no | Empty WorkList: yes"}], "macros": [], "notes": [], "path": "/usr/include/openssl/x509.h", "reportHash": "467bb82b890edd4da3cb989cd26fff41", "checkerName": "debug.Stats", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"line": 254, "col": 1, "file": 16}, "message": "sk_X509_INFO_new_reserve -> Total CFGBlocks: 3 | Unreachable CFGBlocks: 0 | Exhausted Block: no | Empty WorkList: yes"}], "macros": [], "notes": [], "path": "/usr/include/openssl/x509.h", "reportHash": "c6cc9767f3565a872324fa4adfd0677e", "checkerName": "debug.Stats", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"line": 254, "col": 1, "file": 16}, "message": "sk_X509_INFO_reserve -> Total CFGBlocks: 3 | Unreachable CFGBlocks: 0 | Exhausted Block: no | Empty WorkList: yes"}], "macros": [], "notes": [], "path": "/usr/include/openssl/x509.h", "reportHash": "526f8c3383dea2370355a5c8f6613417", "checkerName": "debug.Stats", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"line": 254, "col": 1, "file": 16}, "message": "sk_X509_INFO_free -> Total CFGBlocks: 3 | Unreachable CFGBlocks: 0 | Exhausted Block: no | Empty WorkList: yes"}], "macros": [], "notes": [], "path": "/usr/include/openssl/x509.h", "reportHash": "2b3aee06c40206942e19f52404e9ed8f", "checkerName": "debug.Stats", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"line": 254, "col": 1, "file": 16}, "message": "sk_X509_INFO_zero -> Total CFGBlocks: 3 | Unreachable CFGBlocks: 0 | Exhausted Block: no | Empty WorkList: yes"}], "macros": [], "notes": [], "path": "/usr/include/openssl/x509.h", "reportHash": "b52c514e5aaebc622b1e9d94bb20d0da", "checkerName": "debug.Stats", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"line": 254, "col": 1, "file": 16}, "message": "sk_X509_INFO_delete -> Total CFGBlocks: 3 | Unreachable CFGBlocks: 0 | Exhausted Block: no | Empty WorkList: yes"}], "macros": [], "notes": [], "path": "/usr/include/openssl/x509.h", "reportHash": "fddf5ac623640c70082a3714476c2810", "checkerName": "debug.Stats", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"line": 254, "col": 1, "file": 16}, "message": "sk_X509_INFO_delete_ptr -> Total CFGBlocks: 3 | Unreachable CFGBlocks: 0 | Exhausted Block: no | Empty WorkList: yes"}], "macros": [], "notes": [], "path": "/usr/include/openssl/x509.h", "reportHash": "5b7a1e13ee971ea299fadcf1873dcc2f", "checkerName": "debug.Stats", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"line": 254, "col": 1, "file": 16}, "message": "sk_X509_INFO_push -> Total CFGBlocks: 3 | Unreachable CFGBlocks: 0 | Exhausted Block: no | Empty WorkList: yes"}], "macros": [], "notes": [], "path": "/usr/include/openssl/x509.h", "reportHash": "586400ed7f9bb8a80450832282503173", "checkerName": "debug.Stats", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"line": 254, "col": 1, "file": 16}, "message": "sk_X509_INFO_unshift -> Total CFGBlocks: 3 | Unreachable CFGBlocks: 0 | Exhausted Block: no | Empty WorkList: yes"}], "macros": [], "notes": [], "path": "/usr/include/openssl/x509.h", "reportHash": "b6507a475991ffb25cf6114c09b3348b", "checkerName": "debug.Stats", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"line": 254, "col": 1, "file": 16}, "message": "sk_X509_INFO_pop -> Total CFGBlocks: 3 | Unreachable CFGBlocks: 0 | Exhausted Block: no | Empty WorkList: yes"}], "macros": [], "notes": [], "path": "/usr/include/openssl/x509.h", "reportHash": "b734ee9507bfb9e402b36471a92d2d94", "checkerName": "debug.Stats", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"line": 254, "col": 1, "file": 16}, "message": "sk_X509_INFO_shift -> Total CFGBlocks: 3 | Unreachable CFGBlocks: 0 | Exhausted Block: no | Empty WorkList: yes"}], "macros": [], "notes": [], "path": "/usr/include/openssl/x509.h", "reportHash": "ca3f3f0c46f7ec1fb816ab37d59c87d7", "checkerName": "debug.Stats", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"line": 254, "col": 1, "file": 16}, "message": "sk_X509_INFO_pop_free -> Total CFGBlocks: 3 | Unreachable CFGBlocks: 0 | Exhausted Block: no | Empty WorkList: yes"}], "macros": [], "notes": [], "path": "/usr/include/openssl/x509.h", "reportHash": "e27a68c53142ecef3a0bfdaaa9b4ac0b", "checkerName": "debug.Stats", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"line": 254, "col": 1, "file": 16}, "message": "sk_X509_INFO_insert -> Total CFGBlocks: 3 | Unreachable CFGBlocks: 0 | Exhausted Block: no | Empty WorkList: yes"}], "macros": [], "notes": [], "path": "/usr/include/openssl/x509.h", "reportHash": "86271ae808ef0713d6fcb352628ecee1", "checkerName": "debug.Stats", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"line": 254, "col": 1, "file": 16}, "message": "sk_X509_INFO_set -> Total CFGBlocks: 3 | Unreachable CFGBlocks: 0 | Exhausted Block: no | Empty WorkList: yes"}], "macros": [], "notes": [], "path": "/usr/include/openssl/x509.h", "reportHash": "b0cac111323cdf5ea34483000c877ecc", "checkerName": "debug.Stats", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"line": 254, "col": 1, "file": 16}, "message": "sk_X509_INFO_find -> Total CFGBlocks: 3 | Unreachable CFGBlocks: 0 | Exhausted Block: no | Empty WorkList: yes"}], "macros": [], "notes": [], "path": "/usr/include/openssl/x509.h", "reportHash": "0a833b793aeb994768903d2d39562c8d", "checkerName": "debug.Stats", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"line": 254, "col": 1, "file": 16}, "message": "sk_X509_INFO_find_ex -> Total CFGBlocks: 3 | Unreachable CFGBlocks: 0 | Exhausted Block: no | Empty WorkList: yes"}], "macros": [], "notes": [], "path": "/usr/include/openssl/x509.h", "reportHash": "9e26d990de8e5477780331553a51ca2e", "checkerName": "debug.Stats", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"line": 254, "col": 1, "file": 16}, "message": "sk_X509_INFO_sort -> Total CFGBlocks: 3 | Unreachable CFGBlocks: 0 | Exhausted Block: no | Empty WorkList: yes"}], "macros": [], "notes": [], "path": "/usr/include/openssl/x509.h", "reportHash": "abf81997e092315eb025b41fceeff280", "checkerName": "debug.Stats", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"line": 254, "col": 1, "file": 16}, "message": "sk_X509_INFO_is_sorted -> Total CFGBlocks: 3 | Unreachable CFGBlocks: 0 | Exhausted Block: no | Empty WorkList: yes"}], "macros": [], "notes": [], "path": "/usr/include/openssl/x509.h", "reportHash": "688ddd7f644ce39a701a0821102cc201", "checkerName": "debug.Stats", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"line": 254, "col": 1, "file": 16}, "message": "sk_X509_INFO_dup -> Total CFGBlocks: 3 | Unreachable CFGBlocks: 0 | Exhausted Block: no | Empty WorkList: yes"}], "macros": [], "notes": [], "path": "/usr/include/openssl/x509.h", "reportHash": "db5730857a6cc099521bb37b1f5bf415", "checkerName": "debug.Stats", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"line": 254, "col": 1, "file": 16}, "message": "sk_X509_INFO_deep_copy -> Total CFGBlocks: 3 | Unreachable CFGBlocks: 0 | Exhausted Block: no | Empty WorkList: yes"}], "macros": [], "notes": [], "path": "/usr/include/openssl/x509.h", "reportHash": "a0353522d0754ff2680248082d5dcb28", "checkerName": "debug.Stats", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"line": 254, "col": 1, "file": 16}, "message": "sk_X509_INFO_set_cmp_func -> Total CFGBlocks: 3 | Unreachable CFGBlocks: 0 | Exhausted Block: no | Empty WorkList: yes"}], "macros": [], "notes": [], "path": "/usr/include/openssl/x509.h", "reportHash": "b47d2f7be8c6d59c7a9692b893db5434", "checkerName": "debug.Stats", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"line": 196, "col": 1, "file": 17}, "message": "lh_OPENSSL_STRING_new -> Total CFGBlocks: 3 | Unreachable CFGBlocks: 0 | Exhausted Block: no | Empty WorkList: yes"}], "macros": [], "notes": [], "path": "/usr/include/openssl/lhash.h", "reportHash": "4707577863261b1c4ac15b3d625a46bb", "checkerName": "debug.Stats", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"line": 196, "col": 1, "file": 17}, "message": "lh_OPENSSL_STRING_free -> Total CFGBlocks: 3 | Unreachable CFGBlocks: 0 | Exhausted Block: no | Empty WorkList: yes"}], "macros": [], "notes": [], "path": "/usr/include/openssl/lhash.h", "reportHash": "4d06645a30d0203ddfb2d3a30e3060e6", "checkerName": "debug.Stats", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"line": 196, "col": 1, "file": 17}, "message": "lh_OPENSSL_STRING_insert -> Total CFGBlocks: 3 | Unreachable CFGBlocks: 0 | Exhausted Block: no | Empty WorkList: yes"}], "macros": [], "notes": [], "path": "/usr/include/openssl/lhash.h", "reportHash": "775057305eb67ffca200f5b878cf1cb7", "checkerName": "debug.Stats", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"line": 196, "col": 1, "file": 17}, "message": "lh_OPENSSL_STRING_delete -> Total CFGBlocks: 3 | Unreachable CFGBlocks: 0 | Exhausted Block: no | Empty WorkList: yes"}], "macros": [], "notes": [], "path": "/usr/include/openssl/lhash.h", "reportHash": "2a195fbe9c21e02c906943e3d15d0281", "checkerName": "debug.Stats", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"line": 196, "col": 1, "file": 17}, "message": "lh_OPENSSL_STRING_retrieve -> Total CFGBlocks: 3 | Unreachable CFGBlocks: 0 | Exhausted Block: no | Empty WorkList: yes"}], "macros": [], "notes": [], "path": "/usr/include/openssl/lhash.h", "reportHash": "a74b1553b409d70d8be56224935eef2c", "checkerName": "debug.Stats", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"line": 196, "col": 1, "file": 17}, "message": "lh_OPENSSL_STRING_error -> Total CFGBlocks: 3 | Unreachable CFGBlocks: 0 | Exhausted Block: no | Empty WorkList: yes"}], "macros": [], "notes": [], "path": "/usr/include/openssl/lhash.h", "reportHash": "dbd453bb2779a4d56cc6e26fdec7eb35", "checkerName": "debug.Stats", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"line": 196, "col": 1, "file": 17}, "message": "lh_OPENSSL_STRING_num_items -> Total CFGBlocks: 3 | Unreachable CFGBlocks: 0 | Exhausted Block: no | Empty WorkList: yes"}], "macros": [], "notes": [], "path": "/usr/include/openssl/lhash.h", "reportHash": "5ae005fca7d205fcb1bf756158dd1308", "checkerName": "debug.Stats", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"line": 196, "col": 1, "file": 17}, "message": "lh_OPENSSL_STRING_node_stats_bio -> Total CFGBlocks: 3 | Unreachable CFGBlocks: 0 | Exhausted Block: no | Empty WorkList: yes"}], "macros": [], "notes": [], "path": "/usr/include/openssl/lhash.h", "reportHash": "0c68ba0dc1f4cb93d65e43100a2c61c8", "checkerName": "debug.Stats", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"line": 196, "col": 1, "file": 17}, "message": "lh_OPENSSL_STRING_node_usage_stats_bio -> Total CFGBlocks: 3 | Unreachable CFGBlocks: 0 | Exhausted Block: no | Empty WorkList: yes"}], "macros": [], "notes": [], "path": "/usr/include/openssl/lhash.h", "reportHash": "12efafc36177e6e798608168c7d081a7", "checkerName": "debug.Stats", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"line": 196, "col": 1, "file": 17}, "message": "lh_OPENSSL_STRING_stats_bio -> Total CFGBlocks: 3 | Unreachable CFGBlocks: 0 | Exhausted Block: no | Empty WorkList: yes"}], "macros": [], "notes": [], "path": "/usr/include/openssl/lhash.h", "reportHash": "71c5e00f7318bb74607aeee1aefa5662", "checkerName": "debug.Stats", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"line": 196, "col": 1, "file": 17}, "message": "lh_OPENSSL_STRING_get_down_load -> Total CFGBlocks: 3 | Unreachable CFGBlocks: 0 | Exhausted Block: no | Empty WorkList: yes"}], "macros": [], "notes": [], "path": "/usr/include/openssl/lhash.h", "reportHash": "14ae53ad64b9b9b3444a1aa38b9485c4", "checkerName": "debug.Stats", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"line": 196, "col": 1, "file": 17}, "message": "lh_OPENSSL_STRING_set_down_load -> Total CFGBlocks: 3 | Unreachable CFGBlocks: 0 | Exhausted Block: no | Empty WorkList: yes"}], "macros": [], "notes": [], "path": "/usr/include/openssl/lhash.h", "reportHash": "8a4d45a1c9114c5de04c93f320188769", "checkerName": "debug.Stats", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"line": 196, "col": 1, "file": 17}, "message": "lh_OPENSSL_STRING_doall -> Total CFGBlocks: 3 | Unreachable CFGBlocks: 0 | Exhausted Block: no | Empty WorkList: yes"}], "macros": [], "notes": [], "path": "/usr/include/openssl/lhash.h", "reportHash": "27e044f09d407f0d73fe24a15c5ce550", "checkerName": "debug.Stats", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"line": 206, "col": 1, "file": 17}, "message": "lh_OPENSSL_CSTRING_new -> Total CFGBlocks: 3 | Unreachable CFGBlocks: 0 | Exhausted Block: no | Empty WorkList: yes"}], "macros": [], "notes": [], "path": "/usr/include/openssl/lhash.h", "reportHash": "2443beb0468e185a05f6e41aa6f19488", "checkerName": "debug.Stats", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"line": 206, "col": 1, "file": 17}, "message": "lh_OPENSSL_CSTRING_free -> Total CFGBlocks: 3 | Unreachable CFGBlocks: 0 | Exhausted Block: no | Empty WorkList: yes"}], "macros": [], "notes": [], "path": "/usr/include/openssl/lhash.h", "reportHash": "97504eca0dd7568a8ebe120d4b98b522", "checkerName": "debug.Stats", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"line": 206, "col": 1, "file": 17}, "message": "lh_OPENSSL_CSTRING_insert -> Total CFGBlocks: 3 | Unreachable CFGBlocks: 0 | Exhausted Block: no | Empty WorkList: yes"}], "macros": [], "notes": [], "path": "/usr/include/openssl/lhash.h", "reportHash": "e8dd3988e7970527b1170a97124355cb", "checkerName": "debug.Stats", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"line": 206, "col": 1, "file": 17}, "message": "lh_OPENSSL_CSTRING_delete -> Total CFGBlocks: 3 | Unreachable CFGBlocks: 0 | Exhausted Block: no | Empty WorkList: yes"}], "macros": [], "notes": [], "path": "/usr/include/openssl/lhash.h", "reportHash": "2ba1dccfc71244b340524103c82e4627", "checkerName": "debug.Stats", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"line": 206, "col": 1, "file": 17}, "message": "lh_OPENSSL_CSTRING_retrieve -> Total CFGBlocks: 3 | Unreachable CFGBlocks: 0 | Exhausted Block: no | Empty WorkList: yes"}], "macros": [], "notes": [], "path": "/usr/include/openssl/lhash.h", "reportHash": "6f1f018abcba99a9f3528d7d4d3a7115", "checkerName": "debug.Stats", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"line": 206, "col": 1, "file": 17}, "message": "lh_OPENSSL_CSTRING_error -> Total CFGBlocks: 3 | Unreachable CFGBlocks: 0 | Exhausted Block: no | Empty WorkList: yes"}], "macros": [], "notes": [], "path": "/usr/include/openssl/lhash.h", "reportHash": "c9be6bc1ff852a22e55cb8848a92ab3c", "checkerName": "debug.Stats", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"line": 206, "col": 1, "file": 17}, "message": "lh_OPENSSL_CSTRING_num_items -> Total CFGBlocks: 3 | Unreachable CFGBlocks: 0 | Exhausted Block: no | Empty WorkList: yes"}], "macros": [], "notes": [], "path": "/usr/include/openssl/lhash.h", "reportHash": "5dae55db314b0ab83ab2b93ba45bbefc", "checkerName": "debug.Stats", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"line": 206, "col": 1, "file": 17}, "message": "lh_OPENSSL_CSTRING_node_stats_bio -> Total CFGBlocks: 3 | Unreachable CFGBlocks: 0 | Exhausted Block: no | Empty WorkList: yes"}], "macros": [], "notes": [], "path": "/usr/include/openssl/lhash.h", "reportHash": "a3776f381923773f405c00db3d9d78ab", "checkerName": "debug.Stats", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"line": 206, "col": 1, "file": 17}, "message": "lh_OPENSSL_CSTRING_node_usage_stats_bio -> Total CFGBlocks: 3 | Unreachable CFGBlocks: 0 | Exhausted Block: no | Empty WorkList: yes"}], "macros": [], "notes": [], "path": "/usr/include/openssl/lhash.h", "reportHash": "7f444437e5a884e0c0d453bb6a92e6c3", "checkerName": "debug.Stats", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"line": 206, "col": 1, "file": 17}, "message": "lh_OPENSSL_CSTRING_stats_bio -> Total CFGBlocks: 3 | Unreachable CFGBlocks: 0 | Exhausted Block: no | Empty WorkList: yes"}], "macros": [], "notes": [], "path": "/usr/include/openssl/lhash.h", "reportHash": "9d0a0b572b2f87742eaa0f6b696e39b1", "checkerName": "debug.Stats", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"line": 206, "col": 1, "file": 17}, "message": "lh_OPENSSL_CSTRING_get_down_load -> Total CFGBlocks: 3 | Unreachable CFGBlocks: 0 | Exhausted Block: no | Empty WorkList: yes"}], "macros": [], "notes": [], "path": "/usr/include/openssl/lhash.h", "reportHash": "5dfb513f19033e3c0b10e5dfe89067e6", "checkerName": "debug.Stats", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"line": 206, "col": 1, "file": 17}, "message": "lh_OPENSSL_CSTRING_set_down_load -> Total CFGBlocks: 3 | Unreachable CFGBlocks: 0 | Exhausted Block: no | Empty WorkList: yes"}], "macros": [], "notes": [], "path": "/usr/include/openssl/lhash.h", "reportHash": "2db7f834a8354061d6f0bb84b608cb73", "checkerName": "debug.Stats", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"line": 206, "col": 1, "file": 17}, "message": "lh_OPENSSL_CSTRING_doall -> Total CFGBlocks: 3 | Unreachable CFGBlocks: 0 | Exhausted Block: no | Empty WorkList: yes"}], "macros": [], "notes": [], "path": "/usr/include/openssl/lhash.h", "reportHash": "a304a80674fdfd36a5d99cfd3aed4c78", "checkerName": "debug.Stats", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"line": 57, "col": 1, "file": 18}, "message": "sk_X509_LOOKUP_num -> Total CFGBlocks: 3 | Unreachable CFGBlocks: 0 | Exhausted Block: no | Empty WorkList: yes"}], "macros": [], "notes": [], "path": "/usr/include/openssl/x509_vfy.h", "reportHash": "66abfa56342c1029590ff564f947239c", "checkerName": "debug.Stats", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"line": 57, "col": 1, "file": 18}, "message": "sk_X509_LOOKUP_value -> Total CFGBlocks: 3 | Unreachable CFGBlocks: 0 | Exhausted Block: no | Empty WorkList: yes"}], "macros": [], "notes": [], "path": "/usr/include/openssl/x509_vfy.h", "reportHash": "95ac7a9e40f0da35f1a102734ada707d", "checkerName": "debug.Stats", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"line": 57, "col": 1, "file": 18}, "message": "sk_X509_LOOKUP_new -> Total CFGBlocks: 3 | Unreachable CFGBlocks: 0 | Exhausted Block: no | Empty WorkList: yes"}], "macros": [], "notes": [], "path": "/usr/include/openssl/x509_vfy.h", "reportHash": "21654ece82d502901fee6a72bb35fa3e", "checkerName": "debug.Stats", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"line": 57, "col": 1, "file": 18}, "message": "sk_X509_LOOKUP_new_null -> Total CFGBlocks: 3 | Unreachable CFGBlocks: 0 | Exhausted Block: no | Empty WorkList: yes"}], "macros": [], "notes": [], "path": "/usr/include/openssl/x509_vfy.h", "reportHash": "d89f370378f528e231b029271f37b040", "checkerName": "debug.Stats", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"line": 57, "col": 1, "file": 18}, "message": "sk_X509_LOOKUP_new_reserve -> Total CFGBlocks: 3 | Unreachable CFGBlocks: 0 | Exhausted Block: no | Empty WorkList: yes"}], "macros": [], "notes": [], "path": "/usr/include/openssl/x509_vfy.h", "reportHash": "0c91471593f4821a3d526c2ee1b69d12", "checkerName": "debug.Stats", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"line": 57, "col": 1, "file": 18}, "message": "sk_X509_LOOKUP_reserve -> Total CFGBlocks: 3 | Unreachable CFGBlocks: 0 | Exhausted Block: no | Empty WorkList: yes"}], "macros": [], "notes": [], "path": "/usr/include/openssl/x509_vfy.h", "reportHash": "487a694342ad910d97f09e2470366dc4", "checkerName": "debug.Stats", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"line": 57, "col": 1, "file": 18}, "message": "sk_X509_LOOKUP_free -> Total CFGBlocks: 3 | Unreachable CFGBlocks: 0 | Exhausted Block: no | Empty WorkList: yes"}], "macros": [], "notes": [], "path": "/usr/include/openssl/x509_vfy.h", "reportHash": "70bd7b3ee730081e52f60c5dfde55654", "checkerName": "debug.Stats", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"line": 57, "col": 1, "file": 18}, "message": "sk_X509_LOOKUP_zero -> Total CFGBlocks: 3 | Unreachable CFGBlocks: 0 | Exhausted Block: no | Empty WorkList: yes"}], "macros": [], "notes": [], "path": "/usr/include/openssl/x509_vfy.h", "reportHash": "8be6ff7ab7a8e71a6ebfbddb5bb816d2", "checkerName": "debug.Stats", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"line": 57, "col": 1, "file": 18}, "message": "sk_X509_LOOKUP_delete -> Total CFGBlocks: 3 | Unreachable CFGBlocks: 0 | Exhausted Block: no | Empty WorkList: yes"}], "macros": [], "notes": [], "path": "/usr/include/openssl/x509_vfy.h", "reportHash": "c07b0ee4a061e599b6a2da1fce424e47", "checkerName": "debug.Stats", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"line": 57, "col": 1, "file": 18}, "message": "sk_X509_LOOKUP_delete_ptr -> Total CFGBlocks: 3 | Unreachable CFGBlocks: 0 | Exhausted Block: no | Empty WorkList: yes"}], "macros": [], "notes": [], "path": "/usr/include/openssl/x509_vfy.h", "reportHash": "454229b9be520cb35dcf8b4f7dac6c60", "checkerName": "debug.Stats", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"line": 57, "col": 1, "file": 18}, "message": "sk_X509_LOOKUP_push -> Total CFGBlocks: 3 | Unreachable CFGBlocks: 0 | Exhausted Block: no | Empty WorkList: yes"}], "macros": [], "notes": [], "path": "/usr/include/openssl/x509_vfy.h", "reportHash": "ef9d678efe9d4901abb3f59803e65d2d", "checkerName": "debug.Stats", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"line": 57, "col": 1, "file": 18}, "message": "sk_X509_LOOKUP_unshift -> Total CFGBlocks: 3 | Unreachable CFGBlocks: 0 | Exhausted Block: no | Empty WorkList: yes"}], "macros": [], "notes": [], "path": "/usr/include/openssl/x509_vfy.h", "reportHash": "d598b6a91062183863393221e1b28089", "checkerName": "debug.Stats", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"line": 57, "col": 1, "file": 18}, "message": "sk_X509_LOOKUP_pop -> Total CFGBlocks: 3 | Unreachable CFGBlocks: 0 | Exhausted Block: no | Empty WorkList: yes"}], "macros": [], "notes": [], "path": "/usr/include/openssl/x509_vfy.h", "reportHash": "45ca2dc7f6c832b7becd121c04f4070d", "checkerName": "debug.Stats", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"line": 57, "col": 1, "file": 18}, "message": "sk_X509_LOOKUP_shift -> Total CFGBlocks: 3 | Unreachable CFGBlocks: 0 | Exhausted Block: no | Empty WorkList: yes"}], "macros": [], "notes": [], "path": "/usr/include/openssl/x509_vfy.h", "reportHash": "32ab12c9eddb54639b2b07edf37cdc4d", "checkerName": "debug.Stats", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"line": 57, "col": 1, "file": 18}, "message": "sk_X509_LOOKUP_pop_free -> Total CFGBlocks: 3 | Unreachable CFGBlocks: 0 | Exhausted Block: no | Empty WorkList: yes"}], "macros": [], "notes": [], "path": "/usr/include/openssl/x509_vfy.h", "reportHash": "f3832447e86bf291bd2f3a50fc509c6f", "checkerName": "debug.Stats", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"line": 57, "col": 1, "file": 18}, "message": "sk_X509_LOOKUP_insert -> Total CFGBlocks: 3 | Unreachable CFGBlocks: 0 | Exhausted Block: no | Empty WorkList: yes"}], "macros": [], "notes": [], "path": "/usr/include/openssl/x509_vfy.h", "reportHash": "1d49aa037a5a27a314088726f78e1884", "checkerName": "debug.Stats", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"line": 57, "col": 1, "file": 18}, "message": "sk_X509_LOOKUP_set -> Total CFGBlocks: 3 | Unreachable CFGBlocks: 0 | Exhausted Block: no | Empty WorkList: yes"}], "macros": [], "notes": [], "path": "/usr/include/openssl/x509_vfy.h", "reportHash": "615997d5d77c3d9f1aa1b064fd0fb4bc", "checkerName": "debug.Stats", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"line": 57, "col": 1, "file": 18}, "message": "sk_X509_LOOKUP_find -> Total CFGBlocks: 3 | Unreachable CFGBlocks: 0 | Exhausted Block: no | Empty WorkList: yes"}], "macros": [], "notes": [], "path": "/usr/include/openssl/x509_vfy.h", "reportHash": "6407d58d9bef65cf5701ad48bbc42bc3", "checkerName": "debug.Stats", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"line": 57, "col": 1, "file": 18}, "message": "sk_X509_LOOKUP_find_ex -> Total CFGBlocks: 3 | Unreachable CFGBlocks: 0 | Exhausted Block: no | Empty WorkList: yes"}], "macros": [], "notes": [], "path": "/usr/include/openssl/x509_vfy.h", "reportHash": "3e2ef73911451baceb8fa0ccae9fe6cd", "checkerName": "debug.Stats", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"line": 57, "col": 1, "file": 18}, "message": "sk_X509_LOOKUP_sort -> Total CFGBlocks: 3 | Unreachable CFGBlocks: 0 | Exhausted Block: no | Empty WorkList: yes"}], "macros": [], "notes": [], "path": "/usr/include/openssl/x509_vfy.h", "reportHash": "2c29c06cfd6bcc873e188d0cc1e8ff88", "checkerName": "debug.Stats", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"line": 57, "col": 1, "file": 18}, "message": "sk_X509_LOOKUP_is_sorted -> Total CFGBlocks: 3 | Unreachable CFGBlocks: 0 | Exhausted Block: no | Empty WorkList: yes"}], "macros": [], "notes": [], "path": "/usr/include/openssl/x509_vfy.h", "reportHash": "31abc22542fb1daccb077ba25088c08b", "checkerName": "debug.Stats", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"line": 57, "col": 1, "file": 18}, "message": "sk_X509_LOOKUP_dup -> Total CFGBlocks: 3 | Unreachable CFGBlocks: 0 | Exhausted Block: no | Empty WorkList: yes"}], "macros": [], "notes": [], "path": "/usr/include/openssl/x509_vfy.h", "reportHash": "2bb96a2b269137d0e38b4f33f9bcd30a", "checkerName": "debug.Stats", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"line": 57, "col": 1, "file": 18}, "message": "sk_X509_LOOKUP_deep_copy -> Total CFGBlocks: 3 | Unreachable CFGBlocks: 0 | Exhausted Block: no | Empty WorkList: yes"}], "macros": [], "notes": [], "path": "/usr/include/openssl/x509_vfy.h", "reportHash": "99faa989cbca900858f055514f86dfa3", "checkerName": "debug.Stats", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"line": 57, "col": 1, "file": 18}, "message": "sk_X509_LOOKUP_set_cmp_func -> Total CFGBlocks: 3 | Unreachable CFGBlocks: 0 | Exhausted Block: no | Empty WorkList: yes"}], "macros": [], "notes": [], "path": "/usr/include/openssl/x509_vfy.h", "reportHash": "d2cbc33260f1db94d1a4407fa384bf5a", "checkerName": "debug.Stats", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"line": 58, "col": 1, "file": 18}, "message": "sk_X509_OBJECT_num -> Total CFGBlocks: 3 | Unreachable CFGBlocks: 0 | Exhausted Block: no | Empty WorkList: yes"}], "macros": [], "notes": [], "path": "/usr/include/openssl/x509_vfy.h", "reportHash": "74cd3a263b017b10d6dcf712dda1f686", "checkerName": "debug.Stats", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"line": 58, "col": 1, "file": 18}, "message": "sk_X509_OBJECT_value -> Total CFGBlocks: 3 | Unreachable CFGBlocks: 0 | Exhausted Block: no | Empty WorkList: yes"}], "macros": [], "notes": [], "path": "/usr/include/openssl/x509_vfy.h", "reportHash": "c650e802458bf162528714226bb79980", "checkerName": "debug.Stats", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"line": 58, "col": 1, "file": 18}, "message": "sk_X509_OBJECT_new -> Total CFGBlocks: 3 | Unreachable CFGBlocks: 0 | Exhausted Block: no | Empty WorkList: yes"}], "macros": [], "notes": [], "path": "/usr/include/openssl/x509_vfy.h", "reportHash": "16a12f787c33e3aa60009c652b89fcc2", "checkerName": "debug.Stats", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"line": 58, "col": 1, "file": 18}, "message": "sk_X509_OBJECT_new_null -> Total CFGBlocks: 3 | Unreachable CFGBlocks: 0 | Exhausted Block: no | Empty WorkList: yes"}], "macros": [], "notes": [], "path": "/usr/include/openssl/x509_vfy.h", "reportHash": "5c76fb9405d9fe009e46b5c21892ad91", "checkerName": "debug.Stats", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"line": 58, "col": 1, "file": 18}, "message": "sk_X509_OBJECT_new_reserve -> Total CFGBlocks: 3 | Unreachable CFGBlocks: 0 | Exhausted Block: no | Empty WorkList: yes"}], "macros": [], "notes": [], "path": "/usr/include/openssl/x509_vfy.h", "reportHash": "9f4ccbcbac508b4272a498428ba66e6f", "checkerName": "debug.Stats", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"line": 58, "col": 1, "file": 18}, "message": "sk_X509_OBJECT_reserve -> Total CFGBlocks: 3 | Unreachable CFGBlocks: 0 | Exhausted Block: no | Empty WorkList: yes"}], "macros": [], "notes": [], "path": "/usr/include/openssl/x509_vfy.h", "reportHash": "42c673d0e495d9d9e0d26a743c20e558", "checkerName": "debug.Stats", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"line": 58, "col": 1, "file": 18}, "message": "sk_X509_OBJECT_free -> Total CFGBlocks: 3 | Unreachable CFGBlocks: 0 | Exhausted Block: no | Empty WorkList: yes"}], "macros": [], "notes": [], "path": "/usr/include/openssl/x509_vfy.h", "reportHash": "e025e06adb314366a3b7cfb0b0c258c6", "checkerName": "debug.Stats", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"line": 58, "col": 1, "file": 18}, "message": "sk_X509_OBJECT_zero -> Total CFGBlocks: 3 | Unreachable CFGBlocks: 0 | Exhausted Block: no | Empty WorkList: yes"}], "macros": [], "notes": [], "path": "/usr/include/openssl/x509_vfy.h", "reportHash": "201e1116887a09880cc0b40c6adc7a9b", "checkerName": "debug.Stats", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"line": 58, "col": 1, "file": 18}, "message": "sk_X509_OBJECT_delete -> Total CFGBlocks: 3 | Unreachable CFGBlocks: 0 | Exhausted Block: no | Empty WorkList: yes"}], "macros": [], "notes": [], "path": "/usr/include/openssl/x509_vfy.h", "reportHash": "54404a62beb32b9ffdd9c8f40aa1156e", "checkerName": "debug.Stats", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"line": 58, "col": 1, "file": 18}, "message": "sk_X509_OBJECT_delete_ptr -> Total CFGBlocks: 3 | Unreachable CFGBlocks: 0 | Exhausted Block: no | Empty WorkList: yes"}], "macros": [], "notes": [], "path": "/usr/include/openssl/x509_vfy.h", "reportHash": "33bb9fa9ca3f15c00469663ab12779c3", "checkerName": "debug.Stats", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"line": 58, "col": 1, "file": 18}, "message": "sk_X509_OBJECT_push -> Total CFGBlocks: 3 | Unreachable CFGBlocks: 0 | Exhausted Block: no | Empty WorkList: yes"}], "macros": [], "notes": [], "path": "/usr/include/openssl/x509_vfy.h", "reportHash": "86c8550d963bd60ab46d3bcebc1186b7", "checkerName": "debug.Stats", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"line": 58, "col": 1, "file": 18}, "message": "sk_X509_OBJECT_unshift -> Total CFGBlocks: 3 | Unreachable CFGBlocks: 0 | Exhausted Block: no | Empty WorkList: yes"}], "macros": [], "notes": [], "path": "/usr/include/openssl/x509_vfy.h", "reportHash": "3c47759537acbb3058efb9f805fe03e9", "checkerName": "debug.Stats", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"line": 58, "col": 1, "file": 18}, "message": "sk_X509_OBJECT_pop -> Total CFGBlocks: 3 | Unreachable CFGBlocks: 0 | Exhausted Block: no | Empty WorkList: yes"}], "macros": [], "notes": [], "path": "/usr/include/openssl/x509_vfy.h", "reportHash": "e59cb82087c0df458e83e430d0d22035", "checkerName": "debug.Stats", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"line": 58, "col": 1, "file": 18}, "message": "sk_X509_OBJECT_shift -> Total CFGBlocks: 3 | Unreachable CFGBlocks: 0 | Exhausted Block: no | Empty WorkList: yes"}], "macros": [], "notes": [], "path": "/usr/include/openssl/x509_vfy.h", "reportHash": "2d4579086b70a70e74b99e163b5fec54", "checkerName": "debug.Stats", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"line": 58, "col": 1, "file": 18}, "message": "sk_X509_OBJECT_pop_free -> Total CFGBlocks: 3 | Unreachable CFGBlocks: 0 | Exhausted Block: no | Empty WorkList: yes"}], "macros": [], "notes": [], "path": "/usr/include/openssl/x509_vfy.h", "reportHash": "8562f7de1afaba8fc1d2b34db34601fb", "checkerName": "debug.Stats", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"line": 58, "col": 1, "file": 18}, "message": "sk_X509_OBJECT_insert -> Total CFGBlocks: 3 | Unreachable CFGBlocks: 0 | Exhausted Block: no | Empty WorkList: yes"}], "macros": [], "notes": [], "path": "/usr/include/openssl/x509_vfy.h", "reportHash": "c731e2414a5c36df0c646eff171e2b3f", "checkerName": "debug.Stats", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"line": 58, "col": 1, "file": 18}, "message": "sk_X509_OBJECT_set -> Total CFGBlocks: 3 | Unreachable CFGBlocks: 0 | Exhausted Block: no | Empty WorkList: yes"}], "macros": [], "notes": [], "path": "/usr/include/openssl/x509_vfy.h", "reportHash": "2d34210de94409a32bf27f9c87a3e024", "checkerName": "debug.Stats", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"line": 58, "col": 1, "file": 18}, "message": "sk_X509_OBJECT_find -> Total CFGBlocks: 3 | Unreachable CFGBlocks: 0 | Exhausted Block: no | Empty WorkList: yes"}], "macros": [], "notes": [], "path": "/usr/include/openssl/x509_vfy.h", "reportHash": "c07ed23afb199292bbe5be58568c0681", "checkerName": "debug.Stats", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"line": 58, "col": 1, "file": 18}, "message": "sk_X509_OBJECT_find_ex -> Total CFGBlocks: 3 | Unreachable CFGBlocks: 0 | Exhausted Block: no | Empty WorkList: yes"}], "macros": [], "notes": [], "path": "/usr/include/openssl/x509_vfy.h", "reportHash": "bcc3f40a2719c57a62271838c4055ff6", "checkerName": "debug.Stats", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"line": 58, "col": 1, "file": 18}, "message": "sk_X509_OBJECT_sort -> Total CFGBlocks: 3 | Unreachable CFGBlocks: 0 | Exhausted Block: no | Empty WorkList: yes"}], "macros": [], "notes": [], "path": "/usr/include/openssl/x509_vfy.h", "reportHash": "c8a4e3a6e7b0fb22d32ba9a495bb23c2", "checkerName": "debug.Stats", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"line": 58, "col": 1, "file": 18}, "message": "sk_X509_OBJECT_is_sorted -> Total CFGBlocks: 3 | Unreachable CFGBlocks: 0 | Exhausted Block: no | Empty WorkList: yes"}], "macros": [], "notes": [], "path": "/usr/include/openssl/x509_vfy.h", "reportHash": "6f36aef72cb51a037d5bbeb66a1111f8", "checkerName": "debug.Stats", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"line": 58, "col": 1, "file": 18}, "message": "sk_X509_OBJECT_dup -> Total CFGBlocks: 3 | Unreachable CFGBlocks: 0 | Exhausted Block: no | Empty WorkList: yes"}], "macros": [], "notes": [], "path": "/usr/include/openssl/x509_vfy.h", "reportHash": "da0e1c9d8a7d786c3144f6670a4c5d2d", "checkerName": "debug.Stats", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"line": 58, "col": 1, "file": 18}, "message": "sk_X509_OBJECT_deep_copy -> Total CFGBlocks: 3 | Unreachable CFGBlocks: 0 | Exhausted Block: no | Empty WorkList: yes"}], "macros": [], "notes": [], "path": "/usr/include/openssl/x509_vfy.h", "reportHash": "280a2229e27e27e62c51e1c77c03bdfd", "checkerName": "debug.Stats", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"line": 58, "col": 1, "file": 18}, "message": "sk_X509_OBJECT_set_cmp_func -> Total CFGBlocks: 3 | Unreachable CFGBlocks: 0 | Exhausted Block: no | Empty WorkList: yes"}], "macros": [], "notes": [], "path": "/usr/include/openssl/x509_vfy.h", "reportHash": "6c2fec7e19433a3fc94acedf636984aa", "checkerName": "debug.Stats", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"line": 59, "col": 1, "file": 18}, "message": "sk_X509_VERIFY_PARAM_num -> Total CFGBlocks: 3 | Unreachable CFGBlocks: 0 | Exhausted Block: no | Empty WorkList: yes"}], "macros": [], "notes": [], "path": "/usr/include/openssl/x509_vfy.h", "reportHash": "7214ea5c330bf94a71259741fa6417ae", "checkerName": "debug.Stats", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"line": 59, "col": 1, "file": 18}, "message": "sk_X509_VERIFY_PARAM_value -> Total CFGBlocks: 3 | Unreachable CFGBlocks: 0 | Exhausted Block: no | Empty WorkList: yes"}], "macros": [], "notes": [], "path": "/usr/include/openssl/x509_vfy.h", "reportHash": "6e3b871d5222f660ff169be56777efaf", "checkerName": "debug.Stats", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"line": 59, "col": 1, "file": 18}, "message": "sk_X509_VERIFY_PARAM_new -> Total CFGBlocks: 3 | Unreachable CFGBlocks: 0 | Exhausted Block: no | Empty WorkList: yes"}], "macros": [], "notes": [], "path": "/usr/include/openssl/x509_vfy.h", "reportHash": "51a94a501bcf055133f02df381ce0226", "checkerName": "debug.Stats", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"line": 59, "col": 1, "file": 18}, "message": "sk_X509_VERIFY_PARAM_new_null -> Total CFGBlocks: 3 | Unreachable CFGBlocks: 0 | Exhausted Block: no | Empty WorkList: yes"}], "macros": [], "notes": [], "path": "/usr/include/openssl/x509_vfy.h", "reportHash": "a52082b3035b10b17dbc08e3222d8fb5", "checkerName": "debug.Stats", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"line": 59, "col": 1, "file": 18}, "message": "sk_X509_VERIFY_PARAM_new_reserve -> Total CFGBlocks: 3 | Unreachable CFGBlocks: 0 | Exhausted Block: no | Empty WorkList: yes"}], "macros": [], "notes": [], "path": "/usr/include/openssl/x509_vfy.h", "reportHash": "020662452412c98969aad45b948ba595", "checkerName": "debug.Stats", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"line": 59, "col": 1, "file": 18}, "message": "sk_X509_VERIFY_PARAM_reserve -> Total CFGBlocks: 3 | Unreachable CFGBlocks: 0 | Exhausted Block: no | Empty WorkList: yes"}], "macros": [], "notes": [], "path": "/usr/include/openssl/x509_vfy.h", "reportHash": "21e9f1ee52258dba2926d00710853eeb", "checkerName": "debug.Stats", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"line": 59, "col": 1, "file": 18}, "message": "sk_X509_VERIFY_PARAM_free -> Total CFGBlocks: 3 | Unreachable CFGBlocks: 0 | Exhausted Block: no | Empty WorkList: yes"}], "macros": [], "notes": [], "path": "/usr/include/openssl/x509_vfy.h", "reportHash": "5395d78993c649557e02a978822f7c46", "checkerName": "debug.Stats", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"line": 59, "col": 1, "file": 18}, "message": "sk_X509_VERIFY_PARAM_zero -> Total CFGBlocks: 3 | Unreachable CFGBlocks: 0 | Exhausted Block: no | Empty WorkList: yes"}], "macros": [], "notes": [], "path": "/usr/include/openssl/x509_vfy.h", "reportHash": "70f6296d307c60833888f366d6d58850", "checkerName": "debug.Stats", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"line": 59, "col": 1, "file": 18}, "message": "sk_X509_VERIFY_PARAM_delete -> Total CFGBlocks: 3 | Unreachable CFGBlocks: 0 | Exhausted Block: no | Empty WorkList: yes"}], "macros": [], "notes": [], "path": "/usr/include/openssl/x509_vfy.h", "reportHash": "0226f53bdaee27540fb3b7e5740eaf00", "checkerName": "debug.Stats", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"line": 59, "col": 1, "file": 18}, "message": "sk_X509_VERIFY_PARAM_delete_ptr -> Total CFGBlocks: 3 | Unreachable CFGBlocks: 0 | Exhausted Block: no | Empty WorkList: yes"}], "macros": [], "notes": [], "path": "/usr/include/openssl/x509_vfy.h", "reportHash": "050ba104d0e8d220ff0c8a1f2cfa8eb5", "checkerName": "debug.Stats", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"line": 59, "col": 1, "file": 18}, "message": "sk_X509_VERIFY_PARAM_push -> Total CFGBlocks: 3 | Unreachable CFGBlocks: 0 | Exhausted Block: no | Empty WorkList: yes"}], "macros": [], "notes": [], "path": "/usr/include/openssl/x509_vfy.h", "reportHash": "00434d2c41651dd5d6fd47747c9fab3e", "checkerName": "debug.Stats", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"line": 59, "col": 1, "file": 18}, "message": "sk_X509_VERIFY_PARAM_unshift -> Total CFGBlocks: 3 | Unreachable CFGBlocks: 0 | Exhausted Block: no | Empty WorkList: yes"}], "macros": [], "notes": [], "path": "/usr/include/openssl/x509_vfy.h", "reportHash": "6d8df80f41bf70e654fc8f271b581161", "checkerName": "debug.Stats", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"line": 59, "col": 1, "file": 18}, "message": "sk_X509_VERIFY_PARAM_pop -> Total CFGBlocks: 3 | Unreachable CFGBlocks: 0 | Exhausted Block: no | Empty WorkList: yes"}], "macros": [], "notes": [], "path": "/usr/include/openssl/x509_vfy.h", "reportHash": "511a9a0ab126c201df536b44393e424d", "checkerName": "debug.Stats", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"line": 59, "col": 1, "file": 18}, "message": "sk_X509_VERIFY_PARAM_shift -> Total CFGBlocks: 3 | Unreachable CFGBlocks: 0 | Exhausted Block: no | Empty WorkList: yes"}], "macros": [], "notes": [], "path": "/usr/include/openssl/x509_vfy.h", "reportHash": "2b6235e0672c58f03c82e8a6c918c610", "checkerName": "debug.Stats", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"line": 59, "col": 1, "file": 18}, "message": "sk_X509_VERIFY_PARAM_pop_free -> Total CFGBlocks: 3 | Unreachable CFGBlocks: 0 | Exhausted Block: no | Empty WorkList: yes"}], "macros": [], "notes": [], "path": "/usr/include/openssl/x509_vfy.h", "reportHash": "ba1d99ebc5110fbdee45c473c9e1877c", "checkerName": "debug.Stats", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"line": 59, "col": 1, "file": 18}, "message": "sk_X509_VERIFY_PARAM_insert -> Total CFGBlocks: 3 | Unreachable CFGBlocks: 0 | Exhausted Block: no | Empty WorkList: yes"}], "macros": [], "notes": [], "path": "/usr/include/openssl/x509_vfy.h", "reportHash": "259c00fe8204819f543c4eff897e11e3", "checkerName": "debug.Stats", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"line": 59, "col": 1, "file": 18}, "message": "sk_X509_VERIFY_PARAM_set -> Total CFGBlocks: 3 | Unreachable CFGBlocks: 0 | Exhausted Block: no | Empty WorkList: yes"}], "macros": [], "notes": [], "path": "/usr/include/openssl/x509_vfy.h", "reportHash": "ec780131d91628144808642d641bea9c", "checkerName": "debug.Stats", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"line": 59, "col": 1, "file": 18}, "message": "sk_X509_VERIFY_PARAM_find -> Total CFGBlocks: 3 | Unreachable CFGBlocks: 0 | Exhausted Block: no | Empty WorkList: yes"}], "macros": [], "notes": [], "path": "/usr/include/openssl/x509_vfy.h", "reportHash": "3d388a897d2a3a472349fce61eb9fe4b", "checkerName": "debug.Stats", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"line": 59, "col": 1, "file": 18}, "message": "sk_X509_VERIFY_PARAM_find_ex -> Total CFGBlocks: 3 | Unreachable CFGBlocks: 0 | Exhausted Block: no | Empty WorkList: yes"}], "macros": [], "notes": [], "path": "/usr/include/openssl/x509_vfy.h", "reportHash": "19924f28ed4ac71b143a90515b447447", "checkerName": "debug.Stats", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"line": 59, "col": 1, "file": 18}, "message": "sk_X509_VERIFY_PARAM_sort -> Total CFGBlocks: 3 | Unreachable CFGBlocks: 0 | Exhausted Block: no | Empty WorkList: yes"}], "macros": [], "notes": [], "path": "/usr/include/openssl/x509_vfy.h", "reportHash": "bc99540ac88102010cc1d183b175e264", "checkerName": "debug.Stats", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"line": 59, "col": 1, "file": 18}, "message": "sk_X509_VERIFY_PARAM_is_sorted -> Total CFGBlocks: 3 | Unreachable CFGBlocks: 0 | Exhausted Block: no | Empty WorkList: yes"}], "macros": [], "notes": [], "path": "/usr/include/openssl/x509_vfy.h", "reportHash": "f5afac7e7e2df87f91a769af75880940", "checkerName": "debug.Stats", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"line": 59, "col": 1, "file": 18}, "message": "sk_X509_VERIFY_PARAM_dup -> Total CFGBlocks: 3 | Unreachable CFGBlocks: 0 | Exhausted Block: no | Empty WorkList: yes"}], "macros": [], "notes": [], "path": "/usr/include/openssl/x509_vfy.h", "reportHash": "ba59a32b3941895facf9d4db52f7dadf", "checkerName": "debug.Stats", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"line": 59, "col": 1, "file": 18}, "message": "sk_X509_VERIFY_PARAM_deep_copy -> Total CFGBlocks: 3 | Unreachable CFGBlocks: 0 | Exhausted Block: no | Empty WorkList: yes"}], "macros": [], "notes": [], "path": "/usr/include/openssl/x509_vfy.h", "reportHash": "91cb87864dea319845f289cea571ab27", "checkerName": "debug.Stats", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"line": 59, "col": 1, "file": 18}, "message": "sk_X509_VERIFY_PARAM_set_cmp_func -> Total CFGBlocks: 3 | Unreachable CFGBlocks: 0 | Exhausted Block: no | Empty WorkList: yes"}], "macros": [], "notes": [], "path": "/usr/include/openssl/x509_vfy.h", "reportHash": "32894056d22de0feda20eb44d4065d77", "checkerName": "debug.Stats", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"line": 49, "col": 1, "file": 19}, "message": "sk_PKCS7_SIGNER_INFO_num -> Total CFGBlocks: 3 | Unreachable CFGBlocks: 0 | Exhausted Block: no | Empty WorkList: yes"}], "macros": [], "notes": [], "path": "/usr/include/openssl/pkcs7.h", "reportHash": "5859fbfbe39fd61ff77ae2e75a5de49c", "checkerName": "debug.Stats", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"line": 49, "col": 1, "file": 19}, "message": "sk_PKCS7_SIGNER_INFO_value -> Total CFGBlocks: 3 | Unreachable CFGBlocks: 0 | Exhausted Block: no | Empty WorkList: yes"}], "macros": [], "notes": [], "path": "/usr/include/openssl/pkcs7.h", "reportHash": "6bdc47f7ab4c0b2595d534592aa71809", "checkerName": "debug.Stats", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"line": 49, "col": 1, "file": 19}, "message": "sk_PKCS7_SIGNER_INFO_new -> Total CFGBlocks: 3 | Unreachable CFGBlocks: 0 | Exhausted Block: no | Empty WorkList: yes"}], "macros": [], "notes": [], "path": "/usr/include/openssl/pkcs7.h", "reportHash": "0f2e5f96634c0648fcebbedec84077f8", "checkerName": "debug.Stats", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"line": 49, "col": 1, "file": 19}, "message": "sk_PKCS7_SIGNER_INFO_new_null -> Total CFGBlocks: 3 | Unreachable CFGBlocks: 0 | Exhausted Block: no | Empty WorkList: yes"}], "macros": [], "notes": [], "path": "/usr/include/openssl/pkcs7.h", "reportHash": "5d5d5f2eace004a6a28119e74bc8a4ea", "checkerName": "debug.Stats", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"line": 49, "col": 1, "file": 19}, "message": "sk_PKCS7_SIGNER_INFO_new_reserve -> Total CFGBlocks: 3 | Unreachable CFGBlocks: 0 | Exhausted Block: no | Empty WorkList: yes"}], "macros": [], "notes": [], "path": "/usr/include/openssl/pkcs7.h", "reportHash": "83a13733a91024bedaa207488548f920", "checkerName": "debug.Stats", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"line": 49, "col": 1, "file": 19}, "message": "sk_PKCS7_SIGNER_INFO_reserve -> Total CFGBlocks: 3 | Unreachable CFGBlocks: 0 | Exhausted Block: no | Empty WorkList: yes"}], "macros": [], "notes": [], "path": "/usr/include/openssl/pkcs7.h", "reportHash": "e5428234974172c1a85e6a40300e21ec", "checkerName": "debug.Stats", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"line": 49, "col": 1, "file": 19}, "message": "sk_PKCS7_SIGNER_INFO_free -> Total CFGBlocks: 3 | Unreachable CFGBlocks: 0 | Exhausted Block: no | Empty WorkList: yes"}], "macros": [], "notes": [], "path": "/usr/include/openssl/pkcs7.h", "reportHash": "2a9f3a3ba380a8c19b00b9225d9dadc3", "checkerName": "debug.Stats", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"line": 49, "col": 1, "file": 19}, "message": "sk_PKCS7_SIGNER_INFO_zero -> Total CFGBlocks: 3 | Unreachable CFGBlocks: 0 | Exhausted Block: no | Empty WorkList: yes"}], "macros": [], "notes": [], "path": "/usr/include/openssl/pkcs7.h", "reportHash": "bc038afdfea374c19b32cb9d3058332f", "checkerName": "debug.Stats", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"line": 49, "col": 1, "file": 19}, "message": "sk_PKCS7_SIGNER_INFO_delete -> Total CFGBlocks: 3 | Unreachable CFGBlocks: 0 | Exhausted Block: no | Empty WorkList: yes"}], "macros": [], "notes": [], "path": "/usr/include/openssl/pkcs7.h", "reportHash": "85b7e624e0c4f8dd645e4175f277287a", "checkerName": "debug.Stats", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"line": 49, "col": 1, "file": 19}, "message": "sk_PKCS7_SIGNER_INFO_delete_ptr -> Total CFGBlocks: 3 | Unreachable CFGBlocks: 0 | Exhausted Block: no | Empty WorkList: yes"}], "macros": [], "notes": [], "path": "/usr/include/openssl/pkcs7.h", "reportHash": "15083c9ea176ca96a357acc4ff385579", "checkerName": "debug.Stats", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"line": 49, "col": 1, "file": 19}, "message": "sk_PKCS7_SIGNER_INFO_push -> Total CFGBlocks: 3 | Unreachable CFGBlocks: 0 | Exhausted Block: no | Empty WorkList: yes"}], "macros": [], "notes": [], "path": "/usr/include/openssl/pkcs7.h", "reportHash": "ef66a42aecca2ce3c30ab937506c0d15", "checkerName": "debug.Stats", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"line": 49, "col": 1, "file": 19}, "message": "sk_PKCS7_SIGNER_INFO_unshift -> Total CFGBlocks: 3 | Unreachable CFGBlocks: 0 | Exhausted Block: no | Empty WorkList: yes"}], "macros": [], "notes": [], "path": "/usr/include/openssl/pkcs7.h", "reportHash": "abe844944389b54ab9e00879d44268da", "checkerName": "debug.Stats", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"line": 49, "col": 1, "file": 19}, "message": "sk_PKCS7_SIGNER_INFO_pop -> Total CFGBlocks: 3 | Unreachable CFGBlocks: 0 | Exhausted Block: no | Empty WorkList: yes"}], "macros": [], "notes": [], "path": "/usr/include/openssl/pkcs7.h", "reportHash": "6daa15df6049198149183f546a7883c2", "checkerName": "debug.Stats", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"line": 49, "col": 1, "file": 19}, "message": "sk_PKCS7_SIGNER_INFO_shift -> Total CFGBlocks: 3 | Unreachable CFGBlocks: 0 | Exhausted Block: no | Empty WorkList: yes"}], "macros": [], "notes": [], "path": "/usr/include/openssl/pkcs7.h", "reportHash": "b6945c4c70404952c45e15be4b71b276", "checkerName": "debug.Stats", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"line": 49, "col": 1, "file": 19}, "message": "sk_PKCS7_SIGNER_INFO_pop_free -> Total CFGBlocks: 3 | Unreachable CFGBlocks: 0 | Exhausted Block: no | Empty WorkList: yes"}], "macros": [], "notes": [], "path": "/usr/include/openssl/pkcs7.h", "reportHash": "5be444b0e02669fc8f7387b0385e0ac4", "checkerName": "debug.Stats", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"line": 49, "col": 1, "file": 19}, "message": "sk_PKCS7_SIGNER_INFO_insert -> Total CFGBlocks: 3 | Unreachable CFGBlocks: 0 | Exhausted Block: no | Empty WorkList: yes"}], "macros": [], "notes": [], "path": "/usr/include/openssl/pkcs7.h", "reportHash": "0149ad023ee993eb31c6db9ce65f1272", "checkerName": "debug.Stats", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"line": 49, "col": 1, "file": 19}, "message": "sk_PKCS7_SIGNER_INFO_set -> Total CFGBlocks: 3 | Unreachable CFGBlocks: 0 | Exhausted Block: no | Empty WorkList: yes"}], "macros": [], "notes": [], "path": "/usr/include/openssl/pkcs7.h", "reportHash": "2bee342b4bf71c7a2ac0364d6c85bb36", "checkerName": "debug.Stats", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"line": 49, "col": 1, "file": 19}, "message": "sk_PKCS7_SIGNER_INFO_find -> Total CFGBlocks: 3 | Unreachable CFGBlocks: 0 | Exhausted Block: no | Empty WorkList: yes"}], "macros": [], "notes": [], "path": "/usr/include/openssl/pkcs7.h", "reportHash": "17565e32d8ccd3ae6f6e770f884c3c35", "checkerName": "debug.Stats", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"line": 49, "col": 1, "file": 19}, "message": "sk_PKCS7_SIGNER_INFO_find_ex -> Total CFGBlocks: 3 | Unreachable CFGBlocks: 0 | Exhausted Block: no | Empty WorkList: yes"}], "macros": [], "notes": [], "path": "/usr/include/openssl/pkcs7.h", "reportHash": "d5bf9802467da45610d75aea19b03c0b", "checkerName": "debug.Stats", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"line": 49, "col": 1, "file": 19}, "message": "sk_PKCS7_SIGNER_INFO_sort -> Total CFGBlocks: 3 | Unreachable CFGBlocks: 0 | Exhausted Block: no | Empty WorkList: yes"}], "macros": [], "notes": [], "path": "/usr/include/openssl/pkcs7.h", "reportHash": "0a5f4ee7ecf0b46c3f71d4f4a6a0736d", "checkerName": "debug.Stats", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"line": 49, "col": 1, "file": 19}, "message": "sk_PKCS7_SIGNER_INFO_is_sorted -> Total CFGBlocks: 3 | Unreachable CFGBlocks: 0 | Exhausted Block: no | Empty WorkList: yes"}], "macros": [], "notes": [], "path": "/usr/include/openssl/pkcs7.h", "reportHash": "138f349e78155535cb8085f2b70c50e3", "checkerName": "debug.Stats", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"line": 49, "col": 1, "file": 19}, "message": "sk_PKCS7_SIGNER_INFO_dup -> Total CFGBlocks: 3 | Unreachable CFGBlocks: 0 | Exhausted Block: no | Empty WorkList: yes"}], "macros": [], "notes": [], "path": "/usr/include/openssl/pkcs7.h", "reportHash": "d043a0b2df5dc0eb6f5948859c93bf5d", "checkerName": "debug.Stats", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"line": 49, "col": 1, "file": 19}, "message": "sk_PKCS7_SIGNER_INFO_deep_copy -> Total CFGBlocks: 3 | Unreachable CFGBlocks: 0 | Exhausted Block: no | Empty WorkList: yes"}], "macros": [], "notes": [], "path": "/usr/include/openssl/pkcs7.h", "reportHash": "17a8e7577c44de494d546f7d7100c744", "checkerName": "debug.Stats", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"line": 49, "col": 1, "file": 19}, "message": "sk_PKCS7_SIGNER_INFO_set_cmp_func -> Total CFGBlocks: 3 | Unreachable CFGBlocks: 0 | Exhausted Block: no | Empty WorkList: yes"}], "macros": [], "notes": [], "path": "/usr/include/openssl/pkcs7.h", "reportHash": "7d3db62d8d104b58d08500e830fd8799", "checkerName": "debug.Stats", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"line": 59, "col": 1, "file": 19}, "message": "sk_PKCS7_RECIP_INFO_num -> Total CFGBlocks: 3 | Unreachable CFGBlocks: 0 | Exhausted Block: no | Empty WorkList: yes"}], "macros": [], "notes": [], "path": "/usr/include/openssl/pkcs7.h", "reportHash": "1e8398a2d07c1cffe977c59fdeb621f3", "checkerName": "debug.Stats", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"line": 59, "col": 1, "file": 19}, "message": "sk_PKCS7_RECIP_INFO_value -> Total CFGBlocks: 3 | Unreachable CFGBlocks: 0 | Exhausted Block: no | Empty WorkList: yes"}], "macros": [], "notes": [], "path": "/usr/include/openssl/pkcs7.h", "reportHash": "98d69dca368f6bc2a9e6ee3b4b7caf9d", "checkerName": "debug.Stats", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"line": 59, "col": 1, "file": 19}, "message": "sk_PKCS7_RECIP_INFO_new -> Total CFGBlocks: 3 | Unreachable CFGBlocks: 0 | Exhausted Block: no | Empty WorkList: yes"}], "macros": [], "notes": [], "path": "/usr/include/openssl/pkcs7.h", "reportHash": "f8dc9b0d2e1c2b22ead84fb0fd2dc93d", "checkerName": "debug.Stats", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"line": 59, "col": 1, "file": 19}, "message": "sk_PKCS7_RECIP_INFO_new_null -> Total CFGBlocks: 3 | Unreachable CFGBlocks: 0 | Exhausted Block: no | Empty WorkList: yes"}], "macros": [], "notes": [], "path": "/usr/include/openssl/pkcs7.h", "reportHash": "7948b28ff013e4b9014e8313f11920c7", "checkerName": "debug.Stats", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"line": 59, "col": 1, "file": 19}, "message": "sk_PKCS7_RECIP_INFO_new_reserve -> Total CFGBlocks: 3 | Unreachable CFGBlocks: 0 | Exhausted Block: no | Empty WorkList: yes"}], "macros": [], "notes": [], "path": "/usr/include/openssl/pkcs7.h", "reportHash": "81ec95b30c87a648677912afc118d6e9", "checkerName": "debug.Stats", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"line": 59, "col": 1, "file": 19}, "message": "sk_PKCS7_RECIP_INFO_reserve -> Total CFGBlocks: 3 | Unreachable CFGBlocks: 0 | Exhausted Block: no | Empty WorkList: yes"}], "macros": [], "notes": [], "path": "/usr/include/openssl/pkcs7.h", "reportHash": "ade674d01920354da0752053b77fe561", "checkerName": "debug.Stats", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"line": 59, "col": 1, "file": 19}, "message": "sk_PKCS7_RECIP_INFO_free -> Total CFGBlocks: 3 | Unreachable CFGBlocks: 0 | Exhausted Block: no | Empty WorkList: yes"}], "macros": [], "notes": [], "path": "/usr/include/openssl/pkcs7.h", "reportHash": "1c039b1948dc98fde3fe9a8057785c3e", "checkerName": "debug.Stats", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"line": 59, "col": 1, "file": 19}, "message": "sk_PKCS7_RECIP_INFO_zero -> Total CFGBlocks: 3 | Unreachable CFGBlocks: 0 | Exhausted Block: no | Empty WorkList: yes"}], "macros": [], "notes": [], "path": "/usr/include/openssl/pkcs7.h", "reportHash": "26bd9ee793588099f95631ea15016e78", "checkerName": "debug.Stats", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"line": 59, "col": 1, "file": 19}, "message": "sk_PKCS7_RECIP_INFO_delete -> Total CFGBlocks: 3 | Unreachable CFGBlocks: 0 | Exhausted Block: no | Empty WorkList: yes"}], "macros": [], "notes": [], "path": "/usr/include/openssl/pkcs7.h", "reportHash": "fe13777e40cd8f5a8ed10b58166d2c95", "checkerName": "debug.Stats", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"line": 59, "col": 1, "file": 19}, "message": "sk_PKCS7_RECIP_INFO_delete_ptr -> Total CFGBlocks: 3 | Unreachable CFGBlocks: 0 | Exhausted Block: no | Empty WorkList: yes"}], "macros": [], "notes": [], "path": "/usr/include/openssl/pkcs7.h", "reportHash": "f975019d5669b8aa299ae8a46bd0ecfe", "checkerName": "debug.Stats", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"line": 59, "col": 1, "file": 19}, "message": "sk_PKCS7_RECIP_INFO_push -> Total CFGBlocks: 3 | Unreachable CFGBlocks: 0 | Exhausted Block: no | Empty WorkList: yes"}], "macros": [], "notes": [], "path": "/usr/include/openssl/pkcs7.h", "reportHash": "388466a63fc25039258f6ca8c4933fab", "checkerName": "debug.Stats", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"line": 59, "col": 1, "file": 19}, "message": "sk_PKCS7_RECIP_INFO_unshift -> Total CFGBlocks: 3 | Unreachable CFGBlocks: 0 | Exhausted Block: no | Empty WorkList: yes"}], "macros": [], "notes": [], "path": "/usr/include/openssl/pkcs7.h", "reportHash": "605bf9c16ce570ff9dd0cfffaaba00a4", "checkerName": "debug.Stats", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"line": 59, "col": 1, "file": 19}, "message": "sk_PKCS7_RECIP_INFO_pop -> Total CFGBlocks: 3 | Unreachable CFGBlocks: 0 | Exhausted Block: no | Empty WorkList: yes"}], "macros": [], "notes": [], "path": "/usr/include/openssl/pkcs7.h", "reportHash": "934b729204746e6278151523852973d5", "checkerName": "debug.Stats", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"line": 59, "col": 1, "file": 19}, "message": "sk_PKCS7_RECIP_INFO_shift -> Total CFGBlocks: 3 | Unreachable CFGBlocks: 0 | Exhausted Block: no | Empty WorkList: yes"}], "macros": [], "notes": [], "path": "/usr/include/openssl/pkcs7.h", "reportHash": "de8a81edea26ad42859a9f3ff2c72a20", "checkerName": "debug.Stats", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"line": 59, "col": 1, "file": 19}, "message": "sk_PKCS7_RECIP_INFO_pop_free -> Total CFGBlocks: 3 | Unreachable CFGBlocks: 0 | Exhausted Block: no | Empty WorkList: yes"}], "macros": [], "notes": [], "path": "/usr/include/openssl/pkcs7.h", "reportHash": "51c8ae88018a615a5ba174ae90f1490d", "checkerName": "debug.Stats", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"line": 59, "col": 1, "file": 19}, "message": "sk_PKCS7_RECIP_INFO_insert -> Total CFGBlocks: 3 | Unreachable CFGBlocks: 0 | Exhausted Block: no | Empty WorkList: yes"}], "macros": [], "notes": [], "path": "/usr/include/openssl/pkcs7.h", "reportHash": "8b6278d3af03f74578d356e68eb23a31", "checkerName": "debug.Stats", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"line": 59, "col": 1, "file": 19}, "message": "sk_PKCS7_RECIP_INFO_set -> Total CFGBlocks: 3 | Unreachable CFGBlocks: 0 | Exhausted Block: no | Empty WorkList: yes"}], "macros": [], "notes": [], "path": "/usr/include/openssl/pkcs7.h", "reportHash": "e5210e18a486015f3920aeddaf27cc52", "checkerName": "debug.Stats", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"line": 59, "col": 1, "file": 19}, "message": "sk_PKCS7_RECIP_INFO_find -> Total CFGBlocks: 3 | Unreachable CFGBlocks: 0 | Exhausted Block: no | Empty WorkList: yes"}], "macros": [], "notes": [], "path": "/usr/include/openssl/pkcs7.h", "reportHash": "080adfa4bcac1ce04623fe36e9accf73", "checkerName": "debug.Stats", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"line": 59, "col": 1, "file": 19}, "message": "sk_PKCS7_RECIP_INFO_find_ex -> Total CFGBlocks: 3 | Unreachable CFGBlocks: 0 | Exhausted Block: no | Empty WorkList: yes"}], "macros": [], "notes": [], "path": "/usr/include/openssl/pkcs7.h", "reportHash": "7ac8ebc3a998fc28b701a8a9c82e6f27", "checkerName": "debug.Stats", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"line": 59, "col": 1, "file": 19}, "message": "sk_PKCS7_RECIP_INFO_sort -> Total CFGBlocks: 3 | Unreachable CFGBlocks: 0 | Exhausted Block: no | Empty WorkList: yes"}], "macros": [], "notes": [], "path": "/usr/include/openssl/pkcs7.h", "reportHash": "74e486df88cf539f9718fed26fc69e36", "checkerName": "debug.Stats", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"line": 59, "col": 1, "file": 19}, "message": "sk_PKCS7_RECIP_INFO_is_sorted -> Total CFGBlocks: 3 | Unreachable CFGBlocks: 0 | Exhausted Block: no | Empty WorkList: yes"}], "macros": [], "notes": [], "path": "/usr/include/openssl/pkcs7.h", "reportHash": "4a47a9560e181e254eb62a452f77a8fd", "checkerName": "debug.Stats", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"line": 59, "col": 1, "file": 19}, "message": "sk_PKCS7_RECIP_INFO_dup -> Total CFGBlocks: 3 | Unreachable CFGBlocks: 0 | Exhausted Block: no | Empty WorkList: yes"}], "macros": [], "notes": [], "path": "/usr/include/openssl/pkcs7.h", "reportHash": "8f539239ed94e7e829649014d0065a17", "checkerName": "debug.Stats", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"line": 59, "col": 1, "file": 19}, "message": "sk_PKCS7_RECIP_INFO_deep_copy -> Total CFGBlocks: 3 | Unreachable CFGBlocks: 0 | Exhausted Block: no | Empty WorkList: yes"}], "macros": [], "notes": [], "path": "/usr/include/openssl/pkcs7.h", "reportHash": "1b5aee99838f7f188f84a043e44bb712", "checkerName": "debug.Stats", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"line": 59, "col": 1, "file": 19}, "message": "sk_PKCS7_RECIP_INFO_set_cmp_func -> Total CFGBlocks: 3 | Unreachable CFGBlocks: 0 | Exhausted Block: no | Empty WorkList: yes"}], "macros": [], "notes": [], "path": "/usr/include/openssl/pkcs7.h", "reportHash": "1145cd7cff1819bfb0630bd80c0c91fa", "checkerName": "debug.Stats", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"line": 146, "col": 1, "file": 19}, "message": "sk_PKCS7_num -> Total CFGBlocks: 3 | Unreachable CFGBlocks: 0 | Exhausted Block: no | Empty WorkList: yes"}], "macros": [], "notes": [], "path": "/usr/include/openssl/pkcs7.h", "reportHash": "d81e09bf8f541dc7c0c621677e8b7de0", "checkerName": "debug.Stats", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"line": 146, "col": 1, "file": 19}, "message": "sk_PKCS7_value -> Total CFGBlocks: 3 | Unreachable CFGBlocks: 0 | Exhausted Block: no | Empty WorkList: yes"}], "macros": [], "notes": [], "path": "/usr/include/openssl/pkcs7.h", "reportHash": "502aac4e13a97815511843b463bd7dd3", "checkerName": "debug.Stats", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"line": 146, "col": 1, "file": 19}, "message": "sk_PKCS7_new -> Total CFGBlocks: 3 | Unreachable CFGBlocks: 0 | Exhausted Block: no | Empty WorkList: yes"}], "macros": [], "notes": [], "path": "/usr/include/openssl/pkcs7.h", "reportHash": "7b4322051752351994b325ec0e191828", "checkerName": "debug.Stats", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"line": 146, "col": 1, "file": 19}, "message": "sk_PKCS7_new_null -> Total CFGBlocks: 3 | Unreachable CFGBlocks: 0 | Exhausted Block: no | Empty WorkList: yes"}], "macros": [], "notes": [], "path": "/usr/include/openssl/pkcs7.h", "reportHash": "2955ca29f57452f1cdab756be4a8d469", "checkerName": "debug.Stats", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"line": 146, "col": 1, "file": 19}, "message": "sk_PKCS7_new_reserve -> Total CFGBlocks: 3 | Unreachable CFGBlocks: 0 | Exhausted Block: no | Empty WorkList: yes"}], "macros": [], "notes": [], "path": "/usr/include/openssl/pkcs7.h", "reportHash": "cffaae62e891c34f159181c7083d41c5", "checkerName": "debug.Stats", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"line": 146, "col": 1, "file": 19}, "message": "sk_PKCS7_reserve -> Total CFGBlocks: 3 | Unreachable CFGBlocks: 0 | Exhausted Block: no | Empty WorkList: yes"}], "macros": [], "notes": [], "path": "/usr/include/openssl/pkcs7.h", "reportHash": "d19eef119a3fec9f7f7cae1a0d3807d8", "checkerName": "debug.Stats", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"line": 146, "col": 1, "file": 19}, "message": "sk_PKCS7_free -> Total CFGBlocks: 3 | Unreachable CFGBlocks: 0 | Exhausted Block: no | Empty WorkList: yes"}], "macros": [], "notes": [], "path": "/usr/include/openssl/pkcs7.h", "reportHash": "d5d59560b72ca3fc3599a06b40526b9c", "checkerName": "debug.Stats", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"line": 146, "col": 1, "file": 19}, "message": "sk_PKCS7_zero -> Total CFGBlocks: 3 | Unreachable CFGBlocks: 0 | Exhausted Block: no | Empty WorkList: yes"}], "macros": [], "notes": [], "path": "/usr/include/openssl/pkcs7.h", "reportHash": "907fb23978889a560541b46c91b4e264", "checkerName": "debug.Stats", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"line": 146, "col": 1, "file": 19}, "message": "sk_PKCS7_delete -> Total CFGBlocks: 3 | Unreachable CFGBlocks: 0 | Exhausted Block: no | Empty WorkList: yes"}], "macros": [], "notes": [], "path": "/usr/include/openssl/pkcs7.h", "reportHash": "080dce463873c481e06fbb7151da99a4", "checkerName": "debug.Stats", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"line": 146, "col": 1, "file": 19}, "message": "sk_PKCS7_delete_ptr -> Total CFGBlocks: 3 | Unreachable CFGBlocks: 0 | Exhausted Block: no | Empty WorkList: yes"}], "macros": [], "notes": [], "path": "/usr/include/openssl/pkcs7.h", "reportHash": "f791f43fe6c1ec9afef7e94c16844a4d", "checkerName": "debug.Stats", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"line": 146, "col": 1, "file": 19}, "message": "sk_PKCS7_push -> Total CFGBlocks: 3 | Unreachable CFGBlocks: 0 | Exhausted Block: no | Empty WorkList: yes"}], "macros": [], "notes": [], "path": "/usr/include/openssl/pkcs7.h", "reportHash": "e3733a19ce23f9b10f3f8842d5ee002b", "checkerName": "debug.Stats", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"line": 146, "col": 1, "file": 19}, "message": "sk_PKCS7_unshift -> Total CFGBlocks: 3 | Unreachable CFGBlocks: 0 | Exhausted Block: no | Empty WorkList: yes"}], "macros": [], "notes": [], "path": "/usr/include/openssl/pkcs7.h", "reportHash": "d5f85108aa590320dd3c52cc8d8a6fd1", "checkerName": "debug.Stats", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"line": 146, "col": 1, "file": 19}, "message": "sk_PKCS7_pop -> Total CFGBlocks: 3 | Unreachable CFGBlocks: 0 | Exhausted Block: no | Empty WorkList: yes"}], "macros": [], "notes": [], "path": "/usr/include/openssl/pkcs7.h", "reportHash": "b9577daab87c700358cc9fa18415ad6e", "checkerName": "debug.Stats", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"line": 146, "col": 1, "file": 19}, "message": "sk_PKCS7_shift -> Total CFGBlocks: 3 | Unreachable CFGBlocks: 0 | Exhausted Block: no | Empty WorkList: yes"}], "macros": [], "notes": [], "path": "/usr/include/openssl/pkcs7.h", "reportHash": "2ba6c5969e5e59e4478d7493468183c6", "checkerName": "debug.Stats", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"line": 146, "col": 1, "file": 19}, "message": "sk_PKCS7_pop_free -> Total CFGBlocks: 3 | Unreachable CFGBlocks: 0 | Exhausted Block: no | Empty WorkList: yes"}], "macros": [], "notes": [], "path": "/usr/include/openssl/pkcs7.h", "reportHash": "6e5fa3d71a3c8263c5dbf05891e1c63f", "checkerName": "debug.Stats", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"line": 146, "col": 1, "file": 19}, "message": "sk_PKCS7_insert -> Total CFGBlocks: 3 | Unreachable CFGBlocks: 0 | Exhausted Block: no | Empty WorkList: yes"}], "macros": [], "notes": [], "path": "/usr/include/openssl/pkcs7.h", "reportHash": "e68da5f91aae6066db4b7ae1da08e774", "checkerName": "debug.Stats", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"line": 146, "col": 1, "file": 19}, "message": "sk_PKCS7_set -> Total CFGBlocks: 3 | Unreachable CFGBlocks: 0 | Exhausted Block: no | Empty WorkList: yes"}], "macros": [], "notes": [], "path": "/usr/include/openssl/pkcs7.h", "reportHash": "6a3ca8ce153cec5093c6bb3a6a60c791", "checkerName": "debug.Stats", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"line": 146, "col": 1, "file": 19}, "message": "sk_PKCS7_find -> Total CFGBlocks: 3 | Unreachable CFGBlocks: 0 | Exhausted Block: no | Empty WorkList: yes"}], "macros": [], "notes": [], "path": "/usr/include/openssl/pkcs7.h", "reportHash": "ddfdc982e7b72121c9e910ca7f78536f", "checkerName": "debug.Stats", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"line": 146, "col": 1, "file": 19}, "message": "sk_PKCS7_find_ex -> Total CFGBlocks: 3 | Unreachable CFGBlocks: 0 | Exhausted Block: no | Empty WorkList: yes"}], "macros": [], "notes": [], "path": "/usr/include/openssl/pkcs7.h", "reportHash": "9bf820cc4d680e5ce5e6983e19401463", "checkerName": "debug.Stats", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"line": 146, "col": 1, "file": 19}, "message": "sk_PKCS7_sort -> Total CFGBlocks: 3 | Unreachable CFGBlocks: 0 | Exhausted Block: no | Empty WorkList: yes"}], "macros": [], "notes": [], "path": "/usr/include/openssl/pkcs7.h", "reportHash": "84710d8099903499d3a09309188211ef", "checkerName": "debug.Stats", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"line": 146, "col": 1, "file": 19}, "message": "sk_PKCS7_is_sorted -> Total CFGBlocks: 3 | Unreachable CFGBlocks: 0 | Exhausted Block: no | Empty WorkList: yes"}], "macros": [], "notes": [], "path": "/usr/include/openssl/pkcs7.h", "reportHash": "6646af5ad4f91c9fa5674515e37d5db3", "checkerName": "debug.Stats", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"line": 146, "col": 1, "file": 19}, "message": "sk_PKCS7_dup -> Total CFGBlocks: 3 | Unreachable CFGBlocks: 0 | Exhausted Block: no | Empty WorkList: yes"}], "macros": [], "notes": [], "path": "/usr/include/openssl/pkcs7.h", "reportHash": "648a380b8f9575233926562545b61636", "checkerName": "debug.Stats", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"line": 146, "col": 1, "file": 19}, "message": "sk_PKCS7_deep_copy -> Total CFGBlocks: 3 | Unreachable CFGBlocks: 0 | Exhausted Block: no | Empty WorkList: yes"}], "macros": [], "notes": [], "path": "/usr/include/openssl/pkcs7.h", "reportHash": "b50597ae1b4d3d20d9cf6f184db649d1", "checkerName": "debug.Stats", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"line": 146, "col": 1, "file": 19}, "message": "sk_PKCS7_set_cmp_func -> Total CFGBlocks: 3 | Unreachable CFGBlocks: 0 | Exhausted Block: no | Empty WorkList: yes"}], "macros": [], "notes": [], "path": "/usr/include/openssl/pkcs7.h", "reportHash": "c228ae76e8d15e902192c9cf2cd8f28b", "checkerName": "debug.Stats", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"line": 58, "col": 1, "file": 20}, "message": "sk_SCT_num -> Total CFGBlocks: 3 | Unreachable CFGBlocks: 0 | Exhausted Block: no | Empty WorkList: yes"}], "macros": [], "notes": [], "path": "/usr/include/openssl/ct.h", "reportHash": "55d8ce27bd54cfe603ae343d9221838f", "checkerName": "debug.Stats", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"line": 58, "col": 1, "file": 20}, "message": "sk_SCT_value -> Total CFGBlocks: 3 | Unreachable CFGBlocks: 0 | Exhausted Block: no | Empty WorkList: yes"}], "macros": [], "notes": [], "path": "/usr/include/openssl/ct.h", "reportHash": "8409d1be14981c6c67b6a9b3ff7d9c61", "checkerName": "debug.Stats", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"line": 58, "col": 1, "file": 20}, "message": "sk_SCT_new -> Total CFGBlocks: 3 | Unreachable CFGBlocks: 0 | Exhausted Block: no | Empty WorkList: yes"}], "macros": [], "notes": [], "path": "/usr/include/openssl/ct.h", "reportHash": "401c29f6dad0ed2ab3bccfdb4af27d9b", "checkerName": "debug.Stats", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"line": 58, "col": 1, "file": 20}, "message": "sk_SCT_new_null -> Total CFGBlocks: 3 | Unreachable CFGBlocks: 0 | Exhausted Block: no | Empty WorkList: yes"}], "macros": [], "notes": [], "path": "/usr/include/openssl/ct.h", "reportHash": "2af63e51a47c5b4d2bebd4f10612d16d", "checkerName": "debug.Stats", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"line": 58, "col": 1, "file": 20}, "message": "sk_SCT_new_reserve -> Total CFGBlocks: 3 | Unreachable CFGBlocks: 0 | Exhausted Block: no | Empty WorkList: yes"}], "macros": [], "notes": [], "path": "/usr/include/openssl/ct.h", "reportHash": "2da9262993f4b45100e93e891f5289ad", "checkerName": "debug.Stats", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"line": 58, "col": 1, "file": 20}, "message": "sk_SCT_reserve -> Total CFGBlocks: 3 | Unreachable CFGBlocks: 0 | Exhausted Block: no | Empty WorkList: yes"}], "macros": [], "notes": [], "path": "/usr/include/openssl/ct.h", "reportHash": "cdd4b05cd1ce810b092ddcdf1a157a02", "checkerName": "debug.Stats", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"line": 58, "col": 1, "file": 20}, "message": "sk_SCT_free -> Total CFGBlocks: 3 | Unreachable CFGBlocks: 0 | Exhausted Block: no | Empty WorkList: yes"}], "macros": [], "notes": [], "path": "/usr/include/openssl/ct.h", "reportHash": "02a13205cc7e56ff61af4a262a159859", "checkerName": "debug.Stats", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"line": 58, "col": 1, "file": 20}, "message": "sk_SCT_zero -> Total CFGBlocks: 3 | Unreachable CFGBlocks: 0 | Exhausted Block: no | Empty WorkList: yes"}], "macros": [], "notes": [], "path": "/usr/include/openssl/ct.h", "reportHash": "edcc1bf250698a3596e638d47266b646", "checkerName": "debug.Stats", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"line": 58, "col": 1, "file": 20}, "message": "sk_SCT_delete -> Total CFGBlocks: 3 | Unreachable CFGBlocks: 0 | Exhausted Block: no | Empty WorkList: yes"}], "macros": [], "notes": [], "path": "/usr/include/openssl/ct.h", "reportHash": "0bd661c287e0b43e1c2a59eeb391443e", "checkerName": "debug.Stats", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"line": 58, "col": 1, "file": 20}, "message": "sk_SCT_delete_ptr -> Total CFGBlocks: 3 | Unreachable CFGBlocks: 0 | Exhausted Block: no | Empty WorkList: yes"}], "macros": [], "notes": [], "path": "/usr/include/openssl/ct.h", "reportHash": "540b992454f54efc19a97f4691624080", "checkerName": "debug.Stats", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"line": 58, "col": 1, "file": 20}, "message": "sk_SCT_push -> Total CFGBlocks: 3 | Unreachable CFGBlocks: 0 | Exhausted Block: no | Empty WorkList: yes"}], "macros": [], "notes": [], "path": "/usr/include/openssl/ct.h", "reportHash": "a21e359afd1f761bb48fe9e936f8f752", "checkerName": "debug.Stats", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"line": 58, "col": 1, "file": 20}, "message": "sk_SCT_unshift -> Total CFGBlocks: 3 | Unreachable CFGBlocks: 0 | Exhausted Block: no | Empty WorkList: yes"}], "macros": [], "notes": [], "path": "/usr/include/openssl/ct.h", "reportHash": "0040616dff96e87e9c9eece884f65d3b", "checkerName": "debug.Stats", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"line": 58, "col": 1, "file": 20}, "message": "sk_SCT_pop -> Total CFGBlocks: 3 | Unreachable CFGBlocks: 0 | Exhausted Block: no | Empty WorkList: yes"}], "macros": [], "notes": [], "path": "/usr/include/openssl/ct.h", "reportHash": "35adbd6232baed57d93e6cbefe1ebe34", "checkerName": "debug.Stats", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"line": 58, "col": 1, "file": 20}, "message": "sk_SCT_shift -> Total CFGBlocks: 3 | Unreachable CFGBlocks: 0 | Exhausted Block: no | Empty WorkList: yes"}], "macros": [], "notes": [], "path": "/usr/include/openssl/ct.h", "reportHash": "30d7769ca23fd944e82fa8a3f1cafaf2", "checkerName": "debug.Stats", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"line": 58, "col": 1, "file": 20}, "message": "sk_SCT_pop_free -> Total CFGBlocks: 3 | Unreachable CFGBlocks: 0 | Exhausted Block: no | Empty WorkList: yes"}], "macros": [], "notes": [], "path": "/usr/include/openssl/ct.h", "reportHash": "8e5a03f077263081c9587b8c6f35b296", "checkerName": "debug.Stats", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"line": 58, "col": 1, "file": 20}, "message": "sk_SCT_insert -> Total CFGBlocks: 3 | Unreachable CFGBlocks: 0 | Exhausted Block: no | Empty WorkList: yes"}], "macros": [], "notes": [], "path": "/usr/include/openssl/ct.h", "reportHash": "472bddec50ab63e86e4166ddac74305a", "checkerName": "debug.Stats", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"line": 58, "col": 1, "file": 20}, "message": "sk_SCT_set -> Total CFGBlocks: 3 | Unreachable CFGBlocks: 0 | Exhausted Block: no | Empty WorkList: yes"}], "macros": [], "notes": [], "path": "/usr/include/openssl/ct.h", "reportHash": "54e7d5b21b6e337f6d5c7cb8492d1b19", "checkerName": "debug.Stats", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"line": 58, "col": 1, "file": 20}, "message": "sk_SCT_find -> Total CFGBlocks: 3 | Unreachable CFGBlocks: 0 | Exhausted Block: no | Empty WorkList: yes"}], "macros": [], "notes": [], "path": "/usr/include/openssl/ct.h", "reportHash": "8b7c248309d4a832fd63f8b5dc95ede2", "checkerName": "debug.Stats", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"line": 58, "col": 1, "file": 20}, "message": "sk_SCT_find_ex -> Total CFGBlocks: 3 | Unreachable CFGBlocks: 0 | Exhausted Block: no | Empty WorkList: yes"}], "macros": [], "notes": [], "path": "/usr/include/openssl/ct.h", "reportHash": "624de9ce9e6aa649f459f499ae543cea", "checkerName": "debug.Stats", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"line": 58, "col": 1, "file": 20}, "message": "sk_SCT_sort -> Total CFGBlocks: 3 | Unreachable CFGBlocks: 0 | Exhausted Block: no | Empty WorkList: yes"}], "macros": [], "notes": [], "path": "/usr/include/openssl/ct.h", "reportHash": "81129b72acda9c933e3e47dbf29cc504", "checkerName": "debug.Stats", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"line": 58, "col": 1, "file": 20}, "message": "sk_SCT_is_sorted -> Total CFGBlocks: 3 | Unreachable CFGBlocks: 0 | Exhausted Block: no | Empty WorkList: yes"}], "macros": [], "notes": [], "path": "/usr/include/openssl/ct.h", "reportHash": "ad7fd64a03f3a4bb81449e6fe259823d", "checkerName": "debug.Stats", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"line": 58, "col": 1, "file": 20}, "message": "sk_SCT_dup -> Total CFGBlocks: 3 | Unreachable CFGBlocks: 0 | Exhausted Block: no | Empty WorkList: yes"}], "macros": [], "notes": [], "path": "/usr/include/openssl/ct.h", "reportHash": "484ec91b0e38f88763f033cce930e637", "checkerName": "debug.Stats", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"line": 58, "col": 1, "file": 20}, "message": "sk_SCT_deep_copy -> Total CFGBlocks: 3 | Unreachable CFGBlocks: 0 | Exhausted Block: no | Empty WorkList: yes"}], "macros": [], "notes": [], "path": "/usr/include/openssl/ct.h", "reportHash": "b9b73feff9911848dc294eb05a1bb71d", "checkerName": "debug.Stats", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"line": 58, "col": 1, "file": 20}, "message": "sk_SCT_set_cmp_func -> Total CFGBlocks: 3 | Unreachable CFGBlocks: 0 | Exhausted Block: no | Empty WorkList: yes"}], "macros": [], "notes": [], "path": "/usr/include/openssl/ct.h", "reportHash": "2c50a33a05ebff0f7c2be8a7433e8956", "checkerName": "debug.Stats", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"line": 59, "col": 1, "file": 20}, "message": "sk_CTLOG_num -> Total CFGBlocks: 3 | Unreachable CFGBlocks: 0 | Exhausted Block: no | Empty WorkList: yes"}], "macros": [], "notes": [], "path": "/usr/include/openssl/ct.h", "reportHash": "5c66fce80029be8797296dbdca2a1cc4", "checkerName": "debug.Stats", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"line": 59, "col": 1, "file": 20}, "message": "sk_CTLOG_value -> Total CFGBlocks: 3 | Unreachable CFGBlocks: 0 | Exhausted Block: no | Empty WorkList: yes"}], "macros": [], "notes": [], "path": "/usr/include/openssl/ct.h", "reportHash": "bce9a458d292ef63a3ed99d0c735b3d4", "checkerName": "debug.Stats", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"line": 59, "col": 1, "file": 20}, "message": "sk_CTLOG_new -> Total CFGBlocks: 3 | Unreachable CFGBlocks: 0 | Exhausted Block: no | Empty WorkList: yes"}], "macros": [], "notes": [], "path": "/usr/include/openssl/ct.h", "reportHash": "313420d684ad5de4228c681f9eefdee4", "checkerName": "debug.Stats", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"line": 59, "col": 1, "file": 20}, "message": "sk_CTLOG_new_null -> Total CFGBlocks: 3 | Unreachable CFGBlocks: 0 | Exhausted Block: no | Empty WorkList: yes"}], "macros": [], "notes": [], "path": "/usr/include/openssl/ct.h", "reportHash": "202a016cf6ce2942bd49889cdae7db9b", "checkerName": "debug.Stats", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"line": 59, "col": 1, "file": 20}, "message": "sk_CTLOG_new_reserve -> Total CFGBlocks: 3 | Unreachable CFGBlocks: 0 | Exhausted Block: no | Empty WorkList: yes"}], "macros": [], "notes": [], "path": "/usr/include/openssl/ct.h", "reportHash": "54c89fed8dcb1dad459eeb9cb9c7f8bd", "checkerName": "debug.Stats", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"line": 59, "col": 1, "file": 20}, "message": "sk_CTLOG_reserve -> Total CFGBlocks: 3 | Unreachable CFGBlocks: 0 | Exhausted Block: no | Empty WorkList: yes"}], "macros": [], "notes": [], "path": "/usr/include/openssl/ct.h", "reportHash": "3c4b7266e674c68f682a2dbd5a272526", "checkerName": "debug.Stats", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"line": 59, "col": 1, "file": 20}, "message": "sk_CTLOG_free -> Total CFGBlocks: 3 | Unreachable CFGBlocks: 0 | Exhausted Block: no | Empty WorkList: yes"}], "macros": [], "notes": [], "path": "/usr/include/openssl/ct.h", "reportHash": "653c3fb37163f5f9cdab7f8c6efb9575", "checkerName": "debug.Stats", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"line": 59, "col": 1, "file": 20}, "message": "sk_CTLOG_zero -> Total CFGBlocks: 3 | Unreachable CFGBlocks: 0 | Exhausted Block: no | Empty WorkList: yes"}], "macros": [], "notes": [], "path": "/usr/include/openssl/ct.h", "reportHash": "5a5d5d36a91ff9efd5e2531945da527a", "checkerName": "debug.Stats", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"line": 59, "col": 1, "file": 20}, "message": "sk_CTLOG_delete -> Total CFGBlocks: 3 | Unreachable CFGBlocks: 0 | Exhausted Block: no | Empty WorkList: yes"}], "macros": [], "notes": [], "path": "/usr/include/openssl/ct.h", "reportHash": "0816184c356d34f976e1b0ceeb2fe8f9", "checkerName": "debug.Stats", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"line": 59, "col": 1, "file": 20}, "message": "sk_CTLOG_delete_ptr -> Total CFGBlocks: 3 | Unreachable CFGBlocks: 0 | Exhausted Block: no | Empty WorkList: yes"}], "macros": [], "notes": [], "path": "/usr/include/openssl/ct.h", "reportHash": "6422f4fb22eeb75d9915aec9529c1812", "checkerName": "debug.Stats", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"line": 59, "col": 1, "file": 20}, "message": "sk_CTLOG_push -> Total CFGBlocks: 3 | Unreachable CFGBlocks: 0 | Exhausted Block: no | Empty WorkList: yes"}], "macros": [], "notes": [], "path": "/usr/include/openssl/ct.h", "reportHash": "665a2ee13418e9364266179f3efcc017", "checkerName": "debug.Stats", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"line": 59, "col": 1, "file": 20}, "message": "sk_CTLOG_unshift -> Total CFGBlocks: 3 | Unreachable CFGBlocks: 0 | Exhausted Block: no | Empty WorkList: yes"}], "macros": [], "notes": [], "path": "/usr/include/openssl/ct.h", "reportHash": "f48603d77f63c9cb24daa8569f32894a", "checkerName": "debug.Stats", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"line": 59, "col": 1, "file": 20}, "message": "sk_CTLOG_pop -> Total CFGBlocks: 3 | Unreachable CFGBlocks: 0 | Exhausted Block: no | Empty WorkList: yes"}], "macros": [], "notes": [], "path": "/usr/include/openssl/ct.h", "reportHash": "08dc0588ed411099e3a0b8c7bb6826c5", "checkerName": "debug.Stats", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"line": 59, "col": 1, "file": 20}, "message": "sk_CTLOG_shift -> Total CFGBlocks: 3 | Unreachable CFGBlocks: 0 | Exhausted Block: no | Empty WorkList: yes"}], "macros": [], "notes": [], "path": "/usr/include/openssl/ct.h", "reportHash": "a8991dad23a42bed369d353a5c50bb51", "checkerName": "debug.Stats", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"line": 59, "col": 1, "file": 20}, "message": "sk_CTLOG_pop_free -> Total CFGBlocks: 3 | Unreachable CFGBlocks: 0 | Exhausted Block: no | Empty WorkList: yes"}], "macros": [], "notes": [], "path": "/usr/include/openssl/ct.h", "reportHash": "26eab95812399cf9363ef2905954b6db", "checkerName": "debug.Stats", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"line": 59, "col": 1, "file": 20}, "message": "sk_CTLOG_insert -> Total CFGBlocks: 3 | Unreachable CFGBlocks: 0 | Exhausted Block: no | Empty WorkList: yes"}], "macros": [], "notes": [], "path": "/usr/include/openssl/ct.h", "reportHash": "8f1f3eb27fcda06ff0d4150ce91f1279", "checkerName": "debug.Stats", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"line": 59, "col": 1, "file": 20}, "message": "sk_CTLOG_set -> Total CFGBlocks: 3 | Unreachable CFGBlocks: 0 | Exhausted Block: no | Empty WorkList: yes"}], "macros": [], "notes": [], "path": "/usr/include/openssl/ct.h", "reportHash": "37464e1a09ddfd1186e2799f7ee2ca1d", "checkerName": "debug.Stats", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"line": 59, "col": 1, "file": 20}, "message": "sk_CTLOG_find -> Total CFGBlocks: 3 | Unreachable CFGBlocks: 0 | Exhausted Block: no | Empty WorkList: yes"}], "macros": [], "notes": [], "path": "/usr/include/openssl/ct.h", "reportHash": "8878c4ac6d6c8aabb233a2efd26a6e0f", "checkerName": "debug.Stats", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"line": 59, "col": 1, "file": 20}, "message": "sk_CTLOG_find_ex -> Total CFGBlocks: 3 | Unreachable CFGBlocks: 0 | Exhausted Block: no | Empty WorkList: yes"}], "macros": [], "notes": [], "path": "/usr/include/openssl/ct.h", "reportHash": "6cdb97ac6398f2ebb4e1f33f4fc3ca5d", "checkerName": "debug.Stats", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"line": 59, "col": 1, "file": 20}, "message": "sk_CTLOG_sort -> Total CFGBlocks: 3 | Unreachable CFGBlocks: 0 | Exhausted Block: no | Empty WorkList: yes"}], "macros": [], "notes": [], "path": "/usr/include/openssl/ct.h", "reportHash": "7344e7420d290133f02acb4714962f51", "checkerName": "debug.Stats", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"line": 59, "col": 1, "file": 20}, "message": "sk_CTLOG_is_sorted -> Total CFGBlocks: 3 | Unreachable CFGBlocks: 0 | Exhausted Block: no | Empty WorkList: yes"}], "macros": [], "notes": [], "path": "/usr/include/openssl/ct.h", "reportHash": "a041501556c1ae5e91af73345af082ee", "checkerName": "debug.Stats", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"line": 59, "col": 1, "file": 20}, "message": "sk_CTLOG_dup -> Total CFGBlocks: 3 | Unreachable CFGBlocks: 0 | Exhausted Block: no | Empty WorkList: yes"}], "macros": [], "notes": [], "path": "/usr/include/openssl/ct.h", "reportHash": "764c35590159f4382bb00973f5511ea0", "checkerName": "debug.Stats", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"line": 59, "col": 1, "file": 20}, "message": "sk_CTLOG_deep_copy -> Total CFGBlocks: 3 | Unreachable CFGBlocks: 0 | Exhausted Block: no | Empty WorkList: yes"}], "macros": [], "notes": [], "path": "/usr/include/openssl/ct.h", "reportHash": "f4f26084f38ae86969c2046520f053ed", "checkerName": "debug.Stats", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"line": 59, "col": 1, "file": 20}, "message": "sk_CTLOG_set_cmp_func -> Total CFGBlocks: 3 | Unreachable CFGBlocks: 0 | Exhausted Block: no | Empty WorkList: yes"}], "macros": [], "notes": [], "path": "/usr/include/openssl/ct.h", "reportHash": "16505f6005ca367bac8e25a44b232339", "checkerName": "debug.Stats", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"line": 227, "col": 1, "file": 21}, "message": "sk_SRTP_PROTECTION_PROFILE_num -> Total CFGBlocks: 3 | Unreachable CFGBlocks: 0 | Exhausted Block: no | Empty WorkList: yes"}], "macros": [], "notes": [], "path": "/usr/include/openssl/ssl.h", "reportHash": "9782ff4dcf3fc4f926925b0db8cafc13", "checkerName": "debug.Stats", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"line": 227, "col": 1, "file": 21}, "message": "sk_SRTP_PROTECTION_PROFILE_value -> Total CFGBlocks: 3 | Unreachable CFGBlocks: 0 | Exhausted Block: no | Empty WorkList: yes"}], "macros": [], "notes": [], "path": "/usr/include/openssl/ssl.h", "reportHash": "ac6f5ebac25843c2a6f4c758e16d8aac", "checkerName": "debug.Stats", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"line": 227, "col": 1, "file": 21}, "message": "sk_SRTP_PROTECTION_PROFILE_new -> Total CFGBlocks: 3 | Unreachable CFGBlocks: 0 | Exhausted Block: no | Empty WorkList: yes"}], "macros": [], "notes": [], "path": "/usr/include/openssl/ssl.h", "reportHash": "ecdad42d4b669ed8acec16c1bef02c46", "checkerName": "debug.Stats", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"line": 227, "col": 1, "file": 21}, "message": "sk_SRTP_PROTECTION_PROFILE_new_null -> Total CFGBlocks: 3 | Unreachable CFGBlocks: 0 | Exhausted Block: no | Empty WorkList: yes"}], "macros": [], "notes": [], "path": "/usr/include/openssl/ssl.h", "reportHash": "e83dabb363598101a8bb49e2fc34ddf6", "checkerName": "debug.Stats", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"line": 227, "col": 1, "file": 21}, "message": "sk_SRTP_PROTECTION_PROFILE_new_reserve -> Total CFGBlocks: 3 | Unreachable CFGBlocks: 0 | Exhausted Block: no | Empty WorkList: yes"}], "macros": [], "notes": [], "path": "/usr/include/openssl/ssl.h", "reportHash": "49e1b9f70c4a048bc51a013473708027", "checkerName": "debug.Stats", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"line": 227, "col": 1, "file": 21}, "message": "sk_SRTP_PROTECTION_PROFILE_reserve -> Total CFGBlocks: 3 | Unreachable CFGBlocks: 0 | Exhausted Block: no | Empty WorkList: yes"}], "macros": [], "notes": [], "path": "/usr/include/openssl/ssl.h", "reportHash": "b5b298aa48df7e15458c7d82ad164c3d", "checkerName": "debug.Stats", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"line": 227, "col": 1, "file": 21}, "message": "sk_SRTP_PROTECTION_PROFILE_free -> Total CFGBlocks: 3 | Unreachable CFGBlocks: 0 | Exhausted Block: no | Empty WorkList: yes"}], "macros": [], "notes": [], "path": "/usr/include/openssl/ssl.h", "reportHash": "f48e40320281dc9dd9f8bf1cc8326c1b", "checkerName": "debug.Stats", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"line": 227, "col": 1, "file": 21}, "message": "sk_SRTP_PROTECTION_PROFILE_zero -> Total CFGBlocks: 3 | Unreachable CFGBlocks: 0 | Exhausted Block: no | Empty WorkList: yes"}], "macros": [], "notes": [], "path": "/usr/include/openssl/ssl.h", "reportHash": "3cd97728e03296aafa81e5d5917cb9ae", "checkerName": "debug.Stats", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"line": 227, "col": 1, "file": 21}, "message": "sk_SRTP_PROTECTION_PROFILE_delete -> Total CFGBlocks: 3 | Unreachable CFGBlocks: 0 | Exhausted Block: no | Empty WorkList: yes"}], "macros": [], "notes": [], "path": "/usr/include/openssl/ssl.h", "reportHash": "f4682e94d51be5f5ca7a69e30c5e1202", "checkerName": "debug.Stats", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"line": 227, "col": 1, "file": 21}, "message": "sk_SRTP_PROTECTION_PROFILE_delete_ptr -> Total CFGBlocks: 3 | Unreachable CFGBlocks: 0 | Exhausted Block: no | Empty WorkList: yes"}], "macros": [], "notes": [], "path": "/usr/include/openssl/ssl.h", "reportHash": "392ee178980efce87ff085e7a9c10cfd", "checkerName": "debug.Stats", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"line": 227, "col": 1, "file": 21}, "message": "sk_SRTP_PROTECTION_PROFILE_push -> Total CFGBlocks: 3 | Unreachable CFGBlocks: 0 | Exhausted Block: no | Empty WorkList: yes"}], "macros": [], "notes": [], "path": "/usr/include/openssl/ssl.h", "reportHash": "85c1b266e65cda93e76ef85ad6633c35", "checkerName": "debug.Stats", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"line": 227, "col": 1, "file": 21}, "message": "sk_SRTP_PROTECTION_PROFILE_unshift -> Total CFGBlocks: 3 | Unreachable CFGBlocks: 0 | Exhausted Block: no | Empty WorkList: yes"}], "macros": [], "notes": [], "path": "/usr/include/openssl/ssl.h", "reportHash": "7a10a83897410cef70e6a7d766fc5882", "checkerName": "debug.Stats", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"line": 227, "col": 1, "file": 21}, "message": "sk_SRTP_PROTECTION_PROFILE_pop -> Total CFGBlocks: 3 | Unreachable CFGBlocks: 0 | Exhausted Block: no | Empty WorkList: yes"}], "macros": [], "notes": [], "path": "/usr/include/openssl/ssl.h", "reportHash": "4b58ced320832c6784a86291fec42305", "checkerName": "debug.Stats", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"line": 227, "col": 1, "file": 21}, "message": "sk_SRTP_PROTECTION_PROFILE_shift -> Total CFGBlocks: 3 | Unreachable CFGBlocks: 0 | Exhausted Block: no | Empty WorkList: yes"}], "macros": [], "notes": [], "path": "/usr/include/openssl/ssl.h", "reportHash": "e6918b1dac36d16a556881481e87682f", "checkerName": "debug.Stats", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"line": 227, "col": 1, "file": 21}, "message": "sk_SRTP_PROTECTION_PROFILE_pop_free -> Total CFGBlocks: 3 | Unreachable CFGBlocks: 0 | Exhausted Block: no | Empty WorkList: yes"}], "macros": [], "notes": [], "path": "/usr/include/openssl/ssl.h", "reportHash": "3461984e3eb51a254d5e8b1a3f84df71", "checkerName": "debug.Stats", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"line": 227, "col": 1, "file": 21}, "message": "sk_SRTP_PROTECTION_PROFILE_insert -> Total CFGBlocks: 3 | Unreachable CFGBlocks: 0 | Exhausted Block: no | Empty WorkList: yes"}], "macros": [], "notes": [], "path": "/usr/include/openssl/ssl.h", "reportHash": "fc71c44e27bea107e30f311770a702f0", "checkerName": "debug.Stats", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"line": 227, "col": 1, "file": 21}, "message": "sk_SRTP_PROTECTION_PROFILE_set -> Total CFGBlocks: 3 | Unreachable CFGBlocks: 0 | Exhausted Block: no | Empty WorkList: yes"}], "macros": [], "notes": [], "path": "/usr/include/openssl/ssl.h", "reportHash": "7ac4b4684d63135418f97644f5c81a39", "checkerName": "debug.Stats", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"line": 227, "col": 1, "file": 21}, "message": "sk_SRTP_PROTECTION_PROFILE_find -> Total CFGBlocks: 3 | Unreachable CFGBlocks: 0 | Exhausted Block: no | Empty WorkList: yes"}], "macros": [], "notes": [], "path": "/usr/include/openssl/ssl.h", "reportHash": "7d2e43dcda397101a698370545e9b764", "checkerName": "debug.Stats", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"line": 227, "col": 1, "file": 21}, "message": "sk_SRTP_PROTECTION_PROFILE_find_ex -> Total CFGBlocks: 3 | Unreachable CFGBlocks: 0 | Exhausted Block: no | Empty WorkList: yes"}], "macros": [], "notes": [], "path": "/usr/include/openssl/ssl.h", "reportHash": "34602b8d0c987d14cf362a4560e5c8a7", "checkerName": "debug.Stats", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"line": 227, "col": 1, "file": 21}, "message": "sk_SRTP_PROTECTION_PROFILE_sort -> Total CFGBlocks: 3 | Unreachable CFGBlocks: 0 | Exhausted Block: no | Empty WorkList: yes"}], "macros": [], "notes": [], "path": "/usr/include/openssl/ssl.h", "reportHash": "673f9a17fae061cb2d34bfee3083bc01", "checkerName": "debug.Stats", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"line": 227, "col": 1, "file": 21}, "message": "sk_SRTP_PROTECTION_PROFILE_is_sorted -> Total CFGBlocks: 3 | Unreachable CFGBlocks: 0 | Exhausted Block: no | Empty WorkList: yes"}], "macros": [], "notes": [], "path": "/usr/include/openssl/ssl.h", "reportHash": "7ebfd31c02c4f04ddab461231fde0068", "checkerName": "debug.Stats", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"line": 227, "col": 1, "file": 21}, "message": "sk_SRTP_PROTECTION_PROFILE_dup -> Total CFGBlocks: 3 | Unreachable CFGBlocks: 0 | Exhausted Block: no | Empty WorkList: yes"}], "macros": [], "notes": [], "path": "/usr/include/openssl/ssl.h", "reportHash": "6885f55e46a7a030a695a5186187405f", "checkerName": "debug.Stats", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"line": 227, "col": 1, "file": 21}, "message": "sk_SRTP_PROTECTION_PROFILE_deep_copy -> Total CFGBlocks: 3 | Unreachable CFGBlocks: 0 | Exhausted Block: no | Empty WorkList: yes"}], "macros": [], "notes": [], "path": "/usr/include/openssl/ssl.h", "reportHash": "3fd44bb14b1cf6c93ef09f350fa70398", "checkerName": "debug.Stats", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"line": 227, "col": 1, "file": 21}, "message": "sk_SRTP_PROTECTION_PROFILE_set_cmp_func -> Total CFGBlocks: 3 | Unreachable CFGBlocks: 0 | Exhausted Block: no | Empty WorkList: yes"}], "macros": [], "notes": [], "path": "/usr/include/openssl/ssl.h", "reportHash": "205d7204de9666a4cf87591d58cc0746", "checkerName": "debug.Stats", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"line": 958, "col": 1, "file": 21}, "message": "sk_SSL_CIPHER_num -> Total CFGBlocks: 3 | Unreachable CFGBlocks: 0 | Exhausted Block: no | Empty WorkList: yes"}], "macros": [], "notes": [], "path": "/usr/include/openssl/ssl.h", "reportHash": "fc664bae6de8c94f329b1a98c9a963d8", "checkerName": "debug.Stats", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"line": 958, "col": 1, "file": 21}, "message": "sk_SSL_CIPHER_value -> Total CFGBlocks: 3 | Unreachable CFGBlocks: 0 | Exhausted Block: no | Empty WorkList: yes"}], "macros": [], "notes": [], "path": "/usr/include/openssl/ssl.h", "reportHash": "4708464b54393e7bcb4270518b7020d0", "checkerName": "debug.Stats", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"line": 958, "col": 1, "file": 21}, "message": "sk_SSL_CIPHER_new -> Total CFGBlocks: 3 | Unreachable CFGBlocks: 0 | Exhausted Block: no | Empty WorkList: yes"}], "macros": [], "notes": [], "path": "/usr/include/openssl/ssl.h", "reportHash": "78501f58781b6551c01061605e7f263e", "checkerName": "debug.Stats", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"line": 958, "col": 1, "file": 21}, "message": "sk_SSL_CIPHER_new_null -> Total CFGBlocks: 3 | Unreachable CFGBlocks: 0 | Exhausted Block: no | Empty WorkList: yes"}], "macros": [], "notes": [], "path": "/usr/include/openssl/ssl.h", "reportHash": "a9f8242050f5bc2a4a6e96253313cd51", "checkerName": "debug.Stats", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"line": 958, "col": 1, "file": 21}, "message": "sk_SSL_CIPHER_new_reserve -> Total CFGBlocks: 3 | Unreachable CFGBlocks: 0 | Exhausted Block: no | Empty WorkList: yes"}], "macros": [], "notes": [], "path": "/usr/include/openssl/ssl.h", "reportHash": "a2fdd8b96d7dcaad1c04c25a3028d862", "checkerName": "debug.Stats", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"line": 958, "col": 1, "file": 21}, "message": "sk_SSL_CIPHER_reserve -> Total CFGBlocks: 3 | Unreachable CFGBlocks: 0 | Exhausted Block: no | Empty WorkList: yes"}], "macros": [], "notes": [], "path": "/usr/include/openssl/ssl.h", "reportHash": "13e6ca19852c865f19e0c9b98c18eeb8", "checkerName": "debug.Stats", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"line": 958, "col": 1, "file": 21}, "message": "sk_SSL_CIPHER_free -> Total CFGBlocks: 3 | Unreachable CFGBlocks: 0 | Exhausted Block: no | Empty WorkList: yes"}], "macros": [], "notes": [], "path": "/usr/include/openssl/ssl.h", "reportHash": "2d2694410eb170a08d97d0fdc5817b7d", "checkerName": "debug.Stats", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"line": 958, "col": 1, "file": 21}, "message": "sk_SSL_CIPHER_zero -> Total CFGBlocks: 3 | Unreachable CFGBlocks: 0 | Exhausted Block: no | Empty WorkList: yes"}], "macros": [], "notes": [], "path": "/usr/include/openssl/ssl.h", "reportHash": "f2e47159a4765fbc5a7e6161914f9ba3", "checkerName": "debug.Stats", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"line": 958, "col": 1, "file": 21}, "message": "sk_SSL_CIPHER_delete -> Total CFGBlocks: 3 | Unreachable CFGBlocks: 0 | Exhausted Block: no | Empty WorkList: yes"}], "macros": [], "notes": [], "path": "/usr/include/openssl/ssl.h", "reportHash": "5f3d051562a1246e3b8fbf934c995663", "checkerName": "debug.Stats", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"line": 958, "col": 1, "file": 21}, "message": "sk_SSL_CIPHER_delete_ptr -> Total CFGBlocks: 3 | Unreachable CFGBlocks: 0 | Exhausted Block: no | Empty WorkList: yes"}], "macros": [], "notes": [], "path": "/usr/include/openssl/ssl.h", "reportHash": "9a0a35ad3cdb1923ab5bd53a5f866409", "checkerName": "debug.Stats", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"line": 958, "col": 1, "file": 21}, "message": "sk_SSL_CIPHER_push -> Total CFGBlocks: 3 | Unreachable CFGBlocks: 0 | Exhausted Block: no | Empty WorkList: yes"}], "macros": [], "notes": [], "path": "/usr/include/openssl/ssl.h", "reportHash": "613bc34ba8e2dafbb410a56c52ba12e8", "checkerName": "debug.Stats", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"line": 958, "col": 1, "file": 21}, "message": "sk_SSL_CIPHER_unshift -> Total CFGBlocks: 3 | Unreachable CFGBlocks: 0 | Exhausted Block: no | Empty WorkList: yes"}], "macros": [], "notes": [], "path": "/usr/include/openssl/ssl.h", "reportHash": "c79cd24d74ae855a2ee0af5e2a9794c9", "checkerName": "debug.Stats", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"line": 958, "col": 1, "file": 21}, "message": "sk_SSL_CIPHER_pop -> Total CFGBlocks: 3 | Unreachable CFGBlocks: 0 | Exhausted Block: no | Empty WorkList: yes"}], "macros": [], "notes": [], "path": "/usr/include/openssl/ssl.h", "reportHash": "94d793236d81df6eaf034eec0eca8428", "checkerName": "debug.Stats", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"line": 958, "col": 1, "file": 21}, "message": "sk_SSL_CIPHER_shift -> Total CFGBlocks: 3 | Unreachable CFGBlocks: 0 | Exhausted Block: no | Empty WorkList: yes"}], "macros": [], "notes": [], "path": "/usr/include/openssl/ssl.h", "reportHash": "00a43f191ab4d43c5b855c59486a1bdc", "checkerName": "debug.Stats", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"line": 958, "col": 1, "file": 21}, "message": "sk_SSL_CIPHER_pop_free -> Total CFGBlocks: 3 | Unreachable CFGBlocks: 0 | Exhausted Block: no | Empty WorkList: yes"}], "macros": [], "notes": [], "path": "/usr/include/openssl/ssl.h", "reportHash": "e7043abd5d0768250a138911bf08fcc4", "checkerName": "debug.Stats", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"line": 958, "col": 1, "file": 21}, "message": "sk_SSL_CIPHER_insert -> Total CFGBlocks: 3 | Unreachable CFGBlocks: 0 | Exhausted Block: no | Empty WorkList: yes"}], "macros": [], "notes": [], "path": "/usr/include/openssl/ssl.h", "reportHash": "1098e23fd716ba55f8df73661bfd0675", "checkerName": "debug.Stats", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"line": 958, "col": 1, "file": 21}, "message": "sk_SSL_CIPHER_set -> Total CFGBlocks: 3 | Unreachable CFGBlocks: 0 | Exhausted Block: no | Empty WorkList: yes"}], "macros": [], "notes": [], "path": "/usr/include/openssl/ssl.h", "reportHash": "15d2ef6c823b5af742d528e3e298e677", "checkerName": "debug.Stats", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"line": 958, "col": 1, "file": 21}, "message": "sk_SSL_CIPHER_find -> Total CFGBlocks: 3 | Unreachable CFGBlocks: 0 | Exhausted Block: no | Empty WorkList: yes"}], "macros": [], "notes": [], "path": "/usr/include/openssl/ssl.h", "reportHash": "dadc2e0cf4b0d5276618f7ab4411cc9b", "checkerName": "debug.Stats", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"line": 958, "col": 1, "file": 21}, "message": "sk_SSL_CIPHER_find_ex -> Total CFGBlocks: 3 | Unreachable CFGBlocks: 0 | Exhausted Block: no | Empty WorkList: yes"}], "macros": [], "notes": [], "path": "/usr/include/openssl/ssl.h", "reportHash": "b10a43a36665f970086a538b6cf71866", "checkerName": "debug.Stats", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"line": 958, "col": 1, "file": 21}, "message": "sk_SSL_CIPHER_sort -> Total CFGBlocks: 3 | Unreachable CFGBlocks: 0 | Exhausted Block: no | Empty WorkList: yes"}], "macros": [], "notes": [], "path": "/usr/include/openssl/ssl.h", "reportHash": "0a1dc17c61ad34a61448e8284ac31197", "checkerName": "debug.Stats", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"line": 958, "col": 1, "file": 21}, "message": "sk_SSL_CIPHER_is_sorted -> Total CFGBlocks: 3 | Unreachable CFGBlocks: 0 | Exhausted Block: no | Empty WorkList: yes"}], "macros": [], "notes": [], "path": "/usr/include/openssl/ssl.h", "reportHash": "5295fa7b4c942ca2423ad7b1c764bcd9", "checkerName": "debug.Stats", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"line": 958, "col": 1, "file": 21}, "message": "sk_SSL_CIPHER_dup -> Total CFGBlocks: 3 | Unreachable CFGBlocks: 0 | Exhausted Block: no | Empty WorkList: yes"}], "macros": [], "notes": [], "path": "/usr/include/openssl/ssl.h", "reportHash": "1821a86060eb84b7eb3ae48396f4def5", "checkerName": "debug.Stats", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"line": 958, "col": 1, "file": 21}, "message": "sk_SSL_CIPHER_deep_copy -> Total CFGBlocks: 3 | Unreachable CFGBlocks: 0 | Exhausted Block: no | Empty WorkList: yes"}], "macros": [], "notes": [], "path": "/usr/include/openssl/ssl.h", "reportHash": "34793daa420d0ec942125c6da86ec2c3", "checkerName": "debug.Stats", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"line": 958, "col": 1, "file": 21}, "message": "sk_SSL_CIPHER_set_cmp_func -> Total CFGBlocks: 3 | Unreachable CFGBlocks: 0 | Exhausted Block: no | Empty WorkList: yes"}], "macros": [], "notes": [], "path": "/usr/include/openssl/ssl.h", "reportHash": "0a220ea353991b49dcebb57f0f3fd2b5", "checkerName": "debug.Stats", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"line": 959, "col": 1, "file": 21}, "message": "sk_SSL_COMP_num -> Total CFGBlocks: 3 | Unreachable CFGBlocks: 0 | Exhausted Block: no | Empty WorkList: yes"}], "macros": [], "notes": [], "path": "/usr/include/openssl/ssl.h", "reportHash": "0070b6af6b9b625a3ff7a0320c268f73", "checkerName": "debug.Stats", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"line": 959, "col": 1, "file": 21}, "message": "sk_SSL_COMP_value -> Total CFGBlocks: 3 | Unreachable CFGBlocks: 0 | Exhausted Block: no | Empty WorkList: yes"}], "macros": [], "notes": [], "path": "/usr/include/openssl/ssl.h", "reportHash": "daed08970339b987670e2bb4cfa723e1", "checkerName": "debug.Stats", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"line": 959, "col": 1, "file": 21}, "message": "sk_SSL_COMP_new -> Total CFGBlocks: 3 | Unreachable CFGBlocks: 0 | Exhausted Block: no | Empty WorkList: yes"}], "macros": [], "notes": [], "path": "/usr/include/openssl/ssl.h", "reportHash": "427a81f1eb979f97c3be3c4e72771b92", "checkerName": "debug.Stats", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"line": 959, "col": 1, "file": 21}, "message": "sk_SSL_COMP_new_null -> Total CFGBlocks: 3 | Unreachable CFGBlocks: 0 | Exhausted Block: no | Empty WorkList: yes"}], "macros": [], "notes": [], "path": "/usr/include/openssl/ssl.h", "reportHash": "efc8ca88b3d1b83b1775d5a013e5401d", "checkerName": "debug.Stats", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"line": 959, "col": 1, "file": 21}, "message": "sk_SSL_COMP_new_reserve -> Total CFGBlocks: 3 | Unreachable CFGBlocks: 0 | Exhausted Block: no | Empty WorkList: yes"}], "macros": [], "notes": [], "path": "/usr/include/openssl/ssl.h", "reportHash": "c5d368409a323dc0218959597d86807e", "checkerName": "debug.Stats", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"line": 959, "col": 1, "file": 21}, "message": "sk_SSL_COMP_reserve -> Total CFGBlocks: 3 | Unreachable CFGBlocks: 0 | Exhausted Block: no | Empty WorkList: yes"}], "macros": [], "notes": [], "path": "/usr/include/openssl/ssl.h", "reportHash": "dd2d83cf978c74df8f8d5ef505296073", "checkerName": "debug.Stats", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"line": 959, "col": 1, "file": 21}, "message": "sk_SSL_COMP_free -> Total CFGBlocks: 3 | Unreachable CFGBlocks: 0 | Exhausted Block: no | Empty WorkList: yes"}], "macros": [], "notes": [], "path": "/usr/include/openssl/ssl.h", "reportHash": "2521dbd1051086d31dcc36a454a3da97", "checkerName": "debug.Stats", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"line": 959, "col": 1, "file": 21}, "message": "sk_SSL_COMP_zero -> Total CFGBlocks: 3 | Unreachable CFGBlocks: 0 | Exhausted Block: no | Empty WorkList: yes"}], "macros": [], "notes": [], "path": "/usr/include/openssl/ssl.h", "reportHash": "57886b4459305b3f6f568e2ca1091a76", "checkerName": "debug.Stats", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"line": 959, "col": 1, "file": 21}, "message": "sk_SSL_COMP_delete -> Total CFGBlocks: 3 | Unreachable CFGBlocks: 0 | Exhausted Block: no | Empty WorkList: yes"}], "macros": [], "notes": [], "path": "/usr/include/openssl/ssl.h", "reportHash": "790ebee46ce48e911074549c45a038d7", "checkerName": "debug.Stats", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"line": 959, "col": 1, "file": 21}, "message": "sk_SSL_COMP_delete_ptr -> Total CFGBlocks: 3 | Unreachable CFGBlocks: 0 | Exhausted Block: no | Empty WorkList: yes"}], "macros": [], "notes": [], "path": "/usr/include/openssl/ssl.h", "reportHash": "c3086460134e69ab127db7728fa6540d", "checkerName": "debug.Stats", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"line": 959, "col": 1, "file": 21}, "message": "sk_SSL_COMP_push -> Total CFGBlocks: 3 | Unreachable CFGBlocks: 0 | Exhausted Block: no | Empty WorkList: yes"}], "macros": [], "notes": [], "path": "/usr/include/openssl/ssl.h", "reportHash": "58264493ec7310d4e680938beaf8f976", "checkerName": "debug.Stats", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"line": 959, "col": 1, "file": 21}, "message": "sk_SSL_COMP_unshift -> Total CFGBlocks: 3 | Unreachable CFGBlocks: 0 | Exhausted Block: no | Empty WorkList: yes"}], "macros": [], "notes": [], "path": "/usr/include/openssl/ssl.h", "reportHash": "8b8a38aacb13edb45e42af5b09d7de1c", "checkerName": "debug.Stats", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"line": 959, "col": 1, "file": 21}, "message": "sk_SSL_COMP_pop -> Total CFGBlocks: 3 | Unreachable CFGBlocks: 0 | Exhausted Block: no | Empty WorkList: yes"}], "macros": [], "notes": [], "path": "/usr/include/openssl/ssl.h", "reportHash": "733d91619fb12640429f723d834c9559", "checkerName": "debug.Stats", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"line": 959, "col": 1, "file": 21}, "message": "sk_SSL_COMP_shift -> Total CFGBlocks: 3 | Unreachable CFGBlocks: 0 | Exhausted Block: no | Empty WorkList: yes"}], "macros": [], "notes": [], "path": "/usr/include/openssl/ssl.h", "reportHash": "9faa88fbed729fc439b3dd63153b562d", "checkerName": "debug.Stats", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"line": 959, "col": 1, "file": 21}, "message": "sk_SSL_COMP_pop_free -> Total CFGBlocks: 3 | Unreachable CFGBlocks: 0 | Exhausted Block: no | Empty WorkList: yes"}], "macros": [], "notes": [], "path": "/usr/include/openssl/ssl.h", "reportHash": "4df2845a3aab347d62bd7376ff41b597", "checkerName": "debug.Stats", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"line": 959, "col": 1, "file": 21}, "message": "sk_SSL_COMP_insert -> Total CFGBlocks: 3 | Unreachable CFGBlocks: 0 | Exhausted Block: no | Empty WorkList: yes"}], "macros": [], "notes": [], "path": "/usr/include/openssl/ssl.h", "reportHash": "ddc03ed78d08a40101c1a2a604950603", "checkerName": "debug.Stats", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"line": 959, "col": 1, "file": 21}, "message": "sk_SSL_COMP_set -> Total CFGBlocks: 3 | Unreachable CFGBlocks: 0 | Exhausted Block: no | Empty WorkList: yes"}], "macros": [], "notes": [], "path": "/usr/include/openssl/ssl.h", "reportHash": "ec18bebf3c89229f485536b59bc1f35f", "checkerName": "debug.Stats", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"line": 959, "col": 1, "file": 21}, "message": "sk_SSL_COMP_find -> Total CFGBlocks: 3 | Unreachable CFGBlocks: 0 | Exhausted Block: no | Empty WorkList: yes"}], "macros": [], "notes": [], "path": "/usr/include/openssl/ssl.h", "reportHash": "6cb3d3ede0c4607beccfc1f3521138ce", "checkerName": "debug.Stats", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"line": 959, "col": 1, "file": 21}, "message": "sk_SSL_COMP_find_ex -> Total CFGBlocks: 3 | Unreachable CFGBlocks: 0 | Exhausted Block: no | Empty WorkList: yes"}], "macros": [], "notes": [], "path": "/usr/include/openssl/ssl.h", "reportHash": "94fd67cd74aae81b024b9926e9afce62", "checkerName": "debug.Stats", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"line": 959, "col": 1, "file": 21}, "message": "sk_SSL_COMP_sort -> Total CFGBlocks: 3 | Unreachable CFGBlocks: 0 | Exhausted Block: no | Empty WorkList: yes"}], "macros": [], "notes": [], "path": "/usr/include/openssl/ssl.h", "reportHash": "85302a13cb46fb8afcc60464ab67828d", "checkerName": "debug.Stats", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"line": 959, "col": 1, "file": 21}, "message": "sk_SSL_COMP_is_sorted -> Total CFGBlocks: 3 | Unreachable CFGBlocks: 0 | Exhausted Block: no | Empty WorkList: yes"}], "macros": [], "notes": [], "path": "/usr/include/openssl/ssl.h", "reportHash": "9cec4f40bd0b5f56b42c24a3e26552cb", "checkerName": "debug.Stats", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"line": 959, "col": 1, "file": 21}, "message": "sk_SSL_COMP_dup -> Total CFGBlocks: 3 | Unreachable CFGBlocks: 0 | Exhausted Block: no | Empty WorkList: yes"}], "macros": [], "notes": [], "path": "/usr/include/openssl/ssl.h", "reportHash": "0a52a008c87afcb52cf1d64b03f730de", "checkerName": "debug.Stats", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"line": 959, "col": 1, "file": 21}, "message": "sk_SSL_COMP_deep_copy -> Total CFGBlocks: 3 | Unreachable CFGBlocks: 0 | Exhausted Block: no | Empty WorkList: yes"}], "macros": [], "notes": [], "path": "/usr/include/openssl/ssl.h", "reportHash": "a253882d8559d7bdab0a1e62c4c48c0d", "checkerName": "debug.Stats", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"line": 959, "col": 1, "file": 21}, "message": "sk_SSL_COMP_set_cmp_func -> Total CFGBlocks: 3 | Unreachable CFGBlocks: 0 | Exhausted Block: no | Empty WorkList: yes"}], "macros": [], "notes": [], "path": "/usr/include/openssl/ssl.h", "reportHash": "6c7160d3d8c86f7dffb8b916aaaaf911", "checkerName": "debug.Stats", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"line": 133, "col": 3, "file": 22}, "message": "Duplicate code detected"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/lib/curl_ntlm_core.c", "reportHash": "992ac389dab03b55566f685330657eda", "checkerName": "alpha.clone.CloneChecker", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"line": 387, "col": 6, "file": 22}, "message": "Curl_ntlm_core_lm_resp -> Total CFGBlocks: 3 | Unreachable CFGBlocks: 0 | Exhausted Block: no | Empty WorkList: yes"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/lib/curl_ntlm_core.c", "reportHash": "225cf943cf35a333db9d8e9b73e8e6bc", "checkerName": "debug.Stats", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"line": 441, "col": 10, "file": 22}, "message": "Curl_ntlm_core_mk_lm_hash -> Total CFGBlocks: 10 | Unreachable CFGBlocks: 1 | Exhausted Block: no | Empty WorkList: yes"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/lib/curl_ntlm_core.c", "reportHash": "ed28edf8f3dfef2deda170a101feb12f", "checkerName": "debug.Stats", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"line": 461, "col": 12, "file": 22}, "message": "This statement is never executed"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/lib/curl_ntlm_core.c", "reportHash": "96556729afb4fea08080480693382689", "checkerName": "alpha.deadcode.UnreachableCode", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"line": 535, "col": 10, "file": 22}, "message": "Curl_ntlm_core_mk_nt_hash -> Total CFGBlocks: 12 | Unreachable CFGBlocks: 2 | Exhausted Block: no | Empty WorkList: yes"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/lib/curl_ntlm_core.c", "reportHash": "21aa3f9cfc35d717742cef0f3e140ec6", "checkerName": "debug.Stats", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"line": 556, "col": 12, "file": 22}, "message": "This statement is never executed"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/lib/curl_ntlm_core.c", "reportHash": "e46c0d09578d5953d2edb5c79e1143e5", "checkerName": "alpha.deadcode.UnreachableCode", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"line": 573, "col": 10, "file": 22}, "message": "Curl_ntlm_core_mk_ntlmv2_hash -> Total CFGBlocks: 9 | Unreachable CFGBlocks: 0 | Exhausted Block: no | Empty WorkList: yes"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/lib/curl_ntlm_core.c", "reportHash": "b97f966bb31c753a3e9f81628f45b4d1", "checkerName": "debug.Stats", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"line": 623, "col": 10, "file": 22}, "message": "Curl_ntlm_core_mk_ntlmv2_resp -> Total CFGBlocks: 7 | Unreachable CFGBlocks: 0 | Exhausted Block: no | Empty WorkList: yes"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/lib/curl_ntlm_core.c", "reportHash": "4045799e5363bffeebb262d207679016", "checkerName": "debug.Stats", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"line": 717, "col": 11, "file": 22}, "message": "Curl_ntlm_core_mk_lmv2_resp -> Total CFGBlocks: 5 | Unreachable CFGBlocks: 0 | Exhausted Block: no | Empty WorkList: yes"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/lib/curl_ntlm_core.c", "reportHash": "e848a34ddf0296a3bfb04bd15e90ea8a", "checkerName": "debug.Stats", "reviewStatus": null, "severity": "UNSPECIFIED"}]};
      window.onload = function() {
        if (!browserCompatible) {
          setNonCompatibleBrowserMessage();
        } else {
          BugViewer.init(data.files, data.reports);
          BugViewer.create();
          BugViewer.initByUrl();
        }
      };
    </script>
  </head>
  <body>
  <div class="container">
    <div id="content">
      <div id="side-bar">
        <div class="header">
          <a href="index.html" class="button">&#8249; Return to List</a>
        </div>
        <div id="report-nav">
          <div class="header">Reports</div>
        </div>
      </div>
      <div id="editor-wrapper">
        <div class="header">
          <div id="file">
            <span class="label">File:</span>
            <span id="file-path"></span>
          </div>
          <div id="checker">
            <span class="label">Checker name:</span>
            <span id="checker-name"></span>
          </div>
          <div id="review-status-wrapper">
            <span class="label">Review status:</span>
            <span id="review-status"></span>
          </div>
        </div>
        <div id="editor"></div>
      </div>
    </div>
  </div>
  </body>
</html>
