<!DOCTYPE html>
<html>
  <head>
    <title>Plist HTML Viewer</title>

    <meta charset="UTF-8">

    <style type="text/css">
      .CodeMirror{font-family:monospace;height:300px;color:#000;direction:ltr}.CodeMirror-lines{padding:4px 0}.CodeMirror pre{padding:0 4px}.CodeMirror-gutter-filler,.CodeMirror-scrollbar-filler{background-color:#fff}.CodeMirror-gutters{border-right:1px solid #ddd;background-color:#f7f7f7;white-space:nowrap}.CodeMirror-linenumber{padding:0 3px 0 5px;min-width:20px;text-align:right;color:#999;white-space:nowrap}.CodeMirror-guttermarker{color:#000}.CodeMirror-guttermarker-subtle{color:#999}.CodeMirror-cursor{border-left:1px solid #000;border-right:none;width:0}.CodeMirror div.CodeMirror-secondarycursor{border-left:1px solid silver}.cm-fat-cursor .CodeMirror-cursor{width:auto;border:0!important;background:#7e7}.cm-fat-cursor div.CodeMirror-cursors{z-index:1}.cm-animate-fat-cursor{width:auto;border:0;-webkit-animation:blink 1.06s steps(1) infinite;-moz-animation:blink 1.06s steps(1) infinite;animation:blink 1.06s steps(1) infinite;background-color:#7e7}@-moz-keyframes blink{50%{background-color:transparent}}@-webkit-keyframes blink{50%{background-color:transparent}}@keyframes blink{50%{background-color:transparent}}.cm-tab{display:inline-block;text-decoration:inherit}.CodeMirror-rulers{position:absolute;left:0;right:0;top:-50px;bottom:-20px;overflow:hidden}.CodeMirror-ruler{border-left:1px solid #ccc;top:0;bottom:0;position:absolute}.cm-s-default .cm-header{color:#00f}.cm-s-default .cm-quote{color:#090}.cm-negative{color:#d44}.cm-positive{color:#292}.cm-header,.cm-strong{font-weight:700}.cm-em{font-style:italic}.cm-link{text-decoration:underline}.cm-strikethrough{text-decoration:line-through}.cm-s-default .cm-keyword{color:#708}.cm-s-default .cm-atom{color:#219}.cm-s-default .cm-number{color:#164}.cm-s-default .cm-def{color:#00f}.cm-s-default .cm-variable-2{color:#05a}.cm-s-default .cm-type,.cm-s-default .cm-variable-3{color:#085}.cm-s-default .cm-comment{color:#a50}.cm-s-default .cm-string{color:#a11}.cm-s-default .cm-string-2{color:#f50}.cm-s-default .cm-meta{color:#555}.cm-s-default .cm-qualifier{color:#555}.cm-s-default .cm-builtin{color:#30a}.cm-s-default .cm-bracket{color:#997}.cm-s-default .cm-tag{color:#170}.cm-s-default .cm-attribute{color:#00c}.cm-s-default .cm-hr{color:#999}.cm-s-default .cm-link{color:#00c}.cm-s-default .cm-error{color:red}.cm-invalidchar{color:red}.CodeMirror-composing{border-bottom:2px solid}div.CodeMirror span.CodeMirror-matchingbracket{color:#0f0}div.CodeMirror span.CodeMirror-nonmatchingbracket{color:#f22}.CodeMirror-matchingtag{background:rgba(255,150,0,.3)}.CodeMirror-activeline-background{background:#e8f2ff}.CodeMirror{position:relative;overflow:hidden;background:#fff}.CodeMirror-scroll{overflow:scroll!important;margin-bottom:-30px;margin-right:-30px;padding-bottom:30px;height:100%;outline:0;position:relative}.CodeMirror-sizer{position:relative;border-right:30px solid transparent}.CodeMirror-gutter-filler,.CodeMirror-hscrollbar,.CodeMirror-scrollbar-filler,.CodeMirror-vscrollbar{position:absolute;z-index:6;display:none}.CodeMirror-vscrollbar{right:0;top:0;overflow-x:hidden;overflow-y:scroll}.CodeMirror-hscrollbar{bottom:0;left:0;overflow-y:hidden;overflow-x:scroll}.CodeMirror-scrollbar-filler{right:0;bottom:0}.CodeMirror-gutter-filler{left:0;bottom:0}.CodeMirror-gutters{position:absolute;left:0;top:0;min-height:100%;z-index:3}.CodeMirror-gutter{white-space:normal;height:100%;display:inline-block;vertical-align:top;margin-bottom:-30px}.CodeMirror-gutter-wrapper{position:absolute;z-index:4;background:0 0!important;border:none!important}.CodeMirror-gutter-background{position:absolute;top:0;bottom:0;z-index:4}.CodeMirror-gutter-elt{position:absolute;cursor:default;z-index:4}.CodeMirror-gutter-wrapper ::selection{background-color:transparent}.CodeMirror-gutter-wrapper ::-moz-selection{background-color:transparent}.CodeMirror-lines{cursor:text;min-height:1px}.CodeMirror pre{-moz-border-radius:0;-webkit-border-radius:0;border-radius:0;border-width:0;background:0 0;font-family:inherit;font-size:inherit;margin:0;white-space:pre;word-wrap:normal;line-height:inherit;color:inherit;z-index:2;position:relative;overflow:visible;-webkit-tap-highlight-color:transparent;-webkit-font-variant-ligatures:contextual;font-variant-ligatures:contextual}.CodeMirror-wrap pre{word-wrap:break-word;white-space:pre-wrap;word-break:normal}.CodeMirror-linebackground{position:absolute;left:0;right:0;top:0;bottom:0;z-index:0}.CodeMirror-linewidget{position:relative;z-index:2;overflow:auto}.CodeMirror-rtl pre{direction:rtl}.CodeMirror-code{outline:0}.CodeMirror-gutter,.CodeMirror-gutters,.CodeMirror-linenumber,.CodeMirror-scroll,.CodeMirror-sizer{-moz-box-sizing:content-box;box-sizing:content-box}.CodeMirror-measure{position:absolute;width:100%;height:0;overflow:hidden;visibility:hidden}.CodeMirror-cursor{position:absolute;pointer-events:none}.CodeMirror-measure pre{position:static}div.CodeMirror-cursors{visibility:hidden;position:relative;z-index:3}div.CodeMirror-dragcursors{visibility:visible}.CodeMirror-focused div.CodeMirror-cursors{visibility:visible}.CodeMirror-selected{background:#d9d9d9}.CodeMirror-focused .CodeMirror-selected{background:#d7d4f0}.CodeMirror-crosshair{cursor:crosshair}.CodeMirror-line::selection,.CodeMirror-line>span::selection,.CodeMirror-line>span>span::selection{background:#d7d4f0}.CodeMirror-line::-moz-selection,.CodeMirror-line>span::-moz-selection,.CodeMirror-line>span>span::-moz-selection{background:#d7d4f0}.cm-searching{background-color:#ffa;background-color:rgba(255,255,0,.4)}.cm-force-border{padding-right:.1px}@media print{.CodeMirror div.CodeMirror-cursors{visibility:hidden}}.cm-tab-wrap-hack:after{content:''}span.CodeMirror-selectedtext{background:0 0}
/*# sourceMappingURL=codemirror.min.css.map */

      .severity-low {
  background-color: #669603;
}

.severity-low:after {
  content : 'L';
}

.severity-unspecified {
  background-color: #666666;
}

.severity-unspecified:after {
  content : 'U';
}

.severity-style {
  background-color: #9932cc;
}

.severity-style:after {
  content : 'S';
}

.severity-medium {
  background-color: #a9d323;
  color: black;
}

.severity-medium:after {
  content : 'M';
}

.severity-high {
  background-color: #ffa800;
}

.severity-high:after {
  content : 'H';
}

.severity-critical {
  background-color: #e92625;
}

.severity-critical:after {
  content : 'C';
}

i[class*="severity-"] {
  line-height: normal;
  text-transform: capitalize;
  font-size: 0.8em;
  font-weight: bold;
  color: white;
  display: inline-block;
  width: 16px;
  height: 16px;
  text-align: center;
  font-family: sans-serif;
}

      html, body {
  width: 100%;
  height: 100%;
  padding: 0px;
  margin: 0px;
}

div.container {
  padding: 10px;
}

#content {
  height: 100%;
  display: block;
  overflow: hidden;
}

#content > div {
  margin: 10px;
  overflow: hidden;
  border: 1px solid #ddd;
  border-radius: 3px;
  overflow: hidden;
  height: 97%;
}

.button {
  background-color: #f1f1f1;
  text-decoration: none;
  display: inline-block;
  padding: 8px 16px;
  color: black;
  cursor: pointer;
}

.button:hover {
  background-color: #ddd;
  color: black;
}

.review-status {
  color: white;
  text-align: center;
}

.review-status-confirmed {
  background-color: #e92625;
}

.review-status-false-positive {
  background-color: grey;
}

.review-status-intentional {
  background-color: #669603;
}

      div.container {
  width: 100%;
  height: 100%;
  padding: 0px;
}

#editor-wrapper {
  margin: 10px;
}

#side-bar {
  float: left;
  width: 260px;
  margin: 0px;
}

#report-nav ul {
  list-style-type: none;
  padding: 0;
  margin: 0;
  overflow-y: auto;
  height: 100%;
}

#report-nav ul > li {
  padding: .4em;
  background-color: #fff;
  border-bottom: 1px solid rgba(0,0,0,.125);
  text-align: left;
  overflow: hidden;
  white-space: nowrap;
  text-overflow: ellipsis;
}

#report-nav ul > li.active {
  background-color: #427ea9;
  color: white;
}

#report-nav ul > li:hover {
  background-color: #427ea9;
  color: white;
  cursor: pointer;
}

#report-nav ul a {
  text-decoration: none;
}

#report-nav i[class*="severity-"] {
  margin-right: 5px;
}

.header {
  border-bottom: 1px solid lightgrey;
  font-family: monospace;
  padding: 10px;
  background-color: #fafbfc;
  border-bottom: 1px solid #e1e4e8;
  border-top-left-radius: 2px;
  border-top-right-radius: 2px;
}

#report-nav .header {
  font-weight: bold;
}

#editor-wrapper .header > div {
  padding-top: 2px;
}

#file-path,
#checker-name {
  color: #195ea2;
}

#review-status {
  padding: 0px 5px;
}

#file-path {
  font-family: monospace;
}

.check-msg {
  display: inline-block;
  padding: 3px 6px;
  margin: 1px;
  -webkit-border-radius: 5px;
  -moz-border-radius: 5px;
  border-radius: 5px;
}

.check-msg.info {
  color: #00546f;
  background-color: #bfdfe9;
  border: 1px solid #87a8b3;
}

.check-msg.error {
  background-color: #f2dede;
  color: #a94442;
  border: 1px solid #ebcccc;
}

.check-msg.macro {
  background-color: #d7dac2;
  color: #4f5c6d;
  border: 1px solid #d7dac2;
}

.check-msg.note {
  background-color: #d7d7d7;
  color: #4f5c6d;
  border: 1px solid #bfbfbf;
}

.check-msg.current {
  border: 2px dashed #3692ff;
}

.check-msg .tag {
  padding: 1px 5px;
  text-align: center;
  border-radius: 2px;
  margin-right: 5px;
  text-decoration: inherit;
}

.check-msg .tag.macro {
  background-color: #83876a;
  color: white;
  text-transform: capitalize;
}

.check-msg .tag.note {
  background-color: #9299a1;
  color: white;
  text-transform: capitalize;
}

.checker-enum {
  color: white;
  padding: 1px 5px;
  text-align: center;
  border-radius: 25px;
  margin-right: 5px;
  text-decoration: inherit;
}

.checker-enum.info {
  background-color: #427ea9;
}

.checker-enum.error {
  background-color: #a94442;
}

.arrow {
  border: solid black;
  border-width: 0 3px 3px 0;
  display: inline-block;
  padding: 3px;
  cursor: pointer;
  margin: 0px 5px;
}

.arrow:hover {
  border: solid #437ea8;
  border-width: 0 3px 3px 0;
}

.left-arrow {
  transform: rotate(135deg);
  -webkit-transform: rotate(135deg);
}

.right-arrow {
  transform: rotate(-45deg);
  -webkit-transform: rotate(-45deg);
}

    </style>

    <script type="text/javascript">
      function setNonCompatibleBrowserMessage() {
  document.body.innerHTML =
    '<h2 style="margin-left: 20px;">Your browser is not compatible with CodeChecker Viewer!</h2> \
     <p style="margin-left: 20px;">The version required for the following browsers are:</p> \
     <ul style="margin-left: 20px;"> \
     <li>Internet Explorer: version 9 or newer</li> \
     <li>Firefox: version 22.0 or newer</li> \
     </ul>';
}

// http://stackoverflow.com/questions/5916900/how-can-you-detect-the-version-of-a-browser
var browserVersion = (function(){
  var ua = navigator.userAgent, tem,
    M = ua.match(/(opera|chrome|safari|firefox|msie|trident(?=\/))\/?\s*(\d+)/i) || [];

  if (/trident/i.test(M[1])) {
    tem = /\brv[ :]+(\d+)/g.exec(ua) || [];
    return 'IE ' + (tem[1] || '');
  }

  if (M[1] === 'Chrome') {
    tem = ua.match(/\b(OPR|Edge)\/(\d+)/);
    if (tem != null) return tem.slice(1).join(' ').replace('OPR', 'Opera');
  }

  M = M[2] ? [M[1], M[2]] : [navigator.appName, navigator.appVersion, '-?'];
  if ((tem = ua.match(/version\/(\d+)/i)) != null) M.splice(1, 1, tem[1]);
    return M.join(' ');
})();

var pos = browserVersion.indexOf(' ');
var browser = browserVersion.substr(0, pos);
var version = parseInt(browserVersion.substr(pos + 1));

var browserCompatible
  = browser === 'Firefox'
  ? version >= 22
  : browser === 'IE'
  ? version >= 9
  : true;


      /* MIT License

Copyright (C) 2017 by Marijn Haverbeke <marijnh@gmail.com> and others

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
THE SOFTWARE.
 */
      !function(e,t){"object"==typeof exports&&"undefined"!=typeof module?module.exports=t():"function"==typeof define&&define.amd?define(t):e.CodeMirror=t()}(this,function(){"use strict";function e(e){return new RegExp("(^|\\s)"+e+"(?:$|\\s)\\s*")}function t(e){for(var t=e.childNodes.length;t>0;--t)e.removeChild(e.firstChild);return e}function r(e,r){return t(e).appendChild(r)}function n(e,t,r,n){var i=document.createElement(e);if(r&&(i.className=r),n&&(i.style.cssText=n),"string"==typeof t)i.appendChild(document.createTextNode(t));else if(t)for(var o=0;o<t.length;++o)i.appendChild(t[o]);return i}function i(e,t,r,i){var o=n(e,t,r,i);return o.setAttribute("role","presentation"),o}function o(e,t){if(3==t.nodeType&&(t=t.parentNode),e.contains)return e.contains(t);do{if(11==t.nodeType&&(t=t.host),t==e)return!0}while(t=t.parentNode)}function l(){var e;try{e=document.activeElement}catch(t){e=document.body||null}for(;e&&e.shadowRoot&&e.shadowRoot.activeElement;)e=e.shadowRoot.activeElement;return e}function s(t,r){var n=t.className;e(r).test(n)||(t.className+=(n?" ":"")+r)}function a(t,r){for(var n=t.split(" "),i=0;i<n.length;i++)n[i]&&!e(n[i]).test(r)&&(r+=" "+n[i]);return r}function u(e){var t=Array.prototype.slice.call(arguments,1);return function(){return e.apply(null,t)}}function c(e,t,r){t||(t={});for(var n in e)!e.hasOwnProperty(n)||!1===r&&t.hasOwnProperty(n)||(t[n]=e[n]);return t}function f(e,t,r,n,i){null==t&&-1==(t=e.search(/[^\s\u00a0]/))&&(t=e.length);for(var o=n||0,l=i||0;;){var s=e.indexOf("\t",o);if(s<0||s>=t)return l+(t-o);l+=s-o,l+=r-l%r,o=s+1}}function h(e,t){for(var r=0;r<e.length;++r)if(e[r]==t)return r;return-1}function d(e,t,r){for(var n=0,i=0;;){var o=e.indexOf("\t",n);-1==o&&(o=e.length);var l=o-n;if(o==e.length||i+l>=t)return n+Math.min(l,t-i);if(i+=o-n,i+=r-i%r,n=o+1,i>=t)return n}}function p(e){for(;Kl.length<=e;)Kl.push(g(Kl)+" ");return Kl[e]}function g(e){return e[e.length-1]}function v(e,t){for(var r=[],n=0;n<e.length;n++)r[n]=t(e[n],n);return r}function m(e,t,r){for(var n=0,i=r(t);n<e.length&&r(e[n])<=i;)n++;e.splice(n,0,t)}function y(){}function b(e,t){var r;return Object.create?r=Object.create(e):(y.prototype=e,r=new y),t&&c(t,r),r}function w(e){return/\w/.test(e)||e>""&&(e.toUpperCase()!=e.toLowerCase()||jl.test(e))}function x(e,t){return t?!!(t.source.indexOf("\\w")>-1&&w(e))||t.test(e):w(e)}function C(e){for(var t in e)if(e.hasOwnProperty(t)&&e[t])return!1;return!0}function S(e){return e.charCodeAt(0)>=768&&Xl.test(e)}function L(e,t,r){for(;(r<0?t>0:t<e.length)&&S(e.charAt(t));)t+=r;return t}function k(e,t,r){for(var n=t>r?-1:1;;){if(t==r)return t;var i=(t+r)/2,o=n<0?Math.ceil(i):Math.floor(i);if(o==t)return e(o)?t:r;e(o)?r=o:t=o+n}}function T(e,t,r){var o=this;this.input=r,o.scrollbarFiller=n("div",null,"CodeMirror-scrollbar-filler"),o.scrollbarFiller.setAttribute("cm-not-content","true"),o.gutterFiller=n("div",null,"CodeMirror-gutter-filler"),o.gutterFiller.setAttribute("cm-not-content","true"),o.lineDiv=i("div",null,"CodeMirror-code"),o.selectionDiv=n("div",null,null,"position: relative; z-index: 1"),o.cursorDiv=n("div",null,"CodeMirror-cursors"),o.measure=n("div",null,"CodeMirror-measure"),o.lineMeasure=n("div",null,"CodeMirror-measure"),o.lineSpace=i("div",[o.measure,o.lineMeasure,o.selectionDiv,o.cursorDiv,o.lineDiv],null,"position: relative; outline: none");var l=i("div",[o.lineSpace],"CodeMirror-lines");o.mover=n("div",[l],null,"position: relative"),o.sizer=n("div",[o.mover],"CodeMirror-sizer"),o.sizerWidth=null,o.heightForcer=n("div",null,null,"position: absolute; height: "+Rl+"px; width: 1px;"),o.gutters=n("div",null,"CodeMirror-gutters"),o.lineGutter=null,o.scroller=n("div",[o.sizer,o.heightForcer,o.gutters],"CodeMirror-scroll"),o.scroller.setAttribute("tabIndex","-1"),o.wrapper=n("div",[o.scrollbarFiller,o.gutterFiller,o.scroller],"CodeMirror"),gl&&vl<8&&(o.gutters.style.zIndex=-1,o.scroller.style.paddingRight=0),ml||fl&&Tl||(o.scroller.draggable=!0),e&&(e.appendChild?e.appendChild(o.wrapper):e(o.wrapper)),o.viewFrom=o.viewTo=t.first,o.reportedViewFrom=o.reportedViewTo=t.first,o.view=[],o.renderedView=null,o.externalMeasured=null,o.viewOffset=0,o.lastWrapHeight=o.lastWrapWidth=0,o.updateLineNumbers=null,o.nativeBarWidth=o.barHeight=o.barWidth=0,o.scrollbarsClipped=!1,o.lineNumWidth=o.lineNumInnerWidth=o.lineNumChars=null,o.alignWidgets=!1,o.cachedCharWidth=o.cachedTextHeight=o.cachedPaddingH=null,o.maxLine=null,o.maxLineLength=0,o.maxLineChanged=!1,o.wheelDX=o.wheelDY=o.wheelStartX=o.wheelStartY=null,o.shift=!1,o.selForContextMenu=null,o.activeTouch=null,r.init(o)}function M(e,t){if((t-=e.first)<0||t>=e.size)throw new Error("There is no line "+(t+e.first)+" in the document.");for(var r=e;!r.lines;)for(var n=0;;++n){var i=r.children[n],o=i.chunkSize();if(t<o){r=i;break}t-=o}return r.lines[t]}function N(e,t,r){var n=[],i=t.line;return e.iter(t.line,r.line+1,function(e){var o=e.text;i==r.line&&(o=o.slice(0,r.ch)),i==t.line&&(o=o.slice(t.ch)),n.push(o),++i}),n}function O(e,t,r){var n=[];return e.iter(t,r,function(e){n.push(e.text)}),n}function A(e,t){var r=t-e.height;if(r)for(var n=e;n;n=n.parent)n.height+=r}function W(e){if(null==e.parent)return null;for(var t=e.parent,r=h(t.lines,e),n=t.parent;n;t=n,n=n.parent)for(var i=0;n.children[i]!=t;++i)r+=n.children[i].chunkSize();return r+t.first}function D(e,t){var r=e.first;e:do{for(var n=0;n<e.children.length;++n){var i=e.children[n],o=i.height;if(t<o){e=i;continue e}t-=o,r+=i.chunkSize()}return r}while(!e.lines);for(var l=0;l<e.lines.length;++l){var s=e.lines[l].height;if(t<s)break;t-=s}return r+l}function H(e,t){return t>=e.first&&t<e.first+e.size}function F(e,t){return String(e.lineNumberFormatter(t+e.firstLineNumber))}function E(e,t,r){if(void 0===r&&(r=null),!(this instanceof E))return new E(e,t,r);this.line=e,this.ch=t,this.sticky=r}function P(e,t){return e.line-t.line||e.ch-t.ch}function I(e,t){return e.sticky==t.sticky&&0==P(e,t)}function z(e){return E(e.line,e.ch)}function R(e,t){return P(e,t)<0?t:e}function B(e,t){return P(e,t)<0?e:t}function G(e,t){return Math.max(e.first,Math.min(t,e.first+e.size-1))}function U(e,t){if(t.line<e.first)return E(e.first,0);var r=e.first+e.size-1;return t.line>r?E(r,M(e,r).text.length):V(t,M(e,t.line).text.length)}function V(e,t){var r=e.ch;return null==r||r>t?E(e.line,t):r<0?E(e.line,0):e}function K(e,t){for(var r=[],n=0;n<t.length;n++)r[n]=U(e,t[n]);return r}function j(){Yl=!0}function X(){_l=!0}function Y(e,t,r){this.marker=e,this.from=t,this.to=r}function _(e,t){if(e)for(var r=0;r<e.length;++r){var n=e[r];if(n.marker==t)return n}}function $(e,t){for(var r,n=0;n<e.length;++n)e[n]!=t&&(r||(r=[])).push(e[n]);return r}function q(e,t){e.markedSpans=e.markedSpans?e.markedSpans.concat([t]):[t],t.marker.attachLine(e)}function Z(e,t,r){var n;if(e)for(var i=0;i<e.length;++i){var o=e[i],l=o.marker;if(null==o.from||(l.inclusiveLeft?o.from<=t:o.from<t)||o.from==t&&"bookmark"==l.type&&(!r||!o.marker.insertLeft)){var s=null==o.to||(l.inclusiveRight?o.to>=t:o.to>t);(n||(n=[])).push(new Y(l,o.from,s?null:o.to))}}return n}function Q(e,t,r){var n;if(e)for(var i=0;i<e.length;++i){var o=e[i],l=o.marker;if(null==o.to||(l.inclusiveRight?o.to>=t:o.to>t)||o.from==t&&"bookmark"==l.type&&(!r||o.marker.insertLeft)){var s=null==o.from||(l.inclusiveLeft?o.from<=t:o.from<t);(n||(n=[])).push(new Y(l,s?null:o.from-t,null==o.to?null:o.to-t))}}return n}function J(e,t){if(t.full)return null;var r=H(e,t.from.line)&&M(e,t.from.line).markedSpans,n=H(e,t.to.line)&&M(e,t.to.line).markedSpans;if(!r&&!n)return null;var i=t.from.ch,o=t.to.ch,l=0==P(t.from,t.to),s=Z(r,i,l),a=Q(n,o,l),u=1==t.text.length,c=g(t.text).length+(u?i:0);if(s)for(var f=0;f<s.length;++f){var h=s[f];if(null==h.to){var d=_(a,h.marker);d?u&&(h.to=null==d.to?null:d.to+c):h.to=i}}if(a)for(var p=0;p<a.length;++p){var v=a[p];null!=v.to&&(v.to+=c),null==v.from?_(s,v.marker)||(v.from=c,u&&(s||(s=[])).push(v)):(v.from+=c,u&&(s||(s=[])).push(v))}s&&(s=ee(s)),a&&a!=s&&(a=ee(a));var m=[s];if(!u){var y,b=t.text.length-2;if(b>0&&s)for(var w=0;w<s.length;++w)null==s[w].to&&(y||(y=[])).push(new Y(s[w].marker,null,null));for(var x=0;x<b;++x)m.push(y);m.push(a)}return m}function ee(e){for(var t=0;t<e.length;++t){var r=e[t];null!=r.from&&r.from==r.to&&!1!==r.marker.clearWhenEmpty&&e.splice(t--,1)}return e.length?e:null}function te(e,t,r){var n=null;if(e.iter(t.line,r.line+1,function(e){if(e.markedSpans)for(var t=0;t<e.markedSpans.length;++t){var r=e.markedSpans[t].marker;!r.readOnly||n&&-1!=h(n,r)||(n||(n=[])).push(r)}}),!n)return null;for(var i=[{from:t,to:r}],o=0;o<n.length;++o)for(var l=n[o],s=l.find(0),a=0;a<i.length;++a){var u=i[a];if(!(P(u.to,s.from)<0||P(u.from,s.to)>0)){var c=[a,1],f=P(u.from,s.from),d=P(u.to,s.to);(f<0||!l.inclusiveLeft&&!f)&&c.push({from:u.from,to:s.from}),(d>0||!l.inclusiveRight&&!d)&&c.push({from:s.to,to:u.to}),i.splice.apply(i,c),a+=c.length-3}}return i}function re(e){var t=e.markedSpans;if(t){for(var r=0;r<t.length;++r)t[r].marker.detachLine(e);e.markedSpans=null}}function ne(e,t){if(t){for(var r=0;r<t.length;++r)t[r].marker.attachLine(e);e.markedSpans=t}}function ie(e){return e.inclusiveLeft?-1:0}function oe(e){return e.inclusiveRight?1:0}function le(e,t){var r=e.lines.length-t.lines.length;if(0!=r)return r;var n=e.find(),i=t.find(),o=P(n.from,i.from)||ie(e)-ie(t);if(o)return-o;var l=P(n.to,i.to)||oe(e)-oe(t);return l||t.id-e.id}function se(e,t){var r,n=_l&&e.markedSpans;if(n)for(var i=void 0,o=0;o<n.length;++o)(i=n[o]).marker.collapsed&&null==(t?i.from:i.to)&&(!r||le(r,i.marker)<0)&&(r=i.marker);return r}function ae(e){return se(e,!0)}function ue(e){return se(e,!1)}function ce(e,t,r,n,i){var o=M(e,t),l=_l&&o.markedSpans;if(l)for(var s=0;s<l.length;++s){var a=l[s];if(a.marker.collapsed){var u=a.marker.find(0),c=P(u.from,r)||ie(a.marker)-ie(i),f=P(u.to,n)||oe(a.marker)-oe(i);if(!(c>=0&&f<=0||c<=0&&f>=0)&&(c<=0&&(a.marker.inclusiveRight&&i.inclusiveLeft?P(u.to,r)>=0:P(u.to,r)>0)||c>=0&&(a.marker.inclusiveRight&&i.inclusiveLeft?P(u.from,n)<=0:P(u.from,n)<0)))return!0}}}function fe(e){for(var t;t=ae(e);)e=t.find(-1,!0).line;return e}function he(e){for(var t;t=ue(e);)e=t.find(1,!0).line;return e}function de(e){for(var t,r;t=ue(e);)e=t.find(1,!0).line,(r||(r=[])).push(e);return r}function pe(e,t){var r=M(e,t),n=fe(r);return r==n?t:W(n)}function ge(e,t){if(t>e.lastLine())return t;var r,n=M(e,t);if(!ve(e,n))return t;for(;r=ue(n);)n=r.find(1,!0).line;return W(n)+1}function ve(e,t){var r=_l&&t.markedSpans;if(r)for(var n=void 0,i=0;i<r.length;++i)if((n=r[i]).marker.collapsed){if(null==n.from)return!0;if(!n.marker.widgetNode&&0==n.from&&n.marker.inclusiveLeft&&me(e,t,n))return!0}}function me(e,t,r){if(null==r.to){var n=r.marker.find(1,!0);return me(e,n.line,_(n.line.markedSpans,r.marker))}if(r.marker.inclusiveRight&&r.to==t.text.length)return!0;for(var i=void 0,o=0;o<t.markedSpans.length;++o)if((i=t.markedSpans[o]).marker.collapsed&&!i.marker.widgetNode&&i.from==r.to&&(null==i.to||i.to!=r.from)&&(i.marker.inclusiveLeft||r.marker.inclusiveRight)&&me(e,t,i))return!0}function ye(e){for(var t=0,r=(e=fe(e)).parent,n=0;n<r.lines.length;++n){var i=r.lines[n];if(i==e)break;t+=i.height}for(var o=r.parent;o;r=o,o=r.parent)for(var l=0;l<o.children.length;++l){var s=o.children[l];if(s==r)break;t+=s.height}return t}function be(e){if(0==e.height)return 0;for(var t,r=e.text.length,n=e;t=ae(n);){var i=t.find(0,!0);n=i.from.line,r+=i.from.ch-i.to.ch}for(n=e;t=ue(n);){var o=t.find(0,!0);r-=n.text.length-o.from.ch,r+=(n=o.to.line).text.length-o.to.ch}return r}function we(e){var t=e.display,r=e.doc;t.maxLine=M(r,r.first),t.maxLineLength=be(t.maxLine),t.maxLineChanged=!0,r.iter(function(e){var r=be(e);r>t.maxLineLength&&(t.maxLineLength=r,t.maxLine=e)})}function xe(e,t,r,n){if(!e)return n(t,r,"ltr",0);for(var i=!1,o=0;o<e.length;++o){var l=e[o];(l.from<r&&l.to>t||t==r&&l.to==t)&&(n(Math.max(l.from,t),Math.min(l.to,r),1==l.level?"rtl":"ltr",o),i=!0)}i||n(t,r,"ltr")}function Ce(e,t,r){var n;$l=null;for(var i=0;i<e.length;++i){var o=e[i];if(o.from<t&&o.to>t)return i;o.to==t&&(o.from!=o.to&&"before"==r?n=i:$l=i),o.from==t&&(o.from!=o.to&&"before"!=r?n=i:$l=i)}return null!=n?n:$l}function Se(e,t){var r=e.order;return null==r&&(r=e.order=ql(e.text,t)),r}function Le(e,t){return e._handlers&&e._handlers[t]||Zl}function ke(e,t,r){if(e.removeEventListener)e.removeEventListener(t,r,!1);else if(e.detachEvent)e.detachEvent("on"+t,r);else{var n=e._handlers,i=n&&n[t];if(i){var o=h(i,r);o>-1&&(n[t]=i.slice(0,o).concat(i.slice(o+1)))}}}function Te(e,t){var r=Le(e,t);if(r.length)for(var n=Array.prototype.slice.call(arguments,2),i=0;i<r.length;++i)r[i].apply(null,n)}function Me(e,t,r){return"string"==typeof t&&(t={type:t,preventDefault:function(){this.defaultPrevented=!0}}),Te(e,r||t.type,e,t),He(t)||t.codemirrorIgnore}function Ne(e){var t=e._handlers&&e._handlers.cursorActivity;if(t)for(var r=e.curOp.cursorActivityHandlers||(e.curOp.cursorActivityHandlers=[]),n=0;n<t.length;++n)-1==h(r,t[n])&&r.push(t[n])}function Oe(e,t){return Le(e,t).length>0}function Ae(e){e.prototype.on=function(e,t){Ql(this,e,t)},e.prototype.off=function(e,t){ke(this,e,t)}}function We(e){e.preventDefault?e.preventDefault():e.returnValue=!1}function De(e){e.stopPropagation?e.stopPropagation():e.cancelBubble=!0}function He(e){return null!=e.defaultPrevented?e.defaultPrevented:0==e.returnValue}function Fe(e){We(e),De(e)}function Ee(e){return e.target||e.srcElement}function Pe(e){var t=e.which;return null==t&&(1&e.button?t=1:2&e.button?t=3:4&e.button&&(t=2)),Ml&&e.ctrlKey&&1==t&&(t=3),t}function Ie(e){if(null==Il){var t=n("span","​");r(e,n("span",[t,document.createTextNode("x")])),0!=e.firstChild.offsetHeight&&(Il=t.offsetWidth<=1&&t.offsetHeight>2&&!(gl&&vl<8))}var i=Il?n("span","​"):n("span"," ",null,"display: inline-block; width: 1px; margin-right: -1px");return i.setAttribute("cm-text",""),i}function ze(e){if(null!=zl)return zl;var n=r(e,document.createTextNode("AخA")),i=Wl(n,0,1).getBoundingClientRect(),o=Wl(n,1,2).getBoundingClientRect();return t(e),!(!i||i.left==i.right)&&(zl=o.right-i.right<3)}function Re(e){if(null!=ns)return ns;var t=r(e,n("span","x")),i=t.getBoundingClientRect(),o=Wl(t,0,1).getBoundingClientRect();return ns=Math.abs(i.left-o.left)>1}function Be(e,t){arguments.length>2&&(t.dependencies=Array.prototype.slice.call(arguments,2)),is[e]=t}function Ge(e){if("string"==typeof e&&os.hasOwnProperty(e))e=os[e];else if(e&&"string"==typeof e.name&&os.hasOwnProperty(e.name)){var t=os[e.name];"string"==typeof t&&(t={name:t}),(e=b(t,e)).name=t.name}else{if("string"==typeof e&&/^[\w\-]+\/[\w\-]+\+xml$/.test(e))return Ge("application/xml");if("string"==typeof e&&/^[\w\-]+\/[\w\-]+\+json$/.test(e))return Ge("application/json")}return"string"==typeof e?{name:e}:e||{name:"null"}}function Ue(e,t){t=Ge(t);var r=is[t.name];if(!r)return Ue(e,"text/plain");var n=r(e,t);if(ls.hasOwnProperty(t.name)){var i=ls[t.name];for(var o in i)i.hasOwnProperty(o)&&(n.hasOwnProperty(o)&&(n["_"+o]=n[o]),n[o]=i[o])}if(n.name=t.name,t.helperType&&(n.helperType=t.helperType),t.modeProps)for(var l in t.modeProps)n[l]=t.modeProps[l];return n}function Ve(e,t){c(t,ls.hasOwnProperty(e)?ls[e]:ls[e]={})}function Ke(e,t){if(!0===t)return t;if(e.copyState)return e.copyState(t);var r={};for(var n in t){var i=t[n];i instanceof Array&&(i=i.concat([])),r[n]=i}return r}function je(e,t){for(var r;e.innerMode&&(r=e.innerMode(t))&&r.mode!=e;)t=r.state,e=r.mode;return r||{mode:e,state:t}}function Xe(e,t,r){return!e.startState||e.startState(t,r)}function Ye(e,t,r,n){var i=[e.state.modeGen],o={};tt(e,t.text,e.doc.mode,r,function(e,t){return i.push(e,t)},o,n);for(var l=r.state,s=0;s<e.state.overlays.length;++s)!function(n){var l=e.state.overlays[n],s=1,a=0;r.state=!0,tt(e,t.text,l.mode,r,function(e,t){for(var r=s;a<e;){var n=i[s];n>e&&i.splice(s,1,e,i[s+1],n),s+=2,a=Math.min(e,n)}if(t)if(l.opaque)i.splice(r,s-r,e,"overlay "+t),s=r+2;else for(;r<s;r+=2){var o=i[r+1];i[r+1]=(o?o+" ":"")+"overlay "+t}},o)}(s);return r.state=l,{styles:i,classes:o.bgClass||o.textClass?o:null}}function _e(e,t,r){if(!t.styles||t.styles[0]!=e.state.modeGen){var n=$e(e,W(t)),i=t.text.length>e.options.maxHighlightLength&&Ke(e.doc.mode,n.state),o=Ye(e,t,n);i&&(n.state=i),t.stateAfter=n.save(!i),t.styles=o.styles,o.classes?t.styleClasses=o.classes:t.styleClasses&&(t.styleClasses=null),r===e.doc.highlightFrontier&&(e.doc.modeFrontier=Math.max(e.doc.modeFrontier,++e.doc.highlightFrontier))}return t.styles}function $e(e,t,r){var n=e.doc,i=e.display;if(!n.mode.startState)return new us(n,!0,t);var o=rt(e,t,r),l=o>n.first&&M(n,o-1).stateAfter,s=l?us.fromSaved(n,l,o):new us(n,Xe(n.mode),o);return n.iter(o,t,function(r){qe(e,r.text,s);var n=s.line;r.stateAfter=n==t-1||n%5==0||n>=i.viewFrom&&n<i.viewTo?s.save():null,s.nextLine()}),r&&(n.modeFrontier=s.line),s}function qe(e,t,r,n){var i=e.doc.mode,o=new ss(t,e.options.tabSize,r);for(o.start=o.pos=n||0,""==t&&Ze(i,r.state);!o.eol();)Qe(i,o,r.state),o.start=o.pos}function Ze(e,t){if(e.blankLine)return e.blankLine(t);if(e.innerMode){var r=je(e,t);return r.mode.blankLine?r.mode.blankLine(r.state):void 0}}function Qe(e,t,r,n){for(var i=0;i<10;i++){n&&(n[0]=je(e,r).mode);var o=e.token(t,r);if(t.pos>t.start)return o}throw new Error("Mode "+e.name+" failed to advance stream.")}function Je(e,t,r,n){var i,o,l=e.doc,s=l.mode,a=M(l,(t=U(l,t)).line),u=$e(e,t.line,r),c=new ss(a.text,e.options.tabSize,u);for(n&&(o=[]);(n||c.pos<t.ch)&&!c.eol();)c.start=c.pos,i=Qe(s,c,u.state),n&&o.push(new cs(c,i,Ke(l.mode,u.state)));return n?o:new cs(c,i,u.state)}function et(e,t){if(e)for(;;){var r=e.match(/(?:^|\s+)line-(background-)?(\S+)/);if(!r)break;e=e.slice(0,r.index)+e.slice(r.index+r[0].length);var n=r[1]?"bgClass":"textClass";null==t[n]?t[n]=r[2]:new RegExp("(?:^|s)"+r[2]+"(?:$|s)").test(t[n])||(t[n]+=" "+r[2])}return e}function tt(e,t,r,n,i,o,l){var s=r.flattenSpans;null==s&&(s=e.options.flattenSpans);var a,u=0,c=null,f=new ss(t,e.options.tabSize,n),h=e.options.addModeClass&&[null];for(""==t&&et(Ze(r,n.state),o);!f.eol();){if(f.pos>e.options.maxHighlightLength?(s=!1,l&&qe(e,t,n,f.pos),f.pos=t.length,a=null):a=et(Qe(r,f,n.state,h),o),h){var d=h[0].name;d&&(a="m-"+(a?d+" "+a:d))}if(!s||c!=a){for(;u<f.start;)i(u=Math.min(f.start,u+5e3),c);c=a}f.start=f.pos}for(;u<f.pos;){var p=Math.min(f.pos,u+5e3);i(p,c),u=p}}function rt(e,t,r){for(var n,i,o=e.doc,l=r?-1:t-(e.doc.mode.innerMode?1e3:100),s=t;s>l;--s){if(s<=o.first)return o.first;var a=M(o,s-1),u=a.stateAfter;if(u&&(!r||s+(u instanceof as?u.lookAhead:0)<=o.modeFrontier))return s;var c=f(a.text,null,e.options.tabSize);(null==i||n>c)&&(i=s-1,n=c)}return i}function nt(e,t){if(e.modeFrontier=Math.min(e.modeFrontier,t),!(e.highlightFrontier<t-10)){for(var r=e.first,n=t-1;n>r;n--){var i=M(e,n).stateAfter;if(i&&(!(i instanceof as)||n+i.lookAhead<t)){r=n+1;break}}e.highlightFrontier=Math.min(e.highlightFrontier,r)}}function it(e,t,r,n){e.text=t,e.stateAfter&&(e.stateAfter=null),e.styles&&(e.styles=null),null!=e.order&&(e.order=null),re(e),ne(e,r);var i=n?n(e):1;i!=e.height&&A(e,i)}function ot(e){e.parent=null,re(e)}function lt(e,t){if(!e||/^\s*$/.test(e))return null;var r=t.addModeClass?ps:ds;return r[e]||(r[e]=e.replace(/\S+/g,"cm-$&"))}function st(e,t){var r=i("span",null,null,ml?"padding-right: .1px":null),n={pre:i("pre",[r],"CodeMirror-line"),content:r,col:0,pos:0,cm:e,trailingSpace:!1,splitSpaces:(gl||ml)&&e.getOption("lineWrapping")};t.measure={};for(var o=0;o<=(t.rest?t.rest.length:0);o++){var l=o?t.rest[o-1]:t.line,s=void 0;n.pos=0,n.addToken=ut,ze(e.display.measure)&&(s=Se(l,e.doc.direction))&&(n.addToken=ft(n.addToken,s)),n.map=[],dt(l,n,_e(e,l,t!=e.display.externalMeasured&&W(l))),l.styleClasses&&(l.styleClasses.bgClass&&(n.bgClass=a(l.styleClasses.bgClass,n.bgClass||"")),l.styleClasses.textClass&&(n.textClass=a(l.styleClasses.textClass,n.textClass||""))),0==n.map.length&&n.map.push(0,0,n.content.appendChild(Ie(e.display.measure))),0==o?(t.measure.map=n.map,t.measure.cache={}):((t.measure.maps||(t.measure.maps=[])).push(n.map),(t.measure.caches||(t.measure.caches=[])).push({}))}if(ml){var u=n.content.lastChild;(/\bcm-tab\b/.test(u.className)||u.querySelector&&u.querySelector(".cm-tab"))&&(n.content.className="cm-tab-wrap-hack")}return Te(e,"renderLine",e,t.line,n.pre),n.pre.className&&(n.textClass=a(n.pre.className,n.textClass||"")),n}function at(e){var t=n("span","•","cm-invalidchar");return t.title="\\u"+e.charCodeAt(0).toString(16),t.setAttribute("aria-label",t.title),t}function ut(e,t,r,i,o,l,s){if(t){var a,u=e.splitSpaces?ct(t,e.trailingSpace):t,c=e.cm.state.specialChars,f=!1;if(c.test(t)){a=document.createDocumentFragment();for(var h=0;;){c.lastIndex=h;var d=c.exec(t),g=d?d.index-h:t.length-h;if(g){var v=document.createTextNode(u.slice(h,h+g));gl&&vl<9?a.appendChild(n("span",[v])):a.appendChild(v),e.map.push(e.pos,e.pos+g,v),e.col+=g,e.pos+=g}if(!d)break;h+=g+1;var m=void 0;if("\t"==d[0]){var y=e.cm.options.tabSize,b=y-e.col%y;(m=a.appendChild(n("span",p(b),"cm-tab"))).setAttribute("role","presentation"),m.setAttribute("cm-text","\t"),e.col+=b}else"\r"==d[0]||"\n"==d[0]?((m=a.appendChild(n("span","\r"==d[0]?"␍":"␤","cm-invalidchar"))).setAttribute("cm-text",d[0]),e.col+=1):((m=e.cm.options.specialCharPlaceholder(d[0])).setAttribute("cm-text",d[0]),gl&&vl<9?a.appendChild(n("span",[m])):a.appendChild(m),e.col+=1);e.map.push(e.pos,e.pos+1,m),e.pos++}}else e.col+=t.length,a=document.createTextNode(u),e.map.push(e.pos,e.pos+t.length,a),gl&&vl<9&&(f=!0),e.pos+=t.length;if(e.trailingSpace=32==u.charCodeAt(t.length-1),r||i||o||f||s){var w=r||"";i&&(w+=i),o&&(w+=o);var x=n("span",[a],w,s);return l&&(x.title=l),e.content.appendChild(x)}e.content.appendChild(a)}}function ct(e,t){if(e.length>1&&!/  /.test(e))return e;for(var r=t,n="",i=0;i<e.length;i++){var o=e.charAt(i);" "!=o||!r||i!=e.length-1&&32!=e.charCodeAt(i+1)||(o=" "),n+=o,r=" "==o}return n}function ft(e,t){return function(r,n,i,o,l,s,a){i=i?i+" cm-force-border":"cm-force-border";for(var u=r.pos,c=u+n.length;;){for(var f=void 0,h=0;h<t.length&&!((f=t[h]).to>u&&f.from<=u);h++);if(f.to>=c)return e(r,n,i,o,l,s,a);e(r,n.slice(0,f.to-u),i,o,null,s,a),o=null,n=n.slice(f.to-u),u=f.to}}}function ht(e,t,r,n){var i=!n&&r.widgetNode;i&&e.map.push(e.pos,e.pos+t,i),!n&&e.cm.display.input.needsContentAttribute&&(i||(i=e.content.appendChild(document.createElement("span"))),i.setAttribute("cm-marker",r.id)),i&&(e.cm.display.input.setUneditable(i),e.content.appendChild(i)),e.pos+=t,e.trailingSpace=!1}function dt(e,t,r){var n=e.markedSpans,i=e.text,o=0;if(n)for(var l,s,a,u,c,f,h,d=i.length,p=0,g=1,v="",m=0;;){if(m==p){a=u=c=f=s="",h=null,m=1/0;for(var y=[],b=void 0,w=0;w<n.length;++w){var x=n[w],C=x.marker;"bookmark"==C.type&&x.from==p&&C.widgetNode?y.push(C):x.from<=p&&(null==x.to||x.to>p||C.collapsed&&x.to==p&&x.from==p)?(null!=x.to&&x.to!=p&&m>x.to&&(m=x.to,u=""),C.className&&(a+=" "+C.className),C.css&&(s=(s?s+";":"")+C.css),C.startStyle&&x.from==p&&(c+=" "+C.startStyle),C.endStyle&&x.to==m&&(b||(b=[])).push(C.endStyle,x.to),C.title&&!f&&(f=C.title),C.collapsed&&(!h||le(h.marker,C)<0)&&(h=x)):x.from>p&&m>x.from&&(m=x.from)}if(b)for(var S=0;S<b.length;S+=2)b[S+1]==m&&(u+=" "+b[S]);if(!h||h.from==p)for(var L=0;L<y.length;++L)ht(t,0,y[L]);if(h&&(h.from||0)==p){if(ht(t,(null==h.to?d+1:h.to)-p,h.marker,null==h.from),null==h.to)return;h.to==p&&(h=!1)}}if(p>=d)break;for(var k=Math.min(d,m);;){if(v){var T=p+v.length;if(!h){var M=T>k?v.slice(0,k-p):v;t.addToken(t,M,l?l+a:a,c,p+M.length==m?u:"",f,s)}if(T>=k){v=v.slice(k-p),p=k;break}p=T,c=""}v=i.slice(o,o=r[g++]),l=lt(r[g++],t.cm.options)}}else for(var N=1;N<r.length;N+=2)t.addToken(t,i.slice(o,o=r[N]),lt(r[N+1],t.cm.options))}function pt(e,t,r){this.line=t,this.rest=de(t),this.size=this.rest?W(g(this.rest))-r+1:1,this.node=this.text=null,this.hidden=ve(e,t)}function gt(e,t,r){for(var n,i=[],o=t;o<r;o=n){var l=new pt(e.doc,M(e.doc,o),o);n=o+l.size,i.push(l)}return i}function vt(e){gs?gs.ops.push(e):e.ownsGroup=gs={ops:[e],delayedCallbacks:[]}}function mt(e){var t=e.delayedCallbacks,r=0;do{for(;r<t.length;r++)t[r].call(null);for(var n=0;n<e.ops.length;n++){var i=e.ops[n];if(i.cursorActivityHandlers)for(;i.cursorActivityCalled<i.cursorActivityHandlers.length;)i.cursorActivityHandlers[i.cursorActivityCalled++].call(null,i.cm)}}while(r<t.length)}function yt(e,t){var r=e.ownsGroup;if(r)try{mt(r)}finally{gs=null,t(r)}}function bt(e,t){var r=Le(e,t);if(r.length){var n,i=Array.prototype.slice.call(arguments,2);gs?n=gs.delayedCallbacks:vs?n=vs:(n=vs=[],setTimeout(wt,0));for(var o=0;o<r.length;++o)!function(e){n.push(function(){return r[e].apply(null,i)})}(o)}}function wt(){var e=vs;vs=null;for(var t=0;t<e.length;++t)e[t]()}function xt(e,t,r,n){for(var i=0;i<t.changes.length;i++){var o=t.changes[i];"text"==o?kt(e,t):"gutter"==o?Mt(e,t,r,n):"class"==o?Tt(e,t):"widget"==o&&Nt(e,t,n)}t.changes=null}function Ct(e){return e.node==e.text&&(e.node=n("div",null,null,"position: relative"),e.text.parentNode&&e.text.parentNode.replaceChild(e.node,e.text),e.node.appendChild(e.text),gl&&vl<8&&(e.node.style.zIndex=2)),e.node}function St(e,t){var r=t.bgClass?t.bgClass+" "+(t.line.bgClass||""):t.line.bgClass;if(r&&(r+=" CodeMirror-linebackground"),t.background)r?t.background.className=r:(t.background.parentNode.removeChild(t.background),t.background=null);else if(r){var i=Ct(t);t.background=i.insertBefore(n("div",null,r),i.firstChild),e.display.input.setUneditable(t.background)}}function Lt(e,t){var r=e.display.externalMeasured;return r&&r.line==t.line?(e.display.externalMeasured=null,t.measure=r.measure,r.built):st(e,t)}function kt(e,t){var r=t.text.className,n=Lt(e,t);t.text==t.node&&(t.node=n.pre),t.text.parentNode.replaceChild(n.pre,t.text),t.text=n.pre,n.bgClass!=t.bgClass||n.textClass!=t.textClass?(t.bgClass=n.bgClass,t.textClass=n.textClass,Tt(e,t)):r&&(t.text.className=r)}function Tt(e,t){St(e,t),t.line.wrapClass?Ct(t).className=t.line.wrapClass:t.node!=t.text&&(t.node.className="");var r=t.textClass?t.textClass+" "+(t.line.textClass||""):t.line.textClass;t.text.className=r||""}function Mt(e,t,r,i){if(t.gutter&&(t.node.removeChild(t.gutter),t.gutter=null),t.gutterBackground&&(t.node.removeChild(t.gutterBackground),t.gutterBackground=null),t.line.gutterClass){var o=Ct(t);t.gutterBackground=n("div",null,"CodeMirror-gutter-background "+t.line.gutterClass,"left: "+(e.options.fixedGutter?i.fixedPos:-i.gutterTotalWidth)+"px; width: "+i.gutterTotalWidth+"px"),e.display.input.setUneditable(t.gutterBackground),o.insertBefore(t.gutterBackground,t.text)}var l=t.line.gutterMarkers;if(e.options.lineNumbers||l){var s=Ct(t),a=t.gutter=n("div",null,"CodeMirror-gutter-wrapper","left: "+(e.options.fixedGutter?i.fixedPos:-i.gutterTotalWidth)+"px");if(e.display.input.setUneditable(a),s.insertBefore(a,t.text),t.line.gutterClass&&(a.className+=" "+t.line.gutterClass),!e.options.lineNumbers||l&&l["CodeMirror-linenumbers"]||(t.lineNumber=a.appendChild(n("div",F(e.options,r),"CodeMirror-linenumber CodeMirror-gutter-elt","left: "+i.gutterLeft["CodeMirror-linenumbers"]+"px; width: "+e.display.lineNumInnerWidth+"px"))),l)for(var u=0;u<e.options.gutters.length;++u){var c=e.options.gutters[u],f=l.hasOwnProperty(c)&&l[c];f&&a.appendChild(n("div",[f],"CodeMirror-gutter-elt","left: "+i.gutterLeft[c]+"px; width: "+i.gutterWidth[c]+"px"))}}}function Nt(e,t,r){t.alignable&&(t.alignable=null);for(var n=t.node.firstChild,i=void 0;n;n=i)i=n.nextSibling,"CodeMirror-linewidget"==n.className&&t.node.removeChild(n);At(e,t,r)}function Ot(e,t,r,n){var i=Lt(e,t);return t.text=t.node=i.pre,i.bgClass&&(t.bgClass=i.bgClass),i.textClass&&(t.textClass=i.textClass),Tt(e,t),Mt(e,t,r,n),At(e,t,n),t.node}function At(e,t,r){if(Wt(e,t.line,t,r,!0),t.rest)for(var n=0;n<t.rest.length;n++)Wt(e,t.rest[n],t,r,!1)}function Wt(e,t,r,i,o){if(t.widgets)for(var l=Ct(r),s=0,a=t.widgets;s<a.length;++s){var u=a[s],c=n("div",[u.node],"CodeMirror-linewidget");u.handleMouseEvents||c.setAttribute("cm-ignore-events","true"),Dt(u,c,r,i),e.display.input.setUneditable(c),o&&u.above?l.insertBefore(c,r.gutter||r.text):l.appendChild(c),bt(u,"redraw")}}function Dt(e,t,r,n){if(e.noHScroll){(r.alignable||(r.alignable=[])).push(t);var i=n.wrapperWidth;t.style.left=n.fixedPos+"px",e.coverGutter||(i-=n.gutterTotalWidth,t.style.paddingLeft=n.gutterTotalWidth+"px"),t.style.width=i+"px"}e.coverGutter&&(t.style.zIndex=5,t.style.position="relative",e.noHScroll||(t.style.marginLeft=-n.gutterTotalWidth+"px"))}function Ht(e){if(null!=e.height)return e.height;var t=e.doc.cm;if(!t)return 0;if(!o(document.body,e.node)){var i="position: relative;";e.coverGutter&&(i+="margin-left: -"+t.display.gutters.offsetWidth+"px;"),e.noHScroll&&(i+="width: "+t.display.wrapper.clientWidth+"px;"),r(t.display.measure,n("div",[e.node],null,i))}return e.height=e.node.parentNode.offsetHeight}function Ft(e,t){for(var r=Ee(t);r!=e.wrapper;r=r.parentNode)if(!r||1==r.nodeType&&"true"==r.getAttribute("cm-ignore-events")||r.parentNode==e.sizer&&r!=e.mover)return!0}function Et(e){return e.lineSpace.offsetTop}function Pt(e){return e.mover.offsetHeight-e.lineSpace.offsetHeight}function It(e){if(e.cachedPaddingH)return e.cachedPaddingH;var t=r(e.measure,n("pre","x")),i=window.getComputedStyle?window.getComputedStyle(t):t.currentStyle,o={left:parseInt(i.paddingLeft),right:parseInt(i.paddingRight)};return isNaN(o.left)||isNaN(o.right)||(e.cachedPaddingH=o),o}function zt(e){return Rl-e.display.nativeBarWidth}function Rt(e){return e.display.scroller.clientWidth-zt(e)-e.display.barWidth}function Bt(e){return e.display.scroller.clientHeight-zt(e)-e.display.barHeight}function Gt(e,t,r){var n=e.options.lineWrapping,i=n&&Rt(e);if(!t.measure.heights||n&&t.measure.width!=i){var o=t.measure.heights=[];if(n){t.measure.width=i;for(var l=t.text.firstChild.getClientRects(),s=0;s<l.length-1;s++){var a=l[s],u=l[s+1];Math.abs(a.bottom-u.bottom)>2&&o.push((a.bottom+u.top)/2-r.top)}}o.push(r.bottom-r.top)}}function Ut(e,t,r){if(e.line==t)return{map:e.measure.map,cache:e.measure.cache};for(var n=0;n<e.rest.length;n++)if(e.rest[n]==t)return{map:e.measure.maps[n],cache:e.measure.caches[n]};for(var i=0;i<e.rest.length;i++)if(W(e.rest[i])>r)return{map:e.measure.maps[i],cache:e.measure.caches[i],before:!0}}function Vt(e,t){var n=W(t=fe(t)),i=e.display.externalMeasured=new pt(e.doc,t,n);i.lineN=n;var o=i.built=st(e,i);return i.text=o.pre,r(e.display.lineMeasure,o.pre),i}function Kt(e,t,r,n){return Yt(e,Xt(e,t),r,n)}function jt(e,t){if(t>=e.display.viewFrom&&t<e.display.viewTo)return e.display.view[Lr(e,t)];var r=e.display.externalMeasured;return r&&t>=r.lineN&&t<r.lineN+r.size?r:void 0}function Xt(e,t){var r=W(t),n=jt(e,r);n&&!n.text?n=null:n&&n.changes&&(xt(e,n,r,br(e)),e.curOp.forceUpdate=!0),n||(n=Vt(e,t));var i=Ut(n,t,r);return{line:t,view:n,rect:null,map:i.map,cache:i.cache,before:i.before,hasHeights:!1}}function Yt(e,t,r,n,i){t.before&&(r=-1);var o,l=r+(n||"");return t.cache.hasOwnProperty(l)?o=t.cache[l]:(t.rect||(t.rect=t.view.text.getBoundingClientRect()),t.hasHeights||(Gt(e,t.view,t.rect),t.hasHeights=!0),(o=qt(e,t,r,n)).bogus||(t.cache[l]=o)),{left:o.left,right:o.right,top:i?o.rtop:o.top,bottom:i?o.rbottom:o.bottom}}function _t(e,t,r){for(var n,i,o,l,s,a,u=0;u<e.length;u+=3)if(s=e[u],a=e[u+1],t<s?(i=0,o=1,l="left"):t<a?o=(i=t-s)+1:(u==e.length-3||t==a&&e[u+3]>t)&&(i=(o=a-s)-1,t>=a&&(l="right")),null!=i){if(n=e[u+2],s==a&&r==(n.insertLeft?"left":"right")&&(l=r),"left"==r&&0==i)for(;u&&e[u-2]==e[u-3]&&e[u-1].insertLeft;)n=e[2+(u-=3)],l="left";if("right"==r&&i==a-s)for(;u<e.length-3&&e[u+3]==e[u+4]&&!e[u+5].insertLeft;)n=e[(u+=3)+2],l="right";break}return{node:n,start:i,end:o,collapse:l,coverStart:s,coverEnd:a}}function $t(e,t){var r=ms;if("left"==t)for(var n=0;n<e.length&&(r=e[n]).left==r.right;n++);else for(var i=e.length-1;i>=0&&(r=e[i]).left==r.right;i--);return r}function qt(e,t,r,n){var i,o=_t(t.map,r,n),l=o.node,s=o.start,a=o.end,u=o.collapse;if(3==l.nodeType){for(var c=0;c<4;c++){for(;s&&S(t.line.text.charAt(o.coverStart+s));)--s;for(;o.coverStart+a<o.coverEnd&&S(t.line.text.charAt(o.coverStart+a));)++a;if((i=gl&&vl<9&&0==s&&a==o.coverEnd-o.coverStart?l.parentNode.getBoundingClientRect():$t(Wl(l,s,a).getClientRects(),n)).left||i.right||0==s)break;a=s,s-=1,u="right"}gl&&vl<11&&(i=Zt(e.display.measure,i))}else{s>0&&(u=n="right");var f;i=e.options.lineWrapping&&(f=l.getClientRects()).length>1?f["right"==n?f.length-1:0]:l.getBoundingClientRect()}if(gl&&vl<9&&!s&&(!i||!i.left&&!i.right)){var h=l.parentNode.getClientRects()[0];i=h?{left:h.left,right:h.left+yr(e.display),top:h.top,bottom:h.bottom}:ms}for(var d=i.top-t.rect.top,p=i.bottom-t.rect.top,g=(d+p)/2,v=t.view.measure.heights,m=0;m<v.length-1&&!(g<v[m]);m++);var y=m?v[m-1]:0,b=v[m],w={left:("right"==u?i.right:i.left)-t.rect.left,right:("left"==u?i.left:i.right)-t.rect.left,top:y,bottom:b};return i.left||i.right||(w.bogus=!0),e.options.singleCursorHeightPerLine||(w.rtop=d,w.rbottom=p),w}function Zt(e,t){if(!window.screen||null==screen.logicalXDPI||screen.logicalXDPI==screen.deviceXDPI||!Re(e))return t;var r=screen.logicalXDPI/screen.deviceXDPI,n=screen.logicalYDPI/screen.deviceYDPI;return{left:t.left*r,right:t.right*r,top:t.top*n,bottom:t.bottom*n}}function Qt(e){if(e.measure&&(e.measure.cache={},e.measure.heights=null,e.rest))for(var t=0;t<e.rest.length;t++)e.measure.caches[t]={}}function Jt(e){e.display.externalMeasure=null,t(e.display.lineMeasure);for(var r=0;r<e.display.view.length;r++)Qt(e.display.view[r])}function er(e){Jt(e),e.display.cachedCharWidth=e.display.cachedTextHeight=e.display.cachedPaddingH=null,e.options.lineWrapping||(e.display.maxLineChanged=!0),e.display.lineNumChars=null}function tr(){return bl&&kl?-(document.body.getBoundingClientRect().left-parseInt(getComputedStyle(document.body).marginLeft)):window.pageXOffset||(document.documentElement||document.body).scrollLeft}function rr(){return bl&&kl?-(document.body.getBoundingClientRect().top-parseInt(getComputedStyle(document.body).marginTop)):window.pageYOffset||(document.documentElement||document.body).scrollTop}function nr(e){var t=0;if(e.widgets)for(var r=0;r<e.widgets.length;++r)e.widgets[r].above&&(t+=Ht(e.widgets[r]));return t}function ir(e,t,r,n,i){if(!i){var o=nr(t);r.top+=o,r.bottom+=o}if("line"==n)return r;n||(n="local");var l=ye(t);if("local"==n?l+=Et(e.display):l-=e.display.viewOffset,"page"==n||"window"==n){var s=e.display.lineSpace.getBoundingClientRect();l+=s.top+("window"==n?0:rr());var a=s.left+("window"==n?0:tr());r.left+=a,r.right+=a}return r.top+=l,r.bottom+=l,r}function or(e,t,r){if("div"==r)return t;var n=t.left,i=t.top;if("page"==r)n-=tr(),i-=rr();else if("local"==r||!r){var o=e.display.sizer.getBoundingClientRect();n+=o.left,i+=o.top}var l=e.display.lineSpace.getBoundingClientRect();return{left:n-l.left,top:i-l.top}}function lr(e,t,r,n,i){return n||(n=M(e.doc,t.line)),ir(e,n,Kt(e,n,t.ch,i),r)}function sr(e,t,r,n,i,o){function l(t,l){var s=Yt(e,i,t,l?"right":"left",o);return l?s.left=s.right:s.right=s.left,ir(e,n,s,r)}function s(e,t,r){var n=1==a[t].level;return l(r?e-1:e,n!=r)}n=n||M(e.doc,t.line),i||(i=Xt(e,n));var a=Se(n,e.doc.direction),u=t.ch,c=t.sticky;if(u>=n.text.length?(u=n.text.length,c="before"):u<=0&&(u=0,c="after"),!a)return l("before"==c?u-1:u,"before"==c);var f=Ce(a,u,c),h=$l,d=s(u,f,"before"==c);return null!=h&&(d.other=s(u,h,"before"!=c)),d}function ar(e,t){var r=0;t=U(e.doc,t),e.options.lineWrapping||(r=yr(e.display)*t.ch);var n=M(e.doc,t.line),i=ye(n)+Et(e.display);return{left:r,right:r,top:i,bottom:i+n.height}}function ur(e,t,r,n,i){var o=E(e,t,r);return o.xRel=i,n&&(o.outside=!0),o}function cr(e,t,r){var n=e.doc;if((r+=e.display.viewOffset)<0)return ur(n.first,0,null,!0,-1);var i=D(n,r),o=n.first+n.size-1;if(i>o)return ur(n.first+n.size-1,M(n,o).text.length,null,!0,1);t<0&&(t=0);for(var l=M(n,i);;){var s=pr(e,l,i,t,r),a=ue(l),u=a&&a.find(0,!0);if(!a||!(s.ch>u.from.ch||s.ch==u.from.ch&&s.xRel>0))return s;i=W(l=u.to.line)}}function fr(e,t,r,n){n-=nr(t);var i=t.text.length,o=k(function(t){return Yt(e,r,t-1).bottom<=n},i,0);return i=k(function(t){return Yt(e,r,t).top>n},o,i),{begin:o,end:i}}function hr(e,t,r,n){return r||(r=Xt(e,t)),fr(e,t,r,ir(e,t,Yt(e,r,n),"line").top)}function dr(e,t,r,n){return!(e.bottom<=r)&&(e.top>r||(n?e.left:e.right)>t)}function pr(e,t,r,n,i){i-=ye(t);var o=Xt(e,t),l=nr(t),s=0,a=t.text.length,u=!0,c=Se(t,e.doc.direction);if(c){var f=(e.options.lineWrapping?vr:gr)(e,t,r,o,c,n,i);s=(u=1!=f.level)?f.from:f.to-1,a=u?f.to:f.from-1}var h,d,p=null,g=null,v=k(function(t){var r=Yt(e,o,t);return r.top+=l,r.bottom+=l,!!dr(r,n,i,!1)&&(r.top<=i&&r.left<=n&&(p=t,g=r),!0)},s,a),m=!1;if(g){var y=n-g.left<g.right-n,b=y==u;v=p+(b?0:1),d=b?"after":"before",h=y?g.left:g.right}else{u||v!=a&&v!=s||v++,d=0==v?"after":v==t.text.length?"before":Yt(e,o,v-(u?1:0)).bottom+l<=i==u?"after":"before";var w=sr(e,E(r,v,d),"line",t,o);h=w.left,m=i<w.top||i>=w.bottom}return v=L(t.text,v,1),ur(r,v,d,m,n-h)}function gr(e,t,r,n,i,o,l){var s=k(function(s){var a=i[s],u=1!=a.level;return dr(sr(e,E(r,u?a.to:a.from,u?"before":"after"),"line",t,n),o,l,!0)},0,i.length-1),a=i[s];if(s>0){var u=1!=a.level,c=sr(e,E(r,u?a.from:a.to,u?"after":"before"),"line",t,n);dr(c,o,l,!0)&&c.top>l&&(a=i[s-1])}return a}function vr(e,t,r,n,i,o,l){for(var s=fr(e,t,n,l),a=s.begin,u=s.end,c=null,f=null,h=0;h<i.length;h++){var d=i[h];if(!(d.from>=u||d.to<=a)){var p=Yt(e,n,1!=d.level?Math.min(u,d.to)-1:Math.max(a,d.from)).right,g=p<o?o-p+1e9:p-o;(!c||f>g)&&(c=d,f=g)}}return c||(c=i[i.length-1]),c.from<a&&(c={from:a,to:c.to,level:c.level}),c.to>u&&(c={from:c.from,to:u,level:c.level}),c}function mr(e){if(null!=e.cachedTextHeight)return e.cachedTextHeight;if(null==hs){hs=n("pre");for(var i=0;i<49;++i)hs.appendChild(document.createTextNode("x")),hs.appendChild(n("br"));hs.appendChild(document.createTextNode("x"))}r(e.measure,hs);var o=hs.offsetHeight/50;return o>3&&(e.cachedTextHeight=o),t(e.measure),o||1}function yr(e){if(null!=e.cachedCharWidth)return e.cachedCharWidth;var t=n("span","xxxxxxxxxx"),i=n("pre",[t]);r(e.measure,i);var o=t.getBoundingClientRect(),l=(o.right-o.left)/10;return l>2&&(e.cachedCharWidth=l),l||10}function br(e){for(var t=e.display,r={},n={},i=t.gutters.clientLeft,o=t.gutters.firstChild,l=0;o;o=o.nextSibling,++l)r[e.options.gutters[l]]=o.offsetLeft+o.clientLeft+i,n[e.options.gutters[l]]=o.clientWidth;return{fixedPos:wr(t),gutterTotalWidth:t.gutters.offsetWidth,gutterLeft:r,gutterWidth:n,wrapperWidth:t.wrapper.clientWidth}}function wr(e){return e.scroller.getBoundingClientRect().left-e.sizer.getBoundingClientRect().left}function xr(e){var t=mr(e.display),r=e.options.lineWrapping,n=r&&Math.max(5,e.display.scroller.clientWidth/yr(e.display)-3);return function(i){if(ve(e.doc,i))return 0;var o=0;if(i.widgets)for(var l=0;l<i.widgets.length;l++)i.widgets[l].height&&(o+=i.widgets[l].height);return r?o+(Math.ceil(i.text.length/n)||1)*t:o+t}}function Cr(e){var t=e.doc,r=xr(e);t.iter(function(e){var t=r(e);t!=e.height&&A(e,t)})}function Sr(e,t,r,n){var i=e.display;if(!r&&"true"==Ee(t).getAttribute("cm-not-content"))return null;var o,l,s=i.lineSpace.getBoundingClientRect();try{o=t.clientX-s.left,l=t.clientY-s.top}catch(t){return null}var a,u=cr(e,o,l);if(n&&1==u.xRel&&(a=M(e.doc,u.line).text).length==u.ch){var c=f(a,a.length,e.options.tabSize)-a.length;u=E(u.line,Math.max(0,Math.round((o-It(e.display).left)/yr(e.display))-c))}return u}function Lr(e,t){if(t>=e.display.viewTo)return null;if((t-=e.display.viewFrom)<0)return null;for(var r=e.display.view,n=0;n<r.length;n++)if((t-=r[n].size)<0)return n}function kr(e){e.display.input.showSelection(e.display.input.prepareSelection())}function Tr(e,t){void 0===t&&(t=!0);for(var r=e.doc,n={},i=n.cursors=document.createDocumentFragment(),o=n.selection=document.createDocumentFragment(),l=0;l<r.sel.ranges.length;l++)if(t||l!=r.sel.primIndex){var s=r.sel.ranges[l];if(!(s.from().line>=e.display.viewTo||s.to().line<e.display.viewFrom)){var a=s.empty();(a||e.options.showCursorWhenSelecting)&&Mr(e,s.head,i),a||Or(e,s,o)}}return n}function Mr(e,t,r){var i=sr(e,t,"div",null,null,!e.options.singleCursorHeightPerLine),o=r.appendChild(n("div"," ","CodeMirror-cursor"));if(o.style.left=i.left+"px",o.style.top=i.top+"px",o.style.height=Math.max(0,i.bottom-i.top)*e.options.cursorHeight+"px",i.other){var l=r.appendChild(n("div"," ","CodeMirror-cursor CodeMirror-secondarycursor"));l.style.display="",l.style.left=i.other.left+"px",l.style.top=i.other.top+"px",l.style.height=.85*(i.other.bottom-i.other.top)+"px"}}function Nr(e,t){return e.top-t.top||e.left-t.left}function Or(e,t,r){function i(e,t,r,i){t<0&&(t=0),t=Math.round(t),i=Math.round(i),a.appendChild(n("div",null,"CodeMirror-selected","position: absolute; left: "+e+"px;\n                             top: "+t+"px; width: "+(null==r?f-e:r)+"px;\n                             height: "+(i-t)+"px"))}function o(t,r,n){function o(r,n){return lr(e,E(t,r),"div",u,n)}var l,a,u=M(s,t),h=u.text.length,d=Se(u,s.direction);return xe(d,r||0,null==n?h:n,function(t,s,p,g){var v=o(t,"ltr"==p?"left":"right"),m=o(s-1,"ltr"==p?"right":"left");if("ltr"==p){var y=null==r&&0==t?c:v.left,b=null==n&&s==h?f:m.right;m.top-v.top<=3?i(y,m.top,b-y,m.bottom):(i(y,v.top,null,v.bottom),v.bottom<m.top&&i(c,v.bottom,null,m.top),i(c,m.top,m.right,m.bottom))}else if(t<s){var w=null==r&&0==t?f:v.right,x=null==n&&s==h?c:m.left;if(m.top-v.top<=3)i(x,m.top,w-x,m.bottom);else{var C=c;if(g){var S=hr(e,u,null,t).end;C=o(S-(/\s/.test(u.text.charAt(S-1))?2:1),"left").left}i(C,v.top,w-C,v.bottom),v.bottom<m.top&&i(c,v.bottom,null,m.top);var L=null;d.length,L=o(hr(e,u,null,s).begin,"right").right-x,i(x,m.top,L,m.bottom)}}(!l||Nr(v,l)<0)&&(l=v),Nr(m,l)<0&&(l=m),(!a||Nr(v,a)<0)&&(a=v),Nr(m,a)<0&&(a=m)}),{start:l,end:a}}var l=e.display,s=e.doc,a=document.createDocumentFragment(),u=It(e.display),c=u.left,f=Math.max(l.sizerWidth,Rt(e)-l.sizer.offsetLeft)-u.right,h=t.from(),d=t.to();if(h.line==d.line)o(h.line,h.ch,d.ch);else{var p=M(s,h.line),g=M(s,d.line),v=fe(p)==fe(g),m=o(h.line,h.ch,v?p.text.length+1:null).end,y=o(d.line,v?0:null,d.ch).start;v&&(m.top<y.top-2?(i(m.right,m.top,null,m.bottom),i(c,y.top,y.left,y.bottom)):i(m.right,m.top,y.left-m.right,m.bottom)),m.bottom<y.top&&i(c,m.bottom,null,y.top)}r.appendChild(a)}function Ar(e){if(e.state.focused){var t=e.display;clearInterval(t.blinker);var r=!0;t.cursorDiv.style.visibility="",e.options.cursorBlinkRate>0?t.blinker=setInterval(function(){return t.cursorDiv.style.visibility=(r=!r)?"":"hidden"},e.options.cursorBlinkRate):e.options.cursorBlinkRate<0&&(t.cursorDiv.style.visibility="hidden")}}function Wr(e){e.state.focused||(e.display.input.focus(),Hr(e))}function Dr(e){e.state.delayingBlurEvent=!0,setTimeout(function(){e.state.delayingBlurEvent&&(e.state.delayingBlurEvent=!1,Fr(e))},100)}function Hr(e,t){e.state.delayingBlurEvent&&(e.state.delayingBlurEvent=!1),"nocursor"!=e.options.readOnly&&(e.state.focused||(Te(e,"focus",e,t),e.state.focused=!0,s(e.display.wrapper,"CodeMirror-focused"),e.curOp||e.display.selForContextMenu==e.doc.sel||(e.display.input.reset(),ml&&setTimeout(function(){return e.display.input.reset(!0)},20)),e.display.input.receivedFocus()),Ar(e))}function Fr(e,t){e.state.delayingBlurEvent||(e.state.focused&&(Te(e,"blur",e,t),e.state.focused=!1,Fl(e.display.wrapper,"CodeMirror-focused")),clearInterval(e.display.blinker),setTimeout(function(){e.state.focused||(e.display.shift=!1)},150))}function Er(e){for(var t=e.display,r=t.lineDiv.offsetTop,n=0;n<t.view.length;n++){var i=t.view[n],o=void 0;if(!i.hidden){if(gl&&vl<8){var l=i.node.offsetTop+i.node.offsetHeight;o=l-r,r=l}else{var s=i.node.getBoundingClientRect();o=s.bottom-s.top}var a=i.line.height-o;if(o<2&&(o=mr(t)),(a>.005||a<-.005)&&(A(i.line,o),Pr(i.line),i.rest))for(var u=0;u<i.rest.length;u++)Pr(i.rest[u])}}}function Pr(e){if(e.widgets)for(var t=0;t<e.widgets.length;++t)e.widgets[t].height=e.widgets[t].node.parentNode.offsetHeight}function Ir(e,t,r){var n=r&&null!=r.top?Math.max(0,r.top):e.scroller.scrollTop;n=Math.floor(n-Et(e));var i=r&&null!=r.bottom?r.bottom:n+e.wrapper.clientHeight,o=D(t,n),l=D(t,i);if(r&&r.ensure){var s=r.ensure.from.line,a=r.ensure.to.line;s<o?(o=s,l=D(t,ye(M(t,s))+e.wrapper.clientHeight)):Math.min(a,t.lastLine())>=l&&(o=D(t,ye(M(t,a))-e.wrapper.clientHeight),l=a)}return{from:o,to:Math.max(l,o+1)}}function zr(e){var t=e.display,r=t.view;if(t.alignWidgets||t.gutters.firstChild&&e.options.fixedGutter){for(var n=wr(t)-t.scroller.scrollLeft+e.doc.scrollLeft,i=t.gutters.offsetWidth,o=n+"px",l=0;l<r.length;l++)if(!r[l].hidden){e.options.fixedGutter&&(r[l].gutter&&(r[l].gutter.style.left=o),r[l].gutterBackground&&(r[l].gutterBackground.style.left=o));var s=r[l].alignable;if(s)for(var a=0;a<s.length;a++)s[a].style.left=o}e.options.fixedGutter&&(t.gutters.style.left=n+i+"px")}}function Rr(e){if(!e.options.lineNumbers)return!1;var t=e.doc,r=F(e.options,t.first+t.size-1),i=e.display;if(r.length!=i.lineNumChars){var o=i.measure.appendChild(n("div",[n("div",r)],"CodeMirror-linenumber CodeMirror-gutter-elt")),l=o.firstChild.offsetWidth,s=o.offsetWidth-l;return i.lineGutter.style.width="",i.lineNumInnerWidth=Math.max(l,i.lineGutter.offsetWidth-s)+1,i.lineNumWidth=i.lineNumInnerWidth+s,i.lineNumChars=i.lineNumInnerWidth?r.length:-1,i.lineGutter.style.width=i.lineNumWidth+"px",Wn(e),!0}return!1}function Br(e,t){if(!Me(e,"scrollCursorIntoView")){var r=e.display,i=r.sizer.getBoundingClientRect(),o=null;if(t.top+i.top<0?o=!0:t.bottom+i.top>(window.innerHeight||document.documentElement.clientHeight)&&(o=!1),null!=o&&!Sl){var l=n("div","​",null,"position: absolute;\n                         top: "+(t.top-r.viewOffset-Et(e.display))+"px;\n                         height: "+(t.bottom-t.top+zt(e)+r.barHeight)+"px;\n                         left: "+t.left+"px; width: "+Math.max(2,t.right-t.left)+"px;");e.display.lineSpace.appendChild(l),l.scrollIntoView(o),e.display.lineSpace.removeChild(l)}}}function Gr(e,t,r,n){null==n&&(n=0);var i;e.options.lineWrapping||t!=r||(r="before"==(t=t.ch?E(t.line,"before"==t.sticky?t.ch-1:t.ch,"after"):t).sticky?E(t.line,t.ch+1,"before"):t);for(var o=0;o<5;o++){var l=!1,s=sr(e,t),a=r&&r!=t?sr(e,r):s,u=Vr(e,i={left:Math.min(s.left,a.left),top:Math.min(s.top,a.top)-n,right:Math.max(s.left,a.left),bottom:Math.max(s.bottom,a.bottom)+n}),c=e.doc.scrollTop,f=e.doc.scrollLeft;if(null!=u.scrollTop&&(qr(e,u.scrollTop),Math.abs(e.doc.scrollTop-c)>1&&(l=!0)),null!=u.scrollLeft&&(Qr(e,u.scrollLeft),Math.abs(e.doc.scrollLeft-f)>1&&(l=!0)),!l)break}return i}function Ur(e,t){var r=Vr(e,t);null!=r.scrollTop&&qr(e,r.scrollTop),null!=r.scrollLeft&&Qr(e,r.scrollLeft)}function Vr(e,t){var r=e.display,n=mr(e.display);t.top<0&&(t.top=0);var i=e.curOp&&null!=e.curOp.scrollTop?e.curOp.scrollTop:r.scroller.scrollTop,o=Bt(e),l={};t.bottom-t.top>o&&(t.bottom=t.top+o);var s=e.doc.height+Pt(r),a=t.top<n,u=t.bottom>s-n;if(t.top<i)l.scrollTop=a?0:t.top;else if(t.bottom>i+o){var c=Math.min(t.top,(u?s:t.bottom)-o);c!=i&&(l.scrollTop=c)}var f=e.curOp&&null!=e.curOp.scrollLeft?e.curOp.scrollLeft:r.scroller.scrollLeft,h=Rt(e)-(e.options.fixedGutter?r.gutters.offsetWidth:0),d=t.right-t.left>h;return d&&(t.right=t.left+h),t.left<10?l.scrollLeft=0:t.left<f?l.scrollLeft=Math.max(0,t.left-(d?0:10)):t.right>h+f-3&&(l.scrollLeft=t.right+(d?0:10)-h),l}function Kr(e,t){null!=t&&(_r(e),e.curOp.scrollTop=(null==e.curOp.scrollTop?e.doc.scrollTop:e.curOp.scrollTop)+t)}function jr(e){_r(e);var t=e.getCursor();e.curOp.scrollToPos={from:t,to:t,margin:e.options.cursorScrollMargin}}function Xr(e,t,r){null==t&&null==r||_r(e),null!=t&&(e.curOp.scrollLeft=t),null!=r&&(e.curOp.scrollTop=r)}function Yr(e,t){_r(e),e.curOp.scrollToPos=t}function _r(e){var t=e.curOp.scrollToPos;t&&(e.curOp.scrollToPos=null,$r(e,ar(e,t.from),ar(e,t.to),t.margin))}function $r(e,t,r,n){var i=Vr(e,{left:Math.min(t.left,r.left),top:Math.min(t.top,r.top)-n,right:Math.max(t.right,r.right),bottom:Math.max(t.bottom,r.bottom)+n});Xr(e,i.scrollLeft,i.scrollTop)}function qr(e,t){Math.abs(e.doc.scrollTop-t)<2||(fl||On(e,{top:t}),Zr(e,t,!0),fl&&On(e),Cn(e,100))}function Zr(e,t,r){t=Math.min(e.display.scroller.scrollHeight-e.display.scroller.clientHeight,t),(e.display.scroller.scrollTop!=t||r)&&(e.doc.scrollTop=t,e.display.scrollbars.setScrollTop(t),e.display.scroller.scrollTop!=t&&(e.display.scroller.scrollTop=t))}function Qr(e,t,r,n){t=Math.min(t,e.display.scroller.scrollWidth-e.display.scroller.clientWidth),(r?t==e.doc.scrollLeft:Math.abs(e.doc.scrollLeft-t)<2)&&!n||(e.doc.scrollLeft=t,zr(e),e.display.scroller.scrollLeft!=t&&(e.display.scroller.scrollLeft=t),e.display.scrollbars.setScrollLeft(t))}function Jr(e){var t=e.display,r=t.gutters.offsetWidth,n=Math.round(e.doc.height+Pt(e.display));return{clientHeight:t.scroller.clientHeight,viewHeight:t.wrapper.clientHeight,scrollWidth:t.scroller.scrollWidth,clientWidth:t.scroller.clientWidth,viewWidth:t.wrapper.clientWidth,barLeft:e.options.fixedGutter?r:0,docHeight:n,scrollHeight:n+zt(e)+t.barHeight,nativeBarWidth:t.nativeBarWidth,gutterWidth:r}}function en(e,t){t||(t=Jr(e));var r=e.display.barWidth,n=e.display.barHeight;tn(e,t);for(var i=0;i<4&&r!=e.display.barWidth||n!=e.display.barHeight;i++)r!=e.display.barWidth&&e.options.lineWrapping&&Er(e),tn(e,Jr(e)),r=e.display.barWidth,n=e.display.barHeight}function tn(e,t){var r=e.display,n=r.scrollbars.update(t);r.sizer.style.paddingRight=(r.barWidth=n.right)+"px",r.sizer.style.paddingBottom=(r.barHeight=n.bottom)+"px",r.heightForcer.style.borderBottom=n.bottom+"px solid transparent",n.right&&n.bottom?(r.scrollbarFiller.style.display="block",r.scrollbarFiller.style.height=n.bottom+"px",r.scrollbarFiller.style.width=n.right+"px"):r.scrollbarFiller.style.display="",n.bottom&&e.options.coverGutterNextToScrollbar&&e.options.fixedGutter?(r.gutterFiller.style.display="block",r.gutterFiller.style.height=n.bottom+"px",r.gutterFiller.style.width=t.gutterWidth+"px"):r.gutterFiller.style.display=""}function rn(e){e.display.scrollbars&&(e.display.scrollbars.clear(),e.display.scrollbars.addClass&&Fl(e.display.wrapper,e.display.scrollbars.addClass)),e.display.scrollbars=new ws[e.options.scrollbarStyle](function(t){e.display.wrapper.insertBefore(t,e.display.scrollbarFiller),Ql(t,"mousedown",function(){e.state.focused&&setTimeout(function(){return e.display.input.focus()},0)}),t.setAttribute("cm-not-content","true")},function(t,r){"horizontal"==r?Qr(e,t):qr(e,t)},e),e.display.scrollbars.addClass&&s(e.display.wrapper,e.display.scrollbars.addClass)}function nn(e){e.curOp={cm:e,viewChanged:!1,startHeight:e.doc.height,forceUpdate:!1,updateInput:null,typing:!1,changeObjs:null,cursorActivityHandlers:null,cursorActivityCalled:0,selectionChanged:!1,updateMaxLine:!1,scrollLeft:null,scrollTop:null,scrollToPos:null,focus:!1,id:++xs},vt(e.curOp)}function on(e){yt(e.curOp,function(e){for(var t=0;t<e.ops.length;t++)e.ops[t].cm.curOp=null;ln(e)})}function ln(e){for(var t=e.ops,r=0;r<t.length;r++)sn(t[r]);for(var n=0;n<t.length;n++)an(t[n]);for(var i=0;i<t.length;i++)un(t[i]);for(var o=0;o<t.length;o++)cn(t[o]);for(var l=0;l<t.length;l++)fn(t[l])}function sn(e){var t=e.cm,r=t.display;Ln(t),e.updateMaxLine&&we(t),e.mustUpdate=e.viewChanged||e.forceUpdate||null!=e.scrollTop||e.scrollToPos&&(e.scrollToPos.from.line<r.viewFrom||e.scrollToPos.to.line>=r.viewTo)||r.maxLineChanged&&t.options.lineWrapping,e.update=e.mustUpdate&&new Cs(t,e.mustUpdate&&{top:e.scrollTop,ensure:e.scrollToPos},e.forceUpdate)}function an(e){e.updatedDisplay=e.mustUpdate&&Mn(e.cm,e.update)}function un(e){var t=e.cm,r=t.display;e.updatedDisplay&&Er(t),e.barMeasure=Jr(t),r.maxLineChanged&&!t.options.lineWrapping&&(e.adjustWidthTo=Kt(t,r.maxLine,r.maxLine.text.length).left+3,t.display.sizerWidth=e.adjustWidthTo,e.barMeasure.scrollWidth=Math.max(r.scroller.clientWidth,r.sizer.offsetLeft+e.adjustWidthTo+zt(t)+t.display.barWidth),e.maxScrollLeft=Math.max(0,r.sizer.offsetLeft+e.adjustWidthTo-Rt(t))),(e.updatedDisplay||e.selectionChanged)&&(e.preparedSelection=r.input.prepareSelection())}function cn(e){var t=e.cm;null!=e.adjustWidthTo&&(t.display.sizer.style.minWidth=e.adjustWidthTo+"px",e.maxScrollLeft<t.doc.scrollLeft&&Qr(t,Math.min(t.display.scroller.scrollLeft,e.maxScrollLeft),!0),t.display.maxLineChanged=!1);var r=e.focus&&e.focus==l();e.preparedSelection&&t.display.input.showSelection(e.preparedSelection,r),(e.updatedDisplay||e.startHeight!=t.doc.height)&&en(t,e.barMeasure),e.updatedDisplay&&Dn(t,e.barMeasure),e.selectionChanged&&Ar(t),t.state.focused&&e.updateInput&&t.display.input.reset(e.typing),r&&Wr(e.cm)}function fn(e){var t=e.cm,r=t.display,n=t.doc;e.updatedDisplay&&Nn(t,e.update),null==r.wheelStartX||null==e.scrollTop&&null==e.scrollLeft&&!e.scrollToPos||(r.wheelStartX=r.wheelStartY=null),null!=e.scrollTop&&Zr(t,e.scrollTop,e.forceScroll),null!=e.scrollLeft&&Qr(t,e.scrollLeft,!0,!0),e.scrollToPos&&Br(t,Gr(t,U(n,e.scrollToPos.from),U(n,e.scrollToPos.to),e.scrollToPos.margin));var i=e.maybeHiddenMarkers,o=e.maybeUnhiddenMarkers;if(i)for(var l=0;l<i.length;++l)i[l].lines.length||Te(i[l],"hide");if(o)for(var s=0;s<o.length;++s)o[s].lines.length&&Te(o[s],"unhide");r.wrapper.offsetHeight&&(n.scrollTop=t.display.scroller.scrollTop),e.changeObjs&&Te(t,"changes",t,e.changeObjs),e.update&&e.update.finish()}function hn(e,t){if(e.curOp)return t();nn(e);try{return t()}finally{on(e)}}function dn(e,t){return function(){if(e.curOp)return t.apply(e,arguments);nn(e);try{return t.apply(e,arguments)}finally{on(e)}}}function pn(e){return function(){if(this.curOp)return e.apply(this,arguments);nn(this);try{return e.apply(this,arguments)}finally{on(this)}}}function gn(e){return function(){var t=this.cm;if(!t||t.curOp)return e.apply(this,arguments);nn(t);try{return e.apply(this,arguments)}finally{on(t)}}}function vn(e,t,r,n){null==t&&(t=e.doc.first),null==r&&(r=e.doc.first+e.doc.size),n||(n=0);var i=e.display;if(n&&r<i.viewTo&&(null==i.updateLineNumbers||i.updateLineNumbers>t)&&(i.updateLineNumbers=t),e.curOp.viewChanged=!0,t>=i.viewTo)_l&&pe(e.doc,t)<i.viewTo&&yn(e);else if(r<=i.viewFrom)_l&&ge(e.doc,r+n)>i.viewFrom?yn(e):(i.viewFrom+=n,i.viewTo+=n);else if(t<=i.viewFrom&&r>=i.viewTo)yn(e);else if(t<=i.viewFrom){var o=bn(e,r,r+n,1);o?(i.view=i.view.slice(o.index),i.viewFrom=o.lineN,i.viewTo+=n):yn(e)}else if(r>=i.viewTo){var l=bn(e,t,t,-1);l?(i.view=i.view.slice(0,l.index),i.viewTo=l.lineN):yn(e)}else{var s=bn(e,t,t,-1),a=bn(e,r,r+n,1);s&&a?(i.view=i.view.slice(0,s.index).concat(gt(e,s.lineN,a.lineN)).concat(i.view.slice(a.index)),i.viewTo+=n):yn(e)}var u=i.externalMeasured;u&&(r<u.lineN?u.lineN+=n:t<u.lineN+u.size&&(i.externalMeasured=null))}function mn(e,t,r){e.curOp.viewChanged=!0;var n=e.display,i=e.display.externalMeasured;if(i&&t>=i.lineN&&t<i.lineN+i.size&&(n.externalMeasured=null),!(t<n.viewFrom||t>=n.viewTo)){var o=n.view[Lr(e,t)];if(null!=o.node){var l=o.changes||(o.changes=[]);-1==h(l,r)&&l.push(r)}}}function yn(e){e.display.viewFrom=e.display.viewTo=e.doc.first,e.display.view=[],e.display.viewOffset=0}function bn(e,t,r,n){var i,o=Lr(e,t),l=e.display.view;if(!_l||r==e.doc.first+e.doc.size)return{index:o,lineN:r};for(var s=e.display.viewFrom,a=0;a<o;a++)s+=l[a].size;if(s!=t){if(n>0){if(o==l.length-1)return null;i=s+l[o].size-t,o++}else i=s-t;t+=i,r+=i}for(;pe(e.doc,r)!=r;){if(o==(n<0?0:l.length-1))return null;r+=n*l[o-(n<0?1:0)].size,o+=n}return{index:o,lineN:r}}function wn(e,t,r){var n=e.display;0==n.view.length||t>=n.viewTo||r<=n.viewFrom?(n.view=gt(e,t,r),n.viewFrom=t):(n.viewFrom>t?n.view=gt(e,t,n.viewFrom).concat(n.view):n.viewFrom<t&&(n.view=n.view.slice(Lr(e,t))),n.viewFrom=t,n.viewTo<r?n.view=n.view.concat(gt(e,n.viewTo,r)):n.viewTo>r&&(n.view=n.view.slice(0,Lr(e,r)))),n.viewTo=r}function xn(e){for(var t=e.display.view,r=0,n=0;n<t.length;n++){var i=t[n];i.hidden||i.node&&!i.changes||++r}return r}function Cn(e,t){e.doc.highlightFrontier<e.display.viewTo&&e.state.highlight.set(t,u(Sn,e))}function Sn(e){var t=e.doc;if(!(t.highlightFrontier>=e.display.viewTo)){var r=+new Date+e.options.workTime,n=$e(e,t.highlightFrontier),i=[];t.iter(n.line,Math.min(t.first+t.size,e.display.viewTo+500),function(o){if(n.line>=e.display.viewFrom){var l=o.styles,s=o.text.length>e.options.maxHighlightLength?Ke(t.mode,n.state):null,a=Ye(e,o,n,!0);s&&(n.state=s),o.styles=a.styles;var u=o.styleClasses,c=a.classes;c?o.styleClasses=c:u&&(o.styleClasses=null);for(var f=!l||l.length!=o.styles.length||u!=c&&(!u||!c||u.bgClass!=c.bgClass||u.textClass!=c.textClass),h=0;!f&&h<l.length;++h)f=l[h]!=o.styles[h];f&&i.push(n.line),o.stateAfter=n.save(),n.nextLine()}else o.text.length<=e.options.maxHighlightLength&&qe(e,o.text,n),o.stateAfter=n.line%5==0?n.save():null,n.nextLine();if(+new Date>r)return Cn(e,e.options.workDelay),!0}),t.highlightFrontier=n.line,t.modeFrontier=Math.max(t.modeFrontier,n.line),i.length&&hn(e,function(){for(var t=0;t<i.length;t++)mn(e,i[t],"text")})}}function Ln(e){var t=e.display;!t.scrollbarsClipped&&t.scroller.offsetWidth&&(t.nativeBarWidth=t.scroller.offsetWidth-t.scroller.clientWidth,t.heightForcer.style.height=zt(e)+"px",t.sizer.style.marginBottom=-t.nativeBarWidth+"px",t.sizer.style.borderRightWidth=zt(e)+"px",t.scrollbarsClipped=!0)}function kn(e){if(e.hasFocus())return null;var t=l();if(!t||!o(e.display.lineDiv,t))return null;var r={activeElt:t};if(window.getSelection){var n=window.getSelection();n.anchorNode&&n.extend&&o(e.display.lineDiv,n.anchorNode)&&(r.anchorNode=n.anchorNode,r.anchorOffset=n.anchorOffset,r.focusNode=n.focusNode,r.focusOffset=n.focusOffset)}return r}function Tn(e){if(e&&e.activeElt&&e.activeElt!=l()&&(e.activeElt.focus(),e.anchorNode&&o(document.body,e.anchorNode)&&o(document.body,e.focusNode))){var t=window.getSelection(),r=document.createRange();r.setEnd(e.anchorNode,e.anchorOffset),r.collapse(!1),t.removeAllRanges(),t.addRange(r),t.extend(e.focusNode,e.focusOffset)}}function Mn(e,r){var n=e.display,i=e.doc;if(r.editorIsHidden)return yn(e),!1;if(!r.force&&r.visible.from>=n.viewFrom&&r.visible.to<=n.viewTo&&(null==n.updateLineNumbers||n.updateLineNumbers>=n.viewTo)&&n.renderedView==n.view&&0==xn(e))return!1;Rr(e)&&(yn(e),r.dims=br(e));var o=i.first+i.size,l=Math.max(r.visible.from-e.options.viewportMargin,i.first),s=Math.min(o,r.visible.to+e.options.viewportMargin);n.viewFrom<l&&l-n.viewFrom<20&&(l=Math.max(i.first,n.viewFrom)),n.viewTo>s&&n.viewTo-s<20&&(s=Math.min(o,n.viewTo)),_l&&(l=pe(e.doc,l),s=ge(e.doc,s));var a=l!=n.viewFrom||s!=n.viewTo||n.lastWrapHeight!=r.wrapperHeight||n.lastWrapWidth!=r.wrapperWidth;wn(e,l,s),n.viewOffset=ye(M(e.doc,n.viewFrom)),e.display.mover.style.top=n.viewOffset+"px";var u=xn(e);if(!a&&0==u&&!r.force&&n.renderedView==n.view&&(null==n.updateLineNumbers||n.updateLineNumbers>=n.viewTo))return!1;var c=kn(e);return u>4&&(n.lineDiv.style.display="none"),An(e,n.updateLineNumbers,r.dims),u>4&&(n.lineDiv.style.display=""),n.renderedView=n.view,Tn(c),t(n.cursorDiv),t(n.selectionDiv),n.gutters.style.height=n.sizer.style.minHeight=0,a&&(n.lastWrapHeight=r.wrapperHeight,n.lastWrapWidth=r.wrapperWidth,Cn(e,400)),n.updateLineNumbers=null,!0}function Nn(e,t){for(var r=t.viewport,n=!0;(n&&e.options.lineWrapping&&t.oldDisplayWidth!=Rt(e)||(r&&null!=r.top&&(r={top:Math.min(e.doc.height+Pt(e.display)-Bt(e),r.top)}),t.visible=Ir(e.display,e.doc,r),!(t.visible.from>=e.display.viewFrom&&t.visible.to<=e.display.viewTo)))&&Mn(e,t);n=!1){Er(e);var i=Jr(e);kr(e),en(e,i),Dn(e,i),t.force=!1}t.signal(e,"update",e),e.display.viewFrom==e.display.reportedViewFrom&&e.display.viewTo==e.display.reportedViewTo||(t.signal(e,"viewportChange",e,e.display.viewFrom,e.display.viewTo),e.display.reportedViewFrom=e.display.viewFrom,e.display.reportedViewTo=e.display.viewTo)}function On(e,t){var r=new Cs(e,t);if(Mn(e,r)){Er(e),Nn(e,r);var n=Jr(e);kr(e),en(e,n),Dn(e,n),r.finish()}}function An(e,r,n){function i(t){var r=t.nextSibling;return ml&&Ml&&e.display.currentWheelTarget==t?t.style.display="none":t.parentNode.removeChild(t),r}for(var o=e.display,l=e.options.lineNumbers,s=o.lineDiv,a=s.firstChild,u=o.view,c=o.viewFrom,f=0;f<u.length;f++){var d=u[f];if(d.hidden);else if(d.node&&d.node.parentNode==s){for(;a!=d.node;)a=i(a);var p=l&&null!=r&&r<=c&&d.lineNumber;d.changes&&(h(d.changes,"gutter")>-1&&(p=!1),xt(e,d,c,n)),p&&(t(d.lineNumber),d.lineNumber.appendChild(document.createTextNode(F(e.options,c)))),a=d.node.nextSibling}else{var g=Ot(e,d,c,n);s.insertBefore(g,a)}c+=d.size}for(;a;)a=i(a)}function Wn(e){var t=e.display.gutters.offsetWidth;e.display.sizer.style.marginLeft=t+"px"}function Dn(e,t){e.display.sizer.style.minHeight=t.docHeight+"px",e.display.heightForcer.style.top=t.docHeight+"px",e.display.gutters.style.height=t.docHeight+e.display.barHeight+zt(e)+"px"}function Hn(e){var r=e.display.gutters,i=e.options.gutters;t(r);for(var o=0;o<i.length;++o){var l=i[o],s=r.appendChild(n("div",null,"CodeMirror-gutter "+l));"CodeMirror-linenumbers"==l&&(e.display.lineGutter=s,s.style.width=(e.display.lineNumWidth||1)+"px")}r.style.display=o?"":"none",Wn(e)}function Fn(e){var t=h(e.gutters,"CodeMirror-linenumbers");-1==t&&e.lineNumbers?e.gutters=e.gutters.concat(["CodeMirror-linenumbers"]):t>-1&&!e.lineNumbers&&(e.gutters=e.gutters.slice(0),e.gutters.splice(t,1))}function En(e){var t=e.wheelDeltaX,r=e.wheelDeltaY;return null==t&&e.detail&&e.axis==e.HORIZONTAL_AXIS&&(t=e.detail),null==r&&e.detail&&e.axis==e.VERTICAL_AXIS?r=e.detail:null==r&&(r=e.wheelDelta),{x:t,y:r}}function Pn(e){var t=En(e);return t.x*=Ls,t.y*=Ls,t}function In(e,t){var r=En(t),n=r.x,i=r.y,o=e.display,l=o.scroller,s=l.scrollWidth>l.clientWidth,a=l.scrollHeight>l.clientHeight;if(n&&s||i&&a){if(i&&Ml&&ml)e:for(var u=t.target,c=o.view;u!=l;u=u.parentNode)for(var f=0;f<c.length;f++)if(c[f].node==u){e.display.currentWheelTarget=u;break e}if(n&&!fl&&!wl&&null!=Ls)return i&&a&&qr(e,Math.max(0,l.scrollTop+i*Ls)),Qr(e,Math.max(0,l.scrollLeft+n*Ls)),(!i||i&&a)&&We(t),void(o.wheelStartX=null);if(i&&null!=Ls){var h=i*Ls,d=e.doc.scrollTop,p=d+o.wrapper.clientHeight;h<0?d=Math.max(0,d+h-50):p=Math.min(e.doc.height,p+h+50),On(e,{top:d,bottom:p})}Ss<20&&(null==o.wheelStartX?(o.wheelStartX=l.scrollLeft,o.wheelStartY=l.scrollTop,o.wheelDX=n,o.wheelDY=i,setTimeout(function(){if(null!=o.wheelStartX){var e=l.scrollLeft-o.wheelStartX,t=l.scrollTop-o.wheelStartY,r=t&&o.wheelDY&&t/o.wheelDY||e&&o.wheelDX&&e/o.wheelDX;o.wheelStartX=o.wheelStartY=null,r&&(Ls=(Ls*Ss+r)/(Ss+1),++Ss)}},200)):(o.wheelDX+=n,o.wheelDY+=i))}}function zn(e,t){var r=e[t];e.sort(function(e,t){return P(e.from(),t.from())}),t=h(e,r);for(var n=1;n<e.length;n++){var i=e[n],o=e[n-1];if(P(o.to(),i.from())>=0){var l=B(o.from(),i.from()),s=R(o.to(),i.to()),a=o.empty()?i.from()==i.head:o.from()==o.head;n<=t&&--t,e.splice(--n,2,new Ts(a?s:l,a?l:s))}}return new ks(e,t)}function Rn(e,t){return new ks([new Ts(e,t||e)],0)}function Bn(e){return e.text?E(e.from.line+e.text.length-1,g(e.text).length+(1==e.text.length?e.from.ch:0)):e.to}function Gn(e,t){if(P(e,t.from)<0)return e;if(P(e,t.to)<=0)return Bn(t);var r=e.line+t.text.length-(t.to.line-t.from.line)-1,n=e.ch;return e.line==t.to.line&&(n+=Bn(t).ch-t.to.ch),E(r,n)}function Un(e,t){for(var r=[],n=0;n<e.sel.ranges.length;n++){var i=e.sel.ranges[n];r.push(new Ts(Gn(i.anchor,t),Gn(i.head,t)))}return zn(r,e.sel.primIndex)}function Vn(e,t,r){return e.line==t.line?E(r.line,e.ch-t.ch+r.ch):E(r.line+(e.line-t.line),e.ch)}function Kn(e,t,r){for(var n=[],i=E(e.first,0),o=i,l=0;l<t.length;l++){var s=t[l],a=Vn(s.from,i,o),u=Vn(Bn(s),i,o);if(i=s.to,o=u,"around"==r){var c=e.sel.ranges[l],f=P(c.head,c.anchor)<0;n[l]=new Ts(f?u:a,f?a:u)}else n[l]=new Ts(a,a)}return new ks(n,e.sel.primIndex)}function jn(e){e.doc.mode=Ue(e.options,e.doc.modeOption),Xn(e)}function Xn(e){e.doc.iter(function(e){e.stateAfter&&(e.stateAfter=null),e.styles&&(e.styles=null)}),e.doc.modeFrontier=e.doc.highlightFrontier=e.doc.first,Cn(e,100),e.state.modeGen++,e.curOp&&vn(e)}function Yn(e,t){return 0==t.from.ch&&0==t.to.ch&&""==g(t.text)&&(!e.cm||e.cm.options.wholeLineUpdateBefore)}function _n(e,t,r,n){function i(e){return r?r[e]:null}function o(e,r,i){it(e,r,i,n),bt(e,"change",e,t)}function l(e,t){for(var r=[],o=e;o<t;++o)r.push(new fs(u[o],i(o),n));return r}var s=t.from,a=t.to,u=t.text,c=M(e,s.line),f=M(e,a.line),h=g(u),d=i(u.length-1),p=a.line-s.line;if(t.full)e.insert(0,l(0,u.length)),e.remove(u.length,e.size-u.length);else if(Yn(e,t)){var v=l(0,u.length-1);o(f,f.text,d),p&&e.remove(s.line,p),v.length&&e.insert(s.line,v)}else if(c==f)if(1==u.length)o(c,c.text.slice(0,s.ch)+h+c.text.slice(a.ch),d);else{var m=l(1,u.length-1);m.push(new fs(h+c.text.slice(a.ch),d,n)),o(c,c.text.slice(0,s.ch)+u[0],i(0)),e.insert(s.line+1,m)}else if(1==u.length)o(c,c.text.slice(0,s.ch)+u[0]+f.text.slice(a.ch),i(0)),e.remove(s.line+1,p);else{o(c,c.text.slice(0,s.ch)+u[0],i(0)),o(f,h+f.text.slice(a.ch),d);var y=l(1,u.length-1);p>1&&e.remove(s.line+1,p-1),e.insert(s.line+1,y)}bt(e,"change",e,t)}function $n(e,t,r){function n(e,i,o){if(e.linked)for(var l=0;l<e.linked.length;++l){var s=e.linked[l];if(s.doc!=i){var a=o&&s.sharedHist;r&&!a||(t(s.doc,a),n(s.doc,e,a))}}}n(e,null,!0)}function qn(e,t){if(t.cm)throw new Error("This document is already in use.");e.doc=t,t.cm=e,Cr(e),jn(e),Zn(e),e.options.lineWrapping||we(e),e.options.mode=t.modeOption,vn(e)}function Zn(e){("rtl"==e.doc.direction?s:Fl)(e.display.lineDiv,"CodeMirror-rtl")}function Qn(e){hn(e,function(){Zn(e),vn(e)})}function Jn(e){this.done=[],this.undone=[],this.undoDepth=1/0,this.lastModTime=this.lastSelTime=0,this.lastOp=this.lastSelOp=null,this.lastOrigin=this.lastSelOrigin=null,this.generation=this.maxGeneration=e||1}function ei(e,t){var r={from:z(t.from),to:Bn(t),text:N(e,t.from,t.to)};return si(e,r,t.from.line,t.to.line+1),$n(e,function(e){return si(e,r,t.from.line,t.to.line+1)},!0),r}function ti(e){for(;e.length&&g(e).ranges;)e.pop()}function ri(e,t){return t?(ti(e.done),g(e.done)):e.done.length&&!g(e.done).ranges?g(e.done):e.done.length>1&&!e.done[e.done.length-2].ranges?(e.done.pop(),g(e.done)):void 0}function ni(e,t,r,n){var i=e.history;i.undone.length=0;var o,l,s=+new Date;if((i.lastOp==n||i.lastOrigin==t.origin&&t.origin&&("+"==t.origin.charAt(0)&&e.cm&&i.lastModTime>s-e.cm.options.historyEventDelay||"*"==t.origin.charAt(0)))&&(o=ri(i,i.lastOp==n)))l=g(o.changes),0==P(t.from,t.to)&&0==P(t.from,l.to)?l.to=Bn(t):o.changes.push(ei(e,t));else{var a=g(i.done);for(a&&a.ranges||li(e.sel,i.done),o={changes:[ei(e,t)],generation:i.generation},i.done.push(o);i.done.length>i.undoDepth;)i.done.shift(),i.done[0].ranges||i.done.shift()}i.done.push(r),i.generation=++i.maxGeneration,i.lastModTime=i.lastSelTime=s,i.lastOp=i.lastSelOp=n,i.lastOrigin=i.lastSelOrigin=t.origin,l||Te(e,"historyAdded")}function ii(e,t,r,n){var i=t.charAt(0);return"*"==i||"+"==i&&r.ranges.length==n.ranges.length&&r.somethingSelected()==n.somethingSelected()&&new Date-e.history.lastSelTime<=(e.cm?e.cm.options.historyEventDelay:500)}function oi(e,t,r,n){var i=e.history,o=n&&n.origin;r==i.lastSelOp||o&&i.lastSelOrigin==o&&(i.lastModTime==i.lastSelTime&&i.lastOrigin==o||ii(e,o,g(i.done),t))?i.done[i.done.length-1]=t:li(t,i.done),i.lastSelTime=+new Date,i.lastSelOrigin=o,i.lastSelOp=r,n&&!1!==n.clearRedo&&ti(i.undone)}function li(e,t){var r=g(t);r&&r.ranges&&r.equals(e)||t.push(e)}function si(e,t,r,n){var i=t["spans_"+e.id],o=0;e.iter(Math.max(e.first,r),Math.min(e.first+e.size,n),function(r){r.markedSpans&&((i||(i=t["spans_"+e.id]={}))[o]=r.markedSpans),++o})}function ai(e){if(!e)return null;for(var t,r=0;r<e.length;++r)e[r].marker.explicitlyCleared?t||(t=e.slice(0,r)):t&&t.push(e[r]);return t?t.length?t:null:e}function ui(e,t){var r=t["spans_"+e.id];if(!r)return null;for(var n=[],i=0;i<t.text.length;++i)n.push(ai(r[i]));return n}function ci(e,t){var r=ui(e,t),n=J(e,t);if(!r)return n;if(!n)return r;for(var i=0;i<r.length;++i){var o=r[i],l=n[i];if(o&&l)e:for(var s=0;s<l.length;++s){for(var a=l[s],u=0;u<o.length;++u)if(o[u].marker==a.marker)continue e;o.push(a)}else l&&(r[i]=l)}return r}function fi(e,t,r){for(var n=[],i=0;i<e.length;++i){var o=e[i];if(o.ranges)n.push(r?ks.prototype.deepCopy.call(o):o);else{var l=o.changes,s=[];n.push({changes:s});for(var a=0;a<l.length;++a){var u=l[a],c=void 0;if(s.push({from:u.from,to:u.to,text:u.text}),t)for(var f in u)(c=f.match(/^spans_(\d+)$/))&&h(t,Number(c[1]))>-1&&(g(s)[f]=u[f],delete u[f])}}}return n}function hi(e,t,r,n){if(n){var i=e.anchor;if(r){var o=P(t,i)<0;o!=P(r,i)<0?(i=t,t=r):o!=P(t,r)<0&&(t=r)}return new Ts(i,t)}return new Ts(r||t,t)}function di(e,t,r,n,i){null==i&&(i=e.cm&&(e.cm.display.shift||e.extend)),bi(e,new ks([hi(e.sel.primary(),t,r,i)],0),n)}function pi(e,t,r){for(var n=[],i=e.cm&&(e.cm.display.shift||e.extend),o=0;o<e.sel.ranges.length;o++)n[o]=hi(e.sel.ranges[o],t[o],null,i);bi(e,zn(n,e.sel.primIndex),r)}function gi(e,t,r,n){var i=e.sel.ranges.slice(0);i[t]=r,bi(e,zn(i,e.sel.primIndex),n)}function vi(e,t,r,n){bi(e,Rn(t,r),n)}function mi(e,t,r){var n={ranges:t.ranges,update:function(t){var r=this;this.ranges=[];for(var n=0;n<t.length;n++)r.ranges[n]=new Ts(U(e,t[n].anchor),U(e,t[n].head))},origin:r&&r.origin};return Te(e,"beforeSelectionChange",e,n),e.cm&&Te(e.cm,"beforeSelectionChange",e.cm,n),n.ranges!=t.ranges?zn(n.ranges,n.ranges.length-1):t}function yi(e,t,r){var n=e.history.done,i=g(n);i&&i.ranges?(n[n.length-1]=t,wi(e,t,r)):bi(e,t,r)}function bi(e,t,r){wi(e,t,r),oi(e,e.sel,e.cm?e.cm.curOp.id:NaN,r)}function wi(e,t,r){(Oe(e,"beforeSelectionChange")||e.cm&&Oe(e.cm,"beforeSelectionChange"))&&(t=mi(e,t,r)),xi(e,Si(e,t,r&&r.bias||(P(t.primary().head,e.sel.primary().head)<0?-1:1),!0)),r&&!1===r.scroll||!e.cm||jr(e.cm)}function xi(e,t){t.equals(e.sel)||(e.sel=t,e.cm&&(e.cm.curOp.updateInput=e.cm.curOp.selectionChanged=!0,Ne(e.cm)),bt(e,"cursorActivity",e))}function Ci(e){xi(e,Si(e,e.sel,null,!1))}function Si(e,t,r,n){for(var i,o=0;o<t.ranges.length;o++){var l=t.ranges[o],s=t.ranges.length==e.sel.ranges.length&&e.sel.ranges[o],a=ki(e,l.anchor,s&&s.anchor,r,n),u=ki(e,l.head,s&&s.head,r,n);(i||a!=l.anchor||u!=l.head)&&(i||(i=t.ranges.slice(0,o)),i[o]=new Ts(a,u))}return i?zn(i,t.primIndex):t}function Li(e,t,r,n,i){var o=M(e,t.line);if(o.markedSpans)for(var l=0;l<o.markedSpans.length;++l){var s=o.markedSpans[l],a=s.marker;if((null==s.from||(a.inclusiveLeft?s.from<=t.ch:s.from<t.ch))&&(null==s.to||(a.inclusiveRight?s.to>=t.ch:s.to>t.ch))){if(i&&(Te(a,"beforeCursorEnter"),a.explicitlyCleared)){if(o.markedSpans){--l;continue}break}if(!a.atomic)continue;if(r){var u=a.find(n<0?1:-1),c=void 0;if((n<0?a.inclusiveRight:a.inclusiveLeft)&&(u=Ti(e,u,-n,u&&u.line==t.line?o:null)),u&&u.line==t.line&&(c=P(u,r))&&(n<0?c<0:c>0))return Li(e,u,t,n,i)}var f=a.find(n<0?-1:1);return(n<0?a.inclusiveLeft:a.inclusiveRight)&&(f=Ti(e,f,n,f.line==t.line?o:null)),f?Li(e,f,t,n,i):null}}return t}function ki(e,t,r,n,i){var o=n||1,l=Li(e,t,r,o,i)||!i&&Li(e,t,r,o,!0)||Li(e,t,r,-o,i)||!i&&Li(e,t,r,-o,!0);return l||(e.cantEdit=!0,E(e.first,0))}function Ti(e,t,r,n){return r<0&&0==t.ch?t.line>e.first?U(e,E(t.line-1)):null:r>0&&t.ch==(n||M(e,t.line)).text.length?t.line<e.first+e.size-1?E(t.line+1,0):null:new E(t.line,t.ch+r)}function Mi(e){e.setSelection(E(e.firstLine(),0),E(e.lastLine()),Gl)}function Ni(e,t,r){var n={canceled:!1,from:t.from,to:t.to,text:t.text,origin:t.origin,cancel:function(){return n.canceled=!0}};return r&&(n.update=function(t,r,i,o){t&&(n.from=U(e,t)),r&&(n.to=U(e,r)),i&&(n.text=i),void 0!==o&&(n.origin=o)}),Te(e,"beforeChange",e,n),e.cm&&Te(e.cm,"beforeChange",e.cm,n),n.canceled?null:{from:n.from,to:n.to,text:n.text,origin:n.origin}}function Oi(e,t,r){if(e.cm){if(!e.cm.curOp)return dn(e.cm,Oi)(e,t,r);if(e.cm.state.suppressEdits)return}if(!(Oe(e,"beforeChange")||e.cm&&Oe(e.cm,"beforeChange"))||(t=Ni(e,t,!0))){var n=Yl&&!r&&te(e,t.from,t.to);if(n)for(var i=n.length-1;i>=0;--i)Ai(e,{from:n[i].from,to:n[i].to,text:i?[""]:t.text,origin:t.origin});else Ai(e,t)}}function Ai(e,t){if(1!=t.text.length||""!=t.text[0]||0!=P(t.from,t.to)){var r=Un(e,t);ni(e,t,r,e.cm?e.cm.curOp.id:NaN),Hi(e,t,r,J(e,t));var n=[];$n(e,function(e,r){r||-1!=h(n,e.history)||(zi(e.history,t),n.push(e.history)),Hi(e,t,null,J(e,t))})}}function Wi(e,t,r){if(!e.cm||!e.cm.state.suppressEdits||r){for(var n,i=e.history,o=e.sel,l="undo"==t?i.done:i.undone,s="undo"==t?i.undone:i.done,a=0;a<l.length&&(n=l[a],r?!n.ranges||n.equals(e.sel):n.ranges);a++);if(a!=l.length){for(i.lastOrigin=i.lastSelOrigin=null;(n=l.pop()).ranges;){if(li(n,s),r&&!n.equals(e.sel))return void bi(e,n,{clearRedo:!1});o=n}var u=[];li(o,s),s.push({changes:u,generation:i.generation}),i.generation=n.generation||++i.maxGeneration;for(var c=Oe(e,"beforeChange")||e.cm&&Oe(e.cm,"beforeChange"),f=n.changes.length-1;f>=0;--f){var d=function(r){var i=n.changes[r];if(i.origin=t,c&&!Ni(e,i,!1))return l.length=0,{};u.push(ei(e,i));var o=r?Un(e,i):g(l);Hi(e,i,o,ci(e,i)),!r&&e.cm&&e.cm.scrollIntoView({from:i.from,to:Bn(i)});var s=[];$n(e,function(e,t){t||-1!=h(s,e.history)||(zi(e.history,i),s.push(e.history)),Hi(e,i,null,ci(e,i))})}(f);if(d)return d.v}}}}function Di(e,t){if(0!=t&&(e.first+=t,e.sel=new ks(v(e.sel.ranges,function(e){return new Ts(E(e.anchor.line+t,e.anchor.ch),E(e.head.line+t,e.head.ch))}),e.sel.primIndex),e.cm)){vn(e.cm,e.first,e.first-t,t);for(var r=e.cm.display,n=r.viewFrom;n<r.viewTo;n++)mn(e.cm,n,"gutter")}}function Hi(e,t,r,n){if(e.cm&&!e.cm.curOp)return dn(e.cm,Hi)(e,t,r,n);if(t.to.line<e.first)Di(e,t.text.length-1-(t.to.line-t.from.line));else if(!(t.from.line>e.lastLine())){if(t.from.line<e.first){var i=t.text.length-1-(e.first-t.from.line);Di(e,i),t={from:E(e.first,0),to:E(t.to.line+i,t.to.ch),text:[g(t.text)],origin:t.origin}}var o=e.lastLine();t.to.line>o&&(t={from:t.from,to:E(o,M(e,o).text.length),text:[t.text[0]],origin:t.origin}),t.removed=N(e,t.from,t.to),r||(r=Un(e,t)),e.cm?Fi(e.cm,t,n):_n(e,t,n),wi(e,r,Gl)}}function Fi(e,t,r){var n=e.doc,i=e.display,o=t.from,l=t.to,s=!1,a=o.line;e.options.lineWrapping||(a=W(fe(M(n,o.line))),n.iter(a,l.line+1,function(e){if(e==i.maxLine)return s=!0,!0})),n.sel.contains(t.from,t.to)>-1&&Ne(e),_n(n,t,r,xr(e)),e.options.lineWrapping||(n.iter(a,o.line+t.text.length,function(e){var t=be(e);t>i.maxLineLength&&(i.maxLine=e,i.maxLineLength=t,i.maxLineChanged=!0,s=!1)}),s&&(e.curOp.updateMaxLine=!0)),nt(n,o.line),Cn(e,400);var u=t.text.length-(l.line-o.line)-1;t.full?vn(e):o.line!=l.line||1!=t.text.length||Yn(e.doc,t)?vn(e,o.line,l.line+1,u):mn(e,o.line,"text");var c=Oe(e,"changes"),f=Oe(e,"change");if(f||c){var h={from:o,to:l,text:t.text,removed:t.removed,origin:t.origin};f&&bt(e,"change",e,h),c&&(e.curOp.changeObjs||(e.curOp.changeObjs=[])).push(h)}e.display.selForContextMenu=null}function Ei(e,t,r,n,i){if(n||(n=r),P(n,r)<0){var o;r=(o=[n,r])[0],n=o[1]}"string"==typeof t&&(t=e.splitLines(t)),Oi(e,{from:r,to:n,text:t,origin:i})}function Pi(e,t,r,n){r<e.line?e.line+=n:t<e.line&&(e.line=t,e.ch=0)}function Ii(e,t,r,n){for(var i=0;i<e.length;++i){var o=e[i],l=!0;if(o.ranges){o.copied||((o=e[i]=o.deepCopy()).copied=!0);for(var s=0;s<o.ranges.length;s++)Pi(o.ranges[s].anchor,t,r,n),Pi(o.ranges[s].head,t,r,n)}else{for(var a=0;a<o.changes.length;++a){var u=o.changes[a];if(r<u.from.line)u.from=E(u.from.line+n,u.from.ch),u.to=E(u.to.line+n,u.to.ch);else if(t<=u.to.line){l=!1;break}}l||(e.splice(0,i+1),i=0)}}}function zi(e,t){var r=t.from.line,n=t.to.line,i=t.text.length-(n-r)-1;Ii(e.done,r,n,i),Ii(e.undone,r,n,i)}function Ri(e,t,r,n){var i=t,o=t;return"number"==typeof t?o=M(e,G(e,t)):i=W(t),null==i?null:(n(o,i)&&e.cm&&mn(e.cm,i,r),o)}function Bi(e){var t=this;this.lines=e,this.parent=null;for(var r=0,n=0;n<e.length;++n)e[n].parent=t,r+=e[n].height;this.height=r}function Gi(e){var t=this;this.children=e;for(var r=0,n=0,i=0;i<e.length;++i){var o=e[i];r+=o.chunkSize(),n+=o.height,o.parent=t}this.size=r,this.height=n,this.parent=null}function Ui(e,t,r){ye(t)<(e.curOp&&e.curOp.scrollTop||e.doc.scrollTop)&&Kr(e,r)}function Vi(e,t,r,n){var i=new Ms(e,r,n),o=e.cm;return o&&i.noHScroll&&(o.display.alignWidgets=!0),Ri(e,t,"widget",function(t){var r=t.widgets||(t.widgets=[]);if(null==i.insertAt?r.push(i):r.splice(Math.min(r.length-1,Math.max(0,i.insertAt)),0,i),i.line=t,o&&!ve(e,t)){var n=ye(t)<e.scrollTop;A(t,t.height+Ht(i)),n&&Kr(o,i.height),o.curOp.forceUpdate=!0}return!0}),bt(o,"lineWidgetAdded",o,i,"number"==typeof t?t:W(t)),i}function Ki(e,t,r,n,o){if(n&&n.shared)return ji(e,t,r,n,o);if(e.cm&&!e.cm.curOp)return dn(e.cm,Ki)(e,t,r,n,o);var l=new Os(e,o),s=P(t,r);if(n&&c(n,l,!1),s>0||0==s&&!1!==l.clearWhenEmpty)return l;if(l.replacedWith&&(l.collapsed=!0,l.widgetNode=i("span",[l.replacedWith],"CodeMirror-widget"),n.handleMouseEvents||l.widgetNode.setAttribute("cm-ignore-events","true"),n.insertLeft&&(l.widgetNode.insertLeft=!0)),l.collapsed){if(ce(e,t.line,t,r,l)||t.line!=r.line&&ce(e,r.line,t,r,l))throw new Error("Inserting collapsed marker partially overlapping an existing one");X()}l.addToHistory&&ni(e,{from:t,to:r,origin:"markText"},e.sel,NaN);var a,u=t.line,f=e.cm;if(e.iter(u,r.line+1,function(e){f&&l.collapsed&&!f.options.lineWrapping&&fe(e)==f.display.maxLine&&(a=!0),l.collapsed&&u!=t.line&&A(e,0),q(e,new Y(l,u==t.line?t.ch:null,u==r.line?r.ch:null)),++u}),l.collapsed&&e.iter(t.line,r.line+1,function(t){ve(e,t)&&A(t,0)}),l.clearOnEnter&&Ql(l,"beforeCursorEnter",function(){return l.clear()}),l.readOnly&&(j(),(e.history.done.length||e.history.undone.length)&&e.clearHistory()),l.collapsed&&(l.id=++Ns,l.atomic=!0),f){if(a&&(f.curOp.updateMaxLine=!0),l.collapsed)vn(f,t.line,r.line+1);else if(l.className||l.title||l.startStyle||l.endStyle||l.css)for(var h=t.line;h<=r.line;h++)mn(f,h,"text");l.atomic&&Ci(f.doc),bt(f,"markerAdded",f,l)}return l}function ji(e,t,r,n,i){(n=c(n)).shared=!1;var o=[Ki(e,t,r,n,i)],l=o[0],s=n.widgetNode;return $n(e,function(e){s&&(n.widgetNode=s.cloneNode(!0)),o.push(Ki(e,U(e,t),U(e,r),n,i));for(var a=0;a<e.linked.length;++a)if(e.linked[a].isParent)return;l=g(o)}),new As(o,l)}function Xi(e){return e.findMarks(E(e.first,0),e.clipPos(E(e.lastLine())),function(e){return e.parent})}function Yi(e,t){for(var r=0;r<t.length;r++){var n=t[r],i=n.find(),o=e.clipPos(i.from),l=e.clipPos(i.to);if(P(o,l)){var s=Ki(e,o,l,n.primary,n.primary.type);n.markers.push(s),s.parent=n}}}function _i(e){for(var t=0;t<e.length;t++)!function(t){var r=e[t],n=[r.primary.doc];$n(r.primary.doc,function(e){return n.push(e)});for(var i=0;i<r.markers.length;i++){var o=r.markers[i];-1==h(n,o.doc)&&(o.parent=null,r.markers.splice(i--,1))}}(t)}function $i(e){var t=this;if(Qi(t),!Me(t,e)&&!Ft(t.display,e)){We(e),gl&&(Hs=+new Date);var r=Sr(t,e,!0),n=e.dataTransfer.files;if(r&&!t.isReadOnly())if(n&&n.length&&window.FileReader&&window.File)for(var i=n.length,o=Array(i),l=0,s=0;s<i;++s)!function(e,n){if(!t.options.allowDropFileTypes||-1!=h(t.options.allowDropFileTypes,e.type)){var s=new FileReader;s.onload=dn(t,function(){var e=s.result;if(/[\x00-\x08\x0e-\x1f]{2}/.test(e)&&(e=""),o[n]=e,++l==i){var a={from:r=U(t.doc,r),to:r,text:t.doc.splitLines(o.join(t.doc.lineSeparator())),origin:"paste"};Oi(t.doc,a),yi(t.doc,Rn(r,Bn(a)))}}),s.readAsText(e)}}(n[s],s);else{if(t.state.draggingText&&t.doc.sel.contains(r)>-1)return t.state.draggingText(e),void setTimeout(function(){return t.display.input.focus()},20);try{var a=e.dataTransfer.getData("Text");if(a){var u;if(t.state.draggingText&&!t.state.draggingText.copy&&(u=t.listSelections()),wi(t.doc,Rn(r,r)),u)for(var c=0;c<u.length;++c)Ei(t.doc,"",u[c].anchor,u[c].head,"drag");t.replaceSelection(a,"around","paste"),t.display.input.focus()}}catch(e){}}}}function qi(e,t){if(gl&&(!e.state.draggingText||+new Date-Hs<100))Fe(t);else if(!Me(e,t)&&!Ft(e.display,t)&&(t.dataTransfer.setData("Text",e.getSelection()),t.dataTransfer.effectAllowed="copyMove",t.dataTransfer.setDragImage&&!xl)){var r=n("img",null,null,"position: fixed; left: 0; top: 0;");r.src="data:image/gif;base64,R0lGODlhAQABAAAAACH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==",wl&&(r.width=r.height=1,e.display.wrapper.appendChild(r),r._top=r.offsetTop),t.dataTransfer.setDragImage(r,0,0),wl&&r.parentNode.removeChild(r)}}function Zi(e,t){var i=Sr(e,t);if(i){var o=document.createDocumentFragment();Mr(e,i,o),e.display.dragCursor||(e.display.dragCursor=n("div",null,"CodeMirror-cursors CodeMirror-dragcursors"),e.display.lineSpace.insertBefore(e.display.dragCursor,e.display.cursorDiv)),r(e.display.dragCursor,o)}}function Qi(e){e.display.dragCursor&&(e.display.lineSpace.removeChild(e.display.dragCursor),e.display.dragCursor=null)}function Ji(e){if(document.getElementsByClassName)for(var t=document.getElementsByClassName("CodeMirror"),r=0;r<t.length;r++){var n=t[r].CodeMirror;n&&e(n)}}function eo(){Fs||(to(),Fs=!0)}function to(){var e;Ql(window,"resize",function(){null==e&&(e=setTimeout(function(){e=null,Ji(ro)},100))}),Ql(window,"blur",function(){return Ji(Fr)})}function ro(e){var t=e.display;t.lastWrapHeight==t.wrapper.clientHeight&&t.lastWrapWidth==t.wrapper.clientWidth||(t.cachedCharWidth=t.cachedTextHeight=t.cachedPaddingH=null,t.scrollbarsClipped=!1,e.setSize())}function no(e){var t=e.split(/-(?!$)/);e=t[t.length-1];for(var r,n,i,o,l=0;l<t.length-1;l++){var s=t[l];if(/^(cmd|meta|m)$/i.test(s))o=!0;else if(/^a(lt)?$/i.test(s))r=!0;else if(/^(c|ctrl|control)$/i.test(s))n=!0;else{if(!/^s(hift)?$/i.test(s))throw new Error("Unrecognized modifier name: "+s);i=!0}}return r&&(e="Alt-"+e),n&&(e="Ctrl-"+e),o&&(e="Cmd-"+e),i&&(e="Shift-"+e),e}function io(e){var t={};for(var r in e)if(e.hasOwnProperty(r)){var n=e[r];if(/^(name|fallthrough|(de|at)tach)$/.test(r))continue;if("..."==n){delete e[r];continue}for(var i=v(r.split(" "),no),o=0;o<i.length;o++){var l=void 0,s=void 0;o==i.length-1?(s=i.join(" "),l=n):(s=i.slice(0,o+1).join(" "),l="...");var a=t[s];if(a){if(a!=l)throw new Error("Inconsistent bindings for "+s)}else t[s]=l}delete e[r]}for(var u in t)e[u]=t[u];return e}function oo(e,t,r,n){var i=(t=uo(t)).call?t.call(e,n):t[e];if(!1===i)return"nothing";if("..."===i)return"multi";if(null!=i&&r(i))return"handled";if(t.fallthrough){if("[object Array]"!=Object.prototype.toString.call(t.fallthrough))return oo(e,t.fallthrough,r,n);for(var o=0;o<t.fallthrough.length;o++){var l=oo(e,t.fallthrough[o],r,n);if(l)return l}}}function lo(e){var t="string"==typeof e?e:Es[e.keyCode];return"Ctrl"==t||"Alt"==t||"Shift"==t||"Mod"==t}function so(e,t,r){var n=e;return t.altKey&&"Alt"!=n&&(e="Alt-"+e),(Dl?t.metaKey:t.ctrlKey)&&"Ctrl"!=n&&(e="Ctrl-"+e),(Dl?t.ctrlKey:t.metaKey)&&"Cmd"!=n&&(e="Cmd-"+e),!r&&t.shiftKey&&"Shift"!=n&&(e="Shift-"+e),e}function ao(e,t){if(wl&&34==e.keyCode&&e.char)return!1;var r=Es[e.keyCode];return null!=r&&!e.altGraphKey&&so(r,e,t)}function uo(e){return"string"==typeof e?Rs[e]:e}function co(e,t){for(var r=e.doc.sel.ranges,n=[],i=0;i<r.length;i++){for(var o=t(r[i]);n.length&&P(o.from,g(n).to)<=0;){var l=n.pop();if(P(l.from,o.from)<0){o.from=l.from;break}}n.push(o)}hn(e,function(){for(var t=n.length-1;t>=0;t--)Ei(e.doc,"",n[t].from,n[t].to,"+delete");jr(e)})}function fo(e,t,r){var n=L(e.text,t+r,r);return n<0||n>e.text.length?null:n}function ho(e,t,r){var n=fo(e,t.ch,r);return null==n?null:new E(t.line,n,r<0?"after":"before")}function po(e,t,r,n,i){if(e){var o=Se(r,t.doc.direction);if(o){var l,s=i<0?g(o):o[0],a=i<0==(1==s.level)?"after":"before";if(s.level>0){var u=Xt(t,r);l=i<0?r.text.length-1:0;var c=Yt(t,u,l).top;l=k(function(e){return Yt(t,u,e).top==c},i<0==(1==s.level)?s.from:s.to-1,l),"before"==a&&(l=fo(r,l,1))}else l=i<0?s.to:s.from;return new E(n,l,a)}}return new E(n,i<0?r.text.length:0,i<0?"before":"after")}function go(e,t,r,n){var i=Se(t,e.doc.direction);if(!i)return ho(t,r,n);r.ch>=t.text.length?(r.ch=t.text.length,r.sticky="before"):r.ch<=0&&(r.ch=0,r.sticky="after");var o=Ce(i,r.ch,r.sticky),l=i[o];if("ltr"==e.doc.direction&&l.level%2==0&&(n>0?l.to>r.ch:l.from<r.ch))return ho(t,r,n);var s,a=function(e,r){return fo(t,e instanceof E?e.ch:e,r)},u=function(r){return e.options.lineWrapping?(s=s||Xt(e,t),hr(e,t,s,r)):{begin:0,end:t.text.length}},c=u("before"==r.sticky?a(r,-1):r.ch);if("rtl"==e.doc.direction||1==l.level){var f=1==l.level==n<0,h=a(r,f?1:-1);if(null!=h&&(f?h<=l.to&&h<=c.end:h>=l.from&&h>=c.begin)){var d=f?"before":"after";return new E(r.line,h,d)}}var p=function(e,t,n){for(var o=function(e,t){return t?new E(r.line,a(e,1),"before"):new E(r.line,e,"after")};e>=0&&e<i.length;e+=t){var l=i[e],s=t>0==(1!=l.level),u=s?n.begin:a(n.end,-1);if(l.from<=u&&u<l.to)return o(u,s);if(u=s?l.from:a(l.to,-1),n.begin<=u&&u<n.end)return o(u,s)}},g=p(o+n,n,c);if(g)return g;var v=n>0?c.end:a(c.begin,-1);return null==v||n>0&&v==t.text.length||!(g=p(n>0?0:i.length-1,n,u(v)))?null:g}function vo(e,t){var r=M(e.doc,t),n=fe(r);return n!=r&&(t=W(n)),po(!0,e,n,t,1)}function mo(e,t){var r=M(e.doc,t),n=he(r);return n!=r&&(t=W(n)),po(!0,e,r,t,-1)}function yo(e,t){var r=vo(e,t.line),n=M(e.doc,r.line),i=Se(n,e.doc.direction);if(!i||0==i[0].level){var o=Math.max(0,n.text.search(/\S/)),l=t.line==r.line&&t.ch<=o&&t.ch;return E(r.line,l?0:o,r.sticky)}return r}function bo(e,t,r){if("string"==typeof t&&!(t=Bs[t]))return!1;e.display.input.ensurePolled();var n=e.display.shift,i=!1;try{e.isReadOnly()&&(e.state.suppressEdits=!0),r&&(e.display.shift=!1),i=t(e)!=Bl}finally{e.display.shift=n,e.state.suppressEdits=!1}return i}function wo(e,t,r){for(var n=0;n<e.state.keyMaps.length;n++){var i=oo(t,e.state.keyMaps[n],r,e);if(i)return i}return e.options.extraKeys&&oo(t,e.options.extraKeys,r,e)||oo(t,e.options.keyMap,r,e)}function xo(e,t,r,n){var i=e.state.keySeq;if(i){if(lo(t))return"handled";Gs.set(50,function(){e.state.keySeq==i&&(e.state.keySeq=null,e.display.input.reset())}),t=i+" "+t}var o=wo(e,t,n);return"multi"==o&&(e.state.keySeq=t),"handled"==o&&bt(e,"keyHandled",e,t,r),"handled"!=o&&"multi"!=o||(We(r),Ar(e)),i&&!o&&/\'$/.test(t)?(We(r),!0):!!o}function Co(e,t){var r=ao(t,!0);return!!r&&(t.shiftKey&&!e.state.keySeq?xo(e,"Shift-"+r,t,function(t){return bo(e,t,!0)})||xo(e,r,t,function(t){if("string"==typeof t?/^go[A-Z]/.test(t):t.motion)return bo(e,t)}):xo(e,r,t,function(t){return bo(e,t)}))}function So(e,t,r){return xo(e,"'"+r+"'",t,function(t){return bo(e,t,!0)})}function Lo(e){var t=this;if(t.curOp.focus=l(),!Me(t,e)){gl&&vl<11&&27==e.keyCode&&(e.returnValue=!1);var r=e.keyCode;t.display.shift=16==r||e.shiftKey;var n=Co(t,e);wl&&(Us=n?r:null,!n&&88==r&&!rs&&(Ml?e.metaKey:e.ctrlKey)&&t.replaceSelection("",null,"cut")),18!=r||/\bCodeMirror-crosshair\b/.test(t.display.lineDiv.className)||ko(t)}}function ko(e){function t(e){18!=e.keyCode&&e.altKey||(Fl(r,"CodeMirror-crosshair"),ke(document,"keyup",t),ke(document,"mouseover",t))}var r=e.display.lineDiv;s(r,"CodeMirror-crosshair"),Ql(document,"keyup",t),Ql(document,"mouseover",t)}function To(e){16==e.keyCode&&(this.doc.sel.shift=!1),Me(this,e)}function Mo(e){var t=this;if(!(Ft(t.display,e)||Me(t,e)||e.ctrlKey&&!e.altKey||Ml&&e.metaKey)){var r=e.keyCode,n=e.charCode;if(wl&&r==Us)return Us=null,void We(e);if(!wl||e.which&&!(e.which<10)||!Co(t,e)){var i=String.fromCharCode(null==n?r:n);"\b"!=i&&(So(t,e,i)||t.display.input.onKeyPress(e))}}}function No(e,t){var r=+new Date;return js&&js.compare(r,e,t)?(Ks=js=null,"triple"):Ks&&Ks.compare(r,e,t)?(js=new Vs(r,e,t),Ks=null,"double"):(Ks=new Vs(r,e,t),js=null,"single")}function Oo(e){var t=this,r=t.display;if(!(Me(t,e)||r.activeTouch&&r.input.supportsTouch()))if(r.input.ensurePolled(),r.shift=e.shiftKey,Ft(r,e))ml||(r.scroller.draggable=!1,setTimeout(function(){return r.scroller.draggable=!0},100));else if(!zo(t,e)){var n=Sr(t,e),i=Pe(e),o=n?No(n,i):"single";window.focus(),1==i&&t.state.selectingText&&t.state.selectingText(e),n&&Ao(t,i,n,o,e)||(1==i?n?Do(t,n,o,e):Ee(e)==r.scroller&&We(e):2==i?(n&&di(t.doc,n),setTimeout(function(){return r.input.focus()},20)):3==i&&(Hl?Ro(t,e):Dr(t)))}}function Ao(e,t,r,n,i){var o="Click";return"double"==n?o="Double"+o:"triple"==n&&(o="Triple"+o),o=(1==t?"Left":2==t?"Middle":"Right")+o,xo(e,so(o,i),i,function(t){if("string"==typeof t&&(t=Bs[t]),!t)return!1;var n=!1;try{e.isReadOnly()&&(e.state.suppressEdits=!0),n=t(e,r)!=Bl}finally{e.state.suppressEdits=!1}return n})}function Wo(e,t,r){var n=e.getOption("configureMouse"),i=n?n(e,t,r):{};if(null==i.unit){var o=Nl?r.shiftKey&&r.metaKey:r.altKey;i.unit=o?"rectangle":"single"==t?"char":"double"==t?"word":"line"}return(null==i.extend||e.doc.extend)&&(i.extend=e.doc.extend||r.shiftKey),null==i.addNew&&(i.addNew=Ml?r.metaKey:r.ctrlKey),null==i.moveOnDrag&&(i.moveOnDrag=!(Ml?r.altKey:r.ctrlKey)),i}function Do(e,t,r,n){gl?setTimeout(u(Wr,e),0):e.curOp.focus=l();var i,o=Wo(e,r,n),s=e.doc.sel;e.options.dragDrop&&Jl&&!e.isReadOnly()&&"single"==r&&(i=s.contains(t))>-1&&(P((i=s.ranges[i]).from(),t)<0||t.xRel>0)&&(P(i.to(),t)>0||t.xRel<0)?Ho(e,n,t,o):Eo(e,n,t,o)}function Ho(e,t,r,n){var i=e.display,o=!1,l=dn(e,function(t){ml&&(i.scroller.draggable=!1),e.state.draggingText=!1,ke(document,"mouseup",l),ke(document,"mousemove",s),ke(i.scroller,"dragstart",a),ke(i.scroller,"drop",l),o||(We(t),n.addNew||di(e.doc,r,null,null,n.extend),ml||gl&&9==vl?setTimeout(function(){document.body.focus(),i.input.focus()},20):i.input.focus())}),s=function(e){o=o||Math.abs(t.clientX-e.clientX)+Math.abs(t.clientY-e.clientY)>=10},a=function(){return o=!0};ml&&(i.scroller.draggable=!0),e.state.draggingText=l,l.copy=!n.moveOnDrag,i.scroller.dragDrop&&i.scroller.dragDrop(),Ql(document,"mouseup",l),Ql(document,"mousemove",s),Ql(i.scroller,"dragstart",a),Ql(i.scroller,"drop",l),Dr(e),setTimeout(function(){return i.input.focus()},20)}function Fo(e,t,r){if("char"==r)return new Ts(t,t);if("word"==r)return e.findWordAt(t);if("line"==r)return new Ts(E(t.line,0),U(e.doc,E(t.line+1,0)));var n=r(e,t);return new Ts(n.from,n.to)}function Eo(e,t,r,n){function i(t){if(0!=P(m,t))if(m=t,"rectangle"==n.unit){for(var i=[],o=e.options.tabSize,l=f(M(u,r.line).text,r.ch,o),s=f(M(u,t.line).text,t.ch,o),a=Math.min(l,s),g=Math.max(l,s),v=Math.min(r.line,t.line),y=Math.min(e.lastLine(),Math.max(r.line,t.line));v<=y;v++){var b=M(u,v).text,w=d(b,a,o);a==g?i.push(new Ts(E(v,w),E(v,w))):b.length>w&&i.push(new Ts(E(v,w),E(v,d(b,g,o))))}i.length||i.push(new Ts(r,r)),bi(u,zn(p.ranges.slice(0,h).concat(i),h),{origin:"*mouse",scroll:!1}),e.scrollIntoView(t)}else{var x,C=c,S=Fo(e,t,n.unit),L=C.anchor;P(S.anchor,L)>0?(x=S.head,L=B(C.from(),S.anchor)):(x=S.anchor,L=R(C.to(),S.head));var k=p.ranges.slice(0);k[h]=Po(e,new Ts(U(u,L),x)),bi(u,zn(k,h),Ul)}}function o(t){var r=++b,s=Sr(e,t,!0,"rectangle"==n.unit);if(s)if(0!=P(s,m)){e.curOp.focus=l(),i(s);var c=Ir(a,u);(s.line>=c.to||s.line<c.from)&&setTimeout(dn(e,function(){b==r&&o(t)}),150)}else{var f=t.clientY<y.top?-20:t.clientY>y.bottom?20:0;f&&setTimeout(dn(e,function(){b==r&&(a.scroller.scrollTop+=f,o(t))}),50)}}function s(t){e.state.selectingText=!1,b=1/0,We(t),a.input.focus(),ke(document,"mousemove",w),ke(document,"mouseup",x),u.history.lastSelOrigin=null}var a=e.display,u=e.doc;We(t);var c,h,p=u.sel,g=p.ranges;if(n.addNew&&!n.extend?(h=u.sel.contains(r),c=h>-1?g[h]:new Ts(r,r)):(c=u.sel.primary(),h=u.sel.primIndex),"rectangle"==n.unit)n.addNew||(c=new Ts(r,r)),r=Sr(e,t,!0,!0),h=-1;else{var v=Fo(e,r,n.unit);c=n.extend?hi(c,v.anchor,v.head,n.extend):v}n.addNew?-1==h?(h=g.length,bi(u,zn(g.concat([c]),h),{scroll:!1,origin:"*mouse"})):g.length>1&&g[h].empty()&&"char"==n.unit&&!n.extend?(bi(u,zn(g.slice(0,h).concat(g.slice(h+1)),0),{scroll:!1,origin:"*mouse"}),p=u.sel):gi(u,h,c,Ul):(h=0,bi(u,new ks([c],0),Ul),p=u.sel);var m=r,y=a.wrapper.getBoundingClientRect(),b=0,w=dn(e,function(e){Pe(e)?o(e):s(e)}),x=dn(e,s);e.state.selectingText=x,Ql(document,"mousemove",w),Ql(document,"mouseup",x)}function Po(e,t){var r=t.anchor,n=t.head,i=M(e.doc,r.line);if(0==P(r,n)&&r.sticky==n.sticky)return t;var o=Se(i);if(!o)return t;var l=Ce(o,r.ch,r.sticky),s=o[l];if(s.from!=r.ch&&s.to!=r.ch)return t;var a=l+(s.from==r.ch==(1!=s.level)?0:1);if(0==a||a==o.length)return t;var u;if(n.line!=r.line)u=(n.line-r.line)*("ltr"==e.doc.direction?1:-1)>0;else{var c=Ce(o,n.ch,n.sticky),f=c-l||(n.ch-r.ch)*(1==s.level?-1:1);u=c==a-1||c==a?f<0:f>0}var h=o[a+(u?-1:0)],d=u==(1==h.level),p=d?h.from:h.to,g=d?"after":"before";return r.ch==p&&r.sticky==g?t:new Ts(new E(r.line,p,g),n)}function Io(e,t,r,n){var i,o;if(t.touches)i=t.touches[0].clientX,o=t.touches[0].clientY;else try{i=t.clientX,o=t.clientY}catch(t){return!1}if(i>=Math.floor(e.display.gutters.getBoundingClientRect().right))return!1;n&&We(t);var l=e.display,s=l.lineDiv.getBoundingClientRect();if(o>s.bottom||!Oe(e,r))return He(t);o-=s.top-l.viewOffset;for(var a=0;a<e.options.gutters.length;++a){var u=l.gutters.childNodes[a];if(u&&u.getBoundingClientRect().right>=i)return Te(e,r,e,D(e.doc,o),e.options.gutters[a],t),He(t)}}function zo(e,t){return Io(e,t,"gutterClick",!0)}function Ro(e,t){Ft(e.display,t)||Bo(e,t)||Me(e,t,"contextmenu")||e.display.input.onContextMenu(t)}function Bo(e,t){return!!Oe(e,"gutterContextMenu")&&Io(e,t,"gutterContextMenu",!1)}function Go(e){e.display.wrapper.className=e.display.wrapper.className.replace(/\s*cm-s-\S+/g,"")+e.options.theme.replace(/(^|\s)\s*/g," cm-s-"),er(e)}function Uo(e){Hn(e),vn(e),zr(e)}function Vo(e,t,r){if(!t!=!(r&&r!=Xs)){var n=e.display.dragFunctions,i=t?Ql:ke;i(e.display.scroller,"dragstart",n.start),i(e.display.scroller,"dragenter",n.enter),i(e.display.scroller,"dragover",n.over),i(e.display.scroller,"dragleave",n.leave),i(e.display.scroller,"drop",n.drop)}}function Ko(e){e.options.lineWrapping?(s(e.display.wrapper,"CodeMirror-wrap"),e.display.sizer.style.minWidth="",e.display.sizerWidth=null):(Fl(e.display.wrapper,"CodeMirror-wrap"),we(e)),Cr(e),vn(e),er(e),setTimeout(function(){return en(e)},100)}function jo(e,t){var r=this;if(!(this instanceof jo))return new jo(e,t);this.options=t=t?c(t):{},c(Ys,t,!1),Fn(t);var n=t.value;"string"==typeof n&&(n=new Ds(n,t.mode,null,t.lineSeparator,t.direction)),this.doc=n;var i=new jo.inputStyles[t.inputStyle](this),o=this.display=new T(e,n,i);o.wrapper.CodeMirror=this,Hn(this),Go(this),t.lineWrapping&&(this.display.wrapper.className+=" CodeMirror-wrap"),rn(this),this.state={keyMaps:[],overlays:[],modeGen:0,overwrite:!1,delayingBlurEvent:!1,focused:!1,suppressEdits:!1,pasteIncoming:!1,cutIncoming:!1,selectingText:!1,draggingText:!1,highlight:new Pl,keySeq:null,specialChars:null},t.autofocus&&!Tl&&o.input.focus(),gl&&vl<11&&setTimeout(function(){return r.display.input.reset(!0)},20),Xo(this),eo(),nn(this),this.curOp.forceUpdate=!0,qn(this,n),t.autofocus&&!Tl||this.hasFocus()?setTimeout(u(Hr,this),20):Fr(this);for(var l in _s)_s.hasOwnProperty(l)&&_s[l](r,t[l],Xs);Rr(this),t.finishInit&&t.finishInit(this);for(var s=0;s<$s.length;++s)$s[s](r);on(this),ml&&t.lineWrapping&&"optimizelegibility"==getComputedStyle(o.lineDiv).textRendering&&(o.lineDiv.style.textRendering="auto")}function Xo(e){function t(){i.activeTouch&&(o=setTimeout(function(){return i.activeTouch=null},1e3),(l=i.activeTouch).end=+new Date)}function r(e){if(1!=e.touches.length)return!1;var t=e.touches[0];return t.radiusX<=1&&t.radiusY<=1}function n(e,t){if(null==t.left)return!0;var r=t.left-e.left,n=t.top-e.top;return r*r+n*n>400}var i=e.display;Ql(i.scroller,"mousedown",dn(e,Oo)),gl&&vl<11?Ql(i.scroller,"dblclick",dn(e,function(t){if(!Me(e,t)){var r=Sr(e,t);if(r&&!zo(e,t)&&!Ft(e.display,t)){We(t);var n=e.findWordAt(r);di(e.doc,n.anchor,n.head)}}})):Ql(i.scroller,"dblclick",function(t){return Me(e,t)||We(t)}),Hl||Ql(i.scroller,"contextmenu",function(t){return Ro(e,t)});var o,l={end:0};Ql(i.scroller,"touchstart",function(t){if(!Me(e,t)&&!r(t)&&!zo(e,t)){i.input.ensurePolled(),clearTimeout(o);var n=+new Date;i.activeTouch={start:n,moved:!1,prev:n-l.end<=300?l:null},1==t.touches.length&&(i.activeTouch.left=t.touches[0].pageX,i.activeTouch.top=t.touches[0].pageY)}}),Ql(i.scroller,"touchmove",function(){i.activeTouch&&(i.activeTouch.moved=!0)}),Ql(i.scroller,"touchend",function(r){var o=i.activeTouch;if(o&&!Ft(i,r)&&null!=o.left&&!o.moved&&new Date-o.start<300){var l,s=e.coordsChar(i.activeTouch,"page");l=!o.prev||n(o,o.prev)?new Ts(s,s):!o.prev.prev||n(o,o.prev.prev)?e.findWordAt(s):new Ts(E(s.line,0),U(e.doc,E(s.line+1,0))),e.setSelection(l.anchor,l.head),e.focus(),We(r)}t()}),Ql(i.scroller,"touchcancel",t),Ql(i.scroller,"scroll",function(){i.scroller.clientHeight&&(qr(e,i.scroller.scrollTop),Qr(e,i.scroller.scrollLeft,!0),Te(e,"scroll",e))}),Ql(i.scroller,"mousewheel",function(t){return In(e,t)}),Ql(i.scroller,"DOMMouseScroll",function(t){return In(e,t)}),Ql(i.wrapper,"scroll",function(){return i.wrapper.scrollTop=i.wrapper.scrollLeft=0}),i.dragFunctions={enter:function(t){Me(e,t)||Fe(t)},over:function(t){Me(e,t)||(Zi(e,t),Fe(t))},start:function(t){return qi(e,t)},drop:dn(e,$i),leave:function(t){Me(e,t)||Qi(e)}};var s=i.input.getField();Ql(s,"keyup",function(t){return To.call(e,t)}),Ql(s,"keydown",dn(e,Lo)),Ql(s,"keypress",dn(e,Mo)),Ql(s,"focus",function(t){return Hr(e,t)}),Ql(s,"blur",function(t){return Fr(e,t)})}function Yo(e,t,r,n){var i,o=e.doc;null==r&&(r="add"),"smart"==r&&(o.mode.indent?i=$e(e,t).state:r="prev");var l=e.options.tabSize,s=M(o,t),a=f(s.text,null,l);s.stateAfter&&(s.stateAfter=null);var u,c=s.text.match(/^\s*/)[0];if(n||/\S/.test(s.text)){if("smart"==r&&((u=o.mode.indent(i,s.text.slice(c.length),s.text))==Bl||u>150)){if(!n)return;r="prev"}}else u=0,r="not";"prev"==r?u=t>o.first?f(M(o,t-1).text,null,l):0:"add"==r?u=a+e.options.indentUnit:"subtract"==r?u=a-e.options.indentUnit:"number"==typeof r&&(u=a+r),u=Math.max(0,u);var h="",d=0;if(e.options.indentWithTabs)for(var g=Math.floor(u/l);g;--g)d+=l,h+="\t";if(d<u&&(h+=p(u-d)),h!=c)return Ei(o,h,E(t,0),E(t,c.length),"+input"),s.stateAfter=null,!0;for(var v=0;v<o.sel.ranges.length;v++){var m=o.sel.ranges[v];if(m.head.line==t&&m.head.ch<c.length){var y=E(t,c.length);gi(o,v,new Ts(y,y));break}}}function _o(e){qs=e}function $o(e,t,r,n,i){var o=e.doc;e.display.shift=!1,n||(n=o.sel);var l=e.state.pasteIncoming||"paste"==i,s=es(t),a=null;if(l&&n.ranges.length>1)if(qs&&qs.text.join("\n")==t){if(n.ranges.length%qs.text.length==0){a=[];for(var u=0;u<qs.text.length;u++)a.push(o.splitLines(qs.text[u]))}}else s.length==n.ranges.length&&e.options.pasteLinesPerSelection&&(a=v(s,function(e){return[e]}));for(var c,f=n.ranges.length-1;f>=0;f--){var h=n.ranges[f],d=h.from(),p=h.to();h.empty()&&(r&&r>0?d=E(d.line,d.ch-r):e.state.overwrite&&!l?p=E(p.line,Math.min(M(o,p.line).text.length,p.ch+g(s).length)):qs&&qs.lineWise&&qs.text.join("\n")==t&&(d=p=E(d.line,0))),c=e.curOp.updateInput;var m={from:d,to:p,text:a?a[f%a.length]:s,origin:i||(l?"paste":e.state.cutIncoming?"cut":"+input")};Oi(e.doc,m),bt(e,"inputRead",e,m)}t&&!l&&Zo(e,t),jr(e),e.curOp.updateInput=c,e.curOp.typing=!0,e.state.pasteIncoming=e.state.cutIncoming=!1}function qo(e,t){var r=e.clipboardData&&e.clipboardData.getData("Text");if(r)return e.preventDefault(),t.isReadOnly()||t.options.disableInput||hn(t,function(){return $o(t,r,0,null,"paste")}),!0}function Zo(e,t){if(e.options.electricChars&&e.options.smartIndent)for(var r=e.doc.sel,n=r.ranges.length-1;n>=0;n--){var i=r.ranges[n];if(!(i.head.ch>100||n&&r.ranges[n-1].head.line==i.head.line)){var o=e.getModeAt(i.head),l=!1;if(o.electricChars){for(var s=0;s<o.electricChars.length;s++)if(t.indexOf(o.electricChars.charAt(s))>-1){l=Yo(e,i.head.line,"smart");break}}else o.electricInput&&o.electricInput.test(M(e.doc,i.head.line).text.slice(0,i.head.ch))&&(l=Yo(e,i.head.line,"smart"));l&&bt(e,"electricInput",e,i.head.line)}}}function Qo(e){for(var t=[],r=[],n=0;n<e.doc.sel.ranges.length;n++){var i=e.doc.sel.ranges[n].head.line,o={anchor:E(i,0),head:E(i+1,0)};r.push(o),t.push(e.getRange(o.anchor,o.head))}return{text:t,ranges:r}}function Jo(e,t){e.setAttribute("autocorrect","off"),e.setAttribute("autocapitalize","off"),e.setAttribute("spellcheck",!!t)}function el(){var e=n("textarea",null,null,"position: absolute; bottom: -1em; padding: 0; width: 1px; height: 1em; outline: none"),t=n("div",[e],null,"overflow: hidden; position: relative; width: 3px; height: 0px;");return ml?e.style.width="1000px":e.setAttribute("wrap","off"),Ll&&(e.style.border="1px solid black"),Jo(e),t}function tl(e,t,r,n,i){function o(){var n=t.line+r;return!(n<e.first||n>=e.first+e.size)&&(t=new E(n,t.ch,t.sticky),u=M(e,n))}function l(n){var l;if(null==(l=i?go(e.cm,u,t,r):ho(u,t,r))){if(n||!o())return!1;t=po(i,e.cm,u,t.line,r)}else t=l;return!0}var s=t,a=r,u=M(e,t.line);if("char"==n)l();else if("column"==n)l(!0);else if("word"==n||"group"==n)for(var c=null,f="group"==n,h=e.cm&&e.cm.getHelper(t,"wordChars"),d=!0;!(r<0)||l(!d);d=!1){var p=u.text.charAt(t.ch)||"\n",g=x(p,h)?"w":f&&"\n"==p?"n":!f||/\s/.test(p)?null:"p";if(!f||d||g||(g="s"),c&&c!=g){r<0&&(r=1,l(),t.sticky="after");break}if(g&&(c=g),r>0&&!l(!d))break}var v=ki(e,t,s,a,!0);return I(s,v)&&(v.hitSide=!0),v}function rl(e,t,r,n){var i,o=e.doc,l=t.left;if("page"==n){var s=Math.min(e.display.wrapper.clientHeight,window.innerHeight||document.documentElement.clientHeight),a=Math.max(s-.5*mr(e.display),3);i=(r>0?t.bottom:t.top)+r*a}else"line"==n&&(i=r>0?t.bottom+3:t.top-3);for(var u;(u=cr(e,l,i)).outside;){if(r<0?i<=0:i>=o.height){u.hitSide=!0;break}i+=5*r}return u}function nl(e,t){var r=jt(e,t.line);if(!r||r.hidden)return null;var n=M(e.doc,t.line),i=Ut(r,n,t.line),o=Se(n,e.doc.direction),l="left";o&&(l=Ce(o,t.ch)%2?"right":"left");var s=_t(i.map,t.ch,l);return s.offset="right"==s.collapse?s.end:s.start,s}function il(e){for(var t=e;t;t=t.parentNode)if(/CodeMirror-gutter-wrapper/.test(t.className))return!0;return!1}function ol(e,t){return t&&(e.bad=!0),e}function ll(e,t,r,n,i){function o(e){return function(t){return t.id==e}}function l(){c&&(u+=f,c=!1)}function s(e){e&&(l(),u+=e)}function a(t){if(1==t.nodeType){var r=t.getAttribute("cm-text");if(null!=r)return void s(r||t.textContent.replace(/\u200b/g,""));var u,h=t.getAttribute("cm-marker");if(h){var d=e.findMarks(E(n,0),E(i+1,0),o(+h));return void(d.length&&(u=d[0].find(0))&&s(N(e.doc,u.from,u.to).join(f)))}if("false"==t.getAttribute("contenteditable"))return;var p=/^(pre|div|p)$/i.test(t.nodeName);p&&l();for(var g=0;g<t.childNodes.length;g++)a(t.childNodes[g]);p&&(c=!0)}else 3==t.nodeType&&s(t.nodeValue)}for(var u="",c=!1,f=e.doc.lineSeparator();a(t),t!=r;)t=t.nextSibling;return u}function sl(e,t,r){var n;if(t==e.display.lineDiv){if(!(n=e.display.lineDiv.childNodes[r]))return ol(e.clipPos(E(e.display.viewTo-1)),!0);t=null,r=0}else for(n=t;;n=n.parentNode){if(!n||n==e.display.lineDiv)return null;if(n.parentNode&&n.parentNode==e.display.lineDiv)break}for(var i=0;i<e.display.view.length;i++){var o=e.display.view[i];if(o.node==n)return al(o,t,r)}}function al(e,t,r){function n(t,r,n){for(var i=-1;i<(f?f.length:0);i++)for(var o=i<0?c.map:f[i],l=0;l<o.length;l+=3){var s=o[l+2];if(s==t||s==r){var a=W(i<0?e.line:e.rest[i]),u=o[l]+n;return(n<0||s!=t)&&(u=o[l+(n?1:0)]),E(a,u)}}}var i=e.text.firstChild,l=!1;if(!t||!o(i,t))return ol(E(W(e.line),0),!0);if(t==i&&(l=!0,t=i.childNodes[r],r=0,!t)){var s=e.rest?g(e.rest):e.line;return ol(E(W(s),s.text.length),l)}var a=3==t.nodeType?t:null,u=t;for(a||1!=t.childNodes.length||3!=t.firstChild.nodeType||(a=t.firstChild,r&&(r=a.nodeValue.length));u.parentNode!=i;)u=u.parentNode;var c=e.measure,f=c.maps,h=n(a,u,r);if(h)return ol(h,l);for(var d=u.nextSibling,p=a?a.nodeValue.length-r:0;d;d=d.nextSibling){if(h=n(d,d.firstChild,0))return ol(E(h.line,h.ch-p),l);p+=d.textContent.length}for(var v=u.previousSibling,m=r;v;v=v.previousSibling){if(h=n(v,v.firstChild,-1))return ol(E(h.line,h.ch+m),l);m+=v.textContent.length}}var ul=navigator.userAgent,cl=navigator.platform,fl=/gecko\/\d/i.test(ul),hl=/MSIE \d/.test(ul),dl=/Trident\/(?:[7-9]|\d{2,})\..*rv:(\d+)/.exec(ul),pl=/Edge\/(\d+)/.exec(ul),gl=hl||dl||pl,vl=gl&&(hl?document.documentMode||6:+(pl||dl)[1]),ml=!pl&&/WebKit\//.test(ul),yl=ml&&/Qt\/\d+\.\d+/.test(ul),bl=!pl&&/Chrome\//.test(ul),wl=/Opera\//.test(ul),xl=/Apple Computer/.test(navigator.vendor),Cl=/Mac OS X 1\d\D([8-9]|\d\d)\D/.test(ul),Sl=/PhantomJS/.test(ul),Ll=!pl&&/AppleWebKit/.test(ul)&&/Mobile\/\w+/.test(ul),kl=/Android/.test(ul),Tl=Ll||kl||/webOS|BlackBerry|Opera Mini|Opera Mobi|IEMobile/i.test(ul),Ml=Ll||/Mac/.test(cl),Nl=/\bCrOS\b/.test(ul),Ol=/win/i.test(cl),Al=wl&&ul.match(/Version\/(\d*\.\d*)/);Al&&(Al=Number(Al[1])),Al&&Al>=15&&(wl=!1,ml=!0);var Wl,Dl=Ml&&(yl||wl&&(null==Al||Al<12.11)),Hl=fl||gl&&vl>=9,Fl=function(t,r){var n=t.className,i=e(r).exec(n);if(i){var o=n.slice(i.index+i[0].length);t.className=n.slice(0,i.index)+(o?i[1]+o:"")}};Wl=document.createRange?function(e,t,r,n){var i=document.createRange();return i.setEnd(n||e,r),i.setStart(e,t),i}:function(e,t,r){var n=document.body.createTextRange();try{n.moveToElementText(e.parentNode)}catch(e){return n}return n.collapse(!0),n.moveEnd("character",r),n.moveStart("character",t),n};var El=function(e){e.select()};Ll?El=function(e){e.selectionStart=0,e.selectionEnd=e.value.length}:gl&&(El=function(e){try{e.select()}catch(e){}});var Pl=function(){this.id=null};Pl.prototype.set=function(e,t){clearTimeout(this.id),this.id=setTimeout(t,e)};var Il,zl,Rl=30,Bl={toString:function(){return"CodeMirror.Pass"}},Gl={scroll:!1},Ul={origin:"*mouse"},Vl={origin:"+move"},Kl=[""],jl=/[\u00df\u0587\u0590-\u05f4\u0600-\u06ff\u3040-\u309f\u30a0-\u30ff\u3400-\u4db5\u4e00-\u9fcc\uac00-\ud7af]/,Xl=/[\u0300-\u036f\u0483-\u0489\u0591-\u05bd\u05bf\u05c1\u05c2\u05c4\u05c5\u05c7\u0610-\u061a\u064b-\u065e\u0670\u06d6-\u06dc\u06de-\u06e4\u06e7\u06e8\u06ea-\u06ed\u0711\u0730-\u074a\u07a6-\u07b0\u07eb-\u07f3\u0816-\u0819\u081b-\u0823\u0825-\u0827\u0829-\u082d\u0900-\u0902\u093c\u0941-\u0948\u094d\u0951-\u0955\u0962\u0963\u0981\u09bc\u09be\u09c1-\u09c4\u09cd\u09d7\u09e2\u09e3\u0a01\u0a02\u0a3c\u0a41\u0a42\u0a47\u0a48\u0a4b-\u0a4d\u0a51\u0a70\u0a71\u0a75\u0a81\u0a82\u0abc\u0ac1-\u0ac5\u0ac7\u0ac8\u0acd\u0ae2\u0ae3\u0b01\u0b3c\u0b3e\u0b3f\u0b41-\u0b44\u0b4d\u0b56\u0b57\u0b62\u0b63\u0b82\u0bbe\u0bc0\u0bcd\u0bd7\u0c3e-\u0c40\u0c46-\u0c48\u0c4a-\u0c4d\u0c55\u0c56\u0c62\u0c63\u0cbc\u0cbf\u0cc2\u0cc6\u0ccc\u0ccd\u0cd5\u0cd6\u0ce2\u0ce3\u0d3e\u0d41-\u0d44\u0d4d\u0d57\u0d62\u0d63\u0dca\u0dcf\u0dd2-\u0dd4\u0dd6\u0ddf\u0e31\u0e34-\u0e3a\u0e47-\u0e4e\u0eb1\u0eb4-\u0eb9\u0ebb\u0ebc\u0ec8-\u0ecd\u0f18\u0f19\u0f35\u0f37\u0f39\u0f71-\u0f7e\u0f80-\u0f84\u0f86\u0f87\u0f90-\u0f97\u0f99-\u0fbc\u0fc6\u102d-\u1030\u1032-\u1037\u1039\u103a\u103d\u103e\u1058\u1059\u105e-\u1060\u1071-\u1074\u1082\u1085\u1086\u108d\u109d\u135f\u1712-\u1714\u1732-\u1734\u1752\u1753\u1772\u1773\u17b7-\u17bd\u17c6\u17c9-\u17d3\u17dd\u180b-\u180d\u18a9\u1920-\u1922\u1927\u1928\u1932\u1939-\u193b\u1a17\u1a18\u1a56\u1a58-\u1a5e\u1a60\u1a62\u1a65-\u1a6c\u1a73-\u1a7c\u1a7f\u1b00-\u1b03\u1b34\u1b36-\u1b3a\u1b3c\u1b42\u1b6b-\u1b73\u1b80\u1b81\u1ba2-\u1ba5\u1ba8\u1ba9\u1c2c-\u1c33\u1c36\u1c37\u1cd0-\u1cd2\u1cd4-\u1ce0\u1ce2-\u1ce8\u1ced\u1dc0-\u1de6\u1dfd-\u1dff\u200c\u200d\u20d0-\u20f0\u2cef-\u2cf1\u2de0-\u2dff\u302a-\u302f\u3099\u309a\ua66f-\ua672\ua67c\ua67d\ua6f0\ua6f1\ua802\ua806\ua80b\ua825\ua826\ua8c4\ua8e0-\ua8f1\ua926-\ua92d\ua947-\ua951\ua980-\ua982\ua9b3\ua9b6-\ua9b9\ua9bc\uaa29-\uaa2e\uaa31\uaa32\uaa35\uaa36\uaa43\uaa4c\uaab0\uaab2-\uaab4\uaab7\uaab8\uaabe\uaabf\uaac1\uabe5\uabe8\uabed\udc00-\udfff\ufb1e\ufe00-\ufe0f\ufe20-\ufe26\uff9e\uff9f]/,Yl=!1,_l=!1,$l=null,ql=function(){function e(e){return e<=247?r.charAt(e):1424<=e&&e<=1524?"R":1536<=e&&e<=1785?n.charAt(e-1536):1774<=e&&e<=2220?"r":8192<=e&&e<=8203?"w":8204==e?"b":"L"}function t(e,t,r){this.level=e,this.from=t,this.to=r}var r="bbbbbbbbbtstwsbbbbbbbbbbbbbbssstwNN%%%NNNNNN,N,N1111111111NNNNNNNLLLLLLLLLLLLLLLLLLLLLLLLLLNNNNNNLLLLLLLLLLLLLLLLLLLLLLLLLLNNNNbbbbbbsbbbbbbbbbbbbbbbbbbbbbbbbbb,N%%%%NNNNLNNNNN%%11NLNNN1LNNNNNLLLLLLLLLLLLLLLLLLLLLLLNLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLN",n="nnnnnnNNr%%r,rNNmmmmmmmmmmmrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrmmmmmmmmmmmmmmmmmmmmmnnnnnnnnnn%nnrrrmrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrmmmmmmmnNmmmmmmrrmmNmmmmrr1111111111",i=/[\u0590-\u05f4\u0600-\u06ff\u0700-\u08ac]/,o=/[stwN]/,l=/[LRr]/,s=/[Lb1n]/,a=/[1n]/;return function(r,n){var u="ltr"==n?"L":"R";if(0==r.length||"ltr"==n&&!i.test(r))return!1;for(var c=r.length,f=[],h=0;h<c;++h)f.push(e(r.charCodeAt(h)));for(var d=0,p=u;d<c;++d){var v=f[d];"m"==v?f[d]=p:p=v}for(var m=0,y=u;m<c;++m){var b=f[m];"1"==b&&"r"==y?f[m]="n":l.test(b)&&(y=b,"r"==b&&(f[m]="R"))}for(var w=1,x=f[0];w<c-1;++w){var C=f[w];"+"==C&&"1"==x&&"1"==f[w+1]?f[w]="1":","!=C||x!=f[w+1]||"1"!=x&&"n"!=x||(f[w]=x),x=C}for(var S=0;S<c;++S){var L=f[S];if(","==L)f[S]="N";else if("%"==L){var k=void 0;for(k=S+1;k<c&&"%"==f[k];++k);for(var T=S&&"!"==f[S-1]||k<c&&"1"==f[k]?"1":"N",M=S;M<k;++M)f[M]=T;S=k-1}}for(var N=0,O=u;N<c;++N){var A=f[N];"L"==O&&"1"==A?f[N]="L":l.test(A)&&(O=A)}for(var W=0;W<c;++W)if(o.test(f[W])){var D=void 0;for(D=W+1;D<c&&o.test(f[D]);++D);for(var H="L"==(W?f[W-1]:u),F=H==("L"==(D<c?f[D]:u))?H?"L":"R":u,E=W;E<D;++E)f[E]=F;W=D-1}for(var P,I=[],z=0;z<c;)if(s.test(f[z])){var R=z;for(++z;z<c&&s.test(f[z]);++z);I.push(new t(0,R,z))}else{var B=z,G=I.length;for(++z;z<c&&"L"!=f[z];++z);for(var U=B;U<z;)if(a.test(f[U])){B<U&&I.splice(G,0,new t(1,B,U));var V=U;for(++U;U<z&&a.test(f[U]);++U);I.splice(G,0,new t(2,V,U)),B=U}else++U;B<z&&I.splice(G,0,new t(1,B,z))}return 1==I[0].level&&(P=r.match(/^\s+/))&&(I[0].from=P[0].length,I.unshift(new t(0,0,P[0].length))),1==g(I).level&&(P=r.match(/\s+$/))&&(g(I).to-=P[0].length,I.push(new t(0,c-P[0].length,c))),"rtl"==n?I.reverse():I}}(),Zl=[],Ql=function(e,t,r){if(e.addEventListener)e.addEventListener(t,r,!1);else if(e.attachEvent)e.attachEvent("on"+t,r);else{var n=e._handlers||(e._handlers={});n[t]=(n[t]||Zl).concat(r)}},Jl=function(){if(gl&&vl<9)return!1;var e=n("div");return"draggable"in e||"dragDrop"in e}(),es=3!="\n\nb".split(/\n/).length?function(e){for(var t=0,r=[],n=e.length;t<=n;){var i=e.indexOf("\n",t);-1==i&&(i=e.length);var o=e.slice(t,"\r"==e.charAt(i-1)?i-1:i),l=o.indexOf("\r");-1!=l?(r.push(o.slice(0,l)),t+=l+1):(r.push(o),t=i+1)}return r}:function(e){return e.split(/\r\n?|\n/)},ts=window.getSelection?function(e){try{return e.selectionStart!=e.selectionEnd}catch(e){return!1}}:function(e){var t;try{t=e.ownerDocument.selection.createRange()}catch(e){}return!(!t||t.parentElement()!=e)&&0!=t.compareEndPoints("StartToEnd",t)},rs=function(){var e=n("div");return"oncopy"in e||(e.setAttribute("oncopy","return;"),"function"==typeof e.oncopy)}(),ns=null,is={},os={},ls={},ss=function(e,t,r){this.pos=this.start=0,this.string=e,this.tabSize=t||8,this.lastColumnPos=this.lastColumnValue=0,this.lineStart=0,this.lineOracle=r};ss.prototype.eol=function(){return this.pos>=this.string.length},ss.prototype.sol=function(){return this.pos==this.lineStart},ss.prototype.peek=function(){return this.string.charAt(this.pos)||void 0},ss.prototype.next=function(){if(this.pos<this.string.length)return this.string.charAt(this.pos++)},ss.prototype.eat=function(e){var t=this.string.charAt(this.pos);if("string"==typeof e?t==e:t&&(e.test?e.test(t):e(t)))return++this.pos,t},ss.prototype.eatWhile=function(e){for(var t=this.pos;this.eat(e););return this.pos>t},ss.prototype.eatSpace=function(){for(var e=this,t=this.pos;/[\s\u00a0]/.test(this.string.charAt(this.pos));)++e.pos;return this.pos>t},ss.prototype.skipToEnd=function(){this.pos=this.string.length},ss.prototype.skipTo=function(e){var t=this.string.indexOf(e,this.pos);if(t>-1)return this.pos=t,!0},ss.prototype.backUp=function(e){this.pos-=e},ss.prototype.column=function(){return this.lastColumnPos<this.start&&(this.lastColumnValue=f(this.string,this.start,this.tabSize,this.lastColumnPos,this.lastColumnValue),this.lastColumnPos=this.start),this.lastColumnValue-(this.lineStart?f(this.string,this.lineStart,this.tabSize):0)},ss.prototype.indentation=function(){return f(this.string,null,this.tabSize)-(this.lineStart?f(this.string,this.lineStart,this.tabSize):0)},ss.prototype.match=function(e,t,r){if("string"!=typeof e){var n=this.string.slice(this.pos).match(e);return n&&n.index>0?null:(n&&!1!==t&&(this.pos+=n[0].length),n)}var i=function(e){return r?e.toLowerCase():e};if(i(this.string.substr(this.pos,e.length))==i(e))return!1!==t&&(this.pos+=e.length),!0},ss.prototype.current=function(){return this.string.slice(this.start,this.pos)},ss.prototype.hideFirstChars=function(e,t){this.lineStart+=e;try{return t()}finally{this.lineStart-=e}},ss.prototype.lookAhead=function(e){var t=this.lineOracle;return t&&t.lookAhead(e)};var as=function(e,t){this.state=e,this.lookAhead=t},us=function(e,t,r,n){this.state=t,this.doc=e,this.line=r,this.maxLookAhead=n||0};us.prototype.lookAhead=function(e){var t=this.doc.getLine(this.line+e);return null!=t&&e>this.maxLookAhead&&(this.maxLookAhead=e),t},us.prototype.nextLine=function(){this.line++,this.maxLookAhead>0&&this.maxLookAhead--},us.fromSaved=function(e,t,r){return t instanceof as?new us(e,Ke(e.mode,t.state),r,t.lookAhead):new us(e,Ke(e.mode,t),r)},us.prototype.save=function(e){var t=!1!==e?Ke(this.doc.mode,this.state):this.state;return this.maxLookAhead>0?new as(t,this.maxLookAhead):t};var cs=function(e,t,r){this.start=e.start,this.end=e.pos,this.string=e.current(),this.type=t||null,this.state=r},fs=function(e,t,r){this.text=e,ne(this,t),this.height=r?r(this):1};fs.prototype.lineNo=function(){return W(this)},Ae(fs);var hs,ds={},ps={},gs=null,vs=null,ms={left:0,right:0,top:0,bottom:0},ys=function(e,t,r){this.cm=r;var i=this.vert=n("div",[n("div",null,null,"min-width: 1px")],"CodeMirror-vscrollbar"),o=this.horiz=n("div",[n("div",null,null,"height: 100%; min-height: 1px")],"CodeMirror-hscrollbar");e(i),e(o),Ql(i,"scroll",function(){i.clientHeight&&t(i.scrollTop,"vertical")}),Ql(o,"scroll",function(){o.clientWidth&&t(o.scrollLeft,"horizontal")}),this.checkedZeroWidth=!1,gl&&vl<8&&(this.horiz.style.minHeight=this.vert.style.minWidth="18px")};ys.prototype.update=function(e){var t=e.scrollWidth>e.clientWidth+1,r=e.scrollHeight>e.clientHeight+1,n=e.nativeBarWidth;if(r){this.vert.style.display="block",this.vert.style.bottom=t?n+"px":"0";var i=e.viewHeight-(t?n:0);this.vert.firstChild.style.height=Math.max(0,e.scrollHeight-e.clientHeight+i)+"px"}else this.vert.style.display="",this.vert.firstChild.style.height="0";if(t){this.horiz.style.display="block",this.horiz.style.right=r?n+"px":"0",this.horiz.style.left=e.barLeft+"px";var o=e.viewWidth-e.barLeft-(r?n:0);this.horiz.firstChild.style.width=Math.max(0,e.scrollWidth-e.clientWidth+o)+"px"}else this.horiz.style.display="",this.horiz.firstChild.style.width="0";return!this.checkedZeroWidth&&e.clientHeight>0&&(0==n&&this.zeroWidthHack(),this.checkedZeroWidth=!0),{right:r?n:0,bottom:t?n:0}},ys.prototype.setScrollLeft=function(e){this.horiz.scrollLeft!=e&&(this.horiz.scrollLeft=e),this.disableHoriz&&this.enableZeroWidthBar(this.horiz,this.disableHoriz,"horiz")},ys.prototype.setScrollTop=function(e){this.vert.scrollTop!=e&&(this.vert.scrollTop=e),this.disableVert&&this.enableZeroWidthBar(this.vert,this.disableVert,"vert")},ys.prototype.zeroWidthHack=function(){var e=Ml&&!Cl?"12px":"18px";this.horiz.style.height=this.vert.style.width=e,this.horiz.style.pointerEvents=this.vert.style.pointerEvents="none",this.disableHoriz=new Pl,this.disableVert=new Pl},ys.prototype.enableZeroWidthBar=function(e,t,r){function n(){var i=e.getBoundingClientRect();("vert"==r?document.elementFromPoint(i.right-1,(i.top+i.bottom)/2):document.elementFromPoint((i.right+i.left)/2,i.bottom-1))!=e?e.style.pointerEvents="none":t.set(1e3,n)}e.style.pointerEvents="auto",t.set(1e3,n)},ys.prototype.clear=function(){var e=this.horiz.parentNode;e.removeChild(this.horiz),e.removeChild(this.vert)};var bs=function(){};bs.prototype.update=function(){return{bottom:0,right:0}},bs.prototype.setScrollLeft=function(){},bs.prototype.setScrollTop=function(){},bs.prototype.clear=function(){};var ws={native:ys,null:bs},xs=0,Cs=function(e,t,r){var n=e.display;this.viewport=t,this.visible=Ir(n,e.doc,t),this.editorIsHidden=!n.wrapper.offsetWidth,this.wrapperHeight=n.wrapper.clientHeight,this.wrapperWidth=n.wrapper.clientWidth,this.oldDisplayWidth=Rt(e),this.force=r,this.dims=br(e),this.events=[]};Cs.prototype.signal=function(e,t){Oe(e,t)&&this.events.push(arguments)},Cs.prototype.finish=function(){for(var e=this,t=0;t<this.events.length;t++)Te.apply(null,e.events[t])};var Ss=0,Ls=null;gl?Ls=-.53:fl?Ls=15:bl?Ls=-.7:xl&&(Ls=-1/3);var ks=function(e,t){this.ranges=e,this.primIndex=t};ks.prototype.primary=function(){return this.ranges[this.primIndex]},ks.prototype.equals=function(e){var t=this;if(e==this)return!0;if(e.primIndex!=this.primIndex||e.ranges.length!=this.ranges.length)return!1;for(var r=0;r<this.ranges.length;r++){var n=t.ranges[r],i=e.ranges[r];if(!I(n.anchor,i.anchor)||!I(n.head,i.head))return!1}return!0},ks.prototype.deepCopy=function(){for(var e=this,t=[],r=0;r<this.ranges.length;r++)t[r]=new Ts(z(e.ranges[r].anchor),z(e.ranges[r].head));return new ks(t,this.primIndex)},ks.prototype.somethingSelected=function(){for(var e=this,t=0;t<this.ranges.length;t++)if(!e.ranges[t].empty())return!0;return!1},ks.prototype.contains=function(e,t){var r=this;t||(t=e);for(var n=0;n<this.ranges.length;n++){var i=r.ranges[n];if(P(t,i.from())>=0&&P(e,i.to())<=0)return n}return-1};var Ts=function(e,t){this.anchor=e,this.head=t};Ts.prototype.from=function(){return B(this.anchor,this.head)},Ts.prototype.to=function(){return R(this.anchor,this.head)},Ts.prototype.empty=function(){return this.head.line==this.anchor.line&&this.head.ch==this.anchor.ch},Bi.prototype={chunkSize:function(){return this.lines.length},removeInner:function(e,t){for(var r=this,n=e,i=e+t;n<i;++n){var o=r.lines[n];r.height-=o.height,ot(o),bt(o,"delete")}this.lines.splice(e,t)},collapse:function(e){e.push.apply(e,this.lines)},insertInner:function(e,t,r){var n=this;this.height+=r,this.lines=this.lines.slice(0,e).concat(t).concat(this.lines.slice(e));for(var i=0;i<t.length;++i)t[i].parent=n},iterN:function(e,t,r){for(var n=this,i=e+t;e<i;++e)if(r(n.lines[e]))return!0}},Gi.prototype={chunkSize:function(){return this.size},removeInner:function(e,t){var r=this;this.size-=t;for(var n=0;n<this.children.length;++n){var i=r.children[n],o=i.chunkSize();if(e<o){var l=Math.min(t,o-e),s=i.height;if(i.removeInner(e,l),r.height-=s-i.height,o==l&&(r.children.splice(n--,1),i.parent=null),0==(t-=l))break;e=0}else e-=o}if(this.size-t<25&&(this.children.length>1||!(this.children[0]instanceof Bi))){var a=[];this.collapse(a),this.children=[new Bi(a)],this.children[0].parent=this}},collapse:function(e){for(var t=this,r=0;r<this.children.length;++r)t.children[r].collapse(e)},insertInner:function(e,t,r){var n=this;this.size+=t.length,this.height+=r;for(var i=0;i<this.children.length;++i){var o=n.children[i],l=o.chunkSize();if(e<=l){if(o.insertInner(e,t,r),o.lines&&o.lines.length>50){for(var s=o.lines.length%25+25,a=s;a<o.lines.length;){var u=new Bi(o.lines.slice(a,a+=25));o.height-=u.height,n.children.splice(++i,0,u),u.parent=n}o.lines=o.lines.slice(0,s),n.maybeSpill()}break}e-=l}},maybeSpill:function(){if(!(this.children.length<=10)){var e=this;do{var t=new Gi(e.children.splice(e.children.length-5,5));if(e.parent){e.size-=t.size,e.height-=t.height;var r=h(e.parent.children,e);e.parent.children.splice(r+1,0,t)}else{var n=new Gi(e.children);n.parent=e,e.children=[n,t],e=n}t.parent=e.parent}while(e.children.length>10);e.parent.maybeSpill()}},iterN:function(e,t,r){for(var n=this,i=0;i<this.children.length;++i){var o=n.children[i],l=o.chunkSize();if(e<l){var s=Math.min(t,l-e);if(o.iterN(e,s,r))return!0;if(0==(t-=s))break;e=0}else e-=l}}};var Ms=function(e,t,r){var n=this;if(r)for(var i in r)r.hasOwnProperty(i)&&(n[i]=r[i]);this.doc=e,this.node=t};Ms.prototype.clear=function(){var e=this,t=this.doc.cm,r=this.line.widgets,n=this.line,i=W(n);if(null!=i&&r){for(var o=0;o<r.length;++o)r[o]==e&&r.splice(o--,1);r.length||(n.widgets=null);var l=Ht(this);A(n,Math.max(0,n.height-l)),t&&(hn(t,function(){Ui(t,n,-l),mn(t,i,"widget")}),bt(t,"lineWidgetCleared",t,this,i))}},Ms.prototype.changed=function(){var e=this,t=this.height,r=this.doc.cm,n=this.line;this.height=null;var i=Ht(this)-t;i&&(A(n,n.height+i),r&&hn(r,function(){r.curOp.forceUpdate=!0,Ui(r,n,i),bt(r,"lineWidgetChanged",r,e,W(n))}))},Ae(Ms);var Ns=0,Os=function(e,t){this.lines=[],this.type=t,this.doc=e,this.id=++Ns};Os.prototype.clear=function(){var e=this;if(!this.explicitlyCleared){var t=this.doc.cm,r=t&&!t.curOp;if(r&&nn(t),Oe(this,"clear")){var n=this.find();n&&bt(this,"clear",n.from,n.to)}for(var i=null,o=null,l=0;l<this.lines.length;++l){var s=e.lines[l],a=_(s.markedSpans,e);t&&!e.collapsed?mn(t,W(s),"text"):t&&(null!=a.to&&(o=W(s)),null!=a.from&&(i=W(s))),s.markedSpans=$(s.markedSpans,a),null==a.from&&e.collapsed&&!ve(e.doc,s)&&t&&A(s,mr(t.display))}if(t&&this.collapsed&&!t.options.lineWrapping)for(var u=0;u<this.lines.length;++u){var c=fe(e.lines[u]),f=be(c);f>t.display.maxLineLength&&(t.display.maxLine=c,t.display.maxLineLength=f,t.display.maxLineChanged=!0)}null!=i&&t&&this.collapsed&&vn(t,i,o+1),this.lines.length=0,this.explicitlyCleared=!0,this.atomic&&this.doc.cantEdit&&(this.doc.cantEdit=!1,t&&Ci(t.doc)),t&&bt(t,"markerCleared",t,this,i,o),r&&on(t),this.parent&&this.parent.clear()}},Os.prototype.find=function(e,t){var r=this;null==e&&"bookmark"==this.type&&(e=1);for(var n,i,o=0;o<this.lines.length;++o){var l=r.lines[o],s=_(l.markedSpans,r);if(null!=s.from&&(n=E(t?l:W(l),s.from),-1==e))return n;if(null!=s.to&&(i=E(t?l:W(l),s.to),1==e))return i}return n&&{from:n,to:i}},Os.prototype.changed=function(){var e=this,t=this.find(-1,!0),r=this,n=this.doc.cm;t&&n&&hn(n,function(){var i=t.line,o=W(t.line),l=jt(n,o);if(l&&(Qt(l),n.curOp.selectionChanged=n.curOp.forceUpdate=!0),n.curOp.updateMaxLine=!0,!ve(r.doc,i)&&null!=r.height){var s=r.height;r.height=null;var a=Ht(r)-s;a&&A(i,i.height+a)}bt(n,"markerChanged",n,e)})},Os.prototype.attachLine=function(e){if(!this.lines.length&&this.doc.cm){var t=this.doc.cm.curOp;t.maybeHiddenMarkers&&-1!=h(t.maybeHiddenMarkers,this)||(t.maybeUnhiddenMarkers||(t.maybeUnhiddenMarkers=[])).push(this)}this.lines.push(e)},Os.prototype.detachLine=function(e){if(this.lines.splice(h(this.lines,e),1),!this.lines.length&&this.doc.cm){var t=this.doc.cm.curOp;(t.maybeHiddenMarkers||(t.maybeHiddenMarkers=[])).push(this)}},Ae(Os);var As=function(e,t){var r=this;this.markers=e,this.primary=t;for(var n=0;n<e.length;++n)e[n].parent=r};As.prototype.clear=function(){var e=this;if(!this.explicitlyCleared){this.explicitlyCleared=!0;for(var t=0;t<this.markers.length;++t)e.markers[t].clear();bt(this,"clear")}},As.prototype.find=function(e,t){return this.primary.find(e,t)},Ae(As);var Ws=0,Ds=function(e,t,r,n,i){if(!(this instanceof Ds))return new Ds(e,t,r,n,i);null==r&&(r=0),Gi.call(this,[new Bi([new fs("",null)])]),this.first=r,this.scrollTop=this.scrollLeft=0,this.cantEdit=!1,this.cleanGeneration=1,this.modeFrontier=this.highlightFrontier=r;var o=E(r,0);this.sel=Rn(o),this.history=new Jn(null),this.id=++Ws,this.modeOption=t,this.lineSep=n,this.direction="rtl"==i?"rtl":"ltr",this.extend=!1,"string"==typeof e&&(e=this.splitLines(e)),_n(this,{from:o,to:o,text:e}),bi(this,Rn(o),Gl)};Ds.prototype=b(Gi.prototype,{constructor:Ds,iter:function(e,t,r){r?this.iterN(e-this.first,t-e,r):this.iterN(this.first,this.first+this.size,e)},insert:function(e,t){for(var r=0,n=0;n<t.length;++n)r+=t[n].height;this.insertInner(e-this.first,t,r)},remove:function(e,t){this.removeInner(e-this.first,t)},getValue:function(e){var t=O(this,this.first,this.first+this.size);return!1===e?t:t.join(e||this.lineSeparator())},setValue:gn(function(e){var t=E(this.first,0),r=this.first+this.size-1;Oi(this,{from:t,to:E(r,M(this,r).text.length),text:this.splitLines(e),origin:"setValue",full:!0},!0),this.cm&&Xr(this.cm,0,0),bi(this,Rn(t),Gl)}),replaceRange:function(e,t,r,n){Ei(this,e,t=U(this,t),r=r?U(this,r):t,n)},getRange:function(e,t,r){var n=N(this,U(this,e),U(this,t));return!1===r?n:n.join(r||this.lineSeparator())},getLine:function(e){var t=this.getLineHandle(e);return t&&t.text},getLineHandle:function(e){if(H(this,e))return M(this,e)},getLineNumber:function(e){return W(e)},getLineHandleVisualStart:function(e){return"number"==typeof e&&(e=M(this,e)),fe(e)},lineCount:function(){return this.size},firstLine:function(){return this.first},lastLine:function(){return this.first+this.size-1},clipPos:function(e){return U(this,e)},getCursor:function(e){var t=this.sel.primary();return null==e||"head"==e?t.head:"anchor"==e?t.anchor:"end"==e||"to"==e||!1===e?t.to():t.from()},listSelections:function(){return this.sel.ranges},somethingSelected:function(){return this.sel.somethingSelected()},setCursor:gn(function(e,t,r){vi(this,U(this,"number"==typeof e?E(e,t||0):e),null,r)}),setSelection:gn(function(e,t,r){vi(this,U(this,e),U(this,t||e),r)}),extendSelection:gn(function(e,t,r){di(this,U(this,e),t&&U(this,t),r)}),extendSelections:gn(function(e,t){pi(this,K(this,e),t)}),extendSelectionsBy:gn(function(e,t){pi(this,K(this,v(this.sel.ranges,e)),t)}),setSelections:gn(function(e,t,r){var n=this;if(e.length){for(var i=[],o=0;o<e.length;o++)i[o]=new Ts(U(n,e[o].anchor),U(n,e[o].head));null==t&&(t=Math.min(e.length-1,this.sel.primIndex)),bi(this,zn(i,t),r)}}),addSelection:gn(function(e,t,r){var n=this.sel.ranges.slice(0);n.push(new Ts(U(this,e),U(this,t||e))),bi(this,zn(n,n.length-1),r)}),getSelection:function(e){for(var t,r=this,n=this.sel.ranges,i=0;i<n.length;i++){var o=N(r,n[i].from(),n[i].to());t=t?t.concat(o):o}return!1===e?t:t.join(e||this.lineSeparator())},getSelections:function(e){for(var t=this,r=[],n=this.sel.ranges,i=0;i<n.length;i++){var o=N(t,n[i].from(),n[i].to());!1!==e&&(o=o.join(e||t.lineSeparator())),r[i]=o}return r},replaceSelection:function(e,t,r){for(var n=[],i=0;i<this.sel.ranges.length;i++)n[i]=e;this.replaceSelections(n,t,r||"+input")},replaceSelections:gn(function(e,t,r){for(var n=this,i=[],o=this.sel,l=0;l<o.ranges.length;l++){var s=o.ranges[l];i[l]={from:s.from(),to:s.to(),text:n.splitLines(e[l]),origin:r}}for(var a=t&&"end"!=t&&Kn(this,i,t),u=i.length-1;u>=0;u--)Oi(n,i[u]);a?yi(this,a):this.cm&&jr(this.cm)}),undo:gn(function(){Wi(this,"undo")}),redo:gn(function(){Wi(this,"redo")}),undoSelection:gn(function(){Wi(this,"undo",!0)}),redoSelection:gn(function(){Wi(this,"redo",!0)}),setExtending:function(e){this.extend=e},getExtending:function(){return this.extend},historySize:function(){for(var e=this.history,t=0,r=0,n=0;n<e.done.length;n++)e.done[n].ranges||++t;for(var i=0;i<e.undone.length;i++)e.undone[i].ranges||++r;return{undo:t,redo:r}},clearHistory:function(){this.history=new Jn(this.history.maxGeneration)},markClean:function(){this.cleanGeneration=this.changeGeneration(!0)},changeGeneration:function(e){return e&&(this.history.lastOp=this.history.lastSelOp=this.history.lastOrigin=null),this.history.generation},isClean:function(e){return this.history.generation==(e||this.cleanGeneration)},getHistory:function(){return{done:fi(this.history.done),undone:fi(this.history.undone)}},setHistory:function(e){var t=this.history=new Jn(this.history.maxGeneration);t.done=fi(e.done.slice(0),null,!0),t.undone=fi(e.undone.slice(0),null,!0)},setGutterMarker:gn(function(e,t,r){return Ri(this,e,"gutter",function(e){var n=e.gutterMarkers||(e.gutterMarkers={});return n[t]=r,!r&&C(n)&&(e.gutterMarkers=null),!0})}),clearGutter:gn(function(e){var t=this;this.iter(function(r){r.gutterMarkers&&r.gutterMarkers[e]&&Ri(t,r,"gutter",function(){return r.gutterMarkers[e]=null,C(r.gutterMarkers)&&(r.gutterMarkers=null),!0})})}),lineInfo:function(e){var t;if("number"==typeof e){if(!H(this,e))return null;if(t=e,!(e=M(this,e)))return null}else if(null==(t=W(e)))return null;return{line:t,handle:e,text:e.text,gutterMarkers:e.gutterMarkers,textClass:e.textClass,bgClass:e.bgClass,wrapClass:e.wrapClass,widgets:e.widgets}},addLineClass:gn(function(t,r,n){return Ri(this,t,"gutter"==r?"gutter":"class",function(t){var i="text"==r?"textClass":"background"==r?"bgClass":"gutter"==r?"gutterClass":"wrapClass";if(t[i]){if(e(n).test(t[i]))return!1;t[i]+=" "+n}else t[i]=n;return!0})}),removeLineClass:gn(function(t,r,n){return Ri(this,t,"gutter"==r?"gutter":"class",function(t){var i="text"==r?"textClass":"background"==r?"bgClass":"gutter"==r?"gutterClass":"wrapClass",o=t[i];if(!o)return!1;if(null==n)t[i]=null;else{var l=o.match(e(n));if(!l)return!1;var s=l.index+l[0].length;t[i]=o.slice(0,l.index)+(l.index&&s!=o.length?" ":"")+o.slice(s)||null}return!0})}),addLineWidget:gn(function(e,t,r){return Vi(this,e,t,r)}),removeLineWidget:function(e){e.clear()},markText:function(e,t,r){return Ki(this,U(this,e),U(this,t),r,r&&r.type||"range")},setBookmark:function(e,t){var r={replacedWith:t&&(null==t.nodeType?t.widget:t),insertLeft:t&&t.insertLeft,clearWhenEmpty:!1,shared:t&&t.shared,handleMouseEvents:t&&t.handleMouseEvents};return e=U(this,e),Ki(this,e,e,r,"bookmark")},findMarksAt:function(e){var t=[],r=M(this,(e=U(this,e)).line).markedSpans;if(r)for(var n=0;n<r.length;++n){var i=r[n];(null==i.from||i.from<=e.ch)&&(null==i.to||i.to>=e.ch)&&t.push(i.marker.parent||i.marker)}return t},findMarks:function(e,t,r){e=U(this,e),t=U(this,t);var n=[],i=e.line;return this.iter(e.line,t.line+1,function(o){var l=o.markedSpans;if(l)for(var s=0;s<l.length;s++){var a=l[s];null!=a.to&&i==e.line&&e.ch>=a.to||null==a.from&&i!=e.line||null!=a.from&&i==t.line&&a.from>=t.ch||r&&!r(a.marker)||n.push(a.marker.parent||a.marker)}++i}),n},getAllMarks:function(){var e=[];return this.iter(function(t){var r=t.markedSpans;if(r)for(var n=0;n<r.length;++n)null!=r[n].from&&e.push(r[n].marker)}),e},posFromIndex:function(e){var t,r=this.first,n=this.lineSeparator().length;return this.iter(function(i){var o=i.text.length+n;if(o>e)return t=e,!0;e-=o,++r}),U(this,E(r,t))},indexFromPos:function(e){var t=(e=U(this,e)).ch;if(e.line<this.first||e.ch<0)return 0;var r=this.lineSeparator().length;return this.iter(this.first,e.line,function(e){t+=e.text.length+r}),t},copy:function(e){var t=new Ds(O(this,this.first,this.first+this.size),this.modeOption,this.first,this.lineSep,this.direction);return t.scrollTop=this.scrollTop,t.scrollLeft=this.scrollLeft,t.sel=this.sel,t.extend=!1,e&&(t.history.undoDepth=this.history.undoDepth,t.setHistory(this.getHistory())),t},linkedDoc:function(e){e||(e={});var t=this.first,r=this.first+this.size;null!=e.from&&e.from>t&&(t=e.from),null!=e.to&&e.to<r&&(r=e.to);var n=new Ds(O(this,t,r),e.mode||this.modeOption,t,this.lineSep,this.direction);return e.sharedHist&&(n.history=this.history),(this.linked||(this.linked=[])).push({doc:n,sharedHist:e.sharedHist}),n.linked=[{doc:this,isParent:!0,sharedHist:e.sharedHist}],Yi(n,Xi(this)),n},unlinkDoc:function(e){var t=this;if(e instanceof jo&&(e=e.doc),this.linked)for(var r=0;r<this.linked.length;++r)if(t.linked[r].doc==e){t.linked.splice(r,1),e.unlinkDoc(t),_i(Xi(t));break}if(e.history==this.history){var n=[e.id];$n(e,function(e){return n.push(e.id)},!0),e.history=new Jn(null),e.history.done=fi(this.history.done,n),e.history.undone=fi(this.history.undone,n)}},iterLinkedDocs:function(e){$n(this,e)},getMode:function(){return this.mode},getEditor:function(){return this.cm},splitLines:function(e){return this.lineSep?e.split(this.lineSep):es(e)},lineSeparator:function(){return this.lineSep||"\n"},setDirection:gn(function(e){"rtl"!=e&&(e="ltr"),e!=this.direction&&(this.direction=e,this.iter(function(e){return e.order=null}),this.cm&&Qn(this.cm))})}),Ds.prototype.eachLine=Ds.prototype.iter;for(var Hs=0,Fs=!1,Es={3:"Enter",8:"Backspace",9:"Tab",13:"Enter",16:"Shift",17:"Ctrl",18:"Alt",19:"Pause",20:"CapsLock",27:"Esc",32:"Space",33:"PageUp",34:"PageDown",35:"End",36:"Home",37:"Left",38:"Up",39:"Right",40:"Down",44:"PrintScrn",45:"Insert",46:"Delete",59:";",61:"=",91:"Mod",92:"Mod",93:"Mod",106:"*",107:"=",109:"-",110:".",111:"/",127:"Delete",173:"-",186:";",187:"=",188:",",189:"-",190:".",191:"/",192:"`",219:"[",220:"\\",221:"]",222:"'",63232:"Up",63233:"Down",63234:"Left",63235:"Right",63272:"Delete",63273:"Home",63275:"End",63276:"PageUp",63277:"PageDown",63302:"Insert"},Ps=0;Ps<10;Ps++)Es[Ps+48]=Es[Ps+96]=String(Ps);for(var Is=65;Is<=90;Is++)Es[Is]=String.fromCharCode(Is);for(var zs=1;zs<=12;zs++)Es[zs+111]=Es[zs+63235]="F"+zs;var Rs={};Rs.basic={Left:"goCharLeft",Right:"goCharRight",Up:"goLineUp",Down:"goLineDown",End:"goLineEnd",Home:"goLineStartSmart",PageUp:"goPageUp",PageDown:"goPageDown",Delete:"delCharAfter",Backspace:"delCharBefore","Shift-Backspace":"delCharBefore",Tab:"defaultTab","Shift-Tab":"indentAuto",Enter:"newlineAndIndent",Insert:"toggleOverwrite",Esc:"singleSelection"},Rs.pcDefault={"Ctrl-A":"selectAll","Ctrl-D":"deleteLine","Ctrl-Z":"undo","Shift-Ctrl-Z":"redo","Ctrl-Y":"redo","Ctrl-Home":"goDocStart","Ctrl-End":"goDocEnd","Ctrl-Up":"goLineUp","Ctrl-Down":"goLineDown","Ctrl-Left":"goGroupLeft","Ctrl-Right":"goGroupRight","Alt-Left":"goLineStart","Alt-Right":"goLineEnd","Ctrl-Backspace":"delGroupBefore","Ctrl-Delete":"delGroupAfter","Ctrl-S":"save","Ctrl-F":"find","Ctrl-G":"findNext","Shift-Ctrl-G":"findPrev","Shift-Ctrl-F":"replace","Shift-Ctrl-R":"replaceAll","Ctrl-[":"indentLess","Ctrl-]":"indentMore","Ctrl-U":"undoSelection","Shift-Ctrl-U":"redoSelection","Alt-U":"redoSelection",fallthrough:"basic"},Rs.emacsy={"Ctrl-F":"goCharRight","Ctrl-B":"goCharLeft","Ctrl-P":"goLineUp","Ctrl-N":"goLineDown","Alt-F":"goWordRight","Alt-B":"goWordLeft","Ctrl-A":"goLineStart","Ctrl-E":"goLineEnd","Ctrl-V":"goPageDown","Shift-Ctrl-V":"goPageUp","Ctrl-D":"delCharAfter","Ctrl-H":"delCharBefore","Alt-D":"delWordAfter","Alt-Backspace":"delWordBefore","Ctrl-K":"killLine","Ctrl-T":"transposeChars","Ctrl-O":"openLine"},Rs.macDefault={"Cmd-A":"selectAll","Cmd-D":"deleteLine","Cmd-Z":"undo","Shift-Cmd-Z":"redo","Cmd-Y":"redo","Cmd-Home":"goDocStart","Cmd-Up":"goDocStart","Cmd-End":"goDocEnd","Cmd-Down":"goDocEnd","Alt-Left":"goGroupLeft","Alt-Right":"goGroupRight","Cmd-Left":"goLineLeft","Cmd-Right":"goLineRight","Alt-Backspace":"delGroupBefore","Ctrl-Alt-Backspace":"delGroupAfter","Alt-Delete":"delGroupAfter","Cmd-S":"save","Cmd-F":"find","Cmd-G":"findNext","Shift-Cmd-G":"findPrev","Cmd-Alt-F":"replace","Shift-Cmd-Alt-F":"replaceAll","Cmd-[":"indentLess","Cmd-]":"indentMore","Cmd-Backspace":"delWrappedLineLeft","Cmd-Delete":"delWrappedLineRight","Cmd-U":"undoSelection","Shift-Cmd-U":"redoSelection","Ctrl-Up":"goDocStart","Ctrl-Down":"goDocEnd",fallthrough:["basic","emacsy"]},Rs.default=Ml?Rs.macDefault:Rs.pcDefault;var Bs={selectAll:Mi,singleSelection:function(e){return e.setSelection(e.getCursor("anchor"),e.getCursor("head"),Gl)},killLine:function(e){return co(e,function(t){if(t.empty()){var r=M(e.doc,t.head.line).text.length;return t.head.ch==r&&t.head.line<e.lastLine()?{from:t.head,to:E(t.head.line+1,0)}:{from:t.head,to:E(t.head.line,r)}}return{from:t.from(),to:t.to()}})},deleteLine:function(e){return co(e,function(t){return{from:E(t.from().line,0),to:U(e.doc,E(t.to().line+1,0))}})},delLineLeft:function(e){return co(e,function(e){return{from:E(e.from().line,0),to:e.from()}})},delWrappedLineLeft:function(e){return co(e,function(t){var r=e.charCoords(t.head,"div").top+5;return{from:e.coordsChar({left:0,top:r},"div"),to:t.from()}})},delWrappedLineRight:function(e){return co(e,function(t){var r=e.charCoords(t.head,"div").top+5,n=e.coordsChar({left:e.display.lineDiv.offsetWidth+100,top:r},"div");return{from:t.from(),to:n}})},undo:function(e){return e.undo()},redo:function(e){return e.redo()},undoSelection:function(e){return e.undoSelection()},redoSelection:function(e){return e.redoSelection()},goDocStart:function(e){return e.extendSelection(E(e.firstLine(),0))},goDocEnd:function(e){return e.extendSelection(E(e.lastLine()))},goLineStart:function(e){return e.extendSelectionsBy(function(t){return vo(e,t.head.line)},{origin:"+move",bias:1})},goLineStartSmart:function(e){return e.extendSelectionsBy(function(t){return yo(e,t.head)},{origin:"+move",bias:1})},goLineEnd:function(e){return e.extendSelectionsBy(function(t){return mo(e,t.head.line)},{origin:"+move",bias:-1})},goLineRight:function(e){return e.extendSelectionsBy(function(t){var r=e.cursorCoords(t.head,"div").top+5;return e.coordsChar({left:e.display.lineDiv.offsetWidth+100,top:r},"div")},Vl)},goLineLeft:function(e){return e.extendSelectionsBy(function(t){var r=e.cursorCoords(t.head,"div").top+5;return e.coordsChar({left:0,top:r},"div")},Vl)},goLineLeftSmart:function(e){return e.extendSelectionsBy(function(t){var r=e.cursorCoords(t.head,"div").top+5,n=e.coordsChar({left:0,top:r},"div");return n.ch<e.getLine(n.line).search(/\S/)?yo(e,t.head):n},Vl)},goLineUp:function(e){return e.moveV(-1,"line")},goLineDown:function(e){return e.moveV(1,"line")},goPageUp:function(e){return e.moveV(-1,"page")},goPageDown:function(e){return e.moveV(1,"page")},goCharLeft:function(e){return e.moveH(-1,"char")},goCharRight:function(e){return e.moveH(1,"char")},goColumnLeft:function(e){return e.moveH(-1,"column")},goColumnRight:function(e){return e.moveH(1,"column")},goWordLeft:function(e){return e.moveH(-1,"word")},goGroupRight:function(e){return e.moveH(1,"group")},goGroupLeft:function(e){return e.moveH(-1,"group")},goWordRight:function(e){return e.moveH(1,"word")},delCharBefore:function(e){return e.deleteH(-1,"char")},delCharAfter:function(e){return e.deleteH(1,"char")},delWordBefore:function(e){return e.deleteH(-1,"word")},delWordAfter:function(e){return e.deleteH(1,"word")},delGroupBefore:function(e){return e.deleteH(-1,"group")},delGroupAfter:function(e){return e.deleteH(1,"group")},indentAuto:function(e){return e.indentSelection("smart")},indentMore:function(e){return e.indentSelection("add")},indentLess:function(e){return e.indentSelection("subtract")},insertTab:function(e){return e.replaceSelection("\t")},insertSoftTab:function(e){for(var t=[],r=e.listSelections(),n=e.options.tabSize,i=0;i<r.length;i++){var o=r[i].from(),l=f(e.getLine(o.line),o.ch,n);t.push(p(n-l%n))}e.replaceSelections(t)},defaultTab:function(e){e.somethingSelected()?e.indentSelection("add"):e.execCommand("insertTab")},transposeChars:function(e){return hn(e,function(){for(var t=e.listSelections(),r=[],n=0;n<t.length;n++)if(t[n].empty()){var i=t[n].head,o=M(e.doc,i.line).text;if(o)if(i.ch==o.length&&(i=new E(i.line,i.ch-1)),i.ch>0)i=new E(i.line,i.ch+1),e.replaceRange(o.charAt(i.ch-1)+o.charAt(i.ch-2),E(i.line,i.ch-2),i,"+transpose");else if(i.line>e.doc.first){var l=M(e.doc,i.line-1).text;l&&(i=new E(i.line,1),e.replaceRange(o.charAt(0)+e.doc.lineSeparator()+l.charAt(l.length-1),E(i.line-1,l.length-1),i,"+transpose"))}r.push(new Ts(i,i))}e.setSelections(r)})},newlineAndIndent:function(e){return hn(e,function(){for(var t=e.listSelections(),r=t.length-1;r>=0;r--)e.replaceRange(e.doc.lineSeparator(),t[r].anchor,t[r].head,"+input");t=e.listSelections();for(var n=0;n<t.length;n++)e.indentLine(t[n].from().line,null,!0);jr(e)})},openLine:function(e){return e.replaceSelection("\n","start")},toggleOverwrite:function(e){return e.toggleOverwrite()}},Gs=new Pl,Us=null,Vs=function(e,t,r){this.time=e,this.pos=t,this.button=r};Vs.prototype.compare=function(e,t,r){return this.time+400>e&&0==P(t,this.pos)&&r==this.button};var Ks,js,Xs={toString:function(){return"CodeMirror.Init"}},Ys={},_s={};jo.defaults=Ys,jo.optionHandlers=_s;var $s=[];jo.defineInitHook=function(e){return $s.push(e)};var qs=null,Zs=function(e){this.cm=e,this.lastAnchorNode=this.lastAnchorOffset=this.lastFocusNode=this.lastFocusOffset=null,this.polling=new Pl,this.composing=null,this.gracePeriod=!1,this.readDOMTimeout=null};Zs.prototype.init=function(e){function t(e){if(!Me(i,e)){if(i.somethingSelected())_o({lineWise:!1,text:i.getSelections()}),"cut"==e.type&&i.replaceSelection("",null,"cut");else{if(!i.options.lineWiseCopyCut)return;var t=Qo(i);_o({lineWise:!0,text:t.text}),"cut"==e.type&&i.operation(function(){i.setSelections(t.ranges,0,Gl),i.replaceSelection("",null,"cut")})}if(e.clipboardData){e.clipboardData.clearData();var r=qs.text.join("\n");if(e.clipboardData.setData("Text",r),e.clipboardData.getData("Text")==r)return void e.preventDefault()}var l=el(),s=l.firstChild;i.display.lineSpace.insertBefore(l,i.display.lineSpace.firstChild),s.value=qs.text.join("\n");var a=document.activeElement;El(s),setTimeout(function(){i.display.lineSpace.removeChild(l),a.focus(),a==o&&n.showPrimarySelection()},50)}}var r=this,n=this,i=n.cm,o=n.div=e.lineDiv;Jo(o,i.options.spellcheck),Ql(o,"paste",function(e){Me(i,e)||qo(e,i)||vl<=11&&setTimeout(dn(i,function(){return r.updateFromDOM()}),20)}),Ql(o,"compositionstart",function(e){r.composing={data:e.data,done:!1}}),Ql(o,"compositionupdate",function(e){r.composing||(r.composing={data:e.data,done:!1})}),Ql(o,"compositionend",function(e){r.composing&&(e.data!=r.composing.data&&r.readFromDOMSoon(),r.composing.done=!0)}),Ql(o,"touchstart",function(){return n.forceCompositionEnd()}),Ql(o,"input",function(){r.composing||r.readFromDOMSoon()}),Ql(o,"copy",t),Ql(o,"cut",t)},Zs.prototype.prepareSelection=function(){var e=Tr(this.cm,!1);return e.focus=this.cm.state.focused,e},Zs.prototype.showSelection=function(e,t){e&&this.cm.display.view.length&&((e.focus||t)&&this.showPrimarySelection(),this.showMultipleSelections(e))},Zs.prototype.showPrimarySelection=function(){var e=window.getSelection(),t=this.cm,r=t.doc.sel.primary(),n=r.from(),i=r.to();if(t.display.viewTo==t.display.viewFrom||n.line>=t.display.viewTo||i.line<t.display.viewFrom)e.removeAllRanges();else{var o=sl(t,e.anchorNode,e.anchorOffset),l=sl(t,e.focusNode,e.focusOffset);if(!o||o.bad||!l||l.bad||0!=P(B(o,l),n)||0!=P(R(o,l),i)){var s=t.display.view,a=n.line>=t.display.viewFrom&&nl(t,n)||{node:s[0].measure.map[2],offset:0},u=i.line<t.display.viewTo&&nl(t,i);if(!u){var c=s[s.length-1].measure,f=c.maps?c.maps[c.maps.length-1]:c.map;u={node:f[f.length-1],offset:f[f.length-2]-f[f.length-3]}}if(a&&u){var h,d=e.rangeCount&&e.getRangeAt(0);try{h=Wl(a.node,a.offset,u.offset,u.node)}catch(e){}h&&(!fl&&t.state.focused?(e.collapse(a.node,a.offset),h.collapsed||(e.removeAllRanges(),e.addRange(h))):(e.removeAllRanges(),e.addRange(h)),d&&null==e.anchorNode?e.addRange(d):fl&&this.startGracePeriod()),this.rememberSelection()}else e.removeAllRanges()}}},Zs.prototype.startGracePeriod=function(){var e=this;clearTimeout(this.gracePeriod),this.gracePeriod=setTimeout(function(){e.gracePeriod=!1,e.selectionChanged()&&e.cm.operation(function(){return e.cm.curOp.selectionChanged=!0})},20)},Zs.prototype.showMultipleSelections=function(e){r(this.cm.display.cursorDiv,e.cursors),r(this.cm.display.selectionDiv,e.selection)},Zs.prototype.rememberSelection=function(){var e=window.getSelection();this.lastAnchorNode=e.anchorNode,this.lastAnchorOffset=e.anchorOffset,this.lastFocusNode=e.focusNode,this.lastFocusOffset=e.focusOffset},Zs.prototype.selectionInEditor=function(){var e=window.getSelection();if(!e.rangeCount)return!1;var t=e.getRangeAt(0).commonAncestorContainer;return o(this.div,t)},Zs.prototype.focus=function(){"nocursor"!=this.cm.options.readOnly&&(this.selectionInEditor()||this.showSelection(this.prepareSelection(),!0),this.div.focus())},Zs.prototype.blur=function(){this.div.blur()},Zs.prototype.getField=function(){return this.div},Zs.prototype.supportsTouch=function(){return!0},Zs.prototype.receivedFocus=function(){function e(){t.cm.state.focused&&(t.pollSelection(),t.polling.set(t.cm.options.pollInterval,e))}var t=this;this.selectionInEditor()?this.pollSelection():hn(this.cm,function(){return t.cm.curOp.selectionChanged=!0}),this.polling.set(this.cm.options.pollInterval,e)},Zs.prototype.selectionChanged=function(){var e=window.getSelection();return e.anchorNode!=this.lastAnchorNode||e.anchorOffset!=this.lastAnchorOffset||e.focusNode!=this.lastFocusNode||e.focusOffset!=this.lastFocusOffset},Zs.prototype.pollSelection=function(){if(null==this.readDOMTimeout&&!this.gracePeriod&&this.selectionChanged()){var e=window.getSelection(),t=this.cm;if(kl&&bl&&this.cm.options.gutters.length&&il(e.anchorNode))return this.cm.triggerOnKeyDown({type:"keydown",keyCode:8,preventDefault:Math.abs}),this.blur(),void this.focus();if(!this.composing){this.rememberSelection();var r=sl(t,e.anchorNode,e.anchorOffset),n=sl(t,e.focusNode,e.focusOffset);r&&n&&hn(t,function(){bi(t.doc,Rn(r,n),Gl),(r.bad||n.bad)&&(t.curOp.selectionChanged=!0)})}}},Zs.prototype.pollContent=function(){null!=this.readDOMTimeout&&(clearTimeout(this.readDOMTimeout),this.readDOMTimeout=null);var e=this.cm,t=e.display,r=e.doc.sel.primary(),n=r.from(),i=r.to();if(0==n.ch&&n.line>e.firstLine()&&(n=E(n.line-1,M(e.doc,n.line-1).length)),i.ch==M(e.doc,i.line).text.length&&i.line<e.lastLine()&&(i=E(i.line+1,0)),n.line<t.viewFrom||i.line>t.viewTo-1)return!1;var o,l,s;n.line==t.viewFrom||0==(o=Lr(e,n.line))?(l=W(t.view[0].line),s=t.view[0].node):(l=W(t.view[o].line),s=t.view[o-1].node.nextSibling);var a,u,c=Lr(e,i.line);if(c==t.view.length-1?(a=t.viewTo-1,u=t.lineDiv.lastChild):(a=W(t.view[c+1].line)-1,u=t.view[c+1].node.previousSibling),!s)return!1;for(var f=e.doc.splitLines(ll(e,s,u,l,a)),h=N(e.doc,E(l,0),E(a,M(e.doc,a).text.length));f.length>1&&h.length>1;)if(g(f)==g(h))f.pop(),h.pop(),a--;else{if(f[0]!=h[0])break;f.shift(),h.shift(),l++}for(var d=0,p=0,v=f[0],m=h[0],y=Math.min(v.length,m.length);d<y&&v.charCodeAt(d)==m.charCodeAt(d);)++d;for(var b=g(f),w=g(h),x=Math.min(b.length-(1==f.length?d:0),w.length-(1==h.length?d:0));p<x&&b.charCodeAt(b.length-p-1)==w.charCodeAt(w.length-p-1);)++p;if(1==f.length&&1==h.length&&l==n.line)for(;d&&d>n.ch&&b.charCodeAt(b.length-p-1)==w.charCodeAt(w.length-p-1);)d--,p++;f[f.length-1]=b.slice(0,b.length-p).replace(/^\u200b+/,""),f[0]=f[0].slice(d).replace(/\u200b+$/,"");var C=E(l,d),S=E(a,h.length?g(h).length-p:0);return f.length>1||f[0]||P(C,S)?(Ei(e.doc,f,C,S,"+input"),!0):void 0},Zs.prototype.ensurePolled=function(){this.forceCompositionEnd()},Zs.prototype.reset=function(){this.forceCompositionEnd()},Zs.prototype.forceCompositionEnd=function(){this.composing&&(clearTimeout(this.readDOMTimeout),this.composing=null,this.updateFromDOM(),this.div.blur(),this.div.focus())},Zs.prototype.readFromDOMSoon=function(){var e=this;null==this.readDOMTimeout&&(this.readDOMTimeout=setTimeout(function(){if(e.readDOMTimeout=null,e.composing){if(!e.composing.done)return;e.composing=null}e.updateFromDOM()},80))},Zs.prototype.updateFromDOM=function(){var e=this;!this.cm.isReadOnly()&&this.pollContent()||hn(this.cm,function(){return vn(e.cm)})},Zs.prototype.setUneditable=function(e){e.contentEditable="false"},Zs.prototype.onKeyPress=function(e){0!=e.charCode&&(e.preventDefault(),this.cm.isReadOnly()||dn(this.cm,$o)(this.cm,String.fromCharCode(null==e.charCode?e.keyCode:e.charCode),0))},Zs.prototype.readOnlyChanged=function(e){this.div.contentEditable=String("nocursor"!=e)},Zs.prototype.onContextMenu=function(){},Zs.prototype.resetPosition=function(){},Zs.prototype.needsContentAttribute=!0;var Qs=function(e){this.cm=e,this.prevInput="",this.pollingFast=!1,this.polling=new Pl,this.hasSelection=!1,this.composing=null};Qs.prototype.init=function(e){function t(e){if(!Me(i,e)){if(i.somethingSelected())_o({lineWise:!1,text:i.getSelections()});else{if(!i.options.lineWiseCopyCut)return;var t=Qo(i);_o({lineWise:!0,text:t.text}),"cut"==e.type?i.setSelections(t.ranges,null,Gl):(n.prevInput="",l.value=t.text.join("\n"),El(l))}"cut"==e.type&&(i.state.cutIncoming=!0)}}var r=this,n=this,i=this.cm,o=this.wrapper=el(),l=this.textarea=o.firstChild;e.wrapper.insertBefore(o,e.wrapper.firstChild),Ll&&(l.style.width="0px"),Ql(l,"input",function(){gl&&vl>=9&&r.hasSelection&&(r.hasSelection=null),n.poll()}),Ql(l,"paste",function(e){Me(i,e)||qo(e,i)||(i.state.pasteIncoming=!0,n.fastPoll())}),Ql(l,"cut",t),Ql(l,"copy",t),Ql(e.scroller,"paste",function(t){Ft(e,t)||Me(i,t)||(i.state.pasteIncoming=!0,n.focus())}),Ql(e.lineSpace,"selectstart",function(t){Ft(e,t)||We(t)}),Ql(l,"compositionstart",function(){var e=i.getCursor("from");n.composing&&n.composing.range.clear(),n.composing={start:e,range:i.markText(e,i.getCursor("to"),{className:"CodeMirror-composing"})}}),Ql(l,"compositionend",function(){n.composing&&(n.poll(),n.composing.range.clear(),n.composing=null)})},Qs.prototype.prepareSelection=function(){var e=this.cm,t=e.display,r=e.doc,n=Tr(e);if(e.options.moveInputWithCursor){var i=sr(e,r.sel.primary().head,"div"),o=t.wrapper.getBoundingClientRect(),l=t.lineDiv.getBoundingClientRect();n.teTop=Math.max(0,Math.min(t.wrapper.clientHeight-10,i.top+l.top-o.top)),n.teLeft=Math.max(0,Math.min(t.wrapper.clientWidth-10,i.left+l.left-o.left))}return n},Qs.prototype.showSelection=function(e){var t=this.cm.display;r(t.cursorDiv,e.cursors),r(t.selectionDiv,e.selection),null!=e.teTop&&(this.wrapper.style.top=e.teTop+"px",this.wrapper.style.left=e.teLeft+"px")},Qs.prototype.reset=function(e){if(!this.contextMenuPending&&!this.composing){var t=this.cm;if(t.somethingSelected()){this.prevInput="";var r=t.getSelection();this.textarea.value=r,t.state.focused&&El(this.textarea),gl&&vl>=9&&(this.hasSelection=r)}else e||(this.prevInput=this.textarea.value="",gl&&vl>=9&&(this.hasSelection=null))}},Qs.prototype.getField=function(){return this.textarea},Qs.prototype.supportsTouch=function(){return!1},Qs.prototype.focus=function(){if("nocursor"!=this.cm.options.readOnly&&(!Tl||l()!=this.textarea))try{this.textarea.focus()}catch(e){}},Qs.prototype.blur=function(){this.textarea.blur()},Qs.prototype.resetPosition=function(){this.wrapper.style.top=this.wrapper.style.left=0},Qs.prototype.receivedFocus=function(){this.slowPoll()},Qs.prototype.slowPoll=function(){var e=this;this.pollingFast||this.polling.set(this.cm.options.pollInterval,function(){e.poll(),e.cm.state.focused&&e.slowPoll()})},Qs.prototype.fastPoll=function(){function e(){r.poll()||t?(r.pollingFast=!1,r.slowPoll()):(t=!0,r.polling.set(60,e))}var t=!1,r=this;r.pollingFast=!0,r.polling.set(20,e)},Qs.prototype.poll=function(){var e=this,t=this.cm,r=this.textarea,n=this.prevInput;if(this.contextMenuPending||!t.state.focused||ts(r)&&!n&&!this.composing||t.isReadOnly()||t.options.disableInput||t.state.keySeq)return!1;var i=r.value;if(i==n&&!t.somethingSelected())return!1;if(gl&&vl>=9&&this.hasSelection===i||Ml&&/[\uf700-\uf7ff]/.test(i))return t.display.input.reset(),!1;if(t.doc.sel==t.display.selForContextMenu){var o=i.charCodeAt(0);if(8203!=o||n||(n="​"),8666==o)return this.reset(),this.cm.execCommand("undo")}for(var l=0,s=Math.min(n.length,i.length);l<s&&n.charCodeAt(l)==i.charCodeAt(l);)++l;return hn(t,function(){$o(t,i.slice(l),n.length-l,null,e.composing?"*compose":null),i.length>1e3||i.indexOf("\n")>-1?r.value=e.prevInput="":e.prevInput=i,e.composing&&(e.composing.range.clear(),e.composing.range=t.markText(e.composing.start,t.getCursor("to"),{className:"CodeMirror-composing"}))}),!0},Qs.prototype.ensurePolled=function(){this.pollingFast&&this.poll()&&(this.pollingFast=!1)},Qs.prototype.onKeyPress=function(){gl&&vl>=9&&(this.hasSelection=null),this.fastPoll()},Qs.prototype.onContextMenu=function(e){function t(){if(null!=l.selectionStart){var e=i.somethingSelected(),t="​"+(e?l.value:"");l.value="⇚",l.value=t,n.prevInput=e?"":"​",l.selectionStart=1,l.selectionEnd=t.length,o.selForContextMenu=i.doc.sel}}function r(){if(n.contextMenuPending=!1,n.wrapper.style.cssText=c,l.style.cssText=u,gl&&vl<9&&o.scrollbars.setScrollTop(o.scroller.scrollTop=a),null!=l.selectionStart){(!gl||gl&&vl<9)&&t();var e=0,r=function(){o.selForContextMenu==i.doc.sel&&0==l.selectionStart&&l.selectionEnd>0&&"​"==n.prevInput?dn(i,Mi)(i):e++<10?o.detectingSelectAll=setTimeout(r,500):(o.selForContextMenu=null,o.input.reset())};o.detectingSelectAll=setTimeout(r,200)}}var n=this,i=n.cm,o=i.display,l=n.textarea,s=Sr(i,e),a=o.scroller.scrollTop;if(s&&!wl){i.options.resetSelectionOnContextMenu&&-1==i.doc.sel.contains(s)&&dn(i,bi)(i.doc,Rn(s),Gl);var u=l.style.cssText,c=n.wrapper.style.cssText;n.wrapper.style.cssText="position: absolute";var f=n.wrapper.getBoundingClientRect();l.style.cssText="position: absolute; width: 30px; height: 30px;\n      top: "+(e.clientY-f.top-5)+"px; left: "+(e.clientX-f.left-5)+"px;\n      z-index: 1000; background: "+(gl?"rgba(255, 255, 255, .05)":"transparent")+";\n      outline: none; border-width: 0; outline: none; overflow: hidden; opacity: .05; filter: alpha(opacity=5);";var h;if(ml&&(h=window.scrollY),o.input.focus(),ml&&window.scrollTo(null,h),o.input.reset(),i.somethingSelected()||(l.value=n.prevInput=" "),n.contextMenuPending=!0,o.selForContextMenu=i.doc.sel,clearTimeout(o.detectingSelectAll),gl&&vl>=9&&t(),Hl){Fe(e);var d=function(){ke(window,"mouseup",d),setTimeout(r,20)};Ql(window,"mouseup",d)}else setTimeout(r,50)}},Qs.prototype.readOnlyChanged=function(e){e||this.reset(),this.textarea.disabled="nocursor"==e},Qs.prototype.setUneditable=function(){},Qs.prototype.needsContentAttribute=!1,function(e){function t(t,n,i,o){e.defaults[t]=n,i&&(r[t]=o?function(e,t,r){r!=Xs&&i(e,t,r)}:i)}var r=e.optionHandlers;e.defineOption=t,e.Init=Xs,t("value","",function(e,t){return e.setValue(t)},!0),t("mode",null,function(e,t){e.doc.modeOption=t,jn(e)},!0),t("indentUnit",2,jn,!0),t("indentWithTabs",!1),t("smartIndent",!0),t("tabSize",4,function(e){Xn(e),er(e),vn(e)},!0),t("lineSeparator",null,function(e,t){if(e.doc.lineSep=t,t){var r=[],n=e.doc.first;e.doc.iter(function(e){for(var i=0;;){var o=e.text.indexOf(t,i);if(-1==o)break;i=o+t.length,r.push(E(n,o))}n++});for(var i=r.length-1;i>=0;i--)Ei(e.doc,t,r[i],E(r[i].line,r[i].ch+t.length))}}),t("specialChars",/[\u0000-\u001f\u007f-\u009f\u00ad\u061c\u200b-\u200f\u2028\u2029\ufeff]/g,function(e,t,r){e.state.specialChars=new RegExp(t.source+(t.test("\t")?"":"|\t"),"g"),r!=Xs&&e.refresh()}),t("specialCharPlaceholder",at,function(e){return e.refresh()},!0),t("electricChars",!0),t("inputStyle",Tl?"contenteditable":"textarea",function(){throw new Error("inputStyle can not (yet) be changed in a running editor")},!0),t("spellcheck",!1,function(e,t){return e.getInputField().spellcheck=t},!0),t("rtlMoveVisually",!Ol),t("wholeLineUpdateBefore",!0),t("theme","default",function(e){Go(e),Uo(e)},!0),t("keyMap","default",function(e,t,r){var n=uo(t),i=r!=Xs&&uo(r);i&&i.detach&&i.detach(e,n),n.attach&&n.attach(e,i||null)}),t("extraKeys",null),t("configureMouse",null),t("lineWrapping",!1,Ko,!0),t("gutters",[],function(e){Fn(e.options),Uo(e)},!0),t("fixedGutter",!0,function(e,t){e.display.gutters.style.left=t?wr(e.display)+"px":"0",e.refresh()},!0),t("coverGutterNextToScrollbar",!1,function(e){return en(e)},!0),t("scrollbarStyle","native",function(e){rn(e),en(e),e.display.scrollbars.setScrollTop(e.doc.scrollTop),e.display.scrollbars.setScrollLeft(e.doc.scrollLeft)},!0),t("lineNumbers",!1,function(e){Fn(e.options),Uo(e)},!0),t("firstLineNumber",1,Uo,!0),t("lineNumberFormatter",function(e){return e},Uo,!0),t("showCursorWhenSelecting",!1,kr,!0),t("resetSelectionOnContextMenu",!0),t("lineWiseCopyCut",!0),t("pasteLinesPerSelection",!0),t("readOnly",!1,function(e,t){"nocursor"==t&&(Fr(e),e.display.input.blur()),e.display.input.readOnlyChanged(t)}),t("disableInput",!1,function(e,t){t||e.display.input.reset()},!0),t("dragDrop",!0,Vo),t("allowDropFileTypes",null),t("cursorBlinkRate",530),t("cursorScrollMargin",0),t("cursorHeight",1,kr,!0),t("singleCursorHeightPerLine",!0,kr,!0),t("workTime",100),t("workDelay",100),t("flattenSpans",!0,Xn,!0),t("addModeClass",!1,Xn,!0),t("pollInterval",100),t("undoDepth",200,function(e,t){return e.doc.history.undoDepth=t}),t("historyEventDelay",1250),t("viewportMargin",10,function(e){return e.refresh()},!0),t("maxHighlightLength",1e4,Xn,!0),t("moveInputWithCursor",!0,function(e,t){t||e.display.input.resetPosition()}),t("tabindex",null,function(e,t){return e.display.input.getField().tabIndex=t||""}),t("autofocus",null),t("direction","ltr",function(e,t){return e.doc.setDirection(t)},!0)}(jo),function(e){var t=e.optionHandlers,r=e.helpers={};e.prototype={constructor:e,focus:function(){window.focus(),this.display.input.focus()},setOption:function(e,r){var n=this.options,i=n[e];n[e]==r&&"mode"!=e||(n[e]=r,t.hasOwnProperty(e)&&dn(this,t[e])(this,r,i),Te(this,"optionChange",this,e))},getOption:function(e){return this.options[e]},getDoc:function(){return this.doc},addKeyMap:function(e,t){this.state.keyMaps[t?"push":"unshift"](uo(e))},removeKeyMap:function(e){for(var t=this.state.keyMaps,r=0;r<t.length;++r)if(t[r]==e||t[r].name==e)return t.splice(r,1),!0},addOverlay:pn(function(t,r){var n=t.token?t:e.getMode(this.options,t);if(n.startState)throw new Error("Overlays may not be stateful.");m(this.state.overlays,{mode:n,modeSpec:t,opaque:r&&r.opaque,priority:r&&r.priority||0},function(e){return e.priority}),this.state.modeGen++,vn(this)}),removeOverlay:pn(function(e){for(var t=this,r=this.state.overlays,n=0;n<r.length;++n){var i=r[n].modeSpec;if(i==e||"string"==typeof e&&i.name==e)return r.splice(n,1),t.state.modeGen++,void vn(t)}}),indentLine:pn(function(e,t,r){"string"!=typeof t&&"number"!=typeof t&&(t=null==t?this.options.smartIndent?"smart":"prev":t?"add":"subtract"),H(this.doc,e)&&Yo(this,e,t,r)}),indentSelection:pn(function(e){for(var t=this,r=this.doc.sel.ranges,n=-1,i=0;i<r.length;i++){var o=r[i];if(o.empty())o.head.line>n&&(Yo(t,o.head.line,e,!0),n=o.head.line,i==t.doc.sel.primIndex&&jr(t));else{var l=o.from(),s=o.to(),a=Math.max(n,l.line);n=Math.min(t.lastLine(),s.line-(s.ch?0:1))+1;for(var u=a;u<n;++u)Yo(t,u,e);var c=t.doc.sel.ranges;0==l.ch&&r.length==c.length&&c[i].from().ch>0&&gi(t.doc,i,new Ts(l,c[i].to()),Gl)}}}),getTokenAt:function(e,t){return Je(this,e,t)},getLineTokens:function(e,t){return Je(this,E(e),t,!0)},getTokenTypeAt:function(e){e=U(this.doc,e);var t,r=_e(this,M(this.doc,e.line)),n=0,i=(r.length-1)/2,o=e.ch;if(0==o)t=r[2];else for(;;){var l=n+i>>1;if((l?r[2*l-1]:0)>=o)i=l;else{if(!(r[2*l+1]<o)){t=r[2*l+2];break}n=l+1}}var s=t?t.indexOf("overlay "):-1;return s<0?t:0==s?null:t.slice(0,s-1)},getModeAt:function(t){var r=this.doc.mode;return r.innerMode?e.innerMode(r,this.getTokenAt(t).state).mode:r},getHelper:function(e,t){return this.getHelpers(e,t)[0]},getHelpers:function(e,t){var n=this,i=[];if(!r.hasOwnProperty(t))return i;var o=r[t],l=this.getModeAt(e);if("string"==typeof l[t])o[l[t]]&&i.push(o[l[t]]);else if(l[t])for(var s=0;s<l[t].length;s++){var a=o[l[t][s]];a&&i.push(a)}else l.helperType&&o[l.helperType]?i.push(o[l.helperType]):o[l.name]&&i.push(o[l.name]);for(var u=0;u<o._global.length;u++){var c=o._global[u];c.pred(l,n)&&-1==h(i,c.val)&&i.push(c.val)}return i},getStateAfter:function(e,t){var r=this.doc;return e=G(r,null==e?r.first+r.size-1:e),$e(this,e+1,t).state},cursorCoords:function(e,t){var r,n=this.doc.sel.primary();return r=null==e?n.head:"object"==typeof e?U(this.doc,e):e?n.from():n.to(),sr(this,r,t||"page")},charCoords:function(e,t){return lr(this,U(this.doc,e),t||"page")},coordsChar:function(e,t){return e=or(this,e,t||"page"),cr(this,e.left,e.top)},lineAtHeight:function(e,t){return e=or(this,{top:e,left:0},t||"page").top,D(this.doc,e+this.display.viewOffset)},heightAtLine:function(e,t,r){var n,i=!1;if("number"==typeof e){var o=this.doc.first+this.doc.size-1;e<this.doc.first?e=this.doc.first:e>o&&(e=o,i=!0),n=M(this.doc,e)}else n=e;return ir(this,n,{top:0,left:0},t||"page",r||i).top+(i?this.doc.height-ye(n):0)},defaultTextHeight:function(){return mr(this.display)},defaultCharWidth:function(){return yr(this.display)},getViewport:function(){return{from:this.display.viewFrom,to:this.display.viewTo}},addWidget:function(e,t,r,n,i){var o=this.display,l=(e=sr(this,U(this.doc,e))).bottom,s=e.left;if(t.style.position="absolute",t.setAttribute("cm-ignore-events","true"),this.display.input.setUneditable(t),o.sizer.appendChild(t),"over"==n)l=e.top;else if("above"==n||"near"==n){var a=Math.max(o.wrapper.clientHeight,this.doc.height),u=Math.max(o.sizer.clientWidth,o.lineSpace.clientWidth);("above"==n||e.bottom+t.offsetHeight>a)&&e.top>t.offsetHeight?l=e.top-t.offsetHeight:e.bottom+t.offsetHeight<=a&&(l=e.bottom),s+t.offsetWidth>u&&(s=u-t.offsetWidth)}t.style.top=l+"px",t.style.left=t.style.right="","right"==i?(s=o.sizer.clientWidth-t.offsetWidth,t.style.right="0px"):("left"==i?s=0:"middle"==i&&(s=(o.sizer.clientWidth-t.offsetWidth)/2),t.style.left=s+"px"),r&&Ur(this,{left:s,top:l,right:s+t.offsetWidth,bottom:l+t.offsetHeight})},triggerOnKeyDown:pn(Lo),triggerOnKeyPress:pn(Mo),triggerOnKeyUp:To,triggerOnMouseDown:pn(Oo),execCommand:function(e){if(Bs.hasOwnProperty(e))return Bs[e].call(null,this)},triggerElectric:pn(function(e){Zo(this,e)}),findPosH:function(e,t,r,n){var i=this,o=1;t<0&&(o=-1,t=-t);for(var l=U(this.doc,e),s=0;s<t&&!(l=tl(i.doc,l,o,r,n)).hitSide;++s);return l},moveH:pn(function(e,t){var r=this;this.extendSelectionsBy(function(n){return r.display.shift||r.doc.extend||n.empty()?tl(r.doc,n.head,e,t,r.options.rtlMoveVisually):e<0?n.from():n.to()},Vl)}),deleteH:pn(function(e,t){var r=this.doc.sel,n=this.doc;r.somethingSelected()?n.replaceSelection("",null,"+delete"):co(this,function(r){var i=tl(n,r.head,e,t,!1);return e<0?{from:i,to:r.head}:{from:r.head,to:i}})}),findPosV:function(e,t,r,n){var i=this,o=1,l=n;t<0&&(o=-1,t=-t);for(var s=U(this.doc,e),a=0;a<t;++a){var u=sr(i,s,"div");if(null==l?l=u.left:u.left=l,(s=rl(i,u,o,r)).hitSide)break}return s},moveV:pn(function(e,t){var r=this,n=this.doc,i=[],o=!this.display.shift&&!n.extend&&n.sel.somethingSelected();if(n.extendSelectionsBy(function(l){if(o)return e<0?l.from():l.to();var s=sr(r,l.head,"div");null!=l.goalColumn&&(s.left=l.goalColumn),i.push(s.left);var a=rl(r,s,e,t);return"page"==t&&l==n.sel.primary()&&Kr(r,lr(r,a,"div").top-s.top),a},Vl),i.length)for(var l=0;l<n.sel.ranges.length;l++)n.sel.ranges[l].goalColumn=i[l]}),findWordAt:function(e){var t=M(this.doc,e.line).text,r=e.ch,n=e.ch;if(t){var i=this.getHelper(e,"wordChars");"before"!=e.sticky&&n!=t.length||!r?++n:--r;for(var o=t.charAt(r),l=x(o,i)?function(e){return x(e,i)}:/\s/.test(o)?function(e){return/\s/.test(e)}:function(e){return!/\s/.test(e)&&!x(e)};r>0&&l(t.charAt(r-1));)--r;for(;n<t.length&&l(t.charAt(n));)++n}return new Ts(E(e.line,r),E(e.line,n))},toggleOverwrite:function(e){null!=e&&e==this.state.overwrite||((this.state.overwrite=!this.state.overwrite)?s(this.display.cursorDiv,"CodeMirror-overwrite"):Fl(this.display.cursorDiv,"CodeMirror-overwrite"),Te(this,"overwriteToggle",this,this.state.overwrite))},hasFocus:function(){return this.display.input.getField()==l()},isReadOnly:function(){return!(!this.options.readOnly&&!this.doc.cantEdit)},scrollTo:pn(function(e,t){Xr(this,e,t)}),getScrollInfo:function(){var e=this.display.scroller;return{left:e.scrollLeft,top:e.scrollTop,height:e.scrollHeight-zt(this)-this.display.barHeight,width:e.scrollWidth-zt(this)-this.display.barWidth,clientHeight:Bt(this),clientWidth:Rt(this)}},scrollIntoView:pn(function(e,t){null==e?(e={from:this.doc.sel.primary().head,to:null},null==t&&(t=this.options.cursorScrollMargin)):"number"==typeof e?e={from:E(e,0),to:null}:null==e.from&&(e={from:e,to:null}),e.to||(e.to=e.from),e.margin=t||0,null!=e.from.line?Yr(this,e):$r(this,e.from,e.to,e.margin)}),setSize:pn(function(e,t){var r=this,n=function(e){return"number"==typeof e||/^\d+$/.test(String(e))?e+"px":e};null!=e&&(this.display.wrapper.style.width=n(e)),null!=t&&(this.display.wrapper.style.height=n(t)),this.options.lineWrapping&&Jt(this);var i=this.display.viewFrom;this.doc.iter(i,this.display.viewTo,function(e){if(e.widgets)for(var t=0;t<e.widgets.length;t++)if(e.widgets[t].noHScroll){mn(r,i,"widget");break}++i}),this.curOp.forceUpdate=!0,Te(this,"refresh",this)}),operation:function(e){return hn(this,e)},startOperation:function(){return nn(this)},endOperation:function(){return on(this)},refresh:pn(function(){var e=this.display.cachedTextHeight;vn(this),this.curOp.forceUpdate=!0,er(this),Xr(this,this.doc.scrollLeft,this.doc.scrollTop),Wn(this),(null==e||Math.abs(e-mr(this.display))>.5)&&Cr(this),Te(this,"refresh",this)}),swapDoc:pn(function(e){var t=this.doc;return t.cm=null,qn(this,e),er(this),this.display.input.reset(),Xr(this,e.scrollLeft,e.scrollTop),this.curOp.forceScroll=!0,bt(this,"swapDoc",this,t),t}),getInputField:function(){return this.display.input.getField()},getWrapperElement:function(){return this.display.wrapper},getScrollerElement:function(){return this.display.scroller},getGutterElement:function(){return this.display.gutters}},Ae(e),e.registerHelper=function(t,n,i){r.hasOwnProperty(t)||(r[t]=e[t]={_global:[]}),r[t][n]=i},e.registerGlobalHelper=function(t,n,i,o){e.registerHelper(t,n,o),r[t]._global.push({pred:i,val:o})}}(jo);var Js="iter insert remove copy getEditor constructor".split(" ");for(var ea in Ds.prototype)Ds.prototype.hasOwnProperty(ea)&&h(Js,ea)<0&&(jo.prototype[ea]=function(e){return function(){return e.apply(this.doc,arguments)}}(Ds.prototype[ea]));return Ae(Ds),jo.inputStyles={textarea:Qs,contenteditable:Zs},jo.defineMode=function(e){jo.defaults.mode||"null"==e||(jo.defaults.mode=e),Be.apply(this,arguments)},jo.defineMIME=function(e,t){os[e]=t},jo.defineMode("null",function(){return{token:function(e){return e.skipToEnd()}}}),jo.defineMIME("text/plain","null"),jo.defineExtension=function(e,t){jo.prototype[e]=t},jo.defineDocExtension=function(e,t){Ds.prototype[e]=t},jo.fromTextArea=function(e,t){function r(){e.value=a.getValue()}if(t=t?c(t):{},t.value=e.value,!t.tabindex&&e.tabIndex&&(t.tabindex=e.tabIndex),!t.placeholder&&e.placeholder&&(t.placeholder=e.placeholder),null==t.autofocus){var n=l();t.autofocus=n==e||null!=e.getAttribute("autofocus")&&n==document.body}var i;if(e.form&&(Ql(e.form,"submit",r),!t.leaveSubmitMethodAlone)){var o=e.form;i=o.submit;try{var s=o.submit=function(){r(),o.submit=i,o.submit(),o.submit=s}}catch(e){}}t.finishInit=function(t){t.save=r,t.getTextArea=function(){return e},t.toTextArea=function(){t.toTextArea=isNaN,r(),e.parentNode.removeChild(t.getWrapperElement()),e.style.display="",e.form&&(ke(e.form,"submit",r),"function"==typeof e.form.submit&&(e.form.submit=i))}},e.style.display="none";var a=jo(function(t){return e.parentNode.insertBefore(t,e.nextSibling)},t);return a},function(e){e.off=ke,e.on=Ql,e.wheelEventPixels=Pn,e.Doc=Ds,e.splitLines=es,e.countColumn=f,e.findColumn=d,e.isWordChar=w,e.Pass=Bl,e.signal=Te,e.Line=fs,e.changeEnd=Bn,e.scrollbarModel=ws,e.Pos=E,e.cmpPos=P,e.modes=is,e.mimeModes=os,e.resolveMode=Ge,e.getMode=Ue,e.modeExtensions=ls,e.extendMode=Ve,e.copyState=Ke,e.startState=Xe,e.innerMode=je,e.commands=Bs,e.keyMap=Rs,e.keyName=ao,e.isModifierKey=lo,e.lookupKey=oo,e.normalizeKeyMap=io,e.StringStream=ss,e.SharedTextMarker=As,e.TextMarker=Os,e.LineWidget=Ms,e.e_preventDefault=We,e.e_stopPropagation=De,e.e_stop=Fe,e.addClass=s,e.contains=o,e.rmClass=Fl,e.keyNames=Es}(jo),jo.version="5.30.0",jo});
      !function(e){"object"==typeof exports&&"object"==typeof module?e(require("../../lib/codemirror")):"function"==typeof define&&define.amd?define(["../../lib/codemirror"],e):e(CodeMirror)}(function(e){"use strict";function t(e,t,n,r,o,a){this.indented=e,this.column=t,this.type=n,this.info=r,this.align=o,this.prev=a}function n(e,n,r,o){var a=e.indented;return e.context&&"statement"==e.context.type&&"statement"!=r&&(a=e.context.indented),e.context=new t(a,n,r,o,null,e.context)}function r(e){var t=e.context.type;return")"!=t&&"]"!=t&&"}"!=t||(e.indented=e.context.indented),e.context=e.context.prev}function o(e,t,n){return"variable"==t.prevToken||"type"==t.prevToken||(!!/\S(?:[^- ]>|[*\]])\s*$|\*$/.test(e.string.slice(0,n))||(!(!t.typeAtEndOfLine||e.column()!=e.indentation())||void 0))}function a(e){for(;;){if(!e||"top"==e.type)return!0;if("}"==e.type&&"namespace"!=e.prev.info)return!1;e=e.prev}}function i(e){for(var t={},n=e.split(" "),r=0;r<n.length;++r)t[n[r]]=!0;return t}function l(e,t){return"function"==typeof e?e(t):e.propertyIsEnumerable(t)}function s(e,t){if(!t.startOfLine)return!1;for(var n,r=null;n=e.peek();){if("\\"==n&&e.match(/^.$/)){r=s;break}if("/"==n&&e.match(/^\/[\/\*]/,!1))break;e.next()}return t.tokenize=r,"meta"}function c(e,t){return"type"==t.prevToken&&"type"}function u(e){return e.eatWhile(/[\w\.']/),"number"}function d(e,t){if(e.backUp(1),e.match(/(R|u8R|uR|UR|LR)/)){var n=e.match(/"([^\s\\()]{0,16})\(/);return!!n&&(t.cpp11RawStringDelim=n[1],t.tokenize=m,m(e,t))}return e.match(/(u8|u|U|L)/)?!!e.match(/["']/,!1)&&"string":(e.next(),!1)}function f(e){var t=/(\w+)::~?(\w+)$/.exec(e);return t&&t[1]==t[2]}function p(e,t){for(var n;null!=(n=e.next());)if('"'==n&&!e.eat('"')){t.tokenize=null;break}return"string"}function m(e,t){var n=t.cpp11RawStringDelim.replace(/[^\w\s]/g,"\\$&");return e.match(new RegExp(".*?\\)"+n+'"'))?t.tokenize=null:e.skipToEnd(),"string"}function h(t,n){function r(e){if(e)for(var t in e)e.hasOwnProperty(t)&&o.push(t)}"string"==typeof t&&(t=[t]);var o=[];r(n.keywords),r(n.types),r(n.builtin),r(n.atoms),o.length&&(n.helperType=t[0],e.registerHelper("hintWords",t[0],o));for(var a=0;a<t.length;++a)e.defineMIME(t[a],n)}function g(e,t){for(var n=!1;!e.eol();){if(!n&&e.match('"""')){t.tokenize=null;break}n="\\"==e.next()&&!n}return"string"}function y(e){return function(t,n){for(var r,o=!1,a=!1;!t.eol();){if(!e&&!o&&t.match('"')){a=!0;break}if(e&&t.match('"""')){a=!0;break}r=t.next(),!o&&"$"==r&&t.match("{")&&t.skipTo("}"),o=!o&&"\\"==r&&!e}return!a&&e||(n.tokenize=null),"string"}}function x(e){return function(t,n){for(var r,o=!1,a=!1;!t.eol();){if(!o&&t.match('"')&&("single"==e||t.match('""'))){a=!0;break}if(!o&&t.match("``")){w=x(e),a=!0;break}r=t.next(),o="single"==e&&!o&&"\\"==r}return a&&(n.tokenize=null),"string"}}e.defineMode("clike",function(i,s){function c(e,t){var n=e.next();if(S[n]){var r=S[n](e,t);if(!1!==r)return r}if('"'==n||"'"==n)return t.tokenize=u(n),t.tokenize(e,t);if(D.test(n))return p=n,null;if(L.test(n)){if(e.backUp(1),e.match(I))return"number";e.next()}if("/"==n){if(e.eat("*"))return t.tokenize=d,d(e,t);if(e.eat("/"))return e.skipToEnd(),"comment"}if(F.test(n)){for(;!e.match(/^\/[\/*]/,!1)&&e.eat(F););return"operator"}if(e.eatWhile(z),P)for(;e.match(P);)e.eatWhile(z);var o=e.current();return l(x,o)?(l(w,o)&&(p="newstatement"),l(v,o)&&(m=!0),"keyword"):l(b,o)?"type":l(k,o)?(l(w,o)&&(p="newstatement"),"builtin"):l(_,o)?"atom":"variable"}function u(e){return function(t,n){for(var r,o=!1,a=!1;null!=(r=t.next());){if(r==e&&!o){a=!0;break}o=!o&&"\\"==r}return(a||!o&&!C)&&(n.tokenize=null),"string"}}function d(e,t){for(var n,r=!1;n=e.next();){if("/"==n&&r){t.tokenize=null;break}r="*"==n}return"comment"}function f(e,t){s.typeFirstDefinitions&&e.eol()&&a(t.context)&&(t.typeAtEndOfLine=o(e,t,e.pos))}var p,m,h=i.indentUnit,g=s.statementIndentUnit||h,y=s.dontAlignCalls,x=s.keywords||{},b=s.types||{},k=s.builtin||{},w=s.blockKeywords||{},v=s.defKeywords||{},_=s.atoms||{},S=s.hooks||{},C=s.multiLineStrings,T=!1!==s.indentStatements,M=!1!==s.indentSwitch,P=s.namespaceSeparator,D=s.isPunctuationChar||/[\[\]{}\(\),;\:\.]/,L=s.numberStart||/[\d\.]/,I=s.number||/^(?:0x[a-f\d]+|0b[01]+|(?:\d+\.?\d*|\.\d+)(?:e[-+]?\d+)?)(u|ll?|l|f)?/i,F=s.isOperatorChar||/[+\-*&%=<>!?|\/]/,z=s.isIdentifierChar||/[\w\$_\xa1-\uffff]/;return{startState:function(e){return{tokenize:null,context:new t((e||0)-h,0,"top",null,!1),indented:0,startOfLine:!0,prevToken:null}},token:function(e,t){var i=t.context;if(e.sol()&&(null==i.align&&(i.align=!1),t.indented=e.indentation(),t.startOfLine=!0),e.eatSpace())return f(e,t),null;p=m=null;var l=(t.tokenize||c)(e,t);if("comment"==l||"meta"==l)return l;if(null==i.align&&(i.align=!0),";"==p||":"==p||","==p&&e.match(/^\s*(?:\/\/.*)?$/,!1))for(;"statement"==t.context.type;)r(t);else if("{"==p)n(t,e.column(),"}");else if("["==p)n(t,e.column(),"]");else if("("==p)n(t,e.column(),")");else if("}"==p){for(;"statement"==i.type;)i=r(t);for("}"==i.type&&(i=r(t));"statement"==i.type;)i=r(t)}else p==i.type?r(t):T&&(("}"==i.type||"top"==i.type)&&";"!=p||"statement"==i.type&&"newstatement"==p)&&n(t,e.column(),"statement",e.current());if("variable"==l&&("def"==t.prevToken||s.typeFirstDefinitions&&o(e,t,e.start)&&a(t.context)&&e.match(/^\s*\(/,!1))&&(l="def"),S.token){var u=S.token(e,t,l);void 0!==u&&(l=u)}return"def"==l&&!1===s.styleDefs&&(l="variable"),t.startOfLine=!1,t.prevToken=m?"def":l||p,f(e,t),l},indent:function(t,n){if(t.tokenize!=c&&null!=t.tokenize||t.typeAtEndOfLine)return e.Pass;var r=t.context,o=n&&n.charAt(0);if("statement"==r.type&&"}"==o&&(r=r.prev),s.dontIndentStatements)for(;"statement"==r.type&&s.dontIndentStatements.test(r.info);)r=r.prev;if(S.indent){var a=S.indent(t,r,n);if("number"==typeof a)return a}var i=o==r.type,l=r.prev&&"switch"==r.prev.info;if(s.allmanIndentation&&/[{(]/.test(o)){for(;"top"!=r.type&&"}"!=r.type;)r=r.prev;return r.indented}return"statement"==r.type?r.indented+("{"==o?0:g):!r.align||y&&")"==r.type?")"!=r.type||i?r.indented+(i?0:h)+(i||!l||/^(?:case|default)\b/.test(n)?0:h):r.indented+g:r.column+(i?0:1)},electricInput:M?/^\s*(?:case .*?:|default:|\{\}?|\})$/:/^\s*[{}]$/,blockCommentStart:"/*",blockCommentEnd:"*/",lineComment:"//",fold:"brace"}});var b="auto if break case register continue return default do sizeof static else struct switch extern typedef union for goto while enum const volatile",k="int long char short double float unsigned signed void size_t ptrdiff_t";h(["text/x-csrc","text/x-c","text/x-chdr"],{name:"clike",keywords:i(b),types:i(k+" bool _Complex _Bool float_t double_t intptr_t intmax_t int8_t int16_t int32_t int64_t uintptr_t uintmax_t uint8_t uint16_t uint32_t uint64_t"),blockKeywords:i("case do else for if switch while struct"),defKeywords:i("struct"),typeFirstDefinitions:!0,atoms:i("null true false"),hooks:{"#":s,"*":c},modeProps:{fold:["brace","include"]}}),h(["text/x-c++src","text/x-c++hdr"],{name:"clike",keywords:i(b+" asm dynamic_cast namespace reinterpret_cast try explicit new static_cast typeid catch operator template typename class friend private this using const_cast inline public throw virtual delete mutable protected alignas alignof constexpr decltype nullptr noexcept thread_local final static_assert override"),types:i(k+" bool wchar_t"),blockKeywords:i("catch class do else finally for if struct switch try while"),defKeywords:i("class namespace struct enum union"),typeFirstDefinitions:!0,atoms:i("true false null"),dontIndentStatements:/^template$/,isIdentifierChar:/[\w\$_~\xa1-\uffff]/,hooks:{"#":s,"*":c,u:d,U:d,L:d,R:d,0:u,1:u,2:u,3:u,4:u,5:u,6:u,7:u,8:u,9:u,token:function(e,t,n){if("variable"==n&&"("==e.peek()&&(";"==t.prevToken||null==t.prevToken||"}"==t.prevToken)&&f(e.current()))return"def"}},namespaceSeparator:"::",modeProps:{fold:["brace","include"]}}),h("text/x-java",{name:"clike",keywords:i("abstract assert break case catch class const continue default do else enum extends final finally float for goto if implements import instanceof interface native new package private protected public return static strictfp super switch synchronized this throw throws transient try volatile while @interface"),types:i("byte short int long float double boolean char void Boolean Byte Character Double Float Integer Long Number Object Short String StringBuffer StringBuilder Void"),blockKeywords:i("catch class do else finally for if switch try while"),defKeywords:i("class interface package enum @interface"),typeFirstDefinitions:!0,atoms:i("true false null"),number:/^(?:0x[a-f\d_]+|0b[01_]+|(?:[\d_]+\.?\d*|\.\d+)(?:e[-+]?[\d_]+)?)(u|ll?|l|f)?/i,hooks:{"@":function(e){return!e.match("interface",!1)&&(e.eatWhile(/[\w\$_]/),"meta")}},modeProps:{fold:["brace","import"]}}),h("text/x-csharp",{name:"clike",keywords:i("abstract as async await base break case catch checked class const continue default delegate do else enum event explicit extern finally fixed for foreach goto if implicit in interface internal is lock namespace new operator out override params private protected public readonly ref return sealed sizeof stackalloc static struct switch this throw try typeof unchecked unsafe using virtual void volatile while add alias ascending descending dynamic from get global group into join let orderby partial remove select set value var yield"),types:i("Action Boolean Byte Char DateTime DateTimeOffset Decimal Double Func Guid Int16 Int32 Int64 Object SByte Single String Task TimeSpan UInt16 UInt32 UInt64 bool byte char decimal double short int long object sbyte float string ushort uint ulong"),blockKeywords:i("catch class do else finally for foreach if struct switch try while"),defKeywords:i("class interface namespace struct var"),typeFirstDefinitions:!0,atoms:i("true false null"),hooks:{"@":function(e,t){return e.eat('"')?(t.tokenize=p,p(e,t)):(e.eatWhile(/[\w\$_]/),"meta")}}}),h("text/x-scala",{name:"clike",keywords:i("abstract case catch class def do else extends final finally for forSome if implicit import lazy match new null object override package private protected return sealed super this throw trait try type val var while with yield _ assert assume require print println printf readLine readBoolean readByte readShort readChar readInt readLong readFloat readDouble"),types:i("AnyVal App Application Array BufferedIterator BigDecimal BigInt Char Console Either Enumeration Equiv Error Exception Fractional Function IndexedSeq Int Integral Iterable Iterator List Map Numeric Nil NotNull Option Ordered Ordering PartialFunction PartialOrdering Product Proxy Range Responder Seq Serializable Set Specializable Stream StringBuilder StringContext Symbol Throwable Traversable TraversableOnce Tuple Unit Vector Boolean Byte Character CharSequence Class ClassLoader Cloneable Comparable Compiler Double Exception Float Integer Long Math Number Object Package Pair Process Runtime Runnable SecurityManager Short StackTraceElement StrictMath String StringBuffer System Thread ThreadGroup ThreadLocal Throwable Triple Void"),multiLineStrings:!0,blockKeywords:i("catch class enum do else finally for forSome if match switch try while"),defKeywords:i("class enum def object package trait type val var"),atoms:i("true false null"),indentStatements:!1,indentSwitch:!1,isOperatorChar:/[+\-*&%=<>!?|\/#:@]/,hooks:{"@":function(e){return e.eatWhile(/[\w\$_]/),"meta"},'"':function(e,t){return!!e.match('""')&&(t.tokenize=g,t.tokenize(e,t))},"'":function(e){return e.eatWhile(/[\w\$_\xa1-\uffff]/),"atom"},"=":function(e,n){var r=n.context;return!("}"!=r.type||!r.align||!e.eat(">"))&&(n.context=new t(r.indented,r.column,r.type,r.info,null,r.prev),"operator")}},modeProps:{closeBrackets:{triples:'"'}}}),h("text/x-kotlin",{name:"clike",keywords:i("package as typealias class interface this super val var fun for is in This throw return break continue object if else while do try when !in !is as? file import where by get set abstract enum open inner override private public internal protected catch finally out final vararg reified dynamic companion constructor init sealed field property receiver param sparam lateinit data inline noinline tailrec external annotation crossinline const operator infix suspend"),types:i("Boolean Byte Character CharSequence Class ClassLoader Cloneable Comparable Compiler Double Exception Float Integer Long Math Number Object Package Pair Process Runtime Runnable SecurityManager Short StackTraceElement StrictMath String StringBuffer System Thread ThreadGroup ThreadLocal Throwable Triple Void"),intendSwitch:!1,indentStatements:!1,multiLineStrings:!0,number:/^(?:0x[a-f\d_]+|0b[01_]+|(?:[\d_]+\.?\d*|\.\d+)(?:e[-+]?[\d_]+)?)(u|ll?|l|f)?/i,blockKeywords:i("catch class do else finally for if where try while enum"),defKeywords:i("class val var object package interface fun"),atoms:i("true false null this"),hooks:{'"':function(e,t){return t.tokenize=y(e.match('""')),t.tokenize(e,t)}},modeProps:{closeBrackets:{triples:'"'}}}),h(["x-shader/x-vertex","x-shader/x-fragment"],{name:"clike",keywords:i("sampler1D sampler2D sampler3D samplerCube sampler1DShadow sampler2DShadow const attribute uniform varying break continue discard return for while do if else struct in out inout"),types:i("float int bool void vec2 vec3 vec4 ivec2 ivec3 ivec4 bvec2 bvec3 bvec4 mat2 mat3 mat4"),blockKeywords:i("for while do if else struct"),builtin:i("radians degrees sin cos tan asin acos atan pow exp log exp2 sqrt inversesqrt abs sign floor ceil fract mod min max clamp mix step smoothstep length distance dot cross normalize ftransform faceforward reflect refract matrixCompMult lessThan lessThanEqual greaterThan greaterThanEqual equal notEqual any all not texture1D texture1DProj texture1DLod texture1DProjLod texture2D texture2DProj texture2DLod texture2DProjLod texture3D texture3DProj texture3DLod texture3DProjLod textureCube textureCubeLod shadow1D shadow2D shadow1DProj shadow2DProj shadow1DLod shadow2DLod shadow1DProjLod shadow2DProjLod dFdx dFdy fwidth noise1 noise2 noise3 noise4"),atoms:i("true false gl_FragColor gl_SecondaryColor gl_Normal gl_Vertex gl_MultiTexCoord0 gl_MultiTexCoord1 gl_MultiTexCoord2 gl_MultiTexCoord3 gl_MultiTexCoord4 gl_MultiTexCoord5 gl_MultiTexCoord6 gl_MultiTexCoord7 gl_FogCoord gl_PointCoord gl_Position gl_PointSize gl_ClipVertex gl_FrontColor gl_BackColor gl_FrontSecondaryColor gl_BackSecondaryColor gl_TexCoord gl_FogFragCoord gl_FragCoord gl_FrontFacing gl_FragData gl_FragDepth gl_ModelViewMatrix gl_ProjectionMatrix gl_ModelViewProjectionMatrix gl_TextureMatrix gl_NormalMatrix gl_ModelViewMatrixInverse gl_ProjectionMatrixInverse gl_ModelViewProjectionMatrixInverse gl_TexureMatrixTranspose gl_ModelViewMatrixInverseTranspose gl_ProjectionMatrixInverseTranspose gl_ModelViewProjectionMatrixInverseTranspose gl_TextureMatrixInverseTranspose gl_NormalScale gl_DepthRange gl_ClipPlane gl_Point gl_FrontMaterial gl_BackMaterial gl_LightSource gl_LightModel gl_FrontLightModelProduct gl_BackLightModelProduct gl_TextureColor gl_EyePlaneS gl_EyePlaneT gl_EyePlaneR gl_EyePlaneQ gl_FogParameters gl_MaxLights gl_MaxClipPlanes gl_MaxTextureUnits gl_MaxTextureCoords gl_MaxVertexAttribs gl_MaxVertexUniformComponents gl_MaxVaryingFloats gl_MaxVertexTextureImageUnits gl_MaxTextureImageUnits gl_MaxFragmentUniformComponents gl_MaxCombineTextureImageUnits gl_MaxDrawBuffers"),indentSwitch:!1,hooks:{"#":s},modeProps:{fold:["brace","include"]}}),h("text/x-nesc",{name:"clike",keywords:i(b+"as atomic async call command component components configuration event generic implementation includes interface module new norace nx_struct nx_union post provides signal task uses abstract extends"),types:i(k),blockKeywords:i("case do else for if switch while struct"),atoms:i("null true false"),hooks:{"#":s},modeProps:{fold:["brace","include"]}}),h("text/x-objectivec",{name:"clike",keywords:i(b+"inline restrict _Bool _Complex _Imaginary BOOL Class bycopy byref id IMP in inout nil oneway out Protocol SEL self super atomic nonatomic retain copy readwrite readonly"),types:i(k),atoms:i("YES NO NULL NILL ON OFF true false"),hooks:{"@":function(e){return e.eatWhile(/[\w\$]/),"keyword"},"#":s,indent:function(e,t,n){if("statement"==t.type&&/^@\w/.test(n))return t.indented}},modeProps:{fold:"brace"}}),h("text/x-squirrel",{name:"clike",keywords:i("base break clone continue const default delete enum extends function in class foreach local resume return this throw typeof yield constructor instanceof static"),types:i(k),blockKeywords:i("case catch class else for foreach if switch try while"),defKeywords:i("function local class"),typeFirstDefinitions:!0,atoms:i("true false null"),hooks:{"#":s},modeProps:{fold:["brace","include"]}});var w=null;h("text/x-ceylon",{name:"clike",keywords:i("abstracts alias assembly assert assign break case catch class continue dynamic else exists extends finally for function given if import in interface is let module new nonempty object of out outer package return satisfies super switch then this throw try value void while"),types:function(e){var t=e.charAt(0);return t===t.toUpperCase()&&t!==t.toLowerCase()},blockKeywords:i("case catch class dynamic else finally for function if interface module new object switch try while"),defKeywords:i("class dynamic function interface module object package value"),builtin:i("abstract actual aliased annotation by default deprecated doc final formal late license native optional sealed see serializable shared suppressWarnings tagged throws variable"),isPunctuationChar:/[\[\]{}\(\),;\:\.`]/,isOperatorChar:/[+\-*&%=<>!?|^~:\/]/,numberStart:/[\d#$]/,number:/^(?:#[\da-fA-F_]+|\$[01_]+|[\d_]+[kMGTPmunpf]?|[\d_]+\.[\d_]+(?:[eE][-+]?\d+|[kMGTPmunpf]|)|)/i,multiLineStrings:!0,typeFirstDefinitions:!0,atoms:i("true false null larger smaller equal empty finished"),indentSwitch:!1,styleDefs:!1,hooks:{"@":function(e){return e.eatWhile(/[\w\$_]/),"meta"},'"':function(e,t){return t.tokenize=x(e.match('""')?"triple":"single"),t.tokenize(e,t)},"`":function(e,t){return!(!w||!e.match("`"))&&(t.tokenize=w,w=null,t.tokenize(e,t))},"'":function(e){return e.eatWhile(/[\w\$_\xa1-\uffff]/),"atom"},token:function(e,t,n){if(("variable"==n||"type"==n)&&"."==t.prevToken)return"variable-2"}},modeProps:{fold:["brace","import"],closeBrackets:{triples:'"'}}})});
      // -------------------------------------------------------------------------
//  Part of the CodeChecker project, under the Apache License v2.0 with
//  LLVM Exceptions. See LICENSE for license information.
//  SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
// -------------------------------------------------------------------------

var BugViewer = {
  _files : [],
  _reports : [],
  _lineWidgets : [],
  _navigationMenuItems : [],
  _sourceFileData : null,
  _currentReport : null,
  _lastBugEvent  : null,

  init : function (files, reports) {
    this._files = files;
    this._reports = reports;

    this.initEscapeChars();
  },

  initEscapeChars : function () {
    this.escapeChars = {
      ' ' : 'nbsp',
      '<' : 'lt',
      '>' : 'gt',
      '"' : 'quot',
      '&' : 'amp'
    };

    var regexString = '[';
    for (var key in this.escapeChars) {
      regexString += key;
    }
    regexString += ']';

    this.escapeRegExp = new RegExp( regexString, 'g');
  },

  escapeHTML : function (str) {
    var that = this;

    return str.replace(this.escapeRegExp, function (m) {
      return '&' + that.escapeChars[m] + ';';
    });
  },

  initByUrl : function () {
    if (!this._reports) return;

    var state = {};
    window.location.hash.substr(1).split('&').forEach(function (s) {
      var parts = s.split('=');
      state[parts[0]] = parts[1];
    });

    for (var key in this._reports) {
      var report = this._reports[key];
      if (report.reportHash === state['reportHash']) {
        this.navigate(report);
        return;
      }
    }

    this.navigate(this._reports[0]);
  },

  create : function () {
    this._content = document.getElementById('editor-wrapper');
    this._filepath = document.getElementById('file-path');
    this._checkerName = document.getElementById('checker-name');
    this._reviewStatusWrapper =
      document.getElementById('review-status-wrapper');
    this._reviewStatus = document.getElementById('review-status');
    this._editor = document.getElementById('editor');

    this._codeMirror = CodeMirror(this._editor, {
      mode: 'text/x-c++src',
      matchBrackets : true,
      lineNumbers : true,
      readOnly : true,
      foldGutter : true,
      extraKeys : {},
      viewportMargin : 100
    });

    this._createNavigationMenu();
  },

  navigate : function (report, item) {
    if (!item) {
      var items = this._navigationMenuItems.filter(function (navItem) {
        return navItem.report.reportHash === report.reportHash;
      });

      if (!items.length) return;

      item = items[0].widget;
    }

    this._selectedReport.classList.remove('active');
    this._selectedReport = item;
    this._selectedReport.classList.add('active');
    this.setReport(report);
  },

  _createNavigationMenu : function () {
    var that = this;

    var nav = document.getElementById('report-nav');
    var list = document.createElement('ul');
    this._reports.forEach(function (report) {
      var events = report['events'];
      var lastBugEvent = events[events.length - 1];
      var item = document.createElement('li');

      var severity = document.createElement('i');
      severity.className = 'severity-' + report.severity.toLowerCase();

      item.appendChild(severity);
      item.appendChild(document.createTextNode(lastBugEvent.message));

      item.addEventListener('click', function () {
        that.navigate(report, item);
      })
      list.appendChild(item);
      that._navigationMenuItems.push({ report : report, widget : item });
    });

    if (!this._selectedReport && list.childNodes.length) {
      this._selectedReport = list.childNodes[0];
      this._selectedReport.classList.add('active');
    }

    nav.appendChild(list);
  },

  setReport : function (report) {
    this._currentReport = report;
    var events = report['events'];
    var lastBugEvent = events[events.length - 1];
    this.setCurrentBugEvent(lastBugEvent, events.length - 1);
    this.setCheckerName(report.checkerName);
    this.setReviewStatus(report.reviewStatus);

    window.location.hash = '#reportHash=' + report.reportHash;
  },

  setCurrentBugEvent : function (event, idx) {
    this._currentBugEvent = event;
    this.setSourceFileData(this._files[event.location.file]);
    this.drawBugPath();

    this.jumpTo(event.location.line, 0);
    this.highlightBugEvent(event, idx);
  },

  highlightBugEvent : function (event, idx) {
    this._lineWidgets.forEach(function (widget) {
      var lineIdx = widget.node.getAttribute('idx');
      if (parseInt(lineIdx) === idx) {
        widget.node.classList.add('current');
      }
    });
  },

  setCheckerName : function (checkerName) {
    this._checkerName.innerHTML = checkerName;
  },

  setReviewStatus : function (status) {
    if (status) {
      var className =
        'review-status-' + status.toLowerCase().split(' ').join('-');
      this._reviewStatus.className = "review-status " + className;

      this._reviewStatus.innerHTML = status;
      this._reviewStatusWrapper.style.display = 'block';
    } else {
      this._reviewStatusWrapper.style.display = 'none';
    }
  },

  setSourceFileData : function (file) {
    if (this._sourceFileData && file.id === this._sourceFileData.id) {
      return;
    }

    this._sourceFileData = file;
    this._filepath.innerHTML = file.path;
    this._codeMirror.doc.setValue(file.content);
    this._refresh();
  },

  _refresh : function () {
    var that = this;
    setTimeout(function () {
      var fullHeight = parseInt(that._content.clientHeight);
      var headerHeight = that._filepath.clientHeight;

      that._codeMirror.setSize('auto', fullHeight - headerHeight);
      that._codeMirror.refresh();
    }, 200);
  },

  clearBubbles : function () {
    this._lineWidgets.forEach(function (widget) { widget.clear(); });
    this._lineWidgets = [];
  },

  getMessage : function (event, kind) {
    if (kind === 'macro') {
      var name = 'macro expansion' + (event.name ? ': ' + event.name : '');

      return '<span class="tag macro">' + name + '</span>'
        + this.escapeHTML(event.expansion).replace(/(?:\r\n|\r|\n)/g, '<br>');
    } else if (kind === 'note') {
      return '<span class="tag note">note</span>'
        +  this.escapeHTML(event.message).replace(/(?:\r\n|\r|\n)/g, '<br>');
    }
  },

  addExtraPathEvents : function (events, kind) {
    var that = this;

    if (!events) {
      return;
    }

    events.forEach(function (event) {
      if (event.location.file !== that._currentBugEvent.location.file) {
        return;
      }

      var left =
        that._codeMirror.defaultCharWidth() * event.location.col + 'px';

      var element = document.createElement('div');
      element.setAttribute('style', 'margin-left: ' + left);
      element.setAttribute('class', 'check-msg ' + kind);

      var msg = document.createElement('span');
      msg.innerHTML = that.getMessage(event, kind);
      element.appendChild(msg);

      that._lineWidgets.push(that._codeMirror.addLineWidget(
        event.location.line - 1, element));
    });
  },

  drawBugPath : function () {
    var that = this;

    this.clearBubbles();

    this.addExtraPathEvents(this._currentReport.macros, 'macro');
    this.addExtraPathEvents(this._currentReport.notes, 'note');

    // Processing bug path events.
    var currentEvents = this._currentReport.events;
    currentEvents.forEach(function (event, step) {
      if (event.location.file !== that._currentBugEvent.location.file)
        return;

      var left =
        that._codeMirror.defaultCharWidth() * event.location.col + 'px';
      var type = step === currentEvents.length - 1 ? 'error' : 'info';

      var element = document.createElement('div');
      element.setAttribute('style', 'margin-left: ' + left);
      element.setAttribute('class', 'check-msg ' + type);
      element.setAttribute('idx', step);

      var enumeration = document.createElement('span');
      enumeration.setAttribute('class', 'checker-enum ' + type);
      enumeration.innerHTML = step + 1;

      if (currentEvents.length > 1)
        element.appendChild(enumeration);

      var prevBugEvent = step - 1;
      if (step > 0) {
        var prevBug = document.createElement('span');
        prevBug.setAttribute('class', 'arrow left-arrow');
        prevBug.addEventListener('click', function () {
          var event = currentEvents[prevBugEvent];
          that.setCurrentBugEvent(event, prevBugEvent);
        });
        element.appendChild(prevBug);
      }

      var msg = document.createElement('span');
      msg.innerHTML = that.escapeHTML(event.message)
        .replace(/(?:\r\n|\r|\n)/g, '<br>');

      element.appendChild(msg);

      var nextBugEvent = step + 1;
      if (nextBugEvent < currentEvents.length) {
        var nextBug = document.createElement('span');
        nextBug.setAttribute('class', 'arrow right-arrow');
        nextBug.addEventListener('click', function () {
          var event = currentEvents[nextBugEvent];
          that.setCurrentBugEvent(event, nextBugEvent);
        });
        element.appendChild(nextBug);
      }


      that._lineWidgets.push(that._codeMirror.addLineWidget(
        event.location.line - 1, element));
    });
  },

  jumpTo : function (line, column) {
    var that = this;

    setTimeout(function () {
      var selPosPixel
        = that._codeMirror.charCoords({ line : line, ch : column }, 'local');
      var editorSize = {
        width  : that._editor.clientWidth,
        height : that._editor.clientHeight
      };

      that._codeMirror.scrollIntoView({
        top    : selPosPixel.top - 100,
        bottom : selPosPixel.top + editorSize.height - 150,
        left   : selPosPixel.left < editorSize.width - 100
               ? 0
               : selPosPixel.left - 50,
        right  : selPosPixel.left < editorSize.width - 100
               ? 10
               : selPosPixel.left + editorSize.width - 100
      });
    }, 0);
  }
}


      var data = {"files": {"23": {"id": 23, "path": "/home/runner/work/testcc/testcc/retdec/src/lib-storage/mail-storage.c", "content": "/* Copyright (c) 2002-2018 Dovecot authors, see the included COPYING file */\n\n#include \"lib.h\"\n#include \"ioloop.h\"\n#include \"array.h\"\n#include \"llist.h\"\n#include \"str.h\"\n#include \"str-sanitize.h\"\n#include \"sha1.h\"\n#include \"unichar.h\"\n#include \"hex-binary.h\"\n#include \"file-dotlock.h\"\n#include \"file-create-locked.h\"\n#include \"istream.h\"\n#include \"eacces-error.h\"\n#include \"mkdir-parents.h\"\n#include \"time-util.h\"\n#include \"var-expand.h\"\n#include \"dsasl-client.h\"\n#include \"imap-date.h\"\n#include \"settings-parser.h\"\n#include \"mail-index-private.h\"\n#include \"mail-index-alloc-cache.h\"\n#include \"mailbox-tree.h\"\n#include \"mailbox-list-private.h\"\n#include \"mail-storage-private.h\"\n#include \"mail-storage-settings.h\"\n#include \"mail-namespace.h\"\n#include \"mail-search.h\"\n#include \"mail-search-register.h\"\n#include \"mail-search-mime-register.h\"\n#include \"mailbox-search-result-private.h\"\n#include \"mailbox-guid-cache.h\"\n#include \"mail-cache.h\"\n\n#include <ctype.h>\n\n#define MAILBOX_DELETE_RETRY_SECS 30\n#define MAILBOX_MAX_HIERARCHY_NAME_LENGTH 255\n\nextern struct mail_search_register *mail_search_register_imap;\nextern struct mail_search_register *mail_search_register_human;\n\nstruct event_category event_category_storage = {\n\t.name = \"storage\",\n};\nstruct event_category event_category_mailbox = {\n\t.parent = &event_category_storage,\n\t.name = \"mailbox\",\n};\nstruct event_category event_category_mail = {\n\t.parent = &event_category_mailbox,\n\t.name = \"mail\",\n};\n\nstruct mail_storage_module_register mail_storage_module_register = { 0 };\nstruct mail_module_register mail_module_register = { 0 };\n\nstruct mail_storage_mail_index_module mail_storage_mail_index_module =\n\tMODULE_CONTEXT_INIT(&mail_index_module_register);\nARRAY_TYPE(mail_storage) mail_storage_classes;\n\nstatic int mail_storage_init_refcount = 0;\n\nvoid mail_storage_init(void)\n{\n\tif (mail_storage_init_refcount++ > 0)\n\t\treturn;\n\tdsasl_clients_init();\n\tmailbox_attributes_init();\n\tmailbox_lists_init();\n\tmail_storage_hooks_init();\n\ti_array_init(&mail_storage_classes, 8);\n\tmail_storage_register_all();\n\tmailbox_list_register_all();\n}\n\nvoid mail_storage_deinit(void)\n{\n\ti_assert(mail_storage_init_refcount > 0);\n\tif (--mail_storage_init_refcount > 0)\n\t\treturn;\n\tif (mail_search_register_human != NULL)\n\t\tmail_search_register_deinit(&mail_search_register_human);\n\tif (mail_search_register_imap != NULL)\n\t\tmail_search_register_deinit(&mail_search_register_imap);\n\tmail_search_mime_register_deinit();\n\tif (array_is_created(&mail_storage_classes))\n\t\tarray_free(&mail_storage_classes);\n\tmail_storage_hooks_deinit();\n\tmailbox_lists_deinit();\n\tmailbox_attributes_deinit();\n\tdsasl_clients_deinit();\n}\n\nvoid mail_storage_class_register(struct mail_storage *storage_class)\n{\n\ti_assert(mail_storage_find_class(storage_class->name) == NULL);\n\n\t/* append it after the list, so the autodetection order is correct */\n\tarray_push_back(&mail_storage_classes, &storage_class);\n}\n\nvoid mail_storage_class_unregister(struct mail_storage *storage_class)\n{\n\tstruct mail_storage *const *classes;\n\tunsigned int i, count;\n\n\tclasses = array_get(&mail_storage_classes, &count);\n\tfor (i = 0; i < count; i++) {\n\t\tif (classes[i] == storage_class) {\n\t\t\tarray_delete(&mail_storage_classes, i, 1);\n\t\t\tbreak;\n\t\t}\n\t}\n}\n\nstruct mail_storage *mail_storage_find_class(const char *name)\n{\n\tstruct mail_storage *const *classes;\n\tunsigned int i, count;\n\n\ti_assert(name != NULL);\n\n\tclasses = array_get(&mail_storage_classes, &count);\n\tfor (i = 0; i < count; i++) {\n\t\tif (strcasecmp(classes[i]->name, name) == 0)\n\t\t\treturn classes[i];\n\t}\n\treturn NULL;\n}\n\nstatic struct mail_storage *\nmail_storage_autodetect(const struct mail_namespace *ns,\n\t\t\tstruct mailbox_list_settings *set)\n{\n\tstruct mail_storage *const *classes;\n\tunsigned int i, count;\n\n\tclasses = array_get(&mail_storage_classes, &count);\n\tfor (i = 0; i < count; i++) {\n\t\tif (classes[i]->v.autodetect != NULL) {\n\t\t\tif (classes[i]->v.autodetect(ns, set))\n\t\t\t\treturn classes[i];\n\t\t}\n\t}\n\treturn NULL;\n}\n\nstatic void\nmail_storage_set_autodetection(const char **data, const char **driver)\n{\n\tconst char *p;\n\n\t/* check if data is in driver:data format (eg. mbox:~/mail) */\n\tp = *data;\n\twhile (i_isalnum(*p) || *p == '_') p++;\n\n\tif (*p == ':' && p != *data) {\n\t\t/* no autodetection if the storage driver is given. */\n\t\t*driver = t_strdup_until(*data, p);\n\t\t*data = p + 1;\n\t}\n}\n\nstatic struct mail_storage *\nmail_storage_get_class(struct mail_namespace *ns, const char *driver,\n\t\t       struct mailbox_list_settings *list_set,\n\t\t       enum mail_storage_flags flags, const char **error_r)\n{\n\tstruct mail_storage *storage_class = NULL;\n\tconst char *home;\n\n\tif (driver == NULL) {\n\t\t/* no mail_location, autodetect */\n\t} else if (strcmp(driver, \"auto\") == 0) {\n\t\t/* explicit autodetection with \"auto\" driver. */\n\t\tif (list_set->root_dir != NULL &&\n\t\t    *list_set->root_dir == '\\0') {\n\t\t\t/* handle the same as with driver=NULL */\n\t\t\tlist_set->root_dir = NULL;\n\t\t}\n\t} else {\n\t\tstorage_class = mail_user_get_storage_class(ns->user, driver);\n\t\tif (storage_class == NULL) {\n\t\t\t*error_r = t_strdup_printf(\n\t\t\t\t\"Unknown mail storage driver %s\", driver);\n\t\t\treturn NULL;\n\t\t}\n\t}\n\n\tif (list_set->root_dir == NULL || *list_set->root_dir == '\\0') {\n\t\t/* no root directory given. is this allowed? */\n\t\tconst struct mailbox_list *list;\n\n\t\tlist = list_set->layout == NULL ? NULL :\n\t\t\tmailbox_list_find_class(list_set->layout);\n\t\tif (storage_class == NULL &&\n\t\t    (flags & MAIL_STORAGE_FLAG_NO_AUTODETECTION) == 0) {\n\t\t\t/* autodetection should take care of this */\n\t\t} else if (storage_class != NULL &&\n\t\t\t   (storage_class->class_flags & MAIL_STORAGE_CLASS_FLAG_NO_ROOT) != 0) {\n\t\t\t/* root not required for this storage */\n\t\t} else if (list != NULL &&\n\t\t\t   (list->props & MAILBOX_LIST_PROP_NO_ROOT) != 0) {\n\t\t\t/* root not required for this layout */\n\t\t} else {\n\t\t\t*error_r = \"Root mail directory not given\";\n\t\t\treturn NULL;\n\t\t}\n\t}\n\n\tif (storage_class != NULL) {\n\t\tstorage_class->v.get_list_settings(ns, list_set);\n\t\treturn storage_class;\n\t}\n\n\tstorage_class = mail_storage_autodetect(ns, list_set);\n\tif (storage_class != NULL)\n\t\treturn storage_class;\n\n\t(void)mail_user_get_home(ns->user, &home);\n\tif (home == NULL || *home == '\\0') home = \"(not set)\";\n\n\tif (ns->set->location == NULL || *ns->set->location == '\\0') {\n\t\t*error_r = t_strdup_printf(\n\t\t\t\"Mail storage autodetection failed with home=%s\", home);\n\t} else if (str_begins(ns->set->location, \"auto:\")) {\n\t\t*error_r = t_strdup_printf(\n\t\t\t\"Autodetection failed for %s (home=%s)\",\n\t\t\tns->set->location, home);\n\t} else {\n\t\t*error_r = t_strdup_printf(\n\t\t\t\"Ambiguous mail location setting, \"\n\t\t\t\"don't know what to do with it: %s \"\n\t\t\t\"(try prefixing it with mbox: or maildir:)\",\n\t\t\tns->set->location);\n\t}\n\treturn NULL;\n}\n\nstatic int\nmail_storage_verify_root(const char *root_dir, const char *dir_type,\n\t\t\t const char **error_r)\n{\n\tstruct stat st;\n\n\tif (stat(root_dir, &st) == 0) {\n\t\t/* exists */\n\t\tif (S_ISDIR(st.st_mode))\n\t\t\treturn 0;\n\t\t*error_r = t_strdup_printf(\n\t\t\t\"Root mail directory is a file: %s\", root_dir);\n\t\treturn -1;\n\t} else if (errno == EACCES) {\n\t\t*error_r = mail_error_eacces_msg(\"stat\", root_dir);\n\t\treturn -1;\n\t} else if (errno != ENOENT) {\n\t\t*error_r = t_strdup_printf(\"stat(%s) failed: %m\", root_dir);\n\t\treturn -1;\n\t} else {\n\t\t*error_r = t_strdup_printf(\n\t\t\t\"Root %s directory doesn't exist: %s\", dir_type, root_dir);\n\t\treturn -1;\n\t}\n}\n\nstatic int\nmail_storage_create_root(struct mailbox_list *list,\n\t\t\t enum mail_storage_flags flags, const char **error_r)\n{\n\tconst char *root_dir, *type_name, *error;\n\tenum mailbox_list_path_type type;\n\n\tif (list->set.iter_from_index_dir) {\n\t\ttype = MAILBOX_LIST_PATH_TYPE_INDEX;\n\t\ttype_name = \"index\";\n\t} else {\n\t\ttype = MAILBOX_LIST_PATH_TYPE_MAILBOX;\n\t\ttype_name = \"mail\";\n\t}\n\tif (!mailbox_list_get_root_path(list, type, &root_dir)) {\n\t\t/* storage doesn't use directories (e.g. shared root) */\n\t\treturn 0;\n\t}\n\n\tif ((flags & MAIL_STORAGE_FLAG_NO_AUTOVERIFY) != 0) {\n\t\tif (!event_want_debug_log(list->ns->user->event))\n\t\t\treturn 0;\n\n\t\t/* we don't need to verify, but since debugging is\n\t\t   enabled, check and log if the root doesn't exist */\n\t\tif (mail_storage_verify_root(root_dir, type_name, &error) < 0) {\n\t\t\te_debug(list->ns->user->event,\n\t\t\t\t\"Namespace %s: Creating storage despite: %s\",\n\t\t\t\tlist->ns->prefix, error);\n\t\t}\n\t\treturn 0;\n\t}\n\n\tif ((flags & MAIL_STORAGE_FLAG_NO_AUTOCREATE) == 0) {\n\t\t/* If the directories don't exist, we'll just autocreate them\n\t\t   later. */\n\t\treturn 0;\n\t}\n\treturn mail_storage_verify_root(root_dir, type_name, error_r);\n}\n\nstatic bool\nmail_storage_match_class(struct mail_storage *storage,\n\t\t\t const struct mail_storage *storage_class,\n\t\t\t const struct mailbox_list_settings *set)\n{\n\tif (strcmp(storage->name, storage_class->name) != 0)\n\t\treturn FALSE;\n\n\tif ((storage->class_flags & MAIL_STORAGE_CLASS_FLAG_UNIQUE_ROOT) != 0 &&\n\t    strcmp(storage->unique_root_dir,\n\t    \t(set->root_dir != NULL ? set->root_dir : \"\")) != 0)\n\t\treturn FALSE;\n\n\tif (strcmp(storage->name, \"shared\") == 0) {\n\t\t/* allow multiple independent shared namespaces */\n\t\treturn FALSE;\n\t}\n\treturn TRUE;\n}\n\nstatic struct mail_storage *\nmail_storage_find(struct mail_user *user,\n\t\t  const struct mail_storage *storage_class,\n\t\t  const struct mailbox_list_settings *set)\n{\n\tstruct mail_storage *storage = user->storages;\n\n\tfor (; storage != NULL; storage = storage->next) {\n\t\tif (mail_storage_match_class(storage, storage_class, set))\n\t\t\treturn storage;\n\t}\n\treturn NULL;\n}\n\nint mail_storage_create_full(struct mail_namespace *ns, const char *driver,\n\t\t\t     const char *data, enum mail_storage_flags flags,\n\t\t\t     struct mail_storage **storage_r,\n\t\t\t     const char **error_r)\n{\n\tstruct mail_storage *storage_class, *storage = NULL;\n\tstruct mailbox_list *list;\n\tstruct mailbox_list_settings list_set;\n\tenum mailbox_list_flags list_flags = 0;\n\tconst char *p;\n\n\tif ((flags & MAIL_STORAGE_FLAG_KEEP_HEADER_MD5) == 0 &&\n\t    ns->mail_set->pop3_uidl_format != NULL) {\n\t\t/* if pop3_uidl_format contains %m, we want to keep the\n\t\t   header MD5 sums stored even if we're not running POP3\n\t\t   right now. */\n\t\tp = ns->mail_set->pop3_uidl_format;\n\t\twhile ((p = strchr(p, '%')) != NULL) {\n\t\t\tif (p[1] == '%')\n\t\t\t\tp += 2;\n\t\t\telse if (var_get_key(++p) == 'm') {\n\t\t\t\tflags |= MAIL_STORAGE_FLAG_KEEP_HEADER_MD5;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\tmailbox_list_settings_init_defaults(&list_set);\n\tif (data == NULL) {\n\t\t/* autodetect */\n\t} else if (driver != NULL && strcmp(driver, \"shared\") == 0) {\n\t\t/* internal shared namespace */\n\t\tlist_set.root_dir = ns->user->set->base_dir;\n\t} else {\n\t\tif (driver == NULL)\n\t\t\tmail_storage_set_autodetection(&data, &driver);\n\t\tif (mailbox_list_settings_parse(ns->user, data, &list_set,\n\t\t\t\t\t\terror_r) < 0)\n\t\t\treturn -1;\n\t}\n\n\tstorage_class = mail_storage_get_class(ns, driver, &list_set, flags,\n\t\t\t\t\t       error_r);\n\tif (storage_class == NULL)\n\t\treturn -1;\n\ti_assert(list_set.layout != NULL);\n\n\tif (ns->list == NULL) {\n\t\t/* first storage for namespace */\n\t\tif (mail_storage_is_mailbox_file(storage_class))\n\t\t\tlist_flags |= MAILBOX_LIST_FLAG_MAILBOX_FILES;\n\t\tif ((storage_class->class_flags & MAIL_STORAGE_CLASS_FLAG_NO_ROOT) != 0)\n\t\t\tlist_flags |= MAILBOX_LIST_FLAG_NO_MAIL_FILES;\n\t\tif ((storage_class->class_flags & MAIL_STORAGE_CLASS_FLAG_NO_LIST_DELETES) != 0)\n\t\t\tlist_flags |= MAILBOX_LIST_FLAG_NO_DELETES;\n\t\tif (mailbox_list_create(list_set.layout, ns, &list_set,\n\t\t\t\t\tlist_flags, &list, error_r) < 0) {\n\t\t\t*error_r = t_strdup_printf(\"Mailbox list driver %s: %s\",\n\t\t\t\t\t\t   list_set.layout, *error_r);\n\t\t\treturn -1;\n\t\t}\n\t\tif ((storage_class->class_flags & MAIL_STORAGE_CLASS_FLAG_NO_ROOT) == 0) {\n\t\t\tif (mail_storage_create_root(ns->list, flags, error_r) < 0)\n\t\t\t\treturn -1;\n\t\t}\n\t}\n\n\tstorage = mail_storage_find(ns->user, storage_class, &list_set);\n\tif (storage != NULL) {\n\t\t/* using an existing storage */\n\t\tstorage->refcount++;\n\t\tmail_namespace_add_storage(ns, storage);\n\t\t*storage_r = storage;\n\t\treturn 0;\n\t}\n\n\tstorage = storage_class->v.alloc();\n\tstorage->refcount = 1;\n\tstorage->storage_class = storage_class;\n\tstorage->user = ns->user;\n\tstorage->set = ns->mail_set;\n\tstorage->flags = flags;\n\tstorage->event = event_create(ns->user->event);\n\tif (storage_class->event_category != NULL)\n\t\tevent_add_category(storage->event, storage_class->event_category);\n\tp_array_init(&storage->module_contexts, storage->pool, 5);\n\n\tif (storage->v.create != NULL &&\n\t    storage->v.create(storage, ns, error_r) < 0) {\n\t\t*error_r = t_strdup_printf(\"%s: %s\", storage->name, *error_r);\n\t\tevent_unref(&storage->event);\n\t\tpool_unref(&storage->pool);\n\t\treturn -1;\n\t}\n\n\tT_BEGIN {\n\t\thook_mail_storage_created(storage);\n\t} T_END;\n\n\ti_assert(storage->unique_root_dir != NULL ||\n\t\t (storage->class_flags & MAIL_STORAGE_CLASS_FLAG_UNIQUE_ROOT) == 0);\n\tDLLIST_PREPEND(&ns->user->storages, storage);\n\tmail_namespace_add_storage(ns, storage);\n\t*storage_r = storage;\n\treturn 0;\n}\n\nint mail_storage_create(struct mail_namespace *ns, const char *driver,\n\t\t\tenum mail_storage_flags flags, const char **error_r)\n{\n\tstruct mail_storage *storage;\n\n\treturn mail_storage_create_full(ns, driver, ns->set->location,\n\t\t\t\t\tflags, &storage, error_r);\n}\n\nvoid mail_storage_unref(struct mail_storage **_storage)\n{\n\tstruct mail_storage *storage = *_storage;\n\n\ti_assert(storage->refcount > 0);\n\n\t/* set *_storage=NULL only after calling destroy() callback.\n\t   for example mdbox wants to access ns->storage */\n\tif (--storage->refcount > 0) {\n\t\t*_storage = NULL;\n\t\treturn;\n\t}\n\n\tif (storage->mailboxes != NULL) {\n\t\ti_panic(\"Trying to deinit storage without freeing mailbox %s\",\n\t\t\tstorage->mailboxes->vname);\n\t}\n\tif (storage->obj_refcount != 0)\n\t\ti_panic(\"Trying to deinit storage before freeing its objects\");\n\n\tDLLIST_REMOVE(&storage->user->storages, storage);\n\n\tstorage->v.destroy(storage);\n\ti_free(storage->last_internal_error);\n\ti_free(storage->error_string);\n\tif (array_is_created(&storage->error_stack)) {\n\t\ti_assert(array_count(&storage->error_stack) == 0);\n\t\tarray_free(&storage->error_stack);\n\t}\n\tevent_unref(&storage->event);\n\n\t*_storage = NULL;\n\tpool_unref(&storage->pool);\n\n\tmail_index_alloc_cache_destroy_unrefed();\n}\n\nvoid mail_storage_obj_ref(struct mail_storage *storage)\n{\n\ti_assert(storage->refcount > 0);\n\n\tif (storage->obj_refcount++ == 0)\n\t\tmail_user_ref(storage->user);\n}\n\nvoid mail_storage_obj_unref(struct mail_storage *storage)\n{\n\ti_assert(storage->refcount > 0);\n\ti_assert(storage->obj_refcount > 0);\n\n\tif (--storage->obj_refcount == 0) {\n\t\tstruct mail_user *user = storage->user;\n\t\tmail_user_unref(&user);\n\t}\n}\n\nvoid mail_storage_clear_error(struct mail_storage *storage)\n{\n\ti_free_and_null(storage->error_string);\n\n\ti_free(storage->last_internal_error);\n\tstorage->last_error_is_internal = FALSE;\n\tstorage->error = MAIL_ERROR_NONE;\n}\n\nvoid mail_storage_set_error(struct mail_storage *storage,\n\t\t\t    enum mail_error error, const char *string)\n{\n\tif (storage->error_string != string) {\n\t\ti_free(storage->error_string);\n\t\tstorage->error_string = i_strdup(string);\n\t}\n\tstorage->last_error_is_internal = FALSE;\n\tstorage->error = error;\n}\n\nvoid mail_storage_set_internal_error(struct mail_storage *storage)\n{\n\tconst char *str;\n\n\tstr = t_strflocaltime(MAIL_ERRSTR_CRITICAL_MSG_STAMP, ioloop_time);\n\n\ti_free(storage->error_string);\n\tstorage->error_string = i_strdup(str);\n\tstorage->error = MAIL_ERROR_TEMP;\n\n\t/* this function doesn't set last_internal_error, so\n\t   last_error_is_internal can't be TRUE. */\n\tstorage->last_error_is_internal = FALSE;\n\ti_free(storage->last_internal_error);\n}\n\nvoid mail_storage_set_critical(struct mail_storage *storage,\n\t\t\t       const char *fmt, ...)\n{\n\tchar *old_error = storage->error_string;\n\tchar *old_internal_error = storage->last_internal_error;\n\tva_list va;\n\n\tstorage->error_string = NULL;\n\tstorage->last_internal_error = NULL;\n\t/* critical errors may contain sensitive data, so let user\n\t   see only \"Internal error\" with a timestamp to make it\n\t   easier to look from log files the actual error message. */\n\tmail_storage_set_internal_error(storage);\n\n\tva_start(va, fmt);\n\tstorage->last_internal_error = i_strdup_vprintf(fmt, va);\n\tva_end(va);\n\tstorage->last_error_is_internal = TRUE;\n\te_error(storage->event, \"%s\", storage->last_internal_error);\n\n\t/* free the old_error and old_internal_error only after the new error\n\t   is generated, because they may be one of the parameters. */\n\ti_free(old_error);\n\ti_free(old_internal_error);\n}\n\nvoid mailbox_set_critical(struct mailbox *box, const char *fmt, ...)\n{\n\tva_list va;\n\n\tva_start(va, fmt);\n\tT_BEGIN {\n\t\tmail_storage_set_critical(box->storage, \"Mailbox %s: %s\",\n\t\t\tbox->vname, t_strdup_vprintf(fmt, va));\n\t} T_END;\n\tva_end(va);\n}\n\nvoid mail_set_critical(struct mail *mail, const char *fmt, ...)\n{\n\tva_list va;\n\n\tva_start(va, fmt);\n\tT_BEGIN {\n\t\tif (mail->saving) {\n\t\t\tmailbox_set_critical(mail->box, \"Saving mail: %s\",\n\t\t\t\tt_strdup_vprintf(fmt, va));\n\t\t} else {\n\t\t\tmailbox_set_critical(mail->box, \"UID=%u: %s\",\n\t\t\t\tmail->uid, t_strdup_vprintf(fmt, va));\n\t\t}\n\t} T_END;\n\tva_end(va);\n}\n\nconst char *mail_storage_get_last_internal_error(struct mail_storage *storage,\n\t\t\t\t\t\t enum mail_error *error_r)\n{\n\tif (error_r != NULL)\n\t\t*error_r = storage->error;\n\tif (storage->last_error_is_internal) {\n\t\ti_assert(storage->last_internal_error != NULL);\n\t\treturn storage->last_internal_error;\n\t}\n\treturn mail_storage_get_last_error(storage, error_r);\n}\n\nconst char *mailbox_get_last_internal_error(struct mailbox *box,\n\t\t\t\t\t    enum mail_error *error_r)\n{\n\treturn mail_storage_get_last_internal_error(mailbox_get_storage(box),\n\t\t\t\t\t\t    error_r);\n}\n\nvoid mail_storage_copy_error(struct mail_storage *dest,\n\t\t\t     struct mail_storage *src)\n{\n\tconst char *str;\n\tenum mail_error error;\n\n\tif (src == dest)\n\t\treturn;\n\n\tstr = mail_storage_get_last_error(src, &error);\n\tmail_storage_set_error(dest, error, str);\n}\n\nvoid mail_storage_copy_list_error(struct mail_storage *storage,\n\t\t\t\t  struct mailbox_list *list)\n{\n\tconst char *str;\n\tenum mail_error error;\n\n\tstr = mailbox_list_get_last_error(list, &error);\n\tmail_storage_set_error(storage, error, str);\n}\n\nvoid mailbox_set_index_error(struct mailbox *box)\n{\n\tif (mail_index_is_deleted(box->index)) {\n\t\tmailbox_set_deleted(box);\n\t\tmail_index_reset_error(box->index);\n\t} else {\n\t\tmail_storage_set_index_error(box->storage, box->index);\n\t}\n}\n\nvoid mail_storage_set_index_error(struct mail_storage *storage,\n\t\t\t\t  struct mail_index *index)\n{\n\tconst char *index_error;\n\n\tmail_storage_set_internal_error(storage);\n\t/* use the lib-index's error as our internal error string */\n\tindex_error = mail_index_get_error_message(index);\n\tif (index_error == NULL)\n\t\tindex_error = \"BUG: Unknown internal index error\";\n\tstorage->last_internal_error = i_strdup(index_error);\n\tstorage->last_error_is_internal = TRUE;\n\tmail_index_reset_error(index);\n}\n\nconst struct mail_storage_settings *\nmail_storage_get_settings(struct mail_storage *storage)\n{\n\treturn storage->set;\n}\n\nstruct mail_user *mail_storage_get_user(struct mail_storage *storage)\n{\n\treturn storage->user;\n}\n\nvoid mail_storage_set_callbacks(struct mail_storage *storage,\n\t\t\t\tstruct mail_storage_callbacks *callbacks,\n\t\t\t\tvoid *context)\n{\n\tstorage->callbacks = *callbacks;\n\tstorage->callback_context = context;\n}\n\nint mail_storage_purge(struct mail_storage *storage)\n{\n\treturn storage->v.purge == NULL ? 0 :\n\t\tstorage->v.purge(storage);\n}\n\nconst char *mail_storage_get_last_error(struct mail_storage *storage,\n\t\t\t\t\tenum mail_error *error_r)\n{\n\t/* We get here only in error situations, so we have to return some\n\t   error. If storage->error is NONE, it means we forgot to set it at\n\t   some point.. */\n\tif (storage->error == MAIL_ERROR_NONE) {\n\t\tif (error_r != NULL)\n\t\t\t*error_r = MAIL_ERROR_TEMP;\n\t\treturn storage->error_string != NULL ? storage->error_string :\n\t\t\t\"BUG: Unknown internal error\";\n\t}\n\n\tif (storage->error_string == NULL) {\n\t\t/* This shouldn't happen.. */\n\t\tstorage->error_string =\n\t\t\ti_strdup_printf(\"BUG: Unknown 0x%x error\",\n\t\t\t\t\tstorage->error);\n\t}\n\n\tif (error_r != NULL)\n\t\t*error_r = storage->error;\n\treturn storage->error_string;\n}\n\nconst char *mailbox_get_last_error(struct mailbox *box,\n\t\t\t\t   enum mail_error *error_r)\n{\n\treturn mail_storage_get_last_error(box->storage, error_r);\n}\n\nenum mail_error mailbox_get_last_mail_error(struct mailbox *box)\n{\n\tenum mail_error error;\n\n\tmail_storage_get_last_error(box->storage, &error);\n\treturn error;\n}\n\nvoid mail_storage_last_error_push(struct mail_storage *storage)\n{\n\tstruct mail_storage_error *err;\n\n\tif (!array_is_created(&storage->error_stack))\n\t\ti_array_init(&storage->error_stack, 2);\n\terr = array_append_space(&storage->error_stack);\n\terr->error_string = i_strdup(storage->error_string);\n\terr->error = storage->error;\n\terr->last_error_is_internal = storage->last_error_is_internal;\n\tif (err->last_error_is_internal)\n\t\terr->last_internal_error = i_strdup(storage->last_internal_error);\n}\n\nvoid mail_storage_last_error_pop(struct mail_storage *storage)\n{\n\tunsigned int count = array_count(&storage->error_stack);\n\tconst struct mail_storage_error *err =\n\t\tarray_idx(&storage->error_stack, count-1);\n\n\ti_free(storage->error_string);\n\ti_free(storage->last_internal_error);\n\tstorage->error_string = err->error_string;\n\tstorage->error = err->error;\n\tstorage->last_error_is_internal = err->last_error_is_internal;\n\tstorage->last_internal_error = err->last_internal_error;\n\tarray_delete(&storage->error_stack, count-1, 1);\n}\n\nbool mail_storage_is_mailbox_file(struct mail_storage *storage)\n{\n\treturn (storage->class_flags &\n\t\tMAIL_STORAGE_CLASS_FLAG_MAILBOX_IS_FILE) != 0;\n}\n\nbool mail_storage_set_error_from_errno(struct mail_storage *storage)\n{\n\tconst char *error_string;\n\tenum mail_error error;\n\n\tif (!mail_error_from_errno(&error, &error_string))\n\t\treturn FALSE;\n\tif (event_want_debug_log(storage->event) && error != MAIL_ERROR_NOTFOUND) {\n\t\t/* debugging is enabled - admin may be debugging a\n\t\t   (permission) problem, so return FALSE to get the caller to\n\t\t   log the full error message. */\n\t\treturn FALSE;\n\t}\n\n\tmail_storage_set_error(storage, error, error_string);\n\treturn TRUE;\n}\n\nconst struct mailbox_settings *\nmailbox_settings_find(struct mail_namespace *ns, const char *vname)\n{\n\tstruct mailbox_settings *const *box_set;\n\n\tif (!array_is_created(&ns->set->mailboxes))\n\t\treturn NULL;\n\n\tif (ns->prefix_len > 0 &&\n\t    strncmp(ns->prefix, vname, ns->prefix_len-1) == 0) {\n\t\tif (vname[ns->prefix_len-1] == mail_namespace_get_sep(ns))\n\t\t\tvname += ns->prefix_len;\n\t\telse if (vname[ns->prefix_len-1] == '\\0') {\n\t\t\t/* namespace prefix itself */\n\t\t\tvname = \"\";\n\t\t}\n\t}\n\tarray_foreach(&ns->set->mailboxes, box_set) {\n\t\tif (strcmp((*box_set)->name, vname) == 0)\n\t\t\treturn *box_set;\n\t}\n\treturn NULL;\n}\n\nstruct mailbox *mailbox_alloc(struct mailbox_list *list, const char *vname,\n\t\t\t      enum mailbox_flags flags)\n{\n\tstruct mailbox_list *new_list = list;\n\tstruct mail_storage *storage;\n\tstruct mailbox *box;\n\tenum mail_error open_error = 0;\n\tconst char *errstr = NULL;\n\n\ti_assert(uni_utf8_str_is_valid(vname));\n\n\tif (strncasecmp(vname, \"INBOX\", 5) == 0 &&\n\t    !str_begins(vname, \"INBOX\")) {\n\t\t/* make sure INBOX shows up in uppercase everywhere. do this\n\t\t   regardless of whether we're in inbox=yes namespace, because\n\t\t   clients expect INBOX to be case insensitive regardless of\n\t\t   server's internal configuration. */\n\t\tif (vname[5] == '\\0')\n\t\t\tvname = \"INBOX\";\n\t\telse if (vname[5] != mail_namespace_get_sep(list->ns))\n\t\t\t/* not INBOX prefix */ ;\n\t\telse if (strncasecmp(list->ns->prefix, vname, 6) == 0 &&\n\t\t\t !str_begins(list->ns->prefix, \"INBOX\")) {\n\t\t\tmailbox_list_set_critical(list,\n\t\t\t\t\"Invalid server configuration: \"\n\t\t\t\t\"Namespace prefix=%s must be uppercase INBOX\",\n\t\t\t\tlist->ns->prefix);\n\t\t\topen_error = MAIL_ERROR_TEMP;\n\t\t} else {\n\t\t\tvname = t_strconcat(\"INBOX\", vname + 5, NULL);\n\t\t}\n\t}\n\n\tT_BEGIN {\n\t\tif (mailbox_list_get_storage(&new_list, vname, &storage) < 0) {\n\t\t\t/* do a delayed failure at mailbox_open() */\n\t\t\tstorage = mail_namespace_get_default_storage(list->ns);\n\t\t\terrstr = mailbox_list_get_last_error(new_list, &open_error);\n\t\t\terrstr = t_strdup(errstr);\n\t\t}\n\n\t\tbox = storage->v.mailbox_alloc(storage, new_list, vname, flags);\n\t\tbox->set = mailbox_settings_find(new_list->ns, vname);\n\t\tbox->open_error = open_error;\n\t\tif (open_error != 0)\n\t\t\tmail_storage_set_error(storage, open_error, errstr);\n\t\thook_mailbox_allocated(box);\n\t} T_END;\n\n\tDLLIST_PREPEND(&box->storage->mailboxes, box);\n\tmail_storage_obj_ref(box->storage);\n\treturn box;\n}\n\nstruct mailbox *mailbox_alloc_guid(struct mailbox_list *list,\n\t\t\t\t   const guid_128_t guid,\n\t\t\t\t   enum mailbox_flags flags)\n{\n\tstruct mailbox *box = NULL;\n\tstruct mailbox_metadata metadata;\n\tenum mail_error open_error = MAIL_ERROR_TEMP;\n\tconst char *vname;\n\n\tif (mailbox_guid_cache_find(list, guid, &vname) < 0) {\n\t\tvname = NULL;\n\t} else if (vname != NULL) {\n\t\tbox = mailbox_alloc(list, vname, flags);\n\t\tif (mailbox_get_metadata(box, MAILBOX_METADATA_GUID,\n\t\t\t\t\t &metadata) < 0) {\n\t\t} else if (memcmp(metadata.guid, guid,\n\t\t\t\t  sizeof(metadata.guid)) != 0) {\n\t\t\t/* GUID mismatch, refresh cache and try again */\n\t\t\tmailbox_free(&box);\n\t\t\tmailbox_guid_cache_refresh(list);\n\t\t\treturn mailbox_alloc_guid(list, guid, flags);\n\t\t} else {\n\t\t\t/* successfully opened the correct mailbox */\n\t\t\treturn box;\n\t\t}\n\t\ti_error(\"mailbox_alloc_guid(%s): \"\n\t\t\t\"Couldn't verify mailbox GUID: %s\",\n\t\t\tguid_128_to_string(guid),\n\t\t\tmailbox_get_last_internal_error(box, NULL));\n\t\tvname = NULL;\n\t\tmailbox_free(&box);\n\t} else {\n\t\tvname = t_strdup_printf(\"(nonexistent mailbox with GUID=%s)\",\n\t\t\t\t\tguid_128_to_string(guid));\n\t\topen_error = MAIL_ERROR_NOTFOUND;\n\t}\n\n\tif (vname == NULL) {\n\t\tvname = t_strdup_printf(\"(error in mailbox with GUID=%s)\",\n\t\t\t\t\tguid_128_to_string(guid));\n\t}\n\tbox = mailbox_alloc(list, vname, flags);\n\tbox->open_error = open_error;\n\treturn box;\n}\n\nstatic bool\nstr_contains_special_use(const char *str, const char *special_use)\n{\n\tconst char *const *uses;\n\n\ti_assert(special_use != NULL);\n\tif (*special_use != '\\\\')\n\t\treturn FALSE;\n\n\tuses = t_strsplit_spaces(str, \" \");\n\treturn str_array_icase_find(uses, special_use);\n}\n\nstatic int\nnamespace_find_special_use(struct mail_namespace *ns, const char *special_use,\n\t\t           const char **vname_r, enum mail_error *error_code_r)\n{\n\tstruct mailbox_list *list = ns->list;\n\tstruct mailbox_list_iterate_context *ctx;\n\tconst struct mailbox_info *info;\n\tint ret = 0;\n\n\t*vname_r = NULL;\n\t*error_code_r = MAIL_ERROR_NONE;\n\n\tif (!ns->special_use_mailboxes)\n\t\treturn 0;\n\tif (!HAS_ALL_BITS(ns->type, MAIL_NAMESPACE_TYPE_PRIVATE))\n\t\treturn 0;\n\n\tctx = mailbox_list_iter_init(list, \"*\",\n\t\tMAILBOX_LIST_ITER_SELECT_SPECIALUSE |\n\t\tMAILBOX_LIST_ITER_RETURN_SPECIALUSE);\n\twhile ((info = mailbox_list_iter_next(ctx)) != NULL) {\n\t\tif ((info->flags &\n\t\t     (MAILBOX_NOSELECT | MAILBOX_NONEXISTENT)) != 0)\n\t\t\tcontinue;\n\t\t/* iter can only return mailboxes that have non-empty\n\t\t   special-use */\n\t\ti_assert(info->special_use != NULL &&\n\t\t\t *info->special_use != '\\0');\n\n\t\tif (str_contains_special_use(info->special_use, special_use)) {\n\t\t\t*vname_r = t_strdup(info->vname);\n\t\t\tret = 1;\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (mailbox_list_iter_deinit(&ctx) < 0) {\n\t\tconst char *error;\n\n\t\terror = mailbox_list_get_last_error(ns->list, error_code_r);\n\t\te_error(ns->user->event,\n\t\t\t\"Failed to find mailbox with SPECIAL-USE flag '%s' \"\n\t\t\t\"in namespace '%s': %s\",\n\t\t\tspecial_use, ns->prefix, error);\n\t\treturn -1;\n\t}\n\treturn ret;\n}\n\nstatic int\nnamespaces_find_special_use(struct mail_namespace *namespaces,\n\t\t\t    const char *special_use,\n\t\t\t    struct mail_namespace **ns_r,\n\t\t\t    const char **vname_r, enum mail_error *error_code_r)\n{\n\tstruct mail_namespace *ns_inbox;\n\tint ret;\n\n\t*error_code_r = MAIL_ERROR_NONE;\n\t*vname_r = NULL;\n\n\t/* check user's INBOX namespace first */\n\t*ns_r = ns_inbox = mail_namespace_find_inbox(namespaces);\n\tret = namespace_find_special_use(*ns_r, special_use,\n\t\t\t\t\t vname_r, error_code_r);\n\tif (ret != 0)\n\t\treturn ret;\n\n\t/* check other namespaces */\n\tfor (*ns_r = namespaces; *ns_r != NULL; *ns_r = (*ns_r)->next) {\n\t\tif (*ns_r == ns_inbox) {\n\t\t\t/* already checked */\n\t\t\tcontinue;\n\t\t}\n\t\tret = namespace_find_special_use(*ns_r, special_use,\n\t\t\t\t\t\t vname_r, error_code_r);\n\t\tif (ret != 0)\n\t\t\treturn ret;\n\t}\n\n\t*ns_r = ns_inbox;\n\treturn 0;\n}\n\nstruct mailbox *\nmailbox_alloc_for_user(struct mail_user *user, const char *mname,\n\t\t       enum mailbox_flags flags)\n{\n\tstruct mail_namespace *ns;\n\tstruct mailbox *box;\n\tconst char *vname;\n\tenum mail_error open_error = MAIL_ERROR_NONE;\n\tint ret;\n\n\tif (HAS_ALL_BITS(flags, MAILBOX_FLAG_SPECIAL_USE)) {\n\t\tret = namespaces_find_special_use(user->namespaces, mname,\n\t\t\t\t\t\t  &ns, &vname, &open_error);\n\t\tif (ret < 0) {\n\t\t\ti_assert(open_error != MAIL_ERROR_NONE);\n\t\t\tvname = t_strdup_printf(\n\t\t\t\t\"(error finding mailbox with SPECIAL-USE=%s)\",\n\t\t\t\tmname);\n\t\t} else if (ret == 0) {\n\t\t\ti_assert(open_error == MAIL_ERROR_NONE);\n\t\t\tvname = t_strdup_printf(\n\t\t\t\t\"(nonexistent mailbox with SPECIAL-USE=%s)\",\n\t\t\t\tmname);\n\t\t\topen_error = MAIL_ERROR_NOTFOUND;\n\t\t}\n\t} else {\n\t\tvname = mname;\n\t\tns = mail_namespace_find(user->namespaces, mname);\n\t}\n\n\tif (HAS_ALL_BITS(flags, MAILBOX_FLAG_POST_SESSION)) {\n\t\tflags |= MAILBOX_FLAG_SAVEONLY;\n\n\t\tif (strcmp(vname, ns->prefix) == 0 &&\n\t\t    (ns->flags & NAMESPACE_FLAG_INBOX_USER) != 0) {\n\t\t\t/* delivering to a namespace prefix means we actually\n\t\t\t   want to deliver to the INBOX instead */\n\t\t\tvname = \"INBOX\";\n\t\t\tns = mail_namespace_find_inbox(user->namespaces);\n\t\t}\n\n\t\tif (strcasecmp(vname, \"INBOX\") == 0) {\n\t\t\t/* deliveries to INBOX must always succeed,\n\t\t\t   regardless of ACLs */\n\t\t\tflags |= MAILBOX_FLAG_IGNORE_ACLS;\n\t\t}\n\t}\n\n\ti_assert(ns != NULL);\n\tbox = mailbox_alloc(ns->list, vname, flags);\n\tif (open_error != MAIL_ERROR_NONE)\n\t\tbox->open_error = open_error;\n\treturn box;\n}\n\nvoid mailbox_set_reason(struct mailbox *box, const char *reason)\n{\n\ti_assert(reason != NULL);\n\n\tbox->reason = p_strdup(box->pool, reason);\n}\n\nbool mailbox_is_autocreated(struct mailbox *box)\n{\n\tif (box->inbox_user)\n\t\treturn TRUE;\n\tif ((box->flags & MAILBOX_FLAG_AUTO_CREATE) != 0)\n\t\treturn TRUE;\n\treturn box->set != NULL &&\n\t\tstrcmp(box->set->autocreate, MAILBOX_SET_AUTO_NO) != 0;\n}\n\nbool mailbox_is_autosubscribed(struct mailbox *box)\n{\n\tif ((box->flags & MAILBOX_FLAG_AUTO_SUBSCRIBE) != 0)\n\t\treturn TRUE;\n\treturn box->set != NULL &&\n\t\tstrcmp(box->set->autocreate, MAILBOX_SET_AUTO_SUBSCRIBE) == 0;\n}\n\nstatic int mailbox_autocreate(struct mailbox *box)\n{\n\tconst char *errstr;\n\tenum mail_error error;\n\n\tif (mailbox_create(box, NULL, FALSE) < 0) {\n\t\terrstr = mailbox_get_last_internal_error(box, &error);\n\t\tif (error == MAIL_ERROR_NOTFOUND && box->acl_no_lookup_right) {\n\t\t\t/* ACL prevents creating this mailbox */\n\t\t\treturn -1;\n\t\t}\n\t\tif (error != MAIL_ERROR_EXISTS) {\n\t\t\tmailbox_set_critical(box,\n\t\t\t\t\"Failed to autocreate mailbox: %s\",\n\t\t\t\terrstr);\n\t\t\treturn -1;\n\t\t}\n\t} else if (mailbox_is_autosubscribed(box)) {\n\t\tif (mailbox_set_subscribed(box, TRUE) < 0) {\n\t\t\tmailbox_set_critical(box,\n\t\t\t\t\"Failed to autosubscribe to mailbox: %s\",\n\t\t\t\tmailbox_get_last_internal_error(box, NULL));\n\t\t\treturn -1;\n\t\t}\n\t}\n\treturn 0;\n}\n\nstatic int mailbox_autocreate_and_reopen(struct mailbox *box)\n{\n\tint ret;\n\n\tif (mailbox_autocreate(box) < 0)\n\t\treturn -1;\n\tmailbox_close(box);\n\n\tret = box->v.open(box);\n\tif (ret < 0 && box->inbox_user && !box->acl_no_lookup_right &&\n\t    !box->storage->user->inbox_open_error_logged) {\n\t\tbox->storage->user->inbox_open_error_logged = TRUE;\n\t\tmailbox_set_critical(box,\n\t\t\t\"Opening INBOX failed: %s\",\n\t\t\tmailbox_get_last_internal_error(box, NULL));\n\t}\n\treturn ret;\n}\n\nstatic bool\nmailbox_name_verify_extra_separators(const char *vname, char sep,\n\t\t\t\t     const char **error_r)\n{\n\tunsigned int i;\n\tbool prev_sep = FALSE;\n\n\t/* Make sure the vname doesn't have extra separators:\n\n\t   1) Must not have adjacent separators. If we allow these, these could\n\t   end up pointing to existing mailboxes due to kernel ignoring\n\t   duplicate '/' in paths. However, this might cause us to handle some\n\t   of our own checks wrong, such as skipping ACLs.\n\n\t   2) Must not end with separator. Similar reasoning as above.\n\t*/\n\tfor (i = 0; vname[i] != '\\0'; i++) {\n\t\tif (vname[i] == sep) {\n\t\t\tif (prev_sep) {\n\t\t\t\t*error_r = \"Has adjacent hierarchy separators\";\n\t\t\t\treturn FALSE;\n\t\t\t}\n\t\t\tprev_sep = TRUE;\n\t\t} else {\n\t\t\tprev_sep = FALSE;\n\t\t}\n\t}\n\tif (prev_sep && i > 0) {\n\t\t*error_r = \"Ends with hierarchy separator\";\n\t\treturn FALSE;\n\t}\n\treturn TRUE;\n}\n\nstatic bool\nmailbox_verify_name_prefix(struct mail_namespace *ns, const char **vnamep,\n\t\t\t   const char **error_r)\n{\n\tconst char *vname = *vnamep;\n\n\tif (ns->prefix_len == 0)\n\t\treturn TRUE;\n\n\t/* vname is either \"namespace/box\" or \"namespace\" */\n\tif (strncmp(vname, ns->prefix, ns->prefix_len-1) != 0 ||\n\t    (vname[ns->prefix_len-1] != '\\0' &&\n\t     vname[ns->prefix_len-1] != ns->prefix[ns->prefix_len-1])) {\n\t\t/* User input shouldn't normally be able to get us in\n\t\t   here. The main reason this isn't an assert is to\n\t\t   allow any input at all to mailbox_verify_*_name()\n\t\t   without crashing. */\n\t\t*error_r = t_strdup_printf(\"Missing namespace prefix '%s'\",\n\t\t\t\t\t   ns->prefix);\n\t\treturn FALSE;\n\t}\n\tvname += ns->prefix_len - 1;\n\tif (vname[0] != '\\0') {\n\t\ti_assert(vname[0] == ns->prefix[ns->prefix_len-1]);\n\t\tvname++;\n\n\t\tif (vname[0] == '\\0') {\n\t\t\t/* \"namespace/\" isn't a valid mailbox name. */\n\t\t\t*error_r = \"Ends with hierarchy separator\";\n\t\t\treturn FALSE;\n\t\t}\n\t}\n\t*vnamep = vname;\n\treturn TRUE;\n}\n\nint mailbox_verify_name(struct mailbox *box)\n{\n\tstruct mail_namespace *ns = box->list->ns;\n\tconst char *error, *vname = box->vname;\n\tchar list_sep, ns_sep;\n\n\tif (box->inbox_user) {\n\t\t/* this is INBOX - don't bother with further checks */\n\t\treturn 0;\n\t}\n\n\t/* Verify the namespace prefix here. Change vname to skip the prefix\n\t   for the following checks. */\n\tif (!mailbox_verify_name_prefix(box->list->ns, &vname, &error)) {\n\t\tmail_storage_set_error(box->storage, MAIL_ERROR_PARAMS,\n\t\t\tt_strdup_printf(\"Invalid mailbox name '%s': %s\",\n\t\t\t\t\tstr_sanitize(vname, 80), error));\n\t\treturn -1;\n\t}\n\n\tlist_sep = mailbox_list_get_hierarchy_sep(box->list);\n\tns_sep = mail_namespace_get_sep(ns);\n\n\t/* If namespace { separator } differs from the mailbox_list separator,\n\t   the list separator can't actually be used in the mailbox name\n\t   unless it's escaped with escape_char. For example if namespace\n\t   separator is '/' and LAYOUT=Maildir++ has '.' as the separator,\n\t   there's no way to use '.' in the mailbox name (without escaping)\n\t   because it would end up becoming a hierarchy separator. */\n\tif (ns_sep != list_sep && box->list->set.escape_char == '\\0' &&\n\t    strchr(vname, list_sep) != NULL) {\n\t\tmail_storage_set_error(box->storage, MAIL_ERROR_PARAMS, t_strdup_printf(\n\t\t\t\"Character not allowed in mailbox name: '%c'\", list_sep));\n\t\treturn -1;\n\t}\n\t/* vname must not begin with the hierarchy separator normally.\n\t   For example we don't want to allow accessing /etc/passwd. However,\n\t   if mail_full_filesystem_access=yes, we do actually want to allow\n\t   that. */\n\tif (vname[0] == ns_sep &&\n\t    !box->storage->set->mail_full_filesystem_access) {\n\t\tmail_storage_set_error(box->storage, MAIL_ERROR_PARAMS,\n\t\t\t\"Invalid mailbox name: Begins with hierarchy separator\");\n\t\treturn -1;\n\t}\n\n\tif (!mailbox_name_verify_extra_separators(vname, ns_sep, &error) ||\n\t    !mailbox_list_is_valid_name(box->list, box->name, &error)) {\n\t\tmail_storage_set_error(box->storage, MAIL_ERROR_PARAMS,\n\t\t\tt_strdup_printf(\"Invalid mailbox name: %s\", error));\n\t\treturn -1;\n\t}\n\treturn 0;\n}\n\nstatic int mailbox_verify_existing_name(struct mailbox *box)\n{\n\tconst char *path;\n\n\tif (box->opened)\n\t\treturn 0;\n\n\tif (mailbox_verify_name(box) < 0)\n\t\treturn -1;\n\n\t/* Make sure box->_path is set, so mailbox_get_path() works from\n\t   now on. Note that this may also fail with some backends if the\n\t   mailbox doesn't exist. */\n\tif (mailbox_get_path_to(box, MAILBOX_LIST_PATH_TYPE_MAILBOX, &path) < 0) {\n\t\tif (box->storage->error != MAIL_ERROR_NOTFOUND ||\n\t\t    !mailbox_is_autocreated(box))\n\t\t\treturn -1;\n\t\t/* if this is an autocreated mailbox, create it now */\n\t\tif (mailbox_autocreate(box) < 0)\n\t\t\treturn -1;\n\t\tmailbox_close(box);\n\t\tif (mailbox_get_path_to(box, MAILBOX_LIST_PATH_TYPE_MAILBOX,\n\t\t\t\t\t&path) < 0)\n\t\t\treturn -1;\n\t}\n\treturn 0;\n}\n\nstatic bool mailbox_name_has_control_chars(const char *name)\n{\n\tconst char *p;\n\n\tfor (p = name; *p != '\\0'; p++) {\n\t\tif ((unsigned char)*p < ' ')\n\t\t\treturn TRUE;\n\t}\n\treturn FALSE;\n}\n\nvoid mailbox_skip_create_name_restrictions(struct mailbox *box, bool set)\n{\n\tbox->skip_create_name_restrictions = set;\n}\n\nint mailbox_verify_create_name(struct mailbox *box)\n{\n\t/* mailbox_alloc() already checks that vname is valid UTF8,\n\t   so we don't need to verify that.\n\n\t   check vname instead of storage name, because vname is what is\n\t   visible to users, while storage name may be a fixed length GUID. */\n\tif (mailbox_verify_name(box) < 0)\n\t\treturn -1;\n\tif (box->skip_create_name_restrictions)\n\t\treturn 0;\n\tif (mailbox_name_has_control_chars(box->vname)) {\n\t\tmail_storage_set_error(box->storage, MAIL_ERROR_PARAMS,\n\t\t\t\"Control characters not allowed in new mailbox names\");\n\t\treturn -1;\n\t}\n\tif (strlen(box->vname) > MAILBOX_LIST_NAME_MAX_LENGTH) {\n\t\tmail_storage_set_error(box->storage, MAIL_ERROR_PARAMS,\n\t\t\t\t       \"Mailbox name too long\");\n\t\treturn -1;\n\t}\n\t/* check individual component names, too */\n\tconst char *old_name = box->name;\n\tconst char *name;\n\tconst char sep = mailbox_list_get_hierarchy_sep(box->list);\n\twhile((name = strchr(old_name, sep)) != NULL) {\n\t\tif (name - old_name > MAILBOX_MAX_HIERARCHY_NAME_LENGTH) {\n\t\t\tmail_storage_set_error(box->storage, MAIL_ERROR_PARAMS,\n\t\t\t\t\"Mailbox name too long\");\n\t\t\treturn -1;\n\t\t}\n\t\tname++;\n\t\told_name = name;\n\t}\n\tif (strlen(old_name) > MAILBOX_MAX_HIERARCHY_NAME_LENGTH) {\n\t\tmail_storage_set_error(box->storage, MAIL_ERROR_PARAMS,\n\t\t\t\t       \"Mailbox name too long\");\n\t\treturn -1;\n\t}\n\treturn 0;\n}\n\nstatic bool have_listable_namespace_prefix(struct mail_namespace *ns,\n\t\t\t\t\t   const char *name)\n{\n\tsize_t name_len = strlen(name);\n\n\tfor (; ns != NULL; ns = ns->next) {\n\t\tif ((ns->flags & (NAMESPACE_FLAG_LIST_PREFIX |\n\t\t\t\t  NAMESPACE_FLAG_LIST_CHILDREN)) == 0)\n\t\t\tcontinue;\n\n\t\tif (ns->prefix_len <= name_len)\n\t\t\tcontinue;\n\n\t\t/* if prefix has multiple hierarchies, match\n\t\t   any of the hierarchies */\n\t\tif (strncmp(ns->prefix, name, name_len) == 0 &&\n\t\t    ns->prefix[name_len] == mail_namespace_get_sep(ns))\n\t\t\treturn TRUE;\n\t}\n\treturn FALSE;\n}\n\nint mailbox_exists(struct mailbox *box, bool auto_boxes,\n\t\t   enum mailbox_existence *existence_r)\n{\n\tswitch (box->open_error) {\n\tcase 0:\n\t\tbreak;\n\tcase MAIL_ERROR_NOTFOUND:\n\t\t*existence_r = MAILBOX_EXISTENCE_NONE;\n\t\treturn 0;\n\tdefault:\n\t\t/* unsure if this exists or not */\n\t\treturn -1;\n\t}\n\tif (mailbox_verify_name(box) < 0) {\n\t\t/* the mailbox name is invalid. we don't know if it currently\n\t\t   exists or not, but since it can never be accessed in any way\n\t\t   report it as if it didn't exist. */\n\t\t*existence_r = MAILBOX_EXISTENCE_NONE;\n\t\treturn 0;\n\t}\n\n\tif (auto_boxes && mailbox_is_autocreated(box)) {\n\t\t*existence_r = MAILBOX_EXISTENCE_SELECT;\n\t\treturn 0;\n\t}\n\n\tif (box->v.exists(box, auto_boxes, existence_r) < 0)\n\t\treturn -1;\n\n\tif (!box->inbox_user && *existence_r == MAILBOX_EXISTENCE_NOSELECT &&\n\t    have_listable_namespace_prefix(box->storage->user->namespaces,\n\t\t\t\t\t   box->vname)) {\n\t       /* listable namespace prefix always exists. */\n\t\t*existence_r = MAILBOX_EXISTENCE_NOSELECT;\n\t\treturn 0;\n\t}\n\n\t/* if this is a shared namespace with only INBOX and\n\t   mail_shared_explicit_inbox=no, we'll need to mark the namespace as\n\t   usable here since nothing else will. */\n\tbox->list->ns->flags |= NAMESPACE_FLAG_USABLE;\n\treturn 0;\n}\n\nstatic int ATTR_NULL(2)\nmailbox_open_full(struct mailbox *box, struct istream *input)\n{\n\tint ret;\n\n\tif (box->opened)\n\t\treturn 0;\n\n\tif (box->reason != NULL) {\n\t\te_debug(box->event,\n\t\t\t\"Mailbox opened because: %s\",\n\t\t\tbox->reason);\n\t}\n\n\tswitch (box->open_error) {\n\tcase 0:\n\t\tbreak;\n\tcase MAIL_ERROR_NOTFOUND:\n\t\tmail_storage_set_error(box->storage, MAIL_ERROR_NOTFOUND,\n\t\t\tT_MAIL_ERR_MAILBOX_NOT_FOUND(box->vname));\n\t\treturn -1;\n\tdefault:\n\t\tmail_storage_set_internal_error(box->storage);\n\t\tbox->storage->error = box->open_error;\n\t\treturn -1;\n\t}\n\n\tif (mailbox_verify_existing_name(box) < 0)\n\t\treturn -1;\n\n\tif (input != NULL) {\n\t\tif ((box->storage->class_flags &\n\t\t     MAIL_STORAGE_CLASS_FLAG_OPEN_STREAMS) == 0) {\n\t\t\tmailbox_set_critical(box,\n\t\t\t\t\"Storage doesn't support streamed mailboxes\");\n\t\t\treturn -1;\n\t\t}\n\t\tbox->input = input;\n\t\tbox->flags |= MAILBOX_FLAG_READONLY;\n\t\ti_stream_ref(box->input);\n\t}\n\n\tT_BEGIN {\n\t\tret = box->v.open(box);\n\t} T_END;\n\n\tif (ret < 0 && box->storage->error == MAIL_ERROR_NOTFOUND &&\n\t    !box->deleting && !box->creating &&\n\t    box->input == NULL && mailbox_is_autocreated(box)) T_BEGIN {\n\t\tret = mailbox_autocreate_and_reopen(box);\n\t} T_END;\n\n\tif (ret < 0) {\n\t\tif (box->input != NULL)\n\t\t\ti_stream_unref(&box->input);\n\t\treturn -1;\n\t}\n\n\tbox->list->ns->flags |= NAMESPACE_FLAG_USABLE;\n\treturn 0;\n}\n\nstatic bool mailbox_try_undelete(struct mailbox *box)\n{\n\ttime_t mtime;\n\n\ti_assert(!box->mailbox_undeleting);\n\n\tif ((box->flags & MAILBOX_FLAG_READONLY) != 0) {\n\t\t/* most importantly we don't do this because we want to avoid\n\t\t   a loop: mdbox storage rebuild -> mailbox_open() ->\n\t\t   mailbox_mark_index_deleted() -> mailbox_sync() ->\n\t\t   mdbox storage rebuild. */\n\t\treturn FALSE;\n\t}\n\tif (mail_index_get_modification_time(box->index, &mtime) < 0)\n\t\treturn FALSE;\n\tif (mtime + MAILBOX_DELETE_RETRY_SECS > time(NULL))\n\t\treturn FALSE;\n\n\tbox->mailbox_undeleting = TRUE;\n\tint ret = mailbox_mark_index_deleted(box, FALSE);\n\tbox->mailbox_undeleting = FALSE;\n\tif (ret < 0)\n\t\treturn FALSE;\n\tbox->mailbox_deleted = FALSE;\n\treturn TRUE;\n}\n\nint mailbox_open(struct mailbox *box)\n{\n\tif (mailbox_open_full(box, NULL) < 0) {\n\t\tif (!box->mailbox_deleted || box->mailbox_undeleting)\n\t\t\treturn -1;\n\n\t\t/* mailbox has been marked as deleted. if this deletion\n\t\t   started (and crashed) a long time ago, it can be confusing\n\t\t   to user that the mailbox can't be opened. so we'll just\n\t\t   undelete it and reopen. */\n\t\tif(!mailbox_try_undelete(box))\n\t\t\treturn -1;\n\n\t\t/* make sure we close the mailbox in the middle. some backends\n\t\t   may not have fully opened the mailbox while it was being\n\t\t   undeleted. */\n\t\tmailbox_close(box);\n\t\tif (mailbox_open_full(box, NULL) < 0)\n\t\t\treturn -1;\n\t}\n\treturn 0;\n}\n\nstatic int mailbox_alloc_index_pvt(struct mailbox *box)\n{\n\tconst char *index_dir;\n\tint ret;\n\n\tif (box->index_pvt != NULL)\n\t\treturn 1;\n\n\tret = mailbox_get_path_to(box, MAILBOX_LIST_PATH_TYPE_INDEX_PRIVATE,\n\t\t\t\t  &index_dir);\n\tif (ret <= 0)\n\t\treturn ret; /* error / no private indexes */\n\n\tif (mailbox_create_missing_dir(box, MAILBOX_LIST_PATH_TYPE_INDEX_PRIVATE) < 0)\n\t\treturn -1;\n\n\t/* Note that this may cause box->event to live longer than box */\n\tbox->index_pvt = mail_index_alloc_cache_get(box->event,\n\t\tNULL, index_dir, t_strconcat(box->index_prefix, \".pvt\", NULL));\n\tmail_index_set_fsync_mode(box->index_pvt,\n\t\t\t\t  box->storage->set->parsed_fsync_mode, 0);\n\tmail_index_set_lock_method(box->index_pvt,\n\t\tbox->storage->set->parsed_lock_method,\n\t\tmail_storage_get_lock_timeout(box->storage, UINT_MAX));\n\treturn 1;\n}\n\nint mailbox_open_index_pvt(struct mailbox *box)\n{\n\tenum mail_index_open_flags index_flags;\n\tint ret;\n\n\tif (box->view_pvt != NULL)\n\t\treturn 1;\n\tif (mailbox_get_private_flags_mask(box) == 0)\n\t\treturn 0;\n\n\tif ((ret = mailbox_alloc_index_pvt(box)) <= 0)\n\t\treturn ret;\n\tindex_flags = MAIL_INDEX_OPEN_FLAG_CREATE |\n\t\tmail_storage_settings_to_index_flags(box->storage->set);\n\tif ((box->flags & MAILBOX_FLAG_SAVEONLY) != 0)\n\t\tindex_flags |= MAIL_INDEX_OPEN_FLAG_SAVEONLY;\n\tif (mail_index_open(box->index_pvt, index_flags) < 0)\n\t\treturn -1;\n\tbox->view_pvt = mail_index_view_open(box->index_pvt);\n\treturn 1;\n}\n\nint mailbox_open_stream(struct mailbox *box, struct istream *input)\n{\n\treturn mailbox_open_full(box, input);\n}\n\nint mailbox_enable(struct mailbox *box, enum mailbox_feature features)\n{\n\tif (mailbox_verify_name(box) < 0)\n\t\treturn -1;\n\treturn box->v.enable(box, features);\n}\n\nenum mailbox_feature mailbox_get_enabled_features(struct mailbox *box)\n{\n\treturn box->enabled_features;\n}\n\nvoid mail_storage_free_binary_cache(struct mail_storage *storage)\n{\n\tif (storage->binary_cache.box == NULL)\n\t\treturn;\n\n\ttimeout_remove(&storage->binary_cache.to);\n\ti_stream_destroy(&storage->binary_cache.input);\n\ti_zero(&storage->binary_cache);\n}\n\nvoid mailbox_close(struct mailbox *box)\n{\n\tif (!box->opened)\n\t\treturn;\n\n\tif (box->transaction_count != 0) {\n\t\ti_panic(\"Trying to close mailbox %s with open transactions\",\n\t\t\tbox->name);\n\t}\n\tbox->v.close(box);\n\n\tif (box->storage->binary_cache.box == box)\n\t\tmail_storage_free_binary_cache(box->storage);\n\tbox->opened = FALSE;\n\tbox->mailbox_deleted = FALSE;\n\tarray_clear(&box->search_results);\n\n\tif (array_is_created(&box->recent_flags))\n\t\tarray_free(&box->recent_flags);\n\tbox->recent_flags_prev_uid = 0;\n\tbox->recent_flags_count = 0;\n}\n\nvoid mailbox_free(struct mailbox **_box)\n{\n\tstruct mailbox *box = *_box;\n\n\t*_box = NULL;\n\n\tmailbox_close(box);\n\tbox->v.free(box);\n\n\tif (box->attribute_iter_count != 0) {\n\t\ti_panic(\"Trying to free mailbox %s with %u open attribute iterators\",\n\t\t\tbox->name, box->attribute_iter_count);\n\t}\n\n\tDLLIST_REMOVE(&box->storage->mailboxes, box);\n\tmail_storage_obj_unref(box->storage);\n\tpool_unref(&box->pool);\n}\n\nbool mailbox_equals(const struct mailbox *box1,\n\t\t    const struct mail_namespace *ns2, const char *vname2)\n{\n\tstruct mail_namespace *ns1 = mailbox_get_namespace(box1);\n\tconst char *name1;\n\n\tif (ns1 != ns2)\n\t\treturn FALSE;\n\n        name1 = mailbox_get_vname(box1);\n\tif (strcmp(name1, vname2) == 0)\n\t\treturn TRUE;\n\n\treturn strcasecmp(name1, \"INBOX\") == 0 &&\n\t\tstrcasecmp(vname2, \"INBOX\") == 0;\n}\n\nbool mailbox_is_any_inbox(struct mailbox *box)\n{\n\treturn box->inbox_any;\n}\n\nbool mailbox_has_special_use(struct mailbox *box, const char *special_use)\n{\n\tif (box->set == NULL)\n\t\treturn FALSE;\n\treturn str_contains_special_use(box->set->special_use, special_use);\n}\n\nstatic void mailbox_copy_cache_decisions_from_inbox(struct mailbox *box)\n{\n\tstruct mail_namespace *ns =\n\t\tmail_namespace_find_inbox(box->storage->user->namespaces);\n\tstruct mailbox *inbox =\n\t\tmailbox_alloc(ns->list, \"INBOX\", MAILBOX_FLAG_READONLY);\n\tenum mailbox_existence existence;\n\n\t/* this should be NoSelect but since inbox can never be\n\t   NoSelect we use EXISTENCE_NONE to avoid creating inbox by accident */\n\tmailbox_set_reason(inbox, \"copy caching decisions\");\n\tif (mailbox_exists(inbox, FALSE, &existence) == 0 &&\n\t    existence != MAILBOX_EXISTENCE_NONE &&\n\t    mailbox_open(inbox) == 0 &&\n\t    mailbox_open(box) == 0) {\n\t\t/* we can't do much about errors here */\n\t\t(void)mail_cache_decisions_copy(inbox->cache, box->cache);\n\t}\n\n\tmailbox_free(&inbox);\n}\n\nint mailbox_create(struct mailbox *box, const struct mailbox_update *update,\n\t\t   bool directory)\n{\n\tint ret;\n\n\tif (mailbox_verify_create_name(box) < 0)\n\t\treturn -1;\n\n\t/* Avoid race conditions by keeping mailbox list locked during changes.\n\t   This especially fixes a race during INBOX creation with LAYOUT=index\n\t   because it scans for missing mailboxes if INBOX doesn't exist. The\n\t   second process's scan can find a half-created INBOX and add it,\n\t   causing the first process to become confused. */\n\tif (mailbox_list_lock(box->list) < 0) {\n\t\tmail_storage_copy_list_error(box->storage, box->list);\n\t\treturn -1;\n\t}\n\tbox->creating = TRUE;\n\tret = box->v.create_box(box, update, directory);\n\tbox->creating = FALSE;\n\tmailbox_list_unlock(box->list);\n\n\tif (ret == 0) {\n\t\tbox->list->guid_cache_updated = TRUE;\n\t\tif (!box->inbox_any)\n\t\t\tmailbox_copy_cache_decisions_from_inbox(box);\n\t} else if (box->opened) {\n\t\t/* Creation failed after (partially) opening the mailbox.\n\t\t   It may not be in a valid state, so close it. */\n\t\tmail_storage_last_error_push(box->storage);\n\t\tmailbox_close(box);\n\t\tmail_storage_last_error_pop(box->storage);\n\t}\n\treturn ret;\n}\n\nint mailbox_update(struct mailbox *box, const struct mailbox_update *update)\n{\n\tint ret;\n\n\ti_assert(update->min_next_uid == 0 ||\n\t\t update->min_first_recent_uid == 0 ||\n\t\t update->min_first_recent_uid <= update->min_next_uid);\n\n\tif (mailbox_verify_existing_name(box) < 0)\n\t\treturn -1;\n\tret = box->v.update_box(box, update);\n\tif (!guid_128_is_empty(update->mailbox_guid))\n\t\tbox->list->guid_cache_invalidated = TRUE;\n\treturn ret;\n}\n\nint mailbox_mark_index_deleted(struct mailbox *box, bool del)\n{\n\tstruct mail_index_transaction *trans;\n\tenum mail_index_transaction_flags trans_flags = 0;\n\tenum mailbox_flags old_flag;\n\tint ret;\n\n\tif (box->marked_deleted && del) {\n\t\t/* we already marked it deleted. this allows plugins to\n\t\t   \"lock\" the deletion earlier. */\n\t\treturn 0;\n\t}\n\n\told_flag = box->flags & MAILBOX_FLAG_OPEN_DELETED;\n\tbox->flags |= MAILBOX_FLAG_OPEN_DELETED;\n\tret = mailbox_open(box);\n\tbox->flags = (box->flags & ~MAILBOX_FLAG_OPEN_DELETED) | old_flag;\n\tif (ret < 0)\n\t\treturn -1;\n\n\ttrans_flags = del ? 0 : MAIL_INDEX_TRANSACTION_FLAG_EXTERNAL;\n\ttrans = mail_index_transaction_begin(box->view, trans_flags);\n\tif (del)\n\t\tmail_index_set_deleted(trans);\n\telse\n\t\tmail_index_set_undeleted(trans);\n\tif (mail_index_transaction_commit(&trans) < 0) {\n\t\tmailbox_set_index_error(box);\n\t\treturn -1;\n\t}\n\n\tif (del) {\n\t\t/* sync the mailbox. this finishes the index deletion and it\n\t\t   can succeed only for a single session. we do it here, so the\n\t\t   rest of the deletion code doesn't have to worry about race\n\t\t   conditions. */\n\t\tbox->delete_sync_check = TRUE;\n\t\tret = mailbox_sync(box, MAILBOX_SYNC_FLAG_FULL_READ);\n\t\tbox->delete_sync_check = FALSE;\n\t\tif (ret < 0)\n\t\t\treturn -1;\n\t}\n\n\tbox->marked_deleted = del;\n\treturn 0;\n}\n\nstatic void mailbox_close_reset_path(struct mailbox *box)\n{\n\ti_zero(&box->_perm);\n\tbox->_path = NULL;\n\tbox->_index_path = NULL;\n}\n\nint mailbox_delete(struct mailbox *box)\n{\n\tbool list_locked;\n\tint ret;\n\n\tif (*box->name == '\\0') {\n\t\tmail_storage_set_error(box->storage, MAIL_ERROR_PARAMS,\n\t\t\t\t       \"Storage root can't be deleted\");\n\t\treturn -1;\n\t}\n\n\tbox->deleting = TRUE;\n\tif (mailbox_open(box) < 0) {\n\t\tif (mailbox_get_last_mail_error(box) != MAIL_ERROR_NOTFOUND &&\n\t\t    !box->mailbox_deleted)\n\t\t\treturn -1;\n\t\t/* might be a \\noselect mailbox, so continue deletion */\n\t}\n\n\tif (mailbox_list_lock(box->list) < 0) {\n\t\tmail_storage_copy_list_error(box->storage, box->list);\n\t\tlist_locked = FALSE;\n\t\tret = -1;\n\t} else {\n\t\tlist_locked = TRUE;\n\t\tret = box->v.delete_box(box);\n\t}\n\tif (ret < 0 && box->marked_deleted) {\n\t\t/* deletion failed. revert the mark so it can maybe be\n\t\t   tried again later. */\n\t\tif (mailbox_mark_index_deleted(box, FALSE) < 0)\n\t\t\tret = -1;\n\t}\n\tif (list_locked)\n\t\tmailbox_list_unlock(box->list);\n\n\tbox->deleting = FALSE;\n\tmailbox_close(box);\n\n\t/* if mailbox is reopened, its path may be different with\n\t   LAYOUT=index */\n\tmailbox_close_reset_path(box);\n\treturn ret;\n}\n\nint mailbox_delete_empty(struct mailbox *box)\n{\n\tint ret;\n\n\t/* FIXME: should be a parameter to delete(), but since it changes API\n\t   don't do it for now */\n\tbox->deleting_must_be_empty = TRUE;\n\tret = mailbox_delete(box);\n\tbox->deleting_must_be_empty = FALSE;\n\treturn ret;\n}\n\nstatic bool\nmail_storages_rename_compatible(struct mail_storage *storage1,\n\t\t\t\tstruct mail_storage *storage2,\n\t\t\t\tconst char **error_r)\n{\n\tif (storage1 == storage2)\n\t\treturn TRUE;\n\n\tif (strcmp(storage1->name, storage2->name) != 0) {\n\t\t*error_r = t_strdup_printf(\"storage %s != %s\",\n\t\t\t\t\t   storage1->name, storage2->name);\n\t\treturn FALSE;\n\t}\n\tif ((storage1->class_flags & MAIL_STORAGE_CLASS_FLAG_UNIQUE_ROOT) != 0) {\n\t\t/* e.g. mdbox where all mails are in storage/ directory and\n\t\t   they can't be easily moved from there. */\n\t\t*error_r = t_strdup_printf(\"storage %s uses unique root\",\n\t\t\t\t\t   storage1->name);\n\t\treturn FALSE;\n\t}\n\treturn TRUE;\n}\n\nstatic bool nullequals(const void *p1, const void *p2)\n{\n\treturn (p1 == NULL && p2 == NULL) || (p1 != NULL && p2 != NULL);\n}\n\nstatic bool\nmailbox_lists_rename_compatible(struct mailbox_list *list1,\n\t\t\t\tstruct mailbox_list *list2,\n\t\t\t\tconst char **error_r)\n{\n\tif (!nullequals(list1->set.alt_dir, list2->set.alt_dir)) {\n\t\t*error_r = t_strdup_printf(\"Namespace %s has alt dir, %s doesn't\",\n\t\t\t\t\t   list1->ns->prefix, list2->ns->prefix);\n\t\treturn FALSE;\n\t}\n\tif (!nullequals(list1->set.index_dir, list2->set.index_dir)) {\n\t\t*error_r = t_strdup_printf(\"Namespace %s has index dir, %s doesn't\",\n\t\t\t\t\t   list1->ns->prefix, list2->ns->prefix);\n\t\treturn FALSE;\n\t}\n\tif (!nullequals(list1->set.index_cache_dir, list2->set.index_cache_dir)) {\n\t\t*error_r = t_strdup_printf(\"Namespace %s has index cache dir, %s doesn't\",\n\t\t\t\t\t   list1->ns->prefix, list2->ns->prefix);\n\t\treturn FALSE;\n\t}\n\tif (!nullequals(list1->set.control_dir, list2->set.control_dir)) {\n\t\t*error_r = t_strdup_printf(\"Namespace %s has control dir, %s doesn't\",\n\t\t\t\t\t   list1->ns->prefix, list2->ns->prefix);\n\t\treturn FALSE;\n\t}\n\treturn TRUE;\n}\n\nstatic\nint mailbox_rename_check_children(struct mailbox *src, struct mailbox *dest)\n{\n\tint ret = 0;\n\tsize_t src_prefix_len = strlen(src->vname)+1; /* include separator */\n\tsize_t dest_prefix_len = strlen(dest->vname)+1;\n\t/* this can return folders with * in their name, that are not\n\t   actually our children */\n\tchar ns_sep = mail_namespace_get_sep(src->list->ns);\n\tconst char *pattern = t_strdup_printf(\"%s%c*\", src->vname, ns_sep);\n\n\tstruct mailbox_list_iterate_context *iter = mailbox_list_iter_init(src->list, pattern,\n\t\t\t\t      MAILBOX_LIST_ITER_RETURN_NO_FLAGS);\n\n\tconst struct mailbox_info *child;\n\twhile((child = mailbox_list_iter_next(iter)) != NULL) {\n\t\tif (strncmp(child->vname, src->vname, src_prefix_len-1) != 0 ||\n\t\t    child->vname[src_prefix_len-1] != ns_sep)\n\t\t\tcontinue; /* not our child */\n\t\t/* if total length of new name exceeds the limit, fail */\n\t\tif (strlen(child->vname + src_prefix_len)+dest_prefix_len > MAILBOX_LIST_NAME_MAX_LENGTH) {\n\t\t\tmail_storage_set_error(src->storage, MAIL_ERROR_PARAMS,\n\t\t\t\t\"Mailbox or child name too long\");\n\t\t\tret = -1;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\t/* something went bad */\n\tif (mailbox_list_iter_deinit(&iter) < 0) {\n\t\tmail_storage_copy_list_error(src->storage, src->list);\n\t\tret = -1;\n\t}\n\treturn ret;\n}\n\nint mailbox_rename(struct mailbox *src, struct mailbox *dest)\n{\n\tconst char *error = NULL;\n\n\t/* Check only name validity, \\Noselect don't necessarily exist. */\n\tif (mailbox_verify_name(src) < 0)\n\t\treturn -1;\n\tif (*src->name == '\\0') {\n\t\tmail_storage_set_error(src->storage, MAIL_ERROR_PARAMS,\n\t\t\t\t       \"Can't rename mailbox root\");\n\t\treturn -1;\n\t}\n\tif (mailbox_verify_create_name(dest) < 0) {\n\t\tmail_storage_copy_error(src->storage, dest->storage);\n\t\treturn -1;\n\t}\n\tif (mailbox_rename_check_children(src, dest) != 0) {\n\t\treturn -1;\n\t}\n\n\tif (!mail_storages_rename_compatible(src->storage,\n\t\t\t\t\t     dest->storage, &error) ||\n\t    !mailbox_lists_rename_compatible(src->list,\n\t\t\t\t\t     dest->list, &error)) {\n\t\te_debug(src->event,\n\t\t\t\"Can't rename '%s' to '%s': %s\",\n\t\t\tsrc->vname, dest->vname, error);\n\t\tmail_storage_set_error(src->storage, MAIL_ERROR_NOTPOSSIBLE,\n\t\t\t\"Can't rename mailboxes across specified storages.\");\n\t\treturn -1;\n\t}\n\tif (src->list != dest->list &&\n\t    (src->list->ns->type != MAIL_NAMESPACE_TYPE_PRIVATE ||\n\t     dest->list->ns->type != MAIL_NAMESPACE_TYPE_PRIVATE)) {\n\t\tmail_storage_set_error(src->storage, MAIL_ERROR_NOTPOSSIBLE,\n\t\t\t\"Renaming not supported across non-private namespaces.\");\n\t\treturn -1;\n\t}\n\tif (src->list == dest->list && strcmp(src->name, dest->name) == 0) {\n\t\tmail_storage_set_error(src->storage, MAIL_ERROR_EXISTS,\n\t\t\t\t       \"Can't rename mailbox to itself.\");\n\t\treturn -1;\n\t}\n\n\t/* It would be safer to lock both source and destination, but that\n\t   could lead to deadlocks. So at least for now lets just lock only the\n\t   destination list. */\n\tif (mailbox_list_lock(dest->list) < 0) {\n\t\tmail_storage_copy_list_error(src->storage, dest->list);\n\t\treturn -1;\n\t}\n\tint ret = src->v.rename_box(src, dest);\n\tmailbox_list_unlock(dest->list);\n\tif (ret < 0)\n\t\treturn -1;\n\tsrc->list->guid_cache_invalidated = TRUE;\n\tdest->list->guid_cache_invalidated = TRUE;\n\treturn 0;\n}\n\nint mailbox_set_subscribed(struct mailbox *box, bool set)\n{\n\tif (mailbox_verify_name(box) < 0)\n\t\treturn -1;\n\tif (mailbox_list_iter_subscriptions_refresh(box->list) < 0) {\n\t\tmail_storage_copy_list_error(box->storage, box->list);\n\t\treturn -1;\n\t}\n\tif (mailbox_is_subscribed(box) == set)\n\t\treturn 0;\n\treturn box->v.set_subscribed(box, set);\n}\n\nbool mailbox_is_subscribed(struct mailbox *box)\n{\n\tstruct mailbox_node *node;\n\n\ti_assert(box->list->subscriptions != NULL);\n\n\tnode = mailbox_tree_lookup(box->list->subscriptions, box->vname);\n\treturn node != NULL && (node->flags & MAILBOX_SUBSCRIBED) != 0;\n}\n\nstruct mail_storage *mailbox_get_storage(const struct mailbox *box)\n{\n\treturn box->storage;\n}\n\nstruct mail_namespace *\nmailbox_get_namespace(const struct mailbox *box)\n{\n\treturn box->list->ns;\n}\n\nconst struct mail_storage_settings *mailbox_get_settings(struct mailbox *box)\n{\n\treturn box->storage->set;\n}\n\nconst char *mailbox_get_name(const struct mailbox *box)\n{\n\treturn box->name;\n}\n\nconst char *mailbox_get_vname(const struct mailbox *box)\n{\n\treturn box->vname;\n}\n\nbool mailbox_is_readonly(struct mailbox *box)\n{\n\ti_assert(box->opened);\n\n\treturn box->v.is_readonly(box);\n}\n\nbool mailbox_backends_equal(const struct mailbox *box1,\n\t\t\t    const struct mailbox *box2)\n{\n\tstruct mail_namespace *ns1 = box1->list->ns, *ns2 = box2->list->ns;\n\n\tif (strcmp(box1->name, box2->name) != 0)\n\t\treturn FALSE;\n\n\twhile (ns1->alias_for != NULL)\n\t\tns1 = ns1->alias_for;\n\twhile (ns2->alias_for != NULL)\n\t\tns2 = ns2->alias_for;\n\treturn ns1 == ns2;\n}\n\nstatic void\nmailbox_get_status_set_defaults(struct mailbox *box,\n\t\t\t\tstruct mailbox_status *status_r)\n{\n\ti_zero(status_r);\n\tif ((box->storage->class_flags & MAIL_STORAGE_CLASS_FLAG_HAVE_MAIL_GUIDS) != 0)\n\t\tstatus_r->have_guids = TRUE;\n\tif ((box->storage->class_flags & MAIL_STORAGE_CLASS_FLAG_HAVE_MAIL_SAVE_GUIDS) != 0)\n\t\tstatus_r->have_save_guids = TRUE;\n\tif ((box->storage->class_flags & MAIL_STORAGE_CLASS_FLAG_HAVE_MAIL_GUID128) != 0)\n\t\tstatus_r->have_only_guid128 = TRUE;\n}\n\nint mailbox_get_status(struct mailbox *box,\n\t\t       enum mailbox_status_items items,\n\t\t       struct mailbox_status *status_r)\n{\n\tmailbox_get_status_set_defaults(box, status_r);\n\tif (mailbox_verify_existing_name(box) < 0)\n\t\treturn -1;\n\n\tif (box->v.get_status(box, items, status_r) < 0)\n\t\treturn -1;\n\ti_assert(status_r->have_guids || !status_r->have_save_guids);\n\treturn 0;\n}\n\nvoid mailbox_get_open_status(struct mailbox *box,\n\t\t\t     enum mailbox_status_items items,\n\t\t\t     struct mailbox_status *status_r)\n{\n\ti_assert(box->opened);\n\ti_assert((items & MAILBOX_STATUS_FAILING_ITEMS) == 0);\n\n\tmailbox_get_status_set_defaults(box, status_r);\n\tif (box->v.get_status(box, items, status_r) < 0)\n\t\ti_unreached();\n}\n\nint mailbox_get_metadata(struct mailbox *box, enum mailbox_metadata_items items,\n\t\t\t struct mailbox_metadata *metadata_r)\n{\n\ti_zero(metadata_r);\n\tif (mailbox_verify_existing_name(box) < 0)\n\t\treturn -1;\n\n\tif (box->v.get_metadata(box, items, metadata_r) < 0)\n\t\treturn -1;\n\n\ti_assert((items & MAILBOX_METADATA_GUID) == 0 ||\n\t\t !guid_128_is_empty(metadata_r->guid));\n\treturn 0;\n}\n\nenum mail_flags mailbox_get_private_flags_mask(struct mailbox *box)\n{\n\tif (box->v.get_private_flags_mask != NULL)\n\t\treturn box->v.get_private_flags_mask(box);\n\telse if (box->list->set.index_pvt_dir != NULL)\n\t\treturn MAIL_SEEN; /* FIXME */\n\telse\n\t\treturn 0;\n}\n\nstruct mailbox_sync_context *\nmailbox_sync_init(struct mailbox *box, enum mailbox_sync_flags flags)\n{\n\tstruct mailbox_sync_context *ctx;\n\n\tif (box->transaction_count != 0) {\n\t\ti_panic(\"Trying to sync mailbox %s with open transactions\",\n\t\t\tbox->name);\n\t}\n\tif (!box->opened) {\n\t\tif (mailbox_open(box) < 0) {\n\t\t\tctx = i_new(struct mailbox_sync_context, 1);\n\t\t\tctx->box = box;\n\t\t\tctx->flags = flags;\n\t\t\tctx->open_failed = TRUE;\n\t\t\treturn ctx;\n\t\t}\n\t}\n\tT_BEGIN {\n\t\tctx = box->v.sync_init(box, flags);\n\t} T_END;\n\treturn ctx;\n}\n\nbool mailbox_sync_next(struct mailbox_sync_context *ctx,\n\t\t       struct mailbox_sync_rec *sync_rec_r)\n{\n\tif (ctx->open_failed)\n\t\treturn FALSE;\n\treturn ctx->box->v.sync_next(ctx, sync_rec_r);\n}\n\nint mailbox_sync_deinit(struct mailbox_sync_context **_ctx,\n\t\t\tstruct mailbox_sync_status *status_r)\n{\n\tstruct mailbox_sync_context *ctx = *_ctx;\n\tstruct mailbox *box = ctx->box;\n\tconst char *errormsg;\n\tenum mail_error error;\n\tint ret;\n\n\t*_ctx = NULL;\n\n\ti_zero(status_r);\n\n\tif (!ctx->open_failed)\n\t\tret = box->v.sync_deinit(ctx, status_r);\n\telse {\n\t\ti_free(ctx);\n\t\tret = -1;\n\t}\n\tif (ret < 0 && box->inbox_user &&\n\t    !box->storage->user->inbox_open_error_logged) {\n\t\terrormsg = mailbox_get_last_internal_error(box, &error);\n\t\tif (error == MAIL_ERROR_NOTPOSSIBLE) {\n\t\t\tbox->storage->user->inbox_open_error_logged = TRUE;\n\t\t\ti_error(\"Syncing INBOX failed: %s\", errormsg);\n\t\t}\n\t}\n\tif (ret == 0)\n\t\tbox->synced = TRUE;\n\treturn ret;\n}\n\nint mailbox_sync(struct mailbox *box, enum mailbox_sync_flags flags)\n{\n\tstruct mailbox_sync_context *ctx;\n\tstruct mailbox_sync_status status;\n\n\tif (array_count(&box->search_results) == 0) {\n\t\t/* we don't care about mailbox's current state, so we might\n\t\t   as well fix inconsistency state */\n\t\tflags |= MAILBOX_SYNC_FLAG_FIX_INCONSISTENT;\n\t}\n\n\tctx = mailbox_sync_init(box, flags);\n\treturn mailbox_sync_deinit(&ctx, &status);\n}\n\n#undef mailbox_notify_changes\nvoid mailbox_notify_changes(struct mailbox *box,\n\t\t\t    mailbox_notify_callback_t *callback, void *context)\n{\n\ti_assert(box->opened);\n\n\tbox->notify_callback = callback;\n\tbox->notify_context = context;\n\n\tbox->v.notify_changes(box);\n}\n\nvoid mailbox_notify_changes_stop(struct mailbox *box)\n{\n\ti_assert(box->opened);\n\n\tbox->notify_callback = NULL;\n\tbox->notify_context = NULL;\n\n\tbox->v.notify_changes(box);\n}\n\nstruct mail_search_context *\nmailbox_search_init(struct mailbox_transaction_context *t,\n\t\t    struct mail_search_args *args,\n\t\t    const enum mail_sort_type *sort_program,\n\t\t    enum mail_fetch_field wanted_fields,\n\t\t    struct mailbox_header_lookup_ctx *wanted_headers)\n{\n\ti_assert(wanted_headers == NULL || wanted_headers->box == t->box);\n\n\tmail_search_args_ref(args);\n\tif (!args->simplified)\n\t\tmail_search_args_simplify(args);\n\treturn t->box->v.search_init(t, args, sort_program,\n\t\t\t\t     wanted_fields, wanted_headers);\n}\n\nint mailbox_search_deinit(struct mail_search_context **_ctx)\n{\n\tstruct mail_search_context *ctx = *_ctx;\n\tstruct mail_search_args *args = ctx->args;\n\tint ret;\n\n\t*_ctx = NULL;\n\tmailbox_search_results_initial_done(ctx);\n\tret = ctx->transaction->box->v.search_deinit(ctx);\n\tmail_search_args_unref(&args);\n\treturn ret;\n}\n\nbool mailbox_search_next(struct mail_search_context *ctx, struct mail **mail_r)\n{\n\tbool tryagain;\n\n\twhile (!mailbox_search_next_nonblock(ctx, mail_r, &tryagain)) {\n\t\tif (!tryagain)\n\t\t\treturn FALSE;\n\t}\n\treturn TRUE;\n}\n\nbool mailbox_search_next_nonblock(struct mail_search_context *ctx,\n\t\t\t\t  struct mail **mail_r, bool *tryagain_r)\n{\n\tstruct mailbox *box = ctx->transaction->box;\n\n\t*mail_r = NULL;\n\t*tryagain_r = FALSE;\n\n\tif (!box->v.search_next_nonblock(ctx, mail_r, tryagain_r))\n\t\treturn FALSE;\n\telse {\n\t\tmailbox_search_results_add(ctx, (*mail_r)->uid);\n\t\treturn TRUE;\n\t}\n}\n\nbool mailbox_search_seen_lost_data(struct mail_search_context *ctx)\n{\n\treturn ctx->seen_lost_data;\n}\n\nvoid mailbox_search_mail_detach(struct mail_search_context *ctx,\n\t\t\t\tstruct mail *mail)\n{\n\tstruct mail_private *pmail =\n\t\tcontainer_of(mail, struct mail_private, mail);\n\tstruct mail *const *mailp;\n\n\tarray_foreach(&ctx->mails, mailp) {\n\t\tif (*mailp == mail) {\n\t\t\tpmail->search_mail = FALSE;\n\t\t\tarray_delete(&ctx->mails,\n\t\t\t\t     array_foreach_idx(&ctx->mails, mailp), 1);\n\t\t\treturn;\n\t\t}\n\t}\n\ti_unreached();\n}\n\nint mailbox_search_result_build(struct mailbox_transaction_context *t,\n\t\t\t\tstruct mail_search_args *args,\n\t\t\t\tenum mailbox_search_result_flags flags,\n\t\t\t\tstruct mail_search_result **result_r)\n{\n\tstruct mail_search_context *ctx;\n\tstruct mail *mail;\n\tint ret;\n\n\tctx = mailbox_search_init(t, args, NULL, 0, NULL);\n\t*result_r = mailbox_search_result_save(ctx, flags);\n\twhile (mailbox_search_next(ctx, &mail)) ;\n\n\tret = mailbox_search_deinit(&ctx);\n\tif (ret < 0)\n\t\tmailbox_search_result_free(result_r);\n\treturn ret;\n}\n\nstruct mailbox_transaction_context *\nmailbox_transaction_begin(struct mailbox *box,\n\t\t\t  enum mailbox_transaction_flags flags,\n\t\t\t  const char *reason)\n{\n\tstruct mailbox_transaction_context *trans;\n\n\ti_assert(box->opened);\n\n\tbox->transaction_count++;\n\ttrans = box->v.transaction_begin(box, flags, reason);\n\ti_assert(trans->reason != NULL);\n\treturn trans;\n}\n\nint mailbox_transaction_commit(struct mailbox_transaction_context **t)\n{\n\tstruct mail_transaction_commit_changes changes;\n\tint ret;\n\n\t/* Store changes temporarily so that plugins overriding\n\t   transaction_commit() can look at them. */\n\tret = mailbox_transaction_commit_get_changes(t, &changes);\n\tpool_unref(&changes.pool);\n\treturn ret;\n}\n\nint mailbox_transaction_commit_get_changes(\n\tstruct mailbox_transaction_context **_t,\n\tstruct mail_transaction_commit_changes *changes_r)\n{\n\tstruct mailbox_transaction_context *t = *_t;\n\tstruct mailbox *box = t->box;\n\tunsigned int save_count = t->save_count;\n\tint ret;\n\n\tchanges_r->pool = NULL;\n\n\t*_t = NULL;\n\tT_BEGIN {\n\t\tret = box->v.transaction_commit(t, changes_r);\n\t} T_END;\n\t/* either all the saved messages get UIDs or none, because a) we\n\t   failed, b) MAILBOX_TRANSACTION_FLAG_ASSIGN_UIDS not set,\n\t   c) backend doesn't support it (e.g. virtual plugin) */\n\ti_assert(ret < 0 ||\n\t\t seq_range_count(&changes_r->saved_uids) == save_count ||\n\t\t array_count(&changes_r->saved_uids) == 0);\n\t/* decrease the transaction count only after transaction_commit().\n\t   that way if it creates and destroys transactions internally, we\n\t   don't see transaction_count=0 until the parent transaction is fully\n\t   finished */\n\tbox->transaction_count--;\n\tif (ret < 0 && changes_r->pool != NULL)\n\t\tpool_unref(&changes_r->pool);\n\treturn ret;\n}\n\nvoid mailbox_transaction_rollback(struct mailbox_transaction_context **_t)\n{\n\tstruct mailbox_transaction_context *t = *_t;\n\tstruct mailbox *box = t->box;\n\n\t*_t = NULL;\n\tbox->v.transaction_rollback(t);\n\tbox->transaction_count--;\n}\n\nunsigned int mailbox_transaction_get_count(const struct mailbox *box)\n{\n\treturn box->transaction_count;\n}\n\nvoid mailbox_transaction_set_max_modseq(struct mailbox_transaction_context *t,\n\t\t\t\t\tuint64_t max_modseq,\n\t\t\t\t\tARRAY_TYPE(seq_range) *seqs)\n{\n\tmail_index_transaction_set_max_modseq(t->itrans, max_modseq, seqs);\n}\n\nstruct mailbox *\nmailbox_transaction_get_mailbox(const struct mailbox_transaction_context *t)\n{\n\treturn t->box;\n}\n\nstatic void mailbox_save_dest_mail_close(struct mail_save_context *ctx)\n{\n\tstruct mail_private *mail = (struct mail_private *)ctx->dest_mail;\n\n\tmail->v.close(&mail->mail);\n}\n\nstruct mail_save_context *\nmailbox_save_alloc(struct mailbox_transaction_context *t)\n{\n\tstruct mail_save_context *ctx;\n\tT_BEGIN {\n\t\tctx = t->box->v.save_alloc(t);\n\t} T_END;\n\ti_assert(!ctx->unfinished);\n\tctx->unfinished = TRUE;\n\tctx->data.received_date = (time_t)-1;\n\tctx->data.save_date = (time_t)-1;\n\n\t/* Always have a dest_mail available. A lot of plugins make use\n\t   of this. */\n\tif (ctx->dest_mail == NULL)\n\t\tctx->dest_mail = mail_alloc(t, 0, NULL);\n\telse {\n\t\t/* make sure the mail isn't used before mail_set_seq_saving() */\n\t\tmailbox_save_dest_mail_close(ctx);\n\t}\n\n\treturn ctx;\n}\n\nvoid mailbox_save_context_deinit(struct mail_save_context *ctx)\n{\n\ti_assert(ctx->dest_mail != NULL);\n\n\tmail_free(&ctx->dest_mail);\n}\n\nvoid mailbox_save_set_flags(struct mail_save_context *ctx,\n\t\t\t    enum mail_flags flags,\n\t\t\t    struct mail_keywords *keywords)\n{\n\tstruct mailbox *box = ctx->transaction->box;\n\n\tif (ctx->data.keywords != NULL)\n\t\tmailbox_keywords_unref(&ctx->data.keywords);\n\n\tctx->data.flags = flags & ~mailbox_get_private_flags_mask(box);\n\tctx->data.pvt_flags = flags & mailbox_get_private_flags_mask(box);\n\tctx->data.keywords = keywords;\n\tif (keywords != NULL)\n\t\tmailbox_keywords_ref(keywords);\n}\n\nvoid mailbox_save_copy_flags(struct mail_save_context *ctx, struct mail *mail)\n{\n\tconst char *const *keywords_list;\n\tstruct mail_keywords *keywords;\n\n\tkeywords_list = mail_get_keywords(mail);\n\tkeywords = str_array_length(keywords_list) == 0 ? NULL :\n\t\tmailbox_keywords_create_valid(ctx->transaction->box,\n\t\t\t\t\t      keywords_list);\n\tmailbox_save_set_flags(ctx, mail_get_flags(mail), keywords);\n\tif (keywords != NULL)\n\t\tmailbox_keywords_unref(&keywords);\n}\n\nvoid mailbox_save_set_min_modseq(struct mail_save_context *ctx,\n\t\t\t\t uint64_t min_modseq)\n{\n\tctx->data.min_modseq = min_modseq;\n}\n\nvoid mailbox_save_set_received_date(struct mail_save_context *ctx,\n\t\t\t\t    time_t received_date, int timezone_offset)\n{\n\tctx->data.received_date = received_date;\n\tctx->data.received_tz_offset = timezone_offset;\n}\n\nvoid mailbox_save_set_save_date(struct mail_save_context *ctx,\n\t\t\t\ttime_t save_date)\n{\n\tctx->data.save_date = save_date;\n}\n\nvoid mailbox_save_set_from_envelope(struct mail_save_context *ctx,\n\t\t\t\t    const char *envelope)\n{\n\ti_free(ctx->data.from_envelope);\n\tctx->data.from_envelope = i_strdup(envelope);\n}\n\nvoid mailbox_save_set_uid(struct mail_save_context *ctx, uint32_t uid)\n{\n\tctx->data.uid = uid;\n}\n\nvoid mailbox_save_set_guid(struct mail_save_context *ctx, const char *guid)\n{\n\ti_assert(guid == NULL || *guid != '\\0');\n\n\ti_free(ctx->data.guid);\n\tctx->data.guid = i_strdup(guid);\n}\n\nvoid mailbox_save_set_pop3_uidl(struct mail_save_context *ctx, const char *uidl)\n{\n\ti_assert(*uidl != '\\0');\n\ti_assert(strchr(uidl, '\\n') == NULL);\n\n\ti_free(ctx->data.pop3_uidl);\n\tctx->data.pop3_uidl = i_strdup(uidl);\n}\n\nvoid mailbox_save_set_pop3_order(struct mail_save_context *ctx,\n\t\t\t\t unsigned int order)\n{\n\ti_assert(order > 0);\n\n\tctx->data.pop3_order = order;\n}\n\nstruct mail *mailbox_save_get_dest_mail(struct mail_save_context *ctx)\n{\n\treturn ctx->dest_mail;\n}\n\nint mailbox_save_begin(struct mail_save_context **ctx, struct istream *input)\n{\n\tstruct mailbox *box = (*ctx)->transaction->box;\n\tint ret;\n\n\tif (mail_index_is_deleted(box->index)) {\n\t\tmailbox_set_deleted(box);\n\t\tmailbox_save_cancel(ctx);\n\t\treturn -1;\n\t}\n\n\t/* make sure parts get parsed early on */\n\tconst struct mail_storage_settings *mail_set =\n\t\tmailbox_get_settings(box);\n\tif (mail_set->parsed_mail_attachment_detection_add_flags_on_save)\n\t\tmail_add_temp_wanted_fields((*ctx)->dest_mail,\n\t\t\t\t\t    MAIL_FETCH_MESSAGE_PARTS, NULL);\n\n\tif (!(*ctx)->copying_or_moving) {\n\t\t/* We're actually saving the mail. We're not being called by\n\t\t   mail_storage_copy() because backend didn't support fast\n\t\t   copying. */\n\t\ti_assert(!(*ctx)->copying_via_save);\n\t\t(*ctx)->saving = TRUE;\n\t} else {\n\t\ti_assert((*ctx)->copying_via_save);\n\t}\n\tif (box->v.save_begin == NULL) {\n\t\tmail_storage_set_error(box->storage, MAIL_ERROR_NOTPOSSIBLE,\n\t\t\t\t       \"Saving messages not supported\");\n\t\tret = -1;\n\t} else T_BEGIN {\n\t\tret = box->v.save_begin(*ctx, input);\n\t} T_END;\n\n\tif (ret < 0) {\n\t\tmailbox_save_cancel(ctx);\n\t\treturn -1;\n\t}\n\treturn 0;\n}\n\nint mailbox_save_continue(struct mail_save_context *ctx)\n{\n\tint ret;\n\n\tT_BEGIN {\n\t\tret = ctx->transaction->box->v.save_continue(ctx);\n\t} T_END;\n\treturn ret;\n}\n\nstatic void\nmailbox_save_add_pvt_flags(struct mailbox_transaction_context *t,\n\t\t\t   enum mail_flags pvt_flags)\n{\n\tstruct mail_save_private_changes *save;\n\n\tif (!array_is_created(&t->pvt_saves))\n\t\ti_array_init(&t->pvt_saves, 8);\n\tsave = array_append_space(&t->pvt_saves);\n\tsave->mailnum = t->save_count;\n\tsave->flags = pvt_flags;\n}\n\nstatic void\nmailbox_save_context_reset(struct mail_save_context *ctx, bool success)\n{\n\ti_assert(!ctx->unfinished);\n\tif (!ctx->copying_or_moving) {\n\t\t/* we're finishing a save (not copy/move). Note that we could\n\t\t   have come here also from mailbox_save_cancel(), in which\n\t\t   case ctx->saving may be FALSE. */\n\t\ti_assert(!ctx->copying_via_save);\n\t\ti_assert(ctx->saving || !success);\n\t\tctx->saving = FALSE;\n\t} else {\n\t\ti_assert(ctx->copying_via_save || !success);\n\t\t/* We came from mailbox_copy(). saving==TRUE is possible here\n\t\t   if we also came from mailbox_save_using_mail(). Don't set\n\t\t   saving=FALSE yet in that case, because copy() is still\n\t\t   running. */\n\t}\n}\n\nint mailbox_save_finish(struct mail_save_context **_ctx)\n{\n\tstruct mail_save_context *ctx = *_ctx;\n\tstruct mailbox_transaction_context *t = ctx->transaction;\n\t/* we need to keep a copy of this because save_finish implementations\n\t   will likely zero the data structure during cleanup */\n\tenum mail_flags pvt_flags = ctx->data.pvt_flags;\n\tbool copying_via_save = ctx->copying_via_save;\n\tint ret;\n\n\t/* Do one final continue. The caller may not have done it if the\n\t   input stream's offset already matched the number of bytes that\n\t   were wanted to be saved. But due to nested istreams some of the\n\t   underlying ones may not have seen the EOF yet, and haven't flushed\n\t   out the pending data. */\n\tif (mailbox_save_continue(ctx) < 0) {\n\t\tmailbox_save_cancel(_ctx);\n\t\treturn -1;\n\t}\n\t*_ctx = NULL;\n\n\tctx->finishing = TRUE;\n\tT_BEGIN {\n\t\tret = t->box->v.save_finish(ctx);\n\t} T_END;\n\tctx->finishing = FALSE;\n\n\tif (ret == 0 && !copying_via_save) {\n\t\tif (pvt_flags != 0)\n\t\t\tmailbox_save_add_pvt_flags(t, pvt_flags);\n\t\tt->save_count++;\n\t}\n\n\tmailbox_save_context_reset(ctx, TRUE);\n\treturn ret;\n}\n\nvoid mailbox_save_cancel(struct mail_save_context **_ctx)\n{\n\tstruct mail_save_context *ctx = *_ctx;\n\n\t*_ctx = NULL;\n\tT_BEGIN {\n\t\tctx->transaction->box->v.save_cancel(ctx);\n\t} T_END;\n\n\t/* the dest_mail is no longer valid. if we're still saving\n\t   more mails, the mail sequence may get reused. make sure\n\t   the mail gets reset in between */\n\tmailbox_save_dest_mail_close(ctx);\n\n\tmailbox_save_context_reset(ctx, FALSE);\n}\n\nstruct mailbox_transaction_context *\nmailbox_save_get_transaction(struct mail_save_context *ctx)\n{\n\treturn ctx->transaction;\n}\n\nstatic int mailbox_copy_int(struct mail_save_context **_ctx, struct mail *mail)\n{\n\tstruct mail_save_context *ctx = *_ctx;\n\tstruct mailbox_transaction_context *t = ctx->transaction;\n\tenum mail_flags pvt_flags = ctx->data.pvt_flags;\n\tstruct mail *backend_mail;\n\tint ret;\n\n\t*_ctx = NULL;\n\n\tif (mail_index_is_deleted(t->box->index)) {\n\t\tmailbox_set_deleted(t->box);\n\t\tmailbox_save_cancel(&ctx);\n\t\treturn -1;\n\t}\n\n\t/* bypass virtual storage, so hard linking can be used whenever\n\t   possible */\n\tif (mail_get_backend_mail(mail, &backend_mail) < 0) {\n\t\tmailbox_save_cancel(&ctx);\n\t\treturn -1;\n\t}\n\n\ti_assert(!ctx->copying_or_moving);\n\ti_assert(ctx->copy_src_mail == NULL);\n\tctx->copying_or_moving = TRUE;\n\tctx->copy_src_mail = mail;\n\tctx->finishing = TRUE;\n\tT_BEGIN {\n\t\tret = t->box->v.copy(ctx, backend_mail);\n\t} T_END;\n\tctx->finishing = FALSE;\n\tif (ret == 0) {\n\t\tif (pvt_flags != 0)\n\t\t\tmailbox_save_add_pvt_flags(t, pvt_flags);\n\t\tt->save_count++;\n\t}\n\ti_assert(!ctx->unfinished);\n\n\tctx->copy_src_mail = NULL;\n\tctx->copying_via_save = FALSE;\n\tctx->copying_or_moving = FALSE;\n\tctx->saving = FALSE; /* if we came from mailbox_save_using_mail() */\n\treturn ret;\n}\n\nint mailbox_copy(struct mail_save_context **_ctx, struct mail *mail)\n{\n\tstruct mail_save_context *ctx = *_ctx;\n\n\ti_assert(!ctx->saving);\n\ti_assert(!ctx->moving);\n\n\treturn mailbox_copy_int(_ctx, mail);\n}\n\nint mailbox_move(struct mail_save_context **_ctx, struct mail *mail)\n{\n\tstruct mail_save_context *ctx = *_ctx;\n\tint ret;\n\n\ti_assert(!ctx->saving);\n\ti_assert(!ctx->moving);\n\n\tctx->moving = TRUE;\n\tif ((ret = mailbox_copy_int(_ctx, mail)) == 0)\n\t\tmail_expunge(mail);\n\tctx->moving = FALSE;\n\treturn ret;\n}\n\nint mailbox_save_using_mail(struct mail_save_context **_ctx, struct mail *mail)\n{\n\tstruct mail_save_context *ctx = *_ctx;\n\n\ti_assert(!ctx->saving);\n\ti_assert(!ctx->moving);\n\n\tctx->saving = TRUE;\n\treturn mailbox_copy_int(_ctx, mail);\n}\n\nbool mailbox_is_inconsistent(struct mailbox *box)\n{\n\treturn box->mailbox_deleted || box->v.is_inconsistent(box);\n}\n\nvoid mailbox_set_deleted(struct mailbox *box)\n{\n\tmail_storage_set_error(box->storage, MAIL_ERROR_NOTFOUND,\n\t\t\t       \"Mailbox was deleted under us\");\n\tbox->mailbox_deleted = TRUE;\n}\n\nstatic int get_path_to(struct mailbox *box, enum mailbox_list_path_type type,\n\t\t       const char **internal_path, const char **path_r)\n{\n\tint ret;\n\n\tif (internal_path != NULL && *internal_path != NULL) {\n\t\tif ((*internal_path)[0] == '\\0') {\n\t\t\t*path_r = NULL;\n\t\t\treturn 0;\n\t\t}\n\t\t*path_r = *internal_path;\n\t\treturn 1;\n\t}\n\tret = mailbox_list_get_path(box->list, box->name, type, path_r);\n\tif (ret < 0) {\n\t\tmail_storage_copy_list_error(box->storage, box->list);\n\t\treturn -1;\n\t}\n\tif (internal_path != NULL && *internal_path == NULL)\n\t\t*internal_path = ret == 0 ? \"\" : p_strdup(box->pool, *path_r);\n\treturn ret;\n}\n\nint mailbox_get_path_to(struct mailbox *box, enum mailbox_list_path_type type,\n\t\t\tconst char **path_r)\n{\n\tif (type == MAILBOX_LIST_PATH_TYPE_MAILBOX)\n\t\treturn get_path_to(box, type, &box->_path, path_r);\n\tif (type == MAILBOX_LIST_PATH_TYPE_INDEX)\n\t\treturn get_path_to(box, type, &box->_index_path, path_r);\n\treturn get_path_to(box, type, NULL, path_r);\n}\n\nconst char *mailbox_get_path(struct mailbox *box)\n{\n\ti_assert(box->_path != NULL);\n\ti_assert(box->_path[0] != '\\0');\n\treturn box->_path;\n}\n\nconst char *mailbox_get_index_path(struct mailbox *box)\n{\n\ti_assert(box->_index_path != NULL);\n\ti_assert(box->_index_path[0] != '\\0');\n\treturn box->_index_path;\n}\n\nstatic void mailbox_get_permissions_if_not_set(struct mailbox *box)\n{\n\tif (box->_perm.file_create_mode != 0)\n\t\treturn;\n\n\tif (box->input != NULL) {\n\t\tbox->_perm.file_uid = geteuid();\n\t\tbox->_perm.file_create_mode = 0600;\n\t\tbox->_perm.dir_create_mode = 0700;\n\t\tbox->_perm.file_create_gid = (gid_t)-1;\n\t\tbox->_perm.file_create_gid_origin = \"defaults\";\n\t\treturn;\n\t}\n\n\tstruct mailbox_permissions perm;\n\tmailbox_list_get_permissions(box->list, box->name, &perm);\n\tmailbox_permissions_copy(&box->_perm, &perm, box->pool);\n}\n\nconst struct mailbox_permissions *mailbox_get_permissions(struct mailbox *box)\n{\n\tmailbox_get_permissions_if_not_set(box);\n\n\tif (!box->_perm.mail_index_permissions_set && box->index != NULL) {\n\t\tbox->_perm.mail_index_permissions_set = TRUE;\n\t\tmail_index_set_permissions(box->index,\n\t\t\t\t\t   box->_perm.file_create_mode,\n\t\t\t\t\t   box->_perm.file_create_gid,\n\t\t\t\t\t   box->_perm.file_create_gid_origin);\n\t}\n\treturn &box->_perm;\n}\n\nvoid mailbox_refresh_permissions(struct mailbox *box)\n{\n\ti_zero(&box->_perm);\n\t(void)mailbox_get_permissions(box);\n}\n\nint mailbox_create_fd(struct mailbox *box, const char *path, int flags,\n\t\t      int *fd_r)\n{\n\tconst struct mailbox_permissions *perm = mailbox_get_permissions(box);\n\tmode_t old_mask;\n\tint fd;\n\n\ti_assert((flags & O_CREAT) != 0);\n\n\t*fd_r = -1;\n\n\told_mask = umask(0);\n\tfd = open(path, flags, perm->file_create_mode);\n\tumask(old_mask);\n\n\tif (fd != -1) {\n\t\t/* ok */\n\t} else if (errno == EEXIST) {\n\t\t/* O_EXCL used, caller will handle this error */\n\t\treturn 0;\n\t} else if (errno == ENOENT) {\n\t\tmailbox_set_deleted(box);\n\t\treturn -1;\n\t} else if (errno == ENOTDIR) {\n\t\tmail_storage_set_error(box->storage, MAIL_ERROR_NOTPOSSIBLE,\n\t\t\t\"Mailbox doesn't allow inferior mailboxes\");\n\t\treturn -1;\n\t} else if (mail_storage_set_error_from_errno(box->storage)) {\n\t\treturn -1;\n\t} else {\n\t\tmailbox_set_critical(box, \"open(%s, O_CREAT) failed: %m\", path);\n\t\treturn -1;\n\t}\n\n\tif (perm->file_create_gid != (gid_t)-1) {\n\t\tif (fchown(fd, (uid_t)-1, perm->file_create_gid) == 0) {\n\t\t\t/* ok */\n\t\t} else if (errno == EPERM) {\n\t\t\tmailbox_set_critical(box, \"%s\",\n\t\t\t\teperm_error_get_chgrp(\"fchown\", path,\n\t\t\t\t\tperm->file_create_gid,\n\t\t\t\t\tperm->file_create_gid_origin));\n\t\t} else {\n\t\t\tmailbox_set_critical(box,\n\t\t\t\t\"fchown(%s) failed: %m\", path);\n\t\t}\n\t}\n\t*fd_r = fd;\n\treturn 1;\n}\n\nint mailbox_mkdir(struct mailbox *box, const char *path,\n\t\t  enum mailbox_list_path_type type)\n{\n\tconst struct mailbox_permissions *perm = mailbox_get_permissions(box);\n\tconst char *root_dir;\n\n\tif (!perm->gid_origin_is_mailbox_path) {\n\t\t/* mailbox root directory doesn't exist, create it */\n\t\troot_dir = mailbox_list_get_root_forced(box->list, type);\n\t\tif (mailbox_list_mkdir_root(box->list, root_dir, type) < 0) {\n\t\t\tmail_storage_copy_list_error(box->storage, box->list);\n\t\t\treturn -1;\n\t\t}\n\t}\n\n\tif (mkdir_parents_chgrp(path, perm->dir_create_mode,\n\t\t\t\tperm->file_create_gid,\n\t\t\t\tperm->file_create_gid_origin) == 0)\n\t\treturn 1;\n\telse if (errno == EEXIST)\n\t\treturn 0;\n\telse if (errno == ENOTDIR) {\n\t\tmail_storage_set_error(box->storage, MAIL_ERROR_NOTPOSSIBLE,\n\t\t\t\"Mailbox doesn't allow inferior mailboxes\");\n\t\treturn -1;\n\t} else if (mail_storage_set_error_from_errno(box->storage)) {\n\t\treturn -1;\n\t} else {\n\t\tmailbox_set_critical(box, \"mkdir_parents(%s) failed: %m\", path);\n\t\treturn -1;\n\t}\n}\n\nint mailbox_create_missing_dir(struct mailbox *box,\n\t\t\t       enum mailbox_list_path_type type)\n{\n\tconst char *mail_dir, *dir;\n\tstruct stat st;\n\tint ret;\n\n\tif ((ret = mailbox_get_path_to(box, type, &dir)) <= 0)\n\t\treturn ret;\n\tif (mailbox_get_path_to(box, MAILBOX_LIST_PATH_TYPE_MAILBOX,\n\t\t\t\t&mail_dir) < 0)\n\t\treturn -1;\n\tif (null_strcmp(dir, mail_dir) != 0) {\n\t\t/* Mailbox directory is different - create a missing dir */\n\t} else if ((box->list->props & MAILBOX_LIST_PROP_AUTOCREATE_DIRS) != 0) {\n\t\t/* This layout (e.g. imapc) wants to autocreate missing mailbox\n\t\t   directories as well. */\n\t} else {\n\t\t/* If the mailbox directory doesn't exist, the mailbox\n\t\t   shouldn't exist at all. So just assume that it's already\n\t\t   created and if there's a race condition just fail later. */\n\t\treturn 0;\n\t}\n\n\t/* we call this function even when the directory exists, so first do a\n\t   quick check to see if we need to mkdir anything */\n\tif (stat(dir, &st) == 0)\n\t\treturn 0;\n\n\tif ((box->storage->class_flags & MAIL_STORAGE_CLASS_FLAG_NO_ROOT) == 0 &&\n\t    null_strcmp(dir, mail_dir) != 0 && mail_dir != NULL &&\n\t    stat(mail_dir, &st) < 0 && (errno == ENOENT || errno == ENOTDIR)) {\n\t\t/* Race condition - mail root directory doesn't exist\n\t\t   anymore either. We shouldn't create this directory\n\t\t   anymore. */\n\t\tmailbox_set_deleted(box);\n\t\treturn -1;\n\t}\n\n\treturn mailbox_mkdir(box, dir, type);\n}\n\nunsigned int mail_storage_get_lock_timeout(struct mail_storage *storage,\n\t\t\t\t\t   unsigned int secs)\n{\n\treturn storage->set->mail_max_lock_timeout == 0 ? secs :\n\t\tI_MIN(secs, storage->set->mail_max_lock_timeout);\n}\n\nenum mail_index_open_flags\nmail_storage_settings_to_index_flags(const struct mail_storage_settings *set)\n{\n\tenum mail_index_open_flags index_flags = 0;\n\n#ifndef MMAP_CONFLICTS_WRITE\n\tif (set->mmap_disable)\n#endif\n\t\tindex_flags |= MAIL_INDEX_OPEN_FLAG_MMAP_DISABLE;\n\tif (set->dotlock_use_excl)\n\t\tindex_flags |= MAIL_INDEX_OPEN_FLAG_DOTLOCK_USE_EXCL;\n\tif (set->mail_nfs_index)\n\t\tindex_flags |= MAIL_INDEX_OPEN_FLAG_NFS_FLUSH;\n\treturn index_flags;\n}\n\nint mail_parse_human_timestamp(const char *str, time_t *timestamp_r,\n\t\t\t       bool *utc_r)\n{\n\tstruct tm tm;\n\tunsigned int secs;\n\tconst char *error;\n\n\tif (i_isdigit(str[0]) && i_isdigit(str[1]) &&\n\t    i_isdigit(str[2]) && i_isdigit(str[3]) && str[4] == '-' &&\n\t    i_isdigit(str[5]) && i_isdigit(str[6]) && str[7] == '-' &&\n\t    i_isdigit(str[8]) && i_isdigit(str[9]) && str[10] == '\\0') {\n\t\t/* yyyy-mm-dd */\n\t\ti_zero(&tm);\n\t\ttm.tm_year = (str[0]-'0') * 1000 + (str[1]-'0') * 100 +\n\t\t\t(str[2]-'0') * 10 + (str[3]-'0') - 1900;\n\t\ttm.tm_mon = (str[5]-'0') * 10 + (str[6]-'0') - 1;\n\t\ttm.tm_mday = (str[8]-'0') * 10 + (str[9]-'0');\n\t\t*timestamp_r = mktime(&tm);\n\t\t*utc_r = FALSE;\n\t\treturn 0;\n\t} else if (imap_parse_date(str, timestamp_r)) {\n\t\t/* imap date */\n\t\t*utc_r = FALSE;\n\t\treturn 0;\n\t} else if (str_to_time(str, timestamp_r) == 0) {\n\t\t/* unix timestamp */\n\t\t*utc_r = TRUE;\n\t\treturn 0;\n\t} else if (settings_get_time(str, &secs, &error) == 0) {\n\t\t*timestamp_r = ioloop_time - secs;\n\t\t*utc_r = TRUE;\n\t\treturn 0;\n\t} else {\n\t\treturn -1;\n\t}\n}\n\nvoid mail_set_mail_cache_corrupted(struct mail *mail, const char *fmt, ...)\n{\n\tstruct mail_cache_view *cache_view =\n\t\tmail->transaction->cache_view;\n\n\ti_assert(cache_view != NULL);\n\n\tva_list va;\n\tva_start(va, fmt);\n\n\tT_BEGIN {\n\t\tmail_cache_set_seq_corrupted_reason(cache_view, mail->seq,\n\t\t\tt_strdup_printf(\"UID %u: %s\",\n\t\t\t\t\tmail->uid,\n\t\t\t\t\tt_strdup_vprintf(fmt, va)));\n\t} T_END;\n\n\t/* update also the storage's internal error */\n\tmailbox_set_index_error(mail->box);\n\n\tva_end(va);\n}\n\nstatic int\nmail_storage_dotlock_create(const char *lock_path,\n\t\t\t    const struct file_create_settings *lock_set,\n\t\t\t    const struct mail_storage_settings *mail_set,\n\t\t\t    struct file_lock **lock_r, const char **error_r)\n{\n\tconst struct dotlock_settings dotlock_set = {\n\t\t.timeout = lock_set->lock_timeout_secs,\n\t\t.stale_timeout = I_MAX(60*5, lock_set->lock_timeout_secs),\n\t\t.lock_suffix = \"\",\n\n\t\t.use_excl_lock = mail_set->dotlock_use_excl,\n\t\t.nfs_flush = mail_set->mail_nfs_storage,\n\t\t.use_io_notify = TRUE,\n\t};\n\tstruct dotlock *dotlock;\n\tint ret = file_dotlock_create(&dotlock_set, lock_path, 0, &dotlock);\n\tif (ret <= 0) {\n\t\t*error_r = t_strdup_printf(\"file_dotlock_create(%s) failed: %m\",\n\t\t\t\t\t   lock_path);\n\t\treturn ret;\n\t}\n\t*lock_r = file_lock_from_dotlock(&dotlock);\n\treturn 1;\n}\n\nint mail_storage_lock_create(const char *lock_path,\n\t\t\t     const struct file_create_settings *lock_set,\n\t\t\t     const struct mail_storage_settings *mail_set,\n\t\t\t     struct file_lock **lock_r, const char **error_r)\n{\n\tbool created;\n\n\tif (lock_set->lock_method == FILE_LOCK_METHOD_DOTLOCK)\n\t\treturn mail_storage_dotlock_create(lock_path, lock_set, mail_set, lock_r, error_r);\n\n\tif (file_create_locked(lock_path, lock_set, lock_r,\n\t\t\t       &created, error_r) == -1) {\n\t\t*error_r = t_strdup_printf(\"file_create_locked(%s) failed: %s\",\n\t\t\t\t\t   lock_path, *error_r);\n\t\treturn errno == EAGAIN ? 0 : -1;\n\t}\n\tfile_lock_set_close_on_free(*lock_r, TRUE);\n\tfile_lock_set_unlink_on_free(*lock_r, TRUE);\n\treturn 1;\n}\n\nint mailbox_lock_file_create(struct mailbox *box, const char *lock_fname,\n\t\t\t     unsigned int lock_secs, struct file_lock **lock_r,\n\t\t\t     const char **error_r)\n{\n\tconst struct mailbox_permissions *perm;\n\tstruct file_create_settings set;\n\tconst char *lock_path;\n\n\tperm = mailbox_get_permissions(box);\n\ti_zero(&set);\n\tset.lock_timeout_secs =\n\t\tmail_storage_get_lock_timeout(box->storage, lock_secs);\n\tset.lock_method = box->storage->set->parsed_lock_method;\n\tset.mode = perm->file_create_mode;\n\tset.gid = perm->file_create_gid;\n\tset.gid_origin = perm->file_create_gid_origin;\n\n\tif (box->list->set.volatile_dir == NULL)\n\t\tlock_path = t_strdup_printf(\"%s/%s\", box->index->dir, lock_fname);\n\telse {\n\t\tunsigned char box_name_sha1[SHA1_RESULTLEN];\n\t\tstring_t *str = t_str_new(128);\n\n\t\t/* Keep this simple: Use the lock_fname with a SHA1 of the\n\t\t   mailbox name as the suffix. The mailbox name itself could\n\t\t   be too large as a filename and creating the full directory\n\t\t   structure would be pretty troublesome. It would also make\n\t\t   it more difficult to perform the automated deletion of empty\n\t\t   lock directories. */\n\t\tstr_printfa(str, \"%s/%s.\", box->list->set.volatile_dir,\n\t\t\t    lock_fname);\n\t\tsha1_get_digest(box->name, strlen(box->name), box_name_sha1);\n\t\tbinary_to_hex_append(str, box_name_sha1, sizeof(box_name_sha1));\n\t\tlock_path = str_c(str);\n\t\tset.mkdir_mode = 0700;\n\t}\n\n\treturn mail_storage_lock_create(lock_path, &set,\n\t\t\t\t\tbox->storage->set, lock_r, error_r);\n}\n"}, "24": {"id": 24, "path": "/usr/include/x86_64-linux-gnu/sys/stat.h", "content": "/* Copyright (C) 1991-2018 Free Software Foundation, Inc.\n   This file is part of the GNU C Library.\n\n   The GNU C Library is free software; you can redistribute it and/or\n   modify it under the terms of the GNU Lesser General Public\n   License as published by the Free Software Foundation; either\n   version 2.1 of the License, or (at your option) any later version.\n\n   The GNU C Library is distributed in the hope that it will be useful,\n   but WITHOUT ANY WARRANTY; without even the implied warranty of\n   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n   Lesser General Public License for more details.\n\n   You should have received a copy of the GNU Lesser General Public\n   License along with the GNU C Library; if not, see\n   <http://www.gnu.org/licenses/>.  */\n\n/*\n *\tPOSIX Standard: 5.6 File Characteristics\t<sys/stat.h>\n */\n\n#ifndef\t_SYS_STAT_H\n#define\t_SYS_STAT_H\t1\n\n#include <features.h>\n\n#include <bits/types.h>\t\t/* For __mode_t and __dev_t.  */\n\n#ifdef __USE_XOPEN2K8\n# include <bits/types/struct_timespec.h>\n#endif\n\n#if defined __USE_XOPEN || defined __USE_XOPEN2K\n/* The Single Unix specification says that some more types are\n   available here.  */\n\n# include <bits/types/time_t.h>\n\n# ifndef __dev_t_defined\ntypedef __dev_t dev_t;\n#  define __dev_t_defined\n# endif\n\n# ifndef __gid_t_defined\ntypedef __gid_t gid_t;\n#  define __gid_t_defined\n# endif\n\n# ifndef __ino_t_defined\n#  ifndef __USE_FILE_OFFSET64\ntypedef __ino_t ino_t;\n#  else\ntypedef __ino64_t ino_t;\n#  endif\n#  define __ino_t_defined\n# endif\n\n# ifndef __mode_t_defined\ntypedef __mode_t mode_t;\n#  define __mode_t_defined\n# endif\n\n# ifndef __nlink_t_defined\ntypedef __nlink_t nlink_t;\n#  define __nlink_t_defined\n# endif\n\n# ifndef __off_t_defined\n#  ifndef __USE_FILE_OFFSET64\ntypedef __off_t off_t;\n#  else\ntypedef __off64_t off_t;\n#  endif\n#  define __off_t_defined\n# endif\n\n# ifndef __uid_t_defined\ntypedef __uid_t uid_t;\n#  define __uid_t_defined\n# endif\n#endif\t/* X/Open */\n\n#ifdef __USE_UNIX98\n# ifndef __blkcnt_t_defined\n#  ifndef __USE_FILE_OFFSET64\ntypedef __blkcnt_t blkcnt_t;\n#  else\ntypedef __blkcnt64_t blkcnt_t;\n#  endif\n#  define __blkcnt_t_defined\n# endif\n\n# ifndef __blksize_t_defined\ntypedef __blksize_t blksize_t;\n#  define __blksize_t_defined\n# endif\n#endif\t/* Unix98 */\n\n__BEGIN_DECLS\n\n#include <bits/stat.h>\n\n#if defined __USE_MISC || defined __USE_XOPEN\n# define S_IFMT\t\t__S_IFMT\n# define S_IFDIR\t__S_IFDIR\n# define S_IFCHR\t__S_IFCHR\n# define S_IFBLK\t__S_IFBLK\n# define S_IFREG\t__S_IFREG\n# ifdef __S_IFIFO\n#  define S_IFIFO\t__S_IFIFO\n# endif\n# ifdef __S_IFLNK\n#  define S_IFLNK\t__S_IFLNK\n# endif\n# if (defined __USE_MISC || defined __USE_XOPEN_EXTENDED) \\\n     && defined __S_IFSOCK\n#  define S_IFSOCK\t__S_IFSOCK\n# endif\n#endif\n\n/* Test macros for file types.\t*/\n\n#define\t__S_ISTYPE(mode, mask)\t(((mode) & __S_IFMT) == (mask))\n\n#define\tS_ISDIR(mode)\t __S_ISTYPE((mode), __S_IFDIR)\n#define\tS_ISCHR(mode)\t __S_ISTYPE((mode), __S_IFCHR)\n#define\tS_ISBLK(mode)\t __S_ISTYPE((mode), __S_IFBLK)\n#define\tS_ISREG(mode)\t __S_ISTYPE((mode), __S_IFREG)\n#ifdef __S_IFIFO\n# define S_ISFIFO(mode)\t __S_ISTYPE((mode), __S_IFIFO)\n#endif\n#ifdef __S_IFLNK\n# define S_ISLNK(mode)\t __S_ISTYPE((mode), __S_IFLNK)\n#endif\n\n#if defined __USE_MISC && !defined __S_IFLNK\n# define S_ISLNK(mode)  0\n#endif\n\n#if (defined __USE_XOPEN_EXTENDED || defined __USE_XOPEN2K) \\\n    && defined __S_IFSOCK\n# define S_ISSOCK(mode) __S_ISTYPE((mode), __S_IFSOCK)\n#elif defined __USE_XOPEN2K\n# define S_ISSOCK(mode) 0\n#endif\n\n/* These are from POSIX.1b.  If the objects are not implemented using separate\n   distinct file types, the macros always will evaluate to zero.  Unlike the\n   other S_* macros the following three take a pointer to a `struct stat'\n   object as the argument.  */\n#ifdef\t__USE_POSIX199309\n# define S_TYPEISMQ(buf) __S_TYPEISMQ(buf)\n# define S_TYPEISSEM(buf) __S_TYPEISSEM(buf)\n# define S_TYPEISSHM(buf) __S_TYPEISSHM(buf)\n#endif\n\n\n/* Protection bits.  */\n\n#define\tS_ISUID __S_ISUID\t/* Set user ID on execution.  */\n#define\tS_ISGID\t__S_ISGID\t/* Set group ID on execution.  */\n\n#if defined __USE_MISC || defined __USE_XOPEN\n/* Save swapped text after use (sticky bit).  This is pretty well obsolete.  */\n# define S_ISVTX\t__S_ISVTX\n#endif\n\n#define\tS_IRUSR\t__S_IREAD\t/* Read by owner.  */\n#define\tS_IWUSR\t__S_IWRITE\t/* Write by owner.  */\n#define\tS_IXUSR\t__S_IEXEC\t/* Execute by owner.  */\n/* Read, write, and execute by owner.  */\n#define\tS_IRWXU\t(__S_IREAD|__S_IWRITE|__S_IEXEC)\n\n#ifdef __USE_MISC\n# define S_IREAD\tS_IRUSR\n# define S_IWRITE\tS_IWUSR\n# define S_IEXEC\tS_IXUSR\n#endif\n\n#define\tS_IRGRP\t(S_IRUSR >> 3)\t/* Read by group.  */\n#define\tS_IWGRP\t(S_IWUSR >> 3)\t/* Write by group.  */\n#define\tS_IXGRP\t(S_IXUSR >> 3)\t/* Execute by group.  */\n/* Read, write, and execute by group.  */\n#define\tS_IRWXG\t(S_IRWXU >> 3)\n\n#define\tS_IROTH\t(S_IRGRP >> 3)\t/* Read by others.  */\n#define\tS_IWOTH\t(S_IWGRP >> 3)\t/* Write by others.  */\n#define\tS_IXOTH\t(S_IXGRP >> 3)\t/* Execute by others.  */\n/* Read, write, and execute by others.  */\n#define\tS_IRWXO\t(S_IRWXG >> 3)\n\n\n#ifdef\t__USE_MISC\n/* Macros for common mode bit masks.  */\n# define ACCESSPERMS (S_IRWXU|S_IRWXG|S_IRWXO) /* 0777 */\n# define ALLPERMS (S_ISUID|S_ISGID|S_ISVTX|S_IRWXU|S_IRWXG|S_IRWXO)/* 07777 */\n# define DEFFILEMODE (S_IRUSR|S_IWUSR|S_IRGRP|S_IWGRP|S_IROTH|S_IWOTH)/* 0666*/\n\n# define S_BLKSIZE\t512\t/* Block size for `st_blocks'.  */\n#endif\n\n\n#ifndef __USE_FILE_OFFSET64\n/* Get file attributes for FILE and put them in BUF.  */\nextern int stat (const char *__restrict __file,\n\t\t struct stat *__restrict __buf) __THROW __nonnull ((1, 2));\n\n/* Get file attributes for the file, device, pipe, or socket\n   that file descriptor FD is open on and put them in BUF.  */\nextern int fstat (int __fd, struct stat *__buf) __THROW __nonnull ((2));\n#else\n# ifdef __REDIRECT_NTH\nextern int __REDIRECT_NTH (stat, (const char *__restrict __file,\n\t\t\t\t  struct stat *__restrict __buf), stat64)\n     __nonnull ((1, 2));\nextern int __REDIRECT_NTH (fstat, (int __fd, struct stat *__buf), fstat64)\n     __nonnull ((2));\n# else\n#  define stat stat64\n#  define fstat fstat64\n# endif\n#endif\n#ifdef __USE_LARGEFILE64\nextern int stat64 (const char *__restrict __file,\n\t\t   struct stat64 *__restrict __buf) __THROW __nonnull ((1, 2));\nextern int fstat64 (int __fd, struct stat64 *__buf) __THROW __nonnull ((2));\n#endif\n\n#ifdef __USE_ATFILE\n/* Similar to stat, get the attributes for FILE and put them in BUF.\n   Relative path names are interpreted relative to FD unless FD is\n   AT_FDCWD.  */\n# ifndef __USE_FILE_OFFSET64\nextern int fstatat (int __fd, const char *__restrict __file,\n\t\t    struct stat *__restrict __buf, int __flag)\n     __THROW __nonnull ((2, 3));\n# else\n#  ifdef __REDIRECT_NTH\nextern int __REDIRECT_NTH (fstatat, (int __fd, const char *__restrict __file,\n\t\t\t\t     struct stat *__restrict __buf,\n\t\t\t\t     int __flag),\n\t\t\t   fstatat64) __nonnull ((2, 3));\n#  else\n#   define fstatat fstatat64\n#  endif\n# endif\n\n# ifdef __USE_LARGEFILE64\nextern int fstatat64 (int __fd, const char *__restrict __file,\n\t\t      struct stat64 *__restrict __buf, int __flag)\n     __THROW __nonnull ((2, 3));\n# endif\n#endif\n\n#if defined __USE_XOPEN_EXTENDED || defined __USE_XOPEN2K\n# ifndef __USE_FILE_OFFSET64\n/* Get file attributes about FILE and put them in BUF.\n   If FILE is a symbolic link, do not follow it.  */\nextern int lstat (const char *__restrict __file,\n\t\t  struct stat *__restrict __buf) __THROW __nonnull ((1, 2));\n# else\n#  ifdef __REDIRECT_NTH\nextern int __REDIRECT_NTH (lstat,\n\t\t\t   (const char *__restrict __file,\n\t\t\t    struct stat *__restrict __buf), lstat64)\n     __nonnull ((1, 2));\n#  else\n#   define lstat lstat64\n#  endif\n# endif\n# ifdef __USE_LARGEFILE64\nextern int lstat64 (const char *__restrict __file,\n\t\t    struct stat64 *__restrict __buf)\n     __THROW __nonnull ((1, 2));\n# endif\n#endif\n\n/* Set file access permissions for FILE to MODE.\n   If FILE is a symbolic link, this affects its target instead.  */\nextern int chmod (const char *__file, __mode_t __mode)\n     __THROW __nonnull ((1));\n\n#ifdef __USE_MISC\n/* Set file access permissions for FILE to MODE.\n   If FILE is a symbolic link, this affects the link itself\n   rather than its target.  */\nextern int lchmod (const char *__file, __mode_t __mode)\n     __THROW __nonnull ((1));\n#endif\n\n/* Set file access permissions of the file FD is open on to MODE.  */\n#if defined __USE_POSIX199309 || defined __USE_XOPEN_EXTENDED\nextern int fchmod (int __fd, __mode_t __mode) __THROW;\n#endif\n\n#ifdef __USE_ATFILE\n/* Set file access permissions of FILE relative to\n   the directory FD is open on.  */\nextern int fchmodat (int __fd, const char *__file, __mode_t __mode,\n\t\t     int __flag)\n     __THROW __nonnull ((2)) __wur;\n#endif /* Use ATFILE.  */\n\n\n\n/* Set the file creation mask of the current process to MASK,\n   and return the old creation mask.  */\nextern __mode_t umask (__mode_t __mask) __THROW;\n\n#ifdef\t__USE_GNU\n/* Get the current `umask' value without changing it.\n   This function is only available under the GNU Hurd.  */\nextern __mode_t getumask (void) __THROW;\n#endif\n\n/* Create a new directory named PATH, with permission bits MODE.  */\nextern int mkdir (const char *__path, __mode_t __mode)\n     __THROW __nonnull ((1));\n\n#ifdef __USE_ATFILE\n/* Like mkdir, create a new directory with permission bits MODE.  But\n   interpret relative PATH names relative to the directory associated\n   with FD.  */\nextern int mkdirat (int __fd, const char *__path, __mode_t __mode)\n     __THROW __nonnull ((2));\n#endif\n\n/* Create a device file named PATH, with permission and special bits MODE\n   and device number DEV (which can be constructed from major and minor\n   device numbers with the `makedev' macro above).  */\n#if defined __USE_MISC || defined __USE_XOPEN_EXTENDED\nextern int mknod (const char *__path, __mode_t __mode, __dev_t __dev)\n     __THROW __nonnull ((1));\n\n# ifdef __USE_ATFILE\n/* Like mknod, create a new device file with permission bits MODE and\n   device number DEV.  But interpret relative PATH names relative to\n   the directory associated with FD.  */\nextern int mknodat (int __fd, const char *__path, __mode_t __mode,\n\t\t    __dev_t __dev) __THROW __nonnull ((2));\n# endif\n#endif\n\n\n/* Create a new FIFO named PATH, with permission bits MODE.  */\nextern int mkfifo (const char *__path, __mode_t __mode)\n     __THROW __nonnull ((1));\n\n#ifdef __USE_ATFILE\n/* Like mkfifo, create a new FIFO with permission bits MODE.  But\n   interpret relative PATH names relative to the directory associated\n   with FD.  */\nextern int mkfifoat (int __fd, const char *__path, __mode_t __mode)\n     __THROW __nonnull ((2));\n#endif\n\f\n#ifdef __USE_ATFILE\n/* Set file access and modification times relative to directory file\n   descriptor.  */\nextern int utimensat (int __fd, const char *__path,\n\t\t      const struct timespec __times[2],\n\t\t      int __flags)\n     __THROW __nonnull ((2));\n#endif\n\n#ifdef __USE_XOPEN2K8\n/* Set file access and modification times of the file associated with FD.  */\nextern int futimens (int __fd, const struct timespec __times[2]) __THROW;\n#endif\n\f\n/* To allow the `struct stat' structure and the file type `mode_t'\n   bits to vary without changing shared library major version number,\n   the `stat' family of functions and `mknod' are in fact inline\n   wrappers around calls to `xstat', `fxstat', `lxstat', and `xmknod',\n   which all take a leading version-number argument designating the\n   data structure and bits used.  <bits/stat.h> defines _STAT_VER with\n   the version number corresponding to `struct stat' as defined in\n   that file; and _MKNOD_VER with the version number corresponding to\n   the S_IF* macros defined therein.  It is arranged that when not\n   inlined these function are always statically linked; that way a\n   dynamically-linked executable always encodes the version number\n   corresponding to the data structures it uses, so the `x' functions\n   in the shared library can adapt without needing to recompile all\n   callers.  */\n\n#ifndef _STAT_VER\n# define _STAT_VER\t0\n#endif\n#ifndef _MKNOD_VER\n# define _MKNOD_VER\t0\n#endif\n\n/* Wrappers for stat and mknod system calls.  */\n#ifndef __USE_FILE_OFFSET64\nextern int __fxstat (int __ver, int __fildes, struct stat *__stat_buf)\n     __THROW __nonnull ((3));\nextern int __xstat (int __ver, const char *__filename,\n\t\t    struct stat *__stat_buf) __THROW __nonnull ((2, 3));\nextern int __lxstat (int __ver, const char *__filename,\n\t\t     struct stat *__stat_buf) __THROW __nonnull ((2, 3));\nextern int __fxstatat (int __ver, int __fildes, const char *__filename,\n\t\t       struct stat *__stat_buf, int __flag)\n     __THROW __nonnull ((3, 4));\n#else\n# ifdef __REDIRECT_NTH\nextern int __REDIRECT_NTH (__fxstat, (int __ver, int __fildes,\n\t\t\t\t      struct stat *__stat_buf), __fxstat64)\n     __nonnull ((3));\nextern int __REDIRECT_NTH (__xstat, (int __ver, const char *__filename,\n\t\t\t\t     struct stat *__stat_buf), __xstat64)\n     __nonnull ((2, 3));\nextern int __REDIRECT_NTH (__lxstat, (int __ver, const char *__filename,\n\t\t\t\t      struct stat *__stat_buf), __lxstat64)\n     __nonnull ((2, 3));\nextern int __REDIRECT_NTH (__fxstatat, (int __ver, int __fildes,\n\t\t\t\t\tconst char *__filename,\n\t\t\t\t\tstruct stat *__stat_buf, int __flag),\n\t\t\t   __fxstatat64) __nonnull ((3, 4));\n\n# else\n#  define __fxstat __fxstat64\n#  define __xstat __xstat64\n#  define __lxstat __lxstat64\n# endif\n#endif\n\n#ifdef __USE_LARGEFILE64\nextern int __fxstat64 (int __ver, int __fildes, struct stat64 *__stat_buf)\n     __THROW __nonnull ((3));\nextern int __xstat64 (int __ver, const char *__filename,\n\t\t      struct stat64 *__stat_buf) __THROW __nonnull ((2, 3));\nextern int __lxstat64 (int __ver, const char *__filename,\n\t\t       struct stat64 *__stat_buf) __THROW __nonnull ((2, 3));\nextern int __fxstatat64 (int __ver, int __fildes, const char *__filename,\n\t\t\t struct stat64 *__stat_buf, int __flag)\n     __THROW __nonnull ((3, 4));\n#endif\nextern int __xmknod (int __ver, const char *__path, __mode_t __mode,\n\t\t     __dev_t *__dev) __THROW __nonnull ((2, 4));\n\nextern int __xmknodat (int __ver, int __fd, const char *__path,\n\t\t       __mode_t __mode, __dev_t *__dev)\n     __THROW __nonnull ((3, 5));\n\n#ifdef __USE_EXTERN_INLINES\n/* Inlined versions of the real stat and mknod functions.  */\n\n__extern_inline int\n__NTH (stat (const char *__path, struct stat *__statbuf))\n{\n  return __xstat (_STAT_VER, __path, __statbuf);\n}\n\n# if defined __USE_MISC || defined __USE_XOPEN_EXTENDED\n__extern_inline int\n__NTH (lstat (const char *__path, struct stat *__statbuf))\n{\n  return __lxstat (_STAT_VER, __path, __statbuf);\n}\n# endif\n\n__extern_inline int\n__NTH (fstat (int __fd, struct stat *__statbuf))\n{\n  return __fxstat (_STAT_VER, __fd, __statbuf);\n}\n\n# ifdef __USE_ATFILE\n__extern_inline int\n__NTH (fstatat (int __fd, const char *__filename, struct stat *__statbuf,\n\t\tint __flag))\n{\n  return __fxstatat (_STAT_VER, __fd, __filename, __statbuf, __flag);\n}\n# endif\n\n# ifdef __USE_MISC\n__extern_inline int\n__NTH (mknod (const char *__path, __mode_t __mode, __dev_t __dev))\n{\n  return __xmknod (_MKNOD_VER, __path, __mode, &__dev);\n}\n# endif\n\n# ifdef __USE_ATFILE\n__extern_inline int\n__NTH (mknodat (int __fd, const char *__path, __mode_t __mode,\n\t\t__dev_t __dev))\n{\n  return __xmknodat (_MKNOD_VER, __fd, __path, __mode, &__dev);\n}\n# endif\n\n# if defined __USE_LARGEFILE64 \\\n  && (! defined __USE_FILE_OFFSET64 \\\n      || (defined __REDIRECT_NTH && defined __OPTIMIZE__))\n__extern_inline int\n__NTH (stat64 (const char *__path, struct stat64 *__statbuf))\n{\n  return __xstat64 (_STAT_VER, __path, __statbuf);\n}\n\n#  if defined __USE_MISC || defined __USE_XOPEN_EXTENDED\n__extern_inline int\n__NTH (lstat64 (const char *__path, struct stat64 *__statbuf))\n{\n  return __lxstat64 (_STAT_VER, __path, __statbuf);\n}\n#  endif\n\n__extern_inline int\n__NTH (fstat64 (int __fd, struct stat64 *__statbuf))\n{\n  return __fxstat64 (_STAT_VER, __fd, __statbuf);\n}\n\n#  ifdef __USE_ATFILE\n__extern_inline int\n__NTH (fstatat64 (int __fd, const char *__filename, struct stat64 *__statbuf,\n\t\t  int __flag))\n{\n  return __fxstatat64 (_STAT_VER, __fd, __filename, __statbuf, __flag);\n}\n#  endif\n\n# endif\n\n#endif\n\n__END_DECLS\n\n\n#endif /* sys/stat.h  */\n"}, "25": {"id": 25, "path": "/home/runner/work/testcc/testcc/retdec/src/lib/macros.h", "content": "#ifndef MACROS_H\n#define MACROS_H\n\n/* several useful macros, mostly from glib.h */\n\n#ifndef NULL\n#  define NULL ((void *)0)\n#endif\n\n#ifndef FALSE\n#  define FALSE (!1)\n#endif\n\n#ifndef TRUE\n#  define TRUE (!FALSE)\n#endif\n\n#define N_ELEMENTS(arr) \\\n\t(sizeof(arr) / sizeof((arr)[0]))\n\n#define MEM_ALIGN(size) \\\n\t(((size) + MEM_ALIGN_SIZE-1) & ~((size_t) MEM_ALIGN_SIZE-1))\n\n#define PTR_OFFSET(ptr, offset) \\\n\t((void *) (((uintptr_t) (ptr)) + ((size_t) (offset))))\n#define CONST_PTR_OFFSET(ptr, offset) \\\n\t((const void *) (((uintptr_t) (ptr)) + ((size_t) (offset))))\n\n#define container_of(ptr, type, name) \\\n\t(type *)((uintptr_t)(ptr) - (uintptr_t)offsetof(type, name) + \\\n\t\t COMPILE_ERROR_IF_TYPES_NOT_COMPATIBLE(ptr, &((type *) 0)->name))\n\n/* Don't use simply MIN/MAX, as they're often defined elsewhere in include\n   files that are included after this file generating tons of warnings. */\n#define I_MIN(a, b)  (((a) < (b)) ? (a) : (b))\n#define I_MAX(a, b)  (((a) > (b)) ? (a) : (b))\n\n/* make it easier to cast from/to pointers. assumes that\n   sizeof(uintptr_t) == sizeof(void *) and they're both the largest datatypes\n   that are allowed to be used. so, long long isn't safe with these. */\n#define POINTER_CAST(i) \\\n\t((void *) (((uintptr_t)NULL) + (i)))\n#define POINTER_CAST_TO(p, type) \\\n\t((type) ((const char *) (p) - (const char *) NULL))\n\n/* Define VA_COPY() to do the right thing for copying va_list variables.\n   config.h may have already defined VA_COPY as va_copy or __va_copy. */\n#ifndef VA_COPY\n#  if defined (__GNUC__) && defined (__PPC__) && \\\n      (defined (_CALL_SYSV) || defined (_WIN32))\n#    define VA_COPY(ap1, ap2) (*(ap1) = *(ap2))\n#  elif defined (VA_COPY_AS_ARRAY)\n#    define VA_COPY(ap1, ap2) memmove ((ap1), (ap2), sizeof (va_list))\n#  else /* va_list is a pointer */\n#    define VA_COPY(ap1, ap2) ((ap1) = (ap2))\n#  endif /* va_list is a pointer */\n#endif\n\n/* Provide convenience macros for handling structure\n * fields through their offsets.\n */\n#define STRUCT_MEMBER_P(struct_p, struct_offset) \\\n\t((void *) ((char *) (struct_p) + (long) (struct_offset)))\n#define CONST_STRUCT_MEMBER_P(struct_p, struct_offset) \\\n\t((const void *) ((const char *) (struct_p) + (long) (struct_offset)))\n\n/* Provide simple macro statement wrappers (adapted from Perl):\n   STMT_START { statements; } STMT_END;\n   can be used as a single statement, as in\n   if (x) STMT_START { ... } STMT_END; else ...\n\n   For gcc we will wrap the statements within `({' and `})' braces.\n   For SunOS they will be wrapped within `if (1)' and `else (void) 0',\n   and otherwise within `do' and `while (0)'. */\n#if !(defined (STMT_START) && defined (STMT_END))\n#  if defined (__GNUC__) && !defined (__cplusplus) && \\\n\t!defined (__STRICT_ANSI__) && !defined (PEDANTIC)\n#    define STMT_START (void)(\n#    define STMT_END   )\n#  else\n#    if (defined (sun) || defined (__sun__))\n#      define STMT_START if (1)\n#      define STMT_END   else (void)0\n#    else\n#      define STMT_START do\n#      define STMT_END   while (0)\n#    endif\n#  endif\n#endif\n\n/* Provide macros to feature the GCC function attribute. */\n#if __GNUC__ > 2 || (__GNUC__ == 2 && __GNUC_MINOR__ > 4)\n#  define ATTRS_DEFINED\n#  define ATTR_FORMAT(format_idx, arg_idx) \\\n\t__attribute__((format (printf, format_idx, arg_idx)))\n#  define ATTR_FORMAT_ARG(arg_idx) \\\n\t__attribute__((format_arg (arg_idx)))\n#  define ATTR_SCANF(format_idx, arg_idx) \\\n\t__attribute__((format (scanf, format_idx, arg_idx)))\n#  define ATTR_STRFTIME(format_idx) \\\n\t__attribute__((format (strftime, format_idx, 0)))\n#  define ATTR_UNUSED __attribute__((unused))\n#  define ATTR_NORETURN __attribute__((noreturn))\n#  define ATTR_CONST __attribute__((const))\n#  define ATTR_PURE __attribute__((pure))\n#else\n#  define ATTR_FORMAT(format_idx, arg_idx)\n#  define ATTR_FORMAT_ARG(arg_idx)\n#  define ATTR_SCANF(format_idx, arg_idx)\n#  define ATTR_STRFTIME(format_idx)\n#  define ATTR_UNUSED\n#  define ATTR_NORETURN\n#  define ATTR_CONST\n#  define ATTR_PURE\n#endif\n#ifdef HAVE_ATTR_NULL\n#  define ATTR_NULL(...) __attribute__((null(__VA_ARGS__)))\n#else\n#  define ATTR_NULL(...)\n#endif\n#ifdef HAVE_ATTR_NOWARN_UNUSED_RESULT\n#  define ATTR_NOWARN_UNUSED_RESULT __attribute__((nowarn_unused_result))\n#else\n#  define ATTR_NOWARN_UNUSED_RESULT\n#endif\n#if __GNUC__ > 2\n#  define ATTR_MALLOC __attribute__((malloc))\n#else\n#  define ATTR_MALLOC\n#endif\n#if __GNUC__ > 3\n/* GCC 4.0 and later */\n#  define ATTR_WARN_UNUSED_RESULT __attribute__((warn_unused_result))\n#  define ATTR_SENTINEL __attribute__((sentinel))\n#else\n#  define ATTR_WARN_UNUSED_RESULT\n#  define ATTR_SENTINEL\n#endif\n#if __GNUC__ > 4 || (__GNUC__ == 4 && __GNUC_MINOR__ >= 3)\n/* GCC 4.3 and later */\n#  define ATTR_HOT __attribute__((hot))\n#  define ATTR_COLD __attribute__((cold))\n#else\n#  define ATTR_HOT\n#  define ATTR_COLD\n#endif\n#if __GNUC__ > 4 || (__GNUC__ == 4 && __GNUC_MINOR__ >= 9)\n/* GCC 4.9 and later */\n#  define ATTR_RETURNS_NONNULL __attribute__((returns_nonnull))\n#else\n#  define ATTR_RETURNS_NONNULL\n#endif\n#ifdef HAVE_ATTR_DEPRECATED\n#  define ATTR_DEPRECATED(str) __attribute__((deprecated(str)))\n#else\n#  define ATTR_DEPRECATED(str)\n#endif\n\n/* Macros to provide type safety for callback functions' context parameters */\n#ifdef HAVE_TYPE_CHECKS\n#  define CALLBACK_TYPECHECK(callback, type) \\\n\t(COMPILE_ERROR_IF_TRUE(!__builtin_types_compatible_p( \\\n\t\ttypeof(&callback), type)) ? 1 : 0)\n#else\n#  define CALLBACK_TYPECHECK(callback, type) 0\n#endif\n\n#if (__GNUC__ > 3 || (__GNUC__ == 3 && __GNUC_MINOR__ > 0)) && !defined(__cplusplus)\n#  define COMPILE_ERROR_IF_TRUE(condition) \\\n\t(sizeof(char[1 - 2 * ((condition) ? 1 : 0)]) - 1)\n#else\n#  define COMPILE_ERROR_IF_TRUE(condition) 0\n#endif\n\n#ifdef HAVE_TYPE_CHECKS\n#  define COMPILE_ERROR_IF_TYPES_NOT_COMPATIBLE(_a, _b) \\\n\tCOMPILE_ERROR_IF_TRUE( \\\n\t\t!__builtin_types_compatible_p(typeof(_a), typeof(_b)))\n#define COMPILE_ERROR_IF_TYPES2_NOT_COMPATIBLE(_a1, _a2, _b) \\\n\tCOMPILE_ERROR_IF_TRUE( \\\n\t\t!__builtin_types_compatible_p(typeof(_a1), typeof(_b)) && \\\n\t\t!__builtin_types_compatible_p(typeof(_a2), typeof(_b)))\n#else\n#  define COMPILE_ERROR_IF_TYPES_NOT_COMPATIBLE(_a, _b) 0\n#  define COMPILE_ERROR_IF_TYPES2_NOT_COMPATIBLE(_a1, _a2, _b) 0\n#endif\n\n#if __GNUC__ > 2\n#  define unlikely(expr) (__builtin_expect((expr) ? 1 : 0, 0) != 0)\n#  define likely(expr) (__builtin_expect((expr) ? 1 : 0, 1) != 0)\n#else\n#  define unlikely(expr) expr\n#  define likely(expr) expr\n#endif\n\n#if defined(__clang__) && ((__clang_major__ > 4) || (__clang_major__ == 3 && __clang_minor__ >= 9))\n#  define ATTR_UNSIGNED_WRAPS __attribute__((no_sanitize(\"integer\")))\n#else\n#  define ATTR_UNSIGNED_WRAPS\n#endif\n\n/* Provide macros for error handling. */\n#ifdef DISABLE_ASSERTS\n#  define i_assert(expr)\n#else\n\n#define i_assert(expr)\t\t\tSTMT_START{\t\t\t\\\n     if (unlikely(!(expr)))\t\t\t\t\t\t\\\n       i_panic(\"file %s: line %d (%s): assertion failed: (%s)\",\t\t\\\n\t\t__FILE__,\t\t\t\t\t\t\\\n\t\t__LINE__,\t\t\t\t\t\t\\\n\t\t__func__,\t\t\t\t\t\\\n\t\t#expr);\t\t\t}STMT_END\n\n#endif\n\n#ifndef STATIC_CHECKER\n#  define i_unreached() \\\n\ti_panic(\"file %s: line %d: unreached\", __FILE__, __LINE__)\n#else\n#  define i_unreached() __builtin_unreachable()\n#endif\n\n/* Convenience macros to test the versions of dovecot. */\n#if defined DOVECOT_VERSION_MAJOR && defined DOVECOT_VERSION_MINOR\n#  define DOVECOT_PREREQ(maj, min) \\\n          ((DOVECOT_VERSION_MAJOR << 16) + DOVECOT_VERSION_MINOR >= ((maj) << 16) + (min))\n#else\n#  define DOVECOT_PREREQ(maj, min) 0\n#endif\n\n#ifdef __cplusplus\n#  undef STATIC_ARRAY\n#  define STATIC_ARRAY\n#endif\n\n/* Convenience wrappers for initializing a struct with zeros, although it can\n   be used for replacing other memset()s also.\n\n   // NOTE: This is the correct way to zero the whole array\n   char arr[5]; i_zero(&arr);\n   // This will give compiler error (or zero only the first element):\n   char arr[5]; i_zero(arr);\n*/\n#define i_zero(p) \\\n\tmemset(p, 0 + COMPILE_ERROR_IF_TRUE(sizeof(p) > sizeof(void *)), sizeof(*(p)))\n#define i_zero_safe(p) \\\n\tsafe_memset(p, 0 + COMPILE_ERROR_IF_TRUE(sizeof(p) > sizeof(void *)), sizeof(*(p)))\n\n#define ST_CHANGED(st_a, st_b) \\\n\t((st_a).st_mtime != (st_b).st_mtime || \\\n\t ST_MTIME_NSEC(st_a) != ST_MTIME_NSEC(st_b) || \\\n\t (st_a).st_size != (st_b).st_size || \\\n\t (st_a).st_ino != (st_b).st_ino)\n\n#endif\n"}, "9": {"id": 9, "path": "/home/runner/work/testcc/testcc/retdec/src/lib/bits.h", "content": "#ifndef BITS_H\n#define BITS_H\n\n#define UINT64_SUM_OVERFLOWS(a, b) \\\n\t(a > (uint64_t)-1 - b)\n\n#define BIT(n) (1u << (n))\n\n/* These expressions make it easy to ensure that bit test expressions\n   are boolean in order to satisfy the in-house -Wstrict-bool. */\n/* ((val & bits) == 0) is very common */\n#define HAS_NO_BITS(val,bits) (((val) & (bits)) == 0)\n/* ((val & bits) != 0) is even more common */\n/* Note - illogical behaviour if bits==0, fixing that requires potential\n   multiple evaluation, but it's a corner case that should never occur. */\n#define HAS_ANY_BITS(val,bits) (((val) & (bits)) != 0)\n/* ((val & bits) == bits) is uncommon */\n#define HAS_ALL_BITS(val,bits) ((~(val) & (bits)) == 0)\n\n/* Returns x, such that x is the smallest power of 2 >= num. */\nsize_t nearest_power(size_t num) ATTR_CONST;\n\n/* Returns TRUE if 2^x=num, i.e. if num has only a single bit set to 1. */\nstatic inline bool ATTR_CONST\nbits_is_power_of_two(uint64_t num)\n{\n\treturn num > 0 && (num & (num - 1)) == 0;\n}\n\n#if __GNUC__ > 3 || (__GNUC__ == 3 && __GNUC_MINOR__ >= 4)\nstatic inline unsigned int ATTR_CONST\nbits_required32(uint32_t num)\n{\n\treturn num == 0 ? 0 : 32 - __builtin_clz(num);\n}\nstatic inline unsigned int ATTR_CONST\nbits_required8(uint8_t num)   { return bits_required32(num); }\n\nstatic inline unsigned int ATTR_CONST\nbits_required16(uint16_t num) { return bits_required32(num); }\n\nstatic inline unsigned int ATTR_CONST\nbits_required64(uint64_t num)\n{\n\treturn num == 0 ? 0 : 64 - __builtin_clzll(num);\n}\n#else\nunsigned int bits_required8(uint8_t num) ATTR_CONST;\n\nstatic inline\nunsigned int bits_required16(uint16_t num)\n{\n\treturn (num <= 0xff) ? bits_required8(num)\n\t\t: 8 + bits_required8(num >> 8);\n}\nstatic inline\nunsigned int bits_required32(uint32_t num)\n{\n\treturn (num <= 0xffff) ? bits_required16(num)\n\t\t: 16 + bits_required16(num >> 16);\n}\nstatic inline\nunsigned int bits_required64(uint64_t num)\n{\n\treturn (num <= 0xffffffff) ? bits_required32(num)\n\t\t: 32 + bits_required32(num >> 32);\n}\n#endif\n\nstatic inline uint64_t\nbits_rotl64(uint64_t num, unsigned int count)\n{\n\tconst unsigned int mask = CHAR_BIT*sizeof(num) - 1;\n\tcount &= mask;\n\treturn (num << count) | (num >> (-count & mask));\n}\n\nstatic inline uint32_t\nbits_rotl32(uint32_t num, unsigned int count)\n{\n        const unsigned int mask = CHAR_BIT*sizeof(num) - 1;\n        count &= mask;\n        return (num << count) | (num >> (-count & mask));\n}\n\nstatic inline uint64_t\nbits_rotr64(uint64_t num, unsigned int count)\n{\n\tconst unsigned int mask = CHAR_BIT*sizeof(num) - 1;\n\tcount &= mask;\n\treturn (num >> count) | (num << (-count & mask));\n}\n\nstatic inline uint32_t\nbits_rotr32(uint32_t num, unsigned int count)\n{\n\tconst unsigned int mask = CHAR_BIT*sizeof(num) - 1;\n\tcount &= mask;\n\treturn (num >> count) | (num << (-count & mask));\n}\n\n/* These functions look too big to be inline, but in almost all expected\n   uses, 'fracbits' will be a compile-time constant, and most of the\n   expressions will simplify greatly.\n*/\n\n/* Perform a piecewise-linear approximation to a log2, with fracbits \"fractional\" bits.\n   Best explained with examples:\n   With 2 fractional bits splitting each power of 2 into 4 bands:\n     00,   01,   10,   11 ->   00,   01,   10,   11 (small corner cases)\n    100,  101,  110,  111 ->  100,  101,  110,  111 ([4-8) split into 4 bands)\n   1000, 1001, 1010, 1011 -> 1000, 1000, 1001, 1001 ([8-15) split ...\n   1100, 1101, 1110, 1111 -> 1010, 1010, 1011, 1011  ... into 4 bands)\n   [16..31) -> 11bb\n   [32..63) -> 100bb\n   [64..127) -> 101bb\n   [128..255) -> 110bb\n   e.g. 236 = 11101100 -> ((8-2)<<2 == 11000) + (111.....>> 5 == 111) - 100 == 11011\n */\nstatic inline unsigned int ATTR_CONST\nbits_fraclog(unsigned int val, unsigned int fracbits)\n{\n\tunsigned bits = bits_required32(val);\n\tif (bits <= fracbits + 1)\n\t\treturn val;\n\n\tunsigned int bandnum = bits - fracbits;\n\tunsigned int bandstart = bandnum << fracbits;\n\tunsigned int fracoffsbad = val >> (bandnum - 1); /* has leading 1 still */\n\tunsigned int bucket = bandstart + fracoffsbad - BIT(fracbits);\n\treturn bucket;\n}\nstatic inline unsigned int ATTR_CONST\nbits_fraclog_bucket_start(unsigned int bucket, unsigned int fracbits)\n{\n\tunsigned int bandnum = bucket >> fracbits;\n\tif (bandnum <= 1)\n\t\treturn bucket;\n\tif (fracbits == 0)\n\t\treturn BIT(bucket - 1);\n\tunsigned int fracoffs = bucket & (BIT(fracbits)-1);\n\tunsigned int fracoffs1 = BIT(fracbits) + fracoffs;\n\tunsigned int bandstart = fracoffs1 << (bandnum - 1);\n\treturn bandstart;\n}\nstatic inline unsigned int ATTR_CONST\nbits_fraclog_bucket_end(unsigned int bucket, unsigned int fracbits)\n{\n\tunsigned int bandnum = bucket >> fracbits;\n\tif (bandnum <= 1)\n\t\treturn bucket;\n\tif (fracbits == 0)\n\t\treturn BIT(bucket - 1) * 2 - 1;\n\tunsigned int fracoffs = bucket & (BIT(fracbits)-1);\n\tunsigned int nextfracoffs1 = 1 + BIT(fracbits) + fracoffs;\n\tunsigned int nextbandstart = nextfracoffs1 << (bandnum - 1);\n\treturn nextbandstart - 1;\n}\n/* UNSAFE: multiple use of parameter (but expecting a constant in reality).\n   But a macro as it's most likely to be used to declare an array size.\n*/\n#define BITS_FRACLOG_BUCKETS(bits) ((33u - (bits)) << (bits))\n\n#endif\n"}, "26": {"id": 26, "path": "/home/runner/work/testcc/testcc/retdec/src/lib-storage/mail-storage.h", "content": "#ifndef MAIL_STORAGE_H\n#define MAIL_STORAGE_H\n\nstruct message_size;\n\n#include \"seq-range-array.h\"\n#include \"file-lock.h\"\n#include \"guid.h\"\n#include \"mail-types.h\"\n#include \"mail-error.h\"\n#include \"mail-index.h\"\n#include \"mail-namespace.h\"\n#include \"mailbox-list.h\"\n#include \"mailbox-attribute.h\"\n\n/* If some operation is taking long, call notify_ok every n seconds. */\n#define MAIL_STORAGE_STAYALIVE_SECS 15\n\n#define MAIL_KEYWORD_HAS_ATTACHMENT \"$HasAttachment\"\n#define MAIL_KEYWORD_HAS_NO_ATTACHMENT \"$HasNoAttachment\"\n\nenum mail_storage_flags {\n\t/* Remember message headers' MD5 sum */\n\tMAIL_STORAGE_FLAG_KEEP_HEADER_MD5\t= 0x01,\n\t/* Don't try to autodetect anything, require that the given data \n\t   contains all the necessary information. */\n\tMAIL_STORAGE_FLAG_NO_AUTODETECTION\t= 0x02,\n\t/* Don't autocreate any directories. If they don't exist,\n\t   fail to create the storage. */\n\tMAIL_STORAGE_FLAG_NO_AUTOCREATE\t\t= 0x04,\n\t/* Don't verify existence or accessibility of any directories.\n\t   Create the storage in any case. */\n\tMAIL_STORAGE_FLAG_NO_AUTOVERIFY\t\t= 0x08\n};\n\nenum mailbox_flags {\n\t/* Mailbox must not be modified even if asked */\n\tMAILBOX_FLAG_READONLY\t\t= 0x01,\n\t/* Only saving/copying mails to mailbox works. */\n\tMAILBOX_FLAG_SAVEONLY\t\t= 0x02,\n\t/* Remove MAIL_RECENT flags when syncing */\n\tMAILBOX_FLAG_DROP_RECENT\t= 0x04,\n\t/* Don't create index files for the mailbox */\n\tMAILBOX_FLAG_NO_INDEX_FILES\t= 0x10,\n\t/* Keep mailbox exclusively locked all the time while it's open */\n\tMAILBOX_FLAG_KEEP_LOCKED\t= 0x20,\n\t/* Enable if mailbox is used for serving POP3. This allows making\n\t   better caching decisions. */\n\tMAILBOX_FLAG_POP3_SESSION\t= 0x40,\n\t/* Enable if mailbox is used for saving a mail delivery using MDA.\n\t   This causes ACL plugin to use POST right rather than INSERT. */\n\tMAILBOX_FLAG_POST_SESSION\t= 0x80,\n\t/* Force opening mailbox and ignoring any ACLs */\n\tMAILBOX_FLAG_IGNORE_ACLS\t= 0x100,\n\t/* Open mailbox even if it's already marked as deleted */\n\tMAILBOX_FLAG_OPEN_DELETED\t= 0x200,\n\t/* Mailbox is opened for deletion, which should be performed as\n\t   efficiently as possible, even allowing the mailbox state to become\n\t   inconsistent. For example this disables lazy_expunge plugin and\n\t   quota updates (possibly resulting in broken quota). and This is\n\t   useful for example when deleting entire user accounts. */\n\tMAILBOX_FLAG_DELETE_UNSAFE\t= 0x400,\n\t/* Mailbox is created implicitly if it does not exist. */\n\tMAILBOX_FLAG_AUTO_CREATE\t= 0x1000,\n\t/* Mailbox is subscribed to implicitly when it is created automatically */\n\tMAILBOX_FLAG_AUTO_SUBSCRIBE\t= 0x2000,\n\t/* Run fsck for mailbox index before doing anything else. This may be\n\t   useful in fixing index corruption errors that aren't otherwise\n\t   detected and that are causing the full mailbox opening to fail. */\n\tMAILBOX_FLAG_FSCK\t\t= 0x4000,\n\t/* Interpret name argument for mailbox_alloc_for_user() as a SPECIAL-USE\n\t   flag. */\n\tMAILBOX_FLAG_SPECIAL_USE\t= 0x8000,\n\t/* Mailbox is opened for reading/writing attributes. This allows ACL\n\t   plugin to determine correctly whether the mailbox should be allowed\n\t   to be opened. */\n\tMAILBOX_FLAG_ATTRIBUTE_SESSION\t= 0x10000,\n};\n\nenum mailbox_feature {\n\t/* Enable tracking modsequences */\n\tMAILBOX_FEATURE_CONDSTORE\t= 0x01,\n};\n\nenum mailbox_existence {\n\tMAILBOX_EXISTENCE_NONE,\n\tMAILBOX_EXISTENCE_NOSELECT,\n\tMAILBOX_EXISTENCE_SELECT\n};\n\nenum mailbox_status_items {\n\tSTATUS_MESSAGES\t\t= 0x01,\n\tSTATUS_RECENT\t\t= 0x02,\n\tSTATUS_UIDNEXT\t\t= 0x04,\n\tSTATUS_UIDVALIDITY\t= 0x08,\n\tSTATUS_UNSEEN\t\t= 0x10,\n\tSTATUS_FIRST_UNSEEN_SEQ\t= 0x20,\n\tSTATUS_KEYWORDS\t\t= 0x40,\n\tSTATUS_HIGHESTMODSEQ\t= 0x80,\n\tSTATUS_PERMANENT_FLAGS\t= 0x200,\n\tSTATUS_FIRST_RECENT_UID\t= 0x400,\n\tSTATUS_LAST_CACHED_SEQ\t= 0x800,\n\tSTATUS_CHECK_OVER_QUOTA\t= 0x1000, /* return error if over quota */\n\tSTATUS_HIGHESTPVTMODSEQ\t= 0x2000,\n\t/* status items that must not be looked up with\n\t   mailbox_get_open_status(), because they can return failure. */\n#define MAILBOX_STATUS_FAILING_ITEMS \\\n\t(STATUS_LAST_CACHED_SEQ | STATUS_CHECK_OVER_QUOTA)\n};\n\nenum mailbox_metadata_items {\n\tMAILBOX_METADATA_GUID\t\t\t= 0x01,\n\tMAILBOX_METADATA_VIRTUAL_SIZE\t\t= 0x02,\n\tMAILBOX_METADATA_CACHE_FIELDS\t\t= 0x04,\n\tMAILBOX_METADATA_PRECACHE_FIELDS\t= 0x08,\n\tMAILBOX_METADATA_BACKEND_NAMESPACE\t= 0x10,\n\tMAILBOX_METADATA_PHYSICAL_SIZE\t\t= 0x20,\n\tMAILBOX_METADATA_FIRST_SAVE_DATE\t= 0x40\n\t/* metadata items that require mailbox to be synced at least once. */\n#define MAILBOX_METADATA_SYNC_ITEMS \\\n\t(MAILBOX_METADATA_VIRTUAL_SIZE | MAILBOX_METADATA_PHYSICAL_SIZE | \\\n\t MAILBOX_METADATA_FIRST_SAVE_DATE)\n};\n\nenum mailbox_search_result_flags {\n\t/* Update search results whenever the mailbox view is synced.\n\t   Expunged messages are removed even without this flag. */\n\tMAILBOX_SEARCH_RESULT_FLAG_UPDATE\t= 0x01,\n\t/* Queue changes so _sync() can be used. */\n\tMAILBOX_SEARCH_RESULT_FLAG_QUEUE_SYNC\t= 0x02\n};\n\nenum mail_sort_type {\n\tMAIL_SORT_ARRIVAL\t= 0x0001,\n\tMAIL_SORT_CC\t\t= 0x0002,\n\tMAIL_SORT_DATE\t\t= 0x0004,\n\tMAIL_SORT_FROM\t\t= 0x0008,\n\tMAIL_SORT_SIZE\t\t= 0x0010,\n\tMAIL_SORT_SUBJECT\t= 0x0020,\n\tMAIL_SORT_TO\t\t= 0x0040,\n\tMAIL_SORT_RELEVANCY\t= 0x0080,\n\tMAIL_SORT_DISPLAYFROM\t= 0x0100,\n\tMAIL_SORT_DISPLAYTO\t= 0x0200,\n\tMAIL_SORT_POP3_ORDER\t= 0x0400,\n/* Maximum size for sort program (each one separately + END) */\n#define MAX_SORT_PROGRAM_SIZE (11 + 1)\n\n\tMAIL_SORT_MASK\t\t= 0x0fff,\n\tMAIL_SORT_FLAG_REVERSE\t= 0x1000, /* reverse this mask type */\n\n\tMAIL_SORT_END\t\t= 0x0000 /* ends sort program */\n};\n\nenum mail_fetch_field {\n\tMAIL_FETCH_FLAGS\t\t= 0x00000001,\n\tMAIL_FETCH_MESSAGE_PARTS\t= 0x00000002,\n\n\tMAIL_FETCH_STREAM_HEADER\t= 0x00000004,\n\tMAIL_FETCH_STREAM_BODY\t\t= 0x00000008,\n\n\tMAIL_FETCH_DATE\t\t\t= 0x00000010,\n\tMAIL_FETCH_RECEIVED_DATE\t= 0x00000020,\n\tMAIL_FETCH_SAVE_DATE\t\t= 0x00000040,\n\tMAIL_FETCH_PHYSICAL_SIZE\t= 0x00000080,\n\tMAIL_FETCH_VIRTUAL_SIZE\t\t= 0x00000100,\n\n\t/* Set has_nuls / has_no_nuls fields */\n\tMAIL_FETCH_NUL_STATE\t\t= 0x00000200,\n\n\tMAIL_FETCH_STREAM_BINARY\t= 0x00000400,\n\n\t/* specials: */\n\tMAIL_FETCH_IMAP_BODY\t\t= 0x00001000,\n\tMAIL_FETCH_IMAP_BODYSTRUCTURE\t= 0x00002000,\n\tMAIL_FETCH_IMAP_ENVELOPE\t= 0x00004000,\n\tMAIL_FETCH_FROM_ENVELOPE\t= 0x00008000,\n\tMAIL_FETCH_HEADER_MD5\t\t= 0x00010000,\n\tMAIL_FETCH_STORAGE_ID\t\t= 0x00020000,\n\tMAIL_FETCH_UIDL_BACKEND\t\t= 0x00040000,\n\tMAIL_FETCH_MAILBOX_NAME\t\t= 0x00080000,\n\tMAIL_FETCH_SEARCH_RELEVANCY\t= 0x00100000,\n\tMAIL_FETCH_GUID\t\t\t= 0x00200000,\n\tMAIL_FETCH_POP3_ORDER\t\t= 0x00400000,\n\tMAIL_FETCH_REFCOUNT\t\t= 0x00800000,\n\tMAIL_FETCH_BODY_SNIPPET\t\t= 0x01000000,\n\tMAIL_FETCH_REFCOUNT_ID\t\t= 0x02000000,\n};\n\nenum mailbox_transaction_flags {\n\t/* Hide changes done in this transaction from next view sync */\n\tMAILBOX_TRANSACTION_FLAG_HIDE\t\t= 0x01,\n\t/* External transaction. Should be used for copying and appends,\n\t   but nothing else. */\n\tMAILBOX_TRANSACTION_FLAG_EXTERNAL\t= 0x02,\n\t/* Always assign UIDs to messages when saving/copying. Normally this\n\t   is done only if it can be done easily. */\n\tMAILBOX_TRANSACTION_FLAG_ASSIGN_UIDS\t= 0x04,\n\t/* Refresh the index so lookups return latest flags/modseqs */\n\tMAILBOX_TRANSACTION_FLAG_REFRESH\t= 0x08,\n\t/* Don't update caching decisions no matter what we do in this\n\t   transaction (useful for e.g. precaching) */\n\tMAILBOX_TRANSACTION_FLAG_NO_CACHE_DEC\t= 0x10,\n\t/* Sync transaction describes changes to mailbox that already happened\n\t   to another mailbox with whom we're syncing with (dsync) */\n\tMAILBOX_TRANSACTION_FLAG_SYNC\t\t= 0x20,\n\t/* Don't trigger any notifications for this transaction. This\n\t   especially means the notify plugin. This would normally be used only\n\t   with _FLAG_SYNC. */\n\tMAILBOX_TRANSACTION_FLAG_NO_NOTIFY\t= 0x40,\n};\n\nenum mailbox_sync_flags {\n\t/* Make sure we sync all external changes done to mailbox */\n\tMAILBOX_SYNC_FLAG_FULL_READ\t\t= 0x01,\n\t/* Make sure we write all our internal changes into the mailbox */\n\tMAILBOX_SYNC_FLAG_FULL_WRITE\t\t= 0x02,\n\t/* If it's not too much trouble, check if there are some changes */\n\tMAILBOX_SYNC_FLAG_FAST\t\t\t= 0x04,\n\n\t/* Don't sync expunges from our view */\n\tMAILBOX_SYNC_FLAG_NO_EXPUNGES\t\t= 0x08,\n\t/* If mailbox is currently inconsistent, fix it instead of failing. */\n\tMAILBOX_SYNC_FLAG_FIX_INCONSISTENT\t= 0x40,\n\t/* Syncing after an EXPUNGE command. This is just an informational\n\t   flag for plugins. */\n\tMAILBOX_SYNC_FLAG_EXPUNGE\t\t= 0x80,\n\t/* Force doing a full resync of indexes. */\n\tMAILBOX_SYNC_FLAG_FORCE_RESYNC\t\t= 0x100,\n\t/* FIXME: kludge until something better comes along:\n\t   Request full text search index optimization */\n\tMAILBOX_SYNC_FLAG_OPTIMIZE\t\t= 0x400\n};\n\nenum mailbox_sync_type {\n\tMAILBOX_SYNC_TYPE_EXPUNGE\t= 0x01,\n\tMAILBOX_SYNC_TYPE_FLAGS\t\t= 0x02,\n\tMAILBOX_SYNC_TYPE_MODSEQ\t= 0x04\n};\n\nstruct message_part;\nstruct mail_namespace;\nstruct mail_storage;\nstruct mail_search_args;\nstruct mail_search_result;\nstruct mail_keywords;\nstruct mail_save_context;\nstruct mailbox;\nstruct mailbox_transaction_context;\n\nstruct mailbox_status {\n\tuint32_t messages; /* STATUS_MESSAGES */\n\tuint32_t recent; /* STATUS_RECENT */\n\tuint32_t unseen; /* STATUS_UNSEEN */\n\n\tuint32_t uidvalidity; /* STATUS_UIDVALIDITY */\n\tuint32_t uidnext; /* STATUS_UIDNEXT */\n\n\tuint32_t first_unseen_seq; /* STATUS_FIRST_UNSEEN_SEQ */\n\tuint32_t first_recent_uid; /* STATUS_FIRST_RECENT_UID */\n\tuint32_t last_cached_seq; /* STATUS_LAST_CACHED_SEQ */\n\tuint64_t highest_modseq; /* STATUS_HIGHESTMODSEQ */\n\t/* 0 if no private index (STATUS_HIGHESTPVTMODSEQ) */\n\tuint64_t highest_pvt_modseq;\n\n\t/* NULL-terminated array of keywords (STATUS_KEYWORDS) */\n\tconst ARRAY_TYPE(keywords) *keywords;\n\n\t/* These flags can be permanently modified (STATUS_PERMANENT_FLAGS) */\n\tenum mail_flags permanent_flags;\n\t/* These flags can be modified (STATUS_PERMANENT_FLAGS) */\n\tenum mail_flags flags;\n\n\t/* All keywords can be permanently modified (STATUS_PERMANENT_FLAGS) */\n\tbool permanent_keywords:1;\n\t/* More keywords can be created (STATUS_PERMANENT_FLAGS) */\n\tbool allow_new_keywords:1;\n\t/* Modseqs aren't permanent (index is in memory) (STATUS_HIGHESTMODSEQ) */\n\tbool nonpermanent_modseqs:1;\n\t/* Modseq tracking has never been enabled for this mailbox\n\t   yet. (STATUS_HIGHESTMODSEQ) */\n\tbool no_modseq_tracking:1;\n\n\t/* Messages have GUIDs (always set) */\n\tbool have_guids:1;\n\t/* mailbox_save_set_guid() works (always set) */\n\tbool have_save_guids:1;\n\t/* GUIDs are always 128bit (always set) */\n\tbool have_only_guid128:1;\n};\n\nstruct mailbox_cache_field {\n\tconst char *name;\n\tint decision; /* enum mail_cache_decision_type */\n\t/* last_used is unchanged, if it's (time_t)-1 */\n\ttime_t last_used;\n};\nARRAY_DEFINE_TYPE(mailbox_cache_field, struct mailbox_cache_field);\n\nstruct mailbox_metadata {\n\tguid_128_t guid;\n\t/* sum of virtual size of all messages in mailbox */\n\tuint64_t virtual_size;\n\t/* sum of physical size of all messages in mailbox */\n\tuint64_t physical_size;\n\t/* timestamp of when the first message was saved.\n\t   (time_t)-1 if there are no mails in the mailbox. */\n\ttime_t first_save_date;\n\n\t/* Fields that have \"temp\" or \"yes\" caching decision. */\n\tconst ARRAY_TYPE(mailbox_cache_field) *cache_fields;\n\t/* Fields that should be precached */\n\tenum mail_fetch_field precache_fields;\n\n\t/* imapc backend returns this based on the remote NAMESPACE reply,\n\t   while currently other backends return \"\" and type the same as the\n\t   mailbox's real namespace type */\n\tconst char *backend_ns_prefix;\n\tenum mail_namespace_type backend_ns_type;\n};\n\nstruct mailbox_update {\n\t/* All non-zero fields are changed. */\n\tguid_128_t mailbox_guid;\n\tuint32_t uid_validity;\n\tuint32_t min_next_uid;\n\tuint32_t min_first_recent_uid;\n\tuint64_t min_highest_modseq;\n\tuint64_t min_highest_pvt_modseq;\n\t/* Modify caching decisions, terminated by name=NULL */\n\tconst struct mailbox_cache_field *cache_updates;\n};\n\nstruct mail_transaction_commit_changes {\n\t/* Unreference the pool to free memory used by these changes. */\n\tpool_t pool;\n\n\t/* UIDVALIDITY for assigned UIDs. */\n\tuint32_t uid_validity;\n\t/* UIDs assigned to saved messages. Not necessarily ascending.\n\t   If UID assignment wasn't required (e.g. LDA), this array may also be\n\t   empty. Otherwise all of the saved mails got an UID. */\n\tARRAY_TYPE(seq_range) saved_uids;\n\n\t/* number of modseq changes that couldn't be changed as requested */\n\tunsigned int ignored_modseq_changes;\n\n\t/* Changes that occurred within this transaction */\n\tenum mail_index_transaction_change changes_mask;\n\t/* User doesn't have read ACL for the mailbox, so don't show the\n\t   uid_validity / saved_uids. */\n\tbool no_read_perm;\n};\n\nstruct mailbox_sync_rec {\n\tuint32_t seq1, seq2;\n\tenum mailbox_sync_type type;\n};\nstruct mailbox_sync_status {\n\t/* There are expunges that haven't been synced yet */\n\tbool sync_delayed_expunges:1;\n};\n\nstruct mailbox_expunge_rec {\n\t/* IMAP UID */\n\tuint32_t uid;\n\t/* 128 bit GUID. If the actual GUID has a different size, this\n\t   contains last bits of its SHA1 sum. */\n\tguid_128_t guid_128;\n};\nARRAY_DEFINE_TYPE(mailbox_expunge_rec, struct mailbox_expunge_rec);\n\nenum mail_lookup_abort {\n\t/* Perform everything no matter what it takes */\n\tMAIL_LOOKUP_ABORT_NEVER = 0,\n\t/* Abort if the operation would require reading message header/body or\n\t   otherwise opening the mail file (e.g. with dbox metadata is read by\n\t   opening and reading the file). This still allows somewhat fast\n\t   operations to be performed, such as stat()ing a file. */\n\tMAIL_LOOKUP_ABORT_READ_MAIL,\n\t/* Abort if the operation can't be done fully using cache file */\n\tMAIL_LOOKUP_ABORT_NOT_IN_CACHE,\n\t/* Abort if the operation can't be done fully using cache file.\n\t * During this lookup all cache lookups that have \"no\" decision\n\t * will be changed to \"tmp\". This way the field will start to be\n\t * cached in the future. */\n\tMAIL_LOOKUP_ABORT_NOT_IN_CACHE_START_CACHING,\n};\n\nenum mail_access_type {\n\tMAIL_ACCESS_TYPE_DEFAULT = 0,\n\t/* Mail is being used for searching */\n\tMAIL_ACCESS_TYPE_SEARCH,\n\t/* Mail is being used for sorting results */\n\tMAIL_ACCESS_TYPE_SORT,\n};\n\nstruct mail {\n\t/* always set */\n\tstruct mailbox *box;\n\tstruct mailbox_transaction_context *transaction;\n\tstruct event *event;\n\tuint32_t seq, uid;\n\n\tbool expunged:1;\n\tbool saving:1; /* This mail is still being saved */\n\tbool has_nuls:1; /* message data is known to contain NULs */\n\tbool has_no_nuls:1; /* -''- known to not contain NULs */\n\n\t/* Mail's header/body stream was opened within this request.\n\t   If lookup_abort!=MAIL_LOOKUP_ABORT_NEVER, this can't become TRUE. */\n\tbool mail_stream_opened:1;\n\t/* Mail's fast metadata was accessed within this request, e.g. the mail\n\t   file was stat()ed. If mail_stream_opened==TRUE, this value isn't\n\t   accurate anymore, because some backends may always set this when\n\t   stream is opened and some don't. If lookup_abort is\n\t   MAIL_LOOKUP_ABORT_NOT_IN_CACHE, this can't become TRUE. */\n\tbool mail_metadata_accessed:1;\n\n\tenum mail_access_type access_type;\n\n\t/* If the lookup is aborted, error is set to MAIL_ERROR_NOTPOSSIBLE */\n\tenum mail_lookup_abort lookup_abort;\n};\n\nstruct mail_storage_callbacks {\n\t/* \"* OK <text>\" */\n\tvoid (*notify_ok)(struct mailbox *mailbox, const char *text,\n\t\t\t  void *context);\n\t/* \"* NO <text>\" */\n\tvoid (*notify_no)(struct mailbox *mailbox, const char *text,\n\t\t\t  void *context);\n\n};\n\nstruct mailbox_virtual_pattern {\n\tstruct mail_namespace *ns;\n\tconst char *pattern;\n};\nARRAY_DEFINE_TYPE(mailbox_virtual_patterns, struct mailbox_virtual_pattern);\nARRAY_DEFINE_TYPE(mail_storage, struct mail_storage *);\nARRAY_DEFINE_TYPE(mailboxes, struct mailbox *);\n\nextern ARRAY_TYPE(mail_storage) mail_storage_classes;\n\ntypedef void mailbox_notify_callback_t(struct mailbox *box, void *context);\n\nvoid mail_storage_init(void);\nvoid mail_storage_deinit(void);\n\n/* register all mail storages */\nvoid mail_storage_register_all(void);\n\n/* Register mail storage class with given name - all methods that are NULL\n   are set to default methods */\nvoid mail_storage_class_register(struct mail_storage *storage_class);\nvoid mail_storage_class_unregister(struct mail_storage *storage_class);\n/* Find mail storage class by name */\nstruct mail_storage *mail_storage_find_class(const char *name);\n\n/* Create a new instance of registered mail storage class with given\n   storage-specific data. If driver is NULL, it's tried to be autodetected\n   from ns location. If ns location is NULL, it uses the first storage that\n   exists. The storage is put into ns->storage. */\nint mail_storage_create(struct mail_namespace *ns, const char *driver,\n\t\t\tenum mail_storage_flags flags, const char **error_r)\n\tATTR_NULL(2);\nint mail_storage_create_full(struct mail_namespace *ns, const char *driver,\n\t\t\t     const char *data, enum mail_storage_flags flags,\n\t\t\t     struct mail_storage **storage_r,\n\t\t\t     const char **error_r) ATTR_NULL(2);\nvoid mail_storage_unref(struct mail_storage **storage);\n\n/* Returns the mail storage settings. */\nconst struct mail_storage_settings *\nmail_storage_get_settings(struct mail_storage *storage) ATTR_PURE;\nstruct mail_user *mail_storage_get_user(struct mail_storage *storage) ATTR_PURE;\n\n/* Set storage callback functions to use. */\nvoid mail_storage_set_callbacks(struct mail_storage *storage,\n\t\t\t\tstruct mail_storage_callbacks *callbacks,\n\t\t\t\tvoid *context) ATTR_NULL(3);\n\n/* Purge storage's mailboxes (freeing disk space from expunged mails),\n   if supported by the storage. Otherwise just a no-op. */\nint mail_storage_purge(struct mail_storage *storage);\n\n/* Returns the error message of last occurred error. */\nconst char * ATTR_NOWARN_UNUSED_RESULT\nmail_storage_get_last_error(struct mail_storage *storage,\n\t\t\t    enum mail_error *error_r) ATTR_NULL(2);\n/* Wrapper for mail_storage_get_last_error(); */\nconst char * ATTR_NOWARN_UNUSED_RESULT\nmailbox_get_last_error(struct mailbox *box, enum mail_error *error_r)\n\tATTR_NULL(2);\n/* Wrapper for mail_storage_get_last_error(); */\nenum mail_error mailbox_get_last_mail_error(struct mailbox *box);\n\nconst char * ATTR_NOWARN_UNUSED_RESULT\nmail_storage_get_last_internal_error(struct mail_storage *storage,\n\t\t\t\t     enum mail_error *error_r) ATTR_NULL(2);\n/* Wrapper for mail_storage_get_last_internal_error(); */\nconst char * ATTR_NOWARN_UNUSED_RESULT\nmailbox_get_last_internal_error(struct mailbox *box,\n\t\t\t\tenum mail_error *error_r) ATTR_NULL(2);\n\n/* Save the last error until it's popped. This is useful for cases where the\n   storage has already failed, but the cleanup code path changes the error to\n   something else unwanted. */\nvoid mail_storage_last_error_push(struct mail_storage *storage);\nvoid mail_storage_last_error_pop(struct mail_storage *storage);\n\n/* Returns TRUE if mailboxes are files. */\nbool mail_storage_is_mailbox_file(struct mail_storage *storage) ATTR_PURE;\n\n/* Initialize mailbox without actually opening any files or verifying that\n   it exists. Note that append and copy may open the selected mailbox again\n   with possibly different readonly-state. */\nstruct mailbox *mailbox_alloc(struct mailbox_list *list, const char *vname,\n\t\t\t      enum mailbox_flags flags);\n/* Like mailbox_alloc(), but use mailbox GUID. */\nstruct mailbox *mailbox_alloc_guid(struct mailbox_list *list,\n\t\t\t\t   const guid_128_t guid,\n\t\t\t\t   enum mailbox_flags flags);\n/* Initialize mailbox for a particular user without actually opening any files\n   or verifying that it exists. The mname parameter is normally equal to the\n   mailbox vname, except when the MAILBOX_FLAG_SPECIAL_USE flag is set, in which\n   case it is the special-use flag. */\nstruct mailbox *\nmailbox_alloc_for_user(struct mail_user *user, const char *mname,\n\t\t       enum mailbox_flags flags);\n\n/* Set a human-readable reason for why this mailbox is being accessed.\n   This is used for logging purposes. */\nvoid mailbox_set_reason(struct mailbox *box, const char *reason);\n/* Get mailbox existence state. If auto_boxes=FALSE, return\n   MAILBOX_EXISTENCE_NONE for autocreated mailboxes that haven't been\n   physically created yet */\nint mailbox_exists(struct mailbox *box, bool auto_boxes,\n\t\t   enum mailbox_existence *existence_r);\n/* Open the mailbox. If this function isn't called explicitly, it's also called\n   internally by lib-storage when necessary. */\nint mailbox_open(struct mailbox *box);\n/* Open mailbox as read-only using the given stream as input. */\nint mailbox_open_stream(struct mailbox *box, struct istream *input);\n/* Close mailbox. Same as if mailbox was freed and re-allocated. */\nvoid mailbox_close(struct mailbox *box);\n/* Close and free the mailbox. */\nvoid mailbox_free(struct mailbox **box);\n\n/* Returns TRUE if box1 points to the same mailbox as ns2/vname2. */\nbool mailbox_equals(const struct mailbox *box1,\n\t\t    const struct mail_namespace *ns2,\n\t\t    const char *vname2) ATTR_PURE;\n/* Returns TRUE if the mailbox is user's INBOX or another user's shared INBOX */\nbool mailbox_is_any_inbox(struct mailbox *box);\n\n/* Returns TRUE if the mailbox has the specified special use flag assigned. */\nbool mailbox_has_special_use(struct mailbox *box, const char *special_use);\n\n/* Change mailbox_verify_create_name() to not verify new mailbox name\n   restrictions (but still check that it's a valid existing name). This is\n   mainly used by dsync to make sure the sync works even though the original\n   name isn't valid anymore. */\nvoid mailbox_skip_create_name_restrictions(struct mailbox *box, bool set);\n/* Returns -1 if mailbox_create() is guaranteed to fail because the mailbox\n   name is invalid, 0 not. The error message contains a reason. */\nint mailbox_verify_create_name(struct mailbox *box);\n/* Create a mailbox. Returns failure if it already exists. Mailbox name is\n   allowed to contain multiple new nonexistent hierarchy levels. If directory\n   is TRUE, the mailbox should be created so that it can contain children. The\n   mailbox itself doesn't have to be created as long as it shows up in LIST.\n   If update is non-NULL, its contents are used to set initial mailbox\n   metadata. */\nint mailbox_create(struct mailbox *box, const struct mailbox_update *update,\n\t\t   bool directory) ATTR_NULL(2);\n/* Update existing mailbox's metadata. */\nint mailbox_update(struct mailbox *box, const struct mailbox_update *update);\n/* Delete mailbox (and its parent directory, if it has no siblings) */\nint mailbox_delete(struct mailbox *box);\n/* Delete mailbox, but only if it's empty. If it's not, fails with\n   MAIL_ERROR_EXISTS. */\nint mailbox_delete_empty(struct mailbox *box);\n/* Rename mailbox (and its children). Renaming across different mailbox lists\n   is possible only between private namespaces and storages of the same type.\n   If the rename fails, the error is set to src's storage. */\nint mailbox_rename(struct mailbox *src, struct mailbox *dest);\n/* Subscribe/unsubscribe mailbox. Subscribing to\n   nonexistent mailboxes is optional. */\nint mailbox_set_subscribed(struct mailbox *box, bool set);\n/* Returns TRUE if mailbox is subscribed, FALSE if not. This function\n   doesn't refresh the subscriptions list, but assumes that it's been done by\n   e.g. mailbox_list_iter*(). */\nbool mailbox_is_subscribed(struct mailbox *box);\n\n/* Enable the given feature for the mailbox. */\nint mailbox_enable(struct mailbox *box, enum mailbox_feature features);\n/* Returns all enabled features. */\nenum mailbox_feature\nmailbox_get_enabled_features(struct mailbox *box) ATTR_PURE;\n\n/* Returns storage of given mailbox */\nstruct mail_storage *mailbox_get_storage(const struct mailbox *box) ATTR_PURE;\n/* Return namespace of given mailbox. */\nstruct mail_namespace *\nmailbox_get_namespace(const struct mailbox *box) ATTR_PURE;\n/* Returns the storage's settings. */\nconst struct mail_storage_settings *\nmailbox_get_settings(struct mailbox *box) ATTR_PURE;\n/* Returns the mailbox's settings, or NULL if there are none. */\nconst struct mailbox_settings *\nmailbox_settings_find(struct mail_namespace *ns, const char *vname);\n\n/* Returns the (virtual) name of the given mailbox. */\nconst char *mailbox_get_vname(const struct mailbox *box) ATTR_PURE;\n/* Returns the backend name of given mailbox. */\nconst char *mailbox_get_name(const struct mailbox *box) ATTR_PURE;\n\n/* Returns TRUE if mailbox is read-only. */\nbool mailbox_is_readonly(struct mailbox *box);\n/* Returns TRUE if two mailboxes point to the same physical mailbox. */\nbool mailbox_backends_equal(const struct mailbox *box1,\n\t\t\t    const struct mailbox *box2);\n/* Returns TRUE if mailbox is now in inconsistent state, meaning that\n   the message IDs etc. may have changed - only way to recover this\n   would be to fully close the mailbox and reopen it. With IMAP\n   connection this would mean a forced disconnection since we can't\n   do forced CLOSE. */\nbool mailbox_is_inconsistent(struct mailbox *box);\n\n/* Gets the mailbox status information. If mailbox isn't opened yet, try to\n   return the results from mailbox list indexes. Otherwise the mailbox is\n   opened and synced. If the mailbox is already opened, no syncing is done\n   automatically. */\nint mailbox_get_status(struct mailbox *box, enum mailbox_status_items items,\n\t\t       struct mailbox_status *status_r);\n/* Gets the mailbox status, requires that mailbox is already opened. */\nvoid mailbox_get_open_status(struct mailbox *box,\n\t\t\t     enum mailbox_status_items items,\n\t\t\t     struct mailbox_status *status_r);\n/* Gets mailbox metadata */\nint mailbox_get_metadata(struct mailbox *box, enum mailbox_metadata_items items,\n\t\t\t struct mailbox_metadata *metadata_r);\n/* Returns a mask of flags that are private to user in this mailbox\n   (as opposed to flags shared between users). */\nenum mail_flags mailbox_get_private_flags_mask(struct mailbox *box);\n\n/* Synchronize the mailbox. */\nstruct mailbox_sync_context *\nmailbox_sync_init(struct mailbox *box, enum mailbox_sync_flags flags);\nbool mailbox_sync_next(struct mailbox_sync_context *ctx,\n\t\t       struct mailbox_sync_rec *sync_rec_r);\nint mailbox_sync_deinit(struct mailbox_sync_context **ctx,\n\t\t\tstruct mailbox_sync_status *status_r);\n/* One-step mailbox synchronization. Use this if you don't care about\n   changes. */\nint mailbox_sync(struct mailbox *box, enum mailbox_sync_flags flags);\n\n/* Call given callback function when something changes in the mailbox. */\nvoid mailbox_notify_changes(struct mailbox *box,\n\t\t\t    mailbox_notify_callback_t *callback, void *context)\n\tATTR_NULL(3);\n#define mailbox_notify_changes(box, callback, context) \\\n\t  mailbox_notify_changes(box, (mailbox_notify_callback_t *)callback, \\\n\t\t(void *)((char *)context - CALLBACK_TYPECHECK(callback, \\\n\t\t\tvoid (*)(struct mailbox *, typeof(context)))))\nvoid mailbox_notify_changes_stop(struct mailbox *box);\n\nstruct mailbox_transaction_context *\nmailbox_transaction_begin(struct mailbox *box,\n\t\t\t  enum mailbox_transaction_flags flags,\n\t\t\t  const char *reason);\nint mailbox_transaction_commit(struct mailbox_transaction_context **t);\nint mailbox_transaction_commit_get_changes(\n\tstruct mailbox_transaction_context **t,\n\tstruct mail_transaction_commit_changes *changes_r);\nvoid mailbox_transaction_rollback(struct mailbox_transaction_context **t);\n/* Return the number of active transactions for the mailbox. */\nunsigned int mailbox_transaction_get_count(const struct mailbox *box) ATTR_PURE;\n/* When committing transaction, drop flag/keyword updates for messages whose\n   modseq is larger than max_modseq. Save those messages' sequences to the\n   given array. */\nvoid mailbox_transaction_set_max_modseq(struct mailbox_transaction_context *t,\n\t\t\t\t\tuint64_t max_modseq,\n\t\t\t\t\tARRAY_TYPE(seq_range) *seqs);\n\nstruct mailbox *\nmailbox_transaction_get_mailbox(const struct mailbox_transaction_context *t)\n\tATTR_PURE;\n\n/* Convert uid range to sequence range. */\nvoid mailbox_get_seq_range(struct mailbox *box, uint32_t uid1, uint32_t uid2,\n\t\t\t   uint32_t *seq1_r, uint32_t *seq2_r);\n/* Convert sequence range to uid range. If sequences contain\n   (uint32_t)-1 to specify \"*\", they're preserved. */\nvoid mailbox_get_uid_range(struct mailbox *box,\n\t\t\t   const ARRAY_TYPE(seq_range) *seqs,\n\t\t\t   ARRAY_TYPE(seq_range) *uids);\n/* Get list of messages' that have been expunged after prev_modseq and that\n   exist in uids_filter range. UIDs that have been expunged after the last\n   mailbox sync aren't returned. Returns TRUE if ok, FALSE if modseq is lower\n   than we can check for (but expunged_uids is still set as best as it can). */\nbool mailbox_get_expunges(struct mailbox *box, uint64_t prev_modseq,\n\t\t\t  const ARRAY_TYPE(seq_range) *uids_filter,\n\t\t\t  ARRAY_TYPE(mailbox_expunge_rec) *expunges);\n/* Same as mailbox_get_expunges(), but return only list of UIDs. Not caring\n   about GUIDs is slightly faster. */\nbool mailbox_get_expunged_uids(struct mailbox *box, uint64_t prev_modseq,\n\t\t\t       const ARRAY_TYPE(seq_range) *uids_filter,\n\t\t\t       ARRAY_TYPE(seq_range) *expunged_uids);\n\n/* Initialize header lookup for given headers. */\nstruct mailbox_header_lookup_ctx *\nmailbox_header_lookup_init(struct mailbox *box, const char *const headers[]);\nvoid mailbox_header_lookup_ref(struct mailbox_header_lookup_ctx *ctx);\nvoid mailbox_header_lookup_unref(struct mailbox_header_lookup_ctx **ctx);\n/* Merge two header lookups. */\nstruct mailbox_header_lookup_ctx *\nmailbox_header_lookup_merge(const struct mailbox_header_lookup_ctx *hdr1,\n\t\t\t    const struct mailbox_header_lookup_ctx *hdr2);\n\n/* Initialize new search request. If sort_program is non-NULL, the messages are\n   returned in the requested order, otherwise from first to last. */\nstruct mail_search_context * ATTR_NULL(3, 5)\nmailbox_search_init(struct mailbox_transaction_context *t,\n\t\t    struct mail_search_args *args,\n\t\t    const enum mail_sort_type *sort_program,\n\t\t    enum mail_fetch_field wanted_fields,\n\t\t    struct mailbox_header_lookup_ctx *wanted_headers);\n/* Deinitialize search request. */\nint mailbox_search_deinit(struct mail_search_context **ctx);\n/* Search the next message. Returns TRUE if found, FALSE if not. */\nbool mailbox_search_next(struct mail_search_context *ctx, struct mail **mail_r);\n/* Like mailbox_search_next(), but don't spend too much time searching.\n   Returns FALSE with tryagain_r=FALSE if finished, and tryagain_r=TRUE if\n   more results will be returned by calling the function again. */\nbool mailbox_search_next_nonblock(struct mail_search_context *ctx,\n\t\t\t\t  struct mail **mail_r, bool *tryagain_r);\n/* Returns TRUE if some messages were already expunged and we couldn't\n   determine correctly if those messages should have been returned in this\n   search. */\nbool mailbox_search_seen_lost_data(struct mail_search_context *ctx);\n/* Detach the given mail from the search context. This allows the mail to live\n   even after mail_search_context has been freed. */\nvoid mailbox_search_mail_detach(struct mail_search_context *ctx,\n\t\t\t\tstruct mail *mail);\n\n/* Remember the search result for future use. This must be called before the\n   first mailbox_search_next*() call. */\nstruct mail_search_result *\nmailbox_search_result_save(struct mail_search_context *ctx,\n\t\t\t   enum mailbox_search_result_flags flags);\n/* Free memory used by search result. */\nvoid mailbox_search_result_free(struct mail_search_result **result);\n/* A simplified API for searching and saving the result. */\nint mailbox_search_result_build(struct mailbox_transaction_context *t,\n\t\t\t\tstruct mail_search_args *args,\n\t\t\t\tenum mailbox_search_result_flags flags,\n\t\t\t\tstruct mail_search_result **result_r);\n/* Return all messages' UIDs in the search result. */\nconst ARRAY_TYPE(seq_range) *\nmailbox_search_result_get(struct mail_search_result *result);\n/* Return messages that have been removed and added since the last sync call.\n   This function must not be called if search result wasn't saved with\n   _QUEUE_SYNC flag. */\nvoid mailbox_search_result_sync(struct mail_search_result *result,\n\t\t\t\tARRAY_TYPE(seq_range) *removed_uids,\n\t\t\t\tARRAY_TYPE(seq_range) *added_uids);\n\n/* Build mail_keywords from NULL-terminated keywords list. Any duplicate\n   keywords are removed. Returns 0 if successful, -1 if there are invalid\n   keywords (error is set). */\nint mailbox_keywords_create(struct mailbox *box, const char *const keywords[],\n\t\t\t    struct mail_keywords **keywords_r);\n/* Like mailbox_keywords_create(), except ignore invalid keywords. */\nstruct mail_keywords *\nmailbox_keywords_create_valid(struct mailbox *box,\n\t\t\t      const char *const keywords[]);\nstruct mail_keywords *\nmailbox_keywords_create_from_indexes(struct mailbox *box,\n\t\t\t\t     const ARRAY_TYPE(keyword_indexes) *idx);\n/* Return union of two mail_keywords. They must be created in the same\n   mailbox. */\nstruct mail_keywords *mailbox_keywords_merge(struct mail_keywords *keywords1,\n\t\t\t\t\t     struct mail_keywords *keywords2);\nvoid mailbox_keywords_ref(struct mail_keywords *keywords);\nvoid mailbox_keywords_unref(struct mail_keywords **keywords);\n/* Returns TRUE if keyword is valid, FALSE and error if not. */\nbool mailbox_keyword_is_valid(struct mailbox *box, const char *keyword,\n\t\t\t      const char **error_r);\n\n/* Initialize saving a new mail. You must not try to save more than one mail\n   at a time. */\nstruct mail_save_context *\nmailbox_save_alloc(struct mailbox_transaction_context *t);\n/* Set the flags and keywords. Nothing is set by default. */\nvoid mailbox_save_set_flags(struct mail_save_context *ctx,\n\t\t\t    enum mail_flags flags,\n\t\t\t    struct mail_keywords *keywords);\n/* Copy flags and keywords from given mail. */\nvoid mailbox_save_copy_flags(struct mail_save_context *ctx, struct mail *mail);\n/* Set message's modseq to be at least min_modseq. */\nvoid mailbox_save_set_min_modseq(struct mail_save_context *ctx,\n\t\t\t\t uint64_t min_modseq);\n/* If received date isn't specified the current time is used. timezone_offset\n   specifies the preferred timezone in minutes, but it may be ignored if\n   backend doesn't support storing it. */\nvoid mailbox_save_set_received_date(struct mail_save_context *ctx,\n\t\t\t\t    time_t received_date, int timezone_offset);\n/* Set the \"message saved\" date. This should be set only when you're\n   replicating/restoring an existing mailbox. */\nvoid mailbox_save_set_save_date(struct mail_save_context *ctx,\n\t\t\t\ttime_t save_date);\n/* Set the envelope sender. This is currently used only with mbox files to\n   specify the address in From_-line. */\nvoid mailbox_save_set_from_envelope(struct mail_save_context *ctx,\n\t\t\t\t    const char *envelope);\n/* Set message's UID. If UID is smaller than the current next_uid, it's given\n   a new UID anyway. */\nvoid mailbox_save_set_uid(struct mail_save_context *ctx, uint32_t uid);\n/* Set globally unique ID for the saved mail. A new GUID is generated by\n   default. This function should usually be called only when copying an\n   existing mail (or restoring a mail from backup). */\nvoid mailbox_save_set_guid(struct mail_save_context *ctx, const char *guid);\n/* Set message's POP3 UIDL, if the backend supports it. */\nvoid mailbox_save_set_pop3_uidl(struct mail_save_context *ctx,\n\t\t\t\tconst char *uidl);\n/* Specify ordering for POP3 messages. The default is to add them to the end\n   of the mailbox. Not all backends support this. */\nvoid mailbox_save_set_pop3_order(struct mail_save_context *ctx,\n\t\t\t\t unsigned int order);\n/* Returns the destination mail */\nstruct mail *mailbox_save_get_dest_mail(struct mail_save_context *ctx);\n/* Begin saving the message. All mail_save_set_*() calls must have been called\n   before this function. If the save initialization fails, the context is freed\n   and -1 is returned. After beginning the save you should keep calling\n   i_stream_read() and calling mailbox_save_continue() as long as there's\n   more input. */\nint mailbox_save_begin(struct mail_save_context **ctx, struct istream *input);\nint mailbox_save_continue(struct mail_save_context *ctx);\nint mailbox_save_finish(struct mail_save_context **ctx);\nvoid mailbox_save_cancel(struct mail_save_context **ctx);\n\nstruct mailbox_transaction_context *\nmailbox_save_get_transaction(struct mail_save_context *ctx);\n\n/* Copy the given message. You'll need to specify the flags etc. using the\n   mailbox_save_*() functions. */\nint mailbox_copy(struct mail_save_context **ctx, struct mail *mail);\n/* Move the given message. This is usually equivalent to copy+expunge,\n   but without enforcing quota. */\nint mailbox_move(struct mail_save_context **ctx, struct mail *mail);\n/* Same as mailbox_copy(), but treat the message as if it's being saved,\n   not copied. (For example: New mail delivered to multiple maildirs, with\n   each mails being hard link copies.) */\nint mailbox_save_using_mail(struct mail_save_context **ctx, struct mail *mail);\n\nstruct mail *mail_alloc(struct mailbox_transaction_context *t,\n\t\t\tenum mail_fetch_field wanted_fields,\n\t\t\tstruct mailbox_header_lookup_ctx *wanted_headers)\n\tATTR_NULL(3);\nvoid mail_free(struct mail **mail);\nvoid mail_set_seq(struct mail *mail, uint32_t seq);\n/* Returns TRUE if successful, FALSE if message doesn't exist.\n   mail_*() functions shouldn't be called if FALSE is returned. */\nbool mail_set_uid(struct mail *mail, uint32_t uid);\n\n/* Add wanted fields/headers on top of existing ones. These will be forgotten\n   after the next mail_set_seq/uid() that closes the existing mail. Note that\n   it's valid to call this function while there is no mail assigned\n   (mail->seq==0), i.e. this is called before any mail_set_seq/uid() or after\n   mail.close(). */\nvoid mail_add_temp_wanted_fields(struct mail *mail,\n\t\t\t\t enum mail_fetch_field fields,\n\t\t\t\t struct mailbox_header_lookup_ctx *headers)\n\tATTR_NULL(3);\n\n/* Returns message's flags */\nenum mail_flags mail_get_flags(struct mail *mail);\n/* Returns message's keywords */\nconst char *const *mail_get_keywords(struct mail *mail);\n/* Returns message's keywords */\nconst ARRAY_TYPE(keyword_indexes) *mail_get_keyword_indexes(struct mail *mail);\n/* Returns message's modseq */\nuint64_t mail_get_modseq(struct mail *mail);\n/* Returns message's private modseq, or 0 if message hasn't had any\n   private flag changes. This is useful only for shared mailboxes that have\n   a private index defined. */\nuint64_t mail_get_pvt_modseq(struct mail *mail);\n\n/* Returns message's MIME parts */\nint mail_get_parts(struct mail *mail, struct message_part **parts_r);\n\n/* Get the Date-header of the mail. Timezone is in minutes. date=0 if it\n   wasn't found or it was invalid. */\nint mail_get_date(struct mail *mail, time_t *date_r, int *timezone_r);\n/* Get the time when the mail was received (IMAP INTERNALDATE). */\nint mail_get_received_date(struct mail *mail, time_t *date_r);\n/* Get the time when the mail was saved into this mailbox. This returns -1 on\n   error, 0 if a real save date is not supported and a fall-back date is used,\n   and 1 when a save date was successfully retrieved. */\nint mail_get_save_date(struct mail *mail, time_t *date_r);\n\n/* Get the space used by the mail as seen by the reader. Linefeeds are always\n   counted as being CR+LF. */\nint mail_get_virtual_size(struct mail *mail, uoff_t *size_r);\n/* Get the size of the stream returned by mail_get_stream(). */\nint mail_get_physical_size(struct mail *mail, uoff_t *size_r);\n\n/* Get value for single header field, or NULL if header wasn't found.\n   Returns 1 if header was found, 0 if not, -1 if error. */\nint mail_get_first_header(struct mail *mail, const char *field,\n\t\t\t  const char **value_r);\n/* Like mail_get_first_header(), but decode MIME encoded words to UTF-8.\n   Also multiline headers are returned unfolded.\n\n   Do not use this function for getting structured fields (e.g. address fields),\n   because decoding may break the structuring. Instead parse them first and\n   only afterwards decode the encoded words. */\nint mail_get_first_header_utf8(struct mail *mail, const char *field,\n\t\t\t       const char **value_r);\n/* Return a NULL-terminated list of values for each found field.\n   Returns 1 if headers were found, 0 if not (value_r[0]==NULL) or\n   -1 if error. */\nint mail_get_headers(struct mail *mail, const char *field,\n\t\t     const char *const **value_r);\n/* Like mail_get_headers(), but decode MIME encoded words to UTF-8.\n   Also multiline headers are returned unfolded.\n   Do not use for structured fields (see mail_get_first_header_utf8()). */\nint mail_get_headers_utf8(struct mail *mail, const char *field,\n\t\t\t  const char *const **value_r);\n/* Returns stream containing specified headers. The returned stream will be\n   automatically freed when the mail is closed, or when another\n   mail_get_header_stream() call is made (so you can't have multiple header\n   streams open at the same time). */\nint mail_get_header_stream(struct mail *mail,\n\t\t\t   struct mailbox_header_lookup_ctx *headers,\n\t\t\t   struct istream **stream_r);\n/* Returns input stream pointing to beginning of message header.\n   hdr_size and body_size are updated unless they're NULL. The returned stream\n   is destroyed automatically, don't unreference it. */\nint mail_get_stream(struct mail *mail, struct message_size *hdr_size,\n\t\t    struct message_size *body_size, struct istream **stream_r)\n\tATTR_NULL(2, 3);\n/* Same as mail_get_stream(), but specify a reason why the mail is being read.\n   This can be useful for debugging purposes. */\nint mail_get_stream_because(struct mail *mail, struct message_size *hdr_size,\n\t\t\t    struct message_size *body_size,\n\t\t\t    const char *reason, struct istream **stream_r)\n\tATTR_NULL(2, 3);\n/* Similar to mail_get_stream(), but the stream may or may not contain the\n   message body. */\nint mail_get_hdr_stream(struct mail *mail, struct message_size *hdr_size,\n\t\t\tstruct istream **stream_r) ATTR_NULL(2);\n/* Same as mail_get_hdr_stream(), but specify a reason why the header is being\n   read. This can be useful for debugging purposes. */\nint mail_get_hdr_stream_because(struct mail *mail,\n\t\t\t\tstruct message_size *hdr_size,\n\t\t\t\tconst char *reason, struct istream **stream_r);\n/* Returns the message part's body decoded to 8bit binary. If the\n   Content-Transfer-Encoding isn't supported, returns -1 and sets error to\n   MAIL_ERROR_CONVERSION. If the part refers to a multipart, all of its\n   children are returned decoded. */\nint mail_get_binary_stream(struct mail *mail, const struct message_part *part,\n\t\t\t   bool include_hdr, uoff_t *size_r,\n\t\t\t   bool *binary_r, struct istream **stream_r);\n/* Like mail_get_binary_stream(), but only return the size. */\nint mail_get_binary_size(struct mail *mail, const struct message_part *part,\n\t\t\t bool include_hdr, uoff_t *size_r,\n\t\t\t unsigned int *lines_r);\n\n/* Get any of the \"special\" fields. Unhandled specials are returned as \"\". */\nint mail_get_special(struct mail *mail, enum mail_fetch_field field,\n\t\t     const char **value_r);\n/* Returns the mail for the physical message. Normally this is the mail itself,\n   but in virtual mailboxes it points to the backend mailbox. */\nint mail_get_backend_mail(struct mail *mail, struct mail **real_mail_r);\n\n/* Retrieve and parse the value of the Message-ID header field. Returns 1 if the\n   header was found and it contains a valid message ID, 0 if the header was not\n   found or no valid message ID was contained in it, and -1 if an error occurred\n   while retrieving the header. Returns the message ID value including '<' and\n   '>' in the *value_r return parameter or NULL if the header wasn't found or\n   its value was invalid. */\nint mail_get_message_id(struct mail *mail, const char **value_r);\n\n/* Update message flags. */\nvoid mail_update_flags(struct mail *mail, enum modify_type modify_type,\n\t\t       enum mail_flags flags);\n/* Update message keywords. */\nvoid mail_update_keywords(struct mail *mail, enum modify_type modify_type,\n\t\t\t  struct mail_keywords *keywords);\n/* Update message's modseq to be at least min_modseq. */\nvoid mail_update_modseq(struct mail *mail, uint64_t min_modseq);\n/* Update message's private modseq to be at least min_pvt_modseq. */\nvoid mail_update_pvt_modseq(struct mail *mail, uint64_t min_pvt_modseq);\n\n/* Update message's POP3 UIDL (if possible). */\nvoid mail_update_pop3_uidl(struct mail *mail, const char *uidl);\n/* Expunge this message. Sequence numbers don't change until commit. */\nvoid mail_expunge(struct mail *mail);\n\n/* Add missing fields to cache. */\nvoid mail_precache(struct mail *mail);\n/* Mark a cached field corrupted and have it recalculated. */\nvoid mail_set_cache_corrupted(struct mail *mail,\n\t\t\t      enum mail_fetch_field field,\n\t\t\t      const char *reason);\n\n/* Return 128 bit GUID using input string. If guid is already 128 bit hex\n   encoded, it's returned as-is. Otherwise SHA1 sum is taken and its last\n   128 bits are returned. */\nvoid mail_generate_guid_128_hash(const char *guid, guid_128_t guid_128_r);\n\n/* Parse a human-writable string into a timestamp. utc_r controls whether\n   the returned timestamp should be treated as an exact UTC time (TRUE), or\n   whether this is a human-given date where the timestamp could be adjusted\n   by the matched mails' timezones (see MAIL_SEARCH_ARG_FLAG_USE_TZ).\n\n   Returns 0 and timestamp on success, -1 if the string couldn't be parsed.\n   Currently supported string formats: yyyy-mm-dd (utc=FALSE),\n   imap date (utc=FALSE), unix timestamp (utc=TRUE), interval (e.g. n days,\n   utc=TRUE). */\nint mail_parse_human_timestamp(const char *str, time_t *timestamp_r,\n\t\t\t       bool *utc_r);\n\n#endif\n"}, "27": {"id": 27, "path": "/home/runner/work/testcc/testcc/retdec/src/lib/imem.h", "content": "#ifndef IMEM_H\n#define IMEM_H\n\n/* For easy allocation of memory from default memory pool. */\n\nextern pool_t default_pool;\n\n#define i_new(type, count) p_new(default_pool, type, count)\n#define i_realloc_type(mem, type, old_count, new_count) \\\n\tp_realloc_type(default_pool, mem, type, old_count, new_count)\n\nvoid *i_malloc(size_t size) ATTR_MALLOC ATTR_RETURNS_NONNULL;\nvoid *i_realloc(void *mem, size_t old_size, size_t new_size)\n\tATTR_WARN_UNUSED_RESULT ATTR_RETURNS_NONNULL;\n\n/* i_free() and i_free_and_null() are now guaranteed to both set mem=NULL,\n   so either one of them can be used. */\n#ifndef STATIC_CHECKER\n#  define i_free(mem) p_free_and_null(default_pool, mem)\n#else\n#  define i_free(mem) \\\n\tSTMT_START { \\\n\t\tpool_system_free(default_pool, mem); \\\n\t\t(mem) = NULL; \\\n\t} STMT_END\n#endif\n#define i_free_and_null(mem) i_free(mem)\n\n/* string functions */\nchar *i_strdup(const char *str) ATTR_MALLOC;\nvoid *i_memdup(const void *data, size_t size) ATTR_MALLOC;\n/* like i_strdup(), but if str == \"\", return NULL */\nchar *i_strdup_empty(const char *str) ATTR_MALLOC;\n/* *end isn't included */\nchar *i_strdup_until(const void *str, const void *end)\n\tATTR_MALLOC ATTR_RETURNS_NONNULL;\nchar *i_strndup(const void *str, size_t max_chars) ATTR_MALLOC;\nchar *i_strdup_printf(const char *format, ...)\n\tATTR_FORMAT(1, 2) ATTR_MALLOC ATTR_RETURNS_NONNULL;\nchar *i_strdup_vprintf(const char *format, va_list args)\n\tATTR_FORMAT(1, 0) ATTR_MALLOC ATTR_RETURNS_NONNULL;\n\nchar *i_strconcat(const char *str1, ...)  ATTR_SENTINEL ATTR_MALLOC;\n\n#endif\n"}, "28": {"id": 28, "path": "/home/runner/work/testcc/testcc/retdec/src/lib/mempool.h", "content": "#ifndef MEMPOOL_H\n#define MEMPOOL_H\n\n#include \"macros.h\"\n\n/* When DEBUG is enabled, Dovecot warns whenever a memory pool is grown.\n   This is done so that the initial pool size could be set large enough so that\n   it wouldn't grow in normal use. For some memory pools it's too difficult\n   to calculate a good initial size, so this prefix should be used with those\n   pools to disable the warning. */\n#define MEMPOOL_GROWING \"GROWING-\"\n\n/* The maximum allocation size that's allowed.  Anything larger than that\n   will panic.  No pool ever should need more than 4kB of overhead per\n   allocation. */\n#define POOL_MAX_ALLOC_SIZE\t(SSIZE_T_MAX - 4096)\n\n/* Memory allocated and reallocated (the new data in it) in pools is always\n   zeroed, it will cost only a few CPU cycles and may well save some debug\n   time. */\n\ntypedef struct pool *pool_t;\n\nstruct pool_vfuncs {\n\tconst char *(*get_name)(pool_t pool);\n\n\tvoid (*ref)(pool_t pool);\n\tvoid (*unref)(pool_t *pool);\n\n\tvoid *(*malloc)(pool_t pool, size_t size) ATTR_RETURNS_NONNULL;\n\tvoid (*free)(pool_t pool, void *mem);\n\n\t/* memory in old_size..new_size will be zeroed */\n\tvoid *(*realloc)(pool_t pool, void *mem,\n\t\t\t size_t old_size, size_t new_size)\n\t\tATTR_WARN_UNUSED_RESULT ATTR_RETURNS_NONNULL;\n\n\t/* Frees all the memory in pool. NOTE: system_pool doesn't support\n\t   this and crashes if it's used */\n\tvoid (*clear)(pool_t pool);\n\n\t/* Returns the maximum amount of bytes that can be allocated with\n\t   minimal trouble. If there's no such concept, always returns 0. */\n\tsize_t (*get_max_easy_alloc_size)(pool_t pool);\n};\n\nstruct pool {\n\tconst struct pool_vfuncs *v;\n\n\tbool alloconly_pool:1;\n\tbool datastack_pool:1;\n};\n\n/* system_pool uses calloc() + realloc() + free() */\nextern pool_t system_pool;\nextern struct pool static_system_pool;\n\n/* memory allocated from data_stack is valid only until next t_pop() call.\n   No checks are performed. */\nextern pool_t unsafe_data_stack_pool;\n\n/* Create a new alloc-only pool. Note that `size' specifies the initial\n   malloc()ed block size, part of it is used internally. */\npool_t pool_alloconly_create(const char *name, size_t size);\n/* Like alloconly pool, but clear the memory before freeing it. The idea is\n   that you could allocate memory for storing sensitive information from this\n   pool, and be sure that it gets cleared from the memory when it's no longer\n   needed. */\npool_t pool_alloconly_create_clean(const char *name, size_t size);\n\n/* When allocating memory from returned pool, the data stack frame must be\n   the same as it was when calling this function. pool_unref() also checks\n   that the stack frame is the same. This should make it quite safe to use. */\npool_t pool_datastack_create(void);\n\n/* Create new alloc pool. This is very similar to system pool, but it\n   will deallocate all memory on deinit. */\npool_t pool_allocfree_create(const char *name);\n\n/* Like alloc pool, but all memory is cleaned before freeing.\n   See pool_alloconly_create_clean. */\npool_t pool_allocfree_create_clean(const char *name);\n\n/* Similar to nearest_power(), but try not to exceed buffer's easy\n   allocation size. If you don't have any explicit minimum size, use\n   old_size + 1. */\nsize_t pool_get_exp_grown_size(pool_t pool, size_t old_size, size_t min_size);\n\n/* We require sizeof(type) to be <= UINT_MAX. This allows compiler to optimize\n   away the entire MALLOC_MULTIPLY() call on 64bit systems. */\n#define p_new(pool, type, count) \\\n\t((type *) p_malloc(pool, MALLOC_MULTIPLY((unsigned int)sizeof(type), (count))) + \\\n\t COMPILE_ERROR_IF_TRUE(sizeof(type) > UINT_MAX))\n\n#define p_realloc_type(pool, mem, type, old_count, new_count) \\\n\t((type *) p_realloc(pool, mem, \\\n\t MALLOC_MULTIPLY((unsigned int)sizeof(type), (old_count)), \\\n\t MALLOC_MULTIPLY((unsigned int)sizeof(type), (new_count))) + \\\n\t\tCOMPILE_ERROR_IF_TRUE(sizeof(type) > UINT_MAX))\n\nstatic inline void * ATTR_MALLOC ATTR_RETURNS_NONNULL\np_malloc(pool_t pool, size_t size)\n{\n\tif (unlikely(size == 0 || size > POOL_MAX_ALLOC_SIZE))\n\t\ti_panic(\"Trying to allocate %zu bytes\", size);\n\n\treturn pool->v->malloc(pool, size);\n}\n\nstatic inline void * ATTR_WARN_UNUSED_RESULT ATTR_RETURNS_NONNULL\np_realloc(pool_t pool, void *mem, size_t old_size, size_t new_size)\n{\n\tif (unlikely(new_size == 0 || new_size > POOL_MAX_ALLOC_SIZE))\n\t\ti_panic(\"Trying to reallocate %zu -> %zu bytes\",\n\t\t\told_size, new_size);\n\n\tif (mem == NULL)\n\t\treturn pool->v->malloc(pool, new_size);\n\n\treturn pool->v->realloc(pool, mem, old_size, new_size);\n}\n\n/* Free the memory. p_free() and p_free_and_null() are now guaranteed to both\n   set mem=NULL, so either one of them can be used. */\n#define p_free(pool, mem) \\\n\tSTMT_START { \\\n\t\tp_free_internal(pool, mem);\t\\\n\t\t(mem) = NULL;\t\t\t\\\n\t} STMT_END\n#define p_free_and_null(pool, mem) p_free(pool, mem)\n\nstatic inline void p_free_internal(pool_t pool, void *mem)\n{\n\tif (mem != NULL)\n\t\tpool->v->free(pool, mem);\n}\n\nstatic inline void p_clear(pool_t pool)\n{\n\tpool->v->clear(pool);\n}\n\nstatic inline size_t p_get_max_easy_alloc_size(pool_t pool)\n{\n\treturn pool->v->get_max_easy_alloc_size(pool);\n}\n\nstatic inline const char *pool_get_name(pool_t pool)\n{\n\treturn pool->v->get_name(pool);\n}\n\nstatic inline void pool_ref(pool_t pool)\n{\n\tpool->v->ref(pool);\n}\n\nstatic inline void pool_unref(pool_t *pool)\n{\n\tif (*pool != NULL)\n\t\t(*pool)->v->unref(pool);\n}\n\n/* These functions are only for pools created with pool_alloconly_create(): */\n\n/* Returns how much memory has been allocated from this pool. */\nsize_t pool_alloconly_get_total_used_size(pool_t pool);\n/* Returns how much system memory has been allocated for this pool. */\nsize_t pool_alloconly_get_total_alloc_size(pool_t pool);\n\n/* Returns how much memory has been allocated from this pool. */\nsize_t pool_allocfree_get_total_used_size(pool_t pool);\n/* Returns how much system memory has been allocated for this pool. */\nsize_t pool_allocfree_get_total_alloc_size(pool_t pool);\n\n/* private: */\nvoid pool_system_free(pool_t pool, void *mem);\n\n#endif\n"}, "29": {"id": 29, "path": "/home/runner/work/testcc/testcc/retdec/src/lib/malloc-overflow.h", "content": "#ifndef MALLOC_OVERFLOW_H\n#define MALLOC_OVERFLOW_H\n\n/* MALLOC_*() can be used to calculate memory allocation sizes. If there's an\n   overflow, it'll cleanly panic instead of causing a potential buffer\n   overflow.\n\n   Note that *_malloc(size+1) doesn't need to use MALLOC_ADD(size, 1). It wraps\n   to size==0 and the *_malloc() calls already panic if size==0. */\nstatic inline size_t\nmalloc_multiply_check(size_t a, size_t b, size_t sizeof_a, size_t sizeof_b,\n\t\t      const char *fname, unsigned int linenum)\n{\n\t/* the first sizeof-checks are intended to optimize away this entire\n\t   if-check for types that are small enough to never wrap size_t. */\n\tif ((sizeof_a * 2 > sizeof(size_t) || sizeof_b * 2 > sizeof(size_t)) &&\n\t    b != 0 && (a > SIZE_MAX / b)) {\n\t\ti_panic(\"file %s: line %d: memory allocation overflow: %zu * %zu\",\n\t\t\tfname, linenum, a, b);\n\t}\n\treturn a * b;\n}\n#ifndef STATIC_CHECKER\n#  define MALLOC_MULTIPLY(a, b) \\\n\tmalloc_multiply_check(a, b, sizeof(a), sizeof(b), __FILE__, __LINE__)\n#else\n/* avoid warning every time about sizeof(b) when b contains any arithmetic */\n#  define MALLOC_MULTIPLY(a, b) \\\n\tmalloc_multiply_check(a, b, sizeof(a), sizeof(size_t), __FILE__, __LINE__)\n#endif\n\nstatic inline size_t\nmalloc_add_check(size_t a, size_t b, size_t sizeof_a, size_t sizeof_b,\n\t\t const char *fname, unsigned int linenum)\n{\n\t/* the first sizeof-checks are intended to optimize away this entire\n\t   if-check for types that are small enough to never wrap size_t. */\n\tif ((sizeof_a >= sizeof(size_t) || sizeof_b >= sizeof(size_t)) &&\n\t    SIZE_MAX - a < b) {\n\t\ti_panic(\"file %s: line %d: memory allocation overflow: %zu + %zu\",\n\t\t\tfname, linenum, a, b);\n\t}\n\treturn a + b;\n}\n#ifndef STATIC_CHECKER\n#  define MALLOC_ADD(a, b) \\\n\tmalloc_add_check(a, b, sizeof(a), sizeof(b), __FILE__, __LINE__)\n#else\n/* avoid warning every time about sizeof(b) when b contains any arithmetic */\n#  define MALLOC_ADD(a, b) \\\n\tmalloc_add_check(a, b, sizeof(a), sizeof(size_t), __FILE__, __LINE__)\n#endif\n\n#endif\n"}}, "reports": [{"events": [{"location": {"col": 10, "file": 23, "line": 4}, "message": "\"array.h\" (fixit)"}, {"location": {"col": 1, "file": 23, "line": 4}, "message": "#includes are not sorted properly"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/src/lib-storage/mail-storage.c", "reportHash": "400e88a96dd3bdd574577cd5f4a2925c", "checkerName": "llvm-include-order", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 39, "file": 23, "line": 59}, "message": "initializing non-local variable with non-const expression depending on uninitialized non-local variable 'mail_index_module_register'"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/src/lib-storage/mail-storage.c", "reportHash": "4e3d05ba0e9410cf45810d6ad6fa594e", "checkerName": "cppcoreguidelines-interfaces-global-init", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 47, "file": 23, "line": 67}, "message": "{ (fixit)"}, {"location": {"col": 39, "file": 23, "line": 67}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/src/lib-storage/mail-storage.c", "reportHash": "cf782df7beef09b49a6c859ec0dceaca", "checkerName": "google-readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 47, "file": 23, "line": 81}, "message": "{ (fixit)"}, {"location": {"col": 39, "file": 23, "line": 81}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/src/lib-storage/mail-storage.c", "reportHash": "5f09ec9e82f0776eacc7695ea4b29330", "checkerName": "google-readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 49, "file": 23, "line": 83}, "message": "{ (fixit)"}, {"location": {"col": 41, "file": 23, "line": 83}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/src/lib-storage/mail-storage.c", "reportHash": "adf434369b970b3fa9cb616bfdb7a21b", "checkerName": "hicpp-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 48, "file": 23, "line": 85}, "message": "{ (fixit)"}, {"location": {"col": 40, "file": 23, "line": 85}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/src/lib-storage/mail-storage.c", "reportHash": "392c75ecd33e84955937b93639835d92", "checkerName": "google-readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 54, "file": 23, "line": 88}, "message": "{ (fixit)"}, {"location": {"col": 46, "file": 23, "line": 88}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/src/lib-storage/mail-storage.c", "reportHash": "a501cd8696ccda9040e94c4071e24f92", "checkerName": "google-readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 62, "file": 23, "line": 127}, "message": "{ (fixit)"}, {"location": {"col": 47, "file": 23, "line": 127}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/src/lib-storage/mail-storage.c", "reportHash": "1114c2be69ddfe17eb3fc64414717963", "checkerName": "readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 64, "file": 23, "line": 143}, "message": "{ (fixit)"}, {"location": {"col": 42, "file": 23, "line": 143}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/src/lib-storage/mail-storage.c", "reportHash": "e78b82a1e086fdfa78e0e2256139f936", "checkerName": "google-readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 44, "file": 23, "line": 157}, "message": "{ (fixit)"}, {"location": {"col": 36, "file": 23, "line": 157}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/src/lib-storage/mail-storage.c", "reportHash": "ded3037c801b93a9bab9fe563e46a10b", "checkerName": "hicpp-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 8, "file": 23, "line": 199}, "message": "use of a signed integer operand with a binary bitwise operator"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/src/lib-storage/mail-storage.c", "reportHash": "f8ee6cb95c9786ab9d3c30a596e28f1b", "checkerName": "hicpp-signed-bitwise", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 8, "file": 23, "line": 202}, "message": "use of a signed integer operand with a binary bitwise operator"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/src/lib-storage/mail-storage.c", "reportHash": "864259a086d8f764c8daa420cb9cea20", "checkerName": "hicpp-signed-bitwise", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 8, "file": 23, "line": 205}, "message": "use of a signed integer operand with a binary bitwise operator"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/src/lib-storage/mail-storage.c", "reportHash": "fdead6c027fdbca3e3ec20b3ea9f81ab", "checkerName": "hicpp-signed-bitwise", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 36, "file": 23, "line": 219}, "message": "{ (fixit)"}, {"location": {"col": 28, "file": 23, "line": 219}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/src/lib-storage/mail-storage.c", "reportHash": "51c7a8b41bcbed2cc71193b02ce65e62", "checkerName": "readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 44, "file": 23, "line": 223}, "message": "{ (fixit)"}, {"location": {"col": 36, "file": 23, "line": 223}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/src/lib-storage/mail-storage.c", "reportHash": "00b427582d1e98466c99178529926750", "checkerName": "hicpp-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 24, "file": 24, "line": 125}, "message": "expanded from macro 'S_ISDIR'"}, {"location": {"col": 34, "file": 24, "line": 123}, "message": "expanded from macro '__S_ISTYPE'"}, {"location": {"col": 7, "file": 23, "line": 250}, "message": "use of a signed integer operand with a binary bitwise operator"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/src/lib-storage/mail-storage.c", "reportHash": "60a7f017609d63b46d27eff66149168c", "checkerName": "hicpp-signed-bitwise", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 42, "file": 23, "line": 250}, "message": "{ (fixit)"}, {"location": {"col": 27, "file": 23, "line": 250}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/src/lib-storage/mail-storage.c", "reportHash": "5a6f131952ad444336cadf72cd4c0ca8", "checkerName": "readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 4, "file": 23, "line": 255}, "message": "do not use 'else' after 'return'"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/src/lib-storage/mail-storage.c", "reportHash": "9173a7f8f97fba21098d6a16eb5bf6c8", "checkerName": "readability-else-after-return", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 7, "file": 23, "line": 287}, "message": "use of a signed integer operand with a binary bitwise operator"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/src/lib-storage/mail-storage.c", "reportHash": "195af74d7a2357572fb8d140aa9a6fb7", "checkerName": "hicpp-signed-bitwise", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 67, "file": 23, "line": 288}, "message": "{ (fixit)"}, {"location": {"col": 52, "file": 23, "line": 288}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/src/lib-storage/mail-storage.c", "reportHash": "47e17998fd63f11ef6e3866c1b49a1c2", "checkerName": "hicpp-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 7, "file": 23, "line": 301}, "message": "use of a signed integer operand with a binary bitwise operator"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/src/lib-storage/mail-storage.c", "reportHash": "27eb8516ddc95d84cf5ce3672969d433", "checkerName": "hicpp-signed-bitwise", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 62, "file": 23, "line": 314}, "message": "{ (fixit)"}, {"location": {"col": 54, "file": 23, "line": 314}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/src/lib-storage/mail-storage.c", "reportHash": "b77dfdad8e5aa0ac7bf65019a1e819f6", "checkerName": "google-readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 7, "file": 23, "line": 317}, "message": "use of a signed integer operand with a binary bitwise operator"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/src/lib-storage/mail-storage.c", "reportHash": "00c9f4967033d563e326372ecedf91f2", "checkerName": "hicpp-signed-bitwise", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 69, "file": 23, "line": 319}, "message": "{ (fixit)"}, {"location": {"col": 58, "file": 23, "line": 319}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/src/lib-storage/mail-storage.c", "reportHash": "a00ed1ade0c04c08af97e9b10cc7c57d", "checkerName": "hicpp-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 76, "file": 23, "line": 337}, "message": "{ (fixit)"}, {"location": {"col": 61, "file": 23, "line": 337}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/src/lib-storage/mail-storage.c", "reportHash": "bbfce38e15adc9f1e18406ac4218968c", "checkerName": "google-readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 7, "file": 23, "line": 354}, "message": "use of a signed integer operand with a binary bitwise operator"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/src/lib-storage/mail-storage.c", "reportHash": "b839c3ffcc2b81eaebbe10d4557cefca", "checkerName": "hicpp-signed-bitwise", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 42, "file": 23, "line": 361}, "message": "{ (fixit)"}, {"location": {"col": 20, "file": 23, "line": 361}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/src/lib-storage/mail-storage.c", "reportHash": "0c7e7840272d0afc3feddf5f7c2567d7", "checkerName": "google-readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 37, "file": 23, "line": 377}, "message": "{ (fixit)"}, {"location": {"col": 22, "file": 23, "line": 377}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/src/lib-storage/mail-storage.c", "reportHash": "a9551d0dddca57a6462d8a2f9923bf37", "checkerName": "hicpp-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 63, "file": 23, "line": 380}, "message": "{ (fixit)"}, {"location": {"col": 20, "file": 23, "line": 380}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/src/lib-storage/mail-storage.c", "reportHash": "88e430675b9a1bb63325d4245e4c393f", "checkerName": "google-readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 36, "file": 23, "line": 386}, "message": "{ (fixit)"}, {"location": {"col": 28, "file": 23, "line": 386}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/src/lib-storage/mail-storage.c", "reportHash": "cd654d69462d909e57c3d4c2125d7a16", "checkerName": "google-readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 66, "file": 23, "line": 392}, "message": "{ (fixit)"}, {"location": {"col": 51, "file": 23, "line": 392}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/src/lib-storage/mail-storage.c", "reportHash": "fbcf9e4f3df777ad887208ad2078b5f2", "checkerName": "google-readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 8, "file": 23, "line": 394}, "message": "use of a signed integer operand with a binary bitwise operator"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/src/lib-storage/mail-storage.c", "reportHash": "289e9c652da8a04d144ef0fe0f2b176e", "checkerName": "hicpp-signed-bitwise", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 90, "file": 23, "line": 394}, "message": "{ (fixit)"}, {"location": {"col": 75, "file": 23, "line": 394}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/src/lib-storage/mail-storage.c", "reportHash": "db5ea5c5edfd13678c0599d73aec1ccb", "checkerName": "google-readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 8, "file": 23, "line": 396}, "message": "use of a signed integer operand with a binary bitwise operator"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/src/lib-storage/mail-storage.c", "reportHash": "f08ea7208c336b21246f804992c65dcd", "checkerName": "hicpp-signed-bitwise", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 98, "file": 23, "line": 396}, "message": "{ (fixit)"}, {"location": {"col": 83, "file": 23, "line": 396}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/src/lib-storage/mail-storage.c", "reportHash": "f3531c6990dde83ce8fa574c8b833f80", "checkerName": "google-readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 8, "file": 23, "line": 404}, "message": "use of a signed integer operand with a binary bitwise operator"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/src/lib-storage/mail-storage.c", "reportHash": "0b91e2f78cb279a897793ed7d8886a95", "checkerName": "hicpp-signed-bitwise", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 85, "file": 23, "line": 405}, "message": "{ (fixit)"}, {"location": {"col": 63, "file": 23, "line": 405}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/src/lib-storage/mail-storage.c", "reportHash": "be9ccd640ecb8f4dbab8e65008843d24", "checkerName": "google-readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 52, "file": 23, "line": 426}, "message": "{ (fixit)"}, {"location": {"col": 44, "file": 23, "line": 426}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/src/lib-storage/mail-storage.c", "reportHash": "484020ceb3a448708e191afa7f83dc15", "checkerName": "google-readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 21, "file": 25, "line": 208}, "message": "expanded from macro 'i_assert'"}, {"location": {"col": 45, "file": 25, "line": 189}, "message": "expanded from macro 'unlikely'"}, {"location": {"col": 5, "file": 23, "line": 443}, "message": "use of a signed integer operand with a binary bitwise operator"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/src/lib-storage/mail-storage.c", "reportHash": "01c266ad8d3b79910abe92efa36b0a3d", "checkerName": "hicpp-signed-bitwise", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 41, "file": 23, "line": 476}, "message": "{ (fixit)"}, {"location": {"col": 33, "file": 23, "line": 476}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/src/lib-storage/mail-storage.c", "reportHash": "a28dfdfbda7c7462775a16376168197f", "checkerName": "google-readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 43, "file": 23, "line": 500}, "message": "{ (fixit)"}, {"location": {"col": 35, "file": 23, "line": 500}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/src/lib-storage/mail-storage.c", "reportHash": "9d8de369296f03337885ef99de57ec72", "checkerName": "google-readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 30, "file": 23, "line": 609}, "message": "{ (fixit)"}, {"location": {"col": 22, "file": 23, "line": 609}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/src/lib-storage/mail-storage.c", "reportHash": "0f04e9b6d4003c157fb9f421ff10bff2", "checkerName": "readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 26, "file": 23, "line": 631}, "message": "{ (fixit)"}, {"location": {"col": 18, "file": 23, "line": 631}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/src/lib-storage/mail-storage.c", "reportHash": "e13e3dc8638aeea3acf609b609fe92f5", "checkerName": "google-readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 34, "file": 23, "line": 666}, "message": "{ (fixit)"}, {"location": {"col": 26, "file": 23, "line": 666}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/src/lib-storage/mail-storage.c", "reportHash": "e9d3b6351db6283a44e72bd1ae617c0f", "checkerName": "google-readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 38, "file": 23, "line": 705}, "message": "{ (fixit)"}, {"location": {"col": 23, "file": 23, "line": 705}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/src/lib-storage/mail-storage.c", "reportHash": "3e1bc4653e187d87ec82dbb08de22c60", "checkerName": "google-readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 30, "file": 23, "line": 718}, "message": "{ (fixit)"}, {"location": {"col": 22, "file": 23, "line": 718}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/src/lib-storage/mail-storage.c", "reportHash": "0f04e9b6d4003c157fb9f421ff10bff2", "checkerName": "readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 55, "file": 23, "line": 741}, "message": "{ (fixit)"}, {"location": {"col": 47, "file": 23, "line": 741}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/src/lib-storage/mail-storage.c", "reportHash": "262c9103b762b1f5293ed69290e8f1e7", "checkerName": "google-readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 42, "file": 23, "line": 747}, "message": "{ (fixit)"}, {"location": {"col": 34, "file": 23, "line": 747}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/src/lib-storage/mail-storage.c", "reportHash": "09966513a965042613ad30e8df11bc3a", "checkerName": "google-readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 10, "file": 23, "line": 768}, "message": "use of a signed integer operand with a binary bitwise operator"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/src/lib-storage/mail-storage.c", "reportHash": "ecec18e8eb117003f5d008191ddecf5b", "checkerName": "hicpp-signed-bitwise", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 60, "file": 23, "line": 777}, "message": "{ (fixit)"}, {"location": {"col": 52, "file": 23, "line": 777}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/src/lib-storage/mail-storage.c", "reportHash": "355ebb4c58415bf0fc2b2c66e3b9b36f", "checkerName": "google-readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 53, "file": 23, "line": 795}, "message": "{ (fixit)"}, {"location": {"col": 45, "file": 23, "line": 795}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/src/lib-storage/mail-storage.c", "reportHash": "3b9ae6d1f1f687e7cf7ecdb613431c53", "checkerName": "hicpp-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 76, "file": 23, "line": 800}, "message": "{ (fixit)"}, {"location": {"col": 61, "file": 23, "line": 800}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/src/lib-storage/mail-storage.c", "reportHash": "9ee45263140e59c5c5f8aebbba29eaa4", "checkerName": "google-readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 59, "file": 23, "line": 808}, "message": "{ (fixit)"}, {"location": {"col": 44, "file": 23, "line": 808}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/src/lib-storage/mail-storage.c", "reportHash": "1144127b847304697a62ba2da6ff5c55", "checkerName": "google-readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 39, "file": 23, "line": 831}, "message": "{ (fixit)"}, {"location": {"col": 24, "file": 23, "line": 831}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/src/lib-storage/mail-storage.c", "reportHash": "eb0d96c3a73ffedddf9856c39017f317", "checkerName": "google-readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 72, "file": 23, "line": 833}, "message": "{ (fixit)"}, {"location": {"col": 57, "file": 23, "line": 833}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/src/lib-storage/mail-storage.c", "reportHash": "01ebe6689aef9995fc7c9cdd2b429d53", "checkerName": "hicpp-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 38, "file": 23, "line": 858}, "message": "{ (fixit)"}, {"location": {"col": 23, "file": 23, "line": 858}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/src/lib-storage/mail-storage.c", "reportHash": "3bd37d7203d75710363c5b455c8fe2aa", "checkerName": "google-readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 35, "file": 23, "line": 920}, "message": "{ (fixit)"}, {"location": {"col": 27, "file": 23, "line": 920}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/src/lib-storage/mail-storage.c", "reportHash": "93e246f66760fd0a899464781fc6a8c8", "checkerName": "google-readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 41, "file": 23, "line": 939}, "message": "{ (fixit)"}, {"location": {"col": 33, "file": 23, "line": 939}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/src/lib-storage/mail-storage.c", "reportHash": "427814dee613af3b6e482cbdec94a0b9", "checkerName": "google-readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 34, "file": 9, "line": 18}, "message": "expanded from macro 'HAS_ALL_BITS'"}, {"location": {"col": 7, "file": 23, "line": 941}, "message": "use of a signed integer operand with a binary bitwise operator"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/src/lib-storage/mail-storage.c", "reportHash": "d789ecb37b9b51b95b78eaecf7327816", "checkerName": "hicpp-signed-bitwise", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 67, "file": 23, "line": 941}, "message": "{ (fixit)"}, {"location": {"col": 59, "file": 23, "line": 941}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/src/lib-storage/mail-storage.c", "reportHash": "f5d908dae2fb4175dd39b5391f9e0eae", "checkerName": "hicpp-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 3, "file": 23, "line": 945}, "message": "use of a signed integer operand with a binary bitwise operator"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/src/lib-storage/mail-storage.c", "reportHash": "5ef733a5e2a5914ca9bfd1db58df0bc2", "checkerName": "hicpp-signed-bitwise", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 8, "file": 23, "line": 948}, "message": "use of a signed integer operand with a binary bitwise operator"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/src/lib-storage/mail-storage.c", "reportHash": "93d836ad7dc20d1c737e0617af799b83", "checkerName": "hicpp-signed-bitwise", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 9, "file": 23, "line": 949}, "message": "use of a signed integer operand with a binary bitwise operator"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/src/lib-storage/mail-storage.c", "reportHash": "8446f94bccd2a21a3c4b1d69911476ac", "checkerName": "hicpp-signed-bitwise", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 70, "file": 23, "line": 949}, "message": "{ (fixit)"}, {"location": {"col": 55, "file": 23, "line": 949}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/src/lib-storage/mail-storage.c", "reportHash": "791a67ea7c587ef3c60cba7424c8591d", "checkerName": "google-readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 23, "file": 23, "line": 991}, "message": "{ (fixit)"}, {"location": {"col": 15, "file": 23, "line": 991}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/src/lib-storage/mail-storage.c", "reportHash": "fc363748b662de874350189164186dbc", "checkerName": "google-readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 31, "file": 23, "line": 1002}, "message": "{ (fixit)"}, {"location": {"col": 16, "file": 23, "line": 1002}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/src/lib-storage/mail-storage.c", "reportHash": "d15228f208147fd3b742f341eb3a12cb", "checkerName": "google-readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 34, "file": 9, "line": 18}, "message": "expanded from macro 'HAS_ALL_BITS'"}, {"location": {"col": 6, "file": 23, "line": 1020}, "message": "use of a signed integer operand with a binary bitwise operator"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/src/lib-storage/mail-storage.c", "reportHash": "340e573ae5ce33a7f3fcdcb1e531c456", "checkerName": "hicpp-signed-bitwise", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 34, "file": 9, "line": 18}, "message": "expanded from macro 'HAS_ALL_BITS'"}, {"location": {"col": 6, "file": 23, "line": 1040}, "message": "use of a signed integer operand with a binary bitwise operator"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/src/lib-storage/mail-storage.c", "reportHash": "86141e7c0feb554fad64810c86dcffdd", "checkerName": "hicpp-signed-bitwise", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 8, "file": 23, "line": 1044}, "message": "use of a signed integer operand with a binary bitwise operator"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/src/lib-storage/mail-storage.c", "reportHash": "af799271216182e54d85e124a061be0a", "checkerName": "hicpp-signed-bitwise", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 44, "file": 23, "line": 1060}, "message": "{ (fixit)"}, {"location": {"col": 36, "file": 23, "line": 1060}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/src/lib-storage/mail-storage.c", "reportHash": "1804d14dbd3c627207247b5194ad7ee4", "checkerName": "google-readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 30, "file": 23, "line": 1074}, "message": "{ (fixit)"}, {"location": {"col": 22, "file": 23, "line": 1074}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/src/lib-storage/mail-storage.c", "reportHash": "ead93ea648e77f95a5cd889beefe17a3", "checkerName": "readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 7, "file": 23, "line": 1076}, "message": "use of a signed integer operand with a binary bitwise operator"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/src/lib-storage/mail-storage.c", "reportHash": "571f6e7a3b36ee664c4cc9a42d417acf", "checkerName": "hicpp-signed-bitwise", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 59, "file": 23, "line": 1076}, "message": "{ (fixit)"}, {"location": {"col": 51, "file": 23, "line": 1076}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/src/lib-storage/mail-storage.c", "reportHash": "ca198a7d34ef62c6ffe6d59141d26700", "checkerName": "google-readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 7, "file": 23, "line": 1084}, "message": "use of a signed integer operand with a binary bitwise operator"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/src/lib-storage/mail-storage.c", "reportHash": "2c432d02d49a989b3056b7ab5f9eb599", "checkerName": "hicpp-signed-bitwise", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 62, "file": 23, "line": 1084}, "message": "{ (fixit)"}, {"location": {"col": 54, "file": 23, "line": 1084}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/src/lib-storage/mail-storage.c", "reportHash": "c0a8bdf519db1547a68d88e51c59911f", "checkerName": "google-readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 42, "file": 23, "line": 1122}, "message": "{ (fixit)"}, {"location": {"col": 34, "file": 23, "line": 1122}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/src/lib-storage/mail-storage.c", "reportHash": "38c86c30082f6a5b5423cd2c373d01ea", "checkerName": "google-readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 34, "file": 23, "line": 1177}, "message": "{ (fixit)"}, {"location": {"col": 26, "file": 23, "line": 1177}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/src/lib-storage/mail-storage.c", "reportHash": "f49ecfffc0a07a859a3be9a2bfdbd6af", "checkerName": "readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 26, "file": 23, "line": 1266}, "message": "{ (fixit)"}, {"location": {"col": 18, "file": 23, "line": 1266}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/src/lib-storage/mail-storage.c", "reportHash": "d4897287ea9f5a856ab8fa06109b39e6", "checkerName": "google-readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 43, "file": 23, "line": 1269}, "message": "{ (fixit)"}, {"location": {"col": 35, "file": 23, "line": 1269}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/src/lib-storage/mail-storage.c", "reportHash": "6ec108bdfd55e996c058ac62fd9f9621", "checkerName": "google-readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 51, "file": 23, "line": 1277}, "message": "{ (fixit)"}, {"location": {"col": 36, "file": 23, "line": 1277}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/src/lib-storage/mail-storage.c", "reportHash": "4c38b5d84d49687579e8ae1e49ebb454", "checkerName": "google-readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 50, "file": 23, "line": 1280}, "message": "{ (fixit)"}, {"location": {"col": 35, "file": 23, "line": 1280}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/src/lib-storage/mail-storage.c", "reportHash": "d0f7aa97e0ef810b07ff34583b6017d2", "checkerName": "google-readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 53, "file": 23, "line": 1284}, "message": "{ (fixit)"}, {"location": {"col": 17, "file": 23, "line": 1284}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/src/lib-storage/mail-storage.c", "reportHash": "d9a9862afc5b4309843f0d13918a446b", "checkerName": "google-readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 46, "file": 23, "line": 1295}, "message": "{ (fixit)"}, {"location": {"col": 31, "file": 23, "line": 1295}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/src/lib-storage/mail-storage.c", "reportHash": "458971aca1ff33cbf77e66ee9b561cba", "checkerName": "google-readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 43, "file": 23, "line": 1313}, "message": "{ (fixit)"}, {"location": {"col": 35, "file": 23, "line": 1313}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/src/lib-storage/mail-storage.c", "reportHash": "32842c818fa0148ec752364b71c5f941", "checkerName": "hicpp-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 49, "file": 23, "line": 1315}, "message": "{ (fixit)"}, {"location": {"col": 41, "file": 23, "line": 1315}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/src/lib-storage/mail-storage.c", "reportHash": "d46f0d3f2112b5e30c16bf9a7a794877", "checkerName": "hicpp-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 8, "file": 23, "line": 1354}, "message": "use of a signed integer operand with a binary bitwise operator"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/src/lib-storage/mail-storage.c", "reportHash": "dd563e54288cef5b34fd1155673f5de3", "checkerName": "hicpp-signed-bitwise", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 21, "file": 23, "line": 1354}, "message": "use of a signed integer operand with a binary bitwise operator"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/src/lib-storage/mail-storage.c", "reportHash": "c7a8df62c27668ef4d4e956e978f745a", "checkerName": "hicpp-signed-bitwise", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 72, "file": 23, "line": 1355}, "message": "{ (fixit)"}, {"location": {"col": 43, "file": 23, "line": 1355}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/src/lib-storage/mail-storage.c", "reportHash": "db0de56d7934d14c165ae132d5e3204a", "checkerName": "google-readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 49, "file": 23, "line": 1358}, "message": "{ (fixit)"}, {"location": {"col": 34, "file": 23, "line": 1358}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/src/lib-storage/mail-storage.c", "reportHash": "ace30c796817548084794d0a54aa9814", "checkerName": "google-readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 73, "file": 23, "line": 1364}, "message": "{ (fixit)"}, {"location": {"col": 58, "file": 23, "line": 1364}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/src/lib-storage/mail-storage.c", "reportHash": "44eb52221bfdeca88ba5809bcff11c95", "checkerName": "google-readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 62, "file": 23, "line": 1396}, "message": "{ (fixit)"}, {"location": {"col": 54, "file": 23, "line": 1396}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/src/lib-storage/mail-storage.c", "reportHash": "12ba39b7f5c08d229398a1792b69d872", "checkerName": "google-readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 26, "file": 23, "line": 1419}, "message": "{ (fixit)"}, {"location": {"col": 18, "file": 23, "line": 1419}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/src/lib-storage/mail-storage.c", "reportHash": "75ea4b46fe8f4cc1596b8369a8d8877b", "checkerName": "hicpp-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 52, "file": 23, "line": 1441}, "message": "{ (fixit)"}, {"location": {"col": 44, "file": 23, "line": 1441}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/src/lib-storage/mail-storage.c", "reportHash": "1841aac83b163b20f6964f0305065007", "checkerName": "google-readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 8, "file": 23, "line": 1445}, "message": "use of a signed integer operand with a binary bitwise operator"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/src/lib-storage/mail-storage.c", "reportHash": "00e3827ae99fa07a4e4a8d2265bdf9fe", "checkerName": "hicpp-signed-bitwise", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 64, "file": 23, "line": 1462}, "message": "{ (fixit)"}, {"location": {"col": 56, "file": 23, "line": 1462}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/src/lib-storage/mail-storage.c", "reportHash": "57028b3066cd3ff53e5e33dde2d31d26", "checkerName": "google-readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 41, "file": 23, "line": 1467}, "message": "{ (fixit)"}, {"location": {"col": 26, "file": 23, "line": 1467}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/src/lib-storage/mail-storage.c", "reportHash": "ba11f43c6168a7f3b3ca05da5b250782", "checkerName": "hicpp-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 7, "file": 23, "line": 1482}, "message": "use of a signed integer operand with a binary bitwise operator"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/src/lib-storage/mail-storage.c", "reportHash": "7a184780baaf1e5e220f652257b6a8c6", "checkerName": "hicpp-signed-bitwise", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 71, "file": 23, "line": 1489}, "message": "{ (fixit)"}, {"location": {"col": 63, "file": 23, "line": 1489}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/src/lib-storage/mail-storage.c", "reportHash": "86f3ec68e3344222bf90a26892476e16", "checkerName": "google-readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 61, "file": 23, "line": 1491}, "message": "{ (fixit)"}, {"location": {"col": 53, "file": 23, "line": 1491}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/src/lib-storage/mail-storage.c", "reportHash": "601fa16ce1a986e9df171716ad8bd04e", "checkerName": "google-readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 22, "file": 23, "line": 1497}, "message": "{ (fixit)"}, {"location": {"col": 14, "file": 23, "line": 1497}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/src/lib-storage/mail-storage.c", "reportHash": "956a0f6c5d22957f16676cd1e81f0161", "checkerName": "readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 71, "file": 23, "line": 1506}, "message": "{ (fixit)"}, {"location": {"col": 56, "file": 23, "line": 1506}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/src/lib-storage/mail-storage.c", "reportHash": "e9667922ef36762fdb8f2db98da9e999", "checkerName": "google-readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 48, "file": 23, "line": 1513}, "message": "{ (fixit)"}, {"location": {"col": 33, "file": 23, "line": 1513}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/src/lib-storage/mail-storage.c", "reportHash": "0da9f360f00cbecd63d595ebc3c4a47b", "checkerName": "google-readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 55, "file": 23, "line": 1520}, "message": "{ (fixit)"}, {"location": {"col": 40, "file": 23, "line": 1520}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/src/lib-storage/mail-storage.c", "reportHash": "a162e32bb81b7833ba37cbd58798f390", "checkerName": "readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 37, "file": 23, "line": 1531}, "message": "{ (fixit)"}, {"location": {"col": 29, "file": 23, "line": 1531}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/src/lib-storage/mail-storage.c", "reportHash": "9530e80fb2ff15a2fbcf25e0175ceae6", "checkerName": "google-readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 23, "file": 23, "line": 1536}, "message": "{ (fixit)"}, {"location": {"col": 15, "file": 23, "line": 1536}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/src/lib-storage/mail-storage.c", "reportHash": "1a42511a5ce9c1af547db90dbd71ae27", "checkerName": "google-readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 88, "file": 23, "line": 1539}, "message": "{ (fixit)"}, {"location": {"col": 80, "file": 23, "line": 1539}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/src/lib-storage/mail-storage.c", "reportHash": "92c797feb6e1edeb544b12c24e171fb3", "checkerName": "google-readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 36, "file": 23, "line": 1558}, "message": "{ (fixit)"}, {"location": {"col": 28, "file": 23, "line": 1558}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/src/lib-storage/mail-storage.c", "reportHash": "ab31628c1059216586fb227a8c27ef31", "checkerName": "google-readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 55, "file": 23, "line": 1560}, "message": "{ (fixit)"}, {"location": {"col": 47, "file": 23, "line": 1560}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/src/lib-storage/mail-storage.c", "reportHash": "65d679d47244e2be83f623fbdfbc874d", "checkerName": "google-readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 56, "file": 23, "line": 1563}, "message": "{ (fixit)"}, {"location": {"col": 48, "file": 23, "line": 1563}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/src/lib-storage/mail-storage.c", "reportHash": "da252b8347623ecd860a80dc0b85a8b5", "checkerName": "google-readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 16, "file": 23, "line": 1565}, "message": "use of a signed integer operand with a binary bitwise operator"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/src/lib-storage/mail-storage.c", "reportHash": "dda877a89f7a6606185fa11b174acccd", "checkerName": "hicpp-signed-bitwise", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 7, "file": 23, "line": 1567}, "message": "use of a signed integer operand with a binary bitwise operator"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/src/lib-storage/mail-storage.c", "reportHash": "c1d430a09eb6016e832f13e59938b5f2", "checkerName": "hicpp-signed-bitwise", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 56, "file": 23, "line": 1567}, "message": "{ (fixit)"}, {"location": {"col": 48, "file": 23, "line": 1567}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/src/lib-storage/mail-storage.c", "reportHash": "f179c1d2ae3f1b16a8dd70013f01a4fd", "checkerName": "google-readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 63, "file": 23, "line": 1569}, "message": "{ (fixit)"}, {"location": {"col": 55, "file": 23, "line": 1569}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/src/lib-storage/mail-storage.c", "reportHash": "a6d7a70cb712ec6c158deb734c63efae", "checkerName": "google-readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 43, "file": 23, "line": 1582}, "message": "{ (fixit)"}, {"location": {"col": 35, "file": 23, "line": 1582}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/src/lib-storage/mail-storage.c", "reportHash": "2062f1187676a5b8ef27cea4910cbba0", "checkerName": "readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 48, "file": 23, "line": 1594}, "message": "{ (fixit)"}, {"location": {"col": 40, "file": 23, "line": 1594}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/src/lib-storage/mail-storage.c", "reportHash": "1a18c68d163396fd5373fc4b461221ee", "checkerName": "google-readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 38, "file": 25, "line": 246}, "message": "expanded from macro 'i_zero'"}, {"location": {"col": 2, "file": 23, "line": 1599}, "message": "suspicious usage of 'sizeof(A*)'; pointer to aggregate"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/src/lib-storage/mail-storage.c", "reportHash": "101cfe86aabdc349878e068b18aff5be", "checkerName": "misc-sizeof-expression", "reviewStatus": null, "severity": "HIGH"}, {"events": [{"location": {"col": 27, "file": 23, "line": 1604}, "message": "{ (fixit)"}, {"location": {"col": 19, "file": 23, "line": 1604}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/src/lib-storage/mail-storage.c", "reportHash": "71cf29b691627ce98914d8821452f6e0", "checkerName": "google-readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 52, "file": 23, "line": 1613}, "message": "{ (fixit)"}, {"location": {"col": 44, "file": 23, "line": 1613}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/src/lib-storage/mail-storage.c", "reportHash": "123d9927f40994919ef2a8eccee869ba", "checkerName": "google-readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 51, "file": 23, "line": 1619}, "message": "{ (fixit)"}, {"location": {"col": 43, "file": 23, "line": 1619}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/src/lib-storage/mail-storage.c", "reportHash": "03c0a9a80e77e701e1321248ba5c5281", "checkerName": "google-readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 25, "file": 23, "line": 1650}, "message": "{ (fixit)"}, {"location": {"col": 17, "file": 23, "line": 1650}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/src/lib-storage/mail-storage.c", "reportHash": "38fc35d953400d68b6f81cb021f0dd0e", "checkerName": "google-readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 41, "file": 23, "line": 1654}, "message": "{ (fixit)"}, {"location": {"col": 33, "file": 23, "line": 1654}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/src/lib-storage/mail-storage.c", "reportHash": "0353fa87bd49af7fe786e3b9935e52e4", "checkerName": "google-readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 31, "file": 23, "line": 1668}, "message": "{ (fixit)"}, {"location": {"col": 23, "file": 23, "line": 1668}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/src/lib-storage/mail-storage.c", "reportHash": "e6a632d5c8b987cf7c90fcf0ea23e9d5", "checkerName": "readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 50, "file": 23, "line": 1700}, "message": "{ (fixit)"}, {"location": {"col": 42, "file": 23, "line": 1700}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/src/lib-storage/mail-storage.c", "reportHash": "2de7a770375d20fa0c78b1aab7480047", "checkerName": "google-readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 38, "file": 23, "line": 1719}, "message": "{ (fixit)"}, {"location": {"col": 23, "file": 23, "line": 1719}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/src/lib-storage/mail-storage.c", "reportHash": "180973562659e207bdf373103df4024d", "checkerName": "google-readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 52, "file": 23, "line": 1739}, "message": "{ (fixit)"}, {"location": {"col": 44, "file": 23, "line": 1739}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/src/lib-storage/mail-storage.c", "reportHash": "cb1fe6031f34407727e0afbf9228e1fa", "checkerName": "readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 55, "file": 23, "line": 1742}, "message": "{ (fixit)"}, {"location": {"col": 47, "file": 23, "line": 1742}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/src/lib-storage/mail-storage.c", "reportHash": "61f502d0140ee8ec941cd4ad472677c4", "checkerName": "google-readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 13, "file": 23, "line": 1760}, "message": "use of a signed integer operand with a binary bitwise operator"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/src/lib-storage/mail-storage.c", "reportHash": "804bdccb537d18add562a9145d086e17", "checkerName": "hicpp-signed-bitwise", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 16, "file": 23, "line": 1763}, "message": "use of a signed integer operand with a binary bitwise operator"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/src/lib-storage/mail-storage.c", "reportHash": "49331a63e5414133e0c46da76c184348", "checkerName": "hicpp-signed-bitwise", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 29, "file": 23, "line": 1763}, "message": "use of a signed integer operand with a unary bitwise operator"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/src/lib-storage/mail-storage.c", "reportHash": "3b3757046c4b4250491974772e16cdbe", "checkerName": "hicpp-signed-bitwise", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 22, "file": 23, "line": 1764}, "message": "{ (fixit)"}, {"location": {"col": 14, "file": 23, "line": 1764}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/src/lib-storage/mail-storage.c", "reportHash": "2886759b9899a4e637add246a9b5de0f", "checkerName": "google-readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 18, "file": 23, "line": 1769}, "message": "{ (fixit)"}, {"location": {"col": 10, "file": 23, "line": 1769}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/src/lib-storage/mail-storage.c", "reportHash": "8599d86a64675a9ffaad50e9d8143b2b", "checkerName": "hicpp-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 14, "file": 23, "line": 1771}, "message": "{ (fixit)"}, {"location": {"col": 6, "file": 23, "line": 1771}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/src/lib-storage/mail-storage.c", "reportHash": "b3a937858426e076aa5532c58ed035a5", "checkerName": "hicpp-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 30, "file": 23, "line": 1786}, "message": "{ (fixit)"}, {"location": {"col": 15, "file": 23, "line": 1786}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/src/lib-storage/mail-storage.c", "reportHash": "39461cf46c1e64da72be91364e3ff234", "checkerName": "google-readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 38, "file": 25, "line": 246}, "message": "expanded from macro 'i_zero'"}, {"location": {"col": 2, "file": 23, "line": 1796}, "message": "suspicious usage of 'sizeof(A*)'; pointer to aggregate"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/src/lib-storage/mail-storage.c", "reportHash": "9aaae22d9bcd1a5a3d84d510c3683f34", "checkerName": "misc-sizeof-expression", "reviewStatus": null, "severity": "HIGH"}, {"events": [{"location": {"col": 44, "file": 23, "line": 1815}, "message": "{ (fixit)"}, {"location": {"col": 29, "file": 23, "line": 1815}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/src/lib-storage/mail-storage.c", "reportHash": "e8ae828a9d910ce46d44d1619f7b2286", "checkerName": "google-readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 65, "file": 23, "line": 1831}, "message": "{ (fixit)"}, {"location": {"col": 50, "file": 23, "line": 1831}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/src/lib-storage/mail-storage.c", "reportHash": "2f019b2694f1436b9cc6a88a66a87c13", "checkerName": "google-readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 26, "file": 23, "line": 1834}, "message": "{ (fixit)"}, {"location": {"col": 18, "file": 23, "line": 1834}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/src/lib-storage/mail-storage.c", "reportHash": "17b5d28c215dc583e65b914d5ef92d73", "checkerName": "google-readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 35, "file": 23, "line": 1863}, "message": "{ (fixit)"}, {"location": {"col": 27, "file": 23, "line": 1863}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/src/lib-storage/mail-storage.c", "reportHash": "987a22543982b23253a6220f4bf095f7", "checkerName": "readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 7, "file": 23, "line": 1871}, "message": "use of a signed integer operand with a binary bitwise operator"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/src/lib-storage/mail-storage.c", "reportHash": "a2b862ddb605d9760b57f3773b75ee57", "checkerName": "hicpp-signed-bitwise", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 63, "file": 23, "line": 1931}, "message": "{ (fixit)"}, {"location": {"col": 48, "file": 23, "line": 1931}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/src/lib-storage/mail-storage.c", "reportHash": "613c0cd3e43f85867c6c6084b5659dc7", "checkerName": "google-readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 43, "file": 23, "line": 1955}, "message": "{ (fixit)"}, {"location": {"col": 35, "file": 23, "line": 1955}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/src/lib-storage/mail-storage.c", "reportHash": "77b4f961ca8736635f34131b1ba4d460", "checkerName": "google-readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 22, "file": 23, "line": 2003}, "message": "{ (fixit)"}, {"location": {"col": 14, "file": 23, "line": 2003}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/src/lib-storage/mail-storage.c", "reportHash": "2886759b9899a4e637add246a9b5de0f", "checkerName": "google-readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 43, "file": 23, "line": 2012}, "message": "{ (fixit)"}, {"location": {"col": 35, "file": 23, "line": 2012}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/src/lib-storage/mail-storage.c", "reportHash": "6ec108bdfd55e996c058ac62fd9f9621", "checkerName": "google-readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 48, "file": 23, "line": 2018}, "message": "{ (fixit)"}, {"location": {"col": 40, "file": 23, "line": 2018}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/src/lib-storage/mail-storage.c", "reportHash": "3a7d7e3beeeabef7b0a63a5f5cfbef08", "checkerName": "google-readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 26, "file": 23, "line": 2030}, "message": "use of a signed integer operand with a binary bitwise operator"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/src/lib-storage/mail-storage.c", "reportHash": "3acd9b27d07c05e43123ccf017105e34", "checkerName": "hicpp-signed-bitwise", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 50, "file": 23, "line": 2071}, "message": "{ (fixit)"}, {"location": {"col": 42, "file": 23, "line": 2071}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/src/lib-storage/mail-storage.c", "reportHash": "b69dfb79c3ccc4403987de23cfd1c2f6", "checkerName": "readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 40, "file": 23, "line": 2074}, "message": "{ (fixit)"}, {"location": {"col": 32, "file": 23, "line": 2074}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/src/lib-storage/mail-storage.c", "reportHash": "cd30b3dc6d3582bef8b52a6b6bad338c", "checkerName": "google-readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 40, "file": 23, "line": 2076}, "message": "{ (fixit)"}, {"location": {"col": 32, "file": 23, "line": 2076}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/src/lib-storage/mail-storage.c", "reportHash": "3239c1f57384895b6fa5d86a5295785a", "checkerName": "hicpp-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 7, "file": 23, "line": 2086}, "message": "use of a signed integer operand with a binary bitwise operator"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/src/lib-storage/mail-storage.c", "reportHash": "c393c80b513f8fa2223186b37596a8dc", "checkerName": "hicpp-signed-bitwise", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 89, "file": 23, "line": 2086}, "message": "{ (fixit)"}, {"location": {"col": 81, "file": 23, "line": 2086}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/src/lib-storage/mail-storage.c", "reportHash": "0c98da2d19c5cc6ae3680ae0a57ab3a0", "checkerName": "google-readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 7, "file": 23, "line": 2088}, "message": "use of a signed integer operand with a binary bitwise operator"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/src/lib-storage/mail-storage.c", "reportHash": "22fadb7d45c96cb463917446e6c00e88", "checkerName": "hicpp-signed-bitwise", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 94, "file": 23, "line": 2088}, "message": "{ (fixit)"}, {"location": {"col": 86, "file": 23, "line": 2088}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/src/lib-storage/mail-storage.c", "reportHash": "92f50480c5b1a02f10bcbbfe2147956d", "checkerName": "google-readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 7, "file": 23, "line": 2090}, "message": "use of a signed integer operand with a binary bitwise operator"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/src/lib-storage/mail-storage.c", "reportHash": "478eb3582283e278b58bb33ee18e3b7c", "checkerName": "hicpp-signed-bitwise", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 91, "file": 23, "line": 2090}, "message": "{ (fixit)"}, {"location": {"col": 83, "file": 23, "line": 2090}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/src/lib-storage/mail-storage.c", "reportHash": "d572d73cb5953c717ea701c130bc77e3", "checkerName": "google-readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 52, "file": 23, "line": 2099}, "message": "{ (fixit)"}, {"location": {"col": 44, "file": 23, "line": 2099}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/src/lib-storage/mail-storage.c", "reportHash": "1841aac83b163b20f6964f0305065007", "checkerName": "google-readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 58, "file": 23, "line": 2102}, "message": "{ (fixit)"}, {"location": {"col": 50, "file": 23, "line": 2102}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/src/lib-storage/mail-storage.c", "reportHash": "ea960263270cfc85290ce503bd256115", "checkerName": "google-readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 21, "file": 25, "line": 208}, "message": "expanded from macro 'i_assert'"}, {"location": {"col": 45, "file": 25, "line": 189}, "message": "expanded from macro 'unlikely'"}, {"location": {"col": 12, "file": 23, "line": 2113}, "message": "use of a signed integer operand with a binary bitwise operator"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/src/lib-storage/mail-storage.c", "reportHash": "169f9ecfdabec26c84211d11493b3447", "checkerName": "hicpp-signed-bitwise", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 3, "file": 26, "line": 108}, "message": "expanded from macro 'MAILBOX_STATUS_FAILING_ITEMS'"}, {"location": {"col": 21, "file": 25, "line": 208}, "message": "expanded from macro 'i_assert'"}, {"location": {"col": 45, "file": 25, "line": 189}, "message": "expanded from macro 'unlikely'"}, {"location": {"col": 20, "file": 23, "line": 2113}, "message": "use of a signed integer operand with a binary bitwise operator"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/src/lib-storage/mail-storage.c", "reportHash": "8d9c5fd717b09818b3e211722e7d0525", "checkerName": "hicpp-signed-bitwise", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 58, "file": 23, "line": 2116}, "message": "{ (fixit)"}, {"location": {"col": 50, "file": 23, "line": 2116}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/src/lib-storage/mail-storage.c", "reportHash": "ea960263270cfc85290ce503bd256115", "checkerName": "google-readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 52, "file": 23, "line": 2124}, "message": "{ (fixit)"}, {"location": {"col": 44, "file": 23, "line": 2124}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/src/lib-storage/mail-storage.c", "reportHash": "1841aac83b163b20f6964f0305065007", "checkerName": "google-readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 62, "file": 23, "line": 2127}, "message": "{ (fixit)"}, {"location": {"col": 54, "file": 23, "line": 2127}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/src/lib-storage/mail-storage.c", "reportHash": "bb566126dcc1395721ec7bd2fb450396", "checkerName": "google-readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 21, "file": 25, "line": 208}, "message": "expanded from macro 'i_assert'"}, {"location": {"col": 45, "file": 25, "line": 189}, "message": "expanded from macro 'unlikely'"}, {"location": {"col": 12, "file": 23, "line": 2130}, "message": "use of a signed integer operand with a binary bitwise operator"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/src/lib-storage/mail-storage.c", "reportHash": "630ded405f733748809844779b01aa8f", "checkerName": "hicpp-signed-bitwise", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 52, "file": 23, "line": 2137}, "message": "{ (fixit)"}, {"location": {"col": 44, "file": 23, "line": 2137}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/src/lib-storage/mail-storage.c", "reportHash": "3378869658826142002bc472bf99e482", "checkerName": "google-readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 2, "file": 23, "line": 2139}, "message": "do not use 'else' after 'return'"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/src/lib-storage/mail-storage.c", "reportHash": "f52ae908f8a1c73859fef47e1f345158", "checkerName": "readability-else-after-return", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 56, "file": 23, "line": 2139}, "message": "{ (fixit)"}, {"location": {"col": 48, "file": 23, "line": 2139}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/src/lib-storage/mail-storage.c", "reportHash": "66d3aedb84296725238acf6b1d9f6905", "checkerName": "readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 14, "file": 23, "line": 2141}, "message": "{ (fixit)"}, {"location": {"col": 6, "file": 23, "line": 2141}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/src/lib-storage/mail-storage.c", "reportHash": "b3a937858426e076aa5532c58ed035a5", "checkerName": "hicpp-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 28, "file": 27, "line": 8}, "message": "expanded from macro 'i_new'"}, {"location": {"col": 27, "file": 28, "line": 92}, "message": "expanded from macro 'p_new'"}, {"location": {"col": 41, "file": 29, "line": 25}, "message": "expanded from macro 'MALLOC_MULTIPLY'"}, {"location": {"col": 10, "file": 23, "line": 2156}, "message": "suspicious usage of 'sizeof(K)'; did you mean 'K'?"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/src/lib-storage/mail-storage.c", "reportHash": "ed5431028c911e3ea1f8f37469d958e8", "checkerName": "misc-sizeof-expression", "reviewStatus": null, "severity": "HIGH"}, {"events": [{"location": {"col": 28, "file": 27, "line": 8}, "message": "expanded from macro 'i_new'"}, {"location": {"col": 27, "file": 28, "line": 92}, "message": "expanded from macro 'p_new'"}, {"location": {"col": 30, "file": 29, "line": 25}, "message": "expanded from macro 'MALLOC_MULTIPLY'"}, {"location": {"col": 10, "file": 23, "line": 2156}, "message": "suspicious usage of 'sizeof(sizeof(...))'"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/src/lib-storage/mail-storage.c", "reportHash": "c89d145815f13b93feaf3cc20c8c341c", "checkerName": "misc-sizeof-expression", "reviewStatus": null, "severity": "HIGH"}, {"events": [{"location": {"col": 31, "file": 23, "line": 2172}, "message": "{ (fixit)"}, {"location": {"col": 23, "file": 23, "line": 2172}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/src/lib-storage/mail-storage.c", "reportHash": "23350e55a429cd5f95ec081b5df7d2cc", "checkerName": "google-readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 32, "file": 23, "line": 2190}, "message": "{ (fixit)"}, {"location": {"col": 24, "file": 23, "line": 2190}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/src/lib-storage/mail-storage.c", "reportHash": "7fc65cb346fb9febe7c8b07824c19491", "checkerName": "google-readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 23, "file": 23, "line": 2204}, "message": "{ (fixit)"}, {"location": {"col": 15, "file": 23, "line": 2204}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/src/lib-storage/mail-storage.c", "reportHash": "ca7db4946fa0b318a67cd1ed1bc11cca", "checkerName": "google-readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 32, "file": 23, "line": 2256}, "message": "{ (fixit)"}, {"location": {"col": 24, "file": 23, "line": 2256}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/src/lib-storage/mail-storage.c", "reportHash": "7089c56d4c6b4b635935c9479d36b077", "checkerName": "google-readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 32, "file": 23, "line": 2280}, "message": "{ (fixit)"}, {"location": {"col": 17, "file": 23, "line": 2280}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/src/lib-storage/mail-storage.c", "reportHash": "9f22d9aae4a03f4175f2ddf7a2563e55", "checkerName": "hicpp-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 68, "file": 23, "line": 2294}, "message": "{ (fixit)"}, {"location": {"col": 60, "file": 23, "line": 2294}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/src/lib-storage/mail-storage.c", "reportHash": "3ce1446de50f683be54414803489219a", "checkerName": "google-readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 2, "file": 23, "line": 2296}, "message": "do not use 'else' after 'return'"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/src/lib-storage/mail-storage.c", "reportHash": "c680a2be13f710664c7f564ce62ed9c7", "checkerName": "readability-else-after-return", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 49, "file": 23, "line": 2336}, "message": "{ (fixit)"}, {"location": {"col": 41, "file": 23, "line": 2336}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/src/lib-storage/mail-storage.c", "reportHash": "5fea154fc518ba5d1e2ecf30b99d8d4f", "checkerName": "hicpp-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 22, "file": 23, "line": 2339}, "message": "{ (fixit)"}, {"location": {"col": 14, "file": 23, "line": 2339}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/src/lib-storage/mail-storage.c", "reportHash": "2886759b9899a4e637add246a9b5de0f", "checkerName": "google-readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 49, "file": 23, "line": 2397}, "message": "{ (fixit)"}, {"location": {"col": 41, "file": 23, "line": 2397}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/src/lib-storage/mail-storage.c", "reportHash": "9bdc36e33ce1e881f17b1b88de0dba47", "checkerName": "google-readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 37, "file": 23, "line": 2451}, "message": "{ (fixit)"}, {"location": {"col": 29, "file": 23, "line": 2451}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/src/lib-storage/mail-storage.c", "reportHash": "5a81efe684c9699c57702c3ed79460f8", "checkerName": "readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 41, "file": 23, "line": 2474}, "message": "{ (fixit)"}, {"location": {"col": 33, "file": 23, "line": 2474}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/src/lib-storage/mail-storage.c", "reportHash": "d0788a5b53458fc0158ee7875fd8feea", "checkerName": "google-readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 31, "file": 23, "line": 2480}, "message": "{ (fixit)"}, {"location": {"col": 23, "file": 23, "line": 2480}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/src/lib-storage/mail-storage.c", "reportHash": "a4e9aa0728c4713e5e8d95416b67afb1", "checkerName": "hicpp-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 31, "file": 23, "line": 2494}, "message": "{ (fixit)"}, {"location": {"col": 23, "file": 23, "line": 2494}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/src/lib-storage/mail-storage.c", "reportHash": "028a61e5d35071e937c968cb3a58904a", "checkerName": "readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 75, "file": 23, "line": 2573}, "message": "{ (fixit)"}, {"location": {"col": 67, "file": 23, "line": 2573}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/src/lib-storage/mail-storage.c", "reportHash": "9868daee7a9ea7444fe6f0f37ba1e6c2", "checkerName": "hicpp-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 16, "file": 23, "line": 2590}, "message": "{ (fixit)"}, {"location": {"col": 8, "file": 23, "line": 2590}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/src/lib-storage/mail-storage.c", "reportHash": "16c7556c6a723ff56d5aaab90bde59dc", "checkerName": "hicpp-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 47, "file": 23, "line": 2617}, "message": "{ (fixit)"}, {"location": {"col": 39, "file": 23, "line": 2617}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/src/lib-storage/mail-storage.c", "reportHash": "15a6fa23289b3707de65c97a467235ec", "checkerName": "google-readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 37, "file": 23, "line": 2672}, "message": "{ (fixit)"}, {"location": {"col": 22, "file": 23, "line": 2672}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/src/lib-storage/mail-storage.c", "reportHash": "b06c12b5eae9ff25bc786b67a9297b03", "checkerName": "hicpp-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 37, "file": 23, "line": 2737}, "message": "{ (fixit)"}, {"location": {"col": 22, "file": 23, "line": 2737}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/src/lib-storage/mail-storage.c", "reportHash": "54ff4c93b4c376a3142634478e394b34", "checkerName": "google-readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 56, "file": 23, "line": 2769}, "message": "{ (fixit)"}, {"location": {"col": 48, "file": 23, "line": 2769}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/src/lib-storage/mail-storage.c", "reportHash": "2a32f067e0277079bf86c02950e8ca97", "checkerName": "google-readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 62, "file": 23, "line": 2816}, "message": "{ (fixit)"}, {"location": {"col": 54, "file": 23, "line": 2816}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/src/lib-storage/mail-storage.c", "reportHash": "7a58c2cc8cb5d34b9065fac0c6ca2eed", "checkerName": "google-readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 53, "file": 23, "line": 2824}, "message": "{ (fixit)"}, {"location": {"col": 45, "file": 23, "line": 2824}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/src/lib-storage/mail-storage.c", "reportHash": "29a2f43d8fd0ab4f4c8583acfdecd112", "checkerName": "google-readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 51, "file": 23, "line": 2826}, "message": "{ (fixit)"}, {"location": {"col": 43, "file": 23, "line": 2826}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/src/lib-storage/mail-storage.c", "reportHash": "dfd502141f5280c92b418bb14bdf91dc", "checkerName": "google-readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 47, "file": 23, "line": 2847}, "message": "{ (fixit)"}, {"location": {"col": 39, "file": 23, "line": 2847}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/src/lib-storage/mail-storage.c", "reportHash": "f6cf9daab6adbde5f8ec56f6f4d00f24", "checkerName": "hicpp-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 38, "file": 25, "line": 246}, "message": "expanded from macro 'i_zero'"}, {"location": {"col": 2, "file": 23, "line": 2880}, "message": "suspicious usage of 'sizeof(A*)'; pointer to aggregate"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/src/lib-storage/mail-storage.c", "reportHash": "9aaae22d9bcd1a5a3d84d510c3683f34", "checkerName": "misc-sizeof-expression", "reviewStatus": null, "severity": "HIGH"}, {"events": [{"location": {"col": 21, "file": 25, "line": 208}, "message": "expanded from macro 'i_assert'"}, {"location": {"col": 45, "file": 25, "line": 189}, "message": "expanded from macro 'unlikely'"}, {"location": {"col": 12, "file": 23, "line": 2891}, "message": "use of a signed integer operand with a binary bitwise operator"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/src/lib-storage/mail-storage.c", "reportHash": "4de8926dac4cd26beec2020ec264ecbd", "checkerName": "hicpp-signed-bitwise", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 69, "file": 23, "line": 2952}, "message": "{ (fixit)"}, {"location": {"col": 40, "file": 23, "line": 2952}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/src/lib-storage/mail-storage.c", "reportHash": "67a45af158faca2e17b4c4764d0d4d75", "checkerName": "google-readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 2, "file": 23, "line": 2954}, "message": "do not use 'else' after 'return'"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/src/lib-storage/mail-storage.c", "reportHash": "55252e00d3d5b87af5463dbc45d9181e", "checkerName": "readability-else-after-return", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 35, "file": 23, "line": 2954}, "message": "{ (fixit)"}, {"location": {"col": 27, "file": 23, "line": 2954}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/src/lib-storage/mail-storage.c", "reportHash": "10efd4447d4123dd9e2cff0218a6b55f", "checkerName": "google-readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 64, "file": 23, "line": 2975}, "message": "{ (fixit)"}, {"location": {"col": 56, "file": 23, "line": 2975}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/src/lib-storage/mail-storage.c", "reportHash": "9745c383d05631c9ca25fc46300005a5", "checkerName": "google-readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 49, "file": 23, "line": 2978}, "message": "{ (fixit)"}, {"location": {"col": 20, "file": 23, "line": 2978}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/src/lib-storage/mail-storage.c", "reportHash": "fe99f98693401af7697b8306f82b618e", "checkerName": "google-readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 14, "file": 23, "line": 2982}, "message": "use of a signed integer operand with a binary bitwise operator"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/src/lib-storage/mail-storage.c", "reportHash": "d10956ef7ba7ef35ecf99c363edba34f", "checkerName": "hicpp-signed-bitwise", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 34, "file": 23, "line": 2994}, "message": "{ (fixit)"}, {"location": {"col": 26, "file": 23, "line": 2994}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/src/lib-storage/mail-storage.c", "reportHash": "4dd3a6d67aaeb97f80d1d9e34e740ebd", "checkerName": "google-readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 7, "file": 23, "line": 2997}, "message": "use of a signed integer operand with a binary bitwise operator"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/src/lib-storage/mail-storage.c", "reportHash": "7b485ff87d65681bbe68911008aaf25d", "checkerName": "hicpp-signed-bitwise", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 32, "file": 23, "line": 3023}, "message": "{ (fixit)"}, {"location": {"col": 24, "file": 23, "line": 3023}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/src/lib-storage/mail-storage.c", "reportHash": "2a8e06a2d6e79231995a108d10b7fc34", "checkerName": "google-readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 36, "file": 23, "line": 3026}, "message": "{ (fixit)"}, {"location": {"col": 28, "file": 23, "line": 3026}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/src/lib-storage/mail-storage.c", "reportHash": "917c0f69206d12841781d35ce0bf0743", "checkerName": "google-readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 34, "file": 23, "line": 3028}, "message": "{ (fixit)"}, {"location": {"col": 26, "file": 23, "line": 3028}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/src/lib-storage/mail-storage.c", "reportHash": "687e67a3453a8ed75885d6b1fb9742e3", "checkerName": "google-readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 38, "file": 25, "line": 246}, "message": "expanded from macro 'i_zero'"}, {"location": {"col": 3, "file": 23, "line": 3045}, "message": "suspicious usage of 'sizeof(A*)'; pointer to aggregate"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/src/lib-storage/mail-storage.c", "reportHash": "4c16142e5642b64ebd343d6e313a490c", "checkerName": "misc-sizeof-expression", "reviewStatus": null, "severity": "HIGH"}, {"events": [{"location": {"col": 4, "file": 23, "line": 3053}, "message": "do not use 'else' after 'return'"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/src/lib-storage/mail-storage.c", "reportHash": "e9243288dbce023da0f378aabaa57510", "checkerName": "readability-else-after-return", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 64, "file": 23, "line": 3126}, "message": "{ (fixit)"}, {"location": {"col": 56, "file": 23, "line": 3126}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/src/lib-storage/mail-storage.c", "reportHash": "118e7bf59f9345611734b5a6503fca90", "checkerName": "google-readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 38, "file": 25, "line": 246}, "message": "expanded from macro 'i_zero'"}, {"location": {"col": 2, "file": 23, "line": 3149}, "message": "suspicious usage of 'sizeof(A*)'; pointer to aggregate"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/src/lib-storage/mail-storage.c", "reportHash": "c4c4e57111f418e7ae2c1ef6a76f44f7", "checkerName": "misc-sizeof-expression", "reviewStatus": null, "severity": "HIGH"}, {"events": [{"location": {"col": 50, "file": 23, "line": 3157}, "message": "{ (fixit)"}, {"location": {"col": 42, "file": 23, "line": 3157}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/src/lib-storage/mail-storage.c", "reportHash": "9a9fbe4d58ddb36b5351962ec1674497", "checkerName": "google-readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 47, "file": 26, "line": 471}, "message": "_storage (fixit)"}, {"location": {"col": 6, "file": 23, "line": 459}, "message": "the definition seen here"}, {"location": {"col": 6, "file": 26, "line": 471}, "message": "differing parameters are named here: ('storage'), in definition: ('_storage')"}, {"location": {"col": 6, "file": 26, "line": 471}, "message": "function 'mail_storage_unref' has a definition with different parameter names"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/src/lib-storage/mail-storage.h", "reportHash": "5472fd293ecdc4e2ebcd41ec9b56b95a", "checkerName": "readability-inconsistent-declaration-parameter-name", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 36, "file": 26, "line": 548}, "message": "_box (fixit)"}, {"location": {"col": 6, "file": 23, "line": 1625}, "message": "the definition seen here"}, {"location": {"col": 6, "file": 26, "line": 548}, "message": "differing parameters are named here: ('box'), in definition: ('_box')"}, {"location": {"col": 6, "file": 26, "line": 548}, "message": "function 'mailbox_free' has a definition with different parameter names"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/src/lib-storage/mail-storage.h", "reportHash": "6a63ce2b67f3f0c99362b41b16918017", "checkerName": "readability-inconsistent-declaration-parameter-name", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 55, "file": 26, "line": 652}, "message": "_ctx (fixit)"}, {"location": {"col": 5, "file": 23, "line": 2177}, "message": "the definition seen here"}, {"location": {"col": 5, "file": 26, "line": 652}, "message": "differing parameters are named here: ('ctx'), in definition: ('_ctx')"}, {"location": {"col": 5, "file": 26, "line": 652}, "message": "function 'mailbox_sync_deinit' has a definition with different parameter names"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/src/lib-storage/mail-storage.h", "reportHash": "2812da23c54622e8caaf1843d94a4d98", "checkerName": "readability-inconsistent-declaration-parameter-name", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 5, "file": 23, "line": 2371}, "message": "the definition seen here"}, {"location": {"col": 5, "file": 26, "line": 673}, "message": "differing parameters are named here: ('t'), in definition: ('_t')"}, {"location": {"col": 5, "file": 26, "line": 673}, "message": "function 'mailbox_transaction_commit_get_changes' has a definition with different parameter names"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/src/lib-storage/mail-storage.h", "reportHash": "5e613aa6337cf805ae7700bc3393c65e", "checkerName": "readability-inconsistent-declaration-parameter-name", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 72, "file": 26, "line": 676}, "message": "_t (fixit)"}, {"location": {"col": 6, "file": 23, "line": 2402}, "message": "the definition seen here"}, {"location": {"col": 6, "file": 26, "line": 676}, "message": "differing parameters are named here: ('t'), in definition: ('_t')"}, {"location": {"col": 6, "file": 26, "line": 676}, "message": "function 'mailbox_transaction_rollback' has a definition with different parameter names"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/src/lib-storage/mail-storage.h", "reportHash": "0cd3e17d338b18ed5bf92d3fabb0b31a", "checkerName": "readability-inconsistent-declaration-parameter-name", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 56, "file": 26, "line": 730}, "message": "_ctx (fixit)"}, {"location": {"col": 5, "file": 23, "line": 2262}, "message": "the definition seen here"}, {"location": {"col": 5, "file": 26, "line": 730}, "message": "differing parameters are named here: ('ctx'), in definition: ('_ctx')"}, {"location": {"col": 5, "file": 26, "line": 730}, "message": "function 'mailbox_search_deinit' has a definition with different parameter names"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/src/lib-storage/mail-storage.h", "reportHash": "bee4788e785881be854237c88f89bab5", "checkerName": "readability-inconsistent-declaration-parameter-name", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 52, "file": 26, "line": 840}, "message": "_ctx (fixit)"}, {"location": {"col": 5, "file": 23, "line": 2644}, "message": "the definition seen here"}, {"location": {"col": 5, "file": 26, "line": 840}, "message": "differing parameters are named here: ('ctx'), in definition: ('_ctx')"}, {"location": {"col": 5, "file": 26, "line": 840}, "message": "function 'mailbox_save_finish' has a definition with different parameter names"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/src/lib-storage/mail-storage.h", "reportHash": "3e90926e8fb9ba52a303bc38b40a6990", "checkerName": "readability-inconsistent-declaration-parameter-name", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 53, "file": 26, "line": 841}, "message": "_ctx (fixit)"}, {"location": {"col": 6, "file": 23, "line": 2681}, "message": "the definition seen here"}, {"location": {"col": 6, "file": 26, "line": 841}, "message": "differing parameters are named here: ('ctx'), in definition: ('_ctx')"}, {"location": {"col": 6, "file": 26, "line": 841}, "message": "function 'mailbox_save_cancel' has a definition with different parameter names"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/src/lib-storage/mail-storage.h", "reportHash": "e7842c9cef7d3fcb2ef5f2b6a3613d73", "checkerName": "readability-inconsistent-declaration-parameter-name", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 45, "file": 26, "line": 848}, "message": "_ctx (fixit)"}, {"location": {"col": 5, "file": 23, "line": 2750}, "message": "the definition seen here"}, {"location": {"col": 5, "file": 26, "line": 848}, "message": "differing parameters are named here: ('ctx'), in definition: ('_ctx')"}, {"location": {"col": 5, "file": 26, "line": 848}, "message": "function 'mailbox_copy' has a definition with different parameter names"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/src/lib-storage/mail-storage.h", "reportHash": "d989ff37351ffe1e3b8ba8163b3c2cc4", "checkerName": "readability-inconsistent-declaration-parameter-name", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 45, "file": 26, "line": 851}, "message": "_ctx (fixit)"}, {"location": {"col": 5, "file": 23, "line": 2760}, "message": "the definition seen here"}, {"location": {"col": 5, "file": 26, "line": 851}, "message": "differing parameters are named here: ('ctx'), in definition: ('_ctx')"}, {"location": {"col": 5, "file": 26, "line": 851}, "message": "function 'mailbox_move' has a definition with different parameter names"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/src/lib-storage/mail-storage.h", "reportHash": "3d23568de0849efb6b9d77123dd4d071", "checkerName": "readability-inconsistent-declaration-parameter-name", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 56, "file": 26, "line": 855}, "message": "_ctx (fixit)"}, {"location": {"col": 5, "file": 23, "line": 2775}, "message": "the definition seen here"}, {"location": {"col": 5, "file": 26, "line": 855}, "message": "differing parameters are named here: ('ctx'), in definition: ('_ctx')"}, {"location": {"col": 5, "file": 26, "line": 855}, "message": "function 'mailbox_save_using_mail' has a definition with different parameter names"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/src/lib-storage/mail-storage.h", "reportHash": "f3dd472880eac34c5e24a3f0e17a7bbd", "checkerName": "readability-inconsistent-declaration-parameter-name", "reviewStatus": null, "severity": "STYLE"}]};
      window.onload = function() {
        if (!browserCompatible) {
          setNonCompatibleBrowserMessage();
        } else {
          BugViewer.init(data.files, data.reports);
          BugViewer.create();
          BugViewer.initByUrl();
        }
      };
    </script>
  </head>
  <body>
  <div class="container">
    <div id="content">
      <div id="side-bar">
        <div class="header">
          <a href="index.html" class="button">&#8249; Return to List</a>
        </div>
        <div id="report-nav">
          <div class="header">Reports</div>
        </div>
      </div>
      <div id="editor-wrapper">
        <div class="header">
          <div id="file">
            <span class="label">File:</span>
            <span id="file-path"></span>
          </div>
          <div id="checker">
            <span class="label">Checker name:</span>
            <span id="checker-name"></span>
          </div>
          <div id="review-status-wrapper">
            <span class="label">Review status:</span>
            <span id="review-status"></span>
          </div>
        </div>
        <div id="editor"></div>
      </div>
    </div>
  </div>
  </body>
</html>
