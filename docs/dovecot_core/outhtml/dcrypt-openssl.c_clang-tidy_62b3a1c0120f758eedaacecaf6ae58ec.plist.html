<!DOCTYPE html>
<html>
  <head>
    <title>Plist HTML Viewer</title>

    <meta charset="UTF-8">

    <style type="text/css">
      .CodeMirror{font-family:monospace;height:300px;color:#000;direction:ltr}.CodeMirror-lines{padding:4px 0}.CodeMirror pre{padding:0 4px}.CodeMirror-gutter-filler,.CodeMirror-scrollbar-filler{background-color:#fff}.CodeMirror-gutters{border-right:1px solid #ddd;background-color:#f7f7f7;white-space:nowrap}.CodeMirror-linenumber{padding:0 3px 0 5px;min-width:20px;text-align:right;color:#999;white-space:nowrap}.CodeMirror-guttermarker{color:#000}.CodeMirror-guttermarker-subtle{color:#999}.CodeMirror-cursor{border-left:1px solid #000;border-right:none;width:0}.CodeMirror div.CodeMirror-secondarycursor{border-left:1px solid silver}.cm-fat-cursor .CodeMirror-cursor{width:auto;border:0!important;background:#7e7}.cm-fat-cursor div.CodeMirror-cursors{z-index:1}.cm-animate-fat-cursor{width:auto;border:0;-webkit-animation:blink 1.06s steps(1) infinite;-moz-animation:blink 1.06s steps(1) infinite;animation:blink 1.06s steps(1) infinite;background-color:#7e7}@-moz-keyframes blink{50%{background-color:transparent}}@-webkit-keyframes blink{50%{background-color:transparent}}@keyframes blink{50%{background-color:transparent}}.cm-tab{display:inline-block;text-decoration:inherit}.CodeMirror-rulers{position:absolute;left:0;right:0;top:-50px;bottom:-20px;overflow:hidden}.CodeMirror-ruler{border-left:1px solid #ccc;top:0;bottom:0;position:absolute}.cm-s-default .cm-header{color:#00f}.cm-s-default .cm-quote{color:#090}.cm-negative{color:#d44}.cm-positive{color:#292}.cm-header,.cm-strong{font-weight:700}.cm-em{font-style:italic}.cm-link{text-decoration:underline}.cm-strikethrough{text-decoration:line-through}.cm-s-default .cm-keyword{color:#708}.cm-s-default .cm-atom{color:#219}.cm-s-default .cm-number{color:#164}.cm-s-default .cm-def{color:#00f}.cm-s-default .cm-variable-2{color:#05a}.cm-s-default .cm-type,.cm-s-default .cm-variable-3{color:#085}.cm-s-default .cm-comment{color:#a50}.cm-s-default .cm-string{color:#a11}.cm-s-default .cm-string-2{color:#f50}.cm-s-default .cm-meta{color:#555}.cm-s-default .cm-qualifier{color:#555}.cm-s-default .cm-builtin{color:#30a}.cm-s-default .cm-bracket{color:#997}.cm-s-default .cm-tag{color:#170}.cm-s-default .cm-attribute{color:#00c}.cm-s-default .cm-hr{color:#999}.cm-s-default .cm-link{color:#00c}.cm-s-default .cm-error{color:red}.cm-invalidchar{color:red}.CodeMirror-composing{border-bottom:2px solid}div.CodeMirror span.CodeMirror-matchingbracket{color:#0f0}div.CodeMirror span.CodeMirror-nonmatchingbracket{color:#f22}.CodeMirror-matchingtag{background:rgba(255,150,0,.3)}.CodeMirror-activeline-background{background:#e8f2ff}.CodeMirror{position:relative;overflow:hidden;background:#fff}.CodeMirror-scroll{overflow:scroll!important;margin-bottom:-30px;margin-right:-30px;padding-bottom:30px;height:100%;outline:0;position:relative}.CodeMirror-sizer{position:relative;border-right:30px solid transparent}.CodeMirror-gutter-filler,.CodeMirror-hscrollbar,.CodeMirror-scrollbar-filler,.CodeMirror-vscrollbar{position:absolute;z-index:6;display:none}.CodeMirror-vscrollbar{right:0;top:0;overflow-x:hidden;overflow-y:scroll}.CodeMirror-hscrollbar{bottom:0;left:0;overflow-y:hidden;overflow-x:scroll}.CodeMirror-scrollbar-filler{right:0;bottom:0}.CodeMirror-gutter-filler{left:0;bottom:0}.CodeMirror-gutters{position:absolute;left:0;top:0;min-height:100%;z-index:3}.CodeMirror-gutter{white-space:normal;height:100%;display:inline-block;vertical-align:top;margin-bottom:-30px}.CodeMirror-gutter-wrapper{position:absolute;z-index:4;background:0 0!important;border:none!important}.CodeMirror-gutter-background{position:absolute;top:0;bottom:0;z-index:4}.CodeMirror-gutter-elt{position:absolute;cursor:default;z-index:4}.CodeMirror-gutter-wrapper ::selection{background-color:transparent}.CodeMirror-gutter-wrapper ::-moz-selection{background-color:transparent}.CodeMirror-lines{cursor:text;min-height:1px}.CodeMirror pre{-moz-border-radius:0;-webkit-border-radius:0;border-radius:0;border-width:0;background:0 0;font-family:inherit;font-size:inherit;margin:0;white-space:pre;word-wrap:normal;line-height:inherit;color:inherit;z-index:2;position:relative;overflow:visible;-webkit-tap-highlight-color:transparent;-webkit-font-variant-ligatures:contextual;font-variant-ligatures:contextual}.CodeMirror-wrap pre{word-wrap:break-word;white-space:pre-wrap;word-break:normal}.CodeMirror-linebackground{position:absolute;left:0;right:0;top:0;bottom:0;z-index:0}.CodeMirror-linewidget{position:relative;z-index:2;overflow:auto}.CodeMirror-rtl pre{direction:rtl}.CodeMirror-code{outline:0}.CodeMirror-gutter,.CodeMirror-gutters,.CodeMirror-linenumber,.CodeMirror-scroll,.CodeMirror-sizer{-moz-box-sizing:content-box;box-sizing:content-box}.CodeMirror-measure{position:absolute;width:100%;height:0;overflow:hidden;visibility:hidden}.CodeMirror-cursor{position:absolute;pointer-events:none}.CodeMirror-measure pre{position:static}div.CodeMirror-cursors{visibility:hidden;position:relative;z-index:3}div.CodeMirror-dragcursors{visibility:visible}.CodeMirror-focused div.CodeMirror-cursors{visibility:visible}.CodeMirror-selected{background:#d9d9d9}.CodeMirror-focused .CodeMirror-selected{background:#d7d4f0}.CodeMirror-crosshair{cursor:crosshair}.CodeMirror-line::selection,.CodeMirror-line>span::selection,.CodeMirror-line>span>span::selection{background:#d7d4f0}.CodeMirror-line::-moz-selection,.CodeMirror-line>span::-moz-selection,.CodeMirror-line>span>span::-moz-selection{background:#d7d4f0}.cm-searching{background-color:#ffa;background-color:rgba(255,255,0,.4)}.cm-force-border{padding-right:.1px}@media print{.CodeMirror div.CodeMirror-cursors{visibility:hidden}}.cm-tab-wrap-hack:after{content:''}span.CodeMirror-selectedtext{background:0 0}
/*# sourceMappingURL=codemirror.min.css.map */

      .severity-low {
  background-color: #669603;
}

.severity-low:after {
  content : 'L';
}

.severity-unspecified {
  background-color: #666666;
}

.severity-unspecified:after {
  content : 'U';
}

.severity-style {
  background-color: #9932cc;
}

.severity-style:after {
  content : 'S';
}

.severity-medium {
  background-color: #a9d323;
  color: black;
}

.severity-medium:after {
  content : 'M';
}

.severity-high {
  background-color: #ffa800;
}

.severity-high:after {
  content : 'H';
}

.severity-critical {
  background-color: #e92625;
}

.severity-critical:after {
  content : 'C';
}

i[class*="severity-"] {
  line-height: normal;
  text-transform: capitalize;
  font-size: 0.8em;
  font-weight: bold;
  color: white;
  display: inline-block;
  width: 16px;
  height: 16px;
  text-align: center;
  font-family: sans-serif;
}

      html, body {
  width: 100%;
  height: 100%;
  padding: 0px;
  margin: 0px;
}

div.container {
  padding: 10px;
}

#content {
  height: 100%;
  display: block;
  overflow: hidden;
}

#content > div {
  margin: 10px;
  overflow: hidden;
  border: 1px solid #ddd;
  border-radius: 3px;
  overflow: hidden;
  height: 97%;
}

.button {
  background-color: #f1f1f1;
  text-decoration: none;
  display: inline-block;
  padding: 8px 16px;
  color: black;
  cursor: pointer;
}

.button:hover {
  background-color: #ddd;
  color: black;
}

.review-status {
  color: white;
  text-align: center;
}

.review-status-confirmed {
  background-color: #e92625;
}

.review-status-false-positive {
  background-color: grey;
}

.review-status-intentional {
  background-color: #669603;
}

      div.container {
  width: 100%;
  height: 100%;
  padding: 0px;
}

#editor-wrapper {
  margin: 10px;
}

#side-bar {
  float: left;
  width: 260px;
  margin: 0px;
}

#report-nav ul {
  list-style-type: none;
  padding: 0;
  margin: 0;
  overflow-y: auto;
  height: 100%;
}

#report-nav ul > li {
  padding: .4em;
  background-color: #fff;
  border-bottom: 1px solid rgba(0,0,0,.125);
  text-align: left;
  overflow: hidden;
  white-space: nowrap;
  text-overflow: ellipsis;
}

#report-nav ul > li.active {
  background-color: #427ea9;
  color: white;
}

#report-nav ul > li:hover {
  background-color: #427ea9;
  color: white;
  cursor: pointer;
}

#report-nav ul a {
  text-decoration: none;
}

#report-nav i[class*="severity-"] {
  margin-right: 5px;
}

.header {
  border-bottom: 1px solid lightgrey;
  font-family: monospace;
  padding: 10px;
  background-color: #fafbfc;
  border-bottom: 1px solid #e1e4e8;
  border-top-left-radius: 2px;
  border-top-right-radius: 2px;
}

#report-nav .header {
  font-weight: bold;
}

#editor-wrapper .header > div {
  padding-top: 2px;
}

#file-path,
#checker-name {
  color: #195ea2;
}

#review-status {
  padding: 0px 5px;
}

#file-path {
  font-family: monospace;
}

.check-msg {
  display: inline-block;
  padding: 3px 6px;
  margin: 1px;
  -webkit-border-radius: 5px;
  -moz-border-radius: 5px;
  border-radius: 5px;
}

.check-msg.info {
  color: #00546f;
  background-color: #bfdfe9;
  border: 1px solid #87a8b3;
}

.check-msg.error {
  background-color: #f2dede;
  color: #a94442;
  border: 1px solid #ebcccc;
}

.check-msg.macro {
  background-color: #d7dac2;
  color: #4f5c6d;
  border: 1px solid #d7dac2;
}

.check-msg.note {
  background-color: #d7d7d7;
  color: #4f5c6d;
  border: 1px solid #bfbfbf;
}

.check-msg.current {
  border: 2px dashed #3692ff;
}

.check-msg .tag {
  padding: 1px 5px;
  text-align: center;
  border-radius: 2px;
  margin-right: 5px;
  text-decoration: inherit;
}

.check-msg .tag.macro {
  background-color: #83876a;
  color: white;
  text-transform: capitalize;
}

.check-msg .tag.note {
  background-color: #9299a1;
  color: white;
  text-transform: capitalize;
}

.checker-enum {
  color: white;
  padding: 1px 5px;
  text-align: center;
  border-radius: 25px;
  margin-right: 5px;
  text-decoration: inherit;
}

.checker-enum.info {
  background-color: #427ea9;
}

.checker-enum.error {
  background-color: #a94442;
}

.arrow {
  border: solid black;
  border-width: 0 3px 3px 0;
  display: inline-block;
  padding: 3px;
  cursor: pointer;
  margin: 0px 5px;
}

.arrow:hover {
  border: solid #437ea8;
  border-width: 0 3px 3px 0;
}

.left-arrow {
  transform: rotate(135deg);
  -webkit-transform: rotate(135deg);
}

.right-arrow {
  transform: rotate(-45deg);
  -webkit-transform: rotate(-45deg);
}

    </style>

    <script type="text/javascript">
      function setNonCompatibleBrowserMessage() {
  document.body.innerHTML =
    '<h2 style="margin-left: 20px;">Your browser is not compatible with CodeChecker Viewer!</h2> \
     <p style="margin-left: 20px;">The version required for the following browsers are:</p> \
     <ul style="margin-left: 20px;"> \
     <li>Internet Explorer: version 9 or newer</li> \
     <li>Firefox: version 22.0 or newer</li> \
     </ul>';
}

// http://stackoverflow.com/questions/5916900/how-can-you-detect-the-version-of-a-browser
var browserVersion = (function(){
  var ua = navigator.userAgent, tem,
    M = ua.match(/(opera|chrome|safari|firefox|msie|trident(?=\/))\/?\s*(\d+)/i) || [];

  if (/trident/i.test(M[1])) {
    tem = /\brv[ :]+(\d+)/g.exec(ua) || [];
    return 'IE ' + (tem[1] || '');
  }

  if (M[1] === 'Chrome') {
    tem = ua.match(/\b(OPR|Edge)\/(\d+)/);
    if (tem != null) return tem.slice(1).join(' ').replace('OPR', 'Opera');
  }

  M = M[2] ? [M[1], M[2]] : [navigator.appName, navigator.appVersion, '-?'];
  if ((tem = ua.match(/version\/(\d+)/i)) != null) M.splice(1, 1, tem[1]);
    return M.join(' ');
})();

var pos = browserVersion.indexOf(' ');
var browser = browserVersion.substr(0, pos);
var version = parseInt(browserVersion.substr(pos + 1));

var browserCompatible
  = browser === 'Firefox'
  ? version >= 22
  : browser === 'IE'
  ? version >= 9
  : true;


      /* MIT License

Copyright (C) 2017 by Marijn Haverbeke <marijnh@gmail.com> and others

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
THE SOFTWARE.
 */
      !function(e,t){"object"==typeof exports&&"undefined"!=typeof module?module.exports=t():"function"==typeof define&&define.amd?define(t):e.CodeMirror=t()}(this,function(){"use strict";function e(e){return new RegExp("(^|\\s)"+e+"(?:$|\\s)\\s*")}function t(e){for(var t=e.childNodes.length;t>0;--t)e.removeChild(e.firstChild);return e}function r(e,r){return t(e).appendChild(r)}function n(e,t,r,n){var i=document.createElement(e);if(r&&(i.className=r),n&&(i.style.cssText=n),"string"==typeof t)i.appendChild(document.createTextNode(t));else if(t)for(var o=0;o<t.length;++o)i.appendChild(t[o]);return i}function i(e,t,r,i){var o=n(e,t,r,i);return o.setAttribute("role","presentation"),o}function o(e,t){if(3==t.nodeType&&(t=t.parentNode),e.contains)return e.contains(t);do{if(11==t.nodeType&&(t=t.host),t==e)return!0}while(t=t.parentNode)}function l(){var e;try{e=document.activeElement}catch(t){e=document.body||null}for(;e&&e.shadowRoot&&e.shadowRoot.activeElement;)e=e.shadowRoot.activeElement;return e}function s(t,r){var n=t.className;e(r).test(n)||(t.className+=(n?" ":"")+r)}function a(t,r){for(var n=t.split(" "),i=0;i<n.length;i++)n[i]&&!e(n[i]).test(r)&&(r+=" "+n[i]);return r}function u(e){var t=Array.prototype.slice.call(arguments,1);return function(){return e.apply(null,t)}}function c(e,t,r){t||(t={});for(var n in e)!e.hasOwnProperty(n)||!1===r&&t.hasOwnProperty(n)||(t[n]=e[n]);return t}function f(e,t,r,n,i){null==t&&-1==(t=e.search(/[^\s\u00a0]/))&&(t=e.length);for(var o=n||0,l=i||0;;){var s=e.indexOf("\t",o);if(s<0||s>=t)return l+(t-o);l+=s-o,l+=r-l%r,o=s+1}}function h(e,t){for(var r=0;r<e.length;++r)if(e[r]==t)return r;return-1}function d(e,t,r){for(var n=0,i=0;;){var o=e.indexOf("\t",n);-1==o&&(o=e.length);var l=o-n;if(o==e.length||i+l>=t)return n+Math.min(l,t-i);if(i+=o-n,i+=r-i%r,n=o+1,i>=t)return n}}function p(e){for(;Kl.length<=e;)Kl.push(g(Kl)+" ");return Kl[e]}function g(e){return e[e.length-1]}function v(e,t){for(var r=[],n=0;n<e.length;n++)r[n]=t(e[n],n);return r}function m(e,t,r){for(var n=0,i=r(t);n<e.length&&r(e[n])<=i;)n++;e.splice(n,0,t)}function y(){}function b(e,t){var r;return Object.create?r=Object.create(e):(y.prototype=e,r=new y),t&&c(t,r),r}function w(e){return/\w/.test(e)||e>""&&(e.toUpperCase()!=e.toLowerCase()||jl.test(e))}function x(e,t){return t?!!(t.source.indexOf("\\w")>-1&&w(e))||t.test(e):w(e)}function C(e){for(var t in e)if(e.hasOwnProperty(t)&&e[t])return!1;return!0}function S(e){return e.charCodeAt(0)>=768&&Xl.test(e)}function L(e,t,r){for(;(r<0?t>0:t<e.length)&&S(e.charAt(t));)t+=r;return t}function k(e,t,r){for(var n=t>r?-1:1;;){if(t==r)return t;var i=(t+r)/2,o=n<0?Math.ceil(i):Math.floor(i);if(o==t)return e(o)?t:r;e(o)?r=o:t=o+n}}function T(e,t,r){var o=this;this.input=r,o.scrollbarFiller=n("div",null,"CodeMirror-scrollbar-filler"),o.scrollbarFiller.setAttribute("cm-not-content","true"),o.gutterFiller=n("div",null,"CodeMirror-gutter-filler"),o.gutterFiller.setAttribute("cm-not-content","true"),o.lineDiv=i("div",null,"CodeMirror-code"),o.selectionDiv=n("div",null,null,"position: relative; z-index: 1"),o.cursorDiv=n("div",null,"CodeMirror-cursors"),o.measure=n("div",null,"CodeMirror-measure"),o.lineMeasure=n("div",null,"CodeMirror-measure"),o.lineSpace=i("div",[o.measure,o.lineMeasure,o.selectionDiv,o.cursorDiv,o.lineDiv],null,"position: relative; outline: none");var l=i("div",[o.lineSpace],"CodeMirror-lines");o.mover=n("div",[l],null,"position: relative"),o.sizer=n("div",[o.mover],"CodeMirror-sizer"),o.sizerWidth=null,o.heightForcer=n("div",null,null,"position: absolute; height: "+Rl+"px; width: 1px;"),o.gutters=n("div",null,"CodeMirror-gutters"),o.lineGutter=null,o.scroller=n("div",[o.sizer,o.heightForcer,o.gutters],"CodeMirror-scroll"),o.scroller.setAttribute("tabIndex","-1"),o.wrapper=n("div",[o.scrollbarFiller,o.gutterFiller,o.scroller],"CodeMirror"),gl&&vl<8&&(o.gutters.style.zIndex=-1,o.scroller.style.paddingRight=0),ml||fl&&Tl||(o.scroller.draggable=!0),e&&(e.appendChild?e.appendChild(o.wrapper):e(o.wrapper)),o.viewFrom=o.viewTo=t.first,o.reportedViewFrom=o.reportedViewTo=t.first,o.view=[],o.renderedView=null,o.externalMeasured=null,o.viewOffset=0,o.lastWrapHeight=o.lastWrapWidth=0,o.updateLineNumbers=null,o.nativeBarWidth=o.barHeight=o.barWidth=0,o.scrollbarsClipped=!1,o.lineNumWidth=o.lineNumInnerWidth=o.lineNumChars=null,o.alignWidgets=!1,o.cachedCharWidth=o.cachedTextHeight=o.cachedPaddingH=null,o.maxLine=null,o.maxLineLength=0,o.maxLineChanged=!1,o.wheelDX=o.wheelDY=o.wheelStartX=o.wheelStartY=null,o.shift=!1,o.selForContextMenu=null,o.activeTouch=null,r.init(o)}function M(e,t){if((t-=e.first)<0||t>=e.size)throw new Error("There is no line "+(t+e.first)+" in the document.");for(var r=e;!r.lines;)for(var n=0;;++n){var i=r.children[n],o=i.chunkSize();if(t<o){r=i;break}t-=o}return r.lines[t]}function N(e,t,r){var n=[],i=t.line;return e.iter(t.line,r.line+1,function(e){var o=e.text;i==r.line&&(o=o.slice(0,r.ch)),i==t.line&&(o=o.slice(t.ch)),n.push(o),++i}),n}function O(e,t,r){var n=[];return e.iter(t,r,function(e){n.push(e.text)}),n}function A(e,t){var r=t-e.height;if(r)for(var n=e;n;n=n.parent)n.height+=r}function W(e){if(null==e.parent)return null;for(var t=e.parent,r=h(t.lines,e),n=t.parent;n;t=n,n=n.parent)for(var i=0;n.children[i]!=t;++i)r+=n.children[i].chunkSize();return r+t.first}function D(e,t){var r=e.first;e:do{for(var n=0;n<e.children.length;++n){var i=e.children[n],o=i.height;if(t<o){e=i;continue e}t-=o,r+=i.chunkSize()}return r}while(!e.lines);for(var l=0;l<e.lines.length;++l){var s=e.lines[l].height;if(t<s)break;t-=s}return r+l}function H(e,t){return t>=e.first&&t<e.first+e.size}function F(e,t){return String(e.lineNumberFormatter(t+e.firstLineNumber))}function E(e,t,r){if(void 0===r&&(r=null),!(this instanceof E))return new E(e,t,r);this.line=e,this.ch=t,this.sticky=r}function P(e,t){return e.line-t.line||e.ch-t.ch}function I(e,t){return e.sticky==t.sticky&&0==P(e,t)}function z(e){return E(e.line,e.ch)}function R(e,t){return P(e,t)<0?t:e}function B(e,t){return P(e,t)<0?e:t}function G(e,t){return Math.max(e.first,Math.min(t,e.first+e.size-1))}function U(e,t){if(t.line<e.first)return E(e.first,0);var r=e.first+e.size-1;return t.line>r?E(r,M(e,r).text.length):V(t,M(e,t.line).text.length)}function V(e,t){var r=e.ch;return null==r||r>t?E(e.line,t):r<0?E(e.line,0):e}function K(e,t){for(var r=[],n=0;n<t.length;n++)r[n]=U(e,t[n]);return r}function j(){Yl=!0}function X(){_l=!0}function Y(e,t,r){this.marker=e,this.from=t,this.to=r}function _(e,t){if(e)for(var r=0;r<e.length;++r){var n=e[r];if(n.marker==t)return n}}function $(e,t){for(var r,n=0;n<e.length;++n)e[n]!=t&&(r||(r=[])).push(e[n]);return r}function q(e,t){e.markedSpans=e.markedSpans?e.markedSpans.concat([t]):[t],t.marker.attachLine(e)}function Z(e,t,r){var n;if(e)for(var i=0;i<e.length;++i){var o=e[i],l=o.marker;if(null==o.from||(l.inclusiveLeft?o.from<=t:o.from<t)||o.from==t&&"bookmark"==l.type&&(!r||!o.marker.insertLeft)){var s=null==o.to||(l.inclusiveRight?o.to>=t:o.to>t);(n||(n=[])).push(new Y(l,o.from,s?null:o.to))}}return n}function Q(e,t,r){var n;if(e)for(var i=0;i<e.length;++i){var o=e[i],l=o.marker;if(null==o.to||(l.inclusiveRight?o.to>=t:o.to>t)||o.from==t&&"bookmark"==l.type&&(!r||o.marker.insertLeft)){var s=null==o.from||(l.inclusiveLeft?o.from<=t:o.from<t);(n||(n=[])).push(new Y(l,s?null:o.from-t,null==o.to?null:o.to-t))}}return n}function J(e,t){if(t.full)return null;var r=H(e,t.from.line)&&M(e,t.from.line).markedSpans,n=H(e,t.to.line)&&M(e,t.to.line).markedSpans;if(!r&&!n)return null;var i=t.from.ch,o=t.to.ch,l=0==P(t.from,t.to),s=Z(r,i,l),a=Q(n,o,l),u=1==t.text.length,c=g(t.text).length+(u?i:0);if(s)for(var f=0;f<s.length;++f){var h=s[f];if(null==h.to){var d=_(a,h.marker);d?u&&(h.to=null==d.to?null:d.to+c):h.to=i}}if(a)for(var p=0;p<a.length;++p){var v=a[p];null!=v.to&&(v.to+=c),null==v.from?_(s,v.marker)||(v.from=c,u&&(s||(s=[])).push(v)):(v.from+=c,u&&(s||(s=[])).push(v))}s&&(s=ee(s)),a&&a!=s&&(a=ee(a));var m=[s];if(!u){var y,b=t.text.length-2;if(b>0&&s)for(var w=0;w<s.length;++w)null==s[w].to&&(y||(y=[])).push(new Y(s[w].marker,null,null));for(var x=0;x<b;++x)m.push(y);m.push(a)}return m}function ee(e){for(var t=0;t<e.length;++t){var r=e[t];null!=r.from&&r.from==r.to&&!1!==r.marker.clearWhenEmpty&&e.splice(t--,1)}return e.length?e:null}function te(e,t,r){var n=null;if(e.iter(t.line,r.line+1,function(e){if(e.markedSpans)for(var t=0;t<e.markedSpans.length;++t){var r=e.markedSpans[t].marker;!r.readOnly||n&&-1!=h(n,r)||(n||(n=[])).push(r)}}),!n)return null;for(var i=[{from:t,to:r}],o=0;o<n.length;++o)for(var l=n[o],s=l.find(0),a=0;a<i.length;++a){var u=i[a];if(!(P(u.to,s.from)<0||P(u.from,s.to)>0)){var c=[a,1],f=P(u.from,s.from),d=P(u.to,s.to);(f<0||!l.inclusiveLeft&&!f)&&c.push({from:u.from,to:s.from}),(d>0||!l.inclusiveRight&&!d)&&c.push({from:s.to,to:u.to}),i.splice.apply(i,c),a+=c.length-3}}return i}function re(e){var t=e.markedSpans;if(t){for(var r=0;r<t.length;++r)t[r].marker.detachLine(e);e.markedSpans=null}}function ne(e,t){if(t){for(var r=0;r<t.length;++r)t[r].marker.attachLine(e);e.markedSpans=t}}function ie(e){return e.inclusiveLeft?-1:0}function oe(e){return e.inclusiveRight?1:0}function le(e,t){var r=e.lines.length-t.lines.length;if(0!=r)return r;var n=e.find(),i=t.find(),o=P(n.from,i.from)||ie(e)-ie(t);if(o)return-o;var l=P(n.to,i.to)||oe(e)-oe(t);return l||t.id-e.id}function se(e,t){var r,n=_l&&e.markedSpans;if(n)for(var i=void 0,o=0;o<n.length;++o)(i=n[o]).marker.collapsed&&null==(t?i.from:i.to)&&(!r||le(r,i.marker)<0)&&(r=i.marker);return r}function ae(e){return se(e,!0)}function ue(e){return se(e,!1)}function ce(e,t,r,n,i){var o=M(e,t),l=_l&&o.markedSpans;if(l)for(var s=0;s<l.length;++s){var a=l[s];if(a.marker.collapsed){var u=a.marker.find(0),c=P(u.from,r)||ie(a.marker)-ie(i),f=P(u.to,n)||oe(a.marker)-oe(i);if(!(c>=0&&f<=0||c<=0&&f>=0)&&(c<=0&&(a.marker.inclusiveRight&&i.inclusiveLeft?P(u.to,r)>=0:P(u.to,r)>0)||c>=0&&(a.marker.inclusiveRight&&i.inclusiveLeft?P(u.from,n)<=0:P(u.from,n)<0)))return!0}}}function fe(e){for(var t;t=ae(e);)e=t.find(-1,!0).line;return e}function he(e){for(var t;t=ue(e);)e=t.find(1,!0).line;return e}function de(e){for(var t,r;t=ue(e);)e=t.find(1,!0).line,(r||(r=[])).push(e);return r}function pe(e,t){var r=M(e,t),n=fe(r);return r==n?t:W(n)}function ge(e,t){if(t>e.lastLine())return t;var r,n=M(e,t);if(!ve(e,n))return t;for(;r=ue(n);)n=r.find(1,!0).line;return W(n)+1}function ve(e,t){var r=_l&&t.markedSpans;if(r)for(var n=void 0,i=0;i<r.length;++i)if((n=r[i]).marker.collapsed){if(null==n.from)return!0;if(!n.marker.widgetNode&&0==n.from&&n.marker.inclusiveLeft&&me(e,t,n))return!0}}function me(e,t,r){if(null==r.to){var n=r.marker.find(1,!0);return me(e,n.line,_(n.line.markedSpans,r.marker))}if(r.marker.inclusiveRight&&r.to==t.text.length)return!0;for(var i=void 0,o=0;o<t.markedSpans.length;++o)if((i=t.markedSpans[o]).marker.collapsed&&!i.marker.widgetNode&&i.from==r.to&&(null==i.to||i.to!=r.from)&&(i.marker.inclusiveLeft||r.marker.inclusiveRight)&&me(e,t,i))return!0}function ye(e){for(var t=0,r=(e=fe(e)).parent,n=0;n<r.lines.length;++n){var i=r.lines[n];if(i==e)break;t+=i.height}for(var o=r.parent;o;r=o,o=r.parent)for(var l=0;l<o.children.length;++l){var s=o.children[l];if(s==r)break;t+=s.height}return t}function be(e){if(0==e.height)return 0;for(var t,r=e.text.length,n=e;t=ae(n);){var i=t.find(0,!0);n=i.from.line,r+=i.from.ch-i.to.ch}for(n=e;t=ue(n);){var o=t.find(0,!0);r-=n.text.length-o.from.ch,r+=(n=o.to.line).text.length-o.to.ch}return r}function we(e){var t=e.display,r=e.doc;t.maxLine=M(r,r.first),t.maxLineLength=be(t.maxLine),t.maxLineChanged=!0,r.iter(function(e){var r=be(e);r>t.maxLineLength&&(t.maxLineLength=r,t.maxLine=e)})}function xe(e,t,r,n){if(!e)return n(t,r,"ltr",0);for(var i=!1,o=0;o<e.length;++o){var l=e[o];(l.from<r&&l.to>t||t==r&&l.to==t)&&(n(Math.max(l.from,t),Math.min(l.to,r),1==l.level?"rtl":"ltr",o),i=!0)}i||n(t,r,"ltr")}function Ce(e,t,r){var n;$l=null;for(var i=0;i<e.length;++i){var o=e[i];if(o.from<t&&o.to>t)return i;o.to==t&&(o.from!=o.to&&"before"==r?n=i:$l=i),o.from==t&&(o.from!=o.to&&"before"!=r?n=i:$l=i)}return null!=n?n:$l}function Se(e,t){var r=e.order;return null==r&&(r=e.order=ql(e.text,t)),r}function Le(e,t){return e._handlers&&e._handlers[t]||Zl}function ke(e,t,r){if(e.removeEventListener)e.removeEventListener(t,r,!1);else if(e.detachEvent)e.detachEvent("on"+t,r);else{var n=e._handlers,i=n&&n[t];if(i){var o=h(i,r);o>-1&&(n[t]=i.slice(0,o).concat(i.slice(o+1)))}}}function Te(e,t){var r=Le(e,t);if(r.length)for(var n=Array.prototype.slice.call(arguments,2),i=0;i<r.length;++i)r[i].apply(null,n)}function Me(e,t,r){return"string"==typeof t&&(t={type:t,preventDefault:function(){this.defaultPrevented=!0}}),Te(e,r||t.type,e,t),He(t)||t.codemirrorIgnore}function Ne(e){var t=e._handlers&&e._handlers.cursorActivity;if(t)for(var r=e.curOp.cursorActivityHandlers||(e.curOp.cursorActivityHandlers=[]),n=0;n<t.length;++n)-1==h(r,t[n])&&r.push(t[n])}function Oe(e,t){return Le(e,t).length>0}function Ae(e){e.prototype.on=function(e,t){Ql(this,e,t)},e.prototype.off=function(e,t){ke(this,e,t)}}function We(e){e.preventDefault?e.preventDefault():e.returnValue=!1}function De(e){e.stopPropagation?e.stopPropagation():e.cancelBubble=!0}function He(e){return null!=e.defaultPrevented?e.defaultPrevented:0==e.returnValue}function Fe(e){We(e),De(e)}function Ee(e){return e.target||e.srcElement}function Pe(e){var t=e.which;return null==t&&(1&e.button?t=1:2&e.button?t=3:4&e.button&&(t=2)),Ml&&e.ctrlKey&&1==t&&(t=3),t}function Ie(e){if(null==Il){var t=n("span","​");r(e,n("span",[t,document.createTextNode("x")])),0!=e.firstChild.offsetHeight&&(Il=t.offsetWidth<=1&&t.offsetHeight>2&&!(gl&&vl<8))}var i=Il?n("span","​"):n("span"," ",null,"display: inline-block; width: 1px; margin-right: -1px");return i.setAttribute("cm-text",""),i}function ze(e){if(null!=zl)return zl;var n=r(e,document.createTextNode("AخA")),i=Wl(n,0,1).getBoundingClientRect(),o=Wl(n,1,2).getBoundingClientRect();return t(e),!(!i||i.left==i.right)&&(zl=o.right-i.right<3)}function Re(e){if(null!=ns)return ns;var t=r(e,n("span","x")),i=t.getBoundingClientRect(),o=Wl(t,0,1).getBoundingClientRect();return ns=Math.abs(i.left-o.left)>1}function Be(e,t){arguments.length>2&&(t.dependencies=Array.prototype.slice.call(arguments,2)),is[e]=t}function Ge(e){if("string"==typeof e&&os.hasOwnProperty(e))e=os[e];else if(e&&"string"==typeof e.name&&os.hasOwnProperty(e.name)){var t=os[e.name];"string"==typeof t&&(t={name:t}),(e=b(t,e)).name=t.name}else{if("string"==typeof e&&/^[\w\-]+\/[\w\-]+\+xml$/.test(e))return Ge("application/xml");if("string"==typeof e&&/^[\w\-]+\/[\w\-]+\+json$/.test(e))return Ge("application/json")}return"string"==typeof e?{name:e}:e||{name:"null"}}function Ue(e,t){t=Ge(t);var r=is[t.name];if(!r)return Ue(e,"text/plain");var n=r(e,t);if(ls.hasOwnProperty(t.name)){var i=ls[t.name];for(var o in i)i.hasOwnProperty(o)&&(n.hasOwnProperty(o)&&(n["_"+o]=n[o]),n[o]=i[o])}if(n.name=t.name,t.helperType&&(n.helperType=t.helperType),t.modeProps)for(var l in t.modeProps)n[l]=t.modeProps[l];return n}function Ve(e,t){c(t,ls.hasOwnProperty(e)?ls[e]:ls[e]={})}function Ke(e,t){if(!0===t)return t;if(e.copyState)return e.copyState(t);var r={};for(var n in t){var i=t[n];i instanceof Array&&(i=i.concat([])),r[n]=i}return r}function je(e,t){for(var r;e.innerMode&&(r=e.innerMode(t))&&r.mode!=e;)t=r.state,e=r.mode;return r||{mode:e,state:t}}function Xe(e,t,r){return!e.startState||e.startState(t,r)}function Ye(e,t,r,n){var i=[e.state.modeGen],o={};tt(e,t.text,e.doc.mode,r,function(e,t){return i.push(e,t)},o,n);for(var l=r.state,s=0;s<e.state.overlays.length;++s)!function(n){var l=e.state.overlays[n],s=1,a=0;r.state=!0,tt(e,t.text,l.mode,r,function(e,t){for(var r=s;a<e;){var n=i[s];n>e&&i.splice(s,1,e,i[s+1],n),s+=2,a=Math.min(e,n)}if(t)if(l.opaque)i.splice(r,s-r,e,"overlay "+t),s=r+2;else for(;r<s;r+=2){var o=i[r+1];i[r+1]=(o?o+" ":"")+"overlay "+t}},o)}(s);return r.state=l,{styles:i,classes:o.bgClass||o.textClass?o:null}}function _e(e,t,r){if(!t.styles||t.styles[0]!=e.state.modeGen){var n=$e(e,W(t)),i=t.text.length>e.options.maxHighlightLength&&Ke(e.doc.mode,n.state),o=Ye(e,t,n);i&&(n.state=i),t.stateAfter=n.save(!i),t.styles=o.styles,o.classes?t.styleClasses=o.classes:t.styleClasses&&(t.styleClasses=null),r===e.doc.highlightFrontier&&(e.doc.modeFrontier=Math.max(e.doc.modeFrontier,++e.doc.highlightFrontier))}return t.styles}function $e(e,t,r){var n=e.doc,i=e.display;if(!n.mode.startState)return new us(n,!0,t);var o=rt(e,t,r),l=o>n.first&&M(n,o-1).stateAfter,s=l?us.fromSaved(n,l,o):new us(n,Xe(n.mode),o);return n.iter(o,t,function(r){qe(e,r.text,s);var n=s.line;r.stateAfter=n==t-1||n%5==0||n>=i.viewFrom&&n<i.viewTo?s.save():null,s.nextLine()}),r&&(n.modeFrontier=s.line),s}function qe(e,t,r,n){var i=e.doc.mode,o=new ss(t,e.options.tabSize,r);for(o.start=o.pos=n||0,""==t&&Ze(i,r.state);!o.eol();)Qe(i,o,r.state),o.start=o.pos}function Ze(e,t){if(e.blankLine)return e.blankLine(t);if(e.innerMode){var r=je(e,t);return r.mode.blankLine?r.mode.blankLine(r.state):void 0}}function Qe(e,t,r,n){for(var i=0;i<10;i++){n&&(n[0]=je(e,r).mode);var o=e.token(t,r);if(t.pos>t.start)return o}throw new Error("Mode "+e.name+" failed to advance stream.")}function Je(e,t,r,n){var i,o,l=e.doc,s=l.mode,a=M(l,(t=U(l,t)).line),u=$e(e,t.line,r),c=new ss(a.text,e.options.tabSize,u);for(n&&(o=[]);(n||c.pos<t.ch)&&!c.eol();)c.start=c.pos,i=Qe(s,c,u.state),n&&o.push(new cs(c,i,Ke(l.mode,u.state)));return n?o:new cs(c,i,u.state)}function et(e,t){if(e)for(;;){var r=e.match(/(?:^|\s+)line-(background-)?(\S+)/);if(!r)break;e=e.slice(0,r.index)+e.slice(r.index+r[0].length);var n=r[1]?"bgClass":"textClass";null==t[n]?t[n]=r[2]:new RegExp("(?:^|s)"+r[2]+"(?:$|s)").test(t[n])||(t[n]+=" "+r[2])}return e}function tt(e,t,r,n,i,o,l){var s=r.flattenSpans;null==s&&(s=e.options.flattenSpans);var a,u=0,c=null,f=new ss(t,e.options.tabSize,n),h=e.options.addModeClass&&[null];for(""==t&&et(Ze(r,n.state),o);!f.eol();){if(f.pos>e.options.maxHighlightLength?(s=!1,l&&qe(e,t,n,f.pos),f.pos=t.length,a=null):a=et(Qe(r,f,n.state,h),o),h){var d=h[0].name;d&&(a="m-"+(a?d+" "+a:d))}if(!s||c!=a){for(;u<f.start;)i(u=Math.min(f.start,u+5e3),c);c=a}f.start=f.pos}for(;u<f.pos;){var p=Math.min(f.pos,u+5e3);i(p,c),u=p}}function rt(e,t,r){for(var n,i,o=e.doc,l=r?-1:t-(e.doc.mode.innerMode?1e3:100),s=t;s>l;--s){if(s<=o.first)return o.first;var a=M(o,s-1),u=a.stateAfter;if(u&&(!r||s+(u instanceof as?u.lookAhead:0)<=o.modeFrontier))return s;var c=f(a.text,null,e.options.tabSize);(null==i||n>c)&&(i=s-1,n=c)}return i}function nt(e,t){if(e.modeFrontier=Math.min(e.modeFrontier,t),!(e.highlightFrontier<t-10)){for(var r=e.first,n=t-1;n>r;n--){var i=M(e,n).stateAfter;if(i&&(!(i instanceof as)||n+i.lookAhead<t)){r=n+1;break}}e.highlightFrontier=Math.min(e.highlightFrontier,r)}}function it(e,t,r,n){e.text=t,e.stateAfter&&(e.stateAfter=null),e.styles&&(e.styles=null),null!=e.order&&(e.order=null),re(e),ne(e,r);var i=n?n(e):1;i!=e.height&&A(e,i)}function ot(e){e.parent=null,re(e)}function lt(e,t){if(!e||/^\s*$/.test(e))return null;var r=t.addModeClass?ps:ds;return r[e]||(r[e]=e.replace(/\S+/g,"cm-$&"))}function st(e,t){var r=i("span",null,null,ml?"padding-right: .1px":null),n={pre:i("pre",[r],"CodeMirror-line"),content:r,col:0,pos:0,cm:e,trailingSpace:!1,splitSpaces:(gl||ml)&&e.getOption("lineWrapping")};t.measure={};for(var o=0;o<=(t.rest?t.rest.length:0);o++){var l=o?t.rest[o-1]:t.line,s=void 0;n.pos=0,n.addToken=ut,ze(e.display.measure)&&(s=Se(l,e.doc.direction))&&(n.addToken=ft(n.addToken,s)),n.map=[],dt(l,n,_e(e,l,t!=e.display.externalMeasured&&W(l))),l.styleClasses&&(l.styleClasses.bgClass&&(n.bgClass=a(l.styleClasses.bgClass,n.bgClass||"")),l.styleClasses.textClass&&(n.textClass=a(l.styleClasses.textClass,n.textClass||""))),0==n.map.length&&n.map.push(0,0,n.content.appendChild(Ie(e.display.measure))),0==o?(t.measure.map=n.map,t.measure.cache={}):((t.measure.maps||(t.measure.maps=[])).push(n.map),(t.measure.caches||(t.measure.caches=[])).push({}))}if(ml){var u=n.content.lastChild;(/\bcm-tab\b/.test(u.className)||u.querySelector&&u.querySelector(".cm-tab"))&&(n.content.className="cm-tab-wrap-hack")}return Te(e,"renderLine",e,t.line,n.pre),n.pre.className&&(n.textClass=a(n.pre.className,n.textClass||"")),n}function at(e){var t=n("span","•","cm-invalidchar");return t.title="\\u"+e.charCodeAt(0).toString(16),t.setAttribute("aria-label",t.title),t}function ut(e,t,r,i,o,l,s){if(t){var a,u=e.splitSpaces?ct(t,e.trailingSpace):t,c=e.cm.state.specialChars,f=!1;if(c.test(t)){a=document.createDocumentFragment();for(var h=0;;){c.lastIndex=h;var d=c.exec(t),g=d?d.index-h:t.length-h;if(g){var v=document.createTextNode(u.slice(h,h+g));gl&&vl<9?a.appendChild(n("span",[v])):a.appendChild(v),e.map.push(e.pos,e.pos+g,v),e.col+=g,e.pos+=g}if(!d)break;h+=g+1;var m=void 0;if("\t"==d[0]){var y=e.cm.options.tabSize,b=y-e.col%y;(m=a.appendChild(n("span",p(b),"cm-tab"))).setAttribute("role","presentation"),m.setAttribute("cm-text","\t"),e.col+=b}else"\r"==d[0]||"\n"==d[0]?((m=a.appendChild(n("span","\r"==d[0]?"␍":"␤","cm-invalidchar"))).setAttribute("cm-text",d[0]),e.col+=1):((m=e.cm.options.specialCharPlaceholder(d[0])).setAttribute("cm-text",d[0]),gl&&vl<9?a.appendChild(n("span",[m])):a.appendChild(m),e.col+=1);e.map.push(e.pos,e.pos+1,m),e.pos++}}else e.col+=t.length,a=document.createTextNode(u),e.map.push(e.pos,e.pos+t.length,a),gl&&vl<9&&(f=!0),e.pos+=t.length;if(e.trailingSpace=32==u.charCodeAt(t.length-1),r||i||o||f||s){var w=r||"";i&&(w+=i),o&&(w+=o);var x=n("span",[a],w,s);return l&&(x.title=l),e.content.appendChild(x)}e.content.appendChild(a)}}function ct(e,t){if(e.length>1&&!/  /.test(e))return e;for(var r=t,n="",i=0;i<e.length;i++){var o=e.charAt(i);" "!=o||!r||i!=e.length-1&&32!=e.charCodeAt(i+1)||(o=" "),n+=o,r=" "==o}return n}function ft(e,t){return function(r,n,i,o,l,s,a){i=i?i+" cm-force-border":"cm-force-border";for(var u=r.pos,c=u+n.length;;){for(var f=void 0,h=0;h<t.length&&!((f=t[h]).to>u&&f.from<=u);h++);if(f.to>=c)return e(r,n,i,o,l,s,a);e(r,n.slice(0,f.to-u),i,o,null,s,a),o=null,n=n.slice(f.to-u),u=f.to}}}function ht(e,t,r,n){var i=!n&&r.widgetNode;i&&e.map.push(e.pos,e.pos+t,i),!n&&e.cm.display.input.needsContentAttribute&&(i||(i=e.content.appendChild(document.createElement("span"))),i.setAttribute("cm-marker",r.id)),i&&(e.cm.display.input.setUneditable(i),e.content.appendChild(i)),e.pos+=t,e.trailingSpace=!1}function dt(e,t,r){var n=e.markedSpans,i=e.text,o=0;if(n)for(var l,s,a,u,c,f,h,d=i.length,p=0,g=1,v="",m=0;;){if(m==p){a=u=c=f=s="",h=null,m=1/0;for(var y=[],b=void 0,w=0;w<n.length;++w){var x=n[w],C=x.marker;"bookmark"==C.type&&x.from==p&&C.widgetNode?y.push(C):x.from<=p&&(null==x.to||x.to>p||C.collapsed&&x.to==p&&x.from==p)?(null!=x.to&&x.to!=p&&m>x.to&&(m=x.to,u=""),C.className&&(a+=" "+C.className),C.css&&(s=(s?s+";":"")+C.css),C.startStyle&&x.from==p&&(c+=" "+C.startStyle),C.endStyle&&x.to==m&&(b||(b=[])).push(C.endStyle,x.to),C.title&&!f&&(f=C.title),C.collapsed&&(!h||le(h.marker,C)<0)&&(h=x)):x.from>p&&m>x.from&&(m=x.from)}if(b)for(var S=0;S<b.length;S+=2)b[S+1]==m&&(u+=" "+b[S]);if(!h||h.from==p)for(var L=0;L<y.length;++L)ht(t,0,y[L]);if(h&&(h.from||0)==p){if(ht(t,(null==h.to?d+1:h.to)-p,h.marker,null==h.from),null==h.to)return;h.to==p&&(h=!1)}}if(p>=d)break;for(var k=Math.min(d,m);;){if(v){var T=p+v.length;if(!h){var M=T>k?v.slice(0,k-p):v;t.addToken(t,M,l?l+a:a,c,p+M.length==m?u:"",f,s)}if(T>=k){v=v.slice(k-p),p=k;break}p=T,c=""}v=i.slice(o,o=r[g++]),l=lt(r[g++],t.cm.options)}}else for(var N=1;N<r.length;N+=2)t.addToken(t,i.slice(o,o=r[N]),lt(r[N+1],t.cm.options))}function pt(e,t,r){this.line=t,this.rest=de(t),this.size=this.rest?W(g(this.rest))-r+1:1,this.node=this.text=null,this.hidden=ve(e,t)}function gt(e,t,r){for(var n,i=[],o=t;o<r;o=n){var l=new pt(e.doc,M(e.doc,o),o);n=o+l.size,i.push(l)}return i}function vt(e){gs?gs.ops.push(e):e.ownsGroup=gs={ops:[e],delayedCallbacks:[]}}function mt(e){var t=e.delayedCallbacks,r=0;do{for(;r<t.length;r++)t[r].call(null);for(var n=0;n<e.ops.length;n++){var i=e.ops[n];if(i.cursorActivityHandlers)for(;i.cursorActivityCalled<i.cursorActivityHandlers.length;)i.cursorActivityHandlers[i.cursorActivityCalled++].call(null,i.cm)}}while(r<t.length)}function yt(e,t){var r=e.ownsGroup;if(r)try{mt(r)}finally{gs=null,t(r)}}function bt(e,t){var r=Le(e,t);if(r.length){var n,i=Array.prototype.slice.call(arguments,2);gs?n=gs.delayedCallbacks:vs?n=vs:(n=vs=[],setTimeout(wt,0));for(var o=0;o<r.length;++o)!function(e){n.push(function(){return r[e].apply(null,i)})}(o)}}function wt(){var e=vs;vs=null;for(var t=0;t<e.length;++t)e[t]()}function xt(e,t,r,n){for(var i=0;i<t.changes.length;i++){var o=t.changes[i];"text"==o?kt(e,t):"gutter"==o?Mt(e,t,r,n):"class"==o?Tt(e,t):"widget"==o&&Nt(e,t,n)}t.changes=null}function Ct(e){return e.node==e.text&&(e.node=n("div",null,null,"position: relative"),e.text.parentNode&&e.text.parentNode.replaceChild(e.node,e.text),e.node.appendChild(e.text),gl&&vl<8&&(e.node.style.zIndex=2)),e.node}function St(e,t){var r=t.bgClass?t.bgClass+" "+(t.line.bgClass||""):t.line.bgClass;if(r&&(r+=" CodeMirror-linebackground"),t.background)r?t.background.className=r:(t.background.parentNode.removeChild(t.background),t.background=null);else if(r){var i=Ct(t);t.background=i.insertBefore(n("div",null,r),i.firstChild),e.display.input.setUneditable(t.background)}}function Lt(e,t){var r=e.display.externalMeasured;return r&&r.line==t.line?(e.display.externalMeasured=null,t.measure=r.measure,r.built):st(e,t)}function kt(e,t){var r=t.text.className,n=Lt(e,t);t.text==t.node&&(t.node=n.pre),t.text.parentNode.replaceChild(n.pre,t.text),t.text=n.pre,n.bgClass!=t.bgClass||n.textClass!=t.textClass?(t.bgClass=n.bgClass,t.textClass=n.textClass,Tt(e,t)):r&&(t.text.className=r)}function Tt(e,t){St(e,t),t.line.wrapClass?Ct(t).className=t.line.wrapClass:t.node!=t.text&&(t.node.className="");var r=t.textClass?t.textClass+" "+(t.line.textClass||""):t.line.textClass;t.text.className=r||""}function Mt(e,t,r,i){if(t.gutter&&(t.node.removeChild(t.gutter),t.gutter=null),t.gutterBackground&&(t.node.removeChild(t.gutterBackground),t.gutterBackground=null),t.line.gutterClass){var o=Ct(t);t.gutterBackground=n("div",null,"CodeMirror-gutter-background "+t.line.gutterClass,"left: "+(e.options.fixedGutter?i.fixedPos:-i.gutterTotalWidth)+"px; width: "+i.gutterTotalWidth+"px"),e.display.input.setUneditable(t.gutterBackground),o.insertBefore(t.gutterBackground,t.text)}var l=t.line.gutterMarkers;if(e.options.lineNumbers||l){var s=Ct(t),a=t.gutter=n("div",null,"CodeMirror-gutter-wrapper","left: "+(e.options.fixedGutter?i.fixedPos:-i.gutterTotalWidth)+"px");if(e.display.input.setUneditable(a),s.insertBefore(a,t.text),t.line.gutterClass&&(a.className+=" "+t.line.gutterClass),!e.options.lineNumbers||l&&l["CodeMirror-linenumbers"]||(t.lineNumber=a.appendChild(n("div",F(e.options,r),"CodeMirror-linenumber CodeMirror-gutter-elt","left: "+i.gutterLeft["CodeMirror-linenumbers"]+"px; width: "+e.display.lineNumInnerWidth+"px"))),l)for(var u=0;u<e.options.gutters.length;++u){var c=e.options.gutters[u],f=l.hasOwnProperty(c)&&l[c];f&&a.appendChild(n("div",[f],"CodeMirror-gutter-elt","left: "+i.gutterLeft[c]+"px; width: "+i.gutterWidth[c]+"px"))}}}function Nt(e,t,r){t.alignable&&(t.alignable=null);for(var n=t.node.firstChild,i=void 0;n;n=i)i=n.nextSibling,"CodeMirror-linewidget"==n.className&&t.node.removeChild(n);At(e,t,r)}function Ot(e,t,r,n){var i=Lt(e,t);return t.text=t.node=i.pre,i.bgClass&&(t.bgClass=i.bgClass),i.textClass&&(t.textClass=i.textClass),Tt(e,t),Mt(e,t,r,n),At(e,t,n),t.node}function At(e,t,r){if(Wt(e,t.line,t,r,!0),t.rest)for(var n=0;n<t.rest.length;n++)Wt(e,t.rest[n],t,r,!1)}function Wt(e,t,r,i,o){if(t.widgets)for(var l=Ct(r),s=0,a=t.widgets;s<a.length;++s){var u=a[s],c=n("div",[u.node],"CodeMirror-linewidget");u.handleMouseEvents||c.setAttribute("cm-ignore-events","true"),Dt(u,c,r,i),e.display.input.setUneditable(c),o&&u.above?l.insertBefore(c,r.gutter||r.text):l.appendChild(c),bt(u,"redraw")}}function Dt(e,t,r,n){if(e.noHScroll){(r.alignable||(r.alignable=[])).push(t);var i=n.wrapperWidth;t.style.left=n.fixedPos+"px",e.coverGutter||(i-=n.gutterTotalWidth,t.style.paddingLeft=n.gutterTotalWidth+"px"),t.style.width=i+"px"}e.coverGutter&&(t.style.zIndex=5,t.style.position="relative",e.noHScroll||(t.style.marginLeft=-n.gutterTotalWidth+"px"))}function Ht(e){if(null!=e.height)return e.height;var t=e.doc.cm;if(!t)return 0;if(!o(document.body,e.node)){var i="position: relative;";e.coverGutter&&(i+="margin-left: -"+t.display.gutters.offsetWidth+"px;"),e.noHScroll&&(i+="width: "+t.display.wrapper.clientWidth+"px;"),r(t.display.measure,n("div",[e.node],null,i))}return e.height=e.node.parentNode.offsetHeight}function Ft(e,t){for(var r=Ee(t);r!=e.wrapper;r=r.parentNode)if(!r||1==r.nodeType&&"true"==r.getAttribute("cm-ignore-events")||r.parentNode==e.sizer&&r!=e.mover)return!0}function Et(e){return e.lineSpace.offsetTop}function Pt(e){return e.mover.offsetHeight-e.lineSpace.offsetHeight}function It(e){if(e.cachedPaddingH)return e.cachedPaddingH;var t=r(e.measure,n("pre","x")),i=window.getComputedStyle?window.getComputedStyle(t):t.currentStyle,o={left:parseInt(i.paddingLeft),right:parseInt(i.paddingRight)};return isNaN(o.left)||isNaN(o.right)||(e.cachedPaddingH=o),o}function zt(e){return Rl-e.display.nativeBarWidth}function Rt(e){return e.display.scroller.clientWidth-zt(e)-e.display.barWidth}function Bt(e){return e.display.scroller.clientHeight-zt(e)-e.display.barHeight}function Gt(e,t,r){var n=e.options.lineWrapping,i=n&&Rt(e);if(!t.measure.heights||n&&t.measure.width!=i){var o=t.measure.heights=[];if(n){t.measure.width=i;for(var l=t.text.firstChild.getClientRects(),s=0;s<l.length-1;s++){var a=l[s],u=l[s+1];Math.abs(a.bottom-u.bottom)>2&&o.push((a.bottom+u.top)/2-r.top)}}o.push(r.bottom-r.top)}}function Ut(e,t,r){if(e.line==t)return{map:e.measure.map,cache:e.measure.cache};for(var n=0;n<e.rest.length;n++)if(e.rest[n]==t)return{map:e.measure.maps[n],cache:e.measure.caches[n]};for(var i=0;i<e.rest.length;i++)if(W(e.rest[i])>r)return{map:e.measure.maps[i],cache:e.measure.caches[i],before:!0}}function Vt(e,t){var n=W(t=fe(t)),i=e.display.externalMeasured=new pt(e.doc,t,n);i.lineN=n;var o=i.built=st(e,i);return i.text=o.pre,r(e.display.lineMeasure,o.pre),i}function Kt(e,t,r,n){return Yt(e,Xt(e,t),r,n)}function jt(e,t){if(t>=e.display.viewFrom&&t<e.display.viewTo)return e.display.view[Lr(e,t)];var r=e.display.externalMeasured;return r&&t>=r.lineN&&t<r.lineN+r.size?r:void 0}function Xt(e,t){var r=W(t),n=jt(e,r);n&&!n.text?n=null:n&&n.changes&&(xt(e,n,r,br(e)),e.curOp.forceUpdate=!0),n||(n=Vt(e,t));var i=Ut(n,t,r);return{line:t,view:n,rect:null,map:i.map,cache:i.cache,before:i.before,hasHeights:!1}}function Yt(e,t,r,n,i){t.before&&(r=-1);var o,l=r+(n||"");return t.cache.hasOwnProperty(l)?o=t.cache[l]:(t.rect||(t.rect=t.view.text.getBoundingClientRect()),t.hasHeights||(Gt(e,t.view,t.rect),t.hasHeights=!0),(o=qt(e,t,r,n)).bogus||(t.cache[l]=o)),{left:o.left,right:o.right,top:i?o.rtop:o.top,bottom:i?o.rbottom:o.bottom}}function _t(e,t,r){for(var n,i,o,l,s,a,u=0;u<e.length;u+=3)if(s=e[u],a=e[u+1],t<s?(i=0,o=1,l="left"):t<a?o=(i=t-s)+1:(u==e.length-3||t==a&&e[u+3]>t)&&(i=(o=a-s)-1,t>=a&&(l="right")),null!=i){if(n=e[u+2],s==a&&r==(n.insertLeft?"left":"right")&&(l=r),"left"==r&&0==i)for(;u&&e[u-2]==e[u-3]&&e[u-1].insertLeft;)n=e[2+(u-=3)],l="left";if("right"==r&&i==a-s)for(;u<e.length-3&&e[u+3]==e[u+4]&&!e[u+5].insertLeft;)n=e[(u+=3)+2],l="right";break}return{node:n,start:i,end:o,collapse:l,coverStart:s,coverEnd:a}}function $t(e,t){var r=ms;if("left"==t)for(var n=0;n<e.length&&(r=e[n]).left==r.right;n++);else for(var i=e.length-1;i>=0&&(r=e[i]).left==r.right;i--);return r}function qt(e,t,r,n){var i,o=_t(t.map,r,n),l=o.node,s=o.start,a=o.end,u=o.collapse;if(3==l.nodeType){for(var c=0;c<4;c++){for(;s&&S(t.line.text.charAt(o.coverStart+s));)--s;for(;o.coverStart+a<o.coverEnd&&S(t.line.text.charAt(o.coverStart+a));)++a;if((i=gl&&vl<9&&0==s&&a==o.coverEnd-o.coverStart?l.parentNode.getBoundingClientRect():$t(Wl(l,s,a).getClientRects(),n)).left||i.right||0==s)break;a=s,s-=1,u="right"}gl&&vl<11&&(i=Zt(e.display.measure,i))}else{s>0&&(u=n="right");var f;i=e.options.lineWrapping&&(f=l.getClientRects()).length>1?f["right"==n?f.length-1:0]:l.getBoundingClientRect()}if(gl&&vl<9&&!s&&(!i||!i.left&&!i.right)){var h=l.parentNode.getClientRects()[0];i=h?{left:h.left,right:h.left+yr(e.display),top:h.top,bottom:h.bottom}:ms}for(var d=i.top-t.rect.top,p=i.bottom-t.rect.top,g=(d+p)/2,v=t.view.measure.heights,m=0;m<v.length-1&&!(g<v[m]);m++);var y=m?v[m-1]:0,b=v[m],w={left:("right"==u?i.right:i.left)-t.rect.left,right:("left"==u?i.left:i.right)-t.rect.left,top:y,bottom:b};return i.left||i.right||(w.bogus=!0),e.options.singleCursorHeightPerLine||(w.rtop=d,w.rbottom=p),w}function Zt(e,t){if(!window.screen||null==screen.logicalXDPI||screen.logicalXDPI==screen.deviceXDPI||!Re(e))return t;var r=screen.logicalXDPI/screen.deviceXDPI,n=screen.logicalYDPI/screen.deviceYDPI;return{left:t.left*r,right:t.right*r,top:t.top*n,bottom:t.bottom*n}}function Qt(e){if(e.measure&&(e.measure.cache={},e.measure.heights=null,e.rest))for(var t=0;t<e.rest.length;t++)e.measure.caches[t]={}}function Jt(e){e.display.externalMeasure=null,t(e.display.lineMeasure);for(var r=0;r<e.display.view.length;r++)Qt(e.display.view[r])}function er(e){Jt(e),e.display.cachedCharWidth=e.display.cachedTextHeight=e.display.cachedPaddingH=null,e.options.lineWrapping||(e.display.maxLineChanged=!0),e.display.lineNumChars=null}function tr(){return bl&&kl?-(document.body.getBoundingClientRect().left-parseInt(getComputedStyle(document.body).marginLeft)):window.pageXOffset||(document.documentElement||document.body).scrollLeft}function rr(){return bl&&kl?-(document.body.getBoundingClientRect().top-parseInt(getComputedStyle(document.body).marginTop)):window.pageYOffset||(document.documentElement||document.body).scrollTop}function nr(e){var t=0;if(e.widgets)for(var r=0;r<e.widgets.length;++r)e.widgets[r].above&&(t+=Ht(e.widgets[r]));return t}function ir(e,t,r,n,i){if(!i){var o=nr(t);r.top+=o,r.bottom+=o}if("line"==n)return r;n||(n="local");var l=ye(t);if("local"==n?l+=Et(e.display):l-=e.display.viewOffset,"page"==n||"window"==n){var s=e.display.lineSpace.getBoundingClientRect();l+=s.top+("window"==n?0:rr());var a=s.left+("window"==n?0:tr());r.left+=a,r.right+=a}return r.top+=l,r.bottom+=l,r}function or(e,t,r){if("div"==r)return t;var n=t.left,i=t.top;if("page"==r)n-=tr(),i-=rr();else if("local"==r||!r){var o=e.display.sizer.getBoundingClientRect();n+=o.left,i+=o.top}var l=e.display.lineSpace.getBoundingClientRect();return{left:n-l.left,top:i-l.top}}function lr(e,t,r,n,i){return n||(n=M(e.doc,t.line)),ir(e,n,Kt(e,n,t.ch,i),r)}function sr(e,t,r,n,i,o){function l(t,l){var s=Yt(e,i,t,l?"right":"left",o);return l?s.left=s.right:s.right=s.left,ir(e,n,s,r)}function s(e,t,r){var n=1==a[t].level;return l(r?e-1:e,n!=r)}n=n||M(e.doc,t.line),i||(i=Xt(e,n));var a=Se(n,e.doc.direction),u=t.ch,c=t.sticky;if(u>=n.text.length?(u=n.text.length,c="before"):u<=0&&(u=0,c="after"),!a)return l("before"==c?u-1:u,"before"==c);var f=Ce(a,u,c),h=$l,d=s(u,f,"before"==c);return null!=h&&(d.other=s(u,h,"before"!=c)),d}function ar(e,t){var r=0;t=U(e.doc,t),e.options.lineWrapping||(r=yr(e.display)*t.ch);var n=M(e.doc,t.line),i=ye(n)+Et(e.display);return{left:r,right:r,top:i,bottom:i+n.height}}function ur(e,t,r,n,i){var o=E(e,t,r);return o.xRel=i,n&&(o.outside=!0),o}function cr(e,t,r){var n=e.doc;if((r+=e.display.viewOffset)<0)return ur(n.first,0,null,!0,-1);var i=D(n,r),o=n.first+n.size-1;if(i>o)return ur(n.first+n.size-1,M(n,o).text.length,null,!0,1);t<0&&(t=0);for(var l=M(n,i);;){var s=pr(e,l,i,t,r),a=ue(l),u=a&&a.find(0,!0);if(!a||!(s.ch>u.from.ch||s.ch==u.from.ch&&s.xRel>0))return s;i=W(l=u.to.line)}}function fr(e,t,r,n){n-=nr(t);var i=t.text.length,o=k(function(t){return Yt(e,r,t-1).bottom<=n},i,0);return i=k(function(t){return Yt(e,r,t).top>n},o,i),{begin:o,end:i}}function hr(e,t,r,n){return r||(r=Xt(e,t)),fr(e,t,r,ir(e,t,Yt(e,r,n),"line").top)}function dr(e,t,r,n){return!(e.bottom<=r)&&(e.top>r||(n?e.left:e.right)>t)}function pr(e,t,r,n,i){i-=ye(t);var o=Xt(e,t),l=nr(t),s=0,a=t.text.length,u=!0,c=Se(t,e.doc.direction);if(c){var f=(e.options.lineWrapping?vr:gr)(e,t,r,o,c,n,i);s=(u=1!=f.level)?f.from:f.to-1,a=u?f.to:f.from-1}var h,d,p=null,g=null,v=k(function(t){var r=Yt(e,o,t);return r.top+=l,r.bottom+=l,!!dr(r,n,i,!1)&&(r.top<=i&&r.left<=n&&(p=t,g=r),!0)},s,a),m=!1;if(g){var y=n-g.left<g.right-n,b=y==u;v=p+(b?0:1),d=b?"after":"before",h=y?g.left:g.right}else{u||v!=a&&v!=s||v++,d=0==v?"after":v==t.text.length?"before":Yt(e,o,v-(u?1:0)).bottom+l<=i==u?"after":"before";var w=sr(e,E(r,v,d),"line",t,o);h=w.left,m=i<w.top||i>=w.bottom}return v=L(t.text,v,1),ur(r,v,d,m,n-h)}function gr(e,t,r,n,i,o,l){var s=k(function(s){var a=i[s],u=1!=a.level;return dr(sr(e,E(r,u?a.to:a.from,u?"before":"after"),"line",t,n),o,l,!0)},0,i.length-1),a=i[s];if(s>0){var u=1!=a.level,c=sr(e,E(r,u?a.from:a.to,u?"after":"before"),"line",t,n);dr(c,o,l,!0)&&c.top>l&&(a=i[s-1])}return a}function vr(e,t,r,n,i,o,l){for(var s=fr(e,t,n,l),a=s.begin,u=s.end,c=null,f=null,h=0;h<i.length;h++){var d=i[h];if(!(d.from>=u||d.to<=a)){var p=Yt(e,n,1!=d.level?Math.min(u,d.to)-1:Math.max(a,d.from)).right,g=p<o?o-p+1e9:p-o;(!c||f>g)&&(c=d,f=g)}}return c||(c=i[i.length-1]),c.from<a&&(c={from:a,to:c.to,level:c.level}),c.to>u&&(c={from:c.from,to:u,level:c.level}),c}function mr(e){if(null!=e.cachedTextHeight)return e.cachedTextHeight;if(null==hs){hs=n("pre");for(var i=0;i<49;++i)hs.appendChild(document.createTextNode("x")),hs.appendChild(n("br"));hs.appendChild(document.createTextNode("x"))}r(e.measure,hs);var o=hs.offsetHeight/50;return o>3&&(e.cachedTextHeight=o),t(e.measure),o||1}function yr(e){if(null!=e.cachedCharWidth)return e.cachedCharWidth;var t=n("span","xxxxxxxxxx"),i=n("pre",[t]);r(e.measure,i);var o=t.getBoundingClientRect(),l=(o.right-o.left)/10;return l>2&&(e.cachedCharWidth=l),l||10}function br(e){for(var t=e.display,r={},n={},i=t.gutters.clientLeft,o=t.gutters.firstChild,l=0;o;o=o.nextSibling,++l)r[e.options.gutters[l]]=o.offsetLeft+o.clientLeft+i,n[e.options.gutters[l]]=o.clientWidth;return{fixedPos:wr(t),gutterTotalWidth:t.gutters.offsetWidth,gutterLeft:r,gutterWidth:n,wrapperWidth:t.wrapper.clientWidth}}function wr(e){return e.scroller.getBoundingClientRect().left-e.sizer.getBoundingClientRect().left}function xr(e){var t=mr(e.display),r=e.options.lineWrapping,n=r&&Math.max(5,e.display.scroller.clientWidth/yr(e.display)-3);return function(i){if(ve(e.doc,i))return 0;var o=0;if(i.widgets)for(var l=0;l<i.widgets.length;l++)i.widgets[l].height&&(o+=i.widgets[l].height);return r?o+(Math.ceil(i.text.length/n)||1)*t:o+t}}function Cr(e){var t=e.doc,r=xr(e);t.iter(function(e){var t=r(e);t!=e.height&&A(e,t)})}function Sr(e,t,r,n){var i=e.display;if(!r&&"true"==Ee(t).getAttribute("cm-not-content"))return null;var o,l,s=i.lineSpace.getBoundingClientRect();try{o=t.clientX-s.left,l=t.clientY-s.top}catch(t){return null}var a,u=cr(e,o,l);if(n&&1==u.xRel&&(a=M(e.doc,u.line).text).length==u.ch){var c=f(a,a.length,e.options.tabSize)-a.length;u=E(u.line,Math.max(0,Math.round((o-It(e.display).left)/yr(e.display))-c))}return u}function Lr(e,t){if(t>=e.display.viewTo)return null;if((t-=e.display.viewFrom)<0)return null;for(var r=e.display.view,n=0;n<r.length;n++)if((t-=r[n].size)<0)return n}function kr(e){e.display.input.showSelection(e.display.input.prepareSelection())}function Tr(e,t){void 0===t&&(t=!0);for(var r=e.doc,n={},i=n.cursors=document.createDocumentFragment(),o=n.selection=document.createDocumentFragment(),l=0;l<r.sel.ranges.length;l++)if(t||l!=r.sel.primIndex){var s=r.sel.ranges[l];if(!(s.from().line>=e.display.viewTo||s.to().line<e.display.viewFrom)){var a=s.empty();(a||e.options.showCursorWhenSelecting)&&Mr(e,s.head,i),a||Or(e,s,o)}}return n}function Mr(e,t,r){var i=sr(e,t,"div",null,null,!e.options.singleCursorHeightPerLine),o=r.appendChild(n("div"," ","CodeMirror-cursor"));if(o.style.left=i.left+"px",o.style.top=i.top+"px",o.style.height=Math.max(0,i.bottom-i.top)*e.options.cursorHeight+"px",i.other){var l=r.appendChild(n("div"," ","CodeMirror-cursor CodeMirror-secondarycursor"));l.style.display="",l.style.left=i.other.left+"px",l.style.top=i.other.top+"px",l.style.height=.85*(i.other.bottom-i.other.top)+"px"}}function Nr(e,t){return e.top-t.top||e.left-t.left}function Or(e,t,r){function i(e,t,r,i){t<0&&(t=0),t=Math.round(t),i=Math.round(i),a.appendChild(n("div",null,"CodeMirror-selected","position: absolute; left: "+e+"px;\n                             top: "+t+"px; width: "+(null==r?f-e:r)+"px;\n                             height: "+(i-t)+"px"))}function o(t,r,n){function o(r,n){return lr(e,E(t,r),"div",u,n)}var l,a,u=M(s,t),h=u.text.length,d=Se(u,s.direction);return xe(d,r||0,null==n?h:n,function(t,s,p,g){var v=o(t,"ltr"==p?"left":"right"),m=o(s-1,"ltr"==p?"right":"left");if("ltr"==p){var y=null==r&&0==t?c:v.left,b=null==n&&s==h?f:m.right;m.top-v.top<=3?i(y,m.top,b-y,m.bottom):(i(y,v.top,null,v.bottom),v.bottom<m.top&&i(c,v.bottom,null,m.top),i(c,m.top,m.right,m.bottom))}else if(t<s){var w=null==r&&0==t?f:v.right,x=null==n&&s==h?c:m.left;if(m.top-v.top<=3)i(x,m.top,w-x,m.bottom);else{var C=c;if(g){var S=hr(e,u,null,t).end;C=o(S-(/\s/.test(u.text.charAt(S-1))?2:1),"left").left}i(C,v.top,w-C,v.bottom),v.bottom<m.top&&i(c,v.bottom,null,m.top);var L=null;d.length,L=o(hr(e,u,null,s).begin,"right").right-x,i(x,m.top,L,m.bottom)}}(!l||Nr(v,l)<0)&&(l=v),Nr(m,l)<0&&(l=m),(!a||Nr(v,a)<0)&&(a=v),Nr(m,a)<0&&(a=m)}),{start:l,end:a}}var l=e.display,s=e.doc,a=document.createDocumentFragment(),u=It(e.display),c=u.left,f=Math.max(l.sizerWidth,Rt(e)-l.sizer.offsetLeft)-u.right,h=t.from(),d=t.to();if(h.line==d.line)o(h.line,h.ch,d.ch);else{var p=M(s,h.line),g=M(s,d.line),v=fe(p)==fe(g),m=o(h.line,h.ch,v?p.text.length+1:null).end,y=o(d.line,v?0:null,d.ch).start;v&&(m.top<y.top-2?(i(m.right,m.top,null,m.bottom),i(c,y.top,y.left,y.bottom)):i(m.right,m.top,y.left-m.right,m.bottom)),m.bottom<y.top&&i(c,m.bottom,null,y.top)}r.appendChild(a)}function Ar(e){if(e.state.focused){var t=e.display;clearInterval(t.blinker);var r=!0;t.cursorDiv.style.visibility="",e.options.cursorBlinkRate>0?t.blinker=setInterval(function(){return t.cursorDiv.style.visibility=(r=!r)?"":"hidden"},e.options.cursorBlinkRate):e.options.cursorBlinkRate<0&&(t.cursorDiv.style.visibility="hidden")}}function Wr(e){e.state.focused||(e.display.input.focus(),Hr(e))}function Dr(e){e.state.delayingBlurEvent=!0,setTimeout(function(){e.state.delayingBlurEvent&&(e.state.delayingBlurEvent=!1,Fr(e))},100)}function Hr(e,t){e.state.delayingBlurEvent&&(e.state.delayingBlurEvent=!1),"nocursor"!=e.options.readOnly&&(e.state.focused||(Te(e,"focus",e,t),e.state.focused=!0,s(e.display.wrapper,"CodeMirror-focused"),e.curOp||e.display.selForContextMenu==e.doc.sel||(e.display.input.reset(),ml&&setTimeout(function(){return e.display.input.reset(!0)},20)),e.display.input.receivedFocus()),Ar(e))}function Fr(e,t){e.state.delayingBlurEvent||(e.state.focused&&(Te(e,"blur",e,t),e.state.focused=!1,Fl(e.display.wrapper,"CodeMirror-focused")),clearInterval(e.display.blinker),setTimeout(function(){e.state.focused||(e.display.shift=!1)},150))}function Er(e){for(var t=e.display,r=t.lineDiv.offsetTop,n=0;n<t.view.length;n++){var i=t.view[n],o=void 0;if(!i.hidden){if(gl&&vl<8){var l=i.node.offsetTop+i.node.offsetHeight;o=l-r,r=l}else{var s=i.node.getBoundingClientRect();o=s.bottom-s.top}var a=i.line.height-o;if(o<2&&(o=mr(t)),(a>.005||a<-.005)&&(A(i.line,o),Pr(i.line),i.rest))for(var u=0;u<i.rest.length;u++)Pr(i.rest[u])}}}function Pr(e){if(e.widgets)for(var t=0;t<e.widgets.length;++t)e.widgets[t].height=e.widgets[t].node.parentNode.offsetHeight}function Ir(e,t,r){var n=r&&null!=r.top?Math.max(0,r.top):e.scroller.scrollTop;n=Math.floor(n-Et(e));var i=r&&null!=r.bottom?r.bottom:n+e.wrapper.clientHeight,o=D(t,n),l=D(t,i);if(r&&r.ensure){var s=r.ensure.from.line,a=r.ensure.to.line;s<o?(o=s,l=D(t,ye(M(t,s))+e.wrapper.clientHeight)):Math.min(a,t.lastLine())>=l&&(o=D(t,ye(M(t,a))-e.wrapper.clientHeight),l=a)}return{from:o,to:Math.max(l,o+1)}}function zr(e){var t=e.display,r=t.view;if(t.alignWidgets||t.gutters.firstChild&&e.options.fixedGutter){for(var n=wr(t)-t.scroller.scrollLeft+e.doc.scrollLeft,i=t.gutters.offsetWidth,o=n+"px",l=0;l<r.length;l++)if(!r[l].hidden){e.options.fixedGutter&&(r[l].gutter&&(r[l].gutter.style.left=o),r[l].gutterBackground&&(r[l].gutterBackground.style.left=o));var s=r[l].alignable;if(s)for(var a=0;a<s.length;a++)s[a].style.left=o}e.options.fixedGutter&&(t.gutters.style.left=n+i+"px")}}function Rr(e){if(!e.options.lineNumbers)return!1;var t=e.doc,r=F(e.options,t.first+t.size-1),i=e.display;if(r.length!=i.lineNumChars){var o=i.measure.appendChild(n("div",[n("div",r)],"CodeMirror-linenumber CodeMirror-gutter-elt")),l=o.firstChild.offsetWidth,s=o.offsetWidth-l;return i.lineGutter.style.width="",i.lineNumInnerWidth=Math.max(l,i.lineGutter.offsetWidth-s)+1,i.lineNumWidth=i.lineNumInnerWidth+s,i.lineNumChars=i.lineNumInnerWidth?r.length:-1,i.lineGutter.style.width=i.lineNumWidth+"px",Wn(e),!0}return!1}function Br(e,t){if(!Me(e,"scrollCursorIntoView")){var r=e.display,i=r.sizer.getBoundingClientRect(),o=null;if(t.top+i.top<0?o=!0:t.bottom+i.top>(window.innerHeight||document.documentElement.clientHeight)&&(o=!1),null!=o&&!Sl){var l=n("div","​",null,"position: absolute;\n                         top: "+(t.top-r.viewOffset-Et(e.display))+"px;\n                         height: "+(t.bottom-t.top+zt(e)+r.barHeight)+"px;\n                         left: "+t.left+"px; width: "+Math.max(2,t.right-t.left)+"px;");e.display.lineSpace.appendChild(l),l.scrollIntoView(o),e.display.lineSpace.removeChild(l)}}}function Gr(e,t,r,n){null==n&&(n=0);var i;e.options.lineWrapping||t!=r||(r="before"==(t=t.ch?E(t.line,"before"==t.sticky?t.ch-1:t.ch,"after"):t).sticky?E(t.line,t.ch+1,"before"):t);for(var o=0;o<5;o++){var l=!1,s=sr(e,t),a=r&&r!=t?sr(e,r):s,u=Vr(e,i={left:Math.min(s.left,a.left),top:Math.min(s.top,a.top)-n,right:Math.max(s.left,a.left),bottom:Math.max(s.bottom,a.bottom)+n}),c=e.doc.scrollTop,f=e.doc.scrollLeft;if(null!=u.scrollTop&&(qr(e,u.scrollTop),Math.abs(e.doc.scrollTop-c)>1&&(l=!0)),null!=u.scrollLeft&&(Qr(e,u.scrollLeft),Math.abs(e.doc.scrollLeft-f)>1&&(l=!0)),!l)break}return i}function Ur(e,t){var r=Vr(e,t);null!=r.scrollTop&&qr(e,r.scrollTop),null!=r.scrollLeft&&Qr(e,r.scrollLeft)}function Vr(e,t){var r=e.display,n=mr(e.display);t.top<0&&(t.top=0);var i=e.curOp&&null!=e.curOp.scrollTop?e.curOp.scrollTop:r.scroller.scrollTop,o=Bt(e),l={};t.bottom-t.top>o&&(t.bottom=t.top+o);var s=e.doc.height+Pt(r),a=t.top<n,u=t.bottom>s-n;if(t.top<i)l.scrollTop=a?0:t.top;else if(t.bottom>i+o){var c=Math.min(t.top,(u?s:t.bottom)-o);c!=i&&(l.scrollTop=c)}var f=e.curOp&&null!=e.curOp.scrollLeft?e.curOp.scrollLeft:r.scroller.scrollLeft,h=Rt(e)-(e.options.fixedGutter?r.gutters.offsetWidth:0),d=t.right-t.left>h;return d&&(t.right=t.left+h),t.left<10?l.scrollLeft=0:t.left<f?l.scrollLeft=Math.max(0,t.left-(d?0:10)):t.right>h+f-3&&(l.scrollLeft=t.right+(d?0:10)-h),l}function Kr(e,t){null!=t&&(_r(e),e.curOp.scrollTop=(null==e.curOp.scrollTop?e.doc.scrollTop:e.curOp.scrollTop)+t)}function jr(e){_r(e);var t=e.getCursor();e.curOp.scrollToPos={from:t,to:t,margin:e.options.cursorScrollMargin}}function Xr(e,t,r){null==t&&null==r||_r(e),null!=t&&(e.curOp.scrollLeft=t),null!=r&&(e.curOp.scrollTop=r)}function Yr(e,t){_r(e),e.curOp.scrollToPos=t}function _r(e){var t=e.curOp.scrollToPos;t&&(e.curOp.scrollToPos=null,$r(e,ar(e,t.from),ar(e,t.to),t.margin))}function $r(e,t,r,n){var i=Vr(e,{left:Math.min(t.left,r.left),top:Math.min(t.top,r.top)-n,right:Math.max(t.right,r.right),bottom:Math.max(t.bottom,r.bottom)+n});Xr(e,i.scrollLeft,i.scrollTop)}function qr(e,t){Math.abs(e.doc.scrollTop-t)<2||(fl||On(e,{top:t}),Zr(e,t,!0),fl&&On(e),Cn(e,100))}function Zr(e,t,r){t=Math.min(e.display.scroller.scrollHeight-e.display.scroller.clientHeight,t),(e.display.scroller.scrollTop!=t||r)&&(e.doc.scrollTop=t,e.display.scrollbars.setScrollTop(t),e.display.scroller.scrollTop!=t&&(e.display.scroller.scrollTop=t))}function Qr(e,t,r,n){t=Math.min(t,e.display.scroller.scrollWidth-e.display.scroller.clientWidth),(r?t==e.doc.scrollLeft:Math.abs(e.doc.scrollLeft-t)<2)&&!n||(e.doc.scrollLeft=t,zr(e),e.display.scroller.scrollLeft!=t&&(e.display.scroller.scrollLeft=t),e.display.scrollbars.setScrollLeft(t))}function Jr(e){var t=e.display,r=t.gutters.offsetWidth,n=Math.round(e.doc.height+Pt(e.display));return{clientHeight:t.scroller.clientHeight,viewHeight:t.wrapper.clientHeight,scrollWidth:t.scroller.scrollWidth,clientWidth:t.scroller.clientWidth,viewWidth:t.wrapper.clientWidth,barLeft:e.options.fixedGutter?r:0,docHeight:n,scrollHeight:n+zt(e)+t.barHeight,nativeBarWidth:t.nativeBarWidth,gutterWidth:r}}function en(e,t){t||(t=Jr(e));var r=e.display.barWidth,n=e.display.barHeight;tn(e,t);for(var i=0;i<4&&r!=e.display.barWidth||n!=e.display.barHeight;i++)r!=e.display.barWidth&&e.options.lineWrapping&&Er(e),tn(e,Jr(e)),r=e.display.barWidth,n=e.display.barHeight}function tn(e,t){var r=e.display,n=r.scrollbars.update(t);r.sizer.style.paddingRight=(r.barWidth=n.right)+"px",r.sizer.style.paddingBottom=(r.barHeight=n.bottom)+"px",r.heightForcer.style.borderBottom=n.bottom+"px solid transparent",n.right&&n.bottom?(r.scrollbarFiller.style.display="block",r.scrollbarFiller.style.height=n.bottom+"px",r.scrollbarFiller.style.width=n.right+"px"):r.scrollbarFiller.style.display="",n.bottom&&e.options.coverGutterNextToScrollbar&&e.options.fixedGutter?(r.gutterFiller.style.display="block",r.gutterFiller.style.height=n.bottom+"px",r.gutterFiller.style.width=t.gutterWidth+"px"):r.gutterFiller.style.display=""}function rn(e){e.display.scrollbars&&(e.display.scrollbars.clear(),e.display.scrollbars.addClass&&Fl(e.display.wrapper,e.display.scrollbars.addClass)),e.display.scrollbars=new ws[e.options.scrollbarStyle](function(t){e.display.wrapper.insertBefore(t,e.display.scrollbarFiller),Ql(t,"mousedown",function(){e.state.focused&&setTimeout(function(){return e.display.input.focus()},0)}),t.setAttribute("cm-not-content","true")},function(t,r){"horizontal"==r?Qr(e,t):qr(e,t)},e),e.display.scrollbars.addClass&&s(e.display.wrapper,e.display.scrollbars.addClass)}function nn(e){e.curOp={cm:e,viewChanged:!1,startHeight:e.doc.height,forceUpdate:!1,updateInput:null,typing:!1,changeObjs:null,cursorActivityHandlers:null,cursorActivityCalled:0,selectionChanged:!1,updateMaxLine:!1,scrollLeft:null,scrollTop:null,scrollToPos:null,focus:!1,id:++xs},vt(e.curOp)}function on(e){yt(e.curOp,function(e){for(var t=0;t<e.ops.length;t++)e.ops[t].cm.curOp=null;ln(e)})}function ln(e){for(var t=e.ops,r=0;r<t.length;r++)sn(t[r]);for(var n=0;n<t.length;n++)an(t[n]);for(var i=0;i<t.length;i++)un(t[i]);for(var o=0;o<t.length;o++)cn(t[o]);for(var l=0;l<t.length;l++)fn(t[l])}function sn(e){var t=e.cm,r=t.display;Ln(t),e.updateMaxLine&&we(t),e.mustUpdate=e.viewChanged||e.forceUpdate||null!=e.scrollTop||e.scrollToPos&&(e.scrollToPos.from.line<r.viewFrom||e.scrollToPos.to.line>=r.viewTo)||r.maxLineChanged&&t.options.lineWrapping,e.update=e.mustUpdate&&new Cs(t,e.mustUpdate&&{top:e.scrollTop,ensure:e.scrollToPos},e.forceUpdate)}function an(e){e.updatedDisplay=e.mustUpdate&&Mn(e.cm,e.update)}function un(e){var t=e.cm,r=t.display;e.updatedDisplay&&Er(t),e.barMeasure=Jr(t),r.maxLineChanged&&!t.options.lineWrapping&&(e.adjustWidthTo=Kt(t,r.maxLine,r.maxLine.text.length).left+3,t.display.sizerWidth=e.adjustWidthTo,e.barMeasure.scrollWidth=Math.max(r.scroller.clientWidth,r.sizer.offsetLeft+e.adjustWidthTo+zt(t)+t.display.barWidth),e.maxScrollLeft=Math.max(0,r.sizer.offsetLeft+e.adjustWidthTo-Rt(t))),(e.updatedDisplay||e.selectionChanged)&&(e.preparedSelection=r.input.prepareSelection())}function cn(e){var t=e.cm;null!=e.adjustWidthTo&&(t.display.sizer.style.minWidth=e.adjustWidthTo+"px",e.maxScrollLeft<t.doc.scrollLeft&&Qr(t,Math.min(t.display.scroller.scrollLeft,e.maxScrollLeft),!0),t.display.maxLineChanged=!1);var r=e.focus&&e.focus==l();e.preparedSelection&&t.display.input.showSelection(e.preparedSelection,r),(e.updatedDisplay||e.startHeight!=t.doc.height)&&en(t,e.barMeasure),e.updatedDisplay&&Dn(t,e.barMeasure),e.selectionChanged&&Ar(t),t.state.focused&&e.updateInput&&t.display.input.reset(e.typing),r&&Wr(e.cm)}function fn(e){var t=e.cm,r=t.display,n=t.doc;e.updatedDisplay&&Nn(t,e.update),null==r.wheelStartX||null==e.scrollTop&&null==e.scrollLeft&&!e.scrollToPos||(r.wheelStartX=r.wheelStartY=null),null!=e.scrollTop&&Zr(t,e.scrollTop,e.forceScroll),null!=e.scrollLeft&&Qr(t,e.scrollLeft,!0,!0),e.scrollToPos&&Br(t,Gr(t,U(n,e.scrollToPos.from),U(n,e.scrollToPos.to),e.scrollToPos.margin));var i=e.maybeHiddenMarkers,o=e.maybeUnhiddenMarkers;if(i)for(var l=0;l<i.length;++l)i[l].lines.length||Te(i[l],"hide");if(o)for(var s=0;s<o.length;++s)o[s].lines.length&&Te(o[s],"unhide");r.wrapper.offsetHeight&&(n.scrollTop=t.display.scroller.scrollTop),e.changeObjs&&Te(t,"changes",t,e.changeObjs),e.update&&e.update.finish()}function hn(e,t){if(e.curOp)return t();nn(e);try{return t()}finally{on(e)}}function dn(e,t){return function(){if(e.curOp)return t.apply(e,arguments);nn(e);try{return t.apply(e,arguments)}finally{on(e)}}}function pn(e){return function(){if(this.curOp)return e.apply(this,arguments);nn(this);try{return e.apply(this,arguments)}finally{on(this)}}}function gn(e){return function(){var t=this.cm;if(!t||t.curOp)return e.apply(this,arguments);nn(t);try{return e.apply(this,arguments)}finally{on(t)}}}function vn(e,t,r,n){null==t&&(t=e.doc.first),null==r&&(r=e.doc.first+e.doc.size),n||(n=0);var i=e.display;if(n&&r<i.viewTo&&(null==i.updateLineNumbers||i.updateLineNumbers>t)&&(i.updateLineNumbers=t),e.curOp.viewChanged=!0,t>=i.viewTo)_l&&pe(e.doc,t)<i.viewTo&&yn(e);else if(r<=i.viewFrom)_l&&ge(e.doc,r+n)>i.viewFrom?yn(e):(i.viewFrom+=n,i.viewTo+=n);else if(t<=i.viewFrom&&r>=i.viewTo)yn(e);else if(t<=i.viewFrom){var o=bn(e,r,r+n,1);o?(i.view=i.view.slice(o.index),i.viewFrom=o.lineN,i.viewTo+=n):yn(e)}else if(r>=i.viewTo){var l=bn(e,t,t,-1);l?(i.view=i.view.slice(0,l.index),i.viewTo=l.lineN):yn(e)}else{var s=bn(e,t,t,-1),a=bn(e,r,r+n,1);s&&a?(i.view=i.view.slice(0,s.index).concat(gt(e,s.lineN,a.lineN)).concat(i.view.slice(a.index)),i.viewTo+=n):yn(e)}var u=i.externalMeasured;u&&(r<u.lineN?u.lineN+=n:t<u.lineN+u.size&&(i.externalMeasured=null))}function mn(e,t,r){e.curOp.viewChanged=!0;var n=e.display,i=e.display.externalMeasured;if(i&&t>=i.lineN&&t<i.lineN+i.size&&(n.externalMeasured=null),!(t<n.viewFrom||t>=n.viewTo)){var o=n.view[Lr(e,t)];if(null!=o.node){var l=o.changes||(o.changes=[]);-1==h(l,r)&&l.push(r)}}}function yn(e){e.display.viewFrom=e.display.viewTo=e.doc.first,e.display.view=[],e.display.viewOffset=0}function bn(e,t,r,n){var i,o=Lr(e,t),l=e.display.view;if(!_l||r==e.doc.first+e.doc.size)return{index:o,lineN:r};for(var s=e.display.viewFrom,a=0;a<o;a++)s+=l[a].size;if(s!=t){if(n>0){if(o==l.length-1)return null;i=s+l[o].size-t,o++}else i=s-t;t+=i,r+=i}for(;pe(e.doc,r)!=r;){if(o==(n<0?0:l.length-1))return null;r+=n*l[o-(n<0?1:0)].size,o+=n}return{index:o,lineN:r}}function wn(e,t,r){var n=e.display;0==n.view.length||t>=n.viewTo||r<=n.viewFrom?(n.view=gt(e,t,r),n.viewFrom=t):(n.viewFrom>t?n.view=gt(e,t,n.viewFrom).concat(n.view):n.viewFrom<t&&(n.view=n.view.slice(Lr(e,t))),n.viewFrom=t,n.viewTo<r?n.view=n.view.concat(gt(e,n.viewTo,r)):n.viewTo>r&&(n.view=n.view.slice(0,Lr(e,r)))),n.viewTo=r}function xn(e){for(var t=e.display.view,r=0,n=0;n<t.length;n++){var i=t[n];i.hidden||i.node&&!i.changes||++r}return r}function Cn(e,t){e.doc.highlightFrontier<e.display.viewTo&&e.state.highlight.set(t,u(Sn,e))}function Sn(e){var t=e.doc;if(!(t.highlightFrontier>=e.display.viewTo)){var r=+new Date+e.options.workTime,n=$e(e,t.highlightFrontier),i=[];t.iter(n.line,Math.min(t.first+t.size,e.display.viewTo+500),function(o){if(n.line>=e.display.viewFrom){var l=o.styles,s=o.text.length>e.options.maxHighlightLength?Ke(t.mode,n.state):null,a=Ye(e,o,n,!0);s&&(n.state=s),o.styles=a.styles;var u=o.styleClasses,c=a.classes;c?o.styleClasses=c:u&&(o.styleClasses=null);for(var f=!l||l.length!=o.styles.length||u!=c&&(!u||!c||u.bgClass!=c.bgClass||u.textClass!=c.textClass),h=0;!f&&h<l.length;++h)f=l[h]!=o.styles[h];f&&i.push(n.line),o.stateAfter=n.save(),n.nextLine()}else o.text.length<=e.options.maxHighlightLength&&qe(e,o.text,n),o.stateAfter=n.line%5==0?n.save():null,n.nextLine();if(+new Date>r)return Cn(e,e.options.workDelay),!0}),t.highlightFrontier=n.line,t.modeFrontier=Math.max(t.modeFrontier,n.line),i.length&&hn(e,function(){for(var t=0;t<i.length;t++)mn(e,i[t],"text")})}}function Ln(e){var t=e.display;!t.scrollbarsClipped&&t.scroller.offsetWidth&&(t.nativeBarWidth=t.scroller.offsetWidth-t.scroller.clientWidth,t.heightForcer.style.height=zt(e)+"px",t.sizer.style.marginBottom=-t.nativeBarWidth+"px",t.sizer.style.borderRightWidth=zt(e)+"px",t.scrollbarsClipped=!0)}function kn(e){if(e.hasFocus())return null;var t=l();if(!t||!o(e.display.lineDiv,t))return null;var r={activeElt:t};if(window.getSelection){var n=window.getSelection();n.anchorNode&&n.extend&&o(e.display.lineDiv,n.anchorNode)&&(r.anchorNode=n.anchorNode,r.anchorOffset=n.anchorOffset,r.focusNode=n.focusNode,r.focusOffset=n.focusOffset)}return r}function Tn(e){if(e&&e.activeElt&&e.activeElt!=l()&&(e.activeElt.focus(),e.anchorNode&&o(document.body,e.anchorNode)&&o(document.body,e.focusNode))){var t=window.getSelection(),r=document.createRange();r.setEnd(e.anchorNode,e.anchorOffset),r.collapse(!1),t.removeAllRanges(),t.addRange(r),t.extend(e.focusNode,e.focusOffset)}}function Mn(e,r){var n=e.display,i=e.doc;if(r.editorIsHidden)return yn(e),!1;if(!r.force&&r.visible.from>=n.viewFrom&&r.visible.to<=n.viewTo&&(null==n.updateLineNumbers||n.updateLineNumbers>=n.viewTo)&&n.renderedView==n.view&&0==xn(e))return!1;Rr(e)&&(yn(e),r.dims=br(e));var o=i.first+i.size,l=Math.max(r.visible.from-e.options.viewportMargin,i.first),s=Math.min(o,r.visible.to+e.options.viewportMargin);n.viewFrom<l&&l-n.viewFrom<20&&(l=Math.max(i.first,n.viewFrom)),n.viewTo>s&&n.viewTo-s<20&&(s=Math.min(o,n.viewTo)),_l&&(l=pe(e.doc,l),s=ge(e.doc,s));var a=l!=n.viewFrom||s!=n.viewTo||n.lastWrapHeight!=r.wrapperHeight||n.lastWrapWidth!=r.wrapperWidth;wn(e,l,s),n.viewOffset=ye(M(e.doc,n.viewFrom)),e.display.mover.style.top=n.viewOffset+"px";var u=xn(e);if(!a&&0==u&&!r.force&&n.renderedView==n.view&&(null==n.updateLineNumbers||n.updateLineNumbers>=n.viewTo))return!1;var c=kn(e);return u>4&&(n.lineDiv.style.display="none"),An(e,n.updateLineNumbers,r.dims),u>4&&(n.lineDiv.style.display=""),n.renderedView=n.view,Tn(c),t(n.cursorDiv),t(n.selectionDiv),n.gutters.style.height=n.sizer.style.minHeight=0,a&&(n.lastWrapHeight=r.wrapperHeight,n.lastWrapWidth=r.wrapperWidth,Cn(e,400)),n.updateLineNumbers=null,!0}function Nn(e,t){for(var r=t.viewport,n=!0;(n&&e.options.lineWrapping&&t.oldDisplayWidth!=Rt(e)||(r&&null!=r.top&&(r={top:Math.min(e.doc.height+Pt(e.display)-Bt(e),r.top)}),t.visible=Ir(e.display,e.doc,r),!(t.visible.from>=e.display.viewFrom&&t.visible.to<=e.display.viewTo)))&&Mn(e,t);n=!1){Er(e);var i=Jr(e);kr(e),en(e,i),Dn(e,i),t.force=!1}t.signal(e,"update",e),e.display.viewFrom==e.display.reportedViewFrom&&e.display.viewTo==e.display.reportedViewTo||(t.signal(e,"viewportChange",e,e.display.viewFrom,e.display.viewTo),e.display.reportedViewFrom=e.display.viewFrom,e.display.reportedViewTo=e.display.viewTo)}function On(e,t){var r=new Cs(e,t);if(Mn(e,r)){Er(e),Nn(e,r);var n=Jr(e);kr(e),en(e,n),Dn(e,n),r.finish()}}function An(e,r,n){function i(t){var r=t.nextSibling;return ml&&Ml&&e.display.currentWheelTarget==t?t.style.display="none":t.parentNode.removeChild(t),r}for(var o=e.display,l=e.options.lineNumbers,s=o.lineDiv,a=s.firstChild,u=o.view,c=o.viewFrom,f=0;f<u.length;f++){var d=u[f];if(d.hidden);else if(d.node&&d.node.parentNode==s){for(;a!=d.node;)a=i(a);var p=l&&null!=r&&r<=c&&d.lineNumber;d.changes&&(h(d.changes,"gutter")>-1&&(p=!1),xt(e,d,c,n)),p&&(t(d.lineNumber),d.lineNumber.appendChild(document.createTextNode(F(e.options,c)))),a=d.node.nextSibling}else{var g=Ot(e,d,c,n);s.insertBefore(g,a)}c+=d.size}for(;a;)a=i(a)}function Wn(e){var t=e.display.gutters.offsetWidth;e.display.sizer.style.marginLeft=t+"px"}function Dn(e,t){e.display.sizer.style.minHeight=t.docHeight+"px",e.display.heightForcer.style.top=t.docHeight+"px",e.display.gutters.style.height=t.docHeight+e.display.barHeight+zt(e)+"px"}function Hn(e){var r=e.display.gutters,i=e.options.gutters;t(r);for(var o=0;o<i.length;++o){var l=i[o],s=r.appendChild(n("div",null,"CodeMirror-gutter "+l));"CodeMirror-linenumbers"==l&&(e.display.lineGutter=s,s.style.width=(e.display.lineNumWidth||1)+"px")}r.style.display=o?"":"none",Wn(e)}function Fn(e){var t=h(e.gutters,"CodeMirror-linenumbers");-1==t&&e.lineNumbers?e.gutters=e.gutters.concat(["CodeMirror-linenumbers"]):t>-1&&!e.lineNumbers&&(e.gutters=e.gutters.slice(0),e.gutters.splice(t,1))}function En(e){var t=e.wheelDeltaX,r=e.wheelDeltaY;return null==t&&e.detail&&e.axis==e.HORIZONTAL_AXIS&&(t=e.detail),null==r&&e.detail&&e.axis==e.VERTICAL_AXIS?r=e.detail:null==r&&(r=e.wheelDelta),{x:t,y:r}}function Pn(e){var t=En(e);return t.x*=Ls,t.y*=Ls,t}function In(e,t){var r=En(t),n=r.x,i=r.y,o=e.display,l=o.scroller,s=l.scrollWidth>l.clientWidth,a=l.scrollHeight>l.clientHeight;if(n&&s||i&&a){if(i&&Ml&&ml)e:for(var u=t.target,c=o.view;u!=l;u=u.parentNode)for(var f=0;f<c.length;f++)if(c[f].node==u){e.display.currentWheelTarget=u;break e}if(n&&!fl&&!wl&&null!=Ls)return i&&a&&qr(e,Math.max(0,l.scrollTop+i*Ls)),Qr(e,Math.max(0,l.scrollLeft+n*Ls)),(!i||i&&a)&&We(t),void(o.wheelStartX=null);if(i&&null!=Ls){var h=i*Ls,d=e.doc.scrollTop,p=d+o.wrapper.clientHeight;h<0?d=Math.max(0,d+h-50):p=Math.min(e.doc.height,p+h+50),On(e,{top:d,bottom:p})}Ss<20&&(null==o.wheelStartX?(o.wheelStartX=l.scrollLeft,o.wheelStartY=l.scrollTop,o.wheelDX=n,o.wheelDY=i,setTimeout(function(){if(null!=o.wheelStartX){var e=l.scrollLeft-o.wheelStartX,t=l.scrollTop-o.wheelStartY,r=t&&o.wheelDY&&t/o.wheelDY||e&&o.wheelDX&&e/o.wheelDX;o.wheelStartX=o.wheelStartY=null,r&&(Ls=(Ls*Ss+r)/(Ss+1),++Ss)}},200)):(o.wheelDX+=n,o.wheelDY+=i))}}function zn(e,t){var r=e[t];e.sort(function(e,t){return P(e.from(),t.from())}),t=h(e,r);for(var n=1;n<e.length;n++){var i=e[n],o=e[n-1];if(P(o.to(),i.from())>=0){var l=B(o.from(),i.from()),s=R(o.to(),i.to()),a=o.empty()?i.from()==i.head:o.from()==o.head;n<=t&&--t,e.splice(--n,2,new Ts(a?s:l,a?l:s))}}return new ks(e,t)}function Rn(e,t){return new ks([new Ts(e,t||e)],0)}function Bn(e){return e.text?E(e.from.line+e.text.length-1,g(e.text).length+(1==e.text.length?e.from.ch:0)):e.to}function Gn(e,t){if(P(e,t.from)<0)return e;if(P(e,t.to)<=0)return Bn(t);var r=e.line+t.text.length-(t.to.line-t.from.line)-1,n=e.ch;return e.line==t.to.line&&(n+=Bn(t).ch-t.to.ch),E(r,n)}function Un(e,t){for(var r=[],n=0;n<e.sel.ranges.length;n++){var i=e.sel.ranges[n];r.push(new Ts(Gn(i.anchor,t),Gn(i.head,t)))}return zn(r,e.sel.primIndex)}function Vn(e,t,r){return e.line==t.line?E(r.line,e.ch-t.ch+r.ch):E(r.line+(e.line-t.line),e.ch)}function Kn(e,t,r){for(var n=[],i=E(e.first,0),o=i,l=0;l<t.length;l++){var s=t[l],a=Vn(s.from,i,o),u=Vn(Bn(s),i,o);if(i=s.to,o=u,"around"==r){var c=e.sel.ranges[l],f=P(c.head,c.anchor)<0;n[l]=new Ts(f?u:a,f?a:u)}else n[l]=new Ts(a,a)}return new ks(n,e.sel.primIndex)}function jn(e){e.doc.mode=Ue(e.options,e.doc.modeOption),Xn(e)}function Xn(e){e.doc.iter(function(e){e.stateAfter&&(e.stateAfter=null),e.styles&&(e.styles=null)}),e.doc.modeFrontier=e.doc.highlightFrontier=e.doc.first,Cn(e,100),e.state.modeGen++,e.curOp&&vn(e)}function Yn(e,t){return 0==t.from.ch&&0==t.to.ch&&""==g(t.text)&&(!e.cm||e.cm.options.wholeLineUpdateBefore)}function _n(e,t,r,n){function i(e){return r?r[e]:null}function o(e,r,i){it(e,r,i,n),bt(e,"change",e,t)}function l(e,t){for(var r=[],o=e;o<t;++o)r.push(new fs(u[o],i(o),n));return r}var s=t.from,a=t.to,u=t.text,c=M(e,s.line),f=M(e,a.line),h=g(u),d=i(u.length-1),p=a.line-s.line;if(t.full)e.insert(0,l(0,u.length)),e.remove(u.length,e.size-u.length);else if(Yn(e,t)){var v=l(0,u.length-1);o(f,f.text,d),p&&e.remove(s.line,p),v.length&&e.insert(s.line,v)}else if(c==f)if(1==u.length)o(c,c.text.slice(0,s.ch)+h+c.text.slice(a.ch),d);else{var m=l(1,u.length-1);m.push(new fs(h+c.text.slice(a.ch),d,n)),o(c,c.text.slice(0,s.ch)+u[0],i(0)),e.insert(s.line+1,m)}else if(1==u.length)o(c,c.text.slice(0,s.ch)+u[0]+f.text.slice(a.ch),i(0)),e.remove(s.line+1,p);else{o(c,c.text.slice(0,s.ch)+u[0],i(0)),o(f,h+f.text.slice(a.ch),d);var y=l(1,u.length-1);p>1&&e.remove(s.line+1,p-1),e.insert(s.line+1,y)}bt(e,"change",e,t)}function $n(e,t,r){function n(e,i,o){if(e.linked)for(var l=0;l<e.linked.length;++l){var s=e.linked[l];if(s.doc!=i){var a=o&&s.sharedHist;r&&!a||(t(s.doc,a),n(s.doc,e,a))}}}n(e,null,!0)}function qn(e,t){if(t.cm)throw new Error("This document is already in use.");e.doc=t,t.cm=e,Cr(e),jn(e),Zn(e),e.options.lineWrapping||we(e),e.options.mode=t.modeOption,vn(e)}function Zn(e){("rtl"==e.doc.direction?s:Fl)(e.display.lineDiv,"CodeMirror-rtl")}function Qn(e){hn(e,function(){Zn(e),vn(e)})}function Jn(e){this.done=[],this.undone=[],this.undoDepth=1/0,this.lastModTime=this.lastSelTime=0,this.lastOp=this.lastSelOp=null,this.lastOrigin=this.lastSelOrigin=null,this.generation=this.maxGeneration=e||1}function ei(e,t){var r={from:z(t.from),to:Bn(t),text:N(e,t.from,t.to)};return si(e,r,t.from.line,t.to.line+1),$n(e,function(e){return si(e,r,t.from.line,t.to.line+1)},!0),r}function ti(e){for(;e.length&&g(e).ranges;)e.pop()}function ri(e,t){return t?(ti(e.done),g(e.done)):e.done.length&&!g(e.done).ranges?g(e.done):e.done.length>1&&!e.done[e.done.length-2].ranges?(e.done.pop(),g(e.done)):void 0}function ni(e,t,r,n){var i=e.history;i.undone.length=0;var o,l,s=+new Date;if((i.lastOp==n||i.lastOrigin==t.origin&&t.origin&&("+"==t.origin.charAt(0)&&e.cm&&i.lastModTime>s-e.cm.options.historyEventDelay||"*"==t.origin.charAt(0)))&&(o=ri(i,i.lastOp==n)))l=g(o.changes),0==P(t.from,t.to)&&0==P(t.from,l.to)?l.to=Bn(t):o.changes.push(ei(e,t));else{var a=g(i.done);for(a&&a.ranges||li(e.sel,i.done),o={changes:[ei(e,t)],generation:i.generation},i.done.push(o);i.done.length>i.undoDepth;)i.done.shift(),i.done[0].ranges||i.done.shift()}i.done.push(r),i.generation=++i.maxGeneration,i.lastModTime=i.lastSelTime=s,i.lastOp=i.lastSelOp=n,i.lastOrigin=i.lastSelOrigin=t.origin,l||Te(e,"historyAdded")}function ii(e,t,r,n){var i=t.charAt(0);return"*"==i||"+"==i&&r.ranges.length==n.ranges.length&&r.somethingSelected()==n.somethingSelected()&&new Date-e.history.lastSelTime<=(e.cm?e.cm.options.historyEventDelay:500)}function oi(e,t,r,n){var i=e.history,o=n&&n.origin;r==i.lastSelOp||o&&i.lastSelOrigin==o&&(i.lastModTime==i.lastSelTime&&i.lastOrigin==o||ii(e,o,g(i.done),t))?i.done[i.done.length-1]=t:li(t,i.done),i.lastSelTime=+new Date,i.lastSelOrigin=o,i.lastSelOp=r,n&&!1!==n.clearRedo&&ti(i.undone)}function li(e,t){var r=g(t);r&&r.ranges&&r.equals(e)||t.push(e)}function si(e,t,r,n){var i=t["spans_"+e.id],o=0;e.iter(Math.max(e.first,r),Math.min(e.first+e.size,n),function(r){r.markedSpans&&((i||(i=t["spans_"+e.id]={}))[o]=r.markedSpans),++o})}function ai(e){if(!e)return null;for(var t,r=0;r<e.length;++r)e[r].marker.explicitlyCleared?t||(t=e.slice(0,r)):t&&t.push(e[r]);return t?t.length?t:null:e}function ui(e,t){var r=t["spans_"+e.id];if(!r)return null;for(var n=[],i=0;i<t.text.length;++i)n.push(ai(r[i]));return n}function ci(e,t){var r=ui(e,t),n=J(e,t);if(!r)return n;if(!n)return r;for(var i=0;i<r.length;++i){var o=r[i],l=n[i];if(o&&l)e:for(var s=0;s<l.length;++s){for(var a=l[s],u=0;u<o.length;++u)if(o[u].marker==a.marker)continue e;o.push(a)}else l&&(r[i]=l)}return r}function fi(e,t,r){for(var n=[],i=0;i<e.length;++i){var o=e[i];if(o.ranges)n.push(r?ks.prototype.deepCopy.call(o):o);else{var l=o.changes,s=[];n.push({changes:s});for(var a=0;a<l.length;++a){var u=l[a],c=void 0;if(s.push({from:u.from,to:u.to,text:u.text}),t)for(var f in u)(c=f.match(/^spans_(\d+)$/))&&h(t,Number(c[1]))>-1&&(g(s)[f]=u[f],delete u[f])}}}return n}function hi(e,t,r,n){if(n){var i=e.anchor;if(r){var o=P(t,i)<0;o!=P(r,i)<0?(i=t,t=r):o!=P(t,r)<0&&(t=r)}return new Ts(i,t)}return new Ts(r||t,t)}function di(e,t,r,n,i){null==i&&(i=e.cm&&(e.cm.display.shift||e.extend)),bi(e,new ks([hi(e.sel.primary(),t,r,i)],0),n)}function pi(e,t,r){for(var n=[],i=e.cm&&(e.cm.display.shift||e.extend),o=0;o<e.sel.ranges.length;o++)n[o]=hi(e.sel.ranges[o],t[o],null,i);bi(e,zn(n,e.sel.primIndex),r)}function gi(e,t,r,n){var i=e.sel.ranges.slice(0);i[t]=r,bi(e,zn(i,e.sel.primIndex),n)}function vi(e,t,r,n){bi(e,Rn(t,r),n)}function mi(e,t,r){var n={ranges:t.ranges,update:function(t){var r=this;this.ranges=[];for(var n=0;n<t.length;n++)r.ranges[n]=new Ts(U(e,t[n].anchor),U(e,t[n].head))},origin:r&&r.origin};return Te(e,"beforeSelectionChange",e,n),e.cm&&Te(e.cm,"beforeSelectionChange",e.cm,n),n.ranges!=t.ranges?zn(n.ranges,n.ranges.length-1):t}function yi(e,t,r){var n=e.history.done,i=g(n);i&&i.ranges?(n[n.length-1]=t,wi(e,t,r)):bi(e,t,r)}function bi(e,t,r){wi(e,t,r),oi(e,e.sel,e.cm?e.cm.curOp.id:NaN,r)}function wi(e,t,r){(Oe(e,"beforeSelectionChange")||e.cm&&Oe(e.cm,"beforeSelectionChange"))&&(t=mi(e,t,r)),xi(e,Si(e,t,r&&r.bias||(P(t.primary().head,e.sel.primary().head)<0?-1:1),!0)),r&&!1===r.scroll||!e.cm||jr(e.cm)}function xi(e,t){t.equals(e.sel)||(e.sel=t,e.cm&&(e.cm.curOp.updateInput=e.cm.curOp.selectionChanged=!0,Ne(e.cm)),bt(e,"cursorActivity",e))}function Ci(e){xi(e,Si(e,e.sel,null,!1))}function Si(e,t,r,n){for(var i,o=0;o<t.ranges.length;o++){var l=t.ranges[o],s=t.ranges.length==e.sel.ranges.length&&e.sel.ranges[o],a=ki(e,l.anchor,s&&s.anchor,r,n),u=ki(e,l.head,s&&s.head,r,n);(i||a!=l.anchor||u!=l.head)&&(i||(i=t.ranges.slice(0,o)),i[o]=new Ts(a,u))}return i?zn(i,t.primIndex):t}function Li(e,t,r,n,i){var o=M(e,t.line);if(o.markedSpans)for(var l=0;l<o.markedSpans.length;++l){var s=o.markedSpans[l],a=s.marker;if((null==s.from||(a.inclusiveLeft?s.from<=t.ch:s.from<t.ch))&&(null==s.to||(a.inclusiveRight?s.to>=t.ch:s.to>t.ch))){if(i&&(Te(a,"beforeCursorEnter"),a.explicitlyCleared)){if(o.markedSpans){--l;continue}break}if(!a.atomic)continue;if(r){var u=a.find(n<0?1:-1),c=void 0;if((n<0?a.inclusiveRight:a.inclusiveLeft)&&(u=Ti(e,u,-n,u&&u.line==t.line?o:null)),u&&u.line==t.line&&(c=P(u,r))&&(n<0?c<0:c>0))return Li(e,u,t,n,i)}var f=a.find(n<0?-1:1);return(n<0?a.inclusiveLeft:a.inclusiveRight)&&(f=Ti(e,f,n,f.line==t.line?o:null)),f?Li(e,f,t,n,i):null}}return t}function ki(e,t,r,n,i){var o=n||1,l=Li(e,t,r,o,i)||!i&&Li(e,t,r,o,!0)||Li(e,t,r,-o,i)||!i&&Li(e,t,r,-o,!0);return l||(e.cantEdit=!0,E(e.first,0))}function Ti(e,t,r,n){return r<0&&0==t.ch?t.line>e.first?U(e,E(t.line-1)):null:r>0&&t.ch==(n||M(e,t.line)).text.length?t.line<e.first+e.size-1?E(t.line+1,0):null:new E(t.line,t.ch+r)}function Mi(e){e.setSelection(E(e.firstLine(),0),E(e.lastLine()),Gl)}function Ni(e,t,r){var n={canceled:!1,from:t.from,to:t.to,text:t.text,origin:t.origin,cancel:function(){return n.canceled=!0}};return r&&(n.update=function(t,r,i,o){t&&(n.from=U(e,t)),r&&(n.to=U(e,r)),i&&(n.text=i),void 0!==o&&(n.origin=o)}),Te(e,"beforeChange",e,n),e.cm&&Te(e.cm,"beforeChange",e.cm,n),n.canceled?null:{from:n.from,to:n.to,text:n.text,origin:n.origin}}function Oi(e,t,r){if(e.cm){if(!e.cm.curOp)return dn(e.cm,Oi)(e,t,r);if(e.cm.state.suppressEdits)return}if(!(Oe(e,"beforeChange")||e.cm&&Oe(e.cm,"beforeChange"))||(t=Ni(e,t,!0))){var n=Yl&&!r&&te(e,t.from,t.to);if(n)for(var i=n.length-1;i>=0;--i)Ai(e,{from:n[i].from,to:n[i].to,text:i?[""]:t.text,origin:t.origin});else Ai(e,t)}}function Ai(e,t){if(1!=t.text.length||""!=t.text[0]||0!=P(t.from,t.to)){var r=Un(e,t);ni(e,t,r,e.cm?e.cm.curOp.id:NaN),Hi(e,t,r,J(e,t));var n=[];$n(e,function(e,r){r||-1!=h(n,e.history)||(zi(e.history,t),n.push(e.history)),Hi(e,t,null,J(e,t))})}}function Wi(e,t,r){if(!e.cm||!e.cm.state.suppressEdits||r){for(var n,i=e.history,o=e.sel,l="undo"==t?i.done:i.undone,s="undo"==t?i.undone:i.done,a=0;a<l.length&&(n=l[a],r?!n.ranges||n.equals(e.sel):n.ranges);a++);if(a!=l.length){for(i.lastOrigin=i.lastSelOrigin=null;(n=l.pop()).ranges;){if(li(n,s),r&&!n.equals(e.sel))return void bi(e,n,{clearRedo:!1});o=n}var u=[];li(o,s),s.push({changes:u,generation:i.generation}),i.generation=n.generation||++i.maxGeneration;for(var c=Oe(e,"beforeChange")||e.cm&&Oe(e.cm,"beforeChange"),f=n.changes.length-1;f>=0;--f){var d=function(r){var i=n.changes[r];if(i.origin=t,c&&!Ni(e,i,!1))return l.length=0,{};u.push(ei(e,i));var o=r?Un(e,i):g(l);Hi(e,i,o,ci(e,i)),!r&&e.cm&&e.cm.scrollIntoView({from:i.from,to:Bn(i)});var s=[];$n(e,function(e,t){t||-1!=h(s,e.history)||(zi(e.history,i),s.push(e.history)),Hi(e,i,null,ci(e,i))})}(f);if(d)return d.v}}}}function Di(e,t){if(0!=t&&(e.first+=t,e.sel=new ks(v(e.sel.ranges,function(e){return new Ts(E(e.anchor.line+t,e.anchor.ch),E(e.head.line+t,e.head.ch))}),e.sel.primIndex),e.cm)){vn(e.cm,e.first,e.first-t,t);for(var r=e.cm.display,n=r.viewFrom;n<r.viewTo;n++)mn(e.cm,n,"gutter")}}function Hi(e,t,r,n){if(e.cm&&!e.cm.curOp)return dn(e.cm,Hi)(e,t,r,n);if(t.to.line<e.first)Di(e,t.text.length-1-(t.to.line-t.from.line));else if(!(t.from.line>e.lastLine())){if(t.from.line<e.first){var i=t.text.length-1-(e.first-t.from.line);Di(e,i),t={from:E(e.first,0),to:E(t.to.line+i,t.to.ch),text:[g(t.text)],origin:t.origin}}var o=e.lastLine();t.to.line>o&&(t={from:t.from,to:E(o,M(e,o).text.length),text:[t.text[0]],origin:t.origin}),t.removed=N(e,t.from,t.to),r||(r=Un(e,t)),e.cm?Fi(e.cm,t,n):_n(e,t,n),wi(e,r,Gl)}}function Fi(e,t,r){var n=e.doc,i=e.display,o=t.from,l=t.to,s=!1,a=o.line;e.options.lineWrapping||(a=W(fe(M(n,o.line))),n.iter(a,l.line+1,function(e){if(e==i.maxLine)return s=!0,!0})),n.sel.contains(t.from,t.to)>-1&&Ne(e),_n(n,t,r,xr(e)),e.options.lineWrapping||(n.iter(a,o.line+t.text.length,function(e){var t=be(e);t>i.maxLineLength&&(i.maxLine=e,i.maxLineLength=t,i.maxLineChanged=!0,s=!1)}),s&&(e.curOp.updateMaxLine=!0)),nt(n,o.line),Cn(e,400);var u=t.text.length-(l.line-o.line)-1;t.full?vn(e):o.line!=l.line||1!=t.text.length||Yn(e.doc,t)?vn(e,o.line,l.line+1,u):mn(e,o.line,"text");var c=Oe(e,"changes"),f=Oe(e,"change");if(f||c){var h={from:o,to:l,text:t.text,removed:t.removed,origin:t.origin};f&&bt(e,"change",e,h),c&&(e.curOp.changeObjs||(e.curOp.changeObjs=[])).push(h)}e.display.selForContextMenu=null}function Ei(e,t,r,n,i){if(n||(n=r),P(n,r)<0){var o;r=(o=[n,r])[0],n=o[1]}"string"==typeof t&&(t=e.splitLines(t)),Oi(e,{from:r,to:n,text:t,origin:i})}function Pi(e,t,r,n){r<e.line?e.line+=n:t<e.line&&(e.line=t,e.ch=0)}function Ii(e,t,r,n){for(var i=0;i<e.length;++i){var o=e[i],l=!0;if(o.ranges){o.copied||((o=e[i]=o.deepCopy()).copied=!0);for(var s=0;s<o.ranges.length;s++)Pi(o.ranges[s].anchor,t,r,n),Pi(o.ranges[s].head,t,r,n)}else{for(var a=0;a<o.changes.length;++a){var u=o.changes[a];if(r<u.from.line)u.from=E(u.from.line+n,u.from.ch),u.to=E(u.to.line+n,u.to.ch);else if(t<=u.to.line){l=!1;break}}l||(e.splice(0,i+1),i=0)}}}function zi(e,t){var r=t.from.line,n=t.to.line,i=t.text.length-(n-r)-1;Ii(e.done,r,n,i),Ii(e.undone,r,n,i)}function Ri(e,t,r,n){var i=t,o=t;return"number"==typeof t?o=M(e,G(e,t)):i=W(t),null==i?null:(n(o,i)&&e.cm&&mn(e.cm,i,r),o)}function Bi(e){var t=this;this.lines=e,this.parent=null;for(var r=0,n=0;n<e.length;++n)e[n].parent=t,r+=e[n].height;this.height=r}function Gi(e){var t=this;this.children=e;for(var r=0,n=0,i=0;i<e.length;++i){var o=e[i];r+=o.chunkSize(),n+=o.height,o.parent=t}this.size=r,this.height=n,this.parent=null}function Ui(e,t,r){ye(t)<(e.curOp&&e.curOp.scrollTop||e.doc.scrollTop)&&Kr(e,r)}function Vi(e,t,r,n){var i=new Ms(e,r,n),o=e.cm;return o&&i.noHScroll&&(o.display.alignWidgets=!0),Ri(e,t,"widget",function(t){var r=t.widgets||(t.widgets=[]);if(null==i.insertAt?r.push(i):r.splice(Math.min(r.length-1,Math.max(0,i.insertAt)),0,i),i.line=t,o&&!ve(e,t)){var n=ye(t)<e.scrollTop;A(t,t.height+Ht(i)),n&&Kr(o,i.height),o.curOp.forceUpdate=!0}return!0}),bt(o,"lineWidgetAdded",o,i,"number"==typeof t?t:W(t)),i}function Ki(e,t,r,n,o){if(n&&n.shared)return ji(e,t,r,n,o);if(e.cm&&!e.cm.curOp)return dn(e.cm,Ki)(e,t,r,n,o);var l=new Os(e,o),s=P(t,r);if(n&&c(n,l,!1),s>0||0==s&&!1!==l.clearWhenEmpty)return l;if(l.replacedWith&&(l.collapsed=!0,l.widgetNode=i("span",[l.replacedWith],"CodeMirror-widget"),n.handleMouseEvents||l.widgetNode.setAttribute("cm-ignore-events","true"),n.insertLeft&&(l.widgetNode.insertLeft=!0)),l.collapsed){if(ce(e,t.line,t,r,l)||t.line!=r.line&&ce(e,r.line,t,r,l))throw new Error("Inserting collapsed marker partially overlapping an existing one");X()}l.addToHistory&&ni(e,{from:t,to:r,origin:"markText"},e.sel,NaN);var a,u=t.line,f=e.cm;if(e.iter(u,r.line+1,function(e){f&&l.collapsed&&!f.options.lineWrapping&&fe(e)==f.display.maxLine&&(a=!0),l.collapsed&&u!=t.line&&A(e,0),q(e,new Y(l,u==t.line?t.ch:null,u==r.line?r.ch:null)),++u}),l.collapsed&&e.iter(t.line,r.line+1,function(t){ve(e,t)&&A(t,0)}),l.clearOnEnter&&Ql(l,"beforeCursorEnter",function(){return l.clear()}),l.readOnly&&(j(),(e.history.done.length||e.history.undone.length)&&e.clearHistory()),l.collapsed&&(l.id=++Ns,l.atomic=!0),f){if(a&&(f.curOp.updateMaxLine=!0),l.collapsed)vn(f,t.line,r.line+1);else if(l.className||l.title||l.startStyle||l.endStyle||l.css)for(var h=t.line;h<=r.line;h++)mn(f,h,"text");l.atomic&&Ci(f.doc),bt(f,"markerAdded",f,l)}return l}function ji(e,t,r,n,i){(n=c(n)).shared=!1;var o=[Ki(e,t,r,n,i)],l=o[0],s=n.widgetNode;return $n(e,function(e){s&&(n.widgetNode=s.cloneNode(!0)),o.push(Ki(e,U(e,t),U(e,r),n,i));for(var a=0;a<e.linked.length;++a)if(e.linked[a].isParent)return;l=g(o)}),new As(o,l)}function Xi(e){return e.findMarks(E(e.first,0),e.clipPos(E(e.lastLine())),function(e){return e.parent})}function Yi(e,t){for(var r=0;r<t.length;r++){var n=t[r],i=n.find(),o=e.clipPos(i.from),l=e.clipPos(i.to);if(P(o,l)){var s=Ki(e,o,l,n.primary,n.primary.type);n.markers.push(s),s.parent=n}}}function _i(e){for(var t=0;t<e.length;t++)!function(t){var r=e[t],n=[r.primary.doc];$n(r.primary.doc,function(e){return n.push(e)});for(var i=0;i<r.markers.length;i++){var o=r.markers[i];-1==h(n,o.doc)&&(o.parent=null,r.markers.splice(i--,1))}}(t)}function $i(e){var t=this;if(Qi(t),!Me(t,e)&&!Ft(t.display,e)){We(e),gl&&(Hs=+new Date);var r=Sr(t,e,!0),n=e.dataTransfer.files;if(r&&!t.isReadOnly())if(n&&n.length&&window.FileReader&&window.File)for(var i=n.length,o=Array(i),l=0,s=0;s<i;++s)!function(e,n){if(!t.options.allowDropFileTypes||-1!=h(t.options.allowDropFileTypes,e.type)){var s=new FileReader;s.onload=dn(t,function(){var e=s.result;if(/[\x00-\x08\x0e-\x1f]{2}/.test(e)&&(e=""),o[n]=e,++l==i){var a={from:r=U(t.doc,r),to:r,text:t.doc.splitLines(o.join(t.doc.lineSeparator())),origin:"paste"};Oi(t.doc,a),yi(t.doc,Rn(r,Bn(a)))}}),s.readAsText(e)}}(n[s],s);else{if(t.state.draggingText&&t.doc.sel.contains(r)>-1)return t.state.draggingText(e),void setTimeout(function(){return t.display.input.focus()},20);try{var a=e.dataTransfer.getData("Text");if(a){var u;if(t.state.draggingText&&!t.state.draggingText.copy&&(u=t.listSelections()),wi(t.doc,Rn(r,r)),u)for(var c=0;c<u.length;++c)Ei(t.doc,"",u[c].anchor,u[c].head,"drag");t.replaceSelection(a,"around","paste"),t.display.input.focus()}}catch(e){}}}}function qi(e,t){if(gl&&(!e.state.draggingText||+new Date-Hs<100))Fe(t);else if(!Me(e,t)&&!Ft(e.display,t)&&(t.dataTransfer.setData("Text",e.getSelection()),t.dataTransfer.effectAllowed="copyMove",t.dataTransfer.setDragImage&&!xl)){var r=n("img",null,null,"position: fixed; left: 0; top: 0;");r.src="data:image/gif;base64,R0lGODlhAQABAAAAACH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==",wl&&(r.width=r.height=1,e.display.wrapper.appendChild(r),r._top=r.offsetTop),t.dataTransfer.setDragImage(r,0,0),wl&&r.parentNode.removeChild(r)}}function Zi(e,t){var i=Sr(e,t);if(i){var o=document.createDocumentFragment();Mr(e,i,o),e.display.dragCursor||(e.display.dragCursor=n("div",null,"CodeMirror-cursors CodeMirror-dragcursors"),e.display.lineSpace.insertBefore(e.display.dragCursor,e.display.cursorDiv)),r(e.display.dragCursor,o)}}function Qi(e){e.display.dragCursor&&(e.display.lineSpace.removeChild(e.display.dragCursor),e.display.dragCursor=null)}function Ji(e){if(document.getElementsByClassName)for(var t=document.getElementsByClassName("CodeMirror"),r=0;r<t.length;r++){var n=t[r].CodeMirror;n&&e(n)}}function eo(){Fs||(to(),Fs=!0)}function to(){var e;Ql(window,"resize",function(){null==e&&(e=setTimeout(function(){e=null,Ji(ro)},100))}),Ql(window,"blur",function(){return Ji(Fr)})}function ro(e){var t=e.display;t.lastWrapHeight==t.wrapper.clientHeight&&t.lastWrapWidth==t.wrapper.clientWidth||(t.cachedCharWidth=t.cachedTextHeight=t.cachedPaddingH=null,t.scrollbarsClipped=!1,e.setSize())}function no(e){var t=e.split(/-(?!$)/);e=t[t.length-1];for(var r,n,i,o,l=0;l<t.length-1;l++){var s=t[l];if(/^(cmd|meta|m)$/i.test(s))o=!0;else if(/^a(lt)?$/i.test(s))r=!0;else if(/^(c|ctrl|control)$/i.test(s))n=!0;else{if(!/^s(hift)?$/i.test(s))throw new Error("Unrecognized modifier name: "+s);i=!0}}return r&&(e="Alt-"+e),n&&(e="Ctrl-"+e),o&&(e="Cmd-"+e),i&&(e="Shift-"+e),e}function io(e){var t={};for(var r in e)if(e.hasOwnProperty(r)){var n=e[r];if(/^(name|fallthrough|(de|at)tach)$/.test(r))continue;if("..."==n){delete e[r];continue}for(var i=v(r.split(" "),no),o=0;o<i.length;o++){var l=void 0,s=void 0;o==i.length-1?(s=i.join(" "),l=n):(s=i.slice(0,o+1).join(" "),l="...");var a=t[s];if(a){if(a!=l)throw new Error("Inconsistent bindings for "+s)}else t[s]=l}delete e[r]}for(var u in t)e[u]=t[u];return e}function oo(e,t,r,n){var i=(t=uo(t)).call?t.call(e,n):t[e];if(!1===i)return"nothing";if("..."===i)return"multi";if(null!=i&&r(i))return"handled";if(t.fallthrough){if("[object Array]"!=Object.prototype.toString.call(t.fallthrough))return oo(e,t.fallthrough,r,n);for(var o=0;o<t.fallthrough.length;o++){var l=oo(e,t.fallthrough[o],r,n);if(l)return l}}}function lo(e){var t="string"==typeof e?e:Es[e.keyCode];return"Ctrl"==t||"Alt"==t||"Shift"==t||"Mod"==t}function so(e,t,r){var n=e;return t.altKey&&"Alt"!=n&&(e="Alt-"+e),(Dl?t.metaKey:t.ctrlKey)&&"Ctrl"!=n&&(e="Ctrl-"+e),(Dl?t.ctrlKey:t.metaKey)&&"Cmd"!=n&&(e="Cmd-"+e),!r&&t.shiftKey&&"Shift"!=n&&(e="Shift-"+e),e}function ao(e,t){if(wl&&34==e.keyCode&&e.char)return!1;var r=Es[e.keyCode];return null!=r&&!e.altGraphKey&&so(r,e,t)}function uo(e){return"string"==typeof e?Rs[e]:e}function co(e,t){for(var r=e.doc.sel.ranges,n=[],i=0;i<r.length;i++){for(var o=t(r[i]);n.length&&P(o.from,g(n).to)<=0;){var l=n.pop();if(P(l.from,o.from)<0){o.from=l.from;break}}n.push(o)}hn(e,function(){for(var t=n.length-1;t>=0;t--)Ei(e.doc,"",n[t].from,n[t].to,"+delete");jr(e)})}function fo(e,t,r){var n=L(e.text,t+r,r);return n<0||n>e.text.length?null:n}function ho(e,t,r){var n=fo(e,t.ch,r);return null==n?null:new E(t.line,n,r<0?"after":"before")}function po(e,t,r,n,i){if(e){var o=Se(r,t.doc.direction);if(o){var l,s=i<0?g(o):o[0],a=i<0==(1==s.level)?"after":"before";if(s.level>0){var u=Xt(t,r);l=i<0?r.text.length-1:0;var c=Yt(t,u,l).top;l=k(function(e){return Yt(t,u,e).top==c},i<0==(1==s.level)?s.from:s.to-1,l),"before"==a&&(l=fo(r,l,1))}else l=i<0?s.to:s.from;return new E(n,l,a)}}return new E(n,i<0?r.text.length:0,i<0?"before":"after")}function go(e,t,r,n){var i=Se(t,e.doc.direction);if(!i)return ho(t,r,n);r.ch>=t.text.length?(r.ch=t.text.length,r.sticky="before"):r.ch<=0&&(r.ch=0,r.sticky="after");var o=Ce(i,r.ch,r.sticky),l=i[o];if("ltr"==e.doc.direction&&l.level%2==0&&(n>0?l.to>r.ch:l.from<r.ch))return ho(t,r,n);var s,a=function(e,r){return fo(t,e instanceof E?e.ch:e,r)},u=function(r){return e.options.lineWrapping?(s=s||Xt(e,t),hr(e,t,s,r)):{begin:0,end:t.text.length}},c=u("before"==r.sticky?a(r,-1):r.ch);if("rtl"==e.doc.direction||1==l.level){var f=1==l.level==n<0,h=a(r,f?1:-1);if(null!=h&&(f?h<=l.to&&h<=c.end:h>=l.from&&h>=c.begin)){var d=f?"before":"after";return new E(r.line,h,d)}}var p=function(e,t,n){for(var o=function(e,t){return t?new E(r.line,a(e,1),"before"):new E(r.line,e,"after")};e>=0&&e<i.length;e+=t){var l=i[e],s=t>0==(1!=l.level),u=s?n.begin:a(n.end,-1);if(l.from<=u&&u<l.to)return o(u,s);if(u=s?l.from:a(l.to,-1),n.begin<=u&&u<n.end)return o(u,s)}},g=p(o+n,n,c);if(g)return g;var v=n>0?c.end:a(c.begin,-1);return null==v||n>0&&v==t.text.length||!(g=p(n>0?0:i.length-1,n,u(v)))?null:g}function vo(e,t){var r=M(e.doc,t),n=fe(r);return n!=r&&(t=W(n)),po(!0,e,n,t,1)}function mo(e,t){var r=M(e.doc,t),n=he(r);return n!=r&&(t=W(n)),po(!0,e,r,t,-1)}function yo(e,t){var r=vo(e,t.line),n=M(e.doc,r.line),i=Se(n,e.doc.direction);if(!i||0==i[0].level){var o=Math.max(0,n.text.search(/\S/)),l=t.line==r.line&&t.ch<=o&&t.ch;return E(r.line,l?0:o,r.sticky)}return r}function bo(e,t,r){if("string"==typeof t&&!(t=Bs[t]))return!1;e.display.input.ensurePolled();var n=e.display.shift,i=!1;try{e.isReadOnly()&&(e.state.suppressEdits=!0),r&&(e.display.shift=!1),i=t(e)!=Bl}finally{e.display.shift=n,e.state.suppressEdits=!1}return i}function wo(e,t,r){for(var n=0;n<e.state.keyMaps.length;n++){var i=oo(t,e.state.keyMaps[n],r,e);if(i)return i}return e.options.extraKeys&&oo(t,e.options.extraKeys,r,e)||oo(t,e.options.keyMap,r,e)}function xo(e,t,r,n){var i=e.state.keySeq;if(i){if(lo(t))return"handled";Gs.set(50,function(){e.state.keySeq==i&&(e.state.keySeq=null,e.display.input.reset())}),t=i+" "+t}var o=wo(e,t,n);return"multi"==o&&(e.state.keySeq=t),"handled"==o&&bt(e,"keyHandled",e,t,r),"handled"!=o&&"multi"!=o||(We(r),Ar(e)),i&&!o&&/\'$/.test(t)?(We(r),!0):!!o}function Co(e,t){var r=ao(t,!0);return!!r&&(t.shiftKey&&!e.state.keySeq?xo(e,"Shift-"+r,t,function(t){return bo(e,t,!0)})||xo(e,r,t,function(t){if("string"==typeof t?/^go[A-Z]/.test(t):t.motion)return bo(e,t)}):xo(e,r,t,function(t){return bo(e,t)}))}function So(e,t,r){return xo(e,"'"+r+"'",t,function(t){return bo(e,t,!0)})}function Lo(e){var t=this;if(t.curOp.focus=l(),!Me(t,e)){gl&&vl<11&&27==e.keyCode&&(e.returnValue=!1);var r=e.keyCode;t.display.shift=16==r||e.shiftKey;var n=Co(t,e);wl&&(Us=n?r:null,!n&&88==r&&!rs&&(Ml?e.metaKey:e.ctrlKey)&&t.replaceSelection("",null,"cut")),18!=r||/\bCodeMirror-crosshair\b/.test(t.display.lineDiv.className)||ko(t)}}function ko(e){function t(e){18!=e.keyCode&&e.altKey||(Fl(r,"CodeMirror-crosshair"),ke(document,"keyup",t),ke(document,"mouseover",t))}var r=e.display.lineDiv;s(r,"CodeMirror-crosshair"),Ql(document,"keyup",t),Ql(document,"mouseover",t)}function To(e){16==e.keyCode&&(this.doc.sel.shift=!1),Me(this,e)}function Mo(e){var t=this;if(!(Ft(t.display,e)||Me(t,e)||e.ctrlKey&&!e.altKey||Ml&&e.metaKey)){var r=e.keyCode,n=e.charCode;if(wl&&r==Us)return Us=null,void We(e);if(!wl||e.which&&!(e.which<10)||!Co(t,e)){var i=String.fromCharCode(null==n?r:n);"\b"!=i&&(So(t,e,i)||t.display.input.onKeyPress(e))}}}function No(e,t){var r=+new Date;return js&&js.compare(r,e,t)?(Ks=js=null,"triple"):Ks&&Ks.compare(r,e,t)?(js=new Vs(r,e,t),Ks=null,"double"):(Ks=new Vs(r,e,t),js=null,"single")}function Oo(e){var t=this,r=t.display;if(!(Me(t,e)||r.activeTouch&&r.input.supportsTouch()))if(r.input.ensurePolled(),r.shift=e.shiftKey,Ft(r,e))ml||(r.scroller.draggable=!1,setTimeout(function(){return r.scroller.draggable=!0},100));else if(!zo(t,e)){var n=Sr(t,e),i=Pe(e),o=n?No(n,i):"single";window.focus(),1==i&&t.state.selectingText&&t.state.selectingText(e),n&&Ao(t,i,n,o,e)||(1==i?n?Do(t,n,o,e):Ee(e)==r.scroller&&We(e):2==i?(n&&di(t.doc,n),setTimeout(function(){return r.input.focus()},20)):3==i&&(Hl?Ro(t,e):Dr(t)))}}function Ao(e,t,r,n,i){var o="Click";return"double"==n?o="Double"+o:"triple"==n&&(o="Triple"+o),o=(1==t?"Left":2==t?"Middle":"Right")+o,xo(e,so(o,i),i,function(t){if("string"==typeof t&&(t=Bs[t]),!t)return!1;var n=!1;try{e.isReadOnly()&&(e.state.suppressEdits=!0),n=t(e,r)!=Bl}finally{e.state.suppressEdits=!1}return n})}function Wo(e,t,r){var n=e.getOption("configureMouse"),i=n?n(e,t,r):{};if(null==i.unit){var o=Nl?r.shiftKey&&r.metaKey:r.altKey;i.unit=o?"rectangle":"single"==t?"char":"double"==t?"word":"line"}return(null==i.extend||e.doc.extend)&&(i.extend=e.doc.extend||r.shiftKey),null==i.addNew&&(i.addNew=Ml?r.metaKey:r.ctrlKey),null==i.moveOnDrag&&(i.moveOnDrag=!(Ml?r.altKey:r.ctrlKey)),i}function Do(e,t,r,n){gl?setTimeout(u(Wr,e),0):e.curOp.focus=l();var i,o=Wo(e,r,n),s=e.doc.sel;e.options.dragDrop&&Jl&&!e.isReadOnly()&&"single"==r&&(i=s.contains(t))>-1&&(P((i=s.ranges[i]).from(),t)<0||t.xRel>0)&&(P(i.to(),t)>0||t.xRel<0)?Ho(e,n,t,o):Eo(e,n,t,o)}function Ho(e,t,r,n){var i=e.display,o=!1,l=dn(e,function(t){ml&&(i.scroller.draggable=!1),e.state.draggingText=!1,ke(document,"mouseup",l),ke(document,"mousemove",s),ke(i.scroller,"dragstart",a),ke(i.scroller,"drop",l),o||(We(t),n.addNew||di(e.doc,r,null,null,n.extend),ml||gl&&9==vl?setTimeout(function(){document.body.focus(),i.input.focus()},20):i.input.focus())}),s=function(e){o=o||Math.abs(t.clientX-e.clientX)+Math.abs(t.clientY-e.clientY)>=10},a=function(){return o=!0};ml&&(i.scroller.draggable=!0),e.state.draggingText=l,l.copy=!n.moveOnDrag,i.scroller.dragDrop&&i.scroller.dragDrop(),Ql(document,"mouseup",l),Ql(document,"mousemove",s),Ql(i.scroller,"dragstart",a),Ql(i.scroller,"drop",l),Dr(e),setTimeout(function(){return i.input.focus()},20)}function Fo(e,t,r){if("char"==r)return new Ts(t,t);if("word"==r)return e.findWordAt(t);if("line"==r)return new Ts(E(t.line,0),U(e.doc,E(t.line+1,0)));var n=r(e,t);return new Ts(n.from,n.to)}function Eo(e,t,r,n){function i(t){if(0!=P(m,t))if(m=t,"rectangle"==n.unit){for(var i=[],o=e.options.tabSize,l=f(M(u,r.line).text,r.ch,o),s=f(M(u,t.line).text,t.ch,o),a=Math.min(l,s),g=Math.max(l,s),v=Math.min(r.line,t.line),y=Math.min(e.lastLine(),Math.max(r.line,t.line));v<=y;v++){var b=M(u,v).text,w=d(b,a,o);a==g?i.push(new Ts(E(v,w),E(v,w))):b.length>w&&i.push(new Ts(E(v,w),E(v,d(b,g,o))))}i.length||i.push(new Ts(r,r)),bi(u,zn(p.ranges.slice(0,h).concat(i),h),{origin:"*mouse",scroll:!1}),e.scrollIntoView(t)}else{var x,C=c,S=Fo(e,t,n.unit),L=C.anchor;P(S.anchor,L)>0?(x=S.head,L=B(C.from(),S.anchor)):(x=S.anchor,L=R(C.to(),S.head));var k=p.ranges.slice(0);k[h]=Po(e,new Ts(U(u,L),x)),bi(u,zn(k,h),Ul)}}function o(t){var r=++b,s=Sr(e,t,!0,"rectangle"==n.unit);if(s)if(0!=P(s,m)){e.curOp.focus=l(),i(s);var c=Ir(a,u);(s.line>=c.to||s.line<c.from)&&setTimeout(dn(e,function(){b==r&&o(t)}),150)}else{var f=t.clientY<y.top?-20:t.clientY>y.bottom?20:0;f&&setTimeout(dn(e,function(){b==r&&(a.scroller.scrollTop+=f,o(t))}),50)}}function s(t){e.state.selectingText=!1,b=1/0,We(t),a.input.focus(),ke(document,"mousemove",w),ke(document,"mouseup",x),u.history.lastSelOrigin=null}var a=e.display,u=e.doc;We(t);var c,h,p=u.sel,g=p.ranges;if(n.addNew&&!n.extend?(h=u.sel.contains(r),c=h>-1?g[h]:new Ts(r,r)):(c=u.sel.primary(),h=u.sel.primIndex),"rectangle"==n.unit)n.addNew||(c=new Ts(r,r)),r=Sr(e,t,!0,!0),h=-1;else{var v=Fo(e,r,n.unit);c=n.extend?hi(c,v.anchor,v.head,n.extend):v}n.addNew?-1==h?(h=g.length,bi(u,zn(g.concat([c]),h),{scroll:!1,origin:"*mouse"})):g.length>1&&g[h].empty()&&"char"==n.unit&&!n.extend?(bi(u,zn(g.slice(0,h).concat(g.slice(h+1)),0),{scroll:!1,origin:"*mouse"}),p=u.sel):gi(u,h,c,Ul):(h=0,bi(u,new ks([c],0),Ul),p=u.sel);var m=r,y=a.wrapper.getBoundingClientRect(),b=0,w=dn(e,function(e){Pe(e)?o(e):s(e)}),x=dn(e,s);e.state.selectingText=x,Ql(document,"mousemove",w),Ql(document,"mouseup",x)}function Po(e,t){var r=t.anchor,n=t.head,i=M(e.doc,r.line);if(0==P(r,n)&&r.sticky==n.sticky)return t;var o=Se(i);if(!o)return t;var l=Ce(o,r.ch,r.sticky),s=o[l];if(s.from!=r.ch&&s.to!=r.ch)return t;var a=l+(s.from==r.ch==(1!=s.level)?0:1);if(0==a||a==o.length)return t;var u;if(n.line!=r.line)u=(n.line-r.line)*("ltr"==e.doc.direction?1:-1)>0;else{var c=Ce(o,n.ch,n.sticky),f=c-l||(n.ch-r.ch)*(1==s.level?-1:1);u=c==a-1||c==a?f<0:f>0}var h=o[a+(u?-1:0)],d=u==(1==h.level),p=d?h.from:h.to,g=d?"after":"before";return r.ch==p&&r.sticky==g?t:new Ts(new E(r.line,p,g),n)}function Io(e,t,r,n){var i,o;if(t.touches)i=t.touches[0].clientX,o=t.touches[0].clientY;else try{i=t.clientX,o=t.clientY}catch(t){return!1}if(i>=Math.floor(e.display.gutters.getBoundingClientRect().right))return!1;n&&We(t);var l=e.display,s=l.lineDiv.getBoundingClientRect();if(o>s.bottom||!Oe(e,r))return He(t);o-=s.top-l.viewOffset;for(var a=0;a<e.options.gutters.length;++a){var u=l.gutters.childNodes[a];if(u&&u.getBoundingClientRect().right>=i)return Te(e,r,e,D(e.doc,o),e.options.gutters[a],t),He(t)}}function zo(e,t){return Io(e,t,"gutterClick",!0)}function Ro(e,t){Ft(e.display,t)||Bo(e,t)||Me(e,t,"contextmenu")||e.display.input.onContextMenu(t)}function Bo(e,t){return!!Oe(e,"gutterContextMenu")&&Io(e,t,"gutterContextMenu",!1)}function Go(e){e.display.wrapper.className=e.display.wrapper.className.replace(/\s*cm-s-\S+/g,"")+e.options.theme.replace(/(^|\s)\s*/g," cm-s-"),er(e)}function Uo(e){Hn(e),vn(e),zr(e)}function Vo(e,t,r){if(!t!=!(r&&r!=Xs)){var n=e.display.dragFunctions,i=t?Ql:ke;i(e.display.scroller,"dragstart",n.start),i(e.display.scroller,"dragenter",n.enter),i(e.display.scroller,"dragover",n.over),i(e.display.scroller,"dragleave",n.leave),i(e.display.scroller,"drop",n.drop)}}function Ko(e){e.options.lineWrapping?(s(e.display.wrapper,"CodeMirror-wrap"),e.display.sizer.style.minWidth="",e.display.sizerWidth=null):(Fl(e.display.wrapper,"CodeMirror-wrap"),we(e)),Cr(e),vn(e),er(e),setTimeout(function(){return en(e)},100)}function jo(e,t){var r=this;if(!(this instanceof jo))return new jo(e,t);this.options=t=t?c(t):{},c(Ys,t,!1),Fn(t);var n=t.value;"string"==typeof n&&(n=new Ds(n,t.mode,null,t.lineSeparator,t.direction)),this.doc=n;var i=new jo.inputStyles[t.inputStyle](this),o=this.display=new T(e,n,i);o.wrapper.CodeMirror=this,Hn(this),Go(this),t.lineWrapping&&(this.display.wrapper.className+=" CodeMirror-wrap"),rn(this),this.state={keyMaps:[],overlays:[],modeGen:0,overwrite:!1,delayingBlurEvent:!1,focused:!1,suppressEdits:!1,pasteIncoming:!1,cutIncoming:!1,selectingText:!1,draggingText:!1,highlight:new Pl,keySeq:null,specialChars:null},t.autofocus&&!Tl&&o.input.focus(),gl&&vl<11&&setTimeout(function(){return r.display.input.reset(!0)},20),Xo(this),eo(),nn(this),this.curOp.forceUpdate=!0,qn(this,n),t.autofocus&&!Tl||this.hasFocus()?setTimeout(u(Hr,this),20):Fr(this);for(var l in _s)_s.hasOwnProperty(l)&&_s[l](r,t[l],Xs);Rr(this),t.finishInit&&t.finishInit(this);for(var s=0;s<$s.length;++s)$s[s](r);on(this),ml&&t.lineWrapping&&"optimizelegibility"==getComputedStyle(o.lineDiv).textRendering&&(o.lineDiv.style.textRendering="auto")}function Xo(e){function t(){i.activeTouch&&(o=setTimeout(function(){return i.activeTouch=null},1e3),(l=i.activeTouch).end=+new Date)}function r(e){if(1!=e.touches.length)return!1;var t=e.touches[0];return t.radiusX<=1&&t.radiusY<=1}function n(e,t){if(null==t.left)return!0;var r=t.left-e.left,n=t.top-e.top;return r*r+n*n>400}var i=e.display;Ql(i.scroller,"mousedown",dn(e,Oo)),gl&&vl<11?Ql(i.scroller,"dblclick",dn(e,function(t){if(!Me(e,t)){var r=Sr(e,t);if(r&&!zo(e,t)&&!Ft(e.display,t)){We(t);var n=e.findWordAt(r);di(e.doc,n.anchor,n.head)}}})):Ql(i.scroller,"dblclick",function(t){return Me(e,t)||We(t)}),Hl||Ql(i.scroller,"contextmenu",function(t){return Ro(e,t)});var o,l={end:0};Ql(i.scroller,"touchstart",function(t){if(!Me(e,t)&&!r(t)&&!zo(e,t)){i.input.ensurePolled(),clearTimeout(o);var n=+new Date;i.activeTouch={start:n,moved:!1,prev:n-l.end<=300?l:null},1==t.touches.length&&(i.activeTouch.left=t.touches[0].pageX,i.activeTouch.top=t.touches[0].pageY)}}),Ql(i.scroller,"touchmove",function(){i.activeTouch&&(i.activeTouch.moved=!0)}),Ql(i.scroller,"touchend",function(r){var o=i.activeTouch;if(o&&!Ft(i,r)&&null!=o.left&&!o.moved&&new Date-o.start<300){var l,s=e.coordsChar(i.activeTouch,"page");l=!o.prev||n(o,o.prev)?new Ts(s,s):!o.prev.prev||n(o,o.prev.prev)?e.findWordAt(s):new Ts(E(s.line,0),U(e.doc,E(s.line+1,0))),e.setSelection(l.anchor,l.head),e.focus(),We(r)}t()}),Ql(i.scroller,"touchcancel",t),Ql(i.scroller,"scroll",function(){i.scroller.clientHeight&&(qr(e,i.scroller.scrollTop),Qr(e,i.scroller.scrollLeft,!0),Te(e,"scroll",e))}),Ql(i.scroller,"mousewheel",function(t){return In(e,t)}),Ql(i.scroller,"DOMMouseScroll",function(t){return In(e,t)}),Ql(i.wrapper,"scroll",function(){return i.wrapper.scrollTop=i.wrapper.scrollLeft=0}),i.dragFunctions={enter:function(t){Me(e,t)||Fe(t)},over:function(t){Me(e,t)||(Zi(e,t),Fe(t))},start:function(t){return qi(e,t)},drop:dn(e,$i),leave:function(t){Me(e,t)||Qi(e)}};var s=i.input.getField();Ql(s,"keyup",function(t){return To.call(e,t)}),Ql(s,"keydown",dn(e,Lo)),Ql(s,"keypress",dn(e,Mo)),Ql(s,"focus",function(t){return Hr(e,t)}),Ql(s,"blur",function(t){return Fr(e,t)})}function Yo(e,t,r,n){var i,o=e.doc;null==r&&(r="add"),"smart"==r&&(o.mode.indent?i=$e(e,t).state:r="prev");var l=e.options.tabSize,s=M(o,t),a=f(s.text,null,l);s.stateAfter&&(s.stateAfter=null);var u,c=s.text.match(/^\s*/)[0];if(n||/\S/.test(s.text)){if("smart"==r&&((u=o.mode.indent(i,s.text.slice(c.length),s.text))==Bl||u>150)){if(!n)return;r="prev"}}else u=0,r="not";"prev"==r?u=t>o.first?f(M(o,t-1).text,null,l):0:"add"==r?u=a+e.options.indentUnit:"subtract"==r?u=a-e.options.indentUnit:"number"==typeof r&&(u=a+r),u=Math.max(0,u);var h="",d=0;if(e.options.indentWithTabs)for(var g=Math.floor(u/l);g;--g)d+=l,h+="\t";if(d<u&&(h+=p(u-d)),h!=c)return Ei(o,h,E(t,0),E(t,c.length),"+input"),s.stateAfter=null,!0;for(var v=0;v<o.sel.ranges.length;v++){var m=o.sel.ranges[v];if(m.head.line==t&&m.head.ch<c.length){var y=E(t,c.length);gi(o,v,new Ts(y,y));break}}}function _o(e){qs=e}function $o(e,t,r,n,i){var o=e.doc;e.display.shift=!1,n||(n=o.sel);var l=e.state.pasteIncoming||"paste"==i,s=es(t),a=null;if(l&&n.ranges.length>1)if(qs&&qs.text.join("\n")==t){if(n.ranges.length%qs.text.length==0){a=[];for(var u=0;u<qs.text.length;u++)a.push(o.splitLines(qs.text[u]))}}else s.length==n.ranges.length&&e.options.pasteLinesPerSelection&&(a=v(s,function(e){return[e]}));for(var c,f=n.ranges.length-1;f>=0;f--){var h=n.ranges[f],d=h.from(),p=h.to();h.empty()&&(r&&r>0?d=E(d.line,d.ch-r):e.state.overwrite&&!l?p=E(p.line,Math.min(M(o,p.line).text.length,p.ch+g(s).length)):qs&&qs.lineWise&&qs.text.join("\n")==t&&(d=p=E(d.line,0))),c=e.curOp.updateInput;var m={from:d,to:p,text:a?a[f%a.length]:s,origin:i||(l?"paste":e.state.cutIncoming?"cut":"+input")};Oi(e.doc,m),bt(e,"inputRead",e,m)}t&&!l&&Zo(e,t),jr(e),e.curOp.updateInput=c,e.curOp.typing=!0,e.state.pasteIncoming=e.state.cutIncoming=!1}function qo(e,t){var r=e.clipboardData&&e.clipboardData.getData("Text");if(r)return e.preventDefault(),t.isReadOnly()||t.options.disableInput||hn(t,function(){return $o(t,r,0,null,"paste")}),!0}function Zo(e,t){if(e.options.electricChars&&e.options.smartIndent)for(var r=e.doc.sel,n=r.ranges.length-1;n>=0;n--){var i=r.ranges[n];if(!(i.head.ch>100||n&&r.ranges[n-1].head.line==i.head.line)){var o=e.getModeAt(i.head),l=!1;if(o.electricChars){for(var s=0;s<o.electricChars.length;s++)if(t.indexOf(o.electricChars.charAt(s))>-1){l=Yo(e,i.head.line,"smart");break}}else o.electricInput&&o.electricInput.test(M(e.doc,i.head.line).text.slice(0,i.head.ch))&&(l=Yo(e,i.head.line,"smart"));l&&bt(e,"electricInput",e,i.head.line)}}}function Qo(e){for(var t=[],r=[],n=0;n<e.doc.sel.ranges.length;n++){var i=e.doc.sel.ranges[n].head.line,o={anchor:E(i,0),head:E(i+1,0)};r.push(o),t.push(e.getRange(o.anchor,o.head))}return{text:t,ranges:r}}function Jo(e,t){e.setAttribute("autocorrect","off"),e.setAttribute("autocapitalize","off"),e.setAttribute("spellcheck",!!t)}function el(){var e=n("textarea",null,null,"position: absolute; bottom: -1em; padding: 0; width: 1px; height: 1em; outline: none"),t=n("div",[e],null,"overflow: hidden; position: relative; width: 3px; height: 0px;");return ml?e.style.width="1000px":e.setAttribute("wrap","off"),Ll&&(e.style.border="1px solid black"),Jo(e),t}function tl(e,t,r,n,i){function o(){var n=t.line+r;return!(n<e.first||n>=e.first+e.size)&&(t=new E(n,t.ch,t.sticky),u=M(e,n))}function l(n){var l;if(null==(l=i?go(e.cm,u,t,r):ho(u,t,r))){if(n||!o())return!1;t=po(i,e.cm,u,t.line,r)}else t=l;return!0}var s=t,a=r,u=M(e,t.line);if("char"==n)l();else if("column"==n)l(!0);else if("word"==n||"group"==n)for(var c=null,f="group"==n,h=e.cm&&e.cm.getHelper(t,"wordChars"),d=!0;!(r<0)||l(!d);d=!1){var p=u.text.charAt(t.ch)||"\n",g=x(p,h)?"w":f&&"\n"==p?"n":!f||/\s/.test(p)?null:"p";if(!f||d||g||(g="s"),c&&c!=g){r<0&&(r=1,l(),t.sticky="after");break}if(g&&(c=g),r>0&&!l(!d))break}var v=ki(e,t,s,a,!0);return I(s,v)&&(v.hitSide=!0),v}function rl(e,t,r,n){var i,o=e.doc,l=t.left;if("page"==n){var s=Math.min(e.display.wrapper.clientHeight,window.innerHeight||document.documentElement.clientHeight),a=Math.max(s-.5*mr(e.display),3);i=(r>0?t.bottom:t.top)+r*a}else"line"==n&&(i=r>0?t.bottom+3:t.top-3);for(var u;(u=cr(e,l,i)).outside;){if(r<0?i<=0:i>=o.height){u.hitSide=!0;break}i+=5*r}return u}function nl(e,t){var r=jt(e,t.line);if(!r||r.hidden)return null;var n=M(e.doc,t.line),i=Ut(r,n,t.line),o=Se(n,e.doc.direction),l="left";o&&(l=Ce(o,t.ch)%2?"right":"left");var s=_t(i.map,t.ch,l);return s.offset="right"==s.collapse?s.end:s.start,s}function il(e){for(var t=e;t;t=t.parentNode)if(/CodeMirror-gutter-wrapper/.test(t.className))return!0;return!1}function ol(e,t){return t&&(e.bad=!0),e}function ll(e,t,r,n,i){function o(e){return function(t){return t.id==e}}function l(){c&&(u+=f,c=!1)}function s(e){e&&(l(),u+=e)}function a(t){if(1==t.nodeType){var r=t.getAttribute("cm-text");if(null!=r)return void s(r||t.textContent.replace(/\u200b/g,""));var u,h=t.getAttribute("cm-marker");if(h){var d=e.findMarks(E(n,0),E(i+1,0),o(+h));return void(d.length&&(u=d[0].find(0))&&s(N(e.doc,u.from,u.to).join(f)))}if("false"==t.getAttribute("contenteditable"))return;var p=/^(pre|div|p)$/i.test(t.nodeName);p&&l();for(var g=0;g<t.childNodes.length;g++)a(t.childNodes[g]);p&&(c=!0)}else 3==t.nodeType&&s(t.nodeValue)}for(var u="",c=!1,f=e.doc.lineSeparator();a(t),t!=r;)t=t.nextSibling;return u}function sl(e,t,r){var n;if(t==e.display.lineDiv){if(!(n=e.display.lineDiv.childNodes[r]))return ol(e.clipPos(E(e.display.viewTo-1)),!0);t=null,r=0}else for(n=t;;n=n.parentNode){if(!n||n==e.display.lineDiv)return null;if(n.parentNode&&n.parentNode==e.display.lineDiv)break}for(var i=0;i<e.display.view.length;i++){var o=e.display.view[i];if(o.node==n)return al(o,t,r)}}function al(e,t,r){function n(t,r,n){for(var i=-1;i<(f?f.length:0);i++)for(var o=i<0?c.map:f[i],l=0;l<o.length;l+=3){var s=o[l+2];if(s==t||s==r){var a=W(i<0?e.line:e.rest[i]),u=o[l]+n;return(n<0||s!=t)&&(u=o[l+(n?1:0)]),E(a,u)}}}var i=e.text.firstChild,l=!1;if(!t||!o(i,t))return ol(E(W(e.line),0),!0);if(t==i&&(l=!0,t=i.childNodes[r],r=0,!t)){var s=e.rest?g(e.rest):e.line;return ol(E(W(s),s.text.length),l)}var a=3==t.nodeType?t:null,u=t;for(a||1!=t.childNodes.length||3!=t.firstChild.nodeType||(a=t.firstChild,r&&(r=a.nodeValue.length));u.parentNode!=i;)u=u.parentNode;var c=e.measure,f=c.maps,h=n(a,u,r);if(h)return ol(h,l);for(var d=u.nextSibling,p=a?a.nodeValue.length-r:0;d;d=d.nextSibling){if(h=n(d,d.firstChild,0))return ol(E(h.line,h.ch-p),l);p+=d.textContent.length}for(var v=u.previousSibling,m=r;v;v=v.previousSibling){if(h=n(v,v.firstChild,-1))return ol(E(h.line,h.ch+m),l);m+=v.textContent.length}}var ul=navigator.userAgent,cl=navigator.platform,fl=/gecko\/\d/i.test(ul),hl=/MSIE \d/.test(ul),dl=/Trident\/(?:[7-9]|\d{2,})\..*rv:(\d+)/.exec(ul),pl=/Edge\/(\d+)/.exec(ul),gl=hl||dl||pl,vl=gl&&(hl?document.documentMode||6:+(pl||dl)[1]),ml=!pl&&/WebKit\//.test(ul),yl=ml&&/Qt\/\d+\.\d+/.test(ul),bl=!pl&&/Chrome\//.test(ul),wl=/Opera\//.test(ul),xl=/Apple Computer/.test(navigator.vendor),Cl=/Mac OS X 1\d\D([8-9]|\d\d)\D/.test(ul),Sl=/PhantomJS/.test(ul),Ll=!pl&&/AppleWebKit/.test(ul)&&/Mobile\/\w+/.test(ul),kl=/Android/.test(ul),Tl=Ll||kl||/webOS|BlackBerry|Opera Mini|Opera Mobi|IEMobile/i.test(ul),Ml=Ll||/Mac/.test(cl),Nl=/\bCrOS\b/.test(ul),Ol=/win/i.test(cl),Al=wl&&ul.match(/Version\/(\d*\.\d*)/);Al&&(Al=Number(Al[1])),Al&&Al>=15&&(wl=!1,ml=!0);var Wl,Dl=Ml&&(yl||wl&&(null==Al||Al<12.11)),Hl=fl||gl&&vl>=9,Fl=function(t,r){var n=t.className,i=e(r).exec(n);if(i){var o=n.slice(i.index+i[0].length);t.className=n.slice(0,i.index)+(o?i[1]+o:"")}};Wl=document.createRange?function(e,t,r,n){var i=document.createRange();return i.setEnd(n||e,r),i.setStart(e,t),i}:function(e,t,r){var n=document.body.createTextRange();try{n.moveToElementText(e.parentNode)}catch(e){return n}return n.collapse(!0),n.moveEnd("character",r),n.moveStart("character",t),n};var El=function(e){e.select()};Ll?El=function(e){e.selectionStart=0,e.selectionEnd=e.value.length}:gl&&(El=function(e){try{e.select()}catch(e){}});var Pl=function(){this.id=null};Pl.prototype.set=function(e,t){clearTimeout(this.id),this.id=setTimeout(t,e)};var Il,zl,Rl=30,Bl={toString:function(){return"CodeMirror.Pass"}},Gl={scroll:!1},Ul={origin:"*mouse"},Vl={origin:"+move"},Kl=[""],jl=/[\u00df\u0587\u0590-\u05f4\u0600-\u06ff\u3040-\u309f\u30a0-\u30ff\u3400-\u4db5\u4e00-\u9fcc\uac00-\ud7af]/,Xl=/[\u0300-\u036f\u0483-\u0489\u0591-\u05bd\u05bf\u05c1\u05c2\u05c4\u05c5\u05c7\u0610-\u061a\u064b-\u065e\u0670\u06d6-\u06dc\u06de-\u06e4\u06e7\u06e8\u06ea-\u06ed\u0711\u0730-\u074a\u07a6-\u07b0\u07eb-\u07f3\u0816-\u0819\u081b-\u0823\u0825-\u0827\u0829-\u082d\u0900-\u0902\u093c\u0941-\u0948\u094d\u0951-\u0955\u0962\u0963\u0981\u09bc\u09be\u09c1-\u09c4\u09cd\u09d7\u09e2\u09e3\u0a01\u0a02\u0a3c\u0a41\u0a42\u0a47\u0a48\u0a4b-\u0a4d\u0a51\u0a70\u0a71\u0a75\u0a81\u0a82\u0abc\u0ac1-\u0ac5\u0ac7\u0ac8\u0acd\u0ae2\u0ae3\u0b01\u0b3c\u0b3e\u0b3f\u0b41-\u0b44\u0b4d\u0b56\u0b57\u0b62\u0b63\u0b82\u0bbe\u0bc0\u0bcd\u0bd7\u0c3e-\u0c40\u0c46-\u0c48\u0c4a-\u0c4d\u0c55\u0c56\u0c62\u0c63\u0cbc\u0cbf\u0cc2\u0cc6\u0ccc\u0ccd\u0cd5\u0cd6\u0ce2\u0ce3\u0d3e\u0d41-\u0d44\u0d4d\u0d57\u0d62\u0d63\u0dca\u0dcf\u0dd2-\u0dd4\u0dd6\u0ddf\u0e31\u0e34-\u0e3a\u0e47-\u0e4e\u0eb1\u0eb4-\u0eb9\u0ebb\u0ebc\u0ec8-\u0ecd\u0f18\u0f19\u0f35\u0f37\u0f39\u0f71-\u0f7e\u0f80-\u0f84\u0f86\u0f87\u0f90-\u0f97\u0f99-\u0fbc\u0fc6\u102d-\u1030\u1032-\u1037\u1039\u103a\u103d\u103e\u1058\u1059\u105e-\u1060\u1071-\u1074\u1082\u1085\u1086\u108d\u109d\u135f\u1712-\u1714\u1732-\u1734\u1752\u1753\u1772\u1773\u17b7-\u17bd\u17c6\u17c9-\u17d3\u17dd\u180b-\u180d\u18a9\u1920-\u1922\u1927\u1928\u1932\u1939-\u193b\u1a17\u1a18\u1a56\u1a58-\u1a5e\u1a60\u1a62\u1a65-\u1a6c\u1a73-\u1a7c\u1a7f\u1b00-\u1b03\u1b34\u1b36-\u1b3a\u1b3c\u1b42\u1b6b-\u1b73\u1b80\u1b81\u1ba2-\u1ba5\u1ba8\u1ba9\u1c2c-\u1c33\u1c36\u1c37\u1cd0-\u1cd2\u1cd4-\u1ce0\u1ce2-\u1ce8\u1ced\u1dc0-\u1de6\u1dfd-\u1dff\u200c\u200d\u20d0-\u20f0\u2cef-\u2cf1\u2de0-\u2dff\u302a-\u302f\u3099\u309a\ua66f-\ua672\ua67c\ua67d\ua6f0\ua6f1\ua802\ua806\ua80b\ua825\ua826\ua8c4\ua8e0-\ua8f1\ua926-\ua92d\ua947-\ua951\ua980-\ua982\ua9b3\ua9b6-\ua9b9\ua9bc\uaa29-\uaa2e\uaa31\uaa32\uaa35\uaa36\uaa43\uaa4c\uaab0\uaab2-\uaab4\uaab7\uaab8\uaabe\uaabf\uaac1\uabe5\uabe8\uabed\udc00-\udfff\ufb1e\ufe00-\ufe0f\ufe20-\ufe26\uff9e\uff9f]/,Yl=!1,_l=!1,$l=null,ql=function(){function e(e){return e<=247?r.charAt(e):1424<=e&&e<=1524?"R":1536<=e&&e<=1785?n.charAt(e-1536):1774<=e&&e<=2220?"r":8192<=e&&e<=8203?"w":8204==e?"b":"L"}function t(e,t,r){this.level=e,this.from=t,this.to=r}var r="bbbbbbbbbtstwsbbbbbbbbbbbbbbssstwNN%%%NNNNNN,N,N1111111111NNNNNNNLLLLLLLLLLLLLLLLLLLLLLLLLLNNNNNNLLLLLLLLLLLLLLLLLLLLLLLLLLNNNNbbbbbbsbbbbbbbbbbbbbbbbbbbbbbbbbb,N%%%%NNNNLNNNNN%%11NLNNN1LNNNNNLLLLLLLLLLLLLLLLLLLLLLLNLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLN",n="nnnnnnNNr%%r,rNNmmmmmmmmmmmrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrmmmmmmmmmmmmmmmmmmmmmnnnnnnnnnn%nnrrrmrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrmmmmmmmnNmmmmmmrrmmNmmmmrr1111111111",i=/[\u0590-\u05f4\u0600-\u06ff\u0700-\u08ac]/,o=/[stwN]/,l=/[LRr]/,s=/[Lb1n]/,a=/[1n]/;return function(r,n){var u="ltr"==n?"L":"R";if(0==r.length||"ltr"==n&&!i.test(r))return!1;for(var c=r.length,f=[],h=0;h<c;++h)f.push(e(r.charCodeAt(h)));for(var d=0,p=u;d<c;++d){var v=f[d];"m"==v?f[d]=p:p=v}for(var m=0,y=u;m<c;++m){var b=f[m];"1"==b&&"r"==y?f[m]="n":l.test(b)&&(y=b,"r"==b&&(f[m]="R"))}for(var w=1,x=f[0];w<c-1;++w){var C=f[w];"+"==C&&"1"==x&&"1"==f[w+1]?f[w]="1":","!=C||x!=f[w+1]||"1"!=x&&"n"!=x||(f[w]=x),x=C}for(var S=0;S<c;++S){var L=f[S];if(","==L)f[S]="N";else if("%"==L){var k=void 0;for(k=S+1;k<c&&"%"==f[k];++k);for(var T=S&&"!"==f[S-1]||k<c&&"1"==f[k]?"1":"N",M=S;M<k;++M)f[M]=T;S=k-1}}for(var N=0,O=u;N<c;++N){var A=f[N];"L"==O&&"1"==A?f[N]="L":l.test(A)&&(O=A)}for(var W=0;W<c;++W)if(o.test(f[W])){var D=void 0;for(D=W+1;D<c&&o.test(f[D]);++D);for(var H="L"==(W?f[W-1]:u),F=H==("L"==(D<c?f[D]:u))?H?"L":"R":u,E=W;E<D;++E)f[E]=F;W=D-1}for(var P,I=[],z=0;z<c;)if(s.test(f[z])){var R=z;for(++z;z<c&&s.test(f[z]);++z);I.push(new t(0,R,z))}else{var B=z,G=I.length;for(++z;z<c&&"L"!=f[z];++z);for(var U=B;U<z;)if(a.test(f[U])){B<U&&I.splice(G,0,new t(1,B,U));var V=U;for(++U;U<z&&a.test(f[U]);++U);I.splice(G,0,new t(2,V,U)),B=U}else++U;B<z&&I.splice(G,0,new t(1,B,z))}return 1==I[0].level&&(P=r.match(/^\s+/))&&(I[0].from=P[0].length,I.unshift(new t(0,0,P[0].length))),1==g(I).level&&(P=r.match(/\s+$/))&&(g(I).to-=P[0].length,I.push(new t(0,c-P[0].length,c))),"rtl"==n?I.reverse():I}}(),Zl=[],Ql=function(e,t,r){if(e.addEventListener)e.addEventListener(t,r,!1);else if(e.attachEvent)e.attachEvent("on"+t,r);else{var n=e._handlers||(e._handlers={});n[t]=(n[t]||Zl).concat(r)}},Jl=function(){if(gl&&vl<9)return!1;var e=n("div");return"draggable"in e||"dragDrop"in e}(),es=3!="\n\nb".split(/\n/).length?function(e){for(var t=0,r=[],n=e.length;t<=n;){var i=e.indexOf("\n",t);-1==i&&(i=e.length);var o=e.slice(t,"\r"==e.charAt(i-1)?i-1:i),l=o.indexOf("\r");-1!=l?(r.push(o.slice(0,l)),t+=l+1):(r.push(o),t=i+1)}return r}:function(e){return e.split(/\r\n?|\n/)},ts=window.getSelection?function(e){try{return e.selectionStart!=e.selectionEnd}catch(e){return!1}}:function(e){var t;try{t=e.ownerDocument.selection.createRange()}catch(e){}return!(!t||t.parentElement()!=e)&&0!=t.compareEndPoints("StartToEnd",t)},rs=function(){var e=n("div");return"oncopy"in e||(e.setAttribute("oncopy","return;"),"function"==typeof e.oncopy)}(),ns=null,is={},os={},ls={},ss=function(e,t,r){this.pos=this.start=0,this.string=e,this.tabSize=t||8,this.lastColumnPos=this.lastColumnValue=0,this.lineStart=0,this.lineOracle=r};ss.prototype.eol=function(){return this.pos>=this.string.length},ss.prototype.sol=function(){return this.pos==this.lineStart},ss.prototype.peek=function(){return this.string.charAt(this.pos)||void 0},ss.prototype.next=function(){if(this.pos<this.string.length)return this.string.charAt(this.pos++)},ss.prototype.eat=function(e){var t=this.string.charAt(this.pos);if("string"==typeof e?t==e:t&&(e.test?e.test(t):e(t)))return++this.pos,t},ss.prototype.eatWhile=function(e){for(var t=this.pos;this.eat(e););return this.pos>t},ss.prototype.eatSpace=function(){for(var e=this,t=this.pos;/[\s\u00a0]/.test(this.string.charAt(this.pos));)++e.pos;return this.pos>t},ss.prototype.skipToEnd=function(){this.pos=this.string.length},ss.prototype.skipTo=function(e){var t=this.string.indexOf(e,this.pos);if(t>-1)return this.pos=t,!0},ss.prototype.backUp=function(e){this.pos-=e},ss.prototype.column=function(){return this.lastColumnPos<this.start&&(this.lastColumnValue=f(this.string,this.start,this.tabSize,this.lastColumnPos,this.lastColumnValue),this.lastColumnPos=this.start),this.lastColumnValue-(this.lineStart?f(this.string,this.lineStart,this.tabSize):0)},ss.prototype.indentation=function(){return f(this.string,null,this.tabSize)-(this.lineStart?f(this.string,this.lineStart,this.tabSize):0)},ss.prototype.match=function(e,t,r){if("string"!=typeof e){var n=this.string.slice(this.pos).match(e);return n&&n.index>0?null:(n&&!1!==t&&(this.pos+=n[0].length),n)}var i=function(e){return r?e.toLowerCase():e};if(i(this.string.substr(this.pos,e.length))==i(e))return!1!==t&&(this.pos+=e.length),!0},ss.prototype.current=function(){return this.string.slice(this.start,this.pos)},ss.prototype.hideFirstChars=function(e,t){this.lineStart+=e;try{return t()}finally{this.lineStart-=e}},ss.prototype.lookAhead=function(e){var t=this.lineOracle;return t&&t.lookAhead(e)};var as=function(e,t){this.state=e,this.lookAhead=t},us=function(e,t,r,n){this.state=t,this.doc=e,this.line=r,this.maxLookAhead=n||0};us.prototype.lookAhead=function(e){var t=this.doc.getLine(this.line+e);return null!=t&&e>this.maxLookAhead&&(this.maxLookAhead=e),t},us.prototype.nextLine=function(){this.line++,this.maxLookAhead>0&&this.maxLookAhead--},us.fromSaved=function(e,t,r){return t instanceof as?new us(e,Ke(e.mode,t.state),r,t.lookAhead):new us(e,Ke(e.mode,t),r)},us.prototype.save=function(e){var t=!1!==e?Ke(this.doc.mode,this.state):this.state;return this.maxLookAhead>0?new as(t,this.maxLookAhead):t};var cs=function(e,t,r){this.start=e.start,this.end=e.pos,this.string=e.current(),this.type=t||null,this.state=r},fs=function(e,t,r){this.text=e,ne(this,t),this.height=r?r(this):1};fs.prototype.lineNo=function(){return W(this)},Ae(fs);var hs,ds={},ps={},gs=null,vs=null,ms={left:0,right:0,top:0,bottom:0},ys=function(e,t,r){this.cm=r;var i=this.vert=n("div",[n("div",null,null,"min-width: 1px")],"CodeMirror-vscrollbar"),o=this.horiz=n("div",[n("div",null,null,"height: 100%; min-height: 1px")],"CodeMirror-hscrollbar");e(i),e(o),Ql(i,"scroll",function(){i.clientHeight&&t(i.scrollTop,"vertical")}),Ql(o,"scroll",function(){o.clientWidth&&t(o.scrollLeft,"horizontal")}),this.checkedZeroWidth=!1,gl&&vl<8&&(this.horiz.style.minHeight=this.vert.style.minWidth="18px")};ys.prototype.update=function(e){var t=e.scrollWidth>e.clientWidth+1,r=e.scrollHeight>e.clientHeight+1,n=e.nativeBarWidth;if(r){this.vert.style.display="block",this.vert.style.bottom=t?n+"px":"0";var i=e.viewHeight-(t?n:0);this.vert.firstChild.style.height=Math.max(0,e.scrollHeight-e.clientHeight+i)+"px"}else this.vert.style.display="",this.vert.firstChild.style.height="0";if(t){this.horiz.style.display="block",this.horiz.style.right=r?n+"px":"0",this.horiz.style.left=e.barLeft+"px";var o=e.viewWidth-e.barLeft-(r?n:0);this.horiz.firstChild.style.width=Math.max(0,e.scrollWidth-e.clientWidth+o)+"px"}else this.horiz.style.display="",this.horiz.firstChild.style.width="0";return!this.checkedZeroWidth&&e.clientHeight>0&&(0==n&&this.zeroWidthHack(),this.checkedZeroWidth=!0),{right:r?n:0,bottom:t?n:0}},ys.prototype.setScrollLeft=function(e){this.horiz.scrollLeft!=e&&(this.horiz.scrollLeft=e),this.disableHoriz&&this.enableZeroWidthBar(this.horiz,this.disableHoriz,"horiz")},ys.prototype.setScrollTop=function(e){this.vert.scrollTop!=e&&(this.vert.scrollTop=e),this.disableVert&&this.enableZeroWidthBar(this.vert,this.disableVert,"vert")},ys.prototype.zeroWidthHack=function(){var e=Ml&&!Cl?"12px":"18px";this.horiz.style.height=this.vert.style.width=e,this.horiz.style.pointerEvents=this.vert.style.pointerEvents="none",this.disableHoriz=new Pl,this.disableVert=new Pl},ys.prototype.enableZeroWidthBar=function(e,t,r){function n(){var i=e.getBoundingClientRect();("vert"==r?document.elementFromPoint(i.right-1,(i.top+i.bottom)/2):document.elementFromPoint((i.right+i.left)/2,i.bottom-1))!=e?e.style.pointerEvents="none":t.set(1e3,n)}e.style.pointerEvents="auto",t.set(1e3,n)},ys.prototype.clear=function(){var e=this.horiz.parentNode;e.removeChild(this.horiz),e.removeChild(this.vert)};var bs=function(){};bs.prototype.update=function(){return{bottom:0,right:0}},bs.prototype.setScrollLeft=function(){},bs.prototype.setScrollTop=function(){},bs.prototype.clear=function(){};var ws={native:ys,null:bs},xs=0,Cs=function(e,t,r){var n=e.display;this.viewport=t,this.visible=Ir(n,e.doc,t),this.editorIsHidden=!n.wrapper.offsetWidth,this.wrapperHeight=n.wrapper.clientHeight,this.wrapperWidth=n.wrapper.clientWidth,this.oldDisplayWidth=Rt(e),this.force=r,this.dims=br(e),this.events=[]};Cs.prototype.signal=function(e,t){Oe(e,t)&&this.events.push(arguments)},Cs.prototype.finish=function(){for(var e=this,t=0;t<this.events.length;t++)Te.apply(null,e.events[t])};var Ss=0,Ls=null;gl?Ls=-.53:fl?Ls=15:bl?Ls=-.7:xl&&(Ls=-1/3);var ks=function(e,t){this.ranges=e,this.primIndex=t};ks.prototype.primary=function(){return this.ranges[this.primIndex]},ks.prototype.equals=function(e){var t=this;if(e==this)return!0;if(e.primIndex!=this.primIndex||e.ranges.length!=this.ranges.length)return!1;for(var r=0;r<this.ranges.length;r++){var n=t.ranges[r],i=e.ranges[r];if(!I(n.anchor,i.anchor)||!I(n.head,i.head))return!1}return!0},ks.prototype.deepCopy=function(){for(var e=this,t=[],r=0;r<this.ranges.length;r++)t[r]=new Ts(z(e.ranges[r].anchor),z(e.ranges[r].head));return new ks(t,this.primIndex)},ks.prototype.somethingSelected=function(){for(var e=this,t=0;t<this.ranges.length;t++)if(!e.ranges[t].empty())return!0;return!1},ks.prototype.contains=function(e,t){var r=this;t||(t=e);for(var n=0;n<this.ranges.length;n++){var i=r.ranges[n];if(P(t,i.from())>=0&&P(e,i.to())<=0)return n}return-1};var Ts=function(e,t){this.anchor=e,this.head=t};Ts.prototype.from=function(){return B(this.anchor,this.head)},Ts.prototype.to=function(){return R(this.anchor,this.head)},Ts.prototype.empty=function(){return this.head.line==this.anchor.line&&this.head.ch==this.anchor.ch},Bi.prototype={chunkSize:function(){return this.lines.length},removeInner:function(e,t){for(var r=this,n=e,i=e+t;n<i;++n){var o=r.lines[n];r.height-=o.height,ot(o),bt(o,"delete")}this.lines.splice(e,t)},collapse:function(e){e.push.apply(e,this.lines)},insertInner:function(e,t,r){var n=this;this.height+=r,this.lines=this.lines.slice(0,e).concat(t).concat(this.lines.slice(e));for(var i=0;i<t.length;++i)t[i].parent=n},iterN:function(e,t,r){for(var n=this,i=e+t;e<i;++e)if(r(n.lines[e]))return!0}},Gi.prototype={chunkSize:function(){return this.size},removeInner:function(e,t){var r=this;this.size-=t;for(var n=0;n<this.children.length;++n){var i=r.children[n],o=i.chunkSize();if(e<o){var l=Math.min(t,o-e),s=i.height;if(i.removeInner(e,l),r.height-=s-i.height,o==l&&(r.children.splice(n--,1),i.parent=null),0==(t-=l))break;e=0}else e-=o}if(this.size-t<25&&(this.children.length>1||!(this.children[0]instanceof Bi))){var a=[];this.collapse(a),this.children=[new Bi(a)],this.children[0].parent=this}},collapse:function(e){for(var t=this,r=0;r<this.children.length;++r)t.children[r].collapse(e)},insertInner:function(e,t,r){var n=this;this.size+=t.length,this.height+=r;for(var i=0;i<this.children.length;++i){var o=n.children[i],l=o.chunkSize();if(e<=l){if(o.insertInner(e,t,r),o.lines&&o.lines.length>50){for(var s=o.lines.length%25+25,a=s;a<o.lines.length;){var u=new Bi(o.lines.slice(a,a+=25));o.height-=u.height,n.children.splice(++i,0,u),u.parent=n}o.lines=o.lines.slice(0,s),n.maybeSpill()}break}e-=l}},maybeSpill:function(){if(!(this.children.length<=10)){var e=this;do{var t=new Gi(e.children.splice(e.children.length-5,5));if(e.parent){e.size-=t.size,e.height-=t.height;var r=h(e.parent.children,e);e.parent.children.splice(r+1,0,t)}else{var n=new Gi(e.children);n.parent=e,e.children=[n,t],e=n}t.parent=e.parent}while(e.children.length>10);e.parent.maybeSpill()}},iterN:function(e,t,r){for(var n=this,i=0;i<this.children.length;++i){var o=n.children[i],l=o.chunkSize();if(e<l){var s=Math.min(t,l-e);if(o.iterN(e,s,r))return!0;if(0==(t-=s))break;e=0}else e-=l}}};var Ms=function(e,t,r){var n=this;if(r)for(var i in r)r.hasOwnProperty(i)&&(n[i]=r[i]);this.doc=e,this.node=t};Ms.prototype.clear=function(){var e=this,t=this.doc.cm,r=this.line.widgets,n=this.line,i=W(n);if(null!=i&&r){for(var o=0;o<r.length;++o)r[o]==e&&r.splice(o--,1);r.length||(n.widgets=null);var l=Ht(this);A(n,Math.max(0,n.height-l)),t&&(hn(t,function(){Ui(t,n,-l),mn(t,i,"widget")}),bt(t,"lineWidgetCleared",t,this,i))}},Ms.prototype.changed=function(){var e=this,t=this.height,r=this.doc.cm,n=this.line;this.height=null;var i=Ht(this)-t;i&&(A(n,n.height+i),r&&hn(r,function(){r.curOp.forceUpdate=!0,Ui(r,n,i),bt(r,"lineWidgetChanged",r,e,W(n))}))},Ae(Ms);var Ns=0,Os=function(e,t){this.lines=[],this.type=t,this.doc=e,this.id=++Ns};Os.prototype.clear=function(){var e=this;if(!this.explicitlyCleared){var t=this.doc.cm,r=t&&!t.curOp;if(r&&nn(t),Oe(this,"clear")){var n=this.find();n&&bt(this,"clear",n.from,n.to)}for(var i=null,o=null,l=0;l<this.lines.length;++l){var s=e.lines[l],a=_(s.markedSpans,e);t&&!e.collapsed?mn(t,W(s),"text"):t&&(null!=a.to&&(o=W(s)),null!=a.from&&(i=W(s))),s.markedSpans=$(s.markedSpans,a),null==a.from&&e.collapsed&&!ve(e.doc,s)&&t&&A(s,mr(t.display))}if(t&&this.collapsed&&!t.options.lineWrapping)for(var u=0;u<this.lines.length;++u){var c=fe(e.lines[u]),f=be(c);f>t.display.maxLineLength&&(t.display.maxLine=c,t.display.maxLineLength=f,t.display.maxLineChanged=!0)}null!=i&&t&&this.collapsed&&vn(t,i,o+1),this.lines.length=0,this.explicitlyCleared=!0,this.atomic&&this.doc.cantEdit&&(this.doc.cantEdit=!1,t&&Ci(t.doc)),t&&bt(t,"markerCleared",t,this,i,o),r&&on(t),this.parent&&this.parent.clear()}},Os.prototype.find=function(e,t){var r=this;null==e&&"bookmark"==this.type&&(e=1);for(var n,i,o=0;o<this.lines.length;++o){var l=r.lines[o],s=_(l.markedSpans,r);if(null!=s.from&&(n=E(t?l:W(l),s.from),-1==e))return n;if(null!=s.to&&(i=E(t?l:W(l),s.to),1==e))return i}return n&&{from:n,to:i}},Os.prototype.changed=function(){var e=this,t=this.find(-1,!0),r=this,n=this.doc.cm;t&&n&&hn(n,function(){var i=t.line,o=W(t.line),l=jt(n,o);if(l&&(Qt(l),n.curOp.selectionChanged=n.curOp.forceUpdate=!0),n.curOp.updateMaxLine=!0,!ve(r.doc,i)&&null!=r.height){var s=r.height;r.height=null;var a=Ht(r)-s;a&&A(i,i.height+a)}bt(n,"markerChanged",n,e)})},Os.prototype.attachLine=function(e){if(!this.lines.length&&this.doc.cm){var t=this.doc.cm.curOp;t.maybeHiddenMarkers&&-1!=h(t.maybeHiddenMarkers,this)||(t.maybeUnhiddenMarkers||(t.maybeUnhiddenMarkers=[])).push(this)}this.lines.push(e)},Os.prototype.detachLine=function(e){if(this.lines.splice(h(this.lines,e),1),!this.lines.length&&this.doc.cm){var t=this.doc.cm.curOp;(t.maybeHiddenMarkers||(t.maybeHiddenMarkers=[])).push(this)}},Ae(Os);var As=function(e,t){var r=this;this.markers=e,this.primary=t;for(var n=0;n<e.length;++n)e[n].parent=r};As.prototype.clear=function(){var e=this;if(!this.explicitlyCleared){this.explicitlyCleared=!0;for(var t=0;t<this.markers.length;++t)e.markers[t].clear();bt(this,"clear")}},As.prototype.find=function(e,t){return this.primary.find(e,t)},Ae(As);var Ws=0,Ds=function(e,t,r,n,i){if(!(this instanceof Ds))return new Ds(e,t,r,n,i);null==r&&(r=0),Gi.call(this,[new Bi([new fs("",null)])]),this.first=r,this.scrollTop=this.scrollLeft=0,this.cantEdit=!1,this.cleanGeneration=1,this.modeFrontier=this.highlightFrontier=r;var o=E(r,0);this.sel=Rn(o),this.history=new Jn(null),this.id=++Ws,this.modeOption=t,this.lineSep=n,this.direction="rtl"==i?"rtl":"ltr",this.extend=!1,"string"==typeof e&&(e=this.splitLines(e)),_n(this,{from:o,to:o,text:e}),bi(this,Rn(o),Gl)};Ds.prototype=b(Gi.prototype,{constructor:Ds,iter:function(e,t,r){r?this.iterN(e-this.first,t-e,r):this.iterN(this.first,this.first+this.size,e)},insert:function(e,t){for(var r=0,n=0;n<t.length;++n)r+=t[n].height;this.insertInner(e-this.first,t,r)},remove:function(e,t){this.removeInner(e-this.first,t)},getValue:function(e){var t=O(this,this.first,this.first+this.size);return!1===e?t:t.join(e||this.lineSeparator())},setValue:gn(function(e){var t=E(this.first,0),r=this.first+this.size-1;Oi(this,{from:t,to:E(r,M(this,r).text.length),text:this.splitLines(e),origin:"setValue",full:!0},!0),this.cm&&Xr(this.cm,0,0),bi(this,Rn(t),Gl)}),replaceRange:function(e,t,r,n){Ei(this,e,t=U(this,t),r=r?U(this,r):t,n)},getRange:function(e,t,r){var n=N(this,U(this,e),U(this,t));return!1===r?n:n.join(r||this.lineSeparator())},getLine:function(e){var t=this.getLineHandle(e);return t&&t.text},getLineHandle:function(e){if(H(this,e))return M(this,e)},getLineNumber:function(e){return W(e)},getLineHandleVisualStart:function(e){return"number"==typeof e&&(e=M(this,e)),fe(e)},lineCount:function(){return this.size},firstLine:function(){return this.first},lastLine:function(){return this.first+this.size-1},clipPos:function(e){return U(this,e)},getCursor:function(e){var t=this.sel.primary();return null==e||"head"==e?t.head:"anchor"==e?t.anchor:"end"==e||"to"==e||!1===e?t.to():t.from()},listSelections:function(){return this.sel.ranges},somethingSelected:function(){return this.sel.somethingSelected()},setCursor:gn(function(e,t,r){vi(this,U(this,"number"==typeof e?E(e,t||0):e),null,r)}),setSelection:gn(function(e,t,r){vi(this,U(this,e),U(this,t||e),r)}),extendSelection:gn(function(e,t,r){di(this,U(this,e),t&&U(this,t),r)}),extendSelections:gn(function(e,t){pi(this,K(this,e),t)}),extendSelectionsBy:gn(function(e,t){pi(this,K(this,v(this.sel.ranges,e)),t)}),setSelections:gn(function(e,t,r){var n=this;if(e.length){for(var i=[],o=0;o<e.length;o++)i[o]=new Ts(U(n,e[o].anchor),U(n,e[o].head));null==t&&(t=Math.min(e.length-1,this.sel.primIndex)),bi(this,zn(i,t),r)}}),addSelection:gn(function(e,t,r){var n=this.sel.ranges.slice(0);n.push(new Ts(U(this,e),U(this,t||e))),bi(this,zn(n,n.length-1),r)}),getSelection:function(e){for(var t,r=this,n=this.sel.ranges,i=0;i<n.length;i++){var o=N(r,n[i].from(),n[i].to());t=t?t.concat(o):o}return!1===e?t:t.join(e||this.lineSeparator())},getSelections:function(e){for(var t=this,r=[],n=this.sel.ranges,i=0;i<n.length;i++){var o=N(t,n[i].from(),n[i].to());!1!==e&&(o=o.join(e||t.lineSeparator())),r[i]=o}return r},replaceSelection:function(e,t,r){for(var n=[],i=0;i<this.sel.ranges.length;i++)n[i]=e;this.replaceSelections(n,t,r||"+input")},replaceSelections:gn(function(e,t,r){for(var n=this,i=[],o=this.sel,l=0;l<o.ranges.length;l++){var s=o.ranges[l];i[l]={from:s.from(),to:s.to(),text:n.splitLines(e[l]),origin:r}}for(var a=t&&"end"!=t&&Kn(this,i,t),u=i.length-1;u>=0;u--)Oi(n,i[u]);a?yi(this,a):this.cm&&jr(this.cm)}),undo:gn(function(){Wi(this,"undo")}),redo:gn(function(){Wi(this,"redo")}),undoSelection:gn(function(){Wi(this,"undo",!0)}),redoSelection:gn(function(){Wi(this,"redo",!0)}),setExtending:function(e){this.extend=e},getExtending:function(){return this.extend},historySize:function(){for(var e=this.history,t=0,r=0,n=0;n<e.done.length;n++)e.done[n].ranges||++t;for(var i=0;i<e.undone.length;i++)e.undone[i].ranges||++r;return{undo:t,redo:r}},clearHistory:function(){this.history=new Jn(this.history.maxGeneration)},markClean:function(){this.cleanGeneration=this.changeGeneration(!0)},changeGeneration:function(e){return e&&(this.history.lastOp=this.history.lastSelOp=this.history.lastOrigin=null),this.history.generation},isClean:function(e){return this.history.generation==(e||this.cleanGeneration)},getHistory:function(){return{done:fi(this.history.done),undone:fi(this.history.undone)}},setHistory:function(e){var t=this.history=new Jn(this.history.maxGeneration);t.done=fi(e.done.slice(0),null,!0),t.undone=fi(e.undone.slice(0),null,!0)},setGutterMarker:gn(function(e,t,r){return Ri(this,e,"gutter",function(e){var n=e.gutterMarkers||(e.gutterMarkers={});return n[t]=r,!r&&C(n)&&(e.gutterMarkers=null),!0})}),clearGutter:gn(function(e){var t=this;this.iter(function(r){r.gutterMarkers&&r.gutterMarkers[e]&&Ri(t,r,"gutter",function(){return r.gutterMarkers[e]=null,C(r.gutterMarkers)&&(r.gutterMarkers=null),!0})})}),lineInfo:function(e){var t;if("number"==typeof e){if(!H(this,e))return null;if(t=e,!(e=M(this,e)))return null}else if(null==(t=W(e)))return null;return{line:t,handle:e,text:e.text,gutterMarkers:e.gutterMarkers,textClass:e.textClass,bgClass:e.bgClass,wrapClass:e.wrapClass,widgets:e.widgets}},addLineClass:gn(function(t,r,n){return Ri(this,t,"gutter"==r?"gutter":"class",function(t){var i="text"==r?"textClass":"background"==r?"bgClass":"gutter"==r?"gutterClass":"wrapClass";if(t[i]){if(e(n).test(t[i]))return!1;t[i]+=" "+n}else t[i]=n;return!0})}),removeLineClass:gn(function(t,r,n){return Ri(this,t,"gutter"==r?"gutter":"class",function(t){var i="text"==r?"textClass":"background"==r?"bgClass":"gutter"==r?"gutterClass":"wrapClass",o=t[i];if(!o)return!1;if(null==n)t[i]=null;else{var l=o.match(e(n));if(!l)return!1;var s=l.index+l[0].length;t[i]=o.slice(0,l.index)+(l.index&&s!=o.length?" ":"")+o.slice(s)||null}return!0})}),addLineWidget:gn(function(e,t,r){return Vi(this,e,t,r)}),removeLineWidget:function(e){e.clear()},markText:function(e,t,r){return Ki(this,U(this,e),U(this,t),r,r&&r.type||"range")},setBookmark:function(e,t){var r={replacedWith:t&&(null==t.nodeType?t.widget:t),insertLeft:t&&t.insertLeft,clearWhenEmpty:!1,shared:t&&t.shared,handleMouseEvents:t&&t.handleMouseEvents};return e=U(this,e),Ki(this,e,e,r,"bookmark")},findMarksAt:function(e){var t=[],r=M(this,(e=U(this,e)).line).markedSpans;if(r)for(var n=0;n<r.length;++n){var i=r[n];(null==i.from||i.from<=e.ch)&&(null==i.to||i.to>=e.ch)&&t.push(i.marker.parent||i.marker)}return t},findMarks:function(e,t,r){e=U(this,e),t=U(this,t);var n=[],i=e.line;return this.iter(e.line,t.line+1,function(o){var l=o.markedSpans;if(l)for(var s=0;s<l.length;s++){var a=l[s];null!=a.to&&i==e.line&&e.ch>=a.to||null==a.from&&i!=e.line||null!=a.from&&i==t.line&&a.from>=t.ch||r&&!r(a.marker)||n.push(a.marker.parent||a.marker)}++i}),n},getAllMarks:function(){var e=[];return this.iter(function(t){var r=t.markedSpans;if(r)for(var n=0;n<r.length;++n)null!=r[n].from&&e.push(r[n].marker)}),e},posFromIndex:function(e){var t,r=this.first,n=this.lineSeparator().length;return this.iter(function(i){var o=i.text.length+n;if(o>e)return t=e,!0;e-=o,++r}),U(this,E(r,t))},indexFromPos:function(e){var t=(e=U(this,e)).ch;if(e.line<this.first||e.ch<0)return 0;var r=this.lineSeparator().length;return this.iter(this.first,e.line,function(e){t+=e.text.length+r}),t},copy:function(e){var t=new Ds(O(this,this.first,this.first+this.size),this.modeOption,this.first,this.lineSep,this.direction);return t.scrollTop=this.scrollTop,t.scrollLeft=this.scrollLeft,t.sel=this.sel,t.extend=!1,e&&(t.history.undoDepth=this.history.undoDepth,t.setHistory(this.getHistory())),t},linkedDoc:function(e){e||(e={});var t=this.first,r=this.first+this.size;null!=e.from&&e.from>t&&(t=e.from),null!=e.to&&e.to<r&&(r=e.to);var n=new Ds(O(this,t,r),e.mode||this.modeOption,t,this.lineSep,this.direction);return e.sharedHist&&(n.history=this.history),(this.linked||(this.linked=[])).push({doc:n,sharedHist:e.sharedHist}),n.linked=[{doc:this,isParent:!0,sharedHist:e.sharedHist}],Yi(n,Xi(this)),n},unlinkDoc:function(e){var t=this;if(e instanceof jo&&(e=e.doc),this.linked)for(var r=0;r<this.linked.length;++r)if(t.linked[r].doc==e){t.linked.splice(r,1),e.unlinkDoc(t),_i(Xi(t));break}if(e.history==this.history){var n=[e.id];$n(e,function(e){return n.push(e.id)},!0),e.history=new Jn(null),e.history.done=fi(this.history.done,n),e.history.undone=fi(this.history.undone,n)}},iterLinkedDocs:function(e){$n(this,e)},getMode:function(){return this.mode},getEditor:function(){return this.cm},splitLines:function(e){return this.lineSep?e.split(this.lineSep):es(e)},lineSeparator:function(){return this.lineSep||"\n"},setDirection:gn(function(e){"rtl"!=e&&(e="ltr"),e!=this.direction&&(this.direction=e,this.iter(function(e){return e.order=null}),this.cm&&Qn(this.cm))})}),Ds.prototype.eachLine=Ds.prototype.iter;for(var Hs=0,Fs=!1,Es={3:"Enter",8:"Backspace",9:"Tab",13:"Enter",16:"Shift",17:"Ctrl",18:"Alt",19:"Pause",20:"CapsLock",27:"Esc",32:"Space",33:"PageUp",34:"PageDown",35:"End",36:"Home",37:"Left",38:"Up",39:"Right",40:"Down",44:"PrintScrn",45:"Insert",46:"Delete",59:";",61:"=",91:"Mod",92:"Mod",93:"Mod",106:"*",107:"=",109:"-",110:".",111:"/",127:"Delete",173:"-",186:";",187:"=",188:",",189:"-",190:".",191:"/",192:"`",219:"[",220:"\\",221:"]",222:"'",63232:"Up",63233:"Down",63234:"Left",63235:"Right",63272:"Delete",63273:"Home",63275:"End",63276:"PageUp",63277:"PageDown",63302:"Insert"},Ps=0;Ps<10;Ps++)Es[Ps+48]=Es[Ps+96]=String(Ps);for(var Is=65;Is<=90;Is++)Es[Is]=String.fromCharCode(Is);for(var zs=1;zs<=12;zs++)Es[zs+111]=Es[zs+63235]="F"+zs;var Rs={};Rs.basic={Left:"goCharLeft",Right:"goCharRight",Up:"goLineUp",Down:"goLineDown",End:"goLineEnd",Home:"goLineStartSmart",PageUp:"goPageUp",PageDown:"goPageDown",Delete:"delCharAfter",Backspace:"delCharBefore","Shift-Backspace":"delCharBefore",Tab:"defaultTab","Shift-Tab":"indentAuto",Enter:"newlineAndIndent",Insert:"toggleOverwrite",Esc:"singleSelection"},Rs.pcDefault={"Ctrl-A":"selectAll","Ctrl-D":"deleteLine","Ctrl-Z":"undo","Shift-Ctrl-Z":"redo","Ctrl-Y":"redo","Ctrl-Home":"goDocStart","Ctrl-End":"goDocEnd","Ctrl-Up":"goLineUp","Ctrl-Down":"goLineDown","Ctrl-Left":"goGroupLeft","Ctrl-Right":"goGroupRight","Alt-Left":"goLineStart","Alt-Right":"goLineEnd","Ctrl-Backspace":"delGroupBefore","Ctrl-Delete":"delGroupAfter","Ctrl-S":"save","Ctrl-F":"find","Ctrl-G":"findNext","Shift-Ctrl-G":"findPrev","Shift-Ctrl-F":"replace","Shift-Ctrl-R":"replaceAll","Ctrl-[":"indentLess","Ctrl-]":"indentMore","Ctrl-U":"undoSelection","Shift-Ctrl-U":"redoSelection","Alt-U":"redoSelection",fallthrough:"basic"},Rs.emacsy={"Ctrl-F":"goCharRight","Ctrl-B":"goCharLeft","Ctrl-P":"goLineUp","Ctrl-N":"goLineDown","Alt-F":"goWordRight","Alt-B":"goWordLeft","Ctrl-A":"goLineStart","Ctrl-E":"goLineEnd","Ctrl-V":"goPageDown","Shift-Ctrl-V":"goPageUp","Ctrl-D":"delCharAfter","Ctrl-H":"delCharBefore","Alt-D":"delWordAfter","Alt-Backspace":"delWordBefore","Ctrl-K":"killLine","Ctrl-T":"transposeChars","Ctrl-O":"openLine"},Rs.macDefault={"Cmd-A":"selectAll","Cmd-D":"deleteLine","Cmd-Z":"undo","Shift-Cmd-Z":"redo","Cmd-Y":"redo","Cmd-Home":"goDocStart","Cmd-Up":"goDocStart","Cmd-End":"goDocEnd","Cmd-Down":"goDocEnd","Alt-Left":"goGroupLeft","Alt-Right":"goGroupRight","Cmd-Left":"goLineLeft","Cmd-Right":"goLineRight","Alt-Backspace":"delGroupBefore","Ctrl-Alt-Backspace":"delGroupAfter","Alt-Delete":"delGroupAfter","Cmd-S":"save","Cmd-F":"find","Cmd-G":"findNext","Shift-Cmd-G":"findPrev","Cmd-Alt-F":"replace","Shift-Cmd-Alt-F":"replaceAll","Cmd-[":"indentLess","Cmd-]":"indentMore","Cmd-Backspace":"delWrappedLineLeft","Cmd-Delete":"delWrappedLineRight","Cmd-U":"undoSelection","Shift-Cmd-U":"redoSelection","Ctrl-Up":"goDocStart","Ctrl-Down":"goDocEnd",fallthrough:["basic","emacsy"]},Rs.default=Ml?Rs.macDefault:Rs.pcDefault;var Bs={selectAll:Mi,singleSelection:function(e){return e.setSelection(e.getCursor("anchor"),e.getCursor("head"),Gl)},killLine:function(e){return co(e,function(t){if(t.empty()){var r=M(e.doc,t.head.line).text.length;return t.head.ch==r&&t.head.line<e.lastLine()?{from:t.head,to:E(t.head.line+1,0)}:{from:t.head,to:E(t.head.line,r)}}return{from:t.from(),to:t.to()}})},deleteLine:function(e){return co(e,function(t){return{from:E(t.from().line,0),to:U(e.doc,E(t.to().line+1,0))}})},delLineLeft:function(e){return co(e,function(e){return{from:E(e.from().line,0),to:e.from()}})},delWrappedLineLeft:function(e){return co(e,function(t){var r=e.charCoords(t.head,"div").top+5;return{from:e.coordsChar({left:0,top:r},"div"),to:t.from()}})},delWrappedLineRight:function(e){return co(e,function(t){var r=e.charCoords(t.head,"div").top+5,n=e.coordsChar({left:e.display.lineDiv.offsetWidth+100,top:r},"div");return{from:t.from(),to:n}})},undo:function(e){return e.undo()},redo:function(e){return e.redo()},undoSelection:function(e){return e.undoSelection()},redoSelection:function(e){return e.redoSelection()},goDocStart:function(e){return e.extendSelection(E(e.firstLine(),0))},goDocEnd:function(e){return e.extendSelection(E(e.lastLine()))},goLineStart:function(e){return e.extendSelectionsBy(function(t){return vo(e,t.head.line)},{origin:"+move",bias:1})},goLineStartSmart:function(e){return e.extendSelectionsBy(function(t){return yo(e,t.head)},{origin:"+move",bias:1})},goLineEnd:function(e){return e.extendSelectionsBy(function(t){return mo(e,t.head.line)},{origin:"+move",bias:-1})},goLineRight:function(e){return e.extendSelectionsBy(function(t){var r=e.cursorCoords(t.head,"div").top+5;return e.coordsChar({left:e.display.lineDiv.offsetWidth+100,top:r},"div")},Vl)},goLineLeft:function(e){return e.extendSelectionsBy(function(t){var r=e.cursorCoords(t.head,"div").top+5;return e.coordsChar({left:0,top:r},"div")},Vl)},goLineLeftSmart:function(e){return e.extendSelectionsBy(function(t){var r=e.cursorCoords(t.head,"div").top+5,n=e.coordsChar({left:0,top:r},"div");return n.ch<e.getLine(n.line).search(/\S/)?yo(e,t.head):n},Vl)},goLineUp:function(e){return e.moveV(-1,"line")},goLineDown:function(e){return e.moveV(1,"line")},goPageUp:function(e){return e.moveV(-1,"page")},goPageDown:function(e){return e.moveV(1,"page")},goCharLeft:function(e){return e.moveH(-1,"char")},goCharRight:function(e){return e.moveH(1,"char")},goColumnLeft:function(e){return e.moveH(-1,"column")},goColumnRight:function(e){return e.moveH(1,"column")},goWordLeft:function(e){return e.moveH(-1,"word")},goGroupRight:function(e){return e.moveH(1,"group")},goGroupLeft:function(e){return e.moveH(-1,"group")},goWordRight:function(e){return e.moveH(1,"word")},delCharBefore:function(e){return e.deleteH(-1,"char")},delCharAfter:function(e){return e.deleteH(1,"char")},delWordBefore:function(e){return e.deleteH(-1,"word")},delWordAfter:function(e){return e.deleteH(1,"word")},delGroupBefore:function(e){return e.deleteH(-1,"group")},delGroupAfter:function(e){return e.deleteH(1,"group")},indentAuto:function(e){return e.indentSelection("smart")},indentMore:function(e){return e.indentSelection("add")},indentLess:function(e){return e.indentSelection("subtract")},insertTab:function(e){return e.replaceSelection("\t")},insertSoftTab:function(e){for(var t=[],r=e.listSelections(),n=e.options.tabSize,i=0;i<r.length;i++){var o=r[i].from(),l=f(e.getLine(o.line),o.ch,n);t.push(p(n-l%n))}e.replaceSelections(t)},defaultTab:function(e){e.somethingSelected()?e.indentSelection("add"):e.execCommand("insertTab")},transposeChars:function(e){return hn(e,function(){for(var t=e.listSelections(),r=[],n=0;n<t.length;n++)if(t[n].empty()){var i=t[n].head,o=M(e.doc,i.line).text;if(o)if(i.ch==o.length&&(i=new E(i.line,i.ch-1)),i.ch>0)i=new E(i.line,i.ch+1),e.replaceRange(o.charAt(i.ch-1)+o.charAt(i.ch-2),E(i.line,i.ch-2),i,"+transpose");else if(i.line>e.doc.first){var l=M(e.doc,i.line-1).text;l&&(i=new E(i.line,1),e.replaceRange(o.charAt(0)+e.doc.lineSeparator()+l.charAt(l.length-1),E(i.line-1,l.length-1),i,"+transpose"))}r.push(new Ts(i,i))}e.setSelections(r)})},newlineAndIndent:function(e){return hn(e,function(){for(var t=e.listSelections(),r=t.length-1;r>=0;r--)e.replaceRange(e.doc.lineSeparator(),t[r].anchor,t[r].head,"+input");t=e.listSelections();for(var n=0;n<t.length;n++)e.indentLine(t[n].from().line,null,!0);jr(e)})},openLine:function(e){return e.replaceSelection("\n","start")},toggleOverwrite:function(e){return e.toggleOverwrite()}},Gs=new Pl,Us=null,Vs=function(e,t,r){this.time=e,this.pos=t,this.button=r};Vs.prototype.compare=function(e,t,r){return this.time+400>e&&0==P(t,this.pos)&&r==this.button};var Ks,js,Xs={toString:function(){return"CodeMirror.Init"}},Ys={},_s={};jo.defaults=Ys,jo.optionHandlers=_s;var $s=[];jo.defineInitHook=function(e){return $s.push(e)};var qs=null,Zs=function(e){this.cm=e,this.lastAnchorNode=this.lastAnchorOffset=this.lastFocusNode=this.lastFocusOffset=null,this.polling=new Pl,this.composing=null,this.gracePeriod=!1,this.readDOMTimeout=null};Zs.prototype.init=function(e){function t(e){if(!Me(i,e)){if(i.somethingSelected())_o({lineWise:!1,text:i.getSelections()}),"cut"==e.type&&i.replaceSelection("",null,"cut");else{if(!i.options.lineWiseCopyCut)return;var t=Qo(i);_o({lineWise:!0,text:t.text}),"cut"==e.type&&i.operation(function(){i.setSelections(t.ranges,0,Gl),i.replaceSelection("",null,"cut")})}if(e.clipboardData){e.clipboardData.clearData();var r=qs.text.join("\n");if(e.clipboardData.setData("Text",r),e.clipboardData.getData("Text")==r)return void e.preventDefault()}var l=el(),s=l.firstChild;i.display.lineSpace.insertBefore(l,i.display.lineSpace.firstChild),s.value=qs.text.join("\n");var a=document.activeElement;El(s),setTimeout(function(){i.display.lineSpace.removeChild(l),a.focus(),a==o&&n.showPrimarySelection()},50)}}var r=this,n=this,i=n.cm,o=n.div=e.lineDiv;Jo(o,i.options.spellcheck),Ql(o,"paste",function(e){Me(i,e)||qo(e,i)||vl<=11&&setTimeout(dn(i,function(){return r.updateFromDOM()}),20)}),Ql(o,"compositionstart",function(e){r.composing={data:e.data,done:!1}}),Ql(o,"compositionupdate",function(e){r.composing||(r.composing={data:e.data,done:!1})}),Ql(o,"compositionend",function(e){r.composing&&(e.data!=r.composing.data&&r.readFromDOMSoon(),r.composing.done=!0)}),Ql(o,"touchstart",function(){return n.forceCompositionEnd()}),Ql(o,"input",function(){r.composing||r.readFromDOMSoon()}),Ql(o,"copy",t),Ql(o,"cut",t)},Zs.prototype.prepareSelection=function(){var e=Tr(this.cm,!1);return e.focus=this.cm.state.focused,e},Zs.prototype.showSelection=function(e,t){e&&this.cm.display.view.length&&((e.focus||t)&&this.showPrimarySelection(),this.showMultipleSelections(e))},Zs.prototype.showPrimarySelection=function(){var e=window.getSelection(),t=this.cm,r=t.doc.sel.primary(),n=r.from(),i=r.to();if(t.display.viewTo==t.display.viewFrom||n.line>=t.display.viewTo||i.line<t.display.viewFrom)e.removeAllRanges();else{var o=sl(t,e.anchorNode,e.anchorOffset),l=sl(t,e.focusNode,e.focusOffset);if(!o||o.bad||!l||l.bad||0!=P(B(o,l),n)||0!=P(R(o,l),i)){var s=t.display.view,a=n.line>=t.display.viewFrom&&nl(t,n)||{node:s[0].measure.map[2],offset:0},u=i.line<t.display.viewTo&&nl(t,i);if(!u){var c=s[s.length-1].measure,f=c.maps?c.maps[c.maps.length-1]:c.map;u={node:f[f.length-1],offset:f[f.length-2]-f[f.length-3]}}if(a&&u){var h,d=e.rangeCount&&e.getRangeAt(0);try{h=Wl(a.node,a.offset,u.offset,u.node)}catch(e){}h&&(!fl&&t.state.focused?(e.collapse(a.node,a.offset),h.collapsed||(e.removeAllRanges(),e.addRange(h))):(e.removeAllRanges(),e.addRange(h)),d&&null==e.anchorNode?e.addRange(d):fl&&this.startGracePeriod()),this.rememberSelection()}else e.removeAllRanges()}}},Zs.prototype.startGracePeriod=function(){var e=this;clearTimeout(this.gracePeriod),this.gracePeriod=setTimeout(function(){e.gracePeriod=!1,e.selectionChanged()&&e.cm.operation(function(){return e.cm.curOp.selectionChanged=!0})},20)},Zs.prototype.showMultipleSelections=function(e){r(this.cm.display.cursorDiv,e.cursors),r(this.cm.display.selectionDiv,e.selection)},Zs.prototype.rememberSelection=function(){var e=window.getSelection();this.lastAnchorNode=e.anchorNode,this.lastAnchorOffset=e.anchorOffset,this.lastFocusNode=e.focusNode,this.lastFocusOffset=e.focusOffset},Zs.prototype.selectionInEditor=function(){var e=window.getSelection();if(!e.rangeCount)return!1;var t=e.getRangeAt(0).commonAncestorContainer;return o(this.div,t)},Zs.prototype.focus=function(){"nocursor"!=this.cm.options.readOnly&&(this.selectionInEditor()||this.showSelection(this.prepareSelection(),!0),this.div.focus())},Zs.prototype.blur=function(){this.div.blur()},Zs.prototype.getField=function(){return this.div},Zs.prototype.supportsTouch=function(){return!0},Zs.prototype.receivedFocus=function(){function e(){t.cm.state.focused&&(t.pollSelection(),t.polling.set(t.cm.options.pollInterval,e))}var t=this;this.selectionInEditor()?this.pollSelection():hn(this.cm,function(){return t.cm.curOp.selectionChanged=!0}),this.polling.set(this.cm.options.pollInterval,e)},Zs.prototype.selectionChanged=function(){var e=window.getSelection();return e.anchorNode!=this.lastAnchorNode||e.anchorOffset!=this.lastAnchorOffset||e.focusNode!=this.lastFocusNode||e.focusOffset!=this.lastFocusOffset},Zs.prototype.pollSelection=function(){if(null==this.readDOMTimeout&&!this.gracePeriod&&this.selectionChanged()){var e=window.getSelection(),t=this.cm;if(kl&&bl&&this.cm.options.gutters.length&&il(e.anchorNode))return this.cm.triggerOnKeyDown({type:"keydown",keyCode:8,preventDefault:Math.abs}),this.blur(),void this.focus();if(!this.composing){this.rememberSelection();var r=sl(t,e.anchorNode,e.anchorOffset),n=sl(t,e.focusNode,e.focusOffset);r&&n&&hn(t,function(){bi(t.doc,Rn(r,n),Gl),(r.bad||n.bad)&&(t.curOp.selectionChanged=!0)})}}},Zs.prototype.pollContent=function(){null!=this.readDOMTimeout&&(clearTimeout(this.readDOMTimeout),this.readDOMTimeout=null);var e=this.cm,t=e.display,r=e.doc.sel.primary(),n=r.from(),i=r.to();if(0==n.ch&&n.line>e.firstLine()&&(n=E(n.line-1,M(e.doc,n.line-1).length)),i.ch==M(e.doc,i.line).text.length&&i.line<e.lastLine()&&(i=E(i.line+1,0)),n.line<t.viewFrom||i.line>t.viewTo-1)return!1;var o,l,s;n.line==t.viewFrom||0==(o=Lr(e,n.line))?(l=W(t.view[0].line),s=t.view[0].node):(l=W(t.view[o].line),s=t.view[o-1].node.nextSibling);var a,u,c=Lr(e,i.line);if(c==t.view.length-1?(a=t.viewTo-1,u=t.lineDiv.lastChild):(a=W(t.view[c+1].line)-1,u=t.view[c+1].node.previousSibling),!s)return!1;for(var f=e.doc.splitLines(ll(e,s,u,l,a)),h=N(e.doc,E(l,0),E(a,M(e.doc,a).text.length));f.length>1&&h.length>1;)if(g(f)==g(h))f.pop(),h.pop(),a--;else{if(f[0]!=h[0])break;f.shift(),h.shift(),l++}for(var d=0,p=0,v=f[0],m=h[0],y=Math.min(v.length,m.length);d<y&&v.charCodeAt(d)==m.charCodeAt(d);)++d;for(var b=g(f),w=g(h),x=Math.min(b.length-(1==f.length?d:0),w.length-(1==h.length?d:0));p<x&&b.charCodeAt(b.length-p-1)==w.charCodeAt(w.length-p-1);)++p;if(1==f.length&&1==h.length&&l==n.line)for(;d&&d>n.ch&&b.charCodeAt(b.length-p-1)==w.charCodeAt(w.length-p-1);)d--,p++;f[f.length-1]=b.slice(0,b.length-p).replace(/^\u200b+/,""),f[0]=f[0].slice(d).replace(/\u200b+$/,"");var C=E(l,d),S=E(a,h.length?g(h).length-p:0);return f.length>1||f[0]||P(C,S)?(Ei(e.doc,f,C,S,"+input"),!0):void 0},Zs.prototype.ensurePolled=function(){this.forceCompositionEnd()},Zs.prototype.reset=function(){this.forceCompositionEnd()},Zs.prototype.forceCompositionEnd=function(){this.composing&&(clearTimeout(this.readDOMTimeout),this.composing=null,this.updateFromDOM(),this.div.blur(),this.div.focus())},Zs.prototype.readFromDOMSoon=function(){var e=this;null==this.readDOMTimeout&&(this.readDOMTimeout=setTimeout(function(){if(e.readDOMTimeout=null,e.composing){if(!e.composing.done)return;e.composing=null}e.updateFromDOM()},80))},Zs.prototype.updateFromDOM=function(){var e=this;!this.cm.isReadOnly()&&this.pollContent()||hn(this.cm,function(){return vn(e.cm)})},Zs.prototype.setUneditable=function(e){e.contentEditable="false"},Zs.prototype.onKeyPress=function(e){0!=e.charCode&&(e.preventDefault(),this.cm.isReadOnly()||dn(this.cm,$o)(this.cm,String.fromCharCode(null==e.charCode?e.keyCode:e.charCode),0))},Zs.prototype.readOnlyChanged=function(e){this.div.contentEditable=String("nocursor"!=e)},Zs.prototype.onContextMenu=function(){},Zs.prototype.resetPosition=function(){},Zs.prototype.needsContentAttribute=!0;var Qs=function(e){this.cm=e,this.prevInput="",this.pollingFast=!1,this.polling=new Pl,this.hasSelection=!1,this.composing=null};Qs.prototype.init=function(e){function t(e){if(!Me(i,e)){if(i.somethingSelected())_o({lineWise:!1,text:i.getSelections()});else{if(!i.options.lineWiseCopyCut)return;var t=Qo(i);_o({lineWise:!0,text:t.text}),"cut"==e.type?i.setSelections(t.ranges,null,Gl):(n.prevInput="",l.value=t.text.join("\n"),El(l))}"cut"==e.type&&(i.state.cutIncoming=!0)}}var r=this,n=this,i=this.cm,o=this.wrapper=el(),l=this.textarea=o.firstChild;e.wrapper.insertBefore(o,e.wrapper.firstChild),Ll&&(l.style.width="0px"),Ql(l,"input",function(){gl&&vl>=9&&r.hasSelection&&(r.hasSelection=null),n.poll()}),Ql(l,"paste",function(e){Me(i,e)||qo(e,i)||(i.state.pasteIncoming=!0,n.fastPoll())}),Ql(l,"cut",t),Ql(l,"copy",t),Ql(e.scroller,"paste",function(t){Ft(e,t)||Me(i,t)||(i.state.pasteIncoming=!0,n.focus())}),Ql(e.lineSpace,"selectstart",function(t){Ft(e,t)||We(t)}),Ql(l,"compositionstart",function(){var e=i.getCursor("from");n.composing&&n.composing.range.clear(),n.composing={start:e,range:i.markText(e,i.getCursor("to"),{className:"CodeMirror-composing"})}}),Ql(l,"compositionend",function(){n.composing&&(n.poll(),n.composing.range.clear(),n.composing=null)})},Qs.prototype.prepareSelection=function(){var e=this.cm,t=e.display,r=e.doc,n=Tr(e);if(e.options.moveInputWithCursor){var i=sr(e,r.sel.primary().head,"div"),o=t.wrapper.getBoundingClientRect(),l=t.lineDiv.getBoundingClientRect();n.teTop=Math.max(0,Math.min(t.wrapper.clientHeight-10,i.top+l.top-o.top)),n.teLeft=Math.max(0,Math.min(t.wrapper.clientWidth-10,i.left+l.left-o.left))}return n},Qs.prototype.showSelection=function(e){var t=this.cm.display;r(t.cursorDiv,e.cursors),r(t.selectionDiv,e.selection),null!=e.teTop&&(this.wrapper.style.top=e.teTop+"px",this.wrapper.style.left=e.teLeft+"px")},Qs.prototype.reset=function(e){if(!this.contextMenuPending&&!this.composing){var t=this.cm;if(t.somethingSelected()){this.prevInput="";var r=t.getSelection();this.textarea.value=r,t.state.focused&&El(this.textarea),gl&&vl>=9&&(this.hasSelection=r)}else e||(this.prevInput=this.textarea.value="",gl&&vl>=9&&(this.hasSelection=null))}},Qs.prototype.getField=function(){return this.textarea},Qs.prototype.supportsTouch=function(){return!1},Qs.prototype.focus=function(){if("nocursor"!=this.cm.options.readOnly&&(!Tl||l()!=this.textarea))try{this.textarea.focus()}catch(e){}},Qs.prototype.blur=function(){this.textarea.blur()},Qs.prototype.resetPosition=function(){this.wrapper.style.top=this.wrapper.style.left=0},Qs.prototype.receivedFocus=function(){this.slowPoll()},Qs.prototype.slowPoll=function(){var e=this;this.pollingFast||this.polling.set(this.cm.options.pollInterval,function(){e.poll(),e.cm.state.focused&&e.slowPoll()})},Qs.prototype.fastPoll=function(){function e(){r.poll()||t?(r.pollingFast=!1,r.slowPoll()):(t=!0,r.polling.set(60,e))}var t=!1,r=this;r.pollingFast=!0,r.polling.set(20,e)},Qs.prototype.poll=function(){var e=this,t=this.cm,r=this.textarea,n=this.prevInput;if(this.contextMenuPending||!t.state.focused||ts(r)&&!n&&!this.composing||t.isReadOnly()||t.options.disableInput||t.state.keySeq)return!1;var i=r.value;if(i==n&&!t.somethingSelected())return!1;if(gl&&vl>=9&&this.hasSelection===i||Ml&&/[\uf700-\uf7ff]/.test(i))return t.display.input.reset(),!1;if(t.doc.sel==t.display.selForContextMenu){var o=i.charCodeAt(0);if(8203!=o||n||(n="​"),8666==o)return this.reset(),this.cm.execCommand("undo")}for(var l=0,s=Math.min(n.length,i.length);l<s&&n.charCodeAt(l)==i.charCodeAt(l);)++l;return hn(t,function(){$o(t,i.slice(l),n.length-l,null,e.composing?"*compose":null),i.length>1e3||i.indexOf("\n")>-1?r.value=e.prevInput="":e.prevInput=i,e.composing&&(e.composing.range.clear(),e.composing.range=t.markText(e.composing.start,t.getCursor("to"),{className:"CodeMirror-composing"}))}),!0},Qs.prototype.ensurePolled=function(){this.pollingFast&&this.poll()&&(this.pollingFast=!1)},Qs.prototype.onKeyPress=function(){gl&&vl>=9&&(this.hasSelection=null),this.fastPoll()},Qs.prototype.onContextMenu=function(e){function t(){if(null!=l.selectionStart){var e=i.somethingSelected(),t="​"+(e?l.value:"");l.value="⇚",l.value=t,n.prevInput=e?"":"​",l.selectionStart=1,l.selectionEnd=t.length,o.selForContextMenu=i.doc.sel}}function r(){if(n.contextMenuPending=!1,n.wrapper.style.cssText=c,l.style.cssText=u,gl&&vl<9&&o.scrollbars.setScrollTop(o.scroller.scrollTop=a),null!=l.selectionStart){(!gl||gl&&vl<9)&&t();var e=0,r=function(){o.selForContextMenu==i.doc.sel&&0==l.selectionStart&&l.selectionEnd>0&&"​"==n.prevInput?dn(i,Mi)(i):e++<10?o.detectingSelectAll=setTimeout(r,500):(o.selForContextMenu=null,o.input.reset())};o.detectingSelectAll=setTimeout(r,200)}}var n=this,i=n.cm,o=i.display,l=n.textarea,s=Sr(i,e),a=o.scroller.scrollTop;if(s&&!wl){i.options.resetSelectionOnContextMenu&&-1==i.doc.sel.contains(s)&&dn(i,bi)(i.doc,Rn(s),Gl);var u=l.style.cssText,c=n.wrapper.style.cssText;n.wrapper.style.cssText="position: absolute";var f=n.wrapper.getBoundingClientRect();l.style.cssText="position: absolute; width: 30px; height: 30px;\n      top: "+(e.clientY-f.top-5)+"px; left: "+(e.clientX-f.left-5)+"px;\n      z-index: 1000; background: "+(gl?"rgba(255, 255, 255, .05)":"transparent")+";\n      outline: none; border-width: 0; outline: none; overflow: hidden; opacity: .05; filter: alpha(opacity=5);";var h;if(ml&&(h=window.scrollY),o.input.focus(),ml&&window.scrollTo(null,h),o.input.reset(),i.somethingSelected()||(l.value=n.prevInput=" "),n.contextMenuPending=!0,o.selForContextMenu=i.doc.sel,clearTimeout(o.detectingSelectAll),gl&&vl>=9&&t(),Hl){Fe(e);var d=function(){ke(window,"mouseup",d),setTimeout(r,20)};Ql(window,"mouseup",d)}else setTimeout(r,50)}},Qs.prototype.readOnlyChanged=function(e){e||this.reset(),this.textarea.disabled="nocursor"==e},Qs.prototype.setUneditable=function(){},Qs.prototype.needsContentAttribute=!1,function(e){function t(t,n,i,o){e.defaults[t]=n,i&&(r[t]=o?function(e,t,r){r!=Xs&&i(e,t,r)}:i)}var r=e.optionHandlers;e.defineOption=t,e.Init=Xs,t("value","",function(e,t){return e.setValue(t)},!0),t("mode",null,function(e,t){e.doc.modeOption=t,jn(e)},!0),t("indentUnit",2,jn,!0),t("indentWithTabs",!1),t("smartIndent",!0),t("tabSize",4,function(e){Xn(e),er(e),vn(e)},!0),t("lineSeparator",null,function(e,t){if(e.doc.lineSep=t,t){var r=[],n=e.doc.first;e.doc.iter(function(e){for(var i=0;;){var o=e.text.indexOf(t,i);if(-1==o)break;i=o+t.length,r.push(E(n,o))}n++});for(var i=r.length-1;i>=0;i--)Ei(e.doc,t,r[i],E(r[i].line,r[i].ch+t.length))}}),t("specialChars",/[\u0000-\u001f\u007f-\u009f\u00ad\u061c\u200b-\u200f\u2028\u2029\ufeff]/g,function(e,t,r){e.state.specialChars=new RegExp(t.source+(t.test("\t")?"":"|\t"),"g"),r!=Xs&&e.refresh()}),t("specialCharPlaceholder",at,function(e){return e.refresh()},!0),t("electricChars",!0),t("inputStyle",Tl?"contenteditable":"textarea",function(){throw new Error("inputStyle can not (yet) be changed in a running editor")},!0),t("spellcheck",!1,function(e,t){return e.getInputField().spellcheck=t},!0),t("rtlMoveVisually",!Ol),t("wholeLineUpdateBefore",!0),t("theme","default",function(e){Go(e),Uo(e)},!0),t("keyMap","default",function(e,t,r){var n=uo(t),i=r!=Xs&&uo(r);i&&i.detach&&i.detach(e,n),n.attach&&n.attach(e,i||null)}),t("extraKeys",null),t("configureMouse",null),t("lineWrapping",!1,Ko,!0),t("gutters",[],function(e){Fn(e.options),Uo(e)},!0),t("fixedGutter",!0,function(e,t){e.display.gutters.style.left=t?wr(e.display)+"px":"0",e.refresh()},!0),t("coverGutterNextToScrollbar",!1,function(e){return en(e)},!0),t("scrollbarStyle","native",function(e){rn(e),en(e),e.display.scrollbars.setScrollTop(e.doc.scrollTop),e.display.scrollbars.setScrollLeft(e.doc.scrollLeft)},!0),t("lineNumbers",!1,function(e){Fn(e.options),Uo(e)},!0),t("firstLineNumber",1,Uo,!0),t("lineNumberFormatter",function(e){return e},Uo,!0),t("showCursorWhenSelecting",!1,kr,!0),t("resetSelectionOnContextMenu",!0),t("lineWiseCopyCut",!0),t("pasteLinesPerSelection",!0),t("readOnly",!1,function(e,t){"nocursor"==t&&(Fr(e),e.display.input.blur()),e.display.input.readOnlyChanged(t)}),t("disableInput",!1,function(e,t){t||e.display.input.reset()},!0),t("dragDrop",!0,Vo),t("allowDropFileTypes",null),t("cursorBlinkRate",530),t("cursorScrollMargin",0),t("cursorHeight",1,kr,!0),t("singleCursorHeightPerLine",!0,kr,!0),t("workTime",100),t("workDelay",100),t("flattenSpans",!0,Xn,!0),t("addModeClass",!1,Xn,!0),t("pollInterval",100),t("undoDepth",200,function(e,t){return e.doc.history.undoDepth=t}),t("historyEventDelay",1250),t("viewportMargin",10,function(e){return e.refresh()},!0),t("maxHighlightLength",1e4,Xn,!0),t("moveInputWithCursor",!0,function(e,t){t||e.display.input.resetPosition()}),t("tabindex",null,function(e,t){return e.display.input.getField().tabIndex=t||""}),t("autofocus",null),t("direction","ltr",function(e,t){return e.doc.setDirection(t)},!0)}(jo),function(e){var t=e.optionHandlers,r=e.helpers={};e.prototype={constructor:e,focus:function(){window.focus(),this.display.input.focus()},setOption:function(e,r){var n=this.options,i=n[e];n[e]==r&&"mode"!=e||(n[e]=r,t.hasOwnProperty(e)&&dn(this,t[e])(this,r,i),Te(this,"optionChange",this,e))},getOption:function(e){return this.options[e]},getDoc:function(){return this.doc},addKeyMap:function(e,t){this.state.keyMaps[t?"push":"unshift"](uo(e))},removeKeyMap:function(e){for(var t=this.state.keyMaps,r=0;r<t.length;++r)if(t[r]==e||t[r].name==e)return t.splice(r,1),!0},addOverlay:pn(function(t,r){var n=t.token?t:e.getMode(this.options,t);if(n.startState)throw new Error("Overlays may not be stateful.");m(this.state.overlays,{mode:n,modeSpec:t,opaque:r&&r.opaque,priority:r&&r.priority||0},function(e){return e.priority}),this.state.modeGen++,vn(this)}),removeOverlay:pn(function(e){for(var t=this,r=this.state.overlays,n=0;n<r.length;++n){var i=r[n].modeSpec;if(i==e||"string"==typeof e&&i.name==e)return r.splice(n,1),t.state.modeGen++,void vn(t)}}),indentLine:pn(function(e,t,r){"string"!=typeof t&&"number"!=typeof t&&(t=null==t?this.options.smartIndent?"smart":"prev":t?"add":"subtract"),H(this.doc,e)&&Yo(this,e,t,r)}),indentSelection:pn(function(e){for(var t=this,r=this.doc.sel.ranges,n=-1,i=0;i<r.length;i++){var o=r[i];if(o.empty())o.head.line>n&&(Yo(t,o.head.line,e,!0),n=o.head.line,i==t.doc.sel.primIndex&&jr(t));else{var l=o.from(),s=o.to(),a=Math.max(n,l.line);n=Math.min(t.lastLine(),s.line-(s.ch?0:1))+1;for(var u=a;u<n;++u)Yo(t,u,e);var c=t.doc.sel.ranges;0==l.ch&&r.length==c.length&&c[i].from().ch>0&&gi(t.doc,i,new Ts(l,c[i].to()),Gl)}}}),getTokenAt:function(e,t){return Je(this,e,t)},getLineTokens:function(e,t){return Je(this,E(e),t,!0)},getTokenTypeAt:function(e){e=U(this.doc,e);var t,r=_e(this,M(this.doc,e.line)),n=0,i=(r.length-1)/2,o=e.ch;if(0==o)t=r[2];else for(;;){var l=n+i>>1;if((l?r[2*l-1]:0)>=o)i=l;else{if(!(r[2*l+1]<o)){t=r[2*l+2];break}n=l+1}}var s=t?t.indexOf("overlay "):-1;return s<0?t:0==s?null:t.slice(0,s-1)},getModeAt:function(t){var r=this.doc.mode;return r.innerMode?e.innerMode(r,this.getTokenAt(t).state).mode:r},getHelper:function(e,t){return this.getHelpers(e,t)[0]},getHelpers:function(e,t){var n=this,i=[];if(!r.hasOwnProperty(t))return i;var o=r[t],l=this.getModeAt(e);if("string"==typeof l[t])o[l[t]]&&i.push(o[l[t]]);else if(l[t])for(var s=0;s<l[t].length;s++){var a=o[l[t][s]];a&&i.push(a)}else l.helperType&&o[l.helperType]?i.push(o[l.helperType]):o[l.name]&&i.push(o[l.name]);for(var u=0;u<o._global.length;u++){var c=o._global[u];c.pred(l,n)&&-1==h(i,c.val)&&i.push(c.val)}return i},getStateAfter:function(e,t){var r=this.doc;return e=G(r,null==e?r.first+r.size-1:e),$e(this,e+1,t).state},cursorCoords:function(e,t){var r,n=this.doc.sel.primary();return r=null==e?n.head:"object"==typeof e?U(this.doc,e):e?n.from():n.to(),sr(this,r,t||"page")},charCoords:function(e,t){return lr(this,U(this.doc,e),t||"page")},coordsChar:function(e,t){return e=or(this,e,t||"page"),cr(this,e.left,e.top)},lineAtHeight:function(e,t){return e=or(this,{top:e,left:0},t||"page").top,D(this.doc,e+this.display.viewOffset)},heightAtLine:function(e,t,r){var n,i=!1;if("number"==typeof e){var o=this.doc.first+this.doc.size-1;e<this.doc.first?e=this.doc.first:e>o&&(e=o,i=!0),n=M(this.doc,e)}else n=e;return ir(this,n,{top:0,left:0},t||"page",r||i).top+(i?this.doc.height-ye(n):0)},defaultTextHeight:function(){return mr(this.display)},defaultCharWidth:function(){return yr(this.display)},getViewport:function(){return{from:this.display.viewFrom,to:this.display.viewTo}},addWidget:function(e,t,r,n,i){var o=this.display,l=(e=sr(this,U(this.doc,e))).bottom,s=e.left;if(t.style.position="absolute",t.setAttribute("cm-ignore-events","true"),this.display.input.setUneditable(t),o.sizer.appendChild(t),"over"==n)l=e.top;else if("above"==n||"near"==n){var a=Math.max(o.wrapper.clientHeight,this.doc.height),u=Math.max(o.sizer.clientWidth,o.lineSpace.clientWidth);("above"==n||e.bottom+t.offsetHeight>a)&&e.top>t.offsetHeight?l=e.top-t.offsetHeight:e.bottom+t.offsetHeight<=a&&(l=e.bottom),s+t.offsetWidth>u&&(s=u-t.offsetWidth)}t.style.top=l+"px",t.style.left=t.style.right="","right"==i?(s=o.sizer.clientWidth-t.offsetWidth,t.style.right="0px"):("left"==i?s=0:"middle"==i&&(s=(o.sizer.clientWidth-t.offsetWidth)/2),t.style.left=s+"px"),r&&Ur(this,{left:s,top:l,right:s+t.offsetWidth,bottom:l+t.offsetHeight})},triggerOnKeyDown:pn(Lo),triggerOnKeyPress:pn(Mo),triggerOnKeyUp:To,triggerOnMouseDown:pn(Oo),execCommand:function(e){if(Bs.hasOwnProperty(e))return Bs[e].call(null,this)},triggerElectric:pn(function(e){Zo(this,e)}),findPosH:function(e,t,r,n){var i=this,o=1;t<0&&(o=-1,t=-t);for(var l=U(this.doc,e),s=0;s<t&&!(l=tl(i.doc,l,o,r,n)).hitSide;++s);return l},moveH:pn(function(e,t){var r=this;this.extendSelectionsBy(function(n){return r.display.shift||r.doc.extend||n.empty()?tl(r.doc,n.head,e,t,r.options.rtlMoveVisually):e<0?n.from():n.to()},Vl)}),deleteH:pn(function(e,t){var r=this.doc.sel,n=this.doc;r.somethingSelected()?n.replaceSelection("",null,"+delete"):co(this,function(r){var i=tl(n,r.head,e,t,!1);return e<0?{from:i,to:r.head}:{from:r.head,to:i}})}),findPosV:function(e,t,r,n){var i=this,o=1,l=n;t<0&&(o=-1,t=-t);for(var s=U(this.doc,e),a=0;a<t;++a){var u=sr(i,s,"div");if(null==l?l=u.left:u.left=l,(s=rl(i,u,o,r)).hitSide)break}return s},moveV:pn(function(e,t){var r=this,n=this.doc,i=[],o=!this.display.shift&&!n.extend&&n.sel.somethingSelected();if(n.extendSelectionsBy(function(l){if(o)return e<0?l.from():l.to();var s=sr(r,l.head,"div");null!=l.goalColumn&&(s.left=l.goalColumn),i.push(s.left);var a=rl(r,s,e,t);return"page"==t&&l==n.sel.primary()&&Kr(r,lr(r,a,"div").top-s.top),a},Vl),i.length)for(var l=0;l<n.sel.ranges.length;l++)n.sel.ranges[l].goalColumn=i[l]}),findWordAt:function(e){var t=M(this.doc,e.line).text,r=e.ch,n=e.ch;if(t){var i=this.getHelper(e,"wordChars");"before"!=e.sticky&&n!=t.length||!r?++n:--r;for(var o=t.charAt(r),l=x(o,i)?function(e){return x(e,i)}:/\s/.test(o)?function(e){return/\s/.test(e)}:function(e){return!/\s/.test(e)&&!x(e)};r>0&&l(t.charAt(r-1));)--r;for(;n<t.length&&l(t.charAt(n));)++n}return new Ts(E(e.line,r),E(e.line,n))},toggleOverwrite:function(e){null!=e&&e==this.state.overwrite||((this.state.overwrite=!this.state.overwrite)?s(this.display.cursorDiv,"CodeMirror-overwrite"):Fl(this.display.cursorDiv,"CodeMirror-overwrite"),Te(this,"overwriteToggle",this,this.state.overwrite))},hasFocus:function(){return this.display.input.getField()==l()},isReadOnly:function(){return!(!this.options.readOnly&&!this.doc.cantEdit)},scrollTo:pn(function(e,t){Xr(this,e,t)}),getScrollInfo:function(){var e=this.display.scroller;return{left:e.scrollLeft,top:e.scrollTop,height:e.scrollHeight-zt(this)-this.display.barHeight,width:e.scrollWidth-zt(this)-this.display.barWidth,clientHeight:Bt(this),clientWidth:Rt(this)}},scrollIntoView:pn(function(e,t){null==e?(e={from:this.doc.sel.primary().head,to:null},null==t&&(t=this.options.cursorScrollMargin)):"number"==typeof e?e={from:E(e,0),to:null}:null==e.from&&(e={from:e,to:null}),e.to||(e.to=e.from),e.margin=t||0,null!=e.from.line?Yr(this,e):$r(this,e.from,e.to,e.margin)}),setSize:pn(function(e,t){var r=this,n=function(e){return"number"==typeof e||/^\d+$/.test(String(e))?e+"px":e};null!=e&&(this.display.wrapper.style.width=n(e)),null!=t&&(this.display.wrapper.style.height=n(t)),this.options.lineWrapping&&Jt(this);var i=this.display.viewFrom;this.doc.iter(i,this.display.viewTo,function(e){if(e.widgets)for(var t=0;t<e.widgets.length;t++)if(e.widgets[t].noHScroll){mn(r,i,"widget");break}++i}),this.curOp.forceUpdate=!0,Te(this,"refresh",this)}),operation:function(e){return hn(this,e)},startOperation:function(){return nn(this)},endOperation:function(){return on(this)},refresh:pn(function(){var e=this.display.cachedTextHeight;vn(this),this.curOp.forceUpdate=!0,er(this),Xr(this,this.doc.scrollLeft,this.doc.scrollTop),Wn(this),(null==e||Math.abs(e-mr(this.display))>.5)&&Cr(this),Te(this,"refresh",this)}),swapDoc:pn(function(e){var t=this.doc;return t.cm=null,qn(this,e),er(this),this.display.input.reset(),Xr(this,e.scrollLeft,e.scrollTop),this.curOp.forceScroll=!0,bt(this,"swapDoc",this,t),t}),getInputField:function(){return this.display.input.getField()},getWrapperElement:function(){return this.display.wrapper},getScrollerElement:function(){return this.display.scroller},getGutterElement:function(){return this.display.gutters}},Ae(e),e.registerHelper=function(t,n,i){r.hasOwnProperty(t)||(r[t]=e[t]={_global:[]}),r[t][n]=i},e.registerGlobalHelper=function(t,n,i,o){e.registerHelper(t,n,o),r[t]._global.push({pred:i,val:o})}}(jo);var Js="iter insert remove copy getEditor constructor".split(" ");for(var ea in Ds.prototype)Ds.prototype.hasOwnProperty(ea)&&h(Js,ea)<0&&(jo.prototype[ea]=function(e){return function(){return e.apply(this.doc,arguments)}}(Ds.prototype[ea]));return Ae(Ds),jo.inputStyles={textarea:Qs,contenteditable:Zs},jo.defineMode=function(e){jo.defaults.mode||"null"==e||(jo.defaults.mode=e),Be.apply(this,arguments)},jo.defineMIME=function(e,t){os[e]=t},jo.defineMode("null",function(){return{token:function(e){return e.skipToEnd()}}}),jo.defineMIME("text/plain","null"),jo.defineExtension=function(e,t){jo.prototype[e]=t},jo.defineDocExtension=function(e,t){Ds.prototype[e]=t},jo.fromTextArea=function(e,t){function r(){e.value=a.getValue()}if(t=t?c(t):{},t.value=e.value,!t.tabindex&&e.tabIndex&&(t.tabindex=e.tabIndex),!t.placeholder&&e.placeholder&&(t.placeholder=e.placeholder),null==t.autofocus){var n=l();t.autofocus=n==e||null!=e.getAttribute("autofocus")&&n==document.body}var i;if(e.form&&(Ql(e.form,"submit",r),!t.leaveSubmitMethodAlone)){var o=e.form;i=o.submit;try{var s=o.submit=function(){r(),o.submit=i,o.submit(),o.submit=s}}catch(e){}}t.finishInit=function(t){t.save=r,t.getTextArea=function(){return e},t.toTextArea=function(){t.toTextArea=isNaN,r(),e.parentNode.removeChild(t.getWrapperElement()),e.style.display="",e.form&&(ke(e.form,"submit",r),"function"==typeof e.form.submit&&(e.form.submit=i))}},e.style.display="none";var a=jo(function(t){return e.parentNode.insertBefore(t,e.nextSibling)},t);return a},function(e){e.off=ke,e.on=Ql,e.wheelEventPixels=Pn,e.Doc=Ds,e.splitLines=es,e.countColumn=f,e.findColumn=d,e.isWordChar=w,e.Pass=Bl,e.signal=Te,e.Line=fs,e.changeEnd=Bn,e.scrollbarModel=ws,e.Pos=E,e.cmpPos=P,e.modes=is,e.mimeModes=os,e.resolveMode=Ge,e.getMode=Ue,e.modeExtensions=ls,e.extendMode=Ve,e.copyState=Ke,e.startState=Xe,e.innerMode=je,e.commands=Bs,e.keyMap=Rs,e.keyName=ao,e.isModifierKey=lo,e.lookupKey=oo,e.normalizeKeyMap=io,e.StringStream=ss,e.SharedTextMarker=As,e.TextMarker=Os,e.LineWidget=Ms,e.e_preventDefault=We,e.e_stopPropagation=De,e.e_stop=Fe,e.addClass=s,e.contains=o,e.rmClass=Fl,e.keyNames=Es}(jo),jo.version="5.30.0",jo});
      !function(e){"object"==typeof exports&&"object"==typeof module?e(require("../../lib/codemirror")):"function"==typeof define&&define.amd?define(["../../lib/codemirror"],e):e(CodeMirror)}(function(e){"use strict";function t(e,t,n,r,o,a){this.indented=e,this.column=t,this.type=n,this.info=r,this.align=o,this.prev=a}function n(e,n,r,o){var a=e.indented;return e.context&&"statement"==e.context.type&&"statement"!=r&&(a=e.context.indented),e.context=new t(a,n,r,o,null,e.context)}function r(e){var t=e.context.type;return")"!=t&&"]"!=t&&"}"!=t||(e.indented=e.context.indented),e.context=e.context.prev}function o(e,t,n){return"variable"==t.prevToken||"type"==t.prevToken||(!!/\S(?:[^- ]>|[*\]])\s*$|\*$/.test(e.string.slice(0,n))||(!(!t.typeAtEndOfLine||e.column()!=e.indentation())||void 0))}function a(e){for(;;){if(!e||"top"==e.type)return!0;if("}"==e.type&&"namespace"!=e.prev.info)return!1;e=e.prev}}function i(e){for(var t={},n=e.split(" "),r=0;r<n.length;++r)t[n[r]]=!0;return t}function l(e,t){return"function"==typeof e?e(t):e.propertyIsEnumerable(t)}function s(e,t){if(!t.startOfLine)return!1;for(var n,r=null;n=e.peek();){if("\\"==n&&e.match(/^.$/)){r=s;break}if("/"==n&&e.match(/^\/[\/\*]/,!1))break;e.next()}return t.tokenize=r,"meta"}function c(e,t){return"type"==t.prevToken&&"type"}function u(e){return e.eatWhile(/[\w\.']/),"number"}function d(e,t){if(e.backUp(1),e.match(/(R|u8R|uR|UR|LR)/)){var n=e.match(/"([^\s\\()]{0,16})\(/);return!!n&&(t.cpp11RawStringDelim=n[1],t.tokenize=m,m(e,t))}return e.match(/(u8|u|U|L)/)?!!e.match(/["']/,!1)&&"string":(e.next(),!1)}function f(e){var t=/(\w+)::~?(\w+)$/.exec(e);return t&&t[1]==t[2]}function p(e,t){for(var n;null!=(n=e.next());)if('"'==n&&!e.eat('"')){t.tokenize=null;break}return"string"}function m(e,t){var n=t.cpp11RawStringDelim.replace(/[^\w\s]/g,"\\$&");return e.match(new RegExp(".*?\\)"+n+'"'))?t.tokenize=null:e.skipToEnd(),"string"}function h(t,n){function r(e){if(e)for(var t in e)e.hasOwnProperty(t)&&o.push(t)}"string"==typeof t&&(t=[t]);var o=[];r(n.keywords),r(n.types),r(n.builtin),r(n.atoms),o.length&&(n.helperType=t[0],e.registerHelper("hintWords",t[0],o));for(var a=0;a<t.length;++a)e.defineMIME(t[a],n)}function g(e,t){for(var n=!1;!e.eol();){if(!n&&e.match('"""')){t.tokenize=null;break}n="\\"==e.next()&&!n}return"string"}function y(e){return function(t,n){for(var r,o=!1,a=!1;!t.eol();){if(!e&&!o&&t.match('"')){a=!0;break}if(e&&t.match('"""')){a=!0;break}r=t.next(),!o&&"$"==r&&t.match("{")&&t.skipTo("}"),o=!o&&"\\"==r&&!e}return!a&&e||(n.tokenize=null),"string"}}function x(e){return function(t,n){for(var r,o=!1,a=!1;!t.eol();){if(!o&&t.match('"')&&("single"==e||t.match('""'))){a=!0;break}if(!o&&t.match("``")){w=x(e),a=!0;break}r=t.next(),o="single"==e&&!o&&"\\"==r}return a&&(n.tokenize=null),"string"}}e.defineMode("clike",function(i,s){function c(e,t){var n=e.next();if(S[n]){var r=S[n](e,t);if(!1!==r)return r}if('"'==n||"'"==n)return t.tokenize=u(n),t.tokenize(e,t);if(D.test(n))return p=n,null;if(L.test(n)){if(e.backUp(1),e.match(I))return"number";e.next()}if("/"==n){if(e.eat("*"))return t.tokenize=d,d(e,t);if(e.eat("/"))return e.skipToEnd(),"comment"}if(F.test(n)){for(;!e.match(/^\/[\/*]/,!1)&&e.eat(F););return"operator"}if(e.eatWhile(z),P)for(;e.match(P);)e.eatWhile(z);var o=e.current();return l(x,o)?(l(w,o)&&(p="newstatement"),l(v,o)&&(m=!0),"keyword"):l(b,o)?"type":l(k,o)?(l(w,o)&&(p="newstatement"),"builtin"):l(_,o)?"atom":"variable"}function u(e){return function(t,n){for(var r,o=!1,a=!1;null!=(r=t.next());){if(r==e&&!o){a=!0;break}o=!o&&"\\"==r}return(a||!o&&!C)&&(n.tokenize=null),"string"}}function d(e,t){for(var n,r=!1;n=e.next();){if("/"==n&&r){t.tokenize=null;break}r="*"==n}return"comment"}function f(e,t){s.typeFirstDefinitions&&e.eol()&&a(t.context)&&(t.typeAtEndOfLine=o(e,t,e.pos))}var p,m,h=i.indentUnit,g=s.statementIndentUnit||h,y=s.dontAlignCalls,x=s.keywords||{},b=s.types||{},k=s.builtin||{},w=s.blockKeywords||{},v=s.defKeywords||{},_=s.atoms||{},S=s.hooks||{},C=s.multiLineStrings,T=!1!==s.indentStatements,M=!1!==s.indentSwitch,P=s.namespaceSeparator,D=s.isPunctuationChar||/[\[\]{}\(\),;\:\.]/,L=s.numberStart||/[\d\.]/,I=s.number||/^(?:0x[a-f\d]+|0b[01]+|(?:\d+\.?\d*|\.\d+)(?:e[-+]?\d+)?)(u|ll?|l|f)?/i,F=s.isOperatorChar||/[+\-*&%=<>!?|\/]/,z=s.isIdentifierChar||/[\w\$_\xa1-\uffff]/;return{startState:function(e){return{tokenize:null,context:new t((e||0)-h,0,"top",null,!1),indented:0,startOfLine:!0,prevToken:null}},token:function(e,t){var i=t.context;if(e.sol()&&(null==i.align&&(i.align=!1),t.indented=e.indentation(),t.startOfLine=!0),e.eatSpace())return f(e,t),null;p=m=null;var l=(t.tokenize||c)(e,t);if("comment"==l||"meta"==l)return l;if(null==i.align&&(i.align=!0),";"==p||":"==p||","==p&&e.match(/^\s*(?:\/\/.*)?$/,!1))for(;"statement"==t.context.type;)r(t);else if("{"==p)n(t,e.column(),"}");else if("["==p)n(t,e.column(),"]");else if("("==p)n(t,e.column(),")");else if("}"==p){for(;"statement"==i.type;)i=r(t);for("}"==i.type&&(i=r(t));"statement"==i.type;)i=r(t)}else p==i.type?r(t):T&&(("}"==i.type||"top"==i.type)&&";"!=p||"statement"==i.type&&"newstatement"==p)&&n(t,e.column(),"statement",e.current());if("variable"==l&&("def"==t.prevToken||s.typeFirstDefinitions&&o(e,t,e.start)&&a(t.context)&&e.match(/^\s*\(/,!1))&&(l="def"),S.token){var u=S.token(e,t,l);void 0!==u&&(l=u)}return"def"==l&&!1===s.styleDefs&&(l="variable"),t.startOfLine=!1,t.prevToken=m?"def":l||p,f(e,t),l},indent:function(t,n){if(t.tokenize!=c&&null!=t.tokenize||t.typeAtEndOfLine)return e.Pass;var r=t.context,o=n&&n.charAt(0);if("statement"==r.type&&"}"==o&&(r=r.prev),s.dontIndentStatements)for(;"statement"==r.type&&s.dontIndentStatements.test(r.info);)r=r.prev;if(S.indent){var a=S.indent(t,r,n);if("number"==typeof a)return a}var i=o==r.type,l=r.prev&&"switch"==r.prev.info;if(s.allmanIndentation&&/[{(]/.test(o)){for(;"top"!=r.type&&"}"!=r.type;)r=r.prev;return r.indented}return"statement"==r.type?r.indented+("{"==o?0:g):!r.align||y&&")"==r.type?")"!=r.type||i?r.indented+(i?0:h)+(i||!l||/^(?:case|default)\b/.test(n)?0:h):r.indented+g:r.column+(i?0:1)},electricInput:M?/^\s*(?:case .*?:|default:|\{\}?|\})$/:/^\s*[{}]$/,blockCommentStart:"/*",blockCommentEnd:"*/",lineComment:"//",fold:"brace"}});var b="auto if break case register continue return default do sizeof static else struct switch extern typedef union for goto while enum const volatile",k="int long char short double float unsigned signed void size_t ptrdiff_t";h(["text/x-csrc","text/x-c","text/x-chdr"],{name:"clike",keywords:i(b),types:i(k+" bool _Complex _Bool float_t double_t intptr_t intmax_t int8_t int16_t int32_t int64_t uintptr_t uintmax_t uint8_t uint16_t uint32_t uint64_t"),blockKeywords:i("case do else for if switch while struct"),defKeywords:i("struct"),typeFirstDefinitions:!0,atoms:i("null true false"),hooks:{"#":s,"*":c},modeProps:{fold:["brace","include"]}}),h(["text/x-c++src","text/x-c++hdr"],{name:"clike",keywords:i(b+" asm dynamic_cast namespace reinterpret_cast try explicit new static_cast typeid catch operator template typename class friend private this using const_cast inline public throw virtual delete mutable protected alignas alignof constexpr decltype nullptr noexcept thread_local final static_assert override"),types:i(k+" bool wchar_t"),blockKeywords:i("catch class do else finally for if struct switch try while"),defKeywords:i("class namespace struct enum union"),typeFirstDefinitions:!0,atoms:i("true false null"),dontIndentStatements:/^template$/,isIdentifierChar:/[\w\$_~\xa1-\uffff]/,hooks:{"#":s,"*":c,u:d,U:d,L:d,R:d,0:u,1:u,2:u,3:u,4:u,5:u,6:u,7:u,8:u,9:u,token:function(e,t,n){if("variable"==n&&"("==e.peek()&&(";"==t.prevToken||null==t.prevToken||"}"==t.prevToken)&&f(e.current()))return"def"}},namespaceSeparator:"::",modeProps:{fold:["brace","include"]}}),h("text/x-java",{name:"clike",keywords:i("abstract assert break case catch class const continue default do else enum extends final finally float for goto if implements import instanceof interface native new package private protected public return static strictfp super switch synchronized this throw throws transient try volatile while @interface"),types:i("byte short int long float double boolean char void Boolean Byte Character Double Float Integer Long Number Object Short String StringBuffer StringBuilder Void"),blockKeywords:i("catch class do else finally for if switch try while"),defKeywords:i("class interface package enum @interface"),typeFirstDefinitions:!0,atoms:i("true false null"),number:/^(?:0x[a-f\d_]+|0b[01_]+|(?:[\d_]+\.?\d*|\.\d+)(?:e[-+]?[\d_]+)?)(u|ll?|l|f)?/i,hooks:{"@":function(e){return!e.match("interface",!1)&&(e.eatWhile(/[\w\$_]/),"meta")}},modeProps:{fold:["brace","import"]}}),h("text/x-csharp",{name:"clike",keywords:i("abstract as async await base break case catch checked class const continue default delegate do else enum event explicit extern finally fixed for foreach goto if implicit in interface internal is lock namespace new operator out override params private protected public readonly ref return sealed sizeof stackalloc static struct switch this throw try typeof unchecked unsafe using virtual void volatile while add alias ascending descending dynamic from get global group into join let orderby partial remove select set value var yield"),types:i("Action Boolean Byte Char DateTime DateTimeOffset Decimal Double Func Guid Int16 Int32 Int64 Object SByte Single String Task TimeSpan UInt16 UInt32 UInt64 bool byte char decimal double short int long object sbyte float string ushort uint ulong"),blockKeywords:i("catch class do else finally for foreach if struct switch try while"),defKeywords:i("class interface namespace struct var"),typeFirstDefinitions:!0,atoms:i("true false null"),hooks:{"@":function(e,t){return e.eat('"')?(t.tokenize=p,p(e,t)):(e.eatWhile(/[\w\$_]/),"meta")}}}),h("text/x-scala",{name:"clike",keywords:i("abstract case catch class def do else extends final finally for forSome if implicit import lazy match new null object override package private protected return sealed super this throw trait try type val var while with yield _ assert assume require print println printf readLine readBoolean readByte readShort readChar readInt readLong readFloat readDouble"),types:i("AnyVal App Application Array BufferedIterator BigDecimal BigInt Char Console Either Enumeration Equiv Error Exception Fractional Function IndexedSeq Int Integral Iterable Iterator List Map Numeric Nil NotNull Option Ordered Ordering PartialFunction PartialOrdering Product Proxy Range Responder Seq Serializable Set Specializable Stream StringBuilder StringContext Symbol Throwable Traversable TraversableOnce Tuple Unit Vector Boolean Byte Character CharSequence Class ClassLoader Cloneable Comparable Compiler Double Exception Float Integer Long Math Number Object Package Pair Process Runtime Runnable SecurityManager Short StackTraceElement StrictMath String StringBuffer System Thread ThreadGroup ThreadLocal Throwable Triple Void"),multiLineStrings:!0,blockKeywords:i("catch class enum do else finally for forSome if match switch try while"),defKeywords:i("class enum def object package trait type val var"),atoms:i("true false null"),indentStatements:!1,indentSwitch:!1,isOperatorChar:/[+\-*&%=<>!?|\/#:@]/,hooks:{"@":function(e){return e.eatWhile(/[\w\$_]/),"meta"},'"':function(e,t){return!!e.match('""')&&(t.tokenize=g,t.tokenize(e,t))},"'":function(e){return e.eatWhile(/[\w\$_\xa1-\uffff]/),"atom"},"=":function(e,n){var r=n.context;return!("}"!=r.type||!r.align||!e.eat(">"))&&(n.context=new t(r.indented,r.column,r.type,r.info,null,r.prev),"operator")}},modeProps:{closeBrackets:{triples:'"'}}}),h("text/x-kotlin",{name:"clike",keywords:i("package as typealias class interface this super val var fun for is in This throw return break continue object if else while do try when !in !is as? file import where by get set abstract enum open inner override private public internal protected catch finally out final vararg reified dynamic companion constructor init sealed field property receiver param sparam lateinit data inline noinline tailrec external annotation crossinline const operator infix suspend"),types:i("Boolean Byte Character CharSequence Class ClassLoader Cloneable Comparable Compiler Double Exception Float Integer Long Math Number Object Package Pair Process Runtime Runnable SecurityManager Short StackTraceElement StrictMath String StringBuffer System Thread ThreadGroup ThreadLocal Throwable Triple Void"),intendSwitch:!1,indentStatements:!1,multiLineStrings:!0,number:/^(?:0x[a-f\d_]+|0b[01_]+|(?:[\d_]+\.?\d*|\.\d+)(?:e[-+]?[\d_]+)?)(u|ll?|l|f)?/i,blockKeywords:i("catch class do else finally for if where try while enum"),defKeywords:i("class val var object package interface fun"),atoms:i("true false null this"),hooks:{'"':function(e,t){return t.tokenize=y(e.match('""')),t.tokenize(e,t)}},modeProps:{closeBrackets:{triples:'"'}}}),h(["x-shader/x-vertex","x-shader/x-fragment"],{name:"clike",keywords:i("sampler1D sampler2D sampler3D samplerCube sampler1DShadow sampler2DShadow const attribute uniform varying break continue discard return for while do if else struct in out inout"),types:i("float int bool void vec2 vec3 vec4 ivec2 ivec3 ivec4 bvec2 bvec3 bvec4 mat2 mat3 mat4"),blockKeywords:i("for while do if else struct"),builtin:i("radians degrees sin cos tan asin acos atan pow exp log exp2 sqrt inversesqrt abs sign floor ceil fract mod min max clamp mix step smoothstep length distance dot cross normalize ftransform faceforward reflect refract matrixCompMult lessThan lessThanEqual greaterThan greaterThanEqual equal notEqual any all not texture1D texture1DProj texture1DLod texture1DProjLod texture2D texture2DProj texture2DLod texture2DProjLod texture3D texture3DProj texture3DLod texture3DProjLod textureCube textureCubeLod shadow1D shadow2D shadow1DProj shadow2DProj shadow1DLod shadow2DLod shadow1DProjLod shadow2DProjLod dFdx dFdy fwidth noise1 noise2 noise3 noise4"),atoms:i("true false gl_FragColor gl_SecondaryColor gl_Normal gl_Vertex gl_MultiTexCoord0 gl_MultiTexCoord1 gl_MultiTexCoord2 gl_MultiTexCoord3 gl_MultiTexCoord4 gl_MultiTexCoord5 gl_MultiTexCoord6 gl_MultiTexCoord7 gl_FogCoord gl_PointCoord gl_Position gl_PointSize gl_ClipVertex gl_FrontColor gl_BackColor gl_FrontSecondaryColor gl_BackSecondaryColor gl_TexCoord gl_FogFragCoord gl_FragCoord gl_FrontFacing gl_FragData gl_FragDepth gl_ModelViewMatrix gl_ProjectionMatrix gl_ModelViewProjectionMatrix gl_TextureMatrix gl_NormalMatrix gl_ModelViewMatrixInverse gl_ProjectionMatrixInverse gl_ModelViewProjectionMatrixInverse gl_TexureMatrixTranspose gl_ModelViewMatrixInverseTranspose gl_ProjectionMatrixInverseTranspose gl_ModelViewProjectionMatrixInverseTranspose gl_TextureMatrixInverseTranspose gl_NormalScale gl_DepthRange gl_ClipPlane gl_Point gl_FrontMaterial gl_BackMaterial gl_LightSource gl_LightModel gl_FrontLightModelProduct gl_BackLightModelProduct gl_TextureColor gl_EyePlaneS gl_EyePlaneT gl_EyePlaneR gl_EyePlaneQ gl_FogParameters gl_MaxLights gl_MaxClipPlanes gl_MaxTextureUnits gl_MaxTextureCoords gl_MaxVertexAttribs gl_MaxVertexUniformComponents gl_MaxVaryingFloats gl_MaxVertexTextureImageUnits gl_MaxTextureImageUnits gl_MaxFragmentUniformComponents gl_MaxCombineTextureImageUnits gl_MaxDrawBuffers"),indentSwitch:!1,hooks:{"#":s},modeProps:{fold:["brace","include"]}}),h("text/x-nesc",{name:"clike",keywords:i(b+"as atomic async call command component components configuration event generic implementation includes interface module new norace nx_struct nx_union post provides signal task uses abstract extends"),types:i(k),blockKeywords:i("case do else for if switch while struct"),atoms:i("null true false"),hooks:{"#":s},modeProps:{fold:["brace","include"]}}),h("text/x-objectivec",{name:"clike",keywords:i(b+"inline restrict _Bool _Complex _Imaginary BOOL Class bycopy byref id IMP in inout nil oneway out Protocol SEL self super atomic nonatomic retain copy readwrite readonly"),types:i(k),atoms:i("YES NO NULL NILL ON OFF true false"),hooks:{"@":function(e){return e.eatWhile(/[\w\$]/),"keyword"},"#":s,indent:function(e,t,n){if("statement"==t.type&&/^@\w/.test(n))return t.indented}},modeProps:{fold:"brace"}}),h("text/x-squirrel",{name:"clike",keywords:i("base break clone continue const default delete enum extends function in class foreach local resume return this throw typeof yield constructor instanceof static"),types:i(k),blockKeywords:i("case catch class else for foreach if switch try while"),defKeywords:i("function local class"),typeFirstDefinitions:!0,atoms:i("true false null"),hooks:{"#":s},modeProps:{fold:["brace","include"]}});var w=null;h("text/x-ceylon",{name:"clike",keywords:i("abstracts alias assembly assert assign break case catch class continue dynamic else exists extends finally for function given if import in interface is let module new nonempty object of out outer package return satisfies super switch then this throw try value void while"),types:function(e){var t=e.charAt(0);return t===t.toUpperCase()&&t!==t.toLowerCase()},blockKeywords:i("case catch class dynamic else finally for function if interface module new object switch try while"),defKeywords:i("class dynamic function interface module object package value"),builtin:i("abstract actual aliased annotation by default deprecated doc final formal late license native optional sealed see serializable shared suppressWarnings tagged throws variable"),isPunctuationChar:/[\[\]{}\(\),;\:\.`]/,isOperatorChar:/[+\-*&%=<>!?|^~:\/]/,numberStart:/[\d#$]/,number:/^(?:#[\da-fA-F_]+|\$[01_]+|[\d_]+[kMGTPmunpf]?|[\d_]+\.[\d_]+(?:[eE][-+]?\d+|[kMGTPmunpf]|)|)/i,multiLineStrings:!0,typeFirstDefinitions:!0,atoms:i("true false null larger smaller equal empty finished"),indentSwitch:!1,styleDefs:!1,hooks:{"@":function(e){return e.eatWhile(/[\w\$_]/),"meta"},'"':function(e,t){return t.tokenize=x(e.match('""')?"triple":"single"),t.tokenize(e,t)},"`":function(e,t){return!(!w||!e.match("`"))&&(t.tokenize=w,w=null,t.tokenize(e,t))},"'":function(e){return e.eatWhile(/[\w\$_\xa1-\uffff]/),"atom"},token:function(e,t,n){if(("variable"==n||"type"==n)&&"."==t.prevToken)return"variable-2"}},modeProps:{fold:["brace","import"],closeBrackets:{triples:'"'}}})});
      // -------------------------------------------------------------------------
//  Part of the CodeChecker project, under the Apache License v2.0 with
//  LLVM Exceptions. See LICENSE for license information.
//  SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
// -------------------------------------------------------------------------

var BugViewer = {
  _files : [],
  _reports : [],
  _lineWidgets : [],
  _navigationMenuItems : [],
  _sourceFileData : null,
  _currentReport : null,
  _lastBugEvent  : null,

  init : function (files, reports) {
    this._files = files;
    this._reports = reports;

    this.initEscapeChars();
  },

  initEscapeChars : function () {
    this.escapeChars = {
      ' ' : 'nbsp',
      '<' : 'lt',
      '>' : 'gt',
      '"' : 'quot',
      '&' : 'amp'
    };

    var regexString = '[';
    for (var key in this.escapeChars) {
      regexString += key;
    }
    regexString += ']';

    this.escapeRegExp = new RegExp( regexString, 'g');
  },

  escapeHTML : function (str) {
    var that = this;

    return str.replace(this.escapeRegExp, function (m) {
      return '&' + that.escapeChars[m] + ';';
    });
  },

  initByUrl : function () {
    if (!this._reports) return;

    var state = {};
    window.location.hash.substr(1).split('&').forEach(function (s) {
      var parts = s.split('=');
      state[parts[0]] = parts[1];
    });

    for (var key in this._reports) {
      var report = this._reports[key];
      if (report.reportHash === state['reportHash']) {
        this.navigate(report);
        return;
      }
    }

    this.navigate(this._reports[0]);
  },

  create : function () {
    this._content = document.getElementById('editor-wrapper');
    this._filepath = document.getElementById('file-path');
    this._checkerName = document.getElementById('checker-name');
    this._reviewStatusWrapper =
      document.getElementById('review-status-wrapper');
    this._reviewStatus = document.getElementById('review-status');
    this._editor = document.getElementById('editor');

    this._codeMirror = CodeMirror(this._editor, {
      mode: 'text/x-c++src',
      matchBrackets : true,
      lineNumbers : true,
      readOnly : true,
      foldGutter : true,
      extraKeys : {},
      viewportMargin : 100
    });

    this._createNavigationMenu();
  },

  navigate : function (report, item) {
    if (!item) {
      var items = this._navigationMenuItems.filter(function (navItem) {
        return navItem.report.reportHash === report.reportHash;
      });

      if (!items.length) return;

      item = items[0].widget;
    }

    this._selectedReport.classList.remove('active');
    this._selectedReport = item;
    this._selectedReport.classList.add('active');
    this.setReport(report);
  },

  _createNavigationMenu : function () {
    var that = this;

    var nav = document.getElementById('report-nav');
    var list = document.createElement('ul');
    this._reports.forEach(function (report) {
      var events = report['events'];
      var lastBugEvent = events[events.length - 1];
      var item = document.createElement('li');

      var severity = document.createElement('i');
      severity.className = 'severity-' + report.severity.toLowerCase();

      item.appendChild(severity);
      item.appendChild(document.createTextNode(lastBugEvent.message));

      item.addEventListener('click', function () {
        that.navigate(report, item);
      })
      list.appendChild(item);
      that._navigationMenuItems.push({ report : report, widget : item });
    });

    if (!this._selectedReport && list.childNodes.length) {
      this._selectedReport = list.childNodes[0];
      this._selectedReport.classList.add('active');
    }

    nav.appendChild(list);
  },

  setReport : function (report) {
    this._currentReport = report;
    var events = report['events'];
    var lastBugEvent = events[events.length - 1];
    this.setCurrentBugEvent(lastBugEvent, events.length - 1);
    this.setCheckerName(report.checkerName);
    this.setReviewStatus(report.reviewStatus);

    window.location.hash = '#reportHash=' + report.reportHash;
  },

  setCurrentBugEvent : function (event, idx) {
    this._currentBugEvent = event;
    this.setSourceFileData(this._files[event.location.file]);
    this.drawBugPath();

    this.jumpTo(event.location.line, 0);
    this.highlightBugEvent(event, idx);
  },

  highlightBugEvent : function (event, idx) {
    this._lineWidgets.forEach(function (widget) {
      var lineIdx = widget.node.getAttribute('idx');
      if (parseInt(lineIdx) === idx) {
        widget.node.classList.add('current');
      }
    });
  },

  setCheckerName : function (checkerName) {
    this._checkerName.innerHTML = checkerName;
  },

  setReviewStatus : function (status) {
    if (status) {
      var className =
        'review-status-' + status.toLowerCase().split(' ').join('-');
      this._reviewStatus.className = "review-status " + className;

      this._reviewStatus.innerHTML = status;
      this._reviewStatusWrapper.style.display = 'block';
    } else {
      this._reviewStatusWrapper.style.display = 'none';
    }
  },

  setSourceFileData : function (file) {
    if (this._sourceFileData && file.id === this._sourceFileData.id) {
      return;
    }

    this._sourceFileData = file;
    this._filepath.innerHTML = file.path;
    this._codeMirror.doc.setValue(file.content);
    this._refresh();
  },

  _refresh : function () {
    var that = this;
    setTimeout(function () {
      var fullHeight = parseInt(that._content.clientHeight);
      var headerHeight = that._filepath.clientHeight;

      that._codeMirror.setSize('auto', fullHeight - headerHeight);
      that._codeMirror.refresh();
    }, 200);
  },

  clearBubbles : function () {
    this._lineWidgets.forEach(function (widget) { widget.clear(); });
    this._lineWidgets = [];
  },

  getMessage : function (event, kind) {
    if (kind === 'macro') {
      var name = 'macro expansion' + (event.name ? ': ' + event.name : '');

      return '<span class="tag macro">' + name + '</span>'
        + this.escapeHTML(event.expansion).replace(/(?:\r\n|\r|\n)/g, '<br>');
    } else if (kind === 'note') {
      return '<span class="tag note">note</span>'
        +  this.escapeHTML(event.message).replace(/(?:\r\n|\r|\n)/g, '<br>');
    }
  },

  addExtraPathEvents : function (events, kind) {
    var that = this;

    if (!events) {
      return;
    }

    events.forEach(function (event) {
      if (event.location.file !== that._currentBugEvent.location.file) {
        return;
      }

      var left =
        that._codeMirror.defaultCharWidth() * event.location.col + 'px';

      var element = document.createElement('div');
      element.setAttribute('style', 'margin-left: ' + left);
      element.setAttribute('class', 'check-msg ' + kind);

      var msg = document.createElement('span');
      msg.innerHTML = that.getMessage(event, kind);
      element.appendChild(msg);

      that._lineWidgets.push(that._codeMirror.addLineWidget(
        event.location.line - 1, element));
    });
  },

  drawBugPath : function () {
    var that = this;

    this.clearBubbles();

    this.addExtraPathEvents(this._currentReport.macros, 'macro');
    this.addExtraPathEvents(this._currentReport.notes, 'note');

    // Processing bug path events.
    var currentEvents = this._currentReport.events;
    currentEvents.forEach(function (event, step) {
      if (event.location.file !== that._currentBugEvent.location.file)
        return;

      var left =
        that._codeMirror.defaultCharWidth() * event.location.col + 'px';
      var type = step === currentEvents.length - 1 ? 'error' : 'info';

      var element = document.createElement('div');
      element.setAttribute('style', 'margin-left: ' + left);
      element.setAttribute('class', 'check-msg ' + type);
      element.setAttribute('idx', step);

      var enumeration = document.createElement('span');
      enumeration.setAttribute('class', 'checker-enum ' + type);
      enumeration.innerHTML = step + 1;

      if (currentEvents.length > 1)
        element.appendChild(enumeration);

      var prevBugEvent = step - 1;
      if (step > 0) {
        var prevBug = document.createElement('span');
        prevBug.setAttribute('class', 'arrow left-arrow');
        prevBug.addEventListener('click', function () {
          var event = currentEvents[prevBugEvent];
          that.setCurrentBugEvent(event, prevBugEvent);
        });
        element.appendChild(prevBug);
      }

      var msg = document.createElement('span');
      msg.innerHTML = that.escapeHTML(event.message)
        .replace(/(?:\r\n|\r|\n)/g, '<br>');

      element.appendChild(msg);

      var nextBugEvent = step + 1;
      if (nextBugEvent < currentEvents.length) {
        var nextBug = document.createElement('span');
        nextBug.setAttribute('class', 'arrow right-arrow');
        nextBug.addEventListener('click', function () {
          var event = currentEvents[nextBugEvent];
          that.setCurrentBugEvent(event, nextBugEvent);
        });
        element.appendChild(nextBug);
      }


      that._lineWidgets.push(that._codeMirror.addLineWidget(
        event.location.line - 1, element));
    });
  },

  jumpTo : function (line, column) {
    var that = this;

    setTimeout(function () {
      var selPosPixel
        = that._codeMirror.charCoords({ line : line, ch : column }, 'local');
      var editorSize = {
        width  : that._editor.clientWidth,
        height : that._editor.clientHeight
      };

      that._codeMirror.scrollIntoView({
        top    : selPosPixel.top - 100,
        bottom : selPosPixel.top + editorSize.height - 150,
        left   : selPosPixel.left < editorSize.width - 100
               ? 0
               : selPosPixel.left - 50,
        right  : selPosPixel.left < editorSize.width - 100
               ? 10
               : selPosPixel.left + editorSize.width - 100
      });
    }, 0);
  }
}


      var data = {"files": {"1": {"id": 1, "path": "/home/runner/work/testcc/testcc/retdec/src/lib-dcrypt/dcrypt-openssl.c", "content": "/* Copyright (c) 2016-2018 Dovecot authors, see the included COPYING file */\n\n#include \"lib.h\"\n#include \"buffer.h\"\n#include \"base64.h\"\n#include \"str.h\"\n#include \"hex-binary.h\"\n#include \"safe-memset.h\"\n#include \"randgen.h\"\n#include \"array.h\"\n#include \"module-dir.h\"\n#include \"istream.h\"\n#include \"json-tree.h\"\n#include \"dovecot-openssl-common.h\"\n#include <openssl/evp.h>\n#include <openssl/sha.h>\n#include <openssl/err.h>\n#include <openssl/rsa.h>\n#include <openssl/ec.h>\n#include <openssl/bio.h>\n#include <openssl/pem.h>\n#include <openssl/x509.h>\n#include <openssl/engine.h>\n#include <openssl/hmac.h>\n#include <openssl/objects.h>\n#include <openssl/bn.h>\n#include \"dcrypt.h\"\n#include \"dcrypt-private.h\"\n\n/**\n\n key format documentation:\n =========================\n\n v1 key\n ------\n algo id = openssl NID\n enctype = 0 = none, 1 = ecdhe, 2 = password\n key id = sha256(hex encoded public point)\n\n public key\n ----------\n 1<tab>algo id<tab>public point\n\n private key\n -----------\n - enctype none\n 1<tab>algo id<tab>0<tab>private point<tab>key id\n\n - enctype ecdh (algorithm AES-256-CTR, key = SHA256(shared secret), IV = \\0\\0\\0...)\n 1<tab>algo id<tab>1<tab>private point<tab>ephemeral public key<tab>encryption key id<tab>key id\n\n - enctype password (algorithm AES-256-CTR, key = PBKDF2(SHA1, 16, password, salt), IV = \\0\\0\\0...)\n 1<tab>algo id<tab>2<tab>private point<tab>salt<tab>key id\n\n v2 key\n ------\n algo oid = ASN1 OID of key algorithm (RSA or EC curve)\n enctype = 0 = none, 1 = ecdhe, 2 = password\n key id = SHA256(i2d_PUBKEY)\n\n public key\n ----------\n 2<tab>HEX(i2d_PUBKEY)<tab>key id\n\n - enctype none\n 2<tab>key algo oid<tab>0<tab>(RSA = i2d_PrivateKey, EC=Private Point)<tab>key id\n\n - enctype ecdh, key,iv = PBKDF2(hash algo, rounds, shared secret, salt)\n 2<tab>key algo oid<tab>1<tab>symmetric algo name<tab>salt<tab>hash algo<tab>rounds<tab>E(RSA = i2d_PrivateKey, EC=Private Point)<tab>ephemeral public key<tab>encryption key id<tab>key id\n\n - enctype password, key,iv = PBKDF2(hash algo, rounds, password, salt)\n  2<tab>key algo oid<tab>1<tab>symmetric algo name<tab>salt<tab>hash algo<tab>rounds<tab>E(RSA = i2d_PrivateKey, EC=Private Point)<tab>key id\n**/\n\n#ifndef HAVE_EVP_PKEY_get0\n#define EVP_PKEY_get0_EC_KEY(x) x->pkey.ec\n#define EVP_PKEY_get0_RSA(x) x->pkey.rsa\n#endif\n\n#ifndef HAVE_OBJ_LENGTH\n#define OBJ_length(o) ((o)->length)\n#endif\n\n#ifndef HAVE_EVP_MD_CTX_NEW\n#  define EVP_MD_CTX_new() EVP_MD_CTX_create()\n#  define EVP_MD_CTX_free(ctx) EVP_MD_CTX_destroy(ctx)\n#endif\n\n#ifndef HAVE_HMAC_CTX_NEW\n#  define HMAC_Init_ex(ctx, key, key_len, md, impl) \\\n\tHMAC_Init_ex(&(ctx), key, key_len, md, impl)\n#  define HMAC_Update(ctx, data, len) HMAC_Update(&(ctx), data, len)\n#  define HMAC_Final(ctx, md, len) HMAC_Final(&(ctx), md, len)\n#  define HMAC_CTX_free(ctx) HMAC_cleanup(&(ctx))\n#else\n#  define HMAC_CTX_free(ctx) \\\n\tSTMT_START { HMAC_CTX_free(ctx); (ctx) = NULL; } STMT_END\n#endif\n\n/* Not always present */\n#ifndef HAVE_BN_SECURE_NEW\n#  define BN_secure_new BN_new\n#endif\n\n/* openssl manual says this is OK */\n#define OID_TEXT_MAX_LEN 80\n\n#define t_base64url_decode_str(x) t_base64url_decode_str(BASE64_DECODE_FLAG_IGNORE_PADDING, (x))\n\nstruct dcrypt_context_symmetric {\n\tpool_t pool;\n\tconst EVP_CIPHER *cipher;\n\tEVP_CIPHER_CTX *ctx;\n\tunsigned char *key;\n\tunsigned char *iv;\n\tunsigned char *aad;\n\tsize_t aad_len;\n\tunsigned char *tag;\n\tsize_t tag_len;\n\tint padding;\n\tint mode;\n};\n\nstruct dcrypt_context_hmac {\n\tpool_t pool;\n\tconst EVP_MD *md;\n#ifdef HAVE_HMAC_CTX_NEW\n\tHMAC_CTX *ctx;\n#else\n\tHMAC_CTX ctx;\n#endif\n\tunsigned char *key;\n\tsize_t klen;\n};\n\nstruct dcrypt_public_key {\n\tEVP_PKEY *key;\n\tunsigned int ref;\n\tenum dcrypt_key_usage usage;\n\tchar *key_id;\n};\n\nstruct dcrypt_private_key {\n\tEVP_PKEY *key;\n\tunsigned int ref;\n\tenum dcrypt_key_usage usage;\n\tchar *key_id;\n};\n\n#define DCRYPT_SET_ERROR(error) STMT_START { if (error_r != NULL) *error_r = (error); } STMT_END\n\nstatic bool\ndcrypt_openssl_public_key_id(struct dcrypt_public_key *key,\n\t\t\t     const char *algorithm, buffer_t *result,\n\t\t\t     const char **error_r);\nstatic bool\ndcrypt_openssl_public_key_id_old(struct dcrypt_public_key *key,\n\t\t\t\t buffer_t *result, const char **error_r);\nstatic bool\ndcrypt_openssl_private_key_id(struct dcrypt_private_key *key,\n\t\t\t      const char *algorithm, buffer_t *result,\n\t\t\t      const char **error_r);\nstatic bool\ndcrypt_openssl_private_key_id_old(struct dcrypt_private_key *key,\n\t\t\t\t  buffer_t *result, const char **error_r);\nstatic void\ndcrypt_openssl_private_to_public_key(struct dcrypt_private_key *priv_key,\n\t\t\t\t     struct dcrypt_public_key **pub_key_r);\nstatic void\ndcrypt_openssl_unref_private_key(struct dcrypt_private_key **key);\nstatic void\ndcrypt_openssl_unref_public_key(struct dcrypt_public_key **key);\nstatic bool\ndcrypt_openssl_rsa_decrypt(struct dcrypt_private_key *key,\n\t\t\t   const unsigned char *data, size_t data_len,\n\t\t\t   buffer_t *result, enum dcrypt_padding padding,\n\t\t\t   const char **error_r);\nstatic bool\ndcrypt_openssl_key_string_get_info(const char *key_data,\n\tenum dcrypt_key_format *format_r, enum dcrypt_key_version *version_r,\n\tenum dcrypt_key_kind *kind_r,\n\tenum dcrypt_key_encryption_type *encryption_type_r,\n\tconst char **encryption_key_hash_r, const char **key_hash_r,\n\tconst char **error_r);\n\n#ifndef HAVE_EC_GROUP_order_bits\nstatic int EC_GROUP_order_bits(const EC_GROUP *grp)\n{\n\tint bits;\n\tBIGNUM *bn = BN_new();\n\t(void)EC_GROUP_get_order(grp, bn, NULL);\n\tbits = BN_num_bits(bn);\n\tBN_free(bn);\n\treturn bits;\n}\n#endif\n\nstatic bool dcrypt_openssl_error(const char **error_r)\n{\n\tunsigned long ec;\n\n\tif (error_r == NULL) {\n\t\t/* caller is not really interested */\n\t\treturn FALSE; \n\t}\n\n\tec = ERR_get_error();\n\tDCRYPT_SET_ERROR(t_strdup_printf(\"%s\", ERR_error_string(ec, NULL)));\n\treturn FALSE;\n}\n\nstatic int\ndcrypt_openssl_padding_mode(enum dcrypt_padding padding,\n\t\t\t    bool sig, const char **error_r)\n{\n\tswitch (padding) {\n\tcase DCRYPT_PADDING_DEFAULT:\n\t\tif (sig) return RSA_PKCS1_PSS_PADDING;\n\t\telse return RSA_PKCS1_OAEP_PADDING;\n\tcase DCRYPT_PADDING_RSA_PKCS1_OAEP:\n\t\treturn RSA_PKCS1_OAEP_PADDING;\n\tcase DCRYPT_PADDING_RSA_PKCS1_PSS:\n\t\treturn RSA_PKCS1_PSS_PADDING;\n\tcase DCRYPT_PADDING_RSA_PKCS1:\n\t\treturn RSA_PKCS1_PADDING;\n\tcase DCRYPT_PADDING_RSA_NO:\n\t\treturn RSA_NO_PADDING;\n\tdefault:\n\t\tDCRYPT_SET_ERROR(\"Unsupported padding mode\");\n\t\treturn -1;\n\t}\n\ti_unreached();\n}\n\nstatic bool dcrypt_openssl_initialize(const struct dcrypt_settings *set,\n\t\t\t\t      const char **error_r)\n{\n\tif (set->crypto_device != NULL && set->crypto_device[0] != '\\0') {\n\t\tif (dovecot_openssl_common_global_set_engine(\n\t\t\tset->crypto_device, error_r) <= 0)\n\t\t\treturn FALSE;\n\t}\n\treturn TRUE;\n}\n\n/* legacy function for old formats that generates\n   hex encoded point from EC public key\n */\nstatic char *ec_key_get_pub_point_hex(const EC_KEY *key)\n{\n\tconst EC_POINT *p;\n\tconst EC_GROUP *g;\n\n\tp = EC_KEY_get0_public_key(key);\n\tg = EC_KEY_get0_group(key);\n\treturn EC_POINT_point2hex(g, p, POINT_CONVERSION_COMPRESSED, NULL);\n}\n\nstatic bool\ndcrypt_openssl_ctx_sym_create(const char *algorithm, enum dcrypt_sym_mode mode,\n\t\t\t      struct dcrypt_context_symmetric **ctx_r,\n\t\t\t      const char **error_r)\n{\n\tstruct dcrypt_context_symmetric *ctx;\n\tpool_t pool;\n\tconst EVP_CIPHER *cipher;\n\n\tcipher = EVP_get_cipherbyname(algorithm);\n\tif (cipher == NULL) {\n\t\tDCRYPT_SET_ERROR(t_strdup_printf(\"Invalid cipher %s\",\n\t\t\t\t\t\t algorithm));\n\t\treturn FALSE;\n\t}\n\n\t/* allocate context */\n\tpool = pool_alloconly_create(\"dcrypt openssl\", 1024);\n\tctx = p_new(pool, struct dcrypt_context_symmetric, 1);\n\tctx->pool = pool;\n\tctx->cipher = cipher;\n\tctx->padding = 1;\n\tctx->mode = (mode == DCRYPT_MODE_ENCRYPT ? 1 : 0);\n\t*ctx_r = ctx;\n\treturn TRUE;\n}\n\nstatic void\ndcrypt_openssl_ctx_sym_destroy(struct dcrypt_context_symmetric **ctx)\n{\n\tpool_t pool = (*ctx)->pool;\n\n\tif ((*ctx)->ctx != NULL)\n\t\tEVP_CIPHER_CTX_free((*ctx)->ctx);\n\tpool_unref(&pool);\n\t*ctx = NULL;\n}\n\nstatic void\ndcrypt_openssl_ctx_sym_set_key(struct dcrypt_context_symmetric *ctx,\n\t\t\t       const unsigned char *key, size_t key_len)\n{\n\tif (ctx->key != NULL)\n\t\tp_free(ctx->pool, ctx->key);\n\tctx->key = p_malloc(ctx->pool, EVP_CIPHER_key_length(ctx->cipher));\n\tmemcpy(ctx->key, key, I_MIN(key_len,\n\t       (size_t)EVP_CIPHER_key_length(ctx->cipher)));\n}\n\nstatic void\ndcrypt_openssl_ctx_sym_set_iv(struct dcrypt_context_symmetric *ctx,\n\t\t\t      const unsigned char *iv, size_t iv_len)\n{\n\tif(ctx->iv != NULL)\n\t\tp_free(ctx->pool, ctx->iv);\n\n\tctx->iv = p_malloc(ctx->pool, EVP_CIPHER_iv_length(ctx->cipher));\n\tmemcpy(ctx->iv, iv, I_MIN(iv_len,\n\t       (size_t)EVP_CIPHER_iv_length(ctx->cipher)));\n}\n\nstatic void\ndcrypt_openssl_ctx_sym_set_key_iv_random(struct dcrypt_context_symmetric *ctx)\n{\n\tif(ctx->key != NULL)\n\t\tp_free(ctx->pool, ctx->key);\n\tif(ctx->iv != NULL)\n\t\tp_free(ctx->pool, ctx->iv);\n\n\tctx->key = p_malloc(ctx->pool, EVP_CIPHER_key_length(ctx->cipher));\n\trandom_fill(ctx->key, EVP_CIPHER_key_length(ctx->cipher));\n\tctx->iv = p_malloc(ctx->pool, EVP_CIPHER_iv_length(ctx->cipher));\n\trandom_fill(ctx->iv, EVP_CIPHER_iv_length(ctx->cipher));\n}\n\nstatic void\ndcrypt_openssl_ctx_sym_set_padding(struct dcrypt_context_symmetric *ctx,\n\t\t\t\t   bool padding)\n{\n\tctx->padding = (padding?1:0);\n}\n\nstatic bool\ndcrypt_openssl_ctx_sym_get_key(struct dcrypt_context_symmetric *ctx,\n\t\t\t       buffer_t *key)\n{\n\tif(ctx->key == NULL)\n\t\treturn FALSE;\n\n\tbuffer_append(key, ctx->key, EVP_CIPHER_key_length(ctx->cipher));\n\treturn TRUE;\n}\n\nstatic bool\ndcrypt_openssl_ctx_sym_get_iv(struct dcrypt_context_symmetric *ctx,\n\t\t\t      buffer_t *iv)\n{\n\tif(ctx->iv == NULL)\n\t\treturn FALSE;\n\n\tbuffer_append(iv, ctx->iv, EVP_CIPHER_iv_length(ctx->cipher));\n\treturn TRUE;\n}\n\nstatic void\ndcrypt_openssl_ctx_sym_set_aad(struct dcrypt_context_symmetric *ctx,\n\t\t\t       const unsigned char *aad, size_t aad_len)\n{\n\tif (ctx->aad != NULL)\n\t\tp_free(ctx->pool, ctx->aad);\n\n\t/* allow empty aad */\n\tctx->aad = p_malloc(ctx->pool, I_MAX(1,aad_len));\n\tmemcpy(ctx->aad, aad, aad_len);\n\tctx->aad_len = aad_len;\n}\n\nstatic bool\ndcrypt_openssl_ctx_sym_get_aad(struct dcrypt_context_symmetric *ctx,\n\t\t\t       buffer_t *aad)\n{\n\tif (ctx->aad == NULL)\n\t\treturn FALSE;\n\n\tbuffer_append(aad, ctx->aad, ctx->aad_len);\n\treturn TRUE;\n}\n\nstatic void\ndcrypt_openssl_ctx_sym_set_tag(struct dcrypt_context_symmetric *ctx,\n\t\t\t       const unsigned char *tag, size_t tag_len)\n{\n\tif (ctx->tag != NULL)\n\t\tp_free(ctx->pool, ctx->tag);\n\n\t/* unlike aad, tag cannot be empty */\n\tctx->tag = p_malloc(ctx->pool, tag_len);\n\tmemcpy(ctx->tag, tag, tag_len);\n\tctx->tag_len = tag_len;\n}\n\nstatic bool\ndcrypt_openssl_ctx_sym_get_tag(struct dcrypt_context_symmetric *ctx,\n\t\t\t       buffer_t *tag)\n{\n\tif (ctx->tag == NULL)\n\t\treturn FALSE;\n\n\tbuffer_append(tag, ctx->tag, ctx->tag_len);\n\treturn TRUE;\n}\n\nstatic unsigned int\ndcrypt_openssl_ctx_sym_get_key_length(struct dcrypt_context_symmetric *ctx)\n{\n\treturn EVP_CIPHER_key_length(ctx->cipher);\n}\n\nstatic unsigned int\ndcrypt_openssl_ctx_sym_get_iv_length(struct dcrypt_context_symmetric *ctx)\n{\n\treturn EVP_CIPHER_iv_length(ctx->cipher);\n}\n\nstatic unsigned int\ndcrypt_openssl_ctx_sym_get_block_size(struct dcrypt_context_symmetric *ctx)\n{\n\treturn EVP_CIPHER_block_size(ctx->cipher);\n}\n\nstatic bool\ndcrypt_openssl_ctx_sym_init(struct dcrypt_context_symmetric *ctx,\n\t\t\t    const char **error_r)\n{\n\tint ec;\n\tint len;\n\n\ti_assert(ctx->key != NULL);\n\ti_assert(ctx->iv != NULL);\n\ti_assert(ctx->ctx == NULL);\n\n\tif((ctx->ctx = EVP_CIPHER_CTX_new()) == NULL)\n\t\treturn dcrypt_openssl_error(error_r);\n\n\tec = EVP_CipherInit_ex(ctx->ctx, ctx->cipher, NULL,\n\t\t\t       ctx->key, ctx->iv, ctx->mode);\n\tif (ec != 1)\n\t\treturn dcrypt_openssl_error(error_r);\n\n\tEVP_CIPHER_CTX_set_padding(ctx->ctx, ctx->padding);\n\tlen = 0;\n\tif (ctx->aad != NULL) {\n\t\tec = EVP_CipherUpdate(ctx->ctx, NULL, &len,\n\t\t\t\t      ctx->aad, ctx->aad_len);\n\t}\n\tif (ec != 1)\n\t\treturn dcrypt_openssl_error(error_r);\n\treturn TRUE;\n}\n\nstatic bool\ndcrypt_openssl_ctx_sym_update(struct dcrypt_context_symmetric *ctx,\n\t\t\t      const unsigned char *data, size_t data_len,\n\t\t\t      buffer_t *result, const char **error_r)\n{\n\tconst size_t block_size = (size_t)EVP_CIPHER_block_size(ctx->cipher);\n\tsize_t buf_used = result->used;\n\tunsigned char *buf;\n\tint outl;\n\n\ti_assert(ctx->ctx != NULL);\n\n\t/* From `man 3 evp_cipherupdate`:\n\n\t   EVP_EncryptUpdate() encrypts inl bytes from the buffer in and writes\n\t   the encrypted version to out. This function can be called multiple\n\t   times to encrypt successive blocks of data. The amount of data\n\t   written depends on the block alignment of the encrypted data: as a\n\t   result the amount of data written may be anything from zero bytes to\n\t   (inl + cipher_block_size - 1) so out should contain sufficient room.\n\t   The actual number of bytes written is placed in outl.\n\t */\n\n\tbuf = buffer_append_space_unsafe(result, data_len + block_size);\n\toutl = 0;\n\tif (EVP_CipherUpdate\n\t\t(ctx->ctx, buf, &outl, data, data_len) != 1)\n\t\treturn dcrypt_openssl_error(error_r);\n\tbuffer_set_used_size(result, buf_used + outl);\n\treturn TRUE;\n}\n\nstatic bool\ndcrypt_openssl_ctx_sym_final(struct dcrypt_context_symmetric *ctx,\n\t\t\t     buffer_t *result, const char **error_r)\n{\n\tconst size_t block_size = (size_t)EVP_CIPHER_block_size(ctx->cipher);\n\tsize_t buf_used = result->used;\n\tunsigned char *buf;\n\tint outl;\n\tint ec;\n\n\ti_assert(ctx->ctx != NULL);\n\n\t/* From `man 3 evp_cipherupdate`:\n\n\t   If padding is enabled (the default) then EVP_EncryptFinal_ex()\n\t   encrypts the \"final\" data, that is any data that remains in a partial\n\t   block. It uses standard block padding (aka PKCS padding). The\n\t   encrypted final data is written to out which should have sufficient\n\t   space for one cipher block. The number of bytes written is placed in\n\t   outl. After this function is called the encryption operation is\n\t   finished and no further calls to EVP_EncryptUpdate() should be made.\n\t */\n\n\tbuf = buffer_append_space_unsafe(result, block_size);\n\toutl = 0;\n\n\t/* when **DECRYPTING** set expected tag */\n\tif (ctx->mode == 0 && ctx->tag != NULL) {\n\t\tec = EVP_CIPHER_CTX_ctrl(ctx->ctx, EVP_CTRL_GCM_SET_TAG,\n\t\t\t\t\t ctx->tag_len, ctx->tag);\n\t} else {\n\t\tec = 1;\n\t}\n\n\tif (ec == 1)\n\t\tec = EVP_CipherFinal_ex(ctx->ctx, buf, &outl);\n\n\tif (ec == 1) {\n\t\tbuffer_set_used_size(result, buf_used + outl);\n\t\t/* when **ENCRYPTING** recover tag */\n\t\tif (ctx->mode == 1 && ctx->aad != NULL) {\n\t\t\t/* tag should be NULL here */\n\t\t\ti_assert(ctx->tag == NULL);\n\t\t\t/* openssl claims taglen is always 16, go figure .. */\n\t\t\tctx->tag = p_malloc(ctx->pool, EVP_GCM_TLS_TAG_LEN);\n\t\t\tec = EVP_CIPHER_CTX_ctrl(ctx->ctx, EVP_CTRL_GCM_GET_TAG,\n\t\t\t\t\t\t EVP_GCM_TLS_TAG_LEN, ctx->tag);\n\t\t\tctx->tag_len = EVP_GCM_TLS_TAG_LEN;\n\t\t}\n\t}\n\n\tif (ec == 0)\n\t\tDCRYPT_SET_ERROR(\"data authentication failed\");\n\telse if (ec < 0)\n\t\tdcrypt_openssl_error(error_r);\n\n\tEVP_CIPHER_CTX_free(ctx->ctx);\n\tctx->ctx = NULL;\n\n\treturn (ec == 1);\n}\n\nstatic bool\ndcrypt_openssl_ctx_hmac_create(const char *algorithm,\n\t\t\t       struct dcrypt_context_hmac **ctx_r,\n\t\t\t       const char **error_r)\n{\n\tstruct dcrypt_context_hmac *ctx;\n\tpool_t pool;\n\tconst EVP_MD *md;\n\n\tmd = EVP_get_digestbyname(algorithm);\n\tif(md == NULL) {\n\t\tDCRYPT_SET_ERROR(t_strdup_printf(\"Invalid digest %s\",\n\t\t\t\t\t\t algorithm));\n\t\treturn FALSE;\n\t}\n\n\t/* allocate context */\n\tpool = pool_alloconly_create(\"dcrypt openssl\", 1024);\n\tctx = p_new(pool, struct dcrypt_context_hmac, 1);\n\tctx->pool = pool;\n\tctx->md = md;\n\t*ctx_r = ctx;\n\treturn TRUE;\n}\n\nstatic void\ndcrypt_openssl_ctx_hmac_destroy(struct dcrypt_context_hmac **ctx)\n{\n\tpool_t pool = (*ctx)->pool;\n\tHMAC_CTX_free((*ctx)->ctx);\n\tpool_unref(&pool);\n\t*ctx = NULL;\n}\n\nstatic void\ndcrypt_openssl_ctx_hmac_set_key(struct dcrypt_context_hmac *ctx,\n\t\t\t\tconst unsigned char *key, size_t key_len)\n{\n\tif (ctx->key != NULL)\n\t\tp_free(ctx->pool, ctx->key);\n\n\tctx->klen = I_MIN(key_len, HMAC_MAX_MD_CBLOCK);\n\tctx->key = p_malloc(ctx->pool, ctx->klen);\n\tmemcpy(ctx->key, key, ctx->klen);\n}\n\nstatic bool\ndcrypt_openssl_ctx_hmac_get_key(struct dcrypt_context_hmac *ctx, buffer_t *key)\n{\n\tif (ctx->key == NULL)\n\t\treturn FALSE;\n\tbuffer_append(key, ctx->key, ctx->klen);\n\treturn TRUE;\n}\n\nstatic void\ndcrypt_openssl_ctx_hmac_set_key_random(struct dcrypt_context_hmac *ctx)\n{\n\tctx->klen = HMAC_MAX_MD_CBLOCK;\n\tctx->key = p_malloc(ctx->pool, ctx->klen);\n\trandom_fill(ctx->key, ctx->klen);\n}\n\nstatic unsigned int\ndcrypt_openssl_ctx_hmac_get_digest_length(struct dcrypt_context_hmac *ctx)\n{\n\treturn EVP_MD_size(ctx->md);\n}\n\nstatic bool\ndcrypt_openssl_ctx_hmac_init(struct dcrypt_context_hmac *ctx,\n\t\t\t     const char **error_r)\n{\n\tint ec;\n\n\ti_assert(ctx->md != NULL);\n#ifdef HAVE_HMAC_CTX_NEW\n\tctx->ctx = HMAC_CTX_new();\n\tif (ctx->ctx == NULL)\n\t\treturn dcrypt_openssl_error(error_r);\n#endif\n\tec = HMAC_Init_ex(ctx->ctx, ctx->key, ctx->klen, ctx->md, NULL);\n\tif (ec != 1)\n\t\treturn dcrypt_openssl_error(error_r);\n\treturn TRUE;\n}\n\nstatic bool\ndcrypt_openssl_ctx_hmac_update(struct dcrypt_context_hmac *ctx,\n\t\t\t       const unsigned char *data, size_t data_len,\n\t\t\t       const char **error_r)\n{\n\tint ec;\n\n\tec = HMAC_Update(ctx->ctx, data, data_len);\n\tif (ec != 1)\n\t\treturn dcrypt_openssl_error(error_r);\n\treturn TRUE;\n}\n\nstatic bool\ndcrypt_openssl_ctx_hmac_final(struct dcrypt_context_hmac *ctx, buffer_t *result,\n\t\t\t      const char **error_r)\n{\n\tint ec;\n\tunsigned char buf[HMAC_MAX_MD_CBLOCK];\n\tunsigned int outl;\n\n\tec = HMAC_Final(ctx->ctx, buf, &outl);\n\tHMAC_CTX_free(ctx->ctx);\n\tif (ec == 1)\n\t\tbuffer_append(result, buf, outl);\n\telse\n\t\treturn dcrypt_openssl_error(error_r);\n\treturn TRUE;\n}\n\nstatic bool\ndcrypt_openssl_generate_ec_key(int nid, EVP_PKEY **key, const char **error_r)\n{\n\tEVP_PKEY_CTX *pctx;\n\tEVP_PKEY_CTX *ctx;\n\tEVP_PKEY *params = NULL;\n\n\t/* generate parameters for EC */\n\tpctx = EVP_PKEY_CTX_new_id(EVP_PKEY_EC, NULL);\n\tif (pctx == NULL ||\n\t    EVP_PKEY_paramgen_init(pctx) < 1 ||\n\t    EVP_PKEY_CTX_set_ec_paramgen_curve_nid(pctx, nid) < 1 ||\n\t    EVP_PKEY_paramgen(pctx, &params) < 1)\n\t{\n\t\tdcrypt_openssl_error(error_r);\n\t\tEVP_PKEY_CTX_free(pctx);\n\t\treturn FALSE;\n\t}\n\n\t/* generate key from parameters */\n\tctx = EVP_PKEY_CTX_new(params, NULL);\n\tif (ctx == NULL ||\n\t    EVP_PKEY_keygen_init(ctx) < 1 ||\n\t    EVP_PKEY_keygen(ctx, key) < 1)\n\t{\n\t\tdcrypt_openssl_error(error_r);\n\t\tEVP_PKEY_free(params);\n\t\tEVP_PKEY_CTX_free(pctx);\n\t\tEVP_PKEY_CTX_free(ctx);\n\t\treturn FALSE;\n\t}\n\n\tEVP_PKEY_free(params);\n\tEVP_PKEY_CTX_free(pctx);\n\tEVP_PKEY_CTX_free(ctx);\n\tEC_KEY_set_asn1_flag(EVP_PKEY_get0_EC_KEY((*key)),\n\t\t\t     OPENSSL_EC_NAMED_CURVE);\n\treturn TRUE;\n}\n\nstatic bool\ndcrypt_openssl_generate_rsa_key(int bits, EVP_PKEY **key, const char **error_r)\n{\n\ti_assert(bits >= 256);\n\tint ec = 0;\n\n\tEVP_PKEY_CTX *ctx;\n\tctx = EVP_PKEY_CTX_new_id(EVP_PKEY_RSA, NULL);\n\tif (ctx == NULL ||\n\t    EVP_PKEY_keygen_init(ctx) < 1 ||\n\t    EVP_PKEY_CTX_set_rsa_keygen_bits(ctx, bits) < 1 ||\n\t    EVP_PKEY_keygen(ctx, key) < 1) {\n\t\tdcrypt_openssl_error(error_r);\n\t\tec = -1;\n\t}\n\n\tEVP_PKEY_CTX_free(ctx);\n\treturn ec == 0;\n}\n\nstatic bool\ndcrypt_openssl_ecdh_derive_secret(struct dcrypt_private_key *priv_key,\n\t\t\t\t  struct dcrypt_public_key *pub_key,\n\t\t\t\t  buffer_t *shared_secret,\n\t\t\t\t  const char **error_r)\n{\n\t/* initialize */\n\tEVP_PKEY_CTX *pctx = EVP_PKEY_CTX_new(priv_key->key, NULL);\n\tif (pctx == NULL ||\n\t    EVP_PKEY_derive_init(pctx) != 1 ||\n\t    EVP_PKEY_derive_set_peer(pctx, pub_key->key) != 1) {\n\t\tEVP_PKEY_CTX_free(pctx);\n\t\treturn dcrypt_openssl_error(error_r);\n\t}\n\n\t/* derive */\n\tsize_t len;\n\tif (EVP_PKEY_derive(pctx, NULL, &len) != 1) {\n\t\tEVP_PKEY_CTX_free(pctx);\n\t\treturn dcrypt_openssl_error(error_r);\n\t}\n\tunsigned char buf[len];\n\tif (EVP_PKEY_derive(pctx, buf, &len) != 1) {\n\t\tEVP_PKEY_CTX_free(pctx);\n\t\treturn dcrypt_openssl_error(error_r);\n\t}\n\n\tEVP_PKEY_CTX_free(pctx);\n\tbuffer_append(shared_secret, buf, len);\n\n\treturn TRUE;\n}\n\nstatic bool\ndcrypt_openssl_ecdh_derive_secret_local(struct dcrypt_private_key *local_key,\n\t\t\t\t\tbuffer_t *R, buffer_t *S,\n\t\t\t\t\tconst char **error_r)\n{\n\tbool ret;\n\ti_assert(local_key != NULL && local_key->key != NULL);\n\n\tEVP_PKEY *local = local_key->key;\n\tBN_CTX *bn_ctx = BN_CTX_new();\n\tif (bn_ctx == NULL)\n\t\treturn dcrypt_openssl_error(error_r);\n\n\tconst EC_GROUP *grp = EC_KEY_get0_group(EVP_PKEY_get0_EC_KEY(local));\n\tEC_POINT *pub = EC_POINT_new(grp);\n\n\t/* convert ephemeral key data EC point */\n\tif (pub == NULL ||\n\t    EC_POINT_oct2point(grp, pub, R->data, R->used, bn_ctx) != 1)\n\t{\n\t\tEC_POINT_free(pub);\n\t\tBN_CTX_free(bn_ctx);\n\t\treturn dcrypt_openssl_error(error_r);\n\t}\n\tEC_KEY *ec_key = EC_KEY_new();\n\n\t/* convert point to public key */\n\tint ec = 0;\n\tif (ec_key == NULL ||\n\t    EC_KEY_set_group(ec_key, grp) != 1 ||\n\t    EC_KEY_set_public_key(ec_key, pub) != 1)\n\t\tec = -1;\n\telse\n\tEC_POINT_free(pub);\n\tBN_CTX_free(bn_ctx);\n\n\t/* make sure it looks like a valid key */\n\tif (ec == -1 || EC_KEY_check_key(ec_key) != 1) {\n\t\tEC_KEY_free(ec_key);\n\t\treturn dcrypt_openssl_error(error_r);\n\t}\n\n\tEVP_PKEY *peer = EVP_PKEY_new();\n\tif (peer == NULL) {\n\t\tEC_KEY_free(ec_key);\n\t\treturn dcrypt_openssl_error(error_r);\n\t}\n\tEVP_PKEY_set1_EC_KEY(peer, ec_key);\n\tEC_KEY_free(ec_key);\n\n\tstruct dcrypt_public_key pub_key;\n\ti_zero(&pub_key);\n\tpub_key.key = peer;\n\n\tret = dcrypt_openssl_ecdh_derive_secret(local_key, &pub_key, S, error_r);\n\n\tEVP_PKEY_free(peer);\n\treturn ret;\n}\n\nstatic bool\ndcrypt_openssl_ecdh_derive_secret_peer(struct dcrypt_public_key *peer_key,\n\t\t\t\t       buffer_t *R, buffer_t *S,\n\t\t\t\t       const char **error_r)\n{\n\ti_assert(peer_key != NULL && peer_key->key != NULL);\n\tbool ret;\n\n\t/* ensure peer_key is EC key */\n\tEVP_PKEY *local = NULL;\n\tEVP_PKEY *peer = peer_key->key;\n\tif (EVP_PKEY_base_id(peer) != EVP_PKEY_EC) {\n\t\tDCRYPT_SET_ERROR(\"Only ECC key can be used\");\n\t\treturn FALSE;\n\t}\n\n\t/* generate another key from same group */\n\tint nid = EC_GROUP_get_curve_name(\n\t\tEC_KEY_get0_group(EVP_PKEY_get0_EC_KEY(peer)));\n\tif (!dcrypt_openssl_generate_ec_key(nid, &local, error_r))\n\t\treturn FALSE;\n\n\tstruct dcrypt_private_key priv_key;\n\ti_zero(&priv_key);\n\tpriv_key.key = local;\n\n\tif (!(ret = dcrypt_openssl_ecdh_derive_secret(&priv_key, peer_key, S,\n\t\t\t\t\t\t error_r))) {\n\t\tEVP_PKEY_free(local);\n\t\treturn FALSE;\n\t}\n\n\t/* get ephemeral key (=R) */\n\tBN_CTX *bn_ctx = BN_CTX_new();\n\tconst EC_POINT *pub = EC_KEY_get0_public_key(EVP_PKEY_get0_EC_KEY(local));\n\tconst EC_GROUP *grp = EC_KEY_get0_group(EVP_PKEY_get0_EC_KEY(local));\n\tsize_t len = EC_POINT_point2oct(grp, pub, POINT_CONVERSION_UNCOMPRESSED,\n\t\t\t\t\tNULL, 0, bn_ctx);\n\tunsigned char R_buf[len];\n\tEC_POINT_point2oct(grp, pub, POINT_CONVERSION_UNCOMPRESSED,\n\t\t\t   R_buf, len, bn_ctx);\n\tBN_CTX_free(bn_ctx);\n\tbuffer_append(R, R_buf, len);\n\tEVP_PKEY_free(local);\n\n\treturn ret;\n}\n\nstatic bool\ndcrypt_openssl_pbkdf2(const unsigned char *password, size_t password_len,\n\t\t      const unsigned char *salt, size_t salt_len,\n\t\t      const char *hash, unsigned int rounds,\n\t\t      buffer_t *result, unsigned int result_len,\n\t\t      const char **error_r)\n{\n\tint ret;\n\ti_assert(rounds > 0);\n\ti_assert(result_len > 0);\n\ti_assert(result != NULL);\n\t/* determine MD */\n\tconst EVP_MD* md = EVP_get_digestbyname(hash);\n\tif (md == NULL) {\n\t\tDCRYPT_SET_ERROR(t_strdup_printf(\"Invalid digest %s\", hash));\n\t\treturn FALSE;\n\t}\n\n\tunsigned char buffer[result_len];\n\tif ((ret = PKCS5_PBKDF2_HMAC((const char*)password, password_len,\n\t\t\t\t     salt, salt_len, rounds,\n\t\t\t\t     md, result_len, buffer)) == 1) {\n\t\tbuffer_append(result, buffer, result_len);\n\t}\n\tif (ret != 1)\n\t\treturn dcrypt_openssl_error(error_r);\n\treturn TRUE;\n}\n\nstatic bool\ndcrypt_openssl_generate_keypair(struct dcrypt_keypair *pair_r,\n\t\t\t\tenum dcrypt_key_type kind, unsigned int bits,\n\t\t\t\tconst char *curve, const char **error_r)\n{\n\tEVP_PKEY *pkey = NULL;\n\n\ti_assert(pair_r != NULL);\n\ti_zero(pair_r);\n\tif (kind == DCRYPT_KEY_RSA) {\n\t\tif (dcrypt_openssl_generate_rsa_key(bits, &pkey, error_r)) {\n\t\t\tpair_r->priv = i_new(struct dcrypt_private_key, 1);\n\t\t\tpair_r->priv->key = pkey;\n\t\t\tpair_r->priv->ref++;\n\t\t\tpair_r->pub = NULL;\n\t\t\tdcrypt_openssl_private_to_public_key(pair_r->priv,\n\t\t\t\t\t\t\t     &pair_r->pub);\n\t\t\treturn TRUE;\n\t\t} else {\n\t\t\treturn dcrypt_openssl_error(error_r);\n\t\t}\n\t} else if (kind == DCRYPT_KEY_EC) {\n\t\tint nid = OBJ_sn2nid(curve);\n\t\tif (nid == NID_undef) {\n\t\t\tDCRYPT_SET_ERROR(t_strdup_printf(\"Unknown EC curve %s\",\n\t\t\t\t\t\t\t curve));\n\t\t\treturn FALSE;\n\t\t}\n\t\tif (dcrypt_openssl_generate_ec_key(nid, &pkey, error_r)) {\n\t\t\tpair_r->priv = i_new(struct dcrypt_private_key, 1);\n\t\t\tpair_r->priv->key = pkey;\n\t\t\tpair_r->priv->ref++;\n\t\t\tpair_r->pub = NULL;\n\t\t\tdcrypt_openssl_private_to_public_key(pair_r->priv,\n\t\t\t\t\t\t\t     &pair_r->pub);\n\t\t\treturn TRUE;\n\t\t} else {\n\t\t\treturn dcrypt_openssl_error(error_r);\n\t\t}\n\t}\n\tDCRYPT_SET_ERROR(\"Key type not supported in this build\");\n\treturn FALSE;\n}\n\nstatic bool\ndcrypt_openssl_decrypt_point_v1(buffer_t *data, buffer_t *key, BIGNUM **point_r,\n\t\t\t\tconst char **error_r)\n{\n\tstruct dcrypt_context_symmetric *dctx;\n\tbuffer_t *tmp = t_buffer_create(64);\n\n\tif (!dcrypt_openssl_ctx_sym_create(\"aes-256-ctr\", DCRYPT_MODE_DECRYPT,\n\t\t\t\t\t   &dctx, error_r)) {\n\t\treturn FALSE;\n\t}\n\n\t/* v1 KEYS have all-zero IV - have to use it ourselves too */\n\tdcrypt_openssl_ctx_sym_set_iv(dctx, (const unsigned char*)\n\t\t\"\\x0\\x0\\x0\\x0\\x0\\x0\\x0\\x0\\x0\\x0\\x0\\x0\\x0\\x0\\x0\\x0\", 16);\n\tdcrypt_openssl_ctx_sym_set_key(dctx, key->data, key->used);\n\n\tif (!dcrypt_openssl_ctx_sym_init(dctx, error_r) ||\n\t    !dcrypt_openssl_ctx_sym_update(dctx, data->data, data->used,\n\t\t\t\t\t   tmp, error_r) ||\n\t    !dcrypt_openssl_ctx_sym_final(dctx, tmp, error_r)) {\n\t\tdcrypt_openssl_ctx_sym_destroy(&dctx);\n\t\treturn FALSE;\n\t}\n\n\tdcrypt_openssl_ctx_sym_destroy(&dctx);\n\n\t*point_r = BN_bin2bn(tmp->data, tmp->used, NULL);\n\tsafe_memset(buffer_get_modifiable_data(tmp, NULL), 0,tmp->used);\n\tbuffer_set_used_size(key, 0);\n\n\tif (*point_r == NULL)\n\t\treturn dcrypt_openssl_error(error_r);\n\treturn TRUE;\n}\n\nstatic bool\ndcrypt_openssl_decrypt_point_ec_v1(struct dcrypt_private_key *dec_key,\n\t\t\t\t   const char *data_hex,\n\t\t\t\t   const char *peer_key_hex, BIGNUM **point_r,\n\t\t\t\t   const char **error_r)\n{\n\tbuffer_t *peer_key, *data, key, *secret;\n\tbool res;\n\n\tdata = t_buffer_create(128);\n\tpeer_key = t_buffer_create(64);\n\n\thex_to_binary(data_hex, data);\n\thex_to_binary(peer_key_hex, peer_key);\n\n\tsecret = t_buffer_create(64);\n\n\tif (!dcrypt_openssl_ecdh_derive_secret_local(dec_key, peer_key,\n\t\t\t\t\t\t     secret, error_r))\n\t\treturn FALSE;\n\n\t/* run it thru SHA256 once */\n\tunsigned char digest[SHA256_DIGEST_LENGTH];\n\tSHA256(secret->data, secret->used, digest);\n\tsafe_memset(buffer_get_modifiable_data(secret, NULL), 0, secret->used);\n\tbuffer_set_used_size(secret, 0);\n\tbuffer_create_from_const_data(&key, digest, SHA256_DIGEST_LENGTH);\n\n\t/* then use this as key */\n\tres = dcrypt_openssl_decrypt_point_v1(data, &key, point_r, error_r);\n\tmemset(digest, 0, sizeof(digest));\n\tsafe_memset(digest, 0, SHA256_DIGEST_LENGTH);\n\n\treturn res;\n}\n\nstatic bool\ndcrypt_openssl_decrypt_point_password_v1(const char *data_hex,\n\t\t\t\t\t const char *password_hex,\n\t\t\t\t\t const char *salt_hex, BIGNUM **point_r,\n\t\t\t\t\t const char **error_r)\n{\n\tbuffer_t *salt, *data, *password, *key;\n\tstruct dcrypt_context_symmetric *dctx;\n\n\tdata = t_buffer_create(128);\n\tsalt = t_buffer_create(16);\n\tpassword = t_buffer_create(32);\n\tkey = t_buffer_create(32);\n\n\thex_to_binary(data_hex, data);\n\thex_to_binary(salt_hex, salt);\n\thex_to_binary(password_hex, password);\n\n\t/* aes-256-ctr uses 32 byte key, and v1 uses all-zero IV */\n\tif (!dcrypt_openssl_pbkdf2(password->data, password->used,\n\t\t\t\t   salt->data, salt->used,\n\t\t\t\t   \"sha256\", 16, key, 32, error_r)) {\n\t\tdcrypt_ctx_sym_destroy(&dctx);\n\t\treturn FALSE;\n\t}\n\n\treturn dcrypt_openssl_decrypt_point_v1(data, key, point_r, error_r);\n}\n\nstatic bool\ndcrypt_openssl_load_private_key_dovecot_v1(struct dcrypt_private_key **key_r,\n\t\t\t\t\t   int len, const char **input,\n\t\t\t\t\t   const char *password,\n\t\t\t\t\t   struct dcrypt_private_key *dec_key,\n\t\t\t\t\t   const char **error_r)\n{\n\tint nid, ec, enctype;\n\tBIGNUM *point = NULL;\n\n\tif (str_to_int(input[1], &nid) != 0) {\n\t\tDCRYPT_SET_ERROR(\"Corrupted data\");\n\t\treturn FALSE;\n\t}\n\n\tif (str_to_int(input[2], &enctype) != 0) {\n\t\tDCRYPT_SET_ERROR(\"Corrupted data\");\n\t\treturn FALSE;\n\t}\n\n\t/* decode and optionally decipher private key value */\n\tif (enctype == DCRYPT_DOVECOT_KEY_ENCRYPT_NONE) {\n\t\tpoint = BN_secure_new();\n\t\tif (point == NULL || BN_hex2bn(&point, input[3]) < 1) {\n\t\t\tBN_free(point);\n\t\t\treturn dcrypt_openssl_error(error_r);\n\t\t}\n\t} else if (enctype == DCRYPT_DOVECOT_KEY_ENCRYPT_PASSWORD) {\n\t\t/* by password */\n\t\tif (password == NULL) {\n\t\t\tDCRYPT_SET_ERROR(\"password missing\");\n\t\t\treturn FALSE;\n\t\t}\n\t\tconst char *enc_priv_pt = input[3];\n\t\tconst char *salt = input[4];\n\t\tif (!dcrypt_openssl_decrypt_point_password_v1(\n\t\t\tenc_priv_pt, password, salt, &point, error_r)) {\n\t\t\treturn FALSE;\n\t\t}\n\t} else if (enctype == DCRYPT_DOVECOT_KEY_ENCRYPT_PK) {\n\t\t/* by key */\n\t\tif (dec_key == NULL) {\n\t\t\tDCRYPT_SET_ERROR(\"decrypt key missing\");\n\t\t\treturn FALSE;\n\t\t}\n\t\tconst char *enc_priv_pt = input[3];\n\t\tconst char *peer_key = input[4];\n\t\tif (!dcrypt_openssl_decrypt_point_ec_v1(\n\t\t\tdec_key, enc_priv_pt, peer_key, &point, error_r)) {\n\t\t\treturn FALSE;\n\t\t}\n\t} else {\n\t\tDCRYPT_SET_ERROR(\"Invalid key data\");\n\t\treturn FALSE;\n\t}\n\n\tEC_KEY *eckey = EC_KEY_new_by_curve_name(nid);\n\tif (eckey == NULL) return dcrypt_openssl_error(error_r);\n\n\t/* assign private key */\n\tBN_CTX *bnctx = BN_CTX_new();\n\tif (bnctx == NULL) {\n\t\tEC_KEY_free(eckey);\n\t\treturn dcrypt_openssl_error(error_r);\n\t}\n\tEC_KEY_set_private_key(eckey, point);\n\tEC_KEY_precompute_mult(eckey, bnctx);\n\tEC_KEY_set_asn1_flag(eckey, OPENSSL_EC_NAMED_CURVE);\n\tEC_POINT *pub = EC_POINT_new(EC_KEY_get0_group(eckey));\n\tif (pub == NULL) {\n\t\tEC_KEY_free(eckey);\n\t\tBN_CTX_free(bnctx);\n\t\treturn dcrypt_openssl_error(error_r);\n\t}\n\t/* calculate public key */\n\tec = EC_POINT_mul(EC_KEY_get0_group(eckey), pub, point,\n\t\t\t  NULL, NULL, bnctx);\n\tEC_KEY_set_public_key(eckey, pub);\n\tBN_free(point);\n\tEC_POINT_free(pub);\n\tBN_CTX_free(bnctx);\n\n\t/* make sure it looks OK and is correct */\n\tif (ec == 1 && EC_KEY_check_key(eckey) == 1) {\n\t\tunsigned char digest[SHA256_DIGEST_LENGTH];\n\t\t/* validate that the key was loaded correctly */\n\t\tchar *id = ec_key_get_pub_point_hex(eckey);\n\t\tif (id == NULL) {\n\t\t\tEC_KEY_free(eckey);\n\t\t\treturn dcrypt_openssl_error(error_r);\n\t\t}\n\t\tSHA256((unsigned char*)id, strlen(id), digest);\n\t\tOPENSSL_free(id);\n\t\tconst char *digest_hex =\n\t\t\tbinary_to_hex(digest, SHA256_DIGEST_LENGTH);\n\t\tif (strcmp(digest_hex, input[len-1]) != 0) {\n\t\t\tDCRYPT_SET_ERROR(\"Key id mismatch after load\");\n\t\t\tEC_KEY_free(eckey);\n\t\t\treturn FALSE;\n\t\t}\n\t\tEVP_PKEY *key = EVP_PKEY_new();\n\t\tif (key == NULL) {\n\t\t\tEC_KEY_free(eckey);\n\t\t\treturn dcrypt_openssl_error(error_r);\n\t\t}\n\t\tEVP_PKEY_set1_EC_KEY(key, eckey);\n\t\tEC_KEY_free(eckey);\n\t\t*key_r = i_new(struct dcrypt_private_key, 1);\n\t\t(*key_r)->key = key;\n\t\t(*key_r)->ref++;\n\t\treturn TRUE;\n\t}\n\n\tEC_KEY_free(eckey);\n\n\treturn dcrypt_openssl_error(error_r);\n}\n\n/* encrypt/decrypt private keys */\nstatic bool\ndcrypt_openssl_cipher_key_dovecot_v2(const char *cipher,\n\t\t\t\t     enum dcrypt_sym_mode mode,\n\t\t\t\t     buffer_t *input, buffer_t *secret,\n\t\t\t\t     buffer_t *salt, const char *digalgo,\n\t\t\t\t     unsigned int rounds, buffer_t *result_r,\n\t\t\t\t     const char **error_r)\n{\n\tstruct dcrypt_context_symmetric *dctx;\n\tbool res;\n\n\tif (!dcrypt_openssl_ctx_sym_create(cipher, mode, &dctx, error_r)) {\n\t\treturn FALSE;\n\t}\n\n\t/* generate encryption key/iv based on secret/salt */\n\tbuffer_t *key_data = t_buffer_create(128);\n\tres = dcrypt_openssl_pbkdf2(secret->data, secret->used,\n\t\tsalt->data, salt->used, digalgo, rounds, key_data,\n\t\tdcrypt_openssl_ctx_sym_get_key_length(dctx) +\n\t\t\tdcrypt_openssl_ctx_sym_get_iv_length(dctx),\n\t\terror_r);\n\n\tif (!res) {\n\t\tdcrypt_openssl_ctx_sym_destroy(&dctx);\n\t\treturn FALSE;\n\t}\n\n\tbuffer_t *tmp = t_buffer_create(128);\n\tconst unsigned char *kd = buffer_free_without_data(&key_data);\n\n\t/* perform ciphering */\n\tdcrypt_openssl_ctx_sym_set_key(dctx, kd,\n\t\tdcrypt_openssl_ctx_sym_get_key_length(dctx));\n\tdcrypt_openssl_ctx_sym_set_iv(dctx,\n\t\tkd + dcrypt_openssl_ctx_sym_get_key_length(dctx),\n\t\tdcrypt_openssl_ctx_sym_get_iv_length(dctx));\n\n\tif (!dcrypt_openssl_ctx_sym_init(dctx, error_r) ||\n\t    !dcrypt_openssl_ctx_sym_update(dctx, input->data,\n\t\t\t\t\t   input->used, tmp, error_r) ||\n\t    !dcrypt_openssl_ctx_sym_final(dctx, tmp, error_r)) {\n\t\tres = FALSE;\n\t} else {\n\t\t/* provide result if succeeded */\n\t\tbuffer_append_buf(result_r, tmp, 0, (size_t)-1);\n\t\tres = TRUE;\n\t}\n\t/* and ensure no data leaks */\n\tsafe_memset(buffer_get_modifiable_data(tmp, NULL), 0, tmp->used);\n\n\tdcrypt_openssl_ctx_sym_destroy(&dctx);\n\treturn res;\n}\n\nstatic bool\ndcrypt_openssl_load_private_key_dovecot_v2(struct dcrypt_private_key **key_r,\n\t\t\t\t\t   int len, const char **input,\n\t\t\t\t\t   const char *password,\n\t\t\t\t\t   struct dcrypt_private_key *dec_key,\n\t\t\t\t\t   const char **error_r)\n{\n\tint enctype;\n\tbuffer_t *key_data = t_buffer_create(256);\n\n\t/* check for encryption type */\n\tif (str_to_int(input[2], &enctype) != 0) {\n\t\tDCRYPT_SET_ERROR(\"Corrupted data\");\n\t\treturn FALSE;\n\t}\n\n\tif (enctype < 0 || enctype > 2) {\n\t\tDCRYPT_SET_ERROR(\"Corrupted data\");\n\t\treturn FALSE;\n\t}\n\n\t/* match encryption type to field counts */\n\tif ((enctype == DCRYPT_DOVECOT_KEY_ENCRYPT_NONE && len != 5) ||\n\t    (enctype == DCRYPT_DOVECOT_KEY_ENCRYPT_PASSWORD && len != 9) ||\n \t    (enctype == DCRYPT_DOVECOT_KEY_ENCRYPT_PK && len != 11)) {\n\t\tDCRYPT_SET_ERROR(\"Corrupted data\");\n\t\treturn FALSE;\n\t}\n\n\t/* get key type */\n\tint nid = OBJ_txt2nid(input[1]);\n\n\tif (nid == NID_undef)\n\t\treturn dcrypt_openssl_error(error_r);\n\n\t/* decode and possibly decipher private key value */\n\tif (enctype == DCRYPT_DOVECOT_KEY_ENCRYPT_NONE) {\n\t\tif (hex_to_binary(input[3], key_data) != 0) {\n\t\t\tDCRYPT_SET_ERROR(\"Corrupted data\");\n\t\t}\n\t} else if (enctype == DCRYPT_DOVECOT_KEY_ENCRYPT_PK) {\n\t\tif (dec_key == NULL) {\n\t\t\tDCRYPT_SET_ERROR(\"decrypt key missing\");\n\t\t\treturn FALSE;\n\t\t}\n\t\tunsigned int rounds;\n\t\tstruct dcrypt_public_key *pubkey = NULL;\n\t\tif (str_to_uint(input[6], &rounds) != 0) {\n\t\t\tDCRYPT_SET_ERROR(\"Corrupted data\");\n\t\t\treturn FALSE;\n\t\t}\n\n\t\tbuffer_t *data = t_buffer_create(128);\n\n\t\t/* check that we have correct decryption key */\n\t\tdcrypt_openssl_private_to_public_key(dec_key, &pubkey);\n\t\tif (!dcrypt_openssl_public_key_id(pubkey, \"sha256\",\n\t\t\t\t\t\t  data, error_r)) {\n\t\t\tdcrypt_openssl_unref_public_key(&pubkey);\n\t\t\treturn FALSE;\n\t\t}\n\n\t\tdcrypt_openssl_unref_public_key(&pubkey);\n\n\t\tif (strcmp(binary_to_hex(data->data, data->used),\n\t\t\t   input[9]) != 0) {\n\t\t\tDCRYPT_SET_ERROR(\"No private key available\");\n\t\t\treturn FALSE;\n\t\t}\n\n\n\t\tbuffer_t *salt, *peer_key, *secret;\n\t\tsalt = t_buffer_create(strlen(input[4])/2);\n\t\tpeer_key = t_buffer_create(strlen(input[8])/2);\n\t\tsecret = t_buffer_create(128);\n\n\t\tbuffer_set_used_size(data, 0);\n\t\thex_to_binary(input[4], salt);\n\t\thex_to_binary(input[8], peer_key);\n\t\thex_to_binary(input[7], data);\n\n\t\t/* get us secret value to use for key/iv generation */\n\t\tif (EVP_PKEY_base_id((EVP_PKEY*)dec_key) == EVP_PKEY_RSA) {\n\t\t\tif (!dcrypt_openssl_rsa_decrypt(dec_key,\n\t\t\t\tpeer_key->data, peer_key->used, secret,\n\t\t\t\tDCRYPT_PADDING_RSA_PKCS1_OAEP, error_r))\n\t\t\t\treturn FALSE;\n\t\t} else {\n\t\t\t/* perform ECDH */\n\t\t\tif (!dcrypt_openssl_ecdh_derive_secret_local(\n\t\t\t\tdec_key, peer_key, secret, error_r))\n\t\t\t\treturn FALSE;\n\t\t}\n\t\t/* decrypt key */\n\t\tif (!dcrypt_openssl_cipher_key_dovecot_v2(input[3],\n\t\t\tDCRYPT_MODE_DECRYPT, data, secret, salt,\n\t\t\tinput[5], rounds, key_data, error_r)) {\n\t\t\treturn FALSE;\n\t\t}\n\t} else if (enctype == DCRYPT_DOVECOT_KEY_ENCRYPT_PASSWORD) {\n\t\tif (password == NULL) {\n\t\t\tDCRYPT_SET_ERROR(\"password missing\");\n\t\t\treturn FALSE;\n\t\t}\n\t\tunsigned int rounds;\n\t\tif (str_to_uint(input[6], &rounds) != 0) {\n\t\t\tDCRYPT_SET_ERROR(\"Corrupted data\");\n\t\t\treturn FALSE;\n\t\t}\n\n\t\tbuffer_t *salt, secret, *data;\n\t\tsalt = t_buffer_create(strlen(input[4])/2);\n\t\tbuffer_create_from_const_data(&secret, password, strlen(password));\n\t\tdata = t_buffer_create(strlen(input[7])/2);\n\t\tif (hex_to_binary(input[4], salt) != 0 ||\n\t\t    hex_to_binary(input[7], data) != 0) {\n\t\t\tDCRYPT_SET_ERROR(\"Corrupted data\");\n\t\t\treturn FALSE;\n\t\t}\n\n\t\tif (!dcrypt_openssl_cipher_key_dovecot_v2(input[3],\n\t\t\tDCRYPT_MODE_DECRYPT, data, &secret, salt,\n\t\t\tinput[5], rounds, key_data, error_r)) {\n\t\t\treturn FALSE;\n\t\t}\n\t}\n\n\t/* decode actual key */\n\tif (EVP_PKEY_type(nid) == EVP_PKEY_RSA) {\n\t\tRSA *rsa = RSA_new();\n\t\tconst unsigned char *ptr = buffer_get_data(key_data, NULL);\n\t\tif (rsa == NULL ||\n\t\t    d2i_RSAPrivateKey(&rsa, &ptr, key_data->used) == NULL ||\n\t\t    RSA_check_key(rsa) != 1) {\n\t\t\tsafe_memset(buffer_get_modifiable_data(key_data, NULL),\n\t\t\t\t    0, key_data->used);\n\t\t\tRSA_free(rsa);\n\t\t\treturn dcrypt_openssl_error(error_r);\n\t\t}\n\t\tsafe_memset(buffer_get_modifiable_data(key_data, NULL),\n\t\t\t    0, key_data->used);\n\t\tbuffer_set_used_size(key_data, 0);\n\t\tEVP_PKEY *pkey = EVP_PKEY_new();\n\t\tif (pkey == NULL) {\n\t\t\tRSA_free(rsa);\n\t\t\treturn dcrypt_openssl_error(error_r);\n\t\t}\n\t\tEVP_PKEY_set1_RSA(pkey, rsa);\n\t\tRSA_free(rsa);\n\t\t*key_r = i_new(struct dcrypt_private_key, 1);\n\t\t(*key_r)->key = pkey;\n\t\t(*key_r)->ref++;\n\t} else {\n\t\tint ec;\n\t\tBIGNUM *point = BN_secure_new();\n\t\tif (point == NULL ||\n\t\t    BN_mpi2bn(key_data->data, key_data->used, point) == NULL) {\n\t\t\tsafe_memset(buffer_get_modifiable_data(key_data, NULL),\n\t\t\t\t    0, key_data->used);\n\t\t\tBN_free(point);\n\t\t\treturn dcrypt_openssl_error(error_r);\n\t\t}\n\t\tEC_KEY *eckey = EC_KEY_new_by_curve_name(nid);\n\t\tsafe_memset(buffer_get_modifiable_data(key_data, NULL),\n\t\t\t    0, key_data->used);\n\t\tbuffer_set_used_size(key_data, 0);\n\t\tBN_CTX *bnctx = BN_CTX_new();\n\t\tif (eckey == NULL || bnctx == NULL) {\n\t\t\tBN_free(point);\n\t\t\tEC_KEY_free(eckey);\n\t\t\tBN_CTX_free(bnctx);\n\t\t\treturn dcrypt_openssl_error(error_r);\n\t\t}\n\t\tEC_KEY_set_private_key(eckey, point);\n\t\tEC_KEY_precompute_mult(eckey, bnctx);\n\t\tEC_KEY_set_asn1_flag(eckey, OPENSSL_EC_NAMED_CURVE);\n\t\tEC_POINT *pub = EC_POINT_new(EC_KEY_get0_group(eckey));\n\t\tif (pub == NULL)\n\t\t\tec = -1;\n\t\telse {\n\t\t\t/* calculate public key */\n\t\t\tec = EC_POINT_mul(EC_KEY_get0_group(eckey), pub, point,\n\t\t\t\t\t  NULL, NULL, bnctx);\n\t\t\tEC_KEY_set_public_key(eckey, pub);\n\t\t\tEC_POINT_free(pub);\n\t\t}\n\t\tBN_free(point);\n\t\tBN_CTX_free(bnctx);\n\t\t/* make sure the EC key is valid */\n\t\tEVP_PKEY *key = EVP_PKEY_new();\n\t\tif (ec == 1 && key != NULL && EC_KEY_check_key(eckey) == 1) {\n\t\t\tEVP_PKEY_set1_EC_KEY(key, eckey);\n\t\t\tEC_KEY_free(eckey);\n\t\t\t*key_r = i_new(struct dcrypt_private_key, 1);\n\t\t\t(*key_r)->key = key;\n\t\t\t(*key_r)->ref++;\n\t\t} else {\n\t\t\tEVP_PKEY_free(key);\n\t\t\tEC_KEY_free(eckey);\n\t\t\treturn dcrypt_openssl_error(error_r);\n\t\t}\n\t}\n\n\t/* finally compare key to key id */\n\tdcrypt_openssl_private_key_id(*key_r, \"sha256\", key_data, NULL);\n\n\tif (strcmp(binary_to_hex(key_data->data, key_data->used),\n\t\t   input[len-1]) != 0) {\n\t\tdcrypt_openssl_unref_private_key(key_r);\n\t\tDCRYPT_SET_ERROR(\"Key id mismatch after load\");\n\t\treturn FALSE;\n\t}\n\n\treturn TRUE;\n}\n\n/* JWK Parameter names defined at https://www.iana.org/assignments/jose/jose.xhtml\u00a0*/\n\nstatic const struct jwk_to_ssl_map_entry {\n\tconst char *jwk_curve;\n\tint nid;\n} jwk_to_ssl_curves[] =\n{\n\t/* See https://tools.ietf.org/search/rfc8422#appendix-A */\n\t{ .jwk_curve = \"P-256\", .nid = NID_X9_62_prime256v1 },\n\t{ .jwk_curve = \"P-384\", .nid = NID_secp384r1 },\n\t{ .jwk_curve = \"P-521\", .nid = NID_secp521r1 },\n\t{ .jwk_curve = NULL, .nid = 0 }\n};\n\nstatic const char *key_usage_to_jwk_use(enum dcrypt_key_usage usage)\n{\n\tswitch(usage) {\n\tcase DCRYPT_KEY_USAGE_NONE:\n\t\treturn NULL;\n\tcase DCRYPT_KEY_USAGE_ENCRYPT:\n\t\treturn \"enc\";\n\tcase DCRYPT_KEY_USAGE_SIGN:\n\t\treturn \"sig\";\n\t};\n\ti_unreached();\n}\n\nstatic enum dcrypt_key_usage jwk_use_to_key_usage(const char *use)\n{\n\tif (strcmp(use, \"enc\") == 0)\n\t\treturn DCRYPT_KEY_USAGE_ENCRYPT;\n\tif (strcmp(use, \"sig\") == 0)\n\t\treturn DCRYPT_KEY_USAGE_SIGN;\n\treturn DCRYPT_KEY_USAGE_NONE;\n}\n\nstatic int jwk_curve_to_nid(const char *curve)\n{\n\t/* use static mapping table to get correct input for OpenSSL */\n\tconst struct jwk_to_ssl_map_entry *entry = jwk_to_ssl_curves;\n\tfor (;entry->jwk_curve != NULL;entry++)\n\t\tif (strcmp(curve, entry->jwk_curve) == 0)\n\t\t\treturn entry->nid;\n\treturn 0;\n}\n\nstatic const char *nid_to_jwk_curve(int nid)\n{\n\tconst struct jwk_to_ssl_map_entry *entry = jwk_to_ssl_curves;\n\tfor (;entry->jwk_curve != NULL;entry++)\n\t\tif (nid == entry->nid)\n\t\t\treturn entry->jwk_curve;\n\treturn NULL;\n}\n\n/* Loads both public and private key */\nstatic bool load_jwk_ec_key(EVP_PKEY **key_r, bool want_private_key,\n\t\t\t    const struct json_tree_node *root,\n\t\t\t    const char *password ATTR_UNUSED,\n\t\t\t    struct dcrypt_private_key *dec_key ATTR_UNUSED,\n\t\t\t    const char **error_r)\n{\n\ti_assert(password == NULL && dec_key == NULL);\n\tconst char *crv, *x, *y, *d;\n\tconst struct json_tree_node *node;\n\n\tif ((node = json_tree_find_key(root, \"crv\")) == NULL ||\n\t    (crv = json_tree_get_value_str(node)) == NULL) {\n\t\tDCRYPT_SET_ERROR(\"Missing crv parameter\");\n\t\treturn FALSE;\n\t}\n\n\tif ((node = json_tree_find_key(root, \"x\")) == NULL ||\n\t    (x = json_tree_get_value_str(node)) == NULL) {\n\t\tDCRYPT_SET_ERROR(\"Missing x parameter\");\n\t\treturn FALSE;\n\t}\n\n\tif ((node = json_tree_find_key(root, \"y\")) == NULL ||\n\t    (y = json_tree_get_value_str(node)) == NULL) {\n\t\tDCRYPT_SET_ERROR(\"Missing y parameter\");\n\t\treturn FALSE;\n\t}\n\n\tif ((node = json_tree_find_key(root, \"d\")) == NULL ||\n\t    (d = json_tree_get_value_str(node)) == NULL) {\n\t\tif (want_private_key) {\n\t\t\tDCRYPT_SET_ERROR(\"Missing d parameter\");\n\t\t\treturn FALSE;\n\t\t}\n\t}\n\n\t/* base64 decode x and y */\n\tbuffer_t *bx = t_base64url_decode_str(x);\n\tbuffer_t *by = t_base64url_decode_str(y);\n\n\t/* determine NID */\n\tint nid = jwk_curve_to_nid(crv);\n\tif (nid == 0) {\n\t\tDCRYPT_SET_ERROR(t_strdup_printf(\"Unsupported curve: %s\", crv));\n\t\treturn FALSE;\n\t}\n\t/* create key */\n\tEC_KEY *ec_key = EC_KEY_new_by_curve_name(nid);\n\tif (ec_key == NULL) {\n\t\tDCRYPT_SET_ERROR(\"Cannot allocate memory\");\n\t\treturn FALSE;\n\t}\n\n\tBIGNUM *px = BN_new();\n\tBIGNUM *py = BN_new();\n\n\tif (BN_bin2bn(bx->data, bx->used, px) == NULL ||\n\t    BN_bin2bn(by->data, by->used, py) == NULL) {\n\t\tEC_KEY_free(ec_key);\n\t\tBN_free(px);\n\t\tBN_free(py);\n\t\treturn dcrypt_openssl_error(error_r);\n\t}\n\n\tint ret = EC_KEY_set_public_key_affine_coordinates(ec_key, px, py);\n\tBN_free(px);\n\tBN_free(py);\n\n\tif (ret != 1) {\n\t\tEC_KEY_free(ec_key);\n\t\treturn dcrypt_openssl_error(error_r);\n\t}\n\n\t/* FIXME: Support decryption */\n\tif (want_private_key) {\n\t\tbuffer_t *bd = t_base64url_decode_str(d);\n\t\tBIGNUM *pd = BN_secure_new();\n\t\tif (BN_bin2bn(bd->data, bd->used, pd) == NULL) {\n\t\t\tEC_KEY_free(ec_key);\n\t\t\treturn dcrypt_openssl_error(error_r);\n\t\t}\n\t\tret = EC_KEY_set_private_key(ec_key, pd);\n\t\tBN_free(pd);\n\t\tif (ret != 1) {\n\t\t\tEC_KEY_free(ec_key);\n\t\t\treturn dcrypt_openssl_error(error_r);\n\t\t}\n\t}\n\n\tif (EC_KEY_check_key(ec_key) != 1) {\n\t\tEC_KEY_free(ec_key);\n\t\treturn dcrypt_openssl_error(error_r);\n\t}\n\n\tEC_KEY_precompute_mult(ec_key, NULL);\n\tEC_KEY_set_asn1_flag(ec_key, OPENSSL_EC_NAMED_CURVE);\n\n\t/* return as EVP_PKEY */\n\tEVP_PKEY *pkey = EVP_PKEY_new();\n\tEVP_PKEY_set1_EC_KEY(pkey, ec_key);\n\tEC_KEY_free(ec_key);\n\t*key_r = pkey;\n\n\treturn TRUE;\n}\n\n/* RSA helpers */\n#if !defined(HAVE_RSA_SET0_KEY)\nstatic int RSA_set0_key(RSA *r, BIGNUM *n, BIGNUM *e, BIGNUM *d)\n{\n\tif (n == NULL || e == NULL) {\n\t\tRSAerr(0, ERR_R_PASSED_NULL_PARAMETER);\n\t\treturn 0;\n\t}\n\tBN_free(r->n);\n\tr->n = n;\n\tBN_free(r->e);\n\tr->e = e;\n\tBN_free(r->d);\n\tr->d = d;\n\treturn 1;\n}\n#endif\n#if !defined(HAVE_RSA_SET0_FACTORS)\nstatic int RSA_set0_factors(RSA *r, BIGNUM *p, BIGNUM *q)\n{\n\tif (p == NULL || q == NULL) {\n\t\tRSAerr(0, ERR_R_PASSED_NULL_PARAMETER);\n\t\treturn 0;\n\t}\n\tBN_free(r->p);\n\tr->p = p;\n\tBN_free(r->q);\n\tr->q = q;\n\treturn 1;\n}\n#endif\n#if !defined(HAVE_RSA_SET0_CRT_PARAMS)\nstatic int RSA_set0_crt_params(RSA *r, BIGNUM *dmp1, BIGNUM *dmq1, BIGNUM *iqmp)\n{\n\tif (dmp1 == NULL || dmq1 == NULL || iqmp == NULL) {\n\t\tRSAerr(0, ERR_R_PASSED_NULL_PARAMETER);\n\t\treturn 0;\n\t}\n\tBN_free(r->dmp1);\n\tr->dmp1 = dmp1;\n\tBN_free(r->dmq1);\n\tr->dmq1 = dmq1;\n\tBN_free(r->iqmp);\n\tr->iqmp = iqmp;\n\treturn 1;\n}\n#endif\n\n/* Loads both public and private key */\nstatic bool load_jwk_rsa_key(EVP_PKEY **key_r, bool want_private_key,\n\t\t\t     const struct json_tree_node *root,\n\t\t\t     const char *password ATTR_UNUSED,\n\t\t\t     struct dcrypt_private_key *dec_key ATTR_UNUSED,\n\t\t\t     const char **error_r)\n{\n\tconst char *n, *e, *d = NULL, *p = NULL, *q = NULL, *dp = NULL;\n\tconst char *dq = NULL, *qi = NULL;\n\tconst struct json_tree_node *node;\n\n\t/* n and e must be present */\n\tif ((node = json_tree_find_key(root, \"n\")) == NULL ||\n\t    (n = json_tree_get_value_str(node)) == NULL) {\n\t\tDCRYPT_SET_ERROR(\"Missing n parameter\");\n\t\treturn FALSE;\n\t}\n\n\tif ((node = json_tree_find_key(root, \"e\")) == NULL ||\n\t    (e = json_tree_get_value_str(node)) == NULL) {\n\t\tDCRYPT_SET_ERROR(\"Missing e parameter\");\n\t\treturn FALSE;\n\t}\n\n\tif (want_private_key) {\n\t\tif ((node = json_tree_find_key(root, \"d\")) == NULL ||\n\t\t    (d = json_tree_get_value_str(node)) == NULL) {\n\t\t\tDCRYPT_SET_ERROR(\"Missing d parameter\");\n\t\t\treturn FALSE;\n\t\t}\n\n\t\tif ((node = json_tree_find_key(root, \"p\")) == NULL ||\n\t\t    (p = json_tree_get_value_str(node)) == NULL) {\n\t\t\tDCRYPT_SET_ERROR(\"Missing p parameter\");\n\t\t\treturn FALSE;\n\t\t}\n\n\t\tif ((node = json_tree_find_key(root, \"q\")) == NULL ||\n\t\t    (q = json_tree_get_value_str(node)) == NULL) {\n\t\t\tDCRYPT_SET_ERROR(\"Missing q parameter\");\n\t\t\treturn FALSE;\n\t\t}\n\n\t\tif ((node = json_tree_find_key(root, \"dp\")) == NULL ||\n\t\t    (dp = json_tree_get_value_str(node)) == NULL) {\n\t\t\tDCRYPT_SET_ERROR(\"Missing dp parameter\");\n\t\t\treturn FALSE;\n\t\t}\n\n\t\tif ((node = json_tree_find_key(root, \"dq\")) == NULL ||\n\t\t    (dq = json_tree_get_value_str(node)) == NULL) {\n\t\t\tDCRYPT_SET_ERROR(\"Missing dq parameter\");\n\t\t\treturn FALSE;\n\t\t}\n\n\t\tif ((node = json_tree_find_key(root, \"qi\")) == NULL ||\n\t\t    (qi = json_tree_get_value_str(node)) == NULL) {\n\t\t\tDCRYPT_SET_ERROR(\"Missing qi parameter\");\n\t\t\treturn FALSE;\n\t\t}\n\t}\n\n\t/* convert into BIGNUMs */\n\tBIGNUM *pn, *pe, *pd, *pp, *pq, *pdp, *pdq, *pqi;\n\tbuffer_t *bn = t_base64url_decode_str(n);\n\tbuffer_t *be = t_base64url_decode_str(e);\n\tif (want_private_key) {\n\t\tpd = BN_secure_new();\n\t\tbuffer_t *bd = t_base64url_decode_str(d);\n\t\tif (BN_bin2bn(bd->data, bd->used, pd) == NULL) {\n\t\t\tBN_free(pd);\n\t\t\treturn dcrypt_openssl_error(error_r);\n\t\t}\n\t} else {\n\t\tpd = NULL;\n\t}\n\n\tpn = BN_new();\n\tpe = BN_new();\n\n\tif (BN_bin2bn(bn->data, bn->used, pn) == NULL ||\n\t    BN_bin2bn(be->data, be->used, pe) == NULL) {\n\t\tif (pd != NULL)\n\t\t\tBN_free(pd);\n\t\tBN_free(pn);\n\t\tBN_free(pe);\n\t\treturn dcrypt_openssl_error(error_r);\n\t}\n\n\tRSA *rsa_key = RSA_new();\n\tif (rsa_key == NULL) {\n\t\tif (pd != NULL)\n\t\t\tBN_free(pd);\n\t\tBN_free(pn);\n\t\tBN_free(pe);\n\t\treturn dcrypt_openssl_error(error_r);\n\t}\n\n\tif (RSA_set0_key(rsa_key, pn, pe, pd) != 1) {\n\t\tif (pd != NULL)\n\t\t\tBN_free(pd);\n\t\tBN_free(pn);\n\t\tBN_free(pe);\n\t\tRSA_free(rsa_key);\n\t\treturn dcrypt_openssl_error(error_r);\n\t}\n\n\tif (want_private_key) {\n\t\tpp = BN_secure_new();\n\t\tpq = BN_secure_new();\n\t\tpdp = BN_secure_new();\n\t\tpdq = BN_secure_new();\n\t\tpqi = BN_secure_new();\n\n\t\tbuffer_t *bp = t_base64url_decode_str(p);\n\t\tbuffer_t *bq = t_base64url_decode_str(q);\n\t\tbuffer_t *bdp = t_base64url_decode_str(dp);\n\t\tbuffer_t *bdq = t_base64url_decode_str(dq);\n\t\tbuffer_t *bqi = t_base64url_decode_str(qi);\n\n\t\tif (BN_bin2bn(bp->data, bp->used, pp) == NULL ||\n\t\t    BN_bin2bn(bq->data, bq->used, pq) == NULL ||\n\t\t    BN_bin2bn(bdp->data, bdp->used, pdp) == NULL ||\n\t\t    BN_bin2bn(bdq->data, bdq->used, pdq) == NULL ||\n\t\t    BN_bin2bn(bqi->data, bqi->used, pqi) == NULL ||\n\t\t    RSA_set0_factors(rsa_key, pp, pq) != 1) {\n\t\t\tRSA_free(rsa_key);\n\t\t\tBN_free(pp);\n\t\t\tBN_free(pq);\n\t\t\tBN_free(pdp);\n\t\t\tBN_free(pdq);\n\t\t\tBN_free(pqi);\n\t\t\treturn dcrypt_openssl_error(error_r);\n\t\t} else if (RSA_set0_crt_params(rsa_key, pdp, pdq, pqi) != 1) {\n\t\t\tRSA_free(rsa_key);\n\t\t\tBN_free(pdp);\n\t\t\tBN_free(pdq);\n\t\t\tBN_free(pqi);\n\t\t\treturn dcrypt_openssl_error(error_r);\n\t\t}\n\t}\n\n\t/* return as EVP_PKEY */\n\tEVP_PKEY *pkey = EVP_PKEY_new();\n\tEVP_PKEY_set1_RSA(pkey, rsa_key);\n\tRSA_free(rsa_key);\n\t*key_r = pkey;\n\n\treturn TRUE;\n}\n\n\nstatic bool\ndcrypt_openssl_load_private_key_jwk(struct dcrypt_private_key **key_r,\n\t\t\t\t    const char *data, const char *password,\n\t\t\t\t    struct dcrypt_private_key *dec_key,\n\t\t\t\t    const char **error_r)\n{\n\tconst char *kty;\n\tconst char *error;\n\tconst struct json_tree_node *root, *node;\n\tstruct json_tree *key_tree;\n\tEVP_PKEY *pkey;\n\tbool ret;\n\n\tif (parse_jwk_key(data, &key_tree, &error) != 0) {\n\t\tDCRYPT_SET_ERROR(t_strdup_printf(\"Cannot load JWK private key: %s\",\n\t\t\t\t\t\t error));\n\t\treturn FALSE;\n\t}\n\n\troot = json_tree_root(key_tree);\n\n\t/* check key type */\n\tif ((node = json_tree_find_key(root, \"kty\")) == NULL) {\n\t\tDCRYPT_SET_ERROR(\"Cannot load JWK private key: no kty parameter\");\n\t\tjson_tree_deinit(&key_tree);\n\t\treturn FALSE;\n\t}\n\n\tkty = json_tree_get_value_str(node);\n\n\tif (null_strcmp(kty, \"EC\") == 0) {\n\t\tret = load_jwk_ec_key(&pkey, TRUE, root, password, dec_key, &error);\n\t} else if (strcmp(kty, \"RSA\") == 0) {\n\t\tret = load_jwk_rsa_key(&pkey, TRUE, root, password, dec_key, &error);\n\t} else {\n\t\terror = \"Unsupported key type\";\n\t\tret = FALSE;\n\t}\n\n\ti_assert(ret || error != NULL);\n\n\tif (!ret)\n\t\tDCRYPT_SET_ERROR(t_strdup_printf(\"Cannot load JWK private key: %s\", error));\n\telse if (ret) {\n\t\t*key_r = i_new(struct dcrypt_private_key, 1);\n\t\t(*key_r)->key = pkey;\n\t\t(*key_r)->ref++;\n\t\t/* check if kid is present */\n\t\tif ((node = json_tree_find_key(root, \"kid\")) != NULL)\n\t\t\t(*key_r)->key_id = i_strdup_empty(json_tree_get_value_str(node));\n\t\t/* check if use is present */\n\t\tif ((node = json_tree_find_key(root, \"use\")) != NULL)\n\t\t\t(*key_r)->usage = jwk_use_to_key_usage(json_tree_get_value_str(node));\n\t}\n\n\tjson_tree_deinit(&key_tree);\n\n\treturn ret;\n}\n\nstatic bool\ndcrypt_openssl_load_public_key_jwk(struct dcrypt_public_key **key_r,\n\t\t\t\t   const char *data, const char **error_r)\n{\n\tconst char *kty;\n\tconst char *error;\n\tconst struct json_tree_node *root, *node;\n\tstruct json_tree *key_tree;\n\tEVP_PKEY *pkey;\n\tbool ret;\n\n\tif (parse_jwk_key(data, &key_tree, &error) != 0) {\n\t\tDCRYPT_SET_ERROR(t_strdup_printf(\"Cannot load JWK public key: %s\",\n\t\t\t\t\t\t   error));\n\t\treturn FALSE;\n\t}\n\n\troot = json_tree_root(key_tree);\n\n\t/* check key type */\n\tif ((node = json_tree_find_key(root, \"kty\")) == NULL) {\n\t\tDCRYPT_SET_ERROR(\"Cannot load JWK public key: no kty parameter\");\n\t\tjson_tree_deinit(&key_tree);\n\t\treturn FALSE;\n\t}\n\n\tkty = json_tree_get_value_str(node);\n\n\tif (null_strcmp(kty, \"EC\") == 0) {\n\t\tret = load_jwk_ec_key(&pkey, FALSE, root, NULL, NULL, &error);\n\t} else if (strcmp(kty, \"RSA\") == 0) {\n\t      ret = load_jwk_rsa_key(&pkey, FALSE, root, NULL, NULL, &error);\n\t} else {\n\t\terror = \"Unsupported key type\";\n\t\tret = FALSE;\n\t}\n\n\ti_assert(ret || error != NULL);\n\n\tif (!ret)\n\t\tDCRYPT_SET_ERROR(t_strdup_printf(\"Cannot load JWK public key: %s\", error));\n\telse if (ret) {\n\t\t*key_r = i_new(struct dcrypt_public_key, 1);\n\t\t(*key_r)->key = pkey;\n\t\t(*key_r)->ref++;\n\t\t/* check if kid is present */\n\t\tif ((node = json_tree_find_key(root, \"kid\")) != NULL)\n\t\t\t(*key_r)->key_id = i_strdup_empty(json_tree_get_value_str(node));\n\t\t/* check if use is present */\n\t\tif ((node = json_tree_find_key(root, \"use\")) != NULL)\n\t\t\t(*key_r)->usage = jwk_use_to_key_usage(json_tree_get_value_str(node));\n\t}\n\n\tjson_tree_deinit(&key_tree);\n\n\treturn ret;\n}\n\n\nstatic int bn2base64url(const BIGNUM *bn, string_t *dest)\n{\n\tint len = BN_num_bytes(bn);\n\tunsigned char *data = t_malloc_no0(len);\n\tif (BN_bn2bin(bn, data) != len)\n\t\treturn -1;\n\tbase64url_encode(BASE64_ENCODE_FLAG_NO_PADDING, (size_t)-1, data, len, dest);\n\treturn 0;\n}\n\n/* FIXME: Add encryption support */\n/* FIXME: Add support for 'algo' field */\nstatic bool store_jwk_ec_key(EVP_PKEY *pkey, bool is_private_key,\n\t\t\t     enum dcrypt_key_usage usage,\n\t\t\t     const char *key_id,\n\t\t\t     const char *cipher ATTR_UNUSED,\n\t\t\t     const char *password ATTR_UNUSED,\n\t\t\t     struct dcrypt_public_key *enc_key ATTR_UNUSED,\n\t\t\t     string_t *dest, const char **error_r)\n{\n\ti_assert(cipher == NULL && password == NULL && enc_key == NULL);\n\tstring_t *temp = t_str_new(256);\n\tconst EC_KEY *ec_key = EVP_PKEY_get0_EC_KEY(pkey);\n\ti_assert(ec_key != NULL);\n\n\tint nid = EC_GROUP_get_curve_name(EC_KEY_get0_group(ec_key));\n\tconst EC_POINT *public_point = EC_KEY_get0_public_key(ec_key);\n\tBIGNUM *x, *y;\n\n\tx = BN_new();\n\ty = BN_new();\n\tif (EC_POINT_get_affine_coordinates_GFp(EC_KEY_get0_group(ec_key), public_point,\n\t\t\t\t\t\tx, y, NULL) != 1) {\n\t\tBN_free(x);\n\t\tBN_free(y);\n\t\treturn dcrypt_openssl_error(error_r);\n\t}\n\n\tconst char *curve = nid_to_jwk_curve(nid);\n\tconst char *use = key_usage_to_jwk_use(usage);\n\n\tstr_printfa(temp, \"{\\\"kty\\\":\\\"EC\\\",\\\"crv\\\":\\\"%s\\\"\", curve);\n\tstr_append(temp, \",\\\"x\\\":\\\"\");\n\tbn2base64url(x, temp);\n\tstr_append(temp, \"\\\",\\\"y\\\":\\\"\");\n\tbn2base64url(y, temp);\n\n\tif (use != NULL) {\n\t\tstr_append(temp, \"\\\",\\\"use\\\":\\\"\");\n\t\tjson_append_escaped(temp, use);\n\t}\n\tif (key_id != NULL) {\n\t\tstr_append(temp, \"\\\",\\\"kid\\\":\\\"\");\n\t\tjson_append_escaped(temp, key_id);\n\t}\n\tBN_free(x);\n\tBN_free(y);\n\n\tif (is_private_key) {\n\t\tconst BIGNUM *d = EC_KEY_get0_private_key(ec_key);\n\t\tif (d == NULL) {\n\t\t\tDCRYPT_SET_ERROR(\"No private key available\");\n\t\t\treturn FALSE;\n\t\t}\n\t\tstr_append(temp, \"\\\",\\\"d\\\":\\\"\");\n\t\tbn2base64url(d, temp);\n\t}\n\tstr_append(temp, \"\\\"}\");\n\tstr_append_str(dest, temp);\n\treturn TRUE;\n}\n\n/* FIXME: Add RSA support */\n\nstatic bool store_jwk_key(EVP_PKEY *pkey, bool is_private_key,\n\t\t\t  enum dcrypt_key_usage usage,\n\t\t\t  const char *key_id,\n\t\t\t  const char *cipher,\n\t\t\t  const char *password,\n\t\t\t  struct dcrypt_public_key *enc_key,\n\t\t\t  string_t *dest, const char **error_r)\n{\n\ti_assert(cipher == NULL && password == NULL && enc_key == NULL);\n\tif (EVP_PKEY_base_id(pkey) == EVP_PKEY_EC) {\n\t\treturn store_jwk_ec_key(pkey, is_private_key, usage, key_id,\n\t\t\t\t\tcipher, password, enc_key, dest, error_r);\n\t}\n\tDCRYPT_SET_ERROR(\"Unsupported key type\");\n\treturn FALSE;\n}\n\nstatic bool\ndcrypt_openssl_load_private_key_dovecot(struct dcrypt_private_key **key_r,\n\t\t\t\t\tconst char *data, const char *password,\n\t\t\t\t\tstruct dcrypt_private_key *key,\n\t\t\t\t\tenum dcrypt_key_version version,\n\t\t\t\t\tconst char **error_r)\n{\n\tconst char **input = t_strsplit(data, \":\\t\");\n\tsize_t len = str_array_length(input);\n\n\tswitch (version) {\n\tcase DCRYPT_KEY_VERSION_1:\n\t\treturn dcrypt_openssl_load_private_key_dovecot_v1(\n\t\t\tkey_r, len, input, password, key, error_r);\n\tcase DCRYPT_KEY_VERSION_2:\n\t\treturn dcrypt_openssl_load_private_key_dovecot_v2(\n\t\t\tkey_r, len, input, password, key, error_r);\n\tcase DCRYPT_KEY_VERSION_NA:\n\t\ti_unreached();\n\t}\n\treturn FALSE;\n}\n\nstatic bool\ndcrypt_openssl_load_public_key_dovecot_v1(struct dcrypt_public_key **key_r,\n\t\t\t\t\t  int len, const char **input,\n\t\t\t\t\t  const char **error_r)\n{\n\tint nid;\n\tif (str_to_int(input[1], &nid) != 0) {\n\t\tDCRYPT_SET_ERROR(\"Corrupted data\");\n\t\treturn FALSE;\n\t}\n\n\tEC_KEY *eckey = EC_KEY_new_by_curve_name(nid);\n\tif (eckey == NULL) {\n\t\tdcrypt_openssl_error(error_r);\n\t\treturn FALSE;\n\t}\n\n\tEC_KEY_set_asn1_flag(eckey, OPENSSL_EC_NAMED_CURVE);\n\tBN_CTX *bnctx = BN_CTX_new();\n\n\tEC_POINT *point = EC_POINT_new(EC_KEY_get0_group(eckey));\n\tif (bnctx == NULL || point == NULL ||\n\t    EC_POINT_hex2point(EC_KEY_get0_group(eckey),\n\t    input[2], point, bnctx) == NULL) {\n\t\tBN_CTX_free(bnctx);\n\t\tEC_KEY_free(eckey);\n\t\tEC_POINT_free(point);\n\t\tdcrypt_openssl_error(error_r);\n\t\treturn FALSE;\n\t}\n\tBN_CTX_free(bnctx);\n\n\tEC_KEY_set_public_key(eckey, point);\n\tEC_KEY_set_asn1_flag(eckey, OPENSSL_EC_NAMED_CURVE);\n\n\tEC_POINT_free(point);\n\n\tif (EC_KEY_check_key(eckey) == 1) {\n\t\tEVP_PKEY *key = EVP_PKEY_new();\n\t\tEVP_PKEY_set1_EC_KEY(key, eckey);\n\t\tEC_KEY_free(eckey);\n\t\t/* make sure digest matches */\n\t\tbuffer_t *dgst = t_buffer_create(32);\n\t\tstruct dcrypt_public_key tmp;\n\t\ti_zero(&tmp);\n\t\ttmp.key = key;\n\t\tdcrypt_openssl_public_key_id_old(&tmp, dgst, NULL);\n\t\tif (strcmp(binary_to_hex(dgst->data, dgst->used),\n\t\t\t   input[len-1]) != 0) {\n\t\t\tDCRYPT_SET_ERROR(\"Key id mismatch after load\");\n\t\t\tEVP_PKEY_free(key);\n\t\t\treturn FALSE;\n\t\t}\n\t\t*key_r = i_new(struct dcrypt_public_key, 1);\n\t\t(*key_r)->key = key;\n\t\t(*key_r)->ref++;\n\t\treturn TRUE;\n\t}\n\n\tdcrypt_openssl_error(error_r);\n\treturn FALSE;\n}\n\nstatic bool\ndcrypt_openssl_load_public_key_dovecot_v2(struct dcrypt_public_key **key_r,\n\t\t\t\t\t  int len, const char **input,\n\t\t\t\t\t  const char **error_r)\n{\n\tbuffer_t tmp;\n\tsize_t keylen = strlen(input[1])/2;\n\tunsigned char keybuf[keylen];\n\tconst unsigned char *ptr;\n\tbuffer_create_from_data(&tmp, keybuf, keylen);\n\thex_to_binary(input[1], &tmp);\n\tptr = keybuf;\n\n\tEVP_PKEY *pkey = EVP_PKEY_new();\n\tif (pkey == NULL || d2i_PUBKEY(&pkey, &ptr, keylen)==NULL) {\n\t\tEVP_PKEY_free(pkey);\n\t\tdcrypt_openssl_error(error_r);\n\t\treturn FALSE;\n\t}\n\n\t/* make sure digest matches */\n\tbuffer_t *dgst = t_buffer_create(32);\n\tstruct dcrypt_public_key tmpkey;\n\ti_zero(&tmpkey);\n\ttmpkey.key = pkey;\n\tdcrypt_openssl_public_key_id(&tmpkey, \"sha256\", dgst, NULL);\n\tif (strcmp(binary_to_hex(dgst->data, dgst->used), input[len-1]) != 0) {\n\t\tDCRYPT_SET_ERROR(\"Key id mismatch after load\");\n\t\tEVP_PKEY_free(pkey);\n\t\treturn FALSE;\n\t}\n\n\t*key_r = i_new(struct dcrypt_public_key, 1);\n\t(*key_r)->key = pkey;\n\t(*key_r)->ref++;\n\treturn TRUE;\n}\n\nstatic bool\ndcrypt_openssl_load_public_key_dovecot(struct dcrypt_public_key **key_r,\n\t\t\t\t       const char *data,\n\t\t\t\t       enum dcrypt_key_version version,\n\t\t\t\t       const char **error_r)\n{\n\tconst char **input = t_strsplit(data, \":\\t\");\n\tsize_t len = str_array_length(input);\n\n\tswitch (version) {\n\tcase DCRYPT_KEY_VERSION_1:\n\t\treturn dcrypt_openssl_load_public_key_dovecot_v1(\n\t\t\tkey_r, len, input, error_r);\n\t\tbreak;\n\tcase DCRYPT_KEY_VERSION_2:\n\t\treturn dcrypt_openssl_load_public_key_dovecot_v2(\n\t\t\tkey_r, len, input, error_r);\n\t\tbreak;\n\tcase DCRYPT_KEY_VERSION_NA:\n\t\ti_unreached();\n\t}\n\treturn FALSE;\n}\n\nstatic bool\ndcrypt_openssl_encrypt_private_key_dovecot(buffer_t *key, int enctype,\n\t\t\t\t\t   const char *cipher,\n\t\t\t\t\t   const char *password,\n\t\t\t\t\t   struct dcrypt_public_key *enc_key,\n\t\t\t\t\t   buffer_t *destination,\n\t\t\t\t\t   const char **error_r)\n{\n\tbool res;\n\tunsigned char *ptr;\n\n\tunsigned char salt[8];\n\tbuffer_t *peer_key = t_buffer_create(128);\n\tbuffer_t *secret = t_buffer_create(128);\n\tcipher = t_str_lcase(cipher);\n\n\tstr_append(destination, cipher);\n\tstr_append_c(destination, ':');\n\trandom_fill(salt, sizeof(salt));\n\tbinary_to_hex_append(destination, salt, sizeof(salt));\n\tbuffer_t saltbuf;\n\tbuffer_create_from_const_data(&saltbuf, salt, sizeof(salt));\n\n\t/* so we don't have to make new version if we ever upgrade these */\n\tstr_append(destination, t_strdup_printf(\":%s:%d:\",\n\t\tDCRYPT_DOVECOT_KEY_ENCRYPT_HASH,\n\t\tDCRYPT_DOVECOT_KEY_ENCRYPT_ROUNDS));\n\n\tif (enctype == DCRYPT_DOVECOT_KEY_ENCRYPT_PK) {\n\t\tif (EVP_PKEY_base_id(enc_key->key) == EVP_PKEY_RSA) {\n\t\t\tsize_t used = buffer_get_used_size(secret);\n\t\t\t/* peer key, in this case, is encrypted secret,\n\t\t\t   which is 16 bytes of data */\n\t\t\tptr = buffer_append_space_unsafe(secret, 16);\n\t\t\trandom_fill(ptr, 16);\n\t\t\tbuffer_set_used_size(secret, used+16);\n\t\t\tif (!dcrypt_rsa_encrypt(enc_key, secret->data,\n\t\t\t\t\t\tsecret->used, peer_key,\n\t\t\t\t\t\tDCRYPT_PADDING_RSA_PKCS1_OAEP,\n\t\t\t\t\t\terror_r)) {\n\t\t\t\treturn FALSE;\n\t\t\t}\n\t\t} else if (EVP_PKEY_base_id(enc_key->key) == EVP_PKEY_EC) {\n\t\t\t/* generate secret by ECDHE */\n\t\t\tif (!dcrypt_openssl_ecdh_derive_secret_peer(\n\t\t\t\tenc_key, peer_key, secret, error_r)) {\n\t\t\t\treturn FALSE;\n\t\t\t}\n\t\t} else {\n\t\t\t/* Loading the key should have failed */\n\t\t\ti_unreached();\n\t\t}\n\t\t/* add encryption key id, reuse peer_key buffer */\n\t} else if (enctype == DCRYPT_DOVECOT_KEY_ENCRYPT_PASSWORD) {\n\t\tstr_append(secret, password);\n\t}\n\n\t/* encrypt key using secret and salt */\n\tbuffer_t *tmp = t_buffer_create(128);\n\tres = dcrypt_openssl_cipher_key_dovecot_v2(cipher,\n\t\tDCRYPT_MODE_ENCRYPT, key, secret, &saltbuf,\n\t\tDCRYPT_DOVECOT_KEY_ENCRYPT_HASH,\n\t\tDCRYPT_DOVECOT_KEY_ENCRYPT_ROUNDS, tmp, error_r);\n\tsafe_memset(buffer_get_modifiable_data(secret, NULL), 0, secret->used);\n\tbinary_to_hex_append(destination, tmp->data, tmp->used);\n\n\t/* some additional fields or private key version */\n\tif (enctype == DCRYPT_DOVECOT_KEY_ENCRYPT_PK) {\n\t\tstr_append_c(destination, ':');\n\n\t\t/* for RSA, this is the actual encrypted secret */\n\t\tbinary_to_hex_append(destination,\n\t\t\t\t     peer_key->data, peer_key->used);\n\t\tstr_append_c(destination, ':');\n\n\t\tbuffer_set_used_size(peer_key, 0);\n\t\tif (!dcrypt_openssl_public_key_id(enc_key, \"sha256\",\n\t\t\t\t\t\t  peer_key, error_r))\n\t\t\treturn FALSE;\n\t\tbinary_to_hex_append(destination,\n\t\t\t\t     peer_key->data, peer_key->used);\n\t}\n\treturn res;\n}\n\nstatic bool\ndcrypt_openssl_store_private_key_dovecot(struct dcrypt_private_key *key,\n\t\t\t\t\t const char *cipher,\n\t\t\t\t\t buffer_t *destination,\n\t\t\t\t\t const char *password,\n\t\t\t\t\t struct dcrypt_public_key *enc_key,\n\t\t\t\t\t const char **error_r)\n{\n\tsize_t dest_used = buffer_get_used_size(destination);\n\tconst char *cipher2 = NULL;\n\tEVP_PKEY *pkey = key->key;\n\tchar objtxt[OID_TEXT_MAX_LEN];\n\tASN1_OBJECT *obj;\n\n\tif (EVP_PKEY_base_id(pkey) == EVP_PKEY_EC) {\n\t\t/* because otherwise we get wrong nid */\n\t\tobj = OBJ_nid2obj(EC_GROUP_get_curve_name(\n\t\t\tEC_KEY_get0_group(EVP_PKEY_get0_EC_KEY(pkey))));\n\t\tEC_KEY_set_conv_form(EVP_PKEY_get0_EC_KEY(pkey),\n\t\t\t\t     POINT_CONVERSION_COMPRESSED);\n\n\t} else {\n\t\tobj = OBJ_nid2obj(EVP_PKEY_id(pkey));\n\t}\n\n\tint enctype = DCRYPT_KEY_ENCRYPTION_TYPE_NONE;\n\tint len = OBJ_obj2txt(objtxt, sizeof(objtxt), obj, 1);\n\tif (len < 1)\n\t\treturn dcrypt_openssl_error(error_r);\n\tif (len > (int)sizeof(objtxt)) {\n\t\tDCRYPT_SET_ERROR(\"Object identifier too long\");\n\t\treturn FALSE;\n\t}\n\n\tbuffer_t *buf = t_buffer_create(256);\n\n\t/* convert key to private key value */\n\tif (EVP_PKEY_base_id(pkey) == EVP_PKEY_RSA) {\n\t\tunsigned char *ptr;\n\t\tRSA *rsa = EVP_PKEY_get0_RSA(pkey);\n\t\tint len = i2d_RSAPrivateKey(rsa, &ptr);\n\t\tif (len < 1)\n\t\t\treturn dcrypt_openssl_error(error_r);\n\t\tbuffer_append(buf, ptr, len);\n\t} else if (EVP_PKEY_base_id(pkey) == EVP_PKEY_EC) {\n\t\tunsigned char *ptr;\n\t\tEC_KEY *eckey = EVP_PKEY_get0_EC_KEY(pkey);\n\t\tconst BIGNUM *pk = EC_KEY_get0_private_key(eckey);\n\t\t/* serialize to MPI which is portable */\n\t\tint len = BN_bn2mpi(pk, NULL);\n\t\tptr = buffer_append_space_unsafe(buf, len);\n\t\tBN_bn2mpi(pk, ptr);\n\t} else {\n\t\t/* Loading the key should have failed */\n\t\ti_unreached();\n\t}\n\n\t/* see if we want ECDH based or password based encryption */\n\tif (cipher != NULL && strncasecmp(cipher, \"ecdh-\", 5) == 0) {\n\t\ti_assert(enc_key != NULL);\n\t\ti_assert(password == NULL);\n\t\tenctype = DCRYPT_DOVECOT_KEY_ENCRYPT_PK;\n\t\tcipher2 = cipher+5;\n\t} else if (cipher != NULL) {\n\t\ti_assert(enc_key == NULL);\n\t\ti_assert(password != NULL);\n\t\tenctype = DCRYPT_DOVECOT_KEY_ENCRYPT_PASSWORD;\n\t\tcipher2 = cipher;\n\t} else if (enctype == DCRYPT_KEY_ENCRYPTION_TYPE_NONE) {\n\t\ti_assert(enc_key == NULL && password == NULL);\n\t}\n\n\t/* put in OID and encryption type */\n\tstr_append(destination, t_strdup_printf(\"2:%s:%d:\",\n\t\tobjtxt, enctype));\n\n\t/* perform encryption if desired */\n\tif (enctype != DCRYPT_KEY_ENCRYPTION_TYPE_NONE) {\n\t\tif (!dcrypt_openssl_encrypt_private_key_dovecot(buf,\n\t\t\tenctype, cipher2, password, enc_key, destination,\n\t\t\terror_r)) {\n\t\t\tbuffer_set_used_size(destination, dest_used);\n\t\t\treturn FALSE;\n\t\t}\n\t} else {\n\t\tbinary_to_hex_append(destination, buf->data, buf->used);\n\t}\n\n\t/* append public key id */\n\tstr_append_c(destination, ':');\n\tbuffer_set_used_size(buf, 0);\n\tbool res = dcrypt_openssl_private_key_id(key, \"sha256\", buf, error_r);\n\tbinary_to_hex_append(destination, buf->data, buf->used);\n\n\tif (!res) {\n\t\t/* well, that didn't end well */\n\t\tbuffer_set_used_size(destination, dest_used);\n\t\treturn FALSE;\n\t}\n\treturn TRUE;\n}\n\nstatic bool\ndcrypt_openssl_store_public_key_dovecot(struct dcrypt_public_key *key,\n\t\t\t\t\tbuffer_t *destination,\n\t\t\t\t\tconst char **error_r)\n{\n\tEVP_PKEY *pubkey = key->key;\n\tunsigned char *tmp = NULL;\n\tsize_t dest_used = buffer_get_used_size(destination);\n\n\tif (EVP_PKEY_base_id(pubkey) == EVP_PKEY_EC)\n\t\tEC_KEY_set_conv_form(EVP_PKEY_get0_EC_KEY(pubkey),\n\t\t\t\t     POINT_CONVERSION_COMPRESSED);\n\tint rv = i2d_PUBKEY(pubkey, &tmp);\n\n\tif (tmp == NULL)\n\t\treturn dcrypt_openssl_error(error_r);\n\n\t/* then store it */\n\tstr_append_c(destination, '2');\n\tstr_append_c(destination, ':');\n\tbinary_to_hex_append(destination, tmp, rv);\n\tOPENSSL_free(tmp);\n\n\t/* append public key ID */\n\tstr_append_c(destination, ':');\n\n\tbuffer_t *buf = t_buffer_create(32);\n\tbool res = dcrypt_openssl_public_key_id(key, \"sha256\", buf, error_r);\n\n\tif (!res) {\n\t\tbuffer_set_used_size(destination, dest_used);\n\t\treturn FALSE;\n\t}\n\n\tstr_append(destination, binary_to_hex(buf->data, buf->used));\n\treturn TRUE;\n}\n\nstatic bool\ndcrypt_openssl_load_private_key(struct dcrypt_private_key **key_r,\n\t\t\t\tconst char *data, const char *password,\n\t\t\t\tstruct dcrypt_private_key *dec_key,\n\t\t\t\tconst char **error_r)\n{\n\ti_assert(key_r != NULL);\n\n\tenum dcrypt_key_format format;\n\tenum dcrypt_key_version version;\n\tenum dcrypt_key_kind kind;\n\tif (!dcrypt_openssl_key_string_get_info(data, &format, &version,\n\t\t\t\t&kind, NULL, NULL, NULL, error_r)) {\n\t\treturn FALSE;\n\t}\n\tif (kind != DCRYPT_KEY_KIND_PRIVATE) {\n\t\tDCRYPT_SET_ERROR(\"key is not private\");\n\t\treturn FALSE;\n\t}\n\n\tif (format == DCRYPT_FORMAT_JWK)\n\t\treturn dcrypt_openssl_load_private_key_jwk(key_r, data, password,\n\t\t\t\t\t\t\t   dec_key, error_r);\n\n\tif (format == DCRYPT_FORMAT_DOVECOT)\n\t\treturn dcrypt_openssl_load_private_key_dovecot(key_r, data,\n\t\t\t\tpassword, dec_key, version, error_r);\n\n\tEVP_PKEY *key = NULL, *key2;\n\n\tBIO *key_in = BIO_new_mem_buf((void*)data, strlen(data));\n\n\tkey = EVP_PKEY_new();\n\n\tkey2 = PEM_read_bio_PrivateKey(key_in, &key, NULL, (void*)password);\n\n\tBIO_vfree(key_in);\n\n\tif (key2 == NULL) {\n\t\tEVP_PKEY_free(key);\n\t\treturn dcrypt_openssl_error(error_r);\n\t}\n\n\tif (EVP_PKEY_base_id(key) == EVP_PKEY_EC) {\n\t\tEC_KEY_set_asn1_flag(EVP_PKEY_get0_EC_KEY(key),\n\t\t\t\t     OPENSSL_EC_NAMED_CURVE);\n\t}\n\n\t*key_r = i_new(struct dcrypt_private_key, 1);\n\t(*key_r)->key = key;\n\t(*key_r)->ref++;\n\n\treturn TRUE;\n}\n\nstatic bool\ndcrypt_openssl_load_public_key(struct dcrypt_public_key **key_r,\n\t\t\t       const char *data, const char **error_r)\n{\n\tenum dcrypt_key_format format;\n\tenum dcrypt_key_version version;\n\tenum dcrypt_key_kind kind;\n\ti_assert(key_r != NULL);\n\n\tif (!dcrypt_openssl_key_string_get_info(data, &format, &version,\n\t\t\t\t\t\t&kind, NULL, NULL, NULL,\n\t\t\t\t\t\terror_r)) {\n\t\treturn FALSE;\n\t}\n\t/* JWK private keys can be loaded as public */\n\tif (kind != DCRYPT_KEY_KIND_PUBLIC && format != DCRYPT_FORMAT_JWK) {\n\t\tDCRYPT_SET_ERROR(\"key is not public\");\n\t\treturn FALSE;\n\t}\n\n\tif (format == DCRYPT_FORMAT_JWK)\n\t\treturn dcrypt_openssl_load_public_key_jwk(key_r, data, error_r);\n\n\tif (format == DCRYPT_FORMAT_DOVECOT)\n\t\treturn dcrypt_openssl_load_public_key_dovecot(key_r, data,\n\t\t\t\tversion, error_r);\n\n\tEVP_PKEY *key = NULL;\n\tBIO *key_in = BIO_new_mem_buf((void*)data, strlen(data));\n\tif (key_in == NULL)\n\t\treturn dcrypt_openssl_error(error_r);\n\n\tkey = PEM_read_bio_PUBKEY(key_in, &key, NULL, NULL);\n\tif (BIO_reset(key_in) <= 0)\n\t\ti_unreached();\n\tif (key == NULL) { /* ec keys are bother */\n\t\t/* read the header */\n\t\tchar buf[27]; /* begin public key */\n\t\tif (BIO_gets(key_in, buf, sizeof(buf)) != 1) {\n\t\t\tBIO_vfree(key_in);\n\t\t\treturn dcrypt_openssl_error(error_r);\n\t\t}\n\t\tif (strcmp(buf, \"-----BEGIN PUBLIC KEY-----\") != 0) {\n\t\t\tDCRYPT_SET_ERROR(\"Missing public key header\");\n\t\t\treturn FALSE;\n\t\t}\n\t\tBIO *b64 = BIO_new(BIO_f_base64());\n\t\tif (b64 == NULL) {\n\t\t\tBIO_vfree(key_in);\n\t\t\treturn dcrypt_openssl_error(error_r);\n\t\t}\n\t\tEC_KEY *eckey = d2i_EC_PUBKEY_bio(b64, NULL);\n\t\tif (eckey != NULL) {\n\t\t\tEC_KEY_set_asn1_flag(eckey, OPENSSL_EC_NAMED_CURVE);\n\t\t\tkey = EVP_PKEY_new();\n\t\t\tif (key != NULL)\n\t\t\t\tEVP_PKEY_set1_EC_KEY(key, eckey);\n\t\t\tEC_KEY_free(eckey);\n\t\t}\n\t}\n\n\tBIO_vfree(key_in);\n\n\tif (key == NULL)\n\t\treturn dcrypt_openssl_error(error_r);\n\n\t*key_r = i_new(struct dcrypt_public_key, 1);\n\t(*key_r)->key = key;\n\t(*key_r)->ref++;\n\n\treturn TRUE;\n}\n\nstatic bool\ndcrypt_openssl_store_private_key(struct dcrypt_private_key *key,\n\t\t\t\t enum dcrypt_key_format format,\n\t\t\t\t const char *cipher, buffer_t *destination,\n\t\t\t\t const char *password,\n\t\t\t\t struct dcrypt_public_key *enc_key,\n\t\t\t\t const char **error_r)\n{\n\ti_assert(key != NULL && key->key != NULL);\n\n\tint ec;\n\tif (format == DCRYPT_FORMAT_DOVECOT) {\n\t\tbool ret;\n\t\tret = dcrypt_openssl_store_private_key_dovecot(\n\t\t\tkey, cipher, destination, password, enc_key, error_r);\n\t\treturn ret;\n\t}\n\n\tEVP_PKEY *pkey = key->key;\n\n\tif (format == DCRYPT_FORMAT_JWK) {\n\t\tbool ret;\n\t\tret = store_jwk_key(pkey, TRUE, key->usage, key->key_id,\n\t\t\t\t    cipher, password, enc_key,\n\t\t\t\t    destination, error_r);\n\t\treturn ret;\n\t}\n\n\tif (EVP_PKEY_base_id(pkey) == EVP_PKEY_EC)\n\t\tEC_KEY_set_conv_form(EVP_PKEY_get0_EC_KEY(pkey),\n\t\t\t\t     POINT_CONVERSION_UNCOMPRESSED);\n\n\tBIO *key_out = BIO_new(BIO_s_mem());\n\tif (key_out == NULL)\n\t\treturn dcrypt_openssl_error(error_r);\n\n\tconst EVP_CIPHER *algo = NULL;\n\tif (cipher != NULL) {\n\t\talgo = EVP_get_cipherbyname(cipher);\n\t\tif (algo == NULL) {\n\t\t\tDCRYPT_SET_ERROR(t_strdup_printf(\"Invalid cipher %s\",\n\t\t\t\t\t\t\t cipher));\n\t\t\treturn FALSE;\n\t\t}\n\t}\n\n\tec = PEM_write_bio_PrivateKey(key_out, pkey, algo,\n\t\t\t\t      NULL, 0, NULL, (void*)password);\n\n\tif (BIO_flush(key_out) <= 0)\n\t\tec = -1;\n\n\tif (ec != 1) {\n\t\tBIO_vfree(key_out);\n\t\treturn dcrypt_openssl_error(error_r);\n\t}\n\n\tlong bs;\n\tchar *buf;\n\tbs = BIO_get_mem_data(key_out, &buf);\n\tbuffer_append(destination, buf, bs);\n\tBIO_vfree(key_out);\n\n\treturn TRUE;\n}\n\nstatic bool\ndcrypt_openssl_store_public_key(struct dcrypt_public_key *key,\n\t\t\t\tenum dcrypt_key_format format,\n\t\t\t\tbuffer_t *destination, const char **error_r)\n{\n\tint ec;\n\n\ti_assert(key != NULL && key->key != NULL);\n\n\tif (format == DCRYPT_FORMAT_DOVECOT) {\n\t\treturn dcrypt_openssl_store_public_key_dovecot(key, destination,\n\t\t\t\t\t\t\t       error_r);\n\t}\n\n\tEVP_PKEY *pkey = key->key;\n\n\tif (format == DCRYPT_FORMAT_JWK) {\n\t\tbool ret;\n\t\tret = store_jwk_key(pkey, FALSE, key->usage, key->key_id,\n\t\t\t\t    NULL, NULL, NULL,\n\t\t\t\t    destination, error_r);\n\t\treturn ret;\n\t}\n\n\tif (EVP_PKEY_base_id(pkey) == EVP_PKEY_EC)\n\t\tEC_KEY_set_conv_form(EVP_PKEY_get0_EC_KEY(pkey),\n\t\t\t\t     POINT_CONVERSION_UNCOMPRESSED);\n\n\tBIO *key_out = BIO_new(BIO_s_mem());\n\tif (key_out == NULL)\n\t\treturn dcrypt_openssl_error(error_r);\n\n\tBIO *b64;\n\tif (EVP_PKEY_base_id(pkey) == EVP_PKEY_RSA)\n\t\tec = PEM_write_bio_PUBKEY(key_out, pkey);\n\telse if ((b64 = BIO_new(BIO_f_base64())) == NULL)\n\t\tec = -1;\n\telse {\n\t\t(void)BIO_puts(key_out, \"-----BEGIN PUBLIC KEY-----\\n\");\n\t\t(void)BIO_push(b64, key_out);\n\t\tec = i2d_EC_PUBKEY_bio(b64, EVP_PKEY_get0_EC_KEY(pkey));\n\t\tif (BIO_flush(b64) <= 0)\n\t\t\tec = -1;\n\t\t(void)BIO_pop(b64);\n\t\tBIO_vfree(b64);\n\t\tif (BIO_puts(key_out, \"-----END PUBLIC KEY-----\") <= 0)\n\t\t\tec = -1;\n\t}\n\n\tif (ec != 1) {\n\t\tBIO_vfree(key_out);\n\t\treturn dcrypt_openssl_error(error_r);\n\t}\n\n\tlong bs;\n\tchar *buf;\n\tbs = BIO_get_mem_data(key_out, &buf);\n\tbuffer_append(destination, buf, bs);\n\tBIO_vfree(key_out);\n\n\treturn TRUE;\n}\n\nstatic void\ndcrypt_openssl_private_to_public_key(struct dcrypt_private_key *priv_key,\n\t\t\t\t     struct dcrypt_public_key **pub_key_r)\n{\n\ti_assert(priv_key != NULL && pub_key_r != NULL);\n\n\tEVP_PKEY *pkey = priv_key->key;\n\tEVP_PKEY *pk;\n\n\tpk = EVP_PKEY_new();\n\ti_assert(pk != NULL); /* we shouldn't get malloc() failures */\n\n\tif (EVP_PKEY_base_id(pkey) == EVP_PKEY_RSA)\n\t{\n\t\tRSA *rsa = RSAPublicKey_dup(EVP_PKEY_get0_RSA(pkey));\n\t\tEVP_PKEY_set1_RSA(pk, rsa);\n\t\tRSA_free(rsa);\n\t} else if (EVP_PKEY_base_id(pkey) == EVP_PKEY_EC) {\n\t\tEC_KEY* eck = EVP_PKEY_get1_EC_KEY(pkey);\n\t\tEC_KEY_set_asn1_flag(eck, OPENSSL_EC_NAMED_CURVE);\n\t\tEVP_PKEY_set1_EC_KEY(pk, eck);\n\t\tEC_KEY_free(eck);\n\t} else {\n\t\t/* Loading the key should have failed */\n\t\ti_unreached();\n\t}\n\n\t*pub_key_r = i_new(struct dcrypt_public_key, 1);\n\t(*pub_key_r)->key = pk;\n\t(*pub_key_r)->ref++;\n}\n\nstatic bool\ndcrypt_openssl_key_string_get_info(\n\tconst char *key_data, enum dcrypt_key_format *format_r,\n\tenum dcrypt_key_version *version_r, enum dcrypt_key_kind *kind_r,\n\tenum dcrypt_key_encryption_type *encryption_type_r,\n\tconst char **encryption_key_hash_r, const char **key_hash_r,\n\tconst char **error_r)\n{\n\tenum dcrypt_key_format format = DCRYPT_FORMAT_PEM;\n\tenum dcrypt_key_version version = DCRYPT_KEY_VERSION_NA;\n\tenum dcrypt_key_encryption_type encryption_type =\n\t\tDCRYPT_KEY_ENCRYPTION_TYPE_NONE;\n\tenum dcrypt_key_kind kind = DCRYPT_KEY_KIND_PUBLIC;\n\tchar *encryption_key_hash = NULL;\n\tchar *key_hash = NULL;\n\n\ti_assert(key_data != NULL);\n\n\t/* is it PEM key */\n\tif (str_begins(key_data, \"-----BEGIN \")) {\n\t\tformat = DCRYPT_FORMAT_PEM;\n\t\tversion = DCRYPT_KEY_VERSION_NA;\n\t\tkey_data += 11;\n\t\tif (str_begins(key_data, \"RSA \")) {\n\t\t\tDCRYPT_SET_ERROR(\"RSA private key format not supported, convert it to PKEY format with openssl pkey\");\n\t\t\treturn FALSE;\n\t\t}\n\t\tif (str_begins(key_data, \"ENCRYPTED \")) {\n\t\t\tencryption_type = DCRYPT_KEY_ENCRYPTION_TYPE_PASSWORD;\n\t\t\tkey_data += 10;\n\t\t}\n\t\tif (str_begins(key_data, \"PRIVATE KEY-----\"))\n\t\t\tkind = DCRYPT_KEY_KIND_PRIVATE;\n\t\telse if (str_begins(key_data, \"PUBLIC KEY-----\"))\n\t\t\tkind = DCRYPT_KEY_KIND_PUBLIC;\n\t\telse {\n\t\t\tDCRYPT_SET_ERROR(\"Unknown/invalid PEM key type\");\n\t\t\treturn FALSE;\n\t\t}\n\t} else if (*key_data == '{') {\n\t\t/* possibly a JWK key */\n\t\tformat = DCRYPT_FORMAT_JWK;\n\t\tversion = DCRYPT_KEY_VERSION_NA;\n\t\tstruct json_tree *tree;\n\t\tconst struct json_tree_node *root, *node;\n\t\tconst char *value, *error;\n\t\tif (parse_jwk_key(key_data, &tree, &error) != 0) {\n\t\t\tDCRYPT_SET_ERROR(\"Unknown/invalid key data\");\n\t\t\treturn FALSE;\n\t\t}\n\n\t\t/* determine key type */\n\t\troot = json_tree_root(tree);\n\t\tif ((node = json_tree_find_key(root, \"kty\")) == NULL ||\n\t\t    (value = json_tree_get_value_str(node)) == NULL) {\n\t\t\tjson_tree_deinit(&tree);\n\t\t\tDCRYPT_SET_ERROR(\"Invalid JWK key: Missing kty parameter\");\n\t\t\treturn FALSE;\n\t\t} else if (strcmp(value, \"RSA\") == 0) {\n\t\t\tif (json_tree_find_key(root, \"d\") != NULL)\n\t\t\t\tkind = DCRYPT_KEY_KIND_PRIVATE;\n\t\t\telse\n\t\t\t\tkind = DCRYPT_KEY_KIND_PUBLIC;\n\t\t} else if (strcmp(value, \"EC\") == 0) {\n\t\t\tif (json_tree_find_key(root, \"d\") != NULL)\n\t\t\t\tkind = DCRYPT_KEY_KIND_PRIVATE;\n\t\t\telse\n\t\t\t\tkind = DCRYPT_KEY_KIND_PUBLIC;\n\t\t} else {\n\t\t\tjson_tree_deinit(&tree);\n\t\t\tDCRYPT_SET_ERROR(\"Unsupported JWK key type\");\n\t\t\treturn FALSE;\n\t\t}\n\t\tjson_tree_deinit(&tree);\n\t} else {\n\t\tif (str_begins(key_data, \"1:\")) {\n\t\t\tDCRYPT_SET_ERROR(\"Dovecot v1 key format uses tab to separate fields\");\n\t\t\treturn FALSE;\n\t\t} else if (str_begins(key_data, \"2\\t\")) {\n\t\t\tDCRYPT_SET_ERROR(\"Dovecot v2 key format uses colon to separate fields\");\n\t\t\treturn FALSE;\n\t\t}\n\t\tconst char **fields = t_strsplit(key_data, \":\\t\");\n\t\tint nfields = str_array_length(fields);\n\n\t\tif (nfields < 2) {\n\t\t\tDCRYPT_SET_ERROR(\"Unknown key format\");\n\t\t\treturn FALSE;\n\t\t}\n\n\t\tformat = DCRYPT_FORMAT_DOVECOT;\n\n\t\t/* field 1 - version */\n\t\tif (strcmp(fields[0], \"1\") == 0) {\n\t\t\tversion = DCRYPT_KEY_VERSION_1;\n\t\t\tif (nfields == 4) {\n\t\t\t\tkind = DCRYPT_KEY_KIND_PUBLIC;\n\t\t\t} else if (nfields == 5 && strcmp(fields[2],\"0\") == 0) {\n\t\t\t\tkind = DCRYPT_KEY_KIND_PRIVATE;\n\t\t\t\tencryption_type = DCRYPT_KEY_ENCRYPTION_TYPE_NONE;\n\t\t\t} else if (nfields == 6 && strcmp(fields[2],\"2\") == 0) {\n\t\t\t\tkind = DCRYPT_KEY_KIND_PRIVATE;\n\t\t\t\tencryption_type = DCRYPT_KEY_ENCRYPTION_TYPE_PASSWORD;\n\t\t\t} else if (nfields == 7 && strcmp(fields[2],\"1\") == 0) {\n\t\t\t\tkind = DCRYPT_KEY_KIND_PRIVATE;\n\t\t\t\tencryption_type = DCRYPT_KEY_ENCRYPTION_TYPE_KEY;\n\t\t\t\tif (encryption_key_hash_r != NULL)\n\t\t\t\t\tencryption_key_hash = i_strdup(fields[nfields-2]);\n\t\t\t} else {\n\t\t\t\tDCRYPT_SET_ERROR(\"Invalid dovecot v1 encoding\");\n\t\t\t\treturn FALSE;\n\t\t\t}\n\t\t} else if (strcmp(fields[0], \"2\") == 0) {\n\t\t\tversion = DCRYPT_KEY_VERSION_2;\n\t\t\tif (nfields == 3) {\n\t\t\t\tkind = DCRYPT_KEY_KIND_PUBLIC;\n\t\t\t} else if (nfields == 5 && strcmp(fields[2],\"0\") == 0) {\n\t\t\t\tkind = DCRYPT_KEY_KIND_PRIVATE;\n\t\t\t\tencryption_type = DCRYPT_KEY_ENCRYPTION_TYPE_NONE;\n\t\t\t} else if (nfields == 9 && strcmp(fields[2],\"2\") == 0) {\n\t\t\t\tkind = DCRYPT_KEY_KIND_PRIVATE;\n\t\t\t\tencryption_type = DCRYPT_KEY_ENCRYPTION_TYPE_PASSWORD;\n\t\t\t} else if (nfields == 11 && strcmp(fields[2],\"1\") == 0) {\n\t\t\t\tkind = DCRYPT_KEY_KIND_PRIVATE;\n\t\t\t\tencryption_type = DCRYPT_KEY_ENCRYPTION_TYPE_KEY;\n\t\t\t\tif (encryption_key_hash_r != NULL)\n\t\t\t\t\tencryption_key_hash = i_strdup(fields[nfields-2]);\n\t\t\t} else {\n\t\t\t\tDCRYPT_SET_ERROR(\"Invalid dovecot v2 encoding\");\n\t\t\t\treturn FALSE;\n\t\t\t}\n\t\t} else {\n\t\t\tDCRYPT_SET_ERROR(\"Invalid dovecot key version\");\n\t\t\treturn FALSE;\n\t\t}\n\n\t\t/* last field is always key hash */\n\t\tif (key_hash_r != NULL)\n\t\t\tkey_hash = i_strdup(fields[nfields-1]);\n\t}\n\n\tif (format_r != NULL) *format_r = format;\n\tif (version_r != NULL) *version_r = version;\n\tif (encryption_type_r != NULL) *encryption_type_r = encryption_type;\n\tif (encryption_key_hash_r != NULL) {\n\t\t*encryption_key_hash_r = t_strdup(encryption_key_hash);\n\t\ti_free(encryption_key_hash);\n\t}\n\tif (kind_r != NULL) *kind_r = kind;\n\tif (key_hash_r != NULL) {\n\t\t*key_hash_r = t_strdup(key_hash);\n\t\ti_free(key_hash);\n\t}\n\treturn TRUE;\n}\n\nstatic void dcrypt_openssl_ref_public_key(struct dcrypt_public_key *key)\n{\n\ti_assert(key != NULL && key->ref > 0);\n\tkey->ref++;\n}\n\nstatic void dcrypt_openssl_ref_private_key(struct dcrypt_private_key *key)\n{\n\ti_assert(key != NULL && key->ref > 0);\n\tkey->ref++;\n}\n\nstatic void dcrypt_openssl_unref_public_key(struct dcrypt_public_key **key)\n{\n\ti_assert(key != NULL);\n\tstruct dcrypt_public_key *_key = *key;\n\tif (_key == NULL)\n\t\treturn;\n\ti_assert(_key->ref > 0);\n\t*key = NULL;\n\tif (--_key->ref > 0) return;\n\tEVP_PKEY_free(_key->key);\n\ti_free(_key->key_id);\n\ti_free(_key);\n}\n\nstatic void dcrypt_openssl_unref_private_key(struct dcrypt_private_key **key)\n{\n\ti_assert(key != NULL);\n\tstruct dcrypt_private_key *_key = *key;\n\tif (_key == NULL)\n\t\treturn;\n\ti_assert(_key->ref > 0);\n\t*key = NULL;\n\tif (--_key->ref > 0) return;\n\tEVP_PKEY_free(_key->key);\n\ti_free(_key->key_id);\n\ti_free(_key);\n}\n\nstatic void dcrypt_openssl_unref_keypair(struct dcrypt_keypair *keypair)\n{\n\ti_assert(keypair != NULL);\n\tdcrypt_openssl_unref_public_key(&keypair->pub);\n\tdcrypt_openssl_unref_private_key(&keypair->priv);\n}\n\nstatic bool\ndcrypt_openssl_rsa_encrypt(struct dcrypt_public_key *key,\n\t\t\t   const unsigned char *data, size_t data_len,\n\t\t\t   buffer_t *result, enum dcrypt_padding padding,\n\t\t\t   const char **error_r)\n{\n\ti_assert(key != NULL && key->key != NULL);\n\tint ec, pad = dcrypt_openssl_padding_mode(padding, FALSE, error_r);\n\tif (pad == -1)\n\t\treturn FALSE;\n\tEVP_PKEY_CTX *ctx = EVP_PKEY_CTX_new(key->key, NULL);\n\tsize_t outl = EVP_PKEY_size(key->key);\n\tunsigned char buf[outl];\n\n\tif (ctx == NULL ||\n\t    EVP_PKEY_encrypt_init(ctx) < 1 ||\n\t    EVP_PKEY_CTX_set_rsa_padding(ctx, pad) < 1 ||\n\t    EVP_PKEY_encrypt(ctx, buf, &outl, data, data_len) < 1) {\n\t\tdcrypt_openssl_error(error_r);\n\t\tec = -1;\n\t} else {\n\t\tbuffer_append(result, buf, outl);\n\t\tec = 0;\n\t}\n\n\tEVP_PKEY_CTX_free(ctx);\n\n\treturn ec == 0;\n}\n\nstatic bool\ndcrypt_openssl_rsa_decrypt(struct dcrypt_private_key *key,\n\t\t\t   const unsigned char *data, size_t data_len,\n\t\t\t   buffer_t *result, enum dcrypt_padding padding,\n\t\t\t   const char **error_r)\n{\n\ti_assert(key != NULL && key->key != NULL);\n\tint ec, pad = dcrypt_openssl_padding_mode(padding, FALSE, error_r);\n\tif (pad == -1)\n\t\treturn FALSE;\n\tEVP_PKEY_CTX *ctx = EVP_PKEY_CTX_new(key->key, NULL);\n\tsize_t outl = EVP_PKEY_size(key->key);\n\tunsigned char buf[outl];\n\n\tif (ctx == NULL ||\n\t    EVP_PKEY_decrypt_init(ctx) < 1 ||\n\t    EVP_PKEY_CTX_set_rsa_padding(ctx, pad) < 1 ||\n\t    EVP_PKEY_decrypt(ctx, buf, &outl, data, data_len) < 1) {\n\t\tdcrypt_openssl_error(error_r);\n\t\tec = -1;\n\t} else {\n\t\tbuffer_append(result, buf, outl);\n\t\tec = 0;\n\t}\n\n\tEVP_PKEY_CTX_free(ctx);\n\n\treturn ec == 0;\n}\n\nstatic const char *\ndcrypt_openssl_oid2name(const unsigned char *oid, size_t oid_len,\n\t\t\tconst char **error_r)\n{\n\tconst char *name;\n\ti_assert(oid != NULL);\n\tASN1_OBJECT *obj = d2i_ASN1_OBJECT(NULL, &oid, oid_len);\n\tif (obj == NULL) {\n\t\tdcrypt_openssl_error(error_r);\n\t\treturn NULL;\n\t}\n\tname = OBJ_nid2sn(OBJ_obj2nid(obj));\n\tASN1_OBJECT_free(obj);\n\treturn name;\n}\n\nstatic bool\ndcrypt_openssl_name2oid(const char *name, buffer_t *oid, const char **error_r)\n{\n\ti_assert(name != NULL);\n\tASN1_OBJECT *obj = OBJ_txt2obj(name, 0);\n\tif (obj == NULL)\n\t\treturn dcrypt_openssl_error(error_r);\n\n\tsize_t len = OBJ_length(obj);\n\tif (len == 0)\n\t{\n\t\tDCRYPT_SET_ERROR(\"Object has no OID assigned\");\n\t\treturn FALSE;\n\t}\n\tlen = i2d_ASN1_OBJECT(obj, NULL);\n\tunsigned char *bufptr = buffer_append_space_unsafe(oid, len);\n\ti2d_ASN1_OBJECT(obj, &bufptr);\n\tASN1_OBJECT_free(obj);\n\tif (bufptr != NULL) {\n\t\treturn TRUE;\n\t}\n\treturn dcrypt_openssl_error(error_r);\n}\n\nstatic enum dcrypt_key_type\ndcrypt_openssl_private_key_type(struct dcrypt_private_key *key)\n{\n\ti_assert(key != NULL && key->key != NULL);\n\tEVP_PKEY *priv = key->key;\n\tif (EVP_PKEY_base_id(priv) == EVP_PKEY_RSA) return DCRYPT_KEY_RSA;\n\telse if (EVP_PKEY_base_id(priv) == EVP_PKEY_EC) return DCRYPT_KEY_EC;\n\telse i_unreached();\n}\n\nstatic enum dcrypt_key_type\ndcrypt_openssl_public_key_type(struct dcrypt_public_key *key)\n{\n\ti_assert(key != NULL && key->key != NULL);\n\tEVP_PKEY *pub = key->key;\n\tif (EVP_PKEY_base_id(pub) == EVP_PKEY_RSA) return DCRYPT_KEY_RSA;\n\telse if (EVP_PKEY_base_id(pub) == EVP_PKEY_EC) return DCRYPT_KEY_EC;\n\telse i_unreached();\n}\n\n/** this is the v1 old legacy way of doing key id's **/\nstatic bool\ndcrypt_openssl_public_key_id_old(struct dcrypt_public_key *key,\n\t\t\t\t buffer_t *result, const char **error_r)\n{\n\tunsigned char buf[SHA256_DIGEST_LENGTH];\n\ti_assert(key != NULL && key->key != NULL);\n\tEVP_PKEY *pub = key->key;\n\n\tif (EVP_PKEY_base_id(pub) != EVP_PKEY_EC) {\n\t\tDCRYPT_SET_ERROR(\"Only EC key supported\");\n\t\treturn FALSE;\n\t}\n\n\tchar *pub_pt_hex = ec_key_get_pub_point_hex(EVP_PKEY_get0_EC_KEY(pub));\n\tif (pub_pt_hex == NULL)\n\t\treturn dcrypt_openssl_error(error_r);\n\t/* digest this */\n\tSHA256((const unsigned char*)pub_pt_hex, strlen(pub_pt_hex), buf);\n\tbuffer_append(result, buf, SHA256_DIGEST_LENGTH);\n\tOPENSSL_free(pub_pt_hex);\n\treturn TRUE;\n}\n\nstatic bool\ndcrypt_openssl_private_key_id_old(struct dcrypt_private_key *key,\n\t\t\t\t  buffer_t *result, const char **error_r)\n{\n\tunsigned char buf[SHA256_DIGEST_LENGTH];\n\ti_assert(key != NULL && key->key != NULL);\n\tEVP_PKEY *priv = key->key;\n\n\tif (EVP_PKEY_base_id(priv) != EVP_PKEY_EC) {\n\t\tDCRYPT_SET_ERROR(\"Only EC key supported\");\n\t\treturn FALSE;\n\t}\n\n\tchar *pub_pt_hex = ec_key_get_pub_point_hex(EVP_PKEY_get0_EC_KEY(priv));\n\tif (pub_pt_hex == NULL)\n\t\treturn dcrypt_openssl_error(error_r);\n\t/* digest this */\n\tSHA256((const unsigned char*)pub_pt_hex, strlen(pub_pt_hex), buf);\n\tbuffer_append(result, buf, SHA256_DIGEST_LENGTH);\n\tOPENSSL_free(pub_pt_hex);\n\treturn TRUE;\n}\n\n/** this is the new which uses H(der formatted public key) **/\nstatic bool\ndcrypt_openssl_public_key_id_evp(EVP_PKEY *key,\n\t\t\t\t const EVP_MD *md, buffer_t *result,\n\t\t\t\t const char **error_r)\n{\n\tbool res = FALSE;\n\tunsigned char buf[EVP_MD_size(md)], *ptr;\n\n\tif (EVP_PKEY_base_id(key) == EVP_PKEY_EC) {\n\t\tEC_KEY_set_conv_form(EVP_PKEY_get0_EC_KEY(key),\n\t\t\t\t     POINT_CONVERSION_COMPRESSED);\n\t}\n\tBIO *b = BIO_new(BIO_s_mem());\n\tif (b == NULL || i2d_PUBKEY_bio(b, key) < 1) {\n\t\tBIO_vfree(b);\n\t\treturn dcrypt_openssl_error(error_r);\n\t}\n\tlong len = BIO_get_mem_data(b, &ptr);\n\tunsigned int hlen = sizeof(buf);\n\t/* then hash it */\n\tEVP_MD_CTX *ctx = EVP_MD_CTX_new();\n\tif (ctx == NULL ||\n\t    EVP_DigestInit_ex(ctx, md, NULL) < 1 ||\n\t    EVP_DigestUpdate(ctx, (const unsigned char*)ptr, len) < 1 ||\n\t    EVP_DigestFinal_ex(ctx, buf, &hlen) < 1) {\n\t\tres = dcrypt_openssl_error(error_r);\n\t} else {\n\t\tbuffer_append(result, buf, hlen);\n\t\tres = TRUE;\n\t}\n\tEVP_MD_CTX_free(ctx);\n\tBIO_vfree(b);\n\n\treturn res;\n}\n\nstatic bool\ndcrypt_openssl_public_key_id(struct dcrypt_public_key *key,\n\t\t\t     const char *algorithm, buffer_t *result,\n\t\t\t     const char **error_r)\n{\n\tconst EVP_MD *md = EVP_get_digestbyname(algorithm);\n\ti_assert(key != NULL && key->key != NULL);\n\tEVP_PKEY *pub = key->key;\n\n\tif (md == NULL) {\n\t\tDCRYPT_SET_ERROR(t_strdup_printf(\"Unknown cipher %s\", algorithm));\n\t\treturn FALSE;\n\t}\n\n\treturn dcrypt_openssl_public_key_id_evp(pub, md, result, error_r);\n}\n\nstatic bool\ndcrypt_openssl_private_key_id(struct dcrypt_private_key *key,\n\t\t\t      const char *algorithm, buffer_t *result,\n\t\t\t      const char **error_r)\n{\n\tconst EVP_MD *md = EVP_get_digestbyname(algorithm);\n\ti_assert(key != NULL && key->key != NULL);\n\tEVP_PKEY *priv = key->key;\n\n\tif (md == NULL) {\n\t\tDCRYPT_SET_ERROR(t_strdup_printf(\"Unknown cipher %s\", algorithm));\n\t\treturn FALSE;\n\t}\n\n\treturn dcrypt_openssl_public_key_id_evp(priv, md, result, error_r);\n}\n\nstatic bool\ndcrypt_openssl_digest(const char *algorithm, const void *data, size_t data_len,\n\t\t      buffer_t *digest_r, const char **error_r)\n{\n\tbool ret;\n\tEVP_MD_CTX *mdctx;\n\tconst EVP_MD *md = EVP_get_digestbyname(algorithm);\n\tif (md == NULL)\n\t\treturn dcrypt_openssl_error(error_r);\n\tunsigned int md_size = EVP_MD_size(md);\n\tif ((mdctx = EVP_MD_CTX_create()) == NULL)\n\t\treturn dcrypt_openssl_error(error_r);\n\tunsigned char *buf = buffer_append_space_unsafe(digest_r, md_size);\n\tif (EVP_DigestInit_ex(mdctx, EVP_sha256(), NULL) != 1 ||\n\t    EVP_DigestUpdate(mdctx, data, data_len) != 1 ||\n\t    EVP_DigestFinal_ex(mdctx, buf, &md_size) != 1) {\n\t\tret = dcrypt_openssl_error(error_r);\n\t} else {\n\t\tret = TRUE;\n\t}\n\tEVP_MD_CTX_free(mdctx);\n\treturn ret;\n}\n\n#ifndef HAVE_ECDSA_SIG_GET0\nstatic void ECDSA_SIG_get0(const ECDSA_SIG *sig, const BIGNUM **pr, const BIGNUM **ps)\n{\n\ti_assert(sig != NULL);\n\t*pr = sig->r;\n\t*ps = sig->s;\n}\n#endif\n#ifndef HAVE_ECDSA_SIG_SET0\nstatic int ECDSA_SIG_set0(ECDSA_SIG *sig, BIGNUM *r, BIGNUM *s)\n{\n\tif (sig == NULL || r == NULL || s == NULL) {\n\t\tECDSAerr(0, ERR_R_PASSED_NULL_PARAMETER);\n\t\treturn 0;\n\t}\n\n\tBN_free(sig->r);\n\tsig->r = r;\n\tBN_free(sig->s);\n\tsig->s = s;\n\n\treturn 1;\n}\n#endif\n\nstatic bool\ndcrypt_openssl_sign_ecdsa(struct dcrypt_private_key *key, const char *algorithm,\n\t\t\t  const void *data, size_t data_len, buffer_t *signature_r,\n\t\t\t  const char **error_r)\n{\n\tEVP_PKEY *pkey = key->key;\n\tEC_KEY *ec_key = EVP_PKEY_get0_EC_KEY(pkey);\n\tbool ret;\n\tint rs_len = EC_GROUP_order_bits(EC_KEY_get0_group(ec_key)) / 8;\n\n\t/* digest data */\n\tbuffer_t *digest = t_buffer_create(64);\n\tif (!dcrypt_openssl_digest(algorithm, data, data_len, digest, error_r))\n\t\treturn FALSE;\n\n\t/* sign data */\n\tECDSA_SIG *ec_sig;\n\tif ((ec_sig = ECDSA_do_sign(digest->data, digest->used, ec_key)) == NULL)\n\t\treturn dcrypt_openssl_error(error_r);\n\n\t/* export signature */\n\tconst BIGNUM *r;\n\tconst BIGNUM *s;\n\n\tECDSA_SIG_get0(ec_sig, &r, &s);\n\n\tint r_len = BN_num_bytes(r);\n\ti_assert(rs_len >= r_len);\n\n\t/* write r */\n\tunsigned char *buf = buffer_append_space_unsafe(signature_r, rs_len);\n\tif (BN_bn2bin(r, buf + (rs_len - r_len)) != r_len) {\n\t\tret = dcrypt_openssl_error(error_r);\n\t} else {\n\t\tbuf = buffer_append_space_unsafe(signature_r, rs_len);\n\t\tint s_len = BN_num_bytes(s);\n\t\ti_assert(rs_len >= s_len);\n\t\tif (BN_bn2bin(s, buf + (rs_len - s_len)) != s_len) {\n\t\t\tret = dcrypt_openssl_error(error_r);\n\t\t} else {\n\t\t\tret = TRUE;\n\t\t}\n\t}\n\n\tECDSA_SIG_free(ec_sig);\n\n\treturn ret;\n}\n\nstatic bool\ndcrypt_openssl_sign(struct dcrypt_private_key *key, const char *algorithm,\n\t\t    enum dcrypt_signature_format format,\n\t\t    const void *data, size_t data_len, buffer_t *signature_r,\n\t\t    enum dcrypt_padding padding, const char **error_r)\n{\n\tswitch (format) {\n\tcase DCRYPT_SIGNATURE_FORMAT_DSS:\n\t\tbreak;\n\tcase DCRYPT_SIGNATURE_FORMAT_X962:\n\t\tif (EVP_PKEY_base_id(key->key) == EVP_PKEY_RSA) {\n\t\t\tDCRYPT_SET_ERROR(\"Format does not support RSA\");\n\t\t\treturn FALSE;\n\t\t}\n\t\treturn dcrypt_openssl_sign_ecdsa(key, algorithm,\n\t\t\t\tdata, data_len, signature_r, error_r);\n\tdefault:\n\t\ti_unreached();\n\t}\n\n\tEVP_PKEY_CTX *pctx = NULL;\n\tEVP_MD_CTX *dctx;\n\tbool ret;\n\tconst EVP_MD *md = EVP_get_digestbyname(algorithm);\n\tsize_t siglen;\n\tint pad = dcrypt_openssl_padding_mode(padding, TRUE, error_r);\n\n\tif (pad == -1)\n\t\treturn FALSE;\n\n\tif (md == NULL) {\n\t\tDCRYPT_SET_ERROR(t_strdup_printf(\"Unknown digest %s\", algorithm));\n\t\treturn FALSE;\n\t}\n\n\tdctx = EVP_MD_CTX_create();\n\n\t/* NB! Padding is set only on RSA signatures\n\t   ECDSA signatures use whatever is default */\n\tif (EVP_DigestSignInit(dctx, &pctx, md, NULL, key->key) != 1 ||\n\t    (EVP_PKEY_base_id(key->key) == EVP_PKEY_RSA &&\n\t     EVP_PKEY_CTX_set_rsa_padding(pctx, pad) != 1) ||\n\t    EVP_DigestSignUpdate(dctx, data, data_len) != 1 ||\n\t    EVP_DigestSignFinal(dctx, NULL, &siglen) != 1) {\n\t\tret = dcrypt_openssl_error(error_r);\n\t} else {\n\t\ti_assert(siglen > 0);\n\t\t/* @UNSAFE */\n\t\tunsigned char *buf =\n\t\t\tbuffer_append_space_unsafe(signature_r, siglen);\n\t\tif (EVP_DigestSignFinal(dctx, buf, &siglen) != 1) {\n\t\t\tret = dcrypt_openssl_error(error_r);\n\t\t} else {\n\t\t\tbuffer_set_used_size(signature_r, siglen);\n\t\t\tret = TRUE;\n\t\t}\n\t}\n\n\tEVP_MD_CTX_destroy(dctx);\n\n\treturn ret;\n}\n\nstatic bool\ndcrypt_openssl_verify_ecdsa(struct dcrypt_public_key *key, const char *algorithm,\n\t\t\t    const void *data, size_t data_len,\n\t\t\t    const unsigned char *signature, size_t signature_len,\n\t\t\t    bool *valid_r, const char **error_r)\n{\n        if ((signature_len % 2) != 0) {\n                DCRYPT_SET_ERROR(\"Truncated signature\");\n                return FALSE;\n        }\n\n\tEVP_PKEY *pkey = key->key;\n\tEC_KEY *ec_key = EVP_PKEY_get0_EC_KEY(pkey);\n\tint ec;\n\n\t/* digest data */\n\tbuffer_t *digest = t_buffer_create(64);\n\tif (!dcrypt_openssl_digest(algorithm, data, data_len, digest, error_r))\n\t\treturn FALSE;\n\n\tBIGNUM *r = BN_new();\n\tBIGNUM *s = BN_new();\n\t/* attempt to decode BIGNUMs */\n\tif (BN_bin2bn(signature, signature_len / 2, r) == NULL) {\n\t\tBN_free(r);\n\t\tBN_free(s);\n\t\treturn dcrypt_openssl_error(error_r);\n\t}\n\t/* then next */\n\tif (BN_bin2bn(CONST_PTR_OFFSET(signature, signature_len / 2),\n\t\t      signature_len / 2, s) == NULL) {\n\t\tBN_free(r);\n\t\tBN_free(s);\n\t\treturn dcrypt_openssl_error(error_r);\n\t}\n\n\t/* reconstruct signature */\n\tECDSA_SIG *ec_sig = ECDSA_SIG_new();\n\tECDSA_SIG_set0(ec_sig, r, s);\n\n\t/* verify it */\n\tec = ECDSA_do_verify(digest->data, digest->used, ec_sig, ec_key);\n\tECDSA_SIG_free(ec_sig);\n\n\tif (ec == 1) {\n\t\t*valid_r = TRUE;\n\t} else if (ec == 0) {\n\t\t*valid_r = FALSE;\n\t} else {\n\t\treturn dcrypt_openssl_error(error_r);\n\t}\n\treturn TRUE;\n}\n\nstatic bool\ndcrypt_openssl_verify(struct dcrypt_public_key *key, const char *algorithm,\n\t\t      enum dcrypt_signature_format format,\n\t\t      const void *data, size_t data_len,\n\t\t      const unsigned char *signature, size_t signature_len,\n\t\t      bool *valid_r, enum dcrypt_padding padding,\n\t\t      const char **error_r)\n{\n\tswitch (format) {\n\tcase DCRYPT_SIGNATURE_FORMAT_DSS:\n\t\tbreak;\n\tcase DCRYPT_SIGNATURE_FORMAT_X962:\n\t\tif (EVP_PKEY_base_id(key->key) == EVP_PKEY_RSA) {\n\t\t\tDCRYPT_SET_ERROR(\"Format does not support RSA\");\n\t\t\treturn FALSE;\n\t\t}\n\t\treturn dcrypt_openssl_verify_ecdsa(key, algorithm,\n\t\t\t\tdata, data_len, signature, signature_len,\n\t\t\t\tvalid_r, error_r);\n\tdefault:\n\t\ti_unreached();\n\t}\n\n\tEVP_PKEY_CTX *pctx = NULL;\n\tEVP_MD_CTX *dctx;\n\tbool ret;\n\tconst EVP_MD *md = EVP_get_digestbyname(algorithm);\n\tint rc, pad = dcrypt_openssl_padding_mode(padding, TRUE, error_r);\n\n\tif (pad == -1)\n\t\treturn FALSE;\n\n\tif (md == NULL) {\n\t\tDCRYPT_SET_ERROR(t_strdup_printf(\"Unknown digest %s\", algorithm));\n\t\treturn FALSE;\n\t}\n\n\tdctx = EVP_MD_CTX_create();\n\n\t/* NB! Padding is set only on RSA signatures\n\t   ECDSA signatures use whatever is default */\n\tif (EVP_DigestVerifyInit(dctx, &pctx, md, NULL, key->key) != 1 ||\n\t    (EVP_PKEY_base_id(key->key) == EVP_PKEY_RSA &&\n\t     EVP_PKEY_CTX_set_rsa_padding(pctx, pad) != 1) ||\n\t    EVP_DigestVerifyUpdate(dctx, data, data_len) != 1 ||\n\t    (rc = EVP_DigestVerifyFinal(dctx, signature, signature_len)) < 0) {\n\t\tret = dcrypt_openssl_error(error_r);\n\t} else {\n\t\t/* return code 1 means valid signature, otherwise invalid */\n\t\t*valid_r = (rc == 1);\n\t\tret = TRUE;\n\t}\n\n\tEVP_MD_CTX_destroy(dctx);\n\n\treturn ret;\n}\n\nstatic bool\ndcrypt_openssl_key_store_private_raw(struct dcrypt_private_key *key,\n\t\t\t\t     pool_t pool,\n\t\t\t\t     enum dcrypt_key_type *type_r,\n\t\t\t\t     ARRAY_TYPE(dcrypt_raw_key) *keys_r,\n\t\t\t\t     const char **error_r)\n{\n\ti_assert(key != NULL && key->key != NULL);\n\ti_assert(array_is_created(keys_r));\n\tEVP_PKEY *priv = key->key;\n\tARRAY_TYPE(dcrypt_raw_key) keys;\n\tt_array_init(&keys, 2);\n\n\tif (EVP_PKEY_base_id(priv) == EVP_PKEY_RSA) {\n\t\tDCRYPT_SET_ERROR(\"Not implemented\");\n\t\treturn FALSE;\n\t} else if (EVP_PKEY_base_id(priv) == EVP_PKEY_EC) {\n\t\t/* store OID */\n\t\tEC_KEY *key = EVP_PKEY_get0_EC_KEY(priv);\n\t\tEC_KEY_set_conv_form(key, POINT_CONVERSION_UNCOMPRESSED);\n\t\tint nid = EC_GROUP_get_curve_name(EC_KEY_get0_group(key));\n\t\tASN1_OBJECT *obj = OBJ_nid2obj(nid);\n\t\tint len = OBJ_length(obj);\n\t\tif (len == 0) {\n\t\t\tDCRYPT_SET_ERROR(\"Object has no OID assigned\");\n\t\t\treturn FALSE;\n\t\t}\n\t\tlen = i2d_ASN1_OBJECT(obj, NULL);\n\t\tunsigned char *bufptr = p_malloc(pool, len);\n\t\tstruct dcrypt_raw_key *item = array_append_space(&keys);\n\t\titem->parameter = bufptr;\n\t\titem->len = i2d_ASN1_OBJECT(obj, &bufptr);\n\t\tASN1_OBJECT_free(obj);\n\t\t/* store private key */\n\t\tconst BIGNUM *b = EC_KEY_get0_private_key(key);\n\t\tlen = BN_num_bytes(b);\n\t\titem = array_append_space(&keys);\n\t\tbufptr = p_malloc(pool, len);\n\t\tif (BN_bn2bin(b, bufptr) < len)\n\t\t\treturn dcrypt_openssl_error(error_r);\n\t\titem->parameter = bufptr;\n\t\titem->len = len;\n\t\t*type_r = DCRYPT_KEY_EC;\n\t} else {\n\t\tDCRYPT_SET_ERROR(\"Key type unsupported\");\n\t\treturn FALSE;\n\t}\n\n\tarray_append_array(keys_r, &keys);\n\treturn TRUE;\n}\n\nstatic bool\ndcrypt_openssl_key_store_public_raw(struct dcrypt_public_key *key,\n\t\t\t\t    pool_t pool,\n\t\t\t\t    enum dcrypt_key_type *type_r,\n\t\t\t\t    ARRAY_TYPE(dcrypt_raw_key) *keys_r,\n\t\t\t\t    const char **error_r)\n{\n\ti_assert(key != NULL && key->key != NULL);\n\tEVP_PKEY *pub = key->key;\n\tARRAY_TYPE(dcrypt_raw_key) keys;\n\tt_array_init(&keys, 2);\n\n\tif (EVP_PKEY_base_id(pub) == EVP_PKEY_RSA) {\n\t\tDCRYPT_SET_ERROR(\"Not implemented\");\n\t\treturn FALSE;\n\t} else if (EVP_PKEY_base_id(pub) == EVP_PKEY_EC) {\n\t\t/* store OID */\n\t\tEC_KEY *key = EVP_PKEY_get0_EC_KEY(pub);\n\t\tEC_KEY_set_conv_form(key, POINT_CONVERSION_UNCOMPRESSED);\n\t\tint nid = EC_GROUP_get_curve_name(EC_KEY_get0_group(key));\n\t\tASN1_OBJECT *obj = OBJ_nid2obj(nid);\n\t\tint len = OBJ_length(obj);\n\t\tif (len == 0) {\n\t\t\tDCRYPT_SET_ERROR(\"Object has no OID assigned\");\n\t\t\treturn FALSE;\n\t\t}\n\t\tlen = i2d_ASN1_OBJECT(obj, NULL);\n\t\tunsigned char *bufptr = p_malloc(pool, len);\n\t\tstruct dcrypt_raw_key *item = array_append_space(&keys);\n\t\titem->parameter = bufptr;\n\t\titem->len = i2d_ASN1_OBJECT(obj, &bufptr);\n\t\tASN1_OBJECT_free(obj);\n\n\t\t/* store public key */\n\t\tconst EC_POINT *point = EC_KEY_get0_public_key(key);\n\t\tlen = EC_POINT_point2oct(EC_KEY_get0_group(key), point,\n\t\t\t\t\t POINT_CONVERSION_UNCOMPRESSED,\n\t\t\t\t\t NULL, 0, NULL);\n\t\tbufptr = p_malloc(pool, len);\n\t\titem = array_append_space(&keys);\n\t\titem->parameter = bufptr;\n\t\titem->len = len;\n\t\tif (EC_POINT_point2oct(EC_KEY_get0_group(key), point,\n\t\t\t\t       POINT_CONVERSION_UNCOMPRESSED,\n\t\t\t\t       bufptr, len, NULL) < (unsigned int)len)\n\t\t\treturn dcrypt_openssl_error(error_r);\n\t\t*type_r = DCRYPT_KEY_EC;\n\t} else {\n\t\tDCRYPT_SET_ERROR(\"Key type unsupported\");\n\t\treturn FALSE;\n\t}\n\n\tarray_append_array(keys_r, &keys);\n\n\treturn TRUE;\n}\n\nstatic bool\ndcrypt_openssl_key_load_private_raw(struct dcrypt_private_key **key_r,\n\t\t\t\t    enum dcrypt_key_type type,\n\t\t\t\t    const ARRAY_TYPE(dcrypt_raw_key) *keys,\n\t\t\t\t    const char **error_r)\n{\n\tint ec;\n\ti_assert(keys != NULL && array_is_created(keys) && array_count(keys) > 1);\n\tconst struct dcrypt_raw_key *item;\n\n\tif (type == DCRYPT_KEY_RSA) {\n\t\tDCRYPT_SET_ERROR(\"Not implemented\");\n\t\treturn FALSE;\n\t} else if (type == DCRYPT_KEY_EC) {\n\t\t/* get curve */\n\t\tif (array_count(keys) < 2) {\n\t\t\tDCRYPT_SET_ERROR(\"Invalid parameters\");\n\t\t\treturn FALSE;\n\t\t}\n\t\titem = array_idx(keys, 0);\n\t\tconst unsigned char *oid = item->parameter;\n\t\tASN1_OBJECT *obj = d2i_ASN1_OBJECT(NULL, &oid, item->len);\n\t\tif (obj == NULL)\n\t\t\treturn dcrypt_openssl_error(error_r);\n\t\tint nid = OBJ_obj2nid(obj);\n\t\tASN1_OBJECT_free(obj);\n\n\t\t/* load private point */\n\t\titem = array_idx(keys, 1);\n\t\tBIGNUM *bn = BN_secure_new();\n\t\tif (BN_bin2bn(item->parameter, item->len, bn) == NULL) {\n\t\t\tBN_free(bn);\n\t\t\treturn dcrypt_openssl_error(error_r);\n\t\t}\n\n\t\t/* setup a key */\n\t\tEC_KEY *key = EC_KEY_new_by_curve_name(nid);\n\t\tec = EC_KEY_set_private_key(key, bn);\n\t\tBN_free(bn);\n\n\t\tif (ec != 1) {\n\t\t\tEC_KEY_free(key);\n\t\t\treturn dcrypt_openssl_error(error_r);\n\t\t}\n\n\t\t/* calculate & assign public key */\n\t\tEC_POINT *pub = EC_POINT_new(EC_KEY_get0_group(key));\n\t\tif (pub == NULL) {\n\t\t\tEC_KEY_free(key);\n\t\t\treturn dcrypt_openssl_error(error_r);\n\t\t}\n\t\t/* calculate public key */\n\t\tec = EC_POINT_mul(EC_KEY_get0_group(key), pub,\n\t\t\t\t  EC_KEY_get0_private_key(key),\n\t\t\t\t  NULL, NULL, NULL);\n\t\tif (ec == 1)\n\t\t\tec = EC_KEY_set_public_key(key, pub);\n\t\tEC_POINT_free(pub);\n\n\t\t/* check the key */\n\t\tif (ec != 1 || EC_KEY_check_key(key) != 1) {\n\t\t\tEC_KEY_free(key);\n\t\t\treturn dcrypt_openssl_error(error_r);\n\t\t}\n\t\tEC_KEY_set_asn1_flag(key, OPENSSL_EC_NAMED_CURVE);\n\n\t\tEVP_PKEY *pkey = EVP_PKEY_new();\n\t\tEVP_PKEY_set1_EC_KEY(pkey, key);\n\t\tEC_KEY_free(key);\n\t\t*key_r = i_new(struct dcrypt_private_key, 1);\n\t\t(*key_r)->key = pkey;\n\t\t(*key_r)->ref++;\n\t\treturn TRUE;\n\t} else {\n\t\tDCRYPT_SET_ERROR(\"Key type unsupported\");\n\t}\n\n\treturn FALSE;\n}\n\nstatic bool\ndcrypt_openssl_key_load_public_raw(struct dcrypt_public_key **key_r,\n\t\t\t\t   enum dcrypt_key_type type,\n\t\t\t\t   const ARRAY_TYPE(dcrypt_raw_key) *keys,\n\t\t\t\t   const char **error_r)\n{\n\tint ec;\n\ti_assert(keys != NULL && array_is_created(keys) && array_count(keys) > 1);\n\tconst struct dcrypt_raw_key *item;\n\n\tif (type == DCRYPT_KEY_RSA) {\n\t\tDCRYPT_SET_ERROR(\"Not implemented\");\n\t\treturn FALSE;\n\t} else if (type == DCRYPT_KEY_EC) {\n\t\t/* get curve */\n\t\tif (array_count(keys) < 2) {\n\t\t\tDCRYPT_SET_ERROR(\"Invalid parameters\");\n\t\t\treturn FALSE;\n\t\t}\n\t\titem = array_idx(keys, 0);\n\t\tconst unsigned char *oid = item->parameter;\n\t\tASN1_OBJECT *obj = d2i_ASN1_OBJECT(NULL, &oid, item->len);\n\t\tif (obj == NULL) {\n\t\t\tdcrypt_openssl_error(error_r);\n\t\t\treturn FALSE;\n\t\t}\n\t\tint nid = OBJ_obj2nid(obj);\n\t\tASN1_OBJECT_free(obj);\n\n\t\t/* set group */\n\t\tEC_GROUP *group = EC_GROUP_new_by_curve_name(nid);\n\t\tif (group == NULL) {\n\t\t\tdcrypt_openssl_error(error_r);\n\t\t\treturn FALSE;\n\t\t}\n\n\t\t/* load point */\n\t\titem = array_idx(keys, 1);\n\t\tEC_POINT *point = EC_POINT_new(group);\n\t\tif (EC_POINT_oct2point(group, point, item->parameter,\n\t\t\t\t       item->len, NULL) != 1) {\n\t\t\tEC_POINT_free(point);\n\t\t\tEC_GROUP_free(group);\n\t\t\treturn dcrypt_openssl_error(error_r);\n\t\t}\n\n\t\tEC_KEY *key = EC_KEY_new();\n\t\tec = EC_KEY_set_group(key, group);\n\t\tif (ec == 1)\n\t\t\tec = EC_KEY_set_public_key(key, point);\n\t\tEC_POINT_free(point);\n\t\tEC_GROUP_free(group);\n\n\t\tif (ec != 1 || EC_KEY_check_key(key) != 1) {\n\t\t\tEC_KEY_free(key);\n\t\t\treturn dcrypt_openssl_error(error_r);\n\t\t}\n\n\t\tEC_KEY_precompute_mult(key, NULL);\n\t\tEC_KEY_set_asn1_flag(key, OPENSSL_EC_NAMED_CURVE);\n\t\tEVP_PKEY *pkey = EVP_PKEY_new();\n\t\tEVP_PKEY_set1_EC_KEY(pkey, key);\n\t\tEC_KEY_free(key);\n\t\t*key_r = i_new(struct dcrypt_public_key, 1);\n\t\t(*key_r)->key = pkey;\n\t\t(*key_r)->ref++;\n\t\treturn TRUE;\n\t} else {\n\t\tDCRYPT_SET_ERROR(\"Key type unsupported\");\n\t}\n\n\treturn FALSE;\n}\n\nstatic bool\ndcrypt_openssl_key_get_curve_public(struct dcrypt_public_key *key,\n\t\t\t\t    const char **curve_r, const char **error_r)\n{\n\tEVP_PKEY *pkey = key->key;\n\tchar objtxt[OID_TEXT_MAX_LEN];\n\n\tif (EVP_PKEY_base_id(pkey) != EVP_PKEY_EC) {\n\t\tDCRYPT_SET_ERROR(\"Unsupported key type\");\n\t\treturn FALSE;\n\t}\n\n\tASN1_OBJECT *obj = OBJ_nid2obj(EC_GROUP_get_curve_name(\n\t\t\t\tEC_KEY_get0_group(EVP_PKEY_get0_EC_KEY(pkey))));\n\n\tint len = OBJ_obj2txt(objtxt, sizeof(objtxt), obj, 1);\n\tASN1_OBJECT_free(obj);\n\n\tif (len < 1) {\n\t\treturn dcrypt_openssl_error(error_r);\n\t} else if ((unsigned int)len > sizeof(objtxt)) {\n\t\tDCRYPT_SET_ERROR(\"Object name too long\");\n\t\treturn FALSE;\n\t}\n\n\t*curve_r = t_strndup(objtxt, len);\n\treturn TRUE;\n}\n\nstatic const char *\ndcrypt_openssl_key_get_id_public(struct dcrypt_public_key *key)\n{\n\treturn key->key_id;\n}\n\nstatic const char *\ndcrypt_openssl_key_get_id_private(struct dcrypt_private_key *key)\n{\n\treturn key->key_id;\n}\n\nstatic void\ndcrypt_openssl_key_set_id_public(struct dcrypt_public_key *key, const char *id)\n{\n\ti_free(key->key_id);\n\tkey->key_id = i_strdup_empty(id);\n}\n\nstatic void\ndcrypt_openssl_key_set_id_private(struct dcrypt_private_key *key, const char *id)\n{\n\ti_free(key->key_id);\n\tkey->key_id = i_strdup_empty(id);\n}\n\nstatic enum dcrypt_key_usage\ndcrypt_openssl_key_get_usage_public(struct dcrypt_public_key *key)\n{\n\treturn key->usage;\n}\n\nstatic enum dcrypt_key_usage\ndcrypt_openssl_key_get_usage_private(struct dcrypt_private_key *key)\n{\n\treturn key->usage;\n}\n\nstatic void\ndcrypt_openssl_key_set_usage_public(struct dcrypt_public_key *key,\n\t\t\t\t    enum dcrypt_key_usage usage)\n{\n\tkey->usage = usage;\n}\n\nstatic void\ndcrypt_openssl_key_set_usage_private(struct dcrypt_private_key *key,\n\t\t\t\t     enum dcrypt_key_usage usage)\n{\n\tkey->usage = usage;\n}\n\n\nstatic struct dcrypt_vfs dcrypt_openssl_vfs = {\n\t.initialize = dcrypt_openssl_initialize,\n\t.ctx_sym_create = dcrypt_openssl_ctx_sym_create,\n\t.ctx_sym_destroy = dcrypt_openssl_ctx_sym_destroy,\n\t.ctx_sym_set_key = dcrypt_openssl_ctx_sym_set_key,\n\t.ctx_sym_set_iv = dcrypt_openssl_ctx_sym_set_iv,\n\t.ctx_sym_set_key_iv_random = dcrypt_openssl_ctx_sym_set_key_iv_random,\n\t.ctx_sym_set_padding = dcrypt_openssl_ctx_sym_set_padding,\n\t.ctx_sym_get_key = dcrypt_openssl_ctx_sym_get_key,\n\t.ctx_sym_get_iv = dcrypt_openssl_ctx_sym_get_iv,\n\t.ctx_sym_set_aad = dcrypt_openssl_ctx_sym_set_aad,\n\t.ctx_sym_get_aad = dcrypt_openssl_ctx_sym_get_aad,\n\t.ctx_sym_set_tag = dcrypt_openssl_ctx_sym_set_tag,\n\t.ctx_sym_get_tag = dcrypt_openssl_ctx_sym_get_tag,\n\t.ctx_sym_get_key_length = dcrypt_openssl_ctx_sym_get_key_length,\n\t.ctx_sym_get_iv_length = dcrypt_openssl_ctx_sym_get_iv_length,\n\t.ctx_sym_get_block_size = dcrypt_openssl_ctx_sym_get_block_size,\n\t.ctx_sym_init = dcrypt_openssl_ctx_sym_init,\n\t.ctx_sym_update = dcrypt_openssl_ctx_sym_update,\n\t.ctx_sym_final = dcrypt_openssl_ctx_sym_final,\n\t.ctx_hmac_create = dcrypt_openssl_ctx_hmac_create,\n\t.ctx_hmac_destroy = dcrypt_openssl_ctx_hmac_destroy,\n\t.ctx_hmac_set_key = dcrypt_openssl_ctx_hmac_set_key,\n\t.ctx_hmac_set_key_random = dcrypt_openssl_ctx_hmac_set_key_random,\n\t.ctx_hmac_get_digest_length = dcrypt_openssl_ctx_hmac_get_digest_length,\n\t.ctx_hmac_get_key = dcrypt_openssl_ctx_hmac_get_key,\n\t.ctx_hmac_init = dcrypt_openssl_ctx_hmac_init,\n\t.ctx_hmac_update = dcrypt_openssl_ctx_hmac_update,\n\t.ctx_hmac_final = dcrypt_openssl_ctx_hmac_final,\n\t.ecdh_derive_secret_local = dcrypt_openssl_ecdh_derive_secret_local,\n\t.ecdh_derive_secret_peer = dcrypt_openssl_ecdh_derive_secret_peer,\n\t.pbkdf2 = dcrypt_openssl_pbkdf2,\n\t.generate_keypair = dcrypt_openssl_generate_keypair,\n\t.load_private_key = dcrypt_openssl_load_private_key,\n\t.load_public_key = dcrypt_openssl_load_public_key,\n\t.store_private_key = dcrypt_openssl_store_private_key,\n\t.store_public_key = dcrypt_openssl_store_public_key,\n\t.private_to_public_key = dcrypt_openssl_private_to_public_key,\n\t.key_string_get_info = dcrypt_openssl_key_string_get_info,\n\t.unref_keypair = dcrypt_openssl_unref_keypair,\n\t.unref_public_key = dcrypt_openssl_unref_public_key,\n\t.unref_private_key = dcrypt_openssl_unref_private_key,\n\t.ref_public_key = dcrypt_openssl_ref_public_key,\n\t.ref_private_key = dcrypt_openssl_ref_private_key,\n\t.rsa_encrypt = dcrypt_openssl_rsa_encrypt,\n\t.rsa_decrypt = dcrypt_openssl_rsa_decrypt,\n\t.oid2name = dcrypt_openssl_oid2name,\n\t.name2oid = dcrypt_openssl_name2oid,\n\t.private_key_type = dcrypt_openssl_private_key_type,\n\t.public_key_type = dcrypt_openssl_public_key_type,\n\t.public_key_id = dcrypt_openssl_public_key_id,\n\t.public_key_id_old = dcrypt_openssl_public_key_id_old,\n\t.private_key_id = dcrypt_openssl_private_key_id,\n\t.private_key_id_old = dcrypt_openssl_private_key_id_old,\n\t.key_store_private_raw = dcrypt_openssl_key_store_private_raw,\n\t.key_store_public_raw = dcrypt_openssl_key_store_public_raw,\n\t.key_load_private_raw = dcrypt_openssl_key_load_private_raw,\n\t.key_load_public_raw = dcrypt_openssl_key_load_public_raw,\n\t.key_get_curve_public = dcrypt_openssl_key_get_curve_public,\n\t.key_get_id_public = dcrypt_openssl_key_get_id_public,\n\t.key_get_id_private = dcrypt_openssl_key_get_id_private,\n\t.key_set_id_public = dcrypt_openssl_key_set_id_public,\n\t.key_set_id_private = dcrypt_openssl_key_set_id_private,\n\t.key_get_usage_public = dcrypt_openssl_key_get_usage_public,\n\t.key_get_usage_private = dcrypt_openssl_key_get_usage_private,\n\t.key_set_usage_public = dcrypt_openssl_key_set_usage_public,\n\t.key_set_usage_private = dcrypt_openssl_key_set_usage_private,\n\t.sign = dcrypt_openssl_sign,\n\t.verify = dcrypt_openssl_verify,\n\t.ecdh_derive_secret = dcrypt_openssl_ecdh_derive_secret,\n};\n\nvoid dcrypt_openssl_init(struct module *module ATTR_UNUSED)\n{\n\tdovecot_openssl_common_global_ref();\n\tdcrypt_set_vfs(&dcrypt_openssl_vfs);\n}\n\nvoid dcrypt_openssl_deinit(void)\n{\n\tdovecot_openssl_common_global_unref();\n}\n"}, "2": {"id": 2, "path": "/home/runner/work/testcc/testcc/retdec/src/lib/mempool.h", "content": "#ifndef MEMPOOL_H\n#define MEMPOOL_H\n\n#include \"macros.h\"\n\n/* When DEBUG is enabled, Dovecot warns whenever a memory pool is grown.\n   This is done so that the initial pool size could be set large enough so that\n   it wouldn't grow in normal use. For some memory pools it's too difficult\n   to calculate a good initial size, so this prefix should be used with those\n   pools to disable the warning. */\n#define MEMPOOL_GROWING \"GROWING-\"\n\n/* The maximum allocation size that's allowed.  Anything larger than that\n   will panic.  No pool ever should need more than 4kB of overhead per\n   allocation. */\n#define POOL_MAX_ALLOC_SIZE\t(SSIZE_T_MAX - 4096)\n\n/* Memory allocated and reallocated (the new data in it) in pools is always\n   zeroed, it will cost only a few CPU cycles and may well save some debug\n   time. */\n\ntypedef struct pool *pool_t;\n\nstruct pool_vfuncs {\n\tconst char *(*get_name)(pool_t pool);\n\n\tvoid (*ref)(pool_t pool);\n\tvoid (*unref)(pool_t *pool);\n\n\tvoid *(*malloc)(pool_t pool, size_t size) ATTR_RETURNS_NONNULL;\n\tvoid (*free)(pool_t pool, void *mem);\n\n\t/* memory in old_size..new_size will be zeroed */\n\tvoid *(*realloc)(pool_t pool, void *mem,\n\t\t\t size_t old_size, size_t new_size)\n\t\tATTR_WARN_UNUSED_RESULT ATTR_RETURNS_NONNULL;\n\n\t/* Frees all the memory in pool. NOTE: system_pool doesn't support\n\t   this and crashes if it's used */\n\tvoid (*clear)(pool_t pool);\n\n\t/* Returns the maximum amount of bytes that can be allocated with\n\t   minimal trouble. If there's no such concept, always returns 0. */\n\tsize_t (*get_max_easy_alloc_size)(pool_t pool);\n};\n\nstruct pool {\n\tconst struct pool_vfuncs *v;\n\n\tbool alloconly_pool:1;\n\tbool datastack_pool:1;\n};\n\n/* system_pool uses calloc() + realloc() + free() */\nextern pool_t system_pool;\nextern struct pool static_system_pool;\n\n/* memory allocated from data_stack is valid only until next t_pop() call.\n   No checks are performed. */\nextern pool_t unsafe_data_stack_pool;\n\n/* Create a new alloc-only pool. Note that `size' specifies the initial\n   malloc()ed block size, part of it is used internally. */\npool_t pool_alloconly_create(const char *name, size_t size);\n/* Like alloconly pool, but clear the memory before freeing it. The idea is\n   that you could allocate memory for storing sensitive information from this\n   pool, and be sure that it gets cleared from the memory when it's no longer\n   needed. */\npool_t pool_alloconly_create_clean(const char *name, size_t size);\n\n/* When allocating memory from returned pool, the data stack frame must be\n   the same as it was when calling this function. pool_unref() also checks\n   that the stack frame is the same. This should make it quite safe to use. */\npool_t pool_datastack_create(void);\n\n/* Create new alloc pool. This is very similar to system pool, but it\n   will deallocate all memory on deinit. */\npool_t pool_allocfree_create(const char *name);\n\n/* Like alloc pool, but all memory is cleaned before freeing.\n   See pool_alloconly_create_clean. */\npool_t pool_allocfree_create_clean(const char *name);\n\n/* Similar to nearest_power(), but try not to exceed buffer's easy\n   allocation size. If you don't have any explicit minimum size, use\n   old_size + 1. */\nsize_t pool_get_exp_grown_size(pool_t pool, size_t old_size, size_t min_size);\n\n/* We require sizeof(type) to be <= UINT_MAX. This allows compiler to optimize\n   away the entire MALLOC_MULTIPLY() call on 64bit systems. */\n#define p_new(pool, type, count) \\\n\t((type *) p_malloc(pool, MALLOC_MULTIPLY((unsigned int)sizeof(type), (count))) + \\\n\t COMPILE_ERROR_IF_TRUE(sizeof(type) > UINT_MAX))\n\n#define p_realloc_type(pool, mem, type, old_count, new_count) \\\n\t((type *) p_realloc(pool, mem, \\\n\t MALLOC_MULTIPLY((unsigned int)sizeof(type), (old_count)), \\\n\t MALLOC_MULTIPLY((unsigned int)sizeof(type), (new_count))) + \\\n\t\tCOMPILE_ERROR_IF_TRUE(sizeof(type) > UINT_MAX))\n\nstatic inline void * ATTR_MALLOC ATTR_RETURNS_NONNULL\np_malloc(pool_t pool, size_t size)\n{\n\tif (unlikely(size == 0 || size > POOL_MAX_ALLOC_SIZE))\n\t\ti_panic(\"Trying to allocate %zu bytes\", size);\n\n\treturn pool->v->malloc(pool, size);\n}\n\nstatic inline void * ATTR_WARN_UNUSED_RESULT ATTR_RETURNS_NONNULL\np_realloc(pool_t pool, void *mem, size_t old_size, size_t new_size)\n{\n\tif (unlikely(new_size == 0 || new_size > POOL_MAX_ALLOC_SIZE))\n\t\ti_panic(\"Trying to reallocate %zu -> %zu bytes\",\n\t\t\told_size, new_size);\n\n\tif (mem == NULL)\n\t\treturn pool->v->malloc(pool, new_size);\n\n\treturn pool->v->realloc(pool, mem, old_size, new_size);\n}\n\n/* Free the memory. p_free() and p_free_and_null() are now guaranteed to both\n   set mem=NULL, so either one of them can be used. */\n#define p_free(pool, mem) \\\n\tSTMT_START { \\\n\t\tp_free_internal(pool, mem);\t\\\n\t\t(mem) = NULL;\t\t\t\\\n\t} STMT_END\n#define p_free_and_null(pool, mem) p_free(pool, mem)\n\nstatic inline void p_free_internal(pool_t pool, void *mem)\n{\n\tif (mem != NULL)\n\t\tpool->v->free(pool, mem);\n}\n\nstatic inline void p_clear(pool_t pool)\n{\n\tpool->v->clear(pool);\n}\n\nstatic inline size_t p_get_max_easy_alloc_size(pool_t pool)\n{\n\treturn pool->v->get_max_easy_alloc_size(pool);\n}\n\nstatic inline const char *pool_get_name(pool_t pool)\n{\n\treturn pool->v->get_name(pool);\n}\n\nstatic inline void pool_ref(pool_t pool)\n{\n\tpool->v->ref(pool);\n}\n\nstatic inline void pool_unref(pool_t *pool)\n{\n\tif (*pool != NULL)\n\t\t(*pool)->v->unref(pool);\n}\n\n/* These functions are only for pools created with pool_alloconly_create(): */\n\n/* Returns how much memory has been allocated from this pool. */\nsize_t pool_alloconly_get_total_used_size(pool_t pool);\n/* Returns how much system memory has been allocated for this pool. */\nsize_t pool_alloconly_get_total_alloc_size(pool_t pool);\n\n/* Returns how much memory has been allocated from this pool. */\nsize_t pool_allocfree_get_total_used_size(pool_t pool);\n/* Returns how much system memory has been allocated for this pool. */\nsize_t pool_allocfree_get_total_alloc_size(pool_t pool);\n\n/* private: */\nvoid pool_system_free(pool_t pool, void *mem);\n\n#endif\n"}, "3": {"id": 3, "path": "/home/runner/work/testcc/testcc/retdec/src/lib/malloc-overflow.h", "content": "#ifndef MALLOC_OVERFLOW_H\n#define MALLOC_OVERFLOW_H\n\n/* MALLOC_*() can be used to calculate memory allocation sizes. If there's an\n   overflow, it'll cleanly panic instead of causing a potential buffer\n   overflow.\n\n   Note that *_malloc(size+1) doesn't need to use MALLOC_ADD(size, 1). It wraps\n   to size==0 and the *_malloc() calls already panic if size==0. */\nstatic inline size_t\nmalloc_multiply_check(size_t a, size_t b, size_t sizeof_a, size_t sizeof_b,\n\t\t      const char *fname, unsigned int linenum)\n{\n\t/* the first sizeof-checks are intended to optimize away this entire\n\t   if-check for types that are small enough to never wrap size_t. */\n\tif ((sizeof_a * 2 > sizeof(size_t) || sizeof_b * 2 > sizeof(size_t)) &&\n\t    b != 0 && (a > SIZE_MAX / b)) {\n\t\ti_panic(\"file %s: line %d: memory allocation overflow: %zu * %zu\",\n\t\t\tfname, linenum, a, b);\n\t}\n\treturn a * b;\n}\n#ifndef STATIC_CHECKER\n#  define MALLOC_MULTIPLY(a, b) \\\n\tmalloc_multiply_check(a, b, sizeof(a), sizeof(b), __FILE__, __LINE__)\n#else\n/* avoid warning every time about sizeof(b) when b contains any arithmetic */\n#  define MALLOC_MULTIPLY(a, b) \\\n\tmalloc_multiply_check(a, b, sizeof(a), sizeof(size_t), __FILE__, __LINE__)\n#endif\n\nstatic inline size_t\nmalloc_add_check(size_t a, size_t b, size_t sizeof_a, size_t sizeof_b,\n\t\t const char *fname, unsigned int linenum)\n{\n\t/* the first sizeof-checks are intended to optimize away this entire\n\t   if-check for types that are small enough to never wrap size_t. */\n\tif ((sizeof_a >= sizeof(size_t) || sizeof_b >= sizeof(size_t)) &&\n\t    SIZE_MAX - a < b) {\n\t\ti_panic(\"file %s: line %d: memory allocation overflow: %zu + %zu\",\n\t\t\tfname, linenum, a, b);\n\t}\n\treturn a + b;\n}\n#ifndef STATIC_CHECKER\n#  define MALLOC_ADD(a, b) \\\n\tmalloc_add_check(a, b, sizeof(a), sizeof(b), __FILE__, __LINE__)\n#else\n/* avoid warning every time about sizeof(b) when b contains any arithmetic */\n#  define MALLOC_ADD(a, b) \\\n\tmalloc_add_check(a, b, sizeof(a), sizeof(size_t), __FILE__, __LINE__)\n#endif\n\n#endif\n"}, "4": {"id": 4, "path": "/usr/include/openssl/ec.h", "content": "/*\n * Copyright 2002-2019 The OpenSSL Project Authors. All Rights Reserved.\n * Copyright (c) 2002, Oracle and/or its affiliates. All rights reserved\n *\n * Licensed under the OpenSSL license (the \"License\").  You may not use\n * this file except in compliance with the License.  You can obtain a copy\n * in the file LICENSE in the source distribution or at\n * https://www.openssl.org/source/license.html\n */\n\n#ifndef HEADER_EC_H\n# define HEADER_EC_H\n\n# include <openssl/opensslconf.h>\n\n# ifndef OPENSSL_NO_EC\n# include <openssl/asn1.h>\n# include <openssl/symhacks.h>\n# if OPENSSL_API_COMPAT < 0x10100000L\n#  include <openssl/bn.h>\n# endif\n# include <openssl/ecerr.h>\n# ifdef  __cplusplus\nextern \"C\" {\n# endif\n\n# ifndef OPENSSL_ECC_MAX_FIELD_BITS\n#  define OPENSSL_ECC_MAX_FIELD_BITS 661\n# endif\n\n/** Enum for the point conversion form as defined in X9.62 (ECDSA)\n *  for the encoding of a elliptic curve point (x,y) */\ntypedef enum {\n        /** the point is encoded as z||x, where the octet z specifies\n         *  which solution of the quadratic equation y is  */\n    POINT_CONVERSION_COMPRESSED = 2,\n        /** the point is encoded as z||x||y, where z is the octet 0x04  */\n    POINT_CONVERSION_UNCOMPRESSED = 4,\n        /** the point is encoded as z||x||y, where the octet z specifies\n         *  which solution of the quadratic equation y is  */\n    POINT_CONVERSION_HYBRID = 6\n} point_conversion_form_t;\n\ntypedef struct ec_method_st EC_METHOD;\ntypedef struct ec_group_st EC_GROUP;\ntypedef struct ec_point_st EC_POINT;\ntypedef struct ecpk_parameters_st ECPKPARAMETERS;\ntypedef struct ec_parameters_st ECPARAMETERS;\n\n/********************************************************************/\n/*               EC_METHODs for curves over GF(p)                   */\n/********************************************************************/\n\n/** Returns the basic GFp ec methods which provides the basis for the\n *  optimized methods.\n *  \\return  EC_METHOD object\n */\nconst EC_METHOD *EC_GFp_simple_method(void);\n\n/** Returns GFp methods using montgomery multiplication.\n *  \\return  EC_METHOD object\n */\nconst EC_METHOD *EC_GFp_mont_method(void);\n\n/** Returns GFp methods using optimized methods for NIST recommended curves\n *  \\return  EC_METHOD object\n */\nconst EC_METHOD *EC_GFp_nist_method(void);\n\n# ifndef OPENSSL_NO_EC_NISTP_64_GCC_128\n/** Returns 64-bit optimized methods for nistp224\n *  \\return  EC_METHOD object\n */\nconst EC_METHOD *EC_GFp_nistp224_method(void);\n\n/** Returns 64-bit optimized methods for nistp256\n *  \\return  EC_METHOD object\n */\nconst EC_METHOD *EC_GFp_nistp256_method(void);\n\n/** Returns 64-bit optimized methods for nistp521\n *  \\return  EC_METHOD object\n */\nconst EC_METHOD *EC_GFp_nistp521_method(void);\n# endif\n\n# ifndef OPENSSL_NO_EC2M\n/********************************************************************/\n/*           EC_METHOD for curves over GF(2^m)                      */\n/********************************************************************/\n\n/** Returns the basic GF2m ec method\n *  \\return  EC_METHOD object\n */\nconst EC_METHOD *EC_GF2m_simple_method(void);\n\n# endif\n\n/********************************************************************/\n/*                   EC_GROUP functions                             */\n/********************************************************************/\n\n/** Creates a new EC_GROUP object\n *  \\param   meth  EC_METHOD to use\n *  \\return  newly created EC_GROUP object or NULL in case of an error.\n */\nEC_GROUP *EC_GROUP_new(const EC_METHOD *meth);\n\n/** Frees a EC_GROUP object\n *  \\param  group  EC_GROUP object to be freed.\n */\nvoid EC_GROUP_free(EC_GROUP *group);\n\n/** Clears and frees a EC_GROUP object\n *  \\param  group  EC_GROUP object to be cleared and freed.\n */\nvoid EC_GROUP_clear_free(EC_GROUP *group);\n\n/** Copies EC_GROUP objects. Note: both EC_GROUPs must use the same EC_METHOD.\n *  \\param  dst  destination EC_GROUP object\n *  \\param  src  source EC_GROUP object\n *  \\return 1 on success and 0 if an error occurred.\n */\nint EC_GROUP_copy(EC_GROUP *dst, const EC_GROUP *src);\n\n/** Creates a new EC_GROUP object and copies the copies the content\n *  form src to the newly created EC_KEY object\n *  \\param  src  source EC_GROUP object\n *  \\return newly created EC_GROUP object or NULL in case of an error.\n */\nEC_GROUP *EC_GROUP_dup(const EC_GROUP *src);\n\n/** Returns the EC_METHOD of the EC_GROUP object.\n *  \\param  group  EC_GROUP object\n *  \\return EC_METHOD used in this EC_GROUP object.\n */\nconst EC_METHOD *EC_GROUP_method_of(const EC_GROUP *group);\n\n/** Returns the field type of the EC_METHOD.\n *  \\param  meth  EC_METHOD object\n *  \\return NID of the underlying field type OID.\n */\nint EC_METHOD_get_field_type(const EC_METHOD *meth);\n\n/** Sets the generator and its order/cofactor of a EC_GROUP object.\n *  \\param  group      EC_GROUP object\n *  \\param  generator  EC_POINT object with the generator.\n *  \\param  order      the order of the group generated by the generator.\n *  \\param  cofactor   the index of the sub-group generated by the generator\n *                     in the group of all points on the elliptic curve.\n *  \\return 1 on success and 0 if an error occurred\n */\nint EC_GROUP_set_generator(EC_GROUP *group, const EC_POINT *generator,\n                           const BIGNUM *order, const BIGNUM *cofactor);\n\n/** Returns the generator of a EC_GROUP object.\n *  \\param  group  EC_GROUP object\n *  \\return the currently used generator (possibly NULL).\n */\nconst EC_POINT *EC_GROUP_get0_generator(const EC_GROUP *group);\n\n/** Returns the montgomery data for order(Generator)\n *  \\param  group  EC_GROUP object\n *  \\return the currently used montgomery data (possibly NULL).\n*/\nBN_MONT_CTX *EC_GROUP_get_mont_data(const EC_GROUP *group);\n\n/** Gets the order of a EC_GROUP\n *  \\param  group  EC_GROUP object\n *  \\param  order  BIGNUM to which the order is copied\n *  \\param  ctx    unused\n *  \\return 1 on success and 0 if an error occurred\n */\nint EC_GROUP_get_order(const EC_GROUP *group, BIGNUM *order, BN_CTX *ctx);\n\n/** Gets the order of an EC_GROUP\n *  \\param  group  EC_GROUP object\n *  \\return the group order\n */\nconst BIGNUM *EC_GROUP_get0_order(const EC_GROUP *group);\n\n/** Gets the number of bits of the order of an EC_GROUP\n *  \\param  group  EC_GROUP object\n *  \\return number of bits of group order.\n */\nint EC_GROUP_order_bits(const EC_GROUP *group);\n\n/** Gets the cofactor of a EC_GROUP\n *  \\param  group     EC_GROUP object\n *  \\param  cofactor  BIGNUM to which the cofactor is copied\n *  \\param  ctx       unused\n *  \\return 1 on success and 0 if an error occurred\n */\nint EC_GROUP_get_cofactor(const EC_GROUP *group, BIGNUM *cofactor,\n                          BN_CTX *ctx);\n\n/** Gets the cofactor of an EC_GROUP\n *  \\param  group  EC_GROUP object\n *  \\return the group cofactor\n */\nconst BIGNUM *EC_GROUP_get0_cofactor(const EC_GROUP *group);\n\n/** Sets the name of a EC_GROUP object\n *  \\param  group  EC_GROUP object\n *  \\param  nid    NID of the curve name OID\n */\nvoid EC_GROUP_set_curve_name(EC_GROUP *group, int nid);\n\n/** Returns the curve name of a EC_GROUP object\n *  \\param  group  EC_GROUP object\n *  \\return NID of the curve name OID or 0 if not set.\n */\nint EC_GROUP_get_curve_name(const EC_GROUP *group);\n\nvoid EC_GROUP_set_asn1_flag(EC_GROUP *group, int flag);\nint EC_GROUP_get_asn1_flag(const EC_GROUP *group);\n\nvoid EC_GROUP_set_point_conversion_form(EC_GROUP *group,\n                                        point_conversion_form_t form);\npoint_conversion_form_t EC_GROUP_get_point_conversion_form(const EC_GROUP *);\n\nunsigned char *EC_GROUP_get0_seed(const EC_GROUP *x);\nsize_t EC_GROUP_get_seed_len(const EC_GROUP *);\nsize_t EC_GROUP_set_seed(EC_GROUP *, const unsigned char *, size_t len);\n\n/** Sets the parameters of a ec curve defined by y^2 = x^3 + a*x + b (for GFp)\n *  or y^2 + x*y = x^3 + a*x^2 + b (for GF2m)\n *  \\param  group  EC_GROUP object\n *  \\param  p      BIGNUM with the prime number (GFp) or the polynomial\n *                 defining the underlying field (GF2m)\n *  \\param  a      BIGNUM with parameter a of the equation\n *  \\param  b      BIGNUM with parameter b of the equation\n *  \\param  ctx    BN_CTX object (optional)\n *  \\return 1 on success and 0 if an error occurred\n */\nint EC_GROUP_set_curve(EC_GROUP *group, const BIGNUM *p, const BIGNUM *a,\n                       const BIGNUM *b, BN_CTX *ctx);\n\n/** Gets the parameters of the ec curve defined by y^2 = x^3 + a*x + b (for GFp)\n *  or y^2 + x*y = x^3 + a*x^2 + b (for GF2m)\n *  \\param  group  EC_GROUP object\n *  \\param  p      BIGNUM with the prime number (GFp) or the polynomial\n *                 defining the underlying field (GF2m)\n *  \\param  a      BIGNUM for parameter a of the equation\n *  \\param  b      BIGNUM for parameter b of the equation\n *  \\param  ctx    BN_CTX object (optional)\n *  \\return 1 on success and 0 if an error occurred\n */\nint EC_GROUP_get_curve(const EC_GROUP *group, BIGNUM *p, BIGNUM *a, BIGNUM *b,\n                       BN_CTX *ctx);\n\n/** Sets the parameters of an ec curve. Synonym for EC_GROUP_set_curve\n *  \\param  group  EC_GROUP object\n *  \\param  p      BIGNUM with the prime number (GFp) or the polynomial\n *                 defining the underlying field (GF2m)\n *  \\param  a      BIGNUM with parameter a of the equation\n *  \\param  b      BIGNUM with parameter b of the equation\n *  \\param  ctx    BN_CTX object (optional)\n *  \\return 1 on success and 0 if an error occurred\n */\nDEPRECATEDIN_1_2_0(int EC_GROUP_set_curve_GFp(EC_GROUP *group, const BIGNUM *p,\n                                              const BIGNUM *a, const BIGNUM *b,\n                                              BN_CTX *ctx))\n\n/** Gets the parameters of an ec curve. Synonym for EC_GROUP_get_curve\n *  \\param  group  EC_GROUP object\n *  \\param  p      BIGNUM with the prime number (GFp) or the polynomial\n *                 defining the underlying field (GF2m)\n *  \\param  a      BIGNUM for parameter a of the equation\n *  \\param  b      BIGNUM for parameter b of the equation\n *  \\param  ctx    BN_CTX object (optional)\n *  \\return 1 on success and 0 if an error occurred\n */\nDEPRECATEDIN_1_2_0(int EC_GROUP_get_curve_GFp(const EC_GROUP *group, BIGNUM *p,\n                                              BIGNUM *a, BIGNUM *b,\n                                              BN_CTX *ctx))\n\n# ifndef OPENSSL_NO_EC2M\n/** Sets the parameter of an ec curve. Synonym for EC_GROUP_set_curve\n *  \\param  group  EC_GROUP object\n *  \\param  p      BIGNUM with the prime number (GFp) or the polynomial\n *                 defining the underlying field (GF2m)\n *  \\param  a      BIGNUM with parameter a of the equation\n *  \\param  b      BIGNUM with parameter b of the equation\n *  \\param  ctx    BN_CTX object (optional)\n *  \\return 1 on success and 0 if an error occurred\n */\nDEPRECATEDIN_1_2_0(int EC_GROUP_set_curve_GF2m(EC_GROUP *group, const BIGNUM *p,\n                                               const BIGNUM *a, const BIGNUM *b,\n                                               BN_CTX *ctx))\n\n/** Gets the parameters of an ec curve. Synonym for EC_GROUP_get_curve\n *  \\param  group  EC_GROUP object\n *  \\param  p      BIGNUM with the prime number (GFp) or the polynomial\n *                 defining the underlying field (GF2m)\n *  \\param  a      BIGNUM for parameter a of the equation\n *  \\param  b      BIGNUM for parameter b of the equation\n *  \\param  ctx    BN_CTX object (optional)\n *  \\return 1 on success and 0 if an error occurred\n */\nDEPRECATEDIN_1_2_0(int EC_GROUP_get_curve_GF2m(const EC_GROUP *group, BIGNUM *p,\n                                               BIGNUM *a, BIGNUM *b,\n                                               BN_CTX *ctx))\n# endif\n/** Returns the number of bits needed to represent a field element\n *  \\param  group  EC_GROUP object\n *  \\return number of bits needed to represent a field element\n */\nint EC_GROUP_get_degree(const EC_GROUP *group);\n\n/** Checks whether the parameter in the EC_GROUP define a valid ec group\n *  \\param  group  EC_GROUP object\n *  \\param  ctx    BN_CTX object (optional)\n *  \\return 1 if group is a valid ec group and 0 otherwise\n */\nint EC_GROUP_check(const EC_GROUP *group, BN_CTX *ctx);\n\n/** Checks whether the discriminant of the elliptic curve is zero or not\n *  \\param  group  EC_GROUP object\n *  \\param  ctx    BN_CTX object (optional)\n *  \\return 1 if the discriminant is not zero and 0 otherwise\n */\nint EC_GROUP_check_discriminant(const EC_GROUP *group, BN_CTX *ctx);\n\n/** Compares two EC_GROUP objects\n *  \\param  a    first EC_GROUP object\n *  \\param  b    second EC_GROUP object\n *  \\param  ctx  BN_CTX object (optional)\n *  \\return 0 if the groups are equal, 1 if not, or -1 on error\n */\nint EC_GROUP_cmp(const EC_GROUP *a, const EC_GROUP *b, BN_CTX *ctx);\n\n/*\n * EC_GROUP_new_GF*() calls EC_GROUP_new() and EC_GROUP_set_GF*() after\n * choosing an appropriate EC_METHOD\n */\n\n/** Creates a new EC_GROUP object with the specified parameters defined\n *  over GFp (defined by the equation y^2 = x^3 + a*x + b)\n *  \\param  p    BIGNUM with the prime number\n *  \\param  a    BIGNUM with the parameter a of the equation\n *  \\param  b    BIGNUM with the parameter b of the equation\n *  \\param  ctx  BN_CTX object (optional)\n *  \\return newly created EC_GROUP object with the specified parameters\n */\nEC_GROUP *EC_GROUP_new_curve_GFp(const BIGNUM *p, const BIGNUM *a,\n                                 const BIGNUM *b, BN_CTX *ctx);\n# ifndef OPENSSL_NO_EC2M\n/** Creates a new EC_GROUP object with the specified parameters defined\n *  over GF2m (defined by the equation y^2 + x*y = x^3 + a*x^2 + b)\n *  \\param  p    BIGNUM with the polynomial defining the underlying field\n *  \\param  a    BIGNUM with the parameter a of the equation\n *  \\param  b    BIGNUM with the parameter b of the equation\n *  \\param  ctx  BN_CTX object (optional)\n *  \\return newly created EC_GROUP object with the specified parameters\n */\nEC_GROUP *EC_GROUP_new_curve_GF2m(const BIGNUM *p, const BIGNUM *a,\n                                  const BIGNUM *b, BN_CTX *ctx);\n# endif\n\n/** Creates a EC_GROUP object with a curve specified by a NID\n *  \\param  nid  NID of the OID of the curve name\n *  \\return newly created EC_GROUP object with specified curve or NULL\n *          if an error occurred\n */\nEC_GROUP *EC_GROUP_new_by_curve_name(int nid);\n\n/** Creates a new EC_GROUP object from an ECPARAMETERS object\n *  \\param  params  pointer to the ECPARAMETERS object\n *  \\return newly created EC_GROUP object with specified curve or NULL\n *          if an error occurred\n */\nEC_GROUP *EC_GROUP_new_from_ecparameters(const ECPARAMETERS *params);\n\n/** Creates an ECPARAMETERS object for the given EC_GROUP object.\n *  \\param  group   pointer to the EC_GROUP object\n *  \\param  params  pointer to an existing ECPARAMETERS object or NULL\n *  \\return pointer to the new ECPARAMETERS object or NULL\n *          if an error occurred.\n */\nECPARAMETERS *EC_GROUP_get_ecparameters(const EC_GROUP *group,\n                                        ECPARAMETERS *params);\n\n/** Creates a new EC_GROUP object from an ECPKPARAMETERS object\n *  \\param  params  pointer to an existing ECPKPARAMETERS object, or NULL\n *  \\return newly created EC_GROUP object with specified curve, or NULL\n *          if an error occurred\n */\nEC_GROUP *EC_GROUP_new_from_ecpkparameters(const ECPKPARAMETERS *params);\n\n/** Creates an ECPKPARAMETERS object for the given EC_GROUP object.\n *  \\param  group   pointer to the EC_GROUP object\n *  \\param  params  pointer to an existing ECPKPARAMETERS object or NULL\n *  \\return pointer to the new ECPKPARAMETERS object or NULL\n *          if an error occurred.\n */\nECPKPARAMETERS *EC_GROUP_get_ecpkparameters(const EC_GROUP *group,\n                                            ECPKPARAMETERS *params);\n\n/********************************************************************/\n/*               handling of internal curves                        */\n/********************************************************************/\n\ntypedef struct {\n    int nid;\n    const char *comment;\n} EC_builtin_curve;\n\n/*\n * EC_builtin_curves(EC_builtin_curve *r, size_t size) returns number of all\n * available curves or zero if a error occurred. In case r is not zero,\n * nitems EC_builtin_curve structures are filled with the data of the first\n * nitems internal groups\n */\nsize_t EC_get_builtin_curves(EC_builtin_curve *r, size_t nitems);\n\nconst char *EC_curve_nid2nist(int nid);\nint EC_curve_nist2nid(const char *name);\n\n/********************************************************************/\n/*                    EC_POINT functions                            */\n/********************************************************************/\n\n/** Creates a new EC_POINT object for the specified EC_GROUP\n *  \\param  group  EC_GROUP the underlying EC_GROUP object\n *  \\return newly created EC_POINT object or NULL if an error occurred\n */\nEC_POINT *EC_POINT_new(const EC_GROUP *group);\n\n/** Frees a EC_POINT object\n *  \\param  point  EC_POINT object to be freed\n */\nvoid EC_POINT_free(EC_POINT *point);\n\n/** Clears and frees a EC_POINT object\n *  \\param  point  EC_POINT object to be cleared and freed\n */\nvoid EC_POINT_clear_free(EC_POINT *point);\n\n/** Copies EC_POINT object\n *  \\param  dst  destination EC_POINT object\n *  \\param  src  source EC_POINT object\n *  \\return 1 on success and 0 if an error occurred\n */\nint EC_POINT_copy(EC_POINT *dst, const EC_POINT *src);\n\n/** Creates a new EC_POINT object and copies the content of the supplied\n *  EC_POINT\n *  \\param  src    source EC_POINT object\n *  \\param  group  underlying the EC_GROUP object\n *  \\return newly created EC_POINT object or NULL if an error occurred\n */\nEC_POINT *EC_POINT_dup(const EC_POINT *src, const EC_GROUP *group);\n\n/** Returns the EC_METHOD used in EC_POINT object\n *  \\param  point  EC_POINT object\n *  \\return the EC_METHOD used\n */\nconst EC_METHOD *EC_POINT_method_of(const EC_POINT *point);\n\n/** Sets a point to infinity (neutral element)\n *  \\param  group  underlying EC_GROUP object\n *  \\param  point  EC_POINT to set to infinity\n *  \\return 1 on success and 0 if an error occurred\n */\nint EC_POINT_set_to_infinity(const EC_GROUP *group, EC_POINT *point);\n\n/** Sets the jacobian projective coordinates of a EC_POINT over GFp\n *  \\param  group  underlying EC_GROUP object\n *  \\param  p      EC_POINT object\n *  \\param  x      BIGNUM with the x-coordinate\n *  \\param  y      BIGNUM with the y-coordinate\n *  \\param  z      BIGNUM with the z-coordinate\n *  \\param  ctx    BN_CTX object (optional)\n *  \\return 1 on success and 0 if an error occurred\n */\nint EC_POINT_set_Jprojective_coordinates_GFp(const EC_GROUP *group,\n                                             EC_POINT *p, const BIGNUM *x,\n                                             const BIGNUM *y, const BIGNUM *z,\n                                             BN_CTX *ctx);\n\n/** Gets the jacobian projective coordinates of a EC_POINT over GFp\n *  \\param  group  underlying EC_GROUP object\n *  \\param  p      EC_POINT object\n *  \\param  x      BIGNUM for the x-coordinate\n *  \\param  y      BIGNUM for the y-coordinate\n *  \\param  z      BIGNUM for the z-coordinate\n *  \\param  ctx    BN_CTX object (optional)\n *  \\return 1 on success and 0 if an error occurred\n */\nint EC_POINT_get_Jprojective_coordinates_GFp(const EC_GROUP *group,\n                                             const EC_POINT *p, BIGNUM *x,\n                                             BIGNUM *y, BIGNUM *z,\n                                             BN_CTX *ctx);\n\n/** Sets the affine coordinates of an EC_POINT\n *  \\param  group  underlying EC_GROUP object\n *  \\param  p      EC_POINT object\n *  \\param  x      BIGNUM with the x-coordinate\n *  \\param  y      BIGNUM with the y-coordinate\n *  \\param  ctx    BN_CTX object (optional)\n *  \\return 1 on success and 0 if an error occurred\n */\nint EC_POINT_set_affine_coordinates(const EC_GROUP *group, EC_POINT *p,\n                                    const BIGNUM *x, const BIGNUM *y,\n                                    BN_CTX *ctx);\n\n/** Gets the affine coordinates of an EC_POINT.\n *  \\param  group  underlying EC_GROUP object\n *  \\param  p      EC_POINT object\n *  \\param  x      BIGNUM for the x-coordinate\n *  \\param  y      BIGNUM for the y-coordinate\n *  \\param  ctx    BN_CTX object (optional)\n *  \\return 1 on success and 0 if an error occurred\n */\nint EC_POINT_get_affine_coordinates(const EC_GROUP *group, const EC_POINT *p,\n                                    BIGNUM *x, BIGNUM *y, BN_CTX *ctx);\n\n/** Sets the affine coordinates of an EC_POINT. A synonym of\n *  EC_POINT_set_affine_coordinates\n *  \\param  group  underlying EC_GROUP object\n *  \\param  p      EC_POINT object\n *  \\param  x      BIGNUM with the x-coordinate\n *  \\param  y      BIGNUM with the y-coordinate\n *  \\param  ctx    BN_CTX object (optional)\n *  \\return 1 on success and 0 if an error occurred\n */\nDEPRECATEDIN_1_2_0(int EC_POINT_set_affine_coordinates_GFp(const EC_GROUP *group,\n                                                           EC_POINT *p,\n                                                           const BIGNUM *x,\n                                                           const BIGNUM *y,\n                                                           BN_CTX *ctx))\n\n/** Gets the affine coordinates of an EC_POINT. A synonym of\n *  EC_POINT_get_affine_coordinates\n *  \\param  group  underlying EC_GROUP object\n *  \\param  p      EC_POINT object\n *  \\param  x      BIGNUM for the x-coordinate\n *  \\param  y      BIGNUM for the y-coordinate\n *  \\param  ctx    BN_CTX object (optional)\n *  \\return 1 on success and 0 if an error occurred\n */\nDEPRECATEDIN_1_2_0(int EC_POINT_get_affine_coordinates_GFp(const EC_GROUP *group,\n                                                           const EC_POINT *p,\n                                                           BIGNUM *x,\n                                                           BIGNUM *y,\n                                                           BN_CTX *ctx))\n\n/** Sets the x9.62 compressed coordinates of a EC_POINT\n *  \\param  group  underlying EC_GROUP object\n *  \\param  p      EC_POINT object\n *  \\param  x      BIGNUM with x-coordinate\n *  \\param  y_bit  integer with the y-Bit (either 0 or 1)\n *  \\param  ctx    BN_CTX object (optional)\n *  \\return 1 on success and 0 if an error occurred\n */\nint EC_POINT_set_compressed_coordinates(const EC_GROUP *group, EC_POINT *p,\n                                        const BIGNUM *x, int y_bit,\n                                        BN_CTX *ctx);\n\n/** Sets the x9.62 compressed coordinates of a EC_POINT. A synonym of\n *  EC_POINT_set_compressed_coordinates\n *  \\param  group  underlying EC_GROUP object\n *  \\param  p      EC_POINT object\n *  \\param  x      BIGNUM with x-coordinate\n *  \\param  y_bit  integer with the y-Bit (either 0 or 1)\n *  \\param  ctx    BN_CTX object (optional)\n *  \\return 1 on success and 0 if an error occurred\n */\nDEPRECATEDIN_1_2_0(int EC_POINT_set_compressed_coordinates_GFp(const EC_GROUP *group,\n                                                               EC_POINT *p,\n                                                               const BIGNUM *x,\n                                                               int y_bit,\n                                                               BN_CTX *ctx))\n# ifndef OPENSSL_NO_EC2M\n/** Sets the affine coordinates of an EC_POINT. A synonym of\n *  EC_POINT_set_affine_coordinates\n *  \\param  group  underlying EC_GROUP object\n *  \\param  p      EC_POINT object\n *  \\param  x      BIGNUM with the x-coordinate\n *  \\param  y      BIGNUM with the y-coordinate\n *  \\param  ctx    BN_CTX object (optional)\n *  \\return 1 on success and 0 if an error occurred\n */\nDEPRECATEDIN_1_2_0(int EC_POINT_set_affine_coordinates_GF2m(const EC_GROUP *group,\n                                                            EC_POINT *p,\n                                                            const BIGNUM *x,\n                                                            const BIGNUM *y,\n                                                            BN_CTX *ctx))\n\n/** Gets the affine coordinates of an EC_POINT. A synonym of\n *  EC_POINT_get_affine_coordinates\n *  \\param  group  underlying EC_GROUP object\n *  \\param  p      EC_POINT object\n *  \\param  x      BIGNUM for the x-coordinate\n *  \\param  y      BIGNUM for the y-coordinate\n *  \\param  ctx    BN_CTX object (optional)\n *  \\return 1 on success and 0 if an error occurred\n */\nDEPRECATEDIN_1_2_0(int EC_POINT_get_affine_coordinates_GF2m(const EC_GROUP *group,\n                                                            const EC_POINT *p,\n                                                            BIGNUM *x,\n                                                            BIGNUM *y,\n                                                            BN_CTX *ctx))\n\n/** Sets the x9.62 compressed coordinates of a EC_POINT. A synonym of\n *  EC_POINT_set_compressed_coordinates\n *  \\param  group  underlying EC_GROUP object\n *  \\param  p      EC_POINT object\n *  \\param  x      BIGNUM with x-coordinate\n *  \\param  y_bit  integer with the y-Bit (either 0 or 1)\n *  \\param  ctx    BN_CTX object (optional)\n *  \\return 1 on success and 0 if an error occurred\n */\nDEPRECATEDIN_1_2_0(int EC_POINT_set_compressed_coordinates_GF2m(const EC_GROUP *group,\n                                                                EC_POINT *p,\n                                                                const BIGNUM *x,\n                                                                int y_bit,\n                                                                BN_CTX *ctx))\n# endif\n/** Encodes a EC_POINT object to a octet string\n *  \\param  group  underlying EC_GROUP object\n *  \\param  p      EC_POINT object\n *  \\param  form   point conversion form\n *  \\param  buf    memory buffer for the result. If NULL the function returns\n *                 required buffer size.\n *  \\param  len    length of the memory buffer\n *  \\param  ctx    BN_CTX object (optional)\n *  \\return the length of the encoded octet string or 0 if an error occurred\n */\nsize_t EC_POINT_point2oct(const EC_GROUP *group, const EC_POINT *p,\n                          point_conversion_form_t form,\n                          unsigned char *buf, size_t len, BN_CTX *ctx);\n\n/** Decodes a EC_POINT from a octet string\n *  \\param  group  underlying EC_GROUP object\n *  \\param  p      EC_POINT object\n *  \\param  buf    memory buffer with the encoded ec point\n *  \\param  len    length of the encoded ec point\n *  \\param  ctx    BN_CTX object (optional)\n *  \\return 1 on success and 0 if an error occurred\n */\nint EC_POINT_oct2point(const EC_GROUP *group, EC_POINT *p,\n                       const unsigned char *buf, size_t len, BN_CTX *ctx);\n\n/** Encodes an EC_POINT object to an allocated octet string\n *  \\param  group  underlying EC_GROUP object\n *  \\param  point  EC_POINT object\n *  \\param  form   point conversion form\n *  \\param  pbuf   returns pointer to allocated buffer\n *  \\param  ctx    BN_CTX object (optional)\n *  \\return the length of the encoded octet string or 0 if an error occurred\n */\nsize_t EC_POINT_point2buf(const EC_GROUP *group, const EC_POINT *point,\n                          point_conversion_form_t form,\n                          unsigned char **pbuf, BN_CTX *ctx);\n\n/* other interfaces to point2oct/oct2point: */\nBIGNUM *EC_POINT_point2bn(const EC_GROUP *, const EC_POINT *,\n                          point_conversion_form_t form, BIGNUM *, BN_CTX *);\nEC_POINT *EC_POINT_bn2point(const EC_GROUP *, const BIGNUM *,\n                            EC_POINT *, BN_CTX *);\nchar *EC_POINT_point2hex(const EC_GROUP *, const EC_POINT *,\n                         point_conversion_form_t form, BN_CTX *);\nEC_POINT *EC_POINT_hex2point(const EC_GROUP *, const char *,\n                             EC_POINT *, BN_CTX *);\n\n/********************************************************************/\n/*         functions for doing EC_POINT arithmetic                  */\n/********************************************************************/\n\n/** Computes the sum of two EC_POINT\n *  \\param  group  underlying EC_GROUP object\n *  \\param  r      EC_POINT object for the result (r = a + b)\n *  \\param  a      EC_POINT object with the first summand\n *  \\param  b      EC_POINT object with the second summand\n *  \\param  ctx    BN_CTX object (optional)\n *  \\return 1 on success and 0 if an error occurred\n */\nint EC_POINT_add(const EC_GROUP *group, EC_POINT *r, const EC_POINT *a,\n                 const EC_POINT *b, BN_CTX *ctx);\n\n/** Computes the double of a EC_POINT\n *  \\param  group  underlying EC_GROUP object\n *  \\param  r      EC_POINT object for the result (r = 2 * a)\n *  \\param  a      EC_POINT object\n *  \\param  ctx    BN_CTX object (optional)\n *  \\return 1 on success and 0 if an error occurred\n */\nint EC_POINT_dbl(const EC_GROUP *group, EC_POINT *r, const EC_POINT *a,\n                 BN_CTX *ctx);\n\n/** Computes the inverse of a EC_POINT\n *  \\param  group  underlying EC_GROUP object\n *  \\param  a      EC_POINT object to be inverted (it's used for the result as well)\n *  \\param  ctx    BN_CTX object (optional)\n *  \\return 1 on success and 0 if an error occurred\n */\nint EC_POINT_invert(const EC_GROUP *group, EC_POINT *a, BN_CTX *ctx);\n\n/** Checks whether the point is the neutral element of the group\n *  \\param  group  the underlying EC_GROUP object\n *  \\param  p      EC_POINT object\n *  \\return 1 if the point is the neutral element and 0 otherwise\n */\nint EC_POINT_is_at_infinity(const EC_GROUP *group, const EC_POINT *p);\n\n/** Checks whether the point is on the curve\n *  \\param  group  underlying EC_GROUP object\n *  \\param  point  EC_POINT object to check\n *  \\param  ctx    BN_CTX object (optional)\n *  \\return 1 if the point is on the curve, 0 if not, or -1 on error\n */\nint EC_POINT_is_on_curve(const EC_GROUP *group, const EC_POINT *point,\n                         BN_CTX *ctx);\n\n/** Compares two EC_POINTs\n *  \\param  group  underlying EC_GROUP object\n *  \\param  a      first EC_POINT object\n *  \\param  b      second EC_POINT object\n *  \\param  ctx    BN_CTX object (optional)\n *  \\return 1 if the points are not equal, 0 if they are, or -1 on error\n */\nint EC_POINT_cmp(const EC_GROUP *group, const EC_POINT *a, const EC_POINT *b,\n                 BN_CTX *ctx);\n\nint EC_POINT_make_affine(const EC_GROUP *group, EC_POINT *point, BN_CTX *ctx);\nint EC_POINTs_make_affine(const EC_GROUP *group, size_t num,\n                          EC_POINT *points[], BN_CTX *ctx);\n\n/** Computes r = generator * n + sum_{i=0}^{num-1} p[i] * m[i]\n *  \\param  group  underlying EC_GROUP object\n *  \\param  r      EC_POINT object for the result\n *  \\param  n      BIGNUM with the multiplier for the group generator (optional)\n *  \\param  num    number further summands\n *  \\param  p      array of size num of EC_POINT objects\n *  \\param  m      array of size num of BIGNUM objects\n *  \\param  ctx    BN_CTX object (optional)\n *  \\return 1 on success and 0 if an error occurred\n */\nint EC_POINTs_mul(const EC_GROUP *group, EC_POINT *r, const BIGNUM *n,\n                  size_t num, const EC_POINT *p[], const BIGNUM *m[],\n                  BN_CTX *ctx);\n\n/** Computes r = generator * n + q * m\n *  \\param  group  underlying EC_GROUP object\n *  \\param  r      EC_POINT object for the result\n *  \\param  n      BIGNUM with the multiplier for the group generator (optional)\n *  \\param  q      EC_POINT object with the first factor of the second summand\n *  \\param  m      BIGNUM with the second factor of the second summand\n *  \\param  ctx    BN_CTX object (optional)\n *  \\return 1 on success and 0 if an error occurred\n */\nint EC_POINT_mul(const EC_GROUP *group, EC_POINT *r, const BIGNUM *n,\n                 const EC_POINT *q, const BIGNUM *m, BN_CTX *ctx);\n\n/** Stores multiples of generator for faster point multiplication\n *  \\param  group  EC_GROUP object\n *  \\param  ctx    BN_CTX object (optional)\n *  \\return 1 on success and 0 if an error occurred\n */\nint EC_GROUP_precompute_mult(EC_GROUP *group, BN_CTX *ctx);\n\n/** Reports whether a precomputation has been done\n *  \\param  group  EC_GROUP object\n *  \\return 1 if a pre-computation has been done and 0 otherwise\n */\nint EC_GROUP_have_precompute_mult(const EC_GROUP *group);\n\n/********************************************************************/\n/*                       ASN1 stuff                                 */\n/********************************************************************/\n\nDECLARE_ASN1_ITEM(ECPKPARAMETERS)\nDECLARE_ASN1_ALLOC_FUNCTIONS(ECPKPARAMETERS)\nDECLARE_ASN1_ITEM(ECPARAMETERS)\nDECLARE_ASN1_ALLOC_FUNCTIONS(ECPARAMETERS)\n\n/*\n * EC_GROUP_get_basis_type() returns the NID of the basis type used to\n * represent the field elements\n */\nint EC_GROUP_get_basis_type(const EC_GROUP *);\n# ifndef OPENSSL_NO_EC2M\nint EC_GROUP_get_trinomial_basis(const EC_GROUP *, unsigned int *k);\nint EC_GROUP_get_pentanomial_basis(const EC_GROUP *, unsigned int *k1,\n                                   unsigned int *k2, unsigned int *k3);\n# endif\n\n# define OPENSSL_EC_EXPLICIT_CURVE  0x000\n# define OPENSSL_EC_NAMED_CURVE     0x001\n\nEC_GROUP *d2i_ECPKParameters(EC_GROUP **, const unsigned char **in, long len);\nint i2d_ECPKParameters(const EC_GROUP *, unsigned char **out);\n\n# define d2i_ECPKParameters_bio(bp,x) ASN1_d2i_bio_of(EC_GROUP,NULL,d2i_ECPKParameters,bp,x)\n# define i2d_ECPKParameters_bio(bp,x) ASN1_i2d_bio_of_const(EC_GROUP,i2d_ECPKParameters,bp,x)\n# define d2i_ECPKParameters_fp(fp,x) (EC_GROUP *)ASN1_d2i_fp(NULL, \\\n                (char *(*)())d2i_ECPKParameters,(fp),(unsigned char **)(x))\n# define i2d_ECPKParameters_fp(fp,x) ASN1_i2d_fp(i2d_ECPKParameters,(fp), \\\n                (unsigned char *)(x))\n\nint ECPKParameters_print(BIO *bp, const EC_GROUP *x, int off);\n# ifndef OPENSSL_NO_STDIO\nint ECPKParameters_print_fp(FILE *fp, const EC_GROUP *x, int off);\n# endif\n\n/********************************************************************/\n/*                      EC_KEY functions                            */\n/********************************************************************/\n\n/* some values for the encoding_flag */\n# define EC_PKEY_NO_PARAMETERS   0x001\n# define EC_PKEY_NO_PUBKEY       0x002\n\n/* some values for the flags field */\n# define EC_FLAG_NON_FIPS_ALLOW  0x1\n# define EC_FLAG_FIPS_CHECKED    0x2\n# define EC_FLAG_COFACTOR_ECDH   0x1000\n\n/** Creates a new EC_KEY object.\n *  \\return EC_KEY object or NULL if an error occurred.\n */\nEC_KEY *EC_KEY_new(void);\n\nint EC_KEY_get_flags(const EC_KEY *key);\n\nvoid EC_KEY_set_flags(EC_KEY *key, int flags);\n\nvoid EC_KEY_clear_flags(EC_KEY *key, int flags);\n\n/** Creates a new EC_KEY object using a named curve as underlying\n *  EC_GROUP object.\n *  \\param  nid  NID of the named curve.\n *  \\return EC_KEY object or NULL if an error occurred.\n */\nEC_KEY *EC_KEY_new_by_curve_name(int nid);\n\n/** Frees a EC_KEY object.\n *  \\param  key  EC_KEY object to be freed.\n */\nvoid EC_KEY_free(EC_KEY *key);\n\n/** Copies a EC_KEY object.\n *  \\param  dst  destination EC_KEY object\n *  \\param  src  src EC_KEY object\n *  \\return dst or NULL if an error occurred.\n */\nEC_KEY *EC_KEY_copy(EC_KEY *dst, const EC_KEY *src);\n\n/** Creates a new EC_KEY object and copies the content from src to it.\n *  \\param  src  the source EC_KEY object\n *  \\return newly created EC_KEY object or NULL if an error occurred.\n */\nEC_KEY *EC_KEY_dup(const EC_KEY *src);\n\n/** Increases the internal reference count of a EC_KEY object.\n *  \\param  key  EC_KEY object\n *  \\return 1 on success and 0 if an error occurred.\n */\nint EC_KEY_up_ref(EC_KEY *key);\n\n/** Returns the ENGINE object of a EC_KEY object\n *  \\param  eckey  EC_KEY object\n *  \\return the ENGINE object (possibly NULL).\n */\nENGINE *EC_KEY_get0_engine(const EC_KEY *eckey);\n\n/** Returns the EC_GROUP object of a EC_KEY object\n *  \\param  key  EC_KEY object\n *  \\return the EC_GROUP object (possibly NULL).\n */\nconst EC_GROUP *EC_KEY_get0_group(const EC_KEY *key);\n\n/** Sets the EC_GROUP of a EC_KEY object.\n *  \\param  key    EC_KEY object\n *  \\param  group  EC_GROUP to use in the EC_KEY object (note: the EC_KEY\n *                 object will use an own copy of the EC_GROUP).\n *  \\return 1 on success and 0 if an error occurred.\n */\nint EC_KEY_set_group(EC_KEY *key, const EC_GROUP *group);\n\n/** Returns the private key of a EC_KEY object.\n *  \\param  key  EC_KEY object\n *  \\return a BIGNUM with the private key (possibly NULL).\n */\nconst BIGNUM *EC_KEY_get0_private_key(const EC_KEY *key);\n\n/** Sets the private key of a EC_KEY object.\n *  \\param  key  EC_KEY object\n *  \\param  prv  BIGNUM with the private key (note: the EC_KEY object\n *               will use an own copy of the BIGNUM).\n *  \\return 1 on success and 0 if an error occurred.\n */\nint EC_KEY_set_private_key(EC_KEY *key, const BIGNUM *prv);\n\n/** Returns the public key of a EC_KEY object.\n *  \\param  key  the EC_KEY object\n *  \\return a EC_POINT object with the public key (possibly NULL)\n */\nconst EC_POINT *EC_KEY_get0_public_key(const EC_KEY *key);\n\n/** Sets the public key of a EC_KEY object.\n *  \\param  key  EC_KEY object\n *  \\param  pub  EC_POINT object with the public key (note: the EC_KEY object\n *               will use an own copy of the EC_POINT object).\n *  \\return 1 on success and 0 if an error occurred.\n */\nint EC_KEY_set_public_key(EC_KEY *key, const EC_POINT *pub);\n\nunsigned EC_KEY_get_enc_flags(const EC_KEY *key);\nvoid EC_KEY_set_enc_flags(EC_KEY *eckey, unsigned int flags);\npoint_conversion_form_t EC_KEY_get_conv_form(const EC_KEY *key);\nvoid EC_KEY_set_conv_form(EC_KEY *eckey, point_conversion_form_t cform);\n\n#define EC_KEY_get_ex_new_index(l, p, newf, dupf, freef) \\\n    CRYPTO_get_ex_new_index(CRYPTO_EX_INDEX_EC_KEY, l, p, newf, dupf, freef)\nint EC_KEY_set_ex_data(EC_KEY *key, int idx, void *arg);\nvoid *EC_KEY_get_ex_data(const EC_KEY *key, int idx);\n\n/* wrapper functions for the underlying EC_GROUP object */\nvoid EC_KEY_set_asn1_flag(EC_KEY *eckey, int asn1_flag);\n\n/** Creates a table of pre-computed multiples of the generator to\n *  accelerate further EC_KEY operations.\n *  \\param  key  EC_KEY object\n *  \\param  ctx  BN_CTX object (optional)\n *  \\return 1 on success and 0 if an error occurred.\n */\nint EC_KEY_precompute_mult(EC_KEY *key, BN_CTX *ctx);\n\n/** Creates a new ec private (and optional a new public) key.\n *  \\param  key  EC_KEY object\n *  \\return 1 on success and 0 if an error occurred.\n */\nint EC_KEY_generate_key(EC_KEY *key);\n\n/** Verifies that a private and/or public key is valid.\n *  \\param  key  the EC_KEY object\n *  \\return 1 on success and 0 otherwise.\n */\nint EC_KEY_check_key(const EC_KEY *key);\n\n/** Indicates if an EC_KEY can be used for signing.\n *  \\param  eckey  the EC_KEY object\n *  \\return 1 if can can sign and 0 otherwise.\n */\nint EC_KEY_can_sign(const EC_KEY *eckey);\n\n/** Sets a public key from affine coordinates performing\n *  necessary NIST PKV tests.\n *  \\param  key  the EC_KEY object\n *  \\param  x    public key x coordinate\n *  \\param  y    public key y coordinate\n *  \\return 1 on success and 0 otherwise.\n */\nint EC_KEY_set_public_key_affine_coordinates(EC_KEY *key, BIGNUM *x,\n                                             BIGNUM *y);\n\n/** Encodes an EC_KEY public key to an allocated octet string\n *  \\param  key    key to encode\n *  \\param  form   point conversion form\n *  \\param  pbuf   returns pointer to allocated buffer\n *  \\param  ctx    BN_CTX object (optional)\n *  \\return the length of the encoded octet string or 0 if an error occurred\n */\nsize_t EC_KEY_key2buf(const EC_KEY *key, point_conversion_form_t form,\n                      unsigned char **pbuf, BN_CTX *ctx);\n\n/** Decodes a EC_KEY public key from a octet string\n *  \\param  key    key to decode\n *  \\param  buf    memory buffer with the encoded ec point\n *  \\param  len    length of the encoded ec point\n *  \\param  ctx    BN_CTX object (optional)\n *  \\return 1 on success and 0 if an error occurred\n */\n\nint EC_KEY_oct2key(EC_KEY *key, const unsigned char *buf, size_t len,\n                   BN_CTX *ctx);\n\n/** Decodes an EC_KEY private key from an octet string\n *  \\param  key    key to decode\n *  \\param  buf    memory buffer with the encoded private key\n *  \\param  len    length of the encoded key\n *  \\return 1 on success and 0 if an error occurred\n */\n\nint EC_KEY_oct2priv(EC_KEY *key, const unsigned char *buf, size_t len);\n\n/** Encodes a EC_KEY private key to an octet string\n *  \\param  key    key to encode\n *  \\param  buf    memory buffer for the result. If NULL the function returns\n *                 required buffer size.\n *  \\param  len    length of the memory buffer\n *  \\return the length of the encoded octet string or 0 if an error occurred\n */\n\nsize_t EC_KEY_priv2oct(const EC_KEY *key, unsigned char *buf, size_t len);\n\n/** Encodes an EC_KEY private key to an allocated octet string\n *  \\param  eckey  key to encode\n *  \\param  pbuf   returns pointer to allocated buffer\n *  \\return the length of the encoded octet string or 0 if an error occurred\n */\nsize_t EC_KEY_priv2buf(const EC_KEY *eckey, unsigned char **pbuf);\n\n/********************************************************************/\n/*        de- and encoding functions for SEC1 ECPrivateKey          */\n/********************************************************************/\n\n/** Decodes a private key from a memory buffer.\n *  \\param  key  a pointer to a EC_KEY object which should be used (or NULL)\n *  \\param  in   pointer to memory with the DER encoded private key\n *  \\param  len  length of the DER encoded private key\n *  \\return the decoded private key or NULL if an error occurred.\n */\nEC_KEY *d2i_ECPrivateKey(EC_KEY **key, const unsigned char **in, long len);\n\n/** Encodes a private key object and stores the result in a buffer.\n *  \\param  key  the EC_KEY object to encode\n *  \\param  out  the buffer for the result (if NULL the function returns number\n *               of bytes needed).\n *  \\return 1 on success and 0 if an error occurred.\n */\nint i2d_ECPrivateKey(EC_KEY *key, unsigned char **out);\n\n/********************************************************************/\n/*        de- and encoding functions for EC parameters              */\n/********************************************************************/\n\n/** Decodes ec parameter from a memory buffer.\n *  \\param  key  a pointer to a EC_KEY object which should be used (or NULL)\n *  \\param  in   pointer to memory with the DER encoded ec parameters\n *  \\param  len  length of the DER encoded ec parameters\n *  \\return a EC_KEY object with the decoded parameters or NULL if an error\n *          occurred.\n */\nEC_KEY *d2i_ECParameters(EC_KEY **key, const unsigned char **in, long len);\n\n/** Encodes ec parameter and stores the result in a buffer.\n *  \\param  key  the EC_KEY object with ec parameters to encode\n *  \\param  out  the buffer for the result (if NULL the function returns number\n *               of bytes needed).\n *  \\return 1 on success and 0 if an error occurred.\n */\nint i2d_ECParameters(EC_KEY *key, unsigned char **out);\n\n/********************************************************************/\n/*         de- and encoding functions for EC public key             */\n/*         (octet string, not DER -- hence 'o2i' and 'i2o')         */\n/********************************************************************/\n\n/** Decodes a ec public key from a octet string.\n *  \\param  key  a pointer to a EC_KEY object which should be used\n *  \\param  in   memory buffer with the encoded public key\n *  \\param  len  length of the encoded public key\n *  \\return EC_KEY object with decoded public key or NULL if an error\n *          occurred.\n */\nEC_KEY *o2i_ECPublicKey(EC_KEY **key, const unsigned char **in, long len);\n\n/** Encodes a ec public key in an octet string.\n *  \\param  key  the EC_KEY object with the public key\n *  \\param  out  the buffer for the result (if NULL the function returns number\n *               of bytes needed).\n *  \\return 1 on success and 0 if an error occurred\n */\nint i2o_ECPublicKey(const EC_KEY *key, unsigned char **out);\n\n/** Prints out the ec parameters on human readable form.\n *  \\param  bp   BIO object to which the information is printed\n *  \\param  key  EC_KEY object\n *  \\return 1 on success and 0 if an error occurred\n */\nint ECParameters_print(BIO *bp, const EC_KEY *key);\n\n/** Prints out the contents of a EC_KEY object\n *  \\param  bp   BIO object to which the information is printed\n *  \\param  key  EC_KEY object\n *  \\param  off  line offset\n *  \\return 1 on success and 0 if an error occurred\n */\nint EC_KEY_print(BIO *bp, const EC_KEY *key, int off);\n\n# ifndef OPENSSL_NO_STDIO\n/** Prints out the ec parameters on human readable form.\n *  \\param  fp   file descriptor to which the information is printed\n *  \\param  key  EC_KEY object\n *  \\return 1 on success and 0 if an error occurred\n */\nint ECParameters_print_fp(FILE *fp, const EC_KEY *key);\n\n/** Prints out the contents of a EC_KEY object\n *  \\param  fp   file descriptor to which the information is printed\n *  \\param  key  EC_KEY object\n *  \\param  off  line offset\n *  \\return 1 on success and 0 if an error occurred\n */\nint EC_KEY_print_fp(FILE *fp, const EC_KEY *key, int off);\n\n# endif\n\nconst EC_KEY_METHOD *EC_KEY_OpenSSL(void);\nconst EC_KEY_METHOD *EC_KEY_get_default_method(void);\nvoid EC_KEY_set_default_method(const EC_KEY_METHOD *meth);\nconst EC_KEY_METHOD *EC_KEY_get_method(const EC_KEY *key);\nint EC_KEY_set_method(EC_KEY *key, const EC_KEY_METHOD *meth);\nEC_KEY *EC_KEY_new_method(ENGINE *engine);\n\n/** The old name for ecdh_KDF_X9_63\n *  The ECDH KDF specification has been mistakingly attributed to ANSI X9.62,\n *  it is actually specified in ANSI X9.63.\n *  This identifier is retained for backwards compatibility\n */\nint ECDH_KDF_X9_62(unsigned char *out, size_t outlen,\n                   const unsigned char *Z, size_t Zlen,\n                   const unsigned char *sinfo, size_t sinfolen,\n                   const EVP_MD *md);\n\nint ECDH_compute_key(void *out, size_t outlen, const EC_POINT *pub_key,\n                     const EC_KEY *ecdh,\n                     void *(*KDF) (const void *in, size_t inlen,\n                                   void *out, size_t *outlen));\n\ntypedef struct ECDSA_SIG_st ECDSA_SIG;\n\n/** Allocates and initialize a ECDSA_SIG structure\n *  \\return pointer to a ECDSA_SIG structure or NULL if an error occurred\n */\nECDSA_SIG *ECDSA_SIG_new(void);\n\n/** frees a ECDSA_SIG structure\n *  \\param  sig  pointer to the ECDSA_SIG structure\n */\nvoid ECDSA_SIG_free(ECDSA_SIG *sig);\n\n/** DER encode content of ECDSA_SIG object (note: this function modifies *pp\n *  (*pp += length of the DER encoded signature)).\n *  \\param  sig  pointer to the ECDSA_SIG object\n *  \\param  pp   pointer to a unsigned char pointer for the output or NULL\n *  \\return the length of the DER encoded ECDSA_SIG object or a negative value\n *          on error\n */\nint i2d_ECDSA_SIG(const ECDSA_SIG *sig, unsigned char **pp);\n\n/** Decodes a DER encoded ECDSA signature (note: this function changes *pp\n *  (*pp += len)).\n *  \\param  sig  pointer to ECDSA_SIG pointer (may be NULL)\n *  \\param  pp   memory buffer with the DER encoded signature\n *  \\param  len  length of the buffer\n *  \\return pointer to the decoded ECDSA_SIG structure (or NULL)\n */\nECDSA_SIG *d2i_ECDSA_SIG(ECDSA_SIG **sig, const unsigned char **pp, long len);\n\n/** Accessor for r and s fields of ECDSA_SIG\n *  \\param  sig  pointer to ECDSA_SIG structure\n *  \\param  pr   pointer to BIGNUM pointer for r (may be NULL)\n *  \\param  ps   pointer to BIGNUM pointer for s (may be NULL)\n */\nvoid ECDSA_SIG_get0(const ECDSA_SIG *sig, const BIGNUM **pr, const BIGNUM **ps);\n\n/** Accessor for r field of ECDSA_SIG\n *  \\param  sig  pointer to ECDSA_SIG structure\n */\nconst BIGNUM *ECDSA_SIG_get0_r(const ECDSA_SIG *sig);\n\n/** Accessor for s field of ECDSA_SIG\n *  \\param  sig  pointer to ECDSA_SIG structure\n */\nconst BIGNUM *ECDSA_SIG_get0_s(const ECDSA_SIG *sig);\n\n/** Setter for r and s fields of ECDSA_SIG\n *  \\param  sig  pointer to ECDSA_SIG structure\n *  \\param  r    pointer to BIGNUM for r (may be NULL)\n *  \\param  s    pointer to BIGNUM for s (may be NULL)\n */\nint ECDSA_SIG_set0(ECDSA_SIG *sig, BIGNUM *r, BIGNUM *s);\n\n/** Computes the ECDSA signature of the given hash value using\n *  the supplied private key and returns the created signature.\n *  \\param  dgst      pointer to the hash value\n *  \\param  dgst_len  length of the hash value\n *  \\param  eckey     EC_KEY object containing a private EC key\n *  \\return pointer to a ECDSA_SIG structure or NULL if an error occurred\n */\nECDSA_SIG *ECDSA_do_sign(const unsigned char *dgst, int dgst_len,\n                         EC_KEY *eckey);\n\n/** Computes ECDSA signature of a given hash value using the supplied\n *  private key (note: sig must point to ECDSA_size(eckey) bytes of memory).\n *  \\param  dgst     pointer to the hash value to sign\n *  \\param  dgstlen  length of the hash value\n *  \\param  kinv     BIGNUM with a pre-computed inverse k (optional)\n *  \\param  rp       BIGNUM with a pre-computed rp value (optional),\n *                   see ECDSA_sign_setup\n *  \\param  eckey    EC_KEY object containing a private EC key\n *  \\return pointer to a ECDSA_SIG structure or NULL if an error occurred\n */\nECDSA_SIG *ECDSA_do_sign_ex(const unsigned char *dgst, int dgstlen,\n                            const BIGNUM *kinv, const BIGNUM *rp,\n                            EC_KEY *eckey);\n\n/** Verifies that the supplied signature is a valid ECDSA\n *  signature of the supplied hash value using the supplied public key.\n *  \\param  dgst      pointer to the hash value\n *  \\param  dgst_len  length of the hash value\n *  \\param  sig       ECDSA_SIG structure\n *  \\param  eckey     EC_KEY object containing a public EC key\n *  \\return 1 if the signature is valid, 0 if the signature is invalid\n *          and -1 on error\n */\nint ECDSA_do_verify(const unsigned char *dgst, int dgst_len,\n                    const ECDSA_SIG *sig, EC_KEY *eckey);\n\n/** Precompute parts of the signing operation\n *  \\param  eckey  EC_KEY object containing a private EC key\n *  \\param  ctx    BN_CTX object (optional)\n *  \\param  kinv   BIGNUM pointer for the inverse of k\n *  \\param  rp     BIGNUM pointer for x coordinate of k * generator\n *  \\return 1 on success and 0 otherwise\n */\nint ECDSA_sign_setup(EC_KEY *eckey, BN_CTX *ctx, BIGNUM **kinv, BIGNUM **rp);\n\n/** Computes ECDSA signature of a given hash value using the supplied\n *  private key (note: sig must point to ECDSA_size(eckey) bytes of memory).\n *  \\param  type     this parameter is ignored\n *  \\param  dgst     pointer to the hash value to sign\n *  \\param  dgstlen  length of the hash value\n *  \\param  sig      memory for the DER encoded created signature\n *  \\param  siglen   pointer to the length of the returned signature\n *  \\param  eckey    EC_KEY object containing a private EC key\n *  \\return 1 on success and 0 otherwise\n */\nint ECDSA_sign(int type, const unsigned char *dgst, int dgstlen,\n               unsigned char *sig, unsigned int *siglen, EC_KEY *eckey);\n\n/** Computes ECDSA signature of a given hash value using the supplied\n *  private key (note: sig must point to ECDSA_size(eckey) bytes of memory).\n *  \\param  type     this parameter is ignored\n *  \\param  dgst     pointer to the hash value to sign\n *  \\param  dgstlen  length of the hash value\n *  \\param  sig      buffer to hold the DER encoded signature\n *  \\param  siglen   pointer to the length of the returned signature\n *  \\param  kinv     BIGNUM with a pre-computed inverse k (optional)\n *  \\param  rp       BIGNUM with a pre-computed rp value (optional),\n *                   see ECDSA_sign_setup\n *  \\param  eckey    EC_KEY object containing a private EC key\n *  \\return 1 on success and 0 otherwise\n */\nint ECDSA_sign_ex(int type, const unsigned char *dgst, int dgstlen,\n                  unsigned char *sig, unsigned int *siglen,\n                  const BIGNUM *kinv, const BIGNUM *rp, EC_KEY *eckey);\n\n/** Verifies that the given signature is valid ECDSA signature\n *  of the supplied hash value using the specified public key.\n *  \\param  type     this parameter is ignored\n *  \\param  dgst     pointer to the hash value\n *  \\param  dgstlen  length of the hash value\n *  \\param  sig      pointer to the DER encoded signature\n *  \\param  siglen   length of the DER encoded signature\n *  \\param  eckey    EC_KEY object containing a public EC key\n *  \\return 1 if the signature is valid, 0 if the signature is invalid\n *          and -1 on error\n */\nint ECDSA_verify(int type, const unsigned char *dgst, int dgstlen,\n                 const unsigned char *sig, int siglen, EC_KEY *eckey);\n\n/** Returns the maximum length of the DER encoded signature\n *  \\param  eckey  EC_KEY object\n *  \\return numbers of bytes required for the DER encoded signature\n */\nint ECDSA_size(const EC_KEY *eckey);\n\n/********************************************************************/\n/*  EC_KEY_METHOD constructors, destructors, writers and accessors  */\n/********************************************************************/\n\nEC_KEY_METHOD *EC_KEY_METHOD_new(const EC_KEY_METHOD *meth);\nvoid EC_KEY_METHOD_free(EC_KEY_METHOD *meth);\nvoid EC_KEY_METHOD_set_init(EC_KEY_METHOD *meth,\n                            int (*init)(EC_KEY *key),\n                            void (*finish)(EC_KEY *key),\n                            int (*copy)(EC_KEY *dest, const EC_KEY *src),\n                            int (*set_group)(EC_KEY *key, const EC_GROUP *grp),\n                            int (*set_private)(EC_KEY *key,\n                                               const BIGNUM *priv_key),\n                            int (*set_public)(EC_KEY *key,\n                                              const EC_POINT *pub_key));\n\nvoid EC_KEY_METHOD_set_keygen(EC_KEY_METHOD *meth,\n                              int (*keygen)(EC_KEY *key));\n\nvoid EC_KEY_METHOD_set_compute_key(EC_KEY_METHOD *meth,\n                                   int (*ckey)(unsigned char **psec,\n                                               size_t *pseclen,\n                                               const EC_POINT *pub_key,\n                                               const EC_KEY *ecdh));\n\nvoid EC_KEY_METHOD_set_sign(EC_KEY_METHOD *meth,\n                            int (*sign)(int type, const unsigned char *dgst,\n                                        int dlen, unsigned char *sig,\n                                        unsigned int *siglen,\n                                        const BIGNUM *kinv, const BIGNUM *r,\n                                        EC_KEY *eckey),\n                            int (*sign_setup)(EC_KEY *eckey, BN_CTX *ctx_in,\n                                              BIGNUM **kinvp, BIGNUM **rp),\n                            ECDSA_SIG *(*sign_sig)(const unsigned char *dgst,\n                                                   int dgst_len,\n                                                   const BIGNUM *in_kinv,\n                                                   const BIGNUM *in_r,\n                                                   EC_KEY *eckey));\n\nvoid EC_KEY_METHOD_set_verify(EC_KEY_METHOD *meth,\n                              int (*verify)(int type, const unsigned\n                                            char *dgst, int dgst_len,\n                                            const unsigned char *sigbuf,\n                                            int sig_len, EC_KEY *eckey),\n                              int (*verify_sig)(const unsigned char *dgst,\n                                                int dgst_len,\n                                                const ECDSA_SIG *sig,\n                                                EC_KEY *eckey));\n\nvoid EC_KEY_METHOD_get_init(const EC_KEY_METHOD *meth,\n                            int (**pinit)(EC_KEY *key),\n                            void (**pfinish)(EC_KEY *key),\n                            int (**pcopy)(EC_KEY *dest, const EC_KEY *src),\n                            int (**pset_group)(EC_KEY *key,\n                                               const EC_GROUP *grp),\n                            int (**pset_private)(EC_KEY *key,\n                                                 const BIGNUM *priv_key),\n                            int (**pset_public)(EC_KEY *key,\n                                                const EC_POINT *pub_key));\n\nvoid EC_KEY_METHOD_get_keygen(const EC_KEY_METHOD *meth,\n                              int (**pkeygen)(EC_KEY *key));\n\nvoid EC_KEY_METHOD_get_compute_key(const EC_KEY_METHOD *meth,\n                                   int (**pck)(unsigned char **psec,\n                                               size_t *pseclen,\n                                               const EC_POINT *pub_key,\n                                               const EC_KEY *ecdh));\n\nvoid EC_KEY_METHOD_get_sign(const EC_KEY_METHOD *meth,\n                            int (**psign)(int type, const unsigned char *dgst,\n                                          int dlen, unsigned char *sig,\n                                          unsigned int *siglen,\n                                          const BIGNUM *kinv, const BIGNUM *r,\n                                          EC_KEY *eckey),\n                            int (**psign_setup)(EC_KEY *eckey, BN_CTX *ctx_in,\n                                                BIGNUM **kinvp, BIGNUM **rp),\n                            ECDSA_SIG *(**psign_sig)(const unsigned char *dgst,\n                                                     int dgst_len,\n                                                     const BIGNUM *in_kinv,\n                                                     const BIGNUM *in_r,\n                                                     EC_KEY *eckey));\n\nvoid EC_KEY_METHOD_get_verify(const EC_KEY_METHOD *meth,\n                              int (**pverify)(int type, const unsigned\n                                              char *dgst, int dgst_len,\n                                              const unsigned char *sigbuf,\n                                              int sig_len, EC_KEY *eckey),\n                              int (**pverify_sig)(const unsigned char *dgst,\n                                                  int dgst_len,\n                                                  const ECDSA_SIG *sig,\n                                                  EC_KEY *eckey));\n\n# define ECParameters_dup(x) ASN1_dup_of(EC_KEY,i2d_ECParameters,d2i_ECParameters,x)\n\n# ifndef __cplusplus\n#  if defined(__SUNPRO_C)\n#   if __SUNPRO_C >= 0x520\n#    pragma error_messages (default,E_ARRAY_OF_INCOMPLETE_NONAME,E_ARRAY_OF_INCOMPLETE)\n#   endif\n#  endif\n# endif\n\n# define EVP_PKEY_CTX_set_ec_paramgen_curve_nid(ctx, nid) \\\n        EVP_PKEY_CTX_ctrl(ctx, EVP_PKEY_EC, \\\n                                EVP_PKEY_OP_PARAMGEN|EVP_PKEY_OP_KEYGEN, \\\n                                EVP_PKEY_CTRL_EC_PARAMGEN_CURVE_NID, nid, NULL)\n\n# define EVP_PKEY_CTX_set_ec_param_enc(ctx, flag) \\\n        EVP_PKEY_CTX_ctrl(ctx, EVP_PKEY_EC, \\\n                                EVP_PKEY_OP_PARAMGEN|EVP_PKEY_OP_KEYGEN, \\\n                                EVP_PKEY_CTRL_EC_PARAM_ENC, flag, NULL)\n\n# define EVP_PKEY_CTX_set_ecdh_cofactor_mode(ctx, flag) \\\n        EVP_PKEY_CTX_ctrl(ctx, EVP_PKEY_EC, \\\n                                EVP_PKEY_OP_DERIVE, \\\n                                EVP_PKEY_CTRL_EC_ECDH_COFACTOR, flag, NULL)\n\n# define EVP_PKEY_CTX_get_ecdh_cofactor_mode(ctx) \\\n        EVP_PKEY_CTX_ctrl(ctx, EVP_PKEY_EC, \\\n                                EVP_PKEY_OP_DERIVE, \\\n                                EVP_PKEY_CTRL_EC_ECDH_COFACTOR, -2, NULL)\n\n# define EVP_PKEY_CTX_set_ecdh_kdf_type(ctx, kdf) \\\n        EVP_PKEY_CTX_ctrl(ctx, EVP_PKEY_EC, \\\n                                EVP_PKEY_OP_DERIVE, \\\n                                EVP_PKEY_CTRL_EC_KDF_TYPE, kdf, NULL)\n\n# define EVP_PKEY_CTX_get_ecdh_kdf_type(ctx) \\\n        EVP_PKEY_CTX_ctrl(ctx, EVP_PKEY_EC, \\\n                                EVP_PKEY_OP_DERIVE, \\\n                                EVP_PKEY_CTRL_EC_KDF_TYPE, -2, NULL)\n\n# define EVP_PKEY_CTX_set_ecdh_kdf_md(ctx, md) \\\n        EVP_PKEY_CTX_ctrl(ctx, EVP_PKEY_EC, \\\n                                EVP_PKEY_OP_DERIVE, \\\n                                EVP_PKEY_CTRL_EC_KDF_MD, 0, (void *)(md))\n\n# define EVP_PKEY_CTX_get_ecdh_kdf_md(ctx, pmd) \\\n        EVP_PKEY_CTX_ctrl(ctx, EVP_PKEY_EC, \\\n                                EVP_PKEY_OP_DERIVE, \\\n                                EVP_PKEY_CTRL_GET_EC_KDF_MD, 0, (void *)(pmd))\n\n# define EVP_PKEY_CTX_set_ecdh_kdf_outlen(ctx, len) \\\n        EVP_PKEY_CTX_ctrl(ctx, EVP_PKEY_EC, \\\n                                EVP_PKEY_OP_DERIVE, \\\n                                EVP_PKEY_CTRL_EC_KDF_OUTLEN, len, NULL)\n\n# define EVP_PKEY_CTX_get_ecdh_kdf_outlen(ctx, plen) \\\n        EVP_PKEY_CTX_ctrl(ctx, EVP_PKEY_EC, \\\n                                EVP_PKEY_OP_DERIVE, \\\n                                EVP_PKEY_CTRL_GET_EC_KDF_OUTLEN, 0, \\\n                                (void *)(plen))\n\n# define EVP_PKEY_CTX_set0_ecdh_kdf_ukm(ctx, p, plen) \\\n        EVP_PKEY_CTX_ctrl(ctx, EVP_PKEY_EC, \\\n                                EVP_PKEY_OP_DERIVE, \\\n                                EVP_PKEY_CTRL_EC_KDF_UKM, plen, (void *)(p))\n\n# define EVP_PKEY_CTX_get0_ecdh_kdf_ukm(ctx, p) \\\n        EVP_PKEY_CTX_ctrl(ctx, EVP_PKEY_EC, \\\n                                EVP_PKEY_OP_DERIVE, \\\n                                EVP_PKEY_CTRL_GET_EC_KDF_UKM, 0, (void *)(p))\n\n/* SM2 will skip the operation check so no need to pass operation here */\n# define EVP_PKEY_CTX_set1_id(ctx, id, id_len) \\\n        EVP_PKEY_CTX_ctrl(ctx, -1, -1, \\\n                                EVP_PKEY_CTRL_SET1_ID, (int)id_len, (void*)(id))\n\n# define EVP_PKEY_CTX_get1_id(ctx, id) \\\n        EVP_PKEY_CTX_ctrl(ctx, -1, -1, \\\n                                EVP_PKEY_CTRL_GET1_ID, 0, (void*)(id))\n\n# define EVP_PKEY_CTX_get1_id_len(ctx, id_len) \\\n        EVP_PKEY_CTX_ctrl(ctx, -1, -1, \\\n                                EVP_PKEY_CTRL_GET1_ID_LEN, 0, (void*)(id_len))\n\n# define EVP_PKEY_CTRL_EC_PARAMGEN_CURVE_NID             (EVP_PKEY_ALG_CTRL + 1)\n# define EVP_PKEY_CTRL_EC_PARAM_ENC                      (EVP_PKEY_ALG_CTRL + 2)\n# define EVP_PKEY_CTRL_EC_ECDH_COFACTOR                  (EVP_PKEY_ALG_CTRL + 3)\n# define EVP_PKEY_CTRL_EC_KDF_TYPE                       (EVP_PKEY_ALG_CTRL + 4)\n# define EVP_PKEY_CTRL_EC_KDF_MD                         (EVP_PKEY_ALG_CTRL + 5)\n# define EVP_PKEY_CTRL_GET_EC_KDF_MD                     (EVP_PKEY_ALG_CTRL + 6)\n# define EVP_PKEY_CTRL_EC_KDF_OUTLEN                     (EVP_PKEY_ALG_CTRL + 7)\n# define EVP_PKEY_CTRL_GET_EC_KDF_OUTLEN                 (EVP_PKEY_ALG_CTRL + 8)\n# define EVP_PKEY_CTRL_EC_KDF_UKM                        (EVP_PKEY_ALG_CTRL + 9)\n# define EVP_PKEY_CTRL_GET_EC_KDF_UKM                    (EVP_PKEY_ALG_CTRL + 10)\n# define EVP_PKEY_CTRL_SET1_ID                           (EVP_PKEY_ALG_CTRL + 11)\n# define EVP_PKEY_CTRL_GET1_ID                           (EVP_PKEY_ALG_CTRL + 12)\n# define EVP_PKEY_CTRL_GET1_ID_LEN                       (EVP_PKEY_ALG_CTRL + 13)\n/* KDF types */\n# define EVP_PKEY_ECDH_KDF_NONE                          1\n# define EVP_PKEY_ECDH_KDF_X9_63                         2\n/** The old name for EVP_PKEY_ECDH_KDF_X9_63\n *  The ECDH KDF specification has been mistakingly attributed to ANSI X9.62,\n *  it is actually specified in ANSI X9.63.\n *  This identifier is retained for backwards compatibility\n */\n# define EVP_PKEY_ECDH_KDF_X9_62   EVP_PKEY_ECDH_KDF_X9_63\n\n\n#  ifdef  __cplusplus\n}\n#  endif\n# endif\n#endif\n"}, "5": {"id": 5, "path": "/usr/include/openssl/evp.h", "content": "/*\n * Copyright 1995-2019 The OpenSSL Project Authors. All Rights Reserved.\n *\n * Licensed under the OpenSSL license (the \"License\").  You may not use\n * this file except in compliance with the License.  You can obtain a copy\n * in the file LICENSE in the source distribution or at\n * https://www.openssl.org/source/license.html\n */\n\n#ifndef HEADER_ENVELOPE_H\n# define HEADER_ENVELOPE_H\n\n# include <openssl/opensslconf.h>\n# include <openssl/ossl_typ.h>\n# include <openssl/symhacks.h>\n# include <openssl/bio.h>\n# include <openssl/evperr.h>\n\n# define EVP_MAX_MD_SIZE                 64/* longest known is SHA512 */\n# define EVP_MAX_KEY_LENGTH              64\n# define EVP_MAX_IV_LENGTH               16\n# define EVP_MAX_BLOCK_LENGTH            32\n\n# define PKCS5_SALT_LEN                  8\n/* Default PKCS#5 iteration count */\n# define PKCS5_DEFAULT_ITER              2048\n\n# include <openssl/objects.h>\n\n# define EVP_PK_RSA      0x0001\n# define EVP_PK_DSA      0x0002\n# define EVP_PK_DH       0x0004\n# define EVP_PK_EC       0x0008\n# define EVP_PKT_SIGN    0x0010\n# define EVP_PKT_ENC     0x0020\n# define EVP_PKT_EXCH    0x0040\n# define EVP_PKS_RSA     0x0100\n# define EVP_PKS_DSA     0x0200\n# define EVP_PKS_EC      0x0400\n\n# define EVP_PKEY_NONE   NID_undef\n# define EVP_PKEY_RSA    NID_rsaEncryption\n# define EVP_PKEY_RSA2   NID_rsa\n# define EVP_PKEY_RSA_PSS NID_rsassaPss\n# define EVP_PKEY_DSA    NID_dsa\n# define EVP_PKEY_DSA1   NID_dsa_2\n# define EVP_PKEY_DSA2   NID_dsaWithSHA\n# define EVP_PKEY_DSA3   NID_dsaWithSHA1\n# define EVP_PKEY_DSA4   NID_dsaWithSHA1_2\n# define EVP_PKEY_DH     NID_dhKeyAgreement\n# define EVP_PKEY_DHX    NID_dhpublicnumber\n# define EVP_PKEY_EC     NID_X9_62_id_ecPublicKey\n# define EVP_PKEY_SM2    NID_sm2\n# define EVP_PKEY_HMAC   NID_hmac\n# define EVP_PKEY_CMAC   NID_cmac\n# define EVP_PKEY_SCRYPT NID_id_scrypt\n# define EVP_PKEY_TLS1_PRF NID_tls1_prf\n# define EVP_PKEY_HKDF   NID_hkdf\n# define EVP_PKEY_POLY1305 NID_poly1305\n# define EVP_PKEY_SIPHASH NID_siphash\n# define EVP_PKEY_X25519 NID_X25519\n# define EVP_PKEY_ED25519 NID_ED25519\n# define EVP_PKEY_X448 NID_X448\n# define EVP_PKEY_ED448 NID_ED448\n\n#ifdef  __cplusplus\nextern \"C\" {\n#endif\n\n# define EVP_PKEY_MO_SIGN        0x0001\n# define EVP_PKEY_MO_VERIFY      0x0002\n# define EVP_PKEY_MO_ENCRYPT     0x0004\n# define EVP_PKEY_MO_DECRYPT     0x0008\n\n# ifndef EVP_MD\nEVP_MD *EVP_MD_meth_new(int md_type, int pkey_type);\nEVP_MD *EVP_MD_meth_dup(const EVP_MD *md);\nvoid EVP_MD_meth_free(EVP_MD *md);\n\nint EVP_MD_meth_set_input_blocksize(EVP_MD *md, int blocksize);\nint EVP_MD_meth_set_result_size(EVP_MD *md, int resultsize);\nint EVP_MD_meth_set_app_datasize(EVP_MD *md, int datasize);\nint EVP_MD_meth_set_flags(EVP_MD *md, unsigned long flags);\nint EVP_MD_meth_set_init(EVP_MD *md, int (*init)(EVP_MD_CTX *ctx));\nint EVP_MD_meth_set_update(EVP_MD *md, int (*update)(EVP_MD_CTX *ctx,\n                                                     const void *data,\n                                                     size_t count));\nint EVP_MD_meth_set_final(EVP_MD *md, int (*final)(EVP_MD_CTX *ctx,\n                                                   unsigned char *md));\nint EVP_MD_meth_set_copy(EVP_MD *md, int (*copy)(EVP_MD_CTX *to,\n                                                 const EVP_MD_CTX *from));\nint EVP_MD_meth_set_cleanup(EVP_MD *md, int (*cleanup)(EVP_MD_CTX *ctx));\nint EVP_MD_meth_set_ctrl(EVP_MD *md, int (*ctrl)(EVP_MD_CTX *ctx, int cmd,\n                                                 int p1, void *p2));\n\nint EVP_MD_meth_get_input_blocksize(const EVP_MD *md);\nint EVP_MD_meth_get_result_size(const EVP_MD *md);\nint EVP_MD_meth_get_app_datasize(const EVP_MD *md);\nunsigned long EVP_MD_meth_get_flags(const EVP_MD *md);\nint (*EVP_MD_meth_get_init(const EVP_MD *md))(EVP_MD_CTX *ctx);\nint (*EVP_MD_meth_get_update(const EVP_MD *md))(EVP_MD_CTX *ctx,\n                                                const void *data,\n                                                size_t count);\nint (*EVP_MD_meth_get_final(const EVP_MD *md))(EVP_MD_CTX *ctx,\n                                               unsigned char *md);\nint (*EVP_MD_meth_get_copy(const EVP_MD *md))(EVP_MD_CTX *to,\n                                              const EVP_MD_CTX *from);\nint (*EVP_MD_meth_get_cleanup(const EVP_MD *md))(EVP_MD_CTX *ctx);\nint (*EVP_MD_meth_get_ctrl(const EVP_MD *md))(EVP_MD_CTX *ctx, int cmd,\n                                              int p1, void *p2);\n\n/* digest can only handle a single block */\n#  define EVP_MD_FLAG_ONESHOT     0x0001\n\n/* digest is extensible-output function, XOF */\n#  define EVP_MD_FLAG_XOF         0x0002\n\n/* DigestAlgorithmIdentifier flags... */\n\n#  define EVP_MD_FLAG_DIGALGID_MASK               0x0018\n\n/* NULL or absent parameter accepted. Use NULL */\n\n#  define EVP_MD_FLAG_DIGALGID_NULL               0x0000\n\n/* NULL or absent parameter accepted. Use NULL for PKCS#1 otherwise absent */\n\n#  define EVP_MD_FLAG_DIGALGID_ABSENT             0x0008\n\n/* Custom handling via ctrl */\n\n#  define EVP_MD_FLAG_DIGALGID_CUSTOM             0x0018\n\n/* Note if suitable for use in FIPS mode */\n#  define EVP_MD_FLAG_FIPS        0x0400\n\n/* Digest ctrls */\n\n#  define EVP_MD_CTRL_DIGALGID                    0x1\n#  define EVP_MD_CTRL_MICALG                      0x2\n#  define EVP_MD_CTRL_XOF_LEN                     0x3\n\n/* Minimum Algorithm specific ctrl value */\n\n#  define EVP_MD_CTRL_ALG_CTRL                    0x1000\n\n# endif                         /* !EVP_MD */\n\n/* values for EVP_MD_CTX flags */\n\n# define EVP_MD_CTX_FLAG_ONESHOT         0x0001/* digest update will be\n                                                * called once only */\n# define EVP_MD_CTX_FLAG_CLEANED         0x0002/* context has already been\n                                                * cleaned */\n# define EVP_MD_CTX_FLAG_REUSE           0x0004/* Don't free up ctx->md_data\n                                                * in EVP_MD_CTX_reset */\n/*\n * FIPS and pad options are ignored in 1.0.0, definitions are here so we\n * don't accidentally reuse the values for other purposes.\n */\n\n# define EVP_MD_CTX_FLAG_NON_FIPS_ALLOW  0x0008/* Allow use of non FIPS\n                                                * digest in FIPS mode */\n\n/*\n * The following PAD options are also currently ignored in 1.0.0, digest\n * parameters are handled through EVP_DigestSign*() and EVP_DigestVerify*()\n * instead.\n */\n# define EVP_MD_CTX_FLAG_PAD_MASK        0xF0/* RSA mode to use */\n# define EVP_MD_CTX_FLAG_PAD_PKCS1       0x00/* PKCS#1 v1.5 mode */\n# define EVP_MD_CTX_FLAG_PAD_X931        0x10/* X9.31 mode */\n# define EVP_MD_CTX_FLAG_PAD_PSS         0x20/* PSS mode */\n\n# define EVP_MD_CTX_FLAG_NO_INIT         0x0100/* Don't initialize md_data */\n/*\n * Some functions such as EVP_DigestSign only finalise copies of internal\n * contexts so additional data can be included after the finalisation call.\n * This is inefficient if this functionality is not required: it is disabled\n * if the following flag is set.\n */\n# define EVP_MD_CTX_FLAG_FINALISE        0x0200\n/* NOTE: 0x0400 is reserved for internal usage */\n\nEVP_CIPHER *EVP_CIPHER_meth_new(int cipher_type, int block_size, int key_len);\nEVP_CIPHER *EVP_CIPHER_meth_dup(const EVP_CIPHER *cipher);\nvoid EVP_CIPHER_meth_free(EVP_CIPHER *cipher);\n\nint EVP_CIPHER_meth_set_iv_length(EVP_CIPHER *cipher, int iv_len);\nint EVP_CIPHER_meth_set_flags(EVP_CIPHER *cipher, unsigned long flags);\nint EVP_CIPHER_meth_set_impl_ctx_size(EVP_CIPHER *cipher, int ctx_size);\nint EVP_CIPHER_meth_set_init(EVP_CIPHER *cipher,\n                             int (*init) (EVP_CIPHER_CTX *ctx,\n                                          const unsigned char *key,\n                                          const unsigned char *iv,\n                                          int enc));\nint EVP_CIPHER_meth_set_do_cipher(EVP_CIPHER *cipher,\n                                  int (*do_cipher) (EVP_CIPHER_CTX *ctx,\n                                                    unsigned char *out,\n                                                    const unsigned char *in,\n                                                    size_t inl));\nint EVP_CIPHER_meth_set_cleanup(EVP_CIPHER *cipher,\n                                int (*cleanup) (EVP_CIPHER_CTX *));\nint EVP_CIPHER_meth_set_set_asn1_params(EVP_CIPHER *cipher,\n                                        int (*set_asn1_parameters) (EVP_CIPHER_CTX *,\n                                                                    ASN1_TYPE *));\nint EVP_CIPHER_meth_set_get_asn1_params(EVP_CIPHER *cipher,\n                                        int (*get_asn1_parameters) (EVP_CIPHER_CTX *,\n                                                                    ASN1_TYPE *));\nint EVP_CIPHER_meth_set_ctrl(EVP_CIPHER *cipher,\n                             int (*ctrl) (EVP_CIPHER_CTX *, int type,\n                                          int arg, void *ptr));\n\nint (*EVP_CIPHER_meth_get_init(const EVP_CIPHER *cipher))(EVP_CIPHER_CTX *ctx,\n                                                          const unsigned char *key,\n                                                          const unsigned char *iv,\n                                                          int enc);\nint (*EVP_CIPHER_meth_get_do_cipher(const EVP_CIPHER *cipher))(EVP_CIPHER_CTX *ctx,\n                                                               unsigned char *out,\n                                                               const unsigned char *in,\n                                                               size_t inl);\nint (*EVP_CIPHER_meth_get_cleanup(const EVP_CIPHER *cipher))(EVP_CIPHER_CTX *);\nint (*EVP_CIPHER_meth_get_set_asn1_params(const EVP_CIPHER *cipher))(EVP_CIPHER_CTX *,\n                                                                     ASN1_TYPE *);\nint (*EVP_CIPHER_meth_get_get_asn1_params(const EVP_CIPHER *cipher))(EVP_CIPHER_CTX *,\n                                                               ASN1_TYPE *);\nint (*EVP_CIPHER_meth_get_ctrl(const EVP_CIPHER *cipher))(EVP_CIPHER_CTX *,\n                                                          int type, int arg,\n                                                          void *ptr);\n\n/* Values for cipher flags */\n\n/* Modes for ciphers */\n\n# define         EVP_CIPH_STREAM_CIPHER          0x0\n# define         EVP_CIPH_ECB_MODE               0x1\n# define         EVP_CIPH_CBC_MODE               0x2\n# define         EVP_CIPH_CFB_MODE               0x3\n# define         EVP_CIPH_OFB_MODE               0x4\n# define         EVP_CIPH_CTR_MODE               0x5\n# define         EVP_CIPH_GCM_MODE               0x6\n# define         EVP_CIPH_CCM_MODE               0x7\n# define         EVP_CIPH_XTS_MODE               0x10001\n# define         EVP_CIPH_WRAP_MODE              0x10002\n# define         EVP_CIPH_OCB_MODE               0x10003\n# define         EVP_CIPH_MODE                   0xF0007\n/* Set if variable length cipher */\n# define         EVP_CIPH_VARIABLE_LENGTH        0x8\n/* Set if the iv handling should be done by the cipher itself */\n# define         EVP_CIPH_CUSTOM_IV              0x10\n/* Set if the cipher's init() function should be called if key is NULL */\n# define         EVP_CIPH_ALWAYS_CALL_INIT       0x20\n/* Call ctrl() to init cipher parameters */\n# define         EVP_CIPH_CTRL_INIT              0x40\n/* Don't use standard key length function */\n# define         EVP_CIPH_CUSTOM_KEY_LENGTH      0x80\n/* Don't use standard block padding */\n# define         EVP_CIPH_NO_PADDING             0x100\n/* cipher handles random key generation */\n# define         EVP_CIPH_RAND_KEY               0x200\n/* cipher has its own additional copying logic */\n# define         EVP_CIPH_CUSTOM_COPY            0x400\n/* Don't use standard iv length function */\n# define         EVP_CIPH_CUSTOM_IV_LENGTH       0x800\n/* Allow use default ASN1 get/set iv */\n# define         EVP_CIPH_FLAG_DEFAULT_ASN1      0x1000\n/* Buffer length in bits not bytes: CFB1 mode only */\n# define         EVP_CIPH_FLAG_LENGTH_BITS       0x2000\n/* Note if suitable for use in FIPS mode */\n# define         EVP_CIPH_FLAG_FIPS              0x4000\n/* Allow non FIPS cipher in FIPS mode */\n# define         EVP_CIPH_FLAG_NON_FIPS_ALLOW    0x8000\n/*\n * Cipher handles any and all padding logic as well as finalisation.\n */\n# define         EVP_CIPH_FLAG_CUSTOM_CIPHER     0x100000\n# define         EVP_CIPH_FLAG_AEAD_CIPHER       0x200000\n# define         EVP_CIPH_FLAG_TLS1_1_MULTIBLOCK 0x400000\n/* Cipher can handle pipeline operations */\n# define         EVP_CIPH_FLAG_PIPELINE          0X800000\n\n/*\n * Cipher context flag to indicate we can handle wrap mode: if allowed in\n * older applications it could overflow buffers.\n */\n\n# define         EVP_CIPHER_CTX_FLAG_WRAP_ALLOW  0x1\n\n/* ctrl() values */\n\n# define         EVP_CTRL_INIT                   0x0\n# define         EVP_CTRL_SET_KEY_LENGTH         0x1\n# define         EVP_CTRL_GET_RC2_KEY_BITS       0x2\n# define         EVP_CTRL_SET_RC2_KEY_BITS       0x3\n# define         EVP_CTRL_GET_RC5_ROUNDS         0x4\n# define         EVP_CTRL_SET_RC5_ROUNDS         0x5\n# define         EVP_CTRL_RAND_KEY               0x6\n# define         EVP_CTRL_PBE_PRF_NID            0x7\n# define         EVP_CTRL_COPY                   0x8\n# define         EVP_CTRL_AEAD_SET_IVLEN         0x9\n# define         EVP_CTRL_AEAD_GET_TAG           0x10\n# define         EVP_CTRL_AEAD_SET_TAG           0x11\n# define         EVP_CTRL_AEAD_SET_IV_FIXED      0x12\n# define         EVP_CTRL_GCM_SET_IVLEN          EVP_CTRL_AEAD_SET_IVLEN\n# define         EVP_CTRL_GCM_GET_TAG            EVP_CTRL_AEAD_GET_TAG\n# define         EVP_CTRL_GCM_SET_TAG            EVP_CTRL_AEAD_SET_TAG\n# define         EVP_CTRL_GCM_SET_IV_FIXED       EVP_CTRL_AEAD_SET_IV_FIXED\n# define         EVP_CTRL_GCM_IV_GEN             0x13\n# define         EVP_CTRL_CCM_SET_IVLEN          EVP_CTRL_AEAD_SET_IVLEN\n# define         EVP_CTRL_CCM_GET_TAG            EVP_CTRL_AEAD_GET_TAG\n# define         EVP_CTRL_CCM_SET_TAG            EVP_CTRL_AEAD_SET_TAG\n# define         EVP_CTRL_CCM_SET_IV_FIXED       EVP_CTRL_AEAD_SET_IV_FIXED\n# define         EVP_CTRL_CCM_SET_L              0x14\n# define         EVP_CTRL_CCM_SET_MSGLEN         0x15\n/*\n * AEAD cipher deduces payload length and returns number of bytes required to\n * store MAC and eventual padding. Subsequent call to EVP_Cipher even\n * appends/verifies MAC.\n */\n# define         EVP_CTRL_AEAD_TLS1_AAD          0x16\n/* Used by composite AEAD ciphers, no-op in GCM, CCM... */\n# define         EVP_CTRL_AEAD_SET_MAC_KEY       0x17\n/* Set the GCM invocation field, decrypt only */\n# define         EVP_CTRL_GCM_SET_IV_INV         0x18\n\n# define         EVP_CTRL_TLS1_1_MULTIBLOCK_AAD  0x19\n# define         EVP_CTRL_TLS1_1_MULTIBLOCK_ENCRYPT      0x1a\n# define         EVP_CTRL_TLS1_1_MULTIBLOCK_DECRYPT      0x1b\n# define         EVP_CTRL_TLS1_1_MULTIBLOCK_MAX_BUFSIZE  0x1c\n\n# define         EVP_CTRL_SSL3_MASTER_SECRET             0x1d\n\n/* EVP_CTRL_SET_SBOX takes the char * specifying S-boxes */\n# define         EVP_CTRL_SET_SBOX                       0x1e\n/*\n * EVP_CTRL_SBOX_USED takes a 'size_t' and 'char *', pointing at a\n * pre-allocated buffer with specified size\n */\n# define         EVP_CTRL_SBOX_USED                      0x1f\n/* EVP_CTRL_KEY_MESH takes 'size_t' number of bytes to mesh the key after,\n * 0 switches meshing off\n */\n# define         EVP_CTRL_KEY_MESH                       0x20\n/* EVP_CTRL_BLOCK_PADDING_MODE takes the padding mode */\n# define         EVP_CTRL_BLOCK_PADDING_MODE             0x21\n\n/* Set the output buffers to use for a pipelined operation */\n# define         EVP_CTRL_SET_PIPELINE_OUTPUT_BUFS       0x22\n/* Set the input buffers to use for a pipelined operation */\n# define         EVP_CTRL_SET_PIPELINE_INPUT_BUFS        0x23\n/* Set the input buffer lengths to use for a pipelined operation */\n# define         EVP_CTRL_SET_PIPELINE_INPUT_LENS        0x24\n\n# define         EVP_CTRL_GET_IVLEN                      0x25\n\n/* Padding modes */\n#define EVP_PADDING_PKCS7       1\n#define EVP_PADDING_ISO7816_4   2\n#define EVP_PADDING_ANSI923     3\n#define EVP_PADDING_ISO10126    4\n#define EVP_PADDING_ZERO        5\n\n/* RFC 5246 defines additional data to be 13 bytes in length */\n# define         EVP_AEAD_TLS1_AAD_LEN           13\n\ntypedef struct {\n    unsigned char *out;\n    const unsigned char *inp;\n    size_t len;\n    unsigned int interleave;\n} EVP_CTRL_TLS1_1_MULTIBLOCK_PARAM;\n\n/* GCM TLS constants */\n/* Length of fixed part of IV derived from PRF */\n# define EVP_GCM_TLS_FIXED_IV_LEN                        4\n/* Length of explicit part of IV part of TLS records */\n# define EVP_GCM_TLS_EXPLICIT_IV_LEN                     8\n/* Length of tag for TLS */\n# define EVP_GCM_TLS_TAG_LEN                             16\n\n/* CCM TLS constants */\n/* Length of fixed part of IV derived from PRF */\n# define EVP_CCM_TLS_FIXED_IV_LEN                        4\n/* Length of explicit part of IV part of TLS records */\n# define EVP_CCM_TLS_EXPLICIT_IV_LEN                     8\n/* Total length of CCM IV length for TLS */\n# define EVP_CCM_TLS_IV_LEN                              12\n/* Length of tag for TLS */\n# define EVP_CCM_TLS_TAG_LEN                             16\n/* Length of CCM8 tag for TLS */\n# define EVP_CCM8_TLS_TAG_LEN                            8\n\n/* Length of tag for TLS */\n# define EVP_CHACHAPOLY_TLS_TAG_LEN                      16\n\ntypedef struct evp_cipher_info_st {\n    const EVP_CIPHER *cipher;\n    unsigned char iv[EVP_MAX_IV_LENGTH];\n} EVP_CIPHER_INFO;\n\n\n/* Password based encryption function */\ntypedef int (EVP_PBE_KEYGEN) (EVP_CIPHER_CTX *ctx, const char *pass,\n                              int passlen, ASN1_TYPE *param,\n                              const EVP_CIPHER *cipher, const EVP_MD *md,\n                              int en_de);\n\n# ifndef OPENSSL_NO_RSA\n#  define EVP_PKEY_assign_RSA(pkey,rsa) EVP_PKEY_assign((pkey),EVP_PKEY_RSA,\\\n                                        (char *)(rsa))\n# endif\n\n# ifndef OPENSSL_NO_DSA\n#  define EVP_PKEY_assign_DSA(pkey,dsa) EVP_PKEY_assign((pkey),EVP_PKEY_DSA,\\\n                                        (char *)(dsa))\n# endif\n\n# ifndef OPENSSL_NO_DH\n#  define EVP_PKEY_assign_DH(pkey,dh) EVP_PKEY_assign((pkey),EVP_PKEY_DH,\\\n                                        (char *)(dh))\n# endif\n\n# ifndef OPENSSL_NO_EC\n#  define EVP_PKEY_assign_EC_KEY(pkey,eckey) EVP_PKEY_assign((pkey),EVP_PKEY_EC,\\\n                                        (char *)(eckey))\n# endif\n# ifndef OPENSSL_NO_SIPHASH\n#  define EVP_PKEY_assign_SIPHASH(pkey,shkey) EVP_PKEY_assign((pkey),EVP_PKEY_SIPHASH,\\\n                                        (char *)(shkey))\n# endif\n\n# ifndef OPENSSL_NO_POLY1305\n#  define EVP_PKEY_assign_POLY1305(pkey,polykey) EVP_PKEY_assign((pkey),EVP_PKEY_POLY1305,\\\n                                        (char *)(polykey))\n# endif\n\n/* Add some extra combinations */\n# define EVP_get_digestbynid(a) EVP_get_digestbyname(OBJ_nid2sn(a))\n# define EVP_get_digestbyobj(a) EVP_get_digestbynid(OBJ_obj2nid(a))\n# define EVP_get_cipherbynid(a) EVP_get_cipherbyname(OBJ_nid2sn(a))\n# define EVP_get_cipherbyobj(a) EVP_get_cipherbynid(OBJ_obj2nid(a))\n\nint EVP_MD_type(const EVP_MD *md);\n# define EVP_MD_nid(e)                   EVP_MD_type(e)\n# define EVP_MD_name(e)                  OBJ_nid2sn(EVP_MD_nid(e))\nint EVP_MD_pkey_type(const EVP_MD *md);\nint EVP_MD_size(const EVP_MD *md);\nint EVP_MD_block_size(const EVP_MD *md);\nunsigned long EVP_MD_flags(const EVP_MD *md);\n\nconst EVP_MD *EVP_MD_CTX_md(const EVP_MD_CTX *ctx);\nint (*EVP_MD_CTX_update_fn(EVP_MD_CTX *ctx))(EVP_MD_CTX *ctx,\n                                             const void *data, size_t count);\nvoid EVP_MD_CTX_set_update_fn(EVP_MD_CTX *ctx,\n                              int (*update) (EVP_MD_CTX *ctx,\n                                             const void *data, size_t count));\n# define EVP_MD_CTX_size(e)              EVP_MD_size(EVP_MD_CTX_md(e))\n# define EVP_MD_CTX_block_size(e)        EVP_MD_block_size(EVP_MD_CTX_md(e))\n# define EVP_MD_CTX_type(e)              EVP_MD_type(EVP_MD_CTX_md(e))\nEVP_PKEY_CTX *EVP_MD_CTX_pkey_ctx(const EVP_MD_CTX *ctx);\nvoid EVP_MD_CTX_set_pkey_ctx(EVP_MD_CTX *ctx, EVP_PKEY_CTX *pctx);\nvoid *EVP_MD_CTX_md_data(const EVP_MD_CTX *ctx);\n\nint EVP_CIPHER_nid(const EVP_CIPHER *cipher);\n# define EVP_CIPHER_name(e)              OBJ_nid2sn(EVP_CIPHER_nid(e))\nint EVP_CIPHER_block_size(const EVP_CIPHER *cipher);\nint EVP_CIPHER_impl_ctx_size(const EVP_CIPHER *cipher);\nint EVP_CIPHER_key_length(const EVP_CIPHER *cipher);\nint EVP_CIPHER_iv_length(const EVP_CIPHER *cipher);\nunsigned long EVP_CIPHER_flags(const EVP_CIPHER *cipher);\n# define EVP_CIPHER_mode(e)              (EVP_CIPHER_flags(e) & EVP_CIPH_MODE)\n\nconst EVP_CIPHER *EVP_CIPHER_CTX_cipher(const EVP_CIPHER_CTX *ctx);\nint EVP_CIPHER_CTX_encrypting(const EVP_CIPHER_CTX *ctx);\nint EVP_CIPHER_CTX_nid(const EVP_CIPHER_CTX *ctx);\nint EVP_CIPHER_CTX_block_size(const EVP_CIPHER_CTX *ctx);\nint EVP_CIPHER_CTX_key_length(const EVP_CIPHER_CTX *ctx);\nint EVP_CIPHER_CTX_iv_length(const EVP_CIPHER_CTX *ctx);\nconst unsigned char *EVP_CIPHER_CTX_iv(const EVP_CIPHER_CTX *ctx);\nconst unsigned char *EVP_CIPHER_CTX_original_iv(const EVP_CIPHER_CTX *ctx);\nunsigned char *EVP_CIPHER_CTX_iv_noconst(EVP_CIPHER_CTX *ctx);\nunsigned char *EVP_CIPHER_CTX_buf_noconst(EVP_CIPHER_CTX *ctx);\nint EVP_CIPHER_CTX_num(const EVP_CIPHER_CTX *ctx);\nvoid EVP_CIPHER_CTX_set_num(EVP_CIPHER_CTX *ctx, int num);\nint EVP_CIPHER_CTX_copy(EVP_CIPHER_CTX *out, const EVP_CIPHER_CTX *in);\nvoid *EVP_CIPHER_CTX_get_app_data(const EVP_CIPHER_CTX *ctx);\nvoid EVP_CIPHER_CTX_set_app_data(EVP_CIPHER_CTX *ctx, void *data);\nvoid *EVP_CIPHER_CTX_get_cipher_data(const EVP_CIPHER_CTX *ctx);\nvoid *EVP_CIPHER_CTX_set_cipher_data(EVP_CIPHER_CTX *ctx, void *cipher_data);\n# define EVP_CIPHER_CTX_type(c)         EVP_CIPHER_type(EVP_CIPHER_CTX_cipher(c))\n# if OPENSSL_API_COMPAT < 0x10100000L\n#  define EVP_CIPHER_CTX_flags(c)       EVP_CIPHER_flags(EVP_CIPHER_CTX_cipher(c))\n# endif\n# define EVP_CIPHER_CTX_mode(c)         EVP_CIPHER_mode(EVP_CIPHER_CTX_cipher(c))\n\n# define EVP_ENCODE_LENGTH(l)    ((((l)+2)/3*4)+((l)/48+1)*2+80)\n# define EVP_DECODE_LENGTH(l)    (((l)+3)/4*3+80)\n\n# define EVP_SignInit_ex(a,b,c)          EVP_DigestInit_ex(a,b,c)\n# define EVP_SignInit(a,b)               EVP_DigestInit(a,b)\n# define EVP_SignUpdate(a,b,c)           EVP_DigestUpdate(a,b,c)\n# define EVP_VerifyInit_ex(a,b,c)        EVP_DigestInit_ex(a,b,c)\n# define EVP_VerifyInit(a,b)             EVP_DigestInit(a,b)\n# define EVP_VerifyUpdate(a,b,c)         EVP_DigestUpdate(a,b,c)\n# define EVP_OpenUpdate(a,b,c,d,e)       EVP_DecryptUpdate(a,b,c,d,e)\n# define EVP_SealUpdate(a,b,c,d,e)       EVP_EncryptUpdate(a,b,c,d,e)\n# define EVP_DigestSignUpdate(a,b,c)     EVP_DigestUpdate(a,b,c)\n# define EVP_DigestVerifyUpdate(a,b,c)   EVP_DigestUpdate(a,b,c)\n\n# ifdef CONST_STRICT\nvoid BIO_set_md(BIO *, const EVP_MD *md);\n# else\n#  define BIO_set_md(b,md)          BIO_ctrl(b,BIO_C_SET_MD,0,(char *)(md))\n# endif\n# define BIO_get_md(b,mdp)          BIO_ctrl(b,BIO_C_GET_MD,0,(char *)(mdp))\n# define BIO_get_md_ctx(b,mdcp)     BIO_ctrl(b,BIO_C_GET_MD_CTX,0, \\\n                                             (char *)(mdcp))\n# define BIO_set_md_ctx(b,mdcp)     BIO_ctrl(b,BIO_C_SET_MD_CTX,0, \\\n                                             (char *)(mdcp))\n# define BIO_get_cipher_status(b)   BIO_ctrl(b,BIO_C_GET_CIPHER_STATUS,0,NULL)\n# define BIO_get_cipher_ctx(b,c_pp) BIO_ctrl(b,BIO_C_GET_CIPHER_CTX,0, \\\n                                             (char *)(c_pp))\n\n/*__owur*/ int EVP_Cipher(EVP_CIPHER_CTX *c,\n                          unsigned char *out,\n                          const unsigned char *in, unsigned int inl);\n\n# define EVP_add_cipher_alias(n,alias) \\\n        OBJ_NAME_add((alias),OBJ_NAME_TYPE_CIPHER_METH|OBJ_NAME_ALIAS,(n))\n# define EVP_add_digest_alias(n,alias) \\\n        OBJ_NAME_add((alias),OBJ_NAME_TYPE_MD_METH|OBJ_NAME_ALIAS,(n))\n# define EVP_delete_cipher_alias(alias) \\\n        OBJ_NAME_remove(alias,OBJ_NAME_TYPE_CIPHER_METH|OBJ_NAME_ALIAS);\n# define EVP_delete_digest_alias(alias) \\\n        OBJ_NAME_remove(alias,OBJ_NAME_TYPE_MD_METH|OBJ_NAME_ALIAS);\n\nint EVP_MD_CTX_ctrl(EVP_MD_CTX *ctx, int cmd, int p1, void *p2);\nEVP_MD_CTX *EVP_MD_CTX_new(void);\nint EVP_MD_CTX_reset(EVP_MD_CTX *ctx);\nvoid EVP_MD_CTX_free(EVP_MD_CTX *ctx);\n# define EVP_MD_CTX_create()     EVP_MD_CTX_new()\n# define EVP_MD_CTX_init(ctx)    EVP_MD_CTX_reset((ctx))\n# define EVP_MD_CTX_destroy(ctx) EVP_MD_CTX_free((ctx))\n__owur int EVP_MD_CTX_copy_ex(EVP_MD_CTX *out, const EVP_MD_CTX *in);\nvoid EVP_MD_CTX_set_flags(EVP_MD_CTX *ctx, int flags);\nvoid EVP_MD_CTX_clear_flags(EVP_MD_CTX *ctx, int flags);\nint EVP_MD_CTX_test_flags(const EVP_MD_CTX *ctx, int flags);\n__owur int EVP_DigestInit_ex(EVP_MD_CTX *ctx, const EVP_MD *type,\n                                 ENGINE *impl);\n__owur int EVP_DigestUpdate(EVP_MD_CTX *ctx, const void *d,\n                                size_t cnt);\n__owur int EVP_DigestFinal_ex(EVP_MD_CTX *ctx, unsigned char *md,\n                                  unsigned int *s);\n__owur int EVP_Digest(const void *data, size_t count,\n                          unsigned char *md, unsigned int *size,\n                          const EVP_MD *type, ENGINE *impl);\n\n__owur int EVP_MD_CTX_copy(EVP_MD_CTX *out, const EVP_MD_CTX *in);\n__owur int EVP_DigestInit(EVP_MD_CTX *ctx, const EVP_MD *type);\n__owur int EVP_DigestFinal(EVP_MD_CTX *ctx, unsigned char *md,\n                           unsigned int *s);\n__owur int EVP_DigestFinalXOF(EVP_MD_CTX *ctx, unsigned char *md,\n                              size_t len);\n\nint EVP_read_pw_string(char *buf, int length, const char *prompt, int verify);\nint EVP_read_pw_string_min(char *buf, int minlen, int maxlen,\n                           const char *prompt, int verify);\nvoid EVP_set_pw_prompt(const char *prompt);\nchar *EVP_get_pw_prompt(void);\n\n__owur int EVP_BytesToKey(const EVP_CIPHER *type, const EVP_MD *md,\n                          const unsigned char *salt,\n                          const unsigned char *data, int datal, int count,\n                          unsigned char *key, unsigned char *iv);\n\nvoid EVP_CIPHER_CTX_set_flags(EVP_CIPHER_CTX *ctx, int flags);\nvoid EVP_CIPHER_CTX_clear_flags(EVP_CIPHER_CTX *ctx, int flags);\nint EVP_CIPHER_CTX_test_flags(const EVP_CIPHER_CTX *ctx, int flags);\n\n__owur int EVP_EncryptInit(EVP_CIPHER_CTX *ctx, const EVP_CIPHER *cipher,\n                           const unsigned char *key, const unsigned char *iv);\n/*__owur*/ int EVP_EncryptInit_ex(EVP_CIPHER_CTX *ctx,\n                                  const EVP_CIPHER *cipher, ENGINE *impl,\n                                  const unsigned char *key,\n                                  const unsigned char *iv);\n/*__owur*/ int EVP_EncryptUpdate(EVP_CIPHER_CTX *ctx, unsigned char *out,\n                                 int *outl, const unsigned char *in, int inl);\n/*__owur*/ int EVP_EncryptFinal_ex(EVP_CIPHER_CTX *ctx, unsigned char *out,\n                                   int *outl);\n/*__owur*/ int EVP_EncryptFinal(EVP_CIPHER_CTX *ctx, unsigned char *out,\n                                int *outl);\n\n__owur int EVP_DecryptInit(EVP_CIPHER_CTX *ctx, const EVP_CIPHER *cipher,\n                           const unsigned char *key, const unsigned char *iv);\n/*__owur*/ int EVP_DecryptInit_ex(EVP_CIPHER_CTX *ctx,\n                                  const EVP_CIPHER *cipher, ENGINE *impl,\n                                  const unsigned char *key,\n                                  const unsigned char *iv);\n/*__owur*/ int EVP_DecryptUpdate(EVP_CIPHER_CTX *ctx, unsigned char *out,\n                                 int *outl, const unsigned char *in, int inl);\n__owur int EVP_DecryptFinal(EVP_CIPHER_CTX *ctx, unsigned char *outm,\n                            int *outl);\n/*__owur*/ int EVP_DecryptFinal_ex(EVP_CIPHER_CTX *ctx, unsigned char *outm,\n                                   int *outl);\n\n__owur int EVP_CipherInit(EVP_CIPHER_CTX *ctx, const EVP_CIPHER *cipher,\n                          const unsigned char *key, const unsigned char *iv,\n                          int enc);\n/*__owur*/ int EVP_CipherInit_ex(EVP_CIPHER_CTX *ctx,\n                                 const EVP_CIPHER *cipher, ENGINE *impl,\n                                 const unsigned char *key,\n                                 const unsigned char *iv, int enc);\n__owur int EVP_CipherUpdate(EVP_CIPHER_CTX *ctx, unsigned char *out,\n                            int *outl, const unsigned char *in, int inl);\n__owur int EVP_CipherFinal(EVP_CIPHER_CTX *ctx, unsigned char *outm,\n                           int *outl);\n__owur int EVP_CipherFinal_ex(EVP_CIPHER_CTX *ctx, unsigned char *outm,\n                              int *outl);\n\n__owur int EVP_SignFinal(EVP_MD_CTX *ctx, unsigned char *md, unsigned int *s,\n                         EVP_PKEY *pkey);\n\n__owur int EVP_DigestSign(EVP_MD_CTX *ctx, unsigned char *sigret,\n                          size_t *siglen, const unsigned char *tbs,\n                          size_t tbslen);\n\n__owur int EVP_VerifyFinal(EVP_MD_CTX *ctx, const unsigned char *sigbuf,\n                           unsigned int siglen, EVP_PKEY *pkey);\n\n__owur int EVP_DigestVerify(EVP_MD_CTX *ctx, const unsigned char *sigret,\n                            size_t siglen, const unsigned char *tbs,\n                            size_t tbslen);\n\n/*__owur*/ int EVP_DigestSignInit(EVP_MD_CTX *ctx, EVP_PKEY_CTX **pctx,\n                                  const EVP_MD *type, ENGINE *e,\n                                  EVP_PKEY *pkey);\n__owur int EVP_DigestSignFinal(EVP_MD_CTX *ctx, unsigned char *sigret,\n                               size_t *siglen);\n\n__owur int EVP_DigestVerifyInit(EVP_MD_CTX *ctx, EVP_PKEY_CTX **pctx,\n                                const EVP_MD *type, ENGINE *e,\n                                EVP_PKEY *pkey);\n__owur int EVP_DigestVerifyFinal(EVP_MD_CTX *ctx, const unsigned char *sig,\n                                 size_t siglen);\n\n# ifndef OPENSSL_NO_RSA\n__owur int EVP_OpenInit(EVP_CIPHER_CTX *ctx, const EVP_CIPHER *type,\n                        const unsigned char *ek, int ekl,\n                        const unsigned char *iv, EVP_PKEY *priv);\n__owur int EVP_OpenFinal(EVP_CIPHER_CTX *ctx, unsigned char *out, int *outl);\n\n__owur int EVP_SealInit(EVP_CIPHER_CTX *ctx, const EVP_CIPHER *type,\n                        unsigned char **ek, int *ekl, unsigned char *iv,\n                        EVP_PKEY **pubk, int npubk);\n__owur int EVP_SealFinal(EVP_CIPHER_CTX *ctx, unsigned char *out, int *outl);\n# endif\n\nEVP_ENCODE_CTX *EVP_ENCODE_CTX_new(void);\nvoid EVP_ENCODE_CTX_free(EVP_ENCODE_CTX *ctx);\nint EVP_ENCODE_CTX_copy(EVP_ENCODE_CTX *dctx, EVP_ENCODE_CTX *sctx);\nint EVP_ENCODE_CTX_num(EVP_ENCODE_CTX *ctx);\nvoid EVP_EncodeInit(EVP_ENCODE_CTX *ctx);\nint EVP_EncodeUpdate(EVP_ENCODE_CTX *ctx, unsigned char *out, int *outl,\n                     const unsigned char *in, int inl);\nvoid EVP_EncodeFinal(EVP_ENCODE_CTX *ctx, unsigned char *out, int *outl);\nint EVP_EncodeBlock(unsigned char *t, const unsigned char *f, int n);\n\nvoid EVP_DecodeInit(EVP_ENCODE_CTX *ctx);\nint EVP_DecodeUpdate(EVP_ENCODE_CTX *ctx, unsigned char *out, int *outl,\n                     const unsigned char *in, int inl);\nint EVP_DecodeFinal(EVP_ENCODE_CTX *ctx, unsigned\n                    char *out, int *outl);\nint EVP_DecodeBlock(unsigned char *t, const unsigned char *f, int n);\n\n# if OPENSSL_API_COMPAT < 0x10100000L\n#  define EVP_CIPHER_CTX_init(c)      EVP_CIPHER_CTX_reset(c)\n#  define EVP_CIPHER_CTX_cleanup(c)   EVP_CIPHER_CTX_reset(c)\n# endif\nEVP_CIPHER_CTX *EVP_CIPHER_CTX_new(void);\nint EVP_CIPHER_CTX_reset(EVP_CIPHER_CTX *c);\nvoid EVP_CIPHER_CTX_free(EVP_CIPHER_CTX *c);\nint EVP_CIPHER_CTX_set_key_length(EVP_CIPHER_CTX *x, int keylen);\nint EVP_CIPHER_CTX_set_padding(EVP_CIPHER_CTX *c, int pad);\nint EVP_CIPHER_CTX_ctrl(EVP_CIPHER_CTX *ctx, int type, int arg, void *ptr);\nint EVP_CIPHER_CTX_rand_key(EVP_CIPHER_CTX *ctx, unsigned char *key);\n\nconst BIO_METHOD *BIO_f_md(void);\nconst BIO_METHOD *BIO_f_base64(void);\nconst BIO_METHOD *BIO_f_cipher(void);\nconst BIO_METHOD *BIO_f_reliable(void);\n__owur int BIO_set_cipher(BIO *b, const EVP_CIPHER *c, const unsigned char *k,\n                          const unsigned char *i, int enc);\n\nconst EVP_MD *EVP_md_null(void);\n# ifndef OPENSSL_NO_MD2\nconst EVP_MD *EVP_md2(void);\n# endif\n# ifndef OPENSSL_NO_MD4\nconst EVP_MD *EVP_md4(void);\n# endif\n# ifndef OPENSSL_NO_MD5\nconst EVP_MD *EVP_md5(void);\nconst EVP_MD *EVP_md5_sha1(void);\n# endif\n# ifndef OPENSSL_NO_BLAKE2\nconst EVP_MD *EVP_blake2b512(void);\nconst EVP_MD *EVP_blake2s256(void);\n# endif\nconst EVP_MD *EVP_sha1(void);\nconst EVP_MD *EVP_sha224(void);\nconst EVP_MD *EVP_sha256(void);\nconst EVP_MD *EVP_sha384(void);\nconst EVP_MD *EVP_sha512(void);\nconst EVP_MD *EVP_sha512_224(void);\nconst EVP_MD *EVP_sha512_256(void);\nconst EVP_MD *EVP_sha3_224(void);\nconst EVP_MD *EVP_sha3_256(void);\nconst EVP_MD *EVP_sha3_384(void);\nconst EVP_MD *EVP_sha3_512(void);\nconst EVP_MD *EVP_shake128(void);\nconst EVP_MD *EVP_shake256(void);\n# ifndef OPENSSL_NO_MDC2\nconst EVP_MD *EVP_mdc2(void);\n# endif\n# ifndef OPENSSL_NO_RMD160\nconst EVP_MD *EVP_ripemd160(void);\n# endif\n# ifndef OPENSSL_NO_WHIRLPOOL\nconst EVP_MD *EVP_whirlpool(void);\n# endif\n# ifndef OPENSSL_NO_SM3\nconst EVP_MD *EVP_sm3(void);\n# endif\nconst EVP_CIPHER *EVP_enc_null(void); /* does nothing :-) */\n# ifndef OPENSSL_NO_DES\nconst EVP_CIPHER *EVP_des_ecb(void);\nconst EVP_CIPHER *EVP_des_ede(void);\nconst EVP_CIPHER *EVP_des_ede3(void);\nconst EVP_CIPHER *EVP_des_ede_ecb(void);\nconst EVP_CIPHER *EVP_des_ede3_ecb(void);\nconst EVP_CIPHER *EVP_des_cfb64(void);\n#  define EVP_des_cfb EVP_des_cfb64\nconst EVP_CIPHER *EVP_des_cfb1(void);\nconst EVP_CIPHER *EVP_des_cfb8(void);\nconst EVP_CIPHER *EVP_des_ede_cfb64(void);\n#  define EVP_des_ede_cfb EVP_des_ede_cfb64\nconst EVP_CIPHER *EVP_des_ede3_cfb64(void);\n#  define EVP_des_ede3_cfb EVP_des_ede3_cfb64\nconst EVP_CIPHER *EVP_des_ede3_cfb1(void);\nconst EVP_CIPHER *EVP_des_ede3_cfb8(void);\nconst EVP_CIPHER *EVP_des_ofb(void);\nconst EVP_CIPHER *EVP_des_ede_ofb(void);\nconst EVP_CIPHER *EVP_des_ede3_ofb(void);\nconst EVP_CIPHER *EVP_des_cbc(void);\nconst EVP_CIPHER *EVP_des_ede_cbc(void);\nconst EVP_CIPHER *EVP_des_ede3_cbc(void);\nconst EVP_CIPHER *EVP_desx_cbc(void);\nconst EVP_CIPHER *EVP_des_ede3_wrap(void);\n/*\n * This should now be supported through the dev_crypto ENGINE. But also, why\n * are rc4 and md5 declarations made here inside a \"NO_DES\" precompiler\n * branch?\n */\n# endif\n# ifndef OPENSSL_NO_RC4\nconst EVP_CIPHER *EVP_rc4(void);\nconst EVP_CIPHER *EVP_rc4_40(void);\n#  ifndef OPENSSL_NO_MD5\nconst EVP_CIPHER *EVP_rc4_hmac_md5(void);\n#  endif\n# endif\n# ifndef OPENSSL_NO_IDEA\nconst EVP_CIPHER *EVP_idea_ecb(void);\nconst EVP_CIPHER *EVP_idea_cfb64(void);\n#  define EVP_idea_cfb EVP_idea_cfb64\nconst EVP_CIPHER *EVP_idea_ofb(void);\nconst EVP_CIPHER *EVP_idea_cbc(void);\n# endif\n# ifndef OPENSSL_NO_RC2\nconst EVP_CIPHER *EVP_rc2_ecb(void);\nconst EVP_CIPHER *EVP_rc2_cbc(void);\nconst EVP_CIPHER *EVP_rc2_40_cbc(void);\nconst EVP_CIPHER *EVP_rc2_64_cbc(void);\nconst EVP_CIPHER *EVP_rc2_cfb64(void);\n#  define EVP_rc2_cfb EVP_rc2_cfb64\nconst EVP_CIPHER *EVP_rc2_ofb(void);\n# endif\n# ifndef OPENSSL_NO_BF\nconst EVP_CIPHER *EVP_bf_ecb(void);\nconst EVP_CIPHER *EVP_bf_cbc(void);\nconst EVP_CIPHER *EVP_bf_cfb64(void);\n#  define EVP_bf_cfb EVP_bf_cfb64\nconst EVP_CIPHER *EVP_bf_ofb(void);\n# endif\n# ifndef OPENSSL_NO_CAST\nconst EVP_CIPHER *EVP_cast5_ecb(void);\nconst EVP_CIPHER *EVP_cast5_cbc(void);\nconst EVP_CIPHER *EVP_cast5_cfb64(void);\n#  define EVP_cast5_cfb EVP_cast5_cfb64\nconst EVP_CIPHER *EVP_cast5_ofb(void);\n# endif\n# ifndef OPENSSL_NO_RC5\nconst EVP_CIPHER *EVP_rc5_32_12_16_cbc(void);\nconst EVP_CIPHER *EVP_rc5_32_12_16_ecb(void);\nconst EVP_CIPHER *EVP_rc5_32_12_16_cfb64(void);\n#  define EVP_rc5_32_12_16_cfb EVP_rc5_32_12_16_cfb64\nconst EVP_CIPHER *EVP_rc5_32_12_16_ofb(void);\n# endif\nconst EVP_CIPHER *EVP_aes_128_ecb(void);\nconst EVP_CIPHER *EVP_aes_128_cbc(void);\nconst EVP_CIPHER *EVP_aes_128_cfb1(void);\nconst EVP_CIPHER *EVP_aes_128_cfb8(void);\nconst EVP_CIPHER *EVP_aes_128_cfb128(void);\n# define EVP_aes_128_cfb EVP_aes_128_cfb128\nconst EVP_CIPHER *EVP_aes_128_ofb(void);\nconst EVP_CIPHER *EVP_aes_128_ctr(void);\nconst EVP_CIPHER *EVP_aes_128_ccm(void);\nconst EVP_CIPHER *EVP_aes_128_gcm(void);\nconst EVP_CIPHER *EVP_aes_128_xts(void);\nconst EVP_CIPHER *EVP_aes_128_wrap(void);\nconst EVP_CIPHER *EVP_aes_128_wrap_pad(void);\n# ifndef OPENSSL_NO_OCB\nconst EVP_CIPHER *EVP_aes_128_ocb(void);\n# endif\nconst EVP_CIPHER *EVP_aes_192_ecb(void);\nconst EVP_CIPHER *EVP_aes_192_cbc(void);\nconst EVP_CIPHER *EVP_aes_192_cfb1(void);\nconst EVP_CIPHER *EVP_aes_192_cfb8(void);\nconst EVP_CIPHER *EVP_aes_192_cfb128(void);\n# define EVP_aes_192_cfb EVP_aes_192_cfb128\nconst EVP_CIPHER *EVP_aes_192_ofb(void);\nconst EVP_CIPHER *EVP_aes_192_ctr(void);\nconst EVP_CIPHER *EVP_aes_192_ccm(void);\nconst EVP_CIPHER *EVP_aes_192_gcm(void);\nconst EVP_CIPHER *EVP_aes_192_wrap(void);\nconst EVP_CIPHER *EVP_aes_192_wrap_pad(void);\n# ifndef OPENSSL_NO_OCB\nconst EVP_CIPHER *EVP_aes_192_ocb(void);\n# endif\nconst EVP_CIPHER *EVP_aes_256_ecb(void);\nconst EVP_CIPHER *EVP_aes_256_cbc(void);\nconst EVP_CIPHER *EVP_aes_256_cfb1(void);\nconst EVP_CIPHER *EVP_aes_256_cfb8(void);\nconst EVP_CIPHER *EVP_aes_256_cfb128(void);\n# define EVP_aes_256_cfb EVP_aes_256_cfb128\nconst EVP_CIPHER *EVP_aes_256_ofb(void);\nconst EVP_CIPHER *EVP_aes_256_ctr(void);\nconst EVP_CIPHER *EVP_aes_256_ccm(void);\nconst EVP_CIPHER *EVP_aes_256_gcm(void);\nconst EVP_CIPHER *EVP_aes_256_xts(void);\nconst EVP_CIPHER *EVP_aes_256_wrap(void);\nconst EVP_CIPHER *EVP_aes_256_wrap_pad(void);\n# ifndef OPENSSL_NO_OCB\nconst EVP_CIPHER *EVP_aes_256_ocb(void);\n# endif\nconst EVP_CIPHER *EVP_aes_128_cbc_hmac_sha1(void);\nconst EVP_CIPHER *EVP_aes_256_cbc_hmac_sha1(void);\nconst EVP_CIPHER *EVP_aes_128_cbc_hmac_sha256(void);\nconst EVP_CIPHER *EVP_aes_256_cbc_hmac_sha256(void);\n# ifndef OPENSSL_NO_ARIA\nconst EVP_CIPHER *EVP_aria_128_ecb(void);\nconst EVP_CIPHER *EVP_aria_128_cbc(void);\nconst EVP_CIPHER *EVP_aria_128_cfb1(void);\nconst EVP_CIPHER *EVP_aria_128_cfb8(void);\nconst EVP_CIPHER *EVP_aria_128_cfb128(void);\n#  define EVP_aria_128_cfb EVP_aria_128_cfb128\nconst EVP_CIPHER *EVP_aria_128_ctr(void);\nconst EVP_CIPHER *EVP_aria_128_ofb(void);\nconst EVP_CIPHER *EVP_aria_128_gcm(void);\nconst EVP_CIPHER *EVP_aria_128_ccm(void);\nconst EVP_CIPHER *EVP_aria_192_ecb(void);\nconst EVP_CIPHER *EVP_aria_192_cbc(void);\nconst EVP_CIPHER *EVP_aria_192_cfb1(void);\nconst EVP_CIPHER *EVP_aria_192_cfb8(void);\nconst EVP_CIPHER *EVP_aria_192_cfb128(void);\n#  define EVP_aria_192_cfb EVP_aria_192_cfb128\nconst EVP_CIPHER *EVP_aria_192_ctr(void);\nconst EVP_CIPHER *EVP_aria_192_ofb(void);\nconst EVP_CIPHER *EVP_aria_192_gcm(void);\nconst EVP_CIPHER *EVP_aria_192_ccm(void);\nconst EVP_CIPHER *EVP_aria_256_ecb(void);\nconst EVP_CIPHER *EVP_aria_256_cbc(void);\nconst EVP_CIPHER *EVP_aria_256_cfb1(void);\nconst EVP_CIPHER *EVP_aria_256_cfb8(void);\nconst EVP_CIPHER *EVP_aria_256_cfb128(void);\n#  define EVP_aria_256_cfb EVP_aria_256_cfb128\nconst EVP_CIPHER *EVP_aria_256_ctr(void);\nconst EVP_CIPHER *EVP_aria_256_ofb(void);\nconst EVP_CIPHER *EVP_aria_256_gcm(void);\nconst EVP_CIPHER *EVP_aria_256_ccm(void);\n# endif\n# ifndef OPENSSL_NO_CAMELLIA\nconst EVP_CIPHER *EVP_camellia_128_ecb(void);\nconst EVP_CIPHER *EVP_camellia_128_cbc(void);\nconst EVP_CIPHER *EVP_camellia_128_cfb1(void);\nconst EVP_CIPHER *EVP_camellia_128_cfb8(void);\nconst EVP_CIPHER *EVP_camellia_128_cfb128(void);\n#  define EVP_camellia_128_cfb EVP_camellia_128_cfb128\nconst EVP_CIPHER *EVP_camellia_128_ofb(void);\nconst EVP_CIPHER *EVP_camellia_128_ctr(void);\nconst EVP_CIPHER *EVP_camellia_192_ecb(void);\nconst EVP_CIPHER *EVP_camellia_192_cbc(void);\nconst EVP_CIPHER *EVP_camellia_192_cfb1(void);\nconst EVP_CIPHER *EVP_camellia_192_cfb8(void);\nconst EVP_CIPHER *EVP_camellia_192_cfb128(void);\n#  define EVP_camellia_192_cfb EVP_camellia_192_cfb128\nconst EVP_CIPHER *EVP_camellia_192_ofb(void);\nconst EVP_CIPHER *EVP_camellia_192_ctr(void);\nconst EVP_CIPHER *EVP_camellia_256_ecb(void);\nconst EVP_CIPHER *EVP_camellia_256_cbc(void);\nconst EVP_CIPHER *EVP_camellia_256_cfb1(void);\nconst EVP_CIPHER *EVP_camellia_256_cfb8(void);\nconst EVP_CIPHER *EVP_camellia_256_cfb128(void);\n#  define EVP_camellia_256_cfb EVP_camellia_256_cfb128\nconst EVP_CIPHER *EVP_camellia_256_ofb(void);\nconst EVP_CIPHER *EVP_camellia_256_ctr(void);\n# endif\n# ifndef OPENSSL_NO_CHACHA\nconst EVP_CIPHER *EVP_chacha20(void);\n#  ifndef OPENSSL_NO_POLY1305\nconst EVP_CIPHER *EVP_chacha20_poly1305(void);\n#  endif\n# endif\n\n# ifndef OPENSSL_NO_SEED\nconst EVP_CIPHER *EVP_seed_ecb(void);\nconst EVP_CIPHER *EVP_seed_cbc(void);\nconst EVP_CIPHER *EVP_seed_cfb128(void);\n#  define EVP_seed_cfb EVP_seed_cfb128\nconst EVP_CIPHER *EVP_seed_ofb(void);\n# endif\n\n# ifndef OPENSSL_NO_SM4\nconst EVP_CIPHER *EVP_sm4_ecb(void);\nconst EVP_CIPHER *EVP_sm4_cbc(void);\nconst EVP_CIPHER *EVP_sm4_cfb128(void);\n#  define EVP_sm4_cfb EVP_sm4_cfb128\nconst EVP_CIPHER *EVP_sm4_ofb(void);\nconst EVP_CIPHER *EVP_sm4_ctr(void);\n# endif\n\n# if OPENSSL_API_COMPAT < 0x10100000L\n#  define OPENSSL_add_all_algorithms_conf() \\\n    OPENSSL_init_crypto(OPENSSL_INIT_ADD_ALL_CIPHERS \\\n                        | OPENSSL_INIT_ADD_ALL_DIGESTS \\\n                        | OPENSSL_INIT_LOAD_CONFIG, NULL)\n#  define OPENSSL_add_all_algorithms_noconf() \\\n    OPENSSL_init_crypto(OPENSSL_INIT_ADD_ALL_CIPHERS \\\n                        | OPENSSL_INIT_ADD_ALL_DIGESTS, NULL)\n\n#  ifdef OPENSSL_LOAD_CONF\n#   define OpenSSL_add_all_algorithms() OPENSSL_add_all_algorithms_conf()\n#  else\n#   define OpenSSL_add_all_algorithms() OPENSSL_add_all_algorithms_noconf()\n#  endif\n\n#  define OpenSSL_add_all_ciphers() \\\n    OPENSSL_init_crypto(OPENSSL_INIT_ADD_ALL_CIPHERS, NULL)\n#  define OpenSSL_add_all_digests() \\\n    OPENSSL_init_crypto(OPENSSL_INIT_ADD_ALL_DIGESTS, NULL)\n\n#  define EVP_cleanup() while(0) continue\n# endif\n\nint EVP_add_cipher(const EVP_CIPHER *cipher);\nint EVP_add_digest(const EVP_MD *digest);\n\nconst EVP_CIPHER *EVP_get_cipherbyname(const char *name);\nconst EVP_MD *EVP_get_digestbyname(const char *name);\n\nvoid EVP_CIPHER_do_all(void (*fn) (const EVP_CIPHER *ciph,\n                                   const char *from, const char *to, void *x),\n                       void *arg);\nvoid EVP_CIPHER_do_all_sorted(void (*fn)\n                               (const EVP_CIPHER *ciph, const char *from,\n                                const char *to, void *x), void *arg);\n\nvoid EVP_MD_do_all(void (*fn) (const EVP_MD *ciph,\n                               const char *from, const char *to, void *x),\n                   void *arg);\nvoid EVP_MD_do_all_sorted(void (*fn)\n                           (const EVP_MD *ciph, const char *from,\n                            const char *to, void *x), void *arg);\n\nint EVP_PKEY_decrypt_old(unsigned char *dec_key,\n                         const unsigned char *enc_key, int enc_key_len,\n                         EVP_PKEY *private_key);\nint EVP_PKEY_encrypt_old(unsigned char *enc_key,\n                         const unsigned char *key, int key_len,\n                         EVP_PKEY *pub_key);\nint EVP_PKEY_type(int type);\nint EVP_PKEY_id(const EVP_PKEY *pkey);\nint EVP_PKEY_base_id(const EVP_PKEY *pkey);\nint EVP_PKEY_bits(const EVP_PKEY *pkey);\nint EVP_PKEY_security_bits(const EVP_PKEY *pkey);\nint EVP_PKEY_size(const EVP_PKEY *pkey);\nint EVP_PKEY_set_type(EVP_PKEY *pkey, int type);\nint EVP_PKEY_set_type_str(EVP_PKEY *pkey, const char *str, int len);\nint EVP_PKEY_set_alias_type(EVP_PKEY *pkey, int type);\n# ifndef OPENSSL_NO_ENGINE\nint EVP_PKEY_set1_engine(EVP_PKEY *pkey, ENGINE *e);\nENGINE *EVP_PKEY_get0_engine(const EVP_PKEY *pkey);\n# endif\nint EVP_PKEY_assign(EVP_PKEY *pkey, int type, void *key);\nvoid *EVP_PKEY_get0(const EVP_PKEY *pkey);\nconst unsigned char *EVP_PKEY_get0_hmac(const EVP_PKEY *pkey, size_t *len);\n# ifndef OPENSSL_NO_POLY1305\nconst unsigned char *EVP_PKEY_get0_poly1305(const EVP_PKEY *pkey, size_t *len);\n# endif\n# ifndef OPENSSL_NO_SIPHASH\nconst unsigned char *EVP_PKEY_get0_siphash(const EVP_PKEY *pkey, size_t *len);\n# endif\n\n# ifndef OPENSSL_NO_RSA\nstruct rsa_st;\nint EVP_PKEY_set1_RSA(EVP_PKEY *pkey, struct rsa_st *key);\nstruct rsa_st *EVP_PKEY_get0_RSA(EVP_PKEY *pkey);\nstruct rsa_st *EVP_PKEY_get1_RSA(EVP_PKEY *pkey);\n# endif\n# ifndef OPENSSL_NO_DSA\nstruct dsa_st;\nint EVP_PKEY_set1_DSA(EVP_PKEY *pkey, struct dsa_st *key);\nstruct dsa_st *EVP_PKEY_get0_DSA(EVP_PKEY *pkey);\nstruct dsa_st *EVP_PKEY_get1_DSA(EVP_PKEY *pkey);\n# endif\n# ifndef OPENSSL_NO_DH\nstruct dh_st;\nint EVP_PKEY_set1_DH(EVP_PKEY *pkey, struct dh_st *key);\nstruct dh_st *EVP_PKEY_get0_DH(EVP_PKEY *pkey);\nstruct dh_st *EVP_PKEY_get1_DH(EVP_PKEY *pkey);\n# endif\n# ifndef OPENSSL_NO_EC\nstruct ec_key_st;\nint EVP_PKEY_set1_EC_KEY(EVP_PKEY *pkey, struct ec_key_st *key);\nstruct ec_key_st *EVP_PKEY_get0_EC_KEY(EVP_PKEY *pkey);\nstruct ec_key_st *EVP_PKEY_get1_EC_KEY(EVP_PKEY *pkey);\n# endif\n\nEVP_PKEY *EVP_PKEY_new(void);\nint EVP_PKEY_up_ref(EVP_PKEY *pkey);\nvoid EVP_PKEY_free(EVP_PKEY *pkey);\n\nEVP_PKEY *d2i_PublicKey(int type, EVP_PKEY **a, const unsigned char **pp,\n                        long length);\nint i2d_PublicKey(EVP_PKEY *a, unsigned char **pp);\n\nEVP_PKEY *d2i_PrivateKey(int type, EVP_PKEY **a, const unsigned char **pp,\n                         long length);\nEVP_PKEY *d2i_AutoPrivateKey(EVP_PKEY **a, const unsigned char **pp,\n                             long length);\nint i2d_PrivateKey(EVP_PKEY *a, unsigned char **pp);\n\nint EVP_PKEY_copy_parameters(EVP_PKEY *to, const EVP_PKEY *from);\nint EVP_PKEY_missing_parameters(const EVP_PKEY *pkey);\nint EVP_PKEY_save_parameters(EVP_PKEY *pkey, int mode);\nint EVP_PKEY_cmp_parameters(const EVP_PKEY *a, const EVP_PKEY *b);\n\nint EVP_PKEY_cmp(const EVP_PKEY *a, const EVP_PKEY *b);\n\nint EVP_PKEY_print_public(BIO *out, const EVP_PKEY *pkey,\n                          int indent, ASN1_PCTX *pctx);\nint EVP_PKEY_print_private(BIO *out, const EVP_PKEY *pkey,\n                           int indent, ASN1_PCTX *pctx);\nint EVP_PKEY_print_params(BIO *out, const EVP_PKEY *pkey,\n                          int indent, ASN1_PCTX *pctx);\n\nint EVP_PKEY_get_default_digest_nid(EVP_PKEY *pkey, int *pnid);\n\nint EVP_PKEY_set1_tls_encodedpoint(EVP_PKEY *pkey,\n                                   const unsigned char *pt, size_t ptlen);\nsize_t EVP_PKEY_get1_tls_encodedpoint(EVP_PKEY *pkey, unsigned char **ppt);\n\nint EVP_CIPHER_type(const EVP_CIPHER *ctx);\n\n/* calls methods */\nint EVP_CIPHER_param_to_asn1(EVP_CIPHER_CTX *c, ASN1_TYPE *type);\nint EVP_CIPHER_asn1_to_param(EVP_CIPHER_CTX *c, ASN1_TYPE *type);\n\n/* These are used by EVP_CIPHER methods */\nint EVP_CIPHER_set_asn1_iv(EVP_CIPHER_CTX *c, ASN1_TYPE *type);\nint EVP_CIPHER_get_asn1_iv(EVP_CIPHER_CTX *c, ASN1_TYPE *type);\n\n/* PKCS5 password based encryption */\nint PKCS5_PBE_keyivgen(EVP_CIPHER_CTX *ctx, const char *pass, int passlen,\n                       ASN1_TYPE *param, const EVP_CIPHER *cipher,\n                       const EVP_MD *md, int en_de);\nint PKCS5_PBKDF2_HMAC_SHA1(const char *pass, int passlen,\n                           const unsigned char *salt, int saltlen, int iter,\n                           int keylen, unsigned char *out);\nint PKCS5_PBKDF2_HMAC(const char *pass, int passlen,\n                      const unsigned char *salt, int saltlen, int iter,\n                      const EVP_MD *digest, int keylen, unsigned char *out);\nint PKCS5_v2_PBE_keyivgen(EVP_CIPHER_CTX *ctx, const char *pass, int passlen,\n                          ASN1_TYPE *param, const EVP_CIPHER *cipher,\n                          const EVP_MD *md, int en_de);\n\n#ifndef OPENSSL_NO_SCRYPT\nint EVP_PBE_scrypt(const char *pass, size_t passlen,\n                   const unsigned char *salt, size_t saltlen,\n                   uint64_t N, uint64_t r, uint64_t p, uint64_t maxmem,\n                   unsigned char *key, size_t keylen);\n\nint PKCS5_v2_scrypt_keyivgen(EVP_CIPHER_CTX *ctx, const char *pass,\n                             int passlen, ASN1_TYPE *param,\n                             const EVP_CIPHER *c, const EVP_MD *md, int en_de);\n#endif\n\nvoid PKCS5_PBE_add(void);\n\nint EVP_PBE_CipherInit(ASN1_OBJECT *pbe_obj, const char *pass, int passlen,\n                       ASN1_TYPE *param, EVP_CIPHER_CTX *ctx, int en_de);\n\n/* PBE type */\n\n/* Can appear as the outermost AlgorithmIdentifier */\n# define EVP_PBE_TYPE_OUTER      0x0\n/* Is an PRF type OID */\n# define EVP_PBE_TYPE_PRF        0x1\n/* Is a PKCS#5 v2.0 KDF */\n# define EVP_PBE_TYPE_KDF        0x2\n\nint EVP_PBE_alg_add_type(int pbe_type, int pbe_nid, int cipher_nid,\n                         int md_nid, EVP_PBE_KEYGEN *keygen);\nint EVP_PBE_alg_add(int nid, const EVP_CIPHER *cipher, const EVP_MD *md,\n                    EVP_PBE_KEYGEN *keygen);\nint EVP_PBE_find(int type, int pbe_nid, int *pcnid, int *pmnid,\n                 EVP_PBE_KEYGEN **pkeygen);\nvoid EVP_PBE_cleanup(void);\nint EVP_PBE_get(int *ptype, int *ppbe_nid, size_t num);\n\n# define ASN1_PKEY_ALIAS         0x1\n# define ASN1_PKEY_DYNAMIC       0x2\n# define ASN1_PKEY_SIGPARAM_NULL 0x4\n\n# define ASN1_PKEY_CTRL_PKCS7_SIGN       0x1\n# define ASN1_PKEY_CTRL_PKCS7_ENCRYPT    0x2\n# define ASN1_PKEY_CTRL_DEFAULT_MD_NID   0x3\n# define ASN1_PKEY_CTRL_CMS_SIGN         0x5\n# define ASN1_PKEY_CTRL_CMS_ENVELOPE     0x7\n# define ASN1_PKEY_CTRL_CMS_RI_TYPE      0x8\n\n# define ASN1_PKEY_CTRL_SET1_TLS_ENCPT   0x9\n# define ASN1_PKEY_CTRL_GET1_TLS_ENCPT   0xa\n\nint EVP_PKEY_asn1_get_count(void);\nconst EVP_PKEY_ASN1_METHOD *EVP_PKEY_asn1_get0(int idx);\nconst EVP_PKEY_ASN1_METHOD *EVP_PKEY_asn1_find(ENGINE **pe, int type);\nconst EVP_PKEY_ASN1_METHOD *EVP_PKEY_asn1_find_str(ENGINE **pe,\n                                                   const char *str, int len);\nint EVP_PKEY_asn1_add0(const EVP_PKEY_ASN1_METHOD *ameth);\nint EVP_PKEY_asn1_add_alias(int to, int from);\nint EVP_PKEY_asn1_get0_info(int *ppkey_id, int *pkey_base_id,\n                            int *ppkey_flags, const char **pinfo,\n                            const char **ppem_str,\n                            const EVP_PKEY_ASN1_METHOD *ameth);\n\nconst EVP_PKEY_ASN1_METHOD *EVP_PKEY_get0_asn1(const EVP_PKEY *pkey);\nEVP_PKEY_ASN1_METHOD *EVP_PKEY_asn1_new(int id, int flags,\n                                        const char *pem_str,\n                                        const char *info);\nvoid EVP_PKEY_asn1_copy(EVP_PKEY_ASN1_METHOD *dst,\n                        const EVP_PKEY_ASN1_METHOD *src);\nvoid EVP_PKEY_asn1_free(EVP_PKEY_ASN1_METHOD *ameth);\nvoid EVP_PKEY_asn1_set_public(EVP_PKEY_ASN1_METHOD *ameth,\n                              int (*pub_decode) (EVP_PKEY *pk,\n                                                 X509_PUBKEY *pub),\n                              int (*pub_encode) (X509_PUBKEY *pub,\n                                                 const EVP_PKEY *pk),\n                              int (*pub_cmp) (const EVP_PKEY *a,\n                                              const EVP_PKEY *b),\n                              int (*pub_print) (BIO *out,\n                                                const EVP_PKEY *pkey,\n                                                int indent, ASN1_PCTX *pctx),\n                              int (*pkey_size) (const EVP_PKEY *pk),\n                              int (*pkey_bits) (const EVP_PKEY *pk));\nvoid EVP_PKEY_asn1_set_private(EVP_PKEY_ASN1_METHOD *ameth,\n                               int (*priv_decode) (EVP_PKEY *pk,\n                                                   const PKCS8_PRIV_KEY_INFO\n                                                   *p8inf),\n                               int (*priv_encode) (PKCS8_PRIV_KEY_INFO *p8,\n                                                   const EVP_PKEY *pk),\n                               int (*priv_print) (BIO *out,\n                                                  const EVP_PKEY *pkey,\n                                                  int indent,\n                                                  ASN1_PCTX *pctx));\nvoid EVP_PKEY_asn1_set_param(EVP_PKEY_ASN1_METHOD *ameth,\n                             int (*param_decode) (EVP_PKEY *pkey,\n                                                  const unsigned char **pder,\n                                                  int derlen),\n                             int (*param_encode) (const EVP_PKEY *pkey,\n                                                  unsigned char **pder),\n                             int (*param_missing) (const EVP_PKEY *pk),\n                             int (*param_copy) (EVP_PKEY *to,\n                                                const EVP_PKEY *from),\n                             int (*param_cmp) (const EVP_PKEY *a,\n                                               const EVP_PKEY *b),\n                             int (*param_print) (BIO *out,\n                                                 const EVP_PKEY *pkey,\n                                                 int indent,\n                                                 ASN1_PCTX *pctx));\n\nvoid EVP_PKEY_asn1_set_free(EVP_PKEY_ASN1_METHOD *ameth,\n                            void (*pkey_free) (EVP_PKEY *pkey));\nvoid EVP_PKEY_asn1_set_ctrl(EVP_PKEY_ASN1_METHOD *ameth,\n                            int (*pkey_ctrl) (EVP_PKEY *pkey, int op,\n                                              long arg1, void *arg2));\nvoid EVP_PKEY_asn1_set_item(EVP_PKEY_ASN1_METHOD *ameth,\n                            int (*item_verify) (EVP_MD_CTX *ctx,\n                                                const ASN1_ITEM *it,\n                                                void *asn,\n                                                X509_ALGOR *a,\n                                                ASN1_BIT_STRING *sig,\n                                                EVP_PKEY *pkey),\n                            int (*item_sign) (EVP_MD_CTX *ctx,\n                                              const ASN1_ITEM *it,\n                                              void *asn,\n                                              X509_ALGOR *alg1,\n                                              X509_ALGOR *alg2,\n                                              ASN1_BIT_STRING *sig));\n\nvoid EVP_PKEY_asn1_set_siginf(EVP_PKEY_ASN1_METHOD *ameth,\n                              int (*siginf_set) (X509_SIG_INFO *siginf,\n                                                 const X509_ALGOR *alg,\n                                                 const ASN1_STRING *sig));\n\nvoid EVP_PKEY_asn1_set_check(EVP_PKEY_ASN1_METHOD *ameth,\n                             int (*pkey_check) (const EVP_PKEY *pk));\n\nvoid EVP_PKEY_asn1_set_public_check(EVP_PKEY_ASN1_METHOD *ameth,\n                                    int (*pkey_pub_check) (const EVP_PKEY *pk));\n\nvoid EVP_PKEY_asn1_set_param_check(EVP_PKEY_ASN1_METHOD *ameth,\n                                   int (*pkey_param_check) (const EVP_PKEY *pk));\n\nvoid EVP_PKEY_asn1_set_set_priv_key(EVP_PKEY_ASN1_METHOD *ameth,\n                                    int (*set_priv_key) (EVP_PKEY *pk,\n                                                         const unsigned char\n                                                            *priv,\n                                                         size_t len));\nvoid EVP_PKEY_asn1_set_set_pub_key(EVP_PKEY_ASN1_METHOD *ameth,\n                                   int (*set_pub_key) (EVP_PKEY *pk,\n                                                       const unsigned char *pub,\n                                                       size_t len));\nvoid EVP_PKEY_asn1_set_get_priv_key(EVP_PKEY_ASN1_METHOD *ameth,\n                                    int (*get_priv_key) (const EVP_PKEY *pk,\n                                                         unsigned char *priv,\n                                                         size_t *len));\nvoid EVP_PKEY_asn1_set_get_pub_key(EVP_PKEY_ASN1_METHOD *ameth,\n                                   int (*get_pub_key) (const EVP_PKEY *pk,\n                                                       unsigned char *pub,\n                                                       size_t *len));\n\nvoid EVP_PKEY_asn1_set_security_bits(EVP_PKEY_ASN1_METHOD *ameth,\n                                     int (*pkey_security_bits) (const EVP_PKEY\n                                                                *pk));\n\n# define EVP_PKEY_OP_UNDEFINED           0\n# define EVP_PKEY_OP_PARAMGEN            (1<<1)\n# define EVP_PKEY_OP_KEYGEN              (1<<2)\n# define EVP_PKEY_OP_SIGN                (1<<3)\n# define EVP_PKEY_OP_VERIFY              (1<<4)\n# define EVP_PKEY_OP_VERIFYRECOVER       (1<<5)\n# define EVP_PKEY_OP_SIGNCTX             (1<<6)\n# define EVP_PKEY_OP_VERIFYCTX           (1<<7)\n# define EVP_PKEY_OP_ENCRYPT             (1<<8)\n# define EVP_PKEY_OP_DECRYPT             (1<<9)\n# define EVP_PKEY_OP_DERIVE              (1<<10)\n\n# define EVP_PKEY_OP_TYPE_SIG    \\\n        (EVP_PKEY_OP_SIGN | EVP_PKEY_OP_VERIFY | EVP_PKEY_OP_VERIFYRECOVER \\\n                | EVP_PKEY_OP_SIGNCTX | EVP_PKEY_OP_VERIFYCTX)\n\n# define EVP_PKEY_OP_TYPE_CRYPT \\\n        (EVP_PKEY_OP_ENCRYPT | EVP_PKEY_OP_DECRYPT)\n\n# define EVP_PKEY_OP_TYPE_NOGEN \\\n        (EVP_PKEY_OP_TYPE_SIG | EVP_PKEY_OP_TYPE_CRYPT | EVP_PKEY_OP_DERIVE)\n\n# define EVP_PKEY_OP_TYPE_GEN \\\n                (EVP_PKEY_OP_PARAMGEN | EVP_PKEY_OP_KEYGEN)\n\n# define  EVP_PKEY_CTX_set_signature_md(ctx, md) \\\n                EVP_PKEY_CTX_ctrl(ctx, -1, EVP_PKEY_OP_TYPE_SIG,  \\\n                                        EVP_PKEY_CTRL_MD, 0, (void *)(md))\n\n# define  EVP_PKEY_CTX_get_signature_md(ctx, pmd)        \\\n                EVP_PKEY_CTX_ctrl(ctx, -1, EVP_PKEY_OP_TYPE_SIG,  \\\n                                        EVP_PKEY_CTRL_GET_MD, 0, (void *)(pmd))\n\n# define  EVP_PKEY_CTX_set_mac_key(ctx, key, len)        \\\n                EVP_PKEY_CTX_ctrl(ctx, -1, EVP_PKEY_OP_KEYGEN,  \\\n                                  EVP_PKEY_CTRL_SET_MAC_KEY, len, (void *)(key))\n\n# define EVP_PKEY_CTRL_MD                1\n# define EVP_PKEY_CTRL_PEER_KEY          2\n\n# define EVP_PKEY_CTRL_PKCS7_ENCRYPT     3\n# define EVP_PKEY_CTRL_PKCS7_DECRYPT     4\n\n# define EVP_PKEY_CTRL_PKCS7_SIGN        5\n\n# define EVP_PKEY_CTRL_SET_MAC_KEY       6\n\n# define EVP_PKEY_CTRL_DIGESTINIT        7\n\n/* Used by GOST key encryption in TLS */\n# define EVP_PKEY_CTRL_SET_IV            8\n\n# define EVP_PKEY_CTRL_CMS_ENCRYPT       9\n# define EVP_PKEY_CTRL_CMS_DECRYPT       10\n# define EVP_PKEY_CTRL_CMS_SIGN          11\n\n# define EVP_PKEY_CTRL_CIPHER            12\n\n# define EVP_PKEY_CTRL_GET_MD            13\n\n# define EVP_PKEY_CTRL_SET_DIGEST_SIZE   14\n\n# define EVP_PKEY_ALG_CTRL               0x1000\n\n# define EVP_PKEY_FLAG_AUTOARGLEN        2\n/*\n * Method handles all operations: don't assume any digest related defaults.\n */\n# define EVP_PKEY_FLAG_SIGCTX_CUSTOM     4\n\nconst EVP_PKEY_METHOD *EVP_PKEY_meth_find(int type);\nEVP_PKEY_METHOD *EVP_PKEY_meth_new(int id, int flags);\nvoid EVP_PKEY_meth_get0_info(int *ppkey_id, int *pflags,\n                             const EVP_PKEY_METHOD *meth);\nvoid EVP_PKEY_meth_copy(EVP_PKEY_METHOD *dst, const EVP_PKEY_METHOD *src);\nvoid EVP_PKEY_meth_free(EVP_PKEY_METHOD *pmeth);\nint EVP_PKEY_meth_add0(const EVP_PKEY_METHOD *pmeth);\nint EVP_PKEY_meth_remove(const EVP_PKEY_METHOD *pmeth);\nsize_t EVP_PKEY_meth_get_count(void);\nconst EVP_PKEY_METHOD *EVP_PKEY_meth_get0(size_t idx);\n\nEVP_PKEY_CTX *EVP_PKEY_CTX_new(EVP_PKEY *pkey, ENGINE *e);\nEVP_PKEY_CTX *EVP_PKEY_CTX_new_id(int id, ENGINE *e);\nEVP_PKEY_CTX *EVP_PKEY_CTX_dup(EVP_PKEY_CTX *ctx);\nvoid EVP_PKEY_CTX_free(EVP_PKEY_CTX *ctx);\n\nint EVP_PKEY_CTX_ctrl(EVP_PKEY_CTX *ctx, int keytype, int optype,\n                      int cmd, int p1, void *p2);\nint EVP_PKEY_CTX_ctrl_str(EVP_PKEY_CTX *ctx, const char *type,\n                          const char *value);\nint EVP_PKEY_CTX_ctrl_uint64(EVP_PKEY_CTX *ctx, int keytype, int optype,\n                             int cmd, uint64_t value);\n\nint EVP_PKEY_CTX_str2ctrl(EVP_PKEY_CTX *ctx, int cmd, const char *str);\nint EVP_PKEY_CTX_hex2ctrl(EVP_PKEY_CTX *ctx, int cmd, const char *hex);\n\nint EVP_PKEY_CTX_md(EVP_PKEY_CTX *ctx, int optype, int cmd, const char *md);\n\nint EVP_PKEY_CTX_get_operation(EVP_PKEY_CTX *ctx);\nvoid EVP_PKEY_CTX_set0_keygen_info(EVP_PKEY_CTX *ctx, int *dat, int datlen);\n\nEVP_PKEY *EVP_PKEY_new_mac_key(int type, ENGINE *e,\n                               const unsigned char *key, int keylen);\nEVP_PKEY *EVP_PKEY_new_raw_private_key(int type, ENGINE *e,\n                                       const unsigned char *priv,\n                                       size_t len);\nEVP_PKEY *EVP_PKEY_new_raw_public_key(int type, ENGINE *e,\n                                      const unsigned char *pub,\n                                      size_t len);\nint EVP_PKEY_get_raw_private_key(const EVP_PKEY *pkey, unsigned char *priv,\n                                 size_t *len);\nint EVP_PKEY_get_raw_public_key(const EVP_PKEY *pkey, unsigned char *pub,\n                                size_t *len);\n\nEVP_PKEY *EVP_PKEY_new_CMAC_key(ENGINE *e, const unsigned char *priv,\n                                size_t len, const EVP_CIPHER *cipher);\n\nvoid EVP_PKEY_CTX_set_data(EVP_PKEY_CTX *ctx, void *data);\nvoid *EVP_PKEY_CTX_get_data(EVP_PKEY_CTX *ctx);\nEVP_PKEY *EVP_PKEY_CTX_get0_pkey(EVP_PKEY_CTX *ctx);\n\nEVP_PKEY *EVP_PKEY_CTX_get0_peerkey(EVP_PKEY_CTX *ctx);\n\nvoid EVP_PKEY_CTX_set_app_data(EVP_PKEY_CTX *ctx, void *data);\nvoid *EVP_PKEY_CTX_get_app_data(EVP_PKEY_CTX *ctx);\n\nint EVP_PKEY_sign_init(EVP_PKEY_CTX *ctx);\nint EVP_PKEY_sign(EVP_PKEY_CTX *ctx,\n                  unsigned char *sig, size_t *siglen,\n                  const unsigned char *tbs, size_t tbslen);\nint EVP_PKEY_verify_init(EVP_PKEY_CTX *ctx);\nint EVP_PKEY_verify(EVP_PKEY_CTX *ctx,\n                    const unsigned char *sig, size_t siglen,\n                    const unsigned char *tbs, size_t tbslen);\nint EVP_PKEY_verify_recover_init(EVP_PKEY_CTX *ctx);\nint EVP_PKEY_verify_recover(EVP_PKEY_CTX *ctx,\n                            unsigned char *rout, size_t *routlen,\n                            const unsigned char *sig, size_t siglen);\nint EVP_PKEY_encrypt_init(EVP_PKEY_CTX *ctx);\nint EVP_PKEY_encrypt(EVP_PKEY_CTX *ctx,\n                     unsigned char *out, size_t *outlen,\n                     const unsigned char *in, size_t inlen);\nint EVP_PKEY_decrypt_init(EVP_PKEY_CTX *ctx);\nint EVP_PKEY_decrypt(EVP_PKEY_CTX *ctx,\n                     unsigned char *out, size_t *outlen,\n                     const unsigned char *in, size_t inlen);\n\nint EVP_PKEY_derive_init(EVP_PKEY_CTX *ctx);\nint EVP_PKEY_derive_set_peer(EVP_PKEY_CTX *ctx, EVP_PKEY *peer);\nint EVP_PKEY_derive(EVP_PKEY_CTX *ctx, unsigned char *key, size_t *keylen);\n\ntypedef int EVP_PKEY_gen_cb(EVP_PKEY_CTX *ctx);\n\nint EVP_PKEY_paramgen_init(EVP_PKEY_CTX *ctx);\nint EVP_PKEY_paramgen(EVP_PKEY_CTX *ctx, EVP_PKEY **ppkey);\nint EVP_PKEY_keygen_init(EVP_PKEY_CTX *ctx);\nint EVP_PKEY_keygen(EVP_PKEY_CTX *ctx, EVP_PKEY **ppkey);\nint EVP_PKEY_check(EVP_PKEY_CTX *ctx);\nint EVP_PKEY_public_check(EVP_PKEY_CTX *ctx);\nint EVP_PKEY_param_check(EVP_PKEY_CTX *ctx);\n\nvoid EVP_PKEY_CTX_set_cb(EVP_PKEY_CTX *ctx, EVP_PKEY_gen_cb *cb);\nEVP_PKEY_gen_cb *EVP_PKEY_CTX_get_cb(EVP_PKEY_CTX *ctx);\n\nint EVP_PKEY_CTX_get_keygen_info(EVP_PKEY_CTX *ctx, int idx);\n\nvoid EVP_PKEY_meth_set_init(EVP_PKEY_METHOD *pmeth,\n                            int (*init) (EVP_PKEY_CTX *ctx));\n\nvoid EVP_PKEY_meth_set_copy(EVP_PKEY_METHOD *pmeth,\n                            int (*copy) (EVP_PKEY_CTX *dst,\n                                         EVP_PKEY_CTX *src));\n\nvoid EVP_PKEY_meth_set_cleanup(EVP_PKEY_METHOD *pmeth,\n                               void (*cleanup) (EVP_PKEY_CTX *ctx));\n\nvoid EVP_PKEY_meth_set_paramgen(EVP_PKEY_METHOD *pmeth,\n                                int (*paramgen_init) (EVP_PKEY_CTX *ctx),\n                                int (*paramgen) (EVP_PKEY_CTX *ctx,\n                                                 EVP_PKEY *pkey));\n\nvoid EVP_PKEY_meth_set_keygen(EVP_PKEY_METHOD *pmeth,\n                              int (*keygen_init) (EVP_PKEY_CTX *ctx),\n                              int (*keygen) (EVP_PKEY_CTX *ctx,\n                                             EVP_PKEY *pkey));\n\nvoid EVP_PKEY_meth_set_sign(EVP_PKEY_METHOD *pmeth,\n                            int (*sign_init) (EVP_PKEY_CTX *ctx),\n                            int (*sign) (EVP_PKEY_CTX *ctx,\n                                         unsigned char *sig, size_t *siglen,\n                                         const unsigned char *tbs,\n                                         size_t tbslen));\n\nvoid EVP_PKEY_meth_set_verify(EVP_PKEY_METHOD *pmeth,\n                              int (*verify_init) (EVP_PKEY_CTX *ctx),\n                              int (*verify) (EVP_PKEY_CTX *ctx,\n                                             const unsigned char *sig,\n                                             size_t siglen,\n                                             const unsigned char *tbs,\n                                             size_t tbslen));\n\nvoid EVP_PKEY_meth_set_verify_recover(EVP_PKEY_METHOD *pmeth,\n                                      int (*verify_recover_init) (EVP_PKEY_CTX\n                                                                  *ctx),\n                                      int (*verify_recover) (EVP_PKEY_CTX\n                                                             *ctx,\n                                                             unsigned char\n                                                             *sig,\n                                                             size_t *siglen,\n                                                             const unsigned\n                                                             char *tbs,\n                                                             size_t tbslen));\n\nvoid EVP_PKEY_meth_set_signctx(EVP_PKEY_METHOD *pmeth,\n                               int (*signctx_init) (EVP_PKEY_CTX *ctx,\n                                                    EVP_MD_CTX *mctx),\n                               int (*signctx) (EVP_PKEY_CTX *ctx,\n                                               unsigned char *sig,\n                                               size_t *siglen,\n                                               EVP_MD_CTX *mctx));\n\nvoid EVP_PKEY_meth_set_verifyctx(EVP_PKEY_METHOD *pmeth,\n                                 int (*verifyctx_init) (EVP_PKEY_CTX *ctx,\n                                                        EVP_MD_CTX *mctx),\n                                 int (*verifyctx) (EVP_PKEY_CTX *ctx,\n                                                   const unsigned char *sig,\n                                                   int siglen,\n                                                   EVP_MD_CTX *mctx));\n\nvoid EVP_PKEY_meth_set_encrypt(EVP_PKEY_METHOD *pmeth,\n                               int (*encrypt_init) (EVP_PKEY_CTX *ctx),\n                               int (*encryptfn) (EVP_PKEY_CTX *ctx,\n                                                 unsigned char *out,\n                                                 size_t *outlen,\n                                                 const unsigned char *in,\n                                                 size_t inlen));\n\nvoid EVP_PKEY_meth_set_decrypt(EVP_PKEY_METHOD *pmeth,\n                               int (*decrypt_init) (EVP_PKEY_CTX *ctx),\n                               int (*decrypt) (EVP_PKEY_CTX *ctx,\n                                               unsigned char *out,\n                                               size_t *outlen,\n                                               const unsigned char *in,\n                                               size_t inlen));\n\nvoid EVP_PKEY_meth_set_derive(EVP_PKEY_METHOD *pmeth,\n                              int (*derive_init) (EVP_PKEY_CTX *ctx),\n                              int (*derive) (EVP_PKEY_CTX *ctx,\n                                             unsigned char *key,\n                                             size_t *keylen));\n\nvoid EVP_PKEY_meth_set_ctrl(EVP_PKEY_METHOD *pmeth,\n                            int (*ctrl) (EVP_PKEY_CTX *ctx, int type, int p1,\n                                         void *p2),\n                            int (*ctrl_str) (EVP_PKEY_CTX *ctx,\n                                             const char *type,\n                                             const char *value));\n\nvoid EVP_PKEY_meth_set_digestsign(EVP_PKEY_METHOD *pmeth,\n                                  int (*digestsign) (EVP_MD_CTX *ctx,\n                                                     unsigned char *sig,\n                                                     size_t *siglen,\n                                                     const unsigned char *tbs,\n                                                     size_t tbslen));\n\nvoid EVP_PKEY_meth_set_digestverify(EVP_PKEY_METHOD *pmeth,\n                                    int (*digestverify) (EVP_MD_CTX *ctx,\n                                                         const unsigned char *sig,\n                                                         size_t siglen,\n                                                         const unsigned char *tbs,\n                                                         size_t tbslen));\n\nvoid EVP_PKEY_meth_set_check(EVP_PKEY_METHOD *pmeth,\n                             int (*check) (EVP_PKEY *pkey));\n\nvoid EVP_PKEY_meth_set_public_check(EVP_PKEY_METHOD *pmeth,\n                                    int (*check) (EVP_PKEY *pkey));\n\nvoid EVP_PKEY_meth_set_param_check(EVP_PKEY_METHOD *pmeth,\n                                   int (*check) (EVP_PKEY *pkey));\n\nvoid EVP_PKEY_meth_set_digest_custom(EVP_PKEY_METHOD *pmeth,\n                                     int (*digest_custom) (EVP_PKEY_CTX *ctx,\n                                                           EVP_MD_CTX *mctx));\n\nvoid EVP_PKEY_meth_get_init(const EVP_PKEY_METHOD *pmeth,\n                            int (**pinit) (EVP_PKEY_CTX *ctx));\n\nvoid EVP_PKEY_meth_get_copy(const EVP_PKEY_METHOD *pmeth,\n                            int (**pcopy) (EVP_PKEY_CTX *dst,\n                                           EVP_PKEY_CTX *src));\n\nvoid EVP_PKEY_meth_get_cleanup(const EVP_PKEY_METHOD *pmeth,\n                               void (**pcleanup) (EVP_PKEY_CTX *ctx));\n\nvoid EVP_PKEY_meth_get_paramgen(const EVP_PKEY_METHOD *pmeth,\n                                int (**pparamgen_init) (EVP_PKEY_CTX *ctx),\n                                int (**pparamgen) (EVP_PKEY_CTX *ctx,\n                                                   EVP_PKEY *pkey));\n\nvoid EVP_PKEY_meth_get_keygen(const EVP_PKEY_METHOD *pmeth,\n                              int (**pkeygen_init) (EVP_PKEY_CTX *ctx),\n                              int (**pkeygen) (EVP_PKEY_CTX *ctx,\n                                               EVP_PKEY *pkey));\n\nvoid EVP_PKEY_meth_get_sign(const EVP_PKEY_METHOD *pmeth,\n                            int (**psign_init) (EVP_PKEY_CTX *ctx),\n                            int (**psign) (EVP_PKEY_CTX *ctx,\n                                           unsigned char *sig, size_t *siglen,\n                                           const unsigned char *tbs,\n                                           size_t tbslen));\n\nvoid EVP_PKEY_meth_get_verify(const EVP_PKEY_METHOD *pmeth,\n                              int (**pverify_init) (EVP_PKEY_CTX *ctx),\n                              int (**pverify) (EVP_PKEY_CTX *ctx,\n                                               const unsigned char *sig,\n                                               size_t siglen,\n                                               const unsigned char *tbs,\n                                               size_t tbslen));\n\nvoid EVP_PKEY_meth_get_verify_recover(const EVP_PKEY_METHOD *pmeth,\n                                      int (**pverify_recover_init) (EVP_PKEY_CTX\n                                                                    *ctx),\n                                      int (**pverify_recover) (EVP_PKEY_CTX\n                                                               *ctx,\n                                                               unsigned char\n                                                               *sig,\n                                                               size_t *siglen,\n                                                               const unsigned\n                                                               char *tbs,\n                                                               size_t tbslen));\n\nvoid EVP_PKEY_meth_get_signctx(const EVP_PKEY_METHOD *pmeth,\n                               int (**psignctx_init) (EVP_PKEY_CTX *ctx,\n                                                      EVP_MD_CTX *mctx),\n                               int (**psignctx) (EVP_PKEY_CTX *ctx,\n                                                 unsigned char *sig,\n                                                 size_t *siglen,\n                                                 EVP_MD_CTX *mctx));\n\nvoid EVP_PKEY_meth_get_verifyctx(const EVP_PKEY_METHOD *pmeth,\n                                 int (**pverifyctx_init) (EVP_PKEY_CTX *ctx,\n                                                          EVP_MD_CTX *mctx),\n                                 int (**pverifyctx) (EVP_PKEY_CTX *ctx,\n                                                     const unsigned char *sig,\n                                                     int siglen,\n                                                     EVP_MD_CTX *mctx));\n\nvoid EVP_PKEY_meth_get_encrypt(const EVP_PKEY_METHOD *pmeth,\n                               int (**pencrypt_init) (EVP_PKEY_CTX *ctx),\n                               int (**pencryptfn) (EVP_PKEY_CTX *ctx,\n                                                   unsigned char *out,\n                                                   size_t *outlen,\n                                                   const unsigned char *in,\n                                                   size_t inlen));\n\nvoid EVP_PKEY_meth_get_decrypt(const EVP_PKEY_METHOD *pmeth,\n                               int (**pdecrypt_init) (EVP_PKEY_CTX *ctx),\n                               int (**pdecrypt) (EVP_PKEY_CTX *ctx,\n                                                 unsigned char *out,\n                                                 size_t *outlen,\n                                                 const unsigned char *in,\n                                                 size_t inlen));\n\nvoid EVP_PKEY_meth_get_derive(const EVP_PKEY_METHOD *pmeth,\n                              int (**pderive_init) (EVP_PKEY_CTX *ctx),\n                              int (**pderive) (EVP_PKEY_CTX *ctx,\n                                               unsigned char *key,\n                                               size_t *keylen));\n\nvoid EVP_PKEY_meth_get_ctrl(const EVP_PKEY_METHOD *pmeth,\n                            int (**pctrl) (EVP_PKEY_CTX *ctx, int type, int p1,\n                                           void *p2),\n                            int (**pctrl_str) (EVP_PKEY_CTX *ctx,\n                                               const char *type,\n                                               const char *value));\n\nvoid EVP_PKEY_meth_get_digestsign(EVP_PKEY_METHOD *pmeth,\n                                  int (**digestsign) (EVP_MD_CTX *ctx,\n                                                      unsigned char *sig,\n                                                      size_t *siglen,\n                                                      const unsigned char *tbs,\n                                                      size_t tbslen));\n\nvoid EVP_PKEY_meth_get_digestverify(EVP_PKEY_METHOD *pmeth,\n                                    int (**digestverify) (EVP_MD_CTX *ctx,\n                                                          const unsigned char *sig,\n                                                          size_t siglen,\n                                                          const unsigned char *tbs,\n                                                          size_t tbslen));\n\nvoid EVP_PKEY_meth_get_check(const EVP_PKEY_METHOD *pmeth,\n                             int (**pcheck) (EVP_PKEY *pkey));\n\nvoid EVP_PKEY_meth_get_public_check(const EVP_PKEY_METHOD *pmeth,\n                                    int (**pcheck) (EVP_PKEY *pkey));\n\nvoid EVP_PKEY_meth_get_param_check(const EVP_PKEY_METHOD *pmeth,\n                                   int (**pcheck) (EVP_PKEY *pkey));\n\nvoid EVP_PKEY_meth_get_digest_custom(EVP_PKEY_METHOD *pmeth,\n                                     int (**pdigest_custom) (EVP_PKEY_CTX *ctx,\n                                                             EVP_MD_CTX *mctx));\nvoid EVP_add_alg_module(void);\n\n\n# ifdef  __cplusplus\n}\n# endif\n#endif\n"}, "6": {"id": 6, "path": "/usr/include/openssl/rsa.h", "content": "/*\n * Copyright 1995-2018 The OpenSSL Project Authors. All Rights Reserved.\n *\n * Licensed under the OpenSSL license (the \"License\").  You may not use\n * this file except in compliance with the License.  You can obtain a copy\n * in the file LICENSE in the source distribution or at\n * https://www.openssl.org/source/license.html\n */\n\n#ifndef HEADER_RSA_H\n# define HEADER_RSA_H\n\n# include <openssl/opensslconf.h>\n\n# ifndef OPENSSL_NO_RSA\n# include <openssl/asn1.h>\n# include <openssl/bio.h>\n# include <openssl/crypto.h>\n# include <openssl/ossl_typ.h>\n# if OPENSSL_API_COMPAT < 0x10100000L\n#  include <openssl/bn.h>\n# endif\n# include <openssl/rsaerr.h>\n# ifdef  __cplusplus\nextern \"C\" {\n# endif\n\n/* The types RSA and RSA_METHOD are defined in ossl_typ.h */\n\n# ifndef OPENSSL_RSA_MAX_MODULUS_BITS\n#  define OPENSSL_RSA_MAX_MODULUS_BITS   16384\n# endif\n\n# define OPENSSL_RSA_FIPS_MIN_MODULUS_BITS 1024\n\n# ifndef OPENSSL_RSA_SMALL_MODULUS_BITS\n#  define OPENSSL_RSA_SMALL_MODULUS_BITS 3072\n# endif\n# ifndef OPENSSL_RSA_MAX_PUBEXP_BITS\n\n/* exponent limit enforced for \"large\" modulus only */\n#  define OPENSSL_RSA_MAX_PUBEXP_BITS    64\n# endif\n\n# define RSA_3   0x3L\n# define RSA_F4  0x10001L\n\n/* based on RFC 8017 appendix A.1.2 */\n# define RSA_ASN1_VERSION_DEFAULT        0\n# define RSA_ASN1_VERSION_MULTI          1\n\n# define RSA_DEFAULT_PRIME_NUM           2\n\n# define RSA_METHOD_FLAG_NO_CHECK        0x0001/* don't check pub/private\n                                                * match */\n\n# define RSA_FLAG_CACHE_PUBLIC           0x0002\n# define RSA_FLAG_CACHE_PRIVATE          0x0004\n# define RSA_FLAG_BLINDING               0x0008\n# define RSA_FLAG_THREAD_SAFE            0x0010\n/*\n * This flag means the private key operations will be handled by rsa_mod_exp\n * and that they do not depend on the private key components being present:\n * for example a key stored in external hardware. Without this flag\n * bn_mod_exp gets called when private key components are absent.\n */\n# define RSA_FLAG_EXT_PKEY               0x0020\n\n/*\n * new with 0.9.6j and 0.9.7b; the built-in\n * RSA implementation now uses blinding by\n * default (ignoring RSA_FLAG_BLINDING),\n * but other engines might not need it\n */\n# define RSA_FLAG_NO_BLINDING            0x0080\n# if OPENSSL_API_COMPAT < 0x10100000L\n/*\n * Does nothing. Previously this switched off constant time behaviour.\n */\n#  define RSA_FLAG_NO_CONSTTIME           0x0000\n# endif\n# if OPENSSL_API_COMPAT < 0x00908000L\n/* deprecated name for the flag*/\n/*\n * new with 0.9.7h; the built-in RSA\n * implementation now uses constant time\n * modular exponentiation for secret exponents\n * by default. This flag causes the\n * faster variable sliding window method to\n * be used for all exponents.\n */\n#  define RSA_FLAG_NO_EXP_CONSTTIME RSA_FLAG_NO_CONSTTIME\n# endif\n\n# define EVP_PKEY_CTX_set_rsa_padding(ctx, pad) \\\n        RSA_pkey_ctx_ctrl(ctx, -1, EVP_PKEY_CTRL_RSA_PADDING, pad, NULL)\n\n# define EVP_PKEY_CTX_get_rsa_padding(ctx, ppad) \\\n        RSA_pkey_ctx_ctrl(ctx, -1, EVP_PKEY_CTRL_GET_RSA_PADDING, 0, ppad)\n\n# define EVP_PKEY_CTX_set_rsa_pss_saltlen(ctx, len) \\\n        RSA_pkey_ctx_ctrl(ctx, (EVP_PKEY_OP_SIGN|EVP_PKEY_OP_VERIFY), \\\n                          EVP_PKEY_CTRL_RSA_PSS_SALTLEN, len, NULL)\n/* Salt length matches digest */\n# define RSA_PSS_SALTLEN_DIGEST -1\n/* Verify only: auto detect salt length */\n# define RSA_PSS_SALTLEN_AUTO   -2\n/* Set salt length to maximum possible */\n# define RSA_PSS_SALTLEN_MAX    -3\n/* Old compatible max salt length for sign only */\n# define RSA_PSS_SALTLEN_MAX_SIGN    -2\n\n# define EVP_PKEY_CTX_set_rsa_pss_keygen_saltlen(ctx, len) \\\n        EVP_PKEY_CTX_ctrl(ctx, EVP_PKEY_RSA_PSS, EVP_PKEY_OP_KEYGEN, \\\n                          EVP_PKEY_CTRL_RSA_PSS_SALTLEN, len, NULL)\n\n# define EVP_PKEY_CTX_get_rsa_pss_saltlen(ctx, plen) \\\n        RSA_pkey_ctx_ctrl(ctx, (EVP_PKEY_OP_SIGN|EVP_PKEY_OP_VERIFY), \\\n                          EVP_PKEY_CTRL_GET_RSA_PSS_SALTLEN, 0, plen)\n\n# define EVP_PKEY_CTX_set_rsa_keygen_bits(ctx, bits) \\\n        RSA_pkey_ctx_ctrl(ctx, EVP_PKEY_OP_KEYGEN, \\\n                          EVP_PKEY_CTRL_RSA_KEYGEN_BITS, bits, NULL)\n\n# define EVP_PKEY_CTX_set_rsa_keygen_pubexp(ctx, pubexp) \\\n        RSA_pkey_ctx_ctrl(ctx, EVP_PKEY_OP_KEYGEN, \\\n                          EVP_PKEY_CTRL_RSA_KEYGEN_PUBEXP, 0, pubexp)\n\n# define EVP_PKEY_CTX_set_rsa_keygen_primes(ctx, primes) \\\n        RSA_pkey_ctx_ctrl(ctx, EVP_PKEY_OP_KEYGEN, \\\n                          EVP_PKEY_CTRL_RSA_KEYGEN_PRIMES, primes, NULL)\n\n# define  EVP_PKEY_CTX_set_rsa_mgf1_md(ctx, md) \\\n        RSA_pkey_ctx_ctrl(ctx, EVP_PKEY_OP_TYPE_SIG | EVP_PKEY_OP_TYPE_CRYPT, \\\n                          EVP_PKEY_CTRL_RSA_MGF1_MD, 0, (void *)(md))\n\n# define  EVP_PKEY_CTX_set_rsa_pss_keygen_mgf1_md(ctx, md) \\\n        EVP_PKEY_CTX_ctrl(ctx, EVP_PKEY_RSA_PSS, EVP_PKEY_OP_KEYGEN, \\\n                          EVP_PKEY_CTRL_RSA_MGF1_MD, 0, (void *)(md))\n\n# define  EVP_PKEY_CTX_set_rsa_oaep_md(ctx, md) \\\n        EVP_PKEY_CTX_ctrl(ctx, EVP_PKEY_RSA, EVP_PKEY_OP_TYPE_CRYPT,  \\\n                          EVP_PKEY_CTRL_RSA_OAEP_MD, 0, (void *)(md))\n\n# define  EVP_PKEY_CTX_get_rsa_mgf1_md(ctx, pmd) \\\n        RSA_pkey_ctx_ctrl(ctx, EVP_PKEY_OP_TYPE_SIG | EVP_PKEY_OP_TYPE_CRYPT, \\\n                          EVP_PKEY_CTRL_GET_RSA_MGF1_MD, 0, (void *)(pmd))\n\n# define  EVP_PKEY_CTX_get_rsa_oaep_md(ctx, pmd) \\\n        EVP_PKEY_CTX_ctrl(ctx, EVP_PKEY_RSA, EVP_PKEY_OP_TYPE_CRYPT,  \\\n                          EVP_PKEY_CTRL_GET_RSA_OAEP_MD, 0, (void *)(pmd))\n\n# define  EVP_PKEY_CTX_set0_rsa_oaep_label(ctx, l, llen) \\\n        EVP_PKEY_CTX_ctrl(ctx, EVP_PKEY_RSA, EVP_PKEY_OP_TYPE_CRYPT,  \\\n                          EVP_PKEY_CTRL_RSA_OAEP_LABEL, llen, (void *)(l))\n\n# define  EVP_PKEY_CTX_get0_rsa_oaep_label(ctx, l) \\\n        EVP_PKEY_CTX_ctrl(ctx, EVP_PKEY_RSA, EVP_PKEY_OP_TYPE_CRYPT,  \\\n                          EVP_PKEY_CTRL_GET_RSA_OAEP_LABEL, 0, (void *)(l))\n\n# define  EVP_PKEY_CTX_set_rsa_pss_keygen_md(ctx, md) \\\n        EVP_PKEY_CTX_ctrl(ctx, EVP_PKEY_RSA_PSS,  \\\n                          EVP_PKEY_OP_KEYGEN, EVP_PKEY_CTRL_MD,  \\\n                          0, (void *)(md))\n\n# define EVP_PKEY_CTRL_RSA_PADDING       (EVP_PKEY_ALG_CTRL + 1)\n# define EVP_PKEY_CTRL_RSA_PSS_SALTLEN   (EVP_PKEY_ALG_CTRL + 2)\n\n# define EVP_PKEY_CTRL_RSA_KEYGEN_BITS   (EVP_PKEY_ALG_CTRL + 3)\n# define EVP_PKEY_CTRL_RSA_KEYGEN_PUBEXP (EVP_PKEY_ALG_CTRL + 4)\n# define EVP_PKEY_CTRL_RSA_MGF1_MD       (EVP_PKEY_ALG_CTRL + 5)\n\n# define EVP_PKEY_CTRL_GET_RSA_PADDING           (EVP_PKEY_ALG_CTRL + 6)\n# define EVP_PKEY_CTRL_GET_RSA_PSS_SALTLEN       (EVP_PKEY_ALG_CTRL + 7)\n# define EVP_PKEY_CTRL_GET_RSA_MGF1_MD           (EVP_PKEY_ALG_CTRL + 8)\n\n# define EVP_PKEY_CTRL_RSA_OAEP_MD       (EVP_PKEY_ALG_CTRL + 9)\n# define EVP_PKEY_CTRL_RSA_OAEP_LABEL    (EVP_PKEY_ALG_CTRL + 10)\n\n# define EVP_PKEY_CTRL_GET_RSA_OAEP_MD   (EVP_PKEY_ALG_CTRL + 11)\n# define EVP_PKEY_CTRL_GET_RSA_OAEP_LABEL (EVP_PKEY_ALG_CTRL + 12)\n\n# define EVP_PKEY_CTRL_RSA_KEYGEN_PRIMES  (EVP_PKEY_ALG_CTRL + 13)\n\n# define RSA_PKCS1_PADDING       1\n# define RSA_SSLV23_PADDING      2\n# define RSA_NO_PADDING          3\n# define RSA_PKCS1_OAEP_PADDING  4\n# define RSA_X931_PADDING        5\n/* EVP_PKEY_ only */\n# define RSA_PKCS1_PSS_PADDING   6\n\n# define RSA_PKCS1_PADDING_SIZE  11\n\n# define RSA_set_app_data(s,arg)         RSA_set_ex_data(s,0,arg)\n# define RSA_get_app_data(s)             RSA_get_ex_data(s,0)\n\nRSA *RSA_new(void);\nRSA *RSA_new_method(ENGINE *engine);\nint RSA_bits(const RSA *rsa);\nint RSA_size(const RSA *rsa);\nint RSA_security_bits(const RSA *rsa);\n\nint RSA_set0_key(RSA *r, BIGNUM *n, BIGNUM *e, BIGNUM *d);\nint RSA_set0_factors(RSA *r, BIGNUM *p, BIGNUM *q);\nint RSA_set0_crt_params(RSA *r,BIGNUM *dmp1, BIGNUM *dmq1, BIGNUM *iqmp);\nint RSA_set0_multi_prime_params(RSA *r, BIGNUM *primes[], BIGNUM *exps[],\n                                BIGNUM *coeffs[], int pnum);\nvoid RSA_get0_key(const RSA *r,\n                  const BIGNUM **n, const BIGNUM **e, const BIGNUM **d);\nvoid RSA_get0_factors(const RSA *r, const BIGNUM **p, const BIGNUM **q);\nint RSA_get_multi_prime_extra_count(const RSA *r);\nint RSA_get0_multi_prime_factors(const RSA *r, const BIGNUM *primes[]);\nvoid RSA_get0_crt_params(const RSA *r,\n                         const BIGNUM **dmp1, const BIGNUM **dmq1,\n                         const BIGNUM **iqmp);\nint RSA_get0_multi_prime_crt_params(const RSA *r, const BIGNUM *exps[],\n                                    const BIGNUM *coeffs[]);\nconst BIGNUM *RSA_get0_n(const RSA *d);\nconst BIGNUM *RSA_get0_e(const RSA *d);\nconst BIGNUM *RSA_get0_d(const RSA *d);\nconst BIGNUM *RSA_get0_p(const RSA *d);\nconst BIGNUM *RSA_get0_q(const RSA *d);\nconst BIGNUM *RSA_get0_dmp1(const RSA *r);\nconst BIGNUM *RSA_get0_dmq1(const RSA *r);\nconst BIGNUM *RSA_get0_iqmp(const RSA *r);\nconst RSA_PSS_PARAMS *RSA_get0_pss_params(const RSA *r);\nvoid RSA_clear_flags(RSA *r, int flags);\nint RSA_test_flags(const RSA *r, int flags);\nvoid RSA_set_flags(RSA *r, int flags);\nint RSA_get_version(RSA *r);\nENGINE *RSA_get0_engine(const RSA *r);\n\n/* Deprecated version */\nDEPRECATEDIN_0_9_8(RSA *RSA_generate_key(int bits, unsigned long e, void\n                                         (*callback) (int, int, void *),\n                                         void *cb_arg))\n\n/* New version */\nint RSA_generate_key_ex(RSA *rsa, int bits, BIGNUM *e, BN_GENCB *cb);\n/* Multi-prime version */\nint RSA_generate_multi_prime_key(RSA *rsa, int bits, int primes,\n                                 BIGNUM *e, BN_GENCB *cb);\n\nint RSA_X931_derive_ex(RSA *rsa, BIGNUM *p1, BIGNUM *p2, BIGNUM *q1,\n                       BIGNUM *q2, const BIGNUM *Xp1, const BIGNUM *Xp2,\n                       const BIGNUM *Xp, const BIGNUM *Xq1, const BIGNUM *Xq2,\n                       const BIGNUM *Xq, const BIGNUM *e, BN_GENCB *cb);\nint RSA_X931_generate_key_ex(RSA *rsa, int bits, const BIGNUM *e,\n                             BN_GENCB *cb);\n\nint RSA_check_key(const RSA *);\nint RSA_check_key_ex(const RSA *, BN_GENCB *cb);\n        /* next 4 return -1 on error */\nint RSA_public_encrypt(int flen, const unsigned char *from,\n                       unsigned char *to, RSA *rsa, int padding);\nint RSA_private_encrypt(int flen, const unsigned char *from,\n                        unsigned char *to, RSA *rsa, int padding);\nint RSA_public_decrypt(int flen, const unsigned char *from,\n                       unsigned char *to, RSA *rsa, int padding);\nint RSA_private_decrypt(int flen, const unsigned char *from,\n                        unsigned char *to, RSA *rsa, int padding);\nvoid RSA_free(RSA *r);\n/* \"up\" the RSA object's reference count */\nint RSA_up_ref(RSA *r);\n\nint RSA_flags(const RSA *r);\n\nvoid RSA_set_default_method(const RSA_METHOD *meth);\nconst RSA_METHOD *RSA_get_default_method(void);\nconst RSA_METHOD *RSA_null_method(void);\nconst RSA_METHOD *RSA_get_method(const RSA *rsa);\nint RSA_set_method(RSA *rsa, const RSA_METHOD *meth);\n\n/* these are the actual RSA functions */\nconst RSA_METHOD *RSA_PKCS1_OpenSSL(void);\n\nint RSA_pkey_ctx_ctrl(EVP_PKEY_CTX *ctx, int optype, int cmd, int p1, void *p2);\n\nDECLARE_ASN1_ENCODE_FUNCTIONS_const(RSA, RSAPublicKey)\nDECLARE_ASN1_ENCODE_FUNCTIONS_const(RSA, RSAPrivateKey)\n\nstruct rsa_pss_params_st {\n    X509_ALGOR *hashAlgorithm;\n    X509_ALGOR *maskGenAlgorithm;\n    ASN1_INTEGER *saltLength;\n    ASN1_INTEGER *trailerField;\n    /* Decoded hash algorithm from maskGenAlgorithm */\n    X509_ALGOR *maskHash;\n};\n\nDECLARE_ASN1_FUNCTIONS(RSA_PSS_PARAMS)\n\ntypedef struct rsa_oaep_params_st {\n    X509_ALGOR *hashFunc;\n    X509_ALGOR *maskGenFunc;\n    X509_ALGOR *pSourceFunc;\n    /* Decoded hash algorithm from maskGenFunc */\n    X509_ALGOR *maskHash;\n} RSA_OAEP_PARAMS;\n\nDECLARE_ASN1_FUNCTIONS(RSA_OAEP_PARAMS)\n\n# ifndef OPENSSL_NO_STDIO\nint RSA_print_fp(FILE *fp, const RSA *r, int offset);\n# endif\n\nint RSA_print(BIO *bp, const RSA *r, int offset);\n\n/*\n * The following 2 functions sign and verify a X509_SIG ASN1 object inside\n * PKCS#1 padded RSA encryption\n */\nint RSA_sign(int type, const unsigned char *m, unsigned int m_length,\n             unsigned char *sigret, unsigned int *siglen, RSA *rsa);\nint RSA_verify(int type, const unsigned char *m, unsigned int m_length,\n               const unsigned char *sigbuf, unsigned int siglen, RSA *rsa);\n\n/*\n * The following 2 function sign and verify a ASN1_OCTET_STRING object inside\n * PKCS#1 padded RSA encryption\n */\nint RSA_sign_ASN1_OCTET_STRING(int type,\n                               const unsigned char *m, unsigned int m_length,\n                               unsigned char *sigret, unsigned int *siglen,\n                               RSA *rsa);\nint RSA_verify_ASN1_OCTET_STRING(int type, const unsigned char *m,\n                                 unsigned int m_length, unsigned char *sigbuf,\n                                 unsigned int siglen, RSA *rsa);\n\nint RSA_blinding_on(RSA *rsa, BN_CTX *ctx);\nvoid RSA_blinding_off(RSA *rsa);\nBN_BLINDING *RSA_setup_blinding(RSA *rsa, BN_CTX *ctx);\n\nint RSA_padding_add_PKCS1_type_1(unsigned char *to, int tlen,\n                                 const unsigned char *f, int fl);\nint RSA_padding_check_PKCS1_type_1(unsigned char *to, int tlen,\n                                   const unsigned char *f, int fl,\n                                   int rsa_len);\nint RSA_padding_add_PKCS1_type_2(unsigned char *to, int tlen,\n                                 const unsigned char *f, int fl);\nint RSA_padding_check_PKCS1_type_2(unsigned char *to, int tlen,\n                                   const unsigned char *f, int fl,\n                                   int rsa_len);\nint PKCS1_MGF1(unsigned char *mask, long len, const unsigned char *seed,\n               long seedlen, const EVP_MD *dgst);\nint RSA_padding_add_PKCS1_OAEP(unsigned char *to, int tlen,\n                               const unsigned char *f, int fl,\n                               const unsigned char *p, int pl);\nint RSA_padding_check_PKCS1_OAEP(unsigned char *to, int tlen,\n                                 const unsigned char *f, int fl, int rsa_len,\n                                 const unsigned char *p, int pl);\nint RSA_padding_add_PKCS1_OAEP_mgf1(unsigned char *to, int tlen,\n                                    const unsigned char *from, int flen,\n                                    const unsigned char *param, int plen,\n                                    const EVP_MD *md, const EVP_MD *mgf1md);\nint RSA_padding_check_PKCS1_OAEP_mgf1(unsigned char *to, int tlen,\n                                      const unsigned char *from, int flen,\n                                      int num, const unsigned char *param,\n                                      int plen, const EVP_MD *md,\n                                      const EVP_MD *mgf1md);\nint RSA_padding_add_SSLv23(unsigned char *to, int tlen,\n                           const unsigned char *f, int fl);\nint RSA_padding_check_SSLv23(unsigned char *to, int tlen,\n                             const unsigned char *f, int fl, int rsa_len);\nint RSA_padding_add_none(unsigned char *to, int tlen, const unsigned char *f,\n                         int fl);\nint RSA_padding_check_none(unsigned char *to, int tlen,\n                           const unsigned char *f, int fl, int rsa_len);\nint RSA_padding_add_X931(unsigned char *to, int tlen, const unsigned char *f,\n                         int fl);\nint RSA_padding_check_X931(unsigned char *to, int tlen,\n                           const unsigned char *f, int fl, int rsa_len);\nint RSA_X931_hash_id(int nid);\n\nint RSA_verify_PKCS1_PSS(RSA *rsa, const unsigned char *mHash,\n                         const EVP_MD *Hash, const unsigned char *EM,\n                         int sLen);\nint RSA_padding_add_PKCS1_PSS(RSA *rsa, unsigned char *EM,\n                              const unsigned char *mHash, const EVP_MD *Hash,\n                              int sLen);\n\nint RSA_verify_PKCS1_PSS_mgf1(RSA *rsa, const unsigned char *mHash,\n                              const EVP_MD *Hash, const EVP_MD *mgf1Hash,\n                              const unsigned char *EM, int sLen);\n\nint RSA_padding_add_PKCS1_PSS_mgf1(RSA *rsa, unsigned char *EM,\n                                   const unsigned char *mHash,\n                                   const EVP_MD *Hash, const EVP_MD *mgf1Hash,\n                                   int sLen);\n\n#define RSA_get_ex_new_index(l, p, newf, dupf, freef) \\\n    CRYPTO_get_ex_new_index(CRYPTO_EX_INDEX_RSA, l, p, newf, dupf, freef)\nint RSA_set_ex_data(RSA *r, int idx, void *arg);\nvoid *RSA_get_ex_data(const RSA *r, int idx);\n\nRSA *RSAPublicKey_dup(RSA *rsa);\nRSA *RSAPrivateKey_dup(RSA *rsa);\n\n/*\n * If this flag is set the RSA method is FIPS compliant and can be used in\n * FIPS mode. This is set in the validated module method. If an application\n * sets this flag in its own methods it is its responsibility to ensure the\n * result is compliant.\n */\n\n# define RSA_FLAG_FIPS_METHOD                    0x0400\n\n/*\n * If this flag is set the operations normally disabled in FIPS mode are\n * permitted it is then the applications responsibility to ensure that the\n * usage is compliant.\n */\n\n# define RSA_FLAG_NON_FIPS_ALLOW                 0x0400\n/*\n * Application has decided PRNG is good enough to generate a key: don't\n * check.\n */\n# define RSA_FLAG_CHECKED                        0x0800\n\nRSA_METHOD *RSA_meth_new(const char *name, int flags);\nvoid RSA_meth_free(RSA_METHOD *meth);\nRSA_METHOD *RSA_meth_dup(const RSA_METHOD *meth);\nconst char *RSA_meth_get0_name(const RSA_METHOD *meth);\nint RSA_meth_set1_name(RSA_METHOD *meth, const char *name);\nint RSA_meth_get_flags(const RSA_METHOD *meth);\nint RSA_meth_set_flags(RSA_METHOD *meth, int flags);\nvoid *RSA_meth_get0_app_data(const RSA_METHOD *meth);\nint RSA_meth_set0_app_data(RSA_METHOD *meth, void *app_data);\nint (*RSA_meth_get_pub_enc(const RSA_METHOD *meth))\n    (int flen, const unsigned char *from,\n     unsigned char *to, RSA *rsa, int padding);\nint RSA_meth_set_pub_enc(RSA_METHOD *rsa,\n                         int (*pub_enc) (int flen, const unsigned char *from,\n                                         unsigned char *to, RSA *rsa,\n                                         int padding));\nint (*RSA_meth_get_pub_dec(const RSA_METHOD *meth))\n    (int flen, const unsigned char *from,\n     unsigned char *to, RSA *rsa, int padding);\nint RSA_meth_set_pub_dec(RSA_METHOD *rsa,\n                         int (*pub_dec) (int flen, const unsigned char *from,\n                                         unsigned char *to, RSA *rsa,\n                                         int padding));\nint (*RSA_meth_get_priv_enc(const RSA_METHOD *meth))\n    (int flen, const unsigned char *from,\n     unsigned char *to, RSA *rsa, int padding);\nint RSA_meth_set_priv_enc(RSA_METHOD *rsa,\n                          int (*priv_enc) (int flen, const unsigned char *from,\n                                           unsigned char *to, RSA *rsa,\n                                           int padding));\nint (*RSA_meth_get_priv_dec(const RSA_METHOD *meth))\n    (int flen, const unsigned char *from,\n     unsigned char *to, RSA *rsa, int padding);\nint RSA_meth_set_priv_dec(RSA_METHOD *rsa,\n                          int (*priv_dec) (int flen, const unsigned char *from,\n                                           unsigned char *to, RSA *rsa,\n                                           int padding));\nint (*RSA_meth_get_mod_exp(const RSA_METHOD *meth))\n    (BIGNUM *r0, const BIGNUM *i, RSA *rsa, BN_CTX *ctx);\nint RSA_meth_set_mod_exp(RSA_METHOD *rsa,\n                         int (*mod_exp) (BIGNUM *r0, const BIGNUM *i, RSA *rsa,\n                                         BN_CTX *ctx));\nint (*RSA_meth_get_bn_mod_exp(const RSA_METHOD *meth))\n    (BIGNUM *r, const BIGNUM *a, const BIGNUM *p,\n     const BIGNUM *m, BN_CTX *ctx, BN_MONT_CTX *m_ctx);\nint RSA_meth_set_bn_mod_exp(RSA_METHOD *rsa,\n                            int (*bn_mod_exp) (BIGNUM *r,\n                                               const BIGNUM *a,\n                                               const BIGNUM *p,\n                                               const BIGNUM *m,\n                                               BN_CTX *ctx,\n                                               BN_MONT_CTX *m_ctx));\nint (*RSA_meth_get_init(const RSA_METHOD *meth)) (RSA *rsa);\nint RSA_meth_set_init(RSA_METHOD *rsa, int (*init) (RSA *rsa));\nint (*RSA_meth_get_finish(const RSA_METHOD *meth)) (RSA *rsa);\nint RSA_meth_set_finish(RSA_METHOD *rsa, int (*finish) (RSA *rsa));\nint (*RSA_meth_get_sign(const RSA_METHOD *meth))\n    (int type,\n     const unsigned char *m, unsigned int m_length,\n     unsigned char *sigret, unsigned int *siglen,\n     const RSA *rsa);\nint RSA_meth_set_sign(RSA_METHOD *rsa,\n                      int (*sign) (int type, const unsigned char *m,\n                                   unsigned int m_length,\n                                   unsigned char *sigret, unsigned int *siglen,\n                                   const RSA *rsa));\nint (*RSA_meth_get_verify(const RSA_METHOD *meth))\n    (int dtype, const unsigned char *m,\n     unsigned int m_length, const unsigned char *sigbuf,\n     unsigned int siglen, const RSA *rsa);\nint RSA_meth_set_verify(RSA_METHOD *rsa,\n                        int (*verify) (int dtype, const unsigned char *m,\n                                       unsigned int m_length,\n                                       const unsigned char *sigbuf,\n                                       unsigned int siglen, const RSA *rsa));\nint (*RSA_meth_get_keygen(const RSA_METHOD *meth))\n    (RSA *rsa, int bits, BIGNUM *e, BN_GENCB *cb);\nint RSA_meth_set_keygen(RSA_METHOD *rsa,\n                        int (*keygen) (RSA *rsa, int bits, BIGNUM *e,\n                                       BN_GENCB *cb));\nint (*RSA_meth_get_multi_prime_keygen(const RSA_METHOD *meth))\n    (RSA *rsa, int bits, int primes, BIGNUM *e, BN_GENCB *cb);\nint RSA_meth_set_multi_prime_keygen(RSA_METHOD *meth,\n                                    int (*keygen) (RSA *rsa, int bits,\n                                                   int primes, BIGNUM *e,\n                                                   BN_GENCB *cb));\n\n#  ifdef  __cplusplus\n}\n#  endif\n# endif\n#endif\n"}, "7": {"id": 7, "path": "/home/runner/work/testcc/testcc/retdec/src/lib/macros.h", "content": "#ifndef MACROS_H\n#define MACROS_H\n\n/* several useful macros, mostly from glib.h */\n\n#ifndef NULL\n#  define NULL ((void *)0)\n#endif\n\n#ifndef FALSE\n#  define FALSE (!1)\n#endif\n\n#ifndef TRUE\n#  define TRUE (!FALSE)\n#endif\n\n#define N_ELEMENTS(arr) \\\n\t(sizeof(arr) / sizeof((arr)[0]))\n\n#define MEM_ALIGN(size) \\\n\t(((size) + MEM_ALIGN_SIZE-1) & ~((size_t) MEM_ALIGN_SIZE-1))\n\n#define PTR_OFFSET(ptr, offset) \\\n\t((void *) (((uintptr_t) (ptr)) + ((size_t) (offset))))\n#define CONST_PTR_OFFSET(ptr, offset) \\\n\t((const void *) (((uintptr_t) (ptr)) + ((size_t) (offset))))\n\n#define container_of(ptr, type, name) \\\n\t(type *)((uintptr_t)(ptr) - (uintptr_t)offsetof(type, name) + \\\n\t\t COMPILE_ERROR_IF_TYPES_NOT_COMPATIBLE(ptr, &((type *) 0)->name))\n\n/* Don't use simply MIN/MAX, as they're often defined elsewhere in include\n   files that are included after this file generating tons of warnings. */\n#define I_MIN(a, b)  (((a) < (b)) ? (a) : (b))\n#define I_MAX(a, b)  (((a) > (b)) ? (a) : (b))\n\n/* make it easier to cast from/to pointers. assumes that\n   sizeof(uintptr_t) == sizeof(void *) and they're both the largest datatypes\n   that are allowed to be used. so, long long isn't safe with these. */\n#define POINTER_CAST(i) \\\n\t((void *) (((uintptr_t)NULL) + (i)))\n#define POINTER_CAST_TO(p, type) \\\n\t((type) ((const char *) (p) - (const char *) NULL))\n\n/* Define VA_COPY() to do the right thing for copying va_list variables.\n   config.h may have already defined VA_COPY as va_copy or __va_copy. */\n#ifndef VA_COPY\n#  if defined (__GNUC__) && defined (__PPC__) && \\\n      (defined (_CALL_SYSV) || defined (_WIN32))\n#    define VA_COPY(ap1, ap2) (*(ap1) = *(ap2))\n#  elif defined (VA_COPY_AS_ARRAY)\n#    define VA_COPY(ap1, ap2) memmove ((ap1), (ap2), sizeof (va_list))\n#  else /* va_list is a pointer */\n#    define VA_COPY(ap1, ap2) ((ap1) = (ap2))\n#  endif /* va_list is a pointer */\n#endif\n\n/* Provide convenience macros for handling structure\n * fields through their offsets.\n */\n#define STRUCT_MEMBER_P(struct_p, struct_offset) \\\n\t((void *) ((char *) (struct_p) + (long) (struct_offset)))\n#define CONST_STRUCT_MEMBER_P(struct_p, struct_offset) \\\n\t((const void *) ((const char *) (struct_p) + (long) (struct_offset)))\n\n/* Provide simple macro statement wrappers (adapted from Perl):\n   STMT_START { statements; } STMT_END;\n   can be used as a single statement, as in\n   if (x) STMT_START { ... } STMT_END; else ...\n\n   For gcc we will wrap the statements within `({' and `})' braces.\n   For SunOS they will be wrapped within `if (1)' and `else (void) 0',\n   and otherwise within `do' and `while (0)'. */\n#if !(defined (STMT_START) && defined (STMT_END))\n#  if defined (__GNUC__) && !defined (__cplusplus) && \\\n\t!defined (__STRICT_ANSI__) && !defined (PEDANTIC)\n#    define STMT_START (void)(\n#    define STMT_END   )\n#  else\n#    if (defined (sun) || defined (__sun__))\n#      define STMT_START if (1)\n#      define STMT_END   else (void)0\n#    else\n#      define STMT_START do\n#      define STMT_END   while (0)\n#    endif\n#  endif\n#endif\n\n/* Provide macros to feature the GCC function attribute. */\n#if __GNUC__ > 2 || (__GNUC__ == 2 && __GNUC_MINOR__ > 4)\n#  define ATTRS_DEFINED\n#  define ATTR_FORMAT(format_idx, arg_idx) \\\n\t__attribute__((format (printf, format_idx, arg_idx)))\n#  define ATTR_FORMAT_ARG(arg_idx) \\\n\t__attribute__((format_arg (arg_idx)))\n#  define ATTR_SCANF(format_idx, arg_idx) \\\n\t__attribute__((format (scanf, format_idx, arg_idx)))\n#  define ATTR_STRFTIME(format_idx) \\\n\t__attribute__((format (strftime, format_idx, 0)))\n#  define ATTR_UNUSED __attribute__((unused))\n#  define ATTR_NORETURN __attribute__((noreturn))\n#  define ATTR_CONST __attribute__((const))\n#  define ATTR_PURE __attribute__((pure))\n#else\n#  define ATTR_FORMAT(format_idx, arg_idx)\n#  define ATTR_FORMAT_ARG(arg_idx)\n#  define ATTR_SCANF(format_idx, arg_idx)\n#  define ATTR_STRFTIME(format_idx)\n#  define ATTR_UNUSED\n#  define ATTR_NORETURN\n#  define ATTR_CONST\n#  define ATTR_PURE\n#endif\n#ifdef HAVE_ATTR_NULL\n#  define ATTR_NULL(...) __attribute__((null(__VA_ARGS__)))\n#else\n#  define ATTR_NULL(...)\n#endif\n#ifdef HAVE_ATTR_NOWARN_UNUSED_RESULT\n#  define ATTR_NOWARN_UNUSED_RESULT __attribute__((nowarn_unused_result))\n#else\n#  define ATTR_NOWARN_UNUSED_RESULT\n#endif\n#if __GNUC__ > 2\n#  define ATTR_MALLOC __attribute__((malloc))\n#else\n#  define ATTR_MALLOC\n#endif\n#if __GNUC__ > 3\n/* GCC 4.0 and later */\n#  define ATTR_WARN_UNUSED_RESULT __attribute__((warn_unused_result))\n#  define ATTR_SENTINEL __attribute__((sentinel))\n#else\n#  define ATTR_WARN_UNUSED_RESULT\n#  define ATTR_SENTINEL\n#endif\n#if __GNUC__ > 4 || (__GNUC__ == 4 && __GNUC_MINOR__ >= 3)\n/* GCC 4.3 and later */\n#  define ATTR_HOT __attribute__((hot))\n#  define ATTR_COLD __attribute__((cold))\n#else\n#  define ATTR_HOT\n#  define ATTR_COLD\n#endif\n#if __GNUC__ > 4 || (__GNUC__ == 4 && __GNUC_MINOR__ >= 9)\n/* GCC 4.9 and later */\n#  define ATTR_RETURNS_NONNULL __attribute__((returns_nonnull))\n#else\n#  define ATTR_RETURNS_NONNULL\n#endif\n#ifdef HAVE_ATTR_DEPRECATED\n#  define ATTR_DEPRECATED(str) __attribute__((deprecated(str)))\n#else\n#  define ATTR_DEPRECATED(str)\n#endif\n\n/* Macros to provide type safety for callback functions' context parameters */\n#ifdef HAVE_TYPE_CHECKS\n#  define CALLBACK_TYPECHECK(callback, type) \\\n\t(COMPILE_ERROR_IF_TRUE(!__builtin_types_compatible_p( \\\n\t\ttypeof(&callback), type)) ? 1 : 0)\n#else\n#  define CALLBACK_TYPECHECK(callback, type) 0\n#endif\n\n#if (__GNUC__ > 3 || (__GNUC__ == 3 && __GNUC_MINOR__ > 0)) && !defined(__cplusplus)\n#  define COMPILE_ERROR_IF_TRUE(condition) \\\n\t(sizeof(char[1 - 2 * ((condition) ? 1 : 0)]) - 1)\n#else\n#  define COMPILE_ERROR_IF_TRUE(condition) 0\n#endif\n\n#ifdef HAVE_TYPE_CHECKS\n#  define COMPILE_ERROR_IF_TYPES_NOT_COMPATIBLE(_a, _b) \\\n\tCOMPILE_ERROR_IF_TRUE( \\\n\t\t!__builtin_types_compatible_p(typeof(_a), typeof(_b)))\n#define COMPILE_ERROR_IF_TYPES2_NOT_COMPATIBLE(_a1, _a2, _b) \\\n\tCOMPILE_ERROR_IF_TRUE( \\\n\t\t!__builtin_types_compatible_p(typeof(_a1), typeof(_b)) && \\\n\t\t!__builtin_types_compatible_p(typeof(_a2), typeof(_b)))\n#else\n#  define COMPILE_ERROR_IF_TYPES_NOT_COMPATIBLE(_a, _b) 0\n#  define COMPILE_ERROR_IF_TYPES2_NOT_COMPATIBLE(_a1, _a2, _b) 0\n#endif\n\n#if __GNUC__ > 2\n#  define unlikely(expr) (__builtin_expect((expr) ? 1 : 0, 0) != 0)\n#  define likely(expr) (__builtin_expect((expr) ? 1 : 0, 1) != 0)\n#else\n#  define unlikely(expr) expr\n#  define likely(expr) expr\n#endif\n\n#if defined(__clang__) && ((__clang_major__ > 4) || (__clang_major__ == 3 && __clang_minor__ >= 9))\n#  define ATTR_UNSIGNED_WRAPS __attribute__((no_sanitize(\"integer\")))\n#else\n#  define ATTR_UNSIGNED_WRAPS\n#endif\n\n/* Provide macros for error handling. */\n#ifdef DISABLE_ASSERTS\n#  define i_assert(expr)\n#else\n\n#define i_assert(expr)\t\t\tSTMT_START{\t\t\t\\\n     if (unlikely(!(expr)))\t\t\t\t\t\t\\\n       i_panic(\"file %s: line %d (%s): assertion failed: (%s)\",\t\t\\\n\t\t__FILE__,\t\t\t\t\t\t\\\n\t\t__LINE__,\t\t\t\t\t\t\\\n\t\t__func__,\t\t\t\t\t\\\n\t\t#expr);\t\t\t}STMT_END\n\n#endif\n\n#ifndef STATIC_CHECKER\n#  define i_unreached() \\\n\ti_panic(\"file %s: line %d: unreached\", __FILE__, __LINE__)\n#else\n#  define i_unreached() __builtin_unreachable()\n#endif\n\n/* Convenience macros to test the versions of dovecot. */\n#if defined DOVECOT_VERSION_MAJOR && defined DOVECOT_VERSION_MINOR\n#  define DOVECOT_PREREQ(maj, min) \\\n          ((DOVECOT_VERSION_MAJOR << 16) + DOVECOT_VERSION_MINOR >= ((maj) << 16) + (min))\n#else\n#  define DOVECOT_PREREQ(maj, min) 0\n#endif\n\n#ifdef __cplusplus\n#  undef STATIC_ARRAY\n#  define STATIC_ARRAY\n#endif\n\n/* Convenience wrappers for initializing a struct with zeros, although it can\n   be used for replacing other memset()s also.\n\n   // NOTE: This is the correct way to zero the whole array\n   char arr[5]; i_zero(&arr);\n   // This will give compiler error (or zero only the first element):\n   char arr[5]; i_zero(arr);\n*/\n#define i_zero(p) \\\n\tmemset(p, 0 + COMPILE_ERROR_IF_TRUE(sizeof(p) > sizeof(void *)), sizeof(*(p)))\n#define i_zero_safe(p) \\\n\tsafe_memset(p, 0 + COMPILE_ERROR_IF_TRUE(sizeof(p) > sizeof(void *)), sizeof(*(p)))\n\n#define ST_CHANGED(st_a, st_b) \\\n\t((st_a).st_mtime != (st_b).st_mtime || \\\n\t ST_MTIME_NSEC(st_a) != ST_MTIME_NSEC(st_b) || \\\n\t (st_a).st_size != (st_b).st_size || \\\n\t (st_a).st_ino != (st_b).st_ino)\n\n#endif\n"}, "8": {"id": 8, "path": "/home/runner/work/testcc/testcc/retdec/src/lib/imem.h", "content": "#ifndef IMEM_H\n#define IMEM_H\n\n/* For easy allocation of memory from default memory pool. */\n\nextern pool_t default_pool;\n\n#define i_new(type, count) p_new(default_pool, type, count)\n#define i_realloc_type(mem, type, old_count, new_count) \\\n\tp_realloc_type(default_pool, mem, type, old_count, new_count)\n\nvoid *i_malloc(size_t size) ATTR_MALLOC ATTR_RETURNS_NONNULL;\nvoid *i_realloc(void *mem, size_t old_size, size_t new_size)\n\tATTR_WARN_UNUSED_RESULT ATTR_RETURNS_NONNULL;\n\n/* i_free() and i_free_and_null() are now guaranteed to both set mem=NULL,\n   so either one of them can be used. */\n#ifndef STATIC_CHECKER\n#  define i_free(mem) p_free_and_null(default_pool, mem)\n#else\n#  define i_free(mem) \\\n\tSTMT_START { \\\n\t\tpool_system_free(default_pool, mem); \\\n\t\t(mem) = NULL; \\\n\t} STMT_END\n#endif\n#define i_free_and_null(mem) i_free(mem)\n\n/* string functions */\nchar *i_strdup(const char *str) ATTR_MALLOC;\nvoid *i_memdup(const void *data, size_t size) ATTR_MALLOC;\n/* like i_strdup(), but if str == \"\", return NULL */\nchar *i_strdup_empty(const char *str) ATTR_MALLOC;\n/* *end isn't included */\nchar *i_strdup_until(const void *str, const void *end)\n\tATTR_MALLOC ATTR_RETURNS_NONNULL;\nchar *i_strndup(const void *str, size_t max_chars) ATTR_MALLOC;\nchar *i_strdup_printf(const char *format, ...)\n\tATTR_FORMAT(1, 2) ATTR_MALLOC ATTR_RETURNS_NONNULL;\nchar *i_strdup_vprintf(const char *format, va_list args)\n\tATTR_FORMAT(1, 0) ATTR_MALLOC ATTR_RETURNS_NONNULL;\n\nchar *i_strconcat(const char *str1, ...)  ATTR_SENTINEL ATTR_MALLOC;\n\n#endif\n"}, "9": {"id": 9, "path": "/home/runner/work/testcc/testcc/retdec/src/lib/buffer.h", "content": "#ifndef BUFFER_H\n#define BUFFER_H\n\nstruct buffer {\n\tconst void *data;\n\tconst size_t used;\n\tvoid *priv[5];\n};\n\n/* WARNING: Be careful with functions that return pointers to data.\n   With dynamic buffers they are valid only as long as buffer is not\n   realloc()ed. You shouldn't rely on it being valid if you have modified\n   buffer in any way. */\n\n/* Create a modifiable buffer from given data. Writes past this size will\n   i_panic(). */\nvoid buffer_create_from_data(buffer_t *buffer, void *data, size_t size);\n/* Create a non-modifiable buffer from given data. */\nvoid buffer_create_from_const_data(buffer_t *buffer,\n\t\t\t\t   const void *data, size_t size);\n#if defined(__GNUC__) && (__GNUC__ * 100 + __GNUC_MINOR__) > 401\n#define buffer_create_from_data(b,d,s) ({\t\t\t\t           \\\n\t(void)COMPILE_ERROR_IF_TRUE(__builtin_object_size((d),1) < ((s)>0?(s):1)); \\\n\tbuffer_create_from_data((b), (d), (s)); })\n#define buffer_create_from_const_data(b,d,s) ({\t\t\t\t           \\\n\t(void)COMPILE_ERROR_IF_TRUE(__builtin_object_size((d),1) < ((s)>0?(s):1)); \\\n\tbuffer_create_from_const_data((b), (d), (s)); })\n#endif\n/* Creates a dynamically growing buffer. Whenever write would exceed the\n   current size it's grown. */\nbuffer_t *buffer_create_dynamic(pool_t pool, size_t init_size);\n\n#define t_buffer_create(init_size) \\\n\tbuffer_create_dynamic(pool_datastack_create(), (init_size))\n\n/* Free the memory used by buffer. Not needed if the memory is free'd\n   directly from the memory pool. */\nvoid buffer_free(buffer_t **buf);\n/* Free the memory used by buffer structure, but return the buffer data\n   unfree'd. */\nvoid *buffer_free_without_data(buffer_t **buf);\n\n/* Returns the pool buffer was created with. */\npool_t buffer_get_pool(const buffer_t *buf) ATTR_PURE;\n\n/* Write data to buffer at specified position. If pos is beyond the buffer's\n   current size, it is zero-filled up to that point (even if data_size==0). */\nvoid buffer_write(buffer_t *buf, size_t pos,\n\t\t  const void *data, size_t data_size);\n/* Append data to buffer. */\nvoid buffer_append(buffer_t *buf, const void *data, size_t data_size);\n/* Append character to buffer. */\nvoid buffer_append_c(buffer_t *buf, unsigned char chr);\n\n/* Insert the provided data into the buffer at position pos. If pos points past\n   the current buffer size, the gap is zero-filled. */\nvoid buffer_insert(buffer_t *buf, size_t pos,\n\t\t   const void *data, size_t data_size);\n/* Delete data with the indicated size from the buffer at position pos. The\n   deleted block may cross the current buffer size boundary, which is ignored.\n */\nvoid buffer_delete(buffer_t *buf, size_t pos, size_t size);\n/* Replace the data in the buffer with the indicated size at position pos with\n   the provided data. This is a more optimized version of\n   buffer_delete(buf, pos, size); buffer_insert(buf, pos, data, data_size); */\nvoid buffer_replace(buffer_t *buf, size_t pos, size_t size,\n\t\t    const void *data, size_t data_size);\n\n/* Fill buffer with zero bytes. */\nvoid buffer_write_zero(buffer_t *buf, size_t pos, size_t data_size);\nvoid buffer_append_zero(buffer_t *buf, size_t data_size);\nvoid buffer_insert_zero(buffer_t *buf, size_t pos, size_t data_size);\n\n/* Copy data from buffer to another. The buffers may be same in which case\n   it's internal copying, possibly with overlapping positions (ie. memmove()\n   like functionality). copy_size may be set to (size_t)-1 to copy the rest of\n   the used data in buffer. */\nvoid buffer_copy(buffer_t *dest, size_t dest_pos,\n\t\t const buffer_t *src, size_t src_pos, size_t copy_size);\n/* Append data to buffer from another. copy_size may be set to (size_t)-1 to\n   copy the rest of the used data in buffer. */\nvoid buffer_append_buf(buffer_t *dest, const buffer_t *src,\n\t\t       size_t src_pos, size_t copy_size);\n\n/* Returns pointer to specified position in buffer. WARNING: The returned\n   address may become invalid if you add more data to buffer. */\nvoid *buffer_get_space_unsafe(buffer_t *buf, size_t pos, size_t size);\n/* Increase the buffer usage by given size, and return a pointer to beginning\n   of it. */\nvoid *buffer_append_space_unsafe(buffer_t *buf, size_t size);\n\n/* Like buffer_get_data(), but don't return it as const. Returns NULL if the\n   buffer is non-modifiable. WARNING: The returned address may become invalid\n   if you add more data to buffer. */\nvoid *buffer_get_modifiable_data(const buffer_t *buf, size_t *used_size_r)\n\tATTR_NULL(2);\n\n/* Set the \"used size\" of buffer, ie. 0 would set the buffer empty.\n   Must not be used to grow buffer. The data after the buffer's new size will\n   be effectively lost, because e.g. buffer_get_space_unsafe() will zero out\n   the contents. */\nvoid buffer_set_used_size(buffer_t *buf, size_t used_size);\n\n/* Returns the current buffer size. */\nsize_t buffer_get_size(const buffer_t *buf) ATTR_PURE;\n/* Returns how many bytes we can write to buffer without increasing its size.\n   With dynamic buffers this is buffer_get_size()-1, because the extra 1 byte\n   is reserved for str_c()'s NUL. */\nsize_t buffer_get_writable_size(const buffer_t *buf) ATTR_PURE;\n/* Returns the maximum number of bytes we can append to the buffer. If the\n   buffer is dynamic, this is always near SIZE_MAX. */\nsize_t buffer_get_avail_size(const buffer_t *buf) ATTR_PURE;\n\n/* Returns TRUE if buffer contents are identical. */\nbool buffer_cmp(const buffer_t *buf1, const buffer_t *buf2);\n\n/* Returns pointer to beginning of buffer data. Current used size of buffer is\n   stored in used_size if it's non-NULL. */\nstatic inline const void * ATTR_NULL(2)\nbuffer_get_data(const buffer_t *buf, size_t *used_size_r)\n{\n\tif (used_size_r != NULL)\n\t\t*used_size_r = buf->used;\n\treturn buf->data;\n}\n\n/* Returns the current used buffer size. */\nstatic inline size_t ATTR_PURE\nbuffer_get_used_size(const buffer_t *buf)\n{\n\treturn buf->used;\n}\n\n/* Crash if buffer was allocated from data stack and stack frame has changed.\n   This can be used as an assert-like check to verify that it's valid to\n   increase the buffer size here, instead of crashing only randomly when the\n   buffer needs to be increased. */\nvoid buffer_verify_pool(buffer_t *buf);\n\n/* This will truncate your byte buffer to contain at most\n   given number of bits. \n\n 1 bits:    01 00000001\n 2 bits:    03 00000011\n 3 bits:    07 00000111\n 4 bits:    0f 00001111\n 5 bits:    1f 00011111\n 6 bits:    3f 00111111\n 7 bits:    7f 01111111\n 8 bits:    ff 11111111\n 9 bits:  01ff 0000000111111111\n10 bits:  03ff 0000001111111111\n11 bits:  07ff 0000011111111111\n12 bits:  0fff 0000111111111111\n13 bits:  1fff 0001111111111111\n14 bits:  3fff 0011111111111111\n15 bits:  7fff 0111111111111111\n16 bits:  ffff 1111111111111111\n\n and so forth\n\n*/\nvoid buffer_truncate_rshift_bits(buffer_t *buf, size_t bits);\n\n#endif\n"}, "10": {"id": 10, "path": "/home/runner/work/testcc/testcc/retdec/src/lib-dcrypt/dcrypt-private.h", "content": "#ifndef DCRYPT_PRIVATE_H\n#define DCRYPT_PRIVATE_H\n\n#define DCRYPT_DOVECOT_KEY_ENCRYPT_HASH \"sha256\"\n#define DCRYPT_DOVECOT_KEY_ENCRYPT_ROUNDS 2048\n\n#define DCRYPT_DOVECOT_KEY_ENCRYPT_NONE 0\n#define DCRYPT_DOVECOT_KEY_ENCRYPT_PK 1\n#define DCRYPT_DOVECOT_KEY_ENCRYPT_PASSWORD 2\n\nstruct dcrypt_vfs {\n\tbool (*initialize)(const struct dcrypt_settings *set,\n\t\t\t   const char **error_r);\n\n\tbool (*ctx_sym_create)(const char *algorithm,\n\t\t\t       enum dcrypt_sym_mode mode,\n\t\t\t       struct dcrypt_context_symmetric **ctx_r,\n\t\t\t       const char **error_r);\n\tvoid (*ctx_sym_destroy)(struct dcrypt_context_symmetric **ctx);\n\n\tvoid (*ctx_sym_set_key)(struct dcrypt_context_symmetric *ctx,\n\t\t\t\tconst unsigned char *key, size_t key_len);\n\tvoid (*ctx_sym_set_iv)(struct dcrypt_context_symmetric *ctx,\n\t\t\t       const unsigned char *iv, size_t iv_len);\n\tvoid (*ctx_sym_set_key_iv_random)(struct dcrypt_context_symmetric *ctx);\n\n\tvoid (*ctx_sym_set_padding)(struct dcrypt_context_symmetric *ctx,\n\t\t\t\t    bool padding);\n\n\tbool (*ctx_sym_get_key)(struct dcrypt_context_symmetric *ctx,\n\t\t\t\tbuffer_t *key);\n\tbool (*ctx_sym_get_iv)(struct dcrypt_context_symmetric *ctx,\n\t\t\t       buffer_t *iv);\n\n\tvoid (*ctx_sym_set_aad)(struct dcrypt_context_symmetric *ctx,\n\t\t\t\tconst unsigned char *aad, size_t aad_len);\n\tbool (*ctx_sym_get_aad)(struct dcrypt_context_symmetric *ctx,\n\t\t\t\tbuffer_t *aad);\n\tvoid (*ctx_sym_set_tag)(struct dcrypt_context_symmetric *ctx,\n\t\t\t\tconst unsigned char *tag, size_t tag_len);\n\tbool (*ctx_sym_get_tag)(struct dcrypt_context_symmetric *ctx,\n\t\t\t\tbuffer_t *tag);\n\n\tunsigned int (*ctx_sym_get_key_length)(\n\t\tstruct dcrypt_context_symmetric *ctx);\n\tunsigned int (*ctx_sym_get_iv_length)(\n\t\tstruct dcrypt_context_symmetric *ctx);\n\tunsigned int (*ctx_sym_get_block_size)(\n\t\tstruct dcrypt_context_symmetric *ctx);\n\n\tbool (*ctx_sym_init)(struct dcrypt_context_symmetric *ctx,\n\t\t\t     const char **error_r);\n\tbool (*ctx_sym_update)(struct dcrypt_context_symmetric *ctx,\n\t\t\t       const unsigned char *data, size_t data_len,\n\t\t\t       buffer_t *result, const char **error_r);\n\tbool (*ctx_sym_final)(struct dcrypt_context_symmetric *ctx,\n\t\t\t      buffer_t *result, const char **error_r);\n\n\tbool (*ctx_hmac_create)(const char *algorithm,\n\t\t\t\tstruct dcrypt_context_hmac **ctx_r,\n\t\t\t\tconst char **error_r);\n\tvoid (*ctx_hmac_destroy)(struct dcrypt_context_hmac **ctx);\n\n\tvoid (*ctx_hmac_set_key)(struct dcrypt_context_hmac *ctx,\n\t\t\t\t const unsigned char *key, size_t key_len);\n\tbool (*ctx_hmac_get_key)(struct dcrypt_context_hmac *ctx,\n\t\t\t\t buffer_t *key);\n\tunsigned int (*ctx_hmac_get_digest_length)(\n\t\tstruct dcrypt_context_hmac *ctx);\n\tvoid (*ctx_hmac_set_key_random)(struct dcrypt_context_hmac *ctx);\n\n\tbool (*ctx_hmac_init)(struct dcrypt_context_hmac *ctx,\n\t\t\t      const char **error_r);\n\tbool (*ctx_hmac_update)(struct dcrypt_context_hmac *ctx,\n\t\t\t\tconst unsigned char *data, size_t data_len,\n\t\t\t\tconst char **error_r);\n\tbool (*ctx_hmac_final)(struct dcrypt_context_hmac *ctx,\n\t\t\t       buffer_t *result, const char **error_r);\n\n\tbool (*ecdh_derive_secret_local)(struct dcrypt_private_key *local_key,\n\t\t\t\t\t buffer_t *R, buffer_t *S,\n\t\t\t\t\t const char **error_r);\n\tbool (*ecdh_derive_secret_peer)(struct dcrypt_public_key *peer_key,\n\t\t\t\t\tbuffer_t *R, buffer_t *S,\n\t\t\t\t\tconst char **error_r);\n\tbool (*pbkdf2)(const unsigned char *password, size_t password_len,\n\t\t       const unsigned char *salt, size_t salt_len,\n\t\t       const char *hash, unsigned int rounds,\n\t\t       buffer_t *result, unsigned int result_len,\n\t\t       const char **error_r);\n\n\tbool (*generate_keypair)(struct dcrypt_keypair *pair_r,\n\t\t\t\t enum dcrypt_key_type kind, unsigned int bits,\n\t\t\t\t const char *curve, const char **error_r);\n\n\tbool (*load_private_key)(struct dcrypt_private_key **key_r,\n\t\t\t\t const char *data, const char *password,\n\t\t\t\t struct dcrypt_private_key *dec_key,\n\t\t\t\t const char **error_r);\n\tbool (*load_public_key)(struct dcrypt_public_key **key_r,\n\t\t\t\tconst char *data, const char **error_r);\n\n\tbool (*store_private_key)(struct dcrypt_private_key *key,\n\t\t\t\t  enum dcrypt_key_format format,\n\t\t\t\t  const char *cipher, buffer_t *destination,\n\t\t\t\t  const char *password,\n\t\t\t\t  struct dcrypt_public_key *enc_key,\n\t\t\t\t  const char **error_r);\n\tbool (*store_public_key)(struct dcrypt_public_key *key,\n\t\t\t\t enum dcrypt_key_format format,\n\t\t\t\t buffer_t *destination, const char **error_r);\n\n\tvoid (*private_to_public_key)(struct dcrypt_private_key *priv_key,\n\t\t\t\t      struct dcrypt_public_key **pub_key_r);\n\n\tbool (*key_string_get_info)(\n\t\tconst char *key_data, enum dcrypt_key_format *format_r,\n\t\tenum dcrypt_key_version *version_r,\n\t\tenum dcrypt_key_kind *kind_r,\n\t\tenum dcrypt_key_encryption_type *encryption_type_r,\n\t\tconst char **encryption_key_hash_r, const char **key_hash_r,\n\t\tconst char **error_r);\n\n\tvoid (*unref_keypair)(struct dcrypt_keypair *keypair);\n\tvoid (*unref_public_key)(struct dcrypt_public_key **key);\n\tvoid (*unref_private_key)(struct dcrypt_private_key **key);\n        void (*ref_public_key)(struct dcrypt_public_key *key);\n        void (*ref_private_key)(struct dcrypt_private_key *key);\n\n\tbool (*rsa_encrypt)(struct dcrypt_public_key *key,\n\t\t\t    const unsigned char *data, size_t data_len,\n\t\t\t    buffer_t *result, enum dcrypt_padding padding,\n\t\t\t    const char **error_r);\n\tbool (*rsa_decrypt)(struct dcrypt_private_key *key,\n\t\t\t    const unsigned char *data, size_t data_len,\n\t\t\t    buffer_t *result, enum dcrypt_padding padding,\n\t\t\t    const char **error_r);\n\n\tconst char *(*oid2name)(const unsigned char *oid,\n\t\t\t\tsize_t oid_len, const char **error_r);\n\tbool (*name2oid)(const char *name, buffer_t *oid,\n\t\t\t const char **error_r);\n\n\tenum dcrypt_key_type (*private_key_type)(struct dcrypt_private_key *key);\n\tenum dcrypt_key_type (*public_key_type)(struct dcrypt_public_key *key);\n\tbool (*public_key_id)(struct dcrypt_public_key *key,\n\t\t\t      const char *algorithm, buffer_t *result,\n\t\t\t      const char **error_r);\n\tbool (*public_key_id_old)(struct dcrypt_public_key *key,\n\t\t\t\t  buffer_t *result, const char **error_r);\n\tbool (*private_key_id)(struct dcrypt_private_key *key,\n\t\t\t       const char *algorithm, buffer_t *result,\n\t\t\t       const char **error_r);\n\tbool (*private_key_id_old)(struct dcrypt_private_key *key,\n\t\t\t\t   buffer_t *result, const char **error_r);\n\tbool (*key_store_private_raw)(struct dcrypt_private_key *key,\n\t\t\t\t      pool_t pool,\n\t\t\t\t      enum dcrypt_key_type *key_type_r,\n\t\t\t\t      ARRAY_TYPE(dcrypt_raw_key) *keys_r,\n\t\t\t\t      const char **error_r);\n\tbool (*key_store_public_raw)(struct dcrypt_public_key *key,\n\t\t\t\t     pool_t pool,\n\t\t\t\t     enum dcrypt_key_type *key_type_r,\n\t\t\t\t     ARRAY_TYPE(dcrypt_raw_key) *keys_r,\n\t\t\t\t     const char **error_r);\n\tbool (*key_load_private_raw)(struct dcrypt_private_key **key_r,\n\t\t\t\t     enum dcrypt_key_type key_type,\n\t\t\t\t     const ARRAY_TYPE(dcrypt_raw_key) *keys,\n\t\t\t\t     const char **error_r);\n\tbool (*key_load_public_raw)(struct dcrypt_public_key **key_r,\n\t\t\t\t    enum dcrypt_key_type key_type,\n\t\t\t\t    const ARRAY_TYPE(dcrypt_raw_key) *keys,\n\t\t\t\t    const char **error_r);\n\tbool (*key_get_curve_public)(struct dcrypt_public_key *key,\n\t\t\t\t     const char **curve_r, const char **error_r);\n\tconst char *(*key_get_id_public)(struct dcrypt_public_key *key);\n\tconst char *(*key_get_id_private)(struct dcrypt_private_key *key);\n\tvoid (*key_set_id_public)(struct dcrypt_public_key *key, const char *id);\n\tvoid (*key_set_id_private)(struct dcrypt_private_key *key, const char *id);\n\tenum dcrypt_key_usage (*key_get_usage_public)(struct dcrypt_public_key *key);\n\tenum dcrypt_key_usage (*key_get_usage_private)(struct dcrypt_private_key *key);\n\tvoid (*key_set_usage_public)(struct dcrypt_public_key *key,\n\t\t\t\t     enum dcrypt_key_usage usage);\n\tvoid (*key_set_usage_private)(struct dcrypt_private_key *key,\n\t\t\t\t      enum dcrypt_key_usage usage);\n\tbool (*sign)(struct dcrypt_private_key *key, const char *algorithm,\n\t\t     enum dcrypt_signature_format format,\n\t\t     const void *data, size_t data_len, buffer_t *signature_r,\n\t\t     enum dcrypt_padding padding, const char **error_r);\n\tbool (*verify)(struct dcrypt_public_key *key, const char *algorithm,\n\t\t       enum dcrypt_signature_format format,\n\t\t       const void *data, size_t data_len,\n\t\t       const unsigned char *signature, size_t signature_len,\n\t\t       bool *valid_r, enum dcrypt_padding padding,\n\t\t       const char **error_r);\n\tbool (*ecdh_derive_secret)(struct dcrypt_private_key *priv_key,\n\t\t\t\t   struct dcrypt_public_key *pub_key,\n\t\t\t\t   buffer_t *shared_secret, const char **error_r);\n};\n\nvoid dcrypt_set_vfs(struct dcrypt_vfs *vfs);\n\nvoid dcrypt_openssl_init(struct module *module ATTR_UNUSED);\nvoid dcrypt_gnutls_init(struct module *module ATTR_UNUSED);\nvoid dcrypt_openssl_deinit(void);\nvoid dcrypt_gnutls_deinit(void);\n\nint parse_jwk_key(const char *key_data, struct json_tree **tree_r,\n\t\t  const char **error_r);\n\n#endif\n"}}, "reports": [{"events": [{"location": {"col": 10, "file": 1, "line": 4}, "message": "\"array.h\" (fixit)"}, {"location": {"col": 1, "file": 1, "line": 4}, "message": "#includes are not sorted properly"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/src/lib-dcrypt/dcrypt-openssl.c", "reportHash": "9ab238a7a3488933fbfbddb205bec153", "checkerName": "llvm-include-order", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 26, "file": 1, "line": 219}, "message": "{ (fixit)"}, {"location": {"col": 11, "file": 1, "line": 219}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/src/lib-dcrypt/dcrypt-openssl.c", "reportHash": "36211a6c5fbf2d742d0179afab27805a", "checkerName": "google-readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 22, "file": 1, "line": 220}, "message": "{ (fixit)"}, {"location": {"col": 7, "file": 1, "line": 220}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/src/lib-dcrypt/dcrypt-openssl.c", "reportHash": "54af57e0857aa335c240043da77d5575", "checkerName": "google-readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 60, "file": 1, "line": 241}, "message": "{ (fixit)"}, {"location": {"col": 38, "file": 1, "line": 241}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/src/lib-dcrypt/dcrypt-openssl.c", "reportHash": "fdf924ab2124c0fe9a99e33f78183ea7", "checkerName": "google-readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 27, "file": 2, "line": 92}, "message": "expanded from macro 'p_new'"}, {"location": {"col": 41, "file": 3, "line": 25}, "message": "expanded from macro 'MALLOC_MULTIPLY'"}, {"location": {"col": 8, "file": 1, "line": 278}, "message": "suspicious usage of 'sizeof(K)'; did you mean 'K'?"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/src/lib-dcrypt/dcrypt-openssl.c", "reportHash": "0f1d95aa49ed3de94075ab7f37125823", "checkerName": "misc-sizeof-expression", "reviewStatus": null, "severity": "HIGH"}, {"events": [{"location": {"col": 27, "file": 2, "line": 92}, "message": "expanded from macro 'p_new'"}, {"location": {"col": 30, "file": 3, "line": 25}, "message": "expanded from macro 'MALLOC_MULTIPLY'"}, {"location": {"col": 8, "file": 1, "line": 278}, "message": "suspicious usage of 'sizeof(sizeof(...))'"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/src/lib-dcrypt/dcrypt-openssl.c", "reportHash": "2f4108fb6ddfb1c07c19c775e99d405e", "checkerName": "misc-sizeof-expression", "reviewStatus": null, "severity": "HIGH"}, {"events": [{"location": {"col": 34, "file": 1, "line": 292}, "message": "{ (fixit)"}, {"location": {"col": 26, "file": 1, "line": 292}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/src/lib-dcrypt/dcrypt-openssl.c", "reportHash": "3a68d2a3d9f6216039427d5ba59cea41", "checkerName": "google-readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 31, "file": 1, "line": 302}, "message": "{ (fixit)"}, {"location": {"col": 23, "file": 1, "line": 302}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/src/lib-dcrypt/dcrypt-openssl.c", "reportHash": "e85cfd7d802a41e087aff0edee21c680", "checkerName": "google-readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 29, "file": 1, "line": 313}, "message": "{ (fixit)"}, {"location": {"col": 21, "file": 1, "line": 313}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/src/lib-dcrypt/dcrypt-openssl.c", "reportHash": "c0e3d7e23197d02d0d7ad4c6811a563a", "checkerName": "google-readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 30, "file": 1, "line": 324}, "message": "{ (fixit)"}, {"location": {"col": 22, "file": 1, "line": 324}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/src/lib-dcrypt/dcrypt-openssl.c", "reportHash": "2c99ece81dda3ed527b93508984b9324", "checkerName": "google-readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 29, "file": 1, "line": 326}, "message": "{ (fixit)"}, {"location": {"col": 21, "file": 1, "line": 326}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/src/lib-dcrypt/dcrypt-openssl.c", "reportHash": "40e383631b2c6e42a3299882d68fa9f8", "checkerName": "hicpp-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 30, "file": 1, "line": 346}, "message": "{ (fixit)"}, {"location": {"col": 22, "file": 1, "line": 346}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/src/lib-dcrypt/dcrypt-openssl.c", "reportHash": "38d4ebdcb5c0decc44f8ac1806d7bc51", "checkerName": "google-readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 29, "file": 1, "line": 357}, "message": "{ (fixit)"}, {"location": {"col": 21, "file": 1, "line": 357}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/src/lib-dcrypt/dcrypt-openssl.c", "reportHash": "a27dd871ab15285e802761798a6ac803", "checkerName": "google-readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 31, "file": 1, "line": 368}, "message": "{ (fixit)"}, {"location": {"col": 23, "file": 1, "line": 368}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/src/lib-dcrypt/dcrypt-openssl.c", "reportHash": "86d5e57f02f2db004457377a51a7c0ef", "checkerName": "google-readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 31, "file": 1, "line": 381}, "message": "{ (fixit)"}, {"location": {"col": 23, "file": 1, "line": 381}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/src/lib-dcrypt/dcrypt-openssl.c", "reportHash": "1e203e913bdad33cfc4851f53c288fb6", "checkerName": "google-readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 31, "file": 1, "line": 392}, "message": "{ (fixit)"}, {"location": {"col": 23, "file": 1, "line": 392}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/src/lib-dcrypt/dcrypt-openssl.c", "reportHash": "8b57ae09da5171b039bcdb16173ab1c7", "checkerName": "readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 31, "file": 1, "line": 405}, "message": "{ (fixit)"}, {"location": {"col": 23, "file": 1, "line": 405}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/src/lib-dcrypt/dcrypt-openssl.c", "reportHash": "c4c7cffabd6e0cdf0636e45c0ebcc164", "checkerName": "google-readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 55, "file": 1, "line": 441}, "message": "{ (fixit)"}, {"location": {"col": 47, "file": 1, "line": 441}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/src/lib-dcrypt/dcrypt-openssl.c", "reportHash": "d89a1c016979e329914958730d992b43", "checkerName": "google-readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 22, "file": 1, "line": 446}, "message": "{ (fixit)"}, {"location": {"col": 14, "file": 1, "line": 446}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/src/lib-dcrypt/dcrypt-openssl.c", "reportHash": "a113e73fe3722cae851100863f038739", "checkerName": "google-readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 22, "file": 1, "line": 455}, "message": "{ (fixit)"}, {"location": {"col": 14, "file": 1, "line": 455}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/src/lib-dcrypt/dcrypt-openssl.c", "reportHash": "a113e73fe3722cae851100863f038739", "checkerName": "google-readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 62, "file": 1, "line": 486}, "message": "{ (fixit)"}, {"location": {"col": 47, "file": 1, "line": 486}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/src/lib-dcrypt/dcrypt-openssl.c", "reportHash": "e6184485e282dab754240a93a1bf7171", "checkerName": "google-readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 22, "file": 1, "line": 526}, "message": "{ (fixit)"}, {"location": {"col": 14, "file": 1, "line": 526}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/src/lib-dcrypt/dcrypt-openssl.c", "reportHash": "cb121dd1d82ebb36b2d3f1d470a3baec", "checkerName": "google-readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 22, "file": 1, "line": 543}, "message": "{ (fixit)"}, {"location": {"col": 14, "file": 1, "line": 543}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/src/lib-dcrypt/dcrypt-openssl.c", "reportHash": "822f8ba271a467584462a3a3fa3fb60c", "checkerName": "google-readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 26, "file": 1, "line": 545}, "message": "{ (fixit)"}, {"location": {"col": 18, "file": 1, "line": 545}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/src/lib-dcrypt/dcrypt-openssl.c", "reportHash": "7d6be9f13154fd37d269fef40a518d69", "checkerName": "google-readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 27, "file": 2, "line": 92}, "message": "expanded from macro 'p_new'"}, {"location": {"col": 41, "file": 3, "line": 25}, "message": "expanded from macro 'MALLOC_MULTIPLY'"}, {"location": {"col": 8, "file": 1, "line": 572}, "message": "suspicious usage of 'sizeof(K)'; did you mean 'K'?"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/src/lib-dcrypt/dcrypt-openssl.c", "reportHash": "9e5bf682a3afce4802fb7e66a9dff897", "checkerName": "misc-sizeof-expression", "reviewStatus": null, "severity": "HIGH"}, {"events": [{"location": {"col": 27, "file": 2, "line": 92}, "message": "expanded from macro 'p_new'"}, {"location": {"col": 30, "file": 3, "line": 25}, "message": "expanded from macro 'MALLOC_MULTIPLY'"}, {"location": {"col": 8, "file": 1, "line": 572}, "message": "suspicious usage of 'sizeof(sizeof(...))'"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/src/lib-dcrypt/dcrypt-openssl.c", "reportHash": "c8ffc669a121b938eda889115887d05e", "checkerName": "misc-sizeof-expression", "reviewStatus": null, "severity": "HIGH"}, {"events": [{"location": {"col": 31, "file": 1, "line": 592}, "message": "{ (fixit)"}, {"location": {"col": 23, "file": 1, "line": 592}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/src/lib-dcrypt/dcrypt-openssl.c", "reportHash": "385c978d34a3e9b9cea29ae5b5909f08", "checkerName": "readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 31, "file": 1, "line": 603}, "message": "{ (fixit)"}, {"location": {"col": 23, "file": 1, "line": 603}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/src/lib-dcrypt/dcrypt-openssl.c", "reportHash": "a270ba210ab1f72ee0b9f81335b76b40", "checkerName": "google-readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 31, "file": 1, "line": 632}, "message": "{ (fixit)"}, {"location": {"col": 23, "file": 1, "line": 632}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/src/lib-dcrypt/dcrypt-openssl.c", "reportHash": "960f2a5a7b16caf219283304db0bd372", "checkerName": "google-readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 22, "file": 1, "line": 636}, "message": "{ (fixit)"}, {"location": {"col": 14, "file": 1, "line": 636}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/src/lib-dcrypt/dcrypt-openssl.c", "reportHash": "a113e73fe3722cae851100863f038739", "checkerName": "google-readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 22, "file": 1, "line": 649}, "message": "{ (fixit)"}, {"location": {"col": 14, "file": 1, "line": 649}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/src/lib-dcrypt/dcrypt-openssl.c", "reportHash": "a113e73fe3722cae851100863f038739", "checkerName": "google-readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 22, "file": 1, "line": 664}, "message": "{ (fixit)"}, {"location": {"col": 14, "file": 1, "line": 664}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/src/lib-dcrypt/dcrypt-openssl.c", "reportHash": "cb121dd1d82ebb36b2d3f1d470a3baec", "checkerName": "google-readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 14, "file": 1, "line": 666}, "message": "{ (fixit)"}, {"location": {"col": 6, "file": 1, "line": 666}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/src/lib-dcrypt/dcrypt-openssl.c", "reportHash": "fbcb1af723f80350be6404b0c8b02a5d", "checkerName": "google-readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 33, "file": 4, "line": 1379}, "message": "expanded from macro 'EVP_PKEY_CTX_set_ec_paramgen_curve_nid'"}, {"location": {"col": 42, "file": 5, "line": 1258}, "message": "expanded from macro 'EVP_PKEY_OP_PARAMGEN'"}, {"location": {"col": 6, "file": 1, "line": 682}, "message": "use of a signed integer operand with a binary bitwise operator"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/src/lib-dcrypt/dcrypt-openssl.c", "reportHash": "8f93362edcc1c78460456d2500addbd6", "checkerName": "hicpp-signed-bitwise", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 32, "file": 6, "line": 122}, "message": "expanded from macro 'EVP_PKEY_CTX_set_rsa_keygen_bits'"}, {"location": {"col": 43, "file": 5, "line": 1259}, "message": "expanded from macro 'EVP_PKEY_OP_KEYGEN'"}, {"location": {"col": 6, "file": 1, "line": 721}, "message": "use of a signed integer operand with a binary bitwise operator"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/src/lib-dcrypt/dcrypt-openssl.c", "reportHash": "dca6a4029a8fe2d561c3563a346cab22", "checkerName": "hicpp-signed-bitwise", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 29, "file": 1, "line": 774}, "message": "{ (fixit)"}, {"location": {"col": 21, "file": 1, "line": 774}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/src/lib-dcrypt/dcrypt-openssl.c", "reportHash": "d5cbacda749920cbb975457a0badce0c", "checkerName": "google-readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 54, "file": 1, "line": 794}, "message": "{ (fixit)"}, {"location": {"col": 46, "file": 1, "line": 794}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/src/lib-dcrypt/dcrypt-openssl.c", "reportHash": "a7fb84b7aa6a14addb352b3bf335a5a8", "checkerName": "readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 14, "file": 1, "line": 796}, "message": "{ (fixit)"}, {"location": {"col": 6, "file": 1, "line": 796}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/src/lib-dcrypt/dcrypt-openssl.c", "reportHash": "fbcb1af723f80350be6404b0c8b02a5d", "checkerName": "google-readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 2, "file": 1, "line": 792}, "message": "did you mean this line to be inside this 'if'"}, {"location": {"col": 2, "file": 1, "line": 798}, "message": "misleading indentation: statement is indented too deeply"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/src/lib-dcrypt/dcrypt-openssl.c", "reportHash": "4abad303a652357cbda846241298e3e3", "checkerName": "readability-misleading-indentation", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 38, "file": 7, "line": 246}, "message": "expanded from macro 'i_zero'"}, {"location": {"col": 2, "file": 1, "line": 815}, "message": "suspicious usage of 'sizeof(A*)'; pointer to aggregate"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/src/lib-dcrypt/dcrypt-openssl.c", "reportHash": "55ee5320bfa290cbb3470ac6e26a257c", "checkerName": "misc-sizeof-expression", "reviewStatus": null, "severity": "HIGH"}, {"events": [{"location": {"col": 68, "file": 1, "line": 843}, "message": "{ (fixit)"}, {"location": {"col": 60, "file": 1, "line": 843}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/src/lib-dcrypt/dcrypt-openssl.c", "reportHash": "ac1d9b7f18920d301a4393911a4caa0b", "checkerName": "readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 38, "file": 7, "line": 246}, "message": "expanded from macro 'i_zero'"}, {"location": {"col": 2, "file": 1, "line": 847}, "message": "suspicious usage of 'sizeof(A*)'; pointer to aggregate"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/src/lib-dcrypt/dcrypt-openssl.c", "reportHash": "8c6a59e2d2382e280344fe548f56c646", "checkerName": "misc-sizeof-expression", "reviewStatus": null, "severity": "HIGH"}, {"events": [{"location": {"col": 23, "file": 1, "line": 896}, "message": "{ (fixit)"}, {"location": {"col": 15, "file": 1, "line": 896}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/src/lib-dcrypt/dcrypt-openssl.c", "reportHash": "ed59358e081dfb7fb61024a6d60ce1f6", "checkerName": "google-readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 28, "file": 8, "line": 8}, "message": "expanded from macro 'i_new'"}, {"location": {"col": 27, "file": 2, "line": 92}, "message": "expanded from macro 'p_new'"}, {"location": {"col": 41, "file": 3, "line": 25}, "message": "expanded from macro 'MALLOC_MULTIPLY'"}, {"location": {"col": 19, "file": 1, "line": 912}, "message": "suspicious usage of 'sizeof(K)'; did you mean 'K'?"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/src/lib-dcrypt/dcrypt-openssl.c", "reportHash": "c32bf9042f79deecf366d76411b376f8", "checkerName": "misc-sizeof-expression", "reviewStatus": null, "severity": "HIGH"}, {"events": [{"location": {"col": 28, "file": 8, "line": 8}, "message": "expanded from macro 'i_new'"}, {"location": {"col": 27, "file": 2, "line": 92}, "message": "expanded from macro 'p_new'"}, {"location": {"col": 30, "file": 3, "line": 25}, "message": "expanded from macro 'MALLOC_MULTIPLY'"}, {"location": {"col": 19, "file": 1, "line": 912}, "message": "suspicious usage of 'sizeof(sizeof(...))'"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/src/lib-dcrypt/dcrypt-openssl.c", "reportHash": "e05ecf82630093cea3b6577dc3208f77", "checkerName": "misc-sizeof-expression", "reviewStatus": null, "severity": "HIGH"}, {"events": [{"location": {"col": 5, "file": 1, "line": 919}, "message": "do not use 'else' after 'return'"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/src/lib-dcrypt/dcrypt-openssl.c", "reportHash": "0c7a3ada65d8b894313d6f92690f9943", "checkerName": "readability-else-after-return", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 28, "file": 8, "line": 8}, "message": "expanded from macro 'i_new'"}, {"location": {"col": 27, "file": 2, "line": 92}, "message": "expanded from macro 'p_new'"}, {"location": {"col": 41, "file": 3, "line": 25}, "message": "expanded from macro 'MALLOC_MULTIPLY'"}, {"location": {"col": 19, "file": 1, "line": 930}, "message": "suspicious usage of 'sizeof(K)'; did you mean 'K'?"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/src/lib-dcrypt/dcrypt-openssl.c", "reportHash": "c32bf9042f79deecf366d76411b376f8", "checkerName": "misc-sizeof-expression", "reviewStatus": null, "severity": "HIGH"}, {"events": [{"location": {"col": 28, "file": 8, "line": 8}, "message": "expanded from macro 'i_new'"}, {"location": {"col": 27, "file": 2, "line": 92}, "message": "expanded from macro 'p_new'"}, {"location": {"col": 30, "file": 3, "line": 25}, "message": "expanded from macro 'MALLOC_MULTIPLY'"}, {"location": {"col": 19, "file": 1, "line": 930}, "message": "suspicious usage of 'sizeof(sizeof(...))'"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/src/lib-dcrypt/dcrypt-openssl.c", "reportHash": "e05ecf82630093cea3b6577dc3208f77", "checkerName": "misc-sizeof-expression", "reviewStatus": null, "severity": "HIGH"}, {"events": [{"location": {"col": 5, "file": 1, "line": 937}, "message": "do not use 'else' after 'return'"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/src/lib-dcrypt/dcrypt-openssl.c", "reportHash": "0c7a3ada65d8b894313d6f92690f9943", "checkerName": "readability-else-after-return", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 31, "file": 1, "line": 976}, "message": "{ (fixit)"}, {"location": {"col": 23, "file": 1, "line": 976}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/src/lib-dcrypt/dcrypt-openssl.c", "reportHash": "b7ddfb17d2b12ddb74ab64432bd3bbd3", "checkerName": "google-readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 72, "file": 1, "line": 999}, "message": "{ (fixit)"}, {"location": {"col": 29, "file": 1, "line": 999}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/src/lib-dcrypt/dcrypt-openssl.c", "reportHash": "fa04ba39aaceb7577e4b0c22466878f4", "checkerName": "google-readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 28, "file": 1, "line": 1103}, "message": "{ (fixit)"}, {"location": {"col": 20, "file": 1, "line": 1103}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/src/lib-dcrypt/dcrypt-openssl.c", "reportHash": "17b5b4a1d764f8455438651548e24489", "checkerName": "hicpp-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 28, "file": 8, "line": 8}, "message": "expanded from macro 'i_new'"}, {"location": {"col": 27, "file": 2, "line": 92}, "message": "expanded from macro 'p_new'"}, {"location": {"col": 41, "file": 3, "line": 25}, "message": "expanded from macro 'MALLOC_MULTIPLY'"}, {"location": {"col": 12, "file": 1, "line": 1153}, "message": "suspicious usage of 'sizeof(K)'; did you mean 'K'?"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/src/lib-dcrypt/dcrypt-openssl.c", "reportHash": "44658063e7230a517270c1368c5b16aa", "checkerName": "misc-sizeof-expression", "reviewStatus": null, "severity": "HIGH"}, {"events": [{"location": {"col": 28, "file": 8, "line": 8}, "message": "expanded from macro 'i_new'"}, {"location": {"col": 27, "file": 2, "line": 92}, "message": "expanded from macro 'p_new'"}, {"location": {"col": 30, "file": 3, "line": 25}, "message": "expanded from macro 'MALLOC_MULTIPLY'"}, {"location": {"col": 12, "file": 1, "line": 1153}, "message": "suspicious usage of 'sizeof(sizeof(...))'"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/src/lib-dcrypt/dcrypt-openssl.c", "reportHash": "14ad0ad4280931796dec53ed513ef301", "checkerName": "misc-sizeof-expression", "reviewStatus": null, "severity": "HIGH"}, {"events": [{"location": {"col": 31, "file": 1, "line": 1252}, "message": "{ (fixit)"}, {"location": {"col": 23, "file": 1, "line": 1252}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/src/lib-dcrypt/dcrypt-openssl.c", "reportHash": "310c8e2269c9ce6a24f66f0c5d2e201e", "checkerName": "google-readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 74, "file": 1, "line": 1305}, "message": "{ (fixit)"}, {"location": {"col": 45, "file": 1, "line": 1305}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/src/lib-dcrypt/dcrypt-openssl.c", "reportHash": "9c5216cfd45c5004337ffce63887bed8", "checkerName": "google-readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 70, "file": 1, "line": 1310}, "message": "{ (fixit)"}, {"location": {"col": 41, "file": 1, "line": 1310}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/src/lib-dcrypt/dcrypt-openssl.c", "reportHash": "a0563b1d02bed330ddab14e8beb10968", "checkerName": "readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 28, "file": 8, "line": 8}, "message": "expanded from macro 'i_new'"}, {"location": {"col": 27, "file": 2, "line": 92}, "message": "expanded from macro 'p_new'"}, {"location": {"col": 41, "file": 3, "line": 25}, "message": "expanded from macro 'MALLOC_MULTIPLY'"}, {"location": {"col": 12, "file": 1, "line": 1369}, "message": "suspicious usage of 'sizeof(K)'; did you mean 'K'?"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/src/lib-dcrypt/dcrypt-openssl.c", "reportHash": "44658063e7230a517270c1368c5b16aa", "checkerName": "misc-sizeof-expression", "reviewStatus": null, "severity": "HIGH"}, {"events": [{"location": {"col": 28, "file": 8, "line": 8}, "message": "expanded from macro 'i_new'"}, {"location": {"col": 27, "file": 2, "line": 92}, "message": "expanded from macro 'p_new'"}, {"location": {"col": 30, "file": 3, "line": 25}, "message": "expanded from macro 'MALLOC_MULTIPLY'"}, {"location": {"col": 12, "file": 1, "line": 1369}, "message": "suspicious usage of 'sizeof(sizeof(...))'"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/src/lib-dcrypt/dcrypt-openssl.c", "reportHash": "14ad0ad4280931796dec53ed513ef301", "checkerName": "misc-sizeof-expression", "reviewStatus": null, "severity": "HIGH"}, {"events": [{"location": {"col": 34, "file": 1, "line": 1397}, "message": "{ (fixit)"}, {"location": {"col": 19, "file": 1, "line": 1397}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/src/lib-dcrypt/dcrypt-openssl.c", "reportHash": "012e0c31505d9cb3df52d07b76d99973", "checkerName": "google-readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 28, "file": 8, "line": 8}, "message": "expanded from macro 'i_new'"}, {"location": {"col": 27, "file": 2, "line": 92}, "message": "expanded from macro 'p_new'"}, {"location": {"col": 41, "file": 3, "line": 25}, "message": "expanded from macro 'MALLOC_MULTIPLY'"}, {"location": {"col": 13, "file": 1, "line": 1413}, "message": "suspicious usage of 'sizeof(K)'; did you mean 'K'?"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/src/lib-dcrypt/dcrypt-openssl.c", "reportHash": "6670955dd9300e2de9fdcf0c8f219d88", "checkerName": "misc-sizeof-expression", "reviewStatus": null, "severity": "HIGH"}, {"events": [{"location": {"col": 28, "file": 8, "line": 8}, "message": "expanded from macro 'i_new'"}, {"location": {"col": 27, "file": 2, "line": 92}, "message": "expanded from macro 'p_new'"}, {"location": {"col": 30, "file": 3, "line": 25}, "message": "expanded from macro 'MALLOC_MULTIPLY'"}, {"location": {"col": 13, "file": 1, "line": 1413}, "message": "suspicious usage of 'sizeof(sizeof(...))'"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/src/lib-dcrypt/dcrypt-openssl.c", "reportHash": "627b83484930b0f06a1dda86f610317f", "checkerName": "misc-sizeof-expression", "reviewStatus": null, "severity": "HIGH"}, {"events": [{"location": {"col": 38, "file": 1, "line": 1465}, "message": "{ (fixit)"}, {"location": {"col": 30, "file": 1, "line": 1465}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/src/lib-dcrypt/dcrypt-openssl.c", "reportHash": "87ef8362d3376d729b42374157dcaece", "checkerName": "google-readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 38, "file": 1, "line": 1467}, "message": "{ (fixit)"}, {"location": {"col": 30, "file": 1, "line": 1467}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/src/lib-dcrypt/dcrypt-openssl.c", "reportHash": "c7a004f1b1e7bc1cb4bb6d7994a2db97", "checkerName": "google-readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 49, "file": 1, "line": 1476}, "message": "{ (fixit)"}, {"location": {"col": 41, "file": 1, "line": 1476}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/src/lib-dcrypt/dcrypt-openssl.c", "reportHash": "0f560c6abe86807f9ca48b3fa3d4b586", "checkerName": "google-readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 59, "file": 1, "line": 1477}, "message": "{ (fixit)"}, {"location": {"col": 44, "file": 1, "line": 1477}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/src/lib-dcrypt/dcrypt-openssl.c", "reportHash": "daa843485ec2fc5c9b2d95fd744c43d2", "checkerName": "readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 49, "file": 1, "line": 1485}, "message": "{ (fixit)"}, {"location": {"col": 41, "file": 1, "line": 1485}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/src/lib-dcrypt/dcrypt-openssl.c", "reportHash": "7a0900573e251d646c8a70309954f81f", "checkerName": "readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 40, "file": 1, "line": 1486}, "message": "{ (fixit)"}, {"location": {"col": 25, "file": 1, "line": 1486}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/src/lib-dcrypt/dcrypt-openssl.c", "reportHash": "4cb47bee4034c7c0d04da5d36a7fc413", "checkerName": "readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 33, "file": 1, "line": 1728}, "message": "{ (fixit)"}, {"location": {"col": 18, "file": 1, "line": 1728}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/src/lib-dcrypt/dcrypt-openssl.c", "reportHash": "573d20a064360421164e085680d3b46c", "checkerName": "readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 33, "file": 1, "line": 1737}, "message": "{ (fixit)"}, {"location": {"col": 18, "file": 1, "line": 1737}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/src/lib-dcrypt/dcrypt-openssl.c", "reportHash": "573d20a064360421164e085680d3b46c", "checkerName": "readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 33, "file": 1, "line": 1745}, "message": "{ (fixit)"}, {"location": {"col": 18, "file": 1, "line": 1745}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/src/lib-dcrypt/dcrypt-openssl.c", "reportHash": "573d20a064360421164e085680d3b46c", "checkerName": "readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 5, "file": 1, "line": 1779}, "message": "do not use 'else' after 'return'"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/src/lib-dcrypt/dcrypt-openssl.c", "reportHash": "6af9b85ba25896be2e9fdfa3b7b1a12b", "checkerName": "readability-else-after-return", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 19, "file": 1, "line": 1839}, "message": "{ (fixit)"}, {"location": {"col": 11, "file": 1, "line": 1839}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/src/lib-dcrypt/dcrypt-openssl.c", "reportHash": "9e25f097b9a39283153ecccdecee49da", "checkerName": "google-readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 28, "file": 8, "line": 8}, "message": "expanded from macro 'i_new'"}, {"location": {"col": 27, "file": 2, "line": 92}, "message": "expanded from macro 'p_new'"}, {"location": {"col": 41, "file": 3, "line": 25}, "message": "expanded from macro 'MALLOC_MULTIPLY'"}, {"location": {"col": 12, "file": 1, "line": 1842}, "message": "suspicious usage of 'sizeof(K)'; did you mean 'K'?"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/src/lib-dcrypt/dcrypt-openssl.c", "reportHash": "44658063e7230a517270c1368c5b16aa", "checkerName": "misc-sizeof-expression", "reviewStatus": null, "severity": "HIGH"}, {"events": [{"location": {"col": 28, "file": 8, "line": 8}, "message": "expanded from macro 'i_new'"}, {"location": {"col": 27, "file": 2, "line": 92}, "message": "expanded from macro 'p_new'"}, {"location": {"col": 30, "file": 3, "line": 25}, "message": "expanded from macro 'MALLOC_MULTIPLY'"}, {"location": {"col": 12, "file": 1, "line": 1842}, "message": "suspicious usage of 'sizeof(sizeof(...))'"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/src/lib-dcrypt/dcrypt-openssl.c", "reportHash": "14ad0ad4280931796dec53ed513ef301", "checkerName": "misc-sizeof-expression", "reviewStatus": null, "severity": "HIGH"}, {"events": [{"location": {"col": 71, "file": 1, "line": 1846}, "message": "{ (fixit)"}, {"location": {"col": 56, "file": 1, "line": 1846}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/src/lib-dcrypt/dcrypt-openssl.c", "reportHash": "a1ac3406a79d09ba4fb902b2d4be6db8", "checkerName": "readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 71, "file": 1, "line": 1849}, "message": "{ (fixit)"}, {"location": {"col": 56, "file": 1, "line": 1849}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/src/lib-dcrypt/dcrypt-openssl.c", "reportHash": "41fe0631751f49995e59885eb9eeaa1a", "checkerName": "hicpp-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 19, "file": 1, "line": 1897}, "message": "{ (fixit)"}, {"location": {"col": 11, "file": 1, "line": 1897}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/src/lib-dcrypt/dcrypt-openssl.c", "reportHash": "1e67031d78eaec01ccb6a9c3c858d6d3", "checkerName": "readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 28, "file": 8, "line": 8}, "message": "expanded from macro 'i_new'"}, {"location": {"col": 27, "file": 2, "line": 92}, "message": "expanded from macro 'p_new'"}, {"location": {"col": 41, "file": 3, "line": 25}, "message": "expanded from macro 'MALLOC_MULTIPLY'"}, {"location": {"col": 12, "file": 1, "line": 1900}, "message": "suspicious usage of 'sizeof(K)'; did you mean 'K'?"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/src/lib-dcrypt/dcrypt-openssl.c", "reportHash": "27aa250dc0a95aae9df902c31e50aefe", "checkerName": "misc-sizeof-expression", "reviewStatus": null, "severity": "HIGH"}, {"events": [{"location": {"col": 28, "file": 8, "line": 8}, "message": "expanded from macro 'i_new'"}, {"location": {"col": 27, "file": 2, "line": 92}, "message": "expanded from macro 'p_new'"}, {"location": {"col": 30, "file": 3, "line": 25}, "message": "expanded from macro 'MALLOC_MULTIPLY'"}, {"location": {"col": 12, "file": 1, "line": 1900}, "message": "suspicious usage of 'sizeof(sizeof(...))'"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/src/lib-dcrypt/dcrypt-openssl.c", "reportHash": "1a5e5e1950653493058ab3b7abdfbfb6", "checkerName": "misc-sizeof-expression", "reviewStatus": null, "severity": "HIGH"}, {"events": [{"location": {"col": 71, "file": 1, "line": 1904}, "message": "{ (fixit)"}, {"location": {"col": 56, "file": 1, "line": 1904}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/src/lib-dcrypt/dcrypt-openssl.c", "reportHash": "dac3510ebe82f39feb54929271540eb1", "checkerName": "hicpp-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 71, "file": 1, "line": 1907}, "message": "{ (fixit)"}, {"location": {"col": 56, "file": 1, "line": 1907}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/src/lib-dcrypt/dcrypt-openssl.c", "reportHash": "9c974dd5d243b1aca0d9943ec2ca4049", "checkerName": "readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 41, "file": 1, "line": 1921}, "message": "{ (fixit)"}, {"location": {"col": 33, "file": 1, "line": 1921}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/src/lib-dcrypt/dcrypt-openssl.c", "reportHash": "b71bb86a89df99f760f634895626762a", "checkerName": "readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 38, "file": 7, "line": 246}, "message": "expanded from macro 'i_zero'"}, {"location": {"col": 3, "file": 1, "line": 2075}, "message": "suspicious usage of 'sizeof(A*)'; pointer to aggregate"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/src/lib-dcrypt/dcrypt-openssl.c", "reportHash": "593e15e8a7bf9feba6942ab14d1ed694", "checkerName": "misc-sizeof-expression", "reviewStatus": null, "severity": "HIGH"}, {"events": [{"location": {"col": 28, "file": 8, "line": 8}, "message": "expanded from macro 'i_new'"}, {"location": {"col": 27, "file": 2, "line": 92}, "message": "expanded from macro 'p_new'"}, {"location": {"col": 41, "file": 3, "line": 25}, "message": "expanded from macro 'MALLOC_MULTIPLY'"}, {"location": {"col": 12, "file": 1, "line": 2084}, "message": "suspicious usage of 'sizeof(K)'; did you mean 'K'?"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/src/lib-dcrypt/dcrypt-openssl.c", "reportHash": "27aa250dc0a95aae9df902c31e50aefe", "checkerName": "misc-sizeof-expression", "reviewStatus": null, "severity": "HIGH"}, {"events": [{"location": {"col": 28, "file": 8, "line": 8}, "message": "expanded from macro 'i_new'"}, {"location": {"col": 27, "file": 2, "line": 92}, "message": "expanded from macro 'p_new'"}, {"location": {"col": 30, "file": 3, "line": 25}, "message": "expanded from macro 'MALLOC_MULTIPLY'"}, {"location": {"col": 12, "file": 1, "line": 2084}, "message": "suspicious usage of 'sizeof(sizeof(...))'"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/src/lib-dcrypt/dcrypt-openssl.c", "reportHash": "1a5e5e1950653493058ab3b7abdfbfb6", "checkerName": "misc-sizeof-expression", "reviewStatus": null, "severity": "HIGH"}, {"events": [{"location": {"col": 38, "file": 7, "line": 246}, "message": "expanded from macro 'i_zero'"}, {"location": {"col": 2, "file": 1, "line": 2117}, "message": "suspicious usage of 'sizeof(A*)'; pointer to aggregate"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/src/lib-dcrypt/dcrypt-openssl.c", "reportHash": "4404ba31c8ff4b0e3e136044ad00c5a0", "checkerName": "misc-sizeof-expression", "reviewStatus": null, "severity": "HIGH"}, {"events": [{"location": {"col": 28, "file": 8, "line": 8}, "message": "expanded from macro 'i_new'"}, {"location": {"col": 27, "file": 2, "line": 92}, "message": "expanded from macro 'p_new'"}, {"location": {"col": 41, "file": 3, "line": 25}, "message": "expanded from macro 'MALLOC_MULTIPLY'"}, {"location": {"col": 11, "file": 1, "line": 2126}, "message": "suspicious usage of 'sizeof(K)'; did you mean 'K'?"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/src/lib-dcrypt/dcrypt-openssl.c", "reportHash": "05330904a78ee30b94972ad40eaa62d7", "checkerName": "misc-sizeof-expression", "reviewStatus": null, "severity": "HIGH"}, {"events": [{"location": {"col": 28, "file": 8, "line": 8}, "message": "expanded from macro 'i_new'"}, {"location": {"col": 27, "file": 2, "line": 92}, "message": "expanded from macro 'p_new'"}, {"location": {"col": 30, "file": 3, "line": 25}, "message": "expanded from macro 'MALLOC_MULTIPLY'"}, {"location": {"col": 11, "file": 1, "line": 2126}, "message": "suspicious usage of 'sizeof(sizeof(...))'"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/src/lib-dcrypt/dcrypt-openssl.c", "reportHash": "a84471e885681300e65626b99c3a2021", "checkerName": "misc-sizeof-expression", "reviewStatus": null, "severity": "HIGH"}, {"events": [{"location": {"col": 62, "file": 9, "line": 26}, "message": "expanded from macro 'buffer_create_from_const_data'"}, {"location": {"col": 2, "file": 1, "line": 2177}, "message": "suspicious comparison of 'sizeof(expr)' to a constant"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/src/lib-dcrypt/dcrypt-openssl.c", "reportHash": "fef717acc58f4540bf1a87e69c1cde7f", "checkerName": "misc-sizeof-expression", "reviewStatus": null, "severity": "HIGH"}, {"events": [{"location": {"col": 71, "file": 1, "line": 2233}, "message": "{ (fixit)"}, {"location": {"col": 28, "file": 1, "line": 2233}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/src/lib-dcrypt/dcrypt-openssl.c", "reportHash": "f3313e7870a86b07b9e0256aecc2e2d5", "checkerName": "readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 22, "file": 1, "line": 2268}, "message": "{ (fixit)"}, {"location": {"col": 14, "file": 1, "line": 2268}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/src/lib-dcrypt/dcrypt-openssl.c", "reportHash": "fa52047e4db7e7fe427c105615694adc", "checkerName": "readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 30, "file": 1, "line": 2282}, "message": "{ (fixit)"}, {"location": {"col": 15, "file": 1, "line": 2282}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/src/lib-dcrypt/dcrypt-openssl.c", "reportHash": "c98bdc8bf876a7f1258134cd904b2eb1", "checkerName": "readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 54, "file": 1, "line": 2352}, "message": "{ (fixit)"}, {"location": {"col": 46, "file": 1, "line": 2352}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/src/lib-dcrypt/dcrypt-openssl.c", "reportHash": "0f3a1206f1ec39a4aace4ffd10bad224", "checkerName": "readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 26, "file": 1, "line": 2357}, "message": "{ (fixit)"}, {"location": {"col": 18, "file": 1, "line": 2357}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/src/lib-dcrypt/dcrypt-openssl.c", "reportHash": "a061ce8ad55a94d3af030a970cd3e50a", "checkerName": "readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 42, "file": 1, "line": 2401}, "message": "{ (fixit)"}, {"location": {"col": 34, "file": 1, "line": 2401}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/src/lib-dcrypt/dcrypt-openssl.c", "reportHash": "1544dc692b8919c88f2d101c27a130f2", "checkerName": "hicpp-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 46, "file": 1, "line": 2405}, "message": "{ (fixit)"}, {"location": {"col": 38, "file": 1, "line": 2405}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/src/lib-dcrypt/dcrypt-openssl.c", "reportHash": "508b82f9adcf7888d86003e46dc9a250", "checkerName": "readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 28, "file": 8, "line": 8}, "message": "expanded from macro 'i_new'"}, {"location": {"col": 27, "file": 2, "line": 92}, "message": "expanded from macro 'p_new'"}, {"location": {"col": 41, "file": 3, "line": 25}, "message": "expanded from macro 'MALLOC_MULTIPLY'"}, {"location": {"col": 11, "file": 1, "line": 2429}, "message": "suspicious usage of 'sizeof(K)'; did you mean 'K'?"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/src/lib-dcrypt/dcrypt-openssl.c", "reportHash": "f94dd642d1aab00e956b7689df8d398d", "checkerName": "misc-sizeof-expression", "reviewStatus": null, "severity": "HIGH"}, {"events": [{"location": {"col": 28, "file": 8, "line": 8}, "message": "expanded from macro 'i_new'"}, {"location": {"col": 27, "file": 2, "line": 92}, "message": "expanded from macro 'p_new'"}, {"location": {"col": 30, "file": 3, "line": 25}, "message": "expanded from macro 'MALLOC_MULTIPLY'"}, {"location": {"col": 11, "file": 1, "line": 2429}, "message": "suspicious usage of 'sizeof(sizeof(...))'"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/src/lib-dcrypt/dcrypt-openssl.c", "reportHash": "5360e5969b35bd3106d22ea79f5126a3", "checkerName": "misc-sizeof-expression", "reviewStatus": null, "severity": "HIGH"}, {"events": [{"location": {"col": 42, "file": 1, "line": 2456}, "message": "{ (fixit)"}, {"location": {"col": 34, "file": 1, "line": 2456}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/src/lib-dcrypt/dcrypt-openssl.c", "reportHash": "de5d20ae11c63feb893a1ecd1487c089", "checkerName": "readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 46, "file": 1, "line": 2459}, "message": "{ (fixit)"}, {"location": {"col": 38, "file": 1, "line": 2459}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/src/lib-dcrypt/dcrypt-openssl.c", "reportHash": "508b82f9adcf7888d86003e46dc9a250", "checkerName": "readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 29, "file": 1, "line": 2465}, "message": "{ (fixit)"}, {"location": {"col": 21, "file": 1, "line": 2465}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/src/lib-dcrypt/dcrypt-openssl.c", "reportHash": "e47cf8143c834f8cb84a0bbb0e9cd012", "checkerName": "readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 37, "file": 1, "line": 2469}, "message": "{ (fixit)"}, {"location": {"col": 29, "file": 1, "line": 2469}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/src/lib-dcrypt/dcrypt-openssl.c", "reportHash": "868cae61bad889d77065c781f9772d74", "checkerName": "readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 42, "file": 1, "line": 2491}, "message": "{ (fixit)"}, {"location": {"col": 20, "file": 1, "line": 2491}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/src/lib-dcrypt/dcrypt-openssl.c", "reportHash": "5b4189f324d36e59dcfa42e8de39b093", "checkerName": "readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 26, "file": 1, "line": 2499}, "message": "{ (fixit)"}, {"location": {"col": 18, "file": 1, "line": 2499}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/src/lib-dcrypt/dcrypt-openssl.c", "reportHash": "c186d8c575e552393976c9429d50fef9", "checkerName": "hicpp-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 28, "file": 8, "line": 8}, "message": "expanded from macro 'i_new'"}, {"location": {"col": 27, "file": 2, "line": 92}, "message": "expanded from macro 'p_new'"}, {"location": {"col": 41, "file": 3, "line": 25}, "message": "expanded from macro 'MALLOC_MULTIPLY'"}, {"location": {"col": 11, "file": 1, "line": 2502}, "message": "suspicious usage of 'sizeof(K)'; did you mean 'K'?"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/src/lib-dcrypt/dcrypt-openssl.c", "reportHash": "05330904a78ee30b94972ad40eaa62d7", "checkerName": "misc-sizeof-expression", "reviewStatus": null, "severity": "HIGH"}, {"events": [{"location": {"col": 28, "file": 8, "line": 8}, "message": "expanded from macro 'i_new'"}, {"location": {"col": 27, "file": 2, "line": 92}, "message": "expanded from macro 'p_new'"}, {"location": {"col": 30, "file": 3, "line": 25}, "message": "expanded from macro 'MALLOC_MULTIPLY'"}, {"location": {"col": 11, "file": 1, "line": 2502}, "message": "suspicious usage of 'sizeof(sizeof(...))'"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/src/lib-dcrypt/dcrypt-openssl.c", "reportHash": "a84471e885681300e65626b99c3a2021", "checkerName": "misc-sizeof-expression", "reviewStatus": null, "severity": "HIGH"}, {"events": [{"location": {"col": 52, "file": 1, "line": 2537}, "message": "{ (fixit)"}, {"location": {"col": 44, "file": 1, "line": 2537}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/src/lib-dcrypt/dcrypt-openssl.c", "reportHash": "8cf9a8f1f9ba66789da33bb4c281bd3f", "checkerName": "readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 30, "file": 1, "line": 2542}, "message": "{ (fixit)"}, {"location": {"col": 22, "file": 1, "line": 2542}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/src/lib-dcrypt/dcrypt-openssl.c", "reportHash": "54c7d138c5477405cd21526d651a04d6", "checkerName": "google-readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 38, "file": 1, "line": 2558}, "message": "{ (fixit)"}, {"location": {"col": 30, "file": 1, "line": 2558}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/src/lib-dcrypt/dcrypt-openssl.c", "reportHash": "215d46021a663c2f3f8303f98e402e63", "checkerName": "google-readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 52, "file": 1, "line": 2599}, "message": "{ (fixit)"}, {"location": {"col": 44, "file": 1, "line": 2599}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/src/lib-dcrypt/dcrypt-openssl.c", "reportHash": "1cdce201687bc8748b9c898de6c61456", "checkerName": "google-readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 30, "file": 1, "line": 2604}, "message": "{ (fixit)"}, {"location": {"col": 22, "file": 1, "line": 2604}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/src/lib-dcrypt/dcrypt-openssl.c", "reportHash": "8b9503af4ac04c56a4c7d15cb95e302a", "checkerName": "hicpp-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 53, "file": 1, "line": 2608}, "message": "{ (fixit)"}, {"location": {"col": 45, "file": 1, "line": 2608}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/src/lib-dcrypt/dcrypt-openssl.c", "reportHash": "ed31c772bd6ab9ccd2394283a04b4001", "checkerName": "google-readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 59, "file": 1, "line": 2610}, "message": "{ (fixit)"}, {"location": {"col": 51, "file": 1, "line": 2610}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/src/lib-dcrypt/dcrypt-openssl.c", "reportHash": "4ac2a291da6c0a86e7a0957c8383adde", "checkerName": "google-readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 42, "file": 1, "line": 2616}, "message": "{ (fixit)"}, {"location": {"col": 27, "file": 1, "line": 2616}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/src/lib-dcrypt/dcrypt-openssl.c", "reportHash": "cc8562d8c0a58cd1530a23b8be122d65", "checkerName": "google-readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 73, "file": 1, "line": 2620}, "message": "{ (fixit)"}, {"location": {"col": 58, "file": 1, "line": 2620}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/src/lib-dcrypt/dcrypt-openssl.c", "reportHash": "ab49dea2c7cc1d09d986d03238b45d3e", "checkerName": "google-readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 28, "file": 8, "line": 8}, "message": "expanded from macro 'i_new'"}, {"location": {"col": 27, "file": 2, "line": 92}, "message": "expanded from macro 'p_new'"}, {"location": {"col": 41, "file": 3, "line": 25}, "message": "expanded from macro 'MALLOC_MULTIPLY'"}, {"location": {"col": 15, "file": 1, "line": 2665}, "message": "suspicious usage of 'sizeof(K)'; did you mean 'K'?"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/src/lib-dcrypt/dcrypt-openssl.c", "reportHash": "57587607eb52921efadd33372581c8dc", "checkerName": "misc-sizeof-expression", "reviewStatus": null, "severity": "HIGH"}, {"events": [{"location": {"col": 28, "file": 8, "line": 8}, "message": "expanded from macro 'i_new'"}, {"location": {"col": 27, "file": 2, "line": 92}, "message": "expanded from macro 'p_new'"}, {"location": {"col": 30, "file": 3, "line": 25}, "message": "expanded from macro 'MALLOC_MULTIPLY'"}, {"location": {"col": 15, "file": 1, "line": 2665}, "message": "suspicious usage of 'sizeof(sizeof(...))'"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/src/lib-dcrypt/dcrypt-openssl.c", "reportHash": "4ff7b37062401a1823d348e6b6174a10", "checkerName": "misc-sizeof-expression", "reviewStatus": null, "severity": "HIGH"}, {"events": [{"location": {"col": 63, "file": 1, "line": 2701}, "message": "{ (fixit)"}, {"location": {"col": 48, "file": 1, "line": 2701}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/src/lib-dcrypt/dcrypt-openssl.c", "reportHash": "cd81244373bbd9b1c7570e85b2c1b563", "checkerName": "google-readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 67, "file": 1, "line": 2703}, "message": "{ (fixit)"}, {"location": {"col": 52, "file": 1, "line": 2703}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/src/lib-dcrypt/dcrypt-openssl.c", "reportHash": "950e99712b271318dee252b00fe79605", "checkerName": "google-readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 5, "file": 1, "line": 2728}, "message": "do not use 'else' after 'return'"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/src/lib-dcrypt/dcrypt-openssl.c", "reportHash": "f0570e0eb5d10242fa2d64733583c52e", "checkerName": "readability-else-after-return", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 68, "file": 1, "line": 2729}, "message": "{ (fixit)"}, {"location": {"col": 46, "file": 1, "line": 2729}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/src/lib-dcrypt/dcrypt-openssl.c", "reportHash": "c5196b643db40cdc8cacd9210e000f62", "checkerName": "google-readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 30, "file": 1, "line": 2731}, "message": "{ (fixit)"}, {"location": {"col": 8, "file": 1, "line": 2731}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/src/lib-dcrypt/dcrypt-openssl.c", "reportHash": "7819c582371a81bbcd6e130bbf99c0ec", "checkerName": "google-readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 68, "file": 1, "line": 2734}, "message": "{ (fixit)"}, {"location": {"col": 46, "file": 1, "line": 2734}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/src/lib-dcrypt/dcrypt-openssl.c", "reportHash": "c5196b643db40cdc8cacd9210e000f62", "checkerName": "google-readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 30, "file": 1, "line": 2736}, "message": "{ (fixit)"}, {"location": {"col": 8, "file": 1, "line": 2736}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/src/lib-dcrypt/dcrypt-openssl.c", "reportHash": "7819c582371a81bbcd6e130bbf99c0ec", "checkerName": "google-readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 5, "file": 1, "line": 2748}, "message": "do not use 'else' after 'return'"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/src/lib-dcrypt/dcrypt-openssl.c", "reportHash": "faca85fc2e05a4790f03e8ea881151c4", "checkerName": "readability-else-after-return", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 68, "file": 1, "line": 2776}, "message": "{ (fixit)"}, {"location": {"col": 39, "file": 1, "line": 2776}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/src/lib-dcrypt/dcrypt-openssl.c", "reportHash": "8d3f6f920ac96e191cd37425b24e0a1e", "checkerName": "google-readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 68, "file": 1, "line": 2795}, "message": "{ (fixit)"}, {"location": {"col": 39, "file": 1, "line": 2795}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/src/lib-dcrypt/dcrypt-openssl.c", "reportHash": "8d3f6f920ac96e191cd37425b24e0a1e", "checkerName": "google-readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 41, "file": 1, "line": 2807}, "message": "{ (fixit)"}, {"location": {"col": 26, "file": 1, "line": 2807}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/src/lib-dcrypt/dcrypt-openssl.c", "reportHash": "b3047713fd9daae33617ff1b6f07ab7d", "checkerName": "google-readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 31, "file": 1, "line": 2811}, "message": "{ (fixit)"}, {"location": {"col": 23, "file": 1, "line": 2811}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/src/lib-dcrypt/dcrypt-openssl.c", "reportHash": "316c18d306056438fa0b67dbea466da3", "checkerName": "hicpp-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 32, "file": 1, "line": 2812}, "message": "{ (fixit)"}, {"location": {"col": 24, "file": 1, "line": 2812}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/src/lib-dcrypt/dcrypt-openssl.c", "reportHash": "8668b41873368865926222f1708f9e8b", "checkerName": "hicpp-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 40, "file": 1, "line": 2813}, "message": "{ (fixit)"}, {"location": {"col": 32, "file": 1, "line": 2813}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/src/lib-dcrypt/dcrypt-openssl.c", "reportHash": "a663deaa6d3ed5d0f9747c1b347c867d", "checkerName": "hicpp-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 29, "file": 1, "line": 2818}, "message": "{ (fixit)"}, {"location": {"col": 21, "file": 1, "line": 2818}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/src/lib-dcrypt/dcrypt-openssl.c", "reportHash": "0dd554715a554219bee13b11711df18a", "checkerName": "hicpp-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 27, "file": 1, "line": 2842}, "message": "{ (fixit)"}, {"location": {"col": 19, "file": 1, "line": 2842}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/src/lib-dcrypt/dcrypt-openssl.c", "reportHash": "759497d78a9642fe81432b83223850b7", "checkerName": "google-readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 30, "file": 1, "line": 2846}, "message": "{ (fixit)"}, {"location": {"col": 22, "file": 1, "line": 2846}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/src/lib-dcrypt/dcrypt-openssl.c", "reportHash": "701471a62fc013b8e433c3037a290a5a", "checkerName": "hicpp-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 27, "file": 1, "line": 2856}, "message": "{ (fixit)"}, {"location": {"col": 19, "file": 1, "line": 2856}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/src/lib-dcrypt/dcrypt-openssl.c", "reportHash": "759497d78a9642fe81432b83223850b7", "checkerName": "google-readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 30, "file": 1, "line": 2860}, "message": "{ (fixit)"}, {"location": {"col": 22, "file": 1, "line": 2860}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/src/lib-dcrypt/dcrypt-openssl.c", "reportHash": "701471a62fc013b8e433c3037a290a5a", "checkerName": "hicpp-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 24, "file": 1, "line": 2881}, "message": "{ (fixit)"}, {"location": {"col": 16, "file": 1, "line": 2881}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/src/lib-dcrypt/dcrypt-openssl.c", "reportHash": "9f7cfd384f382a2bcbb81384b308633b", "checkerName": "google-readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 24, "file": 1, "line": 2911}, "message": "{ (fixit)"}, {"location": {"col": 16, "file": 1, "line": 2911}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/src/lib-dcrypt/dcrypt-openssl.c", "reportHash": "9f7cfd384f382a2bcbb81384b308633b", "checkerName": "google-readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 26, "file": 1, "line": 2954}, "message": "{ (fixit)"}, {"location": {"col": 18, "file": 1, "line": 2954}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/src/lib-dcrypt/dcrypt-openssl.c", "reportHash": "41d2803303a13ecf4d3237292ef44ffb", "checkerName": "google-readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 53, "file": 1, "line": 2978}, "message": "{ (fixit)"}, {"location": {"col": 45, "file": 1, "line": 2978}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/src/lib-dcrypt/dcrypt-openssl.c", "reportHash": "6aceaba397bcdd420cbc9ee93b0d6542", "checkerName": "google-readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 2, "file": 1, "line": 2979}, "message": "do not use 'else' after 'return'"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/src/lib-dcrypt/dcrypt-openssl.c", "reportHash": "fc7f9a31c23762e2f1d129a7032bbcaa", "checkerName": "readability-else-after-return", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 57, "file": 1, "line": 2979}, "message": "{ (fixit)"}, {"location": {"col": 49, "file": 1, "line": 2979}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/src/lib-dcrypt/dcrypt-openssl.c", "reportHash": "6c576b6e0f7091ab105c9c4c05ac7d14", "checkerName": "hicpp-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 14, "file": 1, "line": 2980}, "message": "{ (fixit)"}, {"location": {"col": 6, "file": 1, "line": 2980}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/src/lib-dcrypt/dcrypt-openssl.c", "reportHash": "5c6b6b678a9bd2a338d1828d3a01a91c", "checkerName": "google-readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 52, "file": 1, "line": 2988}, "message": "{ (fixit)"}, {"location": {"col": 44, "file": 1, "line": 2988}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/src/lib-dcrypt/dcrypt-openssl.c", "reportHash": "4f7e0fa0fbea4833fcd7910890c4e430", "checkerName": "google-readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 2, "file": 1, "line": 2989}, "message": "do not use 'else' after 'return'"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/src/lib-dcrypt/dcrypt-openssl.c", "reportHash": "45f23ccc9d8be04943a412696b8b519c", "checkerName": "readability-else-after-return", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 56, "file": 1, "line": 2989}, "message": "{ (fixit)"}, {"location": {"col": 48, "file": 1, "line": 2989}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/src/lib-dcrypt/dcrypt-openssl.c", "reportHash": "cfb8a58f4060079fd06b2449710c21a5", "checkerName": "google-readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 14, "file": 1, "line": 2990}, "message": "{ (fixit)"}, {"location": {"col": 6, "file": 1, "line": 2990}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/src/lib-dcrypt/dcrypt-openssl.c", "reportHash": "5c6b6b678a9bd2a338d1828d3a01a91c", "checkerName": "google-readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 33, "file": 1, "line": 3008}, "message": "{ (fixit)"}, {"location": {"col": 25, "file": 1, "line": 3008}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/src/lib-dcrypt/dcrypt-openssl.c", "reportHash": "ba0439e6f184e7d0ae62c4326f7e5b7d", "checkerName": "google-readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 33, "file": 1, "line": 3031}, "message": "{ (fixit)"}, {"location": {"col": 25, "file": 1, "line": 3031}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/src/lib-dcrypt/dcrypt-openssl.c", "reportHash": "ba0439e6f184e7d0ae62c4326f7e5b7d", "checkerName": "google-readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 25, "file": 1, "line": 3118}, "message": "{ (fixit)"}, {"location": {"col": 17, "file": 1, "line": 3118}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/src/lib-dcrypt/dcrypt-openssl.c", "reportHash": "7fe312b8ff3b81a2ea70e687b9578bba", "checkerName": "google-readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 52, "file": 1, "line": 3121}, "message": "{ (fixit)"}, {"location": {"col": 44, "file": 1, "line": 3121}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/src/lib-dcrypt/dcrypt-openssl.c", "reportHash": "2cbc44c9184d554e40e329e88fee23cb", "checkerName": "google-readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 81, "file": 1, "line": 3172}, "message": "{ (fixit)"}, {"location": {"col": 73, "file": 1, "line": 3172}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/src/lib-dcrypt/dcrypt-openssl.c", "reportHash": "e154ca672ec37585e82cb55343a77939", "checkerName": "google-readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 83, "file": 1, "line": 3177}, "message": "{ (fixit)"}, {"location": {"col": 75, "file": 1, "line": 3177}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/src/lib-dcrypt/dcrypt-openssl.c", "reportHash": "3ead77226227f4804d2a1770330c5ec2", "checkerName": "readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 24, "file": 1, "line": 3236}, "message": "{ (fixit)"}, {"location": {"col": 16, "file": 1, "line": 3236}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/src/lib-dcrypt/dcrypt-openssl.c", "reportHash": "9f7cfd384f382a2bcbb81384b308633b", "checkerName": "google-readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 81, "file": 1, "line": 3289}, "message": "{ (fixit)"}, {"location": {"col": 73, "file": 1, "line": 3289}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/src/lib-dcrypt/dcrypt-openssl.c", "reportHash": "e154ca672ec37585e82cb55343a77939", "checkerName": "google-readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 24, "file": 1, "line": 3355}, "message": "{ (fixit)"}, {"location": {"col": 16, "file": 1, "line": 3355}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/src/lib-dcrypt/dcrypt-openssl.c", "reportHash": "9f7cfd384f382a2bcbb81384b308633b", "checkerName": "google-readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 4, "file": 1, "line": 3400}, "message": "do not use 'else' after 'return'"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/src/lib-dcrypt/dcrypt-openssl.c", "reportHash": "c2517b59cb4825fbd072b2afcd4f57b4", "checkerName": "readability-else-after-return", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 49, "file": 1, "line": 3422}, "message": "{ (fixit)"}, {"location": {"col": 34, "file": 1, "line": 3422}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/src/lib-dcrypt/dcrypt-openssl.c", "reportHash": "aac3f1e92db5777ca29da96aeed80323", "checkerName": "google-readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 4, "file": 1, "line": 3451}, "message": "do not use 'else' after 'return'"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/src/lib-dcrypt/dcrypt-openssl.c", "reportHash": "b87fce1e1ef7d5c05735daa65e1a8840", "checkerName": "readability-else-after-return", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 80, "file": 1, "line": 3480}, "message": "{ (fixit)"}, {"location": {"col": 51, "file": 1, "line": 3480}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/src/lib-dcrypt/dcrypt-openssl.c", "reportHash": "9de9adf1d8aa2e5034013d96994b5300", "checkerName": "google-readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 4, "file": 1, "line": 3506}, "message": "do not use 'else' after 'return'"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/src/lib-dcrypt/dcrypt-openssl.c", "reportHash": "a83696e7ff25e61ad463fad9008cb478", "checkerName": "readability-else-after-return", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 34, "file": 1, "line": 3515}, "message": "{ (fixit)"}, {"location": {"col": 19, "file": 1, "line": 3515}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/src/lib-dcrypt/dcrypt-openssl.c", "reportHash": "c5f2d43cbfbd71928df0f34df661a4d9", "checkerName": "google-readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 30, "file": 1, "line": 3548}, "message": "{ (fixit)"}, {"location": {"col": 15, "file": 1, "line": 3548}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/src/lib-dcrypt/dcrypt-openssl.c", "reportHash": "cbcdeac2f64d3615cd25f5e14b93e89a", "checkerName": "google-readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 28, "file": 8, "line": 8}, "message": "expanded from macro 'i_new'"}, {"location": {"col": 27, "file": 2, "line": 92}, "message": "expanded from macro 'p_new'"}, {"location": {"col": 41, "file": 3, "line": 25}, "message": "expanded from macro 'MALLOC_MULTIPLY'"}, {"location": {"col": 12, "file": 1, "line": 3562}, "message": "suspicious usage of 'sizeof(K)'; did you mean 'K'?"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/src/lib-dcrypt/dcrypt-openssl.c", "reportHash": "44658063e7230a517270c1368c5b16aa", "checkerName": "misc-sizeof-expression", "reviewStatus": null, "severity": "HIGH"}, {"events": [{"location": {"col": 28, "file": 8, "line": 8}, "message": "expanded from macro 'i_new'"}, {"location": {"col": 27, "file": 2, "line": 92}, "message": "expanded from macro 'p_new'"}, {"location": {"col": 30, "file": 3, "line": 25}, "message": "expanded from macro 'MALLOC_MULTIPLY'"}, {"location": {"col": 12, "file": 1, "line": 3562}, "message": "suspicious usage of 'sizeof(sizeof(...))'"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/src/lib-dcrypt/dcrypt-openssl.c", "reportHash": "14ad0ad4280931796dec53ed513ef301", "checkerName": "misc-sizeof-expression", "reviewStatus": null, "severity": "HIGH"}, {"events": [{"location": {"col": 4, "file": 1, "line": 3586}, "message": "do not use 'else' after 'return'"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/src/lib-dcrypt/dcrypt-openssl.c", "reportHash": "a83696e7ff25e61ad463fad9008cb478", "checkerName": "readability-else-after-return", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 30, "file": 1, "line": 3621}, "message": "{ (fixit)"}, {"location": {"col": 15, "file": 1, "line": 3621}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/src/lib-dcrypt/dcrypt-openssl.c", "reportHash": "cbcdeac2f64d3615cd25f5e14b93e89a", "checkerName": "google-readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 28, "file": 8, "line": 8}, "message": "expanded from macro 'i_new'"}, {"location": {"col": 27, "file": 2, "line": 92}, "message": "expanded from macro 'p_new'"}, {"location": {"col": 41, "file": 3, "line": 25}, "message": "expanded from macro 'MALLOC_MULTIPLY'"}, {"location": {"col": 12, "file": 1, "line": 3636}, "message": "suspicious usage of 'sizeof(K)'; did you mean 'K'?"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/src/lib-dcrypt/dcrypt-openssl.c", "reportHash": "27aa250dc0a95aae9df902c31e50aefe", "checkerName": "misc-sizeof-expression", "reviewStatus": null, "severity": "HIGH"}, {"events": [{"location": {"col": 28, "file": 8, "line": 8}, "message": "expanded from macro 'i_new'"}, {"location": {"col": 27, "file": 2, "line": 92}, "message": "expanded from macro 'p_new'"}, {"location": {"col": 30, "file": 3, "line": 25}, "message": "expanded from macro 'MALLOC_MULTIPLY'"}, {"location": {"col": 12, "file": 1, "line": 3636}, "message": "suspicious usage of 'sizeof(sizeof(...))'"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/src/lib-dcrypt/dcrypt-openssl.c", "reportHash": "1a5e5e1950653493058ab3b7abdfbfb6", "checkerName": "misc-sizeof-expression", "reviewStatus": null, "severity": "HIGH"}, {"events": [{"location": {"col": 4, "file": 1, "line": 3667}, "message": "do not use 'else' after 'return'"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/src/lib-dcrypt/dcrypt-openssl.c", "reportHash": "2950efa8beeae8f57ea5562de956f23b", "checkerName": "readability-else-after-return", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 9, "file": 10, "line": 1}, "message": "_HOME_RUNNER_WORK_TESTCC_TESTCC_RETDEC_SRC_LIB_DCRYPT_DCRYPT_PRIVATE_H (fixit)"}, {"location": {"col": 9, "file": 10, "line": 1}, "message": "header guard does not follow preferred style"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/src/lib-dcrypt/dcrypt-private.h", "reportHash": "853c820558a7be863a0d7c0c21972342", "checkerName": "llvm-header-guard", "reviewStatus": null, "severity": "LOW"}]};
      window.onload = function() {
        if (!browserCompatible) {
          setNonCompatibleBrowserMessage();
        } else {
          BugViewer.init(data.files, data.reports);
          BugViewer.create();
          BugViewer.initByUrl();
        }
      };
    </script>
  </head>
  <body>
  <div class="container">
    <div id="content">
      <div id="side-bar">
        <div class="header">
          <a href="index.html" class="button">&#8249; Return to List</a>
        </div>
        <div id="report-nav">
          <div class="header">Reports</div>
        </div>
      </div>
      <div id="editor-wrapper">
        <div class="header">
          <div id="file">
            <span class="label">File:</span>
            <span id="file-path"></span>
          </div>
          <div id="checker">
            <span class="label">Checker name:</span>
            <span id="checker-name"></span>
          </div>
          <div id="review-status-wrapper">
            <span class="label">Review status:</span>
            <span id="review-status"></span>
          </div>
        </div>
        <div id="editor"></div>
      </div>
    </div>
  </div>
  </body>
</html>
