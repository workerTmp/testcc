<!DOCTYPE html>
<html>
  <head>
    <title>Plist HTML Viewer</title>

    <meta charset="UTF-8">

    <style type="text/css">
      .CodeMirror{font-family:monospace;height:300px;color:#000;direction:ltr}.CodeMirror-lines{padding:4px 0}.CodeMirror pre{padding:0 4px}.CodeMirror-gutter-filler,.CodeMirror-scrollbar-filler{background-color:#fff}.CodeMirror-gutters{border-right:1px solid #ddd;background-color:#f7f7f7;white-space:nowrap}.CodeMirror-linenumber{padding:0 3px 0 5px;min-width:20px;text-align:right;color:#999;white-space:nowrap}.CodeMirror-guttermarker{color:#000}.CodeMirror-guttermarker-subtle{color:#999}.CodeMirror-cursor{border-left:1px solid #000;border-right:none;width:0}.CodeMirror div.CodeMirror-secondarycursor{border-left:1px solid silver}.cm-fat-cursor .CodeMirror-cursor{width:auto;border:0!important;background:#7e7}.cm-fat-cursor div.CodeMirror-cursors{z-index:1}.cm-animate-fat-cursor{width:auto;border:0;-webkit-animation:blink 1.06s steps(1) infinite;-moz-animation:blink 1.06s steps(1) infinite;animation:blink 1.06s steps(1) infinite;background-color:#7e7}@-moz-keyframes blink{50%{background-color:transparent}}@-webkit-keyframes blink{50%{background-color:transparent}}@keyframes blink{50%{background-color:transparent}}.cm-tab{display:inline-block;text-decoration:inherit}.CodeMirror-rulers{position:absolute;left:0;right:0;top:-50px;bottom:-20px;overflow:hidden}.CodeMirror-ruler{border-left:1px solid #ccc;top:0;bottom:0;position:absolute}.cm-s-default .cm-header{color:#00f}.cm-s-default .cm-quote{color:#090}.cm-negative{color:#d44}.cm-positive{color:#292}.cm-header,.cm-strong{font-weight:700}.cm-em{font-style:italic}.cm-link{text-decoration:underline}.cm-strikethrough{text-decoration:line-through}.cm-s-default .cm-keyword{color:#708}.cm-s-default .cm-atom{color:#219}.cm-s-default .cm-number{color:#164}.cm-s-default .cm-def{color:#00f}.cm-s-default .cm-variable-2{color:#05a}.cm-s-default .cm-type,.cm-s-default .cm-variable-3{color:#085}.cm-s-default .cm-comment{color:#a50}.cm-s-default .cm-string{color:#a11}.cm-s-default .cm-string-2{color:#f50}.cm-s-default .cm-meta{color:#555}.cm-s-default .cm-qualifier{color:#555}.cm-s-default .cm-builtin{color:#30a}.cm-s-default .cm-bracket{color:#997}.cm-s-default .cm-tag{color:#170}.cm-s-default .cm-attribute{color:#00c}.cm-s-default .cm-hr{color:#999}.cm-s-default .cm-link{color:#00c}.cm-s-default .cm-error{color:red}.cm-invalidchar{color:red}.CodeMirror-composing{border-bottom:2px solid}div.CodeMirror span.CodeMirror-matchingbracket{color:#0f0}div.CodeMirror span.CodeMirror-nonmatchingbracket{color:#f22}.CodeMirror-matchingtag{background:rgba(255,150,0,.3)}.CodeMirror-activeline-background{background:#e8f2ff}.CodeMirror{position:relative;overflow:hidden;background:#fff}.CodeMirror-scroll{overflow:scroll!important;margin-bottom:-30px;margin-right:-30px;padding-bottom:30px;height:100%;outline:0;position:relative}.CodeMirror-sizer{position:relative;border-right:30px solid transparent}.CodeMirror-gutter-filler,.CodeMirror-hscrollbar,.CodeMirror-scrollbar-filler,.CodeMirror-vscrollbar{position:absolute;z-index:6;display:none}.CodeMirror-vscrollbar{right:0;top:0;overflow-x:hidden;overflow-y:scroll}.CodeMirror-hscrollbar{bottom:0;left:0;overflow-y:hidden;overflow-x:scroll}.CodeMirror-scrollbar-filler{right:0;bottom:0}.CodeMirror-gutter-filler{left:0;bottom:0}.CodeMirror-gutters{position:absolute;left:0;top:0;min-height:100%;z-index:3}.CodeMirror-gutter{white-space:normal;height:100%;display:inline-block;vertical-align:top;margin-bottom:-30px}.CodeMirror-gutter-wrapper{position:absolute;z-index:4;background:0 0!important;border:none!important}.CodeMirror-gutter-background{position:absolute;top:0;bottom:0;z-index:4}.CodeMirror-gutter-elt{position:absolute;cursor:default;z-index:4}.CodeMirror-gutter-wrapper ::selection{background-color:transparent}.CodeMirror-gutter-wrapper ::-moz-selection{background-color:transparent}.CodeMirror-lines{cursor:text;min-height:1px}.CodeMirror pre{-moz-border-radius:0;-webkit-border-radius:0;border-radius:0;border-width:0;background:0 0;font-family:inherit;font-size:inherit;margin:0;white-space:pre;word-wrap:normal;line-height:inherit;color:inherit;z-index:2;position:relative;overflow:visible;-webkit-tap-highlight-color:transparent;-webkit-font-variant-ligatures:contextual;font-variant-ligatures:contextual}.CodeMirror-wrap pre{word-wrap:break-word;white-space:pre-wrap;word-break:normal}.CodeMirror-linebackground{position:absolute;left:0;right:0;top:0;bottom:0;z-index:0}.CodeMirror-linewidget{position:relative;z-index:2;overflow:auto}.CodeMirror-rtl pre{direction:rtl}.CodeMirror-code{outline:0}.CodeMirror-gutter,.CodeMirror-gutters,.CodeMirror-linenumber,.CodeMirror-scroll,.CodeMirror-sizer{-moz-box-sizing:content-box;box-sizing:content-box}.CodeMirror-measure{position:absolute;width:100%;height:0;overflow:hidden;visibility:hidden}.CodeMirror-cursor{position:absolute;pointer-events:none}.CodeMirror-measure pre{position:static}div.CodeMirror-cursors{visibility:hidden;position:relative;z-index:3}div.CodeMirror-dragcursors{visibility:visible}.CodeMirror-focused div.CodeMirror-cursors{visibility:visible}.CodeMirror-selected{background:#d9d9d9}.CodeMirror-focused .CodeMirror-selected{background:#d7d4f0}.CodeMirror-crosshair{cursor:crosshair}.CodeMirror-line::selection,.CodeMirror-line>span::selection,.CodeMirror-line>span>span::selection{background:#d7d4f0}.CodeMirror-line::-moz-selection,.CodeMirror-line>span::-moz-selection,.CodeMirror-line>span>span::-moz-selection{background:#d7d4f0}.cm-searching{background-color:#ffa;background-color:rgba(255,255,0,.4)}.cm-force-border{padding-right:.1px}@media print{.CodeMirror div.CodeMirror-cursors{visibility:hidden}}.cm-tab-wrap-hack:after{content:''}span.CodeMirror-selectedtext{background:0 0}
/*# sourceMappingURL=codemirror.min.css.map */

      .severity-low {
  background-color: #669603;
}

.severity-low:after {
  content : 'L';
}

.severity-unspecified {
  background-color: #666666;
}

.severity-unspecified:after {
  content : 'U';
}

.severity-style {
  background-color: #9932cc;
}

.severity-style:after {
  content : 'S';
}

.severity-medium {
  background-color: #a9d323;
  color: black;
}

.severity-medium:after {
  content : 'M';
}

.severity-high {
  background-color: #ffa800;
}

.severity-high:after {
  content : 'H';
}

.severity-critical {
  background-color: #e92625;
}

.severity-critical:after {
  content : 'C';
}

i[class*="severity-"] {
  line-height: normal;
  text-transform: capitalize;
  font-size: 0.8em;
  font-weight: bold;
  color: white;
  display: inline-block;
  width: 16px;
  height: 16px;
  text-align: center;
  font-family: sans-serif;
}

      html, body {
  width: 100%;
  height: 100%;
  padding: 0px;
  margin: 0px;
}

div.container {
  padding: 10px;
}

#content {
  height: 100%;
  display: block;
  overflow: hidden;
}

#content > div {
  margin: 10px;
  overflow: hidden;
  border: 1px solid #ddd;
  border-radius: 3px;
  overflow: hidden;
  height: 97%;
}

.button {
  background-color: #f1f1f1;
  text-decoration: none;
  display: inline-block;
  padding: 8px 16px;
  color: black;
  cursor: pointer;
}

.button:hover {
  background-color: #ddd;
  color: black;
}

.review-status {
  color: white;
  text-align: center;
}

.review-status-confirmed {
  background-color: #e92625;
}

.review-status-false-positive {
  background-color: grey;
}

.review-status-intentional {
  background-color: #669603;
}

      div.container {
  width: 100%;
  height: 100%;
  padding: 0px;
}

#editor-wrapper {
  margin: 10px;
}

#side-bar {
  float: left;
  width: 260px;
  margin: 0px;
}

#report-nav ul {
  list-style-type: none;
  padding: 0;
  margin: 0;
  overflow-y: auto;
  height: 100%;
}

#report-nav ul > li {
  padding: .4em;
  background-color: #fff;
  border-bottom: 1px solid rgba(0,0,0,.125);
  text-align: left;
  overflow: hidden;
  white-space: nowrap;
  text-overflow: ellipsis;
}

#report-nav ul > li.active {
  background-color: #427ea9;
  color: white;
}

#report-nav ul > li:hover {
  background-color: #427ea9;
  color: white;
  cursor: pointer;
}

#report-nav ul a {
  text-decoration: none;
}

#report-nav i[class*="severity-"] {
  margin-right: 5px;
}

.header {
  border-bottom: 1px solid lightgrey;
  font-family: monospace;
  padding: 10px;
  background-color: #fafbfc;
  border-bottom: 1px solid #e1e4e8;
  border-top-left-radius: 2px;
  border-top-right-radius: 2px;
}

#report-nav .header {
  font-weight: bold;
}

#editor-wrapper .header > div {
  padding-top: 2px;
}

#file-path,
#checker-name {
  color: #195ea2;
}

#review-status {
  padding: 0px 5px;
}

#file-path {
  font-family: monospace;
}

.check-msg {
  display: inline-block;
  padding: 3px 6px;
  margin: 1px;
  -webkit-border-radius: 5px;
  -moz-border-radius: 5px;
  border-radius: 5px;
}

.check-msg.info {
  color: #00546f;
  background-color: #bfdfe9;
  border: 1px solid #87a8b3;
}

.check-msg.error {
  background-color: #f2dede;
  color: #a94442;
  border: 1px solid #ebcccc;
}

.check-msg.macro {
  background-color: #d7dac2;
  color: #4f5c6d;
  border: 1px solid #d7dac2;
}

.check-msg.note {
  background-color: #d7d7d7;
  color: #4f5c6d;
  border: 1px solid #bfbfbf;
}

.check-msg.current {
  border: 2px dashed #3692ff;
}

.check-msg .tag {
  padding: 1px 5px;
  text-align: center;
  border-radius: 2px;
  margin-right: 5px;
  text-decoration: inherit;
}

.check-msg .tag.macro {
  background-color: #83876a;
  color: white;
  text-transform: capitalize;
}

.check-msg .tag.note {
  background-color: #9299a1;
  color: white;
  text-transform: capitalize;
}

.checker-enum {
  color: white;
  padding: 1px 5px;
  text-align: center;
  border-radius: 25px;
  margin-right: 5px;
  text-decoration: inherit;
}

.checker-enum.info {
  background-color: #427ea9;
}

.checker-enum.error {
  background-color: #a94442;
}

.arrow {
  border: solid black;
  border-width: 0 3px 3px 0;
  display: inline-block;
  padding: 3px;
  cursor: pointer;
  margin: 0px 5px;
}

.arrow:hover {
  border: solid #437ea8;
  border-width: 0 3px 3px 0;
}

.left-arrow {
  transform: rotate(135deg);
  -webkit-transform: rotate(135deg);
}

.right-arrow {
  transform: rotate(-45deg);
  -webkit-transform: rotate(-45deg);
}

    </style>

    <script type="text/javascript">
      function setNonCompatibleBrowserMessage() {
  document.body.innerHTML =
    '<h2 style="margin-left: 20px;">Your browser is not compatible with CodeChecker Viewer!</h2> \
     <p style="margin-left: 20px;">The version required for the following browsers are:</p> \
     <ul style="margin-left: 20px;"> \
     <li>Internet Explorer: version 9 or newer</li> \
     <li>Firefox: version 22.0 or newer</li> \
     </ul>';
}

// http://stackoverflow.com/questions/5916900/how-can-you-detect-the-version-of-a-browser
var browserVersion = (function(){
  var ua = navigator.userAgent, tem,
    M = ua.match(/(opera|chrome|safari|firefox|msie|trident(?=\/))\/?\s*(\d+)/i) || [];

  if (/trident/i.test(M[1])) {
    tem = /\brv[ :]+(\d+)/g.exec(ua) || [];
    return 'IE ' + (tem[1] || '');
  }

  if (M[1] === 'Chrome') {
    tem = ua.match(/\b(OPR|Edge)\/(\d+)/);
    if (tem != null) return tem.slice(1).join(' ').replace('OPR', 'Opera');
  }

  M = M[2] ? [M[1], M[2]] : [navigator.appName, navigator.appVersion, '-?'];
  if ((tem = ua.match(/version\/(\d+)/i)) != null) M.splice(1, 1, tem[1]);
    return M.join(' ');
})();

var pos = browserVersion.indexOf(' ');
var browser = browserVersion.substr(0, pos);
var version = parseInt(browserVersion.substr(pos + 1));

var browserCompatible
  = browser === 'Firefox'
  ? version >= 22
  : browser === 'IE'
  ? version >= 9
  : true;


      /* MIT License

Copyright (C) 2017 by Marijn Haverbeke <marijnh@gmail.com> and others

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
THE SOFTWARE.
 */
      !function(e,t){"object"==typeof exports&&"undefined"!=typeof module?module.exports=t():"function"==typeof define&&define.amd?define(t):e.CodeMirror=t()}(this,function(){"use strict";function e(e){return new RegExp("(^|\\s)"+e+"(?:$|\\s)\\s*")}function t(e){for(var t=e.childNodes.length;t>0;--t)e.removeChild(e.firstChild);return e}function r(e,r){return t(e).appendChild(r)}function n(e,t,r,n){var i=document.createElement(e);if(r&&(i.className=r),n&&(i.style.cssText=n),"string"==typeof t)i.appendChild(document.createTextNode(t));else if(t)for(var o=0;o<t.length;++o)i.appendChild(t[o]);return i}function i(e,t,r,i){var o=n(e,t,r,i);return o.setAttribute("role","presentation"),o}function o(e,t){if(3==t.nodeType&&(t=t.parentNode),e.contains)return e.contains(t);do{if(11==t.nodeType&&(t=t.host),t==e)return!0}while(t=t.parentNode)}function l(){var e;try{e=document.activeElement}catch(t){e=document.body||null}for(;e&&e.shadowRoot&&e.shadowRoot.activeElement;)e=e.shadowRoot.activeElement;return e}function s(t,r){var n=t.className;e(r).test(n)||(t.className+=(n?" ":"")+r)}function a(t,r){for(var n=t.split(" "),i=0;i<n.length;i++)n[i]&&!e(n[i]).test(r)&&(r+=" "+n[i]);return r}function u(e){var t=Array.prototype.slice.call(arguments,1);return function(){return e.apply(null,t)}}function c(e,t,r){t||(t={});for(var n in e)!e.hasOwnProperty(n)||!1===r&&t.hasOwnProperty(n)||(t[n]=e[n]);return t}function f(e,t,r,n,i){null==t&&-1==(t=e.search(/[^\s\u00a0]/))&&(t=e.length);for(var o=n||0,l=i||0;;){var s=e.indexOf("\t",o);if(s<0||s>=t)return l+(t-o);l+=s-o,l+=r-l%r,o=s+1}}function h(e,t){for(var r=0;r<e.length;++r)if(e[r]==t)return r;return-1}function d(e,t,r){for(var n=0,i=0;;){var o=e.indexOf("\t",n);-1==o&&(o=e.length);var l=o-n;if(o==e.length||i+l>=t)return n+Math.min(l,t-i);if(i+=o-n,i+=r-i%r,n=o+1,i>=t)return n}}function p(e){for(;Kl.length<=e;)Kl.push(g(Kl)+" ");return Kl[e]}function g(e){return e[e.length-1]}function v(e,t){for(var r=[],n=0;n<e.length;n++)r[n]=t(e[n],n);return r}function m(e,t,r){for(var n=0,i=r(t);n<e.length&&r(e[n])<=i;)n++;e.splice(n,0,t)}function y(){}function b(e,t){var r;return Object.create?r=Object.create(e):(y.prototype=e,r=new y),t&&c(t,r),r}function w(e){return/\w/.test(e)||e>""&&(e.toUpperCase()!=e.toLowerCase()||jl.test(e))}function x(e,t){return t?!!(t.source.indexOf("\\w")>-1&&w(e))||t.test(e):w(e)}function C(e){for(var t in e)if(e.hasOwnProperty(t)&&e[t])return!1;return!0}function S(e){return e.charCodeAt(0)>=768&&Xl.test(e)}function L(e,t,r){for(;(r<0?t>0:t<e.length)&&S(e.charAt(t));)t+=r;return t}function k(e,t,r){for(var n=t>r?-1:1;;){if(t==r)return t;var i=(t+r)/2,o=n<0?Math.ceil(i):Math.floor(i);if(o==t)return e(o)?t:r;e(o)?r=o:t=o+n}}function T(e,t,r){var o=this;this.input=r,o.scrollbarFiller=n("div",null,"CodeMirror-scrollbar-filler"),o.scrollbarFiller.setAttribute("cm-not-content","true"),o.gutterFiller=n("div",null,"CodeMirror-gutter-filler"),o.gutterFiller.setAttribute("cm-not-content","true"),o.lineDiv=i("div",null,"CodeMirror-code"),o.selectionDiv=n("div",null,null,"position: relative; z-index: 1"),o.cursorDiv=n("div",null,"CodeMirror-cursors"),o.measure=n("div",null,"CodeMirror-measure"),o.lineMeasure=n("div",null,"CodeMirror-measure"),o.lineSpace=i("div",[o.measure,o.lineMeasure,o.selectionDiv,o.cursorDiv,o.lineDiv],null,"position: relative; outline: none");var l=i("div",[o.lineSpace],"CodeMirror-lines");o.mover=n("div",[l],null,"position: relative"),o.sizer=n("div",[o.mover],"CodeMirror-sizer"),o.sizerWidth=null,o.heightForcer=n("div",null,null,"position: absolute; height: "+Rl+"px; width: 1px;"),o.gutters=n("div",null,"CodeMirror-gutters"),o.lineGutter=null,o.scroller=n("div",[o.sizer,o.heightForcer,o.gutters],"CodeMirror-scroll"),o.scroller.setAttribute("tabIndex","-1"),o.wrapper=n("div",[o.scrollbarFiller,o.gutterFiller,o.scroller],"CodeMirror"),gl&&vl<8&&(o.gutters.style.zIndex=-1,o.scroller.style.paddingRight=0),ml||fl&&Tl||(o.scroller.draggable=!0),e&&(e.appendChild?e.appendChild(o.wrapper):e(o.wrapper)),o.viewFrom=o.viewTo=t.first,o.reportedViewFrom=o.reportedViewTo=t.first,o.view=[],o.renderedView=null,o.externalMeasured=null,o.viewOffset=0,o.lastWrapHeight=o.lastWrapWidth=0,o.updateLineNumbers=null,o.nativeBarWidth=o.barHeight=o.barWidth=0,o.scrollbarsClipped=!1,o.lineNumWidth=o.lineNumInnerWidth=o.lineNumChars=null,o.alignWidgets=!1,o.cachedCharWidth=o.cachedTextHeight=o.cachedPaddingH=null,o.maxLine=null,o.maxLineLength=0,o.maxLineChanged=!1,o.wheelDX=o.wheelDY=o.wheelStartX=o.wheelStartY=null,o.shift=!1,o.selForContextMenu=null,o.activeTouch=null,r.init(o)}function M(e,t){if((t-=e.first)<0||t>=e.size)throw new Error("There is no line "+(t+e.first)+" in the document.");for(var r=e;!r.lines;)for(var n=0;;++n){var i=r.children[n],o=i.chunkSize();if(t<o){r=i;break}t-=o}return r.lines[t]}function N(e,t,r){var n=[],i=t.line;return e.iter(t.line,r.line+1,function(e){var o=e.text;i==r.line&&(o=o.slice(0,r.ch)),i==t.line&&(o=o.slice(t.ch)),n.push(o),++i}),n}function O(e,t,r){var n=[];return e.iter(t,r,function(e){n.push(e.text)}),n}function A(e,t){var r=t-e.height;if(r)for(var n=e;n;n=n.parent)n.height+=r}function W(e){if(null==e.parent)return null;for(var t=e.parent,r=h(t.lines,e),n=t.parent;n;t=n,n=n.parent)for(var i=0;n.children[i]!=t;++i)r+=n.children[i].chunkSize();return r+t.first}function D(e,t){var r=e.first;e:do{for(var n=0;n<e.children.length;++n){var i=e.children[n],o=i.height;if(t<o){e=i;continue e}t-=o,r+=i.chunkSize()}return r}while(!e.lines);for(var l=0;l<e.lines.length;++l){var s=e.lines[l].height;if(t<s)break;t-=s}return r+l}function H(e,t){return t>=e.first&&t<e.first+e.size}function F(e,t){return String(e.lineNumberFormatter(t+e.firstLineNumber))}function E(e,t,r){if(void 0===r&&(r=null),!(this instanceof E))return new E(e,t,r);this.line=e,this.ch=t,this.sticky=r}function P(e,t){return e.line-t.line||e.ch-t.ch}function I(e,t){return e.sticky==t.sticky&&0==P(e,t)}function z(e){return E(e.line,e.ch)}function R(e,t){return P(e,t)<0?t:e}function B(e,t){return P(e,t)<0?e:t}function G(e,t){return Math.max(e.first,Math.min(t,e.first+e.size-1))}function U(e,t){if(t.line<e.first)return E(e.first,0);var r=e.first+e.size-1;return t.line>r?E(r,M(e,r).text.length):V(t,M(e,t.line).text.length)}function V(e,t){var r=e.ch;return null==r||r>t?E(e.line,t):r<0?E(e.line,0):e}function K(e,t){for(var r=[],n=0;n<t.length;n++)r[n]=U(e,t[n]);return r}function j(){Yl=!0}function X(){_l=!0}function Y(e,t,r){this.marker=e,this.from=t,this.to=r}function _(e,t){if(e)for(var r=0;r<e.length;++r){var n=e[r];if(n.marker==t)return n}}function $(e,t){for(var r,n=0;n<e.length;++n)e[n]!=t&&(r||(r=[])).push(e[n]);return r}function q(e,t){e.markedSpans=e.markedSpans?e.markedSpans.concat([t]):[t],t.marker.attachLine(e)}function Z(e,t,r){var n;if(e)for(var i=0;i<e.length;++i){var o=e[i],l=o.marker;if(null==o.from||(l.inclusiveLeft?o.from<=t:o.from<t)||o.from==t&&"bookmark"==l.type&&(!r||!o.marker.insertLeft)){var s=null==o.to||(l.inclusiveRight?o.to>=t:o.to>t);(n||(n=[])).push(new Y(l,o.from,s?null:o.to))}}return n}function Q(e,t,r){var n;if(e)for(var i=0;i<e.length;++i){var o=e[i],l=o.marker;if(null==o.to||(l.inclusiveRight?o.to>=t:o.to>t)||o.from==t&&"bookmark"==l.type&&(!r||o.marker.insertLeft)){var s=null==o.from||(l.inclusiveLeft?o.from<=t:o.from<t);(n||(n=[])).push(new Y(l,s?null:o.from-t,null==o.to?null:o.to-t))}}return n}function J(e,t){if(t.full)return null;var r=H(e,t.from.line)&&M(e,t.from.line).markedSpans,n=H(e,t.to.line)&&M(e,t.to.line).markedSpans;if(!r&&!n)return null;var i=t.from.ch,o=t.to.ch,l=0==P(t.from,t.to),s=Z(r,i,l),a=Q(n,o,l),u=1==t.text.length,c=g(t.text).length+(u?i:0);if(s)for(var f=0;f<s.length;++f){var h=s[f];if(null==h.to){var d=_(a,h.marker);d?u&&(h.to=null==d.to?null:d.to+c):h.to=i}}if(a)for(var p=0;p<a.length;++p){var v=a[p];null!=v.to&&(v.to+=c),null==v.from?_(s,v.marker)||(v.from=c,u&&(s||(s=[])).push(v)):(v.from+=c,u&&(s||(s=[])).push(v))}s&&(s=ee(s)),a&&a!=s&&(a=ee(a));var m=[s];if(!u){var y,b=t.text.length-2;if(b>0&&s)for(var w=0;w<s.length;++w)null==s[w].to&&(y||(y=[])).push(new Y(s[w].marker,null,null));for(var x=0;x<b;++x)m.push(y);m.push(a)}return m}function ee(e){for(var t=0;t<e.length;++t){var r=e[t];null!=r.from&&r.from==r.to&&!1!==r.marker.clearWhenEmpty&&e.splice(t--,1)}return e.length?e:null}function te(e,t,r){var n=null;if(e.iter(t.line,r.line+1,function(e){if(e.markedSpans)for(var t=0;t<e.markedSpans.length;++t){var r=e.markedSpans[t].marker;!r.readOnly||n&&-1!=h(n,r)||(n||(n=[])).push(r)}}),!n)return null;for(var i=[{from:t,to:r}],o=0;o<n.length;++o)for(var l=n[o],s=l.find(0),a=0;a<i.length;++a){var u=i[a];if(!(P(u.to,s.from)<0||P(u.from,s.to)>0)){var c=[a,1],f=P(u.from,s.from),d=P(u.to,s.to);(f<0||!l.inclusiveLeft&&!f)&&c.push({from:u.from,to:s.from}),(d>0||!l.inclusiveRight&&!d)&&c.push({from:s.to,to:u.to}),i.splice.apply(i,c),a+=c.length-3}}return i}function re(e){var t=e.markedSpans;if(t){for(var r=0;r<t.length;++r)t[r].marker.detachLine(e);e.markedSpans=null}}function ne(e,t){if(t){for(var r=0;r<t.length;++r)t[r].marker.attachLine(e);e.markedSpans=t}}function ie(e){return e.inclusiveLeft?-1:0}function oe(e){return e.inclusiveRight?1:0}function le(e,t){var r=e.lines.length-t.lines.length;if(0!=r)return r;var n=e.find(),i=t.find(),o=P(n.from,i.from)||ie(e)-ie(t);if(o)return-o;var l=P(n.to,i.to)||oe(e)-oe(t);return l||t.id-e.id}function se(e,t){var r,n=_l&&e.markedSpans;if(n)for(var i=void 0,o=0;o<n.length;++o)(i=n[o]).marker.collapsed&&null==(t?i.from:i.to)&&(!r||le(r,i.marker)<0)&&(r=i.marker);return r}function ae(e){return se(e,!0)}function ue(e){return se(e,!1)}function ce(e,t,r,n,i){var o=M(e,t),l=_l&&o.markedSpans;if(l)for(var s=0;s<l.length;++s){var a=l[s];if(a.marker.collapsed){var u=a.marker.find(0),c=P(u.from,r)||ie(a.marker)-ie(i),f=P(u.to,n)||oe(a.marker)-oe(i);if(!(c>=0&&f<=0||c<=0&&f>=0)&&(c<=0&&(a.marker.inclusiveRight&&i.inclusiveLeft?P(u.to,r)>=0:P(u.to,r)>0)||c>=0&&(a.marker.inclusiveRight&&i.inclusiveLeft?P(u.from,n)<=0:P(u.from,n)<0)))return!0}}}function fe(e){for(var t;t=ae(e);)e=t.find(-1,!0).line;return e}function he(e){for(var t;t=ue(e);)e=t.find(1,!0).line;return e}function de(e){for(var t,r;t=ue(e);)e=t.find(1,!0).line,(r||(r=[])).push(e);return r}function pe(e,t){var r=M(e,t),n=fe(r);return r==n?t:W(n)}function ge(e,t){if(t>e.lastLine())return t;var r,n=M(e,t);if(!ve(e,n))return t;for(;r=ue(n);)n=r.find(1,!0).line;return W(n)+1}function ve(e,t){var r=_l&&t.markedSpans;if(r)for(var n=void 0,i=0;i<r.length;++i)if((n=r[i]).marker.collapsed){if(null==n.from)return!0;if(!n.marker.widgetNode&&0==n.from&&n.marker.inclusiveLeft&&me(e,t,n))return!0}}function me(e,t,r){if(null==r.to){var n=r.marker.find(1,!0);return me(e,n.line,_(n.line.markedSpans,r.marker))}if(r.marker.inclusiveRight&&r.to==t.text.length)return!0;for(var i=void 0,o=0;o<t.markedSpans.length;++o)if((i=t.markedSpans[o]).marker.collapsed&&!i.marker.widgetNode&&i.from==r.to&&(null==i.to||i.to!=r.from)&&(i.marker.inclusiveLeft||r.marker.inclusiveRight)&&me(e,t,i))return!0}function ye(e){for(var t=0,r=(e=fe(e)).parent,n=0;n<r.lines.length;++n){var i=r.lines[n];if(i==e)break;t+=i.height}for(var o=r.parent;o;r=o,o=r.parent)for(var l=0;l<o.children.length;++l){var s=o.children[l];if(s==r)break;t+=s.height}return t}function be(e){if(0==e.height)return 0;for(var t,r=e.text.length,n=e;t=ae(n);){var i=t.find(0,!0);n=i.from.line,r+=i.from.ch-i.to.ch}for(n=e;t=ue(n);){var o=t.find(0,!0);r-=n.text.length-o.from.ch,r+=(n=o.to.line).text.length-o.to.ch}return r}function we(e){var t=e.display,r=e.doc;t.maxLine=M(r,r.first),t.maxLineLength=be(t.maxLine),t.maxLineChanged=!0,r.iter(function(e){var r=be(e);r>t.maxLineLength&&(t.maxLineLength=r,t.maxLine=e)})}function xe(e,t,r,n){if(!e)return n(t,r,"ltr",0);for(var i=!1,o=0;o<e.length;++o){var l=e[o];(l.from<r&&l.to>t||t==r&&l.to==t)&&(n(Math.max(l.from,t),Math.min(l.to,r),1==l.level?"rtl":"ltr",o),i=!0)}i||n(t,r,"ltr")}function Ce(e,t,r){var n;$l=null;for(var i=0;i<e.length;++i){var o=e[i];if(o.from<t&&o.to>t)return i;o.to==t&&(o.from!=o.to&&"before"==r?n=i:$l=i),o.from==t&&(o.from!=o.to&&"before"!=r?n=i:$l=i)}return null!=n?n:$l}function Se(e,t){var r=e.order;return null==r&&(r=e.order=ql(e.text,t)),r}function Le(e,t){return e._handlers&&e._handlers[t]||Zl}function ke(e,t,r){if(e.removeEventListener)e.removeEventListener(t,r,!1);else if(e.detachEvent)e.detachEvent("on"+t,r);else{var n=e._handlers,i=n&&n[t];if(i){var o=h(i,r);o>-1&&(n[t]=i.slice(0,o).concat(i.slice(o+1)))}}}function Te(e,t){var r=Le(e,t);if(r.length)for(var n=Array.prototype.slice.call(arguments,2),i=0;i<r.length;++i)r[i].apply(null,n)}function Me(e,t,r){return"string"==typeof t&&(t={type:t,preventDefault:function(){this.defaultPrevented=!0}}),Te(e,r||t.type,e,t),He(t)||t.codemirrorIgnore}function Ne(e){var t=e._handlers&&e._handlers.cursorActivity;if(t)for(var r=e.curOp.cursorActivityHandlers||(e.curOp.cursorActivityHandlers=[]),n=0;n<t.length;++n)-1==h(r,t[n])&&r.push(t[n])}function Oe(e,t){return Le(e,t).length>0}function Ae(e){e.prototype.on=function(e,t){Ql(this,e,t)},e.prototype.off=function(e,t){ke(this,e,t)}}function We(e){e.preventDefault?e.preventDefault():e.returnValue=!1}function De(e){e.stopPropagation?e.stopPropagation():e.cancelBubble=!0}function He(e){return null!=e.defaultPrevented?e.defaultPrevented:0==e.returnValue}function Fe(e){We(e),De(e)}function Ee(e){return e.target||e.srcElement}function Pe(e){var t=e.which;return null==t&&(1&e.button?t=1:2&e.button?t=3:4&e.button&&(t=2)),Ml&&e.ctrlKey&&1==t&&(t=3),t}function Ie(e){if(null==Il){var t=n("span","​");r(e,n("span",[t,document.createTextNode("x")])),0!=e.firstChild.offsetHeight&&(Il=t.offsetWidth<=1&&t.offsetHeight>2&&!(gl&&vl<8))}var i=Il?n("span","​"):n("span"," ",null,"display: inline-block; width: 1px; margin-right: -1px");return i.setAttribute("cm-text",""),i}function ze(e){if(null!=zl)return zl;var n=r(e,document.createTextNode("AخA")),i=Wl(n,0,1).getBoundingClientRect(),o=Wl(n,1,2).getBoundingClientRect();return t(e),!(!i||i.left==i.right)&&(zl=o.right-i.right<3)}function Re(e){if(null!=ns)return ns;var t=r(e,n("span","x")),i=t.getBoundingClientRect(),o=Wl(t,0,1).getBoundingClientRect();return ns=Math.abs(i.left-o.left)>1}function Be(e,t){arguments.length>2&&(t.dependencies=Array.prototype.slice.call(arguments,2)),is[e]=t}function Ge(e){if("string"==typeof e&&os.hasOwnProperty(e))e=os[e];else if(e&&"string"==typeof e.name&&os.hasOwnProperty(e.name)){var t=os[e.name];"string"==typeof t&&(t={name:t}),(e=b(t,e)).name=t.name}else{if("string"==typeof e&&/^[\w\-]+\/[\w\-]+\+xml$/.test(e))return Ge("application/xml");if("string"==typeof e&&/^[\w\-]+\/[\w\-]+\+json$/.test(e))return Ge("application/json")}return"string"==typeof e?{name:e}:e||{name:"null"}}function Ue(e,t){t=Ge(t);var r=is[t.name];if(!r)return Ue(e,"text/plain");var n=r(e,t);if(ls.hasOwnProperty(t.name)){var i=ls[t.name];for(var o in i)i.hasOwnProperty(o)&&(n.hasOwnProperty(o)&&(n["_"+o]=n[o]),n[o]=i[o])}if(n.name=t.name,t.helperType&&(n.helperType=t.helperType),t.modeProps)for(var l in t.modeProps)n[l]=t.modeProps[l];return n}function Ve(e,t){c(t,ls.hasOwnProperty(e)?ls[e]:ls[e]={})}function Ke(e,t){if(!0===t)return t;if(e.copyState)return e.copyState(t);var r={};for(var n in t){var i=t[n];i instanceof Array&&(i=i.concat([])),r[n]=i}return r}function je(e,t){for(var r;e.innerMode&&(r=e.innerMode(t))&&r.mode!=e;)t=r.state,e=r.mode;return r||{mode:e,state:t}}function Xe(e,t,r){return!e.startState||e.startState(t,r)}function Ye(e,t,r,n){var i=[e.state.modeGen],o={};tt(e,t.text,e.doc.mode,r,function(e,t){return i.push(e,t)},o,n);for(var l=r.state,s=0;s<e.state.overlays.length;++s)!function(n){var l=e.state.overlays[n],s=1,a=0;r.state=!0,tt(e,t.text,l.mode,r,function(e,t){for(var r=s;a<e;){var n=i[s];n>e&&i.splice(s,1,e,i[s+1],n),s+=2,a=Math.min(e,n)}if(t)if(l.opaque)i.splice(r,s-r,e,"overlay "+t),s=r+2;else for(;r<s;r+=2){var o=i[r+1];i[r+1]=(o?o+" ":"")+"overlay "+t}},o)}(s);return r.state=l,{styles:i,classes:o.bgClass||o.textClass?o:null}}function _e(e,t,r){if(!t.styles||t.styles[0]!=e.state.modeGen){var n=$e(e,W(t)),i=t.text.length>e.options.maxHighlightLength&&Ke(e.doc.mode,n.state),o=Ye(e,t,n);i&&(n.state=i),t.stateAfter=n.save(!i),t.styles=o.styles,o.classes?t.styleClasses=o.classes:t.styleClasses&&(t.styleClasses=null),r===e.doc.highlightFrontier&&(e.doc.modeFrontier=Math.max(e.doc.modeFrontier,++e.doc.highlightFrontier))}return t.styles}function $e(e,t,r){var n=e.doc,i=e.display;if(!n.mode.startState)return new us(n,!0,t);var o=rt(e,t,r),l=o>n.first&&M(n,o-1).stateAfter,s=l?us.fromSaved(n,l,o):new us(n,Xe(n.mode),o);return n.iter(o,t,function(r){qe(e,r.text,s);var n=s.line;r.stateAfter=n==t-1||n%5==0||n>=i.viewFrom&&n<i.viewTo?s.save():null,s.nextLine()}),r&&(n.modeFrontier=s.line),s}function qe(e,t,r,n){var i=e.doc.mode,o=new ss(t,e.options.tabSize,r);for(o.start=o.pos=n||0,""==t&&Ze(i,r.state);!o.eol();)Qe(i,o,r.state),o.start=o.pos}function Ze(e,t){if(e.blankLine)return e.blankLine(t);if(e.innerMode){var r=je(e,t);return r.mode.blankLine?r.mode.blankLine(r.state):void 0}}function Qe(e,t,r,n){for(var i=0;i<10;i++){n&&(n[0]=je(e,r).mode);var o=e.token(t,r);if(t.pos>t.start)return o}throw new Error("Mode "+e.name+" failed to advance stream.")}function Je(e,t,r,n){var i,o,l=e.doc,s=l.mode,a=M(l,(t=U(l,t)).line),u=$e(e,t.line,r),c=new ss(a.text,e.options.tabSize,u);for(n&&(o=[]);(n||c.pos<t.ch)&&!c.eol();)c.start=c.pos,i=Qe(s,c,u.state),n&&o.push(new cs(c,i,Ke(l.mode,u.state)));return n?o:new cs(c,i,u.state)}function et(e,t){if(e)for(;;){var r=e.match(/(?:^|\s+)line-(background-)?(\S+)/);if(!r)break;e=e.slice(0,r.index)+e.slice(r.index+r[0].length);var n=r[1]?"bgClass":"textClass";null==t[n]?t[n]=r[2]:new RegExp("(?:^|s)"+r[2]+"(?:$|s)").test(t[n])||(t[n]+=" "+r[2])}return e}function tt(e,t,r,n,i,o,l){var s=r.flattenSpans;null==s&&(s=e.options.flattenSpans);var a,u=0,c=null,f=new ss(t,e.options.tabSize,n),h=e.options.addModeClass&&[null];for(""==t&&et(Ze(r,n.state),o);!f.eol();){if(f.pos>e.options.maxHighlightLength?(s=!1,l&&qe(e,t,n,f.pos),f.pos=t.length,a=null):a=et(Qe(r,f,n.state,h),o),h){var d=h[0].name;d&&(a="m-"+(a?d+" "+a:d))}if(!s||c!=a){for(;u<f.start;)i(u=Math.min(f.start,u+5e3),c);c=a}f.start=f.pos}for(;u<f.pos;){var p=Math.min(f.pos,u+5e3);i(p,c),u=p}}function rt(e,t,r){for(var n,i,o=e.doc,l=r?-1:t-(e.doc.mode.innerMode?1e3:100),s=t;s>l;--s){if(s<=o.first)return o.first;var a=M(o,s-1),u=a.stateAfter;if(u&&(!r||s+(u instanceof as?u.lookAhead:0)<=o.modeFrontier))return s;var c=f(a.text,null,e.options.tabSize);(null==i||n>c)&&(i=s-1,n=c)}return i}function nt(e,t){if(e.modeFrontier=Math.min(e.modeFrontier,t),!(e.highlightFrontier<t-10)){for(var r=e.first,n=t-1;n>r;n--){var i=M(e,n).stateAfter;if(i&&(!(i instanceof as)||n+i.lookAhead<t)){r=n+1;break}}e.highlightFrontier=Math.min(e.highlightFrontier,r)}}function it(e,t,r,n){e.text=t,e.stateAfter&&(e.stateAfter=null),e.styles&&(e.styles=null),null!=e.order&&(e.order=null),re(e),ne(e,r);var i=n?n(e):1;i!=e.height&&A(e,i)}function ot(e){e.parent=null,re(e)}function lt(e,t){if(!e||/^\s*$/.test(e))return null;var r=t.addModeClass?ps:ds;return r[e]||(r[e]=e.replace(/\S+/g,"cm-$&"))}function st(e,t){var r=i("span",null,null,ml?"padding-right: .1px":null),n={pre:i("pre",[r],"CodeMirror-line"),content:r,col:0,pos:0,cm:e,trailingSpace:!1,splitSpaces:(gl||ml)&&e.getOption("lineWrapping")};t.measure={};for(var o=0;o<=(t.rest?t.rest.length:0);o++){var l=o?t.rest[o-1]:t.line,s=void 0;n.pos=0,n.addToken=ut,ze(e.display.measure)&&(s=Se(l,e.doc.direction))&&(n.addToken=ft(n.addToken,s)),n.map=[],dt(l,n,_e(e,l,t!=e.display.externalMeasured&&W(l))),l.styleClasses&&(l.styleClasses.bgClass&&(n.bgClass=a(l.styleClasses.bgClass,n.bgClass||"")),l.styleClasses.textClass&&(n.textClass=a(l.styleClasses.textClass,n.textClass||""))),0==n.map.length&&n.map.push(0,0,n.content.appendChild(Ie(e.display.measure))),0==o?(t.measure.map=n.map,t.measure.cache={}):((t.measure.maps||(t.measure.maps=[])).push(n.map),(t.measure.caches||(t.measure.caches=[])).push({}))}if(ml){var u=n.content.lastChild;(/\bcm-tab\b/.test(u.className)||u.querySelector&&u.querySelector(".cm-tab"))&&(n.content.className="cm-tab-wrap-hack")}return Te(e,"renderLine",e,t.line,n.pre),n.pre.className&&(n.textClass=a(n.pre.className,n.textClass||"")),n}function at(e){var t=n("span","•","cm-invalidchar");return t.title="\\u"+e.charCodeAt(0).toString(16),t.setAttribute("aria-label",t.title),t}function ut(e,t,r,i,o,l,s){if(t){var a,u=e.splitSpaces?ct(t,e.trailingSpace):t,c=e.cm.state.specialChars,f=!1;if(c.test(t)){a=document.createDocumentFragment();for(var h=0;;){c.lastIndex=h;var d=c.exec(t),g=d?d.index-h:t.length-h;if(g){var v=document.createTextNode(u.slice(h,h+g));gl&&vl<9?a.appendChild(n("span",[v])):a.appendChild(v),e.map.push(e.pos,e.pos+g,v),e.col+=g,e.pos+=g}if(!d)break;h+=g+1;var m=void 0;if("\t"==d[0]){var y=e.cm.options.tabSize,b=y-e.col%y;(m=a.appendChild(n("span",p(b),"cm-tab"))).setAttribute("role","presentation"),m.setAttribute("cm-text","\t"),e.col+=b}else"\r"==d[0]||"\n"==d[0]?((m=a.appendChild(n("span","\r"==d[0]?"␍":"␤","cm-invalidchar"))).setAttribute("cm-text",d[0]),e.col+=1):((m=e.cm.options.specialCharPlaceholder(d[0])).setAttribute("cm-text",d[0]),gl&&vl<9?a.appendChild(n("span",[m])):a.appendChild(m),e.col+=1);e.map.push(e.pos,e.pos+1,m),e.pos++}}else e.col+=t.length,a=document.createTextNode(u),e.map.push(e.pos,e.pos+t.length,a),gl&&vl<9&&(f=!0),e.pos+=t.length;if(e.trailingSpace=32==u.charCodeAt(t.length-1),r||i||o||f||s){var w=r||"";i&&(w+=i),o&&(w+=o);var x=n("span",[a],w,s);return l&&(x.title=l),e.content.appendChild(x)}e.content.appendChild(a)}}function ct(e,t){if(e.length>1&&!/  /.test(e))return e;for(var r=t,n="",i=0;i<e.length;i++){var o=e.charAt(i);" "!=o||!r||i!=e.length-1&&32!=e.charCodeAt(i+1)||(o=" "),n+=o,r=" "==o}return n}function ft(e,t){return function(r,n,i,o,l,s,a){i=i?i+" cm-force-border":"cm-force-border";for(var u=r.pos,c=u+n.length;;){for(var f=void 0,h=0;h<t.length&&!((f=t[h]).to>u&&f.from<=u);h++);if(f.to>=c)return e(r,n,i,o,l,s,a);e(r,n.slice(0,f.to-u),i,o,null,s,a),o=null,n=n.slice(f.to-u),u=f.to}}}function ht(e,t,r,n){var i=!n&&r.widgetNode;i&&e.map.push(e.pos,e.pos+t,i),!n&&e.cm.display.input.needsContentAttribute&&(i||(i=e.content.appendChild(document.createElement("span"))),i.setAttribute("cm-marker",r.id)),i&&(e.cm.display.input.setUneditable(i),e.content.appendChild(i)),e.pos+=t,e.trailingSpace=!1}function dt(e,t,r){var n=e.markedSpans,i=e.text,o=0;if(n)for(var l,s,a,u,c,f,h,d=i.length,p=0,g=1,v="",m=0;;){if(m==p){a=u=c=f=s="",h=null,m=1/0;for(var y=[],b=void 0,w=0;w<n.length;++w){var x=n[w],C=x.marker;"bookmark"==C.type&&x.from==p&&C.widgetNode?y.push(C):x.from<=p&&(null==x.to||x.to>p||C.collapsed&&x.to==p&&x.from==p)?(null!=x.to&&x.to!=p&&m>x.to&&(m=x.to,u=""),C.className&&(a+=" "+C.className),C.css&&(s=(s?s+";":"")+C.css),C.startStyle&&x.from==p&&(c+=" "+C.startStyle),C.endStyle&&x.to==m&&(b||(b=[])).push(C.endStyle,x.to),C.title&&!f&&(f=C.title),C.collapsed&&(!h||le(h.marker,C)<0)&&(h=x)):x.from>p&&m>x.from&&(m=x.from)}if(b)for(var S=0;S<b.length;S+=2)b[S+1]==m&&(u+=" "+b[S]);if(!h||h.from==p)for(var L=0;L<y.length;++L)ht(t,0,y[L]);if(h&&(h.from||0)==p){if(ht(t,(null==h.to?d+1:h.to)-p,h.marker,null==h.from),null==h.to)return;h.to==p&&(h=!1)}}if(p>=d)break;for(var k=Math.min(d,m);;){if(v){var T=p+v.length;if(!h){var M=T>k?v.slice(0,k-p):v;t.addToken(t,M,l?l+a:a,c,p+M.length==m?u:"",f,s)}if(T>=k){v=v.slice(k-p),p=k;break}p=T,c=""}v=i.slice(o,o=r[g++]),l=lt(r[g++],t.cm.options)}}else for(var N=1;N<r.length;N+=2)t.addToken(t,i.slice(o,o=r[N]),lt(r[N+1],t.cm.options))}function pt(e,t,r){this.line=t,this.rest=de(t),this.size=this.rest?W(g(this.rest))-r+1:1,this.node=this.text=null,this.hidden=ve(e,t)}function gt(e,t,r){for(var n,i=[],o=t;o<r;o=n){var l=new pt(e.doc,M(e.doc,o),o);n=o+l.size,i.push(l)}return i}function vt(e){gs?gs.ops.push(e):e.ownsGroup=gs={ops:[e],delayedCallbacks:[]}}function mt(e){var t=e.delayedCallbacks,r=0;do{for(;r<t.length;r++)t[r].call(null);for(var n=0;n<e.ops.length;n++){var i=e.ops[n];if(i.cursorActivityHandlers)for(;i.cursorActivityCalled<i.cursorActivityHandlers.length;)i.cursorActivityHandlers[i.cursorActivityCalled++].call(null,i.cm)}}while(r<t.length)}function yt(e,t){var r=e.ownsGroup;if(r)try{mt(r)}finally{gs=null,t(r)}}function bt(e,t){var r=Le(e,t);if(r.length){var n,i=Array.prototype.slice.call(arguments,2);gs?n=gs.delayedCallbacks:vs?n=vs:(n=vs=[],setTimeout(wt,0));for(var o=0;o<r.length;++o)!function(e){n.push(function(){return r[e].apply(null,i)})}(o)}}function wt(){var e=vs;vs=null;for(var t=0;t<e.length;++t)e[t]()}function xt(e,t,r,n){for(var i=0;i<t.changes.length;i++){var o=t.changes[i];"text"==o?kt(e,t):"gutter"==o?Mt(e,t,r,n):"class"==o?Tt(e,t):"widget"==o&&Nt(e,t,n)}t.changes=null}function Ct(e){return e.node==e.text&&(e.node=n("div",null,null,"position: relative"),e.text.parentNode&&e.text.parentNode.replaceChild(e.node,e.text),e.node.appendChild(e.text),gl&&vl<8&&(e.node.style.zIndex=2)),e.node}function St(e,t){var r=t.bgClass?t.bgClass+" "+(t.line.bgClass||""):t.line.bgClass;if(r&&(r+=" CodeMirror-linebackground"),t.background)r?t.background.className=r:(t.background.parentNode.removeChild(t.background),t.background=null);else if(r){var i=Ct(t);t.background=i.insertBefore(n("div",null,r),i.firstChild),e.display.input.setUneditable(t.background)}}function Lt(e,t){var r=e.display.externalMeasured;return r&&r.line==t.line?(e.display.externalMeasured=null,t.measure=r.measure,r.built):st(e,t)}function kt(e,t){var r=t.text.className,n=Lt(e,t);t.text==t.node&&(t.node=n.pre),t.text.parentNode.replaceChild(n.pre,t.text),t.text=n.pre,n.bgClass!=t.bgClass||n.textClass!=t.textClass?(t.bgClass=n.bgClass,t.textClass=n.textClass,Tt(e,t)):r&&(t.text.className=r)}function Tt(e,t){St(e,t),t.line.wrapClass?Ct(t).className=t.line.wrapClass:t.node!=t.text&&(t.node.className="");var r=t.textClass?t.textClass+" "+(t.line.textClass||""):t.line.textClass;t.text.className=r||""}function Mt(e,t,r,i){if(t.gutter&&(t.node.removeChild(t.gutter),t.gutter=null),t.gutterBackground&&(t.node.removeChild(t.gutterBackground),t.gutterBackground=null),t.line.gutterClass){var o=Ct(t);t.gutterBackground=n("div",null,"CodeMirror-gutter-background "+t.line.gutterClass,"left: "+(e.options.fixedGutter?i.fixedPos:-i.gutterTotalWidth)+"px; width: "+i.gutterTotalWidth+"px"),e.display.input.setUneditable(t.gutterBackground),o.insertBefore(t.gutterBackground,t.text)}var l=t.line.gutterMarkers;if(e.options.lineNumbers||l){var s=Ct(t),a=t.gutter=n("div",null,"CodeMirror-gutter-wrapper","left: "+(e.options.fixedGutter?i.fixedPos:-i.gutterTotalWidth)+"px");if(e.display.input.setUneditable(a),s.insertBefore(a,t.text),t.line.gutterClass&&(a.className+=" "+t.line.gutterClass),!e.options.lineNumbers||l&&l["CodeMirror-linenumbers"]||(t.lineNumber=a.appendChild(n("div",F(e.options,r),"CodeMirror-linenumber CodeMirror-gutter-elt","left: "+i.gutterLeft["CodeMirror-linenumbers"]+"px; width: "+e.display.lineNumInnerWidth+"px"))),l)for(var u=0;u<e.options.gutters.length;++u){var c=e.options.gutters[u],f=l.hasOwnProperty(c)&&l[c];f&&a.appendChild(n("div",[f],"CodeMirror-gutter-elt","left: "+i.gutterLeft[c]+"px; width: "+i.gutterWidth[c]+"px"))}}}function Nt(e,t,r){t.alignable&&(t.alignable=null);for(var n=t.node.firstChild,i=void 0;n;n=i)i=n.nextSibling,"CodeMirror-linewidget"==n.className&&t.node.removeChild(n);At(e,t,r)}function Ot(e,t,r,n){var i=Lt(e,t);return t.text=t.node=i.pre,i.bgClass&&(t.bgClass=i.bgClass),i.textClass&&(t.textClass=i.textClass),Tt(e,t),Mt(e,t,r,n),At(e,t,n),t.node}function At(e,t,r){if(Wt(e,t.line,t,r,!0),t.rest)for(var n=0;n<t.rest.length;n++)Wt(e,t.rest[n],t,r,!1)}function Wt(e,t,r,i,o){if(t.widgets)for(var l=Ct(r),s=0,a=t.widgets;s<a.length;++s){var u=a[s],c=n("div",[u.node],"CodeMirror-linewidget");u.handleMouseEvents||c.setAttribute("cm-ignore-events","true"),Dt(u,c,r,i),e.display.input.setUneditable(c),o&&u.above?l.insertBefore(c,r.gutter||r.text):l.appendChild(c),bt(u,"redraw")}}function Dt(e,t,r,n){if(e.noHScroll){(r.alignable||(r.alignable=[])).push(t);var i=n.wrapperWidth;t.style.left=n.fixedPos+"px",e.coverGutter||(i-=n.gutterTotalWidth,t.style.paddingLeft=n.gutterTotalWidth+"px"),t.style.width=i+"px"}e.coverGutter&&(t.style.zIndex=5,t.style.position="relative",e.noHScroll||(t.style.marginLeft=-n.gutterTotalWidth+"px"))}function Ht(e){if(null!=e.height)return e.height;var t=e.doc.cm;if(!t)return 0;if(!o(document.body,e.node)){var i="position: relative;";e.coverGutter&&(i+="margin-left: -"+t.display.gutters.offsetWidth+"px;"),e.noHScroll&&(i+="width: "+t.display.wrapper.clientWidth+"px;"),r(t.display.measure,n("div",[e.node],null,i))}return e.height=e.node.parentNode.offsetHeight}function Ft(e,t){for(var r=Ee(t);r!=e.wrapper;r=r.parentNode)if(!r||1==r.nodeType&&"true"==r.getAttribute("cm-ignore-events")||r.parentNode==e.sizer&&r!=e.mover)return!0}function Et(e){return e.lineSpace.offsetTop}function Pt(e){return e.mover.offsetHeight-e.lineSpace.offsetHeight}function It(e){if(e.cachedPaddingH)return e.cachedPaddingH;var t=r(e.measure,n("pre","x")),i=window.getComputedStyle?window.getComputedStyle(t):t.currentStyle,o={left:parseInt(i.paddingLeft),right:parseInt(i.paddingRight)};return isNaN(o.left)||isNaN(o.right)||(e.cachedPaddingH=o),o}function zt(e){return Rl-e.display.nativeBarWidth}function Rt(e){return e.display.scroller.clientWidth-zt(e)-e.display.barWidth}function Bt(e){return e.display.scroller.clientHeight-zt(e)-e.display.barHeight}function Gt(e,t,r){var n=e.options.lineWrapping,i=n&&Rt(e);if(!t.measure.heights||n&&t.measure.width!=i){var o=t.measure.heights=[];if(n){t.measure.width=i;for(var l=t.text.firstChild.getClientRects(),s=0;s<l.length-1;s++){var a=l[s],u=l[s+1];Math.abs(a.bottom-u.bottom)>2&&o.push((a.bottom+u.top)/2-r.top)}}o.push(r.bottom-r.top)}}function Ut(e,t,r){if(e.line==t)return{map:e.measure.map,cache:e.measure.cache};for(var n=0;n<e.rest.length;n++)if(e.rest[n]==t)return{map:e.measure.maps[n],cache:e.measure.caches[n]};for(var i=0;i<e.rest.length;i++)if(W(e.rest[i])>r)return{map:e.measure.maps[i],cache:e.measure.caches[i],before:!0}}function Vt(e,t){var n=W(t=fe(t)),i=e.display.externalMeasured=new pt(e.doc,t,n);i.lineN=n;var o=i.built=st(e,i);return i.text=o.pre,r(e.display.lineMeasure,o.pre),i}function Kt(e,t,r,n){return Yt(e,Xt(e,t),r,n)}function jt(e,t){if(t>=e.display.viewFrom&&t<e.display.viewTo)return e.display.view[Lr(e,t)];var r=e.display.externalMeasured;return r&&t>=r.lineN&&t<r.lineN+r.size?r:void 0}function Xt(e,t){var r=W(t),n=jt(e,r);n&&!n.text?n=null:n&&n.changes&&(xt(e,n,r,br(e)),e.curOp.forceUpdate=!0),n||(n=Vt(e,t));var i=Ut(n,t,r);return{line:t,view:n,rect:null,map:i.map,cache:i.cache,before:i.before,hasHeights:!1}}function Yt(e,t,r,n,i){t.before&&(r=-1);var o,l=r+(n||"");return t.cache.hasOwnProperty(l)?o=t.cache[l]:(t.rect||(t.rect=t.view.text.getBoundingClientRect()),t.hasHeights||(Gt(e,t.view,t.rect),t.hasHeights=!0),(o=qt(e,t,r,n)).bogus||(t.cache[l]=o)),{left:o.left,right:o.right,top:i?o.rtop:o.top,bottom:i?o.rbottom:o.bottom}}function _t(e,t,r){for(var n,i,o,l,s,a,u=0;u<e.length;u+=3)if(s=e[u],a=e[u+1],t<s?(i=0,o=1,l="left"):t<a?o=(i=t-s)+1:(u==e.length-3||t==a&&e[u+3]>t)&&(i=(o=a-s)-1,t>=a&&(l="right")),null!=i){if(n=e[u+2],s==a&&r==(n.insertLeft?"left":"right")&&(l=r),"left"==r&&0==i)for(;u&&e[u-2]==e[u-3]&&e[u-1].insertLeft;)n=e[2+(u-=3)],l="left";if("right"==r&&i==a-s)for(;u<e.length-3&&e[u+3]==e[u+4]&&!e[u+5].insertLeft;)n=e[(u+=3)+2],l="right";break}return{node:n,start:i,end:o,collapse:l,coverStart:s,coverEnd:a}}function $t(e,t){var r=ms;if("left"==t)for(var n=0;n<e.length&&(r=e[n]).left==r.right;n++);else for(var i=e.length-1;i>=0&&(r=e[i]).left==r.right;i--);return r}function qt(e,t,r,n){var i,o=_t(t.map,r,n),l=o.node,s=o.start,a=o.end,u=o.collapse;if(3==l.nodeType){for(var c=0;c<4;c++){for(;s&&S(t.line.text.charAt(o.coverStart+s));)--s;for(;o.coverStart+a<o.coverEnd&&S(t.line.text.charAt(o.coverStart+a));)++a;if((i=gl&&vl<9&&0==s&&a==o.coverEnd-o.coverStart?l.parentNode.getBoundingClientRect():$t(Wl(l,s,a).getClientRects(),n)).left||i.right||0==s)break;a=s,s-=1,u="right"}gl&&vl<11&&(i=Zt(e.display.measure,i))}else{s>0&&(u=n="right");var f;i=e.options.lineWrapping&&(f=l.getClientRects()).length>1?f["right"==n?f.length-1:0]:l.getBoundingClientRect()}if(gl&&vl<9&&!s&&(!i||!i.left&&!i.right)){var h=l.parentNode.getClientRects()[0];i=h?{left:h.left,right:h.left+yr(e.display),top:h.top,bottom:h.bottom}:ms}for(var d=i.top-t.rect.top,p=i.bottom-t.rect.top,g=(d+p)/2,v=t.view.measure.heights,m=0;m<v.length-1&&!(g<v[m]);m++);var y=m?v[m-1]:0,b=v[m],w={left:("right"==u?i.right:i.left)-t.rect.left,right:("left"==u?i.left:i.right)-t.rect.left,top:y,bottom:b};return i.left||i.right||(w.bogus=!0),e.options.singleCursorHeightPerLine||(w.rtop=d,w.rbottom=p),w}function Zt(e,t){if(!window.screen||null==screen.logicalXDPI||screen.logicalXDPI==screen.deviceXDPI||!Re(e))return t;var r=screen.logicalXDPI/screen.deviceXDPI,n=screen.logicalYDPI/screen.deviceYDPI;return{left:t.left*r,right:t.right*r,top:t.top*n,bottom:t.bottom*n}}function Qt(e){if(e.measure&&(e.measure.cache={},e.measure.heights=null,e.rest))for(var t=0;t<e.rest.length;t++)e.measure.caches[t]={}}function Jt(e){e.display.externalMeasure=null,t(e.display.lineMeasure);for(var r=0;r<e.display.view.length;r++)Qt(e.display.view[r])}function er(e){Jt(e),e.display.cachedCharWidth=e.display.cachedTextHeight=e.display.cachedPaddingH=null,e.options.lineWrapping||(e.display.maxLineChanged=!0),e.display.lineNumChars=null}function tr(){return bl&&kl?-(document.body.getBoundingClientRect().left-parseInt(getComputedStyle(document.body).marginLeft)):window.pageXOffset||(document.documentElement||document.body).scrollLeft}function rr(){return bl&&kl?-(document.body.getBoundingClientRect().top-parseInt(getComputedStyle(document.body).marginTop)):window.pageYOffset||(document.documentElement||document.body).scrollTop}function nr(e){var t=0;if(e.widgets)for(var r=0;r<e.widgets.length;++r)e.widgets[r].above&&(t+=Ht(e.widgets[r]));return t}function ir(e,t,r,n,i){if(!i){var o=nr(t);r.top+=o,r.bottom+=o}if("line"==n)return r;n||(n="local");var l=ye(t);if("local"==n?l+=Et(e.display):l-=e.display.viewOffset,"page"==n||"window"==n){var s=e.display.lineSpace.getBoundingClientRect();l+=s.top+("window"==n?0:rr());var a=s.left+("window"==n?0:tr());r.left+=a,r.right+=a}return r.top+=l,r.bottom+=l,r}function or(e,t,r){if("div"==r)return t;var n=t.left,i=t.top;if("page"==r)n-=tr(),i-=rr();else if("local"==r||!r){var o=e.display.sizer.getBoundingClientRect();n+=o.left,i+=o.top}var l=e.display.lineSpace.getBoundingClientRect();return{left:n-l.left,top:i-l.top}}function lr(e,t,r,n,i){return n||(n=M(e.doc,t.line)),ir(e,n,Kt(e,n,t.ch,i),r)}function sr(e,t,r,n,i,o){function l(t,l){var s=Yt(e,i,t,l?"right":"left",o);return l?s.left=s.right:s.right=s.left,ir(e,n,s,r)}function s(e,t,r){var n=1==a[t].level;return l(r?e-1:e,n!=r)}n=n||M(e.doc,t.line),i||(i=Xt(e,n));var a=Se(n,e.doc.direction),u=t.ch,c=t.sticky;if(u>=n.text.length?(u=n.text.length,c="before"):u<=0&&(u=0,c="after"),!a)return l("before"==c?u-1:u,"before"==c);var f=Ce(a,u,c),h=$l,d=s(u,f,"before"==c);return null!=h&&(d.other=s(u,h,"before"!=c)),d}function ar(e,t){var r=0;t=U(e.doc,t),e.options.lineWrapping||(r=yr(e.display)*t.ch);var n=M(e.doc,t.line),i=ye(n)+Et(e.display);return{left:r,right:r,top:i,bottom:i+n.height}}function ur(e,t,r,n,i){var o=E(e,t,r);return o.xRel=i,n&&(o.outside=!0),o}function cr(e,t,r){var n=e.doc;if((r+=e.display.viewOffset)<0)return ur(n.first,0,null,!0,-1);var i=D(n,r),o=n.first+n.size-1;if(i>o)return ur(n.first+n.size-1,M(n,o).text.length,null,!0,1);t<0&&(t=0);for(var l=M(n,i);;){var s=pr(e,l,i,t,r),a=ue(l),u=a&&a.find(0,!0);if(!a||!(s.ch>u.from.ch||s.ch==u.from.ch&&s.xRel>0))return s;i=W(l=u.to.line)}}function fr(e,t,r,n){n-=nr(t);var i=t.text.length,o=k(function(t){return Yt(e,r,t-1).bottom<=n},i,0);return i=k(function(t){return Yt(e,r,t).top>n},o,i),{begin:o,end:i}}function hr(e,t,r,n){return r||(r=Xt(e,t)),fr(e,t,r,ir(e,t,Yt(e,r,n),"line").top)}function dr(e,t,r,n){return!(e.bottom<=r)&&(e.top>r||(n?e.left:e.right)>t)}function pr(e,t,r,n,i){i-=ye(t);var o=Xt(e,t),l=nr(t),s=0,a=t.text.length,u=!0,c=Se(t,e.doc.direction);if(c){var f=(e.options.lineWrapping?vr:gr)(e,t,r,o,c,n,i);s=(u=1!=f.level)?f.from:f.to-1,a=u?f.to:f.from-1}var h,d,p=null,g=null,v=k(function(t){var r=Yt(e,o,t);return r.top+=l,r.bottom+=l,!!dr(r,n,i,!1)&&(r.top<=i&&r.left<=n&&(p=t,g=r),!0)},s,a),m=!1;if(g){var y=n-g.left<g.right-n,b=y==u;v=p+(b?0:1),d=b?"after":"before",h=y?g.left:g.right}else{u||v!=a&&v!=s||v++,d=0==v?"after":v==t.text.length?"before":Yt(e,o,v-(u?1:0)).bottom+l<=i==u?"after":"before";var w=sr(e,E(r,v,d),"line",t,o);h=w.left,m=i<w.top||i>=w.bottom}return v=L(t.text,v,1),ur(r,v,d,m,n-h)}function gr(e,t,r,n,i,o,l){var s=k(function(s){var a=i[s],u=1!=a.level;return dr(sr(e,E(r,u?a.to:a.from,u?"before":"after"),"line",t,n),o,l,!0)},0,i.length-1),a=i[s];if(s>0){var u=1!=a.level,c=sr(e,E(r,u?a.from:a.to,u?"after":"before"),"line",t,n);dr(c,o,l,!0)&&c.top>l&&(a=i[s-1])}return a}function vr(e,t,r,n,i,o,l){for(var s=fr(e,t,n,l),a=s.begin,u=s.end,c=null,f=null,h=0;h<i.length;h++){var d=i[h];if(!(d.from>=u||d.to<=a)){var p=Yt(e,n,1!=d.level?Math.min(u,d.to)-1:Math.max(a,d.from)).right,g=p<o?o-p+1e9:p-o;(!c||f>g)&&(c=d,f=g)}}return c||(c=i[i.length-1]),c.from<a&&(c={from:a,to:c.to,level:c.level}),c.to>u&&(c={from:c.from,to:u,level:c.level}),c}function mr(e){if(null!=e.cachedTextHeight)return e.cachedTextHeight;if(null==hs){hs=n("pre");for(var i=0;i<49;++i)hs.appendChild(document.createTextNode("x")),hs.appendChild(n("br"));hs.appendChild(document.createTextNode("x"))}r(e.measure,hs);var o=hs.offsetHeight/50;return o>3&&(e.cachedTextHeight=o),t(e.measure),o||1}function yr(e){if(null!=e.cachedCharWidth)return e.cachedCharWidth;var t=n("span","xxxxxxxxxx"),i=n("pre",[t]);r(e.measure,i);var o=t.getBoundingClientRect(),l=(o.right-o.left)/10;return l>2&&(e.cachedCharWidth=l),l||10}function br(e){for(var t=e.display,r={},n={},i=t.gutters.clientLeft,o=t.gutters.firstChild,l=0;o;o=o.nextSibling,++l)r[e.options.gutters[l]]=o.offsetLeft+o.clientLeft+i,n[e.options.gutters[l]]=o.clientWidth;return{fixedPos:wr(t),gutterTotalWidth:t.gutters.offsetWidth,gutterLeft:r,gutterWidth:n,wrapperWidth:t.wrapper.clientWidth}}function wr(e){return e.scroller.getBoundingClientRect().left-e.sizer.getBoundingClientRect().left}function xr(e){var t=mr(e.display),r=e.options.lineWrapping,n=r&&Math.max(5,e.display.scroller.clientWidth/yr(e.display)-3);return function(i){if(ve(e.doc,i))return 0;var o=0;if(i.widgets)for(var l=0;l<i.widgets.length;l++)i.widgets[l].height&&(o+=i.widgets[l].height);return r?o+(Math.ceil(i.text.length/n)||1)*t:o+t}}function Cr(e){var t=e.doc,r=xr(e);t.iter(function(e){var t=r(e);t!=e.height&&A(e,t)})}function Sr(e,t,r,n){var i=e.display;if(!r&&"true"==Ee(t).getAttribute("cm-not-content"))return null;var o,l,s=i.lineSpace.getBoundingClientRect();try{o=t.clientX-s.left,l=t.clientY-s.top}catch(t){return null}var a,u=cr(e,o,l);if(n&&1==u.xRel&&(a=M(e.doc,u.line).text).length==u.ch){var c=f(a,a.length,e.options.tabSize)-a.length;u=E(u.line,Math.max(0,Math.round((o-It(e.display).left)/yr(e.display))-c))}return u}function Lr(e,t){if(t>=e.display.viewTo)return null;if((t-=e.display.viewFrom)<0)return null;for(var r=e.display.view,n=0;n<r.length;n++)if((t-=r[n].size)<0)return n}function kr(e){e.display.input.showSelection(e.display.input.prepareSelection())}function Tr(e,t){void 0===t&&(t=!0);for(var r=e.doc,n={},i=n.cursors=document.createDocumentFragment(),o=n.selection=document.createDocumentFragment(),l=0;l<r.sel.ranges.length;l++)if(t||l!=r.sel.primIndex){var s=r.sel.ranges[l];if(!(s.from().line>=e.display.viewTo||s.to().line<e.display.viewFrom)){var a=s.empty();(a||e.options.showCursorWhenSelecting)&&Mr(e,s.head,i),a||Or(e,s,o)}}return n}function Mr(e,t,r){var i=sr(e,t,"div",null,null,!e.options.singleCursorHeightPerLine),o=r.appendChild(n("div"," ","CodeMirror-cursor"));if(o.style.left=i.left+"px",o.style.top=i.top+"px",o.style.height=Math.max(0,i.bottom-i.top)*e.options.cursorHeight+"px",i.other){var l=r.appendChild(n("div"," ","CodeMirror-cursor CodeMirror-secondarycursor"));l.style.display="",l.style.left=i.other.left+"px",l.style.top=i.other.top+"px",l.style.height=.85*(i.other.bottom-i.other.top)+"px"}}function Nr(e,t){return e.top-t.top||e.left-t.left}function Or(e,t,r){function i(e,t,r,i){t<0&&(t=0),t=Math.round(t),i=Math.round(i),a.appendChild(n("div",null,"CodeMirror-selected","position: absolute; left: "+e+"px;\n                             top: "+t+"px; width: "+(null==r?f-e:r)+"px;\n                             height: "+(i-t)+"px"))}function o(t,r,n){function o(r,n){return lr(e,E(t,r),"div",u,n)}var l,a,u=M(s,t),h=u.text.length,d=Se(u,s.direction);return xe(d,r||0,null==n?h:n,function(t,s,p,g){var v=o(t,"ltr"==p?"left":"right"),m=o(s-1,"ltr"==p?"right":"left");if("ltr"==p){var y=null==r&&0==t?c:v.left,b=null==n&&s==h?f:m.right;m.top-v.top<=3?i(y,m.top,b-y,m.bottom):(i(y,v.top,null,v.bottom),v.bottom<m.top&&i(c,v.bottom,null,m.top),i(c,m.top,m.right,m.bottom))}else if(t<s){var w=null==r&&0==t?f:v.right,x=null==n&&s==h?c:m.left;if(m.top-v.top<=3)i(x,m.top,w-x,m.bottom);else{var C=c;if(g){var S=hr(e,u,null,t).end;C=o(S-(/\s/.test(u.text.charAt(S-1))?2:1),"left").left}i(C,v.top,w-C,v.bottom),v.bottom<m.top&&i(c,v.bottom,null,m.top);var L=null;d.length,L=o(hr(e,u,null,s).begin,"right").right-x,i(x,m.top,L,m.bottom)}}(!l||Nr(v,l)<0)&&(l=v),Nr(m,l)<0&&(l=m),(!a||Nr(v,a)<0)&&(a=v),Nr(m,a)<0&&(a=m)}),{start:l,end:a}}var l=e.display,s=e.doc,a=document.createDocumentFragment(),u=It(e.display),c=u.left,f=Math.max(l.sizerWidth,Rt(e)-l.sizer.offsetLeft)-u.right,h=t.from(),d=t.to();if(h.line==d.line)o(h.line,h.ch,d.ch);else{var p=M(s,h.line),g=M(s,d.line),v=fe(p)==fe(g),m=o(h.line,h.ch,v?p.text.length+1:null).end,y=o(d.line,v?0:null,d.ch).start;v&&(m.top<y.top-2?(i(m.right,m.top,null,m.bottom),i(c,y.top,y.left,y.bottom)):i(m.right,m.top,y.left-m.right,m.bottom)),m.bottom<y.top&&i(c,m.bottom,null,y.top)}r.appendChild(a)}function Ar(e){if(e.state.focused){var t=e.display;clearInterval(t.blinker);var r=!0;t.cursorDiv.style.visibility="",e.options.cursorBlinkRate>0?t.blinker=setInterval(function(){return t.cursorDiv.style.visibility=(r=!r)?"":"hidden"},e.options.cursorBlinkRate):e.options.cursorBlinkRate<0&&(t.cursorDiv.style.visibility="hidden")}}function Wr(e){e.state.focused||(e.display.input.focus(),Hr(e))}function Dr(e){e.state.delayingBlurEvent=!0,setTimeout(function(){e.state.delayingBlurEvent&&(e.state.delayingBlurEvent=!1,Fr(e))},100)}function Hr(e,t){e.state.delayingBlurEvent&&(e.state.delayingBlurEvent=!1),"nocursor"!=e.options.readOnly&&(e.state.focused||(Te(e,"focus",e,t),e.state.focused=!0,s(e.display.wrapper,"CodeMirror-focused"),e.curOp||e.display.selForContextMenu==e.doc.sel||(e.display.input.reset(),ml&&setTimeout(function(){return e.display.input.reset(!0)},20)),e.display.input.receivedFocus()),Ar(e))}function Fr(e,t){e.state.delayingBlurEvent||(e.state.focused&&(Te(e,"blur",e,t),e.state.focused=!1,Fl(e.display.wrapper,"CodeMirror-focused")),clearInterval(e.display.blinker),setTimeout(function(){e.state.focused||(e.display.shift=!1)},150))}function Er(e){for(var t=e.display,r=t.lineDiv.offsetTop,n=0;n<t.view.length;n++){var i=t.view[n],o=void 0;if(!i.hidden){if(gl&&vl<8){var l=i.node.offsetTop+i.node.offsetHeight;o=l-r,r=l}else{var s=i.node.getBoundingClientRect();o=s.bottom-s.top}var a=i.line.height-o;if(o<2&&(o=mr(t)),(a>.005||a<-.005)&&(A(i.line,o),Pr(i.line),i.rest))for(var u=0;u<i.rest.length;u++)Pr(i.rest[u])}}}function Pr(e){if(e.widgets)for(var t=0;t<e.widgets.length;++t)e.widgets[t].height=e.widgets[t].node.parentNode.offsetHeight}function Ir(e,t,r){var n=r&&null!=r.top?Math.max(0,r.top):e.scroller.scrollTop;n=Math.floor(n-Et(e));var i=r&&null!=r.bottom?r.bottom:n+e.wrapper.clientHeight,o=D(t,n),l=D(t,i);if(r&&r.ensure){var s=r.ensure.from.line,a=r.ensure.to.line;s<o?(o=s,l=D(t,ye(M(t,s))+e.wrapper.clientHeight)):Math.min(a,t.lastLine())>=l&&(o=D(t,ye(M(t,a))-e.wrapper.clientHeight),l=a)}return{from:o,to:Math.max(l,o+1)}}function zr(e){var t=e.display,r=t.view;if(t.alignWidgets||t.gutters.firstChild&&e.options.fixedGutter){for(var n=wr(t)-t.scroller.scrollLeft+e.doc.scrollLeft,i=t.gutters.offsetWidth,o=n+"px",l=0;l<r.length;l++)if(!r[l].hidden){e.options.fixedGutter&&(r[l].gutter&&(r[l].gutter.style.left=o),r[l].gutterBackground&&(r[l].gutterBackground.style.left=o));var s=r[l].alignable;if(s)for(var a=0;a<s.length;a++)s[a].style.left=o}e.options.fixedGutter&&(t.gutters.style.left=n+i+"px")}}function Rr(e){if(!e.options.lineNumbers)return!1;var t=e.doc,r=F(e.options,t.first+t.size-1),i=e.display;if(r.length!=i.lineNumChars){var o=i.measure.appendChild(n("div",[n("div",r)],"CodeMirror-linenumber CodeMirror-gutter-elt")),l=o.firstChild.offsetWidth,s=o.offsetWidth-l;return i.lineGutter.style.width="",i.lineNumInnerWidth=Math.max(l,i.lineGutter.offsetWidth-s)+1,i.lineNumWidth=i.lineNumInnerWidth+s,i.lineNumChars=i.lineNumInnerWidth?r.length:-1,i.lineGutter.style.width=i.lineNumWidth+"px",Wn(e),!0}return!1}function Br(e,t){if(!Me(e,"scrollCursorIntoView")){var r=e.display,i=r.sizer.getBoundingClientRect(),o=null;if(t.top+i.top<0?o=!0:t.bottom+i.top>(window.innerHeight||document.documentElement.clientHeight)&&(o=!1),null!=o&&!Sl){var l=n("div","​",null,"position: absolute;\n                         top: "+(t.top-r.viewOffset-Et(e.display))+"px;\n                         height: "+(t.bottom-t.top+zt(e)+r.barHeight)+"px;\n                         left: "+t.left+"px; width: "+Math.max(2,t.right-t.left)+"px;");e.display.lineSpace.appendChild(l),l.scrollIntoView(o),e.display.lineSpace.removeChild(l)}}}function Gr(e,t,r,n){null==n&&(n=0);var i;e.options.lineWrapping||t!=r||(r="before"==(t=t.ch?E(t.line,"before"==t.sticky?t.ch-1:t.ch,"after"):t).sticky?E(t.line,t.ch+1,"before"):t);for(var o=0;o<5;o++){var l=!1,s=sr(e,t),a=r&&r!=t?sr(e,r):s,u=Vr(e,i={left:Math.min(s.left,a.left),top:Math.min(s.top,a.top)-n,right:Math.max(s.left,a.left),bottom:Math.max(s.bottom,a.bottom)+n}),c=e.doc.scrollTop,f=e.doc.scrollLeft;if(null!=u.scrollTop&&(qr(e,u.scrollTop),Math.abs(e.doc.scrollTop-c)>1&&(l=!0)),null!=u.scrollLeft&&(Qr(e,u.scrollLeft),Math.abs(e.doc.scrollLeft-f)>1&&(l=!0)),!l)break}return i}function Ur(e,t){var r=Vr(e,t);null!=r.scrollTop&&qr(e,r.scrollTop),null!=r.scrollLeft&&Qr(e,r.scrollLeft)}function Vr(e,t){var r=e.display,n=mr(e.display);t.top<0&&(t.top=0);var i=e.curOp&&null!=e.curOp.scrollTop?e.curOp.scrollTop:r.scroller.scrollTop,o=Bt(e),l={};t.bottom-t.top>o&&(t.bottom=t.top+o);var s=e.doc.height+Pt(r),a=t.top<n,u=t.bottom>s-n;if(t.top<i)l.scrollTop=a?0:t.top;else if(t.bottom>i+o){var c=Math.min(t.top,(u?s:t.bottom)-o);c!=i&&(l.scrollTop=c)}var f=e.curOp&&null!=e.curOp.scrollLeft?e.curOp.scrollLeft:r.scroller.scrollLeft,h=Rt(e)-(e.options.fixedGutter?r.gutters.offsetWidth:0),d=t.right-t.left>h;return d&&(t.right=t.left+h),t.left<10?l.scrollLeft=0:t.left<f?l.scrollLeft=Math.max(0,t.left-(d?0:10)):t.right>h+f-3&&(l.scrollLeft=t.right+(d?0:10)-h),l}function Kr(e,t){null!=t&&(_r(e),e.curOp.scrollTop=(null==e.curOp.scrollTop?e.doc.scrollTop:e.curOp.scrollTop)+t)}function jr(e){_r(e);var t=e.getCursor();e.curOp.scrollToPos={from:t,to:t,margin:e.options.cursorScrollMargin}}function Xr(e,t,r){null==t&&null==r||_r(e),null!=t&&(e.curOp.scrollLeft=t),null!=r&&(e.curOp.scrollTop=r)}function Yr(e,t){_r(e),e.curOp.scrollToPos=t}function _r(e){var t=e.curOp.scrollToPos;t&&(e.curOp.scrollToPos=null,$r(e,ar(e,t.from),ar(e,t.to),t.margin))}function $r(e,t,r,n){var i=Vr(e,{left:Math.min(t.left,r.left),top:Math.min(t.top,r.top)-n,right:Math.max(t.right,r.right),bottom:Math.max(t.bottom,r.bottom)+n});Xr(e,i.scrollLeft,i.scrollTop)}function qr(e,t){Math.abs(e.doc.scrollTop-t)<2||(fl||On(e,{top:t}),Zr(e,t,!0),fl&&On(e),Cn(e,100))}function Zr(e,t,r){t=Math.min(e.display.scroller.scrollHeight-e.display.scroller.clientHeight,t),(e.display.scroller.scrollTop!=t||r)&&(e.doc.scrollTop=t,e.display.scrollbars.setScrollTop(t),e.display.scroller.scrollTop!=t&&(e.display.scroller.scrollTop=t))}function Qr(e,t,r,n){t=Math.min(t,e.display.scroller.scrollWidth-e.display.scroller.clientWidth),(r?t==e.doc.scrollLeft:Math.abs(e.doc.scrollLeft-t)<2)&&!n||(e.doc.scrollLeft=t,zr(e),e.display.scroller.scrollLeft!=t&&(e.display.scroller.scrollLeft=t),e.display.scrollbars.setScrollLeft(t))}function Jr(e){var t=e.display,r=t.gutters.offsetWidth,n=Math.round(e.doc.height+Pt(e.display));return{clientHeight:t.scroller.clientHeight,viewHeight:t.wrapper.clientHeight,scrollWidth:t.scroller.scrollWidth,clientWidth:t.scroller.clientWidth,viewWidth:t.wrapper.clientWidth,barLeft:e.options.fixedGutter?r:0,docHeight:n,scrollHeight:n+zt(e)+t.barHeight,nativeBarWidth:t.nativeBarWidth,gutterWidth:r}}function en(e,t){t||(t=Jr(e));var r=e.display.barWidth,n=e.display.barHeight;tn(e,t);for(var i=0;i<4&&r!=e.display.barWidth||n!=e.display.barHeight;i++)r!=e.display.barWidth&&e.options.lineWrapping&&Er(e),tn(e,Jr(e)),r=e.display.barWidth,n=e.display.barHeight}function tn(e,t){var r=e.display,n=r.scrollbars.update(t);r.sizer.style.paddingRight=(r.barWidth=n.right)+"px",r.sizer.style.paddingBottom=(r.barHeight=n.bottom)+"px",r.heightForcer.style.borderBottom=n.bottom+"px solid transparent",n.right&&n.bottom?(r.scrollbarFiller.style.display="block",r.scrollbarFiller.style.height=n.bottom+"px",r.scrollbarFiller.style.width=n.right+"px"):r.scrollbarFiller.style.display="",n.bottom&&e.options.coverGutterNextToScrollbar&&e.options.fixedGutter?(r.gutterFiller.style.display="block",r.gutterFiller.style.height=n.bottom+"px",r.gutterFiller.style.width=t.gutterWidth+"px"):r.gutterFiller.style.display=""}function rn(e){e.display.scrollbars&&(e.display.scrollbars.clear(),e.display.scrollbars.addClass&&Fl(e.display.wrapper,e.display.scrollbars.addClass)),e.display.scrollbars=new ws[e.options.scrollbarStyle](function(t){e.display.wrapper.insertBefore(t,e.display.scrollbarFiller),Ql(t,"mousedown",function(){e.state.focused&&setTimeout(function(){return e.display.input.focus()},0)}),t.setAttribute("cm-not-content","true")},function(t,r){"horizontal"==r?Qr(e,t):qr(e,t)},e),e.display.scrollbars.addClass&&s(e.display.wrapper,e.display.scrollbars.addClass)}function nn(e){e.curOp={cm:e,viewChanged:!1,startHeight:e.doc.height,forceUpdate:!1,updateInput:null,typing:!1,changeObjs:null,cursorActivityHandlers:null,cursorActivityCalled:0,selectionChanged:!1,updateMaxLine:!1,scrollLeft:null,scrollTop:null,scrollToPos:null,focus:!1,id:++xs},vt(e.curOp)}function on(e){yt(e.curOp,function(e){for(var t=0;t<e.ops.length;t++)e.ops[t].cm.curOp=null;ln(e)})}function ln(e){for(var t=e.ops,r=0;r<t.length;r++)sn(t[r]);for(var n=0;n<t.length;n++)an(t[n]);for(var i=0;i<t.length;i++)un(t[i]);for(var o=0;o<t.length;o++)cn(t[o]);for(var l=0;l<t.length;l++)fn(t[l])}function sn(e){var t=e.cm,r=t.display;Ln(t),e.updateMaxLine&&we(t),e.mustUpdate=e.viewChanged||e.forceUpdate||null!=e.scrollTop||e.scrollToPos&&(e.scrollToPos.from.line<r.viewFrom||e.scrollToPos.to.line>=r.viewTo)||r.maxLineChanged&&t.options.lineWrapping,e.update=e.mustUpdate&&new Cs(t,e.mustUpdate&&{top:e.scrollTop,ensure:e.scrollToPos},e.forceUpdate)}function an(e){e.updatedDisplay=e.mustUpdate&&Mn(e.cm,e.update)}function un(e){var t=e.cm,r=t.display;e.updatedDisplay&&Er(t),e.barMeasure=Jr(t),r.maxLineChanged&&!t.options.lineWrapping&&(e.adjustWidthTo=Kt(t,r.maxLine,r.maxLine.text.length).left+3,t.display.sizerWidth=e.adjustWidthTo,e.barMeasure.scrollWidth=Math.max(r.scroller.clientWidth,r.sizer.offsetLeft+e.adjustWidthTo+zt(t)+t.display.barWidth),e.maxScrollLeft=Math.max(0,r.sizer.offsetLeft+e.adjustWidthTo-Rt(t))),(e.updatedDisplay||e.selectionChanged)&&(e.preparedSelection=r.input.prepareSelection())}function cn(e){var t=e.cm;null!=e.adjustWidthTo&&(t.display.sizer.style.minWidth=e.adjustWidthTo+"px",e.maxScrollLeft<t.doc.scrollLeft&&Qr(t,Math.min(t.display.scroller.scrollLeft,e.maxScrollLeft),!0),t.display.maxLineChanged=!1);var r=e.focus&&e.focus==l();e.preparedSelection&&t.display.input.showSelection(e.preparedSelection,r),(e.updatedDisplay||e.startHeight!=t.doc.height)&&en(t,e.barMeasure),e.updatedDisplay&&Dn(t,e.barMeasure),e.selectionChanged&&Ar(t),t.state.focused&&e.updateInput&&t.display.input.reset(e.typing),r&&Wr(e.cm)}function fn(e){var t=e.cm,r=t.display,n=t.doc;e.updatedDisplay&&Nn(t,e.update),null==r.wheelStartX||null==e.scrollTop&&null==e.scrollLeft&&!e.scrollToPos||(r.wheelStartX=r.wheelStartY=null),null!=e.scrollTop&&Zr(t,e.scrollTop,e.forceScroll),null!=e.scrollLeft&&Qr(t,e.scrollLeft,!0,!0),e.scrollToPos&&Br(t,Gr(t,U(n,e.scrollToPos.from),U(n,e.scrollToPos.to),e.scrollToPos.margin));var i=e.maybeHiddenMarkers,o=e.maybeUnhiddenMarkers;if(i)for(var l=0;l<i.length;++l)i[l].lines.length||Te(i[l],"hide");if(o)for(var s=0;s<o.length;++s)o[s].lines.length&&Te(o[s],"unhide");r.wrapper.offsetHeight&&(n.scrollTop=t.display.scroller.scrollTop),e.changeObjs&&Te(t,"changes",t,e.changeObjs),e.update&&e.update.finish()}function hn(e,t){if(e.curOp)return t();nn(e);try{return t()}finally{on(e)}}function dn(e,t){return function(){if(e.curOp)return t.apply(e,arguments);nn(e);try{return t.apply(e,arguments)}finally{on(e)}}}function pn(e){return function(){if(this.curOp)return e.apply(this,arguments);nn(this);try{return e.apply(this,arguments)}finally{on(this)}}}function gn(e){return function(){var t=this.cm;if(!t||t.curOp)return e.apply(this,arguments);nn(t);try{return e.apply(this,arguments)}finally{on(t)}}}function vn(e,t,r,n){null==t&&(t=e.doc.first),null==r&&(r=e.doc.first+e.doc.size),n||(n=0);var i=e.display;if(n&&r<i.viewTo&&(null==i.updateLineNumbers||i.updateLineNumbers>t)&&(i.updateLineNumbers=t),e.curOp.viewChanged=!0,t>=i.viewTo)_l&&pe(e.doc,t)<i.viewTo&&yn(e);else if(r<=i.viewFrom)_l&&ge(e.doc,r+n)>i.viewFrom?yn(e):(i.viewFrom+=n,i.viewTo+=n);else if(t<=i.viewFrom&&r>=i.viewTo)yn(e);else if(t<=i.viewFrom){var o=bn(e,r,r+n,1);o?(i.view=i.view.slice(o.index),i.viewFrom=o.lineN,i.viewTo+=n):yn(e)}else if(r>=i.viewTo){var l=bn(e,t,t,-1);l?(i.view=i.view.slice(0,l.index),i.viewTo=l.lineN):yn(e)}else{var s=bn(e,t,t,-1),a=bn(e,r,r+n,1);s&&a?(i.view=i.view.slice(0,s.index).concat(gt(e,s.lineN,a.lineN)).concat(i.view.slice(a.index)),i.viewTo+=n):yn(e)}var u=i.externalMeasured;u&&(r<u.lineN?u.lineN+=n:t<u.lineN+u.size&&(i.externalMeasured=null))}function mn(e,t,r){e.curOp.viewChanged=!0;var n=e.display,i=e.display.externalMeasured;if(i&&t>=i.lineN&&t<i.lineN+i.size&&(n.externalMeasured=null),!(t<n.viewFrom||t>=n.viewTo)){var o=n.view[Lr(e,t)];if(null!=o.node){var l=o.changes||(o.changes=[]);-1==h(l,r)&&l.push(r)}}}function yn(e){e.display.viewFrom=e.display.viewTo=e.doc.first,e.display.view=[],e.display.viewOffset=0}function bn(e,t,r,n){var i,o=Lr(e,t),l=e.display.view;if(!_l||r==e.doc.first+e.doc.size)return{index:o,lineN:r};for(var s=e.display.viewFrom,a=0;a<o;a++)s+=l[a].size;if(s!=t){if(n>0){if(o==l.length-1)return null;i=s+l[o].size-t,o++}else i=s-t;t+=i,r+=i}for(;pe(e.doc,r)!=r;){if(o==(n<0?0:l.length-1))return null;r+=n*l[o-(n<0?1:0)].size,o+=n}return{index:o,lineN:r}}function wn(e,t,r){var n=e.display;0==n.view.length||t>=n.viewTo||r<=n.viewFrom?(n.view=gt(e,t,r),n.viewFrom=t):(n.viewFrom>t?n.view=gt(e,t,n.viewFrom).concat(n.view):n.viewFrom<t&&(n.view=n.view.slice(Lr(e,t))),n.viewFrom=t,n.viewTo<r?n.view=n.view.concat(gt(e,n.viewTo,r)):n.viewTo>r&&(n.view=n.view.slice(0,Lr(e,r)))),n.viewTo=r}function xn(e){for(var t=e.display.view,r=0,n=0;n<t.length;n++){var i=t[n];i.hidden||i.node&&!i.changes||++r}return r}function Cn(e,t){e.doc.highlightFrontier<e.display.viewTo&&e.state.highlight.set(t,u(Sn,e))}function Sn(e){var t=e.doc;if(!(t.highlightFrontier>=e.display.viewTo)){var r=+new Date+e.options.workTime,n=$e(e,t.highlightFrontier),i=[];t.iter(n.line,Math.min(t.first+t.size,e.display.viewTo+500),function(o){if(n.line>=e.display.viewFrom){var l=o.styles,s=o.text.length>e.options.maxHighlightLength?Ke(t.mode,n.state):null,a=Ye(e,o,n,!0);s&&(n.state=s),o.styles=a.styles;var u=o.styleClasses,c=a.classes;c?o.styleClasses=c:u&&(o.styleClasses=null);for(var f=!l||l.length!=o.styles.length||u!=c&&(!u||!c||u.bgClass!=c.bgClass||u.textClass!=c.textClass),h=0;!f&&h<l.length;++h)f=l[h]!=o.styles[h];f&&i.push(n.line),o.stateAfter=n.save(),n.nextLine()}else o.text.length<=e.options.maxHighlightLength&&qe(e,o.text,n),o.stateAfter=n.line%5==0?n.save():null,n.nextLine();if(+new Date>r)return Cn(e,e.options.workDelay),!0}),t.highlightFrontier=n.line,t.modeFrontier=Math.max(t.modeFrontier,n.line),i.length&&hn(e,function(){for(var t=0;t<i.length;t++)mn(e,i[t],"text")})}}function Ln(e){var t=e.display;!t.scrollbarsClipped&&t.scroller.offsetWidth&&(t.nativeBarWidth=t.scroller.offsetWidth-t.scroller.clientWidth,t.heightForcer.style.height=zt(e)+"px",t.sizer.style.marginBottom=-t.nativeBarWidth+"px",t.sizer.style.borderRightWidth=zt(e)+"px",t.scrollbarsClipped=!0)}function kn(e){if(e.hasFocus())return null;var t=l();if(!t||!o(e.display.lineDiv,t))return null;var r={activeElt:t};if(window.getSelection){var n=window.getSelection();n.anchorNode&&n.extend&&o(e.display.lineDiv,n.anchorNode)&&(r.anchorNode=n.anchorNode,r.anchorOffset=n.anchorOffset,r.focusNode=n.focusNode,r.focusOffset=n.focusOffset)}return r}function Tn(e){if(e&&e.activeElt&&e.activeElt!=l()&&(e.activeElt.focus(),e.anchorNode&&o(document.body,e.anchorNode)&&o(document.body,e.focusNode))){var t=window.getSelection(),r=document.createRange();r.setEnd(e.anchorNode,e.anchorOffset),r.collapse(!1),t.removeAllRanges(),t.addRange(r),t.extend(e.focusNode,e.focusOffset)}}function Mn(e,r){var n=e.display,i=e.doc;if(r.editorIsHidden)return yn(e),!1;if(!r.force&&r.visible.from>=n.viewFrom&&r.visible.to<=n.viewTo&&(null==n.updateLineNumbers||n.updateLineNumbers>=n.viewTo)&&n.renderedView==n.view&&0==xn(e))return!1;Rr(e)&&(yn(e),r.dims=br(e));var o=i.first+i.size,l=Math.max(r.visible.from-e.options.viewportMargin,i.first),s=Math.min(o,r.visible.to+e.options.viewportMargin);n.viewFrom<l&&l-n.viewFrom<20&&(l=Math.max(i.first,n.viewFrom)),n.viewTo>s&&n.viewTo-s<20&&(s=Math.min(o,n.viewTo)),_l&&(l=pe(e.doc,l),s=ge(e.doc,s));var a=l!=n.viewFrom||s!=n.viewTo||n.lastWrapHeight!=r.wrapperHeight||n.lastWrapWidth!=r.wrapperWidth;wn(e,l,s),n.viewOffset=ye(M(e.doc,n.viewFrom)),e.display.mover.style.top=n.viewOffset+"px";var u=xn(e);if(!a&&0==u&&!r.force&&n.renderedView==n.view&&(null==n.updateLineNumbers||n.updateLineNumbers>=n.viewTo))return!1;var c=kn(e);return u>4&&(n.lineDiv.style.display="none"),An(e,n.updateLineNumbers,r.dims),u>4&&(n.lineDiv.style.display=""),n.renderedView=n.view,Tn(c),t(n.cursorDiv),t(n.selectionDiv),n.gutters.style.height=n.sizer.style.minHeight=0,a&&(n.lastWrapHeight=r.wrapperHeight,n.lastWrapWidth=r.wrapperWidth,Cn(e,400)),n.updateLineNumbers=null,!0}function Nn(e,t){for(var r=t.viewport,n=!0;(n&&e.options.lineWrapping&&t.oldDisplayWidth!=Rt(e)||(r&&null!=r.top&&(r={top:Math.min(e.doc.height+Pt(e.display)-Bt(e),r.top)}),t.visible=Ir(e.display,e.doc,r),!(t.visible.from>=e.display.viewFrom&&t.visible.to<=e.display.viewTo)))&&Mn(e,t);n=!1){Er(e);var i=Jr(e);kr(e),en(e,i),Dn(e,i),t.force=!1}t.signal(e,"update",e),e.display.viewFrom==e.display.reportedViewFrom&&e.display.viewTo==e.display.reportedViewTo||(t.signal(e,"viewportChange",e,e.display.viewFrom,e.display.viewTo),e.display.reportedViewFrom=e.display.viewFrom,e.display.reportedViewTo=e.display.viewTo)}function On(e,t){var r=new Cs(e,t);if(Mn(e,r)){Er(e),Nn(e,r);var n=Jr(e);kr(e),en(e,n),Dn(e,n),r.finish()}}function An(e,r,n){function i(t){var r=t.nextSibling;return ml&&Ml&&e.display.currentWheelTarget==t?t.style.display="none":t.parentNode.removeChild(t),r}for(var o=e.display,l=e.options.lineNumbers,s=o.lineDiv,a=s.firstChild,u=o.view,c=o.viewFrom,f=0;f<u.length;f++){var d=u[f];if(d.hidden);else if(d.node&&d.node.parentNode==s){for(;a!=d.node;)a=i(a);var p=l&&null!=r&&r<=c&&d.lineNumber;d.changes&&(h(d.changes,"gutter")>-1&&(p=!1),xt(e,d,c,n)),p&&(t(d.lineNumber),d.lineNumber.appendChild(document.createTextNode(F(e.options,c)))),a=d.node.nextSibling}else{var g=Ot(e,d,c,n);s.insertBefore(g,a)}c+=d.size}for(;a;)a=i(a)}function Wn(e){var t=e.display.gutters.offsetWidth;e.display.sizer.style.marginLeft=t+"px"}function Dn(e,t){e.display.sizer.style.minHeight=t.docHeight+"px",e.display.heightForcer.style.top=t.docHeight+"px",e.display.gutters.style.height=t.docHeight+e.display.barHeight+zt(e)+"px"}function Hn(e){var r=e.display.gutters,i=e.options.gutters;t(r);for(var o=0;o<i.length;++o){var l=i[o],s=r.appendChild(n("div",null,"CodeMirror-gutter "+l));"CodeMirror-linenumbers"==l&&(e.display.lineGutter=s,s.style.width=(e.display.lineNumWidth||1)+"px")}r.style.display=o?"":"none",Wn(e)}function Fn(e){var t=h(e.gutters,"CodeMirror-linenumbers");-1==t&&e.lineNumbers?e.gutters=e.gutters.concat(["CodeMirror-linenumbers"]):t>-1&&!e.lineNumbers&&(e.gutters=e.gutters.slice(0),e.gutters.splice(t,1))}function En(e){var t=e.wheelDeltaX,r=e.wheelDeltaY;return null==t&&e.detail&&e.axis==e.HORIZONTAL_AXIS&&(t=e.detail),null==r&&e.detail&&e.axis==e.VERTICAL_AXIS?r=e.detail:null==r&&(r=e.wheelDelta),{x:t,y:r}}function Pn(e){var t=En(e);return t.x*=Ls,t.y*=Ls,t}function In(e,t){var r=En(t),n=r.x,i=r.y,o=e.display,l=o.scroller,s=l.scrollWidth>l.clientWidth,a=l.scrollHeight>l.clientHeight;if(n&&s||i&&a){if(i&&Ml&&ml)e:for(var u=t.target,c=o.view;u!=l;u=u.parentNode)for(var f=0;f<c.length;f++)if(c[f].node==u){e.display.currentWheelTarget=u;break e}if(n&&!fl&&!wl&&null!=Ls)return i&&a&&qr(e,Math.max(0,l.scrollTop+i*Ls)),Qr(e,Math.max(0,l.scrollLeft+n*Ls)),(!i||i&&a)&&We(t),void(o.wheelStartX=null);if(i&&null!=Ls){var h=i*Ls,d=e.doc.scrollTop,p=d+o.wrapper.clientHeight;h<0?d=Math.max(0,d+h-50):p=Math.min(e.doc.height,p+h+50),On(e,{top:d,bottom:p})}Ss<20&&(null==o.wheelStartX?(o.wheelStartX=l.scrollLeft,o.wheelStartY=l.scrollTop,o.wheelDX=n,o.wheelDY=i,setTimeout(function(){if(null!=o.wheelStartX){var e=l.scrollLeft-o.wheelStartX,t=l.scrollTop-o.wheelStartY,r=t&&o.wheelDY&&t/o.wheelDY||e&&o.wheelDX&&e/o.wheelDX;o.wheelStartX=o.wheelStartY=null,r&&(Ls=(Ls*Ss+r)/(Ss+1),++Ss)}},200)):(o.wheelDX+=n,o.wheelDY+=i))}}function zn(e,t){var r=e[t];e.sort(function(e,t){return P(e.from(),t.from())}),t=h(e,r);for(var n=1;n<e.length;n++){var i=e[n],o=e[n-1];if(P(o.to(),i.from())>=0){var l=B(o.from(),i.from()),s=R(o.to(),i.to()),a=o.empty()?i.from()==i.head:o.from()==o.head;n<=t&&--t,e.splice(--n,2,new Ts(a?s:l,a?l:s))}}return new ks(e,t)}function Rn(e,t){return new ks([new Ts(e,t||e)],0)}function Bn(e){return e.text?E(e.from.line+e.text.length-1,g(e.text).length+(1==e.text.length?e.from.ch:0)):e.to}function Gn(e,t){if(P(e,t.from)<0)return e;if(P(e,t.to)<=0)return Bn(t);var r=e.line+t.text.length-(t.to.line-t.from.line)-1,n=e.ch;return e.line==t.to.line&&(n+=Bn(t).ch-t.to.ch),E(r,n)}function Un(e,t){for(var r=[],n=0;n<e.sel.ranges.length;n++){var i=e.sel.ranges[n];r.push(new Ts(Gn(i.anchor,t),Gn(i.head,t)))}return zn(r,e.sel.primIndex)}function Vn(e,t,r){return e.line==t.line?E(r.line,e.ch-t.ch+r.ch):E(r.line+(e.line-t.line),e.ch)}function Kn(e,t,r){for(var n=[],i=E(e.first,0),o=i,l=0;l<t.length;l++){var s=t[l],a=Vn(s.from,i,o),u=Vn(Bn(s),i,o);if(i=s.to,o=u,"around"==r){var c=e.sel.ranges[l],f=P(c.head,c.anchor)<0;n[l]=new Ts(f?u:a,f?a:u)}else n[l]=new Ts(a,a)}return new ks(n,e.sel.primIndex)}function jn(e){e.doc.mode=Ue(e.options,e.doc.modeOption),Xn(e)}function Xn(e){e.doc.iter(function(e){e.stateAfter&&(e.stateAfter=null),e.styles&&(e.styles=null)}),e.doc.modeFrontier=e.doc.highlightFrontier=e.doc.first,Cn(e,100),e.state.modeGen++,e.curOp&&vn(e)}function Yn(e,t){return 0==t.from.ch&&0==t.to.ch&&""==g(t.text)&&(!e.cm||e.cm.options.wholeLineUpdateBefore)}function _n(e,t,r,n){function i(e){return r?r[e]:null}function o(e,r,i){it(e,r,i,n),bt(e,"change",e,t)}function l(e,t){for(var r=[],o=e;o<t;++o)r.push(new fs(u[o],i(o),n));return r}var s=t.from,a=t.to,u=t.text,c=M(e,s.line),f=M(e,a.line),h=g(u),d=i(u.length-1),p=a.line-s.line;if(t.full)e.insert(0,l(0,u.length)),e.remove(u.length,e.size-u.length);else if(Yn(e,t)){var v=l(0,u.length-1);o(f,f.text,d),p&&e.remove(s.line,p),v.length&&e.insert(s.line,v)}else if(c==f)if(1==u.length)o(c,c.text.slice(0,s.ch)+h+c.text.slice(a.ch),d);else{var m=l(1,u.length-1);m.push(new fs(h+c.text.slice(a.ch),d,n)),o(c,c.text.slice(0,s.ch)+u[0],i(0)),e.insert(s.line+1,m)}else if(1==u.length)o(c,c.text.slice(0,s.ch)+u[0]+f.text.slice(a.ch),i(0)),e.remove(s.line+1,p);else{o(c,c.text.slice(0,s.ch)+u[0],i(0)),o(f,h+f.text.slice(a.ch),d);var y=l(1,u.length-1);p>1&&e.remove(s.line+1,p-1),e.insert(s.line+1,y)}bt(e,"change",e,t)}function $n(e,t,r){function n(e,i,o){if(e.linked)for(var l=0;l<e.linked.length;++l){var s=e.linked[l];if(s.doc!=i){var a=o&&s.sharedHist;r&&!a||(t(s.doc,a),n(s.doc,e,a))}}}n(e,null,!0)}function qn(e,t){if(t.cm)throw new Error("This document is already in use.");e.doc=t,t.cm=e,Cr(e),jn(e),Zn(e),e.options.lineWrapping||we(e),e.options.mode=t.modeOption,vn(e)}function Zn(e){("rtl"==e.doc.direction?s:Fl)(e.display.lineDiv,"CodeMirror-rtl")}function Qn(e){hn(e,function(){Zn(e),vn(e)})}function Jn(e){this.done=[],this.undone=[],this.undoDepth=1/0,this.lastModTime=this.lastSelTime=0,this.lastOp=this.lastSelOp=null,this.lastOrigin=this.lastSelOrigin=null,this.generation=this.maxGeneration=e||1}function ei(e,t){var r={from:z(t.from),to:Bn(t),text:N(e,t.from,t.to)};return si(e,r,t.from.line,t.to.line+1),$n(e,function(e){return si(e,r,t.from.line,t.to.line+1)},!0),r}function ti(e){for(;e.length&&g(e).ranges;)e.pop()}function ri(e,t){return t?(ti(e.done),g(e.done)):e.done.length&&!g(e.done).ranges?g(e.done):e.done.length>1&&!e.done[e.done.length-2].ranges?(e.done.pop(),g(e.done)):void 0}function ni(e,t,r,n){var i=e.history;i.undone.length=0;var o,l,s=+new Date;if((i.lastOp==n||i.lastOrigin==t.origin&&t.origin&&("+"==t.origin.charAt(0)&&e.cm&&i.lastModTime>s-e.cm.options.historyEventDelay||"*"==t.origin.charAt(0)))&&(o=ri(i,i.lastOp==n)))l=g(o.changes),0==P(t.from,t.to)&&0==P(t.from,l.to)?l.to=Bn(t):o.changes.push(ei(e,t));else{var a=g(i.done);for(a&&a.ranges||li(e.sel,i.done),o={changes:[ei(e,t)],generation:i.generation},i.done.push(o);i.done.length>i.undoDepth;)i.done.shift(),i.done[0].ranges||i.done.shift()}i.done.push(r),i.generation=++i.maxGeneration,i.lastModTime=i.lastSelTime=s,i.lastOp=i.lastSelOp=n,i.lastOrigin=i.lastSelOrigin=t.origin,l||Te(e,"historyAdded")}function ii(e,t,r,n){var i=t.charAt(0);return"*"==i||"+"==i&&r.ranges.length==n.ranges.length&&r.somethingSelected()==n.somethingSelected()&&new Date-e.history.lastSelTime<=(e.cm?e.cm.options.historyEventDelay:500)}function oi(e,t,r,n){var i=e.history,o=n&&n.origin;r==i.lastSelOp||o&&i.lastSelOrigin==o&&(i.lastModTime==i.lastSelTime&&i.lastOrigin==o||ii(e,o,g(i.done),t))?i.done[i.done.length-1]=t:li(t,i.done),i.lastSelTime=+new Date,i.lastSelOrigin=o,i.lastSelOp=r,n&&!1!==n.clearRedo&&ti(i.undone)}function li(e,t){var r=g(t);r&&r.ranges&&r.equals(e)||t.push(e)}function si(e,t,r,n){var i=t["spans_"+e.id],o=0;e.iter(Math.max(e.first,r),Math.min(e.first+e.size,n),function(r){r.markedSpans&&((i||(i=t["spans_"+e.id]={}))[o]=r.markedSpans),++o})}function ai(e){if(!e)return null;for(var t,r=0;r<e.length;++r)e[r].marker.explicitlyCleared?t||(t=e.slice(0,r)):t&&t.push(e[r]);return t?t.length?t:null:e}function ui(e,t){var r=t["spans_"+e.id];if(!r)return null;for(var n=[],i=0;i<t.text.length;++i)n.push(ai(r[i]));return n}function ci(e,t){var r=ui(e,t),n=J(e,t);if(!r)return n;if(!n)return r;for(var i=0;i<r.length;++i){var o=r[i],l=n[i];if(o&&l)e:for(var s=0;s<l.length;++s){for(var a=l[s],u=0;u<o.length;++u)if(o[u].marker==a.marker)continue e;o.push(a)}else l&&(r[i]=l)}return r}function fi(e,t,r){for(var n=[],i=0;i<e.length;++i){var o=e[i];if(o.ranges)n.push(r?ks.prototype.deepCopy.call(o):o);else{var l=o.changes,s=[];n.push({changes:s});for(var a=0;a<l.length;++a){var u=l[a],c=void 0;if(s.push({from:u.from,to:u.to,text:u.text}),t)for(var f in u)(c=f.match(/^spans_(\d+)$/))&&h(t,Number(c[1]))>-1&&(g(s)[f]=u[f],delete u[f])}}}return n}function hi(e,t,r,n){if(n){var i=e.anchor;if(r){var o=P(t,i)<0;o!=P(r,i)<0?(i=t,t=r):o!=P(t,r)<0&&(t=r)}return new Ts(i,t)}return new Ts(r||t,t)}function di(e,t,r,n,i){null==i&&(i=e.cm&&(e.cm.display.shift||e.extend)),bi(e,new ks([hi(e.sel.primary(),t,r,i)],0),n)}function pi(e,t,r){for(var n=[],i=e.cm&&(e.cm.display.shift||e.extend),o=0;o<e.sel.ranges.length;o++)n[o]=hi(e.sel.ranges[o],t[o],null,i);bi(e,zn(n,e.sel.primIndex),r)}function gi(e,t,r,n){var i=e.sel.ranges.slice(0);i[t]=r,bi(e,zn(i,e.sel.primIndex),n)}function vi(e,t,r,n){bi(e,Rn(t,r),n)}function mi(e,t,r){var n={ranges:t.ranges,update:function(t){var r=this;this.ranges=[];for(var n=0;n<t.length;n++)r.ranges[n]=new Ts(U(e,t[n].anchor),U(e,t[n].head))},origin:r&&r.origin};return Te(e,"beforeSelectionChange",e,n),e.cm&&Te(e.cm,"beforeSelectionChange",e.cm,n),n.ranges!=t.ranges?zn(n.ranges,n.ranges.length-1):t}function yi(e,t,r){var n=e.history.done,i=g(n);i&&i.ranges?(n[n.length-1]=t,wi(e,t,r)):bi(e,t,r)}function bi(e,t,r){wi(e,t,r),oi(e,e.sel,e.cm?e.cm.curOp.id:NaN,r)}function wi(e,t,r){(Oe(e,"beforeSelectionChange")||e.cm&&Oe(e.cm,"beforeSelectionChange"))&&(t=mi(e,t,r)),xi(e,Si(e,t,r&&r.bias||(P(t.primary().head,e.sel.primary().head)<0?-1:1),!0)),r&&!1===r.scroll||!e.cm||jr(e.cm)}function xi(e,t){t.equals(e.sel)||(e.sel=t,e.cm&&(e.cm.curOp.updateInput=e.cm.curOp.selectionChanged=!0,Ne(e.cm)),bt(e,"cursorActivity",e))}function Ci(e){xi(e,Si(e,e.sel,null,!1))}function Si(e,t,r,n){for(var i,o=0;o<t.ranges.length;o++){var l=t.ranges[o],s=t.ranges.length==e.sel.ranges.length&&e.sel.ranges[o],a=ki(e,l.anchor,s&&s.anchor,r,n),u=ki(e,l.head,s&&s.head,r,n);(i||a!=l.anchor||u!=l.head)&&(i||(i=t.ranges.slice(0,o)),i[o]=new Ts(a,u))}return i?zn(i,t.primIndex):t}function Li(e,t,r,n,i){var o=M(e,t.line);if(o.markedSpans)for(var l=0;l<o.markedSpans.length;++l){var s=o.markedSpans[l],a=s.marker;if((null==s.from||(a.inclusiveLeft?s.from<=t.ch:s.from<t.ch))&&(null==s.to||(a.inclusiveRight?s.to>=t.ch:s.to>t.ch))){if(i&&(Te(a,"beforeCursorEnter"),a.explicitlyCleared)){if(o.markedSpans){--l;continue}break}if(!a.atomic)continue;if(r){var u=a.find(n<0?1:-1),c=void 0;if((n<0?a.inclusiveRight:a.inclusiveLeft)&&(u=Ti(e,u,-n,u&&u.line==t.line?o:null)),u&&u.line==t.line&&(c=P(u,r))&&(n<0?c<0:c>0))return Li(e,u,t,n,i)}var f=a.find(n<0?-1:1);return(n<0?a.inclusiveLeft:a.inclusiveRight)&&(f=Ti(e,f,n,f.line==t.line?o:null)),f?Li(e,f,t,n,i):null}}return t}function ki(e,t,r,n,i){var o=n||1,l=Li(e,t,r,o,i)||!i&&Li(e,t,r,o,!0)||Li(e,t,r,-o,i)||!i&&Li(e,t,r,-o,!0);return l||(e.cantEdit=!0,E(e.first,0))}function Ti(e,t,r,n){return r<0&&0==t.ch?t.line>e.first?U(e,E(t.line-1)):null:r>0&&t.ch==(n||M(e,t.line)).text.length?t.line<e.first+e.size-1?E(t.line+1,0):null:new E(t.line,t.ch+r)}function Mi(e){e.setSelection(E(e.firstLine(),0),E(e.lastLine()),Gl)}function Ni(e,t,r){var n={canceled:!1,from:t.from,to:t.to,text:t.text,origin:t.origin,cancel:function(){return n.canceled=!0}};return r&&(n.update=function(t,r,i,o){t&&(n.from=U(e,t)),r&&(n.to=U(e,r)),i&&(n.text=i),void 0!==o&&(n.origin=o)}),Te(e,"beforeChange",e,n),e.cm&&Te(e.cm,"beforeChange",e.cm,n),n.canceled?null:{from:n.from,to:n.to,text:n.text,origin:n.origin}}function Oi(e,t,r){if(e.cm){if(!e.cm.curOp)return dn(e.cm,Oi)(e,t,r);if(e.cm.state.suppressEdits)return}if(!(Oe(e,"beforeChange")||e.cm&&Oe(e.cm,"beforeChange"))||(t=Ni(e,t,!0))){var n=Yl&&!r&&te(e,t.from,t.to);if(n)for(var i=n.length-1;i>=0;--i)Ai(e,{from:n[i].from,to:n[i].to,text:i?[""]:t.text,origin:t.origin});else Ai(e,t)}}function Ai(e,t){if(1!=t.text.length||""!=t.text[0]||0!=P(t.from,t.to)){var r=Un(e,t);ni(e,t,r,e.cm?e.cm.curOp.id:NaN),Hi(e,t,r,J(e,t));var n=[];$n(e,function(e,r){r||-1!=h(n,e.history)||(zi(e.history,t),n.push(e.history)),Hi(e,t,null,J(e,t))})}}function Wi(e,t,r){if(!e.cm||!e.cm.state.suppressEdits||r){for(var n,i=e.history,o=e.sel,l="undo"==t?i.done:i.undone,s="undo"==t?i.undone:i.done,a=0;a<l.length&&(n=l[a],r?!n.ranges||n.equals(e.sel):n.ranges);a++);if(a!=l.length){for(i.lastOrigin=i.lastSelOrigin=null;(n=l.pop()).ranges;){if(li(n,s),r&&!n.equals(e.sel))return void bi(e,n,{clearRedo:!1});o=n}var u=[];li(o,s),s.push({changes:u,generation:i.generation}),i.generation=n.generation||++i.maxGeneration;for(var c=Oe(e,"beforeChange")||e.cm&&Oe(e.cm,"beforeChange"),f=n.changes.length-1;f>=0;--f){var d=function(r){var i=n.changes[r];if(i.origin=t,c&&!Ni(e,i,!1))return l.length=0,{};u.push(ei(e,i));var o=r?Un(e,i):g(l);Hi(e,i,o,ci(e,i)),!r&&e.cm&&e.cm.scrollIntoView({from:i.from,to:Bn(i)});var s=[];$n(e,function(e,t){t||-1!=h(s,e.history)||(zi(e.history,i),s.push(e.history)),Hi(e,i,null,ci(e,i))})}(f);if(d)return d.v}}}}function Di(e,t){if(0!=t&&(e.first+=t,e.sel=new ks(v(e.sel.ranges,function(e){return new Ts(E(e.anchor.line+t,e.anchor.ch),E(e.head.line+t,e.head.ch))}),e.sel.primIndex),e.cm)){vn(e.cm,e.first,e.first-t,t);for(var r=e.cm.display,n=r.viewFrom;n<r.viewTo;n++)mn(e.cm,n,"gutter")}}function Hi(e,t,r,n){if(e.cm&&!e.cm.curOp)return dn(e.cm,Hi)(e,t,r,n);if(t.to.line<e.first)Di(e,t.text.length-1-(t.to.line-t.from.line));else if(!(t.from.line>e.lastLine())){if(t.from.line<e.first){var i=t.text.length-1-(e.first-t.from.line);Di(e,i),t={from:E(e.first,0),to:E(t.to.line+i,t.to.ch),text:[g(t.text)],origin:t.origin}}var o=e.lastLine();t.to.line>o&&(t={from:t.from,to:E(o,M(e,o).text.length),text:[t.text[0]],origin:t.origin}),t.removed=N(e,t.from,t.to),r||(r=Un(e,t)),e.cm?Fi(e.cm,t,n):_n(e,t,n),wi(e,r,Gl)}}function Fi(e,t,r){var n=e.doc,i=e.display,o=t.from,l=t.to,s=!1,a=o.line;e.options.lineWrapping||(a=W(fe(M(n,o.line))),n.iter(a,l.line+1,function(e){if(e==i.maxLine)return s=!0,!0})),n.sel.contains(t.from,t.to)>-1&&Ne(e),_n(n,t,r,xr(e)),e.options.lineWrapping||(n.iter(a,o.line+t.text.length,function(e){var t=be(e);t>i.maxLineLength&&(i.maxLine=e,i.maxLineLength=t,i.maxLineChanged=!0,s=!1)}),s&&(e.curOp.updateMaxLine=!0)),nt(n,o.line),Cn(e,400);var u=t.text.length-(l.line-o.line)-1;t.full?vn(e):o.line!=l.line||1!=t.text.length||Yn(e.doc,t)?vn(e,o.line,l.line+1,u):mn(e,o.line,"text");var c=Oe(e,"changes"),f=Oe(e,"change");if(f||c){var h={from:o,to:l,text:t.text,removed:t.removed,origin:t.origin};f&&bt(e,"change",e,h),c&&(e.curOp.changeObjs||(e.curOp.changeObjs=[])).push(h)}e.display.selForContextMenu=null}function Ei(e,t,r,n,i){if(n||(n=r),P(n,r)<0){var o;r=(o=[n,r])[0],n=o[1]}"string"==typeof t&&(t=e.splitLines(t)),Oi(e,{from:r,to:n,text:t,origin:i})}function Pi(e,t,r,n){r<e.line?e.line+=n:t<e.line&&(e.line=t,e.ch=0)}function Ii(e,t,r,n){for(var i=0;i<e.length;++i){var o=e[i],l=!0;if(o.ranges){o.copied||((o=e[i]=o.deepCopy()).copied=!0);for(var s=0;s<o.ranges.length;s++)Pi(o.ranges[s].anchor,t,r,n),Pi(o.ranges[s].head,t,r,n)}else{for(var a=0;a<o.changes.length;++a){var u=o.changes[a];if(r<u.from.line)u.from=E(u.from.line+n,u.from.ch),u.to=E(u.to.line+n,u.to.ch);else if(t<=u.to.line){l=!1;break}}l||(e.splice(0,i+1),i=0)}}}function zi(e,t){var r=t.from.line,n=t.to.line,i=t.text.length-(n-r)-1;Ii(e.done,r,n,i),Ii(e.undone,r,n,i)}function Ri(e,t,r,n){var i=t,o=t;return"number"==typeof t?o=M(e,G(e,t)):i=W(t),null==i?null:(n(o,i)&&e.cm&&mn(e.cm,i,r),o)}function Bi(e){var t=this;this.lines=e,this.parent=null;for(var r=0,n=0;n<e.length;++n)e[n].parent=t,r+=e[n].height;this.height=r}function Gi(e){var t=this;this.children=e;for(var r=0,n=0,i=0;i<e.length;++i){var o=e[i];r+=o.chunkSize(),n+=o.height,o.parent=t}this.size=r,this.height=n,this.parent=null}function Ui(e,t,r){ye(t)<(e.curOp&&e.curOp.scrollTop||e.doc.scrollTop)&&Kr(e,r)}function Vi(e,t,r,n){var i=new Ms(e,r,n),o=e.cm;return o&&i.noHScroll&&(o.display.alignWidgets=!0),Ri(e,t,"widget",function(t){var r=t.widgets||(t.widgets=[]);if(null==i.insertAt?r.push(i):r.splice(Math.min(r.length-1,Math.max(0,i.insertAt)),0,i),i.line=t,o&&!ve(e,t)){var n=ye(t)<e.scrollTop;A(t,t.height+Ht(i)),n&&Kr(o,i.height),o.curOp.forceUpdate=!0}return!0}),bt(o,"lineWidgetAdded",o,i,"number"==typeof t?t:W(t)),i}function Ki(e,t,r,n,o){if(n&&n.shared)return ji(e,t,r,n,o);if(e.cm&&!e.cm.curOp)return dn(e.cm,Ki)(e,t,r,n,o);var l=new Os(e,o),s=P(t,r);if(n&&c(n,l,!1),s>0||0==s&&!1!==l.clearWhenEmpty)return l;if(l.replacedWith&&(l.collapsed=!0,l.widgetNode=i("span",[l.replacedWith],"CodeMirror-widget"),n.handleMouseEvents||l.widgetNode.setAttribute("cm-ignore-events","true"),n.insertLeft&&(l.widgetNode.insertLeft=!0)),l.collapsed){if(ce(e,t.line,t,r,l)||t.line!=r.line&&ce(e,r.line,t,r,l))throw new Error("Inserting collapsed marker partially overlapping an existing one");X()}l.addToHistory&&ni(e,{from:t,to:r,origin:"markText"},e.sel,NaN);var a,u=t.line,f=e.cm;if(e.iter(u,r.line+1,function(e){f&&l.collapsed&&!f.options.lineWrapping&&fe(e)==f.display.maxLine&&(a=!0),l.collapsed&&u!=t.line&&A(e,0),q(e,new Y(l,u==t.line?t.ch:null,u==r.line?r.ch:null)),++u}),l.collapsed&&e.iter(t.line,r.line+1,function(t){ve(e,t)&&A(t,0)}),l.clearOnEnter&&Ql(l,"beforeCursorEnter",function(){return l.clear()}),l.readOnly&&(j(),(e.history.done.length||e.history.undone.length)&&e.clearHistory()),l.collapsed&&(l.id=++Ns,l.atomic=!0),f){if(a&&(f.curOp.updateMaxLine=!0),l.collapsed)vn(f,t.line,r.line+1);else if(l.className||l.title||l.startStyle||l.endStyle||l.css)for(var h=t.line;h<=r.line;h++)mn(f,h,"text");l.atomic&&Ci(f.doc),bt(f,"markerAdded",f,l)}return l}function ji(e,t,r,n,i){(n=c(n)).shared=!1;var o=[Ki(e,t,r,n,i)],l=o[0],s=n.widgetNode;return $n(e,function(e){s&&(n.widgetNode=s.cloneNode(!0)),o.push(Ki(e,U(e,t),U(e,r),n,i));for(var a=0;a<e.linked.length;++a)if(e.linked[a].isParent)return;l=g(o)}),new As(o,l)}function Xi(e){return e.findMarks(E(e.first,0),e.clipPos(E(e.lastLine())),function(e){return e.parent})}function Yi(e,t){for(var r=0;r<t.length;r++){var n=t[r],i=n.find(),o=e.clipPos(i.from),l=e.clipPos(i.to);if(P(o,l)){var s=Ki(e,o,l,n.primary,n.primary.type);n.markers.push(s),s.parent=n}}}function _i(e){for(var t=0;t<e.length;t++)!function(t){var r=e[t],n=[r.primary.doc];$n(r.primary.doc,function(e){return n.push(e)});for(var i=0;i<r.markers.length;i++){var o=r.markers[i];-1==h(n,o.doc)&&(o.parent=null,r.markers.splice(i--,1))}}(t)}function $i(e){var t=this;if(Qi(t),!Me(t,e)&&!Ft(t.display,e)){We(e),gl&&(Hs=+new Date);var r=Sr(t,e,!0),n=e.dataTransfer.files;if(r&&!t.isReadOnly())if(n&&n.length&&window.FileReader&&window.File)for(var i=n.length,o=Array(i),l=0,s=0;s<i;++s)!function(e,n){if(!t.options.allowDropFileTypes||-1!=h(t.options.allowDropFileTypes,e.type)){var s=new FileReader;s.onload=dn(t,function(){var e=s.result;if(/[\x00-\x08\x0e-\x1f]{2}/.test(e)&&(e=""),o[n]=e,++l==i){var a={from:r=U(t.doc,r),to:r,text:t.doc.splitLines(o.join(t.doc.lineSeparator())),origin:"paste"};Oi(t.doc,a),yi(t.doc,Rn(r,Bn(a)))}}),s.readAsText(e)}}(n[s],s);else{if(t.state.draggingText&&t.doc.sel.contains(r)>-1)return t.state.draggingText(e),void setTimeout(function(){return t.display.input.focus()},20);try{var a=e.dataTransfer.getData("Text");if(a){var u;if(t.state.draggingText&&!t.state.draggingText.copy&&(u=t.listSelections()),wi(t.doc,Rn(r,r)),u)for(var c=0;c<u.length;++c)Ei(t.doc,"",u[c].anchor,u[c].head,"drag");t.replaceSelection(a,"around","paste"),t.display.input.focus()}}catch(e){}}}}function qi(e,t){if(gl&&(!e.state.draggingText||+new Date-Hs<100))Fe(t);else if(!Me(e,t)&&!Ft(e.display,t)&&(t.dataTransfer.setData("Text",e.getSelection()),t.dataTransfer.effectAllowed="copyMove",t.dataTransfer.setDragImage&&!xl)){var r=n("img",null,null,"position: fixed; left: 0; top: 0;");r.src="data:image/gif;base64,R0lGODlhAQABAAAAACH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==",wl&&(r.width=r.height=1,e.display.wrapper.appendChild(r),r._top=r.offsetTop),t.dataTransfer.setDragImage(r,0,0),wl&&r.parentNode.removeChild(r)}}function Zi(e,t){var i=Sr(e,t);if(i){var o=document.createDocumentFragment();Mr(e,i,o),e.display.dragCursor||(e.display.dragCursor=n("div",null,"CodeMirror-cursors CodeMirror-dragcursors"),e.display.lineSpace.insertBefore(e.display.dragCursor,e.display.cursorDiv)),r(e.display.dragCursor,o)}}function Qi(e){e.display.dragCursor&&(e.display.lineSpace.removeChild(e.display.dragCursor),e.display.dragCursor=null)}function Ji(e){if(document.getElementsByClassName)for(var t=document.getElementsByClassName("CodeMirror"),r=0;r<t.length;r++){var n=t[r].CodeMirror;n&&e(n)}}function eo(){Fs||(to(),Fs=!0)}function to(){var e;Ql(window,"resize",function(){null==e&&(e=setTimeout(function(){e=null,Ji(ro)},100))}),Ql(window,"blur",function(){return Ji(Fr)})}function ro(e){var t=e.display;t.lastWrapHeight==t.wrapper.clientHeight&&t.lastWrapWidth==t.wrapper.clientWidth||(t.cachedCharWidth=t.cachedTextHeight=t.cachedPaddingH=null,t.scrollbarsClipped=!1,e.setSize())}function no(e){var t=e.split(/-(?!$)/);e=t[t.length-1];for(var r,n,i,o,l=0;l<t.length-1;l++){var s=t[l];if(/^(cmd|meta|m)$/i.test(s))o=!0;else if(/^a(lt)?$/i.test(s))r=!0;else if(/^(c|ctrl|control)$/i.test(s))n=!0;else{if(!/^s(hift)?$/i.test(s))throw new Error("Unrecognized modifier name: "+s);i=!0}}return r&&(e="Alt-"+e),n&&(e="Ctrl-"+e),o&&(e="Cmd-"+e),i&&(e="Shift-"+e),e}function io(e){var t={};for(var r in e)if(e.hasOwnProperty(r)){var n=e[r];if(/^(name|fallthrough|(de|at)tach)$/.test(r))continue;if("..."==n){delete e[r];continue}for(var i=v(r.split(" "),no),o=0;o<i.length;o++){var l=void 0,s=void 0;o==i.length-1?(s=i.join(" "),l=n):(s=i.slice(0,o+1).join(" "),l="...");var a=t[s];if(a){if(a!=l)throw new Error("Inconsistent bindings for "+s)}else t[s]=l}delete e[r]}for(var u in t)e[u]=t[u];return e}function oo(e,t,r,n){var i=(t=uo(t)).call?t.call(e,n):t[e];if(!1===i)return"nothing";if("..."===i)return"multi";if(null!=i&&r(i))return"handled";if(t.fallthrough){if("[object Array]"!=Object.prototype.toString.call(t.fallthrough))return oo(e,t.fallthrough,r,n);for(var o=0;o<t.fallthrough.length;o++){var l=oo(e,t.fallthrough[o],r,n);if(l)return l}}}function lo(e){var t="string"==typeof e?e:Es[e.keyCode];return"Ctrl"==t||"Alt"==t||"Shift"==t||"Mod"==t}function so(e,t,r){var n=e;return t.altKey&&"Alt"!=n&&(e="Alt-"+e),(Dl?t.metaKey:t.ctrlKey)&&"Ctrl"!=n&&(e="Ctrl-"+e),(Dl?t.ctrlKey:t.metaKey)&&"Cmd"!=n&&(e="Cmd-"+e),!r&&t.shiftKey&&"Shift"!=n&&(e="Shift-"+e),e}function ao(e,t){if(wl&&34==e.keyCode&&e.char)return!1;var r=Es[e.keyCode];return null!=r&&!e.altGraphKey&&so(r,e,t)}function uo(e){return"string"==typeof e?Rs[e]:e}function co(e,t){for(var r=e.doc.sel.ranges,n=[],i=0;i<r.length;i++){for(var o=t(r[i]);n.length&&P(o.from,g(n).to)<=0;){var l=n.pop();if(P(l.from,o.from)<0){o.from=l.from;break}}n.push(o)}hn(e,function(){for(var t=n.length-1;t>=0;t--)Ei(e.doc,"",n[t].from,n[t].to,"+delete");jr(e)})}function fo(e,t,r){var n=L(e.text,t+r,r);return n<0||n>e.text.length?null:n}function ho(e,t,r){var n=fo(e,t.ch,r);return null==n?null:new E(t.line,n,r<0?"after":"before")}function po(e,t,r,n,i){if(e){var o=Se(r,t.doc.direction);if(o){var l,s=i<0?g(o):o[0],a=i<0==(1==s.level)?"after":"before";if(s.level>0){var u=Xt(t,r);l=i<0?r.text.length-1:0;var c=Yt(t,u,l).top;l=k(function(e){return Yt(t,u,e).top==c},i<0==(1==s.level)?s.from:s.to-1,l),"before"==a&&(l=fo(r,l,1))}else l=i<0?s.to:s.from;return new E(n,l,a)}}return new E(n,i<0?r.text.length:0,i<0?"before":"after")}function go(e,t,r,n){var i=Se(t,e.doc.direction);if(!i)return ho(t,r,n);r.ch>=t.text.length?(r.ch=t.text.length,r.sticky="before"):r.ch<=0&&(r.ch=0,r.sticky="after");var o=Ce(i,r.ch,r.sticky),l=i[o];if("ltr"==e.doc.direction&&l.level%2==0&&(n>0?l.to>r.ch:l.from<r.ch))return ho(t,r,n);var s,a=function(e,r){return fo(t,e instanceof E?e.ch:e,r)},u=function(r){return e.options.lineWrapping?(s=s||Xt(e,t),hr(e,t,s,r)):{begin:0,end:t.text.length}},c=u("before"==r.sticky?a(r,-1):r.ch);if("rtl"==e.doc.direction||1==l.level){var f=1==l.level==n<0,h=a(r,f?1:-1);if(null!=h&&(f?h<=l.to&&h<=c.end:h>=l.from&&h>=c.begin)){var d=f?"before":"after";return new E(r.line,h,d)}}var p=function(e,t,n){for(var o=function(e,t){return t?new E(r.line,a(e,1),"before"):new E(r.line,e,"after")};e>=0&&e<i.length;e+=t){var l=i[e],s=t>0==(1!=l.level),u=s?n.begin:a(n.end,-1);if(l.from<=u&&u<l.to)return o(u,s);if(u=s?l.from:a(l.to,-1),n.begin<=u&&u<n.end)return o(u,s)}},g=p(o+n,n,c);if(g)return g;var v=n>0?c.end:a(c.begin,-1);return null==v||n>0&&v==t.text.length||!(g=p(n>0?0:i.length-1,n,u(v)))?null:g}function vo(e,t){var r=M(e.doc,t),n=fe(r);return n!=r&&(t=W(n)),po(!0,e,n,t,1)}function mo(e,t){var r=M(e.doc,t),n=he(r);return n!=r&&(t=W(n)),po(!0,e,r,t,-1)}function yo(e,t){var r=vo(e,t.line),n=M(e.doc,r.line),i=Se(n,e.doc.direction);if(!i||0==i[0].level){var o=Math.max(0,n.text.search(/\S/)),l=t.line==r.line&&t.ch<=o&&t.ch;return E(r.line,l?0:o,r.sticky)}return r}function bo(e,t,r){if("string"==typeof t&&!(t=Bs[t]))return!1;e.display.input.ensurePolled();var n=e.display.shift,i=!1;try{e.isReadOnly()&&(e.state.suppressEdits=!0),r&&(e.display.shift=!1),i=t(e)!=Bl}finally{e.display.shift=n,e.state.suppressEdits=!1}return i}function wo(e,t,r){for(var n=0;n<e.state.keyMaps.length;n++){var i=oo(t,e.state.keyMaps[n],r,e);if(i)return i}return e.options.extraKeys&&oo(t,e.options.extraKeys,r,e)||oo(t,e.options.keyMap,r,e)}function xo(e,t,r,n){var i=e.state.keySeq;if(i){if(lo(t))return"handled";Gs.set(50,function(){e.state.keySeq==i&&(e.state.keySeq=null,e.display.input.reset())}),t=i+" "+t}var o=wo(e,t,n);return"multi"==o&&(e.state.keySeq=t),"handled"==o&&bt(e,"keyHandled",e,t,r),"handled"!=o&&"multi"!=o||(We(r),Ar(e)),i&&!o&&/\'$/.test(t)?(We(r),!0):!!o}function Co(e,t){var r=ao(t,!0);return!!r&&(t.shiftKey&&!e.state.keySeq?xo(e,"Shift-"+r,t,function(t){return bo(e,t,!0)})||xo(e,r,t,function(t){if("string"==typeof t?/^go[A-Z]/.test(t):t.motion)return bo(e,t)}):xo(e,r,t,function(t){return bo(e,t)}))}function So(e,t,r){return xo(e,"'"+r+"'",t,function(t){return bo(e,t,!0)})}function Lo(e){var t=this;if(t.curOp.focus=l(),!Me(t,e)){gl&&vl<11&&27==e.keyCode&&(e.returnValue=!1);var r=e.keyCode;t.display.shift=16==r||e.shiftKey;var n=Co(t,e);wl&&(Us=n?r:null,!n&&88==r&&!rs&&(Ml?e.metaKey:e.ctrlKey)&&t.replaceSelection("",null,"cut")),18!=r||/\bCodeMirror-crosshair\b/.test(t.display.lineDiv.className)||ko(t)}}function ko(e){function t(e){18!=e.keyCode&&e.altKey||(Fl(r,"CodeMirror-crosshair"),ke(document,"keyup",t),ke(document,"mouseover",t))}var r=e.display.lineDiv;s(r,"CodeMirror-crosshair"),Ql(document,"keyup",t),Ql(document,"mouseover",t)}function To(e){16==e.keyCode&&(this.doc.sel.shift=!1),Me(this,e)}function Mo(e){var t=this;if(!(Ft(t.display,e)||Me(t,e)||e.ctrlKey&&!e.altKey||Ml&&e.metaKey)){var r=e.keyCode,n=e.charCode;if(wl&&r==Us)return Us=null,void We(e);if(!wl||e.which&&!(e.which<10)||!Co(t,e)){var i=String.fromCharCode(null==n?r:n);"\b"!=i&&(So(t,e,i)||t.display.input.onKeyPress(e))}}}function No(e,t){var r=+new Date;return js&&js.compare(r,e,t)?(Ks=js=null,"triple"):Ks&&Ks.compare(r,e,t)?(js=new Vs(r,e,t),Ks=null,"double"):(Ks=new Vs(r,e,t),js=null,"single")}function Oo(e){var t=this,r=t.display;if(!(Me(t,e)||r.activeTouch&&r.input.supportsTouch()))if(r.input.ensurePolled(),r.shift=e.shiftKey,Ft(r,e))ml||(r.scroller.draggable=!1,setTimeout(function(){return r.scroller.draggable=!0},100));else if(!zo(t,e)){var n=Sr(t,e),i=Pe(e),o=n?No(n,i):"single";window.focus(),1==i&&t.state.selectingText&&t.state.selectingText(e),n&&Ao(t,i,n,o,e)||(1==i?n?Do(t,n,o,e):Ee(e)==r.scroller&&We(e):2==i?(n&&di(t.doc,n),setTimeout(function(){return r.input.focus()},20)):3==i&&(Hl?Ro(t,e):Dr(t)))}}function Ao(e,t,r,n,i){var o="Click";return"double"==n?o="Double"+o:"triple"==n&&(o="Triple"+o),o=(1==t?"Left":2==t?"Middle":"Right")+o,xo(e,so(o,i),i,function(t){if("string"==typeof t&&(t=Bs[t]),!t)return!1;var n=!1;try{e.isReadOnly()&&(e.state.suppressEdits=!0),n=t(e,r)!=Bl}finally{e.state.suppressEdits=!1}return n})}function Wo(e,t,r){var n=e.getOption("configureMouse"),i=n?n(e,t,r):{};if(null==i.unit){var o=Nl?r.shiftKey&&r.metaKey:r.altKey;i.unit=o?"rectangle":"single"==t?"char":"double"==t?"word":"line"}return(null==i.extend||e.doc.extend)&&(i.extend=e.doc.extend||r.shiftKey),null==i.addNew&&(i.addNew=Ml?r.metaKey:r.ctrlKey),null==i.moveOnDrag&&(i.moveOnDrag=!(Ml?r.altKey:r.ctrlKey)),i}function Do(e,t,r,n){gl?setTimeout(u(Wr,e),0):e.curOp.focus=l();var i,o=Wo(e,r,n),s=e.doc.sel;e.options.dragDrop&&Jl&&!e.isReadOnly()&&"single"==r&&(i=s.contains(t))>-1&&(P((i=s.ranges[i]).from(),t)<0||t.xRel>0)&&(P(i.to(),t)>0||t.xRel<0)?Ho(e,n,t,o):Eo(e,n,t,o)}function Ho(e,t,r,n){var i=e.display,o=!1,l=dn(e,function(t){ml&&(i.scroller.draggable=!1),e.state.draggingText=!1,ke(document,"mouseup",l),ke(document,"mousemove",s),ke(i.scroller,"dragstart",a),ke(i.scroller,"drop",l),o||(We(t),n.addNew||di(e.doc,r,null,null,n.extend),ml||gl&&9==vl?setTimeout(function(){document.body.focus(),i.input.focus()},20):i.input.focus())}),s=function(e){o=o||Math.abs(t.clientX-e.clientX)+Math.abs(t.clientY-e.clientY)>=10},a=function(){return o=!0};ml&&(i.scroller.draggable=!0),e.state.draggingText=l,l.copy=!n.moveOnDrag,i.scroller.dragDrop&&i.scroller.dragDrop(),Ql(document,"mouseup",l),Ql(document,"mousemove",s),Ql(i.scroller,"dragstart",a),Ql(i.scroller,"drop",l),Dr(e),setTimeout(function(){return i.input.focus()},20)}function Fo(e,t,r){if("char"==r)return new Ts(t,t);if("word"==r)return e.findWordAt(t);if("line"==r)return new Ts(E(t.line,0),U(e.doc,E(t.line+1,0)));var n=r(e,t);return new Ts(n.from,n.to)}function Eo(e,t,r,n){function i(t){if(0!=P(m,t))if(m=t,"rectangle"==n.unit){for(var i=[],o=e.options.tabSize,l=f(M(u,r.line).text,r.ch,o),s=f(M(u,t.line).text,t.ch,o),a=Math.min(l,s),g=Math.max(l,s),v=Math.min(r.line,t.line),y=Math.min(e.lastLine(),Math.max(r.line,t.line));v<=y;v++){var b=M(u,v).text,w=d(b,a,o);a==g?i.push(new Ts(E(v,w),E(v,w))):b.length>w&&i.push(new Ts(E(v,w),E(v,d(b,g,o))))}i.length||i.push(new Ts(r,r)),bi(u,zn(p.ranges.slice(0,h).concat(i),h),{origin:"*mouse",scroll:!1}),e.scrollIntoView(t)}else{var x,C=c,S=Fo(e,t,n.unit),L=C.anchor;P(S.anchor,L)>0?(x=S.head,L=B(C.from(),S.anchor)):(x=S.anchor,L=R(C.to(),S.head));var k=p.ranges.slice(0);k[h]=Po(e,new Ts(U(u,L),x)),bi(u,zn(k,h),Ul)}}function o(t){var r=++b,s=Sr(e,t,!0,"rectangle"==n.unit);if(s)if(0!=P(s,m)){e.curOp.focus=l(),i(s);var c=Ir(a,u);(s.line>=c.to||s.line<c.from)&&setTimeout(dn(e,function(){b==r&&o(t)}),150)}else{var f=t.clientY<y.top?-20:t.clientY>y.bottom?20:0;f&&setTimeout(dn(e,function(){b==r&&(a.scroller.scrollTop+=f,o(t))}),50)}}function s(t){e.state.selectingText=!1,b=1/0,We(t),a.input.focus(),ke(document,"mousemove",w),ke(document,"mouseup",x),u.history.lastSelOrigin=null}var a=e.display,u=e.doc;We(t);var c,h,p=u.sel,g=p.ranges;if(n.addNew&&!n.extend?(h=u.sel.contains(r),c=h>-1?g[h]:new Ts(r,r)):(c=u.sel.primary(),h=u.sel.primIndex),"rectangle"==n.unit)n.addNew||(c=new Ts(r,r)),r=Sr(e,t,!0,!0),h=-1;else{var v=Fo(e,r,n.unit);c=n.extend?hi(c,v.anchor,v.head,n.extend):v}n.addNew?-1==h?(h=g.length,bi(u,zn(g.concat([c]),h),{scroll:!1,origin:"*mouse"})):g.length>1&&g[h].empty()&&"char"==n.unit&&!n.extend?(bi(u,zn(g.slice(0,h).concat(g.slice(h+1)),0),{scroll:!1,origin:"*mouse"}),p=u.sel):gi(u,h,c,Ul):(h=0,bi(u,new ks([c],0),Ul),p=u.sel);var m=r,y=a.wrapper.getBoundingClientRect(),b=0,w=dn(e,function(e){Pe(e)?o(e):s(e)}),x=dn(e,s);e.state.selectingText=x,Ql(document,"mousemove",w),Ql(document,"mouseup",x)}function Po(e,t){var r=t.anchor,n=t.head,i=M(e.doc,r.line);if(0==P(r,n)&&r.sticky==n.sticky)return t;var o=Se(i);if(!o)return t;var l=Ce(o,r.ch,r.sticky),s=o[l];if(s.from!=r.ch&&s.to!=r.ch)return t;var a=l+(s.from==r.ch==(1!=s.level)?0:1);if(0==a||a==o.length)return t;var u;if(n.line!=r.line)u=(n.line-r.line)*("ltr"==e.doc.direction?1:-1)>0;else{var c=Ce(o,n.ch,n.sticky),f=c-l||(n.ch-r.ch)*(1==s.level?-1:1);u=c==a-1||c==a?f<0:f>0}var h=o[a+(u?-1:0)],d=u==(1==h.level),p=d?h.from:h.to,g=d?"after":"before";return r.ch==p&&r.sticky==g?t:new Ts(new E(r.line,p,g),n)}function Io(e,t,r,n){var i,o;if(t.touches)i=t.touches[0].clientX,o=t.touches[0].clientY;else try{i=t.clientX,o=t.clientY}catch(t){return!1}if(i>=Math.floor(e.display.gutters.getBoundingClientRect().right))return!1;n&&We(t);var l=e.display,s=l.lineDiv.getBoundingClientRect();if(o>s.bottom||!Oe(e,r))return He(t);o-=s.top-l.viewOffset;for(var a=0;a<e.options.gutters.length;++a){var u=l.gutters.childNodes[a];if(u&&u.getBoundingClientRect().right>=i)return Te(e,r,e,D(e.doc,o),e.options.gutters[a],t),He(t)}}function zo(e,t){return Io(e,t,"gutterClick",!0)}function Ro(e,t){Ft(e.display,t)||Bo(e,t)||Me(e,t,"contextmenu")||e.display.input.onContextMenu(t)}function Bo(e,t){return!!Oe(e,"gutterContextMenu")&&Io(e,t,"gutterContextMenu",!1)}function Go(e){e.display.wrapper.className=e.display.wrapper.className.replace(/\s*cm-s-\S+/g,"")+e.options.theme.replace(/(^|\s)\s*/g," cm-s-"),er(e)}function Uo(e){Hn(e),vn(e),zr(e)}function Vo(e,t,r){if(!t!=!(r&&r!=Xs)){var n=e.display.dragFunctions,i=t?Ql:ke;i(e.display.scroller,"dragstart",n.start),i(e.display.scroller,"dragenter",n.enter),i(e.display.scroller,"dragover",n.over),i(e.display.scroller,"dragleave",n.leave),i(e.display.scroller,"drop",n.drop)}}function Ko(e){e.options.lineWrapping?(s(e.display.wrapper,"CodeMirror-wrap"),e.display.sizer.style.minWidth="",e.display.sizerWidth=null):(Fl(e.display.wrapper,"CodeMirror-wrap"),we(e)),Cr(e),vn(e),er(e),setTimeout(function(){return en(e)},100)}function jo(e,t){var r=this;if(!(this instanceof jo))return new jo(e,t);this.options=t=t?c(t):{},c(Ys,t,!1),Fn(t);var n=t.value;"string"==typeof n&&(n=new Ds(n,t.mode,null,t.lineSeparator,t.direction)),this.doc=n;var i=new jo.inputStyles[t.inputStyle](this),o=this.display=new T(e,n,i);o.wrapper.CodeMirror=this,Hn(this),Go(this),t.lineWrapping&&(this.display.wrapper.className+=" CodeMirror-wrap"),rn(this),this.state={keyMaps:[],overlays:[],modeGen:0,overwrite:!1,delayingBlurEvent:!1,focused:!1,suppressEdits:!1,pasteIncoming:!1,cutIncoming:!1,selectingText:!1,draggingText:!1,highlight:new Pl,keySeq:null,specialChars:null},t.autofocus&&!Tl&&o.input.focus(),gl&&vl<11&&setTimeout(function(){return r.display.input.reset(!0)},20),Xo(this),eo(),nn(this),this.curOp.forceUpdate=!0,qn(this,n),t.autofocus&&!Tl||this.hasFocus()?setTimeout(u(Hr,this),20):Fr(this);for(var l in _s)_s.hasOwnProperty(l)&&_s[l](r,t[l],Xs);Rr(this),t.finishInit&&t.finishInit(this);for(var s=0;s<$s.length;++s)$s[s](r);on(this),ml&&t.lineWrapping&&"optimizelegibility"==getComputedStyle(o.lineDiv).textRendering&&(o.lineDiv.style.textRendering="auto")}function Xo(e){function t(){i.activeTouch&&(o=setTimeout(function(){return i.activeTouch=null},1e3),(l=i.activeTouch).end=+new Date)}function r(e){if(1!=e.touches.length)return!1;var t=e.touches[0];return t.radiusX<=1&&t.radiusY<=1}function n(e,t){if(null==t.left)return!0;var r=t.left-e.left,n=t.top-e.top;return r*r+n*n>400}var i=e.display;Ql(i.scroller,"mousedown",dn(e,Oo)),gl&&vl<11?Ql(i.scroller,"dblclick",dn(e,function(t){if(!Me(e,t)){var r=Sr(e,t);if(r&&!zo(e,t)&&!Ft(e.display,t)){We(t);var n=e.findWordAt(r);di(e.doc,n.anchor,n.head)}}})):Ql(i.scroller,"dblclick",function(t){return Me(e,t)||We(t)}),Hl||Ql(i.scroller,"contextmenu",function(t){return Ro(e,t)});var o,l={end:0};Ql(i.scroller,"touchstart",function(t){if(!Me(e,t)&&!r(t)&&!zo(e,t)){i.input.ensurePolled(),clearTimeout(o);var n=+new Date;i.activeTouch={start:n,moved:!1,prev:n-l.end<=300?l:null},1==t.touches.length&&(i.activeTouch.left=t.touches[0].pageX,i.activeTouch.top=t.touches[0].pageY)}}),Ql(i.scroller,"touchmove",function(){i.activeTouch&&(i.activeTouch.moved=!0)}),Ql(i.scroller,"touchend",function(r){var o=i.activeTouch;if(o&&!Ft(i,r)&&null!=o.left&&!o.moved&&new Date-o.start<300){var l,s=e.coordsChar(i.activeTouch,"page");l=!o.prev||n(o,o.prev)?new Ts(s,s):!o.prev.prev||n(o,o.prev.prev)?e.findWordAt(s):new Ts(E(s.line,0),U(e.doc,E(s.line+1,0))),e.setSelection(l.anchor,l.head),e.focus(),We(r)}t()}),Ql(i.scroller,"touchcancel",t),Ql(i.scroller,"scroll",function(){i.scroller.clientHeight&&(qr(e,i.scroller.scrollTop),Qr(e,i.scroller.scrollLeft,!0),Te(e,"scroll",e))}),Ql(i.scroller,"mousewheel",function(t){return In(e,t)}),Ql(i.scroller,"DOMMouseScroll",function(t){return In(e,t)}),Ql(i.wrapper,"scroll",function(){return i.wrapper.scrollTop=i.wrapper.scrollLeft=0}),i.dragFunctions={enter:function(t){Me(e,t)||Fe(t)},over:function(t){Me(e,t)||(Zi(e,t),Fe(t))},start:function(t){return qi(e,t)},drop:dn(e,$i),leave:function(t){Me(e,t)||Qi(e)}};var s=i.input.getField();Ql(s,"keyup",function(t){return To.call(e,t)}),Ql(s,"keydown",dn(e,Lo)),Ql(s,"keypress",dn(e,Mo)),Ql(s,"focus",function(t){return Hr(e,t)}),Ql(s,"blur",function(t){return Fr(e,t)})}function Yo(e,t,r,n){var i,o=e.doc;null==r&&(r="add"),"smart"==r&&(o.mode.indent?i=$e(e,t).state:r="prev");var l=e.options.tabSize,s=M(o,t),a=f(s.text,null,l);s.stateAfter&&(s.stateAfter=null);var u,c=s.text.match(/^\s*/)[0];if(n||/\S/.test(s.text)){if("smart"==r&&((u=o.mode.indent(i,s.text.slice(c.length),s.text))==Bl||u>150)){if(!n)return;r="prev"}}else u=0,r="not";"prev"==r?u=t>o.first?f(M(o,t-1).text,null,l):0:"add"==r?u=a+e.options.indentUnit:"subtract"==r?u=a-e.options.indentUnit:"number"==typeof r&&(u=a+r),u=Math.max(0,u);var h="",d=0;if(e.options.indentWithTabs)for(var g=Math.floor(u/l);g;--g)d+=l,h+="\t";if(d<u&&(h+=p(u-d)),h!=c)return Ei(o,h,E(t,0),E(t,c.length),"+input"),s.stateAfter=null,!0;for(var v=0;v<o.sel.ranges.length;v++){var m=o.sel.ranges[v];if(m.head.line==t&&m.head.ch<c.length){var y=E(t,c.length);gi(o,v,new Ts(y,y));break}}}function _o(e){qs=e}function $o(e,t,r,n,i){var o=e.doc;e.display.shift=!1,n||(n=o.sel);var l=e.state.pasteIncoming||"paste"==i,s=es(t),a=null;if(l&&n.ranges.length>1)if(qs&&qs.text.join("\n")==t){if(n.ranges.length%qs.text.length==0){a=[];for(var u=0;u<qs.text.length;u++)a.push(o.splitLines(qs.text[u]))}}else s.length==n.ranges.length&&e.options.pasteLinesPerSelection&&(a=v(s,function(e){return[e]}));for(var c,f=n.ranges.length-1;f>=0;f--){var h=n.ranges[f],d=h.from(),p=h.to();h.empty()&&(r&&r>0?d=E(d.line,d.ch-r):e.state.overwrite&&!l?p=E(p.line,Math.min(M(o,p.line).text.length,p.ch+g(s).length)):qs&&qs.lineWise&&qs.text.join("\n")==t&&(d=p=E(d.line,0))),c=e.curOp.updateInput;var m={from:d,to:p,text:a?a[f%a.length]:s,origin:i||(l?"paste":e.state.cutIncoming?"cut":"+input")};Oi(e.doc,m),bt(e,"inputRead",e,m)}t&&!l&&Zo(e,t),jr(e),e.curOp.updateInput=c,e.curOp.typing=!0,e.state.pasteIncoming=e.state.cutIncoming=!1}function qo(e,t){var r=e.clipboardData&&e.clipboardData.getData("Text");if(r)return e.preventDefault(),t.isReadOnly()||t.options.disableInput||hn(t,function(){return $o(t,r,0,null,"paste")}),!0}function Zo(e,t){if(e.options.electricChars&&e.options.smartIndent)for(var r=e.doc.sel,n=r.ranges.length-1;n>=0;n--){var i=r.ranges[n];if(!(i.head.ch>100||n&&r.ranges[n-1].head.line==i.head.line)){var o=e.getModeAt(i.head),l=!1;if(o.electricChars){for(var s=0;s<o.electricChars.length;s++)if(t.indexOf(o.electricChars.charAt(s))>-1){l=Yo(e,i.head.line,"smart");break}}else o.electricInput&&o.electricInput.test(M(e.doc,i.head.line).text.slice(0,i.head.ch))&&(l=Yo(e,i.head.line,"smart"));l&&bt(e,"electricInput",e,i.head.line)}}}function Qo(e){for(var t=[],r=[],n=0;n<e.doc.sel.ranges.length;n++){var i=e.doc.sel.ranges[n].head.line,o={anchor:E(i,0),head:E(i+1,0)};r.push(o),t.push(e.getRange(o.anchor,o.head))}return{text:t,ranges:r}}function Jo(e,t){e.setAttribute("autocorrect","off"),e.setAttribute("autocapitalize","off"),e.setAttribute("spellcheck",!!t)}function el(){var e=n("textarea",null,null,"position: absolute; bottom: -1em; padding: 0; width: 1px; height: 1em; outline: none"),t=n("div",[e],null,"overflow: hidden; position: relative; width: 3px; height: 0px;");return ml?e.style.width="1000px":e.setAttribute("wrap","off"),Ll&&(e.style.border="1px solid black"),Jo(e),t}function tl(e,t,r,n,i){function o(){var n=t.line+r;return!(n<e.first||n>=e.first+e.size)&&(t=new E(n,t.ch,t.sticky),u=M(e,n))}function l(n){var l;if(null==(l=i?go(e.cm,u,t,r):ho(u,t,r))){if(n||!o())return!1;t=po(i,e.cm,u,t.line,r)}else t=l;return!0}var s=t,a=r,u=M(e,t.line);if("char"==n)l();else if("column"==n)l(!0);else if("word"==n||"group"==n)for(var c=null,f="group"==n,h=e.cm&&e.cm.getHelper(t,"wordChars"),d=!0;!(r<0)||l(!d);d=!1){var p=u.text.charAt(t.ch)||"\n",g=x(p,h)?"w":f&&"\n"==p?"n":!f||/\s/.test(p)?null:"p";if(!f||d||g||(g="s"),c&&c!=g){r<0&&(r=1,l(),t.sticky="after");break}if(g&&(c=g),r>0&&!l(!d))break}var v=ki(e,t,s,a,!0);return I(s,v)&&(v.hitSide=!0),v}function rl(e,t,r,n){var i,o=e.doc,l=t.left;if("page"==n){var s=Math.min(e.display.wrapper.clientHeight,window.innerHeight||document.documentElement.clientHeight),a=Math.max(s-.5*mr(e.display),3);i=(r>0?t.bottom:t.top)+r*a}else"line"==n&&(i=r>0?t.bottom+3:t.top-3);for(var u;(u=cr(e,l,i)).outside;){if(r<0?i<=0:i>=o.height){u.hitSide=!0;break}i+=5*r}return u}function nl(e,t){var r=jt(e,t.line);if(!r||r.hidden)return null;var n=M(e.doc,t.line),i=Ut(r,n,t.line),o=Se(n,e.doc.direction),l="left";o&&(l=Ce(o,t.ch)%2?"right":"left");var s=_t(i.map,t.ch,l);return s.offset="right"==s.collapse?s.end:s.start,s}function il(e){for(var t=e;t;t=t.parentNode)if(/CodeMirror-gutter-wrapper/.test(t.className))return!0;return!1}function ol(e,t){return t&&(e.bad=!0),e}function ll(e,t,r,n,i){function o(e){return function(t){return t.id==e}}function l(){c&&(u+=f,c=!1)}function s(e){e&&(l(),u+=e)}function a(t){if(1==t.nodeType){var r=t.getAttribute("cm-text");if(null!=r)return void s(r||t.textContent.replace(/\u200b/g,""));var u,h=t.getAttribute("cm-marker");if(h){var d=e.findMarks(E(n,0),E(i+1,0),o(+h));return void(d.length&&(u=d[0].find(0))&&s(N(e.doc,u.from,u.to).join(f)))}if("false"==t.getAttribute("contenteditable"))return;var p=/^(pre|div|p)$/i.test(t.nodeName);p&&l();for(var g=0;g<t.childNodes.length;g++)a(t.childNodes[g]);p&&(c=!0)}else 3==t.nodeType&&s(t.nodeValue)}for(var u="",c=!1,f=e.doc.lineSeparator();a(t),t!=r;)t=t.nextSibling;return u}function sl(e,t,r){var n;if(t==e.display.lineDiv){if(!(n=e.display.lineDiv.childNodes[r]))return ol(e.clipPos(E(e.display.viewTo-1)),!0);t=null,r=0}else for(n=t;;n=n.parentNode){if(!n||n==e.display.lineDiv)return null;if(n.parentNode&&n.parentNode==e.display.lineDiv)break}for(var i=0;i<e.display.view.length;i++){var o=e.display.view[i];if(o.node==n)return al(o,t,r)}}function al(e,t,r){function n(t,r,n){for(var i=-1;i<(f?f.length:0);i++)for(var o=i<0?c.map:f[i],l=0;l<o.length;l+=3){var s=o[l+2];if(s==t||s==r){var a=W(i<0?e.line:e.rest[i]),u=o[l]+n;return(n<0||s!=t)&&(u=o[l+(n?1:0)]),E(a,u)}}}var i=e.text.firstChild,l=!1;if(!t||!o(i,t))return ol(E(W(e.line),0),!0);if(t==i&&(l=!0,t=i.childNodes[r],r=0,!t)){var s=e.rest?g(e.rest):e.line;return ol(E(W(s),s.text.length),l)}var a=3==t.nodeType?t:null,u=t;for(a||1!=t.childNodes.length||3!=t.firstChild.nodeType||(a=t.firstChild,r&&(r=a.nodeValue.length));u.parentNode!=i;)u=u.parentNode;var c=e.measure,f=c.maps,h=n(a,u,r);if(h)return ol(h,l);for(var d=u.nextSibling,p=a?a.nodeValue.length-r:0;d;d=d.nextSibling){if(h=n(d,d.firstChild,0))return ol(E(h.line,h.ch-p),l);p+=d.textContent.length}for(var v=u.previousSibling,m=r;v;v=v.previousSibling){if(h=n(v,v.firstChild,-1))return ol(E(h.line,h.ch+m),l);m+=v.textContent.length}}var ul=navigator.userAgent,cl=navigator.platform,fl=/gecko\/\d/i.test(ul),hl=/MSIE \d/.test(ul),dl=/Trident\/(?:[7-9]|\d{2,})\..*rv:(\d+)/.exec(ul),pl=/Edge\/(\d+)/.exec(ul),gl=hl||dl||pl,vl=gl&&(hl?document.documentMode||6:+(pl||dl)[1]),ml=!pl&&/WebKit\//.test(ul),yl=ml&&/Qt\/\d+\.\d+/.test(ul),bl=!pl&&/Chrome\//.test(ul),wl=/Opera\//.test(ul),xl=/Apple Computer/.test(navigator.vendor),Cl=/Mac OS X 1\d\D([8-9]|\d\d)\D/.test(ul),Sl=/PhantomJS/.test(ul),Ll=!pl&&/AppleWebKit/.test(ul)&&/Mobile\/\w+/.test(ul),kl=/Android/.test(ul),Tl=Ll||kl||/webOS|BlackBerry|Opera Mini|Opera Mobi|IEMobile/i.test(ul),Ml=Ll||/Mac/.test(cl),Nl=/\bCrOS\b/.test(ul),Ol=/win/i.test(cl),Al=wl&&ul.match(/Version\/(\d*\.\d*)/);Al&&(Al=Number(Al[1])),Al&&Al>=15&&(wl=!1,ml=!0);var Wl,Dl=Ml&&(yl||wl&&(null==Al||Al<12.11)),Hl=fl||gl&&vl>=9,Fl=function(t,r){var n=t.className,i=e(r).exec(n);if(i){var o=n.slice(i.index+i[0].length);t.className=n.slice(0,i.index)+(o?i[1]+o:"")}};Wl=document.createRange?function(e,t,r,n){var i=document.createRange();return i.setEnd(n||e,r),i.setStart(e,t),i}:function(e,t,r){var n=document.body.createTextRange();try{n.moveToElementText(e.parentNode)}catch(e){return n}return n.collapse(!0),n.moveEnd("character",r),n.moveStart("character",t),n};var El=function(e){e.select()};Ll?El=function(e){e.selectionStart=0,e.selectionEnd=e.value.length}:gl&&(El=function(e){try{e.select()}catch(e){}});var Pl=function(){this.id=null};Pl.prototype.set=function(e,t){clearTimeout(this.id),this.id=setTimeout(t,e)};var Il,zl,Rl=30,Bl={toString:function(){return"CodeMirror.Pass"}},Gl={scroll:!1},Ul={origin:"*mouse"},Vl={origin:"+move"},Kl=[""],jl=/[\u00df\u0587\u0590-\u05f4\u0600-\u06ff\u3040-\u309f\u30a0-\u30ff\u3400-\u4db5\u4e00-\u9fcc\uac00-\ud7af]/,Xl=/[\u0300-\u036f\u0483-\u0489\u0591-\u05bd\u05bf\u05c1\u05c2\u05c4\u05c5\u05c7\u0610-\u061a\u064b-\u065e\u0670\u06d6-\u06dc\u06de-\u06e4\u06e7\u06e8\u06ea-\u06ed\u0711\u0730-\u074a\u07a6-\u07b0\u07eb-\u07f3\u0816-\u0819\u081b-\u0823\u0825-\u0827\u0829-\u082d\u0900-\u0902\u093c\u0941-\u0948\u094d\u0951-\u0955\u0962\u0963\u0981\u09bc\u09be\u09c1-\u09c4\u09cd\u09d7\u09e2\u09e3\u0a01\u0a02\u0a3c\u0a41\u0a42\u0a47\u0a48\u0a4b-\u0a4d\u0a51\u0a70\u0a71\u0a75\u0a81\u0a82\u0abc\u0ac1-\u0ac5\u0ac7\u0ac8\u0acd\u0ae2\u0ae3\u0b01\u0b3c\u0b3e\u0b3f\u0b41-\u0b44\u0b4d\u0b56\u0b57\u0b62\u0b63\u0b82\u0bbe\u0bc0\u0bcd\u0bd7\u0c3e-\u0c40\u0c46-\u0c48\u0c4a-\u0c4d\u0c55\u0c56\u0c62\u0c63\u0cbc\u0cbf\u0cc2\u0cc6\u0ccc\u0ccd\u0cd5\u0cd6\u0ce2\u0ce3\u0d3e\u0d41-\u0d44\u0d4d\u0d57\u0d62\u0d63\u0dca\u0dcf\u0dd2-\u0dd4\u0dd6\u0ddf\u0e31\u0e34-\u0e3a\u0e47-\u0e4e\u0eb1\u0eb4-\u0eb9\u0ebb\u0ebc\u0ec8-\u0ecd\u0f18\u0f19\u0f35\u0f37\u0f39\u0f71-\u0f7e\u0f80-\u0f84\u0f86\u0f87\u0f90-\u0f97\u0f99-\u0fbc\u0fc6\u102d-\u1030\u1032-\u1037\u1039\u103a\u103d\u103e\u1058\u1059\u105e-\u1060\u1071-\u1074\u1082\u1085\u1086\u108d\u109d\u135f\u1712-\u1714\u1732-\u1734\u1752\u1753\u1772\u1773\u17b7-\u17bd\u17c6\u17c9-\u17d3\u17dd\u180b-\u180d\u18a9\u1920-\u1922\u1927\u1928\u1932\u1939-\u193b\u1a17\u1a18\u1a56\u1a58-\u1a5e\u1a60\u1a62\u1a65-\u1a6c\u1a73-\u1a7c\u1a7f\u1b00-\u1b03\u1b34\u1b36-\u1b3a\u1b3c\u1b42\u1b6b-\u1b73\u1b80\u1b81\u1ba2-\u1ba5\u1ba8\u1ba9\u1c2c-\u1c33\u1c36\u1c37\u1cd0-\u1cd2\u1cd4-\u1ce0\u1ce2-\u1ce8\u1ced\u1dc0-\u1de6\u1dfd-\u1dff\u200c\u200d\u20d0-\u20f0\u2cef-\u2cf1\u2de0-\u2dff\u302a-\u302f\u3099\u309a\ua66f-\ua672\ua67c\ua67d\ua6f0\ua6f1\ua802\ua806\ua80b\ua825\ua826\ua8c4\ua8e0-\ua8f1\ua926-\ua92d\ua947-\ua951\ua980-\ua982\ua9b3\ua9b6-\ua9b9\ua9bc\uaa29-\uaa2e\uaa31\uaa32\uaa35\uaa36\uaa43\uaa4c\uaab0\uaab2-\uaab4\uaab7\uaab8\uaabe\uaabf\uaac1\uabe5\uabe8\uabed\udc00-\udfff\ufb1e\ufe00-\ufe0f\ufe20-\ufe26\uff9e\uff9f]/,Yl=!1,_l=!1,$l=null,ql=function(){function e(e){return e<=247?r.charAt(e):1424<=e&&e<=1524?"R":1536<=e&&e<=1785?n.charAt(e-1536):1774<=e&&e<=2220?"r":8192<=e&&e<=8203?"w":8204==e?"b":"L"}function t(e,t,r){this.level=e,this.from=t,this.to=r}var r="bbbbbbbbbtstwsbbbbbbbbbbbbbbssstwNN%%%NNNNNN,N,N1111111111NNNNNNNLLLLLLLLLLLLLLLLLLLLLLLLLLNNNNNNLLLLLLLLLLLLLLLLLLLLLLLLLLNNNNbbbbbbsbbbbbbbbbbbbbbbbbbbbbbbbbb,N%%%%NNNNLNNNNN%%11NLNNN1LNNNNNLLLLLLLLLLLLLLLLLLLLLLLNLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLN",n="nnnnnnNNr%%r,rNNmmmmmmmmmmmrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrmmmmmmmmmmmmmmmmmmmmmnnnnnnnnnn%nnrrrmrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrmmmmmmmnNmmmmmmrrmmNmmmmrr1111111111",i=/[\u0590-\u05f4\u0600-\u06ff\u0700-\u08ac]/,o=/[stwN]/,l=/[LRr]/,s=/[Lb1n]/,a=/[1n]/;return function(r,n){var u="ltr"==n?"L":"R";if(0==r.length||"ltr"==n&&!i.test(r))return!1;for(var c=r.length,f=[],h=0;h<c;++h)f.push(e(r.charCodeAt(h)));for(var d=0,p=u;d<c;++d){var v=f[d];"m"==v?f[d]=p:p=v}for(var m=0,y=u;m<c;++m){var b=f[m];"1"==b&&"r"==y?f[m]="n":l.test(b)&&(y=b,"r"==b&&(f[m]="R"))}for(var w=1,x=f[0];w<c-1;++w){var C=f[w];"+"==C&&"1"==x&&"1"==f[w+1]?f[w]="1":","!=C||x!=f[w+1]||"1"!=x&&"n"!=x||(f[w]=x),x=C}for(var S=0;S<c;++S){var L=f[S];if(","==L)f[S]="N";else if("%"==L){var k=void 0;for(k=S+1;k<c&&"%"==f[k];++k);for(var T=S&&"!"==f[S-1]||k<c&&"1"==f[k]?"1":"N",M=S;M<k;++M)f[M]=T;S=k-1}}for(var N=0,O=u;N<c;++N){var A=f[N];"L"==O&&"1"==A?f[N]="L":l.test(A)&&(O=A)}for(var W=0;W<c;++W)if(o.test(f[W])){var D=void 0;for(D=W+1;D<c&&o.test(f[D]);++D);for(var H="L"==(W?f[W-1]:u),F=H==("L"==(D<c?f[D]:u))?H?"L":"R":u,E=W;E<D;++E)f[E]=F;W=D-1}for(var P,I=[],z=0;z<c;)if(s.test(f[z])){var R=z;for(++z;z<c&&s.test(f[z]);++z);I.push(new t(0,R,z))}else{var B=z,G=I.length;for(++z;z<c&&"L"!=f[z];++z);for(var U=B;U<z;)if(a.test(f[U])){B<U&&I.splice(G,0,new t(1,B,U));var V=U;for(++U;U<z&&a.test(f[U]);++U);I.splice(G,0,new t(2,V,U)),B=U}else++U;B<z&&I.splice(G,0,new t(1,B,z))}return 1==I[0].level&&(P=r.match(/^\s+/))&&(I[0].from=P[0].length,I.unshift(new t(0,0,P[0].length))),1==g(I).level&&(P=r.match(/\s+$/))&&(g(I).to-=P[0].length,I.push(new t(0,c-P[0].length,c))),"rtl"==n?I.reverse():I}}(),Zl=[],Ql=function(e,t,r){if(e.addEventListener)e.addEventListener(t,r,!1);else if(e.attachEvent)e.attachEvent("on"+t,r);else{var n=e._handlers||(e._handlers={});n[t]=(n[t]||Zl).concat(r)}},Jl=function(){if(gl&&vl<9)return!1;var e=n("div");return"draggable"in e||"dragDrop"in e}(),es=3!="\n\nb".split(/\n/).length?function(e){for(var t=0,r=[],n=e.length;t<=n;){var i=e.indexOf("\n",t);-1==i&&(i=e.length);var o=e.slice(t,"\r"==e.charAt(i-1)?i-1:i),l=o.indexOf("\r");-1!=l?(r.push(o.slice(0,l)),t+=l+1):(r.push(o),t=i+1)}return r}:function(e){return e.split(/\r\n?|\n/)},ts=window.getSelection?function(e){try{return e.selectionStart!=e.selectionEnd}catch(e){return!1}}:function(e){var t;try{t=e.ownerDocument.selection.createRange()}catch(e){}return!(!t||t.parentElement()!=e)&&0!=t.compareEndPoints("StartToEnd",t)},rs=function(){var e=n("div");return"oncopy"in e||(e.setAttribute("oncopy","return;"),"function"==typeof e.oncopy)}(),ns=null,is={},os={},ls={},ss=function(e,t,r){this.pos=this.start=0,this.string=e,this.tabSize=t||8,this.lastColumnPos=this.lastColumnValue=0,this.lineStart=0,this.lineOracle=r};ss.prototype.eol=function(){return this.pos>=this.string.length},ss.prototype.sol=function(){return this.pos==this.lineStart},ss.prototype.peek=function(){return this.string.charAt(this.pos)||void 0},ss.prototype.next=function(){if(this.pos<this.string.length)return this.string.charAt(this.pos++)},ss.prototype.eat=function(e){var t=this.string.charAt(this.pos);if("string"==typeof e?t==e:t&&(e.test?e.test(t):e(t)))return++this.pos,t},ss.prototype.eatWhile=function(e){for(var t=this.pos;this.eat(e););return this.pos>t},ss.prototype.eatSpace=function(){for(var e=this,t=this.pos;/[\s\u00a0]/.test(this.string.charAt(this.pos));)++e.pos;return this.pos>t},ss.prototype.skipToEnd=function(){this.pos=this.string.length},ss.prototype.skipTo=function(e){var t=this.string.indexOf(e,this.pos);if(t>-1)return this.pos=t,!0},ss.prototype.backUp=function(e){this.pos-=e},ss.prototype.column=function(){return this.lastColumnPos<this.start&&(this.lastColumnValue=f(this.string,this.start,this.tabSize,this.lastColumnPos,this.lastColumnValue),this.lastColumnPos=this.start),this.lastColumnValue-(this.lineStart?f(this.string,this.lineStart,this.tabSize):0)},ss.prototype.indentation=function(){return f(this.string,null,this.tabSize)-(this.lineStart?f(this.string,this.lineStart,this.tabSize):0)},ss.prototype.match=function(e,t,r){if("string"!=typeof e){var n=this.string.slice(this.pos).match(e);return n&&n.index>0?null:(n&&!1!==t&&(this.pos+=n[0].length),n)}var i=function(e){return r?e.toLowerCase():e};if(i(this.string.substr(this.pos,e.length))==i(e))return!1!==t&&(this.pos+=e.length),!0},ss.prototype.current=function(){return this.string.slice(this.start,this.pos)},ss.prototype.hideFirstChars=function(e,t){this.lineStart+=e;try{return t()}finally{this.lineStart-=e}},ss.prototype.lookAhead=function(e){var t=this.lineOracle;return t&&t.lookAhead(e)};var as=function(e,t){this.state=e,this.lookAhead=t},us=function(e,t,r,n){this.state=t,this.doc=e,this.line=r,this.maxLookAhead=n||0};us.prototype.lookAhead=function(e){var t=this.doc.getLine(this.line+e);return null!=t&&e>this.maxLookAhead&&(this.maxLookAhead=e),t},us.prototype.nextLine=function(){this.line++,this.maxLookAhead>0&&this.maxLookAhead--},us.fromSaved=function(e,t,r){return t instanceof as?new us(e,Ke(e.mode,t.state),r,t.lookAhead):new us(e,Ke(e.mode,t),r)},us.prototype.save=function(e){var t=!1!==e?Ke(this.doc.mode,this.state):this.state;return this.maxLookAhead>0?new as(t,this.maxLookAhead):t};var cs=function(e,t,r){this.start=e.start,this.end=e.pos,this.string=e.current(),this.type=t||null,this.state=r},fs=function(e,t,r){this.text=e,ne(this,t),this.height=r?r(this):1};fs.prototype.lineNo=function(){return W(this)},Ae(fs);var hs,ds={},ps={},gs=null,vs=null,ms={left:0,right:0,top:0,bottom:0},ys=function(e,t,r){this.cm=r;var i=this.vert=n("div",[n("div",null,null,"min-width: 1px")],"CodeMirror-vscrollbar"),o=this.horiz=n("div",[n("div",null,null,"height: 100%; min-height: 1px")],"CodeMirror-hscrollbar");e(i),e(o),Ql(i,"scroll",function(){i.clientHeight&&t(i.scrollTop,"vertical")}),Ql(o,"scroll",function(){o.clientWidth&&t(o.scrollLeft,"horizontal")}),this.checkedZeroWidth=!1,gl&&vl<8&&(this.horiz.style.minHeight=this.vert.style.minWidth="18px")};ys.prototype.update=function(e){var t=e.scrollWidth>e.clientWidth+1,r=e.scrollHeight>e.clientHeight+1,n=e.nativeBarWidth;if(r){this.vert.style.display="block",this.vert.style.bottom=t?n+"px":"0";var i=e.viewHeight-(t?n:0);this.vert.firstChild.style.height=Math.max(0,e.scrollHeight-e.clientHeight+i)+"px"}else this.vert.style.display="",this.vert.firstChild.style.height="0";if(t){this.horiz.style.display="block",this.horiz.style.right=r?n+"px":"0",this.horiz.style.left=e.barLeft+"px";var o=e.viewWidth-e.barLeft-(r?n:0);this.horiz.firstChild.style.width=Math.max(0,e.scrollWidth-e.clientWidth+o)+"px"}else this.horiz.style.display="",this.horiz.firstChild.style.width="0";return!this.checkedZeroWidth&&e.clientHeight>0&&(0==n&&this.zeroWidthHack(),this.checkedZeroWidth=!0),{right:r?n:0,bottom:t?n:0}},ys.prototype.setScrollLeft=function(e){this.horiz.scrollLeft!=e&&(this.horiz.scrollLeft=e),this.disableHoriz&&this.enableZeroWidthBar(this.horiz,this.disableHoriz,"horiz")},ys.prototype.setScrollTop=function(e){this.vert.scrollTop!=e&&(this.vert.scrollTop=e),this.disableVert&&this.enableZeroWidthBar(this.vert,this.disableVert,"vert")},ys.prototype.zeroWidthHack=function(){var e=Ml&&!Cl?"12px":"18px";this.horiz.style.height=this.vert.style.width=e,this.horiz.style.pointerEvents=this.vert.style.pointerEvents="none",this.disableHoriz=new Pl,this.disableVert=new Pl},ys.prototype.enableZeroWidthBar=function(e,t,r){function n(){var i=e.getBoundingClientRect();("vert"==r?document.elementFromPoint(i.right-1,(i.top+i.bottom)/2):document.elementFromPoint((i.right+i.left)/2,i.bottom-1))!=e?e.style.pointerEvents="none":t.set(1e3,n)}e.style.pointerEvents="auto",t.set(1e3,n)},ys.prototype.clear=function(){var e=this.horiz.parentNode;e.removeChild(this.horiz),e.removeChild(this.vert)};var bs=function(){};bs.prototype.update=function(){return{bottom:0,right:0}},bs.prototype.setScrollLeft=function(){},bs.prototype.setScrollTop=function(){},bs.prototype.clear=function(){};var ws={native:ys,null:bs},xs=0,Cs=function(e,t,r){var n=e.display;this.viewport=t,this.visible=Ir(n,e.doc,t),this.editorIsHidden=!n.wrapper.offsetWidth,this.wrapperHeight=n.wrapper.clientHeight,this.wrapperWidth=n.wrapper.clientWidth,this.oldDisplayWidth=Rt(e),this.force=r,this.dims=br(e),this.events=[]};Cs.prototype.signal=function(e,t){Oe(e,t)&&this.events.push(arguments)},Cs.prototype.finish=function(){for(var e=this,t=0;t<this.events.length;t++)Te.apply(null,e.events[t])};var Ss=0,Ls=null;gl?Ls=-.53:fl?Ls=15:bl?Ls=-.7:xl&&(Ls=-1/3);var ks=function(e,t){this.ranges=e,this.primIndex=t};ks.prototype.primary=function(){return this.ranges[this.primIndex]},ks.prototype.equals=function(e){var t=this;if(e==this)return!0;if(e.primIndex!=this.primIndex||e.ranges.length!=this.ranges.length)return!1;for(var r=0;r<this.ranges.length;r++){var n=t.ranges[r],i=e.ranges[r];if(!I(n.anchor,i.anchor)||!I(n.head,i.head))return!1}return!0},ks.prototype.deepCopy=function(){for(var e=this,t=[],r=0;r<this.ranges.length;r++)t[r]=new Ts(z(e.ranges[r].anchor),z(e.ranges[r].head));return new ks(t,this.primIndex)},ks.prototype.somethingSelected=function(){for(var e=this,t=0;t<this.ranges.length;t++)if(!e.ranges[t].empty())return!0;return!1},ks.prototype.contains=function(e,t){var r=this;t||(t=e);for(var n=0;n<this.ranges.length;n++){var i=r.ranges[n];if(P(t,i.from())>=0&&P(e,i.to())<=0)return n}return-1};var Ts=function(e,t){this.anchor=e,this.head=t};Ts.prototype.from=function(){return B(this.anchor,this.head)},Ts.prototype.to=function(){return R(this.anchor,this.head)},Ts.prototype.empty=function(){return this.head.line==this.anchor.line&&this.head.ch==this.anchor.ch},Bi.prototype={chunkSize:function(){return this.lines.length},removeInner:function(e,t){for(var r=this,n=e,i=e+t;n<i;++n){var o=r.lines[n];r.height-=o.height,ot(o),bt(o,"delete")}this.lines.splice(e,t)},collapse:function(e){e.push.apply(e,this.lines)},insertInner:function(e,t,r){var n=this;this.height+=r,this.lines=this.lines.slice(0,e).concat(t).concat(this.lines.slice(e));for(var i=0;i<t.length;++i)t[i].parent=n},iterN:function(e,t,r){for(var n=this,i=e+t;e<i;++e)if(r(n.lines[e]))return!0}},Gi.prototype={chunkSize:function(){return this.size},removeInner:function(e,t){var r=this;this.size-=t;for(var n=0;n<this.children.length;++n){var i=r.children[n],o=i.chunkSize();if(e<o){var l=Math.min(t,o-e),s=i.height;if(i.removeInner(e,l),r.height-=s-i.height,o==l&&(r.children.splice(n--,1),i.parent=null),0==(t-=l))break;e=0}else e-=o}if(this.size-t<25&&(this.children.length>1||!(this.children[0]instanceof Bi))){var a=[];this.collapse(a),this.children=[new Bi(a)],this.children[0].parent=this}},collapse:function(e){for(var t=this,r=0;r<this.children.length;++r)t.children[r].collapse(e)},insertInner:function(e,t,r){var n=this;this.size+=t.length,this.height+=r;for(var i=0;i<this.children.length;++i){var o=n.children[i],l=o.chunkSize();if(e<=l){if(o.insertInner(e,t,r),o.lines&&o.lines.length>50){for(var s=o.lines.length%25+25,a=s;a<o.lines.length;){var u=new Bi(o.lines.slice(a,a+=25));o.height-=u.height,n.children.splice(++i,0,u),u.parent=n}o.lines=o.lines.slice(0,s),n.maybeSpill()}break}e-=l}},maybeSpill:function(){if(!(this.children.length<=10)){var e=this;do{var t=new Gi(e.children.splice(e.children.length-5,5));if(e.parent){e.size-=t.size,e.height-=t.height;var r=h(e.parent.children,e);e.parent.children.splice(r+1,0,t)}else{var n=new Gi(e.children);n.parent=e,e.children=[n,t],e=n}t.parent=e.parent}while(e.children.length>10);e.parent.maybeSpill()}},iterN:function(e,t,r){for(var n=this,i=0;i<this.children.length;++i){var o=n.children[i],l=o.chunkSize();if(e<l){var s=Math.min(t,l-e);if(o.iterN(e,s,r))return!0;if(0==(t-=s))break;e=0}else e-=l}}};var Ms=function(e,t,r){var n=this;if(r)for(var i in r)r.hasOwnProperty(i)&&(n[i]=r[i]);this.doc=e,this.node=t};Ms.prototype.clear=function(){var e=this,t=this.doc.cm,r=this.line.widgets,n=this.line,i=W(n);if(null!=i&&r){for(var o=0;o<r.length;++o)r[o]==e&&r.splice(o--,1);r.length||(n.widgets=null);var l=Ht(this);A(n,Math.max(0,n.height-l)),t&&(hn(t,function(){Ui(t,n,-l),mn(t,i,"widget")}),bt(t,"lineWidgetCleared",t,this,i))}},Ms.prototype.changed=function(){var e=this,t=this.height,r=this.doc.cm,n=this.line;this.height=null;var i=Ht(this)-t;i&&(A(n,n.height+i),r&&hn(r,function(){r.curOp.forceUpdate=!0,Ui(r,n,i),bt(r,"lineWidgetChanged",r,e,W(n))}))},Ae(Ms);var Ns=0,Os=function(e,t){this.lines=[],this.type=t,this.doc=e,this.id=++Ns};Os.prototype.clear=function(){var e=this;if(!this.explicitlyCleared){var t=this.doc.cm,r=t&&!t.curOp;if(r&&nn(t),Oe(this,"clear")){var n=this.find();n&&bt(this,"clear",n.from,n.to)}for(var i=null,o=null,l=0;l<this.lines.length;++l){var s=e.lines[l],a=_(s.markedSpans,e);t&&!e.collapsed?mn(t,W(s),"text"):t&&(null!=a.to&&(o=W(s)),null!=a.from&&(i=W(s))),s.markedSpans=$(s.markedSpans,a),null==a.from&&e.collapsed&&!ve(e.doc,s)&&t&&A(s,mr(t.display))}if(t&&this.collapsed&&!t.options.lineWrapping)for(var u=0;u<this.lines.length;++u){var c=fe(e.lines[u]),f=be(c);f>t.display.maxLineLength&&(t.display.maxLine=c,t.display.maxLineLength=f,t.display.maxLineChanged=!0)}null!=i&&t&&this.collapsed&&vn(t,i,o+1),this.lines.length=0,this.explicitlyCleared=!0,this.atomic&&this.doc.cantEdit&&(this.doc.cantEdit=!1,t&&Ci(t.doc)),t&&bt(t,"markerCleared",t,this,i,o),r&&on(t),this.parent&&this.parent.clear()}},Os.prototype.find=function(e,t){var r=this;null==e&&"bookmark"==this.type&&(e=1);for(var n,i,o=0;o<this.lines.length;++o){var l=r.lines[o],s=_(l.markedSpans,r);if(null!=s.from&&(n=E(t?l:W(l),s.from),-1==e))return n;if(null!=s.to&&(i=E(t?l:W(l),s.to),1==e))return i}return n&&{from:n,to:i}},Os.prototype.changed=function(){var e=this,t=this.find(-1,!0),r=this,n=this.doc.cm;t&&n&&hn(n,function(){var i=t.line,o=W(t.line),l=jt(n,o);if(l&&(Qt(l),n.curOp.selectionChanged=n.curOp.forceUpdate=!0),n.curOp.updateMaxLine=!0,!ve(r.doc,i)&&null!=r.height){var s=r.height;r.height=null;var a=Ht(r)-s;a&&A(i,i.height+a)}bt(n,"markerChanged",n,e)})},Os.prototype.attachLine=function(e){if(!this.lines.length&&this.doc.cm){var t=this.doc.cm.curOp;t.maybeHiddenMarkers&&-1!=h(t.maybeHiddenMarkers,this)||(t.maybeUnhiddenMarkers||(t.maybeUnhiddenMarkers=[])).push(this)}this.lines.push(e)},Os.prototype.detachLine=function(e){if(this.lines.splice(h(this.lines,e),1),!this.lines.length&&this.doc.cm){var t=this.doc.cm.curOp;(t.maybeHiddenMarkers||(t.maybeHiddenMarkers=[])).push(this)}},Ae(Os);var As=function(e,t){var r=this;this.markers=e,this.primary=t;for(var n=0;n<e.length;++n)e[n].parent=r};As.prototype.clear=function(){var e=this;if(!this.explicitlyCleared){this.explicitlyCleared=!0;for(var t=0;t<this.markers.length;++t)e.markers[t].clear();bt(this,"clear")}},As.prototype.find=function(e,t){return this.primary.find(e,t)},Ae(As);var Ws=0,Ds=function(e,t,r,n,i){if(!(this instanceof Ds))return new Ds(e,t,r,n,i);null==r&&(r=0),Gi.call(this,[new Bi([new fs("",null)])]),this.first=r,this.scrollTop=this.scrollLeft=0,this.cantEdit=!1,this.cleanGeneration=1,this.modeFrontier=this.highlightFrontier=r;var o=E(r,0);this.sel=Rn(o),this.history=new Jn(null),this.id=++Ws,this.modeOption=t,this.lineSep=n,this.direction="rtl"==i?"rtl":"ltr",this.extend=!1,"string"==typeof e&&(e=this.splitLines(e)),_n(this,{from:o,to:o,text:e}),bi(this,Rn(o),Gl)};Ds.prototype=b(Gi.prototype,{constructor:Ds,iter:function(e,t,r){r?this.iterN(e-this.first,t-e,r):this.iterN(this.first,this.first+this.size,e)},insert:function(e,t){for(var r=0,n=0;n<t.length;++n)r+=t[n].height;this.insertInner(e-this.first,t,r)},remove:function(e,t){this.removeInner(e-this.first,t)},getValue:function(e){var t=O(this,this.first,this.first+this.size);return!1===e?t:t.join(e||this.lineSeparator())},setValue:gn(function(e){var t=E(this.first,0),r=this.first+this.size-1;Oi(this,{from:t,to:E(r,M(this,r).text.length),text:this.splitLines(e),origin:"setValue",full:!0},!0),this.cm&&Xr(this.cm,0,0),bi(this,Rn(t),Gl)}),replaceRange:function(e,t,r,n){Ei(this,e,t=U(this,t),r=r?U(this,r):t,n)},getRange:function(e,t,r){var n=N(this,U(this,e),U(this,t));return!1===r?n:n.join(r||this.lineSeparator())},getLine:function(e){var t=this.getLineHandle(e);return t&&t.text},getLineHandle:function(e){if(H(this,e))return M(this,e)},getLineNumber:function(e){return W(e)},getLineHandleVisualStart:function(e){return"number"==typeof e&&(e=M(this,e)),fe(e)},lineCount:function(){return this.size},firstLine:function(){return this.first},lastLine:function(){return this.first+this.size-1},clipPos:function(e){return U(this,e)},getCursor:function(e){var t=this.sel.primary();return null==e||"head"==e?t.head:"anchor"==e?t.anchor:"end"==e||"to"==e||!1===e?t.to():t.from()},listSelections:function(){return this.sel.ranges},somethingSelected:function(){return this.sel.somethingSelected()},setCursor:gn(function(e,t,r){vi(this,U(this,"number"==typeof e?E(e,t||0):e),null,r)}),setSelection:gn(function(e,t,r){vi(this,U(this,e),U(this,t||e),r)}),extendSelection:gn(function(e,t,r){di(this,U(this,e),t&&U(this,t),r)}),extendSelections:gn(function(e,t){pi(this,K(this,e),t)}),extendSelectionsBy:gn(function(e,t){pi(this,K(this,v(this.sel.ranges,e)),t)}),setSelections:gn(function(e,t,r){var n=this;if(e.length){for(var i=[],o=0;o<e.length;o++)i[o]=new Ts(U(n,e[o].anchor),U(n,e[o].head));null==t&&(t=Math.min(e.length-1,this.sel.primIndex)),bi(this,zn(i,t),r)}}),addSelection:gn(function(e,t,r){var n=this.sel.ranges.slice(0);n.push(new Ts(U(this,e),U(this,t||e))),bi(this,zn(n,n.length-1),r)}),getSelection:function(e){for(var t,r=this,n=this.sel.ranges,i=0;i<n.length;i++){var o=N(r,n[i].from(),n[i].to());t=t?t.concat(o):o}return!1===e?t:t.join(e||this.lineSeparator())},getSelections:function(e){for(var t=this,r=[],n=this.sel.ranges,i=0;i<n.length;i++){var o=N(t,n[i].from(),n[i].to());!1!==e&&(o=o.join(e||t.lineSeparator())),r[i]=o}return r},replaceSelection:function(e,t,r){for(var n=[],i=0;i<this.sel.ranges.length;i++)n[i]=e;this.replaceSelections(n,t,r||"+input")},replaceSelections:gn(function(e,t,r){for(var n=this,i=[],o=this.sel,l=0;l<o.ranges.length;l++){var s=o.ranges[l];i[l]={from:s.from(),to:s.to(),text:n.splitLines(e[l]),origin:r}}for(var a=t&&"end"!=t&&Kn(this,i,t),u=i.length-1;u>=0;u--)Oi(n,i[u]);a?yi(this,a):this.cm&&jr(this.cm)}),undo:gn(function(){Wi(this,"undo")}),redo:gn(function(){Wi(this,"redo")}),undoSelection:gn(function(){Wi(this,"undo",!0)}),redoSelection:gn(function(){Wi(this,"redo",!0)}),setExtending:function(e){this.extend=e},getExtending:function(){return this.extend},historySize:function(){for(var e=this.history,t=0,r=0,n=0;n<e.done.length;n++)e.done[n].ranges||++t;for(var i=0;i<e.undone.length;i++)e.undone[i].ranges||++r;return{undo:t,redo:r}},clearHistory:function(){this.history=new Jn(this.history.maxGeneration)},markClean:function(){this.cleanGeneration=this.changeGeneration(!0)},changeGeneration:function(e){return e&&(this.history.lastOp=this.history.lastSelOp=this.history.lastOrigin=null),this.history.generation},isClean:function(e){return this.history.generation==(e||this.cleanGeneration)},getHistory:function(){return{done:fi(this.history.done),undone:fi(this.history.undone)}},setHistory:function(e){var t=this.history=new Jn(this.history.maxGeneration);t.done=fi(e.done.slice(0),null,!0),t.undone=fi(e.undone.slice(0),null,!0)},setGutterMarker:gn(function(e,t,r){return Ri(this,e,"gutter",function(e){var n=e.gutterMarkers||(e.gutterMarkers={});return n[t]=r,!r&&C(n)&&(e.gutterMarkers=null),!0})}),clearGutter:gn(function(e){var t=this;this.iter(function(r){r.gutterMarkers&&r.gutterMarkers[e]&&Ri(t,r,"gutter",function(){return r.gutterMarkers[e]=null,C(r.gutterMarkers)&&(r.gutterMarkers=null),!0})})}),lineInfo:function(e){var t;if("number"==typeof e){if(!H(this,e))return null;if(t=e,!(e=M(this,e)))return null}else if(null==(t=W(e)))return null;return{line:t,handle:e,text:e.text,gutterMarkers:e.gutterMarkers,textClass:e.textClass,bgClass:e.bgClass,wrapClass:e.wrapClass,widgets:e.widgets}},addLineClass:gn(function(t,r,n){return Ri(this,t,"gutter"==r?"gutter":"class",function(t){var i="text"==r?"textClass":"background"==r?"bgClass":"gutter"==r?"gutterClass":"wrapClass";if(t[i]){if(e(n).test(t[i]))return!1;t[i]+=" "+n}else t[i]=n;return!0})}),removeLineClass:gn(function(t,r,n){return Ri(this,t,"gutter"==r?"gutter":"class",function(t){var i="text"==r?"textClass":"background"==r?"bgClass":"gutter"==r?"gutterClass":"wrapClass",o=t[i];if(!o)return!1;if(null==n)t[i]=null;else{var l=o.match(e(n));if(!l)return!1;var s=l.index+l[0].length;t[i]=o.slice(0,l.index)+(l.index&&s!=o.length?" ":"")+o.slice(s)||null}return!0})}),addLineWidget:gn(function(e,t,r){return Vi(this,e,t,r)}),removeLineWidget:function(e){e.clear()},markText:function(e,t,r){return Ki(this,U(this,e),U(this,t),r,r&&r.type||"range")},setBookmark:function(e,t){var r={replacedWith:t&&(null==t.nodeType?t.widget:t),insertLeft:t&&t.insertLeft,clearWhenEmpty:!1,shared:t&&t.shared,handleMouseEvents:t&&t.handleMouseEvents};return e=U(this,e),Ki(this,e,e,r,"bookmark")},findMarksAt:function(e){var t=[],r=M(this,(e=U(this,e)).line).markedSpans;if(r)for(var n=0;n<r.length;++n){var i=r[n];(null==i.from||i.from<=e.ch)&&(null==i.to||i.to>=e.ch)&&t.push(i.marker.parent||i.marker)}return t},findMarks:function(e,t,r){e=U(this,e),t=U(this,t);var n=[],i=e.line;return this.iter(e.line,t.line+1,function(o){var l=o.markedSpans;if(l)for(var s=0;s<l.length;s++){var a=l[s];null!=a.to&&i==e.line&&e.ch>=a.to||null==a.from&&i!=e.line||null!=a.from&&i==t.line&&a.from>=t.ch||r&&!r(a.marker)||n.push(a.marker.parent||a.marker)}++i}),n},getAllMarks:function(){var e=[];return this.iter(function(t){var r=t.markedSpans;if(r)for(var n=0;n<r.length;++n)null!=r[n].from&&e.push(r[n].marker)}),e},posFromIndex:function(e){var t,r=this.first,n=this.lineSeparator().length;return this.iter(function(i){var o=i.text.length+n;if(o>e)return t=e,!0;e-=o,++r}),U(this,E(r,t))},indexFromPos:function(e){var t=(e=U(this,e)).ch;if(e.line<this.first||e.ch<0)return 0;var r=this.lineSeparator().length;return this.iter(this.first,e.line,function(e){t+=e.text.length+r}),t},copy:function(e){var t=new Ds(O(this,this.first,this.first+this.size),this.modeOption,this.first,this.lineSep,this.direction);return t.scrollTop=this.scrollTop,t.scrollLeft=this.scrollLeft,t.sel=this.sel,t.extend=!1,e&&(t.history.undoDepth=this.history.undoDepth,t.setHistory(this.getHistory())),t},linkedDoc:function(e){e||(e={});var t=this.first,r=this.first+this.size;null!=e.from&&e.from>t&&(t=e.from),null!=e.to&&e.to<r&&(r=e.to);var n=new Ds(O(this,t,r),e.mode||this.modeOption,t,this.lineSep,this.direction);return e.sharedHist&&(n.history=this.history),(this.linked||(this.linked=[])).push({doc:n,sharedHist:e.sharedHist}),n.linked=[{doc:this,isParent:!0,sharedHist:e.sharedHist}],Yi(n,Xi(this)),n},unlinkDoc:function(e){var t=this;if(e instanceof jo&&(e=e.doc),this.linked)for(var r=0;r<this.linked.length;++r)if(t.linked[r].doc==e){t.linked.splice(r,1),e.unlinkDoc(t),_i(Xi(t));break}if(e.history==this.history){var n=[e.id];$n(e,function(e){return n.push(e.id)},!0),e.history=new Jn(null),e.history.done=fi(this.history.done,n),e.history.undone=fi(this.history.undone,n)}},iterLinkedDocs:function(e){$n(this,e)},getMode:function(){return this.mode},getEditor:function(){return this.cm},splitLines:function(e){return this.lineSep?e.split(this.lineSep):es(e)},lineSeparator:function(){return this.lineSep||"\n"},setDirection:gn(function(e){"rtl"!=e&&(e="ltr"),e!=this.direction&&(this.direction=e,this.iter(function(e){return e.order=null}),this.cm&&Qn(this.cm))})}),Ds.prototype.eachLine=Ds.prototype.iter;for(var Hs=0,Fs=!1,Es={3:"Enter",8:"Backspace",9:"Tab",13:"Enter",16:"Shift",17:"Ctrl",18:"Alt",19:"Pause",20:"CapsLock",27:"Esc",32:"Space",33:"PageUp",34:"PageDown",35:"End",36:"Home",37:"Left",38:"Up",39:"Right",40:"Down",44:"PrintScrn",45:"Insert",46:"Delete",59:";",61:"=",91:"Mod",92:"Mod",93:"Mod",106:"*",107:"=",109:"-",110:".",111:"/",127:"Delete",173:"-",186:";",187:"=",188:",",189:"-",190:".",191:"/",192:"`",219:"[",220:"\\",221:"]",222:"'",63232:"Up",63233:"Down",63234:"Left",63235:"Right",63272:"Delete",63273:"Home",63275:"End",63276:"PageUp",63277:"PageDown",63302:"Insert"},Ps=0;Ps<10;Ps++)Es[Ps+48]=Es[Ps+96]=String(Ps);for(var Is=65;Is<=90;Is++)Es[Is]=String.fromCharCode(Is);for(var zs=1;zs<=12;zs++)Es[zs+111]=Es[zs+63235]="F"+zs;var Rs={};Rs.basic={Left:"goCharLeft",Right:"goCharRight",Up:"goLineUp",Down:"goLineDown",End:"goLineEnd",Home:"goLineStartSmart",PageUp:"goPageUp",PageDown:"goPageDown",Delete:"delCharAfter",Backspace:"delCharBefore","Shift-Backspace":"delCharBefore",Tab:"defaultTab","Shift-Tab":"indentAuto",Enter:"newlineAndIndent",Insert:"toggleOverwrite",Esc:"singleSelection"},Rs.pcDefault={"Ctrl-A":"selectAll","Ctrl-D":"deleteLine","Ctrl-Z":"undo","Shift-Ctrl-Z":"redo","Ctrl-Y":"redo","Ctrl-Home":"goDocStart","Ctrl-End":"goDocEnd","Ctrl-Up":"goLineUp","Ctrl-Down":"goLineDown","Ctrl-Left":"goGroupLeft","Ctrl-Right":"goGroupRight","Alt-Left":"goLineStart","Alt-Right":"goLineEnd","Ctrl-Backspace":"delGroupBefore","Ctrl-Delete":"delGroupAfter","Ctrl-S":"save","Ctrl-F":"find","Ctrl-G":"findNext","Shift-Ctrl-G":"findPrev","Shift-Ctrl-F":"replace","Shift-Ctrl-R":"replaceAll","Ctrl-[":"indentLess","Ctrl-]":"indentMore","Ctrl-U":"undoSelection","Shift-Ctrl-U":"redoSelection","Alt-U":"redoSelection",fallthrough:"basic"},Rs.emacsy={"Ctrl-F":"goCharRight","Ctrl-B":"goCharLeft","Ctrl-P":"goLineUp","Ctrl-N":"goLineDown","Alt-F":"goWordRight","Alt-B":"goWordLeft","Ctrl-A":"goLineStart","Ctrl-E":"goLineEnd","Ctrl-V":"goPageDown","Shift-Ctrl-V":"goPageUp","Ctrl-D":"delCharAfter","Ctrl-H":"delCharBefore","Alt-D":"delWordAfter","Alt-Backspace":"delWordBefore","Ctrl-K":"killLine","Ctrl-T":"transposeChars","Ctrl-O":"openLine"},Rs.macDefault={"Cmd-A":"selectAll","Cmd-D":"deleteLine","Cmd-Z":"undo","Shift-Cmd-Z":"redo","Cmd-Y":"redo","Cmd-Home":"goDocStart","Cmd-Up":"goDocStart","Cmd-End":"goDocEnd","Cmd-Down":"goDocEnd","Alt-Left":"goGroupLeft","Alt-Right":"goGroupRight","Cmd-Left":"goLineLeft","Cmd-Right":"goLineRight","Alt-Backspace":"delGroupBefore","Ctrl-Alt-Backspace":"delGroupAfter","Alt-Delete":"delGroupAfter","Cmd-S":"save","Cmd-F":"find","Cmd-G":"findNext","Shift-Cmd-G":"findPrev","Cmd-Alt-F":"replace","Shift-Cmd-Alt-F":"replaceAll","Cmd-[":"indentLess","Cmd-]":"indentMore","Cmd-Backspace":"delWrappedLineLeft","Cmd-Delete":"delWrappedLineRight","Cmd-U":"undoSelection","Shift-Cmd-U":"redoSelection","Ctrl-Up":"goDocStart","Ctrl-Down":"goDocEnd",fallthrough:["basic","emacsy"]},Rs.default=Ml?Rs.macDefault:Rs.pcDefault;var Bs={selectAll:Mi,singleSelection:function(e){return e.setSelection(e.getCursor("anchor"),e.getCursor("head"),Gl)},killLine:function(e){return co(e,function(t){if(t.empty()){var r=M(e.doc,t.head.line).text.length;return t.head.ch==r&&t.head.line<e.lastLine()?{from:t.head,to:E(t.head.line+1,0)}:{from:t.head,to:E(t.head.line,r)}}return{from:t.from(),to:t.to()}})},deleteLine:function(e){return co(e,function(t){return{from:E(t.from().line,0),to:U(e.doc,E(t.to().line+1,0))}})},delLineLeft:function(e){return co(e,function(e){return{from:E(e.from().line,0),to:e.from()}})},delWrappedLineLeft:function(e){return co(e,function(t){var r=e.charCoords(t.head,"div").top+5;return{from:e.coordsChar({left:0,top:r},"div"),to:t.from()}})},delWrappedLineRight:function(e){return co(e,function(t){var r=e.charCoords(t.head,"div").top+5,n=e.coordsChar({left:e.display.lineDiv.offsetWidth+100,top:r},"div");return{from:t.from(),to:n}})},undo:function(e){return e.undo()},redo:function(e){return e.redo()},undoSelection:function(e){return e.undoSelection()},redoSelection:function(e){return e.redoSelection()},goDocStart:function(e){return e.extendSelection(E(e.firstLine(),0))},goDocEnd:function(e){return e.extendSelection(E(e.lastLine()))},goLineStart:function(e){return e.extendSelectionsBy(function(t){return vo(e,t.head.line)},{origin:"+move",bias:1})},goLineStartSmart:function(e){return e.extendSelectionsBy(function(t){return yo(e,t.head)},{origin:"+move",bias:1})},goLineEnd:function(e){return e.extendSelectionsBy(function(t){return mo(e,t.head.line)},{origin:"+move",bias:-1})},goLineRight:function(e){return e.extendSelectionsBy(function(t){var r=e.cursorCoords(t.head,"div").top+5;return e.coordsChar({left:e.display.lineDiv.offsetWidth+100,top:r},"div")},Vl)},goLineLeft:function(e){return e.extendSelectionsBy(function(t){var r=e.cursorCoords(t.head,"div").top+5;return e.coordsChar({left:0,top:r},"div")},Vl)},goLineLeftSmart:function(e){return e.extendSelectionsBy(function(t){var r=e.cursorCoords(t.head,"div").top+5,n=e.coordsChar({left:0,top:r},"div");return n.ch<e.getLine(n.line).search(/\S/)?yo(e,t.head):n},Vl)},goLineUp:function(e){return e.moveV(-1,"line")},goLineDown:function(e){return e.moveV(1,"line")},goPageUp:function(e){return e.moveV(-1,"page")},goPageDown:function(e){return e.moveV(1,"page")},goCharLeft:function(e){return e.moveH(-1,"char")},goCharRight:function(e){return e.moveH(1,"char")},goColumnLeft:function(e){return e.moveH(-1,"column")},goColumnRight:function(e){return e.moveH(1,"column")},goWordLeft:function(e){return e.moveH(-1,"word")},goGroupRight:function(e){return e.moveH(1,"group")},goGroupLeft:function(e){return e.moveH(-1,"group")},goWordRight:function(e){return e.moveH(1,"word")},delCharBefore:function(e){return e.deleteH(-1,"char")},delCharAfter:function(e){return e.deleteH(1,"char")},delWordBefore:function(e){return e.deleteH(-1,"word")},delWordAfter:function(e){return e.deleteH(1,"word")},delGroupBefore:function(e){return e.deleteH(-1,"group")},delGroupAfter:function(e){return e.deleteH(1,"group")},indentAuto:function(e){return e.indentSelection("smart")},indentMore:function(e){return e.indentSelection("add")},indentLess:function(e){return e.indentSelection("subtract")},insertTab:function(e){return e.replaceSelection("\t")},insertSoftTab:function(e){for(var t=[],r=e.listSelections(),n=e.options.tabSize,i=0;i<r.length;i++){var o=r[i].from(),l=f(e.getLine(o.line),o.ch,n);t.push(p(n-l%n))}e.replaceSelections(t)},defaultTab:function(e){e.somethingSelected()?e.indentSelection("add"):e.execCommand("insertTab")},transposeChars:function(e){return hn(e,function(){for(var t=e.listSelections(),r=[],n=0;n<t.length;n++)if(t[n].empty()){var i=t[n].head,o=M(e.doc,i.line).text;if(o)if(i.ch==o.length&&(i=new E(i.line,i.ch-1)),i.ch>0)i=new E(i.line,i.ch+1),e.replaceRange(o.charAt(i.ch-1)+o.charAt(i.ch-2),E(i.line,i.ch-2),i,"+transpose");else if(i.line>e.doc.first){var l=M(e.doc,i.line-1).text;l&&(i=new E(i.line,1),e.replaceRange(o.charAt(0)+e.doc.lineSeparator()+l.charAt(l.length-1),E(i.line-1,l.length-1),i,"+transpose"))}r.push(new Ts(i,i))}e.setSelections(r)})},newlineAndIndent:function(e){return hn(e,function(){for(var t=e.listSelections(),r=t.length-1;r>=0;r--)e.replaceRange(e.doc.lineSeparator(),t[r].anchor,t[r].head,"+input");t=e.listSelections();for(var n=0;n<t.length;n++)e.indentLine(t[n].from().line,null,!0);jr(e)})},openLine:function(e){return e.replaceSelection("\n","start")},toggleOverwrite:function(e){return e.toggleOverwrite()}},Gs=new Pl,Us=null,Vs=function(e,t,r){this.time=e,this.pos=t,this.button=r};Vs.prototype.compare=function(e,t,r){return this.time+400>e&&0==P(t,this.pos)&&r==this.button};var Ks,js,Xs={toString:function(){return"CodeMirror.Init"}},Ys={},_s={};jo.defaults=Ys,jo.optionHandlers=_s;var $s=[];jo.defineInitHook=function(e){return $s.push(e)};var qs=null,Zs=function(e){this.cm=e,this.lastAnchorNode=this.lastAnchorOffset=this.lastFocusNode=this.lastFocusOffset=null,this.polling=new Pl,this.composing=null,this.gracePeriod=!1,this.readDOMTimeout=null};Zs.prototype.init=function(e){function t(e){if(!Me(i,e)){if(i.somethingSelected())_o({lineWise:!1,text:i.getSelections()}),"cut"==e.type&&i.replaceSelection("",null,"cut");else{if(!i.options.lineWiseCopyCut)return;var t=Qo(i);_o({lineWise:!0,text:t.text}),"cut"==e.type&&i.operation(function(){i.setSelections(t.ranges,0,Gl),i.replaceSelection("",null,"cut")})}if(e.clipboardData){e.clipboardData.clearData();var r=qs.text.join("\n");if(e.clipboardData.setData("Text",r),e.clipboardData.getData("Text")==r)return void e.preventDefault()}var l=el(),s=l.firstChild;i.display.lineSpace.insertBefore(l,i.display.lineSpace.firstChild),s.value=qs.text.join("\n");var a=document.activeElement;El(s),setTimeout(function(){i.display.lineSpace.removeChild(l),a.focus(),a==o&&n.showPrimarySelection()},50)}}var r=this,n=this,i=n.cm,o=n.div=e.lineDiv;Jo(o,i.options.spellcheck),Ql(o,"paste",function(e){Me(i,e)||qo(e,i)||vl<=11&&setTimeout(dn(i,function(){return r.updateFromDOM()}),20)}),Ql(o,"compositionstart",function(e){r.composing={data:e.data,done:!1}}),Ql(o,"compositionupdate",function(e){r.composing||(r.composing={data:e.data,done:!1})}),Ql(o,"compositionend",function(e){r.composing&&(e.data!=r.composing.data&&r.readFromDOMSoon(),r.composing.done=!0)}),Ql(o,"touchstart",function(){return n.forceCompositionEnd()}),Ql(o,"input",function(){r.composing||r.readFromDOMSoon()}),Ql(o,"copy",t),Ql(o,"cut",t)},Zs.prototype.prepareSelection=function(){var e=Tr(this.cm,!1);return e.focus=this.cm.state.focused,e},Zs.prototype.showSelection=function(e,t){e&&this.cm.display.view.length&&((e.focus||t)&&this.showPrimarySelection(),this.showMultipleSelections(e))},Zs.prototype.showPrimarySelection=function(){var e=window.getSelection(),t=this.cm,r=t.doc.sel.primary(),n=r.from(),i=r.to();if(t.display.viewTo==t.display.viewFrom||n.line>=t.display.viewTo||i.line<t.display.viewFrom)e.removeAllRanges();else{var o=sl(t,e.anchorNode,e.anchorOffset),l=sl(t,e.focusNode,e.focusOffset);if(!o||o.bad||!l||l.bad||0!=P(B(o,l),n)||0!=P(R(o,l),i)){var s=t.display.view,a=n.line>=t.display.viewFrom&&nl(t,n)||{node:s[0].measure.map[2],offset:0},u=i.line<t.display.viewTo&&nl(t,i);if(!u){var c=s[s.length-1].measure,f=c.maps?c.maps[c.maps.length-1]:c.map;u={node:f[f.length-1],offset:f[f.length-2]-f[f.length-3]}}if(a&&u){var h,d=e.rangeCount&&e.getRangeAt(0);try{h=Wl(a.node,a.offset,u.offset,u.node)}catch(e){}h&&(!fl&&t.state.focused?(e.collapse(a.node,a.offset),h.collapsed||(e.removeAllRanges(),e.addRange(h))):(e.removeAllRanges(),e.addRange(h)),d&&null==e.anchorNode?e.addRange(d):fl&&this.startGracePeriod()),this.rememberSelection()}else e.removeAllRanges()}}},Zs.prototype.startGracePeriod=function(){var e=this;clearTimeout(this.gracePeriod),this.gracePeriod=setTimeout(function(){e.gracePeriod=!1,e.selectionChanged()&&e.cm.operation(function(){return e.cm.curOp.selectionChanged=!0})},20)},Zs.prototype.showMultipleSelections=function(e){r(this.cm.display.cursorDiv,e.cursors),r(this.cm.display.selectionDiv,e.selection)},Zs.prototype.rememberSelection=function(){var e=window.getSelection();this.lastAnchorNode=e.anchorNode,this.lastAnchorOffset=e.anchorOffset,this.lastFocusNode=e.focusNode,this.lastFocusOffset=e.focusOffset},Zs.prototype.selectionInEditor=function(){var e=window.getSelection();if(!e.rangeCount)return!1;var t=e.getRangeAt(0).commonAncestorContainer;return o(this.div,t)},Zs.prototype.focus=function(){"nocursor"!=this.cm.options.readOnly&&(this.selectionInEditor()||this.showSelection(this.prepareSelection(),!0),this.div.focus())},Zs.prototype.blur=function(){this.div.blur()},Zs.prototype.getField=function(){return this.div},Zs.prototype.supportsTouch=function(){return!0},Zs.prototype.receivedFocus=function(){function e(){t.cm.state.focused&&(t.pollSelection(),t.polling.set(t.cm.options.pollInterval,e))}var t=this;this.selectionInEditor()?this.pollSelection():hn(this.cm,function(){return t.cm.curOp.selectionChanged=!0}),this.polling.set(this.cm.options.pollInterval,e)},Zs.prototype.selectionChanged=function(){var e=window.getSelection();return e.anchorNode!=this.lastAnchorNode||e.anchorOffset!=this.lastAnchorOffset||e.focusNode!=this.lastFocusNode||e.focusOffset!=this.lastFocusOffset},Zs.prototype.pollSelection=function(){if(null==this.readDOMTimeout&&!this.gracePeriod&&this.selectionChanged()){var e=window.getSelection(),t=this.cm;if(kl&&bl&&this.cm.options.gutters.length&&il(e.anchorNode))return this.cm.triggerOnKeyDown({type:"keydown",keyCode:8,preventDefault:Math.abs}),this.blur(),void this.focus();if(!this.composing){this.rememberSelection();var r=sl(t,e.anchorNode,e.anchorOffset),n=sl(t,e.focusNode,e.focusOffset);r&&n&&hn(t,function(){bi(t.doc,Rn(r,n),Gl),(r.bad||n.bad)&&(t.curOp.selectionChanged=!0)})}}},Zs.prototype.pollContent=function(){null!=this.readDOMTimeout&&(clearTimeout(this.readDOMTimeout),this.readDOMTimeout=null);var e=this.cm,t=e.display,r=e.doc.sel.primary(),n=r.from(),i=r.to();if(0==n.ch&&n.line>e.firstLine()&&(n=E(n.line-1,M(e.doc,n.line-1).length)),i.ch==M(e.doc,i.line).text.length&&i.line<e.lastLine()&&(i=E(i.line+1,0)),n.line<t.viewFrom||i.line>t.viewTo-1)return!1;var o,l,s;n.line==t.viewFrom||0==(o=Lr(e,n.line))?(l=W(t.view[0].line),s=t.view[0].node):(l=W(t.view[o].line),s=t.view[o-1].node.nextSibling);var a,u,c=Lr(e,i.line);if(c==t.view.length-1?(a=t.viewTo-1,u=t.lineDiv.lastChild):(a=W(t.view[c+1].line)-1,u=t.view[c+1].node.previousSibling),!s)return!1;for(var f=e.doc.splitLines(ll(e,s,u,l,a)),h=N(e.doc,E(l,0),E(a,M(e.doc,a).text.length));f.length>1&&h.length>1;)if(g(f)==g(h))f.pop(),h.pop(),a--;else{if(f[0]!=h[0])break;f.shift(),h.shift(),l++}for(var d=0,p=0,v=f[0],m=h[0],y=Math.min(v.length,m.length);d<y&&v.charCodeAt(d)==m.charCodeAt(d);)++d;for(var b=g(f),w=g(h),x=Math.min(b.length-(1==f.length?d:0),w.length-(1==h.length?d:0));p<x&&b.charCodeAt(b.length-p-1)==w.charCodeAt(w.length-p-1);)++p;if(1==f.length&&1==h.length&&l==n.line)for(;d&&d>n.ch&&b.charCodeAt(b.length-p-1)==w.charCodeAt(w.length-p-1);)d--,p++;f[f.length-1]=b.slice(0,b.length-p).replace(/^\u200b+/,""),f[0]=f[0].slice(d).replace(/\u200b+$/,"");var C=E(l,d),S=E(a,h.length?g(h).length-p:0);return f.length>1||f[0]||P(C,S)?(Ei(e.doc,f,C,S,"+input"),!0):void 0},Zs.prototype.ensurePolled=function(){this.forceCompositionEnd()},Zs.prototype.reset=function(){this.forceCompositionEnd()},Zs.prototype.forceCompositionEnd=function(){this.composing&&(clearTimeout(this.readDOMTimeout),this.composing=null,this.updateFromDOM(),this.div.blur(),this.div.focus())},Zs.prototype.readFromDOMSoon=function(){var e=this;null==this.readDOMTimeout&&(this.readDOMTimeout=setTimeout(function(){if(e.readDOMTimeout=null,e.composing){if(!e.composing.done)return;e.composing=null}e.updateFromDOM()},80))},Zs.prototype.updateFromDOM=function(){var e=this;!this.cm.isReadOnly()&&this.pollContent()||hn(this.cm,function(){return vn(e.cm)})},Zs.prototype.setUneditable=function(e){e.contentEditable="false"},Zs.prototype.onKeyPress=function(e){0!=e.charCode&&(e.preventDefault(),this.cm.isReadOnly()||dn(this.cm,$o)(this.cm,String.fromCharCode(null==e.charCode?e.keyCode:e.charCode),0))},Zs.prototype.readOnlyChanged=function(e){this.div.contentEditable=String("nocursor"!=e)},Zs.prototype.onContextMenu=function(){},Zs.prototype.resetPosition=function(){},Zs.prototype.needsContentAttribute=!0;var Qs=function(e){this.cm=e,this.prevInput="",this.pollingFast=!1,this.polling=new Pl,this.hasSelection=!1,this.composing=null};Qs.prototype.init=function(e){function t(e){if(!Me(i,e)){if(i.somethingSelected())_o({lineWise:!1,text:i.getSelections()});else{if(!i.options.lineWiseCopyCut)return;var t=Qo(i);_o({lineWise:!0,text:t.text}),"cut"==e.type?i.setSelections(t.ranges,null,Gl):(n.prevInput="",l.value=t.text.join("\n"),El(l))}"cut"==e.type&&(i.state.cutIncoming=!0)}}var r=this,n=this,i=this.cm,o=this.wrapper=el(),l=this.textarea=o.firstChild;e.wrapper.insertBefore(o,e.wrapper.firstChild),Ll&&(l.style.width="0px"),Ql(l,"input",function(){gl&&vl>=9&&r.hasSelection&&(r.hasSelection=null),n.poll()}),Ql(l,"paste",function(e){Me(i,e)||qo(e,i)||(i.state.pasteIncoming=!0,n.fastPoll())}),Ql(l,"cut",t),Ql(l,"copy",t),Ql(e.scroller,"paste",function(t){Ft(e,t)||Me(i,t)||(i.state.pasteIncoming=!0,n.focus())}),Ql(e.lineSpace,"selectstart",function(t){Ft(e,t)||We(t)}),Ql(l,"compositionstart",function(){var e=i.getCursor("from");n.composing&&n.composing.range.clear(),n.composing={start:e,range:i.markText(e,i.getCursor("to"),{className:"CodeMirror-composing"})}}),Ql(l,"compositionend",function(){n.composing&&(n.poll(),n.composing.range.clear(),n.composing=null)})},Qs.prototype.prepareSelection=function(){var e=this.cm,t=e.display,r=e.doc,n=Tr(e);if(e.options.moveInputWithCursor){var i=sr(e,r.sel.primary().head,"div"),o=t.wrapper.getBoundingClientRect(),l=t.lineDiv.getBoundingClientRect();n.teTop=Math.max(0,Math.min(t.wrapper.clientHeight-10,i.top+l.top-o.top)),n.teLeft=Math.max(0,Math.min(t.wrapper.clientWidth-10,i.left+l.left-o.left))}return n},Qs.prototype.showSelection=function(e){var t=this.cm.display;r(t.cursorDiv,e.cursors),r(t.selectionDiv,e.selection),null!=e.teTop&&(this.wrapper.style.top=e.teTop+"px",this.wrapper.style.left=e.teLeft+"px")},Qs.prototype.reset=function(e){if(!this.contextMenuPending&&!this.composing){var t=this.cm;if(t.somethingSelected()){this.prevInput="";var r=t.getSelection();this.textarea.value=r,t.state.focused&&El(this.textarea),gl&&vl>=9&&(this.hasSelection=r)}else e||(this.prevInput=this.textarea.value="",gl&&vl>=9&&(this.hasSelection=null))}},Qs.prototype.getField=function(){return this.textarea},Qs.prototype.supportsTouch=function(){return!1},Qs.prototype.focus=function(){if("nocursor"!=this.cm.options.readOnly&&(!Tl||l()!=this.textarea))try{this.textarea.focus()}catch(e){}},Qs.prototype.blur=function(){this.textarea.blur()},Qs.prototype.resetPosition=function(){this.wrapper.style.top=this.wrapper.style.left=0},Qs.prototype.receivedFocus=function(){this.slowPoll()},Qs.prototype.slowPoll=function(){var e=this;this.pollingFast||this.polling.set(this.cm.options.pollInterval,function(){e.poll(),e.cm.state.focused&&e.slowPoll()})},Qs.prototype.fastPoll=function(){function e(){r.poll()||t?(r.pollingFast=!1,r.slowPoll()):(t=!0,r.polling.set(60,e))}var t=!1,r=this;r.pollingFast=!0,r.polling.set(20,e)},Qs.prototype.poll=function(){var e=this,t=this.cm,r=this.textarea,n=this.prevInput;if(this.contextMenuPending||!t.state.focused||ts(r)&&!n&&!this.composing||t.isReadOnly()||t.options.disableInput||t.state.keySeq)return!1;var i=r.value;if(i==n&&!t.somethingSelected())return!1;if(gl&&vl>=9&&this.hasSelection===i||Ml&&/[\uf700-\uf7ff]/.test(i))return t.display.input.reset(),!1;if(t.doc.sel==t.display.selForContextMenu){var o=i.charCodeAt(0);if(8203!=o||n||(n="​"),8666==o)return this.reset(),this.cm.execCommand("undo")}for(var l=0,s=Math.min(n.length,i.length);l<s&&n.charCodeAt(l)==i.charCodeAt(l);)++l;return hn(t,function(){$o(t,i.slice(l),n.length-l,null,e.composing?"*compose":null),i.length>1e3||i.indexOf("\n")>-1?r.value=e.prevInput="":e.prevInput=i,e.composing&&(e.composing.range.clear(),e.composing.range=t.markText(e.composing.start,t.getCursor("to"),{className:"CodeMirror-composing"}))}),!0},Qs.prototype.ensurePolled=function(){this.pollingFast&&this.poll()&&(this.pollingFast=!1)},Qs.prototype.onKeyPress=function(){gl&&vl>=9&&(this.hasSelection=null),this.fastPoll()},Qs.prototype.onContextMenu=function(e){function t(){if(null!=l.selectionStart){var e=i.somethingSelected(),t="​"+(e?l.value:"");l.value="⇚",l.value=t,n.prevInput=e?"":"​",l.selectionStart=1,l.selectionEnd=t.length,o.selForContextMenu=i.doc.sel}}function r(){if(n.contextMenuPending=!1,n.wrapper.style.cssText=c,l.style.cssText=u,gl&&vl<9&&o.scrollbars.setScrollTop(o.scroller.scrollTop=a),null!=l.selectionStart){(!gl||gl&&vl<9)&&t();var e=0,r=function(){o.selForContextMenu==i.doc.sel&&0==l.selectionStart&&l.selectionEnd>0&&"​"==n.prevInput?dn(i,Mi)(i):e++<10?o.detectingSelectAll=setTimeout(r,500):(o.selForContextMenu=null,o.input.reset())};o.detectingSelectAll=setTimeout(r,200)}}var n=this,i=n.cm,o=i.display,l=n.textarea,s=Sr(i,e),a=o.scroller.scrollTop;if(s&&!wl){i.options.resetSelectionOnContextMenu&&-1==i.doc.sel.contains(s)&&dn(i,bi)(i.doc,Rn(s),Gl);var u=l.style.cssText,c=n.wrapper.style.cssText;n.wrapper.style.cssText="position: absolute";var f=n.wrapper.getBoundingClientRect();l.style.cssText="position: absolute; width: 30px; height: 30px;\n      top: "+(e.clientY-f.top-5)+"px; left: "+(e.clientX-f.left-5)+"px;\n      z-index: 1000; background: "+(gl?"rgba(255, 255, 255, .05)":"transparent")+";\n      outline: none; border-width: 0; outline: none; overflow: hidden; opacity: .05; filter: alpha(opacity=5);";var h;if(ml&&(h=window.scrollY),o.input.focus(),ml&&window.scrollTo(null,h),o.input.reset(),i.somethingSelected()||(l.value=n.prevInput=" "),n.contextMenuPending=!0,o.selForContextMenu=i.doc.sel,clearTimeout(o.detectingSelectAll),gl&&vl>=9&&t(),Hl){Fe(e);var d=function(){ke(window,"mouseup",d),setTimeout(r,20)};Ql(window,"mouseup",d)}else setTimeout(r,50)}},Qs.prototype.readOnlyChanged=function(e){e||this.reset(),this.textarea.disabled="nocursor"==e},Qs.prototype.setUneditable=function(){},Qs.prototype.needsContentAttribute=!1,function(e){function t(t,n,i,o){e.defaults[t]=n,i&&(r[t]=o?function(e,t,r){r!=Xs&&i(e,t,r)}:i)}var r=e.optionHandlers;e.defineOption=t,e.Init=Xs,t("value","",function(e,t){return e.setValue(t)},!0),t("mode",null,function(e,t){e.doc.modeOption=t,jn(e)},!0),t("indentUnit",2,jn,!0),t("indentWithTabs",!1),t("smartIndent",!0),t("tabSize",4,function(e){Xn(e),er(e),vn(e)},!0),t("lineSeparator",null,function(e,t){if(e.doc.lineSep=t,t){var r=[],n=e.doc.first;e.doc.iter(function(e){for(var i=0;;){var o=e.text.indexOf(t,i);if(-1==o)break;i=o+t.length,r.push(E(n,o))}n++});for(var i=r.length-1;i>=0;i--)Ei(e.doc,t,r[i],E(r[i].line,r[i].ch+t.length))}}),t("specialChars",/[\u0000-\u001f\u007f-\u009f\u00ad\u061c\u200b-\u200f\u2028\u2029\ufeff]/g,function(e,t,r){e.state.specialChars=new RegExp(t.source+(t.test("\t")?"":"|\t"),"g"),r!=Xs&&e.refresh()}),t("specialCharPlaceholder",at,function(e){return e.refresh()},!0),t("electricChars",!0),t("inputStyle",Tl?"contenteditable":"textarea",function(){throw new Error("inputStyle can not (yet) be changed in a running editor")},!0),t("spellcheck",!1,function(e,t){return e.getInputField().spellcheck=t},!0),t("rtlMoveVisually",!Ol),t("wholeLineUpdateBefore",!0),t("theme","default",function(e){Go(e),Uo(e)},!0),t("keyMap","default",function(e,t,r){var n=uo(t),i=r!=Xs&&uo(r);i&&i.detach&&i.detach(e,n),n.attach&&n.attach(e,i||null)}),t("extraKeys",null),t("configureMouse",null),t("lineWrapping",!1,Ko,!0),t("gutters",[],function(e){Fn(e.options),Uo(e)},!0),t("fixedGutter",!0,function(e,t){e.display.gutters.style.left=t?wr(e.display)+"px":"0",e.refresh()},!0),t("coverGutterNextToScrollbar",!1,function(e){return en(e)},!0),t("scrollbarStyle","native",function(e){rn(e),en(e),e.display.scrollbars.setScrollTop(e.doc.scrollTop),e.display.scrollbars.setScrollLeft(e.doc.scrollLeft)},!0),t("lineNumbers",!1,function(e){Fn(e.options),Uo(e)},!0),t("firstLineNumber",1,Uo,!0),t("lineNumberFormatter",function(e){return e},Uo,!0),t("showCursorWhenSelecting",!1,kr,!0),t("resetSelectionOnContextMenu",!0),t("lineWiseCopyCut",!0),t("pasteLinesPerSelection",!0),t("readOnly",!1,function(e,t){"nocursor"==t&&(Fr(e),e.display.input.blur()),e.display.input.readOnlyChanged(t)}),t("disableInput",!1,function(e,t){t||e.display.input.reset()},!0),t("dragDrop",!0,Vo),t("allowDropFileTypes",null),t("cursorBlinkRate",530),t("cursorScrollMargin",0),t("cursorHeight",1,kr,!0),t("singleCursorHeightPerLine",!0,kr,!0),t("workTime",100),t("workDelay",100),t("flattenSpans",!0,Xn,!0),t("addModeClass",!1,Xn,!0),t("pollInterval",100),t("undoDepth",200,function(e,t){return e.doc.history.undoDepth=t}),t("historyEventDelay",1250),t("viewportMargin",10,function(e){return e.refresh()},!0),t("maxHighlightLength",1e4,Xn,!0),t("moveInputWithCursor",!0,function(e,t){t||e.display.input.resetPosition()}),t("tabindex",null,function(e,t){return e.display.input.getField().tabIndex=t||""}),t("autofocus",null),t("direction","ltr",function(e,t){return e.doc.setDirection(t)},!0)}(jo),function(e){var t=e.optionHandlers,r=e.helpers={};e.prototype={constructor:e,focus:function(){window.focus(),this.display.input.focus()},setOption:function(e,r){var n=this.options,i=n[e];n[e]==r&&"mode"!=e||(n[e]=r,t.hasOwnProperty(e)&&dn(this,t[e])(this,r,i),Te(this,"optionChange",this,e))},getOption:function(e){return this.options[e]},getDoc:function(){return this.doc},addKeyMap:function(e,t){this.state.keyMaps[t?"push":"unshift"](uo(e))},removeKeyMap:function(e){for(var t=this.state.keyMaps,r=0;r<t.length;++r)if(t[r]==e||t[r].name==e)return t.splice(r,1),!0},addOverlay:pn(function(t,r){var n=t.token?t:e.getMode(this.options,t);if(n.startState)throw new Error("Overlays may not be stateful.");m(this.state.overlays,{mode:n,modeSpec:t,opaque:r&&r.opaque,priority:r&&r.priority||0},function(e){return e.priority}),this.state.modeGen++,vn(this)}),removeOverlay:pn(function(e){for(var t=this,r=this.state.overlays,n=0;n<r.length;++n){var i=r[n].modeSpec;if(i==e||"string"==typeof e&&i.name==e)return r.splice(n,1),t.state.modeGen++,void vn(t)}}),indentLine:pn(function(e,t,r){"string"!=typeof t&&"number"!=typeof t&&(t=null==t?this.options.smartIndent?"smart":"prev":t?"add":"subtract"),H(this.doc,e)&&Yo(this,e,t,r)}),indentSelection:pn(function(e){for(var t=this,r=this.doc.sel.ranges,n=-1,i=0;i<r.length;i++){var o=r[i];if(o.empty())o.head.line>n&&(Yo(t,o.head.line,e,!0),n=o.head.line,i==t.doc.sel.primIndex&&jr(t));else{var l=o.from(),s=o.to(),a=Math.max(n,l.line);n=Math.min(t.lastLine(),s.line-(s.ch?0:1))+1;for(var u=a;u<n;++u)Yo(t,u,e);var c=t.doc.sel.ranges;0==l.ch&&r.length==c.length&&c[i].from().ch>0&&gi(t.doc,i,new Ts(l,c[i].to()),Gl)}}}),getTokenAt:function(e,t){return Je(this,e,t)},getLineTokens:function(e,t){return Je(this,E(e),t,!0)},getTokenTypeAt:function(e){e=U(this.doc,e);var t,r=_e(this,M(this.doc,e.line)),n=0,i=(r.length-1)/2,o=e.ch;if(0==o)t=r[2];else for(;;){var l=n+i>>1;if((l?r[2*l-1]:0)>=o)i=l;else{if(!(r[2*l+1]<o)){t=r[2*l+2];break}n=l+1}}var s=t?t.indexOf("overlay "):-1;return s<0?t:0==s?null:t.slice(0,s-1)},getModeAt:function(t){var r=this.doc.mode;return r.innerMode?e.innerMode(r,this.getTokenAt(t).state).mode:r},getHelper:function(e,t){return this.getHelpers(e,t)[0]},getHelpers:function(e,t){var n=this,i=[];if(!r.hasOwnProperty(t))return i;var o=r[t],l=this.getModeAt(e);if("string"==typeof l[t])o[l[t]]&&i.push(o[l[t]]);else if(l[t])for(var s=0;s<l[t].length;s++){var a=o[l[t][s]];a&&i.push(a)}else l.helperType&&o[l.helperType]?i.push(o[l.helperType]):o[l.name]&&i.push(o[l.name]);for(var u=0;u<o._global.length;u++){var c=o._global[u];c.pred(l,n)&&-1==h(i,c.val)&&i.push(c.val)}return i},getStateAfter:function(e,t){var r=this.doc;return e=G(r,null==e?r.first+r.size-1:e),$e(this,e+1,t).state},cursorCoords:function(e,t){var r,n=this.doc.sel.primary();return r=null==e?n.head:"object"==typeof e?U(this.doc,e):e?n.from():n.to(),sr(this,r,t||"page")},charCoords:function(e,t){return lr(this,U(this.doc,e),t||"page")},coordsChar:function(e,t){return e=or(this,e,t||"page"),cr(this,e.left,e.top)},lineAtHeight:function(e,t){return e=or(this,{top:e,left:0},t||"page").top,D(this.doc,e+this.display.viewOffset)},heightAtLine:function(e,t,r){var n,i=!1;if("number"==typeof e){var o=this.doc.first+this.doc.size-1;e<this.doc.first?e=this.doc.first:e>o&&(e=o,i=!0),n=M(this.doc,e)}else n=e;return ir(this,n,{top:0,left:0},t||"page",r||i).top+(i?this.doc.height-ye(n):0)},defaultTextHeight:function(){return mr(this.display)},defaultCharWidth:function(){return yr(this.display)},getViewport:function(){return{from:this.display.viewFrom,to:this.display.viewTo}},addWidget:function(e,t,r,n,i){var o=this.display,l=(e=sr(this,U(this.doc,e))).bottom,s=e.left;if(t.style.position="absolute",t.setAttribute("cm-ignore-events","true"),this.display.input.setUneditable(t),o.sizer.appendChild(t),"over"==n)l=e.top;else if("above"==n||"near"==n){var a=Math.max(o.wrapper.clientHeight,this.doc.height),u=Math.max(o.sizer.clientWidth,o.lineSpace.clientWidth);("above"==n||e.bottom+t.offsetHeight>a)&&e.top>t.offsetHeight?l=e.top-t.offsetHeight:e.bottom+t.offsetHeight<=a&&(l=e.bottom),s+t.offsetWidth>u&&(s=u-t.offsetWidth)}t.style.top=l+"px",t.style.left=t.style.right="","right"==i?(s=o.sizer.clientWidth-t.offsetWidth,t.style.right="0px"):("left"==i?s=0:"middle"==i&&(s=(o.sizer.clientWidth-t.offsetWidth)/2),t.style.left=s+"px"),r&&Ur(this,{left:s,top:l,right:s+t.offsetWidth,bottom:l+t.offsetHeight})},triggerOnKeyDown:pn(Lo),triggerOnKeyPress:pn(Mo),triggerOnKeyUp:To,triggerOnMouseDown:pn(Oo),execCommand:function(e){if(Bs.hasOwnProperty(e))return Bs[e].call(null,this)},triggerElectric:pn(function(e){Zo(this,e)}),findPosH:function(e,t,r,n){var i=this,o=1;t<0&&(o=-1,t=-t);for(var l=U(this.doc,e),s=0;s<t&&!(l=tl(i.doc,l,o,r,n)).hitSide;++s);return l},moveH:pn(function(e,t){var r=this;this.extendSelectionsBy(function(n){return r.display.shift||r.doc.extend||n.empty()?tl(r.doc,n.head,e,t,r.options.rtlMoveVisually):e<0?n.from():n.to()},Vl)}),deleteH:pn(function(e,t){var r=this.doc.sel,n=this.doc;r.somethingSelected()?n.replaceSelection("",null,"+delete"):co(this,function(r){var i=tl(n,r.head,e,t,!1);return e<0?{from:i,to:r.head}:{from:r.head,to:i}})}),findPosV:function(e,t,r,n){var i=this,o=1,l=n;t<0&&(o=-1,t=-t);for(var s=U(this.doc,e),a=0;a<t;++a){var u=sr(i,s,"div");if(null==l?l=u.left:u.left=l,(s=rl(i,u,o,r)).hitSide)break}return s},moveV:pn(function(e,t){var r=this,n=this.doc,i=[],o=!this.display.shift&&!n.extend&&n.sel.somethingSelected();if(n.extendSelectionsBy(function(l){if(o)return e<0?l.from():l.to();var s=sr(r,l.head,"div");null!=l.goalColumn&&(s.left=l.goalColumn),i.push(s.left);var a=rl(r,s,e,t);return"page"==t&&l==n.sel.primary()&&Kr(r,lr(r,a,"div").top-s.top),a},Vl),i.length)for(var l=0;l<n.sel.ranges.length;l++)n.sel.ranges[l].goalColumn=i[l]}),findWordAt:function(e){var t=M(this.doc,e.line).text,r=e.ch,n=e.ch;if(t){var i=this.getHelper(e,"wordChars");"before"!=e.sticky&&n!=t.length||!r?++n:--r;for(var o=t.charAt(r),l=x(o,i)?function(e){return x(e,i)}:/\s/.test(o)?function(e){return/\s/.test(e)}:function(e){return!/\s/.test(e)&&!x(e)};r>0&&l(t.charAt(r-1));)--r;for(;n<t.length&&l(t.charAt(n));)++n}return new Ts(E(e.line,r),E(e.line,n))},toggleOverwrite:function(e){null!=e&&e==this.state.overwrite||((this.state.overwrite=!this.state.overwrite)?s(this.display.cursorDiv,"CodeMirror-overwrite"):Fl(this.display.cursorDiv,"CodeMirror-overwrite"),Te(this,"overwriteToggle",this,this.state.overwrite))},hasFocus:function(){return this.display.input.getField()==l()},isReadOnly:function(){return!(!this.options.readOnly&&!this.doc.cantEdit)},scrollTo:pn(function(e,t){Xr(this,e,t)}),getScrollInfo:function(){var e=this.display.scroller;return{left:e.scrollLeft,top:e.scrollTop,height:e.scrollHeight-zt(this)-this.display.barHeight,width:e.scrollWidth-zt(this)-this.display.barWidth,clientHeight:Bt(this),clientWidth:Rt(this)}},scrollIntoView:pn(function(e,t){null==e?(e={from:this.doc.sel.primary().head,to:null},null==t&&(t=this.options.cursorScrollMargin)):"number"==typeof e?e={from:E(e,0),to:null}:null==e.from&&(e={from:e,to:null}),e.to||(e.to=e.from),e.margin=t||0,null!=e.from.line?Yr(this,e):$r(this,e.from,e.to,e.margin)}),setSize:pn(function(e,t){var r=this,n=function(e){return"number"==typeof e||/^\d+$/.test(String(e))?e+"px":e};null!=e&&(this.display.wrapper.style.width=n(e)),null!=t&&(this.display.wrapper.style.height=n(t)),this.options.lineWrapping&&Jt(this);var i=this.display.viewFrom;this.doc.iter(i,this.display.viewTo,function(e){if(e.widgets)for(var t=0;t<e.widgets.length;t++)if(e.widgets[t].noHScroll){mn(r,i,"widget");break}++i}),this.curOp.forceUpdate=!0,Te(this,"refresh",this)}),operation:function(e){return hn(this,e)},startOperation:function(){return nn(this)},endOperation:function(){return on(this)},refresh:pn(function(){var e=this.display.cachedTextHeight;vn(this),this.curOp.forceUpdate=!0,er(this),Xr(this,this.doc.scrollLeft,this.doc.scrollTop),Wn(this),(null==e||Math.abs(e-mr(this.display))>.5)&&Cr(this),Te(this,"refresh",this)}),swapDoc:pn(function(e){var t=this.doc;return t.cm=null,qn(this,e),er(this),this.display.input.reset(),Xr(this,e.scrollLeft,e.scrollTop),this.curOp.forceScroll=!0,bt(this,"swapDoc",this,t),t}),getInputField:function(){return this.display.input.getField()},getWrapperElement:function(){return this.display.wrapper},getScrollerElement:function(){return this.display.scroller},getGutterElement:function(){return this.display.gutters}},Ae(e),e.registerHelper=function(t,n,i){r.hasOwnProperty(t)||(r[t]=e[t]={_global:[]}),r[t][n]=i},e.registerGlobalHelper=function(t,n,i,o){e.registerHelper(t,n,o),r[t]._global.push({pred:i,val:o})}}(jo);var Js="iter insert remove copy getEditor constructor".split(" ");for(var ea in Ds.prototype)Ds.prototype.hasOwnProperty(ea)&&h(Js,ea)<0&&(jo.prototype[ea]=function(e){return function(){return e.apply(this.doc,arguments)}}(Ds.prototype[ea]));return Ae(Ds),jo.inputStyles={textarea:Qs,contenteditable:Zs},jo.defineMode=function(e){jo.defaults.mode||"null"==e||(jo.defaults.mode=e),Be.apply(this,arguments)},jo.defineMIME=function(e,t){os[e]=t},jo.defineMode("null",function(){return{token:function(e){return e.skipToEnd()}}}),jo.defineMIME("text/plain","null"),jo.defineExtension=function(e,t){jo.prototype[e]=t},jo.defineDocExtension=function(e,t){Ds.prototype[e]=t},jo.fromTextArea=function(e,t){function r(){e.value=a.getValue()}if(t=t?c(t):{},t.value=e.value,!t.tabindex&&e.tabIndex&&(t.tabindex=e.tabIndex),!t.placeholder&&e.placeholder&&(t.placeholder=e.placeholder),null==t.autofocus){var n=l();t.autofocus=n==e||null!=e.getAttribute("autofocus")&&n==document.body}var i;if(e.form&&(Ql(e.form,"submit",r),!t.leaveSubmitMethodAlone)){var o=e.form;i=o.submit;try{var s=o.submit=function(){r(),o.submit=i,o.submit(),o.submit=s}}catch(e){}}t.finishInit=function(t){t.save=r,t.getTextArea=function(){return e},t.toTextArea=function(){t.toTextArea=isNaN,r(),e.parentNode.removeChild(t.getWrapperElement()),e.style.display="",e.form&&(ke(e.form,"submit",r),"function"==typeof e.form.submit&&(e.form.submit=i))}},e.style.display="none";var a=jo(function(t){return e.parentNode.insertBefore(t,e.nextSibling)},t);return a},function(e){e.off=ke,e.on=Ql,e.wheelEventPixels=Pn,e.Doc=Ds,e.splitLines=es,e.countColumn=f,e.findColumn=d,e.isWordChar=w,e.Pass=Bl,e.signal=Te,e.Line=fs,e.changeEnd=Bn,e.scrollbarModel=ws,e.Pos=E,e.cmpPos=P,e.modes=is,e.mimeModes=os,e.resolveMode=Ge,e.getMode=Ue,e.modeExtensions=ls,e.extendMode=Ve,e.copyState=Ke,e.startState=Xe,e.innerMode=je,e.commands=Bs,e.keyMap=Rs,e.keyName=ao,e.isModifierKey=lo,e.lookupKey=oo,e.normalizeKeyMap=io,e.StringStream=ss,e.SharedTextMarker=As,e.TextMarker=Os,e.LineWidget=Ms,e.e_preventDefault=We,e.e_stopPropagation=De,e.e_stop=Fe,e.addClass=s,e.contains=o,e.rmClass=Fl,e.keyNames=Es}(jo),jo.version="5.30.0",jo});
      !function(e){"object"==typeof exports&&"object"==typeof module?e(require("../../lib/codemirror")):"function"==typeof define&&define.amd?define(["../../lib/codemirror"],e):e(CodeMirror)}(function(e){"use strict";function t(e,t,n,r,o,a){this.indented=e,this.column=t,this.type=n,this.info=r,this.align=o,this.prev=a}function n(e,n,r,o){var a=e.indented;return e.context&&"statement"==e.context.type&&"statement"!=r&&(a=e.context.indented),e.context=new t(a,n,r,o,null,e.context)}function r(e){var t=e.context.type;return")"!=t&&"]"!=t&&"}"!=t||(e.indented=e.context.indented),e.context=e.context.prev}function o(e,t,n){return"variable"==t.prevToken||"type"==t.prevToken||(!!/\S(?:[^- ]>|[*\]])\s*$|\*$/.test(e.string.slice(0,n))||(!(!t.typeAtEndOfLine||e.column()!=e.indentation())||void 0))}function a(e){for(;;){if(!e||"top"==e.type)return!0;if("}"==e.type&&"namespace"!=e.prev.info)return!1;e=e.prev}}function i(e){for(var t={},n=e.split(" "),r=0;r<n.length;++r)t[n[r]]=!0;return t}function l(e,t){return"function"==typeof e?e(t):e.propertyIsEnumerable(t)}function s(e,t){if(!t.startOfLine)return!1;for(var n,r=null;n=e.peek();){if("\\"==n&&e.match(/^.$/)){r=s;break}if("/"==n&&e.match(/^\/[\/\*]/,!1))break;e.next()}return t.tokenize=r,"meta"}function c(e,t){return"type"==t.prevToken&&"type"}function u(e){return e.eatWhile(/[\w\.']/),"number"}function d(e,t){if(e.backUp(1),e.match(/(R|u8R|uR|UR|LR)/)){var n=e.match(/"([^\s\\()]{0,16})\(/);return!!n&&(t.cpp11RawStringDelim=n[1],t.tokenize=m,m(e,t))}return e.match(/(u8|u|U|L)/)?!!e.match(/["']/,!1)&&"string":(e.next(),!1)}function f(e){var t=/(\w+)::~?(\w+)$/.exec(e);return t&&t[1]==t[2]}function p(e,t){for(var n;null!=(n=e.next());)if('"'==n&&!e.eat('"')){t.tokenize=null;break}return"string"}function m(e,t){var n=t.cpp11RawStringDelim.replace(/[^\w\s]/g,"\\$&");return e.match(new RegExp(".*?\\)"+n+'"'))?t.tokenize=null:e.skipToEnd(),"string"}function h(t,n){function r(e){if(e)for(var t in e)e.hasOwnProperty(t)&&o.push(t)}"string"==typeof t&&(t=[t]);var o=[];r(n.keywords),r(n.types),r(n.builtin),r(n.atoms),o.length&&(n.helperType=t[0],e.registerHelper("hintWords",t[0],o));for(var a=0;a<t.length;++a)e.defineMIME(t[a],n)}function g(e,t){for(var n=!1;!e.eol();){if(!n&&e.match('"""')){t.tokenize=null;break}n="\\"==e.next()&&!n}return"string"}function y(e){return function(t,n){for(var r,o=!1,a=!1;!t.eol();){if(!e&&!o&&t.match('"')){a=!0;break}if(e&&t.match('"""')){a=!0;break}r=t.next(),!o&&"$"==r&&t.match("{")&&t.skipTo("}"),o=!o&&"\\"==r&&!e}return!a&&e||(n.tokenize=null),"string"}}function x(e){return function(t,n){for(var r,o=!1,a=!1;!t.eol();){if(!o&&t.match('"')&&("single"==e||t.match('""'))){a=!0;break}if(!o&&t.match("``")){w=x(e),a=!0;break}r=t.next(),o="single"==e&&!o&&"\\"==r}return a&&(n.tokenize=null),"string"}}e.defineMode("clike",function(i,s){function c(e,t){var n=e.next();if(S[n]){var r=S[n](e,t);if(!1!==r)return r}if('"'==n||"'"==n)return t.tokenize=u(n),t.tokenize(e,t);if(D.test(n))return p=n,null;if(L.test(n)){if(e.backUp(1),e.match(I))return"number";e.next()}if("/"==n){if(e.eat("*"))return t.tokenize=d,d(e,t);if(e.eat("/"))return e.skipToEnd(),"comment"}if(F.test(n)){for(;!e.match(/^\/[\/*]/,!1)&&e.eat(F););return"operator"}if(e.eatWhile(z),P)for(;e.match(P);)e.eatWhile(z);var o=e.current();return l(x,o)?(l(w,o)&&(p="newstatement"),l(v,o)&&(m=!0),"keyword"):l(b,o)?"type":l(k,o)?(l(w,o)&&(p="newstatement"),"builtin"):l(_,o)?"atom":"variable"}function u(e){return function(t,n){for(var r,o=!1,a=!1;null!=(r=t.next());){if(r==e&&!o){a=!0;break}o=!o&&"\\"==r}return(a||!o&&!C)&&(n.tokenize=null),"string"}}function d(e,t){for(var n,r=!1;n=e.next();){if("/"==n&&r){t.tokenize=null;break}r="*"==n}return"comment"}function f(e,t){s.typeFirstDefinitions&&e.eol()&&a(t.context)&&(t.typeAtEndOfLine=o(e,t,e.pos))}var p,m,h=i.indentUnit,g=s.statementIndentUnit||h,y=s.dontAlignCalls,x=s.keywords||{},b=s.types||{},k=s.builtin||{},w=s.blockKeywords||{},v=s.defKeywords||{},_=s.atoms||{},S=s.hooks||{},C=s.multiLineStrings,T=!1!==s.indentStatements,M=!1!==s.indentSwitch,P=s.namespaceSeparator,D=s.isPunctuationChar||/[\[\]{}\(\),;\:\.]/,L=s.numberStart||/[\d\.]/,I=s.number||/^(?:0x[a-f\d]+|0b[01]+|(?:\d+\.?\d*|\.\d+)(?:e[-+]?\d+)?)(u|ll?|l|f)?/i,F=s.isOperatorChar||/[+\-*&%=<>!?|\/]/,z=s.isIdentifierChar||/[\w\$_\xa1-\uffff]/;return{startState:function(e){return{tokenize:null,context:new t((e||0)-h,0,"top",null,!1),indented:0,startOfLine:!0,prevToken:null}},token:function(e,t){var i=t.context;if(e.sol()&&(null==i.align&&(i.align=!1),t.indented=e.indentation(),t.startOfLine=!0),e.eatSpace())return f(e,t),null;p=m=null;var l=(t.tokenize||c)(e,t);if("comment"==l||"meta"==l)return l;if(null==i.align&&(i.align=!0),";"==p||":"==p||","==p&&e.match(/^\s*(?:\/\/.*)?$/,!1))for(;"statement"==t.context.type;)r(t);else if("{"==p)n(t,e.column(),"}");else if("["==p)n(t,e.column(),"]");else if("("==p)n(t,e.column(),")");else if("}"==p){for(;"statement"==i.type;)i=r(t);for("}"==i.type&&(i=r(t));"statement"==i.type;)i=r(t)}else p==i.type?r(t):T&&(("}"==i.type||"top"==i.type)&&";"!=p||"statement"==i.type&&"newstatement"==p)&&n(t,e.column(),"statement",e.current());if("variable"==l&&("def"==t.prevToken||s.typeFirstDefinitions&&o(e,t,e.start)&&a(t.context)&&e.match(/^\s*\(/,!1))&&(l="def"),S.token){var u=S.token(e,t,l);void 0!==u&&(l=u)}return"def"==l&&!1===s.styleDefs&&(l="variable"),t.startOfLine=!1,t.prevToken=m?"def":l||p,f(e,t),l},indent:function(t,n){if(t.tokenize!=c&&null!=t.tokenize||t.typeAtEndOfLine)return e.Pass;var r=t.context,o=n&&n.charAt(0);if("statement"==r.type&&"}"==o&&(r=r.prev),s.dontIndentStatements)for(;"statement"==r.type&&s.dontIndentStatements.test(r.info);)r=r.prev;if(S.indent){var a=S.indent(t,r,n);if("number"==typeof a)return a}var i=o==r.type,l=r.prev&&"switch"==r.prev.info;if(s.allmanIndentation&&/[{(]/.test(o)){for(;"top"!=r.type&&"}"!=r.type;)r=r.prev;return r.indented}return"statement"==r.type?r.indented+("{"==o?0:g):!r.align||y&&")"==r.type?")"!=r.type||i?r.indented+(i?0:h)+(i||!l||/^(?:case|default)\b/.test(n)?0:h):r.indented+g:r.column+(i?0:1)},electricInput:M?/^\s*(?:case .*?:|default:|\{\}?|\})$/:/^\s*[{}]$/,blockCommentStart:"/*",blockCommentEnd:"*/",lineComment:"//",fold:"brace"}});var b="auto if break case register continue return default do sizeof static else struct switch extern typedef union for goto while enum const volatile",k="int long char short double float unsigned signed void size_t ptrdiff_t";h(["text/x-csrc","text/x-c","text/x-chdr"],{name:"clike",keywords:i(b),types:i(k+" bool _Complex _Bool float_t double_t intptr_t intmax_t int8_t int16_t int32_t int64_t uintptr_t uintmax_t uint8_t uint16_t uint32_t uint64_t"),blockKeywords:i("case do else for if switch while struct"),defKeywords:i("struct"),typeFirstDefinitions:!0,atoms:i("null true false"),hooks:{"#":s,"*":c},modeProps:{fold:["brace","include"]}}),h(["text/x-c++src","text/x-c++hdr"],{name:"clike",keywords:i(b+" asm dynamic_cast namespace reinterpret_cast try explicit new static_cast typeid catch operator template typename class friend private this using const_cast inline public throw virtual delete mutable protected alignas alignof constexpr decltype nullptr noexcept thread_local final static_assert override"),types:i(k+" bool wchar_t"),blockKeywords:i("catch class do else finally for if struct switch try while"),defKeywords:i("class namespace struct enum union"),typeFirstDefinitions:!0,atoms:i("true false null"),dontIndentStatements:/^template$/,isIdentifierChar:/[\w\$_~\xa1-\uffff]/,hooks:{"#":s,"*":c,u:d,U:d,L:d,R:d,0:u,1:u,2:u,3:u,4:u,5:u,6:u,7:u,8:u,9:u,token:function(e,t,n){if("variable"==n&&"("==e.peek()&&(";"==t.prevToken||null==t.prevToken||"}"==t.prevToken)&&f(e.current()))return"def"}},namespaceSeparator:"::",modeProps:{fold:["brace","include"]}}),h("text/x-java",{name:"clike",keywords:i("abstract assert break case catch class const continue default do else enum extends final finally float for goto if implements import instanceof interface native new package private protected public return static strictfp super switch synchronized this throw throws transient try volatile while @interface"),types:i("byte short int long float double boolean char void Boolean Byte Character Double Float Integer Long Number Object Short String StringBuffer StringBuilder Void"),blockKeywords:i("catch class do else finally for if switch try while"),defKeywords:i("class interface package enum @interface"),typeFirstDefinitions:!0,atoms:i("true false null"),number:/^(?:0x[a-f\d_]+|0b[01_]+|(?:[\d_]+\.?\d*|\.\d+)(?:e[-+]?[\d_]+)?)(u|ll?|l|f)?/i,hooks:{"@":function(e){return!e.match("interface",!1)&&(e.eatWhile(/[\w\$_]/),"meta")}},modeProps:{fold:["brace","import"]}}),h("text/x-csharp",{name:"clike",keywords:i("abstract as async await base break case catch checked class const continue default delegate do else enum event explicit extern finally fixed for foreach goto if implicit in interface internal is lock namespace new operator out override params private protected public readonly ref return sealed sizeof stackalloc static struct switch this throw try typeof unchecked unsafe using virtual void volatile while add alias ascending descending dynamic from get global group into join let orderby partial remove select set value var yield"),types:i("Action Boolean Byte Char DateTime DateTimeOffset Decimal Double Func Guid Int16 Int32 Int64 Object SByte Single String Task TimeSpan UInt16 UInt32 UInt64 bool byte char decimal double short int long object sbyte float string ushort uint ulong"),blockKeywords:i("catch class do else finally for foreach if struct switch try while"),defKeywords:i("class interface namespace struct var"),typeFirstDefinitions:!0,atoms:i("true false null"),hooks:{"@":function(e,t){return e.eat('"')?(t.tokenize=p,p(e,t)):(e.eatWhile(/[\w\$_]/),"meta")}}}),h("text/x-scala",{name:"clike",keywords:i("abstract case catch class def do else extends final finally for forSome if implicit import lazy match new null object override package private protected return sealed super this throw trait try type val var while with yield _ assert assume require print println printf readLine readBoolean readByte readShort readChar readInt readLong readFloat readDouble"),types:i("AnyVal App Application Array BufferedIterator BigDecimal BigInt Char Console Either Enumeration Equiv Error Exception Fractional Function IndexedSeq Int Integral Iterable Iterator List Map Numeric Nil NotNull Option Ordered Ordering PartialFunction PartialOrdering Product Proxy Range Responder Seq Serializable Set Specializable Stream StringBuilder StringContext Symbol Throwable Traversable TraversableOnce Tuple Unit Vector Boolean Byte Character CharSequence Class ClassLoader Cloneable Comparable Compiler Double Exception Float Integer Long Math Number Object Package Pair Process Runtime Runnable SecurityManager Short StackTraceElement StrictMath String StringBuffer System Thread ThreadGroup ThreadLocal Throwable Triple Void"),multiLineStrings:!0,blockKeywords:i("catch class enum do else finally for forSome if match switch try while"),defKeywords:i("class enum def object package trait type val var"),atoms:i("true false null"),indentStatements:!1,indentSwitch:!1,isOperatorChar:/[+\-*&%=<>!?|\/#:@]/,hooks:{"@":function(e){return e.eatWhile(/[\w\$_]/),"meta"},'"':function(e,t){return!!e.match('""')&&(t.tokenize=g,t.tokenize(e,t))},"'":function(e){return e.eatWhile(/[\w\$_\xa1-\uffff]/),"atom"},"=":function(e,n){var r=n.context;return!("}"!=r.type||!r.align||!e.eat(">"))&&(n.context=new t(r.indented,r.column,r.type,r.info,null,r.prev),"operator")}},modeProps:{closeBrackets:{triples:'"'}}}),h("text/x-kotlin",{name:"clike",keywords:i("package as typealias class interface this super val var fun for is in This throw return break continue object if else while do try when !in !is as? file import where by get set abstract enum open inner override private public internal protected catch finally out final vararg reified dynamic companion constructor init sealed field property receiver param sparam lateinit data inline noinline tailrec external annotation crossinline const operator infix suspend"),types:i("Boolean Byte Character CharSequence Class ClassLoader Cloneable Comparable Compiler Double Exception Float Integer Long Math Number Object Package Pair Process Runtime Runnable SecurityManager Short StackTraceElement StrictMath String StringBuffer System Thread ThreadGroup ThreadLocal Throwable Triple Void"),intendSwitch:!1,indentStatements:!1,multiLineStrings:!0,number:/^(?:0x[a-f\d_]+|0b[01_]+|(?:[\d_]+\.?\d*|\.\d+)(?:e[-+]?[\d_]+)?)(u|ll?|l|f)?/i,blockKeywords:i("catch class do else finally for if where try while enum"),defKeywords:i("class val var object package interface fun"),atoms:i("true false null this"),hooks:{'"':function(e,t){return t.tokenize=y(e.match('""')),t.tokenize(e,t)}},modeProps:{closeBrackets:{triples:'"'}}}),h(["x-shader/x-vertex","x-shader/x-fragment"],{name:"clike",keywords:i("sampler1D sampler2D sampler3D samplerCube sampler1DShadow sampler2DShadow const attribute uniform varying break continue discard return for while do if else struct in out inout"),types:i("float int bool void vec2 vec3 vec4 ivec2 ivec3 ivec4 bvec2 bvec3 bvec4 mat2 mat3 mat4"),blockKeywords:i("for while do if else struct"),builtin:i("radians degrees sin cos tan asin acos atan pow exp log exp2 sqrt inversesqrt abs sign floor ceil fract mod min max clamp mix step smoothstep length distance dot cross normalize ftransform faceforward reflect refract matrixCompMult lessThan lessThanEqual greaterThan greaterThanEqual equal notEqual any all not texture1D texture1DProj texture1DLod texture1DProjLod texture2D texture2DProj texture2DLod texture2DProjLod texture3D texture3DProj texture3DLod texture3DProjLod textureCube textureCubeLod shadow1D shadow2D shadow1DProj shadow2DProj shadow1DLod shadow2DLod shadow1DProjLod shadow2DProjLod dFdx dFdy fwidth noise1 noise2 noise3 noise4"),atoms:i("true false gl_FragColor gl_SecondaryColor gl_Normal gl_Vertex gl_MultiTexCoord0 gl_MultiTexCoord1 gl_MultiTexCoord2 gl_MultiTexCoord3 gl_MultiTexCoord4 gl_MultiTexCoord5 gl_MultiTexCoord6 gl_MultiTexCoord7 gl_FogCoord gl_PointCoord gl_Position gl_PointSize gl_ClipVertex gl_FrontColor gl_BackColor gl_FrontSecondaryColor gl_BackSecondaryColor gl_TexCoord gl_FogFragCoord gl_FragCoord gl_FrontFacing gl_FragData gl_FragDepth gl_ModelViewMatrix gl_ProjectionMatrix gl_ModelViewProjectionMatrix gl_TextureMatrix gl_NormalMatrix gl_ModelViewMatrixInverse gl_ProjectionMatrixInverse gl_ModelViewProjectionMatrixInverse gl_TexureMatrixTranspose gl_ModelViewMatrixInverseTranspose gl_ProjectionMatrixInverseTranspose gl_ModelViewProjectionMatrixInverseTranspose gl_TextureMatrixInverseTranspose gl_NormalScale gl_DepthRange gl_ClipPlane gl_Point gl_FrontMaterial gl_BackMaterial gl_LightSource gl_LightModel gl_FrontLightModelProduct gl_BackLightModelProduct gl_TextureColor gl_EyePlaneS gl_EyePlaneT gl_EyePlaneR gl_EyePlaneQ gl_FogParameters gl_MaxLights gl_MaxClipPlanes gl_MaxTextureUnits gl_MaxTextureCoords gl_MaxVertexAttribs gl_MaxVertexUniformComponents gl_MaxVaryingFloats gl_MaxVertexTextureImageUnits gl_MaxTextureImageUnits gl_MaxFragmentUniformComponents gl_MaxCombineTextureImageUnits gl_MaxDrawBuffers"),indentSwitch:!1,hooks:{"#":s},modeProps:{fold:["brace","include"]}}),h("text/x-nesc",{name:"clike",keywords:i(b+"as atomic async call command component components configuration event generic implementation includes interface module new norace nx_struct nx_union post provides signal task uses abstract extends"),types:i(k),blockKeywords:i("case do else for if switch while struct"),atoms:i("null true false"),hooks:{"#":s},modeProps:{fold:["brace","include"]}}),h("text/x-objectivec",{name:"clike",keywords:i(b+"inline restrict _Bool _Complex _Imaginary BOOL Class bycopy byref id IMP in inout nil oneway out Protocol SEL self super atomic nonatomic retain copy readwrite readonly"),types:i(k),atoms:i("YES NO NULL NILL ON OFF true false"),hooks:{"@":function(e){return e.eatWhile(/[\w\$]/),"keyword"},"#":s,indent:function(e,t,n){if("statement"==t.type&&/^@\w/.test(n))return t.indented}},modeProps:{fold:"brace"}}),h("text/x-squirrel",{name:"clike",keywords:i("base break clone continue const default delete enum extends function in class foreach local resume return this throw typeof yield constructor instanceof static"),types:i(k),blockKeywords:i("case catch class else for foreach if switch try while"),defKeywords:i("function local class"),typeFirstDefinitions:!0,atoms:i("true false null"),hooks:{"#":s},modeProps:{fold:["brace","include"]}});var w=null;h("text/x-ceylon",{name:"clike",keywords:i("abstracts alias assembly assert assign break case catch class continue dynamic else exists extends finally for function given if import in interface is let module new nonempty object of out outer package return satisfies super switch then this throw try value void while"),types:function(e){var t=e.charAt(0);return t===t.toUpperCase()&&t!==t.toLowerCase()},blockKeywords:i("case catch class dynamic else finally for function if interface module new object switch try while"),defKeywords:i("class dynamic function interface module object package value"),builtin:i("abstract actual aliased annotation by default deprecated doc final formal late license native optional sealed see serializable shared suppressWarnings tagged throws variable"),isPunctuationChar:/[\[\]{}\(\),;\:\.`]/,isOperatorChar:/[+\-*&%=<>!?|^~:\/]/,numberStart:/[\d#$]/,number:/^(?:#[\da-fA-F_]+|\$[01_]+|[\d_]+[kMGTPmunpf]?|[\d_]+\.[\d_]+(?:[eE][-+]?\d+|[kMGTPmunpf]|)|)/i,multiLineStrings:!0,typeFirstDefinitions:!0,atoms:i("true false null larger smaller equal empty finished"),indentSwitch:!1,styleDefs:!1,hooks:{"@":function(e){return e.eatWhile(/[\w\$_]/),"meta"},'"':function(e,t){return t.tokenize=x(e.match('""')?"triple":"single"),t.tokenize(e,t)},"`":function(e,t){return!(!w||!e.match("`"))&&(t.tokenize=w,w=null,t.tokenize(e,t))},"'":function(e){return e.eatWhile(/[\w\$_\xa1-\uffff]/),"atom"},token:function(e,t,n){if(("variable"==n||"type"==n)&&"."==t.prevToken)return"variable-2"}},modeProps:{fold:["brace","import"],closeBrackets:{triples:'"'}}})});
      // -------------------------------------------------------------------------
//  Part of the CodeChecker project, under the Apache License v2.0 with
//  LLVM Exceptions. See LICENSE for license information.
//  SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
// -------------------------------------------------------------------------

var BugViewer = {
  _files : [],
  _reports : [],
  _lineWidgets : [],
  _navigationMenuItems : [],
  _sourceFileData : null,
  _currentReport : null,
  _lastBugEvent  : null,

  init : function (files, reports) {
    this._files = files;
    this._reports = reports;

    this.initEscapeChars();
  },

  initEscapeChars : function () {
    this.escapeChars = {
      ' ' : 'nbsp',
      '<' : 'lt',
      '>' : 'gt',
      '"' : 'quot',
      '&' : 'amp'
    };

    var regexString = '[';
    for (var key in this.escapeChars) {
      regexString += key;
    }
    regexString += ']';

    this.escapeRegExp = new RegExp( regexString, 'g');
  },

  escapeHTML : function (str) {
    var that = this;

    return str.replace(this.escapeRegExp, function (m) {
      return '&' + that.escapeChars[m] + ';';
    });
  },

  initByUrl : function () {
    if (!this._reports) return;

    var state = {};
    window.location.hash.substr(1).split('&').forEach(function (s) {
      var parts = s.split('=');
      state[parts[0]] = parts[1];
    });

    for (var key in this._reports) {
      var report = this._reports[key];
      if (report.reportHash === state['reportHash']) {
        this.navigate(report);
        return;
      }
    }

    this.navigate(this._reports[0]);
  },

  create : function () {
    this._content = document.getElementById('editor-wrapper');
    this._filepath = document.getElementById('file-path');
    this._checkerName = document.getElementById('checker-name');
    this._reviewStatusWrapper =
      document.getElementById('review-status-wrapper');
    this._reviewStatus = document.getElementById('review-status');
    this._editor = document.getElementById('editor');

    this._codeMirror = CodeMirror(this._editor, {
      mode: 'text/x-c++src',
      matchBrackets : true,
      lineNumbers : true,
      readOnly : true,
      foldGutter : true,
      extraKeys : {},
      viewportMargin : 100
    });

    this._createNavigationMenu();
  },

  navigate : function (report, item) {
    if (!item) {
      var items = this._navigationMenuItems.filter(function (navItem) {
        return navItem.report.reportHash === report.reportHash;
      });

      if (!items.length) return;

      item = items[0].widget;
    }

    this._selectedReport.classList.remove('active');
    this._selectedReport = item;
    this._selectedReport.classList.add('active');
    this.setReport(report);
  },

  _createNavigationMenu : function () {
    var that = this;

    var nav = document.getElementById('report-nav');
    var list = document.createElement('ul');
    this._reports.forEach(function (report) {
      var events = report['events'];
      var lastBugEvent = events[events.length - 1];
      var item = document.createElement('li');

      var severity = document.createElement('i');
      severity.className = 'severity-' + report.severity.toLowerCase();

      item.appendChild(severity);
      item.appendChild(document.createTextNode(lastBugEvent.message));

      item.addEventListener('click', function () {
        that.navigate(report, item);
      })
      list.appendChild(item);
      that._navigationMenuItems.push({ report : report, widget : item });
    });

    if (!this._selectedReport && list.childNodes.length) {
      this._selectedReport = list.childNodes[0];
      this._selectedReport.classList.add('active');
    }

    nav.appendChild(list);
  },

  setReport : function (report) {
    this._currentReport = report;
    var events = report['events'];
    var lastBugEvent = events[events.length - 1];
    this.setCurrentBugEvent(lastBugEvent, events.length - 1);
    this.setCheckerName(report.checkerName);
    this.setReviewStatus(report.reviewStatus);

    window.location.hash = '#reportHash=' + report.reportHash;
  },

  setCurrentBugEvent : function (event, idx) {
    this._currentBugEvent = event;
    this.setSourceFileData(this._files[event.location.file]);
    this.drawBugPath();

    this.jumpTo(event.location.line, 0);
    this.highlightBugEvent(event, idx);
  },

  highlightBugEvent : function (event, idx) {
    this._lineWidgets.forEach(function (widget) {
      var lineIdx = widget.node.getAttribute('idx');
      if (parseInt(lineIdx) === idx) {
        widget.node.classList.add('current');
      }
    });
  },

  setCheckerName : function (checkerName) {
    this._checkerName.innerHTML = checkerName;
  },

  setReviewStatus : function (status) {
    if (status) {
      var className =
        'review-status-' + status.toLowerCase().split(' ').join('-');
      this._reviewStatus.className = "review-status " + className;

      this._reviewStatus.innerHTML = status;
      this._reviewStatusWrapper.style.display = 'block';
    } else {
      this._reviewStatusWrapper.style.display = 'none';
    }
  },

  setSourceFileData : function (file) {
    if (this._sourceFileData && file.id === this._sourceFileData.id) {
      return;
    }

    this._sourceFileData = file;
    this._filepath.innerHTML = file.path;
    this._codeMirror.doc.setValue(file.content);
    this._refresh();
  },

  _refresh : function () {
    var that = this;
    setTimeout(function () {
      var fullHeight = parseInt(that._content.clientHeight);
      var headerHeight = that._filepath.clientHeight;

      that._codeMirror.setSize('auto', fullHeight - headerHeight);
      that._codeMirror.refresh();
    }, 200);
  },

  clearBubbles : function () {
    this._lineWidgets.forEach(function (widget) { widget.clear(); });
    this._lineWidgets = [];
  },

  getMessage : function (event, kind) {
    if (kind === 'macro') {
      var name = 'macro expansion' + (event.name ? ': ' + event.name : '');

      return '<span class="tag macro">' + name + '</span>'
        + this.escapeHTML(event.expansion).replace(/(?:\r\n|\r|\n)/g, '<br>');
    } else if (kind === 'note') {
      return '<span class="tag note">note</span>'
        +  this.escapeHTML(event.message).replace(/(?:\r\n|\r|\n)/g, '<br>');
    }
  },

  addExtraPathEvents : function (events, kind) {
    var that = this;

    if (!events) {
      return;
    }

    events.forEach(function (event) {
      if (event.location.file !== that._currentBugEvent.location.file) {
        return;
      }

      var left =
        that._codeMirror.defaultCharWidth() * event.location.col + 'px';

      var element = document.createElement('div');
      element.setAttribute('style', 'margin-left: ' + left);
      element.setAttribute('class', 'check-msg ' + kind);

      var msg = document.createElement('span');
      msg.innerHTML = that.getMessage(event, kind);
      element.appendChild(msg);

      that._lineWidgets.push(that._codeMirror.addLineWidget(
        event.location.line - 1, element));
    });
  },

  drawBugPath : function () {
    var that = this;

    this.clearBubbles();

    this.addExtraPathEvents(this._currentReport.macros, 'macro');
    this.addExtraPathEvents(this._currentReport.notes, 'note');

    // Processing bug path events.
    var currentEvents = this._currentReport.events;
    currentEvents.forEach(function (event, step) {
      if (event.location.file !== that._currentBugEvent.location.file)
        return;

      var left =
        that._codeMirror.defaultCharWidth() * event.location.col + 'px';
      var type = step === currentEvents.length - 1 ? 'error' : 'info';

      var element = document.createElement('div');
      element.setAttribute('style', 'margin-left: ' + left);
      element.setAttribute('class', 'check-msg ' + type);
      element.setAttribute('idx', step);

      var enumeration = document.createElement('span');
      enumeration.setAttribute('class', 'checker-enum ' + type);
      enumeration.innerHTML = step + 1;

      if (currentEvents.length > 1)
        element.appendChild(enumeration);

      var prevBugEvent = step - 1;
      if (step > 0) {
        var prevBug = document.createElement('span');
        prevBug.setAttribute('class', 'arrow left-arrow');
        prevBug.addEventListener('click', function () {
          var event = currentEvents[prevBugEvent];
          that.setCurrentBugEvent(event, prevBugEvent);
        });
        element.appendChild(prevBug);
      }

      var msg = document.createElement('span');
      msg.innerHTML = that.escapeHTML(event.message)
        .replace(/(?:\r\n|\r|\n)/g, '<br>');

      element.appendChild(msg);

      var nextBugEvent = step + 1;
      if (nextBugEvent < currentEvents.length) {
        var nextBug = document.createElement('span');
        nextBug.setAttribute('class', 'arrow right-arrow');
        nextBug.addEventListener('click', function () {
          var event = currentEvents[nextBugEvent];
          that.setCurrentBugEvent(event, nextBugEvent);
        });
        element.appendChild(nextBug);
      }


      that._lineWidgets.push(that._codeMirror.addLineWidget(
        event.location.line - 1, element));
    });
  },

  jumpTo : function (line, column) {
    var that = this;

    setTimeout(function () {
      var selPosPixel
        = that._codeMirror.charCoords({ line : line, ch : column }, 'local');
      var editorSize = {
        width  : that._editor.clientWidth,
        height : that._editor.clientHeight
      };

      that._codeMirror.scrollIntoView({
        top    : selPosPixel.top - 100,
        bottom : selPosPixel.top + editorSize.height - 150,
        left   : selPosPixel.left < editorSize.width - 100
               ? 0
               : selPosPixel.left - 50,
        right  : selPosPixel.left < editorSize.width - 100
               ? 10
               : selPosPixel.left + editorSize.width - 100
      });
    }, 0);
  }
}


      var data = {"files": {"0": {"id": 0, "path": "/home/runner/work/testcc/testcc/retdec/config.h", "content": "/* config.h.  Generated from config.h.in by configure.  */\n/* config.h.in.  Generated from configure.ac by autoheader.  */\n\n/* Define if building universal (internal helper macro) */\n/* #undef AC_APPLE_UNIVERSAL_BUILD */\n\n/* Define if you have buggy CMSG macros */\n/* #undef BUGGY_CMSG_MACROS */\n\n/* Built-in Cassandra support */\n/* #undef BUILD_CASSANDRA */\n\n/* Build with CDB support */\n/* #undef BUILD_CDB */\n\n/* Build with Berkeley DB support */\n/* #undef BUILD_DB */\n\n/* Built-in MySQL support */\n/* #undef BUILD_MYSQL */\n\n/* Built-in PostgreSQL support */\n/* #undef BUILD_PGSQL */\n\n/* Built-in SQLite support */\n/* #undef BUILD_SQLITE */\n\n/* GSSAPI support is built in */\n/* #undef BUILTIN_GSSAPI */\n\n/* LDAP support is built in */\n/* #undef BUILTIN_LDAP */\n\n/* Lua support is builtin */\n/* #undef BUILTIN_LUA */\n\n/* IMAP capabilities advertised in banner */\n#define CAPABILITY_BANNER_STRING \"IMAP4rev1 SASL-IR LOGIN-REFERRALS ID ENABLE IDLE\"\n\n/* IMAP capabilities */\n#define CAPABILITY_STRING \"IMAP4rev1 SASL-IR LOGIN-REFERRALS ID ENABLE IDLE SORT SORT=DISPLAY THREAD=REFERENCES THREAD=REFS THREAD=ORDEREDSUBJECT MULTIAPPEND URL-PARTIAL CATENATE UNSELECT CHILDREN NAMESPACE UIDPLUS LIST-EXTENDED I18NLEVEL=1 CONDSTORE QRESYNC ESEARCH ESORT SEARCHRES WITHIN CONTEXT=SEARCH LIST-STATUS BINARY MOVE SNIPPET=FUZZY PREVIEW=FUZZY STATUS=SIZE SAVEDATE\"\n\n/* Define if _XPG6 macro is needed for crypt() */\n#define CRYPT_USE_XPG6 /**/\n\n/* Build with extra debugging checks */\n/* #undef DEBUG */\n\n/* Define if your dev_t is a structure instead of integer type */\n/* #undef DEV_T_STRUCT */\n\n/* Path to random source */\n#define DEV_URANDOM_PATH \"/dev/urandom\"\n\n/* Disable asserts */\n/* #undef DISABLE_ASSERTS */\n\n/* Dovecot ABI version */\n#define DOVECOT_ABI_VERSION \"2.4.ABIv0(2.4.devel)\"\n\n/* Dovecot name */\n#define DOVECOT_NAME \"Dovecot\"\n\n/* Dovecot string */\n#define DOVECOT_STRING \"Dovecot 2.4.devel\"\n\n/* Dovecot version */\n#define DOVECOT_VERSION \"2.4.devel\"\n\n/* Dovecot major version */\n#define DOVECOT_VERSION_MAJOR 2\n\n/* Dovecot minor version */\n#define DOVECOT_VERSION_MINOR 4\n\n/* How to define flexible array members in structs */\n#define FLEXIBLE_ARRAY_MEMBER \n\n/* Define this if you have arc4random_buf() */\n/* #undef HAVE_ARC4RANDOM */\n\n/* Build with ASN1_STRING_get0_data() support */\n#define HAVE_ASN1_STRING_GET0_DATA /**/\n\n/* Define to 1 if you have the `backtrace_symbols' function. */\n#define HAVE_BACKTRACE_SYMBOLS 1\n\n/* Build with BN_secure_new support */\n#define HAVE_BN_SECURE_NEW /**/\n\n/* Define if you have bzlib library */\n#define HAVE_BZLIB /**/\n\n/* Build with Cassandra support */\n/* #undef HAVE_CASSANDRA */\n\n/* Cassandra supports speculative execution policy */\n/* #undef HAVE_CASSANDRA_SPECULATIVE_POLICY */\n\n/* Define to 1 if you have the `clearenv' function. */\n#define HAVE_CLEARENV 1\n\n/* Define if you have the clock_gettime function */\n#define HAVE_CLOCK_GETTIME /**/\n\n/* Define to 1 if you have the <crypt.h> header file. */\n#define HAVE_CRYPT_H 1\n\n/* Define to 1 if you have the declaration of `getrandom', and to 0 if you\n   don't. */\n#define HAVE_DECL_GETRANDOM 1\n\n/* Define to 1 if you have the declaration of\n   `ZSTD_error_parameter_unsupported', and to 0 if you don't. */\n/* #undef HAVE_DECL_ZSTD_ERROR_PARAMETER_UNSUPPORTED */\n\n/* Define if you have struct dirent->d_type */\n#define HAVE_DIRENT_D_TYPE /**/\n\n/* Define to 1 if you have the <dirent.h> header file. */\n#define HAVE_DIRENT_H 1\n\n/* Define to 1 if you have the `dirfd' function. */\n#define HAVE_DIRFD 1\n\n/* Define to 1 if you have the <dlfcn.h> header file. */\n#define HAVE_DLFCN_H 1\n\n/* Build with ECDSA_SIG_get0 support */\n#define HAVE_ECDSA_SIG_GET0 /**/\n\n/* Build with ECDSA_SIG_set0 support */\n#define HAVE_ECDSA_SIG_SET0 /**/\n\n/* Build with EC_GROUP_order_bits support */\n#define HAVE_EC_GROUP_order_bits /**/\n\n/* Build with EVP_MD_CTX_new() support */\n#define HAVE_EVP_MD_CTX_NEW /**/\n\n/* Build with EVP_PKEY_get0_*() support */\n#define HAVE_EVP_PKEY_get0 /**/\n\n/* Define to 1 if you have the <execinfo.h> header file. */\n#define HAVE_EXECINFO_H 1\n\n/* Define to 1 if you have the `fallocate' function. */\n#define HAVE_FALLOCATE 1\n\n/* Define to 1 if you have the `fcntl' function. */\n#define HAVE_FCNTL 1\n\n/* Define if you have fdatasync() */\n#define HAVE_FDATASYNC /**/\n\n/* Define to 1 if you have the `flock' function. */\n#define HAVE_FLOCK 1\n\n/* Define if you have FreeBSD-compatible sendfile() */\n/* #undef HAVE_FREEBSD_SENDFILE */\n\n/* Define if you want exttextcat support for FTS */\n/* #undef HAVE_FTS_EXTTEXTCAT */\n\n/* Define if you want stemming support for FTS */\n/* #undef HAVE_FTS_STEMMER */\n\n/* Define if you want textcat support for FTS */\n/* #undef HAVE_FTS_TEXTCAT */\n\n/* Define to 1 if you have the `getmntent' function. */\n#define HAVE_GETMNTENT 1\n\n/* Define to 1 if you have the `getmntinfo' function. */\n/* #undef HAVE_GETMNTINFO */\n\n/* Define to 1 if you have the `getpagesize' function. */\n#define HAVE_GETPAGESIZE 1\n\n/* Define to 1 if you have the `getpeereid' function. */\n/* #undef HAVE_GETPEEREID */\n\n/* Define to 1 if you have the `getpeerucred' function. */\n/* #undef HAVE_GETPEERUCRED */\n\n/* Define to 1 if you have the `getrandom' function. */\n#define HAVE_GETRANDOM 1\n\n/* Define to 1 if you have the `glob' function. */\n#define HAVE_GLOB 1\n\n/* Define to 1 if you have the <glob.h> header file. */\n#define HAVE_GLOB_H 1\n\n/* Build with GNUTLS support */\n/* #undef HAVE_GNUTLS */\n\n/* Build with GSSAPI support */\n/* #undef HAVE_GSSAPI */\n\n/* Define to 1 if you have the <gssapi/gssapi_ext.h> header file. */\n/* #undef HAVE_GSSAPI_GSSAPI_EXT_H */\n\n/* GSSAPI headers in gssapi/gssapi.h */\n/* #undef HAVE_GSSAPI_GSSAPI_H */\n\n/* Define to 1 if you have the <gssapi/gssapi_krb5.h> header file. */\n/* #undef HAVE_GSSAPI_GSSAPI_KRB5_H */\n\n/* GSSAPI headers in gssapi.h */\n/* #undef HAVE_GSSAPI_H */\n\n/* Define to 1 if you have the <gssapi_krb5.h> header file. */\n/* #undef HAVE_GSSAPI_KRB5_H */\n\n/* GSSAPI supports SPNEGO */\n/* #undef HAVE_GSSAPI_SPNEGO */\n\n/* Define to 1 if you have the `gsskrb5_register_acceptor_identity' function.\n   */\n/* #undef HAVE_GSSKRB5_REGISTER_ACCEPTOR_IDENTITY */\n\n/* Build with HMAC_CTX_new() support */\n#define HAVE_HMAC_CTX_NEW /**/\n\n/* Define if you have the iconv() function and it works. */\n#define HAVE_ICONV 1\n\n/* Define to 1 if you have the `inet_aton' function. */\n#define HAVE_INET_ATON 1\n\n/* Define to 1 if you have the `inotify_init' function. */\n#define HAVE_INOTIFY_INIT 1\n\n/* Define to 1 if you have the <inttypes.h> header file. */\n#define HAVE_INTTYPES_H 1\n\n/* Build with IPv6 support */\n#define HAVE_IPV6 /**/\n\n/* Define to 1 if you have the <jfs/quota.h> header file. */\n/* #undef HAVE_JFS_QUOTA_H */\n\n/* Define to 1 if you have the `kevent' function. */\n/* #undef HAVE_KEVENT */\n\n/* Define to 1 if you have the `kqueue' function. */\n/* #undef HAVE_KQUEUE */\n\n/* Define to 1 if you have the `krb5_free_context' function. */\n/* #undef HAVE_KRB5_FREE_CONTEXT */\n\n/* Define to 1 if you have the `krb5_gss_register_acceptor_identity' function.\n   */\n/* #undef HAVE_KRB5_GSS_REGISTER_ACCEPTOR_IDENTITY */\n\n/* Define this if you have libbsd */\n/* #undef HAVE_LIBBSD */\n\n/* libcap is installed for cap_init() */\n/* #undef HAVE_LIBCAP */\n\n/* Define to 1 if you have the <libexttextcat/textcat.h> header file. */\n/* #undef HAVE_LIBEXTTEXTCAT_TEXTCAT_H */\n\n/* Define to 1 if you have the <libgen.h> header file. */\n#define HAVE_LIBGEN_H 1\n\n/* Define if you want ICU normalization support for FTS */\n#define HAVE_LIBICU /**/\n\n/* Define if you have libsodium */\n/* #undef HAVE_LIBSODIUM */\n\n/* Define to 1 if you have the <libtextcat/textcat.h> header file. */\n/* #undef HAVE_LIBTEXTCAT_TEXTCAT_H */\n\n/* Define this if you have libunwind */\n/* #undef HAVE_LIBUNWIND */\n\n/* Define if you have libwrap */\n/* #undef HAVE_LIBWRAP */\n\n/* Define to 1 if you have the <linux/dqblk_xfs.h> header file. */\n#define HAVE_LINUX_DQBLK_XFS_H 1\n\n/* Define to 1 if you have the <linux/falloc.h> header file. */\n#define HAVE_LINUX_FALLOC_H 1\n\n/* Define if you have Linux-compatible mremap() */\n#define HAVE_LINUX_MREMAP /**/\n\n/* Define if you have Linux-compatible sendfile() */\n#define HAVE_LINUX_SENDFILE /**/\n\n/* Define to 1 if you have the `lockf' function. */\n#define HAVE_LOCKF 1\n\n/* Define to 1 if you have lua */\n/* #undef HAVE_LUA */\n\n/* Define if you have lz4 library */\n/* #undef HAVE_LZ4 */\n\n/* Define if you have LZ4_compress_default */\n/* #undef HAVE_LZ4_COMPRESS_DEFAULT */\n\n/* Define if you have lzma library */\n#define HAVE_LZMA /**/\n\n/* Define to 1 if you have the `madvise' function. */\n#define HAVE_MADVISE 1\n\n/* Define to 1 if you have the <malloc.h> header file. */\n#define HAVE_MALLOC_H 1\n\n/* Define to 1 if you have the <malloc_np.h> header file. */\n/* #undef HAVE_MALLOC_NP_H */\n\n/* Define to 1 if you have the `malloc_usable_size' function. */\n#define HAVE_MALLOC_USABLE_SIZE 1\n\n/* Define to 1 if you have the <memory.h> header file. */\n#define HAVE_MEMORY_H 1\n\n/* Define to 1 if you have the <mntent.h> header file. */\n#define HAVE_MNTENT_H 1\n\n/* Define if you have dynamic module support */\n#define HAVE_MODULES /**/\n\n/* Build with MySQL support */\n/* #undef HAVE_MYSQL */\n\n/* Define if your MySQL library has SSL functions */\n/* #undef HAVE_MYSQL_SSL */\n\n/* Define if your MySQL library supports setting cipher */\n/* #undef HAVE_MYSQL_SSL_CIPHER */\n\n/* Defineif your MySQL library supports verifying the name in the SSL\n   certificate */\n/* #undef HAVE_MYSQL_SSL_VERIFY_SERVER_CERT */\n\n/* Build with OBJ_length() support */\n#define HAVE_OBJ_LENGTH /**/\n\n/* Define if you don't have C99 compatible vsnprintf() call */\n/* #undef HAVE_OLD_VSNPRINTF */\n\n/* Build with OpenSSL support */\n#define HAVE_OPENSSL /**/\n\n/* Define if OpenSSL performs thread cleanup automatically */\n#define HAVE_OPENSSL_AUTO_THREAD_DEINIT /**/\n\n/* OpenSSL supports OPENSSL_cleanup() */\n#define HAVE_OPENSSL_CLEANUP /**/\n\n/* Define to 1 if you have the <openssl/err.h> header file. */\n/* #undef HAVE_OPENSSL_ERR_H */\n\n/* Define if you have ERR_remove_thread_state */\n#define HAVE_OPENSSL_ERR_REMOVE_THREAD_STATE /**/\n\n/* Define if you have openssl/rand.h */\n/* #undef HAVE_OPENSSL_RAND_H */\n\n/* Define to 1 if you have the <openssl/ssl.h> header file. */\n/* #undef HAVE_OPENSSL_SSL_H */\n\n/* Define if you have pam/pam_appl.h */\n/* #undef HAVE_PAM_PAM_APPL_H */\n\n/* Define if you have pam_setcred() */\n/* #undef HAVE_PAM_SETCRED */\n\n/* Build with PostgreSQL support */\n/* #undef HAVE_PGSQL */\n\n/* Define to 1 if you have the `posix_fadvise' function. */\n#define HAVE_POSIX_FADVISE 1\n\n/* Define if you have a working posix_fallocate() */\n#define HAVE_POSIX_FALLOCATE /**/\n\n/* Define if libpq has PQescapeStringConn function */\n/* #undef HAVE_PQESCAPE_STRING_CONN */\n\n/* Define to 1 if you have the `pread' function. */\n#define HAVE_PREAD 1\n\n/* Define if you have prctl(PR_SET_DUMPABLE) */\n#define HAVE_PR_SET_DUMPABLE /**/\n\n/* Define to 1 if you have the `quotactl' function. */\n#define HAVE_QUOTACTL 1\n\n/* Define to 1 if you have the <quota.h> header file. */\n/* #undef HAVE_QUOTA_H */\n\n/* Define if you have quota_open() */\n/* #undef HAVE_QUOTA_OPEN */\n\n/* Define if Q_QUOTACTL exists */\n/* #undef HAVE_Q_QUOTACTL */\n\n/* Define if you have RLIMIT_AS for setrlimit() */\n#define HAVE_RLIMIT_AS /**/\n\n/* Define if you have RLIMIT_CORE for getrlimit() */\n#define HAVE_RLIMIT_CORE /**/\n\n/* Define if you have RLIMIT_NPROC for setrlimit() */\n#define HAVE_RLIMIT_NPROC /**/\n\n/* Define if you wish to retrieve quota of NFS mounted mailboxes */\n#define HAVE_RQUOTA /**/\n\n/* Build with RSA_generate_key_ex() support */\n#define HAVE_RSA_GENERATE_KEY_EX /**/\n\n/* Build with RSA_set0_crt_params support */\n#define HAVE_RSA_SET0_CRT_PARAMS /**/\n\n/* Build with RSA_set0_factors support */\n#define HAVE_RSA_SET0_FACTORS /**/\n\n/* Build with RSA_set0_key support */\n#define HAVE_RSA_SET0_KEY /**/\n\n/* Define to 1 if you have the <sasl.h> header file. */\n/* #undef HAVE_SASL_H */\n\n/* Define to 1 if you have the <sasl/sasl.h> header file. */\n/* #undef HAVE_SASL_SASL_H */\n\n/* Define if you have security/pam_appl.h */\n/* #undef HAVE_SECURITY_PAM_APPL_H */\n\n/* Define to 1 if you have the `setegid' function. */\n#define HAVE_SETEGID 1\n\n/* Define to 1 if you have the `seteuid' function. */\n#define HAVE_SETEUID 1\n\n/* Define to 1 if you have the `setpriority' function. */\n#define HAVE_SETPRIORITY 1\n\n/* Define to 1 if you have the `setproctitle' function. */\n/* #undef HAVE_SETPROCTITLE */\n\n/* Define to 1 if you have the `setresgid' function. */\n#define HAVE_SETRESGID 1\n\n/* Define to 1 if you have the `setreuid' function. */\n#define HAVE_SETREUID 1\n\n/* Define to 1 if you have the `setrlimit' function. */\n#define HAVE_SETRLIMIT 1\n\n/* Define to 1 if you have the `sigaction' function. */\n#define HAVE_SIGACTION 1\n\n/* Define to 'int' if you don't have socklen_t */\n#define HAVE_SOCKLEN_T /**/\n\n/* Define if you have Solaris-compatible sendfile() */\n/* #undef HAVE_SOLARIS_SENDFILE */\n\n/* Build with SQLite3 support */\n/* #undef HAVE_SQLITE */\n\n/* Build with SSL/TLS support */\n#define HAVE_SSL /**/\n\n/* Define if you have SSL_CIPHER_get_kx_nid */\n#define HAVE_SSL_CIPHER_get_kx_nid /**/\n\n/* Define if you have SSL_clear_options */\n#define HAVE_SSL_CLEAR_OPTIONS /**/\n\n/* Build with OpenSSL compression */\n#define HAVE_SSL_COMPRESSION /**/\n\n/* Build with SSL_COMP_free_compression_methods() support */\n/* #undef HAVE_SSL_COMP_FREE_COMPRESSION_METHODS */\n\n/* Define if you have SSL_CTX_add0_chain_cert */\n#define HAVE_SSL_CTX_ADD0_CHAIN_CERT /**/\n\n/* Define if you have SSL_CTX_set1_curves_list */\n#define HAVE_SSL_CTX_SET1_CURVES_LIST /**/\n\n/* Build with SSL_CTX_set_ciphersuites() support */\n#define HAVE_SSL_CTX_SET_CIPHERSUITES /**/\n\n/* Define if you have SSL_CTX_set_current_cert */\n#define HAVE_SSL_CTX_SET_CURRENT_CERT /**/\n\n/* Define if you have SSL_CTX_set_min_proto_version */\n#define HAVE_SSL_CTX_SET_MIN_PROTO_VERSION /**/\n\n/* Build with TLS hostname support */\n#define HAVE_SSL_GET_SERVERNAME /**/\n\n/* Define if CRYPTO_set_mem_functions has new style parameters */\n#define HAVE_SSL_NEW_MEM_FUNCS /**/\n\n/* Define if you have statfs.f_mntfromname */\n/* #undef HAVE_STATFS_MNTFROMNAME */\n\n/* Define if you have statvfs.f_mntfromname */\n/* #undef HAVE_STATVFS_MNTFROMNAME */\n\n/* Define if you have st_?tim timespec fields in struct stat */\n#define HAVE_STAT_XTIM /**/\n\n/* Define if you have st_?timespec fields in struct stat */\n/* #undef HAVE_STAT_XTIMESPEC */\n\n/* Define to 1 if you have the <stdint.h> header file. */\n#define HAVE_STDINT_H 1\n\n/* Define to 1 if you have the <stdlib.h> header file. */\n#define HAVE_STDLIB_H 1\n\n/* Define to 1 if you have the `strcasecmp' function. */\n#define HAVE_STRCASECMP 1\n\n/* Define to 1 if you have the `stricmp' function. */\n/* #undef HAVE_STRICMP */\n\n/* Define to 1 if you have the <strings.h> header file. */\n#define HAVE_STRINGS_H 1\n\n/* Define to 1 if you have the <string.h> header file. */\n#define HAVE_STRING_H 1\n\n/* Define if struct sqblk.dqb_curblocks exists */\n/* #undef HAVE_STRUCT_DQBLK_CURBLOCKS */\n\n/* Define if struct sqblk.dqb_curspace exists */\n#define HAVE_STRUCT_DQBLK_CURSPACE /**/\n\n/* Define if you have struct iovec */\n#define HAVE_STRUCT_IOVEC /**/\n\n/* Define to 1 if the system has the type `struct sockpeercred'. */\n/* #undef HAVE_STRUCT_SOCKPEERCRED */\n\n/* Define if you want to use systemd socket activation */\n/* #undef HAVE_SYSTEMD */\n\n/* Define to 1 if you have the <sys/event.h> header file. */\n/* #undef HAVE_SYS_EVENT_H */\n\n/* Define to 1 if you have the <sys/fs/quota_common.h> header file. */\n/* #undef HAVE_SYS_FS_QUOTA_COMMON_H */\n\n/* Define to 1 if you have the <sys/fs/ufs_quota.h> header file. */\n/* #undef HAVE_SYS_FS_UFS_QUOTA_H */\n\n/* Define to 1 if you have the <sys/mkdev.h> header file. */\n/* #undef HAVE_SYS_MKDEV_H */\n\n/* Define to 1 if you have the <sys/mnttab.h> header file. */\n/* #undef HAVE_SYS_MNTTAB_H */\n\n/* Define to 1 if you have the <sys/quota.h> header file. */\n#define HAVE_SYS_QUOTA_H 1\n\n/* Define to 1 if you have the <sys/resource.h> header file. */\n#define HAVE_SYS_RESOURCE_H 1\n\n/* Define to 1 if you have the <sys/select.h> header file. */\n#define HAVE_SYS_SELECT_H 1\n\n/* Define to 1 if you have the <sys/stat.h> header file. */\n#define HAVE_SYS_STAT_H 1\n\n/* Define to 1 if you have the <sys/sysmacros.h> header file. */\n#define HAVE_SYS_SYSMACROS_H 1\n\n/* Define to 1 if you have the <sys/time.h> header file. */\n#define HAVE_SYS_TIME_H 1\n\n/* Define to 1 if you have the <sys/types.h> header file. */\n#define HAVE_SYS_TYPES_H 1\n\n/* Define to 1 if you have the <sys/ucred.h> header file. */\n/* #undef HAVE_SYS_UCRED_H */\n\n/* Define to 1 if you have the <sys/uio.h> header file. */\n#define HAVE_SYS_UIO_H 1\n\n/* Define to 1 if you have the <sys/utsname.h> header file. */\n#define HAVE_SYS_UTSNAME_H 1\n\n/* Define to 1 if you have the <sys/vmount.h> header file. */\n/* #undef HAVE_SYS_VMOUNT_H */\n\n/* Define to 1 if you have the `timegm' function. */\n#define HAVE_TIMEGM 1\n\n/* Define if you have struct tm->tm_gmtoff */\n#define HAVE_TM_GMTOFF /**/\n\n/* Define if you have typeof() */\n#define HAVE_TYPEOF /**/\n\n/* Define to 1 if you have the <ucontext.h> header file. */\n#define HAVE_UCONTEXT_H 1\n\n/* Define to 1 if you have the <ucred.h> header file. */\n/* #undef HAVE_UCRED_H */\n\n/* Define to 1 if you have the <ufs/ufs/quota.h> header file. */\n/* #undef HAVE_UFS_UFS_QUOTA_H */\n\n/* Define if you have uintmax_t (C99 type) */\n#define HAVE_UINTMAX_T /**/\n\n/* Define if you have uint_fast32_t (C99 type) */\n#define HAVE_UINT_FAST32_T /**/\n\n/* Define to 1 if you have the `uname' function. */\n#define HAVE_UNAME 1\n\n/* Define to 1 if you have the <unistd.h> header file. */\n#define HAVE_UNISTD_H 1\n\n/* Define to 1 if you have the `unsetenv' function. */\n#define HAVE_UNSETENV 1\n\n/* Define if you have a native uoff_t type */\n/* #undef HAVE_UOFF_T */\n\n/* Define to 1 if you have the `vsyslog' function. */\n#define HAVE_VSYSLOG 1\n\n/* Define to 1 if you have the `walkcontext' function. */\n/* #undef HAVE_WALKCONTEXT */\n\n/* Define to 1 if you have the `writev' function. */\n#define HAVE_WRITEV 1\n\n/* Define to 1 if you have the <xfs/xqm.h> header file. */\n/* #undef HAVE_XFS_XQM_H */\n\n/* Define if you have zlib library */\n#define HAVE_ZLIB /**/\n\n/* Define if you have ZSTD library */\n/* #undef HAVE_ZSTD */\n\n/* Whether zstd has ZSTD_getErrorCode */\n/* #undef HAVE_ZSTD_GETERRORCODE */\n\n/* Define to 1 if the system has the type `_Bool'. */\n#define HAVE__BOOL 1\n\n/* Define if you have __gss_userok() */\n/* #undef HAVE___GSS_USEROK */\n\n/* Define as const if the declaration of iconv() needs const. */\n#define ICONV_CONST \n\n/* Implement I/O loop with Linux 2.6 epoll() */\n#define IOLOOP_EPOLL /**/\n\n/* Implement I/O loop with BSD kqueue() */\n/* #undef IOLOOP_KQUEUE */\n\n/* Use Linux inotify */\n#define IOLOOP_NOTIFY_INOTIFY /**/\n\n/* Use BSD kqueue directory changes notification */\n/* #undef IOLOOP_NOTIFY_KQUEUE */\n\n/* No special notify support */\n/* #undef IOLOOP_NOTIFY_NONE */\n\n/* Implement I/O loop with poll() */\n/* #undef IOLOOP_POLL */\n\n/* Implement I/O loop with select() */\n/* #undef IOLOOP_SELECT */\n\n/* Define if you have ldap_initialize */\n/* #undef LDAP_HAVE_INITIALIZE */\n\n/* Define if you have ldap_start_tls_s */\n/* #undef LDAP_HAVE_START_TLS_S */\n\n/* Define to the sub-directory where libtool stores uninstalled libraries. */\n#define LT_OBJDIR \".libs/\"\n\n/* Required memory alignment */\n#define MEM_ALIGN_SIZE 8\n\n/* Define if shared mmaps don't get updated by write()s */\n/* #undef MMAP_CONFLICTS_WRITE */\n\n/* Dynamic module suffix */\n#define MODULE_SUFFIX \".so\"\n\n/* Maximum value of off_t */\n#define OFF_T_MAX LONG_MAX\n\n/* Name of package */\n#define PACKAGE \"dovecot\"\n\n/* Define to the address where bug reports for this package should be sent. */\n#define PACKAGE_BUGREPORT \"dovecot@dovecot.org\"\n\n/* Define to the full name of this package. */\n#define PACKAGE_NAME \"Dovecot\"\n\n/* Define to the full name and version of this package. */\n#define PACKAGE_STRING \"Dovecot 2.4.devel\"\n\n/* Define to the one symbol short name of this package. */\n#define PACKAGE_TARNAME \"dovecot\"\n\n/* Define to the home page for this package. */\n#define PACKAGE_URL \"\"\n\n/* Define to the version of this package. */\n#define PACKAGE_VERSION \"2.4.devel\"\n\n/* Support URL */\n#define PACKAGE_WEBPAGE \"http://www.dovecot.org/\"\n\n/* Build with BSD authentication support */\n/* #undef PASSDB_BSDAUTH */\n\n/* Build with checkpassword passdb support */\n#define PASSDB_CHECKPASSWORD /**/\n\n/* Build with LDAP support */\n/* #undef PASSDB_LDAP */\n\n/* Build with PAM support */\n/* #undef PASSDB_PAM */\n\n/* Build with passwd support */\n#define PASSDB_PASSWD /**/\n\n/* Build with passwd-file support */\n#define PASSDB_PASSWD_FILE /**/\n\n/* Build with shadow support */\n#define PASSDB_SHADOW /**/\n\n/* Build with Tru64 SIA support */\n/* #undef PASSDB_SIA */\n\n/* Build with SQL support */\n/* #undef PASSDB_SQL */\n\n/* Build with vpopmail support */\n/* #undef PASSDB_VPOPMAIL */\n\n/* Define if pread/pwrite implementation is broken */\n/* #undef PREAD_BROKEN */\n\n/* Define if pread/pwrite needs _XOPEN_SOURCE 500 */\n#define PREAD_WRAPPERS /**/\n\n/* printf() fmt for dec time_t */\n#define PRIdTIME_T \"ld\"\n\n/* printf() format for uoff_t */\n#define PRIuUOFF_T \"lu\"\n\n/* printf() fmt for hex time_t */\n#define PRIxTIME_T \"lx\"\n\n/* Define if process title can be changed by modifying argv */\n#define PROCTITLE_HACK /**/\n\n/* The size of `int', as computed by sizeof. */\n#define SIZEOF_INT 4\n\n/* The size of `long', as computed by sizeof. */\n#define SIZEOF_LONG 8\n\n/* The size of `long long', as computed by sizeof. */\n#define SIZEOF_LONG_LONG 8\n\n/* The size of `void *', as computed by sizeof. */\n#define SIZEOF_VOID_P 8\n\n/* Build SQL drivers as plugins */\n/* #undef SQL_DRIVER_PLUGINS */\n\n/* Maximum value of ssize_t */\n#define SSIZE_T_MAX LONG_MAX\n\n/* C99 static array */\n#define STATIC_ARRAY static\n\n/* Building with static code analyzer */\n/* #undef STATIC_CHECKER */\n\n/* reasonable mntctl buffer size */\n/* #undef STATIC_MTAB_SIZE */\n\n/* Define to 1 if you have the ANSI C header files. */\n#define STDC_HEADERS 1\n\n/* Points to textcat pkgdatadir containing the language files */\n/* #undef TEXTCAT_DATADIR */\n\n/* max. time_t bits gmtime() can handle */\n#define TIME_T_MAX_BITS 40\n\n/* Define if your time_t is signed */\n#define TIME_T_SIGNED /**/\n\n/* Define if unsetenv() returns int */\n#define UNSETENV_RET_INT /**/\n\n/* Define if off_t is int */\n/* #undef UOFF_T_INT */\n\n/* Define if off_t is long */\n#define UOFF_T_LONG /**/\n\n/* Define if off_t is long long */\n/* #undef UOFF_T_LONG_LONG */\n\n/* Maximum value of uoff_t */\n#define UOFF_T_MAX ULONG_MAX\n\n/* Build with checkpassword userdb support */\n#define USERDB_CHECKPASSWORD /**/\n\n/* Build with LDAP support */\n/* #undef USERDB_LDAP */\n\n/* Build with passwd support */\n#define USERDB_PASSWD /**/\n\n/* Build with passwd-file support */\n#define USERDB_PASSWD_FILE /**/\n\n/* Build with prefetch userdb support */\n#define USERDB_PREFETCH /**/\n\n/* Build with SQL support */\n/* #undef USERDB_SQL */\n\n/* Build with vpopmail support */\n/* #undef USERDB_VPOPMAIL */\n\n/* A 'va_copy' style function */\n#define VA_COPY va_copy\n\n/* 'va_lists' cannot be copied as values */\n#define VA_COPY_AS_ARRAY 1\n\n/* Version number of package */\n#define VERSION \"2.4.devel\"\n\n/* Define WORDS_BIGENDIAN to 1 if your processor stores words with the most\n   significant byte first (like Motorola and SPARC, unlike Intel). */\n#if defined AC_APPLE_UNIVERSAL_BUILD\n# if defined __BIG_ENDIAN__\n#  define WORDS_BIGENDIAN 1\n# endif\n#else\n# ifndef WORDS_BIGENDIAN\n/* #  undef WORDS_BIGENDIAN */\n# endif\n#endif\n\n/* Enable large inode numbers on Mac OS X 10.5.  */\n#ifndef _DARWIN_USE_64_BIT_INODE\n# define _DARWIN_USE_64_BIT_INODE 1\n#endif\n\n/* Number of bits in a file offset, on hosts where this is settable. */\n/* #undef _FILE_OFFSET_BITS */\n\n/* Define for large files, on AIX-style hosts. */\n/* #undef _LARGE_FILES */\n\n/* Define to `__inline__' or `__inline' if that's what the C compiler\n   calls it, or to nothing if 'inline' is not supported under any name.  */\n#ifndef __cplusplus\n/* #undef inline */\n#endif\n\n/* Define to 'unsigned int' if you don't have it */\n/* #undef size_t */\n\n/* Define to 'int' if you don't have it */\n/* #undef ssize_t */\n"}, "1": {"id": 1, "path": "/home/runner/work/testcc/testcc/retdec/src/lib-imap-urlauth/imap-urlauth-backend.c", "content": "/* Copyright (c) 2013-2018 Dovecot authors, see the included COPYING file */\n\n#include \"lib.h\"\n#include \"buffer.h\"\n#include \"hex-binary.h\"\n#include \"randgen.h\"\n#include \"mail-user.h\"\n#include \"mail-storage.h\"\n#include \"mailbox-list-iter.h\"\n#include \"imap-urlauth-private.h\"\n#include \"imap-urlauth-backend.h\"\n\n#define IMAP_URLAUTH_KEY MAILBOX_ATTRIBUTE_PREFIX_DOVECOT\"imap-urlauth\"\n\nstatic int\nimap_urlauth_backend_trans_set_mailbox_key(struct mailbox *box,\n\t\t\t\t\t   unsigned char mailbox_key_r[IMAP_URLAUTH_KEY_LEN],\n\t\t\t\t\t   const char **client_error_r,\n\t\t\t\t\t   enum mail_error *error_code_r)\n{\n\tstruct mail_attribute_value urlauth_key;\n\tconst char *mailbox_key_hex = NULL;\n\tint ret;\n\n\tif (mailbox_open(box) < 0) {\n\t\t*client_error_r = mailbox_get_last_error(box, error_code_r);\n\t\treturn -1;\n\t}\n\n\tstruct mailbox_transaction_context *t =\n\t\tmailbox_transaction_begin(box,\n\t\t\t\tMAILBOX_TRANSACTION_FLAG_EXTERNAL,\n\t\t\t\t__func__);\n\n\t/* create new key */\n\trandom_fill(mailbox_key_r, IMAP_URLAUTH_KEY_LEN);\n\tmailbox_key_hex = binary_to_hex(mailbox_key_r,\n\t\t\t\t\tIMAP_URLAUTH_KEY_LEN);\n\ti_zero(&urlauth_key);\n\turlauth_key.value = mailbox_key_hex;\n\tret = mailbox_attribute_set(t, MAIL_ATTRIBUTE_TYPE_PRIVATE,\n\t\t\t\t    IMAP_URLAUTH_KEY, &urlauth_key);\n\n\tif (mailbox_transaction_commit(&t) < 0) {\n\t\t*client_error_r = mailbox_get_last_error(box, error_code_r);\n\t\tret = -1;\n\t}\n\n\treturn ret;\n}\n\nstatic int\nimap_urlauth_backend_trans_get_mailbox_key(struct mailbox *box,\n\t\t\t\t\t   bool create,\n\t\t\t\t\t   unsigned char mailbox_key_r[IMAP_URLAUTH_KEY_LEN],\n\t\t\t\t\t   const char **client_error_r,\n\t\t\t\t\t   enum mail_error *error_code_r)\n{\n\tstruct mail_user *user = mail_storage_get_user(mailbox_get_storage(box));\n\tstruct mail_attribute_value urlauth_key;\n\tconst char *mailbox_key_hex = NULL;\n\tbuffer_t key_buf;\n\tint ret;\n\n\t*client_error_r = \"Internal server error\";\n\t*error_code_r = MAIL_ERROR_TEMP;\n\n\tret = mailbox_attribute_get(box, MAIL_ATTRIBUTE_TYPE_PRIVATE,\n\t\t\t\t    IMAP_URLAUTH_KEY, &urlauth_key);\n\tif (ret < 0)\n\t\treturn -1;\n\n\te_debug(user->event, \"imap-urlauth: %skey found for mailbox %s\",\n\t\t(ret > 0 ? \"\" : \"no \"), mailbox_get_vname(box));\n\n\tif (ret == 0) {\n\t\tif (!create)\n\t\t\treturn 0;\n\n\t\tret = imap_urlauth_backend_trans_set_mailbox_key(box,\n\t\t\t\t\t\t\t\t mailbox_key_r,\n\t\t\t\t\t\t\t\t client_error_r,\n\t\t\t\t\t\t\t\t error_code_r);\n\n\t\tif (ret < 0)\n\t\t\treturn -1;\n\t\te_debug(user->event, \"imap-urlauth: created key for mailbox %s\",\n\t\t\tmailbox_get_vname(box));\n\t} else {\n\t\t/* read existing key */\n\t\tbuffer_create_from_data(&key_buf, mailbox_key_r,\n\t\t\t\t\tIMAP_URLAUTH_KEY_LEN);\n\t\tmailbox_key_hex = urlauth_key.value;\n\t\tif (strlen(mailbox_key_hex) != 2*IMAP_URLAUTH_KEY_LEN ||\n\t\t    hex_to_binary(mailbox_key_hex, &key_buf) < 0 ||\n\t\t    key_buf.used != IMAP_URLAUTH_KEY_LEN) {\n\t\t\ti_error(\"imap-urlauth: key found for mailbox %s is invalid\",\n\t\t\t\tmailbox_get_vname(box));\n\t\t\treturn -1;\n\t\t}\n\t}\n\treturn 1;\n}\n\nint imap_urlauth_backend_get_mailbox_key(struct mailbox *box, bool create,\n\t\t\t\t\t unsigned char mailbox_key_r[IMAP_URLAUTH_KEY_LEN],\n\t\t\t\t\t const char **client_error_r,\n\t\t\t\t\t enum mail_error *error_code_r)\n{\n\tint ret;\n\n\tret = imap_urlauth_backend_trans_get_mailbox_key(box, create,\n\t\t\t\t\t\t\t mailbox_key_r,\n\t\t\t\t\t\t\t client_error_r,\n\t\t\t\t\t\t\t error_code_r);\n\treturn ret;\n}\n\nint imap_urlauth_backend_reset_mailbox_key(struct mailbox *box)\n{\n\tstruct mailbox_transaction_context *t;\n\tint ret;\n\n\tt = mailbox_transaction_begin(box, MAILBOX_TRANSACTION_FLAG_EXTERNAL,\n\t\t\t\t      __func__);\n\tret = mailbox_attribute_unset(t, MAIL_ATTRIBUTE_TYPE_PRIVATE,\n\t\t\t\t      IMAP_URLAUTH_KEY);\n\tif (mailbox_transaction_commit(&t) < 0)\n\t\tret = -1;\n\treturn ret;\n}\n\nstatic int imap_urlauth_backend_mailbox_reset_key(struct mailbox *box)\n{\n\tconst char *errstr;\n\tenum mail_error error;\n\n\tif (mailbox_open(box) < 0) {\n\t\terrstr = mailbox_get_last_internal_error(box, &error);\n\t\tif (error == MAIL_ERROR_NOTFOUND || error == MAIL_ERROR_PERM)\n\t\t\treturn 0;\n\t\ti_error(\"urlauth key reset: Couldn't open mailbox %s: %s\",\n\t\t\tmailbox_get_vname(box), errstr);\n\t\treturn -1;\n\t}\n\treturn imap_urlauth_backend_reset_mailbox_key(box);\n}\n\nint imap_urlauth_backend_reset_all_keys(struct mail_user *user)\n{ \n\tconst char *const patterns[] = { \"*\", NULL };\n\tstruct mailbox_list_iterate_context *iter;\n\tconst struct mailbox_info *info;\n\tstruct mailbox *box;\n\tint ret = 0;\n\n\titer = mailbox_list_iter_init_namespaces(user->namespaces, patterns,\n\t\t\t\t\t\t MAIL_NAMESPACE_TYPE_MASK_ALL,\n\t\t\t\t\t\t MAILBOX_LIST_ITER_NO_AUTO_BOXES |\n\t\t\t\t\t\t MAILBOX_LIST_ITER_SKIP_ALIASES |\n\t\t\t\t\t\t MAILBOX_LIST_ITER_RETURN_NO_FLAGS);\n\twhile ((info = mailbox_list_iter_next(iter)) != NULL) {\n\t\tbox = mailbox_alloc(info->ns->list, info->vname, 0);\n\t\tmailbox_set_reason(box, \"URLAUTH reset all keys\");\n\t\tif (imap_urlauth_backend_mailbox_reset_key(box) < 0)\n\t\t\tret = -1;\n\t\tmailbox_free(&box);\n\t}\n\tif (mailbox_list_iter_deinit(&iter) < 0) {\n\t\ti_error(\"urlauth key reset: Couldn't iterate mailboxes: %s\",\n\t\t\tmailbox_list_get_last_internal_error(user->namespaces->list, NULL));\n\t\tret = -1;\n\t}\n\treturn ret;\n}\n"}, "2": {"id": 2, "path": "/home/runner/work/testcc/testcc/retdec/src/lib/macros.h", "content": "#ifndef MACROS_H\n#define MACROS_H\n\n/* several useful macros, mostly from glib.h */\n\n#ifndef NULL\n#  define NULL ((void *)0)\n#endif\n\n#ifndef FALSE\n#  define FALSE (!1)\n#endif\n\n#ifndef TRUE\n#  define TRUE (!FALSE)\n#endif\n\n#define N_ELEMENTS(arr) \\\n\t(sizeof(arr) / sizeof((arr)[0]))\n\n#define MEM_ALIGN(size) \\\n\t(((size) + MEM_ALIGN_SIZE-1) & ~((size_t) MEM_ALIGN_SIZE-1))\n\n#define PTR_OFFSET(ptr, offset) \\\n\t((void *) (((uintptr_t) (ptr)) + ((size_t) (offset))))\n#define CONST_PTR_OFFSET(ptr, offset) \\\n\t((const void *) (((uintptr_t) (ptr)) + ((size_t) (offset))))\n\n#define container_of(ptr, type, name) \\\n\t(type *)((uintptr_t)(ptr) - (uintptr_t)offsetof(type, name) + \\\n\t\t COMPILE_ERROR_IF_TYPES_NOT_COMPATIBLE(ptr, &((type *) 0)->name))\n\n/* Don't use simply MIN/MAX, as they're often defined elsewhere in include\n   files that are included after this file generating tons of warnings. */\n#define I_MIN(a, b)  (((a) < (b)) ? (a) : (b))\n#define I_MAX(a, b)  (((a) > (b)) ? (a) : (b))\n\n/* make it easier to cast from/to pointers. assumes that\n   sizeof(uintptr_t) == sizeof(void *) and they're both the largest datatypes\n   that are allowed to be used. so, long long isn't safe with these. */\n#define POINTER_CAST(i) \\\n\t((void *) (((uintptr_t)NULL) + (i)))\n#define POINTER_CAST_TO(p, type) \\\n\t((type) ((const char *) (p) - (const char *) NULL))\n\n/* Define VA_COPY() to do the right thing for copying va_list variables.\n   config.h may have already defined VA_COPY as va_copy or __va_copy. */\n#ifndef VA_COPY\n#  if defined (__GNUC__) && defined (__PPC__) && \\\n      (defined (_CALL_SYSV) || defined (_WIN32))\n#    define VA_COPY(ap1, ap2) (*(ap1) = *(ap2))\n#  elif defined (VA_COPY_AS_ARRAY)\n#    define VA_COPY(ap1, ap2) memmove ((ap1), (ap2), sizeof (va_list))\n#  else /* va_list is a pointer */\n#    define VA_COPY(ap1, ap2) ((ap1) = (ap2))\n#  endif /* va_list is a pointer */\n#endif\n\n/* Provide convenience macros for handling structure\n * fields through their offsets.\n */\n#define STRUCT_MEMBER_P(struct_p, struct_offset) \\\n\t((void *) ((char *) (struct_p) + (long) (struct_offset)))\n#define CONST_STRUCT_MEMBER_P(struct_p, struct_offset) \\\n\t((const void *) ((const char *) (struct_p) + (long) (struct_offset)))\n\n/* Provide simple macro statement wrappers (adapted from Perl):\n   STMT_START { statements; } STMT_END;\n   can be used as a single statement, as in\n   if (x) STMT_START { ... } STMT_END; else ...\n\n   For gcc we will wrap the statements within `({' and `})' braces.\n   For SunOS they will be wrapped within `if (1)' and `else (void) 0',\n   and otherwise within `do' and `while (0)'. */\n#if !(defined (STMT_START) && defined (STMT_END))\n#  if defined (__GNUC__) && !defined (__cplusplus) && \\\n\t!defined (__STRICT_ANSI__) && !defined (PEDANTIC)\n#    define STMT_START (void)(\n#    define STMT_END   )\n#  else\n#    if (defined (sun) || defined (__sun__))\n#      define STMT_START if (1)\n#      define STMT_END   else (void)0\n#    else\n#      define STMT_START do\n#      define STMT_END   while (0)\n#    endif\n#  endif\n#endif\n\n/* Provide macros to feature the GCC function attribute. */\n#if __GNUC__ > 2 || (__GNUC__ == 2 && __GNUC_MINOR__ > 4)\n#  define ATTRS_DEFINED\n#  define ATTR_FORMAT(format_idx, arg_idx) \\\n\t__attribute__((format (printf, format_idx, arg_idx)))\n#  define ATTR_FORMAT_ARG(arg_idx) \\\n\t__attribute__((format_arg (arg_idx)))\n#  define ATTR_SCANF(format_idx, arg_idx) \\\n\t__attribute__((format (scanf, format_idx, arg_idx)))\n#  define ATTR_STRFTIME(format_idx) \\\n\t__attribute__((format (strftime, format_idx, 0)))\n#  define ATTR_UNUSED __attribute__((unused))\n#  define ATTR_NORETURN __attribute__((noreturn))\n#  define ATTR_CONST __attribute__((const))\n#  define ATTR_PURE __attribute__((pure))\n#else\n#  define ATTR_FORMAT(format_idx, arg_idx)\n#  define ATTR_FORMAT_ARG(arg_idx)\n#  define ATTR_SCANF(format_idx, arg_idx)\n#  define ATTR_STRFTIME(format_idx)\n#  define ATTR_UNUSED\n#  define ATTR_NORETURN\n#  define ATTR_CONST\n#  define ATTR_PURE\n#endif\n#ifdef HAVE_ATTR_NULL\n#  define ATTR_NULL(...) __attribute__((null(__VA_ARGS__)))\n#else\n#  define ATTR_NULL(...)\n#endif\n#ifdef HAVE_ATTR_NOWARN_UNUSED_RESULT\n#  define ATTR_NOWARN_UNUSED_RESULT __attribute__((nowarn_unused_result))\n#else\n#  define ATTR_NOWARN_UNUSED_RESULT\n#endif\n#if __GNUC__ > 2\n#  define ATTR_MALLOC __attribute__((malloc))\n#else\n#  define ATTR_MALLOC\n#endif\n#if __GNUC__ > 3\n/* GCC 4.0 and later */\n#  define ATTR_WARN_UNUSED_RESULT __attribute__((warn_unused_result))\n#  define ATTR_SENTINEL __attribute__((sentinel))\n#else\n#  define ATTR_WARN_UNUSED_RESULT\n#  define ATTR_SENTINEL\n#endif\n#if __GNUC__ > 4 || (__GNUC__ == 4 && __GNUC_MINOR__ >= 3)\n/* GCC 4.3 and later */\n#  define ATTR_HOT __attribute__((hot))\n#  define ATTR_COLD __attribute__((cold))\n#else\n#  define ATTR_HOT\n#  define ATTR_COLD\n#endif\n#if __GNUC__ > 4 || (__GNUC__ == 4 && __GNUC_MINOR__ >= 9)\n/* GCC 4.9 and later */\n#  define ATTR_RETURNS_NONNULL __attribute__((returns_nonnull))\n#else\n#  define ATTR_RETURNS_NONNULL\n#endif\n#ifdef HAVE_ATTR_DEPRECATED\n#  define ATTR_DEPRECATED(str) __attribute__((deprecated(str)))\n#else\n#  define ATTR_DEPRECATED(str)\n#endif\n\n/* Macros to provide type safety for callback functions' context parameters */\n#ifdef HAVE_TYPE_CHECKS\n#  define CALLBACK_TYPECHECK(callback, type) \\\n\t(COMPILE_ERROR_IF_TRUE(!__builtin_types_compatible_p( \\\n\t\ttypeof(&callback), type)) ? 1 : 0)\n#else\n#  define CALLBACK_TYPECHECK(callback, type) 0\n#endif\n\n#if (__GNUC__ > 3 || (__GNUC__ == 3 && __GNUC_MINOR__ > 0)) && !defined(__cplusplus)\n#  define COMPILE_ERROR_IF_TRUE(condition) \\\n\t(sizeof(char[1 - 2 * ((condition) ? 1 : 0)]) - 1)\n#else\n#  define COMPILE_ERROR_IF_TRUE(condition) 0\n#endif\n\n#ifdef HAVE_TYPE_CHECKS\n#  define COMPILE_ERROR_IF_TYPES_NOT_COMPATIBLE(_a, _b) \\\n\tCOMPILE_ERROR_IF_TRUE( \\\n\t\t!__builtin_types_compatible_p(typeof(_a), typeof(_b)))\n#define COMPILE_ERROR_IF_TYPES2_NOT_COMPATIBLE(_a1, _a2, _b) \\\n\tCOMPILE_ERROR_IF_TRUE( \\\n\t\t!__builtin_types_compatible_p(typeof(_a1), typeof(_b)) && \\\n\t\t!__builtin_types_compatible_p(typeof(_a2), typeof(_b)))\n#else\n#  define COMPILE_ERROR_IF_TYPES_NOT_COMPATIBLE(_a, _b) 0\n#  define COMPILE_ERROR_IF_TYPES2_NOT_COMPATIBLE(_a1, _a2, _b) 0\n#endif\n\n#if __GNUC__ > 2\n#  define unlikely(expr) (__builtin_expect((expr) ? 1 : 0, 0) != 0)\n#  define likely(expr) (__builtin_expect((expr) ? 1 : 0, 1) != 0)\n#else\n#  define unlikely(expr) expr\n#  define likely(expr) expr\n#endif\n\n#if defined(__clang__) && ((__clang_major__ > 4) || (__clang_major__ == 3 && __clang_minor__ >= 9))\n#  define ATTR_UNSIGNED_WRAPS __attribute__((no_sanitize(\"integer\")))\n#else\n#  define ATTR_UNSIGNED_WRAPS\n#endif\n\n/* Provide macros for error handling. */\n#ifdef DISABLE_ASSERTS\n#  define i_assert(expr)\n#else\n\n#define i_assert(expr)\t\t\tSTMT_START{\t\t\t\\\n     if (unlikely(!(expr)))\t\t\t\t\t\t\\\n       i_panic(\"file %s: line %d (%s): assertion failed: (%s)\",\t\t\\\n\t\t__FILE__,\t\t\t\t\t\t\\\n\t\t__LINE__,\t\t\t\t\t\t\\\n\t\t__func__,\t\t\t\t\t\\\n\t\t#expr);\t\t\t}STMT_END\n\n#endif\n\n#ifndef STATIC_CHECKER\n#  define i_unreached() \\\n\ti_panic(\"file %s: line %d: unreached\", __FILE__, __LINE__)\n#else\n#  define i_unreached() __builtin_unreachable()\n#endif\n\n/* Convenience macros to test the versions of dovecot. */\n#if defined DOVECOT_VERSION_MAJOR && defined DOVECOT_VERSION_MINOR\n#  define DOVECOT_PREREQ(maj, min) \\\n          ((DOVECOT_VERSION_MAJOR << 16) + DOVECOT_VERSION_MINOR >= ((maj) << 16) + (min))\n#else\n#  define DOVECOT_PREREQ(maj, min) 0\n#endif\n\n#ifdef __cplusplus\n#  undef STATIC_ARRAY\n#  define STATIC_ARRAY\n#endif\n\n/* Convenience wrappers for initializing a struct with zeros, although it can\n   be used for replacing other memset()s also.\n\n   // NOTE: This is the correct way to zero the whole array\n   char arr[5]; i_zero(&arr);\n   // This will give compiler error (or zero only the first element):\n   char arr[5]; i_zero(arr);\n*/\n#define i_zero(p) \\\n\tmemset(p, 0 + COMPILE_ERROR_IF_TRUE(sizeof(p) > sizeof(void *)), sizeof(*(p)))\n#define i_zero_safe(p) \\\n\tsafe_memset(p, 0 + COMPILE_ERROR_IF_TRUE(sizeof(p) > sizeof(void *)), sizeof(*(p)))\n\n#define ST_CHANGED(st_a, st_b) \\\n\t((st_a).st_mtime != (st_b).st_mtime || \\\n\t ST_MTIME_NSEC(st_a) != ST_MTIME_NSEC(st_b) || \\\n\t (st_a).st_size != (st_b).st_size || \\\n\t (st_a).st_ino != (st_b).st_ino)\n\n#endif\n"}, "3": {"id": 3, "path": "/home/runner/work/testcc/testcc/retdec/src/lib-storage/mail-namespace.h", "content": "#ifndef MAIL_NAMESPACE_H\n#define MAIL_NAMESPACE_H\n\n#include \"mail-user.h\"\n\nstruct mail_storage_callbacks;\n\nenum mail_namespace_type {\n\tMAIL_NAMESPACE_TYPE_PRIVATE\t= 0x01,\n\tMAIL_NAMESPACE_TYPE_SHARED\t= 0x02,\n\tMAIL_NAMESPACE_TYPE_PUBLIC\t= 0x04\n#define MAIL_NAMESPACE_TYPE_MASK_ALL \\\n\t(MAIL_NAMESPACE_TYPE_PRIVATE | MAIL_NAMESPACE_TYPE_SHARED | \\\n\t MAIL_NAMESPACE_TYPE_PUBLIC)\n};\n\nenum namespace_flags {\n\t/* Namespace contains the user's INBOX mailbox. Normally only a single\n\t   namespace has this flag set, but when using alias_for for the INBOX\n\t   namespace the flag gets copied to the alias namespace as well */\n\tNAMESPACE_FLAG_INBOX_USER\t= 0x01,\n\t/* Namespace contains someone's INBOX. This is set for both user's\n\t   INBOX namespace and also for any other users' shared namespaces. */\n\tNAMESPACE_FLAG_INBOX_ANY\t= 0x02,\n\t/* Namespace is visible only by explicitly using its full prefix */\n\tNAMESPACE_FLAG_HIDDEN\t\t= 0x04,\n\t/* Namespace prefix is visible with LIST */\n\tNAMESPACE_FLAG_LIST_PREFIX\t= 0x08,\n\t/* Namespace prefix isn't visible with LIST, but child mailboxes are */\n\tNAMESPACE_FLAG_LIST_CHILDREN\t= 0x10,\n\t/* Namespace uses its own subscriptions. */\n\tNAMESPACE_FLAG_SUBSCRIPTIONS\t= 0x20,\n\n\t/* Namespace was created automatically (for shared mailboxes) */\n\tNAMESPACE_FLAG_AUTOCREATED\t= 0x1000,\n\t/* Namespace has at least some usable mailboxes. Autocreated namespaces\n\t   that don't have usable mailboxes may be removed automatically. */\n\tNAMESPACE_FLAG_USABLE\t\t= 0x2000,\n\t/* Automatically created namespace for a user that doesn't exist. */\n\tNAMESPACE_FLAG_UNUSABLE\t\t= 0x4000,\n\t/* Don't track quota for this namespace */\n\tNAMESPACE_FLAG_NOQUOTA\t\t= 0x8000,\n\t/* Don't enforce ACLs for this namespace */\n\tNAMESPACE_FLAG_NOACL\t\t= 0x10000\n};\n\nstruct mail_namespace {\n\t/* Namespaces are sorted by their prefix length, \"\" comes first */\n\tstruct mail_namespace *next;\n\tint refcount;\n\n        enum mail_namespace_type type;\n\tenum namespace_flags flags;\n\n\tchar *prefix;\n\tsize_t prefix_len;\n\n\t/* If non-NULL, this points to a namespace with identical mail location\n\t   and it should be considered as the primary way to access the\n\t   mailboxes. This allows for example FTS plugin to avoid duplicating\n\t   indexes for same mailboxes when they're accessed via different\n\t   namespaces. */\n\tstruct mail_namespace *alias_for;\n\t/* alias_for->alias_chain_next starts each chain. The chain goes\n\t   through all namespaces that have the same alias_for. */\n\tstruct mail_namespace *alias_chain_next;\n\n\tstruct mail_user *user, *owner;\n\tstruct mailbox_list *list;\n\tstruct mail_storage *storage; /* default storage */\n\tARRAY(struct mail_storage *) all_storages;\n\n\t/* This may point to user->set, but it may also point to\n\t   namespace-specific settings. When accessing namespace-specific\n\t   settings it should be done through here instead of through the\n\t   mail_user. */\n\tstruct mail_user_settings *user_set;\n\n\tconst struct mail_namespace_settings *set, *unexpanded_set;\n\tconst struct mail_storage_settings *mail_set;\n\n\tbool special_use_mailboxes:1;\n\tbool destroyed:1;\n};\n\n/* Returns TRUE when namespace can be removed without consequence. */\nstatic inline bool mail_namespace_is_removable(const struct mail_namespace *ns)\n{\n\treturn ((ns->flags & NAMESPACE_FLAG_USABLE) == 0 &&\n\t\t(ns->flags & NAMESPACE_FLAG_AUTOCREATED) != 0);\n}\n\n/* Allocate a new namespace, and fill it based on the passed in settings.\n   This is the most low-level namespace creation function. The storage isn't\n   initialized for the namespace.\n\n   user_all_settings normally points to user->set. If you want to override\n   settings for the created namespace, you can duplicate the user's settings\n   and provide a pointer to it here. Note that the pointer must contain\n   ALL the settings, including the dynamic driver-specific settings, so it\n   needs to created via settings-parser API. */\nint mail_namespace_alloc(struct mail_user *user,\n\t\t\t void *user_all_settings,\n\t\t\t struct mail_namespace_settings *ns_set,\n\t\t\t struct mail_namespace_settings *unexpanded_set,\n\t\t\t struct mail_namespace **ns_r,\n\t\t\t const char **error_r);\n\n/* Add and initialize namespaces to user based on namespace settings. */\nint mail_namespaces_init(struct mail_user *user, const char **error_r);\n/* Add and initialize INBOX namespace to user based on the given location. */\nint mail_namespaces_init_location(struct mail_user *user, const char *location,\n\t\t\t\t  const char **error_r) ATTR_NULL(2);\n/* Add an empty namespace to user. */\nstruct mail_namespace *mail_namespaces_init_empty(struct mail_user *user);\n/* Deinitialize all namespaces. mail_user_deinit() calls this automatically\n   for user's namespaces. */\nvoid mail_namespaces_deinit(struct mail_namespace **namespaces);\n\n/* Allocate a new namespace and initialize it. This is called automatically by\n   mail_namespaces_init(). */\nint mail_namespaces_init_add(struct mail_user *user,\n\t\t\t     struct mail_namespace_settings *ns_set,\n\t\t\t     struct mail_namespace_settings *unexpanded_ns_set,\n\t\t\t     struct mail_namespace **ns_p, const char **error_r);\nint mail_namespaces_init_finish(struct mail_namespace *namespaces,\n\t\t\t\tconst char **error_r);\n\nvoid mail_namespace_ref(struct mail_namespace *ns);\nvoid mail_namespace_unref(struct mail_namespace **ns);\n\n/* Set storage callback functions to use in all namespaces. */\nvoid mail_namespaces_set_storage_callbacks(struct mail_namespace *namespaces,\n\t\t\t\t\t   struct mail_storage_callbacks *callbacks,\n\t\t\t\t\t   void *context);\n\n/* Add a new storage to namespace. */\nvoid mail_namespace_add_storage(struct mail_namespace *ns,\n\t\t\t\tstruct mail_storage *storage);\n/* Destroy a single namespace and remove it from user's namespaces list. */\nvoid mail_namespace_destroy(struct mail_namespace *ns);\n\n/* Returns the default storage to use for newly created mailboxes. */\nstruct mail_storage *\nmail_namespace_get_default_storage(struct mail_namespace *ns);\n\n/* Return namespace's hierarchy separator. */\nchar mail_namespace_get_sep(struct mail_namespace *ns);\n/* Returns the hierarchy separator for mailboxes that are listed at root. */\nchar mail_namespaces_get_root_sep(struct mail_namespace *namespaces)\n\tATTR_PURE;\n\n/* Returns namespace based on the mailbox name's prefix. Note that there is\n   always a prefix=\"\" namespace, so for this function NULL is never returned. */\nstruct mail_namespace *\nmail_namespace_find(struct mail_namespace *namespaces, const char *mailbox);\n/* Same as mail_namespace_find(), but if the namespace has alias_for set,\n   return that namespace instead and change mailbox name to be a valid\n   inside it. */\nstruct mail_namespace *\nmail_namespace_find_unalias(struct mail_namespace *namespaces,\n\t\t\t    const char **mailbox);\n\n/* Like mail_namespace_find(), but ignore hidden namespaces. */\nstruct mail_namespace *\nmail_namespace_find_visible(struct mail_namespace *namespaces,\n\t\t\t    const char *mailbox);\n/* Like mail_namespace_find(), but find only from namespaces with\n   subscriptions=yes. */\nstruct mail_namespace *\nmail_namespace_find_subscribable(struct mail_namespace *namespaces,\n\t\t\t\t const char *mailbox);\n/* Like mail_namespace_find(), but find only from namespaces with\n   subscriptions=no. */\nstruct mail_namespace *\nmail_namespace_find_unsubscribable(struct mail_namespace *namespaces,\n\t\t\t\t   const char *mailbox);\n/* Returns the INBOX namespace. It always exists, so NULL is never returned. */\nstruct mail_namespace *\nmail_namespace_find_inbox(struct mail_namespace *namespaces);\n/* Find a namespace with given prefix. */\nstruct mail_namespace *\nmail_namespace_find_prefix(struct mail_namespace *namespaces,\n\t\t\t   const char *prefix);\n/* Like _find_prefix(), but ignore trailing separator */\nstruct mail_namespace *\nmail_namespace_find_prefix_nosep(struct mail_namespace *namespaces,\n\t\t\t\t const char *prefix);\n\n/* Called internally by mailbox_list_create(). */\nvoid mail_namespace_finish_list_init(struct mail_namespace *ns,\n\t\t\t\t     struct mailbox_list *list);\n\n/* Returns TRUE if this is the root of a type=shared namespace that is actually\n   used for accessing shared users' mailboxes (as opposed to marking a\n   type=public namespace \"wrong\"). */\nbool mail_namespace_is_shared_user_root(struct mail_namespace *ns);\n\n/* Returns TRUE if namespace includes INBOX that should be \\Noinferiors.\n   This happens when the namespace has a prefix, which is not empty and not\n   \"INBOX\". This happens, because if storage_name=INBOX/foo it would be\n   converted to vname=prefix/INBOX/foo. */\nstatic inline bool\nmail_namespace_is_inbox_noinferiors(struct mail_namespace *ns)\n{\n\treturn (ns->flags & NAMESPACE_FLAG_INBOX_USER) != 0 &&\n\t\tns->prefix_len > 0 &&\n\t\tstrncmp(ns->prefix, \"INBOX\", ns->prefix_len-1) != 0;\n}\n\n#endif\n"}, "4": {"id": 4, "path": "/home/runner/work/testcc/testcc/retdec/src/lib-imap-urlauth/imap-urlauth-backend.h", "content": "#ifndef IMAP_URLAUTH_BACKEND_H\n#define IMAP_URLAUTH_BACKEND_H\n\n#define IMAP_URLAUTH_KEY_LEN 64\n\nstruct imap_urlauth_backend;\n\nint imap_urlauth_backend_get_mailbox_key(struct mailbox *box, bool create,\n\t\t\t\t\t unsigned char mailbox_key_r[IMAP_URLAUTH_KEY_LEN],\n\t\t\t\t\t const char **client_error_r,\n\t\t\t\t\t enum mail_error *error_code_r);\nint imap_urlauth_backend_reset_mailbox_key(struct mailbox *box);\nint imap_urlauth_backend_reset_all_keys(struct mail_user *user);\n\n#endif\n\n"}, "5": {"id": 5, "path": "/home/runner/work/testcc/testcc/retdec/src/lib-imap-urlauth/imap-urlauth-private.h", "content": "#ifndef IMAP_URLAUTH_PRIVATE_H\n#define IMAP_URLAUTH_PRIVATE_H\n\n#include \"imap-urlauth.h\"\n\nstruct imap_urlauth_context {\n\tstruct mail_user *user;\n\tstruct imap_urlauth_connection *conn;\n\n\tchar *url_host;\n\tin_port_t url_port;\n\n\tchar *access_user;\n\tchar *access_service;\n\tconst char **access_applications;\n\n\tbool access_anonymous:1;\n};\n\n#endif\n"}, "6": {"id": 6, "path": "/home/runner/work/testcc/testcc/retdec/src/lib-imap-urlauth/imap-urlauth.h", "content": "#ifndef IMAP_URLAUTH_H\n#define IMAP_URLAUTH_H\n\n#include \"net.h\"\n\n#define IMAP_URLAUTH_SOCKET_NAME \"imap-urlauth\"\n\nstruct imap_url;\nstruct imap_msgpart_url;\nstruct imap_urlauth_context;\n\nstruct imap_urlauth_config {\n\tconst char *url_host;\n\tin_port_t url_port;\n\n\tconst char *socket_path;\n\tconst char *session_id;\n\n\t/* the user who is requesting access to URLAUTHs */\n\tconst char *access_user;\n\t/* ... is using this service (i.e. imap or submission) */\n\tconst char *access_service;\n\t/* ... represents these applications */\n\tconst char *const *access_applications;\n\t/* ... is anonymous? */\n\tbool access_anonymous;\n};\n\nstruct imap_urlauth_context *\nimap_urlauth_init(struct mail_user *user,\n\t\t  const struct imap_urlauth_config *config);\nvoid imap_urlauth_deinit(struct imap_urlauth_context **_uctx);\n\nint imap_urlauth_generate(struct imap_urlauth_context *uctx,\n\t\t\t  const char *mechanism, const char *rumpurl,\n\t\t\t  const char **urlauth_r, const char **client_error_r);\n\nbool imap_urlauth_check(struct imap_urlauth_context *uctx,\n\t\t\tstruct imap_url *url, bool ignore_unknown_access,\n\t\t\tconst char **error_r);\n\nint imap_urlauth_fetch_parsed(struct imap_urlauth_context *uctx,\n\t\t\t      struct imap_url *url,\n\t\t\t      struct imap_msgpart_url **mpurl_r,\n\t\t\t      enum mail_error *error_code_r,\n\t\t\t      const char **error_r);\nint imap_urlauth_fetch(struct imap_urlauth_context *uctx,\n\t\t       const char *urlauth, struct imap_msgpart_url **mpurl_r,\n\t\t       enum mail_error *error_code_r, const char **error_r);\n\nint imap_urlauth_reset_mailbox_key(struct imap_urlauth_context *uctx,\n\t\t\t\t   struct mailbox *box);\nint imap_urlauth_reset_all_keys(struct imap_urlauth_context *uctx);\n\n#endif\n"}, "7": {"id": 7, "path": "/home/runner/work/testcc/testcc/retdec/src/lib-index/mail-index.h", "content": "#ifndef MAIL_INDEX_H\n#define MAIL_INDEX_H\n\n#include \"file-lock.h\"\n#include \"fsync-mode.h\"\n#include \"guid.h\"\n#include \"mail-types.h\"\n#include \"seq-range-array.h\"\n\n#define MAIL_INDEX_MAJOR_VERSION 7\n#define MAIL_INDEX_MINOR_VERSION 3\n\n#define MAIL_INDEX_HEADER_MIN_SIZE 120\n\n/* Log a warning when transaction log has been locked for this many seconds.\n   This lock is held also between mail_index_sync_begin()..commit(). */\n#define MAIL_TRANSACTION_LOG_LOCK_WARN_SECS 30\n\nenum mail_index_open_flags {\n\t/* Create index if it doesn't exist */\n\tMAIL_INDEX_OPEN_FLAG_CREATE\t\t= 0x01,\n\t/* Don't try to mmap() index files */\n\tMAIL_INDEX_OPEN_FLAG_MMAP_DISABLE\t= 0x04,\n\t/* Rely on O_EXCL when creating dotlocks */\n\tMAIL_INDEX_OPEN_FLAG_DOTLOCK_USE_EXCL\t= 0x10,\n\t/* Flush NFS attr/data/write cache when necessary */\n\tMAIL_INDEX_OPEN_FLAG_NFS_FLUSH\t\t= 0x40,\n\t/* Open the index read-only */\n\tMAIL_INDEX_OPEN_FLAG_READONLY\t\t= 0x80,\n\t/* Create backups of dovecot.index files once in a while */\n\tMAIL_INDEX_OPEN_FLAG_KEEP_BACKUPS\t= 0x100,\n\t/* If we run out of disk space, fail modifications instead of moving\n\t   indexes to memory. */\n\tMAIL_INDEX_OPEN_FLAG_NEVER_IN_MEMORY\t= 0x200,\n\t/* We're only going to save new messages to the index.\n\t   Avoid unnecessary reads. */\n\tMAIL_INDEX_OPEN_FLAG_SAVEONLY\t\t= 0x400,\n\t/* Enable debug logging */\n\tMAIL_INDEX_OPEN_FLAG_DEBUG\t\t= 0x800,\n\t/* MAIL_INDEX_MAIL_FLAG_DIRTY can be used as a backend-specific flag.\n\t   All special handling of the flag is disabled by this. */\n\tMAIL_INDEX_OPEN_FLAG_NO_DIRTY\t\t= 0x1000,\n};\n\nenum mail_index_header_compat_flags {\n\tMAIL_INDEX_COMPAT_LITTLE_ENDIAN\t\t= 0x01\n};\n\nenum mail_index_header_flag {\n\t/* Index file is corrupted, reopen or recreate it. */\n\tMAIL_INDEX_HDR_FLAG_CORRUPTED\t\t= 0x0001,\n\tMAIL_INDEX_HDR_FLAG_HAVE_DIRTY\t\t= 0x0002,\n\t/* Index has been fsck'd. The caller may want to resync the index\n\t   to make sure it's valid and drop this flag. */\n\tMAIL_INDEX_HDR_FLAG_FSCKD\t\t= 0x0004,\n};\n\nenum mail_index_mail_flags {\n\t/* For private use by backend. Replacing flags doesn't change this. */\n\tMAIL_INDEX_MAIL_FLAG_BACKEND\t\t= 0x40,\n\t/* Message flags haven't been written to backend. If\n\t   MAIL_INDEX_OPEN_FLAG_NO_DIRTY is set, this is treated as a\n\t   backend-specific flag with no special internal handling. */\n\tMAIL_INDEX_MAIL_FLAG_DIRTY\t\t= 0x80,\n\t/* Force updating this message's modseq via a flag update record */\n\tMAIL_INDEX_MAIL_FLAG_UPDATE_MODSEQ\t= 0x100\n};\n\n#define MAIL_INDEX_FLAGS_MASK \\\n\t(MAIL_ANSWERED | MAIL_FLAGGED | MAIL_DELETED | MAIL_SEEN | MAIL_DRAFT)\n\nstruct mail_index_header {\n\t/* major version is increased only when you can't have backwards\n\t   compatibility. minor version is increased when header size is\n\t   increased to contain new non-critical fields. */\n\tuint8_t major_version;\n\tuint8_t minor_version;\n\n\tuint16_t base_header_size;\n\tuint32_t header_size; /* base + extended header size */\n\tuint32_t record_size;\n\n\tuint8_t compat_flags; /* enum mail_index_header_compat_flags */\n\tuint8_t unused[3];\n\n\tuint32_t indexid;\n\tuint32_t flags;\n\n\tuint32_t uid_validity;\n\tuint32_t next_uid;\n\n\tuint32_t messages_count;\n\tuint32_t unused_old_recent_messages_count;\n\tuint32_t seen_messages_count;\n\tuint32_t deleted_messages_count;\n\n\tuint32_t first_recent_uid;\n\t/* these UIDs may not exist and may not even be unseen/deleted */\n\tuint32_t first_unseen_uid_lowwater;\n\tuint32_t first_deleted_uid_lowwater;\n\n\tuint32_t log_file_seq;\n\t/* non-external records between tail..head haven't been committed to\n\t   mailbox yet. */\n\tuint32_t log_file_tail_offset;\n\tuint32_t log_file_head_offset;\n\n\tuint32_t unused_old_sync_size_part1;\n\t/* Timestamp of when .log was rotated into .log.2. This can be used to\n\t   optimize checking when it's time to unlink it without stat()ing it.\n\t   0 = unknown, -1 = .log.2 doesn't exists. */\n\tuint32_t log2_rotate_time;\n\tuint32_t last_temp_file_scan;\n\n\t/* daily first UIDs that have been added to index. */\n\tuint32_t day_stamp;\n\tuint32_t day_first_uid[8];\n};\n\n#define MAIL_INDEX_RECORD_MIN_SIZE (sizeof(uint32_t) + sizeof(uint8_t))\nstruct mail_index_record {\n\tuint32_t uid;\n\tuint8_t flags; /* enum mail_flags | enum mail_index_mail_flags */\n};\n\nstruct mail_keywords {\n\tstruct mail_index *index;\n\tunsigned int count;\n\tint refcount;\n\n        /* variable sized list of keyword indexes */\n\tunsigned int idx[FLEXIBLE_ARRAY_MEMBER];\n};\n\nenum mail_index_transaction_flags {\n\t/* If transaction is marked as hidden, the changes are marked with\n\t   hidden=TRUE when the view is synchronized. */\n\tMAIL_INDEX_TRANSACTION_FLAG_HIDE\t\t= 0x01,\n\t/* External transactions describe changes to mailbox that have already\n\t   happened. */\n\tMAIL_INDEX_TRANSACTION_FLAG_EXTERNAL\t\t= 0x02,\n\t/* Don't add flag updates unless they actually change something.\n\t   This is reliable only when syncing, otherwise someone else might\n\t   have already committed a transaction that had changed the flags. */\n\tMAIL_INDEX_TRANSACTION_FLAG_AVOID_FLAG_UPDATES\t= 0x04,\n\t/* fsync() this transaction (unless fsyncs are disabled) */\n\tMAIL_INDEX_TRANSACTION_FLAG_FSYNC\t\t= 0x08,\n\t/* Sync transaction describes changes to mailbox that already happened\n\t   to another mailbox with whom we're syncing with (dsync) */\n\tMAIL_INDEX_TRANSACTION_FLAG_SYNC\t\t= 0x10\n};\n\nenum mail_index_sync_type {\n\tMAIL_INDEX_SYNC_TYPE_EXPUNGE\t\t= 0x02,\n\tMAIL_INDEX_SYNC_TYPE_FLAGS\t\t= 0x04,\n\tMAIL_INDEX_SYNC_TYPE_KEYWORD_ADD\t= 0x08,\n\tMAIL_INDEX_SYNC_TYPE_KEYWORD_REMOVE\t= 0x10\n};\n\nenum mail_index_fsync_mask {\n\tMAIL_INDEX_FSYNC_MASK_APPENDS\t= 0x01,\n\tMAIL_INDEX_FSYNC_MASK_EXPUNGES\t= 0x02,\n\tMAIL_INDEX_FSYNC_MASK_FLAGS\t= 0x04,\n\tMAIL_INDEX_FSYNC_MASK_KEYWORDS\t= 0x08\n};\n\nenum mail_index_sync_flags {\n\t/* Resync all dirty messages' flags. */\n\tMAIL_INDEX_SYNC_FLAG_FLUSH_DIRTY\t= 0x01,\n\t/* Drop recent flags from all messages */\n\tMAIL_INDEX_SYNC_FLAG_DROP_RECENT\t= 0x02,\n\t/* Create the transaction with AVOID_FLAG_UPDATES flag */\n\tMAIL_INDEX_SYNC_FLAG_AVOID_FLAG_UPDATES\t= 0x04,\n\t/* If there are no new transactions and nothing else to do,\n\t   return 0 in mail_index_sync_begin() */\n\tMAIL_INDEX_SYNC_FLAG_REQUIRE_CHANGES\t= 0x08,\n\t/* Create the transaction with FSYNC flag */\n\tMAIL_INDEX_SYNC_FLAG_FSYNC\t\t= 0x10,\n\t/* If we see \"delete index\" request transaction, finish it.\n\t   This flag also allows committing more changes to a deleted index. */\n\tMAIL_INDEX_SYNC_FLAG_DELETING_INDEX\t= 0x20,\n\t/* Same as MAIL_INDEX_SYNC_FLAG_DELETING_INDEX, but finish index\n\t   deletion only once and fail the rest (= avoid race conditions when\n\t   multiple processes try to mark the index deleted) */\n\tMAIL_INDEX_SYNC_FLAG_TRY_DELETING_INDEX\t= 0x40,\n\t/* Update header's tail_offset to head_offset, even if it's the only\n\t   thing we do and there's no strict need for it. */\n\tMAIL_INDEX_SYNC_FLAG_UPDATE_TAIL_OFFSET\t= 0x80\n};\n\nenum mail_index_view_sync_flags {\n\t/* Don't sync expunges */\n\tMAIL_INDEX_VIEW_SYNC_FLAG_NOEXPUNGES\t\t= 0x01,\n\t/* Make sure view isn't inconsistent after syncing. This also means\n\t   that you don't care about view_sync_next()'s output, so it won't\n\t   return anything. */\n\tMAIL_INDEX_VIEW_SYNC_FLAG_FIX_INCONSISTENT\t= 0x02\n};\n\nstruct mail_index_sync_rec {\n\tuint32_t uid1, uid2;\n\tenum mail_index_sync_type type;\n\n\t/* MAIL_INDEX_SYNC_TYPE_FLAGS: */\n\tuint8_t add_flags;\n\tuint8_t remove_flags;\n\n\t/* MAIL_INDEX_SYNC_TYPE_KEYWORD_ADD, .._REMOVE: */\n\tunsigned int keyword_idx;\n\n\t/* MAIL_INDEX_SYNC_TYPE_EXPUNGE: */\n\tguid_128_t guid_128;\n};\n\nenum mail_index_view_sync_type {\n\t/* Flags or keywords changed */\n\tMAIL_INDEX_VIEW_SYNC_TYPE_FLAGS\t\t= 0x01,\n\tMAIL_INDEX_VIEW_SYNC_TYPE_MODSEQ\t= 0x02\n};\n\nstruct mail_index_view_sync_rec {\n\tuint32_t uid1, uid2;\n\tenum mail_index_view_sync_type type;\n\n\t/* TRUE if this was a hidden transaction. */\n\tbool hidden:1;\n};\n\nenum mail_index_transaction_change {\n\tMAIL_INDEX_TRANSACTION_CHANGE_APPEND\t= BIT(0),\n\tMAIL_INDEX_TRANSACTION_CHANGE_EXPUNGE\t= BIT(1),\n\tMAIL_INDEX_TRANSACTION_CHANGE_FLAGS\t= BIT(2),\n\tMAIL_INDEX_TRANSACTION_CHANGE_KEYWORDS\t= BIT(3),\n\tMAIL_INDEX_TRANSACTION_CHANGE_MODSEQ\t= BIT(4),\n\tMAIL_INDEX_TRANSACTION_CHANGE_ATTRIBUTE\t= BIT(5),\n\n\tMAIL_INDEX_TRANSACTION_CHANGE_OTHERS\t= BIT(30),\n};\n\nstruct mail_index_transaction_commit_result {\n\t/* seq/offset points to end of transaction */\n\tuint32_t log_file_seq;\n\tuoff_t log_file_offset;\n\t/* number of bytes in the written transaction.\n\t   all of it was written to the same file. */\n\tuoff_t commit_size;\n\n\tenum mail_index_transaction_change changes_mask;\n\tunsigned int ignored_modseq_changes;\n};\n\nstruct mail_index_base_optimization_settings {\n\t/* Rewrite the index when the number of bytes that needs to be read\n\t   from the .log on refresh is between these min/max values. */\n\tuoff_t rewrite_min_log_bytes;\n\tuoff_t rewrite_max_log_bytes;\n};\n\nstruct mail_index_log_optimization_settings {\n\t/* Rotate transaction log after it's a) min_size or larger and it was\n\t   created at least min_age_secs or b) larger than max_size. */\n\tuoff_t min_size;\n\tuoff_t max_size;\n\tunsigned int min_age_secs;\n\n\t/* Delete .log.2 when it's older than log2_stale_secs. Don't be too\n\t   eager, because older files are useful for QRESYNC and dsync. */\n\tunsigned int log2_max_age_secs;\n};\n\nstruct mail_index_cache_optimization_settings {\n\t/* Drop fields that haven't been accessed for n seconds */\n\tunsigned int unaccessed_field_drop_secs;\n\t/* If cache record becomes larger than this, don't add it. */\n\tunsigned int record_max_size;\n\n\t/* Maximum size for the cache file. Internally the limit is 1 GB. */\n\tuoff_t max_size;\n\t/* Never purge the file if it's smaller than this */\n\tuoff_t purge_min_size;\n\t/* Purge the file when n% of records are deleted */\n\tunsigned int purge_delete_percentage;\n\t/* Purge the file when n% of rows contain continued rows.\n\t   For example 200% means that the record has 2 continued rows, i.e.\n\t   it exists in 3 separate segments in the cache file. */\n\tunsigned int purge_continued_percentage;\n\t/* Purge the file when we need to follow more than n next_offsets to\n\t   find the latest cache header. */\n\tunsigned int purge_header_continue_count;\n};\n\nstruct mail_index_optimization_settings {\n\tstruct mail_index_base_optimization_settings index;\n\tstruct mail_index_log_optimization_settings log;\n\tstruct mail_index_cache_optimization_settings cache;\n};\n\nstruct mail_index;\nstruct mail_index_map;\nstruct mail_index_view;\nstruct mail_index_transaction;\nstruct mail_index_sync_ctx;\nstruct mail_index_view_sync_ctx;\n\nstruct mail_index *mail_index_alloc(struct event *parent_event,\n\t\t\t\t    const char *dir, const char *prefix);\nvoid mail_index_free(struct mail_index **index);\n\n/* Change .cache file's directory. */\nvoid mail_index_set_cache_dir(struct mail_index *index, const char *dir);\n/* Specify how often to do fsyncs. If mode is FSYNC_MODE_OPTIMIZED, the mask\n   can be used to specify which transaction types to fsync. */\nvoid mail_index_set_fsync_mode(struct mail_index *index, enum fsync_mode mode,\n\t\t\t       enum mail_index_fsync_mask mask);\n/* Try to set the index's permissions based on its index directory. Returns\n   TRUE if successful (directory existed), FALSE if mail_index_set_permissions()\n   should be called. */\nbool mail_index_use_existing_permissions(struct mail_index *index);\nvoid mail_index_set_permissions(struct mail_index *index,\n\t\t\t\tmode_t mode, gid_t gid, const char *gid_origin);\n/* Set locking method and maximum time to wait for a lock\n   (UINT_MAX = default). */\nvoid mail_index_set_lock_method(struct mail_index *index,\n\t\t\t\tenum file_lock_method lock_method,\n\t\t\t\tunsigned int max_timeout_secs);\n/* Override the default optimization-related settings. Anything set to 0 will\n   use the default. */\nvoid mail_index_set_optimization_settings(struct mail_index *index,\n\tconst struct mail_index_optimization_settings *set);\n/* When creating a new index file or reseting an existing one, add the given\n   extension header data immediately to it. */\nvoid mail_index_set_ext_init_data(struct mail_index *index, uint32_t ext_id,\n\t\t\t\t  const void *data, size_t size);\n\n/* Open index. Returns 1 if ok, 0 if index doesn't exist and CREATE flags\n   wasn't given, -1 if error. */\nint mail_index_open(struct mail_index *index, enum mail_index_open_flags flags);\n/* Open or create index. Returns 0 if ok, -1 if error. */\nint mail_index_open_or_create(struct mail_index *index,\n\t\t\t      enum mail_index_open_flags flags);\nvoid mail_index_close(struct mail_index *index);\n/* unlink() all the index files. */\nint mail_index_unlink(struct mail_index *index);\n\n/* Returns TRUE if index is currently in memory. */\nbool mail_index_is_in_memory(struct mail_index *index);\n/* Move the index into memory. Returns 0 if ok, -1 if error occurred. */\nint mail_index_move_to_memory(struct mail_index *index);\n\nstruct mail_cache *mail_index_get_cache(struct mail_index *index);\n\n/* Refresh index so mail_index_lookup*() will return latest values. Note that\n   immediately after this call there may already be changes, so if you need to\n   rely on validity of the returned values, use some external locking for it. */\nint ATTR_NOWARN_UNUSED_RESULT\nmail_index_refresh(struct mail_index *index);\n\n/* View can be used to look into index. Sequence numbers inside view change\n   only when you synchronize it. The view acquires required locks\n   automatically, but you'll have to drop them manually. */\nstruct mail_index_view *\nmail_index_view_open(struct mail_index *index,\n\t\t     const char *source_filename, unsigned int source_linenum);\n#define mail_index_view_open(index) \\\n\tmail_index_view_open(index, __FILE__, __LINE__)\nvoid mail_index_view_close(struct mail_index_view **view);\n\n/* Returns the index for given view. */\nstruct mail_index *mail_index_view_get_index(struct mail_index_view *view);\n/* Returns number of mails in view. */\nuint32_t mail_index_view_get_messages_count(struct mail_index_view *view);\n/* Returns TRUE if we lost track of changes for some reason. */\nbool mail_index_view_is_inconsistent(struct mail_index_view *view);\n/* Returns number of transactions open for the view. */\nunsigned int\nmail_index_view_get_transaction_count(struct mail_index_view *view);\n\n/* Transaction has to be opened to be able to modify index. You can have\n   multiple transactions open simultaneously. Committed transactions won't\n   show up until you've synchronized the view. Expunges won't show up until\n   you've synchronized the mailbox (mail_index_sync_begin). */\nstruct mail_index_transaction *\nmail_index_transaction_begin(struct mail_index_view *view,\n\t\t\t     enum mail_index_transaction_flags flags);\nint mail_index_transaction_commit(struct mail_index_transaction **t);\nint mail_index_transaction_commit_full(struct mail_index_transaction **t,\n\t\t\t\t       struct mail_index_transaction_commit_result *result_r);\nvoid mail_index_transaction_rollback(struct mail_index_transaction **t);\n/* Discard all changes in the transaction. */\nvoid mail_index_transaction_reset(struct mail_index_transaction *t);\n/* When committing transaction, drop flag/keyword updates for messages whose\n   mdoseq is larger than max_modseq. Save those messages' sequences to the\n   given array. */\nvoid mail_index_transaction_set_max_modseq(struct mail_index_transaction *t,\n\t\t\t\t\t   uint64_t max_modseq,\n\t\t\t\t\t   ARRAY_TYPE(seq_range) *seqs);\n/* Returns the resulting highest-modseq after this commit. This can be called\n   only if transaction log is locked, which normally means only during mail\n   index syncing. If there are any appends, they all must have been assigned\n   UIDs before calling this. */\nuint64_t mail_index_transaction_get_highest_modseq(struct mail_index_transaction *t);\n\n/* Returns the view transaction was created for. */\nstruct mail_index_view *\nmail_index_transaction_get_view(struct mail_index_transaction *t);\n/* Returns TRUE if the given sequence is being expunged in this transaction. */\nbool mail_index_transaction_is_expunged(struct mail_index_transaction *t,\n\t\t\t\t\tuint32_t seq);\n\n/* Returns a view containing the mailbox state after changes in transaction\n   are applied. The view can still be used after transaction has been\n   committed. */\nstruct mail_index_view *\nmail_index_transaction_open_updated_view(struct mail_index_transaction *t);\n\n/* Begin synchronizing mailbox with index file. Returns 1 if ok,\n   0 if MAIL_INDEX_SYNC_FLAG_REQUIRE_CHANGES is set and there's nothing to\n   sync, -1 if error.\n\n   mail_index_sync_next() returns all changes from previously committed\n   transactions which haven't yet been committed to the actual mailbox.\n   They're returned in ascending order and they never overlap (if we add more\n   sync types, then they might). You must go through all of them and update\n   the mailbox accordingly.\n\n   Changes done to the returned transaction are expected to describe the\n   mailbox's current state.\n\n   The returned view already contains all the changes (except expunge\n   requests). After applying sync records on top of backend flags they should\n   match flags in the view. If they don't, there have been external changes.\n\n   Returned expunges are treated as expunge requests. They're not really\n   removed from the index until you mark them expunged to the returned\n   transaction. If it's not possible to expunge the message (e.g. permission\n   denied), simply don't mark them expunged.\n\n   Returned sequence numbers describe the mailbox state at the beginning of\n   synchronization, ie. expunges don't affect them. */\nint mail_index_sync_begin(struct mail_index *index,\n\t\t\t  struct mail_index_sync_ctx **ctx_r,\n\t\t\t  struct mail_index_view **view_r,\n\t\t\t  struct mail_index_transaction **trans_r,\n\t\t\t  enum mail_index_sync_flags flags);\n/* Like mail_index_sync_begin(), but returns 1 if OK and if index is already\n   synchronized up to the given log_file_seq+offset, the synchronization isn't\n   started and this function returns 0. This should be done when you wish to\n   sync your committed transaction instead of doing a full mailbox\n   synchronization. */\nint mail_index_sync_begin_to(struct mail_index *index,\n\t\t\t     struct mail_index_sync_ctx **ctx_r,\n\t\t\t     struct mail_index_view **view_r,\n\t\t\t     struct mail_index_transaction **trans_r,\n\t\t\t     uint32_t log_file_seq, uoff_t log_file_offset,\n\t\t\t     enum mail_index_sync_flags flags);\n/* Returns TRUE if it currently looks like syncing would return changes. */\nbool mail_index_sync_have_any(struct mail_index *index,\n\t\t\t      enum mail_index_sync_flags flags);\n/* Returns TRUE if it currently looks like syncing would return expunges. */\nbool mail_index_sync_have_any_expunges(struct mail_index *index);\n/* Returns the log file seq+offsets for the area which this sync is handling. */\nvoid mail_index_sync_get_offsets(struct mail_index_sync_ctx *ctx,\n\t\t\t\t uint32_t *seq1_r, uoff_t *offset1_r,\n\t\t\t\t uint32_t *seq2_r, uoff_t *offset2_r);\n/* Returns -1 if error, 0 if sync is finished, 1 if record was filled. */\nbool mail_index_sync_next(struct mail_index_sync_ctx *ctx,\n\t\t\t  struct mail_index_sync_rec *sync_rec);\n/* Returns TRUE if there's more to sync. */\nbool mail_index_sync_have_more(struct mail_index_sync_ctx *ctx);\n/* Returns TRUE if sync has any expunges to handle. */\nbool mail_index_sync_has_expunges(struct mail_index_sync_ctx *ctx);\n/* Reset syncing to initial state after mail_index_sync_begin(), so you can\n   go through all the sync records again with mail_index_sync_next(). */\nvoid mail_index_sync_reset(struct mail_index_sync_ctx *ctx);\n/* Update result when refreshing index at the end of sync. */\nvoid mail_index_sync_set_commit_result(struct mail_index_sync_ctx *ctx,\n\t\t\t\t       struct mail_index_transaction_commit_result *result);\n/* Don't log a warning even if syncing took over\n   MAIL_TRANSACTION_LOG_LOCK_WARN_SECS seconds. Usually this is called because\n   the caller itself already logged a warning about it. */\nvoid mail_index_sync_no_warning(struct mail_index_sync_ctx *ctx);\n/* If a warning is logged because syncing took over\n   MAIL_TRANSACTION_LOG_LOCK_WARN_SECS seconds, log this as the reason for the\n   syncing. */\nvoid mail_index_sync_set_reason(struct mail_index_sync_ctx *ctx,\n\t\t\t\tconst char *reason);\n/* Commit synchronization by writing all changes to mail index file. */\nint mail_index_sync_commit(struct mail_index_sync_ctx **ctx);\n/* Rollback synchronization - none of the changes listed by sync_next() are\n   actually written to index file. */\nvoid mail_index_sync_rollback(struct mail_index_sync_ctx **ctx);\n\n/* Lock the index exclusively. This is the same locking as what happens when\n   syncing the index. It's not necessary to normally call this function, unless\n   doing something special such as rebuilding the index outside syncing.\n   Returns 0 on success, -1 if locking failed for any reason. */\nint mail_index_lock_sync(struct mail_index *index, const char *lock_reason);\n/* Unlock the locked index. The index must have been locked previously with\n   mail_index_lock_sync(). If the lock had been kept for excessively long,\n   a warning is logged with the long_lock_reason. */\nvoid mail_index_unlock(struct mail_index *index, const char *long_lock_reason);\n/* Returns TRUE if index is currently exclusively locked. */\nbool mail_index_is_locked(struct mail_index *index);\n\n/* Mark index file corrupted. Invalidates all views. */\nvoid mail_index_mark_corrupted(struct mail_index *index);\n/* Check and fix any found problems. Returns -1 if we couldn't lock for sync,\n   0 if everything went ok. */\nint mail_index_fsck(struct mail_index *index);\n/* Returns TRUE if mail_index_fsck() has been called since the last\n   mail_index_reset_fscked() call. */\nbool mail_index_reset_fscked(struct mail_index *index);\n\n/* Synchronize changes in view. You have to go through all records, or view\n   will be marked inconsistent. Only sync_mask type records are\n   synchronized. */\nstruct mail_index_view_sync_ctx *\nmail_index_view_sync_begin(struct mail_index_view *view,\n\t\t\t   enum mail_index_view_sync_flags flags);\nbool mail_index_view_sync_next(struct mail_index_view_sync_ctx *ctx,\n\t\t\t       struct mail_index_view_sync_rec *sync_rec);\nvoid\nmail_index_view_sync_get_expunges(struct mail_index_view_sync_ctx *ctx,\n\t\t\t\t  const ARRAY_TYPE(seq_range) **expunges_r);\nint mail_index_view_sync_commit(struct mail_index_view_sync_ctx **ctx,\n\t\t\t\tbool *delayed_expunges_r);\n\n/* Returns the index header. */\nconst struct mail_index_header *\nmail_index_get_header(struct mail_index_view *view);\n/* Returns the wanted message record. */\nconst struct mail_index_record *\nmail_index_lookup(struct mail_index_view *view, uint32_t seq);\nconst struct mail_index_record *\nmail_index_lookup_full(struct mail_index_view *view, uint32_t seq,\n\t\t       struct mail_index_map **map_r);\n/* Returns TRUE if the given message has already been expunged from index. */\nbool mail_index_is_expunged(struct mail_index_view *view, uint32_t seq);\n/* Note that returned keyword indexes aren't sorted. */\nvoid mail_index_lookup_keywords(struct mail_index_view *view, uint32_t seq,\n\t\t\t\tARRAY_TYPE(keyword_indexes) *keyword_idx);\n/* Return keywords from given map. */\nvoid mail_index_map_lookup_keywords(struct mail_index_map *map, uint32_t seq,\n\t\t\t\t    ARRAY_TYPE(keyword_indexes) *keyword_idx);\n/* mail_index_lookup[_keywords]() returns the latest flag changes.\n   This function instead attempts to return the flags and keywords done by the\n   last view sync. */\nvoid mail_index_lookup_view_flags(struct mail_index_view *view, uint32_t seq,\n\t\t\t\t  enum mail_flags *flags_r,\n\t\t\t\t  ARRAY_TYPE(keyword_indexes) *keyword_idx);\n/* Returns the UID for given message. May be slightly faster than\n   mail_index_lookup()->uid. */\nvoid mail_index_lookup_uid(struct mail_index_view *view, uint32_t seq,\n\t\t\t   uint32_t *uid_r);\n/* Convert UID range to sequence range. If no UIDs are found, returns FALSE and\n   sequences are set to 0. Note that any of the returned sequences may have\n   been expunged already. */\nbool mail_index_lookup_seq_range(struct mail_index_view *view,\n\t\t\t\t uint32_t first_uid, uint32_t last_uid,\n\t\t\t\t uint32_t *first_seq_r, uint32_t *last_seq_r);\nbool mail_index_lookup_seq(struct mail_index_view *view,\n\t\t\t   uint32_t uid, uint32_t *seq_r);\n/* Find first mail with (mail->flags & flags_mask) == flags. Useful mostly for\n   taking advantage of lowwater-fields in headers. */\nvoid mail_index_lookup_first(struct mail_index_view *view,\n\t\t\t     enum mail_flags flags, uint8_t flags_mask,\n\t\t\t     uint32_t *seq_r);\n\n/* Append a new record to index. */\nvoid mail_index_append(struct mail_index_transaction *t, uint32_t uid,\n\t\t       uint32_t *seq_r);\n/* Assign new UIDs for mails with uid=0 or uid<min_allowed_uid. All the new\n   UIDs are >= first_new_uid, an also higher than the highest seen uid (i.e. it\n   doesn't try to fill UID gaps). Assumes that mailbox is locked in a way that\n   UIDs can be safely assigned. Returns UIDs for all assigned messages, in\n   their sequence order (so UIDs are not necessary ascending). */\nvoid mail_index_append_finish_uids_full(struct mail_index_transaction *t,\n\t\t\t\t\tuint32_t min_allowed_uid,\n\t\t\t\t\tuint32_t first_new_uid,\n\t\t\t\t\tARRAY_TYPE(seq_range) *uids_r);\n/* Call mail_index_append_finish_uids_full() with first_uid used for both\n   min_allowed_uid and first_new_uid. */\nvoid mail_index_append_finish_uids(struct mail_index_transaction *t,\n\t\t\t\t   uint32_t first_uid,\n\t\t\t\t   ARRAY_TYPE(seq_range) *uids_r);\n/* Expunge record from index. Note that this doesn't affect sequence numbers\n   until transaction is committed and mailbox is synced. */\nvoid mail_index_expunge(struct mail_index_transaction *t, uint32_t seq);\n/* Like mail_index_expunge(), but also write message GUID to transaction log. */\nvoid mail_index_expunge_guid(struct mail_index_transaction *t, uint32_t seq,\n\t\t\t     const guid_128_t guid_128);\n/* Revert all changes done in this transaction to the given existing mail. */\nvoid mail_index_revert_changes(struct mail_index_transaction *t, uint32_t seq);\n/* Update flags in index. */\nvoid mail_index_update_flags(struct mail_index_transaction *t, uint32_t seq,\n\t\t\t     enum modify_type modify_type,\n\t\t\t     enum mail_flags flags);\nvoid mail_index_update_flags_range(struct mail_index_transaction *t,\n\t\t\t\t   uint32_t seq1, uint32_t seq2,\n\t\t\t\t   enum modify_type modify_type,\n\t\t\t\t   enum mail_flags flags);\n/* Specified attribute's value was changed. This is just a notification so the\n   change gets assigned its own modseq and any log readers can find out about\n   this change. */\nvoid mail_index_attribute_set(struct mail_index_transaction *t,\n\t\t\t      bool pvt, const char *key,\n\t\t\t      time_t timestamp, uint32_t value_len);\n/* Attribute was deleted. */\nvoid mail_index_attribute_unset(struct mail_index_transaction *t,\n\t\t\t\tbool pvt, const char *key, time_t timestamp);\n/* Update message's modseq to be at least min_modseq. */\nvoid mail_index_update_modseq(struct mail_index_transaction *t, uint32_t seq,\n\t\t\t      uint64_t min_modseq);\n/* Update highest modseq to be at least min_modseq. */\nvoid mail_index_update_highest_modseq(struct mail_index_transaction *t,\n\t\t\t\t      uint64_t min_modseq);\n/* Reset the index before committing this transaction. This is usually done\n   only when UIDVALIDITY changes. */\nvoid mail_index_reset(struct mail_index_transaction *t);\n/* Remove MAIL_INDEX_HDR_FLAG_FSCKD from header if it exists. This must be\n   called only during syncing so that the mailbox is locked. */\nvoid mail_index_unset_fscked(struct mail_index_transaction *t);\n/* Mark index deleted. No further changes will be possible after the\n   transaction has been committed. */\nvoid mail_index_set_deleted(struct mail_index_transaction *t);\n/* Mark a deleted index as undeleted. Afterwards index can be changed again. */\nvoid mail_index_set_undeleted(struct mail_index_transaction *t);\n/* Returns TRUE if index has been set deleted. This gets set only after\n   index has been opened/refreshed and the transaction has been seen. */\nbool mail_index_is_deleted(struct mail_index *index);\n/* Returns the last time the index was modified. This can be called even if the\n   index isn't open. If the index doesn't exist, sets mtime to 0. */\nint mail_index_get_modification_time(struct mail_index *index, time_t *mtime_r);\n\n/* Lookup a keyword, returns TRUE if found, FALSE if not. */\nbool mail_index_keyword_lookup(struct mail_index *index,\n\t\t\t       const char *keyword, unsigned int *idx_r);\nvoid mail_index_keyword_lookup_or_create(struct mail_index *index,\n\t\t\t\t\t const char *keyword,\n\t\t\t\t\t unsigned int *idx_r);\n/* Return a pointer to array of NULL-terminated list of keywords. Note that\n   the array contents (and thus pointers inside it) may change after calling\n   mail_index_keywords_create() or mail_index_sync_begin(). */\nconst ARRAY_TYPE(keywords) *mail_index_get_keywords(struct mail_index *index);\n\n/* Create a keyword list structure. */\nstruct mail_keywords *\nmail_index_keywords_create(struct mail_index *index,\n\t\t\t   const char *const keywords[]) ATTR_NULL(2);\nstruct mail_keywords *\nmail_index_keywords_create_from_indexes(struct mail_index *index,\n\t\t\t\t\tconst ARRAY_TYPE(keyword_indexes)\n\t\t\t\t\t\t*keyword_indexes);\nvoid mail_index_keywords_ref(struct mail_keywords *keywords);\nvoid mail_index_keywords_unref(struct mail_keywords **keywords);\n\n/* Update keywords for given message. */\nvoid mail_index_update_keywords(struct mail_index_transaction *t, uint32_t seq,\n\t\t\t\tenum modify_type modify_type,\n\t\t\t\tstruct mail_keywords *keywords);\n\n/* Update field in header. If prepend is TRUE, the header change is visible\n   before message syncing begins. */\nvoid mail_index_update_header(struct mail_index_transaction *t,\n\t\t\t      size_t offset, const void *data, size_t size,\n\t\t\t      bool prepend);\n\n/* Returns the full error message for last error. This message may\n   contain paths etc. so it shouldn't be shown to users. */\nconst char *mail_index_get_error_message(struct mail_index *index);\n/* Reset the error message. */\nvoid mail_index_reset_error(struct mail_index *index);\n\n/* Apply changes in MAIL_INDEX_SYNC_TYPE_FLAGS typed sync records to given\n   flags variable. */\nvoid mail_index_sync_flags_apply(const struct mail_index_sync_rec *sync_rec,\n\t\t\t\t uint8_t *flags);\n/* Apply changes in MAIL_INDEX_SYNC_TYPE_KEYWORD_* typed sync records to given\n   keywords array. Returns TRUE If something was changed. */\nbool mail_index_sync_keywords_apply(const struct mail_index_sync_rec *sync_rec,\n\t\t\t\t    ARRAY_TYPE(keyword_indexes) *keywords);\n\n/* register index extension. name is a unique identifier for the extension.\n   returns unique identifier for the name. */\nuint32_t mail_index_ext_register(struct mail_index *index, const char *name,\n\t\t\t\t uint32_t default_hdr_size,\n\t\t\t\t uint16_t default_record_size,\n\t\t\t\t uint16_t default_record_align);\n/* Change an already registered extension's default sizes. */\nvoid mail_index_ext_register_resize_defaults(struct mail_index *index,\n\t\t\t\t\t     uint32_t ext_id,\n\t\t\t\t\t     uint32_t default_hdr_size,\n\t\t\t\t\t     uint16_t default_record_size,\n\t\t\t\t\t     uint16_t default_record_align);\n/* Returns TRUE and sets ext_id_r if extension with given name is registered. */\nbool mail_index_ext_lookup(struct mail_index *index, const char *name,\n\t\t\t   uint32_t *ext_id_r);\n/* Resize existing extension data. If size is grown, the new data will be\n   zero-filled. If size is shrinked, the data is simply dropped. */\nvoid mail_index_ext_resize(struct mail_index_transaction *t, uint32_t ext_id,\n\t\t\t   uint32_t hdr_size, uint16_t record_size,\n\t\t\t   uint16_t record_align);\n/* Resize header, keeping the old record size. */\nvoid mail_index_ext_resize_hdr(struct mail_index_transaction *t,\n\t\t\t       uint32_t ext_id, uint32_t hdr_size);\n\n/* Reset extension. Any updates for this extension which were issued before the\n   writer had seen this reset are discarded. reset_id is used to figure this\n   out, so it must be different every time. If clear_data=TRUE, records and\n   header is zeroed. */\nvoid mail_index_ext_reset(struct mail_index_transaction *t, uint32_t ext_id,\n\t\t\t  uint32_t reset_id, bool clear_data);\n/* Like mail_index_ext_reset(), but increase extension's reset_id atomically\n   when the transaction is being committed. If prev_reset_id doesn't match the\n   latest reset_id, the reset_id isn't increased and all extension changes are\n   ignored. */\nvoid mail_index_ext_reset_inc(struct mail_index_transaction *t, uint32_t ext_id,\n\t\t\t      uint32_t prev_reset_id, bool clear_data);\n/* Discard existing extension updates in this transaction and write new updates\n   using the given reset_id. The difference to mail_index_ext_reset() is that\n   this doesn't clear any existing record or header data. */\nvoid mail_index_ext_set_reset_id(struct mail_index_transaction *t,\n\t\t\t\t uint32_t ext_id, uint32_t reset_id);\n/* Get the current reset_id for given extension. Returns TRUE if it exists. */\nbool mail_index_ext_get_reset_id(struct mail_index_view *view,\n\t\t\t\t struct mail_index_map *map,\n\t\t\t\t uint32_t ext_id, uint32_t *reset_id_r);\n\n/* Returns extension header. */\nvoid mail_index_get_header_ext(struct mail_index_view *view, uint32_t ext_id,\n\t\t\t       const void **data_r, size_t *data_size_r);\nvoid mail_index_map_get_header_ext(struct mail_index_view *view,\n\t\t\t\t   struct mail_index_map *map, uint32_t ext_id,\n\t\t\t\t   const void **data_r, size_t *data_size_r);\n/* Returns the wanted extension record for given message. If it doesn't exist,\n   *data_r is set to NULL. expunged_r is TRUE if the message has already been\n   expunged from the index. */\nvoid mail_index_lookup_ext(struct mail_index_view *view, uint32_t seq,\n\t\t\t   uint32_t ext_id, const void **data_r,\n\t\t\t   bool *expunged_r);\nvoid mail_index_lookup_ext_full(struct mail_index_view *view, uint32_t seq,\n\t\t\t\tuint32_t ext_id, struct mail_index_map **map_r,\n\t\t\t\tconst void **data_r, bool *expunged_r);\n/* Get current extension sizes. Returns 1 if ok, 0 if extension doesn't exist\n   in view. Any of the _r parameters may be NULL. */\nvoid mail_index_ext_get_size(struct mail_index_map *map, uint32_t ext_id,\n\t\t\t     uint32_t *hdr_size_r, uint16_t *record_size_r,\n\t\t\t     uint16_t *record_align_r);\n/* Update extension header field. */\nvoid mail_index_update_header_ext(struct mail_index_transaction *t,\n\t\t\t\t  uint32_t ext_id, size_t offset,\n\t\t\t\t  const void *data, size_t size);\n/* Update extension record. If old_data_r is non-NULL and the record extension\n   was already updated in this transaction, it's set to contain the data it's\n   now overwriting. */\nvoid mail_index_update_ext(struct mail_index_transaction *t, uint32_t seq,\n\t\t\t   uint32_t ext_id, const void *data, void *old_data)\n\tATTR_NULL(5);\n/* Increase/decrease number in extension atomically. Returns the sum of the\n   diffs for this seq. */\nint mail_index_atomic_inc_ext(struct mail_index_transaction *t,\n\t\t\t      uint32_t seq, uint32_t ext_id, int diff);\n\n#endif\n"}, "8": {"id": 8, "path": "/home/runner/work/testcc/testcc/retdec/src/lib/bits.h", "content": "#ifndef BITS_H\n#define BITS_H\n\n#define UINT64_SUM_OVERFLOWS(a, b) \\\n\t(a > (uint64_t)-1 - b)\n\n#define BIT(n) (1u << (n))\n\n/* These expressions make it easy to ensure that bit test expressions\n   are boolean in order to satisfy the in-house -Wstrict-bool. */\n/* ((val & bits) == 0) is very common */\n#define HAS_NO_BITS(val,bits) (((val) & (bits)) == 0)\n/* ((val & bits) != 0) is even more common */\n/* Note - illogical behaviour if bits==0, fixing that requires potential\n   multiple evaluation, but it's a corner case that should never occur. */\n#define HAS_ANY_BITS(val,bits) (((val) & (bits)) != 0)\n/* ((val & bits) == bits) is uncommon */\n#define HAS_ALL_BITS(val,bits) ((~(val) & (bits)) == 0)\n\n/* Returns x, such that x is the smallest power of 2 >= num. */\nsize_t nearest_power(size_t num) ATTR_CONST;\n\n/* Returns TRUE if 2^x=num, i.e. if num has only a single bit set to 1. */\nstatic inline bool ATTR_CONST\nbits_is_power_of_two(uint64_t num)\n{\n\treturn num > 0 && (num & (num - 1)) == 0;\n}\n\n#if __GNUC__ > 3 || (__GNUC__ == 3 && __GNUC_MINOR__ >= 4)\nstatic inline unsigned int ATTR_CONST\nbits_required32(uint32_t num)\n{\n\treturn num == 0 ? 0 : 32 - __builtin_clz(num);\n}\nstatic inline unsigned int ATTR_CONST\nbits_required8(uint8_t num)   { return bits_required32(num); }\n\nstatic inline unsigned int ATTR_CONST\nbits_required16(uint16_t num) { return bits_required32(num); }\n\nstatic inline unsigned int ATTR_CONST\nbits_required64(uint64_t num)\n{\n\treturn num == 0 ? 0 : 64 - __builtin_clzll(num);\n}\n#else\nunsigned int bits_required8(uint8_t num) ATTR_CONST;\n\nstatic inline\nunsigned int bits_required16(uint16_t num)\n{\n\treturn (num <= 0xff) ? bits_required8(num)\n\t\t: 8 + bits_required8(num >> 8);\n}\nstatic inline\nunsigned int bits_required32(uint32_t num)\n{\n\treturn (num <= 0xffff) ? bits_required16(num)\n\t\t: 16 + bits_required16(num >> 16);\n}\nstatic inline\nunsigned int bits_required64(uint64_t num)\n{\n\treturn (num <= 0xffffffff) ? bits_required32(num)\n\t\t: 32 + bits_required32(num >> 32);\n}\n#endif\n\nstatic inline uint64_t\nbits_rotl64(uint64_t num, unsigned int count)\n{\n\tconst unsigned int mask = CHAR_BIT*sizeof(num) - 1;\n\tcount &= mask;\n\treturn (num << count) | (num >> (-count & mask));\n}\n\nstatic inline uint32_t\nbits_rotl32(uint32_t num, unsigned int count)\n{\n        const unsigned int mask = CHAR_BIT*sizeof(num) - 1;\n        count &= mask;\n        return (num << count) | (num >> (-count & mask));\n}\n\nstatic inline uint64_t\nbits_rotr64(uint64_t num, unsigned int count)\n{\n\tconst unsigned int mask = CHAR_BIT*sizeof(num) - 1;\n\tcount &= mask;\n\treturn (num >> count) | (num << (-count & mask));\n}\n\nstatic inline uint32_t\nbits_rotr32(uint32_t num, unsigned int count)\n{\n\tconst unsigned int mask = CHAR_BIT*sizeof(num) - 1;\n\tcount &= mask;\n\treturn (num >> count) | (num << (-count & mask));\n}\n\n/* These functions look too big to be inline, but in almost all expected\n   uses, 'fracbits' will be a compile-time constant, and most of the\n   expressions will simplify greatly.\n*/\n\n/* Perform a piecewise-linear approximation to a log2, with fracbits \"fractional\" bits.\n   Best explained with examples:\n   With 2 fractional bits splitting each power of 2 into 4 bands:\n     00,   01,   10,   11 ->   00,   01,   10,   11 (small corner cases)\n    100,  101,  110,  111 ->  100,  101,  110,  111 ([4-8) split into 4 bands)\n   1000, 1001, 1010, 1011 -> 1000, 1000, 1001, 1001 ([8-15) split ...\n   1100, 1101, 1110, 1111 -> 1010, 1010, 1011, 1011  ... into 4 bands)\n   [16..31) -> 11bb\n   [32..63) -> 100bb\n   [64..127) -> 101bb\n   [128..255) -> 110bb\n   e.g. 236 = 11101100 -> ((8-2)<<2 == 11000) + (111.....>> 5 == 111) - 100 == 11011\n */\nstatic inline unsigned int ATTR_CONST\nbits_fraclog(unsigned int val, unsigned int fracbits)\n{\n\tunsigned bits = bits_required32(val);\n\tif (bits <= fracbits + 1)\n\t\treturn val;\n\n\tunsigned int bandnum = bits - fracbits;\n\tunsigned int bandstart = bandnum << fracbits;\n\tunsigned int fracoffsbad = val >> (bandnum - 1); /* has leading 1 still */\n\tunsigned int bucket = bandstart + fracoffsbad - BIT(fracbits);\n\treturn bucket;\n}\nstatic inline unsigned int ATTR_CONST\nbits_fraclog_bucket_start(unsigned int bucket, unsigned int fracbits)\n{\n\tunsigned int bandnum = bucket >> fracbits;\n\tif (bandnum <= 1)\n\t\treturn bucket;\n\tif (fracbits == 0)\n\t\treturn BIT(bucket - 1);\n\tunsigned int fracoffs = bucket & (BIT(fracbits)-1);\n\tunsigned int fracoffs1 = BIT(fracbits) + fracoffs;\n\tunsigned int bandstart = fracoffs1 << (bandnum - 1);\n\treturn bandstart;\n}\nstatic inline unsigned int ATTR_CONST\nbits_fraclog_bucket_end(unsigned int bucket, unsigned int fracbits)\n{\n\tunsigned int bandnum = bucket >> fracbits;\n\tif (bandnum <= 1)\n\t\treturn bucket;\n\tif (fracbits == 0)\n\t\treturn BIT(bucket - 1) * 2 - 1;\n\tunsigned int fracoffs = bucket & (BIT(fracbits)-1);\n\tunsigned int nextfracoffs1 = 1 + BIT(fracbits) + fracoffs;\n\tunsigned int nextbandstart = nextfracoffs1 << (bandnum - 1);\n\treturn nextbandstart - 1;\n}\n/* UNSAFE: multiple use of parameter (but expecting a constant in reality).\n   But a macro as it's most likely to be used to declare an array size.\n*/\n#define BITS_FRACLOG_BUCKETS(bits) ((33u - (bits)) << (bits))\n\n#endif\n"}, "9": {"id": 9, "path": "/home/runner/work/testcc/testcc/retdec/src/lib-mail/mail-types.h", "content": "#ifndef MAIL_TYPES_H\n#define MAIL_TYPES_H\n\nenum mail_flags {\n\tMAIL_ANSWERED\t= 0x01,\n\tMAIL_FLAGGED\t= 0x02,\n\tMAIL_DELETED\t= 0x04,\n\tMAIL_SEEN\t= 0x08,\n\tMAIL_DRAFT\t= 0x10,\n\tMAIL_RECENT\t= 0x20,\n\n\tMAIL_FLAGS_MASK = 0x3f,\n\tMAIL_FLAGS_NONRECENT = (MAIL_FLAGS_MASK ^ MAIL_RECENT)\n};\n\nenum modify_type {\n\tMODIFY_ADD,\n\tMODIFY_REMOVE,\n\tMODIFY_REPLACE\n};\n\nARRAY_DEFINE_TYPE(keywords, const char *);\nARRAY_DEFINE_TYPE(keyword_indexes, unsigned int);\n\n#endif\n"}, "10": {"id": 10, "path": "/home/runner/work/testcc/testcc/retdec/src/lib-storage/mail-error.h", "content": "#ifndef MAIL_ERROR_H\n#define MAIL_ERROR_H\n\n/* Some error strings that should be used everywhere to avoid\n   permissions checks from revealing mailbox's existence */\n#define MAIL_ERRSTR_MAILBOX_NOT_FOUND \"Mailbox doesn't exist: %s\"\n#define MAIL_ERRSTR_NO_PERMISSION \"Permission denied\"\n\n/* And just for making error strings consistent: */\n#define MAIL_ERRSTR_NO_QUOTA \"Not enough disk quota\"\n#define MAIL_ERRSTR_LOCK_TIMEOUT \"Timeout while waiting for lock\"\n\n/* Message to show to users when critical error occurs */\n#define MAIL_ERRSTR_CRITICAL_MSG \\\n\t\"Internal error occurred. Refer to server log for more information.\"\n#define MAIL_ERRSTR_CRITICAL_MSG_STAMP \\\n\tMAIL_ERRSTR_CRITICAL_MSG \" [%Y-%m-%d %H:%M:%S]\"\n\n#define T_MAIL_ERR_MAILBOX_NOT_FOUND(name) \\\n\tt_strdup_printf(MAIL_ERRSTR_MAILBOX_NOT_FOUND, name)\n\nenum mail_error {\n\tMAIL_ERROR_NONE = 0,\n\n\t/* Temporary internal error */\n\tMAIL_ERROR_TEMP,\n\t/* Temporary failure because a subsystem is down */\n\tMAIL_ERROR_UNAVAILABLE,\n\t/* It's not possible to do the wanted operation */\n\tMAIL_ERROR_NOTPOSSIBLE,\n\t/* Invalid parameters (eg. mailbox name not valid) */\n\tMAIL_ERROR_PARAMS,\n\t/* No permission to do the request */\n\tMAIL_ERROR_PERM,\n\t/* Out of disk quota for user */\n\tMAIL_ERROR_NOQUOTA,\n\t/* Item (e.g. mailbox) doesn't exist or it's not visible to us */\n\tMAIL_ERROR_NOTFOUND,\n\t/* Item (e.g. mailbox) already exists */\n\tMAIL_ERROR_EXISTS,\n\t/* Tried to access an expunged message */\n\tMAIL_ERROR_EXPUNGED,\n\t/* Operation cannot be done because another session prevents it\n\t   (e.g. lock timeout) */\n\tMAIL_ERROR_INUSE,\n\t/* Can't do the requested data conversion (e.g. IMAP BINARY's\n\t   UNKNOWN-CTE code) */\n\tMAIL_ERROR_CONVERSION,\n\t/* Can't do the requested data conversion because the original data\n\t   isn't valid. */\n\tMAIL_ERROR_INVALIDDATA,\n\t/* Operation ran against some kind of a limit. */\n\tMAIL_ERROR_LIMIT,\n\t/* Operation couldn't be finished as efficiently as required by\n\t   mail.lookup_abort. */\n\tMAIL_ERROR_LOOKUP_ABORTED,\n};\n\n/* Convert errno to mail_error and an error string. Returns TRUE if successful,\n   FALSE if we couldn't handle the errno. */\nbool mail_error_from_errno(enum mail_error *error_r,\n\t\t\t   const char **error_string_r);\n\n/* Build a helpful error message for a failed EACCES syscall. */\nconst char *mail_error_eacces_msg(const char *func, const char *path);\n/* Build a helpful error message for a failed EACCES syscall that tried to\n   write to directory (create, rename, etc). */\nconst char *mail_error_create_eacces_msg(const char *func, const char *path);\n\n#endif\n"}, "11": {"id": 11, "path": "/home/runner/work/testcc/testcc/retdec/src/lib-storage/mail-storage-settings.h", "content": "#ifndef MAIL_STORAGE_SETTINGS_H\n#define MAIL_STORAGE_SETTINGS_H\n\n#include \"file-lock.h\"\n#include \"fsync-mode.h\"\n\n#define MAIL_STORAGE_SET_DRIVER_NAME \"MAIL\"\n\nstruct mail_user;\nstruct mail_namespace;\nstruct mail_storage;\nstruct message_address;\nstruct smtp_address;\n\nstruct mail_storage_settings {\n\tconst char *mail_location;\n\tconst char *mail_attachment_fs;\n\tconst char *mail_attachment_dir;\n\tconst char *mail_attachment_hash;\n\tuoff_t mail_attachment_min_size;\n\tconst char *mail_attribute_dict;\n\tunsigned int mail_prefetch_count;\n\tconst char *mail_cache_fields;\n\tconst char *mail_always_cache_fields;\n\tconst char *mail_never_cache_fields;\n\tconst char *mail_server_comment;\n\tconst char *mail_server_admin;\n\tunsigned int mail_cache_min_mail_count;\n\tunsigned int mail_cache_unaccessed_field_drop;\n\tuoff_t mail_cache_record_max_size;\n\tuoff_t mail_cache_max_size;\n\tuoff_t mail_cache_purge_min_size;\n\tunsigned int mail_cache_purge_delete_percentage;\n\tunsigned int mail_cache_purge_continued_percentage;\n\tunsigned int mail_cache_purge_header_continue_count;\n\tuoff_t mail_index_rewrite_min_log_bytes;\n\tuoff_t mail_index_rewrite_max_log_bytes;\n\tuoff_t mail_index_log_rotate_min_size;\n\tuoff_t mail_index_log_rotate_max_size;\n\tunsigned int mail_index_log_rotate_min_age;\n\tunsigned int mail_index_log2_max_age;\n\tunsigned int mailbox_idle_check_interval;\n\tunsigned int mail_max_keyword_length;\n\tunsigned int mail_max_lock_timeout;\n\tunsigned int mail_temp_scan_interval;\n\tunsigned int mail_vsize_bg_after_count;\n\tunsigned int mail_sort_max_read_count;\n\tbool mail_save_crlf;\n\tconst char *mail_fsync;\n\tbool mmap_disable;\n\tbool dotlock_use_excl;\n\tbool mail_nfs_storage;\n\tbool mail_nfs_index;\n\tbool mailbox_list_index;\n\tbool mailbox_list_index_very_dirty_syncs;\n\tbool mailbox_list_index_include_inbox;\n\tbool mail_debug;\n\tbool mail_full_filesystem_access;\n\tbool maildir_stat_dirs;\n\tbool mail_shared_explicit_inbox;\n\tconst char *lock_method;\n\tconst char *pop3_uidl_format;\n\n\tconst char *hostname;\n\tconst char *recipient_delimiter;\n\n\tconst char *ssl_client_ca_file;\n\tconst char *ssl_client_ca_dir;\n\tconst char *ssl_client_cert;\n\tconst char *ssl_client_key;\n\tconst char *ssl_cipher_list;\n\tconst char *ssl_curve_list;\n\tconst char *ssl_min_protocol;\n\tconst char *ssl_crypto_device;\n\tbool ssl_client_require_valid_cert;\n\tbool verbose_ssl;\n\tconst char *mail_attachment_detection_options;\n\n\tenum file_lock_method parsed_lock_method;\n\tenum fsync_mode parsed_fsync_mode;\n\n\tconst char *const *parsed_mail_attachment_content_type_filter;\n\tbool parsed_mail_attachment_exclude_inlined;\n\tbool parsed_mail_attachment_detection_add_flags_on_save;\n};\n\nstruct mail_namespace_settings {\n\tconst char *name;\n\tconst char *type;\n\tconst char *separator;\n\tconst char *prefix;\n\tconst char *location;\n\tconst char *alias_for;\n\n\tbool inbox;\n\tbool hidden;\n\tconst char *list;\n\tbool subscriptions;\n\tbool ignore_on_failure;\n\tbool disabled;\n\tunsigned int order;\n\n\tARRAY(struct mailbox_settings *) mailboxes;\n\tstruct mail_user_settings *user_set;\n};\n\n/* <settings checks> */\n#define MAILBOX_SET_AUTO_NO \"no\"\n#define MAILBOX_SET_AUTO_CREATE \"create\"\n#define MAILBOX_SET_AUTO_SUBSCRIBE \"subscribe\"\n/* </settings checks> */\nstruct mailbox_settings {\n\tconst char *name;\n\tconst char *autocreate;\n\tconst char *special_use;\n\tconst char *driver;\n\tconst char *comment;\n\tunsigned int autoexpunge;\n\tunsigned int autoexpunge_max_mails;\n};\n\nstruct mail_user_settings {\n\tconst char *base_dir;\n\tconst char *auth_socket_path;\n\tconst char *mail_temp_dir;\n\n\tconst char *mail_uid;\n\tconst char *mail_gid;\n\tconst char *mail_home;\n\tconst char *mail_chroot;\n\tconst char *mail_access_groups;\n\tconst char *mail_privileged_group;\n\tconst char *valid_chroot_dirs;\n\n\tunsigned int first_valid_uid, last_valid_uid;\n\tunsigned int first_valid_gid, last_valid_gid;\n\n\tconst char *mail_plugins;\n\tconst char *mail_plugin_dir;\n\n\tconst char *mail_log_prefix;\n\n\tconst char *hostname;\n\tconst char *postmaster_address;\n\n\tARRAY(struct mail_namespace_settings *) namespaces;\n\tARRAY(const char *) plugin_envs;\n\n\t/* May be NULL - use mail_storage_get_postmaster_address() instead of\n\t   directly accessing this. */\n\tconst struct message_address *_parsed_postmaster_address;\n\tconst struct smtp_address *_parsed_postmaster_address_smtp;\n};\n\nextern const struct setting_parser_info mail_user_setting_parser_info;\nextern const struct setting_parser_info mail_namespace_setting_parser_info;\nextern const struct setting_parser_info mail_storage_setting_parser_info;\nextern const struct mail_namespace_settings mail_namespace_default_settings;\nextern const struct mailbox_settings mailbox_default_settings;\n\nstruct ssl_iostream_settings;\n\nconst void *\nmail_user_set_get_driver_settings(const struct setting_parser_info *info,\n\t\t\t\t  const struct mail_user_settings *set,\n\t\t\t\t  const char *driver);\n\nconst struct mail_storage_settings *\nmail_user_set_get_storage_set(struct mail_user *user);\n/* Get storage-specific settings, which may be namespace-specific. */\nconst void *mail_namespace_get_driver_settings(struct mail_namespace *ns,\n\t\t\t\t\t       struct mail_storage *storage);\n\nconst struct dynamic_settings_parser *\nmail_storage_get_dynamic_parsers(pool_t pool);\n\nbool mail_user_set_get_postmaster_address(const struct mail_user_settings *set,\n\t\t\t\t\t  const struct message_address **address_r,\n\t\t\t\t\t  const char **error_r);\nbool mail_user_set_get_postmaster_smtp(const struct mail_user_settings *set,\n\t\t\t\t       const struct smtp_address **address_r,\n\t\t\t\t       const char **error_r);\n\nvoid mail_storage_settings_init_ssl_client_settings(const struct mail_storage_settings *mail_set,\n\t\t\t\t\t\t    struct ssl_iostream_settings *ssl_set_r);\n\n#endif\n"}, "12": {"id": 12, "path": "/home/runner/work/testcc/testcc/retdec/src/lib-storage/mail-storage.h", "content": "#ifndef MAIL_STORAGE_H\n#define MAIL_STORAGE_H\n\nstruct message_size;\n\n#include \"seq-range-array.h\"\n#include \"file-lock.h\"\n#include \"guid.h\"\n#include \"mail-types.h\"\n#include \"mail-error.h\"\n#include \"mail-index.h\"\n#include \"mail-namespace.h\"\n#include \"mailbox-list.h\"\n#include \"mailbox-attribute.h\"\n\n/* If some operation is taking long, call notify_ok every n seconds. */\n#define MAIL_STORAGE_STAYALIVE_SECS 15\n\n#define MAIL_KEYWORD_HAS_ATTACHMENT \"$HasAttachment\"\n#define MAIL_KEYWORD_HAS_NO_ATTACHMENT \"$HasNoAttachment\"\n\nenum mail_storage_flags {\n\t/* Remember message headers' MD5 sum */\n\tMAIL_STORAGE_FLAG_KEEP_HEADER_MD5\t= 0x01,\n\t/* Don't try to autodetect anything, require that the given data \n\t   contains all the necessary information. */\n\tMAIL_STORAGE_FLAG_NO_AUTODETECTION\t= 0x02,\n\t/* Don't autocreate any directories. If they don't exist,\n\t   fail to create the storage. */\n\tMAIL_STORAGE_FLAG_NO_AUTOCREATE\t\t= 0x04,\n\t/* Don't verify existence or accessibility of any directories.\n\t   Create the storage in any case. */\n\tMAIL_STORAGE_FLAG_NO_AUTOVERIFY\t\t= 0x08\n};\n\nenum mailbox_flags {\n\t/* Mailbox must not be modified even if asked */\n\tMAILBOX_FLAG_READONLY\t\t= 0x01,\n\t/* Only saving/copying mails to mailbox works. */\n\tMAILBOX_FLAG_SAVEONLY\t\t= 0x02,\n\t/* Remove MAIL_RECENT flags when syncing */\n\tMAILBOX_FLAG_DROP_RECENT\t= 0x04,\n\t/* Don't create index files for the mailbox */\n\tMAILBOX_FLAG_NO_INDEX_FILES\t= 0x10,\n\t/* Keep mailbox exclusively locked all the time while it's open */\n\tMAILBOX_FLAG_KEEP_LOCKED\t= 0x20,\n\t/* Enable if mailbox is used for serving POP3. This allows making\n\t   better caching decisions. */\n\tMAILBOX_FLAG_POP3_SESSION\t= 0x40,\n\t/* Enable if mailbox is used for saving a mail delivery using MDA.\n\t   This causes ACL plugin to use POST right rather than INSERT. */\n\tMAILBOX_FLAG_POST_SESSION\t= 0x80,\n\t/* Force opening mailbox and ignoring any ACLs */\n\tMAILBOX_FLAG_IGNORE_ACLS\t= 0x100,\n\t/* Open mailbox even if it's already marked as deleted */\n\tMAILBOX_FLAG_OPEN_DELETED\t= 0x200,\n\t/* Mailbox is opened for deletion, which should be performed as\n\t   efficiently as possible, even allowing the mailbox state to become\n\t   inconsistent. For example this disables lazy_expunge plugin and\n\t   quota updates (possibly resulting in broken quota). and This is\n\t   useful for example when deleting entire user accounts. */\n\tMAILBOX_FLAG_DELETE_UNSAFE\t= 0x400,\n\t/* Mailbox is created implicitly if it does not exist. */\n\tMAILBOX_FLAG_AUTO_CREATE\t= 0x1000,\n\t/* Mailbox is subscribed to implicitly when it is created automatically */\n\tMAILBOX_FLAG_AUTO_SUBSCRIBE\t= 0x2000,\n\t/* Run fsck for mailbox index before doing anything else. This may be\n\t   useful in fixing index corruption errors that aren't otherwise\n\t   detected and that are causing the full mailbox opening to fail. */\n\tMAILBOX_FLAG_FSCK\t\t= 0x4000,\n\t/* Interpret name argument for mailbox_alloc_for_user() as a SPECIAL-USE\n\t   flag. */\n\tMAILBOX_FLAG_SPECIAL_USE\t= 0x8000,\n\t/* Mailbox is opened for reading/writing attributes. This allows ACL\n\t   plugin to determine correctly whether the mailbox should be allowed\n\t   to be opened. */\n\tMAILBOX_FLAG_ATTRIBUTE_SESSION\t= 0x10000,\n};\n\nenum mailbox_feature {\n\t/* Enable tracking modsequences */\n\tMAILBOX_FEATURE_CONDSTORE\t= 0x01,\n};\n\nenum mailbox_existence {\n\tMAILBOX_EXISTENCE_NONE,\n\tMAILBOX_EXISTENCE_NOSELECT,\n\tMAILBOX_EXISTENCE_SELECT\n};\n\nenum mailbox_status_items {\n\tSTATUS_MESSAGES\t\t= 0x01,\n\tSTATUS_RECENT\t\t= 0x02,\n\tSTATUS_UIDNEXT\t\t= 0x04,\n\tSTATUS_UIDVALIDITY\t= 0x08,\n\tSTATUS_UNSEEN\t\t= 0x10,\n\tSTATUS_FIRST_UNSEEN_SEQ\t= 0x20,\n\tSTATUS_KEYWORDS\t\t= 0x40,\n\tSTATUS_HIGHESTMODSEQ\t= 0x80,\n\tSTATUS_PERMANENT_FLAGS\t= 0x200,\n\tSTATUS_FIRST_RECENT_UID\t= 0x400,\n\tSTATUS_LAST_CACHED_SEQ\t= 0x800,\n\tSTATUS_CHECK_OVER_QUOTA\t= 0x1000, /* return error if over quota */\n\tSTATUS_HIGHESTPVTMODSEQ\t= 0x2000,\n\t/* status items that must not be looked up with\n\t   mailbox_get_open_status(), because they can return failure. */\n#define MAILBOX_STATUS_FAILING_ITEMS \\\n\t(STATUS_LAST_CACHED_SEQ | STATUS_CHECK_OVER_QUOTA)\n};\n\nenum mailbox_metadata_items {\n\tMAILBOX_METADATA_GUID\t\t\t= 0x01,\n\tMAILBOX_METADATA_VIRTUAL_SIZE\t\t= 0x02,\n\tMAILBOX_METADATA_CACHE_FIELDS\t\t= 0x04,\n\tMAILBOX_METADATA_PRECACHE_FIELDS\t= 0x08,\n\tMAILBOX_METADATA_BACKEND_NAMESPACE\t= 0x10,\n\tMAILBOX_METADATA_PHYSICAL_SIZE\t\t= 0x20,\n\tMAILBOX_METADATA_FIRST_SAVE_DATE\t= 0x40\n\t/* metadata items that require mailbox to be synced at least once. */\n#define MAILBOX_METADATA_SYNC_ITEMS \\\n\t(MAILBOX_METADATA_VIRTUAL_SIZE | MAILBOX_METADATA_PHYSICAL_SIZE | \\\n\t MAILBOX_METADATA_FIRST_SAVE_DATE)\n};\n\nenum mailbox_search_result_flags {\n\t/* Update search results whenever the mailbox view is synced.\n\t   Expunged messages are removed even without this flag. */\n\tMAILBOX_SEARCH_RESULT_FLAG_UPDATE\t= 0x01,\n\t/* Queue changes so _sync() can be used. */\n\tMAILBOX_SEARCH_RESULT_FLAG_QUEUE_SYNC\t= 0x02\n};\n\nenum mail_sort_type {\n\tMAIL_SORT_ARRIVAL\t= 0x0001,\n\tMAIL_SORT_CC\t\t= 0x0002,\n\tMAIL_SORT_DATE\t\t= 0x0004,\n\tMAIL_SORT_FROM\t\t= 0x0008,\n\tMAIL_SORT_SIZE\t\t= 0x0010,\n\tMAIL_SORT_SUBJECT\t= 0x0020,\n\tMAIL_SORT_TO\t\t= 0x0040,\n\tMAIL_SORT_RELEVANCY\t= 0x0080,\n\tMAIL_SORT_DISPLAYFROM\t= 0x0100,\n\tMAIL_SORT_DISPLAYTO\t= 0x0200,\n\tMAIL_SORT_POP3_ORDER\t= 0x0400,\n/* Maximum size for sort program (each one separately + END) */\n#define MAX_SORT_PROGRAM_SIZE (11 + 1)\n\n\tMAIL_SORT_MASK\t\t= 0x0fff,\n\tMAIL_SORT_FLAG_REVERSE\t= 0x1000, /* reverse this mask type */\n\n\tMAIL_SORT_END\t\t= 0x0000 /* ends sort program */\n};\n\nenum mail_fetch_field {\n\tMAIL_FETCH_FLAGS\t\t= 0x00000001,\n\tMAIL_FETCH_MESSAGE_PARTS\t= 0x00000002,\n\n\tMAIL_FETCH_STREAM_HEADER\t= 0x00000004,\n\tMAIL_FETCH_STREAM_BODY\t\t= 0x00000008,\n\n\tMAIL_FETCH_DATE\t\t\t= 0x00000010,\n\tMAIL_FETCH_RECEIVED_DATE\t= 0x00000020,\n\tMAIL_FETCH_SAVE_DATE\t\t= 0x00000040,\n\tMAIL_FETCH_PHYSICAL_SIZE\t= 0x00000080,\n\tMAIL_FETCH_VIRTUAL_SIZE\t\t= 0x00000100,\n\n\t/* Set has_nuls / has_no_nuls fields */\n\tMAIL_FETCH_NUL_STATE\t\t= 0x00000200,\n\n\tMAIL_FETCH_STREAM_BINARY\t= 0x00000400,\n\n\t/* specials: */\n\tMAIL_FETCH_IMAP_BODY\t\t= 0x00001000,\n\tMAIL_FETCH_IMAP_BODYSTRUCTURE\t= 0x00002000,\n\tMAIL_FETCH_IMAP_ENVELOPE\t= 0x00004000,\n\tMAIL_FETCH_FROM_ENVELOPE\t= 0x00008000,\n\tMAIL_FETCH_HEADER_MD5\t\t= 0x00010000,\n\tMAIL_FETCH_STORAGE_ID\t\t= 0x00020000,\n\tMAIL_FETCH_UIDL_BACKEND\t\t= 0x00040000,\n\tMAIL_FETCH_MAILBOX_NAME\t\t= 0x00080000,\n\tMAIL_FETCH_SEARCH_RELEVANCY\t= 0x00100000,\n\tMAIL_FETCH_GUID\t\t\t= 0x00200000,\n\tMAIL_FETCH_POP3_ORDER\t\t= 0x00400000,\n\tMAIL_FETCH_REFCOUNT\t\t= 0x00800000,\n\tMAIL_FETCH_BODY_SNIPPET\t\t= 0x01000000,\n\tMAIL_FETCH_REFCOUNT_ID\t\t= 0x02000000,\n};\n\nenum mailbox_transaction_flags {\n\t/* Hide changes done in this transaction from next view sync */\n\tMAILBOX_TRANSACTION_FLAG_HIDE\t\t= 0x01,\n\t/* External transaction. Should be used for copying and appends,\n\t   but nothing else. */\n\tMAILBOX_TRANSACTION_FLAG_EXTERNAL\t= 0x02,\n\t/* Always assign UIDs to messages when saving/copying. Normally this\n\t   is done only if it can be done easily. */\n\tMAILBOX_TRANSACTION_FLAG_ASSIGN_UIDS\t= 0x04,\n\t/* Refresh the index so lookups return latest flags/modseqs */\n\tMAILBOX_TRANSACTION_FLAG_REFRESH\t= 0x08,\n\t/* Don't update caching decisions no matter what we do in this\n\t   transaction (useful for e.g. precaching) */\n\tMAILBOX_TRANSACTION_FLAG_NO_CACHE_DEC\t= 0x10,\n\t/* Sync transaction describes changes to mailbox that already happened\n\t   to another mailbox with whom we're syncing with (dsync) */\n\tMAILBOX_TRANSACTION_FLAG_SYNC\t\t= 0x20,\n\t/* Don't trigger any notifications for this transaction. This\n\t   especially means the notify plugin. This would normally be used only\n\t   with _FLAG_SYNC. */\n\tMAILBOX_TRANSACTION_FLAG_NO_NOTIFY\t= 0x40,\n};\n\nenum mailbox_sync_flags {\n\t/* Make sure we sync all external changes done to mailbox */\n\tMAILBOX_SYNC_FLAG_FULL_READ\t\t= 0x01,\n\t/* Make sure we write all our internal changes into the mailbox */\n\tMAILBOX_SYNC_FLAG_FULL_WRITE\t\t= 0x02,\n\t/* If it's not too much trouble, check if there are some changes */\n\tMAILBOX_SYNC_FLAG_FAST\t\t\t= 0x04,\n\n\t/* Don't sync expunges from our view */\n\tMAILBOX_SYNC_FLAG_NO_EXPUNGES\t\t= 0x08,\n\t/* If mailbox is currently inconsistent, fix it instead of failing. */\n\tMAILBOX_SYNC_FLAG_FIX_INCONSISTENT\t= 0x40,\n\t/* Syncing after an EXPUNGE command. This is just an informational\n\t   flag for plugins. */\n\tMAILBOX_SYNC_FLAG_EXPUNGE\t\t= 0x80,\n\t/* Force doing a full resync of indexes. */\n\tMAILBOX_SYNC_FLAG_FORCE_RESYNC\t\t= 0x100,\n\t/* FIXME: kludge until something better comes along:\n\t   Request full text search index optimization */\n\tMAILBOX_SYNC_FLAG_OPTIMIZE\t\t= 0x400\n};\n\nenum mailbox_sync_type {\n\tMAILBOX_SYNC_TYPE_EXPUNGE\t= 0x01,\n\tMAILBOX_SYNC_TYPE_FLAGS\t\t= 0x02,\n\tMAILBOX_SYNC_TYPE_MODSEQ\t= 0x04\n};\n\nstruct message_part;\nstruct mail_namespace;\nstruct mail_storage;\nstruct mail_search_args;\nstruct mail_search_result;\nstruct mail_keywords;\nstruct mail_save_context;\nstruct mailbox;\nstruct mailbox_transaction_context;\n\nstruct mailbox_status {\n\tuint32_t messages; /* STATUS_MESSAGES */\n\tuint32_t recent; /* STATUS_RECENT */\n\tuint32_t unseen; /* STATUS_UNSEEN */\n\n\tuint32_t uidvalidity; /* STATUS_UIDVALIDITY */\n\tuint32_t uidnext; /* STATUS_UIDNEXT */\n\n\tuint32_t first_unseen_seq; /* STATUS_FIRST_UNSEEN_SEQ */\n\tuint32_t first_recent_uid; /* STATUS_FIRST_RECENT_UID */\n\tuint32_t last_cached_seq; /* STATUS_LAST_CACHED_SEQ */\n\tuint64_t highest_modseq; /* STATUS_HIGHESTMODSEQ */\n\t/* 0 if no private index (STATUS_HIGHESTPVTMODSEQ) */\n\tuint64_t highest_pvt_modseq;\n\n\t/* NULL-terminated array of keywords (STATUS_KEYWORDS) */\n\tconst ARRAY_TYPE(keywords) *keywords;\n\n\t/* These flags can be permanently modified (STATUS_PERMANENT_FLAGS) */\n\tenum mail_flags permanent_flags;\n\t/* These flags can be modified (STATUS_PERMANENT_FLAGS) */\n\tenum mail_flags flags;\n\n\t/* All keywords can be permanently modified (STATUS_PERMANENT_FLAGS) */\n\tbool permanent_keywords:1;\n\t/* More keywords can be created (STATUS_PERMANENT_FLAGS) */\n\tbool allow_new_keywords:1;\n\t/* Modseqs aren't permanent (index is in memory) (STATUS_HIGHESTMODSEQ) */\n\tbool nonpermanent_modseqs:1;\n\t/* Modseq tracking has never been enabled for this mailbox\n\t   yet. (STATUS_HIGHESTMODSEQ) */\n\tbool no_modseq_tracking:1;\n\n\t/* Messages have GUIDs (always set) */\n\tbool have_guids:1;\n\t/* mailbox_save_set_guid() works (always set) */\n\tbool have_save_guids:1;\n\t/* GUIDs are always 128bit (always set) */\n\tbool have_only_guid128:1;\n};\n\nstruct mailbox_cache_field {\n\tconst char *name;\n\tint decision; /* enum mail_cache_decision_type */\n\t/* last_used is unchanged, if it's (time_t)-1 */\n\ttime_t last_used;\n};\nARRAY_DEFINE_TYPE(mailbox_cache_field, struct mailbox_cache_field);\n\nstruct mailbox_metadata {\n\tguid_128_t guid;\n\t/* sum of virtual size of all messages in mailbox */\n\tuint64_t virtual_size;\n\t/* sum of physical size of all messages in mailbox */\n\tuint64_t physical_size;\n\t/* timestamp of when the first message was saved.\n\t   (time_t)-1 if there are no mails in the mailbox. */\n\ttime_t first_save_date;\n\n\t/* Fields that have \"temp\" or \"yes\" caching decision. */\n\tconst ARRAY_TYPE(mailbox_cache_field) *cache_fields;\n\t/* Fields that should be precached */\n\tenum mail_fetch_field precache_fields;\n\n\t/* imapc backend returns this based on the remote NAMESPACE reply,\n\t   while currently other backends return \"\" and type the same as the\n\t   mailbox's real namespace type */\n\tconst char *backend_ns_prefix;\n\tenum mail_namespace_type backend_ns_type;\n};\n\nstruct mailbox_update {\n\t/* All non-zero fields are changed. */\n\tguid_128_t mailbox_guid;\n\tuint32_t uid_validity;\n\tuint32_t min_next_uid;\n\tuint32_t min_first_recent_uid;\n\tuint64_t min_highest_modseq;\n\tuint64_t min_highest_pvt_modseq;\n\t/* Modify caching decisions, terminated by name=NULL */\n\tconst struct mailbox_cache_field *cache_updates;\n};\n\nstruct mail_transaction_commit_changes {\n\t/* Unreference the pool to free memory used by these changes. */\n\tpool_t pool;\n\n\t/* UIDVALIDITY for assigned UIDs. */\n\tuint32_t uid_validity;\n\t/* UIDs assigned to saved messages. Not necessarily ascending.\n\t   If UID assignment wasn't required (e.g. LDA), this array may also be\n\t   empty. Otherwise all of the saved mails got an UID. */\n\tARRAY_TYPE(seq_range) saved_uids;\n\n\t/* number of modseq changes that couldn't be changed as requested */\n\tunsigned int ignored_modseq_changes;\n\n\t/* Changes that occurred within this transaction */\n\tenum mail_index_transaction_change changes_mask;\n\t/* User doesn't have read ACL for the mailbox, so don't show the\n\t   uid_validity / saved_uids. */\n\tbool no_read_perm;\n};\n\nstruct mailbox_sync_rec {\n\tuint32_t seq1, seq2;\n\tenum mailbox_sync_type type;\n};\nstruct mailbox_sync_status {\n\t/* There are expunges that haven't been synced yet */\n\tbool sync_delayed_expunges:1;\n};\n\nstruct mailbox_expunge_rec {\n\t/* IMAP UID */\n\tuint32_t uid;\n\t/* 128 bit GUID. If the actual GUID has a different size, this\n\t   contains last bits of its SHA1 sum. */\n\tguid_128_t guid_128;\n};\nARRAY_DEFINE_TYPE(mailbox_expunge_rec, struct mailbox_expunge_rec);\n\nenum mail_lookup_abort {\n\t/* Perform everything no matter what it takes */\n\tMAIL_LOOKUP_ABORT_NEVER = 0,\n\t/* Abort if the operation would require reading message header/body or\n\t   otherwise opening the mail file (e.g. with dbox metadata is read by\n\t   opening and reading the file). This still allows somewhat fast\n\t   operations to be performed, such as stat()ing a file. */\n\tMAIL_LOOKUP_ABORT_READ_MAIL,\n\t/* Abort if the operation can't be done fully using cache file */\n\tMAIL_LOOKUP_ABORT_NOT_IN_CACHE,\n\t/* Abort if the operation can't be done fully using cache file.\n\t * During this lookup all cache lookups that have \"no\" decision\n\t * will be changed to \"tmp\". This way the field will start to be\n\t * cached in the future. */\n\tMAIL_LOOKUP_ABORT_NOT_IN_CACHE_START_CACHING,\n};\n\nenum mail_access_type {\n\tMAIL_ACCESS_TYPE_DEFAULT = 0,\n\t/* Mail is being used for searching */\n\tMAIL_ACCESS_TYPE_SEARCH,\n\t/* Mail is being used for sorting results */\n\tMAIL_ACCESS_TYPE_SORT,\n};\n\nstruct mail {\n\t/* always set */\n\tstruct mailbox *box;\n\tstruct mailbox_transaction_context *transaction;\n\tstruct event *event;\n\tuint32_t seq, uid;\n\n\tbool expunged:1;\n\tbool saving:1; /* This mail is still being saved */\n\tbool has_nuls:1; /* message data is known to contain NULs */\n\tbool has_no_nuls:1; /* -''- known to not contain NULs */\n\n\t/* Mail's header/body stream was opened within this request.\n\t   If lookup_abort!=MAIL_LOOKUP_ABORT_NEVER, this can't become TRUE. */\n\tbool mail_stream_opened:1;\n\t/* Mail's fast metadata was accessed within this request, e.g. the mail\n\t   file was stat()ed. If mail_stream_opened==TRUE, this value isn't\n\t   accurate anymore, because some backends may always set this when\n\t   stream is opened and some don't. If lookup_abort is\n\t   MAIL_LOOKUP_ABORT_NOT_IN_CACHE, this can't become TRUE. */\n\tbool mail_metadata_accessed:1;\n\n\tenum mail_access_type access_type;\n\n\t/* If the lookup is aborted, error is set to MAIL_ERROR_NOTPOSSIBLE */\n\tenum mail_lookup_abort lookup_abort;\n};\n\nstruct mail_storage_callbacks {\n\t/* \"* OK <text>\" */\n\tvoid (*notify_ok)(struct mailbox *mailbox, const char *text,\n\t\t\t  void *context);\n\t/* \"* NO <text>\" */\n\tvoid (*notify_no)(struct mailbox *mailbox, const char *text,\n\t\t\t  void *context);\n\n};\n\nstruct mailbox_virtual_pattern {\n\tstruct mail_namespace *ns;\n\tconst char *pattern;\n};\nARRAY_DEFINE_TYPE(mailbox_virtual_patterns, struct mailbox_virtual_pattern);\nARRAY_DEFINE_TYPE(mail_storage, struct mail_storage *);\nARRAY_DEFINE_TYPE(mailboxes, struct mailbox *);\n\nextern ARRAY_TYPE(mail_storage) mail_storage_classes;\n\ntypedef void mailbox_notify_callback_t(struct mailbox *box, void *context);\n\nvoid mail_storage_init(void);\nvoid mail_storage_deinit(void);\n\n/* register all mail storages */\nvoid mail_storage_register_all(void);\n\n/* Register mail storage class with given name - all methods that are NULL\n   are set to default methods */\nvoid mail_storage_class_register(struct mail_storage *storage_class);\nvoid mail_storage_class_unregister(struct mail_storage *storage_class);\n/* Find mail storage class by name */\nstruct mail_storage *mail_storage_find_class(const char *name);\n\n/* Create a new instance of registered mail storage class with given\n   storage-specific data. If driver is NULL, it's tried to be autodetected\n   from ns location. If ns location is NULL, it uses the first storage that\n   exists. The storage is put into ns->storage. */\nint mail_storage_create(struct mail_namespace *ns, const char *driver,\n\t\t\tenum mail_storage_flags flags, const char **error_r)\n\tATTR_NULL(2);\nint mail_storage_create_full(struct mail_namespace *ns, const char *driver,\n\t\t\t     const char *data, enum mail_storage_flags flags,\n\t\t\t     struct mail_storage **storage_r,\n\t\t\t     const char **error_r) ATTR_NULL(2);\nvoid mail_storage_unref(struct mail_storage **storage);\n\n/* Returns the mail storage settings. */\nconst struct mail_storage_settings *\nmail_storage_get_settings(struct mail_storage *storage) ATTR_PURE;\nstruct mail_user *mail_storage_get_user(struct mail_storage *storage) ATTR_PURE;\n\n/* Set storage callback functions to use. */\nvoid mail_storage_set_callbacks(struct mail_storage *storage,\n\t\t\t\tstruct mail_storage_callbacks *callbacks,\n\t\t\t\tvoid *context) ATTR_NULL(3);\n\n/* Purge storage's mailboxes (freeing disk space from expunged mails),\n   if supported by the storage. Otherwise just a no-op. */\nint mail_storage_purge(struct mail_storage *storage);\n\n/* Returns the error message of last occurred error. */\nconst char * ATTR_NOWARN_UNUSED_RESULT\nmail_storage_get_last_error(struct mail_storage *storage,\n\t\t\t    enum mail_error *error_r) ATTR_NULL(2);\n/* Wrapper for mail_storage_get_last_error(); */\nconst char * ATTR_NOWARN_UNUSED_RESULT\nmailbox_get_last_error(struct mailbox *box, enum mail_error *error_r)\n\tATTR_NULL(2);\n/* Wrapper for mail_storage_get_last_error(); */\nenum mail_error mailbox_get_last_mail_error(struct mailbox *box);\n\nconst char * ATTR_NOWARN_UNUSED_RESULT\nmail_storage_get_last_internal_error(struct mail_storage *storage,\n\t\t\t\t     enum mail_error *error_r) ATTR_NULL(2);\n/* Wrapper for mail_storage_get_last_internal_error(); */\nconst char * ATTR_NOWARN_UNUSED_RESULT\nmailbox_get_last_internal_error(struct mailbox *box,\n\t\t\t\tenum mail_error *error_r) ATTR_NULL(2);\n\n/* Save the last error until it's popped. This is useful for cases where the\n   storage has already failed, but the cleanup code path changes the error to\n   something else unwanted. */\nvoid mail_storage_last_error_push(struct mail_storage *storage);\nvoid mail_storage_last_error_pop(struct mail_storage *storage);\n\n/* Returns TRUE if mailboxes are files. */\nbool mail_storage_is_mailbox_file(struct mail_storage *storage) ATTR_PURE;\n\n/* Initialize mailbox without actually opening any files or verifying that\n   it exists. Note that append and copy may open the selected mailbox again\n   with possibly different readonly-state. */\nstruct mailbox *mailbox_alloc(struct mailbox_list *list, const char *vname,\n\t\t\t      enum mailbox_flags flags);\n/* Like mailbox_alloc(), but use mailbox GUID. */\nstruct mailbox *mailbox_alloc_guid(struct mailbox_list *list,\n\t\t\t\t   const guid_128_t guid,\n\t\t\t\t   enum mailbox_flags flags);\n/* Initialize mailbox for a particular user without actually opening any files\n   or verifying that it exists. The mname parameter is normally equal to the\n   mailbox vname, except when the MAILBOX_FLAG_SPECIAL_USE flag is set, in which\n   case it is the special-use flag. */\nstruct mailbox *\nmailbox_alloc_for_user(struct mail_user *user, const char *mname,\n\t\t       enum mailbox_flags flags);\n\n/* Set a human-readable reason for why this mailbox is being accessed.\n   This is used for logging purposes. */\nvoid mailbox_set_reason(struct mailbox *box, const char *reason);\n/* Get mailbox existence state. If auto_boxes=FALSE, return\n   MAILBOX_EXISTENCE_NONE for autocreated mailboxes that haven't been\n   physically created yet */\nint mailbox_exists(struct mailbox *box, bool auto_boxes,\n\t\t   enum mailbox_existence *existence_r);\n/* Open the mailbox. If this function isn't called explicitly, it's also called\n   internally by lib-storage when necessary. */\nint mailbox_open(struct mailbox *box);\n/* Open mailbox as read-only using the given stream as input. */\nint mailbox_open_stream(struct mailbox *box, struct istream *input);\n/* Close mailbox. Same as if mailbox was freed and re-allocated. */\nvoid mailbox_close(struct mailbox *box);\n/* Close and free the mailbox. */\nvoid mailbox_free(struct mailbox **box);\n\n/* Returns TRUE if box1 points to the same mailbox as ns2/vname2. */\nbool mailbox_equals(const struct mailbox *box1,\n\t\t    const struct mail_namespace *ns2,\n\t\t    const char *vname2) ATTR_PURE;\n/* Returns TRUE if the mailbox is user's INBOX or another user's shared INBOX */\nbool mailbox_is_any_inbox(struct mailbox *box);\n\n/* Returns TRUE if the mailbox has the specified special use flag assigned. */\nbool mailbox_has_special_use(struct mailbox *box, const char *special_use);\n\n/* Change mailbox_verify_create_name() to not verify new mailbox name\n   restrictions (but still check that it's a valid existing name). This is\n   mainly used by dsync to make sure the sync works even though the original\n   name isn't valid anymore. */\nvoid mailbox_skip_create_name_restrictions(struct mailbox *box, bool set);\n/* Returns -1 if mailbox_create() is guaranteed to fail because the mailbox\n   name is invalid, 0 not. The error message contains a reason. */\nint mailbox_verify_create_name(struct mailbox *box);\n/* Create a mailbox. Returns failure if it already exists. Mailbox name is\n   allowed to contain multiple new nonexistent hierarchy levels. If directory\n   is TRUE, the mailbox should be created so that it can contain children. The\n   mailbox itself doesn't have to be created as long as it shows up in LIST.\n   If update is non-NULL, its contents are used to set initial mailbox\n   metadata. */\nint mailbox_create(struct mailbox *box, const struct mailbox_update *update,\n\t\t   bool directory) ATTR_NULL(2);\n/* Update existing mailbox's metadata. */\nint mailbox_update(struct mailbox *box, const struct mailbox_update *update);\n/* Delete mailbox (and its parent directory, if it has no siblings) */\nint mailbox_delete(struct mailbox *box);\n/* Delete mailbox, but only if it's empty. If it's not, fails with\n   MAIL_ERROR_EXISTS. */\nint mailbox_delete_empty(struct mailbox *box);\n/* Rename mailbox (and its children). Renaming across different mailbox lists\n   is possible only between private namespaces and storages of the same type.\n   If the rename fails, the error is set to src's storage. */\nint mailbox_rename(struct mailbox *src, struct mailbox *dest);\n/* Subscribe/unsubscribe mailbox. Subscribing to\n   nonexistent mailboxes is optional. */\nint mailbox_set_subscribed(struct mailbox *box, bool set);\n/* Returns TRUE if mailbox is subscribed, FALSE if not. This function\n   doesn't refresh the subscriptions list, but assumes that it's been done by\n   e.g. mailbox_list_iter*(). */\nbool mailbox_is_subscribed(struct mailbox *box);\n\n/* Enable the given feature for the mailbox. */\nint mailbox_enable(struct mailbox *box, enum mailbox_feature features);\n/* Returns all enabled features. */\nenum mailbox_feature\nmailbox_get_enabled_features(struct mailbox *box) ATTR_PURE;\n\n/* Returns storage of given mailbox */\nstruct mail_storage *mailbox_get_storage(const struct mailbox *box) ATTR_PURE;\n/* Return namespace of given mailbox. */\nstruct mail_namespace *\nmailbox_get_namespace(const struct mailbox *box) ATTR_PURE;\n/* Returns the storage's settings. */\nconst struct mail_storage_settings *\nmailbox_get_settings(struct mailbox *box) ATTR_PURE;\n/* Returns the mailbox's settings, or NULL if there are none. */\nconst struct mailbox_settings *\nmailbox_settings_find(struct mail_namespace *ns, const char *vname);\n\n/* Returns the (virtual) name of the given mailbox. */\nconst char *mailbox_get_vname(const struct mailbox *box) ATTR_PURE;\n/* Returns the backend name of given mailbox. */\nconst char *mailbox_get_name(const struct mailbox *box) ATTR_PURE;\n\n/* Returns TRUE if mailbox is read-only. */\nbool mailbox_is_readonly(struct mailbox *box);\n/* Returns TRUE if two mailboxes point to the same physical mailbox. */\nbool mailbox_backends_equal(const struct mailbox *box1,\n\t\t\t    const struct mailbox *box2);\n/* Returns TRUE if mailbox is now in inconsistent state, meaning that\n   the message IDs etc. may have changed - only way to recover this\n   would be to fully close the mailbox and reopen it. With IMAP\n   connection this would mean a forced disconnection since we can't\n   do forced CLOSE. */\nbool mailbox_is_inconsistent(struct mailbox *box);\n\n/* Gets the mailbox status information. If mailbox isn't opened yet, try to\n   return the results from mailbox list indexes. Otherwise the mailbox is\n   opened and synced. If the mailbox is already opened, no syncing is done\n   automatically. */\nint mailbox_get_status(struct mailbox *box, enum mailbox_status_items items,\n\t\t       struct mailbox_status *status_r);\n/* Gets the mailbox status, requires that mailbox is already opened. */\nvoid mailbox_get_open_status(struct mailbox *box,\n\t\t\t     enum mailbox_status_items items,\n\t\t\t     struct mailbox_status *status_r);\n/* Gets mailbox metadata */\nint mailbox_get_metadata(struct mailbox *box, enum mailbox_metadata_items items,\n\t\t\t struct mailbox_metadata *metadata_r);\n/* Returns a mask of flags that are private to user in this mailbox\n   (as opposed to flags shared between users). */\nenum mail_flags mailbox_get_private_flags_mask(struct mailbox *box);\n\n/* Synchronize the mailbox. */\nstruct mailbox_sync_context *\nmailbox_sync_init(struct mailbox *box, enum mailbox_sync_flags flags);\nbool mailbox_sync_next(struct mailbox_sync_context *ctx,\n\t\t       struct mailbox_sync_rec *sync_rec_r);\nint mailbox_sync_deinit(struct mailbox_sync_context **ctx,\n\t\t\tstruct mailbox_sync_status *status_r);\n/* One-step mailbox synchronization. Use this if you don't care about\n   changes. */\nint mailbox_sync(struct mailbox *box, enum mailbox_sync_flags flags);\n\n/* Call given callback function when something changes in the mailbox. */\nvoid mailbox_notify_changes(struct mailbox *box,\n\t\t\t    mailbox_notify_callback_t *callback, void *context)\n\tATTR_NULL(3);\n#define mailbox_notify_changes(box, callback, context) \\\n\t  mailbox_notify_changes(box, (mailbox_notify_callback_t *)callback, \\\n\t\t(void *)((char *)context - CALLBACK_TYPECHECK(callback, \\\n\t\t\tvoid (*)(struct mailbox *, typeof(context)))))\nvoid mailbox_notify_changes_stop(struct mailbox *box);\n\nstruct mailbox_transaction_context *\nmailbox_transaction_begin(struct mailbox *box,\n\t\t\t  enum mailbox_transaction_flags flags,\n\t\t\t  const char *reason);\nint mailbox_transaction_commit(struct mailbox_transaction_context **t);\nint mailbox_transaction_commit_get_changes(\n\tstruct mailbox_transaction_context **t,\n\tstruct mail_transaction_commit_changes *changes_r);\nvoid mailbox_transaction_rollback(struct mailbox_transaction_context **t);\n/* Return the number of active transactions for the mailbox. */\nunsigned int mailbox_transaction_get_count(const struct mailbox *box) ATTR_PURE;\n/* When committing transaction, drop flag/keyword updates for messages whose\n   modseq is larger than max_modseq. Save those messages' sequences to the\n   given array. */\nvoid mailbox_transaction_set_max_modseq(struct mailbox_transaction_context *t,\n\t\t\t\t\tuint64_t max_modseq,\n\t\t\t\t\tARRAY_TYPE(seq_range) *seqs);\n\nstruct mailbox *\nmailbox_transaction_get_mailbox(const struct mailbox_transaction_context *t)\n\tATTR_PURE;\n\n/* Convert uid range to sequence range. */\nvoid mailbox_get_seq_range(struct mailbox *box, uint32_t uid1, uint32_t uid2,\n\t\t\t   uint32_t *seq1_r, uint32_t *seq2_r);\n/* Convert sequence range to uid range. If sequences contain\n   (uint32_t)-1 to specify \"*\", they're preserved. */\nvoid mailbox_get_uid_range(struct mailbox *box,\n\t\t\t   const ARRAY_TYPE(seq_range) *seqs,\n\t\t\t   ARRAY_TYPE(seq_range) *uids);\n/* Get list of messages' that have been expunged after prev_modseq and that\n   exist in uids_filter range. UIDs that have been expunged after the last\n   mailbox sync aren't returned. Returns TRUE if ok, FALSE if modseq is lower\n   than we can check for (but expunged_uids is still set as best as it can). */\nbool mailbox_get_expunges(struct mailbox *box, uint64_t prev_modseq,\n\t\t\t  const ARRAY_TYPE(seq_range) *uids_filter,\n\t\t\t  ARRAY_TYPE(mailbox_expunge_rec) *expunges);\n/* Same as mailbox_get_expunges(), but return only list of UIDs. Not caring\n   about GUIDs is slightly faster. */\nbool mailbox_get_expunged_uids(struct mailbox *box, uint64_t prev_modseq,\n\t\t\t       const ARRAY_TYPE(seq_range) *uids_filter,\n\t\t\t       ARRAY_TYPE(seq_range) *expunged_uids);\n\n/* Initialize header lookup for given headers. */\nstruct mailbox_header_lookup_ctx *\nmailbox_header_lookup_init(struct mailbox *box, const char *const headers[]);\nvoid mailbox_header_lookup_ref(struct mailbox_header_lookup_ctx *ctx);\nvoid mailbox_header_lookup_unref(struct mailbox_header_lookup_ctx **ctx);\n/* Merge two header lookups. */\nstruct mailbox_header_lookup_ctx *\nmailbox_header_lookup_merge(const struct mailbox_header_lookup_ctx *hdr1,\n\t\t\t    const struct mailbox_header_lookup_ctx *hdr2);\n\n/* Initialize new search request. If sort_program is non-NULL, the messages are\n   returned in the requested order, otherwise from first to last. */\nstruct mail_search_context * ATTR_NULL(3, 5)\nmailbox_search_init(struct mailbox_transaction_context *t,\n\t\t    struct mail_search_args *args,\n\t\t    const enum mail_sort_type *sort_program,\n\t\t    enum mail_fetch_field wanted_fields,\n\t\t    struct mailbox_header_lookup_ctx *wanted_headers);\n/* Deinitialize search request. */\nint mailbox_search_deinit(struct mail_search_context **ctx);\n/* Search the next message. Returns TRUE if found, FALSE if not. */\nbool mailbox_search_next(struct mail_search_context *ctx, struct mail **mail_r);\n/* Like mailbox_search_next(), but don't spend too much time searching.\n   Returns FALSE with tryagain_r=FALSE if finished, and tryagain_r=TRUE if\n   more results will be returned by calling the function again. */\nbool mailbox_search_next_nonblock(struct mail_search_context *ctx,\n\t\t\t\t  struct mail **mail_r, bool *tryagain_r);\n/* Returns TRUE if some messages were already expunged and we couldn't\n   determine correctly if those messages should have been returned in this\n   search. */\nbool mailbox_search_seen_lost_data(struct mail_search_context *ctx);\n/* Detach the given mail from the search context. This allows the mail to live\n   even after mail_search_context has been freed. */\nvoid mailbox_search_mail_detach(struct mail_search_context *ctx,\n\t\t\t\tstruct mail *mail);\n\n/* Remember the search result for future use. This must be called before the\n   first mailbox_search_next*() call. */\nstruct mail_search_result *\nmailbox_search_result_save(struct mail_search_context *ctx,\n\t\t\t   enum mailbox_search_result_flags flags);\n/* Free memory used by search result. */\nvoid mailbox_search_result_free(struct mail_search_result **result);\n/* A simplified API for searching and saving the result. */\nint mailbox_search_result_build(struct mailbox_transaction_context *t,\n\t\t\t\tstruct mail_search_args *args,\n\t\t\t\tenum mailbox_search_result_flags flags,\n\t\t\t\tstruct mail_search_result **result_r);\n/* Return all messages' UIDs in the search result. */\nconst ARRAY_TYPE(seq_range) *\nmailbox_search_result_get(struct mail_search_result *result);\n/* Return messages that have been removed and added since the last sync call.\n   This function must not be called if search result wasn't saved with\n   _QUEUE_SYNC flag. */\nvoid mailbox_search_result_sync(struct mail_search_result *result,\n\t\t\t\tARRAY_TYPE(seq_range) *removed_uids,\n\t\t\t\tARRAY_TYPE(seq_range) *added_uids);\n\n/* Build mail_keywords from NULL-terminated keywords list. Any duplicate\n   keywords are removed. Returns 0 if successful, -1 if there are invalid\n   keywords (error is set). */\nint mailbox_keywords_create(struct mailbox *box, const char *const keywords[],\n\t\t\t    struct mail_keywords **keywords_r);\n/* Like mailbox_keywords_create(), except ignore invalid keywords. */\nstruct mail_keywords *\nmailbox_keywords_create_valid(struct mailbox *box,\n\t\t\t      const char *const keywords[]);\nstruct mail_keywords *\nmailbox_keywords_create_from_indexes(struct mailbox *box,\n\t\t\t\t     const ARRAY_TYPE(keyword_indexes) *idx);\n/* Return union of two mail_keywords. They must be created in the same\n   mailbox. */\nstruct mail_keywords *mailbox_keywords_merge(struct mail_keywords *keywords1,\n\t\t\t\t\t     struct mail_keywords *keywords2);\nvoid mailbox_keywords_ref(struct mail_keywords *keywords);\nvoid mailbox_keywords_unref(struct mail_keywords **keywords);\n/* Returns TRUE if keyword is valid, FALSE and error if not. */\nbool mailbox_keyword_is_valid(struct mailbox *box, const char *keyword,\n\t\t\t      const char **error_r);\n\n/* Initialize saving a new mail. You must not try to save more than one mail\n   at a time. */\nstruct mail_save_context *\nmailbox_save_alloc(struct mailbox_transaction_context *t);\n/* Set the flags and keywords. Nothing is set by default. */\nvoid mailbox_save_set_flags(struct mail_save_context *ctx,\n\t\t\t    enum mail_flags flags,\n\t\t\t    struct mail_keywords *keywords);\n/* Copy flags and keywords from given mail. */\nvoid mailbox_save_copy_flags(struct mail_save_context *ctx, struct mail *mail);\n/* Set message's modseq to be at least min_modseq. */\nvoid mailbox_save_set_min_modseq(struct mail_save_context *ctx,\n\t\t\t\t uint64_t min_modseq);\n/* If received date isn't specified the current time is used. timezone_offset\n   specifies the preferred timezone in minutes, but it may be ignored if\n   backend doesn't support storing it. */\nvoid mailbox_save_set_received_date(struct mail_save_context *ctx,\n\t\t\t\t    time_t received_date, int timezone_offset);\n/* Set the \"message saved\" date. This should be set only when you're\n   replicating/restoring an existing mailbox. */\nvoid mailbox_save_set_save_date(struct mail_save_context *ctx,\n\t\t\t\ttime_t save_date);\n/* Set the envelope sender. This is currently used only with mbox files to\n   specify the address in From_-line. */\nvoid mailbox_save_set_from_envelope(struct mail_save_context *ctx,\n\t\t\t\t    const char *envelope);\n/* Set message's UID. If UID is smaller than the current next_uid, it's given\n   a new UID anyway. */\nvoid mailbox_save_set_uid(struct mail_save_context *ctx, uint32_t uid);\n/* Set globally unique ID for the saved mail. A new GUID is generated by\n   default. This function should usually be called only when copying an\n   existing mail (or restoring a mail from backup). */\nvoid mailbox_save_set_guid(struct mail_save_context *ctx, const char *guid);\n/* Set message's POP3 UIDL, if the backend supports it. */\nvoid mailbox_save_set_pop3_uidl(struct mail_save_context *ctx,\n\t\t\t\tconst char *uidl);\n/* Specify ordering for POP3 messages. The default is to add them to the end\n   of the mailbox. Not all backends support this. */\nvoid mailbox_save_set_pop3_order(struct mail_save_context *ctx,\n\t\t\t\t unsigned int order);\n/* Returns the destination mail */\nstruct mail *mailbox_save_get_dest_mail(struct mail_save_context *ctx);\n/* Begin saving the message. All mail_save_set_*() calls must have been called\n   before this function. If the save initialization fails, the context is freed\n   and -1 is returned. After beginning the save you should keep calling\n   i_stream_read() and calling mailbox_save_continue() as long as there's\n   more input. */\nint mailbox_save_begin(struct mail_save_context **ctx, struct istream *input);\nint mailbox_save_continue(struct mail_save_context *ctx);\nint mailbox_save_finish(struct mail_save_context **ctx);\nvoid mailbox_save_cancel(struct mail_save_context **ctx);\n\nstruct mailbox_transaction_context *\nmailbox_save_get_transaction(struct mail_save_context *ctx);\n\n/* Copy the given message. You'll need to specify the flags etc. using the\n   mailbox_save_*() functions. */\nint mailbox_copy(struct mail_save_context **ctx, struct mail *mail);\n/* Move the given message. This is usually equivalent to copy+expunge,\n   but without enforcing quota. */\nint mailbox_move(struct mail_save_context **ctx, struct mail *mail);\n/* Same as mailbox_copy(), but treat the message as if it's being saved,\n   not copied. (For example: New mail delivered to multiple maildirs, with\n   each mails being hard link copies.) */\nint mailbox_save_using_mail(struct mail_save_context **ctx, struct mail *mail);\n\nstruct mail *mail_alloc(struct mailbox_transaction_context *t,\n\t\t\tenum mail_fetch_field wanted_fields,\n\t\t\tstruct mailbox_header_lookup_ctx *wanted_headers)\n\tATTR_NULL(3);\nvoid mail_free(struct mail **mail);\nvoid mail_set_seq(struct mail *mail, uint32_t seq);\n/* Returns TRUE if successful, FALSE if message doesn't exist.\n   mail_*() functions shouldn't be called if FALSE is returned. */\nbool mail_set_uid(struct mail *mail, uint32_t uid);\n\n/* Add wanted fields/headers on top of existing ones. These will be forgotten\n   after the next mail_set_seq/uid() that closes the existing mail. Note that\n   it's valid to call this function while there is no mail assigned\n   (mail->seq==0), i.e. this is called before any mail_set_seq/uid() or after\n   mail.close(). */\nvoid mail_add_temp_wanted_fields(struct mail *mail,\n\t\t\t\t enum mail_fetch_field fields,\n\t\t\t\t struct mailbox_header_lookup_ctx *headers)\n\tATTR_NULL(3);\n\n/* Returns message's flags */\nenum mail_flags mail_get_flags(struct mail *mail);\n/* Returns message's keywords */\nconst char *const *mail_get_keywords(struct mail *mail);\n/* Returns message's keywords */\nconst ARRAY_TYPE(keyword_indexes) *mail_get_keyword_indexes(struct mail *mail);\n/* Returns message's modseq */\nuint64_t mail_get_modseq(struct mail *mail);\n/* Returns message's private modseq, or 0 if message hasn't had any\n   private flag changes. This is useful only for shared mailboxes that have\n   a private index defined. */\nuint64_t mail_get_pvt_modseq(struct mail *mail);\n\n/* Returns message's MIME parts */\nint mail_get_parts(struct mail *mail, struct message_part **parts_r);\n\n/* Get the Date-header of the mail. Timezone is in minutes. date=0 if it\n   wasn't found or it was invalid. */\nint mail_get_date(struct mail *mail, time_t *date_r, int *timezone_r);\n/* Get the time when the mail was received (IMAP INTERNALDATE). */\nint mail_get_received_date(struct mail *mail, time_t *date_r);\n/* Get the time when the mail was saved into this mailbox. This returns -1 on\n   error, 0 if a real save date is not supported and a fall-back date is used,\n   and 1 when a save date was successfully retrieved. */\nint mail_get_save_date(struct mail *mail, time_t *date_r);\n\n/* Get the space used by the mail as seen by the reader. Linefeeds are always\n   counted as being CR+LF. */\nint mail_get_virtual_size(struct mail *mail, uoff_t *size_r);\n/* Get the size of the stream returned by mail_get_stream(). */\nint mail_get_physical_size(struct mail *mail, uoff_t *size_r);\n\n/* Get value for single header field, or NULL if header wasn't found.\n   Returns 1 if header was found, 0 if not, -1 if error. */\nint mail_get_first_header(struct mail *mail, const char *field,\n\t\t\t  const char **value_r);\n/* Like mail_get_first_header(), but decode MIME encoded words to UTF-8.\n   Also multiline headers are returned unfolded.\n\n   Do not use this function for getting structured fields (e.g. address fields),\n   because decoding may break the structuring. Instead parse them first and\n   only afterwards decode the encoded words. */\nint mail_get_first_header_utf8(struct mail *mail, const char *field,\n\t\t\t       const char **value_r);\n/* Return a NULL-terminated list of values for each found field.\n   Returns 1 if headers were found, 0 if not (value_r[0]==NULL) or\n   -1 if error. */\nint mail_get_headers(struct mail *mail, const char *field,\n\t\t     const char *const **value_r);\n/* Like mail_get_headers(), but decode MIME encoded words to UTF-8.\n   Also multiline headers are returned unfolded.\n   Do not use for structured fields (see mail_get_first_header_utf8()). */\nint mail_get_headers_utf8(struct mail *mail, const char *field,\n\t\t\t  const char *const **value_r);\n/* Returns stream containing specified headers. The returned stream will be\n   automatically freed when the mail is closed, or when another\n   mail_get_header_stream() call is made (so you can't have multiple header\n   streams open at the same time). */\nint mail_get_header_stream(struct mail *mail,\n\t\t\t   struct mailbox_header_lookup_ctx *headers,\n\t\t\t   struct istream **stream_r);\n/* Returns input stream pointing to beginning of message header.\n   hdr_size and body_size are updated unless they're NULL. The returned stream\n   is destroyed automatically, don't unreference it. */\nint mail_get_stream(struct mail *mail, struct message_size *hdr_size,\n\t\t    struct message_size *body_size, struct istream **stream_r)\n\tATTR_NULL(2, 3);\n/* Same as mail_get_stream(), but specify a reason why the mail is being read.\n   This can be useful for debugging purposes. */\nint mail_get_stream_because(struct mail *mail, struct message_size *hdr_size,\n\t\t\t    struct message_size *body_size,\n\t\t\t    const char *reason, struct istream **stream_r)\n\tATTR_NULL(2, 3);\n/* Similar to mail_get_stream(), but the stream may or may not contain the\n   message body. */\nint mail_get_hdr_stream(struct mail *mail, struct message_size *hdr_size,\n\t\t\tstruct istream **stream_r) ATTR_NULL(2);\n/* Same as mail_get_hdr_stream(), but specify a reason why the header is being\n   read. This can be useful for debugging purposes. */\nint mail_get_hdr_stream_because(struct mail *mail,\n\t\t\t\tstruct message_size *hdr_size,\n\t\t\t\tconst char *reason, struct istream **stream_r);\n/* Returns the message part's body decoded to 8bit binary. If the\n   Content-Transfer-Encoding isn't supported, returns -1 and sets error to\n   MAIL_ERROR_CONVERSION. If the part refers to a multipart, all of its\n   children are returned decoded. */\nint mail_get_binary_stream(struct mail *mail, const struct message_part *part,\n\t\t\t   bool include_hdr, uoff_t *size_r,\n\t\t\t   bool *binary_r, struct istream **stream_r);\n/* Like mail_get_binary_stream(), but only return the size. */\nint mail_get_binary_size(struct mail *mail, const struct message_part *part,\n\t\t\t bool include_hdr, uoff_t *size_r,\n\t\t\t unsigned int *lines_r);\n\n/* Get any of the \"special\" fields. Unhandled specials are returned as \"\". */\nint mail_get_special(struct mail *mail, enum mail_fetch_field field,\n\t\t     const char **value_r);\n/* Returns the mail for the physical message. Normally this is the mail itself,\n   but in virtual mailboxes it points to the backend mailbox. */\nint mail_get_backend_mail(struct mail *mail, struct mail **real_mail_r);\n\n/* Retrieve and parse the value of the Message-ID header field. Returns 1 if the\n   header was found and it contains a valid message ID, 0 if the header was not\n   found or no valid message ID was contained in it, and -1 if an error occurred\n   while retrieving the header. Returns the message ID value including '<' and\n   '>' in the *value_r return parameter or NULL if the header wasn't found or\n   its value was invalid. */\nint mail_get_message_id(struct mail *mail, const char **value_r);\n\n/* Update message flags. */\nvoid mail_update_flags(struct mail *mail, enum modify_type modify_type,\n\t\t       enum mail_flags flags);\n/* Update message keywords. */\nvoid mail_update_keywords(struct mail *mail, enum modify_type modify_type,\n\t\t\t  struct mail_keywords *keywords);\n/* Update message's modseq to be at least min_modseq. */\nvoid mail_update_modseq(struct mail *mail, uint64_t min_modseq);\n/* Update message's private modseq to be at least min_pvt_modseq. */\nvoid mail_update_pvt_modseq(struct mail *mail, uint64_t min_pvt_modseq);\n\n/* Update message's POP3 UIDL (if possible). */\nvoid mail_update_pop3_uidl(struct mail *mail, const char *uidl);\n/* Expunge this message. Sequence numbers don't change until commit. */\nvoid mail_expunge(struct mail *mail);\n\n/* Add missing fields to cache. */\nvoid mail_precache(struct mail *mail);\n/* Mark a cached field corrupted and have it recalculated. */\nvoid mail_set_cache_corrupted(struct mail *mail,\n\t\t\t      enum mail_fetch_field field,\n\t\t\t      const char *reason);\n\n/* Return 128 bit GUID using input string. If guid is already 128 bit hex\n   encoded, it's returned as-is. Otherwise SHA1 sum is taken and its last\n   128 bits are returned. */\nvoid mail_generate_guid_128_hash(const char *guid, guid_128_t guid_128_r);\n\n/* Parse a human-writable string into a timestamp. utc_r controls whether\n   the returned timestamp should be treated as an exact UTC time (TRUE), or\n   whether this is a human-given date where the timestamp could be adjusted\n   by the matched mails' timezones (see MAIL_SEARCH_ARG_FLAG_USE_TZ).\n\n   Returns 0 and timestamp on success, -1 if the string couldn't be parsed.\n   Currently supported string formats: yyyy-mm-dd (utc=FALSE),\n   imap date (utc=FALSE), unix timestamp (utc=TRUE), interval (e.g. n days,\n   utc=TRUE). */\nint mail_parse_human_timestamp(const char *str, time_t *timestamp_r,\n\t\t\t       bool *utc_r);\n\n#endif\n"}, "13": {"id": 13, "path": "/home/runner/work/testcc/testcc/retdec/src/lib-storage/mail-user.h", "content": "#ifndef MAIL_USER_H\n#define MAIL_USER_H\n\n#include \"net.h\"\n#include \"unichar.h\"\n#include \"mail-storage-settings.h\"\n\nstruct module;\nstruct stats;\nstruct fs_settings;\nstruct ssl_iostream_settings;\nstruct mail_user;\n\nstruct mail_user_vfuncs {\n\tvoid (*deinit)(struct mail_user *user);\n\tvoid (*deinit_pre)(struct mail_user *user);\n\tvoid (*stats_fill)(struct mail_user *user, struct stats *stats);\n};\n\nstruct mail_user_connection_data {\n\tstruct ip_addr *local_ip, *remote_ip;\n\tin_port_t local_port, remote_port;\n\n\tbool secured:1;\n\tbool ssl_secured:1;\n};\n\nstruct mail_user {\n\tpool_t pool;\n\tstruct mail_user_vfuncs v, *vlast;\n\tint refcount;\n\n\tstruct event *event;\n\t/* User's creator if such exists. For example for autocreated shared\n\t   mailbox users their creator is the logged in user. */\n\tstruct mail_user *creator;\n\t/* Set if user was created via mail_storage_service. */\n\tstruct mail_storage_service_user *_service_user;\n\n\tconst char *username;\n\t/* don't access the home directly. It may be set lazily. */\n\tconst char *_home;\n\n\tuid_t uid;\n\tgid_t gid;\n\tconst char *service;\n\tconst char *session_id;\n\tstruct mail_user_connection_data conn;\n\tconst char *auth_mech, *auth_token, *auth_user;\n\tconst char *const *userdb_fields;\n\t/* Timestamp when this session was initially created. Most importantly\n\t   this stays the same after IMAP client is hibernated and restored. */\n\ttime_t session_create_time;\n\n\tconst struct var_expand_table *var_expand_table;\n\t/* If non-NULL, fail the user initialization with this error.\n\t   This could be set by plugins that need to fail the initialization. */\n\tconst char *error;\n\n\tconst struct setting_parser_info *set_info;\n\tconst struct mail_user_settings *unexpanded_set;\n\tstruct mail_user_settings *set;\n\tstruct mail_namespace *namespaces;\n\tstruct mail_storage *storages;\n\tARRAY(const struct mail_storage_hooks *) hooks;\n\n\tnormalizer_func_t *default_normalizer;\n\t/* Filled lazily by mailbox_attribute_*() when accessing attributes. */\n\tstruct dict *_attr_dict;\n\n\t/* Module-specific contexts. See mail_storage_module_id. */\n\tARRAY(union mail_user_module_context *) module_contexts;\n\n\t/* User doesn't exist (as reported by userdb lookup when looking\n\t   up home) */\n\tbool nonexistent:1;\n\t/* Either home is set or there is no home for the user. */\n\tbool home_looked_up:1;\n\t/* User is anonymous */\n\tbool anonymous:1;\n\t/* This is an autocreated user (e.g. for shared namespace or\n\t   lda raw storage) */\n\tbool autocreated:1;\n\t/* mail_user_init() has been called */\n\tbool initialized:1;\n\t/* The initial namespaces have been created and\n\t   hook_mail_namespaces_created() has been called. */\n\tbool namespaces_created:1;\n\t/* SET_STR_VARS in user's all settings have been expanded.\n\t   This happens near the beginning of the user initialization,\n\t   so this is rarely needed to be checked. */\n\tbool settings_expanded:1;\n\t/* Shortcut to mail_storage_settings.mail_debug */\n\tbool mail_debug:1;\n\t/* If INBOX can't be opened, log an error, but only once. */\n\tbool inbox_open_error_logged:1;\n\t/* Fuzzy search works for this user (FTS enabled) */\n\tbool fuzzy_search:1;\n\t/* We're running dsync */\n\tbool dsyncing:1;\n\t/* Failed to create attribute dict, don't try again */\n\tbool attr_dict_failed:1;\n\t/* We're deinitializing the user */\n\tbool deinitializing:1;\n\t/* Enable administrator user commands for the user */\n\tbool admin:1;\n\t/* Enable all statistics gathering */\n\tbool stats_enabled:1;\n\t/* This session was restored (e.g. IMAP unhibernation) */\n\tbool session_restored:1;\n};\n\nstruct mail_user_module_register {\n\tunsigned int id;\n};\n\nunion mail_user_module_context {\n\tstruct mail_user_vfuncs super;\n\tstruct mail_user_module_register *reg;\n};\nextern struct mail_user_module_register mail_user_module_register;\nextern struct auth_master_connection *mail_user_auth_master_conn;\nextern const struct var_expand_func_table *mail_user_var_expand_func_table;\n\nstruct mail_user *mail_user_alloc(struct event *parent_event,\n\t\t\t\t  const char *username,\n\t\t\t\t  const struct setting_parser_info *set_info,\n\t\t\t\t  const struct mail_user_settings *set);\nstruct mail_user *\nmail_user_alloc_nodup_set(struct event *parent_event,\n\t\t\t  const char *username,\n\t\t\t  const struct setting_parser_info *set_info,\n\t\t\t  const struct mail_user_settings *set);\n/* Returns -1 if settings were invalid. */\nint mail_user_init(struct mail_user *user, const char **error_r);\n\nvoid mail_user_ref(struct mail_user *user);\nvoid mail_user_unref(struct mail_user **user);\n/* Assert that this is the last reference for the user and unref it. */\nvoid mail_user_deinit(struct mail_user **user);\n\n/* Duplicate a mail_user. mail_user_init() and mail_namespaces_init() need to\n   be called before the user is usable. */\nstruct mail_user *mail_user_dup(struct mail_user *user);\n\n/* Find another user from the given user's namespaces. */\nstruct mail_user *mail_user_find(struct mail_user *user, const char *name);\n\n/* Specify mail location %variable expansion data. */\nvoid mail_user_set_vars(struct mail_user *user, const char *service,\n\t\t\tconst struct mail_user_connection_data *conn);\n/* Return %variable expansion table for the user. */\nconst struct var_expand_table *\nmail_user_var_expand_table(struct mail_user *user);\n\n/* Specify the user's home directory. This should be called also when it's\n   known that the user doesn't have a home directory to avoid the internal\n   lookup. */\nvoid mail_user_set_home(struct mail_user *user, const char *home);\n/* Get the home directory for the user. Returns 1 if home directory looked up\n   successfully, 0 if there is no home directory (either user doesn't exist or\n   has no home directory) or -1 if lookup failed. */\nint mail_user_get_home(struct mail_user *user, const char **home_r);\n/* Appends path + file prefix for creating a temporary file.\n   The file prefix doesn't contain any uniqueness. */\nvoid mail_user_set_get_temp_prefix(string_t *dest,\n\t\t\t\t   const struct mail_user_settings *set);\n/* Returns 1 on success, 0 if lock_secs is reached, -1 on error */\nint mail_user_lock_file_create(struct mail_user *user, const char *lock_fname,\n\t\t\t       unsigned int lock_secs,\n\t\t\t       struct file_lock **lock_r, const char **error_r);\n\n/* Returns TRUE if plugin is loaded for the user. */\nbool mail_user_is_plugin_loaded(struct mail_user *user, struct module *module);\n/* If name exists in plugin_envs, return its value. */\nconst char *mail_user_plugin_getenv(struct mail_user *user, const char *name);\nbool mail_user_plugin_getenv_bool(struct mail_user *user, const char *name);\nconst char *mail_user_set_plugin_getenv(const struct mail_user_settings *set,\n\t\t\t\t\tconst char *name);\nbool mail_user_set_plugin_getenv_bool(const struct mail_user_settings *set,\n\t\t\t\t      const char *name);\n\n/* Add more namespaces to user's namespaces. The ->next pointers may be\n   changed, so the namespaces pointer will be updated to user->namespaces. */\nvoid mail_user_add_namespace(struct mail_user *user,\n\t\t\t     struct mail_namespace **namespaces);\n/* Drop autocreated shared namespaces that don't have any \"usable\" mailboxes. */\nvoid mail_user_drop_useless_namespaces(struct mail_user *user);\n\n/* Replace ~/ at the beginning of the path with the user's home directory. */\nconst char *mail_user_home_expand(struct mail_user *user, const char *path);\n/* Returns 0 if ok, -1 if home directory isn't set. */\nint mail_user_try_home_expand(struct mail_user *user, const char **path);\n/* Returns unique user+ip identifier for anvil. */\nconst char *mail_user_get_anvil_userip_ident(struct mail_user *user);\n\n/* Basically the same as mail_storage_find_class(), except automatically load\n   storage plugins when needed. */\nstruct mail_storage *\nmail_user_get_storage_class(struct mail_user *user, const char *name);\n\n/* Initialize SSL client settings from mail_user settings. */\nvoid mail_user_init_ssl_client_settings(struct mail_user *user,\n\t\t\t\tstruct ssl_iostream_settings *ssl_set);\n\n/* Initialize fs_settings from mail_user settings. */\nvoid mail_user_init_fs_settings(struct mail_user *user,\n\t\t\t\tstruct fs_settings *fs_set,\n\t\t\t\tstruct ssl_iostream_settings *ssl_set);\n\n/* Fill statistics for user. By default there are no statistics, so stats\n   plugin must be loaded to have anything filled. */\nvoid mail_user_stats_fill(struct mail_user *user, struct stats *stats);\n\n/* Try to mkdir() user's home directory. Ideally this should be called only\n   after the caller tries to create a file to the home directory, but it fails\n   with ENOENT. This way it avoids unnecessary disk IO to the home. */\nint mail_user_home_mkdir(struct mail_user *user);\n\n/* Obtain the postmaster address to be used for this user as an RFC 5322 (IMF)\n   address. Returns false if the configured postmaster address is invalid in\n   which case error_r contains the error message. */\nstatic inline bool\nmail_user_get_postmaster_address(struct mail_user *user,\n\t\t\t\t const struct message_address **address_r,\n\t\t\t\t const char **error_r)\n{\n\treturn mail_user_set_get_postmaster_address(user->set, address_r,\n\t\t\t\t\t\t    error_r);\n}\n\n/* Obtain the postmaster address to be used for this user as an RFC 5321 (SMTP)\n   address. Returns false if the configured postmaster address is invalid in\n   which case error_r contains the error message. */\nstatic inline bool\nmail_user_get_postmaster_smtp(struct mail_user *user,\n\t\t\t      const struct smtp_address **address_r,\n\t\t\t      const char **error_r)\n{\n\treturn mail_user_set_get_postmaster_smtp(user->set, address_r,\n\t\t\t\t\t\t error_r);\n}\n\n#endif\n"}, "14": {"id": 14, "path": "/home/runner/work/testcc/testcc/retdec/src/lib-storage/mailbox-attribute.h", "content": "#ifndef MAILBOX_ATTRIBUTE_H\n#define MAILBOX_ATTRIBUTE_H\n\n/*\n * Attribute Handling in Dovecot\n * =============================\n *\n * What IMAP & doveadm users see gets translated into one of several things\n * depending on if we're operating on a mailbox or on server metadata (\"\"\n * mailbox in IMAP parlance).  Consider these examples:\n *\n *\t/private/foo\n *\t/shared/foo\n *\n * Here \"foo\" can be any RFC defined attribute name, or a vendor-prefixed\n * non-standard name.  (Our vendor prefix is \"vendor/vendor.dovecot\".)\n *\n * In all cases, the \"/private\" and \"/shared\" user visible prefixes get\n * replaced by priv/<GUID> and shared/<GUID>, respectively.  (Here, <GUID>\n * is the GUID of the mailbox with which the attribute is associated.)  This\n * way, attributes for all mailboxes can be stored in a single dict.  For\n * example, the above examples would map to:\n *\n *\tpriv/<GUID>/foo\n *\tshared/<GUID>/foo\n *\n * More concrete examples:\n *\n *\t/private/comment\n *\t/private/vendor/vendor.dovecot/abc\n *\n * turn into:\n *\n *\tpriv/<GUID>/comment\n *\tpriv/<GUID>/vendor/vendor.dovecot/abc\n *\n * Server attributes, that is attributes not associated with a mailbox, are\n * stored in the INBOX mailbox with a special prefix -\n * vendor/vendor.dovecot/pvt/server.  For example, the server attribute\n * /private/comment gets mapped to:\n *\n *\tpriv/<INBOX GUID>/vendor/vendor.dovecot/pvt/server/comment\n *\n * This means that if we set a /private/comment server attribute as well as\n * /private/comment INBOX mailbox attribute, we'll see the following paths\n * used in the dict:\n *\n *\tpriv/<INBOX GUID>/comment                                   <- mailbox attr\n *\tpriv/<INBOX GUID>/vendor/vendor.dovecot/pvt/server/comment  <- server attr\n *\n * The case of vendor specific server attributes is a bit confusing, but\n * consistent.  For example, this server attribute:\n *\n *\t/private/vendor/vendor.dovecot/abc\n *\n * It will get mapped to:\n *\n *\tpriv/<INBOX GUID>/vendor/vendor.dovecot/pvt/server/vendor/vendor.dovecot/abc\n *\t                  |                              | |                       |\n *\t                  \\----- server attr prefix -----/ \\-- server attr name ---/\n *\n *\n * Internal Attributes\n * -------------------\n *\n * The final aspect of attribute handling in Dovecot are the so called\n * \"internal attributes\".\n *\n * The easiest way to explain internal attributes is to summarize attributes\n * in general.  Attributes are just <key,value> pairs that are stored in a\n * dict.  The key is mangled according to the above rules before passed to\n * the dict code.  That is, the key already encodes whether the attribute is\n * private or shared, the GUID of the mailbox (or of INBOX for server\n * attributes), etc.  There is no processing of the value.  It is stored and\n * returned to clients verbatim.\n *\n * Internal attributes, on the other hand, are special cased attributes.\n * That is, the code contains a list of specific attribute names and how to\n * handle them.  Each internal attribute is defined by a struct\n * mailbox_attribute_internal.  It contains the pre-parsed name of the\n * attribute (type, key, and flags), and how to handle getting and setting\n * of the attribute (rank, get, and set).\n *\n * The values for these attributes may come from two places - from the\n * attributes dict, or from the get function pointer.  Which source to use\n * is identified by the rank (MAIL_ATTRIBUTE_INTERNAL_RANK_*).\n *\n *\n * Access\n * ------\n *\n * In general, a user (IMAP or doveadm) can access all attributes for a\n * mailbox.  The one exception are attributes under:\n *\n *\t/private/vendor/vendor.dovecot/pvt\n *\t/shared/vendor/vendor.dovecot/pvt\n *\n * Which as you may recall map to:\n *\n *\tpriv/<GUID>/vendor/vendor.dovecot/pvt\n *\tshared/<GUID>/vendor/vendor.dovecot/pvt\n *\n * These are deemed internal to Dovecot, and therefore of no concern to the\n * user.\n *\n * Server attributes have a similar restriction.  That is, attributes\n * beginning with the following are not accessible:\n *\n *\t/private/vendor/vendor.dovecot/pvt\n *\t/shared/vendor/vendor.dovecot/pvt\n *\n * However since server attributes are stored under the INBOX mailbox, these\n * paths map to:\n *\n *\tpriv/<INBOX GUID>/vendor/vendor.dovecot/pvt/server/vendor/vendor.dovecot/pvt\n *\tshared/<INBOX GUID>/vendor/vendor.dovecot/pvt/server/vendor/vendor.dovecot/pvt\n *\n * As a result, the code performs access checks via the\n * MAILBOX_ATTRIBUTE_KEY_IS_USER_ACCESSIBLE() macro to make sure that the\n * user is allowed access to the attribute.\n *\n *\n * Nicknames\n * ---------\n *\n * Since every path stored in the dict begins with priv/<GUID> or\n * shared/<GUID>, these prefixes are often omitted.  This also matches the\n * internal implementation where the priv/ or shared/ prefix is specified\n * using an enum, and only the path after the GUID is handled as a string.\n * For example:\n *\n *\tpriv/<GUID>/vendor/vendor.dovecot/pvt/server/foo\n *\n * would be referred to as:\n *\n *\tvendor/vendor.dovecot/pvt/server/foo\n *\n * Since some of the generated paths are very long, developers often use a\n * shorthand to refer to some of these paths.  For example,\n *\n *\tpvt/server/pvt\n *\n * is really:\n *\n *\tvendor/vendor.dovecot/pvt/server/vendor/vendor.dovecot/pvt\n *\n * Which when fully specified with a type and INBOX's GUID would turn into\n * one of the following:\n *\n *\tpriv/<GUID>/vendor/vendor.dovecot/pvt/server/vendor/vendor.dovecot/pvt\n *\tshared/<GUID>/vendor/vendor.dovecot/pvt/server/vendor/vendor.dovecot/pvt\n */\n\nstruct mailbox;\nstruct mailbox_transaction_context;\n\n/* RFC 5464 specifies that this is vendor/<vendor-token>/. The registered\n   vendor-tokens always begin with \"vendor.\" so there's some redundancy.. */\n#define MAILBOX_ATTRIBUTE_PREFIX_DOVECOT \"vendor/vendor.dovecot/\"\n/* Prefix used for attributes reserved for Dovecot's internal use. Normal\n   users cannot access these in any way. */\n#define MAILBOX_ATTRIBUTE_PREFIX_DOVECOT_PVT \\\n\tMAILBOX_ATTRIBUTE_PREFIX_DOVECOT\"pvt/\"\n/* Server attributes are currently stored in INBOX under this private prefix.\n   They're under the pvt/ prefix so they won't be listed as regular INBOX\n   attributes, but unlike other pvt/ attributes it's actually possible to\n   access these attributes as regular users.\n\n   If INBOX is deleted, attributes under this prefix are preserved. */\n#define MAILBOX_ATTRIBUTE_PREFIX_DOVECOT_PVT_SERVER \\\n\tMAILBOX_ATTRIBUTE_PREFIX_DOVECOT_PVT\"server/\"\n\n/* User can get/set all non-pvt/ attributes and also pvt/server/\n   (but not pvt/server/pvt/) attributes. */\n#define MAILBOX_ATTRIBUTE_KEY_IS_USER_ACCESSIBLE(key) \\\n\t(!str_begins(key, MAILBOX_ATTRIBUTE_PREFIX_DOVECOT_PVT) || \\\n\t (str_begins(key, MAILBOX_ATTRIBUTE_PREFIX_DOVECOT_PVT_SERVER) && \\\n\t  strncmp(key, MAILBOX_ATTRIBUTE_PREFIX_DOVECOT_PVT_SERVER MAILBOX_ATTRIBUTE_PREFIX_DOVECOT_PVT, \\\n\t\t strlen(MAILBOX_ATTRIBUTE_PREFIX_DOVECOT_PVT_SERVER MAILBOX_ATTRIBUTE_PREFIX_DOVECOT_PVT)) != 0))\n\nenum mail_attribute_type {\n\tMAIL_ATTRIBUTE_TYPE_PRIVATE,\n\tMAIL_ATTRIBUTE_TYPE_SHARED\n};\n#define MAIL_ATTRIBUTE_TYPE_MASK\t\t0x0f\n/* Allow accessing only attributes with\n   MAIL_ATTRIBUTE_INTERNAL_FLAG_VALIDATED. */\n#define MAIL_ATTRIBUTE_TYPE_FLAG_VALIDATED\t0x80\n\nenum mail_attribute_value_flags {\n\tMAIL_ATTRIBUTE_VALUE_FLAG_READONLY\t= 0x01,\n\tMAIL_ATTRIBUTE_VALUE_FLAG_INT_STREAMS\t= 0x02\n};\n\nstruct mail_attribute_value {\n\t/* mailbox_attribute_set() can set either value or value_stream.\n\t   mailbox_attribute_get() returns only values, but\n\t   mailbox_attribute_get_stream() may return either value or\n\t   value_stream. The caller must unreference the returned streams. */\n\tconst char *value;\n\tstruct istream *value_stream;\n\n\t/* Last time the attribute was changed (0 = unknown). This may be\n\t   returned even for values that don't exist anymore. */\n\ttime_t last_change;\n\n\tenum mail_attribute_value_flags flags;\n};\n\n/*\n * Internal attribute\n */\n\nenum mail_attribute_internal_rank {\n\t/* The internal attribute serves only as a source for a default value\n\t   when the normal mailbox attribute storage has no entry for this\n\t   attribute. Otherwise it is ignored. The `set' function is called\n\t   only as a notification, not with the intention to store the value.\n\t   The value is always assigned to the normal mailbox attribute storage. \n\t */\n\tMAIL_ATTRIBUTE_INTERNAL_RANK_DEFAULT = 0,\n\t/* The internal attribute serves as the main source of the attribute\n\t   value. If the `get' function returns 0, the normal mailbox attribute\n\t   storage is attempted to obtain the value. The `set' function is\n\t   called only as a notification, not with the intention to store the\n\t   value. The value is assigned to the normal mailbox attribute storage.\n\t */\n\tMAIL_ATTRIBUTE_INTERNAL_RANK_OVERRIDE,\n\t/* The value for the internal attribute is never read from the normal\n\t   mailbox attribute storage. If the `set' function is NULL, the\n\t   attribute is read-only. If it is not NULL it is used to assign the\n\t   attribute value; it is not assigned to the normal mailbox attribute\n\t   storage.\n\t */\n\tMAIL_ATTRIBUTE_INTERNAL_RANK_AUTHORITY\n};\n\nenum mail_attribute_internal_flags {\n\t/* Apply this attribute to the given key and its children. */\n\tMAIL_ATTRIBUTE_INTERNAL_FLAG_CHILDREN\t= 0x01,\n\t/* This attribute can be set/get even without generic METADATA support.\n\t   These attributes don't count towards any quotas either, so the set()\n\t   callback should validate that the value isn't excessively large. */\n\tMAIL_ATTRIBUTE_INTERNAL_FLAG_VALIDATED\t= 0x02,\n};\n\nstruct mailbox_attribute_internal {\n\tenum mail_attribute_type type;\n\tconst char *key; /* relative to the GUID, e.g., \"comment\" */\n\tenum mail_attribute_internal_rank rank;\n\tenum mail_attribute_internal_flags flags;\n\n\t/* Get the value of this internal attribute */\n\tint (*get)(struct mailbox *box, const char *key,\n\t\t   struct mail_attribute_value *value_r);\n\t/* Set the value of this internal attribute */\n\tint (*set)(struct mailbox_transaction_context *t, const char *key,\n\t\t   const struct mail_attribute_value *value);\n\t/* If non-NULL, the function is responsible for iterating the\n\t   attribute. Typically this would be used for attributes with\n\t   MAIL_ATTRIBUTE_INTERNAL_FLAG_CHILDREN to get the children\n\t   iterated. If key_prefix is \"\", all keys should be returned.\n\t   Otherwise only the keys beginning with key_prefix should be\n\t   returned. The key_prefix is already relative to the\n\t   mailbox_attribute_internal.key. */\n\tint (*iter)(struct mailbox *box, const char *key_prefix,\n\t\t    pool_t pool, ARRAY_TYPE(const_string) *keys);\n};\n\nvoid mailbox_attribute_register_internal(\n\tconst struct mailbox_attribute_internal *iattr);\nvoid mailbox_attribute_register_internals(\n\tconst struct mailbox_attribute_internal *iattrs, unsigned int count);\n\nvoid mailbox_attribute_unregister_internal(\n\tconst struct mailbox_attribute_internal *iattr);\nvoid mailbox_attribute_unregister_internals(\n\tconst struct mailbox_attribute_internal *iattrs, unsigned int count);\n\n/*\n * Attribute API\n */\n\n/* Set mailbox attribute key to value. The key should be compatible with\n   IMAP METADATA, so for Dovecot-specific keys use\n   MAILBOX_ATTRIBUTE_PREFIX_DOVECOT. */\nint mailbox_attribute_set(struct mailbox_transaction_context *t,\n\t\t\t  enum mail_attribute_type type_flags, const char *key,\n\t\t\t  const struct mail_attribute_value *value);\n/* Delete mailbox attribute key. This is just a wrapper to\n   mailbox_attribute_set() with value->value=NULL. */\nint mailbox_attribute_unset(struct mailbox_transaction_context *t,\n\t\t\t    enum mail_attribute_type type_flags, const char *key);\n/* Returns value for mailbox attribute key. Returns 1 if value was returned,\n   0 if value wasn't found (set to NULL), -1 if error */\nint mailbox_attribute_get(struct mailbox *box,\n\t\t\t  enum mail_attribute_type type_flags, const char *key,\n\t\t\t  struct mail_attribute_value *value_r);\n/* Same as mailbox_attribute_get(), but the returned value may be either an\n   input stream or a string. */\nint mailbox_attribute_get_stream(struct mailbox *box,\n\t\t\t\t enum mail_attribute_type type_flags,\n\t\t\t\t const char *key,\n\t\t\t\t struct mail_attribute_value *value_r);\n\n/* Iterate through mailbox attributes of the given type. The prefix can be used\n   to restrict what attributes are returned. */\nstruct mailbox_attribute_iter *\nmailbox_attribute_iter_init(struct mailbox *box,\n\t\t\t    enum mail_attribute_type type_flags,\n\t\t\t    const char *prefix);\n/* Returns the attribute key or NULL if there are no more attributes. */\nconst char *mailbox_attribute_iter_next(struct mailbox_attribute_iter *iter);\nint mailbox_attribute_iter_deinit(struct mailbox_attribute_iter **iter);\n\n#endif\n"}, "15": {"id": 15, "path": "/home/runner/work/testcc/testcc/retdec/src/lib-storage/mailbox-list-iter.h", "content": "#ifndef MAILBOX_LIST_ITER_H\n#define MAILBOX_LIST_ITER_H\n\n#include \"mail-namespace.h\"\n#include \"mailbox-list.h\"\n\nenum mailbox_list_iter_flags {\n\t/* Ignore index file and ACLs (used by ACL plugin internally) */\n\tMAILBOX_LIST_ITER_RAW_LIST\t\t= 0x000001,\n\t/* Don't list autocreated mailboxes (e.g. INBOX) unless they\n\t   physically exist */\n\tMAILBOX_LIST_ITER_NO_AUTO_BOXES\t\t= 0x000004,\n\n\t/* Skip all kinds of mailbox aliases. This typically includes symlinks\n\t   that point to the same directory. Also when iterating with\n\t   mailbox_list_iter_init_namespaces() skip namespaces that\n\t   have alias_for set. */\n\tMAILBOX_LIST_ITER_SKIP_ALIASES\t\t= 0x000008,\n\t/* For mailbox_list_iter_init_namespaces(): '*' in a pattern doesn't\n\t   match beyond namespace boundary (e.g. \"foo*\" or \"*o\" doesn't match\n\t   \"foo.\" namespace's mailboxes, but \"*.*\" does). also '%' can't match\n\t   namespace prefixes, if there exists a parent namespace whose children\n\t   it matches. */\n\tMAILBOX_LIST_ITER_STAR_WITHIN_NS\t= 0x000010,\n\n\t/* List only subscribed mailboxes */\n\tMAILBOX_LIST_ITER_SELECT_SUBSCRIBED\t= 0x000100,\n\t/* Return MAILBOX_CHILD_* if mailbox's children match selection\n\t   criteria, even if the mailbox itself wouldn't match. */\n\tMAILBOX_LIST_ITER_SELECT_RECURSIVEMATCH\t= 0x000200,\n\t/* Return only mailboxes that have special use flags */\n\tMAILBOX_LIST_ITER_SELECT_SPECIALUSE\t= 0x000400,\n\n\t/* Don't return any flags unless it can be done without cost */\n\tMAILBOX_LIST_ITER_RETURN_NO_FLAGS\t= 0x001000,\n\t/* Return MAILBOX_SUBSCRIBED flag */\n\tMAILBOX_LIST_ITER_RETURN_SUBSCRIBED\t= 0x002000,\n\t/* Return children flags */\n\tMAILBOX_LIST_ITER_RETURN_CHILDREN\t= 0x004000,\n\t/* Return IMAP special use flags */\n\tMAILBOX_LIST_ITER_RETURN_SPECIALUSE\t= 0x008000\n};\n\nstruct mailbox_info {\n\tconst char *vname;\n\tconst char *special_use;\n\tenum mailbox_info_flags flags;\n\n\tstruct mail_namespace *ns;\n};\n\n/* Returns a single pattern from given reference and pattern. */\nconst char *mailbox_list_join_refpattern(struct mailbox_list *list,\n\t\t\t\t\t const char *ref, const char *pattern);\n\n/* Initialize new mailbox list request. Pattern may contain '%' and '*'\n   wildcards as defined by RFC-3501. */\nstruct mailbox_list_iterate_context *\nmailbox_list_iter_init(struct mailbox_list *list, const char *pattern,\n\t\t       enum mailbox_list_iter_flags flags);\n/* Like mailbox_list_iter_init(), but support multiple patterns. Patterns is\n   a NULL-terminated list of strings. It must contain at least one pattern. */\nstruct mailbox_list_iterate_context *\nmailbox_list_iter_init_multiple(struct mailbox_list *list,\n\t\t\t\tconst char *const *patterns,\n\t\t\t\tenum mailbox_list_iter_flags flags);\n/* Like mailbox_list_iter_init_multiple(), but list mailboxes from all the\n   specified namespaces. If it fails, the error message is set to the first\n   namespaces->list. */\nstruct mailbox_list_iterate_context *\nmailbox_list_iter_init_namespaces(struct mail_namespace *namespaces,\n\t\t\t\t  const char *const *patterns,\n\t\t\t\t  enum mail_namespace_type type_mask,\n\t\t\t\t  enum mailbox_list_iter_flags flags);\n/* Get next mailbox. Returns the mailbox name */\nconst struct mailbox_info *\nmailbox_list_iter_next(struct mailbox_list_iterate_context *ctx);\n/* Deinitialize mailbox list request. Returns -1 if some error\n   occurred while listing. The error string can be looked up with\n   mailbox_list_get_last_error(). */\nint mailbox_list_iter_deinit(struct mailbox_list_iterate_context **ctx);\n/* List one mailbox. Returns 1 if info returned, 0 if mailbox doesn't exist,\n   -1 if error. */\nint mailbox_list_mailbox(struct mailbox_list *list, const char *name,\n\t\t\t enum mailbox_info_flags *flags_r);\n/* Returns 1 if mailbox has children, 0 if not, -1 if error. */\nint mailbox_has_children(struct mailbox_list *list, const char *name);\n\n#endif\n"}, "16": {"id": 16, "path": "/home/runner/work/testcc/testcc/retdec/src/lib-storage/mailbox-list.h", "content": "#ifndef MAILBOX_LIST_H\n#define MAILBOX_LIST_H\n\n#include \"mail-error.h\"\n\n#ifdef PATH_MAX\n#  define MAILBOX_LIST_NAME_MAX_LENGTH PATH_MAX\n#else\n#  define MAILBOX_LIST_NAME_MAX_LENGTH 4096\n#endif\n\nstruct fs;\nstruct mail_namespace;\nstruct mail_storage;\nstruct mailbox_list;\n\nenum mailbox_list_properties {\n\t/* maildir_name must always be empty */\n\tMAILBOX_LIST_PROP_NO_MAILDIR_NAME\t= 0x01,\n\t/* alt directories not supported */\n\tMAILBOX_LIST_PROP_NO_ALT_DIR\t\t= 0x02,\n\t/* no support for \\noselect directories, only mailboxes */\n\tMAILBOX_LIST_PROP_NO_NOSELECT\t\t= 0x04,\n\t/* mail root directory isn't required */\n\tMAILBOX_LIST_PROP_NO_ROOT\t\t= 0x08,\n\t/* Automatically create mailbox directories when needed. Normally it's\n\t   assumed that if a mailbox directory doesn't exist, the mailbox\n\t   doesn't exist either. */\n\tMAILBOX_LIST_PROP_AUTOCREATE_DIRS\t= 0x10,\n\t/* Explicitly disable mailbox list index */\n\tMAILBOX_LIST_PROP_NO_LIST_INDEX\t\t= 0x20,\n\t/* Disable checking mailbox_list.is_internal_name(). The layout is\n\t   implemented in a way that there aren't any such reserved internal\n\t   names. For example Maildir++ prefixes all mailboxes with \".\" */\n\tMAILBOX_LIST_PROP_NO_INTERNAL_NAMES\t= 0x40,\n};\n\nenum mailbox_list_flags {\n\t/* Mailboxes are files, not directories. */\n\tMAILBOX_LIST_FLAG_MAILBOX_FILES\t\t= 0x01,\n\t/* Namespace already has a mailbox list, don't assign this\n\t   mailbox list to it. */\n\tMAILBOX_LIST_FLAG_SECONDARY\t\t= 0x02,\n\t/* There are no mail files, only index and/or control files. */\n\tMAILBOX_LIST_FLAG_NO_MAIL_FILES\t\t= 0x04,\n\t/* LAYOUT=index: Don't delete any files in delete_mailbox(). */\n\tMAILBOX_LIST_FLAG_NO_DELETES\t\t= 0x08\n};\n\nenum mailbox_info_flags {\n\tMAILBOX_NOSELECT\t\t= 0x001,\n\tMAILBOX_NONEXISTENT\t\t= 0x002,\n\tMAILBOX_CHILDREN\t\t= 0x004,\n\tMAILBOX_NOCHILDREN\t\t= 0x008,\n\tMAILBOX_NOINFERIORS\t\t= 0x010,\n\tMAILBOX_MARKED\t\t\t= 0x020,\n\tMAILBOX_UNMARKED\t\t= 0x040,\n\tMAILBOX_SUBSCRIBED\t\t= 0x080,\n\tMAILBOX_CHILD_SUBSCRIBED\t= 0x100,\n\tMAILBOX_CHILD_SPECIALUSE\t= 0x200,\n\n\t/* Internally used by lib-storage, use mailbox_info.special_use\n\t   to actually access these: */\n\tMAILBOX_SPECIALUSE_ALL\t\t= 0x00010000,\n\tMAILBOX_SPECIALUSE_ARCHIVE\t= 0x00020000,\n\tMAILBOX_SPECIALUSE_DRAFTS\t= 0x00040000,\n\tMAILBOX_SPECIALUSE_FLAGGED\t= 0x00080000,\n\tMAILBOX_SPECIALUSE_JUNK\t\t= 0x00100000,\n\tMAILBOX_SPECIALUSE_SENT\t\t= 0x00200000,\n\tMAILBOX_SPECIALUSE_TRASH\t= 0x00400000,\n\tMAILBOX_SPECIALUSE_IMPORTANT\t= 0x00800000,\n#define MAILBOX_SPECIALUSE_MASK\t\t  0x00ff0000\n\n\t/* Internally used by lib-storage: */\n\tMAILBOX_SELECT\t\t\t= 0x20000000,\n\tMAILBOX_MATCHED\t\t\t= 0x40000000\n};\n\nenum mailbox_list_path_type {\n\t/* Return directory's path (eg. ~/dbox/INBOX) */\n\tMAILBOX_LIST_PATH_TYPE_DIR,\n\tMAILBOX_LIST_PATH_TYPE_ALT_DIR,\n\t/* Return mailbox path (eg. ~/dbox/INBOX/dbox-Mails) */\n\tMAILBOX_LIST_PATH_TYPE_MAILBOX,\n\tMAILBOX_LIST_PATH_TYPE_ALT_MAILBOX,\n\t/* Return control directory */\n\tMAILBOX_LIST_PATH_TYPE_CONTROL,\n\t/* Return index directory (\"\" for in-memory) */\n\tMAILBOX_LIST_PATH_TYPE_INDEX,\n\t/* Return the private index directory (NULL if none) */\n\tMAILBOX_LIST_PATH_TYPE_INDEX_PRIVATE,\n\t/* Return the index cache directory (usually same as\n\t   MAILBOX_LIST_PATH_TYPE_INDEX) */\n\tMAILBOX_LIST_PATH_TYPE_INDEX_CACHE,\n\t/* Return mailbox list index directory (usually same as\n\t   MAILBOX_LIST_PATH_TYPE_INDEX) */\n\tMAILBOX_LIST_PATH_TYPE_LIST_INDEX,\n};\n\nenum mailbox_list_file_type {\n\tMAILBOX_LIST_FILE_TYPE_UNKNOWN = 0,\n\tMAILBOX_LIST_FILE_TYPE_FILE,\n\tMAILBOX_LIST_FILE_TYPE_DIR,\n\tMAILBOX_LIST_FILE_TYPE_SYMLINK,\n\tMAILBOX_LIST_FILE_TYPE_OTHER\n};\n\nstruct mailbox_list_settings {\n\tconst char *layout; /* FIXME: shouldn't be here */\n\tconst char *root_dir;\n\tconst char *index_dir;\n\tconst char *index_pvt_dir;\n\tconst char *index_cache_dir;\n\tconst char *control_dir;\n\tconst char *alt_dir; /* FIXME: dbox-specific.. */\n\t/* Backend-local directory where volatile data, such as lock files,\n\t   can be temporarily created. This setting allows specifying a\n\t   separate directory for them to reduce disk I/O on the real storage.\n\t   The volatile_dir can point to an in-memory filesystem. */\n\tconst char *volatile_dir;\n\n\tconst char *inbox_path;\n\tconst char *subscription_fname;\n\tconst char *list_index_fname;\n\t/* Mailbox list index directory. NULL defaults to index directory.\n\t   The path may be relative to the index directory. */\n\tconst char *list_index_dir;\n\t/* If non-empty, it means that mails exist in a maildir_name\n\t   subdirectory. eg. if you have a directory containing directories:\n\n\t   mail/\n\t   mail/foo/\n\t   mail/foo/Maildir\n\n\t   If mailbox_name is empty, you have mailboxes \"mail\", \"mail/foo\" and\n\t   \"mail/foo/Maildir\".\n\n\t   If mailbox_name is \"Maildir\", you have a non-selectable mailbox\n\t   \"mail\" and a selectable mailbox \"mail/foo\". */\n\tconst char *maildir_name;\n\t/* if set, store mailboxes under root_dir/mailbox_dir_name/.\n\t   this setting contains either \"\" or \"dir/\". */\n\tconst char *mailbox_dir_name;\n\n\t/* Encode \"bad\" characters in mailbox names as <escape_char><hex> */\n\tchar escape_char;\n\t/* If mailbox name can't be changed reversibly to UTF-8 and back,\n\t   encode the problematic parts using <broken_char><hex> in the\n\t   user-visible UTF-8 name. The broken_char itself also has to be\n\t   encoded the same way. */\n\tchar broken_char;\n\t/* Use UTF-8 mailbox names on filesystem instead of mUTF-7 */\n\tbool utf8;\n\t/* Don't check/create the alt-dir symlink. */\n\tbool alt_dir_nocheck;\n\t/* Use maildir_name also for index/control directories. This should\n\t   have been the default since the beginning, but for backwards\n\t   compatibility it had to be made an option. */\n\tbool index_control_use_maildir_name;\n\t/* Perform mailbox iteration using the index directory instead of the\n\t   mail root directory. This can be helpful if the indexes are on a\n\t   faster storage. This could perhaps be made the default at some point,\n\t   but for now since it's less tested it's optional. */\n\tbool iter_from_index_dir;\n\t/* Avoid creating or listing \\NoSelect mailboxes. */\n\tbool no_noselect;\n\t/* Do not validate names as fs names (allows weird names) */\n\tbool no_fs_validation;\n};\n\nstruct mailbox_permissions {\n\t/* The actual uid/gid of the mailbox */\n\tuid_t file_uid;\n\tgid_t file_gid;\n\n\t/* mode and GID to use for newly created files/dirs.\n\t   (gid_t)-1 is used if the default GID can be used. */\n\tmode_t file_create_mode, dir_create_mode;\n\tgid_t file_create_gid;\n\t/* origin (e.g. path) where the file_create_gid was got from */\n\tconst char *file_create_gid_origin;\n\n\tbool gid_origin_is_mailbox_path;\n\tbool mail_index_permissions_set;\n};\n\n/* register all drivers */\nvoid mailbox_list_register_all(void);\n\nvoid mailbox_list_register(const struct mailbox_list *list);\nvoid mailbox_list_unregister(const struct mailbox_list *list);\n\nconst struct mailbox_list *\nmailbox_list_find_class(const char *driver);\n\n/* Returns 0 if ok, -1 if driver was unknown. */\nint mailbox_list_create(const char *driver, struct mail_namespace *ns,\n\t\t\tconst struct mailbox_list_settings *set,\n\t\t\tenum mailbox_list_flags flags,\n\t\t\tstruct mailbox_list **list_r, const char **error_r);\nvoid mailbox_list_destroy(struct mailbox_list **list);\n\nconst char *\nmailbox_list_get_driver_name(const struct mailbox_list *list) ATTR_PURE;\nconst struct mailbox_list_settings *\nmailbox_list_get_settings(const struct mailbox_list *list) ATTR_PURE;\nenum mailbox_list_flags\nmailbox_list_get_flags(const struct mailbox_list *list) ATTR_PURE;\nstruct mail_namespace *\nmailbox_list_get_namespace(const struct mailbox_list *list) ATTR_PURE;\nstruct mail_user *\nmailbox_list_get_user(const struct mailbox_list *list) ATTR_PURE;\nint mailbox_list_get_storage(struct mailbox_list **list, const char *vname,\n\t\t\t     struct mail_storage **storage_r);\nvoid mailbox_list_get_default_storage(struct mailbox_list *list,\n\t\t\t\t      struct mail_storage **storage);\nchar mailbox_list_get_hierarchy_sep(struct mailbox_list *list);\n\n/* Returns the mode and GID that should be used when creating new files and\n   directories to the specified mailbox. (gid_t)-1 is returned if it's not\n   necessary to change the default gid. */\nvoid mailbox_list_get_permissions(struct mailbox_list *list, const char *name,\n\t\t\t\t  struct mailbox_permissions *permissions_r);\n/* Like mailbox_list_get_permissions(), but for creating files/dirs to the\n   mail root directory (or even the root dir itself). */\nvoid mailbox_list_get_root_permissions(struct mailbox_list *list,\n\t\t\t\t       struct mailbox_permissions *permissions_r);\n/* mkdir() a root directory of given type with proper permissions. The path can\n   be either the root itself or point to a directory under the root. */\nint mailbox_list_mkdir_root(struct mailbox_list *list, const char *path,\n\t\t\t    enum mailbox_list_path_type type);\n/* Like mailbox_list_mkdir_root(), but don't log an error if it fails. */\nint mailbox_list_try_mkdir_root(struct mailbox_list *list, const char *path,\n\t\t\t\tenum mailbox_list_path_type type,\n\t\t\t\tconst char **error_r);\n/* Call mailbox_list_mkdir_root() for index, unless the index root is the\n   same as mailbox root. Returns 1 if ok, 0 if there are no indexes, -1 if\n   error. Calling this multiple times does the check only once. */\nint mailbox_list_mkdir_missing_index_root(struct mailbox_list *list);\n/* Like mailbox_list_mkdir_missing_index_root(), but for mailbox list\n   index root. */\nint mailbox_list_mkdir_missing_list_index_root(struct mailbox_list *list);\n\n/* Returns TRUE if name is ok, FALSE if it can't be safely passed to\n   mailbox_list_*() functions */\nbool mailbox_list_is_valid_name(struct mailbox_list *list,\n\t\t\t\tconst char *name, const char **error_r);\n\nconst char *mailbox_list_get_storage_name(struct mailbox_list *list,\n\t\t\t\t\t  const char *vname);\nconst char *mailbox_list_get_vname(struct mailbox_list *list, const char *name);\n\n/* Get path to specified type of files in mailbox. Returns -1 if an error\n   occurred (e.g. mailbox no longer exists), 0 if there are no files of this\n   type (in-memory index, no alt dir, storage with no files), 1 if path was\n   returned successfully. The path is set to NULL when returning -1/0. */\nint mailbox_list_get_path(struct mailbox_list *list, const char *name,\n\t\t\t  enum mailbox_list_path_type type,\n\t\t\t  const char **path_r);\n/* Get path to the root directory for files of specified type. Returns TRUE\n   if path was returned, FALSE if there are no files of this type. */\nbool mailbox_list_get_root_path(struct mailbox_list *list,\n\t\t\t\tenum mailbox_list_path_type type,\n\t\t\t\tconst char **path_r);\n/* Like mailbox_list_get_root_path(), but assume that the root directory\n   exists (assert crash if not) */\nconst char *mailbox_list_get_root_forced(struct mailbox_list *list,\n\t\t\t\t\t enum mailbox_list_path_type type);\n/* Returns mailbox's change log, or NULL if it doesn't have one. */\nstruct mailbox_log *mailbox_list_get_changelog(struct mailbox_list *list);\n/* Specify timestamp to use when writing mailbox changes to changelog.\n   The same timestamp is used until stamp is set to (time_t)-1, after which\n   current time is used */\nvoid mailbox_list_set_changelog_timestamp(struct mailbox_list *list,\n\t\t\t\t\t  time_t stamp);\n\n/* Returns a prefix that temporary files should use without conflicting\n   with the namespace. */\nconst char *mailbox_list_get_temp_prefix(struct mailbox_list *list);\n/* Returns prefix that's common to all get_temp_prefix() calls.\n   Typically this returns either \"temp.\" or \".temp.\". */\nconst char *mailbox_list_get_global_temp_prefix(struct mailbox_list *list);\n\n/* Subscribe/unsubscribe mailbox. There should be no error when\n   subscribing to already subscribed mailbox. Subscribing to\n   unexisting mailboxes is optional. */\nint mailbox_list_set_subscribed(struct mailbox_list *list,\n\t\t\t\tconst char *name, bool set);\n\n/* Delete a non-selectable mailbox. Fail if the mailbox is selectable. */\nint mailbox_list_delete_dir(struct mailbox_list *list, const char *name);\n/* Delete a symlinked mailbox. Fail if the mailbox isn't a symlink. */\nint mailbox_list_delete_symlink(struct mailbox_list *list, const char *name);\n\n/* Returns the error message of last occurred error. */\nconst char * ATTR_NOWARN_UNUSED_RESULT\nmailbox_list_get_last_error(struct mailbox_list *list,\n\t\t\t    enum mail_error *error_r);\n/* Wrapper for mailbox_list_get_last_error() */\nenum mail_error mailbox_list_get_last_mail_error(struct mailbox_list *list);\n\nconst char * ATTR_NOWARN_UNUSED_RESULT\nmailbox_list_get_last_internal_error(struct mailbox_list *list,\n\t\t\t\t     enum mail_error *error_r);\n\n/* Save the last error until it's popped. This is useful for cases where the\n   list operation has already failed, but the cleanup code path changes the\n   error to something else unwanted. */\nvoid mailbox_list_last_error_push(struct mailbox_list *list);\nvoid mailbox_list_last_error_pop(struct mailbox_list *list);\n\n/* Create a fs based on the settings in the given mailbox_list. */\nint mailbox_list_init_fs(struct mailbox_list *list, const char *driver,\n\t\t\t const char *args, const char *root_dir,\n\t\t\t struct fs **fs_r, const char **error_r);\n/* Return mailbox_list that was used to create the fs via\n   mailbox_list_init_fs(). */\nstruct mailbox_list *mailbox_list_fs_get_list(struct fs *fs);\n\n#endif\n"}, "17": {"id": 17, "path": "/home/runner/work/testcc/testcc/retdec/src/lib/array-decl.h", "content": "#ifndef ARRAY_DECL_H\n#define ARRAY_DECL_H\n\n#define ARRAY(array_type) union { struct array arr; array_type const *const *v; array_type **v_modifiable; }\n#define ARRAY_INIT { { NULL, 0 } }\n\n#define ARRAY_DEFINE_TYPE(name, array_type) \\\n\tunion array ## __ ## name { struct array arr; array_type const *const *v; array_type **v_modifiable; }\n#define ARRAY_TYPE(name) \\\n\tunion array ## __ ## name\n\nstruct array {\n\tbuffer_t *buffer;\n\tsize_t element_size;\n};\n\nARRAY_DEFINE_TYPE(string, char *);\nARRAY_DEFINE_TYPE(const_string, const char *);\nARRAY_DEFINE_TYPE(uint8_t, uint8_t);\nARRAY_DEFINE_TYPE(uint16_t, uint16_t);\nARRAY_DEFINE_TYPE(uint32_t, uint32_t);\nARRAY_DEFINE_TYPE(uint64_t, uint64_t);\nARRAY_DEFINE_TYPE(uint, unsigned int);\nARRAY_DEFINE_TYPE(void_array, void *);\n\n#endif\n"}, "18": {"id": 18, "path": "/home/runner/work/testcc/testcc/retdec/src/lib/buffer.h", "content": "#ifndef BUFFER_H\n#define BUFFER_H\n\nstruct buffer {\n\tconst void *data;\n\tconst size_t used;\n\tvoid *priv[5];\n};\n\n/* WARNING: Be careful with functions that return pointers to data.\n   With dynamic buffers they are valid only as long as buffer is not\n   realloc()ed. You shouldn't rely on it being valid if you have modified\n   buffer in any way. */\n\n/* Create a modifiable buffer from given data. Writes past this size will\n   i_panic(). */\nvoid buffer_create_from_data(buffer_t *buffer, void *data, size_t size);\n/* Create a non-modifiable buffer from given data. */\nvoid buffer_create_from_const_data(buffer_t *buffer,\n\t\t\t\t   const void *data, size_t size);\n#if defined(__GNUC__) && (__GNUC__ * 100 + __GNUC_MINOR__) > 401\n#define buffer_create_from_data(b,d,s) ({\t\t\t\t           \\\n\t(void)COMPILE_ERROR_IF_TRUE(__builtin_object_size((d),1) < ((s)>0?(s):1)); \\\n\tbuffer_create_from_data((b), (d), (s)); })\n#define buffer_create_from_const_data(b,d,s) ({\t\t\t\t           \\\n\t(void)COMPILE_ERROR_IF_TRUE(__builtin_object_size((d),1) < ((s)>0?(s):1)); \\\n\tbuffer_create_from_const_data((b), (d), (s)); })\n#endif\n/* Creates a dynamically growing buffer. Whenever write would exceed the\n   current size it's grown. */\nbuffer_t *buffer_create_dynamic(pool_t pool, size_t init_size);\n\n#define t_buffer_create(init_size) \\\n\tbuffer_create_dynamic(pool_datastack_create(), (init_size))\n\n/* Free the memory used by buffer. Not needed if the memory is free'd\n   directly from the memory pool. */\nvoid buffer_free(buffer_t **buf);\n/* Free the memory used by buffer structure, but return the buffer data\n   unfree'd. */\nvoid *buffer_free_without_data(buffer_t **buf);\n\n/* Returns the pool buffer was created with. */\npool_t buffer_get_pool(const buffer_t *buf) ATTR_PURE;\n\n/* Write data to buffer at specified position. If pos is beyond the buffer's\n   current size, it is zero-filled up to that point (even if data_size==0). */\nvoid buffer_write(buffer_t *buf, size_t pos,\n\t\t  const void *data, size_t data_size);\n/* Append data to buffer. */\nvoid buffer_append(buffer_t *buf, const void *data, size_t data_size);\n/* Append character to buffer. */\nvoid buffer_append_c(buffer_t *buf, unsigned char chr);\n\n/* Insert the provided data into the buffer at position pos. If pos points past\n   the current buffer size, the gap is zero-filled. */\nvoid buffer_insert(buffer_t *buf, size_t pos,\n\t\t   const void *data, size_t data_size);\n/* Delete data with the indicated size from the buffer at position pos. The\n   deleted block may cross the current buffer size boundary, which is ignored.\n */\nvoid buffer_delete(buffer_t *buf, size_t pos, size_t size);\n/* Replace the data in the buffer with the indicated size at position pos with\n   the provided data. This is a more optimized version of\n   buffer_delete(buf, pos, size); buffer_insert(buf, pos, data, data_size); */\nvoid buffer_replace(buffer_t *buf, size_t pos, size_t size,\n\t\t    const void *data, size_t data_size);\n\n/* Fill buffer with zero bytes. */\nvoid buffer_write_zero(buffer_t *buf, size_t pos, size_t data_size);\nvoid buffer_append_zero(buffer_t *buf, size_t data_size);\nvoid buffer_insert_zero(buffer_t *buf, size_t pos, size_t data_size);\n\n/* Copy data from buffer to another. The buffers may be same in which case\n   it's internal copying, possibly with overlapping positions (ie. memmove()\n   like functionality). copy_size may be set to (size_t)-1 to copy the rest of\n   the used data in buffer. */\nvoid buffer_copy(buffer_t *dest, size_t dest_pos,\n\t\t const buffer_t *src, size_t src_pos, size_t copy_size);\n/* Append data to buffer from another. copy_size may be set to (size_t)-1 to\n   copy the rest of the used data in buffer. */\nvoid buffer_append_buf(buffer_t *dest, const buffer_t *src,\n\t\t       size_t src_pos, size_t copy_size);\n\n/* Returns pointer to specified position in buffer. WARNING: The returned\n   address may become invalid if you add more data to buffer. */\nvoid *buffer_get_space_unsafe(buffer_t *buf, size_t pos, size_t size);\n/* Increase the buffer usage by given size, and return a pointer to beginning\n   of it. */\nvoid *buffer_append_space_unsafe(buffer_t *buf, size_t size);\n\n/* Like buffer_get_data(), but don't return it as const. Returns NULL if the\n   buffer is non-modifiable. WARNING: The returned address may become invalid\n   if you add more data to buffer. */\nvoid *buffer_get_modifiable_data(const buffer_t *buf, size_t *used_size_r)\n\tATTR_NULL(2);\n\n/* Set the \"used size\" of buffer, ie. 0 would set the buffer empty.\n   Must not be used to grow buffer. The data after the buffer's new size will\n   be effectively lost, because e.g. buffer_get_space_unsafe() will zero out\n   the contents. */\nvoid buffer_set_used_size(buffer_t *buf, size_t used_size);\n\n/* Returns the current buffer size. */\nsize_t buffer_get_size(const buffer_t *buf) ATTR_PURE;\n/* Returns how many bytes we can write to buffer without increasing its size.\n   With dynamic buffers this is buffer_get_size()-1, because the extra 1 byte\n   is reserved for str_c()'s NUL. */\nsize_t buffer_get_writable_size(const buffer_t *buf) ATTR_PURE;\n/* Returns the maximum number of bytes we can append to the buffer. If the\n   buffer is dynamic, this is always near SIZE_MAX. */\nsize_t buffer_get_avail_size(const buffer_t *buf) ATTR_PURE;\n\n/* Returns TRUE if buffer contents are identical. */\nbool buffer_cmp(const buffer_t *buf1, const buffer_t *buf2);\n\n/* Returns pointer to beginning of buffer data. Current used size of buffer is\n   stored in used_size if it's non-NULL. */\nstatic inline const void * ATTR_NULL(2)\nbuffer_get_data(const buffer_t *buf, size_t *used_size_r)\n{\n\tif (used_size_r != NULL)\n\t\t*used_size_r = buf->used;\n\treturn buf->data;\n}\n\n/* Returns the current used buffer size. */\nstatic inline size_t ATTR_PURE\nbuffer_get_used_size(const buffer_t *buf)\n{\n\treturn buf->used;\n}\n\n/* Crash if buffer was allocated from data stack and stack frame has changed.\n   This can be used as an assert-like check to verify that it's valid to\n   increase the buffer size here, instead of crashing only randomly when the\n   buffer needs to be increased. */\nvoid buffer_verify_pool(buffer_t *buf);\n\n/* This will truncate your byte buffer to contain at most\n   given number of bits. \n\n 1 bits:    01 00000001\n 2 bits:    03 00000011\n 3 bits:    07 00000111\n 4 bits:    0f 00001111\n 5 bits:    1f 00011111\n 6 bits:    3f 00111111\n 7 bits:    7f 01111111\n 8 bits:    ff 11111111\n 9 bits:  01ff 0000000111111111\n10 bits:  03ff 0000001111111111\n11 bits:  07ff 0000011111111111\n12 bits:  0fff 0000111111111111\n13 bits:  1fff 0001111111111111\n14 bits:  3fff 0011111111111111\n15 bits:  7fff 0111111111111111\n16 bits:  ffff 1111111111111111\n\n and so forth\n\n*/\nvoid buffer_truncate_rshift_bits(buffer_t *buf, size_t bits);\n\n#endif\n"}, "19": {"id": 19, "path": "/home/runner/work/testcc/testcc/retdec/src/lib/byteorder.h", "content": "/*\n * Copyright (c) 2016-2017 Josef 'Jeff' Sipek <jeffpc@josefsipek.net>\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n * SOFTWARE.\n */\n\n#ifndef BYTEORDER_H\n#define BYTEORDER_H\n\n/*\n * These prototypes exist to catch bugs in the code generating macros below.\n */\n/* return byte swapped input */\nstatic inline uint64_t i_bswap_64(uint64_t in);\nstatic inline uint32_t i_bswap_32(uint32_t in);\nstatic inline uint16_t i_bswap_16(uint16_t in);\nstatic inline uint8_t i_bswap_8(uint8_t in);\n\n/* load an unaligned cpu native endian number from memory */\nstatic inline uint64_t cpu64_to_cpu_unaligned(const void *in);\nstatic inline uint32_t cpu32_to_cpu_unaligned(const void *in);\nstatic inline uint16_t cpu16_to_cpu_unaligned(const void *in);\nstatic inline uint8_t cpu8_to_cpu_unaligned(const void *in);\n\n/* load an unaligned big endian number from memory */\nstatic inline uint64_t be64_to_cpu_unaligned(const void *in);\nstatic inline uint32_t be32_to_cpu_unaligned(const void *in);\nstatic inline uint16_t be16_to_cpu_unaligned(const void *in);\nstatic inline uint8_t be8_to_cpu_unaligned(const void *in);\n\n/* load an unaligned little endian number from memory */\nstatic inline uint64_t le64_to_cpu_unaligned(const void *in);\nstatic inline uint32_t le32_to_cpu_unaligned(const void *in);\nstatic inline uint16_t le16_to_cpu_unaligned(const void *in);\nstatic inline uint8_t le8_to_cpu_unaligned(const void *in);\n\n/* store into memory a cpu native endian number as a big endian number */\nstatic inline void cpu64_to_be_unaligned(uint64_t in, void *out);\nstatic inline void cpu32_to_be_unaligned(uint32_t in, void *out);\nstatic inline void cpu16_to_be_unaligned(uint16_t in, void *out);\nstatic inline void cpu8_to_be_unaligned(uint8_t in, void *out);\n\n/* store into memory a cpu native endian number as a little endian number */\nstatic inline void cpu64_to_le_unaligned(uint64_t in, void *out);\nstatic inline void cpu32_to_le_unaligned(uint32_t in, void *out);\nstatic inline void cpu16_to_le_unaligned(uint16_t in, void *out);\nstatic inline void cpu8_to_le_unaligned(uint8_t in, void *out);\n\n/* convert a big endian input into cpu native endian */\nstatic inline uint64_t be64_to_cpu(uint64_t in);\nstatic inline uint32_t be32_to_cpu(uint32_t in);\nstatic inline uint16_t be16_to_cpu(uint16_t in);\nstatic inline uint8_t be8_to_cpu(uint8_t in);\n\n/* convert a cpu native endian input into big endian */\nstatic inline uint64_t cpu64_to_be(uint64_t in);\nstatic inline uint32_t cpu32_to_be(uint32_t in);\nstatic inline uint16_t cpu16_to_be(uint16_t in);\nstatic inline uint8_t cpu8_to_be(uint8_t in);\n\n/* convert a little endian input into cpu native endian */\nstatic inline uint64_t le64_to_cpu(uint64_t in);\nstatic inline uint32_t le32_to_cpu(uint32_t in);\nstatic inline uint16_t le16_to_cpu(uint16_t in);\nstatic inline uint8_t le8_to_cpu(uint8_t in);\n\n/* convert a cpu native endian input into little endian */\nstatic inline uint64_t cpu64_to_le(uint64_t in);\nstatic inline uint32_t cpu32_to_le(uint32_t in);\nstatic inline uint16_t cpu16_to_le(uint16_t in);\nstatic inline uint8_t cpu8_to_le(uint8_t in);\n\n/*\n * byte swapping\n */\nstatic inline uint64_t i_bswap_64(uint64_t in)\n{\n\treturn ((in & 0xff00000000000000ULL) >> 56) |\n\t       ((in & 0x00ff000000000000ULL) >> 40) |\n\t       ((in & 0x0000ff0000000000ULL) >> 24) |\n\t       ((in & 0x000000ff00000000ULL) >> 8) |\n\t       ((in & 0x00000000ff000000ULL) << 8) |\n\t       ((in & 0x0000000000ff0000ULL) << 24) |\n\t       ((in & 0x000000000000ff00ULL) << 40) |\n\t       ((in & 0x00000000000000ffULL) << 56);\n}\n\nstatic inline uint32_t i_bswap_32(uint32_t in)\n{\n\treturn ((in & 0xff000000) >> 24) |\n\t       ((in & 0x00ff0000) >> 8) |\n\t       ((in & 0x0000ff00) << 8) |\n\t       ((in & 0x000000ff) << 24);\n}\n\nstatic inline uint16_t i_bswap_16(uint16_t in)\n{\n\treturn ((in & 0xff00) >> 8) |\n\t       ((in & 0x00ff) << 8);\n}\n\nstatic inline uint8_t i_bswap_8(uint8_t in)\n{\n\treturn (in & 0xff);\n}\n\n/*\n * unaligned big-endian integer\n */\nstatic inline uint64_t be64_to_cpu_unaligned(const void *in)\n{\n\tconst uint8_t *p = (const uint8_t *) in;\n\n\treturn (((uint64_t) p[0] << 56) |\n\t\t((uint64_t) p[1] << 48) |\n\t\t((uint64_t) p[2] << 40) |\n\t\t((uint64_t) p[3] << 32) |\n\t\t((uint64_t) p[4] << 24) |\n\t\t((uint64_t) p[5] << 16) |\n\t\t((uint64_t) p[6] << 8) |\n\t\t((uint64_t) p[7]));\n}\n\nstatic inline void cpu64_to_be_unaligned(uint64_t in, void *out)\n{\n\tuint8_t *p = (uint8_t *) out;\n\n\tp[0] = (in >> 56) & 0xff;\n\tp[1] = (in >> 48) & 0xff;\n\tp[2] = (in >> 40) & 0xff;\n\tp[3] = (in >> 32) & 0xff;\n\tp[4] = (in >> 24) & 0xff;\n\tp[5] = (in >> 16) & 0xff;\n\tp[6] = (in >> 8) & 0xff;\n\tp[7] = in & 0xff;\n}\n\nstatic inline uint32_t be32_to_cpu_unaligned(const void *in)\n{\n\tconst uint8_t *p = (const uint8_t *) in;\n\n\treturn (((uint32_t) p[0] << 24) |\n\t\t((uint32_t) p[1] << 16) |\n\t\t((uint32_t) p[2] << 8) |\n\t\t((uint32_t) p[3]));\n}\n\nstatic inline void cpu32_to_be_unaligned(uint32_t in, void *out)\n{\n\tuint8_t *p = (uint8_t *) out;\n\n\tp[0] = (in >> 24) & 0xff;\n\tp[1] = (in >> 16) & 0xff;\n\tp[2] = (in >> 8) & 0xff;\n\tp[3] = in & 0xff;\n}\n\nstatic inline uint16_t be16_to_cpu_unaligned(const void *in)\n{\n\tconst uint8_t *p = (const uint8_t *) in;\n\n\treturn (((uint16_t) p[0] << 8) |\n\t\t((uint16_t) p[1]));\n}\n\nstatic inline void cpu16_to_be_unaligned(uint16_t in, void *out)\n{\n\tuint8_t *p = (uint8_t *) out;\n\n\tp[0] = (in >> 8) & 0xff;\n\tp[1] = in & 0xff;\n}\n\nstatic inline uint8_t be8_to_cpu_unaligned(const void *in)\n{\n\treturn *((const uint8_t *) in);\n}\n\nstatic inline void cpu8_to_be_unaligned(uint8_t in, void *out)\n{\n\tuint8_t *p = (uint8_t *) out;\n\n\t*p = in;\n}\n\n/*\n * unaligned little-endian & cpu-endian integers\n */\n#define __GEN(size, bswap)\t\t\t\t\t\t\\\nstatic inline uint##size##_t le##size##_to_cpu_unaligned(const void *in)\\\n{\t\t\t\t\t\t\t\t\t\\\n\tuint##size##_t x = be##size##_to_cpu_unaligned(in);\t\t\\\n\t/* we read a LE int as BE, so we always have to byte swap */\t\\\n\treturn i_bswap_##size(x);\t\t\t\t\t\t\\\n}\t\t\t\t\t\t\t\t\t\\\nstatic inline void cpu##size##_to_le_unaligned(uint##size##_t in,\t\\\n\t\t\t\t\t       void *out)\t\t\\\n{\t\t\t\t\t\t\t\t\t\\\n\t/* we'll be writing in BE, so we always have to byte swap */\t\\\n\tcpu##size##_to_be_unaligned(i_bswap_##size(in), out);\t\t\\\n}\t\t\t\t\t\t\t\t\t\\\nstatic inline uint##size##_t cpu##size##_to_cpu_unaligned(const void *in)\\\n{\t\t\t\t\t\t\t\t\t\\\n\tuint##size##_t x = be##size##_to_cpu_unaligned(in);\t\t\\\n\treturn bswap;\t\t\t\t\t\t\t\\\n}\n\n#ifdef WORDS_BIGENDIAN\n#define GEN(size)\t__GEN(size, x)\n#else\n#define GEN(size)\t__GEN(size, i_bswap_##size(x))\n#endif\n\nGEN(64)\nGEN(32)\nGEN(16)\nGEN(8)\n\n#undef __GEN\n#undef GEN\n\n/*\n * byte ordering\n */\n#define ___GEN(from, size, to, bswap)\t\t\t\t\t\\\nstatic inline uint##size##_t from##size##_to_##to(uint##size##_t x)\t\\\n{\t\t\t\t\t\t\t\t\t\\\n\treturn bswap;\t\t\t\t\t\t\t\\\n}\n\n#ifdef WORDS_BIGENDIAN\n#define __GEN(from, size, to, be, le) ___GEN(from, size, to, be)\n#else\n#define __GEN(from, size, to, be, le) ___GEN(from, size, to, le)\n#endif\n\n#define GEN(size)\t\t\t\t\t\t\t\\\n\t__GEN(be,  size, cpu, x, i_bswap_##size(x))\t\t\t\\\n\t__GEN(cpu, size, be,  x, i_bswap_##size(x))\t\t\t\\\n\t__GEN(le,  size, cpu, i_bswap_##size(x), x)\t\t\t\\\n\t__GEN(cpu, size, le,  i_bswap_##size(x), x)\n\nGEN(64)\nGEN(32)\nGEN(16)\nGEN(8)\n\n#undef ___GEN\n#undef __GEN\n#undef GEN\n\n#endif\n"}, "20": {"id": 20, "path": "/home/runner/work/testcc/testcc/retdec/src/lib/compat.h", "content": "#ifndef COMPAT_H\n#define COMPAT_H\n\n/* _ILP32 and _LP64 are common but not universal, make sure that exactly one\n   of them is defined. */\n#if !defined(_ILP32) && \\\n\t(SIZEOF_INT == 4) && (SIZEOF_LONG == 4) && (SIZEOF_VOID_P == 4)\n#  define _ILP32\n#endif\n#if !defined(_LP64) && \\\n\t(SIZEOF_INT == 4) && (SIZEOF_LONG == 8) && (SIZEOF_VOID_P == 8)\n#  define _LP64\n#endif\n#if defined(_ILP32) && defined(_LP64)\n#  error \"Cannot have both _ILP32 and _LP64 defined\"\n#elif !defined(_ILP32) && !defined(_LP64)\n#  error \"Must have one of _ILP32 and _LP64 defined\"\n#endif\n\n/* well, this is obviously wrong since it assumes it's 64bit, but older\n   GCCs don't define it and we really want it. */\n#ifndef LLONG_MAX\n#  define LLONG_MAX 9223372036854775807LL\n#endif\n\n#if ((__GNUC__ > 3 || (__GNUC__ == 3 && __GNUC_MINOR__ > 3)) && \\\n\tdefined(HAVE_TYPEOF)) && !defined(__cplusplus)\n#  define HAVE_TYPE_CHECKS\n#endif\n\n/* We really want NULL to be a pointer, since we have various type-checks\n   that may result in compiler warnings/errors if it's not. Do this only when\n   type checking is used - it's not otherwise needed and causes compiling\n   problems with e.g. Sun C compiler. */\n#ifdef HAVE_TYPE_CHECKS\n#  undef NULL\n#  define NULL ((void *)0)\n#endif\n\n#ifndef __has_extension\n  #define __has_extension(x) 0  // Compatibility with non-clang compilers.\n#endif\n\n#if (defined(__GNUC__) && __GNUC__ > 4 || (__GNUC__ == 4 && __GNUC_MINOR__ >= 5)) || \\\n    (defined(__clang__) && (__has_extension(attribute_deprecated_with_message)))\n#  define HAVE_ATTR_DEPRECATED\nint rand(void) __attribute__((deprecated(\"Do not use rand, use i_rand\")));\nint rand_r(unsigned int*) __attribute__((deprecated(\"Do not use rand_r, use i_rand\")));\n#endif\n\n#ifndef __cplusplus\n#ifdef HAVE__BOOL\ntypedef _Bool bool;\n#else\ntypedef int bool;\n#endif\n#endif\n\n#if defined (HAVE_UOFF_T)\n/* native support */\n#elif defined (UOFF_T_INT)\ntypedef unsigned int uoff_t;\n#elif defined (UOFF_T_LONG)\ntypedef unsigned long uoff_t;\n#elif defined (UOFF_T_LONG_LONG)\ntypedef unsigned long long uoff_t;\n#else\n#  error uoff_t size not set\n#endif\n\n#ifndef HAVE_UINTMAX_T\n#  if SIZEOF_LONG_LONG > 0\ntypedef unsigned long long uintmax_t;\n#  else\ntypedef unsigned long uintmax_t;\n#  endif\n#endif\n\n#ifndef HAVE_UINT_FAST32_T\n#  if SIZEOF_INT >= 4\ntypedef unsigned int uint_fast32_t;\n#  else\ntypedef unsigned long uint_fast32_t;\n#  endif\n#endif\n\n#ifndef HAVE_SOCKLEN_T\ntypedef int socklen_t;\n#endif\n\n/* WORDS_BIGENDIAN needs to be undefined if not enabled */\n#if defined(WORDS_BIGENDIAN) && WORDS_BIGENDIAN == 0\n#  undef WORDS_BIGENDIAN\n#endif\n\n#ifdef HAVE_SYS_SYSMACROS_H\n#  include <sys/sysmacros.h>\n#  ifdef HAVE_SYS_MKDEV_H\n#    include <sys/mkdev.h> /* UnixWare */\n#  endif\n#  define CMP_DEV_T(a, b) (major(a) == major(b) && minor(a) == minor(b))\n#elif !defined (DEV_T_STRUCT)\n#  define CMP_DEV_T(a, b) ((a) == (b))\n#else\n#  error I do not know how to compare dev_t\n#endif\n\n#ifdef HAVE_STAT_XTIM\n#  define HAVE_ST_NSECS\n#  define ST_ATIME_NSEC(st) ((unsigned long)(st).st_atim.tv_nsec)\n#  define ST_MTIME_NSEC(st) ((unsigned long)(st).st_mtim.tv_nsec)\n#  define ST_CTIME_NSEC(st) ((unsigned long)(st).st_ctim.tv_nsec)\n#elif defined (HAVE_STAT_XTIMESPEC)\n#  define HAVE_ST_NSECS\n#  define ST_ATIME_NSEC(st) ((unsigned long)(st).st_atimespec.tv_nsec)\n#  define ST_MTIME_NSEC(st) ((unsigned long)(st).st_mtimespec.tv_nsec)\n#  define ST_CTIME_NSEC(st) ((unsigned long)(st).st_ctimespec.tv_nsec)\n#else\n#  define ST_ATIME_NSEC(st) 0UL\n#  define ST_MTIME_NSEC(st) 0UL\n#  define ST_CTIME_NSEC(st) 0UL\n#endif\n\n#ifdef HAVE_ST_NSECS\n/* TRUE if a nanosecond timestamp from struct stat matches another nanosecond.\n   If nanoseconds aren't supported in struct stat, returns always TRUE (useful\n   with NFS if some hosts support nanoseconds and others don't). */\n#  define ST_NTIMES_EQUAL(ns1, ns2) ((ns1) == (ns2))\n#else\n#  define ST_NTIMES_EQUAL(ns1, ns2) TRUE\n#endif\n\n#define CMP_ST_MTIME(st1, st2) \\\n\t((st1)->st_mtime == (st2)->st_mtime && \\\n\t ST_NTIMES_EQUAL(ST_MTIME_NSEC(*(st1)), ST_MTIME_NSEC(*(st2))))\n#define CMP_ST_CTIME(st1, st2) \\\n\t((st1)->st_ctime == (st2)->st_ctime && \\\n\t ST_NTIMES_EQUAL(ST_CTIME_NSEC(*(st1)), ST_CTIME_NSEC(*(st2))))\n\n/* strcasecmp(), strncasecmp() */\n#ifndef HAVE_STRCASECMP\n#  ifdef HAVE_STRICMP\n#    define strcasecmp stricmp\n#    define strncasecmp strnicmp\n#  else\n#    define strcasecmp i_my_strcasecmp\n#    define strncasecmp i_my_strncasecmp\nint i_my_strcasecmp(const char *s1, const char *s2);\nint i_my_strncasecmp(const char *s1, const char *s2, size_t max_chars);\n#  endif\n#endif\n\n#ifndef HAVE_INET_ATON\n#  include <sys/socket.h>\n#  include <netinet/in.h>\n#  include <arpa/inet.h>\n#  define inet_aton i_my_inet_aton\nint i_my_inet_aton(const char *cp, struct in_addr *inp);\n#endif\n\n#ifndef HAVE_VSYSLOG\n#  define vsyslog i_my_vsyslog\nvoid i_my_vsyslog(int priority, const char *format, va_list args);\n#endif\n\n#ifndef HAVE_GETPAGESIZE\n#  define getpagesize i_my_getpagesize\nint i_my_getpagesize(void);\n#endif\n\n#ifndef HAVE_FDATASYNC\n#  define fdatasync fsync\n#endif\n\nstruct const_iovec {\n\tconst void *iov_base;\n\tsize_t iov_len;\n};\n\n#ifndef HAVE_STRUCT_IOVEC\nstruct iovec {\n\tvoid *iov_base;\n\tsize_t iov_len;\n};\n#endif\n\n/* IOV_MAX should be in limits.h nowadays. Linux still (2005) requires\n   defining _XOPEN_SOURCE to get that value. UIO_MAXIOV works with it though,\n   so use it instead. 16 is the lowest acceptable value for all OSes. */\n#ifndef IOV_MAX\n#  include <sys/uio.h>\n#  ifdef UIO_MAXIOV\n#    define IOV_MAX UIO_MAXIOV\n#  else\n#    define IOV_MAX 16\n#  endif\n#endif\n\n#ifndef HAVE_WRITEV\n#  define writev i_my_writev\nstruct iovec;\nssize_t i_my_writev(int fd, const struct iovec *iov, int iov_len);\n#endif\n\n#if !defined(HAVE_PREAD) || defined(PREAD_WRAPPERS) || defined(PREAD_BROKEN)\n#  ifndef IN_COMPAT_C\n#    define pread i_my_pread\n#    define pwrite i_my_pwrite\n#  endif\nssize_t i_my_pread(int fd, void *buf, size_t count, off_t offset);\nssize_t i_my_pwrite(int fd, const void *buf, size_t count, off_t offset);\n#endif\n\n#ifndef HAVE_SETEUID\n#  define seteuid i_my_seteuid\nint i_my_seteuid(uid_t euid);\n#endif\n\n#ifndef HAVE_SETEGID\n#  define setegid i_my_setegid\nint i_my_setegid(gid_t egid);\n#endif\n\n#ifndef HAVE_LIBGEN_H\n#  define basename i_my_basename\nchar *i_my_basename(char *path);\n#endif\n\n#ifdef HAVE_OLD_VSNPRINTF\n#  include <stdio.h>\n#  define vsnprintf i_my_vsnprintf\nint i_my_vsnprintf(char *str, size_t size, const char *format, va_list ap);\n#endif\n\n#ifndef HAVE_CLOCK_GETTIME\n#  include <time.h>\n#  undef CLOCK_REALTIME\n#  define CLOCK_REALTIME 1\n#  define clock_gettime i_my_clock_gettime\nint i_my_clock_gettime(int clk_id, struct timespec *tp);\n#endif\n\n/* ctype.h isn't safe with signed chars,\n   use our own instead if really needed */\n#define i_toupper(x) ((char) toupper((int) (unsigned char) (x)))\n#define i_tolower(x) ((char) tolower((int) (unsigned char) (x)))\n#define i_isalnum(x) (isalnum((int) (unsigned char) (x)) != 0)\n#define i_isalpha(x) (isalpha((int) (unsigned char) (x)) != 0)\n#define i_isascii(x) (isascii((int) (unsigned char) (x)) != 0)\n#define i_isblank(x) (isblank((int) (unsigned char) (x)) != 0)\n#define i_iscntrl(x) (iscntrl((int) (unsigned char) (x)) != 0)\n#define i_isdigit(x) (isdigit((int) (unsigned char) (x)) != 0)\n#define i_isgraph(x) (isgraph((int) (unsigned char) (x)) != 0)\n#define i_islower(x) (islower((int) (unsigned char) (x)) != 0)\n#define i_isprint(x) (isprint((int) (unsigned char) (x)) != 0)\n#define i_ispunct(x) (ispunct((int) (unsigned char) (x)) != 0)\n#define i_isspace(x) (isspace((int) (unsigned char) (x)) != 0)\n#define i_isupper(x) (isupper((int) (unsigned char) (x)) != 0)\n#define i_isxdigit(x) (isxdigit((int) (unsigned char) (x)) != 0)\n\n#ifndef EOVERFLOW\n#  define EOVERFLOW ERANGE\n#endif\n\n#ifdef EDQUOT\n#  define ENOSPACE(errno) ((errno) == ENOSPC || (errno) == EDQUOT)\n#  define ENOQUOTA(errno) ((errno) == EDQUOT)\n#else\n/* probably all modern OSes have EDQUOT, but just in case one doesn't assume\n   that ENOSPC is the same as \"over quota\". */\n#  define ENOSPACE(errno) ((errno) == ENOSPC)\n#  define ENOQUOTA(errno) ((errno) == ENOSPC)\n#endif\n\n/* EPERM is returned sometimes if device doesn't support such modification */\n#ifdef EROFS\n#  define ENOACCESS(errno) \\\n\t((errno) == EACCES || (errno) == EROFS || (errno) == EPERM)\n#else\n#  define ENOACCESS(errno) ((errno) == EACCES || (errno) == EPERM)\n#endif\n\n#define ENOTFOUND(errno) \\\n\t((errno) == ENOENT || (errno) == ENOTDIR || \\\n\t (errno) == ELOOP || (errno) == ENAMETOOLONG)\n\n#define ECANTLINK(errno) \\\n\t((errno) == EXDEV || (errno) == EMLINK || (errno) == EPERM)\n\n/* Returns TRUE if unlink() failed because it attempted to delete a directory */\n#define UNLINK_EISDIR(errno) \\\n\t((errno) == EPERM || /* POSIX */ \\\n\t (errno) == EISDIR) /* Linux */\n\n/* EBUSY is given by some NFS implementations */\n#define EDESTDIREXISTS(errno) \\\n\t((errno) == EEXIST || (errno) == ENOTEMPTY || (errno) == EBUSY)\n\n/* fstat() returns ENOENT instead of ESTALE with some Linux versions */\n#define ESTALE_FSTAT(errno) \\\n\t((errno) == ESTALE || (errno) == ENOENT)\n\n#if !defined(_POSIX_SYNCHRONIZED_IO) && \\\n    defined(__ENVIRONMENT_MAC_OS_X_VERSION_MIN_REQUIRED__) && \\\n    (__ENVIRONMENT_MAC_OS_X_VERSION_MIN_REQUIRED__ >= 1060)\n/* OS X Snow Leopard has fdatasync(), but no prototype for it. */\nint fdatasync(int);\n#endif\n\n/* Try to keep IO operations at least this size */\n#ifndef IO_BLOCK_SIZE\n#  define IO_BLOCK_SIZE 8192\n#endif\n/* Default size for data blocks transferred over the network */\n#ifndef NET_BLOCK_SIZE\n#  define NET_BLOCK_SIZE (128*1024)\n#endif\n\n#if !defined(PIPE_BUF) && defined(_POSIX_PIPE_BUF)\n#  define PIPE_BUF (8 * _POSIX_PIPE_BUF) /* for HURD */\n#endif\n\n#endif\n"}, "21": {"id": 21, "path": "/usr/include/stdlib.h", "content": "/* Copyright (C) 1991-2018 Free Software Foundation, Inc.\n   This file is part of the GNU C Library.\n\n   The GNU C Library is free software; you can redistribute it and/or\n   modify it under the terms of the GNU Lesser General Public\n   License as published by the Free Software Foundation; either\n   version 2.1 of the License, or (at your option) any later version.\n\n   The GNU C Library is distributed in the hope that it will be useful,\n   but WITHOUT ANY WARRANTY; without even the implied warranty of\n   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n   Lesser General Public License for more details.\n\n   You should have received a copy of the GNU Lesser General Public\n   License along with the GNU C Library; if not, see\n   <http://www.gnu.org/licenses/>.  */\n\n/*\n *\tISO C99 Standard: 7.20 General utilities\t<stdlib.h>\n */\n\n#ifndef\t_STDLIB_H\n\n#define __GLIBC_INTERNAL_STARTING_HEADER_IMPLEMENTATION\n#include <bits/libc-header-start.h>\n\n/* Get size_t, wchar_t and NULL from <stddef.h>.  */\n#define __need_size_t\n#define __need_wchar_t\n#define __need_NULL\n#include <stddef.h>\n\n__BEGIN_DECLS\n\n#define\t_STDLIB_H\t1\n\n#if (defined __USE_XOPEN || defined __USE_XOPEN2K8) && !defined _SYS_WAIT_H\n/* XPG requires a few symbols from <sys/wait.h> being defined.  */\n# include <bits/waitflags.h>\n# include <bits/waitstatus.h>\n\n/* Define the macros <sys/wait.h> also would define this way.  */\n# define WEXITSTATUS(status)\t__WEXITSTATUS (status)\n# define WTERMSIG(status)\t__WTERMSIG (status)\n# define WSTOPSIG(status)\t__WSTOPSIG (status)\n# define WIFEXITED(status)\t__WIFEXITED (status)\n# define WIFSIGNALED(status)\t__WIFSIGNALED (status)\n# define WIFSTOPPED(status)\t__WIFSTOPPED (status)\n# ifdef __WIFCONTINUED\n#  define WIFCONTINUED(status)\t__WIFCONTINUED (status)\n# endif\n#endif\t/* X/Open or XPG7 and <sys/wait.h> not included.  */\n\n/* _FloatN API tests for enablement.  */\n#include <bits/floatn.h>\n\n/* Returned by `div'.  */\ntypedef struct\n  {\n    int quot;\t\t\t/* Quotient.  */\n    int rem;\t\t\t/* Remainder.  */\n  } div_t;\n\n/* Returned by `ldiv'.  */\n#ifndef __ldiv_t_defined\ntypedef struct\n  {\n    long int quot;\t\t/* Quotient.  */\n    long int rem;\t\t/* Remainder.  */\n  } ldiv_t;\n# define __ldiv_t_defined\t1\n#endif\n\n#if defined __USE_ISOC99 && !defined __lldiv_t_defined\n/* Returned by `lldiv'.  */\n__extension__ typedef struct\n  {\n    long long int quot;\t\t/* Quotient.  */\n    long long int rem;\t\t/* Remainder.  */\n  } lldiv_t;\n# define __lldiv_t_defined\t1\n#endif\n\n\n/* The largest number rand will return (same as INT_MAX).  */\n#define\tRAND_MAX\t2147483647\n\n\n/* We define these the same for all machines.\n   Changes from this to the outside world should be done in `_exit'.  */\n#define\tEXIT_FAILURE\t1\t/* Failing exit status.  */\n#define\tEXIT_SUCCESS\t0\t/* Successful exit status.  */\n\n\n/* Maximum length of a multibyte character in the current locale.  */\n#define\tMB_CUR_MAX\t(__ctype_get_mb_cur_max ())\nextern size_t __ctype_get_mb_cur_max (void) __THROW __wur;\n\n\n/* Convert a string to a floating-point number.  */\nextern double atof (const char *__nptr)\n     __THROW __attribute_pure__ __nonnull ((1)) __wur;\n/* Convert a string to an integer.  */\nextern int atoi (const char *__nptr)\n     __THROW __attribute_pure__ __nonnull ((1)) __wur;\n/* Convert a string to a long integer.  */\nextern long int atol (const char *__nptr)\n     __THROW __attribute_pure__ __nonnull ((1)) __wur;\n\n#ifdef __USE_ISOC99\n/* Convert a string to a long long integer.  */\n__extension__ extern long long int atoll (const char *__nptr)\n     __THROW __attribute_pure__ __nonnull ((1)) __wur;\n#endif\n\n/* Convert a string to a floating-point number.  */\nextern double strtod (const char *__restrict __nptr,\n\t\t      char **__restrict __endptr)\n     __THROW __nonnull ((1));\n\n#ifdef\t__USE_ISOC99\n/* Likewise for `float' and `long double' sizes of floating-point numbers.  */\nextern float strtof (const char *__restrict __nptr,\n\t\t     char **__restrict __endptr) __THROW __nonnull ((1));\n\nextern long double strtold (const char *__restrict __nptr,\n\t\t\t    char **__restrict __endptr)\n     __THROW __nonnull ((1));\n#endif\n\n/* Likewise for '_FloatN' and '_FloatNx'.  */\n\n#if __HAVE_FLOAT16 && __GLIBC_USE (IEC_60559_TYPES_EXT)\nextern _Float16 strtof16 (const char *__restrict __nptr,\n\t\t\t  char **__restrict __endptr)\n     __THROW __nonnull ((1));\n#endif\n\n#if __HAVE_FLOAT32 && __GLIBC_USE (IEC_60559_TYPES_EXT)\nextern _Float32 strtof32 (const char *__restrict __nptr,\n\t\t\t  char **__restrict __endptr)\n     __THROW __nonnull ((1));\n#endif\n\n#if __HAVE_FLOAT64 && __GLIBC_USE (IEC_60559_TYPES_EXT)\nextern _Float64 strtof64 (const char *__restrict __nptr,\n\t\t\t  char **__restrict __endptr)\n     __THROW __nonnull ((1));\n#endif\n\n#if __HAVE_FLOAT128 && __GLIBC_USE (IEC_60559_TYPES_EXT)\nextern _Float128 strtof128 (const char *__restrict __nptr,\n\t\t\t    char **__restrict __endptr)\n     __THROW __nonnull ((1));\n#endif\n\n#if __HAVE_FLOAT32X && __GLIBC_USE (IEC_60559_TYPES_EXT)\nextern _Float32x strtof32x (const char *__restrict __nptr,\n\t\t\t    char **__restrict __endptr)\n     __THROW __nonnull ((1));\n#endif\n\n#if __HAVE_FLOAT64X && __GLIBC_USE (IEC_60559_TYPES_EXT)\nextern _Float64x strtof64x (const char *__restrict __nptr,\n\t\t\t    char **__restrict __endptr)\n     __THROW __nonnull ((1));\n#endif\n\n#if __HAVE_FLOAT128X && __GLIBC_USE (IEC_60559_TYPES_EXT)\nextern _Float128x strtof128x (const char *__restrict __nptr,\n\t\t\t      char **__restrict __endptr)\n     __THROW __nonnull ((1));\n#endif\n\n/* Convert a string to a long integer.  */\nextern long int strtol (const char *__restrict __nptr,\n\t\t\tchar **__restrict __endptr, int __base)\n     __THROW __nonnull ((1));\n/* Convert a string to an unsigned long integer.  */\nextern unsigned long int strtoul (const char *__restrict __nptr,\n\t\t\t\t  char **__restrict __endptr, int __base)\n     __THROW __nonnull ((1));\n\n#ifdef __USE_MISC\n/* Convert a string to a quadword integer.  */\n__extension__\nextern long long int strtoq (const char *__restrict __nptr,\n\t\t\t     char **__restrict __endptr, int __base)\n     __THROW __nonnull ((1));\n/* Convert a string to an unsigned quadword integer.  */\n__extension__\nextern unsigned long long int strtouq (const char *__restrict __nptr,\n\t\t\t\t       char **__restrict __endptr, int __base)\n     __THROW __nonnull ((1));\n#endif /* Use misc.  */\n\n#ifdef __USE_ISOC99\n/* Convert a string to a quadword integer.  */\n__extension__\nextern long long int strtoll (const char *__restrict __nptr,\n\t\t\t      char **__restrict __endptr, int __base)\n     __THROW __nonnull ((1));\n/* Convert a string to an unsigned quadword integer.  */\n__extension__\nextern unsigned long long int strtoull (const char *__restrict __nptr,\n\t\t\t\t\tchar **__restrict __endptr, int __base)\n     __THROW __nonnull ((1));\n#endif /* ISO C99 or use MISC.  */\n\n/* Convert a floating-point number to a string.  */\n#if __GLIBC_USE (IEC_60559_BFP_EXT)\nextern int strfromd (char *__dest, size_t __size, const char *__format,\n\t\t     double __f)\n     __THROW __nonnull ((3));\n\nextern int strfromf (char *__dest, size_t __size, const char *__format,\n\t\t     float __f)\n     __THROW __nonnull ((3));\n\nextern int strfroml (char *__dest, size_t __size, const char *__format,\n\t\t     long double __f)\n     __THROW __nonnull ((3));\n#endif\n\n#if __HAVE_FLOAT16 && __GLIBC_USE (IEC_60559_TYPES_EXT)\nextern int strfromf16 (char *__dest, size_t __size, const char * __format,\n\t\t       _Float16 __f)\n     __THROW __nonnull ((3));\n#endif\n\n#if __HAVE_FLOAT32 && __GLIBC_USE (IEC_60559_TYPES_EXT)\nextern int strfromf32 (char *__dest, size_t __size, const char * __format,\n\t\t       _Float32 __f)\n     __THROW __nonnull ((3));\n#endif\n\n#if __HAVE_FLOAT64 && __GLIBC_USE (IEC_60559_TYPES_EXT)\nextern int strfromf64 (char *__dest, size_t __size, const char * __format,\n\t\t       _Float64 __f)\n     __THROW __nonnull ((3));\n#endif\n\n#if __HAVE_FLOAT128 && __GLIBC_USE (IEC_60559_TYPES_EXT)\nextern int strfromf128 (char *__dest, size_t __size, const char * __format,\n\t\t\t_Float128 __f)\n     __THROW __nonnull ((3));\n#endif\n\n#if __HAVE_FLOAT32X && __GLIBC_USE (IEC_60559_TYPES_EXT)\nextern int strfromf32x (char *__dest, size_t __size, const char * __format,\n\t\t\t_Float32x __f)\n     __THROW __nonnull ((3));\n#endif\n\n#if __HAVE_FLOAT64X && __GLIBC_USE (IEC_60559_TYPES_EXT)\nextern int strfromf64x (char *__dest, size_t __size, const char * __format,\n\t\t\t_Float64x __f)\n     __THROW __nonnull ((3));\n#endif\n\n#if __HAVE_FLOAT128X && __GLIBC_USE (IEC_60559_TYPES_EXT)\nextern int strfromf128x (char *__dest, size_t __size, const char * __format,\n\t\t\t _Float128x __f)\n     __THROW __nonnull ((3));\n#endif\n\n\n#ifdef __USE_GNU\n/* Parallel versions of the functions above which take the locale to\n   use as an additional parameter.  These are GNU extensions inspired\n   by the POSIX.1-2008 extended locale API.  */\n# include <bits/types/locale_t.h>\n\nextern long int strtol_l (const char *__restrict __nptr,\n\t\t\t  char **__restrict __endptr, int __base,\n\t\t\t  locale_t __loc) __THROW __nonnull ((1, 4));\n\nextern unsigned long int strtoul_l (const char *__restrict __nptr,\n\t\t\t\t    char **__restrict __endptr,\n\t\t\t\t    int __base, locale_t __loc)\n     __THROW __nonnull ((1, 4));\n\n__extension__\nextern long long int strtoll_l (const char *__restrict __nptr,\n\t\t\t\tchar **__restrict __endptr, int __base,\n\t\t\t\tlocale_t __loc)\n     __THROW __nonnull ((1, 4));\n\n__extension__\nextern unsigned long long int strtoull_l (const char *__restrict __nptr,\n\t\t\t\t\t  char **__restrict __endptr,\n\t\t\t\t\t  int __base, locale_t __loc)\n     __THROW __nonnull ((1, 4));\n\nextern double strtod_l (const char *__restrict __nptr,\n\t\t\tchar **__restrict __endptr, locale_t __loc)\n     __THROW __nonnull ((1, 3));\n\nextern float strtof_l (const char *__restrict __nptr,\n\t\t       char **__restrict __endptr, locale_t __loc)\n     __THROW __nonnull ((1, 3));\n\nextern long double strtold_l (const char *__restrict __nptr,\n\t\t\t      char **__restrict __endptr,\n\t\t\t      locale_t __loc)\n     __THROW __nonnull ((1, 3));\n\n# if __HAVE_FLOAT16\nextern _Float16 strtof16_l (const char *__restrict __nptr,\n\t\t\t    char **__restrict __endptr,\n\t\t\t    locale_t __loc)\n     __THROW __nonnull ((1, 3));\n# endif\n\n# if __HAVE_FLOAT32\nextern _Float32 strtof32_l (const char *__restrict __nptr,\n\t\t\t    char **__restrict __endptr,\n\t\t\t    locale_t __loc)\n     __THROW __nonnull ((1, 3));\n# endif\n\n# if __HAVE_FLOAT64\nextern _Float64 strtof64_l (const char *__restrict __nptr,\n\t\t\t    char **__restrict __endptr,\n\t\t\t    locale_t __loc)\n     __THROW __nonnull ((1, 3));\n# endif\n\n# if __HAVE_FLOAT128\nextern _Float128 strtof128_l (const char *__restrict __nptr,\n\t\t\t      char **__restrict __endptr,\n\t\t\t      locale_t __loc)\n     __THROW __nonnull ((1, 3));\n# endif\n\n# if __HAVE_FLOAT32X\nextern _Float32x strtof32x_l (const char *__restrict __nptr,\n\t\t\t      char **__restrict __endptr,\n\t\t\t      locale_t __loc)\n     __THROW __nonnull ((1, 3));\n# endif\n\n# if __HAVE_FLOAT64X\nextern _Float64x strtof64x_l (const char *__restrict __nptr,\n\t\t\t      char **__restrict __endptr,\n\t\t\t      locale_t __loc)\n     __THROW __nonnull ((1, 3));\n# endif\n\n# if __HAVE_FLOAT128X\nextern _Float128x strtof128x_l (const char *__restrict __nptr,\n\t\t\t\tchar **__restrict __endptr,\n\t\t\t\tlocale_t __loc)\n     __THROW __nonnull ((1, 3));\n# endif\n#endif /* GNU */\n\n\n#ifdef __USE_EXTERN_INLINES\n__extern_inline int\n__NTH (atoi (const char *__nptr))\n{\n  return (int) strtol (__nptr, (char **) NULL, 10);\n}\n__extern_inline long int\n__NTH (atol (const char *__nptr))\n{\n  return strtol (__nptr, (char **) NULL, 10);\n}\n\n# ifdef __USE_ISOC99\n__extension__ __extern_inline long long int\n__NTH (atoll (const char *__nptr))\n{\n  return strtoll (__nptr, (char **) NULL, 10);\n}\n# endif\n#endif /* Optimizing and Inlining.  */\n\n\n#if defined __USE_MISC || defined __USE_XOPEN_EXTENDED\n/* Convert N to base 64 using the digits \"./0-9A-Za-z\", least-significant\n   digit first.  Returns a pointer to static storage overwritten by the\n   next call.  */\nextern char *l64a (long int __n) __THROW __wur;\n\n/* Read a number from a string S in base 64 as above.  */\nextern long int a64l (const char *__s)\n     __THROW __attribute_pure__ __nonnull ((1)) __wur;\n\n#endif\t/* Use misc || extended X/Open.  */\n\n#if defined __USE_MISC || defined __USE_XOPEN_EXTENDED\n# include <sys/types.h>\t/* we need int32_t... */\n\n/* These are the functions that actually do things.  The `random', `srandom',\n   `initstate' and `setstate' functions are those from BSD Unices.\n   The `rand' and `srand' functions are required by the ANSI standard.\n   We provide both interfaces to the same random number generator.  */\n/* Return a random long integer between 0 and RAND_MAX inclusive.  */\nextern long int random (void) __THROW;\n\n/* Seed the random number generator with the given number.  */\nextern void srandom (unsigned int __seed) __THROW;\n\n/* Initialize the random number generator to use state buffer STATEBUF,\n   of length STATELEN, and seed it with SEED.  Optimal lengths are 8, 16,\n   32, 64, 128 and 256, the bigger the better; values less than 8 will\n   cause an error and values greater than 256 will be rounded down.  */\nextern char *initstate (unsigned int __seed, char *__statebuf,\n\t\t\tsize_t __statelen) __THROW __nonnull ((2));\n\n/* Switch the random number generator to state buffer STATEBUF,\n   which should have been previously initialized by `initstate'.  */\nextern char *setstate (char *__statebuf) __THROW __nonnull ((1));\n\n\n# ifdef __USE_MISC\n/* Reentrant versions of the `random' family of functions.\n   These functions all use the following data structure to contain\n   state, rather than global state variables.  */\n\nstruct random_data\n  {\n    int32_t *fptr;\t\t/* Front pointer.  */\n    int32_t *rptr;\t\t/* Rear pointer.  */\n    int32_t *state;\t\t/* Array of state values.  */\n    int rand_type;\t\t/* Type of random number generator.  */\n    int rand_deg;\t\t/* Degree of random number generator.  */\n    int rand_sep;\t\t/* Distance between front and rear.  */\n    int32_t *end_ptr;\t\t/* Pointer behind state table.  */\n  };\n\nextern int random_r (struct random_data *__restrict __buf,\n\t\t     int32_t *__restrict __result) __THROW __nonnull ((1, 2));\n\nextern int srandom_r (unsigned int __seed, struct random_data *__buf)\n     __THROW __nonnull ((2));\n\nextern int initstate_r (unsigned int __seed, char *__restrict __statebuf,\n\t\t\tsize_t __statelen,\n\t\t\tstruct random_data *__restrict __buf)\n     __THROW __nonnull ((2, 4));\n\nextern int setstate_r (char *__restrict __statebuf,\n\t\t       struct random_data *__restrict __buf)\n     __THROW __nonnull ((1, 2));\n# endif\t/* Use misc.  */\n#endif\t/* Use extended X/Open || misc. */\n\n\n/* Return a random integer between 0 and RAND_MAX inclusive.  */\nextern int rand (void) __THROW;\n/* Seed the random number generator with the given number.  */\nextern void srand (unsigned int __seed) __THROW;\n\n#ifdef __USE_POSIX199506\n/* Reentrant interface according to POSIX.1.  */\nextern int rand_r (unsigned int *__seed) __THROW;\n#endif\n\n\n#if defined __USE_MISC || defined __USE_XOPEN\n/* System V style 48-bit random number generator functions.  */\n\n/* Return non-negative, double-precision floating-point value in [0.0,1.0).  */\nextern double drand48 (void) __THROW;\nextern double erand48 (unsigned short int __xsubi[3]) __THROW __nonnull ((1));\n\n/* Return non-negative, long integer in [0,2^31).  */\nextern long int lrand48 (void) __THROW;\nextern long int nrand48 (unsigned short int __xsubi[3])\n     __THROW __nonnull ((1));\n\n/* Return signed, long integers in [-2^31,2^31).  */\nextern long int mrand48 (void) __THROW;\nextern long int jrand48 (unsigned short int __xsubi[3])\n     __THROW __nonnull ((1));\n\n/* Seed random number generator.  */\nextern void srand48 (long int __seedval) __THROW;\nextern unsigned short int *seed48 (unsigned short int __seed16v[3])\n     __THROW __nonnull ((1));\nextern void lcong48 (unsigned short int __param[7]) __THROW __nonnull ((1));\n\n# ifdef __USE_MISC\n/* Data structure for communication with thread safe versions.  This\n   type is to be regarded as opaque.  It's only exported because users\n   have to allocate objects of this type.  */\nstruct drand48_data\n  {\n    unsigned short int __x[3];\t/* Current state.  */\n    unsigned short int __old_x[3]; /* Old state.  */\n    unsigned short int __c;\t/* Additive const. in congruential formula.  */\n    unsigned short int __init;\t/* Flag for initializing.  */\n    __extension__ unsigned long long int __a;\t/* Factor in congruential\n\t\t\t\t\t\t   formula.  */\n  };\n\n/* Return non-negative, double-precision floating-point value in [0.0,1.0).  */\nextern int drand48_r (struct drand48_data *__restrict __buffer,\n\t\t      double *__restrict __result) __THROW __nonnull ((1, 2));\nextern int erand48_r (unsigned short int __xsubi[3],\n\t\t      struct drand48_data *__restrict __buffer,\n\t\t      double *__restrict __result) __THROW __nonnull ((1, 2));\n\n/* Return non-negative, long integer in [0,2^31).  */\nextern int lrand48_r (struct drand48_data *__restrict __buffer,\n\t\t      long int *__restrict __result)\n     __THROW __nonnull ((1, 2));\nextern int nrand48_r (unsigned short int __xsubi[3],\n\t\t      struct drand48_data *__restrict __buffer,\n\t\t      long int *__restrict __result)\n     __THROW __nonnull ((1, 2));\n\n/* Return signed, long integers in [-2^31,2^31).  */\nextern int mrand48_r (struct drand48_data *__restrict __buffer,\n\t\t      long int *__restrict __result)\n     __THROW __nonnull ((1, 2));\nextern int jrand48_r (unsigned short int __xsubi[3],\n\t\t      struct drand48_data *__restrict __buffer,\n\t\t      long int *__restrict __result)\n     __THROW __nonnull ((1, 2));\n\n/* Seed random number generator.  */\nextern int srand48_r (long int __seedval, struct drand48_data *__buffer)\n     __THROW __nonnull ((2));\n\nextern int seed48_r (unsigned short int __seed16v[3],\n\t\t     struct drand48_data *__buffer) __THROW __nonnull ((1, 2));\n\nextern int lcong48_r (unsigned short int __param[7],\n\t\t      struct drand48_data *__buffer)\n     __THROW __nonnull ((1, 2));\n# endif\t/* Use misc.  */\n#endif\t/* Use misc or X/Open.  */\n\n/* Allocate SIZE bytes of memory.  */\nextern void *malloc (size_t __size) __THROW __attribute_malloc__ __wur;\n/* Allocate NMEMB elements of SIZE bytes each, all initialized to 0.  */\nextern void *calloc (size_t __nmemb, size_t __size)\n     __THROW __attribute_malloc__ __wur;\n\n/* Re-allocate the previously allocated block\n   in PTR, making the new block SIZE bytes long.  */\n/* __attribute_malloc__ is not used, because if realloc returns\n   the same pointer that was passed to it, aliasing needs to be allowed\n   between objects pointed by the old and new pointers.  */\nextern void *realloc (void *__ptr, size_t __size)\n     __THROW __attribute_warn_unused_result__;\n\n#ifdef __USE_GNU\n/* Re-allocate the previously allocated block in PTR, making the new\n   block large enough for NMEMB elements of SIZE bytes each.  */\n/* __attribute_malloc__ is not used, because if reallocarray returns\n   the same pointer that was passed to it, aliasing needs to be allowed\n   between objects pointed by the old and new pointers.  */\nextern void *reallocarray (void *__ptr, size_t __nmemb, size_t __size)\n     __THROW __attribute_warn_unused_result__;\n#endif\n\n/* Free a block allocated by `malloc', `realloc' or `calloc'.  */\nextern void free (void *__ptr) __THROW;\n\n#ifdef __USE_MISC\n# include <alloca.h>\n#endif /* Use misc.  */\n\n#if (defined __USE_XOPEN_EXTENDED && !defined __USE_XOPEN2K) \\\n    || defined __USE_MISC\n/* Allocate SIZE bytes on a page boundary.  The storage cannot be freed.  */\nextern void *valloc (size_t __size) __THROW __attribute_malloc__ __wur;\n#endif\n\n#ifdef __USE_XOPEN2K\n/* Allocate memory of SIZE bytes with an alignment of ALIGNMENT.  */\nextern int posix_memalign (void **__memptr, size_t __alignment, size_t __size)\n     __THROW __nonnull ((1)) __wur;\n#endif\n\n#ifdef __USE_ISOC11\n/* ISO C variant of aligned allocation.  */\nextern void *aligned_alloc (size_t __alignment, size_t __size)\n     __THROW __attribute_malloc__ __attribute_alloc_size__ ((2)) __wur;\n#endif\n\n/* Abort execution and generate a core-dump.  */\nextern void abort (void) __THROW __attribute__ ((__noreturn__));\n\n\n/* Register a function to be called when `exit' is called.  */\nextern int atexit (void (*__func) (void)) __THROW __nonnull ((1));\n\n#if defined __USE_ISOC11 || defined __USE_ISOCXX11\n/* Register a function to be called when `quick_exit' is called.  */\n# ifdef __cplusplus\nextern \"C++\" int at_quick_exit (void (*__func) (void))\n     __THROW __asm (\"at_quick_exit\") __nonnull ((1));\n# else\nextern int at_quick_exit (void (*__func) (void)) __THROW __nonnull ((1));\n# endif\n#endif\n\n#ifdef\t__USE_MISC\n/* Register a function to be called with the status\n   given to `exit' and the given argument.  */\nextern int on_exit (void (*__func) (int __status, void *__arg), void *__arg)\n     __THROW __nonnull ((1));\n#endif\n\n/* Call all functions registered with `atexit' and `on_exit',\n   in the reverse of the order in which they were registered,\n   perform stdio cleanup, and terminate program execution with STATUS.  */\nextern void exit (int __status) __THROW __attribute__ ((__noreturn__));\n\n#if defined __USE_ISOC11 || defined __USE_ISOCXX11\n/* Call all functions registered with `at_quick_exit' in the reverse\n   of the order in which they were registered and terminate program\n   execution with STATUS.  */\nextern void quick_exit (int __status) __THROW __attribute__ ((__noreturn__));\n#endif\n\n#ifdef __USE_ISOC99\n/* Terminate the program with STATUS without calling any of the\n   functions registered with `atexit' or `on_exit'.  */\nextern void _Exit (int __status) __THROW __attribute__ ((__noreturn__));\n#endif\n\n\n/* Return the value of envariable NAME, or NULL if it doesn't exist.  */\nextern char *getenv (const char *__name) __THROW __nonnull ((1)) __wur;\n\n#ifdef __USE_GNU\n/* This function is similar to the above but returns NULL if the\n   programs is running with SUID or SGID enabled.  */\nextern char *secure_getenv (const char *__name)\n     __THROW __nonnull ((1)) __wur;\n#endif\n\n#if defined __USE_MISC || defined __USE_XOPEN\n/* The SVID says this is in <stdio.h>, but this seems a better place.\t*/\n/* Put STRING, which is of the form \"NAME=VALUE\", in the environment.\n   If there is no `=', remove NAME from the environment.  */\nextern int putenv (char *__string) __THROW __nonnull ((1));\n#endif\n\n#ifdef __USE_XOPEN2K\n/* Set NAME to VALUE in the environment.\n   If REPLACE is nonzero, overwrite an existing value.  */\nextern int setenv (const char *__name, const char *__value, int __replace)\n     __THROW __nonnull ((2));\n\n/* Remove the variable NAME from the environment.  */\nextern int unsetenv (const char *__name) __THROW __nonnull ((1));\n#endif\n\n#ifdef\t__USE_MISC\n/* The `clearenv' was planned to be added to POSIX.1 but probably\n   never made it.  Nevertheless the POSIX.9 standard (POSIX bindings\n   for Fortran 77) requires this function.  */\nextern int clearenv (void) __THROW;\n#endif\n\n\n#if defined __USE_MISC \\\n    || (defined __USE_XOPEN_EXTENDED && !defined __USE_XOPEN2K8)\n/* Generate a unique temporary file name from TEMPLATE.\n   The last six characters of TEMPLATE must be \"XXXXXX\";\n   they are replaced with a string that makes the file name unique.\n   Always returns TEMPLATE, it's either a temporary file name or a null\n   string if it cannot get a unique file name.  */\nextern char *mktemp (char *__template) __THROW __nonnull ((1));\n#endif\n\n#if defined __USE_XOPEN_EXTENDED || defined __USE_XOPEN2K8\n/* Generate a unique temporary file name from TEMPLATE.\n   The last six characters of TEMPLATE must be \"XXXXXX\";\n   they are replaced with a string that makes the filename unique.\n   Returns a file descriptor open on the file for reading and writing,\n   or -1 if it cannot create a uniquely-named file.\n\n   This function is a possible cancellation point and therefore not\n   marked with __THROW.  */\n# ifndef __USE_FILE_OFFSET64\nextern int mkstemp (char *__template) __nonnull ((1)) __wur;\n# else\n#  ifdef __REDIRECT\nextern int __REDIRECT (mkstemp, (char *__template), mkstemp64)\n     __nonnull ((1)) __wur;\n#  else\n#   define mkstemp mkstemp64\n#  endif\n# endif\n# ifdef __USE_LARGEFILE64\nextern int mkstemp64 (char *__template) __nonnull ((1)) __wur;\n# endif\n#endif\n\n#ifdef __USE_MISC\n/* Similar to mkstemp, but the template can have a suffix after the\n   XXXXXX.  The length of the suffix is specified in the second\n   parameter.\n\n   This function is a possible cancellation point and therefore not\n   marked with __THROW.  */\n# ifndef __USE_FILE_OFFSET64\nextern int mkstemps (char *__template, int __suffixlen) __nonnull ((1)) __wur;\n# else\n#  ifdef __REDIRECT\nextern int __REDIRECT (mkstemps, (char *__template, int __suffixlen),\n\t\t       mkstemps64) __nonnull ((1)) __wur;\n#  else\n#   define mkstemps mkstemps64\n#  endif\n# endif\n# ifdef __USE_LARGEFILE64\nextern int mkstemps64 (char *__template, int __suffixlen)\n     __nonnull ((1)) __wur;\n# endif\n#endif\n\n#ifdef __USE_XOPEN2K8\n/* Create a unique temporary directory from TEMPLATE.\n   The last six characters of TEMPLATE must be \"XXXXXX\";\n   they are replaced with a string that makes the directory name unique.\n   Returns TEMPLATE, or a null pointer if it cannot get a unique name.\n   The directory is created mode 700.  */\nextern char *mkdtemp (char *__template) __THROW __nonnull ((1)) __wur;\n#endif\n\n#ifdef __USE_GNU\n/* Generate a unique temporary file name from TEMPLATE similar to\n   mkstemp.  But allow the caller to pass additional flags which are\n   used in the open call to create the file..\n\n   This function is a possible cancellation point and therefore not\n   marked with __THROW.  */\n# ifndef __USE_FILE_OFFSET64\nextern int mkostemp (char *__template, int __flags) __nonnull ((1)) __wur;\n# else\n#  ifdef __REDIRECT\nextern int __REDIRECT (mkostemp, (char *__template, int __flags), mkostemp64)\n     __nonnull ((1)) __wur;\n#  else\n#   define mkostemp mkostemp64\n#  endif\n# endif\n# ifdef __USE_LARGEFILE64\nextern int mkostemp64 (char *__template, int __flags) __nonnull ((1)) __wur;\n# endif\n\n/* Similar to mkostemp, but the template can have a suffix after the\n   XXXXXX.  The length of the suffix is specified in the second\n   parameter.\n\n   This function is a possible cancellation point and therefore not\n   marked with __THROW.  */\n# ifndef __USE_FILE_OFFSET64\nextern int mkostemps (char *__template, int __suffixlen, int __flags)\n     __nonnull ((1)) __wur;\n# else\n#  ifdef __REDIRECT\nextern int __REDIRECT (mkostemps, (char *__template, int __suffixlen,\n\t\t\t\t   int __flags), mkostemps64)\n     __nonnull ((1)) __wur;\n#  else\n#   define mkostemps mkostemps64\n#  endif\n# endif\n# ifdef __USE_LARGEFILE64\nextern int mkostemps64 (char *__template, int __suffixlen, int __flags)\n     __nonnull ((1)) __wur;\n# endif\n#endif\n\n\n/* Execute the given line as a shell command.\n\n   This function is a cancellation point and therefore not marked with\n   __THROW.  */\nextern int system (const char *__command) __wur;\n\n\n#ifdef\t__USE_GNU\n/* Return a malloc'd string containing the canonical absolute name of the\n   existing named file.  */\nextern char *canonicalize_file_name (const char *__name)\n     __THROW __nonnull ((1)) __wur;\n#endif\n\n#if defined __USE_MISC || defined __USE_XOPEN_EXTENDED\n/* Return the canonical absolute name of file NAME.  If RESOLVED is\n   null, the result is malloc'd; otherwise, if the canonical name is\n   PATH_MAX chars or more, returns null with `errno' set to\n   ENAMETOOLONG; if the name fits in fewer than PATH_MAX chars,\n   returns the name in RESOLVED.  */\nextern char *realpath (const char *__restrict __name,\n\t\t       char *__restrict __resolved) __THROW __wur;\n#endif\n\n\n/* Shorthand for type of comparison functions.  */\n#ifndef __COMPAR_FN_T\n# define __COMPAR_FN_T\ntypedef int (*__compar_fn_t) (const void *, const void *);\n\n# ifdef\t__USE_GNU\ntypedef __compar_fn_t comparison_fn_t;\n# endif\n#endif\n#ifdef __USE_GNU\ntypedef int (*__compar_d_fn_t) (const void *, const void *, void *);\n#endif\n\n/* Do a binary search for KEY in BASE, which consists of NMEMB elements\n   of SIZE bytes each, using COMPAR to perform the comparisons.  */\nextern void *bsearch (const void *__key, const void *__base,\n\t\t      size_t __nmemb, size_t __size, __compar_fn_t __compar)\n     __nonnull ((1, 2, 5)) __wur;\n\n#ifdef __USE_EXTERN_INLINES\n# include <bits/stdlib-bsearch.h>\n#endif\n\n/* Sort NMEMB elements of BASE, of SIZE bytes each,\n   using COMPAR to perform the comparisons.  */\nextern void qsort (void *__base, size_t __nmemb, size_t __size,\n\t\t   __compar_fn_t __compar) __nonnull ((1, 4));\n#ifdef __USE_GNU\nextern void qsort_r (void *__base, size_t __nmemb, size_t __size,\n\t\t     __compar_d_fn_t __compar, void *__arg)\n  __nonnull ((1, 4));\n#endif\n\n\n/* Return the absolute value of X.  */\nextern int abs (int __x) __THROW __attribute__ ((__const__)) __wur;\nextern long int labs (long int __x) __THROW __attribute__ ((__const__)) __wur;\n\n#ifdef __USE_ISOC99\n__extension__ extern long long int llabs (long long int __x)\n     __THROW __attribute__ ((__const__)) __wur;\n#endif\n\n\n/* Return the `div_t', `ldiv_t' or `lldiv_t' representation\n   of the value of NUMER over DENOM. */\n/* GCC may have built-ins for these someday.  */\nextern div_t div (int __numer, int __denom)\n     __THROW __attribute__ ((__const__)) __wur;\nextern ldiv_t ldiv (long int __numer, long int __denom)\n     __THROW __attribute__ ((__const__)) __wur;\n\n#ifdef __USE_ISOC99\n__extension__ extern lldiv_t lldiv (long long int __numer,\n\t\t\t\t    long long int __denom)\n     __THROW __attribute__ ((__const__)) __wur;\n#endif\n\n\n#if (defined __USE_XOPEN_EXTENDED && !defined __USE_XOPEN2K8) \\\n    || defined __USE_MISC\n/* Convert floating point numbers to strings.  The returned values are\n   valid only until another call to the same function.  */\n\n/* Convert VALUE to a string with NDIGIT digits and return a pointer to\n   this.  Set *DECPT with the position of the decimal character and *SIGN\n   with the sign of the number.  */\nextern char *ecvt (double __value, int __ndigit, int *__restrict __decpt,\n\t\t   int *__restrict __sign) __THROW __nonnull ((3, 4)) __wur;\n\n/* Convert VALUE to a string rounded to NDIGIT decimal digits.  Set *DECPT\n   with the position of the decimal character and *SIGN with the sign of\n   the number.  */\nextern char *fcvt (double __value, int __ndigit, int *__restrict __decpt,\n\t\t   int *__restrict __sign) __THROW __nonnull ((3, 4)) __wur;\n\n/* If possible convert VALUE to a string with NDIGIT significant digits.\n   Otherwise use exponential representation.  The resulting string will\n   be written to BUF.  */\nextern char *gcvt (double __value, int __ndigit, char *__buf)\n     __THROW __nonnull ((3)) __wur;\n#endif\n\n#ifdef __USE_MISC\n/* Long double versions of above functions.  */\nextern char *qecvt (long double __value, int __ndigit,\n\t\t    int *__restrict __decpt, int *__restrict __sign)\n     __THROW __nonnull ((3, 4)) __wur;\nextern char *qfcvt (long double __value, int __ndigit,\n\t\t    int *__restrict __decpt, int *__restrict __sign)\n     __THROW __nonnull ((3, 4)) __wur;\nextern char *qgcvt (long double __value, int __ndigit, char *__buf)\n     __THROW __nonnull ((3)) __wur;\n\n\n/* Reentrant version of the functions above which provide their own\n   buffers.  */\nextern int ecvt_r (double __value, int __ndigit, int *__restrict __decpt,\n\t\t   int *__restrict __sign, char *__restrict __buf,\n\t\t   size_t __len) __THROW __nonnull ((3, 4, 5));\nextern int fcvt_r (double __value, int __ndigit, int *__restrict __decpt,\n\t\t   int *__restrict __sign, char *__restrict __buf,\n\t\t   size_t __len) __THROW __nonnull ((3, 4, 5));\n\nextern int qecvt_r (long double __value, int __ndigit,\n\t\t    int *__restrict __decpt, int *__restrict __sign,\n\t\t    char *__restrict __buf, size_t __len)\n     __THROW __nonnull ((3, 4, 5));\nextern int qfcvt_r (long double __value, int __ndigit,\n\t\t    int *__restrict __decpt, int *__restrict __sign,\n\t\t    char *__restrict __buf, size_t __len)\n     __THROW __nonnull ((3, 4, 5));\n#endif\t/* misc */\n\n\n/* Return the length of the multibyte character\n   in S, which is no longer than N.  */\nextern int mblen (const char *__s, size_t __n) __THROW;\n/* Return the length of the given multibyte character,\n   putting its `wchar_t' representation in *PWC.  */\nextern int mbtowc (wchar_t *__restrict __pwc,\n\t\t   const char *__restrict __s, size_t __n) __THROW;\n/* Put the multibyte character represented\n   by WCHAR in S, returning its length.  */\nextern int wctomb (char *__s, wchar_t __wchar) __THROW;\n\n\n/* Convert a multibyte string to a wide char string.  */\nextern size_t mbstowcs (wchar_t *__restrict  __pwcs,\n\t\t\tconst char *__restrict __s, size_t __n) __THROW;\n/* Convert a wide char string to multibyte string.  */\nextern size_t wcstombs (char *__restrict __s,\n\t\t\tconst wchar_t *__restrict __pwcs, size_t __n)\n     __THROW;\n\n\n#ifdef __USE_MISC\n/* Determine whether the string value of RESPONSE matches the affirmation\n   or negative response expression as specified by the LC_MESSAGES category\n   in the program's current locale.  Returns 1 if affirmative, 0 if\n   negative, and -1 if not matching.  */\nextern int rpmatch (const char *__response) __THROW __nonnull ((1)) __wur;\n#endif\n\n\n#if defined __USE_XOPEN_EXTENDED || defined __USE_XOPEN2K8\n/* Parse comma separated suboption from *OPTIONP and match against\n   strings in TOKENS.  If found return index and set *VALUEP to\n   optional value introduced by an equal sign.  If the suboption is\n   not part of TOKENS return in *VALUEP beginning of unknown\n   suboption.  On exit *OPTIONP is set to the beginning of the next\n   token or at the terminating NUL character.  */\nextern int getsubopt (char **__restrict __optionp,\n\t\t      char *const *__restrict __tokens,\n\t\t      char **__restrict __valuep)\n     __THROW __nonnull ((1, 2, 3)) __wur;\n#endif\n\n\n#ifdef __USE_XOPEN\n/* Setup DES tables according KEY.  */\nextern void setkey (const char *__key) __THROW __nonnull ((1));\n#endif\n\n\n/* X/Open pseudo terminal handling.  */\n\n#ifdef __USE_XOPEN2KXSI\n/* Return a master pseudo-terminal handle.  */\nextern int posix_openpt (int __oflag) __wur;\n#endif\n\n#ifdef __USE_XOPEN_EXTENDED\n/* The next four functions all take a master pseudo-tty fd and\n   perform an operation on the associated slave:  */\n\n/* Chown the slave to the calling user.  */\nextern int grantpt (int __fd) __THROW;\n\n/* Release an internal lock so the slave can be opened.\n   Call after grantpt().  */\nextern int unlockpt (int __fd) __THROW;\n\n/* Return the pathname of the pseudo terminal slave associated with\n   the master FD is open on, or NULL on errors.\n   The returned storage is good until the next call to this function.  */\nextern char *ptsname (int __fd) __THROW __wur;\n#endif\n\n#ifdef __USE_GNU\n/* Store at most BUFLEN characters of the pathname of the slave pseudo\n   terminal associated with the master FD is open on in BUF.\n   Return 0 on success, otherwise an error number.  */\nextern int ptsname_r (int __fd, char *__buf, size_t __buflen)\n     __THROW __nonnull ((2));\n\n/* Open a master pseudo terminal and return its file descriptor.  */\nextern int getpt (void);\n#endif\n\n#ifdef __USE_MISC\n/* Put the 1 minute, 5 minute and 15 minute load averages into the first\n   NELEM elements of LOADAVG.  Return the number written (never more than\n   three, but may be less than NELEM), or -1 if an error occurred.  */\nextern int getloadavg (double __loadavg[], int __nelem)\n     __THROW __nonnull ((1));\n#endif\n\n#if defined __USE_XOPEN_EXTENDED && !defined __USE_XOPEN2K\n/* Return the index into the active-logins file (utmp) for\n   the controlling terminal.  */\nextern int ttyslot (void) __THROW;\n#endif\n\n#include <bits/stdlib-float.h>\n\n/* Define some macros helping to catch buffer overflows.  */\n#if __USE_FORTIFY_LEVEL > 0 && defined __fortify_function\n# include <bits/stdlib.h>\n#endif\n#ifdef __LDBL_COMPAT\n# include <bits/stdlib-ldbl.h>\n#endif\n\n__END_DECLS\n\n#endif /* stdlib.h  */\n"}, "22": {"id": 22, "path": "/usr/include/unistd.h", "content": "/* Copyright (C) 1991-2018 Free Software Foundation, Inc.\n   This file is part of the GNU C Library.\n\n   The GNU C Library is free software; you can redistribute it and/or\n   modify it under the terms of the GNU Lesser General Public\n   License as published by the Free Software Foundation; either\n   version 2.1 of the License, or (at your option) any later version.\n\n   The GNU C Library is distributed in the hope that it will be useful,\n   but WITHOUT ANY WARRANTY; without even the implied warranty of\n   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n   Lesser General Public License for more details.\n\n   You should have received a copy of the GNU Lesser General Public\n   License along with the GNU C Library; if not, see\n   <http://www.gnu.org/licenses/>.  */\n\n/*\n *\tPOSIX Standard: 2.10 Symbolic Constants\t\t<unistd.h>\n */\n\n#ifndef\t_UNISTD_H\n#define\t_UNISTD_H\t1\n\n#include <features.h>\n\n__BEGIN_DECLS\n\n/* These may be used to determine what facilities are present at compile time.\n   Their values can be obtained at run time from `sysconf'.  */\n\n#ifdef __USE_XOPEN2K8\n/* POSIX Standard approved as ISO/IEC 9945-1 as of September 2008.  */\n# define _POSIX_VERSION\t200809L\n#elif defined __USE_XOPEN2K\n/* POSIX Standard approved as ISO/IEC 9945-1 as of December 2001.  */\n# define _POSIX_VERSION\t200112L\n#elif defined __USE_POSIX199506\n/* POSIX Standard approved as ISO/IEC 9945-1 as of June 1995.  */\n# define _POSIX_VERSION\t199506L\n#elif defined __USE_POSIX199309\n/* POSIX Standard approved as ISO/IEC 9945-1 as of September 1993.  */\n# define _POSIX_VERSION\t199309L\n#else\n/* POSIX Standard approved as ISO/IEC 9945-1 as of September 1990.  */\n# define _POSIX_VERSION\t199009L\n#endif\n\n/* These are not #ifdef __USE_POSIX2 because they are\n   in the theoretically application-owned namespace.  */\n\n#ifdef __USE_XOPEN2K8\n# define __POSIX2_THIS_VERSION\t200809L\n/* The utilities on GNU systems also correspond to this version.  */\n#elif defined __USE_XOPEN2K\n/* The utilities on GNU systems also correspond to this version.  */\n# define __POSIX2_THIS_VERSION\t200112L\n#elif defined __USE_POSIX199506\n/* The utilities on GNU systems also correspond to this version.  */\n# define __POSIX2_THIS_VERSION\t199506L\n#else\n/* The utilities on GNU systems also correspond to this version.  */\n# define __POSIX2_THIS_VERSION\t199209L\n#endif\n\n/* The utilities on GNU systems also correspond to this version.  */\n#define _POSIX2_VERSION\t__POSIX2_THIS_VERSION\n\n/* This symbol was required until the 2001 edition of POSIX.  */\n#define\t_POSIX2_C_VERSION\t__POSIX2_THIS_VERSION\n\n/* If defined, the implementation supports the\n   C Language Bindings Option.  */\n#define\t_POSIX2_C_BIND\t__POSIX2_THIS_VERSION\n\n/* If defined, the implementation supports the\n   C Language Development Utilities Option.  */\n#define\t_POSIX2_C_DEV\t__POSIX2_THIS_VERSION\n\n/* If defined, the implementation supports the\n   Software Development Utilities Option.  */\n#define\t_POSIX2_SW_DEV\t__POSIX2_THIS_VERSION\n\n/* If defined, the implementation supports the\n   creation of locales with the localedef utility.  */\n#define _POSIX2_LOCALEDEF       __POSIX2_THIS_VERSION\n\n/* X/Open version number to which the library conforms.  It is selectable.  */\n#ifdef __USE_XOPEN2K8\n# define _XOPEN_VERSION\t700\n#elif defined __USE_XOPEN2K\n# define _XOPEN_VERSION\t600\n#elif defined __USE_UNIX98\n# define _XOPEN_VERSION\t500\n#else\n# define _XOPEN_VERSION\t4\n#endif\n\n/* Commands and utilities from XPG4 are available.  */\n#define _XOPEN_XCU_VERSION\t4\n\n/* We are compatible with the old published standards as well.  */\n#define _XOPEN_XPG2\t1\n#define _XOPEN_XPG3\t1\n#define _XOPEN_XPG4\t1\n\n/* The X/Open Unix extensions are available.  */\n#define _XOPEN_UNIX\t1\n\n/* Encryption is present.  */\n#define\t_XOPEN_CRYPT\t1\n\n/* The enhanced internationalization capabilities according to XPG4.2\n   are present.  */\n#define\t_XOPEN_ENH_I18N\t1\n\n/* The legacy interfaces are also available.  */\n#define _XOPEN_LEGACY\t1\n\n\n/* Get values of POSIX options:\n\n   If these symbols are defined, the corresponding features are\n   always available.  If not, they may be available sometimes.\n   The current values can be obtained with `sysconf'.\n\n   _POSIX_JOB_CONTROL\t\tJob control is supported.\n   _POSIX_SAVED_IDS\t\tProcesses have a saved set-user-ID\n\t\t\t\tand a saved set-group-ID.\n   _POSIX_REALTIME_SIGNALS\tReal-time, queued signals are supported.\n   _POSIX_PRIORITY_SCHEDULING\tPriority scheduling is supported.\n   _POSIX_TIMERS\t\tPOSIX.4 clocks and timers are supported.\n   _POSIX_ASYNCHRONOUS_IO\tAsynchronous I/O is supported.\n   _POSIX_PRIORITIZED_IO\tPrioritized asynchronous I/O is supported.\n   _POSIX_SYNCHRONIZED_IO\tSynchronizing file data is supported.\n   _POSIX_FSYNC\t\t\tThe fsync function is present.\n   _POSIX_MAPPED_FILES\t\tMapping of files to memory is supported.\n   _POSIX_MEMLOCK\t\tLocking of all memory is supported.\n   _POSIX_MEMLOCK_RANGE\t\tLocking of ranges of memory is supported.\n   _POSIX_MEMORY_PROTECTION\tSetting of memory protections is supported.\n   _POSIX_MESSAGE_PASSING\tPOSIX.4 message queues are supported.\n   _POSIX_SEMAPHORES\t\tPOSIX.4 counting semaphores are supported.\n   _POSIX_SHARED_MEMORY_OBJECTS\tPOSIX.4 shared memory objects are supported.\n   _POSIX_THREADS\t\tPOSIX.1c pthreads are supported.\n   _POSIX_THREAD_ATTR_STACKADDR\tThread stack address attribute option supported.\n   _POSIX_THREAD_ATTR_STACKSIZE\tThread stack size attribute option supported.\n   _POSIX_THREAD_SAFE_FUNCTIONS\tThread-safe functions are supported.\n   _POSIX_THREAD_PRIORITY_SCHEDULING\n\t\t\t\tPOSIX.1c thread execution scheduling supported.\n   _POSIX_THREAD_PRIO_INHERIT\tThread priority inheritance option supported.\n   _POSIX_THREAD_PRIO_PROTECT\tThread priority protection option supported.\n   _POSIX_THREAD_PROCESS_SHARED\tProcess-shared synchronization supported.\n   _POSIX_PII\t\t\tProtocol-independent interfaces are supported.\n   _POSIX_PII_XTI\t\tXTI protocol-indep. interfaces are supported.\n   _POSIX_PII_SOCKET\t\tSocket protocol-indep. interfaces are supported.\n   _POSIX_PII_INTERNET\t\tInternet family of protocols supported.\n   _POSIX_PII_INTERNET_STREAM\tConnection-mode Internet protocol supported.\n   _POSIX_PII_INTERNET_DGRAM\tConnectionless Internet protocol supported.\n   _POSIX_PII_OSI\t\tISO/OSI family of protocols supported.\n   _POSIX_PII_OSI_COTS\t\tConnection-mode ISO/OSI service supported.\n   _POSIX_PII_OSI_CLTS\t\tConnectionless ISO/OSI service supported.\n   _POSIX_POLL\t\t\tImplementation supports `poll' function.\n   _POSIX_SELECT\t\tImplementation supports `select' and `pselect'.\n\n   _XOPEN_REALTIME\t\tX/Open realtime support is available.\n   _XOPEN_REALTIME_THREADS\tX/Open realtime thread support is available.\n   _XOPEN_SHM\t\t\tShared memory interface according to XPG4.2.\n\n   _XBS5_ILP32_OFF32\t\tImplementation provides environment with 32-bit\n\t\t\t\tint, long, pointer, and off_t types.\n   _XBS5_ILP32_OFFBIG\t\tImplementation provides environment with 32-bit\n\t\t\t\tint, long, and pointer and off_t with at least\n\t\t\t\t64 bits.\n   _XBS5_LP64_OFF64\t\tImplementation provides environment with 32-bit\n\t\t\t\tint, and 64-bit long, pointer, and off_t types.\n   _XBS5_LPBIG_OFFBIG\t\tImplementation provides environment with at\n\t\t\t\tleast 32 bits int and long, pointer, and off_t\n\t\t\t\twith at least 64 bits.\n\n   If any of these symbols is defined as -1, the corresponding option is not\n   true for any file.  If any is defined as other than -1, the corresponding\n   option is true for all files.  If a symbol is not defined at all, the value\n   for a specific file can be obtained from `pathconf' and `fpathconf'.\n\n   _POSIX_CHOWN_RESTRICTED\tOnly the super user can use `chown' to change\n\t\t\t\tthe owner of a file.  `chown' can only be used\n\t\t\t\tto change the group ID of a file to a group of\n\t\t\t\twhich the calling process is a member.\n   _POSIX_NO_TRUNC\t\tPathname components longer than\n\t\t\t\tNAME_MAX generate an error.\n   _POSIX_VDISABLE\t\tIf defined, if the value of an element of the\n\t\t\t\t`c_cc' member of `struct termios' is\n\t\t\t\t_POSIX_VDISABLE, no character will have the\n\t\t\t\teffect associated with that element.\n   _POSIX_SYNC_IO\t\tSynchronous I/O may be performed.\n   _POSIX_ASYNC_IO\t\tAsynchronous I/O may be performed.\n   _POSIX_PRIO_IO\t\tPrioritized Asynchronous I/O may be performed.\n\n   Support for the Large File Support interface is not generally available.\n   If it is available the following constants are defined to one.\n   _LFS64_LARGEFILE\t\tLow-level I/O supports large files.\n   _LFS64_STDIO\t\t\tStandard I/O supports large files.\n   */\n\n#include <bits/posix_opt.h>\n\n/* Get the environment definitions from Unix98.  */\n#if defined __USE_UNIX98 || defined __USE_XOPEN2K\n# include <bits/environments.h>\n#endif\n\n/* Standard file descriptors.  */\n#define\tSTDIN_FILENO\t0\t/* Standard input.  */\n#define\tSTDOUT_FILENO\t1\t/* Standard output.  */\n#define\tSTDERR_FILENO\t2\t/* Standard error output.  */\n\n\n/* All functions that are not declared anywhere else.  */\n\n#include <bits/types.h>\n\n#ifndef\t__ssize_t_defined\ntypedef __ssize_t ssize_t;\n# define __ssize_t_defined\n#endif\n\n#define\t__need_size_t\n#define __need_NULL\n#include <stddef.h>\n\n#if defined __USE_XOPEN || defined __USE_XOPEN2K\n/* The Single Unix specification says that some more types are\n   available here.  */\n# ifndef __gid_t_defined\ntypedef __gid_t gid_t;\n#  define __gid_t_defined\n# endif\n\n# ifndef __uid_t_defined\ntypedef __uid_t uid_t;\n#  define __uid_t_defined\n# endif\n\n# ifndef __off_t_defined\n#  ifndef __USE_FILE_OFFSET64\ntypedef __off_t off_t;\n#  else\ntypedef __off64_t off_t;\n#  endif\n#  define __off_t_defined\n# endif\n# if defined __USE_LARGEFILE64 && !defined __off64_t_defined\ntypedef __off64_t off64_t;\n#  define __off64_t_defined\n# endif\n\n# ifndef __useconds_t_defined\ntypedef __useconds_t useconds_t;\n#  define __useconds_t_defined\n# endif\n\n# ifndef __pid_t_defined\ntypedef __pid_t pid_t;\n#  define __pid_t_defined\n# endif\n#endif\t/* X/Open */\n\n#if defined __USE_XOPEN_EXTENDED || defined __USE_XOPEN2K\n# ifndef __intptr_t_defined\ntypedef __intptr_t intptr_t;\n#  define __intptr_t_defined\n# endif\n#endif\n\n#if defined __USE_MISC || defined __USE_XOPEN\n# ifndef __socklen_t_defined\ntypedef __socklen_t socklen_t;\n#  define __socklen_t_defined\n# endif\n#endif\n\n/* Values for the second argument to access.\n   These may be OR'd together.  */\n#define\tR_OK\t4\t\t/* Test for read permission.  */\n#define\tW_OK\t2\t\t/* Test for write permission.  */\n#define\tX_OK\t1\t\t/* Test for execute permission.  */\n#define\tF_OK\t0\t\t/* Test for existence.  */\n\n/* Test for access to NAME using the real UID and real GID.  */\nextern int access (const char *__name, int __type) __THROW __nonnull ((1));\n\n#ifdef __USE_GNU\n/* Test for access to NAME using the effective UID and GID\n   (as normal file operations use).  */\nextern int euidaccess (const char *__name, int __type)\n     __THROW __nonnull ((1));\n\n/* An alias for `euidaccess', used by some other systems.  */\nextern int eaccess (const char *__name, int __type)\n     __THROW __nonnull ((1));\n#endif\n\n#ifdef __USE_ATFILE\n/* Test for access to FILE relative to the directory FD is open on.\n   If AT_EACCESS is set in FLAG, then use effective IDs like `eaccess',\n   otherwise use real IDs like `access'.  */\nextern int faccessat (int __fd, const char *__file, int __type, int __flag)\n     __THROW __nonnull ((2)) __wur;\n#endif /* Use GNU.  */\n\n\n/* Values for the WHENCE argument to lseek.  */\n#ifndef\t_STDIO_H\t\t/* <stdio.h> has the same definitions.  */\n# define SEEK_SET\t0\t/* Seek from beginning of file.  */\n# define SEEK_CUR\t1\t/* Seek from current position.  */\n# define SEEK_END\t2\t/* Seek from end of file.  */\n# ifdef __USE_GNU\n#  define SEEK_DATA\t3\t/* Seek to next data.  */\n#  define SEEK_HOLE\t4\t/* Seek to next hole.  */\n# endif\n#endif\n\n#if defined __USE_MISC && !defined L_SET\n/* Old BSD names for the same constants; just for compatibility.  */\n# define L_SET\t\tSEEK_SET\n# define L_INCR\t\tSEEK_CUR\n# define L_XTND\t\tSEEK_END\n#endif\n\n\n/* Move FD's file position to OFFSET bytes from the\n   beginning of the file (if WHENCE is SEEK_SET),\n   the current position (if WHENCE is SEEK_CUR),\n   or the end of the file (if WHENCE is SEEK_END).\n   Return the new file position.  */\n#ifndef __USE_FILE_OFFSET64\nextern __off_t lseek (int __fd, __off_t __offset, int __whence) __THROW;\n#else\n# ifdef __REDIRECT_NTH\nextern __off64_t __REDIRECT_NTH (lseek,\n\t\t\t\t (int __fd, __off64_t __offset, int __whence),\n\t\t\t\t lseek64);\n# else\n#  define lseek lseek64\n# endif\n#endif\n#ifdef __USE_LARGEFILE64\nextern __off64_t lseek64 (int __fd, __off64_t __offset, int __whence)\n     __THROW;\n#endif\n\n/* Close the file descriptor FD.\n\n   This function is a cancellation point and therefore not marked with\n   __THROW.  */\nextern int close (int __fd);\n\n/* Read NBYTES into BUF from FD.  Return the\n   number read, -1 for errors or 0 for EOF.\n\n   This function is a cancellation point and therefore not marked with\n   __THROW.  */\nextern ssize_t read (int __fd, void *__buf, size_t __nbytes) __wur;\n\n/* Write N bytes of BUF to FD.  Return the number written, or -1.\n\n   This function is a cancellation point and therefore not marked with\n   __THROW.  */\nextern ssize_t write (int __fd, const void *__buf, size_t __n) __wur;\n\n#if defined __USE_UNIX98 || defined __USE_XOPEN2K8\n# ifndef __USE_FILE_OFFSET64\n/* Read NBYTES into BUF from FD at the given position OFFSET without\n   changing the file pointer.  Return the number read, -1 for errors\n   or 0 for EOF.\n\n   This function is a cancellation point and therefore not marked with\n   __THROW.  */\nextern ssize_t pread (int __fd, void *__buf, size_t __nbytes,\n\t\t      __off_t __offset) __wur;\n\n/* Write N bytes of BUF to FD at the given position OFFSET without\n   changing the file pointer.  Return the number written, or -1.\n\n   This function is a cancellation point and therefore not marked with\n   __THROW.  */\nextern ssize_t pwrite (int __fd, const void *__buf, size_t __n,\n\t\t       __off_t __offset) __wur;\n# else\n#  ifdef __REDIRECT\nextern ssize_t __REDIRECT (pread, (int __fd, void *__buf, size_t __nbytes,\n\t\t\t\t   __off64_t __offset),\n\t\t\t   pread64) __wur;\nextern ssize_t __REDIRECT (pwrite, (int __fd, const void *__buf,\n\t\t\t\t    size_t __nbytes, __off64_t __offset),\n\t\t\t   pwrite64) __wur;\n#  else\n#   define pread pread64\n#   define pwrite pwrite64\n#  endif\n# endif\n\n# ifdef __USE_LARGEFILE64\n/* Read NBYTES into BUF from FD at the given position OFFSET without\n   changing the file pointer.  Return the number read, -1 for errors\n   or 0 for EOF.  */\nextern ssize_t pread64 (int __fd, void *__buf, size_t __nbytes,\n\t\t\t__off64_t __offset) __wur;\n/* Write N bytes of BUF to FD at the given position OFFSET without\n   changing the file pointer.  Return the number written, or -1.  */\nextern ssize_t pwrite64 (int __fd, const void *__buf, size_t __n,\n\t\t\t __off64_t __offset) __wur;\n# endif\n#endif\n\n/* Create a one-way communication channel (pipe).\n   If successful, two file descriptors are stored in PIPEDES;\n   bytes written on PIPEDES[1] can be read from PIPEDES[0].\n   Returns 0 if successful, -1 if not.  */\nextern int pipe (int __pipedes[2]) __THROW __wur;\n\n#ifdef __USE_GNU\n/* Same as pipe but apply flags passed in FLAGS to the new file\n   descriptors.  */\nextern int pipe2 (int __pipedes[2], int __flags) __THROW __wur;\n#endif\n\n/* Schedule an alarm.  In SECONDS seconds, the process will get a SIGALRM.\n   If SECONDS is zero, any currently scheduled alarm will be cancelled.\n   The function returns the number of seconds remaining until the last\n   alarm scheduled would have signaled, or zero if there wasn't one.\n   There is no return value to indicate an error, but you can set `errno'\n   to 0 and check its value after calling `alarm', and this might tell you.\n   The signal may come late due to processor scheduling.  */\nextern unsigned int alarm (unsigned int __seconds) __THROW;\n\n/* Make the process sleep for SECONDS seconds, or until a signal arrives\n   and is not ignored.  The function returns the number of seconds less\n   than SECONDS which it actually slept (thus zero if it slept the full time).\n   If a signal handler does a `longjmp' or modifies the handling of the\n   SIGALRM signal while inside `sleep' call, the handling of the SIGALRM\n   signal afterwards is undefined.  There is no return value to indicate\n   error, but if `sleep' returns SECONDS, it probably didn't work.\n\n   This function is a cancellation point and therefore not marked with\n   __THROW.  */\nextern unsigned int sleep (unsigned int __seconds);\n\n#if (defined __USE_XOPEN_EXTENDED && !defined __USE_XOPEN2K8) \\\n    || defined __USE_MISC\n/* Set an alarm to go off (generating a SIGALRM signal) in VALUE\n   microseconds.  If INTERVAL is nonzero, when the alarm goes off, the\n   timer is reset to go off every INTERVAL microseconds thereafter.\n   Returns the number of microseconds remaining before the alarm.  */\nextern __useconds_t ualarm (__useconds_t __value, __useconds_t __interval)\n     __THROW;\n\n/* Sleep USECONDS microseconds, or until a signal arrives that is not blocked\n   or ignored.\n\n   This function is a cancellation point and therefore not marked with\n   __THROW.  */\nextern int usleep (__useconds_t __useconds);\n#endif\n\n\n/* Suspend the process until a signal arrives.\n   This always returns -1 and sets `errno' to EINTR.\n\n   This function is a cancellation point and therefore not marked with\n   __THROW.  */\nextern int pause (void);\n\n\n/* Change the owner and group of FILE.  */\nextern int chown (const char *__file, __uid_t __owner, __gid_t __group)\n     __THROW __nonnull ((1)) __wur;\n\n#if defined __USE_XOPEN_EXTENDED || defined __USE_XOPEN2K8\n/* Change the owner and group of the file that FD is open on.  */\nextern int fchown (int __fd, __uid_t __owner, __gid_t __group) __THROW __wur;\n\n\n/* Change owner and group of FILE, if it is a symbolic\n   link the ownership of the symbolic link is changed.  */\nextern int lchown (const char *__file, __uid_t __owner, __gid_t __group)\n     __THROW __nonnull ((1)) __wur;\n\n#endif /* Use X/Open Unix.  */\n\n#ifdef __USE_ATFILE\n/* Change the owner and group of FILE relative to the directory FD is open\n   on.  */\nextern int fchownat (int __fd, const char *__file, __uid_t __owner,\n\t\t     __gid_t __group, int __flag)\n     __THROW __nonnull ((2)) __wur;\n#endif /* Use GNU.  */\n\n/* Change the process's working directory to PATH.  */\nextern int chdir (const char *__path) __THROW __nonnull ((1)) __wur;\n\n#if defined __USE_XOPEN_EXTENDED || defined __USE_XOPEN2K8\n/* Change the process's working directory to the one FD is open on.  */\nextern int fchdir (int __fd) __THROW __wur;\n#endif\n\n/* Get the pathname of the current working directory,\n   and put it in SIZE bytes of BUF.  Returns NULL if the\n   directory couldn't be determined or SIZE was too small.\n   If successful, returns BUF.  In GNU, if BUF is NULL,\n   an array is allocated with `malloc'; the array is SIZE\n   bytes long, unless SIZE == 0, in which case it is as\n   big as necessary.  */\nextern char *getcwd (char *__buf, size_t __size) __THROW __wur;\n\n#ifdef\t__USE_GNU\n/* Return a malloc'd string containing the current directory name.\n   If the environment variable `PWD' is set, and its value is correct,\n   that value is used.  */\nextern char *get_current_dir_name (void) __THROW;\n#endif\n\n#if (defined __USE_XOPEN_EXTENDED && !defined __USE_XOPEN2K8) \\\n    || defined __USE_MISC\n/* Put the absolute pathname of the current working directory in BUF.\n   If successful, return BUF.  If not, put an error message in\n   BUF and return NULL.  BUF should be at least PATH_MAX bytes long.  */\nextern char *getwd (char *__buf)\n     __THROW __nonnull ((1)) __attribute_deprecated__ __wur;\n#endif\n\n\n/* Duplicate FD, returning a new file descriptor on the same file.  */\nextern int dup (int __fd) __THROW __wur;\n\n/* Duplicate FD to FD2, closing FD2 and making it open on the same file.  */\nextern int dup2 (int __fd, int __fd2) __THROW;\n\n#ifdef __USE_GNU\n/* Duplicate FD to FD2, closing FD2 and making it open on the same\n   file while setting flags according to FLAGS.  */\nextern int dup3 (int __fd, int __fd2, int __flags) __THROW;\n#endif\n\n/* NULL-terminated array of \"NAME=VALUE\" environment variables.  */\nextern char **__environ;\n#ifdef __USE_GNU\nextern char **environ;\n#endif\n\n\n/* Replace the current process, executing PATH with arguments ARGV and\n   environment ENVP.  ARGV and ENVP are terminated by NULL pointers.  */\nextern int execve (const char *__path, char *const __argv[],\n\t\t   char *const __envp[]) __THROW __nonnull ((1, 2));\n\n#ifdef __USE_XOPEN2K8\n/* Execute the file FD refers to, overlaying the running program image.\n   ARGV and ENVP are passed to the new program, as for `execve'.  */\nextern int fexecve (int __fd, char *const __argv[], char *const __envp[])\n     __THROW __nonnull ((2));\n#endif\n\n\n/* Execute PATH with arguments ARGV and environment from `environ'.  */\nextern int execv (const char *__path, char *const __argv[])\n     __THROW __nonnull ((1, 2));\n\n/* Execute PATH with all arguments after PATH until a NULL pointer,\n   and the argument after that for environment.  */\nextern int execle (const char *__path, const char *__arg, ...)\n     __THROW __nonnull ((1, 2));\n\n/* Execute PATH with all arguments after PATH until\n   a NULL pointer and environment from `environ'.  */\nextern int execl (const char *__path, const char *__arg, ...)\n     __THROW __nonnull ((1, 2));\n\n/* Execute FILE, searching in the `PATH' environment variable if it contains\n   no slashes, with arguments ARGV and environment from `environ'.  */\nextern int execvp (const char *__file, char *const __argv[])\n     __THROW __nonnull ((1, 2));\n\n/* Execute FILE, searching in the `PATH' environment variable if\n   it contains no slashes, with all arguments after FILE until a\n   NULL pointer and environment from `environ'.  */\nextern int execlp (const char *__file, const char *__arg, ...)\n     __THROW __nonnull ((1, 2));\n\n#ifdef __USE_GNU\n/* Execute FILE, searching in the `PATH' environment variable if it contains\n   no slashes, with arguments ARGV and environment from `environ'.  */\nextern int execvpe (const char *__file, char *const __argv[],\n\t\t    char *const __envp[])\n     __THROW __nonnull ((1, 2));\n#endif\n\n\n#if defined __USE_MISC || defined __USE_XOPEN\n/* Add INC to priority of the current process.  */\nextern int nice (int __inc) __THROW __wur;\n#endif\n\n\n/* Terminate program execution with the low-order 8 bits of STATUS.  */\nextern void _exit (int __status) __attribute__ ((__noreturn__));\n\n\n/* Get the `_PC_*' symbols for the NAME argument to `pathconf' and `fpathconf';\n   the `_SC_*' symbols for the NAME argument to `sysconf';\n   and the `_CS_*' symbols for the NAME argument to `confstr'.  */\n#include <bits/confname.h>\n\n/* Get file-specific configuration information about PATH.  */\nextern long int pathconf (const char *__path, int __name)\n     __THROW __nonnull ((1));\n\n/* Get file-specific configuration about descriptor FD.  */\nextern long int fpathconf (int __fd, int __name) __THROW;\n\n/* Get the value of the system variable NAME.  */\nextern long int sysconf (int __name) __THROW;\n\n#ifdef\t__USE_POSIX2\n/* Get the value of the string-valued system variable NAME.  */\nextern size_t confstr (int __name, char *__buf, size_t __len) __THROW;\n#endif\n\n\n/* Get the process ID of the calling process.  */\nextern __pid_t getpid (void) __THROW;\n\n/* Get the process ID of the calling process's parent.  */\nextern __pid_t getppid (void) __THROW;\n\n/* Get the process group ID of the calling process.  */\nextern __pid_t getpgrp (void) __THROW;\n\n/* Get the process group ID of process PID.  */\nextern __pid_t __getpgid (__pid_t __pid) __THROW;\n#if defined __USE_XOPEN_EXTENDED || defined __USE_XOPEN2K8\nextern __pid_t getpgid (__pid_t __pid) __THROW;\n#endif\n\n\n/* Set the process group ID of the process matching PID to PGID.\n   If PID is zero, the current process's process group ID is set.\n   If PGID is zero, the process ID of the process is used.  */\nextern int setpgid (__pid_t __pid, __pid_t __pgid) __THROW;\n\n#if defined __USE_MISC || defined __USE_XOPEN_EXTENDED\n/* Both System V and BSD have `setpgrp' functions, but with different\n   calling conventions.  The BSD function is the same as POSIX.1 `setpgid'\n   (above).  The System V function takes no arguments and puts the calling\n   process in its on group like `setpgid (0, 0)'.\n\n   New programs should always use `setpgid' instead.\n\n   GNU provides the POSIX.1 function.  */\n\n/* Set the process group ID of the calling process to its own PID.\n   This is exactly the same as `setpgid (0, 0)'.  */\nextern int setpgrp (void) __THROW;\n\n#endif\t/* Use misc or X/Open.  */\n\n/* Create a new session with the calling process as its leader.\n   The process group IDs of the session and the calling process\n   are set to the process ID of the calling process, which is returned.  */\nextern __pid_t setsid (void) __THROW;\n\n#if defined __USE_XOPEN_EXTENDED || defined __USE_XOPEN2K8\n/* Return the session ID of the given process.  */\nextern __pid_t getsid (__pid_t __pid) __THROW;\n#endif\n\n/* Get the real user ID of the calling process.  */\nextern __uid_t getuid (void) __THROW;\n\n/* Get the effective user ID of the calling process.  */\nextern __uid_t geteuid (void) __THROW;\n\n/* Get the real group ID of the calling process.  */\nextern __gid_t getgid (void) __THROW;\n\n/* Get the effective group ID of the calling process.  */\nextern __gid_t getegid (void) __THROW;\n\n/* If SIZE is zero, return the number of supplementary groups\n   the calling process is in.  Otherwise, fill in the group IDs\n   of its supplementary groups in LIST and return the number written.  */\nextern int getgroups (int __size, __gid_t __list[]) __THROW __wur;\n\n#ifdef\t__USE_GNU\n/* Return nonzero iff the calling process is in group GID.  */\nextern int group_member (__gid_t __gid) __THROW;\n#endif\n\n/* Set the user ID of the calling process to UID.\n   If the calling process is the super-user, set the real\n   and effective user IDs, and the saved set-user-ID to UID;\n   if not, the effective user ID is set to UID.  */\nextern int setuid (__uid_t __uid) __THROW __wur;\n\n#if defined __USE_MISC || defined __USE_XOPEN_EXTENDED\n/* Set the real user ID of the calling process to RUID,\n   and the effective user ID of the calling process to EUID.  */\nextern int setreuid (__uid_t __ruid, __uid_t __euid) __THROW __wur;\n#endif\n\n#ifdef __USE_XOPEN2K\n/* Set the effective user ID of the calling process to UID.  */\nextern int seteuid (__uid_t __uid) __THROW __wur;\n#endif /* Use POSIX.1-2001.  */\n\n/* Set the group ID of the calling process to GID.\n   If the calling process is the super-user, set the real\n   and effective group IDs, and the saved set-group-ID to GID;\n   if not, the effective group ID is set to GID.  */\nextern int setgid (__gid_t __gid) __THROW __wur;\n\n#if defined __USE_MISC || defined __USE_XOPEN_EXTENDED\n/* Set the real group ID of the calling process to RGID,\n   and the effective group ID of the calling process to EGID.  */\nextern int setregid (__gid_t __rgid, __gid_t __egid) __THROW __wur;\n#endif\n\n#ifdef __USE_XOPEN2K\n/* Set the effective group ID of the calling process to GID.  */\nextern int setegid (__gid_t __gid) __THROW __wur;\n#endif /* Use POSIX.1-2001.  */\n\n#ifdef __USE_GNU\n/* Fetch the real user ID, effective user ID, and saved-set user ID,\n   of the calling process.  */\nextern int getresuid (__uid_t *__ruid, __uid_t *__euid, __uid_t *__suid)\n     __THROW;\n\n/* Fetch the real group ID, effective group ID, and saved-set group ID,\n   of the calling process.  */\nextern int getresgid (__gid_t *__rgid, __gid_t *__egid, __gid_t *__sgid)\n     __THROW;\n\n/* Set the real user ID, effective user ID, and saved-set user ID,\n   of the calling process to RUID, EUID, and SUID, respectively.  */\nextern int setresuid (__uid_t __ruid, __uid_t __euid, __uid_t __suid)\n     __THROW __wur;\n\n/* Set the real group ID, effective group ID, and saved-set group ID,\n   of the calling process to RGID, EGID, and SGID, respectively.  */\nextern int setresgid (__gid_t __rgid, __gid_t __egid, __gid_t __sgid)\n     __THROW __wur;\n#endif\n\n\n/* Clone the calling process, creating an exact copy.\n   Return -1 for errors, 0 to the new process,\n   and the process ID of the new process to the old process.  */\nextern __pid_t fork (void) __THROWNL;\n\n#if (defined __USE_XOPEN_EXTENDED && !defined __USE_XOPEN2K8) \\\n    || defined __USE_MISC\n/* Clone the calling process, but without copying the whole address space.\n   The calling process is suspended until the new process exits or is\n   replaced by a call to `execve'.  Return -1 for errors, 0 to the new process,\n   and the process ID of the new process to the old process.  */\nextern __pid_t vfork (void) __THROW;\n#endif /* Use misc or XPG < 7. */\n\n\n/* Return the pathname of the terminal FD is open on, or NULL on errors.\n   The returned storage is good only until the next call to this function.  */\nextern char *ttyname (int __fd) __THROW;\n\n/* Store at most BUFLEN characters of the pathname of the terminal FD is\n   open on in BUF.  Return 0 on success, otherwise an error number.  */\nextern int ttyname_r (int __fd, char *__buf, size_t __buflen)\n     __THROW __nonnull ((2)) __wur;\n\n/* Return 1 if FD is a valid descriptor associated\n   with a terminal, zero if not.  */\nextern int isatty (int __fd) __THROW;\n\n#ifdef __USE_MISC\n/* Return the index into the active-logins file (utmp) for\n   the controlling terminal.  */\nextern int ttyslot (void) __THROW;\n#endif\n\n\n/* Make a link to FROM named TO.  */\nextern int link (const char *__from, const char *__to)\n     __THROW __nonnull ((1, 2)) __wur;\n\n#ifdef __USE_ATFILE\n/* Like link but relative paths in TO and FROM are interpreted relative\n   to FROMFD and TOFD respectively.  */\nextern int linkat (int __fromfd, const char *__from, int __tofd,\n\t\t   const char *__to, int __flags)\n     __THROW __nonnull ((2, 4)) __wur;\n#endif\n\n#if defined __USE_XOPEN_EXTENDED || defined __USE_XOPEN2K\n/* Make a symbolic link to FROM named TO.  */\nextern int symlink (const char *__from, const char *__to)\n     __THROW __nonnull ((1, 2)) __wur;\n\n/* Read the contents of the symbolic link PATH into no more than\n   LEN bytes of BUF.  The contents are not null-terminated.\n   Returns the number of characters read, or -1 for errors.  */\nextern ssize_t readlink (const char *__restrict __path,\n\t\t\t char *__restrict __buf, size_t __len)\n     __THROW __nonnull ((1, 2)) __wur;\n#endif /* Use POSIX.1-2001.  */\n\n#ifdef __USE_ATFILE\n/* Like symlink but a relative path in TO is interpreted relative to TOFD.  */\nextern int symlinkat (const char *__from, int __tofd,\n\t\t      const char *__to) __THROW __nonnull ((1, 3)) __wur;\n\n/* Like readlink but a relative PATH is interpreted relative to FD.  */\nextern ssize_t readlinkat (int __fd, const char *__restrict __path,\n\t\t\t   char *__restrict __buf, size_t __len)\n     __THROW __nonnull ((2, 3)) __wur;\n#endif\n\n/* Remove the link NAME.  */\nextern int unlink (const char *__name) __THROW __nonnull ((1));\n\n#ifdef __USE_ATFILE\n/* Remove the link NAME relative to FD.  */\nextern int unlinkat (int __fd, const char *__name, int __flag)\n     __THROW __nonnull ((2));\n#endif\n\n/* Remove the directory PATH.  */\nextern int rmdir (const char *__path) __THROW __nonnull ((1));\n\n\n/* Return the foreground process group ID of FD.  */\nextern __pid_t tcgetpgrp (int __fd) __THROW;\n\n/* Set the foreground process group ID of FD set PGRP_ID.  */\nextern int tcsetpgrp (int __fd, __pid_t __pgrp_id) __THROW;\n\n\n/* Return the login name of the user.\n\n   This function is a possible cancellation point and therefore not\n   marked with __THROW.  */\nextern char *getlogin (void);\n#ifdef __USE_POSIX199506\n/* Return at most NAME_LEN characters of the login name of the user in NAME.\n   If it cannot be determined or some other error occurred, return the error\n   code.  Otherwise return 0.\n\n   This function is a possible cancellation point and therefore not\n   marked with __THROW.  */\nextern int getlogin_r (char *__name, size_t __name_len) __nonnull ((1));\n#endif\n\n#ifdef\t__USE_MISC\n/* Set the login name returned by `getlogin'.  */\nextern int setlogin (const char *__name) __THROW __nonnull ((1));\n#endif\n\n\n#ifdef\t__USE_POSIX2\n/* Get definitions and prototypes for functions to process the\n   arguments in ARGV (ARGC of them, minus the program name) for\n   options given in OPTS.  */\n# include <bits/getopt_posix.h>\n#endif\n\n\n#if defined __USE_XOPEN_EXTENDED || defined __USE_XOPEN2K\n/* Put the name of the current host in no more than LEN bytes of NAME.\n   The result is null-terminated if LEN is large enough for the full\n   name and the terminator.  */\nextern int gethostname (char *__name, size_t __len) __THROW __nonnull ((1));\n#endif\n\n\n#if defined __USE_MISC\n/* Set the name of the current host to NAME, which is LEN bytes long.\n   This call is restricted to the super-user.  */\nextern int sethostname (const char *__name, size_t __len)\n     __THROW __nonnull ((1)) __wur;\n\n/* Set the current machine's Internet number to ID.\n   This call is restricted to the super-user.  */\nextern int sethostid (long int __id) __THROW __wur;\n\n\n/* Get and set the NIS (aka YP) domain name, if any.\n   Called just like `gethostname' and `sethostname'.\n   The NIS domain name is usually the empty string when not using NIS.  */\nextern int getdomainname (char *__name, size_t __len)\n     __THROW __nonnull ((1)) __wur;\nextern int setdomainname (const char *__name, size_t __len)\n     __THROW __nonnull ((1)) __wur;\n\n\n/* Revoke access permissions to all processes currently communicating\n   with the control terminal, and then send a SIGHUP signal to the process\n   group of the control terminal.  */\nextern int vhangup (void) __THROW;\n\n/* Revoke the access of all descriptors currently open on FILE.  */\nextern int revoke (const char *__file) __THROW __nonnull ((1)) __wur;\n\n\n/* Enable statistical profiling, writing samples of the PC into at most\n   SIZE bytes of SAMPLE_BUFFER; every processor clock tick while profiling\n   is enabled, the system examines the user PC and increments\n   SAMPLE_BUFFER[((PC - OFFSET) / 2) * SCALE / 65536].  If SCALE is zero,\n   disable profiling.  Returns zero on success, -1 on error.  */\nextern int profil (unsigned short int *__sample_buffer, size_t __size,\n\t\t   size_t __offset, unsigned int __scale)\n     __THROW __nonnull ((1));\n\n\n/* Turn accounting on if NAME is an existing file.  The system will then write\n   a record for each process as it terminates, to this file.  If NAME is NULL,\n   turn accounting off.  This call is restricted to the super-user.  */\nextern int acct (const char *__name) __THROW;\n\n\n/* Successive calls return the shells listed in `/etc/shells'.  */\nextern char *getusershell (void) __THROW;\nextern void endusershell (void) __THROW; /* Discard cached info.  */\nextern void setusershell (void) __THROW; /* Rewind and re-read the file.  */\n\n\n/* Put the program in the background, and dissociate from the controlling\n   terminal.  If NOCHDIR is zero, do `chdir (\"/\")'.  If NOCLOSE is zero,\n   redirects stdin, stdout, and stderr to /dev/null.  */\nextern int daemon (int __nochdir, int __noclose) __THROW __wur;\n#endif /* Use misc.  */\n\n\n#if defined __USE_MISC || (defined __USE_XOPEN && !defined __USE_XOPEN2K)\n/* Make PATH be the root directory (the starting point for absolute paths).\n   This call is restricted to the super-user.  */\nextern int chroot (const char *__path) __THROW __nonnull ((1)) __wur;\n\n/* Prompt with PROMPT and read a string from the terminal without echoing.\n   Uses /dev/tty if possible; otherwise stderr and stdin.  */\nextern char *getpass (const char *__prompt) __nonnull ((1));\n#endif /* Use misc || X/Open.  */\n\n\n/* Make all changes done to FD actually appear on disk.\n\n   This function is a cancellation point and therefore not marked with\n   __THROW.  */\nextern int fsync (int __fd);\n\n\n#ifdef __USE_GNU\n/* Make all changes done to all files on the file system associated\n   with FD actually appear on disk.  */\nextern int syncfs (int __fd) __THROW;\n#endif\n\n\n#if defined __USE_MISC || defined __USE_XOPEN_EXTENDED\n\n/* Return identifier for the current host.  */\nextern long int gethostid (void);\n\n/* Make all changes done to all files actually appear on disk.  */\nextern void sync (void) __THROW;\n\n\n# if defined __USE_MISC || !defined __USE_XOPEN2K\n/* Return the number of bytes in a page.  This is the system's page size,\n   which is not necessarily the same as the hardware page size.  */\nextern int getpagesize (void)  __THROW __attribute__ ((__const__));\n\n\n/* Return the maximum number of file descriptors\n   the current process could possibly have.  */\nextern int getdtablesize (void) __THROW;\n# endif\n\n#endif /* Use misc || X/Open Unix.  */\n\n\n#if defined __USE_XOPEN_EXTENDED || defined __USE_XOPEN2K8\n\n/* Truncate FILE to LENGTH bytes.  */\n# ifndef __USE_FILE_OFFSET64\nextern int truncate (const char *__file, __off_t __length)\n     __THROW __nonnull ((1)) __wur;\n# else\n#  ifdef __REDIRECT_NTH\nextern int __REDIRECT_NTH (truncate,\n\t\t\t   (const char *__file, __off64_t __length),\n\t\t\t   truncate64) __nonnull ((1)) __wur;\n#  else\n#   define truncate truncate64\n#  endif\n# endif\n# ifdef __USE_LARGEFILE64\nextern int truncate64 (const char *__file, __off64_t __length)\n     __THROW __nonnull ((1)) __wur;\n# endif\n\n#endif /* Use X/Open Unix || POSIX 2008.  */\n\n#if defined __USE_POSIX199309 \\\n    || defined __USE_XOPEN_EXTENDED || defined __USE_XOPEN2K\n\n/* Truncate the file FD is open on to LENGTH bytes.  */\n# ifndef __USE_FILE_OFFSET64\nextern int ftruncate (int __fd, __off_t __length) __THROW __wur;\n# else\n#  ifdef __REDIRECT_NTH\nextern int __REDIRECT_NTH (ftruncate, (int __fd, __off64_t __length),\n\t\t\t   ftruncate64) __wur;\n#  else\n#   define ftruncate ftruncate64\n#  endif\n# endif\n# ifdef __USE_LARGEFILE64\nextern int ftruncate64 (int __fd, __off64_t __length) __THROW __wur;\n# endif\n\n#endif /* Use POSIX.1b || X/Open Unix || XPG6.  */\n\n\n#if (defined __USE_XOPEN_EXTENDED && !defined __USE_XOPEN2K) \\\n    || defined __USE_MISC\n\n/* Set the end of accessible data space (aka \"the break\") to ADDR.\n   Returns zero on success and -1 for errors (with errno set).  */\nextern int brk (void *__addr) __THROW __wur;\n\n/* Increase or decrease the end of accessible data space by DELTA bytes.\n   If successful, returns the address the previous end of data space\n   (i.e. the beginning of the new space, if DELTA > 0);\n   returns (void *) -1 for errors (with errno set).  */\nextern void *sbrk (intptr_t __delta) __THROW;\n#endif\n\n\n#ifdef __USE_MISC\n/* Invoke `system call' number SYSNO, passing it the remaining arguments.\n   This is completely system-dependent, and not often useful.\n\n   In Unix, `syscall' sets `errno' for all errors and most calls return -1\n   for errors; in many systems you cannot pass arguments or get return\n   values for all system calls (`pipe', `fork', and `getppid' typically\n   among them).\n\n   In Mach, all system calls take normal arguments and always return an\n   error code (zero for success).  */\nextern long int syscall (long int __sysno, ...) __THROW;\n\n#endif\t/* Use misc.  */\n\n\n#if (defined __USE_MISC || defined __USE_XOPEN_EXTENDED) && !defined F_LOCK\n/* NOTE: These declarations also appear in <fcntl.h>; be sure to keep both\n   files consistent.  Some systems have them there and some here, and some\n   software depends on the macros being defined without including both.  */\n\n/* `lockf' is a simpler interface to the locking facilities of `fcntl'.\n   LEN is always relative to the current file position.\n   The CMD argument is one of the following.\n\n   This function is a cancellation point and therefore not marked with\n   __THROW.  */\n\n# define F_ULOCK 0\t/* Unlock a previously locked region.  */\n# define F_LOCK  1\t/* Lock a region for exclusive use.  */\n# define F_TLOCK 2\t/* Test and lock a region for exclusive use.  */\n# define F_TEST  3\t/* Test a region for other processes locks.  */\n\n# ifndef __USE_FILE_OFFSET64\nextern int lockf (int __fd, int __cmd, __off_t __len) __wur;\n# else\n#  ifdef __REDIRECT\nextern int __REDIRECT (lockf, (int __fd, int __cmd, __off64_t __len),\n\t\t       lockf64) __wur;\n#  else\n#   define lockf lockf64\n#  endif\n# endif\n# ifdef __USE_LARGEFILE64\nextern int lockf64 (int __fd, int __cmd, __off64_t __len) __wur;\n# endif\n#endif /* Use misc and F_LOCK not already defined.  */\n\n\n#ifdef __USE_GNU\n\n/* Evaluate EXPRESSION, and repeat as long as it returns -1 with `errno'\n   set to EINTR.  */\n\n# define TEMP_FAILURE_RETRY(expression) \\\n  (__extension__\t\t\t\t\t\t\t      \\\n    ({ long int __result;\t\t\t\t\t\t      \\\n       do __result = (long int) (expression);\t\t\t\t      \\\n       while (__result == -1L && errno == EINTR);\t\t\t      \\\n       __result; }))\n\n/* Copy LENGTH bytes from INFD to OUTFD.  */\nssize_t copy_file_range (int __infd, __off64_t *__pinoff,\n\t\t\t int __outfd, __off64_t *__poutoff,\n\t\t\t size_t __length, unsigned int __flags);\n#endif /* __USE_GNU */\n\n#if defined __USE_POSIX199309 || defined __USE_UNIX98\n/* Synchronize at least the data part of a file with the underlying\n   media.  */\nextern int fdatasync (int __fildes);\n#endif /* Use POSIX199309 */\n\n\n/* XPG4.2 specifies that prototypes for the encryption functions must\n   be defined here.  */\n#ifdef\t__USE_XOPEN\n/* Encrypt at most 8 characters from KEY using salt to perturb DES.  */\nextern char *crypt (const char *__key, const char *__salt)\n     __THROW __nonnull ((1, 2));\n\n/* Encrypt data in BLOCK in place if EDFLAG is zero; otherwise decrypt\n   block in place.  */\nextern void encrypt (char *__glibc_block, int __edflag)\n     __THROW __nonnull ((1));\n\n\n/* Swab pairs bytes in the first N bytes of the area pointed to by\n   FROM and copy the result to TO.  The value of TO must not be in the\n   range [FROM - N + 1, FROM - 1].  If N is odd the first byte in FROM\n   is without partner.  */\nextern void swab (const void *__restrict __from, void *__restrict __to,\n\t\t  ssize_t __n) __THROW __nonnull ((1, 2));\n#endif\n\n\n/* Prior to Issue 6, the Single Unix Specification required these\n   prototypes to appear in this header.  They are also found in\n   <stdio.h>.  */\n#if defined __USE_XOPEN && !defined __USE_XOPEN2K\n/* Return the name of the controlling terminal.  */\nextern char *ctermid (char *__s) __THROW;\n\n/* Return the name of the current user.  */\nextern char *cuserid (char *__s);\n#endif\n\n\n/* Unix98 requires this function to be declared here.  In other\n   standards it is in <pthread.h>.  */\n#if defined __USE_UNIX98 && !defined __USE_XOPEN2K\nextern int pthread_atfork (void (*__prepare) (void),\n\t\t\t   void (*__parent) (void),\n\t\t\t   void (*__child) (void)) __THROW;\n#endif\n\n#ifdef __USE_MISC\n/* Write LENGTH bytes of randomness starting at BUFFER.  Return 0 on\n   success or -1 on error.  */\nint getentropy (void *__buffer, size_t __length) __wur;\n#endif\n\n/* Define some macros helping to catch buffer overflows.  */\n#if __USE_FORTIFY_LEVEL > 0 && defined __fortify_function\n# include <bits/unistd.h>\n#endif\n\n__END_DECLS\n\n#endif /* unistd.h  */\n"}, "23": {"id": 23, "path": "/home/runner/work/testcc/testcc/retdec/src/lib/data-stack.h", "content": "#ifndef DATA_STACK_H\n#define DATA_STACK_H\n\n/* Data stack makes it very easy to implement functions returning dynamic data\n   without having to worry much about memory management like freeing the\n   result or having large enough buffers for the result.\n\n   t_ prefix was chosen to describe functions allocating memory from data\n   stack. \"t\" meaning temporary.\n\n   Advantages over control stack and alloca():\n    - Functions can return a value allocated from data stack\n    - We can portably specify how much data we want to allocate at runtime\n\n   Advantages over malloc():\n    - FAST, most of the time allocating memory means only updating a couple of\n      pointers and integers. Freeing the memory all at once also is a fast\n      operation.\n    - No need to free() each allocation resulting in prettier code\n    - No memory leaks\n    - No memory fragmentation\n\n   Disadvantages:\n    - Allocating memory inside loops can accidentally allocate a lot of memory\n      if the loops are long and you forgot to place t_push() and t_pop() there.\n    - t_malloc()ed data could be accidentally stored into permanent location\n      and accessed after it's already been freed. const'ing the return values\n      helps for most uses though (see the t_malloc() description).\n    - Debugging invalid memory usage may be difficult using existing tools,\n      although compiling with DEBUG enabled helps finding simple buffer\n      overflows.\n*/\n\n#ifndef STATIC_CHECKER\ntypedef unsigned int data_stack_frame_t;\n#else\ntypedef struct data_stack_frame *data_stack_frame_t;\n#endif\n\nextern unsigned int data_stack_frame_id;\n\n/* All t_..() allocations between t_push*() and t_pop() are freed after t_pop()\n   is called. Returns the current stack frame number, which can be used\n   to detect missing t_pop() calls:\n\n   x = t_push(marker); .. if (!t_pop(x)) abort();\n\n   In DEBUG mode, t_push_named() makes a temporary allocation for the name,\n   but is safe to call in a loop as it performs the allocation within its own\n   frame. However, you should always prefer to use T_BEGIN { ... } T_END below.\n*/\ndata_stack_frame_t t_push(const char *marker) ATTR_HOT;\ndata_stack_frame_t t_push_named(const char *format, ...) ATTR_HOT ATTR_FORMAT(1, 2);\n/* Returns TRUE on success, FALSE if t_pop() call was leaked. The caller\n   should panic. */\nbool t_pop(data_stack_frame_t *id) ATTR_HOT;\n/* Pop the last data stack frame. This shouldn't be called outside test code. */\nvoid t_pop_last_unsafe(void);\n\n/* Usage: T_BEGIN { code } T_END */\n#define T_STRING(x)\t#x\n#define T_XSTRING(x)\tT_STRING(x)\t/* expand and then stringify */\n#define T_BEGIN \\\n\tSTMT_START { \\\n\t\tdata_stack_frame_t _data_stack_cur_id = t_push(__FILE__ \":\" T_XSTRING(__LINE__));\n#define T_END \\\n\tSTMT_START { \\\n\t\tif (unlikely(!t_pop(&_data_stack_cur_id))) \\\n\t\t\ti_panic(\"Leaked t_pop() call\"); \\\n\t} STMT_END; \\\n\t} STMT_END\n\n/* WARNING: Be careful when using these functions, it's too easy to\n   accidentally save the returned value somewhere permanently.\n\n   You probably should never use these functions directly, rather\n   create functions that return 'const xxx*' types and use t_malloc()\n   internally in them. This is a lot safer, since usually compiler\n   warns if you try to place them in xxx*. See strfuncs.c for examples.\n\n   t_malloc() calls never fail. If there's not enough memory left,\n   i_panic() will be called. */\nvoid *t_malloc_no0(size_t size) ATTR_MALLOC ATTR_RETURNS_NONNULL;\nvoid *t_malloc0(size_t size) ATTR_MALLOC ATTR_RETURNS_NONNULL;\n\n/* Try growing allocated memory. Returns TRUE if successful. Works only\n   for last allocated memory in current stack frame. */\nbool t_try_realloc(void *mem, size_t size);\n\n/* Returns the number of bytes available in data stack without allocating\n   more memory. */\nsize_t t_get_bytes_available(void) ATTR_PURE;\n\n#define t_new(type, count) \\\n\t((type *) t_malloc0(MALLOC_MULTIPLY((unsigned int)sizeof(type), (count))) + \\\n\t COMPILE_ERROR_IF_TRUE(sizeof(type) > UINT_MAX))\n\n/* Returns pointer to a temporary buffer you can use. The buffer will be\n   invalid as soon as next t_malloc() is called!\n\n   If you wish to grow the buffer, you must give the full wanted size\n   in the size parameter. If return value doesn't point to the same value\n   as last time, you need to memcpy() data from the old buffer to the\n   new one (or do some other trickery). See t_buffer_reget(). */\nvoid *t_buffer_get(size_t size) ATTR_RETURNS_NONNULL;\n\n/* Grow the buffer, memcpy()ing the memory to new location if needed. */\nvoid *t_buffer_reget(void *buffer, size_t size) ATTR_RETURNS_NONNULL;\n\n/* Make the last t_buffer_get()ed buffer permanent. Note that size MUST be\n   less or equal than the size you gave with last t_buffer_get() or the\n   result will be undefined. */\nvoid t_buffer_alloc(size_t size);\n/* Allocate the last t_buffer_get()ed data entirely. */\nvoid t_buffer_alloc_last_full(void);\n\n/* If enabled, all the used memory is cleared after t_pop(). */\nvoid data_stack_set_clean_after_pop(bool enable);\n\nvoid data_stack_init(void);\nvoid data_stack_deinit(void);\n\n#endif\n"}, "24": {"id": 24, "path": "/home/runner/work/testcc/testcc/retdec/src/lib/event-log.h", "content": "#ifndef EVENT_LOG_H\n#define EVENT_LOG_H\n\nstruct event_filter;\n\n#include \"lib-event.h\"\n\nstruct event_log_params {\n\tenum log_type log_type;\n\tconst char *source_filename;\n\tunsigned int source_linenum;\n\n\t/* Base event used as a reference for base_* parameters (see below) */\n\tstruct event *base_event;\n\n\t/* Append the event message to base_str_out in addition to emitting the\n\t   event as normal. The message appended to the string buffer includes\n\t   prefixes and message callback modifications by parent events up until\n\t   the base_event. The event is otherwise sent as normal with the full\n\t   prefixes and all modifications up to the root event (unless\n\t   no_send=TRUE). This is primarily useful to mimic (part of) event\n\t   logging in parallel logs that are visible to users. */\n\tstring_t *base_str_out;\n\n\t/* Prefix inserted at the base_event for the sent log message. */\n\tconst char *base_send_prefix;\n\t/* Prefix inserted at the base_event for the log message appended to the\n\t   string buffer. */\n\tconst char *base_str_prefix;\n\n\t/* Don't actually send the event; only append to the provided string\n\t   buffer (base_str_out must not be NULL). */\n\tbool no_send:1;\n};\n\nvoid e_error(struct event *event,\n\t     const char *source_filename, unsigned int source_linenum,\n\t     const char *fmt, ...) ATTR_FORMAT(4, 5);\n#define e_error(_event, ...) STMT_START { \\\n\tstruct event *_tmp_event = (_event); \\\n\tif (event_want_level(_tmp_event, LOG_TYPE_ERROR)) \\\n\t\te_error(_tmp_event, __FILE__, __LINE__, __VA_ARGS__); \\\n\telse \\\n\t\tevent_send_abort(_tmp_event); \\\n\t} STMT_END\nvoid e_warning(struct event *event,\n\t       const char *source_filename, unsigned int source_linenum,\n\t       const char *fmt, ...) ATTR_FORMAT(4, 5);\n#define e_warning(_event, ...) STMT_START { \\\n\tstruct event *_tmp_event = (_event); \\\n\t if (event_want_level(_tmp_event, LOG_TYPE_WARNING)) \\\n\t\te_warning(_tmp_event, __FILE__, __LINE__, __VA_ARGS__); \\\n\telse \\\n\t\tevent_send_abort(_tmp_event); \\\n\t} STMT_END\nvoid e_info(struct event *event,\n\t    const char *source_filename, unsigned int source_linenum,\n\t    const char *fmt, ...) ATTR_FORMAT(4, 5);\n#define e_info(_event, ...) STMT_START { \\\n\tstruct event *_tmp_event = (_event); \\\n\tif (event_want_level(_tmp_event, LOG_TYPE_INFO)) \\\n\t\te_info(_tmp_event, __FILE__, __LINE__, __VA_ARGS__); \\\n\telse \\\n\t\tevent_send_abort(_tmp_event); \\\n\t} STMT_END\nvoid e_debug(struct event *event,\n\t     const char *source_filename, unsigned int source_linenum,\n\t     const char *fmt, ...) ATTR_FORMAT(4, 5);\n#define e_debug(_event, ...) STMT_START { \\\n\tstruct event *_tmp_event = (_event); \\\n\tif (event_want_debug(_tmp_event)) \\\n\t\te_debug(_tmp_event, __FILE__, __LINE__, __VA_ARGS__); \\\n\telse \\\n\t\tevent_send_abort(_tmp_event); \\\n\t} STMT_END\n\nvoid e_log(struct event *event, enum log_type level,\n\t   const char *source_filename, unsigned int source_linenum,\n\t   const char *fmt, ...) ATTR_FORMAT(5, 6);\n#define e_log(_event, level, ...) STMT_START { \\\n\tstruct event *_tmp_event = (_event); \\\n\tif (event_want_level(_tmp_event, level)) \\\n\t\te_log(_tmp_event, level, __FILE__, __LINE__, __VA_ARGS__); \\\n\telse \\\n\t\tevent_send_abort(_tmp_event); \\\n\t} STMT_END\n\n/* Returns TRUE if debug event should be sent (either logged or sent to\n   stats). */\nbool event_want_log_level(struct event *event, enum log_type level,\n\t\t\t  const char *source_filename,\n\t\t\t  unsigned int source_linenum);\n#define event_want_log_level(_event, level) event_want_log_level((_event), (level), __FILE__, __LINE__)\n#define event_want_debug_log(_event) event_want_log_level((_event), LOG_TYPE_DEBUG)\n\nbool event_want_level(struct event *event, enum log_type level,\n\t\t      const char *source_filename,\n\t\t      unsigned int source_linenum);\n#define event_want_level(_event, level) event_want_level((_event), (level), __FILE__, __LINE__)\n#define event_want_debug(_event) event_want_level((_event), LOG_TYPE_DEBUG)\n\nvoid event_log(struct event *event, const struct event_log_params *params,\n\t       const char *fmt, ...)\n\tATTR_FORMAT(3, 4);\nvoid event_logv(struct event *event, const struct event_log_params *params,\n\t\tconst char *fmt, va_list args)\n\tATTR_FORMAT(3, 0);\n\n/* If debugging is forced, the global debug log filter is ignored. Changing\n   this applies only to this event and any child event that is created\n   afterwards. It doesn't apply to existing child events (mainly for\n   performance reasons).\n\n   Note that event_set_forced_debug(event, FALSE) is a no-op. To disable\n   forced-debug, use event_unset_forced_debug(event). */\nstruct event *event_set_forced_debug(struct event *event, bool force);\n/* Set the forced-debug to FALSE */\nstruct event *event_unset_forced_debug(struct event *event);\n/* Set the global filter to logging debug events. */\nvoid event_set_global_debug_log_filter(struct event_filter *filter);\n/* Return the current global debug log event filter. */\nstruct event_filter *event_get_global_debug_log_filter(void);\n/* Unset global debug log filter, if one exists. */\nvoid event_unset_global_debug_log_filter(void);\n\n/* Set the global filter to sending debug events. The debug events are also\n   sent if they match the global debug log filter. */\nvoid event_set_global_debug_send_filter(struct event_filter *filter);\n/* Return the current global debug send event filter. */\nstruct event_filter *event_get_global_debug_send_filter(void);\n/* Unset global debug send filter, if one exists. */\nvoid event_unset_global_debug_send_filter(void);\n\n/* Set/replace the global core filter, which abort()s on matching events. */\nvoid event_set_global_core_log_filter(struct event_filter *filter);\n/* Return the current global core filter. */\nstruct event_filter *event_get_global_core_log_filter(void);\n/* Unset the global core filter, if one exists. */\nvoid event_unset_global_core_log_filter(void);\n\n#endif\n"}, "25": {"id": 25, "path": "/home/runner/work/testcc/testcc/retdec/src/lib/failures.h", "content": "#ifndef FAILURES_H\n#define FAILURES_H\n\nstruct ip_addr;\n\n/* Default exit status codes that we could use. */\nenum fatal_exit_status {\n\tFATAL_LOGOPEN\t= 80, /* Can't open log file */\n\tFATAL_LOGWRITE  = 81, /* Can't write to log file */\n\tFATAL_LOGERROR  = 82, /* Internal logging error */\n\tFATAL_OUTOFMEM\t= 83, /* Out of memory */\n\tFATAL_EXEC\t= 84, /* exec() failed */\n\n\tFATAL_DEFAULT\t= 89\n};\n\nenum log_type {\n\tLOG_TYPE_DEBUG,\n\tLOG_TYPE_INFO,\n\tLOG_TYPE_WARNING,\n\tLOG_TYPE_ERROR,\n\tLOG_TYPE_FATAL,\n\tLOG_TYPE_PANIC,\n\n\tLOG_TYPE_COUNT,\n\t/* special case */\n\tLOG_TYPE_OPTION\n};\n\nstruct failure_line {\n\tpid_t pid;\n\tenum log_type log_type;\n\t/* If non-zero, the first log_prefix_len bytes in text indicate\n\t   the log prefix. This implies disable_log_prefix=TRUE. */\n\tunsigned int log_prefix_len;\n\t/* Disable the global log prefix. */\n\tbool disable_log_prefix;\n\tconst char *text;\n};\n\nstruct failure_context {\n\tenum log_type type;\n\tint exit_status; /* for LOG_TYPE_FATAL */\n\tconst struct tm *timestamp; /* NULL = use time() + localtime() */\n\tunsigned int timestamp_usecs;\n\tconst char *log_prefix; /* override the default log prefix */\n\t/* If non-0, insert the log type text (e.g. \"Info: \") at this position\n\t   in the log_prefix instead of appending it. */\n\tunsigned int log_prefix_type_pos;\n};\n\n#define DEFAULT_FAILURE_STAMP_FORMAT \"%b %d %H:%M:%S \"\n\ntypedef void failure_callback_t(const struct failure_context *ctx,\n\t\t\t\tconst char *format, va_list args);\n\nextern const char *failure_log_type_prefixes[];\nextern const char *failure_log_type_names[];\n\nvoid i_log_type(const struct failure_context *ctx, const char *format, ...)\n\tATTR_FORMAT(2, 3);\nvoid i_log_typev(const struct failure_context *ctx, const char *format,\n\t\t va_list args) ATTR_FORMAT(2, 0);\n\nvoid i_panic(const char *format, ...) ATTR_FORMAT(1, 2) ATTR_NORETURN ATTR_COLD;\nvoid i_fatal(const char *format, ...) ATTR_FORMAT(1, 2) ATTR_NORETURN ATTR_COLD;\nvoid i_error(const char *format, ...) ATTR_FORMAT(1, 2) ATTR_COLD;\nvoid i_warning(const char *format, ...) ATTR_FORMAT(1, 2);\nvoid i_info(const char *format, ...) ATTR_FORMAT(1, 2);\nvoid i_debug(const char *format, ...) ATTR_FORMAT(1, 2);\n\nvoid i_fatal_status(int status, const char *format, ...)\n\tATTR_FORMAT(2, 3) ATTR_NORETURN ATTR_COLD;\n\n/* Change failure handlers. */\n#ifndef __cplusplus\nvoid i_set_fatal_handler(failure_callback_t *callback ATTR_NORETURN);\n#else\n/* Older g++ doesn't like attributes in parameters */\nvoid i_set_fatal_handler(failure_callback_t *callback);\n#endif\nvoid i_set_error_handler(failure_callback_t *callback);\nvoid i_set_info_handler(failure_callback_t *callback);\nvoid i_set_debug_handler(failure_callback_t *callback);\nvoid i_get_failure_handlers(failure_callback_t **fatal_callback_r,\n\t\t\t    failure_callback_t **error_callback_r,\n\t\t\t    failure_callback_t **info_callback_r,\n\t\t\t    failure_callback_t **debug_callback_r);\n\n/* Send failures to file. */\nvoid default_fatal_handler(const struct failure_context *ctx,\n\t\t\t   const char *format, va_list args)\n\tATTR_NORETURN ATTR_FORMAT(2, 0);\nvoid default_error_handler(const struct failure_context *ctx,\n\t\t\t   const char *format, va_list args)\n\tATTR_FORMAT(2, 0);\n\n/* Send failures to syslog() */\nvoid i_syslog_fatal_handler(const struct failure_context *ctx,\n\t\t\t    const char *format, va_list args)\n\tATTR_NORETURN ATTR_FORMAT(2, 0);\nvoid i_syslog_error_handler(const struct failure_context *ctx,\n\t\t\t    const char *format, va_list args)\n\tATTR_FORMAT(2, 0);\n\n/* Open syslog and set failure/info/debug handlers to use it. */\nvoid i_set_failure_syslog(const char *ident, int options, int facility);\n\n/* Send failures to specified log file instead of stderr. */\nvoid i_set_failure_file(const char *path, const char *prefix);\n\n/* Send errors to stderr using internal error protocol. */\nvoid i_set_failure_internal(void);\n/* Returns TRUE if the given callback handler was set via\n   i_set_failure_internal(). */\nbool i_failure_handler_is_internal(failure_callback_t *const callback);\n/* If writing to log fails, ignore it instead of existing with\n   FATAL_LOGWRITE or FATAL_LOGERROR. */\nvoid i_set_failure_ignore_errors(bool ignore);\n\n/* Send informational messages to specified log file. i_set_failure_*()\n   functions modify the info file too, so call this function after them. */\nvoid i_set_info_file(const char *path);\n\n/* Send debug-level message to the given log file. The i_set_info_file() \n   function modifies also the debug log file, so call this function after it. */\nvoid i_set_debug_file(const char *path);\n\n/* Set the failure prefix. */\nvoid i_set_failure_prefix(const char *prefix_fmt, ...) ATTR_FORMAT(1, 2);\n/* Set prefix to \"\". */\nvoid i_unset_failure_prefix(void);\n/* Returns the current failure prefix (never NULL). */\nconst char *i_get_failure_prefix(void);\n/* Prefix failures with a timestamp. fmt is in strftime() format. */\nvoid i_set_failure_timestamp_format(const char *fmt);\n/* When logging with internal error protocol, update the process's current\n   IP address / log prefix by sending it to log process. This is mainly used to\n   improve the error message if the process crashes. */\nvoid i_set_failure_send_ip(const struct ip_addr *ip);\nvoid i_set_failure_send_prefix(const char *prefix);\n\n/* Call the callback before exit()ing. The callback may update the status. */\nvoid i_set_failure_exit_callback(void (*callback)(int *status));\n/* Call the exit callback and exit() */\nvoid failure_exit(int status) ATTR_NORETURN ATTR_COLD;\n\n/* Parse a line logged using internal failure handler */\nvoid i_failure_parse_line(const char *line, struct failure_line *failure);\n\nvoid failures_deinit(void);\n\n#endif\n"}, "26": {"id": 26, "path": "/home/runner/work/testcc/testcc/retdec/src/lib/fd-util.h", "content": "#ifndef FD_UTIL_H\n#define FD_UTIL_H\n\n/* Change close-on-exec flag of fd. */\nvoid fd_close_on_exec(int fd, bool set);\n\n/* Verify that fds in given range don't exist. */\nvoid fd_debug_verify_leaks(int first_fd, int last_fd);\n\n/* Set file descriptor to blocking/nonblocking state */\nvoid fd_set_nonblock(int fd, bool nonblock);\n\n/* Close fd_in and fd_out, unless they're already -1. They can point to the\n   same fd, in which case they're closed only once. If they point to stdin\n   or stdout, they're replaced with /dev/null. */\nvoid fd_close_maybe_stdio(int *fd_in, int *fd_out);\n\n/* Close the fd and set it to -1. This assert-crashes if fd == 0, and is a\n   no-op if fd == -1. Normally fd == 0 would happen only if an uninitialized\n   fd is attempted to be closed, which is a bug. */\nvoid i_close_fd_path(int *fd, const char *path, const char *arg,\n\t\t     const char *func, const char *file, int line);\n#define i_close_fd_path(fd, path) i_close_fd_path((fd), (path), #fd, __func__, __FILE__, __LINE__)\n#define i_close_fd(fd) i_close_fd_path((fd), NULL)\n\n#endif\n"}, "27": {"id": 27, "path": "/home/runner/work/testcc/testcc/retdec/src/lib/file-lock.h", "content": "#ifndef FILE_LOCK_H\n#define FILE_LOCK_H\n\n#include <unistd.h>\n#include <fcntl.h>\n\n#define DEFAULT_LOCK_TIMEOUT 120\n\nstruct file_lock;\nstruct dotlock;\n\nenum file_lock_method {\n\tFILE_LOCK_METHOD_FCNTL,\n\tFILE_LOCK_METHOD_FLOCK,\n\tFILE_LOCK_METHOD_DOTLOCK\n};\n\n/* Parse lock method from given string. Returns TRUE if ok,\n   FALSE if name is unknown. */\nbool file_lock_method_parse(const char *name, enum file_lock_method *method_r);\n/* Convert lock method to string. */\nconst char *file_lock_method_to_str(enum file_lock_method method);\n\n/* Lock the file. Returns 1 if successful, 0 if file is already locked,\n   or -1 if error. lock_type is F_WRLCK or F_RDLCK. */\nint file_try_lock(int fd, const char *path, int lock_type,\n\t\t  enum file_lock_method lock_method,\n\t\t  struct file_lock **lock_r);\n/* Like file_try_lock(), but return the error message as a string instead\n   of logging it. Also when returning 0 an error message is returned. */\nint file_try_lock_error(int fd, const char *path, int lock_type,\n\t\t\tenum file_lock_method lock_method,\n\t\t\tstruct file_lock **lock_r, const char **error_r);\n/* Like lock_try_lock(), but return 0 only after having tried to lock for\n   timeout_secs. */\nint file_wait_lock(int fd, const char *path, int lock_type,\n\t\t   enum file_lock_method lock_method,\n\t\t   unsigned int timeout_secs,\n\t\t   struct file_lock **lock_r);\n/* Like file_wait_lock(), but return the error message as a string instead\n   of logging it. Also when returning 0 an error message is returned. */\nint file_wait_lock_error(int fd, const char *path, int lock_type,\n\t\t\t enum file_lock_method lock_method,\n\t\t\t unsigned int timeout_secs,\n\t\t\t struct file_lock **lock_r, const char **error_r);\n/* Change the lock type. WARNING: This isn't an atomic operation!\n   The result is the same as file_unlock() + file_try_lock(). */\nint file_lock_try_update(struct file_lock *lock, int lock_type);\n/* When the lock is freed, unlink() the file automatically, unless other\n   processes are already waiting on the lock. This can be useful for files that\n   are only created to exist as lock files. */\nvoid file_lock_set_unlink_on_free(struct file_lock *lock, bool set);\n/* When the lock is freed, close the fd automatically. This can\n   be useful for files that are only created to exist as lock files. */\nvoid file_lock_set_close_on_free(struct file_lock *lock, bool set);\n\n/* Convert dotlock into file_lock, which can be deleted with either\n   file_unlock() or file_lock_free(). */\nstruct file_lock *file_lock_from_dotlock(struct dotlock **dotlock);\n\n/* Unlock and free the lock. */\nvoid file_unlock(struct file_lock **lock);\n/* Free the lock without unlocking it (because you're closing the fd anyway). */\nvoid file_lock_free(struct file_lock **lock);\n\n/* Returns the path given as parameter to file_*lock*(). */\nconst char *file_lock_get_path(struct file_lock *lock);\n/* Update lock file's path (after it gets renamed by the caller). This is\n   useful mainly together with file_lock_set_unlink_on_free(). */\nvoid file_lock_set_path(struct file_lock *lock, const char *path);\n\n/* Returns human-readable string containing the process that has the file\n   currently locked. Returns \"\" if unknown, otherwise \" (string)\". */\nconst char *file_lock_find(int lock_fd, enum file_lock_method lock_method,\n\t\t\t   int lock_type);\n\n/* Track the duration of a lock wait. */\nvoid file_lock_wait_start(void);\nvoid file_lock_wait_end(const char *lock_name);\n/* Return how many microseconds has been spent on lock waiting. */\nuint64_t file_lock_wait_get_total_usecs(void);\n\n#endif\n"}, "28": {"id": 28, "path": "/home/runner/work/testcc/testcc/retdec/src/lib/fsync-mode.h", "content": "#ifndef FSYNC_MODE_H\n#define FSYNC_MODE_H\n\nenum fsync_mode {\n\t/* fsync when it's necessary for data safety. */\n\tFSYNC_MODE_OPTIMIZED = 0,\n\t/* never fsync (in case of a crash can lose data) */\n\tFSYNC_MODE_NEVER,\n\t/* fsync after all writes. this is necessary with NFS to avoid\n\t   write failures being delayed until file is close(). */\n\tFSYNC_MODE_ALWAYS\n};\n\n#endif\n"}, "29": {"id": 29, "path": "/home/runner/work/testcc/testcc/retdec/src/lib/guid.h", "content": "#ifndef GUID_H\n#define GUID_H\n\n#define GUID_128_SIZE 16\ntypedef uint8_t guid_128_t[GUID_128_SIZE];\n\n#define GUID_128_HOST_HASH_SIZE 4\n\nARRAY_DEFINE_TYPE(guid_128_t, guid_128_t);\n\nenum uuid_format {\n\tFORMAT_RECORD,\n\tFORMAT_COMPACT,\n\tFORMAT_MICROSOFT,\n};\n/* Generate a GUID (contains host name) */\nconst char *guid_generate(void);\n/* Generate 128 bit GUID */\nvoid guid_128_generate(guid_128_t guid_r);\n/* Returns TRUE if GUID is empty (not set / unknown). */\nbool guid_128_is_empty(const guid_128_t guid) ATTR_PURE;\nstatic inline void guid_128_empty(guid_128_t guid)\n{\n\tmemset(guid, 0, GUID_128_SIZE);\n}\n/* Returns TRUE if two GUIDs are equal. */\nbool guid_128_equals(const guid_128_t guid1, const guid_128_t guid2) ATTR_PURE;\n/* Copy GUID */\nstatic inline void guid_128_copy(guid_128_t dest, const guid_128_t src)\n{\n\tmemcpy(dest, src, GUID_128_SIZE);\n}\n\n/* Returns GUID as a hex string. */\nconst char *guid_128_to_string(const guid_128_t guid);\n/* Parse GUID from a string. Returns 0 if ok, -1 if GUID isn't valid. */\nint guid_128_from_string(const char *str, guid_128_t guid_r);\n\n/* Returns GUID as a UUID hex string. */\nconst char *guid_128_to_uuid_string(const guid_128_t guid, enum uuid_format format);\n/* Parse GUID from a UUID string. Returns 0 if ok, -1 if UUID isn't valid. */\nint guid_128_from_uuid_string(const char *str, guid_128_t guid_r);\n\n/* guid_128 hash/cmp functions for hash.h */\nunsigned int guid_128_hash(const guid_128_t guid) ATTR_PURE;\nint guid_128_cmp(const guid_128_t guid1, const guid_128_t guid2) ATTR_PURE;\n\n/* Return the hash of host used by guid_128_generate(). */\nvoid guid_128_host_hash_get(const char *host,\n\t\t\t    unsigned char hash_r[STATIC_ARRAY GUID_128_HOST_HASH_SIZE]);\n\n#endif\n"}, "30": {"id": 30, "path": "/home/runner/work/testcc/testcc/retdec/src/lib/hash-decl.h", "content": "#ifndef HASH_DECL_H\n#define HASH_DECL_H\n\n#define HASH_TABLE_UNION(key_type, value_type) { \\\n\t\tstruct hash_table *_table; \\\n\t\tkey_type _key; \\\n\t\tkey_type *_keyp; \\\n\t\tconst key_type _const_key; \\\n\t\tvalue_type _value; \\\n\t\tvalue_type *_valuep; \\\n\t}\n\n#define HASH_TABLE_DEFINE_TYPE(name, key_type, value_type) \\\n\tunion hash ## __ ## name HASH_TABLE_UNION(key_type, value_type)\n#define HASH_TABLE(key_type, value_type) \\\n\tunion HASH_TABLE_UNION(key_type, value_type)\n#define HASH_TABLE_TYPE(name) \\\n\tunion hash ## __ ## name\n\n#endif\n"}, "31": {"id": 31, "path": "/home/runner/work/testcc/testcc/retdec/src/lib/hex-binary.h", "content": "#ifndef HEX_BINARY_H\n#define HEX_BINARY_H\n\n/* Convert binary to hex digits allocating return value from data stack */\nconst char *binary_to_hex(const unsigned char *data, size_t size);\nconst char *binary_to_hex_ucase(const unsigned char *data, size_t size);\n\nvoid binary_to_hex_append(string_t *dest, const unsigned char *data,\n\t\t\t  size_t size);\n\n/* Convert hex to binary. data and dest may point to same value.\n   Returns 0 if all ok, -1 if data is invalid. */\nint hex_to_binary(const char *data, buffer_t *dest);\n\n#endif\n"}, "32": {"id": 32, "path": "/home/runner/work/testcc/testcc/retdec/src/lib/imem.h", "content": "#ifndef IMEM_H\n#define IMEM_H\n\n/* For easy allocation of memory from default memory pool. */\n\nextern pool_t default_pool;\n\n#define i_new(type, count) p_new(default_pool, type, count)\n#define i_realloc_type(mem, type, old_count, new_count) \\\n\tp_realloc_type(default_pool, mem, type, old_count, new_count)\n\nvoid *i_malloc(size_t size) ATTR_MALLOC ATTR_RETURNS_NONNULL;\nvoid *i_realloc(void *mem, size_t old_size, size_t new_size)\n\tATTR_WARN_UNUSED_RESULT ATTR_RETURNS_NONNULL;\n\n/* i_free() and i_free_and_null() are now guaranteed to both set mem=NULL,\n   so either one of them can be used. */\n#ifndef STATIC_CHECKER\n#  define i_free(mem) p_free_and_null(default_pool, mem)\n#else\n#  define i_free(mem) \\\n\tSTMT_START { \\\n\t\tpool_system_free(default_pool, mem); \\\n\t\t(mem) = NULL; \\\n\t} STMT_END\n#endif\n#define i_free_and_null(mem) i_free(mem)\n\n/* string functions */\nchar *i_strdup(const char *str) ATTR_MALLOC;\nvoid *i_memdup(const void *data, size_t size) ATTR_MALLOC;\n/* like i_strdup(), but if str == \"\", return NULL */\nchar *i_strdup_empty(const char *str) ATTR_MALLOC;\n/* *end isn't included */\nchar *i_strdup_until(const void *str, const void *end)\n\tATTR_MALLOC ATTR_RETURNS_NONNULL;\nchar *i_strndup(const void *str, size_t max_chars) ATTR_MALLOC;\nchar *i_strdup_printf(const char *format, ...)\n\tATTR_FORMAT(1, 2) ATTR_MALLOC ATTR_RETURNS_NONNULL;\nchar *i_strdup_vprintf(const char *format, va_list args)\n\tATTR_FORMAT(1, 0) ATTR_MALLOC ATTR_RETURNS_NONNULL;\n\nchar *i_strconcat(const char *str1, ...)  ATTR_SENTINEL ATTR_MALLOC;\n\n#endif\n"}, "33": {"id": 33, "path": "/home/runner/work/testcc/testcc/retdec/src/lib/lib-event.h", "content": "#ifndef LIB_EVENT_H\n#define LIB_EVENT_H\n/* event.h name is probably a bit too generic, so lets avoid using it. */\n\n#include <sys/time.h>\n\nstruct event;\nstruct event_log_params;\n\n/* Hierarchical category of events. Each event can belong to multiple\n   categories. For example [ lib-storage/maildir, syscall/io ]. The categories\n   are expected to live as long as they're used in events. */\nstruct event_category {\n\tstruct event_category *parent;\n\tconst char *name;\n\n\t/* non-NULL if this category has been registered\n\n\t   Do NOT dereference outside of event code in src/lib.\n\n\t   At any point in time it is safe to (1) check the pointer for\n\t   NULL/non-NULL to determine if this particular category instance\n\t   has been registered, and (2) compare two categories' internal\n\t   pointers to determine if they represent the same category. */\n\tvoid *internal;\n};\n\nenum event_field_value_type {\n\tEVENT_FIELD_VALUE_TYPE_STR,\n\tEVENT_FIELD_VALUE_TYPE_INTMAX,\n\tEVENT_FIELD_VALUE_TYPE_TIMEVAL,\n};\n\nstruct event_field {\n\tconst char *key;\n\tenum event_field_value_type value_type;\n\tstruct {\n\t\tconst char *str;\n\t\tintmax_t intmax;\n\t\tstruct timeval timeval;\n\t} value;\n};\n\nstruct event_add_field {\n\tconst char *key;\n\t/* The first non-0/NULL value is used. */\n\tconst char *value;\n\tintmax_t value_intmax;\n\tstruct timeval value_timeval;\n};\n\nstruct event_passthrough {\n\t/* wrappers to event_set_*() and event_add_*() for passthrough events,\n\t   so these can be chained like:\n\t   event_create_passthrough(parent)->name(\"name\")->...->event() */\n\tstruct event_passthrough *\n\t\t(*append_log_prefix)(const char *prefix);\n\tstruct event_passthrough *\n\t\t(*replace_log_prefix)(const char *prefix);\n\tstruct event_passthrough *\n\t\t(*set_name)(const char *name);\n\tstruct event_passthrough *\n\t\t(*set_source)(const char *filename,\n\t\t\t      unsigned int linenum, bool literal_fname);\n\tstruct event_passthrough *\n\t\t(*set_always_log_source)(void);\n\n\tstruct event_passthrough *\n\t\t(*add_categories)(struct event_category *const *categories);\n\tstruct event_passthrough *\n\t\t(*add_category)(struct event_category *category);\n\tstruct event_passthrough *\n\t\t(*add_fields)(const struct event_add_field *fields);\n\n\tstruct event_passthrough *\n\t\t(*add_str)(const char *key, const char *value);\n\tstruct event_passthrough *\n\t\t(*add_int)(const char *key, intmax_t num);\n\tstruct event_passthrough *\n\t\t(*add_timeval)(const char *key, const struct timeval *tv);\n\n\tstruct event_passthrough *\n\t\t(*inc_int)(const char *key, intmax_t num);\n\n\tstruct event_passthrough *\n\t\t(*clear_field)(const char *key);\n\n\tstruct event *(*event)(void);\n};\n\ntypedef const char *\nevent_log_prefix_callback_t(void *context);\ntypedef const char *\nevent_log_message_callback_t(void *context, enum log_type log_type,\n\t\t\t     const char *message);\n\n/* Returns TRUE if the event has all the categories that the \"other\" event has (and maybe more). */\nbool event_has_all_categories(struct event *event, const struct event *other);\n/* Returns TRUE if the event has all the fields that the \"other\" event has (and maybe more).\n   Only the fields in the events themselves are checked. Parent events' fields are not checked. */\nbool event_has_all_fields(struct event *event, const struct event *other);\n\n/* Returns the source event duplicated into a new event. Event pointers are\n   dropped. */\nstruct event *event_dup(const struct event *source);\n/* Returns a flattened version of the source event.\n   Both categories and fields will be flattened.\n   A new reference to the source event is returned if no flattening was\n   needed. Event pointers are dropped if a new event was created. */\nstruct event *event_flatten(struct event *src);\n/* Returns a minimized version of the source event.\n   Remove parents with no fields or categories, attempt to flatten fields\n   and categories to avoid sending one-off parent events.  (There is a more\n   detailed description in a comment above the function implementation.)\n   A new reference to the source event is returned if no simplification\n   occured. Event pointers are dropped if a new event was created. */\nstruct event *event_minimize(struct event *src);\n/* Copy all categories from source to dest.\n   Only the categories in source event itself are copied.\n   Parent events' categories aren't copied. */\nvoid event_copy_categories(struct event *to, struct event *from);\n/* Copy all fields from source to dest.\n   Only the fields in source event itself are copied.\n   Parent events' fields aren't copied. */\nvoid event_copy_fields(struct event *to, struct event *from);\n\n/* Create a new empty event under the parent event, or NULL for root event. */\nstruct event *event_create(struct event *parent, const char *source_filename,\n\t\t\t   unsigned int source_linenum);\n#define event_create(parent) \\\n\tevent_create((parent), __FILE__, __LINE__)\n/* This is a temporary \"passthrough\" event. Its main purpose is to make it\n   easier to create temporary events as part of the event parameter in\n   e_error(), e_warning(), e_info() or e_debug(). These passthrough events are\n   automatically freed when the e_*() call is finished. Because this makes the\n   freeing less obvious, it should be avoided outside e_*()'s event parameter.\n\n   The passthrough events also change the API to be more convenient towards\n   being used in a parameter. Instead of having to use e.g.\n   event_add_str(event_set_name(event_create(parent), \"name\"), \"key\", \"value\")\n   the event_passthrough API can be a bit more readable as:\n   event_create_passthrough(parent)->set_name(\"name\")->\n   add_str(\"key\", \"value\")->event(). The passthrough event is converted to\n   a normal event at the end with the event() call. Note that this API works\n   by modifying the last created passthrough event, so it's not possible to\n   have multiple passthrough events created in parallel. */\nstruct event_passthrough *\nevent_create_passthrough(struct event *parent, const char *source_filename,\n\t\t\t unsigned int source_linenum);\n#define event_create_passthrough(parent) \\\n\tevent_create_passthrough((parent), __FILE__, __LINE__)\n\n/* Reference the event. Returns the event parameter. */\nstruct event *event_ref(struct event *event);\n/* Unreference the event. If the reference count drops to 0, the event is\n   freed. The current global event's refcount must not drop to 0. */\nvoid event_unref(struct event **event);\n\n/* Set the event to be the global default event used by i_error(), etc.\n   Returns the event parameter. The event must be explicitly popped before\n   it's freed.\n\n   The global event stack is also an alternative nonpermanent hierarchy for\n   events. For example the global event can be \"IMAP command SELECT\", which\n   can be used for filtering events that happen while the SELECT command is\n   being executed. However, for the created struct mailbox the parent event\n   should be the mail_user, not the SELECT command. Otherwise everything else\n   that happens afterwards to the selected mailbox would also count towards\n   SELECT. This means that events shouldn't be using the current global event\n   as their parent event. */\nstruct event *event_push_global(struct event *event);\n/* Pop the global event. Assert-crash if the current global event isn't the\n   given event parameter. Returns the new global event. */\nstruct event *event_pop_global(struct event *event);\n/* Returns the current global event. */\nstruct event *event_get_global(void);\n\n/* Set the appended log prefix string for this event. All the parent events'\n   log prefixes will be concatenated together when logging. The log type\n   text (e.g. \"Info: \") will be inserted before appended log prefixes (but\n   after replaced log prefix).\n\n   Clears log_prefix callback.\n */\nstruct event *\nevent_set_append_log_prefix(struct event *event, const char *prefix);\n/* Replace the full log prefix string for this event. The parent events' log\n   prefixes won't be used. Also, any parent event's message amendment callback\n   is not used.\n\n   Clears log_prefix callback.\n*/\nstruct event *event_replace_log_prefix(struct event *event, const char *prefix);\n\n/* Drop count prefixes from parents when this event is used for logging. This\n   does not affect the parent events. This only counts actual prefixes and not\n   parents. If the count is higher than the actual number of prefixes added by\n   parents, all will be dropped. */\nstruct event *\nevent_drop_parent_log_prefixes(struct event *event, unsigned int count);\n\n/* Sets event prefix callback, sets log_prefix empty */\nstruct event *event_set_log_prefix_callback(struct event *event,\n\t\t\t\t\t    bool replace,\n\t\t\t\t\t    event_log_prefix_callback_t *callback,\n\t\t\t\t\t    void *context);\n#define event_set_log_prefix_callback(event, replace, callback, context) \\\n\tevent_set_log_prefix_callback(event, replace, \\\n\t\t(event_log_prefix_callback_t*)callback, TRUE ? context : \\\n\t\tCALLBACK_TYPECHECK(callback, const char *(*)(typeof(context))))\n\n/* Sets event message amendment callback */\nstruct event *event_set_log_message_callback(struct event *event,\n\t\t\t\t\t     event_log_message_callback_t *callback,\n\t\t\t\t\t     void *context);\n#define event_set_log_message_callback(event, callback, context) \\\n\tevent_set_log_message_callback(event, \\\n\t\t(event_log_message_callback_t*)callback, TRUE ? context : \\\n\t\tCALLBACK_TYPECHECK(callback, \\\n\t\t\tconst char *(*)(typeof(context), enum log_type, \\\n\t\t\t\t\tconst char *)))\n\n/* Set the event's name. The name is specific to a single sending of an event,\n   and it'll be automatically cleared once the event is sent. This should\n   typically be used only in a parameter to e_debug(), etc. */\nstruct event *\nevent_set_name(struct event *event, const char *name);\n/* Set the source filename:linenum to the event. If literal_fname==TRUE,\n   it's assumed that __FILE__ has been used and the pointer is stored directly,\n   otherwise the filename is strdup()ed. */\nstruct event *\nevent_set_source(struct event *event, const char *filename,\n\t\t unsigned int linenum, bool literal_fname);\n/* Always include the source path:line in the log replies. This is\n   especially useful when logging about unexpected syscall failures, because\n   it allow quickly finding which of the otherwise identical syscalls in the\n   code generated the error. */\nstruct event *event_set_always_log_source(struct event *event);\n/* Set minimum log level for the event */\nstruct event *event_set_min_log_level(struct event *event, enum log_type level);\nenum log_type event_get_min_log_level(const struct event *event);\n\n/* Add an internal pointer to an event. It can be looked up only with\n   event_get_ptr(). The keys are in their own namespace and won't conflict\n   with event fields. The pointers are specific to this specific event only -\n   they will be dropped from any duplicated/flattened/minimized events. */\nstruct event *event_set_ptr(struct event *event, const char *key, void *value);\n/* Return a pointer set with event_set_ptr(), or NULL if it doesn't exist.\n   The pointer is looked up only from the event itself, not its parents. */\nvoid *event_get_ptr(const struct event *event, const char *key);\n\n/* Add NULL-terminated list of categories to the event. The categories pointer\n   doesn't need to stay valid afterwards, but the event_category structs\n   themselves must be. Returns the event parameter. */\nstruct event *\nevent_add_categories(struct event *event,\n\t\t     struct event_category *const *categories);\n/* Add a single category to the event. */\nstruct event *\nevent_add_category(struct event *event, struct event_category *category);\n\n/* Add key=value field to the event. If a key already exists, it's replaced.\n   Child events automatically inherit key=values from their parents at the\n   time the event is sent. So changing a key in parent will change the values\n   in the child events as well, unless the key has been overwritten in the\n   child event. Setting the value to \"\" is the same as event_field_clear().\n   Returns the event parameter. */\nstruct event *\nevent_add_str(struct event *event, const char *key, const char *value);\nstruct event *\nevent_add_int(struct event *event, const char *key, intmax_t num);\n/* Increase the key's value. If it's not set or isn't an integer type,\n   initialize the value to num. */\nstruct event *\nevent_inc_int(struct event *event, const char *key, intmax_t num);\nstruct event *\nevent_add_timeval(struct event *event, const char *key,\n\t\t  const struct timeval *tv);\n/* Same as event_add_str/int(), but do it via event_field struct. The fields\n   terminates with key=NULL. Returns the event parameter. */\nstruct event *\nevent_add_fields(struct event *event, const struct event_add_field *fields);\n/* Mark a field as nonexistent. If a parent event has the field set, this\n   allows removing it from the child event. Using an event filter with e.g.\n   \"key=*\" won't match this field anymore, although it's still visible in\n   event_find_field*() and event_get_fields(). This is the same as using\n   event_add_str() with value=\"\". */\nvoid event_field_clear(struct event *event, const char *key);\n\n/* Returns the parent event, or NULL if it doesn't exist. */\nstruct event *event_get_parent(const struct event *event);\n/* Get the event's creation time. */\nvoid event_get_create_time(const struct event *event, struct timeval *tv_r);\n/* Get the time when the event was last sent. Returns TRUE if time was\n   returned, FALSE if event has never been sent. */\nbool event_get_last_send_time(const struct event *event, struct timeval *tv_r);\n/* Get the event duration field, calculated after event has been sent. */\nvoid event_get_last_duration(const struct event *event,\n\t\t\t     intmax_t *duration_msec_r);\n/* Returns field for a given key, or NULL if it doesn't exist. If the key\n   isn't found from the event itself, find it from parent events. */\nconst struct event_field *\nevent_find_field(const struct event *event, const char *key);\n/* Returns the given key's value as string, or NULL if it doesn't exist.\n   If the field isn't stored as a string, the result is allocated from\n   data stack. */\nconst char *\nevent_find_field_str(const struct event *event, const char *key);\n/* Returns all key=value fields that the event has.\n   Parent events' fields aren't returned. */\nconst struct event_field *\nevent_get_fields(const struct event *event, unsigned int *count_r);\n/* Return all categories that the event has.\n   Parent events' categories aren't returned. */\nstruct event_category *const *\nevent_get_categories(const struct event *event, unsigned int *count_r);\n\n/* Export the event into a tabescaped string, so its fields are separated\n   with TABs and there are no NUL, CR or LF characters. */\nvoid event_export(const struct event *event, string_t *dest);\n/* Import event. The string is expected to be generated by event_export().\n   All the used categories must already be registered.\n   Returns TRUE on success, FALSE on invalid string. */\nbool event_import(struct event *event, const char *str, const char **error_r);\n/* Same as event_import(), but string is already split into an array\n   of strings via *_strsplit_tabescaped(). */\nbool event_import_unescaped(struct event *event, const char *const *args,\n\t\t\t    const char **error_r);\n\n/* The event wasn't sent after all - free everything related to it.\n   Most importantly this frees any passthrough events. Typically this shouldn't\n   need to be called. */\nvoid event_send_abort(struct event *event);\n\nvoid lib_event_init(void);\nvoid lib_event_deinit(void);\n\n#endif\n"}, "34": {"id": 34, "path": "/home/runner/work/testcc/testcc/retdec/src/lib/lib.h", "content": "#ifndef LIB_H\n#define LIB_H\n\n/* default lib includes */\n#ifdef HAVE_CONFIG_H\n#  include \"config.h\"\n#endif\n\n/* default system includes - keep these at minimum.. */\n#include <stddef.h> /* Solaris defines NULL wrong unless this is used */\n#include <stdlib.h>\n#include <string.h> /* strcmp() etc. */\n#ifdef HAVE_STRINGS_H\n#  include <strings.h> /* strcasecmp() etc. */\n#endif\n#include <stdarg.h> /* va_list is used everywhere */\n#include <limits.h> /* INT_MAX, etc. */\n#include <errno.h> /* error checking is good */\n#include <sys/types.h> /* many other includes want this */\n#include <inttypes.h> /* PRI* macros */\n\n#ifdef HAVE_STDINT_H\n#  include <stdint.h> /* C99 int types, we mostly need uintmax_t */\n#endif\n\n#include \"compat.h\"\n#include \"macros.h\"\n#include \"failures.h\"\n\n#include \"malloc-overflow.h\"\n#include \"data-stack.h\"\n#include \"mempool.h\"\n#include \"imem.h\"\n#include \"byteorder.h\"\n#include \"fd-util.h\"\n\ntypedef struct buffer buffer_t;\ntypedef struct buffer string_t;\n\nstruct istream;\nstruct ostream;\n\ntypedef void lib_atexit_callback_t(void);\n\n#include \"array-decl.h\" /* ARRAY*()s may exist in any header */\n#include \"bits.h\"\n#include \"hash-decl.h\" /* HASH_TABLE*()s may exist in any header */\n#include \"strfuncs.h\"\n#include \"strnum.h\"\n#include \"event-log.h\"\n\n#define LIB_ATEXIT_PRIORITY_HIGH -10\n#define LIB_ATEXIT_PRIORITY_DEFAULT 0\n#define LIB_ATEXIT_PRIORITY_LOW 10\n\n/* /dev/null opened as O_WRONLY. Opened at lib_init(), so it can be accessed\n   also inside chroots. */\nextern int dev_null_fd;\n\n/* Call unlink(). If it fails, log an error including the source filename\n   and line number. */\nint i_unlink(const char *path, const char *source_fname,\n\t     unsigned int source_linenum);\n#define i_unlink(path) i_unlink(path, __FILE__, __LINE__)\n/* Same as i_unlink(), but don't log an error if errno=ENOENT. Returns 1 on\n   unlink() success, 0 if errno=ENOENT, -1 on other errors. */\nint i_unlink_if_exists(const char *path, const char *source_fname,\n\t\t       unsigned int source_linenum);\n#define i_unlink_if_exists(path) i_unlink_if_exists(path, __FILE__, __LINE__)\n/* Reset getopt() so it can be used for the next args. */\nvoid i_getopt_reset(void);\n\n/* Call the given callback at the beginning of lib_deinit(). The main\n   difference to atexit() is that liblib's memory allocation and logging\n   functions are still available. Also if lib_atexit() is called multiple times\n   to the same callback, it's added only once. */\nvoid lib_atexit(lib_atexit_callback_t *callback);\n/* Specify the order in which the callback is called. Lowest numbered\n   priorities are called first. lib_atexit() is called with priority=0. */\nvoid lib_atexit_priority(lib_atexit_callback_t *callback, int priority);\n/* Manually run the atexit callbacks. lib_deinit() also does this if not\n   explicitly called. */\nvoid lib_atexit_run(void);\n\nvoid lib_init(void);\nbool lib_is_initialized(void);\nvoid lib_deinit(void);\n\nuint32_t i_rand(void);\n/* Returns a random integer < upper_bound. */\nuint32_t i_rand_limit(uint32_t upper_bound);\n\n/* Returns a random integer >= min_val, and <= max_val. */\nstatic inline uint32_t i_rand_minmax(uint32_t min_val, uint32_t max_val)\n{\n\ti_assert(min_val <= max_val);\n\treturn min_val + i_rand_limit(max_val - min_val + 1);\n}\n\n#endif\n"}, "35": {"id": 35, "path": "/home/runner/work/testcc/testcc/retdec/src/lib/malloc-overflow.h", "content": "#ifndef MALLOC_OVERFLOW_H\n#define MALLOC_OVERFLOW_H\n\n/* MALLOC_*() can be used to calculate memory allocation sizes. If there's an\n   overflow, it'll cleanly panic instead of causing a potential buffer\n   overflow.\n\n   Note that *_malloc(size+1) doesn't need to use MALLOC_ADD(size, 1). It wraps\n   to size==0 and the *_malloc() calls already panic if size==0. */\nstatic inline size_t\nmalloc_multiply_check(size_t a, size_t b, size_t sizeof_a, size_t sizeof_b,\n\t\t      const char *fname, unsigned int linenum)\n{\n\t/* the first sizeof-checks are intended to optimize away this entire\n\t   if-check for types that are small enough to never wrap size_t. */\n\tif ((sizeof_a * 2 > sizeof(size_t) || sizeof_b * 2 > sizeof(size_t)) &&\n\t    b != 0 && (a > SIZE_MAX / b)) {\n\t\ti_panic(\"file %s: line %d: memory allocation overflow: %zu * %zu\",\n\t\t\tfname, linenum, a, b);\n\t}\n\treturn a * b;\n}\n#ifndef STATIC_CHECKER\n#  define MALLOC_MULTIPLY(a, b) \\\n\tmalloc_multiply_check(a, b, sizeof(a), sizeof(b), __FILE__, __LINE__)\n#else\n/* avoid warning every time about sizeof(b) when b contains any arithmetic */\n#  define MALLOC_MULTIPLY(a, b) \\\n\tmalloc_multiply_check(a, b, sizeof(a), sizeof(size_t), __FILE__, __LINE__)\n#endif\n\nstatic inline size_t\nmalloc_add_check(size_t a, size_t b, size_t sizeof_a, size_t sizeof_b,\n\t\t const char *fname, unsigned int linenum)\n{\n\t/* the first sizeof-checks are intended to optimize away this entire\n\t   if-check for types that are small enough to never wrap size_t. */\n\tif ((sizeof_a >= sizeof(size_t) || sizeof_b >= sizeof(size_t)) &&\n\t    SIZE_MAX - a < b) {\n\t\ti_panic(\"file %s: line %d: memory allocation overflow: %zu + %zu\",\n\t\t\tfname, linenum, a, b);\n\t}\n\treturn a + b;\n}\n#ifndef STATIC_CHECKER\n#  define MALLOC_ADD(a, b) \\\n\tmalloc_add_check(a, b, sizeof(a), sizeof(b), __FILE__, __LINE__)\n#else\n/* avoid warning every time about sizeof(b) when b contains any arithmetic */\n#  define MALLOC_ADD(a, b) \\\n\tmalloc_add_check(a, b, sizeof(a), sizeof(size_t), __FILE__, __LINE__)\n#endif\n\n#endif\n"}, "36": {"id": 36, "path": "/home/runner/work/testcc/testcc/retdec/src/lib/mempool.h", "content": "#ifndef MEMPOOL_H\n#define MEMPOOL_H\n\n#include \"macros.h\"\n\n/* When DEBUG is enabled, Dovecot warns whenever a memory pool is grown.\n   This is done so that the initial pool size could be set large enough so that\n   it wouldn't grow in normal use. For some memory pools it's too difficult\n   to calculate a good initial size, so this prefix should be used with those\n   pools to disable the warning. */\n#define MEMPOOL_GROWING \"GROWING-\"\n\n/* The maximum allocation size that's allowed.  Anything larger than that\n   will panic.  No pool ever should need more than 4kB of overhead per\n   allocation. */\n#define POOL_MAX_ALLOC_SIZE\t(SSIZE_T_MAX - 4096)\n\n/* Memory allocated and reallocated (the new data in it) in pools is always\n   zeroed, it will cost only a few CPU cycles and may well save some debug\n   time. */\n\ntypedef struct pool *pool_t;\n\nstruct pool_vfuncs {\n\tconst char *(*get_name)(pool_t pool);\n\n\tvoid (*ref)(pool_t pool);\n\tvoid (*unref)(pool_t *pool);\n\n\tvoid *(*malloc)(pool_t pool, size_t size) ATTR_RETURNS_NONNULL;\n\tvoid (*free)(pool_t pool, void *mem);\n\n\t/* memory in old_size..new_size will be zeroed */\n\tvoid *(*realloc)(pool_t pool, void *mem,\n\t\t\t size_t old_size, size_t new_size)\n\t\tATTR_WARN_UNUSED_RESULT ATTR_RETURNS_NONNULL;\n\n\t/* Frees all the memory in pool. NOTE: system_pool doesn't support\n\t   this and crashes if it's used */\n\tvoid (*clear)(pool_t pool);\n\n\t/* Returns the maximum amount of bytes that can be allocated with\n\t   minimal trouble. If there's no such concept, always returns 0. */\n\tsize_t (*get_max_easy_alloc_size)(pool_t pool);\n};\n\nstruct pool {\n\tconst struct pool_vfuncs *v;\n\n\tbool alloconly_pool:1;\n\tbool datastack_pool:1;\n};\n\n/* system_pool uses calloc() + realloc() + free() */\nextern pool_t system_pool;\nextern struct pool static_system_pool;\n\n/* memory allocated from data_stack is valid only until next t_pop() call.\n   No checks are performed. */\nextern pool_t unsafe_data_stack_pool;\n\n/* Create a new alloc-only pool. Note that `size' specifies the initial\n   malloc()ed block size, part of it is used internally. */\npool_t pool_alloconly_create(const char *name, size_t size);\n/* Like alloconly pool, but clear the memory before freeing it. The idea is\n   that you could allocate memory for storing sensitive information from this\n   pool, and be sure that it gets cleared from the memory when it's no longer\n   needed. */\npool_t pool_alloconly_create_clean(const char *name, size_t size);\n\n/* When allocating memory from returned pool, the data stack frame must be\n   the same as it was when calling this function. pool_unref() also checks\n   that the stack frame is the same. This should make it quite safe to use. */\npool_t pool_datastack_create(void);\n\n/* Create new alloc pool. This is very similar to system pool, but it\n   will deallocate all memory on deinit. */\npool_t pool_allocfree_create(const char *name);\n\n/* Like alloc pool, but all memory is cleaned before freeing.\n   See pool_alloconly_create_clean. */\npool_t pool_allocfree_create_clean(const char *name);\n\n/* Similar to nearest_power(), but try not to exceed buffer's easy\n   allocation size. If you don't have any explicit minimum size, use\n   old_size + 1. */\nsize_t pool_get_exp_grown_size(pool_t pool, size_t old_size, size_t min_size);\n\n/* We require sizeof(type) to be <= UINT_MAX. This allows compiler to optimize\n   away the entire MALLOC_MULTIPLY() call on 64bit systems. */\n#define p_new(pool, type, count) \\\n\t((type *) p_malloc(pool, MALLOC_MULTIPLY((unsigned int)sizeof(type), (count))) + \\\n\t COMPILE_ERROR_IF_TRUE(sizeof(type) > UINT_MAX))\n\n#define p_realloc_type(pool, mem, type, old_count, new_count) \\\n\t((type *) p_realloc(pool, mem, \\\n\t MALLOC_MULTIPLY((unsigned int)sizeof(type), (old_count)), \\\n\t MALLOC_MULTIPLY((unsigned int)sizeof(type), (new_count))) + \\\n\t\tCOMPILE_ERROR_IF_TRUE(sizeof(type) > UINT_MAX))\n\nstatic inline void * ATTR_MALLOC ATTR_RETURNS_NONNULL\np_malloc(pool_t pool, size_t size)\n{\n\tif (unlikely(size == 0 || size > POOL_MAX_ALLOC_SIZE))\n\t\ti_panic(\"Trying to allocate %zu bytes\", size);\n\n\treturn pool->v->malloc(pool, size);\n}\n\nstatic inline void * ATTR_WARN_UNUSED_RESULT ATTR_RETURNS_NONNULL\np_realloc(pool_t pool, void *mem, size_t old_size, size_t new_size)\n{\n\tif (unlikely(new_size == 0 || new_size > POOL_MAX_ALLOC_SIZE))\n\t\ti_panic(\"Trying to reallocate %zu -> %zu bytes\",\n\t\t\told_size, new_size);\n\n\tif (mem == NULL)\n\t\treturn pool->v->malloc(pool, new_size);\n\n\treturn pool->v->realloc(pool, mem, old_size, new_size);\n}\n\n/* Free the memory. p_free() and p_free_and_null() are now guaranteed to both\n   set mem=NULL, so either one of them can be used. */\n#define p_free(pool, mem) \\\n\tSTMT_START { \\\n\t\tp_free_internal(pool, mem);\t\\\n\t\t(mem) = NULL;\t\t\t\\\n\t} STMT_END\n#define p_free_and_null(pool, mem) p_free(pool, mem)\n\nstatic inline void p_free_internal(pool_t pool, void *mem)\n{\n\tif (mem != NULL)\n\t\tpool->v->free(pool, mem);\n}\n\nstatic inline void p_clear(pool_t pool)\n{\n\tpool->v->clear(pool);\n}\n\nstatic inline size_t p_get_max_easy_alloc_size(pool_t pool)\n{\n\treturn pool->v->get_max_easy_alloc_size(pool);\n}\n\nstatic inline const char *pool_get_name(pool_t pool)\n{\n\treturn pool->v->get_name(pool);\n}\n\nstatic inline void pool_ref(pool_t pool)\n{\n\tpool->v->ref(pool);\n}\n\nstatic inline void pool_unref(pool_t *pool)\n{\n\tif (*pool != NULL)\n\t\t(*pool)->v->unref(pool);\n}\n\n/* These functions are only for pools created with pool_alloconly_create(): */\n\n/* Returns how much memory has been allocated from this pool. */\nsize_t pool_alloconly_get_total_used_size(pool_t pool);\n/* Returns how much system memory has been allocated for this pool. */\nsize_t pool_alloconly_get_total_alloc_size(pool_t pool);\n\n/* Returns how much memory has been allocated from this pool. */\nsize_t pool_allocfree_get_total_used_size(pool_t pool);\n/* Returns how much system memory has been allocated for this pool. */\nsize_t pool_allocfree_get_total_alloc_size(pool_t pool);\n\n/* private: */\nvoid pool_system_free(pool_t pool, void *mem);\n\n#endif\n"}, "37": {"id": 37, "path": "/home/runner/work/testcc/testcc/retdec/src/lib/net.h", "content": "#ifndef NET_H\n#define NET_H\n\n#ifndef WIN32\n#  include <sys/socket.h>\n#  include <netinet/in.h>\n#  include <netdb.h>\n#  include <arpa/inet.h>\n#endif\n\n#ifdef HAVE_SOCKS_H\n#include <socks.h>\n#endif\n\n#ifndef AF_INET6\n#  ifdef PF_INET6\n#    define AF_INET6 PF_INET6\n#  else\n#    define AF_INET6 10\n#  endif\n#endif\n\nstruct ip_addr {\n\tunsigned short family;\n\tunion {\n\t\tstruct in6_addr ip6;\n\t\tstruct in_addr ip4;\n\t} u;\n};\nARRAY_DEFINE_TYPE(ip_addr, struct ip_addr);\n\nstruct net_unix_cred {\n\tuid_t uid;\n\tgid_t gid;\n\tpid_t pid;\n};\n\n/* maximum string length of IP address */\n#define MAX_IP_LEN INET6_ADDRSTRLEN\n\n#define IPADDR_IS_V4(ip) ((ip)->family == AF_INET)\n#define IPADDR_IS_V6(ip) ((ip)->family == AF_INET6)\n#define IPADDR_BITS(ip) (IPADDR_IS_V4(ip) ? 32 : 128)\n\nenum net_listen_flags {\n\t/* Try to use SO_REUSEPORT if available. If it's not, this flag is\n\t   cleared on return. */\n\tNET_LISTEN_FLAG_REUSEPORT\t= 0x01\n};\n\nenum net_hosterror_type {\n\t/* Internal error - should be logged as an error */\n\tNET_HOSTERROR_TYPE_INTERNAL_ERROR,\n\t/* Host not found or no valid IP addresses found */\n\tNET_HOSTERROR_TYPE_NOT_FOUND,\n\t/* Nameserver returned an error */\n\tNET_HOSTERROR_TYPE_NAMESERVER,\n};\n\n/* INADDR_ANY for IPv4 or IPv6. The IPv6 any address may\n   include IPv4 depending on the system (Linux yes, BSD no). */\nextern const struct ip_addr net_ip4_any;\nextern const struct ip_addr net_ip6_any;\n\nextern const struct ip_addr net_ip4_loopback;\nextern const struct ip_addr net_ip6_loopback;\n\n/* Returns TRUE if IPs are the same */\nbool net_ip_compare(const struct ip_addr *ip1, const struct ip_addr *ip2);\n/* Returns 0 if IPs are the same, -1 or 1 otherwise. */\nint net_ip_cmp(const struct ip_addr *ip1, const struct ip_addr *ip2);\nunsigned int net_ip_hash(const struct ip_addr *ip);\n\n/* Connect to TCP socket with ip address. The socket and connect() is\n   non-blocking. */\nint net_connect_ip(const struct ip_addr *ip, in_port_t port,\n\t\t   const struct ip_addr *my_ip) ATTR_NULL(3);\n/* Like net_connect_ip(), but do a blocking connect(). */\nint net_connect_ip_blocking(const struct ip_addr *ip, in_port_t port,\n\t\t\t    const struct ip_addr *my_ip) ATTR_NULL(3);\n/* Like net_connect_ip(), but open a UDP socket. */ \nint net_connect_udp(const struct ip_addr *ip, in_port_t port,\n\t\t    const struct ip_addr *my_ip);\n/* Returns 0 if we can bind() as given IP, -1 if not. */\nint net_try_bind(const struct ip_addr *ip);\n/* Connect to named UNIX socket */\nint net_connect_unix(const char *path);\n/* Try to connect to UNIX socket for give number of seconds when connect()\n   returns EAGAIN or ECONNREFUSED. */\nint net_connect_unix_with_retries(const char *path, unsigned int msecs);\n/* Disconnect socket */\nvoid net_disconnect(int fd);\n\n/* Set socket blocking/nonblocking */\nvoid net_set_nonblock(int fd, bool nonblock);\n/* Set TCP_CORK if supported, ie. don't send out partial frames.\n   Returns 0 if ok, -1 if failed. */\nint net_set_cork(int fd, bool cork) ATTR_NOWARN_UNUSED_RESULT;\n/* Set TCP_NODELAY, which disables the Nagle algorithm. */\nint net_set_tcp_nodelay(int fd, bool nodelay);\n/* Set TCP_QUICKACK, which tells the kernel to not delay ACKs. Note that the\n   kernel can (and will) re-enable delayed ACKs while processing the TCP stack.\n   This means that this function needs to be called repeatedly. */\nint net_set_tcp_quickack(int fd, bool quickack);\n\n/* Set socket kernel buffer sizes */\nint net_set_send_buffer_size(int fd, size_t size);\nint net_set_recv_buffer_size(int fd, size_t size);\n\n/* Listen for connections on a socket */\nint net_listen(const struct ip_addr *my_ip, in_port_t *port, int backlog);\nint net_listen_full(const struct ip_addr *my_ip, in_port_t *port,\n\t\t    enum net_listen_flags *flags, int backlog);\n/* Listen for connections on an UNIX socket */\nint net_listen_unix(const char *path, int backlog);\n/* Like net_listen_unix(), but if socket already exists, try to connect to it.\n   If it fails with ECONNREFUSED, unlink the socket and try creating it\n   again. */\nint net_listen_unix_unlink_stale(const char *path, int backlog);\n/* Accept a connection on a socket. Returns -1 if the connection got closed,\n   -2 for other failures. For UNIX sockets addr_r->family=port=0. */\nint net_accept(int fd, struct ip_addr *addr_r, in_port_t *port_r)\n\tATTR_NULL(2, 3);\n\n/* Read data from socket, return number of bytes read,\n   -1 = error, -2 = disconnected */\nssize_t net_receive(int fd, void *buf, size_t len);\n\n/* Get IP addresses for host. ips contains ips_count of IPs, they don't need\n   to be free'd. Returns 0 = ok, others = error code for net_gethosterror() */\nint net_gethostbyname(const char *addr, struct ip_addr **ips,\n\t\t      unsigned int *ips_count);\n/* Return host for the IP address. Returns 0 = ok, others = error code for\n   net_gethosterror(). */\nint net_gethostbyaddr(const struct ip_addr *ip, const char **name_r);\n/* get error of net_gethostname() */\nconst char *net_gethosterror(int error) ATTR_CONST;\n/* Return type of the error returned by net_gethostname() */\nenum net_hosterror_type net_get_hosterror_type(int error);\n/* return TRUE if host lookup failed because it didn't exist (ie. not\n   some error with name server) */\nint net_hosterror_notfound(int error) ATTR_CONST;\n\n/* Get socket local address/port. For UNIX sockets addr->family=port=0. */\nint net_getsockname(int fd, struct ip_addr *addr, in_port_t *port)\n\tATTR_NULL(2, 3);\n/* Get socket remote address/port. For UNIX sockets addr->family=port=0. */\nint net_getpeername(int fd, struct ip_addr *addr, in_port_t *port)\n\tATTR_NULL(2, 3);\n/* Get UNIX socket name. */\nint net_getunixname(int fd, const char **name_r);\n/* Get UNIX socket peer process's credentials. The pid may be (pid_t)-1 if\n   unavailable. */\nint net_getunixcred(int fd, struct net_unix_cred *cred_r);\n\n/* Returns ip_addr as string, or \"\" if ip isn't valid IPv4 or IPv6 address. */\nconst char *net_ip2addr(const struct ip_addr *ip);\n/* char* -> struct ip_addr translation. */\nint net_addr2ip(const char *addr, struct ip_addr *ip);\n/* char* -> in_port_t translation */\nint net_str2port(const char *str, in_port_t *port_r);\n/* char* -> in_port_t translation (allows port zero) */\nint net_str2port_zero(const char *str, in_port_t *port_r);\n/* Parse \"host\", \"host:port\", \"IPv4\", \"IPv4:port\", \"IPv6\", \"[IPv6]\" or\n   \"[IPv6]:port\" to its host and port components. [IPv6] address is returned\n   without []. If no port is given, return default_port. The :port in the\n   parsed string isn't allowed to be zero, but default_port=0 is passed\n   through. */\nint net_str2hostport(const char *str, in_port_t default_port,\n\t\t     const char **host_r, in_port_t *port_r);\n/* Converts ip and port to ipv4:port or [ipv6]:port. Returns -1 if\n   ip is not valid IPv4 or IPv6 address. */\nint net_ipport2str(const struct ip_addr *ip, in_port_t port, const char **str_r);\n\n/* Convert IPv6 mapped IPv4 address to an actual IPv4 address. Returns 0 if\n   successful, -1 if the source address isn't IPv6 mapped IPv4 address. */\nint net_ipv6_mapped_ipv4_convert(const struct ip_addr *src,\n\t\t\t\t struct ip_addr *dest);\n\n/* Get socket error */\nint net_geterror(int fd);\n\n/* Get name of TCP service */\nconst char *net_getservbyport(in_port_t port) ATTR_CONST;\n\nbool is_ipv4_address(const char *addr) ATTR_PURE;\nbool is_ipv6_address(const char *addr) ATTR_PURE;\n\n/* Parse network as ip/bits. Returns 0 if successful, -1 if invalid input. */\nint net_parse_range(const char *network, struct ip_addr *ip_r,\n\t\t    unsigned int *bits_r);\n/* Returns TRUE if ip is in net_ip/bits network. IPv4-mapped IPv6 addresses\n   in \"ip\" parameter are converted to plain IPv4 addresses before matching.\n   No conversion is done to net_ip though, so using IPv4-mapped IPv6 addresses\n   there will always fail. Invalid IPs (family=0) never match anything. */\nbool net_is_in_network(const struct ip_addr *ip, const struct ip_addr *net_ip,\n\t\t       unsigned int bits) ATTR_PURE;\n\n#endif\n"}, "38": {"id": 38, "path": "/home/runner/work/testcc/testcc/retdec/src/lib/randgen.h", "content": "#ifndef RANDGEN_H\n#define RANDGEN_H\n\n/* Fill given buffer with semi-strong randomness */\nvoid random_fill(void *buf, size_t size);\n\n/* may be called multiple times,\n   and are called by default in lib_init */\nvoid random_init(void);\nvoid random_deinit(void);\n\n#ifdef DEBUG\n/* Debug helper to make random tests reproduceable. 0=got seed, -1=failure. */\nint rand_get_last_seed(unsigned int *seed_r);\n#endif\n\n#endif\n"}, "39": {"id": 39, "path": "/home/runner/work/testcc/testcc/retdec/src/lib/seq-range-array.h", "content": "#ifndef SEQ_RANGE_ARRAY_H\n#define SEQ_RANGE_ARRAY_H\n\nstruct seq_range {\n\tuint32_t seq1, seq2;\n};\nARRAY_DEFINE_TYPE(seq_range, struct seq_range);\n\nstruct seq_range_iter {\n\tconst ARRAY_TYPE(seq_range) *array;\n\tunsigned int prev_n, prev_idx;\n};\n\nstatic inline uint32_t ATTR_PURE seq_range_length(struct seq_range *range)\n{\n\ti_assert(range->seq2 >= range->seq1);\n\treturn range->seq2 - range->seq1 + 1;\n}\n\n/* Add sequence to range. If the array isn't created yet, create it with\n   initial size of init_count. */\nbool ATTR_NOWARN_UNUSED_RESULT\nseq_range_array_add(ARRAY_TYPE(seq_range) *array, uint32_t seq);\n/* Like seq_range_array_add(), but if the array isn't already initialized do\n   it with i_array_init(). */\nvoid seq_range_array_add_with_init(ARRAY_TYPE(seq_range) *array,\n\t\t\t\t   unsigned int init_count, uint32_t seq);\nvoid seq_range_array_add_range(ARRAY_TYPE(seq_range) *array,\n\t\t\t       uint32_t seq1, uint32_t seq2);\nunsigned int seq_range_array_add_range_count(ARRAY_TYPE(seq_range) *array,\n\t\t\t\t\t     uint32_t seq1, uint32_t seq2);\nvoid seq_range_array_merge(ARRAY_TYPE(seq_range) *dest,\n\t\t\t   const ARRAY_TYPE(seq_range) *src);\n/* Merge the first n sequences from src into dest. */\nvoid seq_range_array_merge_n(ARRAY_TYPE(seq_range) *dest,\n\t\t\t     const ARRAY_TYPE(seq_range) *src,\n\t\t\t     unsigned int count);\n/* Remove the given sequence from range. Returns TRUE if it was found. */\nbool ATTR_NOWARN_UNUSED_RESULT\nseq_range_array_remove(ARRAY_TYPE(seq_range) *array, uint32_t seq);\n/* Remove a sequence range. Returns number of sequences actually removed. */\nunsigned int ATTR_NOWARN_UNUSED_RESULT\nseq_range_array_remove_range(ARRAY_TYPE(seq_range) *array,\n\t\t\t     uint32_t seq1, uint32_t seq2);\nunsigned int ATTR_NOWARN_UNUSED_RESULT\nseq_range_array_remove_seq_range(ARRAY_TYPE(seq_range) *dest,\n\t\t\t\t const ARRAY_TYPE(seq_range) *src);\n/* Remove count number of sequences from the nth sequence (0 = first). */\nvoid seq_range_array_remove_nth(ARRAY_TYPE(seq_range) *array,\n\t\t\t\tuint32_t n, uint32_t count);\n/* Remove sequences from dest that don't exist in src. */\nunsigned int ATTR_NOWARN_UNUSED_RESULT\nseq_range_array_intersect(ARRAY_TYPE(seq_range) *dest,\n\t\t\t  const ARRAY_TYPE(seq_range) *src);\n/* Returns TRUE if sequence exists in the range. */\nbool seq_range_exists(const ARRAY_TYPE(seq_range) *array,\n\t\t      uint32_t seq) ATTR_PURE;\n/* Returns TRUE if arrays have common sequences. */\nbool seq_range_array_have_common(const ARRAY_TYPE(seq_range) *array1,\n\t\t\t\t const ARRAY_TYPE(seq_range) *array2) ATTR_PURE;\n/* Return number of sequences in the range. */\nunsigned int seq_range_count(const ARRAY_TYPE(seq_range) *array) ATTR_PURE;\n\n/* Invert the sequence range. For example 5:6 -> min_seq:4,7:max_seq.\n   The array must not have any sequences outside min_seq..max_seq or this\n   function will assert-crash. */\nvoid seq_range_array_invert(ARRAY_TYPE(seq_range) *array,\n\t\t\t    uint32_t min_seq, uint32_t max_seq);\n\nvoid seq_range_array_iter_init(struct seq_range_iter *iter_r,\n\t\t\t       const ARRAY_TYPE(seq_range) *array);\n/* Get the nth sequence (0 = first). Returns FALSE if idx is too large. */\nbool seq_range_array_iter_nth(struct seq_range_iter *iter, unsigned int n,\n\t\t\t      uint32_t *seq_r);\n\n#endif\n"}, "40": {"id": 40, "path": "/home/runner/work/testcc/testcc/retdec/src/lib/strfuncs.h", "content": "#ifndef STRFUNC_H\n#define STRFUNC_H\n\n/* Maximum number of bytes needed for the largest uintmax_t or the lowest\n   intmax_t number in base 10. This value includes the trailing \\0. */\n#define MAX_INT_STRLEN ((sizeof(uintmax_t) * CHAR_BIT + 2) / 3 + 1)\n\nextern const unsigned char uchar_nul; /* (const unsigned char *)\"\" */\nextern const unsigned char *uchar_empty_ptr; /* non-NULL pointer that shouldn't be dereferenced. */\n\n/* Returns -1 if dest wasn't large enough, 0 if not. */\nint i_snprintf(char *dest, size_t max_chars, const char *format, ...)\n\tATTR_FORMAT(3, 4);\n\nchar *p_strdup(pool_t pool, const char *str) ATTR_MALLOC;\nvoid *p_memdup(pool_t pool, const void *data, size_t size) ATTR_MALLOC;\n/* return NULL if str = \"\" */\nchar *p_strdup_empty(pool_t pool, const char *str) ATTR_MALLOC;\n/* *end isn't included */\nchar *p_strdup_until(pool_t pool, const void *start, const void *end)\n\tATTR_MALLOC ATTR_RETURNS_NONNULL;\nchar *p_strndup(pool_t pool, const void *str, size_t max_chars) ATTR_MALLOC;\nchar *p_strdup_printf(pool_t pool, const char *format, ...)\n\tATTR_FORMAT(2, 3) ATTR_MALLOC ATTR_RETURNS_NONNULL;\nchar *p_strdup_vprintf(pool_t pool, const char *format, va_list args)\n\tATTR_FORMAT(2, 0) ATTR_MALLOC ATTR_RETURNS_NONNULL;\nchar *p_strconcat(pool_t pool, const char *str1, ...)\n\tATTR_SENTINEL ATTR_MALLOC;\n\n/* same with temporary memory allocations: */\nconst char *t_strdup(const char *str) ATTR_MALLOC;\nchar *t_strdup_noconst(const char *str) ATTR_MALLOC;\n/* return NULL if str = \"\" */\nconst char *t_strdup_empty(const char *str) ATTR_MALLOC;\n/* *end isn't included */\nconst char *t_strdup_until(const void *start, const void *end)\n\tATTR_MALLOC ATTR_RETURNS_NONNULL;\nconst char *t_strndup(const void *str, size_t max_chars) ATTR_MALLOC;\nconst char *t_strdup_printf(const char *format, ...)\n\tATTR_FORMAT(1, 2) ATTR_MALLOC ATTR_RETURNS_NONNULL;\nconst char *t_strdup_vprintf(const char *format, va_list args)\n\tATTR_FORMAT(1, 0) ATTR_MALLOC ATTR_RETURNS_NONNULL;\nconst char *t_strconcat(const char *str1, ...)\n\tATTR_SENTINEL ATTR_MALLOC;\n\n/* Like t_strdup(), but stop at cutchar. */\nconst char *t_strcut(const char *str, char cutchar);\n/* Replace all from->to chars in the string. */\nconst char *t_str_replace(const char *str, char from, char to);\n/* Put the string on a single line by replacing all newlines with spaces and\n   dropping any carriage returns. Sequences of several newlines are merged into\n   one space and newlines at the beginning and end of the string are dropped. */\nconst char *t_str_oneline(const char *str);\n\n/* Like strlcpy(), but return -1 if buffer was overflown, 0 if not. */\nint i_strocpy(char *dest, const char *src, size_t dstsize);\n\nchar *str_ucase(char *str);\nchar *str_lcase(char *str);\nconst char *t_str_lcase(const char *str);\nconst char *t_str_ucase(const char *str);\n\n/* Return pointer to first matching needle */\nconst char *i_strstr_arr(const char *haystack, const char *const *needles);\n\n/* Trim matching chars from either side of the string */\nconst char *t_str_trim(const char *str, const char *chars);\nconst char *p_str_trim(pool_t pool, const char *str, const char *chars);\nconst char *str_ltrim(const char *str, const char *chars);\nconst char *t_str_ltrim(const char *str, const char *chars);\nconst char *p_str_ltrim(pool_t pool, const char *str, const char *chars);\nconst char *t_str_rtrim(const char *str, const char *chars);\nconst char *p_str_rtrim(pool_t pool, const char *str, const char *chars);\n\nint null_strcmp(const char *s1, const char *s2) ATTR_PURE;\nint null_strcasecmp(const char *s1, const char *s2) ATTR_PURE;\nint i_memcasecmp(const void *p1, const void *p2, size_t size) ATTR_PURE;\nint i_strcmp_p(const char *const *p1, const char *const *p2) ATTR_PURE;\nint i_strcasecmp_p(const char *const *p1, const char *const *p2) ATTR_PURE;\n/* Returns TRUE if the two memory areas are equal. This function is safe\n   against timing attacks, so it compares all the bytes every time. */\nbool mem_equals_timing_safe(const void *p1, const void *p2, size_t size);\n/* Returns TRUE if the two strings are equal. Similar to\n   mem_equals_timing_safe() this function is safe against timing attacks when\n   the string lengths are the same. If not, the length of the secret string may\n   be leaked, but otherwise the contents won't be. */\nbool str_equals_timing_almost_safe(const char *s1, const char *s2);\n\nsize_t str_match(const char *p1, const char *p2) ATTR_PURE;\nstatic inline ATTR_PURE bool str_begins(const char *haystack, const char *needle)\n{\n\treturn needle[str_match(haystack, needle)] == '\\0';\n}\n#if defined(__GNUC__) && (__GNUC__ >= 2)\n/* GCC (and Clang) are known to have a compile-time strlen(\"literal\") shortcut, and\n   an optimised strncmp(), so use that by default. Macro is multi-evaluation safe. */\n# define str_begins(h, n) (__builtin_constant_p(n) ? strncmp((h), (n), strlen(n))==0 : (str_begins)((h), (n)))\n#endif\n\nstatic inline char *i_strchr_to_next(const char *str, char chr)\n{\n\tchar *tmp = (char *)strchr(str, chr);\n\treturn tmp == NULL ? NULL : tmp+1;\n}\n\n/* separators is an array of separator characters, not a separator string.\n   an empty data string results in an array containing only NULL. */\nchar **p_strsplit(pool_t pool, const char *data, const char *separators)\n\tATTR_MALLOC ATTR_RETURNS_NONNULL;\nconst char **t_strsplit(const char *data, const char *separators)\n\tATTR_MALLOC ATTR_RETURNS_NONNULL;\n/* like p_strsplit(), but treats multiple adjacent separators as a single\n   separator. separators at the beginning or at the end of the string are also\n   ignored, so it's not possible for the result to have any empty strings. */\nchar **p_strsplit_spaces(pool_t pool, const char *data, const char *separators)\n\tATTR_MALLOC ATTR_RETURNS_NONNULL;\nconst char **t_strsplit_spaces(const char *data, const char *separators)\n\tATTR_MALLOC ATTR_RETURNS_NONNULL;\nvoid p_strsplit_free(pool_t pool, char **arr);\n\nconst char *dec2str(uintmax_t number);\n/* Use the given buffer to write out the number. Returns pointer to the\n   written number in the buffer. Note that this isn't the same as the beginning\n   of the buffer. */\nchar *dec2str_buf(char buffer[STATIC_ARRAY MAX_INT_STRLEN], uintmax_t number);\n\n/* Return length of NULL-terminated list string array */\nunsigned int str_array_length(const char *const *arr) ATTR_PURE;\n/* Return all strings from array joined into one string. */\nconst char *t_strarray_join(const char *const *arr, const char *separator)\n\tATTR_MALLOC ATTR_RETURNS_NONNULL;\n/* Removes a value from NULL-terminated string array. Returns TRUE if found. */\nbool str_array_remove(const char **arr, const char *value);\n/* Returns TRUE if value exists in NULL-terminated string array. */\nbool str_array_find(const char *const *arr, const char *value);\n/* Like str_array_find(), but use strcasecmp(). */\nbool str_array_icase_find(const char *const *arr, const char *value);\n/* Duplicate array of strings. The memory can be freed by freeing the\n   return value. */\nconst char **p_strarray_dup(pool_t pool, const char *const *arr)\n\tATTR_MALLOC ATTR_RETURNS_NONNULL;\n\n/* Join ARRAY_TYPE(const_string) to a string, similar to t_strarray_join() */\nchar *p_array_const_string_join(pool_t pool, const ARRAY_TYPE(const_string) *arr,\n\t\t\t\tconst char *separator);\n#define t_array_const_string_join(arr, separator) \\\n\t((const char *)p_array_const_string_join(unsafe_data_stack_pool, arr, separator))\n\n/* INTERNAL */\nchar *t_noalloc_strdup_vprintf(const char *format, va_list args,\n\t\t\t       unsigned int *size_r)\n\tATTR_FORMAT(1, 0) ATTR_RETURNS_NONNULL;\nchar *vstrconcat(const char *str1, va_list args, size_t *ret_len) ATTR_MALLOC;\n\n#endif\n"}, "41": {"id": 41, "path": "/home/runner/work/testcc/testcc/retdec/src/lib/strnum.h", "content": "#ifndef STRNUM_H\n#define STRNUM_H\n\n/* str_to_*() functions return 0 if string is nothing more than a valid number\n   in valid range. Otherwise -1 is returned and num_r is left untouched\n\n   str_parse_*() helpers do not require the number to be the entire string\n   and pass back the pointer just past a valid parsed integer in endp_r if\n   it is non-NULL. What is written to endp_r in error cases is undefined.\n*/\n\n/*\n * Unsigned decimal\n */\n\nint str_to_uint(const char *str, unsigned int *num_r)\n\tATTR_WARN_UNUSED_RESULT;\nint str_parse_uint(const char *str, unsigned int *num_r,\n\tconst char **endp_r) ATTR_WARN_UNUSED_RESULT ATTR_NULL(3);\n\nint str_to_ulong(const char *str, unsigned long *num_r)\n\tATTR_WARN_UNUSED_RESULT;\nint str_parse_ulong(const char *str, unsigned long *num_r,\n\tconst char **endp_r) ATTR_WARN_UNUSED_RESULT ATTR_NULL(3);\n\nint str_to_ullong(const char *str, unsigned long long *num_r)\n\tATTR_WARN_UNUSED_RESULT;\nint str_parse_ullong(const char *str, unsigned long long *num_r,\n\tconst char **endp_r) ATTR_WARN_UNUSED_RESULT ATTR_NULL(3);\n\nint str_to_uint32(const char *str, uint32_t *num_r)\n\tATTR_WARN_UNUSED_RESULT;\nint str_parse_uint32(const char *str, uint32_t *num_r,\n\tconst char **endp_r) ATTR_WARN_UNUSED_RESULT ATTR_NULL(3);\n\nint str_to_uint64(const char *str, uint64_t *num_r)\n\tATTR_WARN_UNUSED_RESULT;\nint str_parse_uint64(const char *str, uint64_t *num_r,\n\tconst char **endp_r) ATTR_WARN_UNUSED_RESULT ATTR_NULL(3);\n\nint str_to_uintmax(const char *str, uintmax_t *num_r)\n\tATTR_WARN_UNUSED_RESULT;\nint str_parse_uintmax(const char *str, uintmax_t *num_r,\n\tconst char **endp_r) ATTR_WARN_UNUSED_RESULT ATTR_NULL(3);\n\n/* Returns TRUE if str is a valid unsigned number that equals to num. */\nbool str_uint_equals(const char *str, uintmax_t num);\n\n/*\n * Unsigned hexadecimal\n */\n\nint str_to_uint_hex(const char *str, unsigned int *num_r)\n\tATTR_WARN_UNUSED_RESULT;\nint str_parse_uint_hex(const char *str, unsigned int *num_r,\n\tconst char **endp_r) ATTR_WARN_UNUSED_RESULT ATTR_NULL(3);\n\nint str_to_ulong_hex(const char *str, unsigned long *num_r)\n\tATTR_WARN_UNUSED_RESULT;\nint str_parse_ulong_hex(const char *str, unsigned long *num_r,\n\tconst char **endp_r) ATTR_WARN_UNUSED_RESULT ATTR_NULL(3);\n\nint str_to_ullong_hex(const char *str, unsigned long long *num_r)\n\tATTR_WARN_UNUSED_RESULT;\nint str_parse_ullong_hex(const char *str, unsigned long long *num_r,\n\tconst char **endp_r) ATTR_WARN_UNUSED_RESULT ATTR_NULL(3);\n\nint str_to_uint32_hex(const char *str, uint32_t *num_r)\n\tATTR_WARN_UNUSED_RESULT;\nint str_parse_uint32_hex(const char *str, uint32_t *num_r,\n\tconst char **endp_r) ATTR_WARN_UNUSED_RESULT ATTR_NULL(3);\n\nint str_to_uint64_hex(const char *str, uint64_t *num_r)\n\tATTR_WARN_UNUSED_RESULT;\nint str_parse_uint64_hex(const char *str, uint64_t *num_r,\n\tconst char **endp_r) ATTR_WARN_UNUSED_RESULT ATTR_NULL(3);\n\nint str_to_uintmax_hex(const char *str, uintmax_t *num_r)\n\tATTR_WARN_UNUSED_RESULT;\nint str_parse_uintmax_hex(const char *str, uintmax_t *num_r,\n\tconst char **endp_r) ATTR_WARN_UNUSED_RESULT ATTR_NULL(3);\n\n/*\n * Unsigned octal\n */\n\nint str_to_uint_oct(const char *str, unsigned int *num_r)\n\tATTR_WARN_UNUSED_RESULT;\nint str_parse_uint_oct(const char *str, unsigned int *num_r,\n\tconst char **endp_r) ATTR_WARN_UNUSED_RESULT ATTR_NULL(3);\n\nint str_to_ulong_oct(const char *str, unsigned long *num_r)\n\tATTR_WARN_UNUSED_RESULT;\nint str_parse_ulong_oct(const char *str, unsigned long *num_r,\n\tconst char **endp_r) ATTR_WARN_UNUSED_RESULT ATTR_NULL(3);\n\nint str_to_ullong_oct(const char *str, unsigned long long *num_r)\n\tATTR_WARN_UNUSED_RESULT;\nint str_parse_ullong_oct(const char *str, unsigned long long *num_r,\n\tconst char **endp_r) ATTR_WARN_UNUSED_RESULT ATTR_NULL(3);\n\nint str_to_uint32_oct(const char *str, uint32_t *num_r)\n\tATTR_WARN_UNUSED_RESULT;\nint str_parse_uint32_oct(const char *str, uint32_t *num_r,\n\tconst char **endp_r) ATTR_WARN_UNUSED_RESULT ATTR_NULL(3);\n\nint str_to_uint64_oct(const char *str, uint64_t *num_r)\n\tATTR_WARN_UNUSED_RESULT;\nint str_parse_uint64_oct(const char *str, uint64_t *num_r,\n\tconst char **endp_r) ATTR_WARN_UNUSED_RESULT ATTR_NULL(3);\n\nint str_to_uintmax_oct(const char *str, uintmax_t *num_r)\n\tATTR_WARN_UNUSED_RESULT;\nint str_parse_uintmax_oct(const char *str, uintmax_t *num_r,\n\tconst char **endp_r) ATTR_WARN_UNUSED_RESULT ATTR_NULL(3);\n\n/*\n * Signed\n */\n\nint str_to_int(const char *str, int *num_r)\n\tATTR_WARN_UNUSED_RESULT;\nint str_parse_int(const char *str, int *num_r,\n\tconst char **endp_r) ATTR_WARN_UNUSED_RESULT ATTR_NULL(3);\n\nint str_to_long(const char *str, long *num_r)\n\tATTR_WARN_UNUSED_RESULT;\nint str_parse_long(const char *str, long *num_r,\n\tconst char **endp_r) ATTR_WARN_UNUSED_RESULT ATTR_NULL(3);\n\nint str_to_llong(const char *str, long long *num_r)\n\tATTR_WARN_UNUSED_RESULT;\nint str_parse_llong(const char *str, long long *num_r,\n\tconst char **endp_r) ATTR_WARN_UNUSED_RESULT ATTR_NULL(3);\n\nint str_to_int32(const char *str, int32_t *num_r)\n\tATTR_WARN_UNUSED_RESULT;\nint str_parse_int32(const char *str, int32_t *num_r,\n\tconst char **endp_r) ATTR_WARN_UNUSED_RESULT ATTR_NULL(3);\n\nint str_to_int64(const char *str, int64_t *num_r)\n\tATTR_WARN_UNUSED_RESULT;\nint str_parse_int64(const char *str, int64_t *num_r,\n\tconst char **endp_r) ATTR_WARN_UNUSED_RESULT ATTR_NULL(3);\n\nint str_to_intmax(const char *str, intmax_t *num_r)\n\tATTR_WARN_UNUSED_RESULT;\nint str_parse_intmax(const char *str, intmax_t *num_r,\n\tconst char **endp_r) ATTR_WARN_UNUSED_RESULT ATTR_NULL(3);\n\n/*\n * Special numeric types\n */\n\nint str_to_uid(const char *str, uid_t *num_r)\n\tATTR_WARN_UNUSED_RESULT;\n\nint str_to_gid(const char *str, gid_t *num_r)\n\tATTR_WARN_UNUSED_RESULT;\n\nint str_to_pid(const char *str, pid_t *num_r)\n\tATTR_WARN_UNUSED_RESULT;\n\nint str_to_ino(const char *str, ino_t *num_r)\n\tATTR_WARN_UNUSED_RESULT;\n\nint str_to_uoff(const char *str, uoff_t *num_r)\n\tATTR_WARN_UNUSED_RESULT;\nint str_parse_uoff(const char *str, uoff_t *num_r,\n\tconst char **endp_r) ATTR_WARN_UNUSED_RESULT ATTR_NULL(3);\n\nint str_to_time(const char *str, time_t *num_r)\n\tATTR_WARN_UNUSED_RESULT;\n\n/*\n * Utility\n */\n\n/* Return TRUE if all characters in string are numbers.\n   Stop when `end_char' is found from string. */\nbool str_is_numeric(const char *str, char end_char) ATTR_PURE;\n\n/* Return TRUE when string has one or more numbers, followed\n   with zero or one dot, followed with at least one number. */\nbool str_is_float(const char *str, char end_char) ATTR_PURE;\n\n/* Returns human readable string about what is wrong with the string.\n   This function assumes that str_to_*() had already returned -1 for the\n   string. */\nconst char *str_num_error(const char *str);\n\n#endif\n"}, "42": {"id": 42, "path": "/home/runner/work/testcc/testcc/retdec/src/lib/unichar.h", "content": "#ifndef UNICHAR_H\n#define UNICHAR_H\n\n/* Character used to replace invalid input. */\n#define UNICODE_REPLACEMENT_CHAR 0xfffd\n#define UNICODE_REPLACEMENT_CHAR_UTF8 \"\\xEF\\xBF\\xBD\"\n/* Horizontal ellipsis character ('...') */\n#define UNICODE_HORIZONTAL_ELLIPSIS_CHAR 0x2026\n#define UNICODE_HORIZONTAL_ELLIPSIS_CHAR_UTF8 \"\\xE2\\x80\\xA6\"\n\n/* Characters >= base require surrogates */\n#define UTF16_SURROGATE_BASE 0x10000\n\n#define UTF16_SURROGATE_SHIFT 10\n#define UTF16_SURROGATE_MASK 0x03ff\n#define UTF16_SURROGATE_HIGH_FIRST 0xd800\n#define UTF16_SURROGATE_HIGH_LAST 0xdbff\n#define UTF16_SURROGATE_HIGH_MAX 0xdfff\n#define UTF16_SURROGATE_LOW_FIRST 0xdc00\n#define UTF16_SURROGATE_LOW_LAST 0xdfff\n\n#define UTF16_SURROGATE_HIGH(chr) \\\n\t(UTF16_SURROGATE_HIGH_FIRST + \\\n\t (((chr) - UTF16_SURROGATE_BASE) >> UTF16_SURROGATE_SHIFT))\n#define UTF16_SURROGATE_LOW(chr) \\\n\t(UTF16_SURROGATE_LOW_FIRST + \\\n\t (((chr) - UTF16_SURROGATE_BASE) & UTF16_SURROGATE_MASK))\n\n/* Returns TRUE if given byte is ASCII character or the beginning of a\n   multibyte UTF-8 sequence */\n#define UTF8_IS_START_SEQ(b) \\\n\t(((b) & 0x80) == 0 || ((b) & 0xC0) == 0xC0)\n\n#define UTF8_REPLACEMENT_CHAR_LEN 3\n\n#define UNICHAR_T_MAX 0x10ffff\n\n#define UTF16_VALID_HIGH_SURROGATE(chr) (((chr) & 0xfffc00) == UTF16_SURROGATE_HIGH_FIRST)\n#define UTF16_VALID_LOW_SURROGATE(chr) (((chr) & 0xfffc00) == UTF16_SURROGATE_LOW_FIRST)\n\ntypedef uint32_t unichar_t;\nARRAY_DEFINE_TYPE(unichars, unichar_t);\n\n/* Normalize UTF8 input and append it to output buffer.\n   Returns 0 if ok, -1 if input was invalid. Even if input was invalid,\n   as much as possible should be added to output. */\ntypedef int normalizer_func_t(const void *input, size_t size,\n\t\t\t      buffer_t *output);\n\nextern const unsigned char utf8_replacement_char[UTF8_REPLACEMENT_CHAR_LEN];\nextern const uint8_t *const uni_utf8_non1_bytes;\n\nstatic inline bool ATTR_PURE uni_is_valid_ucs4(unichar_t chr)\n{\n\treturn (!UTF16_VALID_HIGH_SURROGATE(chr) &&\n\t\t!UTF16_VALID_LOW_SURROGATE(chr) &&\n\t\tchr <= UNICHAR_T_MAX);\n};\n\n/* Returns number of characters in a NUL-terminated unicode string */\nunsigned int uni_strlen(const unichar_t *str) ATTR_PURE;\n/* Translates UTF-8 input to UCS-4 output. Returns 0 if ok, -1 if input was\n   invalid */\nint uni_utf8_to_ucs4(const char *input, ARRAY_TYPE(unichars) *output);\nint uni_utf8_to_ucs4_n(const unsigned char *input, size_t size,\n\t\t       ARRAY_TYPE(unichars) *output);\n/* Translates UCS-4 input to UTF-8 output. */\nvoid uni_ucs4_to_utf8(const unichar_t *input, size_t len, buffer_t *output);\nvoid uni_ucs4_to_utf8_c(unichar_t chr, buffer_t *output);\n\n/* Returns char_bytes (>0) if *chr_r is set, 0 for incomplete trailing character,\n   -1 for invalid input. */\nint uni_utf8_get_char(const char *input, unichar_t *chr_r);\nint uni_utf8_get_char_n(const void *input, size_t max_len, unichar_t *chr_r);\n/* Returns number of characters in UTF-8 string. */\nunsigned int uni_utf8_strlen(const char *input) ATTR_PURE;\n/* Returns number of characters in UTF-8 input of specified size. */\nunsigned int uni_utf8_strlen_n(const void *input, size_t size) ATTR_PURE;\n/* Same as uni_utf8_strlen_n(), but if input ends with a partial UTF-8\n   character, don't include it in the return value and set partial_pos_r to\n   where the character begins. Otherwise partial_pos_r is set to the end\n   of the input. */\nunsigned int uni_utf8_partial_strlen_n(const void *input, size_t size,\n\t\t\t\t       size_t *partial_pos_r);\n\n/* Returns the number of bytes belonging to this UTF-8 character. The given\n   parameter is the first byte of the UTF-8 sequence. Invalid input is\n   returned with length 1. */\nstatic inline unsigned int ATTR_CONST\nuni_utf8_char_bytes(char chr)\n{\n\t/* 0x00 .. 0x7f are ASCII. 0x80 .. 0xC1 are invalid. */\n\tif ((uint8_t)chr < (192 + 2))\n\t\treturn 1;\n\treturn uni_utf8_non1_bytes[(uint8_t)chr - (192 + 2)];\n}\n\n/* Return given character in titlecase. */\nunichar_t uni_ucs4_to_titlecase(unichar_t chr) ATTR_CONST;\n\n/* Convert UTF-8 input to titlecase and decompose the titlecase characters to\n   output buffer. Returns 0 if ok, -1 if input was invalid. This generates\n   output that's compatible with i;unicode-casemap comparator. Invalid input\n   is replaced with unicode replacement character (0xfffd). */\nint uni_utf8_to_decomposed_titlecase(const void *input, size_t size,\n\t\t\t\t     buffer_t *output);\n\n/* If input contains only valid UTF-8 characters, return TRUE without updating\n   buf. If input contains invalid UTF-8 characters, replace them with unicode\n   replacement character (0xfffd), write the output to buf and return FALSE. */\nbool uni_utf8_get_valid_data(const unsigned char *input, size_t size,\n\t\t\t     buffer_t *buf) ATTR_WARN_UNUSED_RESULT;\n/* Returns TRUE if string is valid UTF-8 input. */\nbool uni_utf8_str_is_valid(const char *str);\n/* Returns TRUE if data contains only valid UTF-8 input. */\nbool uni_utf8_data_is_valid(const unsigned char *data, size_t size);\n/* Returns the size of the data when truncated to be less than or equal to\n   max_new_size, making sure UTF-8 character boundaries are respected. This only\n   looks at the last character at the new boundary. */\nsize_t uni_utf8_data_truncate(const unsigned char *data, size_t old_size,\n\t\t\t      size_t max_new_size);\n\n/* surrogate handling */\nstatic inline unichar_t uni_join_surrogate(unichar_t high, unichar_t low)\n{\n\ti_assert(UTF16_VALID_HIGH_SURROGATE(high) &&\n\t\t UTF16_VALID_LOW_SURROGATE(low));\n\n\treturn ((high - UTF16_SURROGATE_HIGH_FIRST)<<10) +\n\t\t(low - UTF16_SURROGATE_LOW_FIRST) +\n\t\tUTF16_SURROGATE_BASE;\n}\n\nstatic inline void uni_split_surrogate(unichar_t chr, unichar_t *high_r, unichar_t *low_r)\n{\n\ti_assert(chr >= UTF16_SURROGATE_BASE && chr <= UNICHAR_T_MAX);\n\ti_assert(high_r != NULL && low_r != NULL);\n\t*high_r = UTF16_SURROGATE_HIGH(chr);\n\t*low_r = UTF16_SURROGATE_LOW(chr);\n}\n#endif\n"}}, "reports": [{"events": [{"location": {"col": 1, "file": 0, "line": 1}, "message": "header is missing header guard"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/config.h", "reportHash": "562bc09508681098cb0c0aa40f3642db", "checkerName": "llvm-header-guard", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 10, "file": 1, "line": 6}, "message": "\"imap-urlauth-backend.h\" (fixit)"}, {"location": {"col": 1, "file": 1, "line": 6}, "message": "#includes are not sorted properly"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/src/lib-imap-urlauth/imap-urlauth-backend.c", "reportHash": "ad140f53141b552917fcfdce948a0dbe", "checkerName": "llvm-include-order", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 38, "file": 2, "line": 246}, "message": "expanded from macro 'i_zero'"}, {"location": {"col": 2, "file": 1, "line": 39}, "message": "suspicious usage of 'sizeof(A*)'; pointer to aggregate"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/src/lib-imap-urlauth/imap-urlauth-backend.c", "reportHash": "fb40dab32256369242d3eda1e4e97a47", "checkerName": "misc-sizeof-expression", "reviewStatus": null, "severity": "HIGH"}, {"events": [{"location": {"col": 22, "file": 1, "line": 70}, "message": "{ (fixit)"}, {"location": {"col": 14, "file": 1, "line": 70}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/src/lib-imap-urlauth/imap-urlauth-backend.c", "reportHash": "1a16005a966be9600aaa690c21322560", "checkerName": "google-readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 30, "file": 1, "line": 77}, "message": "{ (fixit)"}, {"location": {"col": 15, "file": 1, "line": 77}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/src/lib-imap-urlauth/imap-urlauth-backend.c", "reportHash": "0858552db06ecda1a789680e94aca21e", "checkerName": "google-readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 30, "file": 1, "line": 85}, "message": "{ (fixit)"}, {"location": {"col": 15, "file": 1, "line": 85}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/src/lib-imap-urlauth/imap-urlauth-backend.c", "reportHash": "0bcc765d6ca5b33cff99b361000a05f9", "checkerName": "readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 49, "file": 1, "line": 128}, "message": "{ (fixit)"}, {"location": {"col": 41, "file": 1, "line": 128}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/src/lib-imap-urlauth/imap-urlauth-backend.c", "reportHash": "5365b0c6a3f7535c8097e56ca6e184e3", "checkerName": "google-readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 79, "file": 1, "line": 140}, "message": "{ (fixit)"}, {"location": {"col": 64, "file": 1, "line": 140}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/src/lib-imap-urlauth/imap-urlauth-backend.c", "reportHash": "74322b3036736ce28c5b9e1307f84ec4", "checkerName": "google-readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 3, "file": 3, "line": 13}, "message": "expanded from macro 'MAIL_NAMESPACE_TYPE_MASK_ALL'"}, {"location": {"col": 8, "file": 1, "line": 158}, "message": "use of a signed integer operand with a binary bitwise operator"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/src/lib-imap-urlauth/imap-urlauth-backend.c", "reportHash": "2e177642feea48a6da810d17d0fae629", "checkerName": "hicpp-signed-bitwise", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 8, "file": 1, "line": 159}, "message": "use of a signed integer operand with a binary bitwise operator"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/src/lib-imap-urlauth/imap-urlauth-backend.c", "reportHash": "d4052c75dbe373b8552cbc8e7ef7ceab", "checkerName": "hicpp-signed-bitwise", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 70, "file": 1, "line": 165}, "message": "{ (fixit)"}, {"location": {"col": 55, "file": 1, "line": 165}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/src/lib-imap-urlauth/imap-urlauth-backend.c", "reportHash": "5ff250a11e734bc651d3295caebf233a", "checkerName": "readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 9, "file": 4, "line": 1}, "message": "_HOME_RUNNER_WORK_TESTCC_TESTCC_RETDEC_SRC_LIB_IMAP_URLAUTH_IMAP_URLAUTH_BACKEND_H (fixit)"}, {"location": {"col": 9, "file": 4, "line": 1}, "message": "header guard does not follow preferred style"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/src/lib-imap-urlauth/imap-urlauth-backend.h", "reportHash": "1d5e0e2194825722a5550f586e345dd2", "checkerName": "llvm-header-guard", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 9, "file": 5, "line": 1}, "message": "_HOME_RUNNER_WORK_TESTCC_TESTCC_RETDEC_SRC_LIB_IMAP_URLAUTH_IMAP_URLAUTH_PRIVATE_H (fixit)"}, {"location": {"col": 9, "file": 5, "line": 1}, "message": "header guard does not follow preferred style"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/src/lib-imap-urlauth/imap-urlauth-private.h", "reportHash": "95d709b28bd41976aa7a609269db0606", "checkerName": "llvm-header-guard", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 9, "file": 6, "line": 1}, "message": "_HOME_RUNNER_WORK_TESTCC_TESTCC_RETDEC_SRC_LIB_IMAP_URLAUTH_IMAP_URLAUTH_H (fixit)"}, {"location": {"col": 9, "file": 6, "line": 1}, "message": "header guard does not follow preferred style"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/src/lib-imap-urlauth/imap-urlauth.h", "reportHash": "3746b7e30cfe4df28148287a0a2b2cbe", "checkerName": "llvm-header-guard", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 9, "file": 7, "line": 1}, "message": "_HOME_RUNNER_WORK_TESTCC_TESTCC_RETDEC_SRC_LIB_INDEX_MAIL_INDEX_H (fixit)"}, {"location": {"col": 9, "file": 7, "line": 1}, "message": "header guard does not follow preferred style"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/src/lib-index/mail-index.h", "reportHash": "7fd0e2b3afca1bf60425205a2733a606", "checkerName": "llvm-header-guard", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 17, "file": 8, "line": 7}, "message": "expanded from macro 'BIT'"}, {"location": {"col": 41, "file": 7, "line": 230}, "message": "use of a signed integer operand with a binary bitwise operator"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/src/lib-index/mail-index.h", "reportHash": "d434a1c1fbc26a886aba6addb10c26a7", "checkerName": "hicpp-signed-bitwise", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 17, "file": 8, "line": 7}, "message": "expanded from macro 'BIT'"}, {"location": {"col": 42, "file": 7, "line": 231}, "message": "use of a signed integer operand with a binary bitwise operator"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/src/lib-index/mail-index.h", "reportHash": "1a2cf095a3d34136c087342a0a40477d", "checkerName": "hicpp-signed-bitwise", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 17, "file": 8, "line": 7}, "message": "expanded from macro 'BIT'"}, {"location": {"col": 40, "file": 7, "line": 232}, "message": "use of a signed integer operand with a binary bitwise operator"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/src/lib-index/mail-index.h", "reportHash": "6f4f02057a7b458b7cbd073fe67dbf52", "checkerName": "hicpp-signed-bitwise", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 17, "file": 8, "line": 7}, "message": "expanded from macro 'BIT'"}, {"location": {"col": 43, "file": 7, "line": 233}, "message": "use of a signed integer operand with a binary bitwise operator"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/src/lib-index/mail-index.h", "reportHash": "cbdc19371485d2f25272fbe3c14d76c1", "checkerName": "hicpp-signed-bitwise", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 17, "file": 8, "line": 7}, "message": "expanded from macro 'BIT'"}, {"location": {"col": 41, "file": 7, "line": 234}, "message": "use of a signed integer operand with a binary bitwise operator"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/src/lib-index/mail-index.h", "reportHash": "00f0dff7da94ab63313233fb70965122", "checkerName": "hicpp-signed-bitwise", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 17, "file": 8, "line": 7}, "message": "expanded from macro 'BIT'"}, {"location": {"col": 44, "file": 7, "line": 235}, "message": "use of a signed integer operand with a binary bitwise operator"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/src/lib-index/mail-index.h", "reportHash": "ae7030421efa6952ddce576d56d00b2d", "checkerName": "hicpp-signed-bitwise", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 17, "file": 8, "line": 7}, "message": "expanded from macro 'BIT'"}, {"location": {"col": 41, "file": 7, "line": 237}, "message": "use of a signed integer operand with a binary bitwise operator"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/src/lib-index/mail-index.h", "reportHash": "cfc7d0a2add2bb7772b4404e666f9d3b", "checkerName": "hicpp-signed-bitwise", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 9, "file": 9, "line": 1}, "message": "_HOME_RUNNER_WORK_TESTCC_TESTCC_RETDEC_SRC_LIB_MAIL_MAIL_TYPES_H (fixit)"}, {"location": {"col": 9, "file": 9, "line": 1}, "message": "header guard does not follow preferred style"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/src/lib-mail/mail-types.h", "reportHash": "a7f94df2ce7f4d6d2e9c458183a24f85", "checkerName": "llvm-header-guard", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 26, "file": 9, "line": 13}, "message": "use of a signed integer operand with a binary bitwise operator"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/src/lib-mail/mail-types.h", "reportHash": "786c96aec8faefac3248a337c538c3c3", "checkerName": "hicpp-signed-bitwise", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 9, "file": 10, "line": 1}, "message": "_HOME_RUNNER_WORK_TESTCC_TESTCC_RETDEC_SRC_LIB_STORAGE_MAIL_ERROR_H (fixit)"}, {"location": {"col": 9, "file": 10, "line": 1}, "message": "header guard does not follow preferred style"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/src/lib-storage/mail-error.h", "reportHash": "9022513baedc71f97a25f367f0251f17", "checkerName": "llvm-header-guard", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 9, "file": 3, "line": 1}, "message": "_HOME_RUNNER_WORK_TESTCC_TESTCC_RETDEC_SRC_LIB_STORAGE_MAIL_NAMESPACE_H (fixit)"}, {"location": {"col": 9, "file": 3, "line": 1}, "message": "header guard does not follow preferred style"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/src/lib-storage/mail-namespace.h", "reportHash": "1d0ec61137c525b4d86c2e80c53f50b9", "checkerName": "llvm-header-guard", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 11, "file": 3, "line": 89}, "message": "use of a signed integer operand with a binary bitwise operator"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/src/lib-storage/mail-namespace.h", "reportHash": "bd7c99ff2eff5bc1d8e0937605039bc3", "checkerName": "hicpp-signed-bitwise", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 4, "file": 3, "line": 90}, "message": "use of a signed integer operand with a binary bitwise operator"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/src/lib-storage/mail-namespace.h", "reportHash": "af7af1e8ca339db94ebfc3a6dce8b136", "checkerName": "hicpp-signed-bitwise", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 10, "file": 3, "line": 206}, "message": "use of a signed integer operand with a binary bitwise operator"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/src/lib-storage/mail-namespace.h", "reportHash": "d44410136fd6b26c28fc17a8f7b4157f", "checkerName": "hicpp-signed-bitwise", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 9, "file": 11, "line": 1}, "message": "_HOME_RUNNER_WORK_TESTCC_TESTCC_RETDEC_SRC_LIB_STORAGE_MAIL_STORAGE_SETTINGS_H (fixit)"}, {"location": {"col": 9, "file": 11, "line": 1}, "message": "header guard does not follow preferred style"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/src/lib-storage/mail-storage-settings.h", "reportHash": "50f01de19b54e7b636d57af93aa3cc66", "checkerName": "llvm-header-guard", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 9, "file": 12, "line": 1}, "message": "_HOME_RUNNER_WORK_TESTCC_TESTCC_RETDEC_SRC_LIB_STORAGE_MAIL_STORAGE_H (fixit)"}, {"location": {"col": 9, "file": 12, "line": 1}, "message": "header guard does not follow preferred style"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/src/lib-storage/mail-storage.h", "reportHash": "7c0c23afef61f7c335fdef6aab7fc402", "checkerName": "llvm-header-guard", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 10, "file": 12, "line": 6}, "message": "\"file-lock.h\" (fixit)"}, {"location": {"col": 1, "file": 12, "line": 6}, "message": "#includes are not sorted properly"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/src/lib-storage/mail-storage.h", "reportHash": "f242570dea2ab3f6424ecc95272caa80", "checkerName": "llvm-include-order", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 68, "file": 12, "line": 663}, "message": "() (fixit)"}, {"location": {"col": 61, "file": 12, "line": 663}, "message": "macro argument should be enclosed in parentheses"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/src/lib-storage/mail-storage.h", "reportHash": "a1329d6d4a90a8a3dd8bb96df1f32113", "checkerName": "misc-macro-parentheses", "reviewStatus": null, "severity": "MEDIUM"}, {"events": [{"location": {"col": 34, "file": 12, "line": 664}, "message": "() (fixit)"}, {"location": {"col": 20, "file": 12, "line": 664}, "message": "macro argument should be enclosed in parentheses"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/src/lib-storage/mail-storage.h", "reportHash": "80d95dd92bd5c94327db2016c6e26dc5", "checkerName": "misc-macro-parentheses", "reviewStatus": null, "severity": "MEDIUM"}, {"events": [{"location": {"col": 9, "file": 13, "line": 1}, "message": "_HOME_RUNNER_WORK_TESTCC_TESTCC_RETDEC_SRC_LIB_STORAGE_MAIL_USER_H (fixit)"}, {"location": {"col": 9, "file": 13, "line": 1}, "message": "header guard does not follow preferred style"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/src/lib-storage/mail-user.h", "reportHash": "2e8bc3197e7eb332fe12c50482936d36", "checkerName": "llvm-header-guard", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 10, "file": 13, "line": 4}, "message": "\"mail-storage-settings.h\" (fixit)"}, {"location": {"col": 1, "file": 13, "line": 4}, "message": "#includes are not sorted properly"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/src/lib-storage/mail-user.h", "reportHash": "60d4140e8f5c533c8fec0eba4918045b", "checkerName": "llvm-include-order", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 9, "file": 14, "line": 1}, "message": "_HOME_RUNNER_WORK_TESTCC_TESTCC_RETDEC_SRC_LIB_STORAGE_MAILBOX_ATTRIBUTE_H (fixit)"}, {"location": {"col": 9, "file": 14, "line": 1}, "message": "header guard does not follow preferred style"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/src/lib-storage/mailbox-attribute.h", "reportHash": "40ad1c6a7eece9a9dd53495db31f6788", "checkerName": "llvm-header-guard", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 9, "file": 15, "line": 1}, "message": "_HOME_RUNNER_WORK_TESTCC_TESTCC_RETDEC_SRC_LIB_STORAGE_MAILBOX_LIST_ITER_H (fixit)"}, {"location": {"col": 9, "file": 15, "line": 1}, "message": "header guard does not follow preferred style"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/src/lib-storage/mailbox-list-iter.h", "reportHash": "3c31786210cfdbaf8371c3d352bf8a5d", "checkerName": "llvm-header-guard", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 9, "file": 16, "line": 1}, "message": "_HOME_RUNNER_WORK_TESTCC_TESTCC_RETDEC_SRC_LIB_STORAGE_MAILBOX_LIST_H (fixit)"}, {"location": {"col": 9, "file": 16, "line": 1}, "message": "header guard does not follow preferred style"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/src/lib-storage/mailbox-list.h", "reportHash": "cc9270bce2b95cac4ee2cbc4da3ff4c7", "checkerName": "llvm-header-guard", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 9, "file": 17, "line": 1}, "message": "_HOME_RUNNER_WORK_TESTCC_TESTCC_RETDEC_SRC_LIB_ARRAY_DECL_H (fixit)"}, {"location": {"col": 9, "file": 17, "line": 1}, "message": "header guard does not follow preferred style"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/src/lib/array-decl.h", "reportHash": "4467a78ded624e0bccb814a7290d9a6b", "checkerName": "llvm-header-guard", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 81, "file": 17, "line": 4}, "message": "() (fixit)"}, {"location": {"col": 81, "file": 17, "line": 4}, "message": "macro argument should be enclosed in parentheses"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/src/lib/array-decl.h", "reportHash": "605fd2ad1633ffa5d0c558773dacd428", "checkerName": "misc-macro-parentheses", "reviewStatus": null, "severity": "MEDIUM"}, {"events": [{"location": {"col": 83, "file": 17, "line": 8}, "message": "() (fixit)"}, {"location": {"col": 76, "file": 17, "line": 8}, "message": "macro argument should be enclosed in parentheses"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/src/lib/array-decl.h", "reportHash": "ad631b96de3e3219610a33009395360f", "checkerName": "misc-macro-parentheses", "reviewStatus": null, "severity": "MEDIUM"}, {"events": [{"location": {"col": 9, "file": 8, "line": 1}, "message": "_HOME_RUNNER_WORK_TESTCC_TESTCC_RETDEC_SRC_LIB_BITS_H (fixit)"}, {"location": {"col": 9, "file": 8, "line": 1}, "message": "header guard does not follow preferred style"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/src/lib/bits.h", "reportHash": "699a6d955856fba302e1f8f779a4c642", "checkerName": "llvm-header-guard", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 10, "file": 8, "line": 5}, "message": "() (fixit)"}, {"location": {"col": 3, "file": 8, "line": 5}, "message": "macro argument should be enclosed in parentheses"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/src/lib/bits.h", "reportHash": "e062f46b230d7ea3b75458a498615130", "checkerName": "misc-macro-parentheses", "reviewStatus": null, "severity": "MEDIUM"}, {"events": [{"location": {"col": 29, "file": 8, "line": 5}, "message": "() (fixit)"}, {"location": {"col": 22, "file": 8, "line": 5}, "message": "macro argument should be enclosed in parentheses"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/src/lib/bits.h", "reportHash": "11ec497e01440afefb6f5d908d2a816c", "checkerName": "misc-macro-parentheses", "reviewStatus": null, "severity": "MEDIUM"}, {"events": [{"location": {"col": 35, "file": 8, "line": 124}, "message": "{ (fixit)"}, {"location": {"col": 27, "file": 8, "line": 124}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/src/lib/bits.h", "reportHash": "57470bd768b7266888688fad79dc74e8", "checkerName": "google-readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 27, "file": 8, "line": 137}, "message": "{ (fixit)"}, {"location": {"col": 19, "file": 8, "line": 137}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/src/lib/bits.h", "reportHash": "72d9571808a56c31505e4fe68a955aa8", "checkerName": "readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 28, "file": 8, "line": 139}, "message": "{ (fixit)"}, {"location": {"col": 20, "file": 8, "line": 139}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/src/lib/bits.h", "reportHash": "9c82ff8f32a754caa8c180b3d284a0cf", "checkerName": "hicpp-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 27, "file": 8, "line": 150}, "message": "{ (fixit)"}, {"location": {"col": 19, "file": 8, "line": 150}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/src/lib/bits.h", "reportHash": "26b459ba6004d549745ed4ad4c768da4", "checkerName": "google-readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 28, "file": 8, "line": 152}, "message": "{ (fixit)"}, {"location": {"col": 20, "file": 8, "line": 152}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/src/lib/bits.h", "reportHash": "9fff798b8fe6f973a8daec570413d358", "checkerName": "google-readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 9, "file": 18, "line": 1}, "message": "_HOME_RUNNER_WORK_TESTCC_TESTCC_RETDEC_SRC_LIB_BUFFER_H (fixit)"}, {"location": {"col": 9, "file": 18, "line": 1}, "message": "header guard does not follow preferred style"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/src/lib/buffer.h", "reportHash": "795182b5835cd0e77d52abf09e9197b1", "checkerName": "llvm-header-guard", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 34, "file": 18, "line": 122}, "message": "{ (fixit)"}, {"location": {"col": 26, "file": 18, "line": 122}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/src/lib/buffer.h", "reportHash": "de52ec74eb04a06b8a28c478c8350924", "checkerName": "google-readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 9, "file": 19, "line": 23}, "message": "_HOME_RUNNER_WORK_TESTCC_TESTCC_RETDEC_SRC_LIB_BYTEORDER_H (fixit)"}, {"location": {"col": 9, "file": 19, "line": 23}, "message": "header guard does not follow preferred style"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/src/lib/byteorder.h", "reportHash": "7a5b70cb8155cc5a6f8d67b152d5394c", "checkerName": "llvm-header-guard", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 45, "file": 19, "line": 66}, "message": "x (fixit)"}, {"location": {"col": 1, "file": 19, "line": 259}, "message": "the definition seen here"}, {"location": {"col": 2, "file": 19, "line": 254}, "message": "expanded from macro 'GEN'"}, {"location": {"col": 39, "file": 19, "line": 250}, "message": "expanded from macro '__GEN'"}, {"location": {"col": 30, "file": 19, "line": 242}, "message": "expanded from macro '___GEN'"}, {"location": {"col": 24, "file": 19, "line": 66}, "message": "function 'be64_to_cpu' has a definition with different parameter names"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/src/lib/byteorder.h", "reportHash": "efac8061ced8f7aafdb8dcdec1abff4e", "checkerName": "readability-inconsistent-declaration-parameter-name", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 45, "file": 19, "line": 67}, "message": "x (fixit)"}, {"location": {"col": 1, "file": 19, "line": 260}, "message": "the definition seen here"}, {"location": {"col": 2, "file": 19, "line": 254}, "message": "expanded from macro 'GEN'"}, {"location": {"col": 39, "file": 19, "line": 250}, "message": "expanded from macro '__GEN'"}, {"location": {"col": 30, "file": 19, "line": 242}, "message": "expanded from macro '___GEN'"}, {"location": {"col": 24, "file": 19, "line": 67}, "message": "function 'be32_to_cpu' has a definition with different parameter names"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/src/lib/byteorder.h", "reportHash": "bb3e424e6746c15087badfdbc2567c45", "checkerName": "readability-inconsistent-declaration-parameter-name", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 45, "file": 19, "line": 68}, "message": "x (fixit)"}, {"location": {"col": 1, "file": 19, "line": 261}, "message": "the definition seen here"}, {"location": {"col": 2, "file": 19, "line": 254}, "message": "expanded from macro 'GEN'"}, {"location": {"col": 39, "file": 19, "line": 250}, "message": "expanded from macro '__GEN'"}, {"location": {"col": 30, "file": 19, "line": 242}, "message": "expanded from macro '___GEN'"}, {"location": {"col": 24, "file": 19, "line": 68}, "message": "function 'be16_to_cpu' has a definition with different parameter names"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/src/lib/byteorder.h", "reportHash": "d5a1ca2beac3fb29d6ffeaa4b3aee352", "checkerName": "readability-inconsistent-declaration-parameter-name", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 42, "file": 19, "line": 69}, "message": "x (fixit)"}, {"location": {"col": 1, "file": 19, "line": 262}, "message": "the definition seen here"}, {"location": {"col": 2, "file": 19, "line": 254}, "message": "expanded from macro 'GEN'"}, {"location": {"col": 39, "file": 19, "line": 250}, "message": "expanded from macro '__GEN'"}, {"location": {"col": 30, "file": 19, "line": 242}, "message": "expanded from macro '___GEN'"}, {"location": {"col": 23, "file": 19, "line": 69}, "message": "function 'be8_to_cpu' has a definition with different parameter names"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/src/lib/byteorder.h", "reportHash": "10fd7082f860a01cf7a8a4ebd13f8a11", "checkerName": "readability-inconsistent-declaration-parameter-name", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 45, "file": 19, "line": 72}, "message": "x (fixit)"}, {"location": {"col": 1, "file": 19, "line": 259}, "message": "the definition seen here"}, {"location": {"col": 2, "file": 19, "line": 255}, "message": "expanded from macro 'GEN'"}, {"location": {"col": 39, "file": 19, "line": 250}, "message": "expanded from macro '__GEN'"}, {"location": {"col": 30, "file": 19, "line": 242}, "message": "expanded from macro '___GEN'"}, {"location": {"col": 24, "file": 19, "line": 72}, "message": "function 'cpu64_to_be' has a definition with different parameter names"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/src/lib/byteorder.h", "reportHash": "6610d5dc75d9e632ff933be4cc39f07b", "checkerName": "readability-inconsistent-declaration-parameter-name", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 45, "file": 19, "line": 73}, "message": "x (fixit)"}, {"location": {"col": 1, "file": 19, "line": 260}, "message": "the definition seen here"}, {"location": {"col": 2, "file": 19, "line": 255}, "message": "expanded from macro 'GEN'"}, {"location": {"col": 39, "file": 19, "line": 250}, "message": "expanded from macro '__GEN'"}, {"location": {"col": 30, "file": 19, "line": 242}, "message": "expanded from macro '___GEN'"}, {"location": {"col": 24, "file": 19, "line": 73}, "message": "function 'cpu32_to_be' has a definition with different parameter names"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/src/lib/byteorder.h", "reportHash": "a15b8d14bec238b86c3a8fce61c3c10c", "checkerName": "readability-inconsistent-declaration-parameter-name", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 45, "file": 19, "line": 74}, "message": "x (fixit)"}, {"location": {"col": 1, "file": 19, "line": 261}, "message": "the definition seen here"}, {"location": {"col": 2, "file": 19, "line": 255}, "message": "expanded from macro 'GEN'"}, {"location": {"col": 39, "file": 19, "line": 250}, "message": "expanded from macro '__GEN'"}, {"location": {"col": 30, "file": 19, "line": 242}, "message": "expanded from macro '___GEN'"}, {"location": {"col": 24, "file": 19, "line": 74}, "message": "function 'cpu16_to_be' has a definition with different parameter names"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/src/lib/byteorder.h", "reportHash": "2df796bb1981183cadbac9e84c46152b", "checkerName": "readability-inconsistent-declaration-parameter-name", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 42, "file": 19, "line": 75}, "message": "x (fixit)"}, {"location": {"col": 1, "file": 19, "line": 262}, "message": "the definition seen here"}, {"location": {"col": 2, "file": 19, "line": 255}, "message": "expanded from macro 'GEN'"}, {"location": {"col": 39, "file": 19, "line": 250}, "message": "expanded from macro '__GEN'"}, {"location": {"col": 30, "file": 19, "line": 242}, "message": "expanded from macro '___GEN'"}, {"location": {"col": 23, "file": 19, "line": 75}, "message": "function 'cpu8_to_be' has a definition with different parameter names"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/src/lib/byteorder.h", "reportHash": "afb05a7dcb56c3ee5410eb9528b5aac1", "checkerName": "readability-inconsistent-declaration-parameter-name", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 45, "file": 19, "line": 78}, "message": "x (fixit)"}, {"location": {"col": 1, "file": 19, "line": 259}, "message": "the definition seen here"}, {"location": {"col": 2, "file": 19, "line": 256}, "message": "expanded from macro 'GEN'"}, {"location": {"col": 39, "file": 19, "line": 250}, "message": "expanded from macro '__GEN'"}, {"location": {"col": 30, "file": 19, "line": 242}, "message": "expanded from macro '___GEN'"}, {"location": {"col": 24, "file": 19, "line": 78}, "message": "function 'le64_to_cpu' has a definition with different parameter names"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/src/lib/byteorder.h", "reportHash": "500af05672cd3454990a340b25bbdd5a", "checkerName": "readability-inconsistent-declaration-parameter-name", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 45, "file": 19, "line": 79}, "message": "x (fixit)"}, {"location": {"col": 1, "file": 19, "line": 260}, "message": "the definition seen here"}, {"location": {"col": 2, "file": 19, "line": 256}, "message": "expanded from macro 'GEN'"}, {"location": {"col": 39, "file": 19, "line": 250}, "message": "expanded from macro '__GEN'"}, {"location": {"col": 30, "file": 19, "line": 242}, "message": "expanded from macro '___GEN'"}, {"location": {"col": 24, "file": 19, "line": 79}, "message": "function 'le32_to_cpu' has a definition with different parameter names"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/src/lib/byteorder.h", "reportHash": "d8bbd11d295b44d23bca9073b372eaa9", "checkerName": "readability-inconsistent-declaration-parameter-name", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 45, "file": 19, "line": 80}, "message": "x (fixit)"}, {"location": {"col": 1, "file": 19, "line": 261}, "message": "the definition seen here"}, {"location": {"col": 2, "file": 19, "line": 256}, "message": "expanded from macro 'GEN'"}, {"location": {"col": 39, "file": 19, "line": 250}, "message": "expanded from macro '__GEN'"}, {"location": {"col": 30, "file": 19, "line": 242}, "message": "expanded from macro '___GEN'"}, {"location": {"col": 24, "file": 19, "line": 80}, "message": "function 'le16_to_cpu' has a definition with different parameter names"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/src/lib/byteorder.h", "reportHash": "fcbbd80f81cf976b4a043bee6818157a", "checkerName": "readability-inconsistent-declaration-parameter-name", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 42, "file": 19, "line": 81}, "message": "x (fixit)"}, {"location": {"col": 1, "file": 19, "line": 262}, "message": "the definition seen here"}, {"location": {"col": 2, "file": 19, "line": 256}, "message": "expanded from macro 'GEN'"}, {"location": {"col": 39, "file": 19, "line": 250}, "message": "expanded from macro '__GEN'"}, {"location": {"col": 30, "file": 19, "line": 242}, "message": "expanded from macro '___GEN'"}, {"location": {"col": 23, "file": 19, "line": 81}, "message": "function 'le8_to_cpu' has a definition with different parameter names"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/src/lib/byteorder.h", "reportHash": "9153333ac764d9d792912422e97ee33b", "checkerName": "readability-inconsistent-declaration-parameter-name", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 45, "file": 19, "line": 84}, "message": "x (fixit)"}, {"location": {"col": 1, "file": 19, "line": 259}, "message": "the definition seen here"}, {"location": {"col": 2, "file": 19, "line": 257}, "message": "expanded from macro 'GEN'"}, {"location": {"col": 39, "file": 19, "line": 250}, "message": "expanded from macro '__GEN'"}, {"location": {"col": 30, "file": 19, "line": 242}, "message": "expanded from macro '___GEN'"}, {"location": {"col": 24, "file": 19, "line": 84}, "message": "function 'cpu64_to_le' has a definition with different parameter names"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/src/lib/byteorder.h", "reportHash": "bc8cb5e7a41c9c001cd5205d1d02ad70", "checkerName": "readability-inconsistent-declaration-parameter-name", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 45, "file": 19, "line": 85}, "message": "x (fixit)"}, {"location": {"col": 1, "file": 19, "line": 260}, "message": "the definition seen here"}, {"location": {"col": 2, "file": 19, "line": 257}, "message": "expanded from macro 'GEN'"}, {"location": {"col": 39, "file": 19, "line": 250}, "message": "expanded from macro '__GEN'"}, {"location": {"col": 30, "file": 19, "line": 242}, "message": "expanded from macro '___GEN'"}, {"location": {"col": 24, "file": 19, "line": 85}, "message": "function 'cpu32_to_le' has a definition with different parameter names"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/src/lib/byteorder.h", "reportHash": "f67c40b0c0b2efb73e2b9d34c94b630c", "checkerName": "readability-inconsistent-declaration-parameter-name", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 45, "file": 19, "line": 86}, "message": "x (fixit)"}, {"location": {"col": 1, "file": 19, "line": 261}, "message": "the definition seen here"}, {"location": {"col": 2, "file": 19, "line": 257}, "message": "expanded from macro 'GEN'"}, {"location": {"col": 39, "file": 19, "line": 250}, "message": "expanded from macro '__GEN'"}, {"location": {"col": 30, "file": 19, "line": 242}, "message": "expanded from macro '___GEN'"}, {"location": {"col": 24, "file": 19, "line": 86}, "message": "function 'cpu16_to_le' has a definition with different parameter names"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/src/lib/byteorder.h", "reportHash": "d67653c7a128df32ccba9756438f34c1", "checkerName": "readability-inconsistent-declaration-parameter-name", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 42, "file": 19, "line": 87}, "message": "x (fixit)"}, {"location": {"col": 1, "file": 19, "line": 262}, "message": "the definition seen here"}, {"location": {"col": 2, "file": 19, "line": 257}, "message": "expanded from macro 'GEN'"}, {"location": {"col": 39, "file": 19, "line": 250}, "message": "expanded from macro '__GEN'"}, {"location": {"col": 30, "file": 19, "line": 242}, "message": "expanded from macro '___GEN'"}, {"location": {"col": 23, "file": 19, "line": 87}, "message": "function 'cpu8_to_le' has a definition with different parameter names"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/src/lib/byteorder.h", "reportHash": "e1939d639dd3eff51283066d8717b341", "checkerName": "readability-inconsistent-declaration-parameter-name", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 10, "file": 19, "line": 94}, "message": "use of a signed integer operand with a binary bitwise operator"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/src/lib/byteorder.h", "reportHash": "e6f1c96b894e55e15699a70881b185ac", "checkerName": "hicpp-signed-bitwise", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 10, "file": 19, "line": 95}, "message": "use of a signed integer operand with a binary bitwise operator"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/src/lib/byteorder.h", "reportHash": "f850598094c16c1e2166b88b54e7aa03", "checkerName": "hicpp-signed-bitwise", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 10, "file": 19, "line": 96}, "message": "use of a signed integer operand with a binary bitwise operator"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/src/lib/byteorder.h", "reportHash": "db5e50c464843c5323f37da30381c10a", "checkerName": "hicpp-signed-bitwise", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 10, "file": 19, "line": 97}, "message": "use of a signed integer operand with a binary bitwise operator"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/src/lib/byteorder.h", "reportHash": "32ca44037999e10bbc506fab12b490a1", "checkerName": "hicpp-signed-bitwise", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 10, "file": 19, "line": 98}, "message": "use of a signed integer operand with a binary bitwise operator"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/src/lib/byteorder.h", "reportHash": "43aeb24db93af7ffafe35fa915ed2ba5", "checkerName": "hicpp-signed-bitwise", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 10, "file": 19, "line": 99}, "message": "use of a signed integer operand with a binary bitwise operator"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/src/lib/byteorder.h", "reportHash": "70801f343487f8b380bd01ea17ea9a22", "checkerName": "hicpp-signed-bitwise", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 10, "file": 19, "line": 100}, "message": "use of a signed integer operand with a binary bitwise operator"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/src/lib/byteorder.h", "reportHash": "df1fee67040390739d3cfd6c1b0dc604", "checkerName": "hicpp-signed-bitwise", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 10, "file": 19, "line": 101}, "message": "use of a signed integer operand with a binary bitwise operator"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/src/lib/byteorder.h", "reportHash": "9987dc3858b67b52bc3f56443e6017bb", "checkerName": "hicpp-signed-bitwise", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 10, "file": 19, "line": 106}, "message": "use of a signed integer operand with a binary bitwise operator"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/src/lib/byteorder.h", "reportHash": "609254a252bcc6446d4686f426df1de5", "checkerName": "hicpp-signed-bitwise", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 10, "file": 19, "line": 107}, "message": "use of a signed integer operand with a binary bitwise operator"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/src/lib/byteorder.h", "reportHash": "f99f92936bd0070a5ceaf89e9c17ef4e", "checkerName": "hicpp-signed-bitwise", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 11, "file": 19, "line": 107}, "message": "use of a signed integer operand with a binary bitwise operator"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/src/lib/byteorder.h", "reportHash": "2250f6421fe46437bbf7bb5ad1863c6a", "checkerName": "hicpp-signed-bitwise", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 10, "file": 19, "line": 108}, "message": "use of a signed integer operand with a binary bitwise operator"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/src/lib/byteorder.h", "reportHash": "38b94833c25798df6ebe2da81e3b1632", "checkerName": "hicpp-signed-bitwise", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 11, "file": 19, "line": 108}, "message": "use of a signed integer operand with a binary bitwise operator"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/src/lib/byteorder.h", "reportHash": "e93bf689e80f76a8a6273f80fd4e2f12", "checkerName": "hicpp-signed-bitwise", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 10, "file": 19, "line": 109}, "message": "use of a signed integer operand with a binary bitwise operator"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/src/lib/byteorder.h", "reportHash": "fdb53ce0707461fbf7188c7caa4b5b74", "checkerName": "hicpp-signed-bitwise", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 11, "file": 19, "line": 109}, "message": "use of a signed integer operand with a binary bitwise operator"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/src/lib/byteorder.h", "reportHash": "a3359c4b2e5ea2664b130e1a145b1b54", "checkerName": "hicpp-signed-bitwise", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 9, "file": 19, "line": 114}, "message": "use of a signed integer operand with a binary bitwise operator"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/src/lib/byteorder.h", "reportHash": "a2f9e8670ee448d77f744ee6056a73d1", "checkerName": "hicpp-signed-bitwise", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 10, "file": 19, "line": 114}, "message": "use of a signed integer operand with a binary bitwise operator"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/src/lib/byteorder.h", "reportHash": "b943a4a06db0ab4d2b6bc85277665be1", "checkerName": "hicpp-signed-bitwise", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 11, "file": 19, "line": 114}, "message": "use of a signed integer operand with a binary bitwise operator"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/src/lib/byteorder.h", "reportHash": "9ba9907d621be0725492ebdfaf837cfc", "checkerName": "hicpp-signed-bitwise", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 10, "file": 19, "line": 115}, "message": "use of a signed integer operand with a binary bitwise operator"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/src/lib/byteorder.h", "reportHash": "0e013521076f7696d2a860ff4c580b70", "checkerName": "hicpp-signed-bitwise", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 11, "file": 19, "line": 115}, "message": "use of a signed integer operand with a binary bitwise operator"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/src/lib/byteorder.h", "reportHash": "0d57b1bc07ead1b9229a65578e46225c", "checkerName": "hicpp-signed-bitwise", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 10, "file": 19, "line": 120}, "message": "use of a signed integer operand with a binary bitwise operator"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/src/lib/byteorder.h", "reportHash": "360cf1c47399072ccb3d98f4ca8116ef", "checkerName": "hicpp-signed-bitwise", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 11, "file": 19, "line": 130}, "message": "use of a signed integer operand with a binary bitwise operator"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/src/lib/byteorder.h", "reportHash": "00298319e51bffeb00ce618549625dc3", "checkerName": "hicpp-signed-bitwise", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 4, "file": 19, "line": 131}, "message": "use of a signed integer operand with a binary bitwise operator"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/src/lib/byteorder.h", "reportHash": "2ca566a1c1a791ab72cfb525cbd0b5a8", "checkerName": "hicpp-signed-bitwise", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 4, "file": 19, "line": 132}, "message": "use of a signed integer operand with a binary bitwise operator"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/src/lib/byteorder.h", "reportHash": "87eb8c71b724724b9fc59055efdfde4e", "checkerName": "hicpp-signed-bitwise", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 4, "file": 19, "line": 133}, "message": "use of a signed integer operand with a binary bitwise operator"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/src/lib/byteorder.h", "reportHash": "a4c61c0ebb9ea0e4b43335af14980cfa", "checkerName": "hicpp-signed-bitwise", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 4, "file": 19, "line": 134}, "message": "use of a signed integer operand with a binary bitwise operator"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/src/lib/byteorder.h", "reportHash": "d9a70234c6ff3340abe7f69e8a8a24bf", "checkerName": "hicpp-signed-bitwise", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 4, "file": 19, "line": 135}, "message": "use of a signed integer operand with a binary bitwise operator"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/src/lib/byteorder.h", "reportHash": "cc6b34e1bbc614ac1ab0afb5fbdab307", "checkerName": "hicpp-signed-bitwise", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 4, "file": 19, "line": 136}, "message": "use of a signed integer operand with a binary bitwise operator"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/src/lib/byteorder.h", "reportHash": "282a3b2a5f342a6cc96cd358948a095b", "checkerName": "hicpp-signed-bitwise", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 9, "file": 19, "line": 144}, "message": "use of a signed integer operand with a binary bitwise operator"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/src/lib/byteorder.h", "reportHash": "fbb12e26d30b24937777cad8ebed7bc4", "checkerName": "hicpp-signed-bitwise", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 10, "file": 19, "line": 144}, "message": "use of a signed integer operand with a binary bitwise operator"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/src/lib/byteorder.h", "reportHash": "08f8c9d6369064bfd263d80181f25106", "checkerName": "hicpp-signed-bitwise", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 9, "file": 19, "line": 145}, "message": "use of a signed integer operand with a binary bitwise operator"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/src/lib/byteorder.h", "reportHash": "b63c5111434d175e19e4341f08c685ec", "checkerName": "hicpp-signed-bitwise", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 10, "file": 19, "line": 145}, "message": "use of a signed integer operand with a binary bitwise operator"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/src/lib/byteorder.h", "reportHash": "3d3291da47f0695031d008e57d4bfa88", "checkerName": "hicpp-signed-bitwise", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 9, "file": 19, "line": 146}, "message": "use of a signed integer operand with a binary bitwise operator"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/src/lib/byteorder.h", "reportHash": "e806689189ed16e74eeb47a833b07bf3", "checkerName": "hicpp-signed-bitwise", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 10, "file": 19, "line": 146}, "message": "use of a signed integer operand with a binary bitwise operator"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/src/lib/byteorder.h", "reportHash": "3ff2df53b9a1afc3e5ac042b5b53a215", "checkerName": "hicpp-signed-bitwise", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 9, "file": 19, "line": 147}, "message": "use of a signed integer operand with a binary bitwise operator"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/src/lib/byteorder.h", "reportHash": "2af071988f02bf73a494cb930cb6b35a", "checkerName": "hicpp-signed-bitwise", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 10, "file": 19, "line": 147}, "message": "use of a signed integer operand with a binary bitwise operator"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/src/lib/byteorder.h", "reportHash": "c962886c31eb02cff5d2a66104e8093b", "checkerName": "hicpp-signed-bitwise", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 9, "file": 19, "line": 148}, "message": "use of a signed integer operand with a binary bitwise operator"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/src/lib/byteorder.h", "reportHash": "a65e26c570168dff02aee9c3a453e4cf", "checkerName": "hicpp-signed-bitwise", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 10, "file": 19, "line": 148}, "message": "use of a signed integer operand with a binary bitwise operator"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/src/lib/byteorder.h", "reportHash": "d86064c3ff16926915af670f55b620e7", "checkerName": "hicpp-signed-bitwise", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 9, "file": 19, "line": 149}, "message": "use of a signed integer operand with a binary bitwise operator"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/src/lib/byteorder.h", "reportHash": "6ce8695ae3e59295fa8b1485b1043030", "checkerName": "hicpp-signed-bitwise", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 10, "file": 19, "line": 149}, "message": "use of a signed integer operand with a binary bitwise operator"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/src/lib/byteorder.h", "reportHash": "ea7f77494c7b26d183c10a1a10560b77", "checkerName": "hicpp-signed-bitwise", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 9, "file": 19, "line": 150}, "message": "use of a signed integer operand with a binary bitwise operator"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/src/lib/byteorder.h", "reportHash": "0791a5ce61c99bfd8ebb28c828bb6c8a", "checkerName": "hicpp-signed-bitwise", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 10, "file": 19, "line": 150}, "message": "use of a signed integer operand with a binary bitwise operator"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/src/lib/byteorder.h", "reportHash": "3c144f85203cbc5fd3605c671189ba62", "checkerName": "hicpp-signed-bitwise", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 9, "file": 19, "line": 151}, "message": "use of a signed integer operand with a binary bitwise operator"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/src/lib/byteorder.h", "reportHash": "f1d1b1312f891d1c96b2daa103463d11", "checkerName": "hicpp-signed-bitwise", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 11, "file": 19, "line": 158}, "message": "use of a signed integer operand with a binary bitwise operator"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/src/lib/byteorder.h", "reportHash": "56df2f70449c1ea2a50cf95ab59f10a1", "checkerName": "hicpp-signed-bitwise", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 4, "file": 19, "line": 159}, "message": "use of a signed integer operand with a binary bitwise operator"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/src/lib/byteorder.h", "reportHash": "a4013dad66931f3e085253731adff0e0", "checkerName": "hicpp-signed-bitwise", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 4, "file": 19, "line": 160}, "message": "use of a signed integer operand with a binary bitwise operator"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/src/lib/byteorder.h", "reportHash": "89cfa133724d11e86d036c30facc2267", "checkerName": "hicpp-signed-bitwise", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 9, "file": 19, "line": 168}, "message": "use of a signed integer operand with a binary bitwise operator"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/src/lib/byteorder.h", "reportHash": "32d244e7dd6d71cb4ca6d1b47ffb7d7b", "checkerName": "hicpp-signed-bitwise", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 10, "file": 19, "line": 168}, "message": "use of a signed integer operand with a binary bitwise operator"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/src/lib/byteorder.h", "reportHash": "350b670bf40c276ba61acabea46a63f1", "checkerName": "hicpp-signed-bitwise", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 9, "file": 19, "line": 169}, "message": "use of a signed integer operand with a binary bitwise operator"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/src/lib/byteorder.h", "reportHash": "a22e0ba776476f1e9cee935a022ba60e", "checkerName": "hicpp-signed-bitwise", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 10, "file": 19, "line": 169}, "message": "use of a signed integer operand with a binary bitwise operator"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/src/lib/byteorder.h", "reportHash": "a26c1ed8358735573f13789752235d7f", "checkerName": "hicpp-signed-bitwise", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 9, "file": 19, "line": 170}, "message": "use of a signed integer operand with a binary bitwise operator"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/src/lib/byteorder.h", "reportHash": "1b9a296def4d5bacd5ab991c2e778aff", "checkerName": "hicpp-signed-bitwise", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 10, "file": 19, "line": 170}, "message": "use of a signed integer operand with a binary bitwise operator"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/src/lib/byteorder.h", "reportHash": "0c37310e7597e504ca1bff93c07a3169", "checkerName": "hicpp-signed-bitwise", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 9, "file": 19, "line": 171}, "message": "use of a signed integer operand with a binary bitwise operator"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/src/lib/byteorder.h", "reportHash": "072b0c0bc3c504704993f44b8ba55069", "checkerName": "hicpp-signed-bitwise", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 10, "file": 19, "line": 178}, "message": "use of a signed integer operand with a binary bitwise operator"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/src/lib/byteorder.h", "reportHash": "affcbbe089dfd9f860fd8c73f3516bc2", "checkerName": "hicpp-signed-bitwise", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 11, "file": 19, "line": 178}, "message": "use of a signed integer operand with a binary bitwise operator"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/src/lib/byteorder.h", "reportHash": "24edcef8c0721084e77f2ac6d664c167", "checkerName": "hicpp-signed-bitwise", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 9, "file": 19, "line": 186}, "message": "use of a signed integer operand with a binary bitwise operator"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/src/lib/byteorder.h", "reportHash": "dadd486f3c9d4615f76564f60641aa70", "checkerName": "hicpp-signed-bitwise", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 10, "file": 19, "line": 186}, "message": "use of a signed integer operand with a binary bitwise operator"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/src/lib/byteorder.h", "reportHash": "844cd29788ba84d55bd47a31c0ed3bff", "checkerName": "hicpp-signed-bitwise", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 9, "file": 19, "line": 187}, "message": "use of a signed integer operand with a binary bitwise operator"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/src/lib/byteorder.h", "reportHash": "9fb965bf9606009e222db3eb9428da26", "checkerName": "hicpp-signed-bitwise", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 9, "file": 20, "line": 1}, "message": "_HOME_RUNNER_WORK_TESTCC_TESTCC_RETDEC_SRC_LIB_COMPAT_H (fixit)"}, {"location": {"col": 9, "file": 20, "line": 1}, "message": "header guard does not follow preferred style"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/src/lib/compat.h", "reportHash": "5345ac4cf0369227f3f216c6ae78d8a4", "checkerName": "llvm-header-guard", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 12, "file": 21, "line": 453}, "message": "previously declared here"}, {"location": {"col": 5, "file": 20, "line": 47}, "message": "redundant 'rand' declaration"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/src/lib/compat.h", "reportHash": "8f0ec306c2e858f6bb74584c52eb381a", "checkerName": "readability-redundant-declaration", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 12, "file": 21, "line": 459}, "message": "previously declared here"}, {"location": {"col": 5, "file": 20, "line": 48}, "message": "redundant 'rand_r' declaration"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/src/lib/compat.h", "reportHash": "3a79bafca76e2fa5cc174b3f16df9f52", "checkerName": "readability-redundant-declaration", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 16, "file": 22, "line": 379}, "message": "the 1st inconsistent declaration seen here"}, {"location": {"col": 19, "file": 20, "line": 207}, "message": "expanded from macro 'pread'"}, {"location": {"col": 16, "file": 22, "line": 379}, "message": "differing parameters are named here: ('__fd', '__buf', '__nbytes', '__offset'), in the other declaration: ('fd', 'buf', 'count', 'offset')"}, {"location": {"col": 19, "file": 20, "line": 207}, "message": "expanded from macro 'pread'"}, {"location": {"col": 9, "file": 20, "line": 210}, "message": "function 'i_my_pread' has 1 other declaration with different parameter names"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/src/lib/compat.h", "reportHash": "c5c9ad8ece60680442502b86e4999896", "checkerName": "readability-inconsistent-declaration-parameter-name", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 16, "file": 22, "line": 387}, "message": "the 1st inconsistent declaration seen here"}, {"location": {"col": 20, "file": 20, "line": 208}, "message": "expanded from macro 'pwrite'"}, {"location": {"col": 16, "file": 22, "line": 387}, "message": "differing parameters are named here: ('__fd', '__buf', '__n', '__offset'), in the other declaration: ('fd', 'buf', 'count', 'offset')"}, {"location": {"col": 20, "file": 20, "line": 208}, "message": "expanded from macro 'pwrite'"}, {"location": {"col": 9, "file": 20, "line": 211}, "message": "function 'i_my_pwrite' has 1 other declaration with different parameter names"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/src/lib/compat.h", "reportHash": "5677040e84a4a1631255c42855c9f6f6", "checkerName": "readability-inconsistent-declaration-parameter-name", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 9, "file": 23, "line": 1}, "message": "_HOME_RUNNER_WORK_TESTCC_TESTCC_RETDEC_SRC_LIB_DATA_STACK_H (fixit)"}, {"location": {"col": 9, "file": 23, "line": 1}, "message": "header guard does not follow preferred style"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/src/lib/data-stack.h", "reportHash": "2af644d600b91bde37acc4825777407c", "checkerName": "llvm-header-guard", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 9, "file": 24, "line": 1}, "message": "_HOME_RUNNER_WORK_TESTCC_TESTCC_RETDEC_SRC_LIB_EVENT_LOG_H (fixit)"}, {"location": {"col": 9, "file": 24, "line": 1}, "message": "header guard does not follow preferred style"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/src/lib/event-log.h", "reportHash": "470ebf2e08bb62d68b78afee6f252124", "checkerName": "llvm-header-guard", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 9, "file": 25, "line": 1}, "message": "_HOME_RUNNER_WORK_TESTCC_TESTCC_RETDEC_SRC_LIB_FAILURES_H (fixit)"}, {"location": {"col": 9, "file": 25, "line": 1}, "message": "header guard does not follow preferred style"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/src/lib/failures.h", "reportHash": "1cdf2fbab194eea0fc3338de66f0bfa6", "checkerName": "llvm-header-guard", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 36, "file": 25, "line": 116}, "message": "parameter 'callback' is const-qualified in the function declaration; const-qualification of parameters only has an effect in function definitions"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/src/lib/failures.h", "reportHash": "c635b1052826da3612688486027f530f", "checkerName": "readability-avoid-const-params-in-decls", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 9, "file": 26, "line": 1}, "message": "_HOME_RUNNER_WORK_TESTCC_TESTCC_RETDEC_SRC_LIB_FD_UTIL_H (fixit)"}, {"location": {"col": 9, "file": 26, "line": 1}, "message": "header guard does not follow preferred style"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/src/lib/fd-util.h", "reportHash": "f46d4ce1c7320e78c926a74c73e174d9", "checkerName": "llvm-header-guard", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 9, "file": 27, "line": 1}, "message": "_HOME_RUNNER_WORK_TESTCC_TESTCC_RETDEC_SRC_LIB_FILE_LOCK_H (fixit)"}, {"location": {"col": 9, "file": 27, "line": 1}, "message": "header guard does not follow preferred style"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/src/lib/file-lock.h", "reportHash": "01e7c4fec8e6f91940a1bdcb44400cc5", "checkerName": "llvm-header-guard", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 10, "file": 27, "line": 4}, "message": "<fcntl.h> (fixit)"}, {"location": {"col": 1, "file": 27, "line": 4}, "message": "#includes are not sorted properly"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/src/lib/file-lock.h", "reportHash": "63689e9658b5f519c1a49e8cde63ea9b", "checkerName": "llvm-include-order", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 9, "file": 28, "line": 1}, "message": "_HOME_RUNNER_WORK_TESTCC_TESTCC_RETDEC_SRC_LIB_FSYNC_MODE_H (fixit)"}, {"location": {"col": 9, "file": 28, "line": 1}, "message": "header guard does not follow preferred style"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/src/lib/fsync-mode.h", "reportHash": "33f14d1754c41d6d28e1bb250de8c9f9", "checkerName": "llvm-header-guard", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 9, "file": 29, "line": 1}, "message": "_HOME_RUNNER_WORK_TESTCC_TESTCC_RETDEC_SRC_LIB_GUID_H (fixit)"}, {"location": {"col": 9, "file": 29, "line": 1}, "message": "header guard does not follow preferred style"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/src/lib/guid.h", "reportHash": "6e7f52d07ac22541932e876ac64bf0d8", "checkerName": "llvm-header-guard", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 9, "file": 30, "line": 1}, "message": "_HOME_RUNNER_WORK_TESTCC_TESTCC_RETDEC_SRC_LIB_HASH_DECL_H (fixit)"}, {"location": {"col": 9, "file": 30, "line": 1}, "message": "header guard does not follow preferred style"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/src/lib/hash-decl.h", "reportHash": "23f3c3376f9b14b9e9db42685f7d270b", "checkerName": "llvm-header-guard", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 17, "file": 30, "line": 7}, "message": "() (fixit)"}, {"location": {"col": 3, "file": 30, "line": 7}, "message": "macro argument should be enclosed in parentheses"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/src/lib/hash-decl.h", "reportHash": "fbd613a690c78cac5282884730ad6941", "checkerName": "misc-macro-parentheses", "reviewStatus": null, "severity": "MEDIUM"}, {"events": [{"location": {"col": 17, "file": 30, "line": 10}, "message": "() (fixit)"}, {"location": {"col": 3, "file": 30, "line": 10}, "message": "macro argument should be enclosed in parentheses"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/src/lib/hash-decl.h", "reportHash": "a4f3c94d8e57352a284d1338832e79df", "checkerName": "misc-macro-parentheses", "reviewStatus": null, "severity": "MEDIUM"}, {"events": [{"location": {"col": 9, "file": 31, "line": 1}, "message": "_HOME_RUNNER_WORK_TESTCC_TESTCC_RETDEC_SRC_LIB_HEX_BINARY_H (fixit)"}, {"location": {"col": 9, "file": 31, "line": 1}, "message": "header guard does not follow preferred style"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/src/lib/hex-binary.h", "reportHash": "70013558c70d6742964b3c6fffcd4779", "checkerName": "llvm-header-guard", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 9, "file": 32, "line": 1}, "message": "_HOME_RUNNER_WORK_TESTCC_TESTCC_RETDEC_SRC_LIB_IMEM_H (fixit)"}, {"location": {"col": 9, "file": 32, "line": 1}, "message": "header guard does not follow preferred style"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/src/lib/imem.h", "reportHash": "047beae7712fa48d93f541d12a9af7ea", "checkerName": "llvm-header-guard", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 9, "file": 33, "line": 1}, "message": "_HOME_RUNNER_WORK_TESTCC_TESTCC_RETDEC_SRC_LIB_LIB_EVENT_H (fixit)"}, {"location": {"col": 9, "file": 33, "line": 1}, "message": "header guard does not follow preferred style"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/src/lib/lib-event.h", "reportHash": "e5752ec77b4e02f62b6ef4e43848ec57", "checkerName": "llvm-header-guard", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 47, "file": 33, "line": 209}, "message": "() (fixit)"}, {"location": {"col": 33, "file": 33, "line": 209}, "message": "macro argument should be enclosed in parentheses"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/src/lib/lib-event.h", "reportHash": "3fdc33dfb1c9fbb83b315341db267c64", "checkerName": "misc-macro-parentheses", "reviewStatus": null, "severity": "MEDIUM"}, {"events": [{"location": {"col": 64, "file": 33, "line": 209}, "message": "() (fixit)"}, {"location": {"col": 50, "file": 33, "line": 209}, "message": "macro argument should be enclosed in parentheses"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/src/lib/lib-event.h", "reportHash": "85135aa8641dd292315f1010ba319812", "checkerName": "misc-macro-parentheses", "reviewStatus": null, "severity": "MEDIUM"}, {"events": [{"location": {"col": 48, "file": 33, "line": 218}, "message": "() (fixit)"}, {"location": {"col": 34, "file": 33, "line": 218}, "message": "macro argument should be enclosed in parentheses"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/src/lib/lib-event.h", "reportHash": "6e04bd5ba0f1919796e283112da08a59", "checkerName": "misc-macro-parentheses", "reviewStatus": null, "severity": "MEDIUM"}, {"events": [{"location": {"col": 65, "file": 33, "line": 218}, "message": "() (fixit)"}, {"location": {"col": 51, "file": 33, "line": 218}, "message": "macro argument should be enclosed in parentheses"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/src/lib/lib-event.h", "reportHash": "7874e3801bc6ad80420e646d1a386d68", "checkerName": "misc-macro-parentheses", "reviewStatus": null, "severity": "MEDIUM"}, {"events": [{"location": {"col": 9, "file": 34, "line": 1}, "message": "_HOME_RUNNER_WORK_TESTCC_TESTCC_RETDEC_SRC_LIB_LIB_H (fixit)"}, {"location": {"col": 9, "file": 34, "line": 1}, "message": "header guard does not follow preferred style"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/src/lib/lib.h", "reportHash": "668f8e0631abd0883b9e52af91c0bdbd", "checkerName": "llvm-header-guard", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 10, "file": 34, "line": 16}, "message": "<errno.h> /* error checking is good */ (fixit)"}, {"location": {"col": 1, "file": 34, "line": 16}, "message": "#includes are not sorted properly"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/src/lib/lib.h", "reportHash": "395a4d2a5c5bbae4246da09bc0b483b3", "checkerName": "llvm-include-order", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 10, "file": 34, "line": 27}, "message": "\"failures.h\" (fixit)"}, {"location": {"col": 1, "file": 34, "line": 27}, "message": "#includes are not sorted properly"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/src/lib/lib.h", "reportHash": "de39a5f8ae00defcbe2acebf48b6ef36", "checkerName": "llvm-include-order", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 10, "file": 34, "line": 30}, "message": "\"byteorder.h\" (fixit)"}, {"location": {"col": 1, "file": 34, "line": 30}, "message": "#includes are not sorted properly"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/src/lib/lib.h", "reportHash": "790d0a8df7c3ba0aa5cc0e6a2f0a42de", "checkerName": "llvm-include-order", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 10, "file": 34, "line": 47}, "message": "\"event-log.h\" (fixit)"}, {"location": {"col": 1, "file": 34, "line": 47}, "message": "#includes are not sorted properly"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/src/lib/lib.h", "reportHash": "efb3c1b0443da3dfe369ebd813719c9d", "checkerName": "llvm-include-order", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 34, "file": 34, "line": 52}, "message": "(  ) (fixit)"}, {"location": {"col": 34, "file": 34, "line": 52}, "message": "macro replacement list should be enclosed in parentheses"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/src/lib/lib.h", "reportHash": "0badabeaeb3032460ff758f1e161e1af", "checkerName": "misc-macro-parentheses", "reviewStatus": null, "severity": "MEDIUM"}, {"events": [{"location": {"col": 9, "file": 2, "line": 1}, "message": "_HOME_RUNNER_WORK_TESTCC_TESTCC_RETDEC_SRC_LIB_MACROS_H (fixit)"}, {"location": {"col": 9, "file": 2, "line": 1}, "message": "header guard does not follow preferred style"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/src/lib/macros.h", "reportHash": "65711be3588bc07fbab954721d30ed94", "checkerName": "llvm-header-guard", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 25, "file": 2, "line": 163}, "message": "() (fixit)"}, {"location": {"col": 11, "file": 2, "line": 163}, "message": "macro argument should be enclosed in parentheses"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/src/lib/macros.h", "reportHash": "c68612e73f83c24309e2b0762f34527a", "checkerName": "misc-macro-parentheses", "reviewStatus": null, "severity": "MEDIUM"}, {"events": [{"location": {"col": 9, "file": 35, "line": 1}, "message": "_HOME_RUNNER_WORK_TESTCC_TESTCC_RETDEC_SRC_LIB_MALLOC_OVERFLOW_H (fixit)"}, {"location": {"col": 9, "file": 35, "line": 1}, "message": "header guard does not follow preferred style"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/src/lib/malloc-overflow.h", "reportHash": "f9837ba0fd3062af3f92c9d99f41dd0c", "checkerName": "llvm-header-guard", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 9, "file": 36, "line": 1}, "message": "_HOME_RUNNER_WORK_TESTCC_TESTCC_RETDEC_SRC_LIB_MEMPOOL_H (fixit)"}, {"location": {"col": 9, "file": 36, "line": 1}, "message": "header guard does not follow preferred style"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/src/lib/mempool.h", "reportHash": "3f48db8b66a8c11009bca668f06d6186", "checkerName": "llvm-header-guard", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 64, "file": 36, "line": 104}, "message": "{ (fixit)"}, {"location": {"col": 56, "file": 36, "line": 104}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/src/lib/mempool.h", "reportHash": "102f394771be5e939b8752174e4f5864", "checkerName": "google-readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 72, "file": 36, "line": 113}, "message": "{ (fixit)"}, {"location": {"col": 64, "file": 36, "line": 113}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/src/lib/mempool.h", "reportHash": "b34b89e890fe958145741e55cf90131b", "checkerName": "google-readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 26, "file": 36, "line": 117}, "message": "{ (fixit)"}, {"location": {"col": 18, "file": 36, "line": 117}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/src/lib/mempool.h", "reportHash": "35d2a639d5c93609ace2e00fd7c36a9d", "checkerName": "google-readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 26, "file": 36, "line": 134}, "message": "{ (fixit)"}, {"location": {"col": 18, "file": 36, "line": 134}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/src/lib/mempool.h", "reportHash": "73ccd3ed31f823432dc752b3451c14c2", "checkerName": "google-readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 28, "file": 36, "line": 160}, "message": "{ (fixit)"}, {"location": {"col": 20, "file": 36, "line": 160}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/src/lib/mempool.h", "reportHash": "394e6c575b0454265205c1617b6a21e0", "checkerName": "readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 9, "file": 37, "line": 1}, "message": "_HOME_RUNNER_WORK_TESTCC_TESTCC_RETDEC_SRC_LIB_NET_H (fixit)"}, {"location": {"col": 9, "file": 37, "line": 1}, "message": "header guard does not follow preferred style"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/src/lib/net.h", "reportHash": "e646e89d5ca6774e50c7bf82f6019e8a", "checkerName": "llvm-header-guard", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 12, "file": 37, "line": 5}, "message": "<arpa/inet.h> (fixit)"}, {"location": {"col": 1, "file": 37, "line": 5}, "message": "#includes are not sorted properly"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/src/lib/net.h", "reportHash": "5f786333199bbc454a393785bf233c87", "checkerName": "llvm-include-order", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 9, "file": 38, "line": 1}, "message": "_HOME_RUNNER_WORK_TESTCC_TESTCC_RETDEC_SRC_LIB_RANDGEN_H (fixit)"}, {"location": {"col": 9, "file": 38, "line": 1}, "message": "header guard does not follow preferred style"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/src/lib/randgen.h", "reportHash": "31865ebe46ab39349dfe4b3a42db9b21", "checkerName": "llvm-header-guard", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 9, "file": 39, "line": 1}, "message": "_HOME_RUNNER_WORK_TESTCC_TESTCC_RETDEC_SRC_LIB_SEQ_RANGE_ARRAY_H (fixit)"}, {"location": {"col": 9, "file": 39, "line": 1}, "message": "header guard does not follow preferred style"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/src/lib/seq-range-array.h", "reportHash": "e9dd6a274c808d09156d51895e34f5df", "checkerName": "llvm-header-guard", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 9, "file": 40, "line": 1}, "message": "_HOME_RUNNER_WORK_TESTCC_TESTCC_RETDEC_SRC_LIB_STRFUNCS_H (fixit)"}, {"location": {"col": 9, "file": 40, "line": 1}, "message": "header guard does not follow preferred style"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/src/lib/strfuncs.h", "reportHash": "65e3c8522598dcead28a7482f5fbf407", "checkerName": "llvm-header-guard", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 14, "file": 40, "line": 102}, "message": "redundant cast to the same type"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/src/lib/strfuncs.h", "reportHash": "50855db3f0c52806834ea48f16c78f97", "checkerName": "google-readability-casting", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 9, "file": 41, "line": 1}, "message": "_HOME_RUNNER_WORK_TESTCC_TESTCC_RETDEC_SRC_LIB_STRNUM_H (fixit)"}, {"location": {"col": 9, "file": 41, "line": 1}, "message": "header guard does not follow preferred style"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/src/lib/strnum.h", "reportHash": "c2f2fcf18b96a90d3f81b81c173754d0", "checkerName": "llvm-header-guard", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 9, "file": 42, "line": 1}, "message": "_HOME_RUNNER_WORK_TESTCC_TESTCC_RETDEC_SRC_LIB_UNICHAR_H (fixit)"}, {"location": {"col": 9, "file": 42, "line": 1}, "message": "header guard does not follow preferred style"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/src/lib/unichar.h", "reportHash": "7ebd1d6e3dd3ed3954640c309c3e738f", "checkerName": "llvm-header-guard", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 43, "file": 42, "line": 38}, "message": "expanded from macro 'UTF16_VALID_HIGH_SURROGATE'"}, {"location": {"col": 11, "file": 42, "line": 55}, "message": "use of a signed integer operand with a binary bitwise operator"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/src/lib/unichar.h", "reportHash": "3351549596c00e0c97c855ddcc6f93ae", "checkerName": "hicpp-signed-bitwise", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 42, "file": 42, "line": 39}, "message": "expanded from macro 'UTF16_VALID_LOW_SURROGATE'"}, {"location": {"col": 4, "file": 42, "line": 56}, "message": "use of a signed integer operand with a binary bitwise operator"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/src/lib/unichar.h", "reportHash": "d852b4a69a0c6140f31684f024c769e0", "checkerName": "hicpp-signed-bitwise", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 39, "file": 42, "line": 93}, "message": "{ (fixit)"}, {"location": {"col": 31, "file": 42, "line": 93}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/src/lib/unichar.h", "reportHash": "a1bf917bb7f8c135ac3b26615cadf991", "checkerName": "readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 43, "file": 42, "line": 38}, "message": "expanded from macro 'UTF16_VALID_HIGH_SURROGATE'"}, {"location": {"col": 21, "file": 2, "line": 208}, "message": "expanded from macro 'i_assert'"}, {"location": {"col": 45, "file": 2, "line": 189}, "message": "expanded from macro 'unlikely'"}, {"location": {"col": 11, "file": 42, "line": 126}, "message": "use of a signed integer operand with a binary bitwise operator"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/src/lib/unichar.h", "reportHash": "3433504fd55529f2c08618b16c561c47", "checkerName": "hicpp-signed-bitwise", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 42, "file": 42, "line": 39}, "message": "expanded from macro 'UTF16_VALID_LOW_SURROGATE'"}, {"location": {"col": 21, "file": 2, "line": 208}, "message": "expanded from macro 'i_assert'"}, {"location": {"col": 45, "file": 2, "line": 189}, "message": "expanded from macro 'unlikely'"}, {"location": {"col": 4, "file": 42, "line": 127}, "message": "use of a signed integer operand with a binary bitwise operator"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/src/lib/unichar.h", "reportHash": "fe995eeadd19dce98cebfdb9e0283450", "checkerName": "hicpp-signed-bitwise", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 10, "file": 42, "line": 129}, "message": "use of a signed integer operand with a binary bitwise operator"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/src/lib/unichar.h", "reportHash": "7c96967e527e5742c5f70f716400e5b3", "checkerName": "hicpp-signed-bitwise", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 4, "file": 42, "line": 24}, "message": "expanded from macro 'UTF16_SURROGATE_HIGH'"}, {"location": {"col": 12, "file": 42, "line": 138}, "message": "use of a signed integer operand with a binary bitwise operator"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/src/lib/unichar.h", "reportHash": "2d4f94901ebb89d7cc3a64a84448b64e", "checkerName": "hicpp-signed-bitwise", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 4, "file": 42, "line": 27}, "message": "expanded from macro 'UTF16_SURROGATE_LOW'"}, {"location": {"col": 11, "file": 42, "line": 139}, "message": "use of a signed integer operand with a binary bitwise operator"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/src/lib/unichar.h", "reportHash": "350b72167be25da86812b3351f23e399", "checkerName": "hicpp-signed-bitwise", "reviewStatus": null, "severity": "LOW"}]};
      window.onload = function() {
        if (!browserCompatible) {
          setNonCompatibleBrowserMessage();
        } else {
          BugViewer.init(data.files, data.reports);
          BugViewer.create();
          BugViewer.initByUrl();
        }
      };
    </script>
  </head>
  <body>
  <div class="container">
    <div id="content">
      <div id="side-bar">
        <div class="header">
          <a href="index.html" class="button">&#8249; Return to List</a>
        </div>
        <div id="report-nav">
          <div class="header">Reports</div>
        </div>
      </div>
      <div id="editor-wrapper">
        <div class="header">
          <div id="file">
            <span class="label">File:</span>
            <span id="file-path"></span>
          </div>
          <div id="checker">
            <span class="label">Checker name:</span>
            <span id="checker-name"></span>
          </div>
          <div id="review-status-wrapper">
            <span class="label">Review status:</span>
            <span id="review-status"></span>
          </div>
        </div>
        <div id="editor"></div>
      </div>
    </div>
  </div>
  </body>
</html>
