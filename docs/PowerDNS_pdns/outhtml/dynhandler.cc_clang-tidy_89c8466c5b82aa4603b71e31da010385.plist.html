<!DOCTYPE html>
<html>
  <head>
    <title>Plist HTML Viewer</title>

    <meta charset="UTF-8">

    <style type="text/css">
      .CodeMirror{font-family:monospace;height:300px;color:#000;direction:ltr}.CodeMirror-lines{padding:4px 0}.CodeMirror pre{padding:0 4px}.CodeMirror-gutter-filler,.CodeMirror-scrollbar-filler{background-color:#fff}.CodeMirror-gutters{border-right:1px solid #ddd;background-color:#f7f7f7;white-space:nowrap}.CodeMirror-linenumber{padding:0 3px 0 5px;min-width:20px;text-align:right;color:#999;white-space:nowrap}.CodeMirror-guttermarker{color:#000}.CodeMirror-guttermarker-subtle{color:#999}.CodeMirror-cursor{border-left:1px solid #000;border-right:none;width:0}.CodeMirror div.CodeMirror-secondarycursor{border-left:1px solid silver}.cm-fat-cursor .CodeMirror-cursor{width:auto;border:0!important;background:#7e7}.cm-fat-cursor div.CodeMirror-cursors{z-index:1}.cm-animate-fat-cursor{width:auto;border:0;-webkit-animation:blink 1.06s steps(1) infinite;-moz-animation:blink 1.06s steps(1) infinite;animation:blink 1.06s steps(1) infinite;background-color:#7e7}@-moz-keyframes blink{50%{background-color:transparent}}@-webkit-keyframes blink{50%{background-color:transparent}}@keyframes blink{50%{background-color:transparent}}.cm-tab{display:inline-block;text-decoration:inherit}.CodeMirror-rulers{position:absolute;left:0;right:0;top:-50px;bottom:-20px;overflow:hidden}.CodeMirror-ruler{border-left:1px solid #ccc;top:0;bottom:0;position:absolute}.cm-s-default .cm-header{color:#00f}.cm-s-default .cm-quote{color:#090}.cm-negative{color:#d44}.cm-positive{color:#292}.cm-header,.cm-strong{font-weight:700}.cm-em{font-style:italic}.cm-link{text-decoration:underline}.cm-strikethrough{text-decoration:line-through}.cm-s-default .cm-keyword{color:#708}.cm-s-default .cm-atom{color:#219}.cm-s-default .cm-number{color:#164}.cm-s-default .cm-def{color:#00f}.cm-s-default .cm-variable-2{color:#05a}.cm-s-default .cm-type,.cm-s-default .cm-variable-3{color:#085}.cm-s-default .cm-comment{color:#a50}.cm-s-default .cm-string{color:#a11}.cm-s-default .cm-string-2{color:#f50}.cm-s-default .cm-meta{color:#555}.cm-s-default .cm-qualifier{color:#555}.cm-s-default .cm-builtin{color:#30a}.cm-s-default .cm-bracket{color:#997}.cm-s-default .cm-tag{color:#170}.cm-s-default .cm-attribute{color:#00c}.cm-s-default .cm-hr{color:#999}.cm-s-default .cm-link{color:#00c}.cm-s-default .cm-error{color:red}.cm-invalidchar{color:red}.CodeMirror-composing{border-bottom:2px solid}div.CodeMirror span.CodeMirror-matchingbracket{color:#0f0}div.CodeMirror span.CodeMirror-nonmatchingbracket{color:#f22}.CodeMirror-matchingtag{background:rgba(255,150,0,.3)}.CodeMirror-activeline-background{background:#e8f2ff}.CodeMirror{position:relative;overflow:hidden;background:#fff}.CodeMirror-scroll{overflow:scroll!important;margin-bottom:-30px;margin-right:-30px;padding-bottom:30px;height:100%;outline:0;position:relative}.CodeMirror-sizer{position:relative;border-right:30px solid transparent}.CodeMirror-gutter-filler,.CodeMirror-hscrollbar,.CodeMirror-scrollbar-filler,.CodeMirror-vscrollbar{position:absolute;z-index:6;display:none}.CodeMirror-vscrollbar{right:0;top:0;overflow-x:hidden;overflow-y:scroll}.CodeMirror-hscrollbar{bottom:0;left:0;overflow-y:hidden;overflow-x:scroll}.CodeMirror-scrollbar-filler{right:0;bottom:0}.CodeMirror-gutter-filler{left:0;bottom:0}.CodeMirror-gutters{position:absolute;left:0;top:0;min-height:100%;z-index:3}.CodeMirror-gutter{white-space:normal;height:100%;display:inline-block;vertical-align:top;margin-bottom:-30px}.CodeMirror-gutter-wrapper{position:absolute;z-index:4;background:0 0!important;border:none!important}.CodeMirror-gutter-background{position:absolute;top:0;bottom:0;z-index:4}.CodeMirror-gutter-elt{position:absolute;cursor:default;z-index:4}.CodeMirror-gutter-wrapper ::selection{background-color:transparent}.CodeMirror-gutter-wrapper ::-moz-selection{background-color:transparent}.CodeMirror-lines{cursor:text;min-height:1px}.CodeMirror pre{-moz-border-radius:0;-webkit-border-radius:0;border-radius:0;border-width:0;background:0 0;font-family:inherit;font-size:inherit;margin:0;white-space:pre;word-wrap:normal;line-height:inherit;color:inherit;z-index:2;position:relative;overflow:visible;-webkit-tap-highlight-color:transparent;-webkit-font-variant-ligatures:contextual;font-variant-ligatures:contextual}.CodeMirror-wrap pre{word-wrap:break-word;white-space:pre-wrap;word-break:normal}.CodeMirror-linebackground{position:absolute;left:0;right:0;top:0;bottom:0;z-index:0}.CodeMirror-linewidget{position:relative;z-index:2;overflow:auto}.CodeMirror-rtl pre{direction:rtl}.CodeMirror-code{outline:0}.CodeMirror-gutter,.CodeMirror-gutters,.CodeMirror-linenumber,.CodeMirror-scroll,.CodeMirror-sizer{-moz-box-sizing:content-box;box-sizing:content-box}.CodeMirror-measure{position:absolute;width:100%;height:0;overflow:hidden;visibility:hidden}.CodeMirror-cursor{position:absolute;pointer-events:none}.CodeMirror-measure pre{position:static}div.CodeMirror-cursors{visibility:hidden;position:relative;z-index:3}div.CodeMirror-dragcursors{visibility:visible}.CodeMirror-focused div.CodeMirror-cursors{visibility:visible}.CodeMirror-selected{background:#d9d9d9}.CodeMirror-focused .CodeMirror-selected{background:#d7d4f0}.CodeMirror-crosshair{cursor:crosshair}.CodeMirror-line::selection,.CodeMirror-line>span::selection,.CodeMirror-line>span>span::selection{background:#d7d4f0}.CodeMirror-line::-moz-selection,.CodeMirror-line>span::-moz-selection,.CodeMirror-line>span>span::-moz-selection{background:#d7d4f0}.cm-searching{background-color:#ffa;background-color:rgba(255,255,0,.4)}.cm-force-border{padding-right:.1px}@media print{.CodeMirror div.CodeMirror-cursors{visibility:hidden}}.cm-tab-wrap-hack:after{content:''}span.CodeMirror-selectedtext{background:0 0}
/*# sourceMappingURL=codemirror.min.css.map */

      .severity-low {
  background-color: #669603;
}

.severity-low:after {
  content : 'L';
}

.severity-unspecified {
  background-color: #666666;
}

.severity-unspecified:after {
  content : 'U';
}

.severity-style {
  background-color: #9932cc;
}

.severity-style:after {
  content : 'S';
}

.severity-medium {
  background-color: #a9d323;
  color: black;
}

.severity-medium:after {
  content : 'M';
}

.severity-high {
  background-color: #ffa800;
}

.severity-high:after {
  content : 'H';
}

.severity-critical {
  background-color: #e92625;
}

.severity-critical:after {
  content : 'C';
}

i[class*="severity-"] {
  line-height: normal;
  text-transform: capitalize;
  font-size: 0.8em;
  font-weight: bold;
  color: white;
  display: inline-block;
  width: 16px;
  height: 16px;
  text-align: center;
  font-family: sans-serif;
}

      html, body {
  width: 100%;
  height: 100%;
  padding: 0px;
  margin: 0px;
}

div.container {
  padding: 10px;
}

#content {
  height: 100%;
  display: block;
  overflow: hidden;
}

#content > div {
  margin: 10px;
  overflow: hidden;
  border: 1px solid #ddd;
  border-radius: 3px;
  overflow: hidden;
  height: 97%;
}

.button {
  background-color: #f1f1f1;
  text-decoration: none;
  display: inline-block;
  padding: 8px 16px;
  color: black;
  cursor: pointer;
}

.button:hover {
  background-color: #ddd;
  color: black;
}

.review-status {
  color: white;
  text-align: center;
}

.review-status-confirmed {
  background-color: #e92625;
}

.review-status-false-positive {
  background-color: grey;
}

.review-status-intentional {
  background-color: #669603;
}

      div.container {
  width: 100%;
  height: 100%;
  padding: 0px;
}

#editor-wrapper {
  margin: 10px;
}

#side-bar {
  float: left;
  width: 260px;
  margin: 0px;
}

#report-nav ul {
  list-style-type: none;
  padding: 0;
  margin: 0;
  overflow-y: auto;
  height: 100%;
}

#report-nav ul > li {
  padding: .4em;
  background-color: #fff;
  border-bottom: 1px solid rgba(0,0,0,.125);
  text-align: left;
  overflow: hidden;
  white-space: nowrap;
  text-overflow: ellipsis;
}

#report-nav ul > li.active {
  background-color: #427ea9;
  color: white;
}

#report-nav ul > li:hover {
  background-color: #427ea9;
  color: white;
  cursor: pointer;
}

#report-nav ul a {
  text-decoration: none;
}

#report-nav i[class*="severity-"] {
  margin-right: 5px;
}

.header {
  border-bottom: 1px solid lightgrey;
  font-family: monospace;
  padding: 10px;
  background-color: #fafbfc;
  border-bottom: 1px solid #e1e4e8;
  border-top-left-radius: 2px;
  border-top-right-radius: 2px;
}

#report-nav .header {
  font-weight: bold;
}

#editor-wrapper .header > div {
  padding-top: 2px;
}

#file-path,
#checker-name {
  color: #195ea2;
}

#review-status {
  padding: 0px 5px;
}

#file-path {
  font-family: monospace;
}

.check-msg {
  display: inline-block;
  padding: 3px 6px;
  margin: 1px;
  -webkit-border-radius: 5px;
  -moz-border-radius: 5px;
  border-radius: 5px;
}

.check-msg.info {
  color: #00546f;
  background-color: #bfdfe9;
  border: 1px solid #87a8b3;
}

.check-msg.error {
  background-color: #f2dede;
  color: #a94442;
  border: 1px solid #ebcccc;
}

.check-msg.macro {
  background-color: #d7dac2;
  color: #4f5c6d;
  border: 1px solid #d7dac2;
}

.check-msg.note {
  background-color: #d7d7d7;
  color: #4f5c6d;
  border: 1px solid #bfbfbf;
}

.check-msg.current {
  border: 2px dashed #3692ff;
}

.check-msg .tag {
  padding: 1px 5px;
  text-align: center;
  border-radius: 2px;
  margin-right: 5px;
  text-decoration: inherit;
}

.check-msg .tag.macro {
  background-color: #83876a;
  color: white;
  text-transform: capitalize;
}

.check-msg .tag.note {
  background-color: #9299a1;
  color: white;
  text-transform: capitalize;
}

.checker-enum {
  color: white;
  padding: 1px 5px;
  text-align: center;
  border-radius: 25px;
  margin-right: 5px;
  text-decoration: inherit;
}

.checker-enum.info {
  background-color: #427ea9;
}

.checker-enum.error {
  background-color: #a94442;
}

.arrow {
  border: solid black;
  border-width: 0 3px 3px 0;
  display: inline-block;
  padding: 3px;
  cursor: pointer;
  margin: 0px 5px;
}

.arrow:hover {
  border: solid #437ea8;
  border-width: 0 3px 3px 0;
}

.left-arrow {
  transform: rotate(135deg);
  -webkit-transform: rotate(135deg);
}

.right-arrow {
  transform: rotate(-45deg);
  -webkit-transform: rotate(-45deg);
}

    </style>

    <script type="text/javascript">
      function setNonCompatibleBrowserMessage() {
  document.body.innerHTML =
    '<h2 style="margin-left: 20px;">Your browser is not compatible with CodeChecker Viewer!</h2> \
     <p style="margin-left: 20px;">The version required for the following browsers are:</p> \
     <ul style="margin-left: 20px;"> \
     <li>Internet Explorer: version 9 or newer</li> \
     <li>Firefox: version 22.0 or newer</li> \
     </ul>';
}

// http://stackoverflow.com/questions/5916900/how-can-you-detect-the-version-of-a-browser
var browserVersion = (function(){
  var ua = navigator.userAgent, tem,
    M = ua.match(/(opera|chrome|safari|firefox|msie|trident(?=\/))\/?\s*(\d+)/i) || [];

  if (/trident/i.test(M[1])) {
    tem = /\brv[ :]+(\d+)/g.exec(ua) || [];
    return 'IE ' + (tem[1] || '');
  }

  if (M[1] === 'Chrome') {
    tem = ua.match(/\b(OPR|Edge)\/(\d+)/);
    if (tem != null) return tem.slice(1).join(' ').replace('OPR', 'Opera');
  }

  M = M[2] ? [M[1], M[2]] : [navigator.appName, navigator.appVersion, '-?'];
  if ((tem = ua.match(/version\/(\d+)/i)) != null) M.splice(1, 1, tem[1]);
    return M.join(' ');
})();

var pos = browserVersion.indexOf(' ');
var browser = browserVersion.substr(0, pos);
var version = parseInt(browserVersion.substr(pos + 1));

var browserCompatible
  = browser === 'Firefox'
  ? version >= 22
  : browser === 'IE'
  ? version >= 9
  : true;


      /* MIT License

Copyright (C) 2017 by Marijn Haverbeke <marijnh@gmail.com> and others

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
THE SOFTWARE.
 */
      !function(e,t){"object"==typeof exports&&"undefined"!=typeof module?module.exports=t():"function"==typeof define&&define.amd?define(t):e.CodeMirror=t()}(this,function(){"use strict";function e(e){return new RegExp("(^|\\s)"+e+"(?:$|\\s)\\s*")}function t(e){for(var t=e.childNodes.length;t>0;--t)e.removeChild(e.firstChild);return e}function r(e,r){return t(e).appendChild(r)}function n(e,t,r,n){var i=document.createElement(e);if(r&&(i.className=r),n&&(i.style.cssText=n),"string"==typeof t)i.appendChild(document.createTextNode(t));else if(t)for(var o=0;o<t.length;++o)i.appendChild(t[o]);return i}function i(e,t,r,i){var o=n(e,t,r,i);return o.setAttribute("role","presentation"),o}function o(e,t){if(3==t.nodeType&&(t=t.parentNode),e.contains)return e.contains(t);do{if(11==t.nodeType&&(t=t.host),t==e)return!0}while(t=t.parentNode)}function l(){var e;try{e=document.activeElement}catch(t){e=document.body||null}for(;e&&e.shadowRoot&&e.shadowRoot.activeElement;)e=e.shadowRoot.activeElement;return e}function s(t,r){var n=t.className;e(r).test(n)||(t.className+=(n?" ":"")+r)}function a(t,r){for(var n=t.split(" "),i=0;i<n.length;i++)n[i]&&!e(n[i]).test(r)&&(r+=" "+n[i]);return r}function u(e){var t=Array.prototype.slice.call(arguments,1);return function(){return e.apply(null,t)}}function c(e,t,r){t||(t={});for(var n in e)!e.hasOwnProperty(n)||!1===r&&t.hasOwnProperty(n)||(t[n]=e[n]);return t}function f(e,t,r,n,i){null==t&&-1==(t=e.search(/[^\s\u00a0]/))&&(t=e.length);for(var o=n||0,l=i||0;;){var s=e.indexOf("\t",o);if(s<0||s>=t)return l+(t-o);l+=s-o,l+=r-l%r,o=s+1}}function h(e,t){for(var r=0;r<e.length;++r)if(e[r]==t)return r;return-1}function d(e,t,r){for(var n=0,i=0;;){var o=e.indexOf("\t",n);-1==o&&(o=e.length);var l=o-n;if(o==e.length||i+l>=t)return n+Math.min(l,t-i);if(i+=o-n,i+=r-i%r,n=o+1,i>=t)return n}}function p(e){for(;Kl.length<=e;)Kl.push(g(Kl)+" ");return Kl[e]}function g(e){return e[e.length-1]}function v(e,t){for(var r=[],n=0;n<e.length;n++)r[n]=t(e[n],n);return r}function m(e,t,r){for(var n=0,i=r(t);n<e.length&&r(e[n])<=i;)n++;e.splice(n,0,t)}function y(){}function b(e,t){var r;return Object.create?r=Object.create(e):(y.prototype=e,r=new y),t&&c(t,r),r}function w(e){return/\w/.test(e)||e>""&&(e.toUpperCase()!=e.toLowerCase()||jl.test(e))}function x(e,t){return t?!!(t.source.indexOf("\\w")>-1&&w(e))||t.test(e):w(e)}function C(e){for(var t in e)if(e.hasOwnProperty(t)&&e[t])return!1;return!0}function S(e){return e.charCodeAt(0)>=768&&Xl.test(e)}function L(e,t,r){for(;(r<0?t>0:t<e.length)&&S(e.charAt(t));)t+=r;return t}function k(e,t,r){for(var n=t>r?-1:1;;){if(t==r)return t;var i=(t+r)/2,o=n<0?Math.ceil(i):Math.floor(i);if(o==t)return e(o)?t:r;e(o)?r=o:t=o+n}}function T(e,t,r){var o=this;this.input=r,o.scrollbarFiller=n("div",null,"CodeMirror-scrollbar-filler"),o.scrollbarFiller.setAttribute("cm-not-content","true"),o.gutterFiller=n("div",null,"CodeMirror-gutter-filler"),o.gutterFiller.setAttribute("cm-not-content","true"),o.lineDiv=i("div",null,"CodeMirror-code"),o.selectionDiv=n("div",null,null,"position: relative; z-index: 1"),o.cursorDiv=n("div",null,"CodeMirror-cursors"),o.measure=n("div",null,"CodeMirror-measure"),o.lineMeasure=n("div",null,"CodeMirror-measure"),o.lineSpace=i("div",[o.measure,o.lineMeasure,o.selectionDiv,o.cursorDiv,o.lineDiv],null,"position: relative; outline: none");var l=i("div",[o.lineSpace],"CodeMirror-lines");o.mover=n("div",[l],null,"position: relative"),o.sizer=n("div",[o.mover],"CodeMirror-sizer"),o.sizerWidth=null,o.heightForcer=n("div",null,null,"position: absolute; height: "+Rl+"px; width: 1px;"),o.gutters=n("div",null,"CodeMirror-gutters"),o.lineGutter=null,o.scroller=n("div",[o.sizer,o.heightForcer,o.gutters],"CodeMirror-scroll"),o.scroller.setAttribute("tabIndex","-1"),o.wrapper=n("div",[o.scrollbarFiller,o.gutterFiller,o.scroller],"CodeMirror"),gl&&vl<8&&(o.gutters.style.zIndex=-1,o.scroller.style.paddingRight=0),ml||fl&&Tl||(o.scroller.draggable=!0),e&&(e.appendChild?e.appendChild(o.wrapper):e(o.wrapper)),o.viewFrom=o.viewTo=t.first,o.reportedViewFrom=o.reportedViewTo=t.first,o.view=[],o.renderedView=null,o.externalMeasured=null,o.viewOffset=0,o.lastWrapHeight=o.lastWrapWidth=0,o.updateLineNumbers=null,o.nativeBarWidth=o.barHeight=o.barWidth=0,o.scrollbarsClipped=!1,o.lineNumWidth=o.lineNumInnerWidth=o.lineNumChars=null,o.alignWidgets=!1,o.cachedCharWidth=o.cachedTextHeight=o.cachedPaddingH=null,o.maxLine=null,o.maxLineLength=0,o.maxLineChanged=!1,o.wheelDX=o.wheelDY=o.wheelStartX=o.wheelStartY=null,o.shift=!1,o.selForContextMenu=null,o.activeTouch=null,r.init(o)}function M(e,t){if((t-=e.first)<0||t>=e.size)throw new Error("There is no line "+(t+e.first)+" in the document.");for(var r=e;!r.lines;)for(var n=0;;++n){var i=r.children[n],o=i.chunkSize();if(t<o){r=i;break}t-=o}return r.lines[t]}function N(e,t,r){var n=[],i=t.line;return e.iter(t.line,r.line+1,function(e){var o=e.text;i==r.line&&(o=o.slice(0,r.ch)),i==t.line&&(o=o.slice(t.ch)),n.push(o),++i}),n}function O(e,t,r){var n=[];return e.iter(t,r,function(e){n.push(e.text)}),n}function A(e,t){var r=t-e.height;if(r)for(var n=e;n;n=n.parent)n.height+=r}function W(e){if(null==e.parent)return null;for(var t=e.parent,r=h(t.lines,e),n=t.parent;n;t=n,n=n.parent)for(var i=0;n.children[i]!=t;++i)r+=n.children[i].chunkSize();return r+t.first}function D(e,t){var r=e.first;e:do{for(var n=0;n<e.children.length;++n){var i=e.children[n],o=i.height;if(t<o){e=i;continue e}t-=o,r+=i.chunkSize()}return r}while(!e.lines);for(var l=0;l<e.lines.length;++l){var s=e.lines[l].height;if(t<s)break;t-=s}return r+l}function H(e,t){return t>=e.first&&t<e.first+e.size}function F(e,t){return String(e.lineNumberFormatter(t+e.firstLineNumber))}function E(e,t,r){if(void 0===r&&(r=null),!(this instanceof E))return new E(e,t,r);this.line=e,this.ch=t,this.sticky=r}function P(e,t){return e.line-t.line||e.ch-t.ch}function I(e,t){return e.sticky==t.sticky&&0==P(e,t)}function z(e){return E(e.line,e.ch)}function R(e,t){return P(e,t)<0?t:e}function B(e,t){return P(e,t)<0?e:t}function G(e,t){return Math.max(e.first,Math.min(t,e.first+e.size-1))}function U(e,t){if(t.line<e.first)return E(e.first,0);var r=e.first+e.size-1;return t.line>r?E(r,M(e,r).text.length):V(t,M(e,t.line).text.length)}function V(e,t){var r=e.ch;return null==r||r>t?E(e.line,t):r<0?E(e.line,0):e}function K(e,t){for(var r=[],n=0;n<t.length;n++)r[n]=U(e,t[n]);return r}function j(){Yl=!0}function X(){_l=!0}function Y(e,t,r){this.marker=e,this.from=t,this.to=r}function _(e,t){if(e)for(var r=0;r<e.length;++r){var n=e[r];if(n.marker==t)return n}}function $(e,t){for(var r,n=0;n<e.length;++n)e[n]!=t&&(r||(r=[])).push(e[n]);return r}function q(e,t){e.markedSpans=e.markedSpans?e.markedSpans.concat([t]):[t],t.marker.attachLine(e)}function Z(e,t,r){var n;if(e)for(var i=0;i<e.length;++i){var o=e[i],l=o.marker;if(null==o.from||(l.inclusiveLeft?o.from<=t:o.from<t)||o.from==t&&"bookmark"==l.type&&(!r||!o.marker.insertLeft)){var s=null==o.to||(l.inclusiveRight?o.to>=t:o.to>t);(n||(n=[])).push(new Y(l,o.from,s?null:o.to))}}return n}function Q(e,t,r){var n;if(e)for(var i=0;i<e.length;++i){var o=e[i],l=o.marker;if(null==o.to||(l.inclusiveRight?o.to>=t:o.to>t)||o.from==t&&"bookmark"==l.type&&(!r||o.marker.insertLeft)){var s=null==o.from||(l.inclusiveLeft?o.from<=t:o.from<t);(n||(n=[])).push(new Y(l,s?null:o.from-t,null==o.to?null:o.to-t))}}return n}function J(e,t){if(t.full)return null;var r=H(e,t.from.line)&&M(e,t.from.line).markedSpans,n=H(e,t.to.line)&&M(e,t.to.line).markedSpans;if(!r&&!n)return null;var i=t.from.ch,o=t.to.ch,l=0==P(t.from,t.to),s=Z(r,i,l),a=Q(n,o,l),u=1==t.text.length,c=g(t.text).length+(u?i:0);if(s)for(var f=0;f<s.length;++f){var h=s[f];if(null==h.to){var d=_(a,h.marker);d?u&&(h.to=null==d.to?null:d.to+c):h.to=i}}if(a)for(var p=0;p<a.length;++p){var v=a[p];null!=v.to&&(v.to+=c),null==v.from?_(s,v.marker)||(v.from=c,u&&(s||(s=[])).push(v)):(v.from+=c,u&&(s||(s=[])).push(v))}s&&(s=ee(s)),a&&a!=s&&(a=ee(a));var m=[s];if(!u){var y,b=t.text.length-2;if(b>0&&s)for(var w=0;w<s.length;++w)null==s[w].to&&(y||(y=[])).push(new Y(s[w].marker,null,null));for(var x=0;x<b;++x)m.push(y);m.push(a)}return m}function ee(e){for(var t=0;t<e.length;++t){var r=e[t];null!=r.from&&r.from==r.to&&!1!==r.marker.clearWhenEmpty&&e.splice(t--,1)}return e.length?e:null}function te(e,t,r){var n=null;if(e.iter(t.line,r.line+1,function(e){if(e.markedSpans)for(var t=0;t<e.markedSpans.length;++t){var r=e.markedSpans[t].marker;!r.readOnly||n&&-1!=h(n,r)||(n||(n=[])).push(r)}}),!n)return null;for(var i=[{from:t,to:r}],o=0;o<n.length;++o)for(var l=n[o],s=l.find(0),a=0;a<i.length;++a){var u=i[a];if(!(P(u.to,s.from)<0||P(u.from,s.to)>0)){var c=[a,1],f=P(u.from,s.from),d=P(u.to,s.to);(f<0||!l.inclusiveLeft&&!f)&&c.push({from:u.from,to:s.from}),(d>0||!l.inclusiveRight&&!d)&&c.push({from:s.to,to:u.to}),i.splice.apply(i,c),a+=c.length-3}}return i}function re(e){var t=e.markedSpans;if(t){for(var r=0;r<t.length;++r)t[r].marker.detachLine(e);e.markedSpans=null}}function ne(e,t){if(t){for(var r=0;r<t.length;++r)t[r].marker.attachLine(e);e.markedSpans=t}}function ie(e){return e.inclusiveLeft?-1:0}function oe(e){return e.inclusiveRight?1:0}function le(e,t){var r=e.lines.length-t.lines.length;if(0!=r)return r;var n=e.find(),i=t.find(),o=P(n.from,i.from)||ie(e)-ie(t);if(o)return-o;var l=P(n.to,i.to)||oe(e)-oe(t);return l||t.id-e.id}function se(e,t){var r,n=_l&&e.markedSpans;if(n)for(var i=void 0,o=0;o<n.length;++o)(i=n[o]).marker.collapsed&&null==(t?i.from:i.to)&&(!r||le(r,i.marker)<0)&&(r=i.marker);return r}function ae(e){return se(e,!0)}function ue(e){return se(e,!1)}function ce(e,t,r,n,i){var o=M(e,t),l=_l&&o.markedSpans;if(l)for(var s=0;s<l.length;++s){var a=l[s];if(a.marker.collapsed){var u=a.marker.find(0),c=P(u.from,r)||ie(a.marker)-ie(i),f=P(u.to,n)||oe(a.marker)-oe(i);if(!(c>=0&&f<=0||c<=0&&f>=0)&&(c<=0&&(a.marker.inclusiveRight&&i.inclusiveLeft?P(u.to,r)>=0:P(u.to,r)>0)||c>=0&&(a.marker.inclusiveRight&&i.inclusiveLeft?P(u.from,n)<=0:P(u.from,n)<0)))return!0}}}function fe(e){for(var t;t=ae(e);)e=t.find(-1,!0).line;return e}function he(e){for(var t;t=ue(e);)e=t.find(1,!0).line;return e}function de(e){for(var t,r;t=ue(e);)e=t.find(1,!0).line,(r||(r=[])).push(e);return r}function pe(e,t){var r=M(e,t),n=fe(r);return r==n?t:W(n)}function ge(e,t){if(t>e.lastLine())return t;var r,n=M(e,t);if(!ve(e,n))return t;for(;r=ue(n);)n=r.find(1,!0).line;return W(n)+1}function ve(e,t){var r=_l&&t.markedSpans;if(r)for(var n=void 0,i=0;i<r.length;++i)if((n=r[i]).marker.collapsed){if(null==n.from)return!0;if(!n.marker.widgetNode&&0==n.from&&n.marker.inclusiveLeft&&me(e,t,n))return!0}}function me(e,t,r){if(null==r.to){var n=r.marker.find(1,!0);return me(e,n.line,_(n.line.markedSpans,r.marker))}if(r.marker.inclusiveRight&&r.to==t.text.length)return!0;for(var i=void 0,o=0;o<t.markedSpans.length;++o)if((i=t.markedSpans[o]).marker.collapsed&&!i.marker.widgetNode&&i.from==r.to&&(null==i.to||i.to!=r.from)&&(i.marker.inclusiveLeft||r.marker.inclusiveRight)&&me(e,t,i))return!0}function ye(e){for(var t=0,r=(e=fe(e)).parent,n=0;n<r.lines.length;++n){var i=r.lines[n];if(i==e)break;t+=i.height}for(var o=r.parent;o;r=o,o=r.parent)for(var l=0;l<o.children.length;++l){var s=o.children[l];if(s==r)break;t+=s.height}return t}function be(e){if(0==e.height)return 0;for(var t,r=e.text.length,n=e;t=ae(n);){var i=t.find(0,!0);n=i.from.line,r+=i.from.ch-i.to.ch}for(n=e;t=ue(n);){var o=t.find(0,!0);r-=n.text.length-o.from.ch,r+=(n=o.to.line).text.length-o.to.ch}return r}function we(e){var t=e.display,r=e.doc;t.maxLine=M(r,r.first),t.maxLineLength=be(t.maxLine),t.maxLineChanged=!0,r.iter(function(e){var r=be(e);r>t.maxLineLength&&(t.maxLineLength=r,t.maxLine=e)})}function xe(e,t,r,n){if(!e)return n(t,r,"ltr",0);for(var i=!1,o=0;o<e.length;++o){var l=e[o];(l.from<r&&l.to>t||t==r&&l.to==t)&&(n(Math.max(l.from,t),Math.min(l.to,r),1==l.level?"rtl":"ltr",o),i=!0)}i||n(t,r,"ltr")}function Ce(e,t,r){var n;$l=null;for(var i=0;i<e.length;++i){var o=e[i];if(o.from<t&&o.to>t)return i;o.to==t&&(o.from!=o.to&&"before"==r?n=i:$l=i),o.from==t&&(o.from!=o.to&&"before"!=r?n=i:$l=i)}return null!=n?n:$l}function Se(e,t){var r=e.order;return null==r&&(r=e.order=ql(e.text,t)),r}function Le(e,t){return e._handlers&&e._handlers[t]||Zl}function ke(e,t,r){if(e.removeEventListener)e.removeEventListener(t,r,!1);else if(e.detachEvent)e.detachEvent("on"+t,r);else{var n=e._handlers,i=n&&n[t];if(i){var o=h(i,r);o>-1&&(n[t]=i.slice(0,o).concat(i.slice(o+1)))}}}function Te(e,t){var r=Le(e,t);if(r.length)for(var n=Array.prototype.slice.call(arguments,2),i=0;i<r.length;++i)r[i].apply(null,n)}function Me(e,t,r){return"string"==typeof t&&(t={type:t,preventDefault:function(){this.defaultPrevented=!0}}),Te(e,r||t.type,e,t),He(t)||t.codemirrorIgnore}function Ne(e){var t=e._handlers&&e._handlers.cursorActivity;if(t)for(var r=e.curOp.cursorActivityHandlers||(e.curOp.cursorActivityHandlers=[]),n=0;n<t.length;++n)-1==h(r,t[n])&&r.push(t[n])}function Oe(e,t){return Le(e,t).length>0}function Ae(e){e.prototype.on=function(e,t){Ql(this,e,t)},e.prototype.off=function(e,t){ke(this,e,t)}}function We(e){e.preventDefault?e.preventDefault():e.returnValue=!1}function De(e){e.stopPropagation?e.stopPropagation():e.cancelBubble=!0}function He(e){return null!=e.defaultPrevented?e.defaultPrevented:0==e.returnValue}function Fe(e){We(e),De(e)}function Ee(e){return e.target||e.srcElement}function Pe(e){var t=e.which;return null==t&&(1&e.button?t=1:2&e.button?t=3:4&e.button&&(t=2)),Ml&&e.ctrlKey&&1==t&&(t=3),t}function Ie(e){if(null==Il){var t=n("span","​");r(e,n("span",[t,document.createTextNode("x")])),0!=e.firstChild.offsetHeight&&(Il=t.offsetWidth<=1&&t.offsetHeight>2&&!(gl&&vl<8))}var i=Il?n("span","​"):n("span"," ",null,"display: inline-block; width: 1px; margin-right: -1px");return i.setAttribute("cm-text",""),i}function ze(e){if(null!=zl)return zl;var n=r(e,document.createTextNode("AخA")),i=Wl(n,0,1).getBoundingClientRect(),o=Wl(n,1,2).getBoundingClientRect();return t(e),!(!i||i.left==i.right)&&(zl=o.right-i.right<3)}function Re(e){if(null!=ns)return ns;var t=r(e,n("span","x")),i=t.getBoundingClientRect(),o=Wl(t,0,1).getBoundingClientRect();return ns=Math.abs(i.left-o.left)>1}function Be(e,t){arguments.length>2&&(t.dependencies=Array.prototype.slice.call(arguments,2)),is[e]=t}function Ge(e){if("string"==typeof e&&os.hasOwnProperty(e))e=os[e];else if(e&&"string"==typeof e.name&&os.hasOwnProperty(e.name)){var t=os[e.name];"string"==typeof t&&(t={name:t}),(e=b(t,e)).name=t.name}else{if("string"==typeof e&&/^[\w\-]+\/[\w\-]+\+xml$/.test(e))return Ge("application/xml");if("string"==typeof e&&/^[\w\-]+\/[\w\-]+\+json$/.test(e))return Ge("application/json")}return"string"==typeof e?{name:e}:e||{name:"null"}}function Ue(e,t){t=Ge(t);var r=is[t.name];if(!r)return Ue(e,"text/plain");var n=r(e,t);if(ls.hasOwnProperty(t.name)){var i=ls[t.name];for(var o in i)i.hasOwnProperty(o)&&(n.hasOwnProperty(o)&&(n["_"+o]=n[o]),n[o]=i[o])}if(n.name=t.name,t.helperType&&(n.helperType=t.helperType),t.modeProps)for(var l in t.modeProps)n[l]=t.modeProps[l];return n}function Ve(e,t){c(t,ls.hasOwnProperty(e)?ls[e]:ls[e]={})}function Ke(e,t){if(!0===t)return t;if(e.copyState)return e.copyState(t);var r={};for(var n in t){var i=t[n];i instanceof Array&&(i=i.concat([])),r[n]=i}return r}function je(e,t){for(var r;e.innerMode&&(r=e.innerMode(t))&&r.mode!=e;)t=r.state,e=r.mode;return r||{mode:e,state:t}}function Xe(e,t,r){return!e.startState||e.startState(t,r)}function Ye(e,t,r,n){var i=[e.state.modeGen],o={};tt(e,t.text,e.doc.mode,r,function(e,t){return i.push(e,t)},o,n);for(var l=r.state,s=0;s<e.state.overlays.length;++s)!function(n){var l=e.state.overlays[n],s=1,a=0;r.state=!0,tt(e,t.text,l.mode,r,function(e,t){for(var r=s;a<e;){var n=i[s];n>e&&i.splice(s,1,e,i[s+1],n),s+=2,a=Math.min(e,n)}if(t)if(l.opaque)i.splice(r,s-r,e,"overlay "+t),s=r+2;else for(;r<s;r+=2){var o=i[r+1];i[r+1]=(o?o+" ":"")+"overlay "+t}},o)}(s);return r.state=l,{styles:i,classes:o.bgClass||o.textClass?o:null}}function _e(e,t,r){if(!t.styles||t.styles[0]!=e.state.modeGen){var n=$e(e,W(t)),i=t.text.length>e.options.maxHighlightLength&&Ke(e.doc.mode,n.state),o=Ye(e,t,n);i&&(n.state=i),t.stateAfter=n.save(!i),t.styles=o.styles,o.classes?t.styleClasses=o.classes:t.styleClasses&&(t.styleClasses=null),r===e.doc.highlightFrontier&&(e.doc.modeFrontier=Math.max(e.doc.modeFrontier,++e.doc.highlightFrontier))}return t.styles}function $e(e,t,r){var n=e.doc,i=e.display;if(!n.mode.startState)return new us(n,!0,t);var o=rt(e,t,r),l=o>n.first&&M(n,o-1).stateAfter,s=l?us.fromSaved(n,l,o):new us(n,Xe(n.mode),o);return n.iter(o,t,function(r){qe(e,r.text,s);var n=s.line;r.stateAfter=n==t-1||n%5==0||n>=i.viewFrom&&n<i.viewTo?s.save():null,s.nextLine()}),r&&(n.modeFrontier=s.line),s}function qe(e,t,r,n){var i=e.doc.mode,o=new ss(t,e.options.tabSize,r);for(o.start=o.pos=n||0,""==t&&Ze(i,r.state);!o.eol();)Qe(i,o,r.state),o.start=o.pos}function Ze(e,t){if(e.blankLine)return e.blankLine(t);if(e.innerMode){var r=je(e,t);return r.mode.blankLine?r.mode.blankLine(r.state):void 0}}function Qe(e,t,r,n){for(var i=0;i<10;i++){n&&(n[0]=je(e,r).mode);var o=e.token(t,r);if(t.pos>t.start)return o}throw new Error("Mode "+e.name+" failed to advance stream.")}function Je(e,t,r,n){var i,o,l=e.doc,s=l.mode,a=M(l,(t=U(l,t)).line),u=$e(e,t.line,r),c=new ss(a.text,e.options.tabSize,u);for(n&&(o=[]);(n||c.pos<t.ch)&&!c.eol();)c.start=c.pos,i=Qe(s,c,u.state),n&&o.push(new cs(c,i,Ke(l.mode,u.state)));return n?o:new cs(c,i,u.state)}function et(e,t){if(e)for(;;){var r=e.match(/(?:^|\s+)line-(background-)?(\S+)/);if(!r)break;e=e.slice(0,r.index)+e.slice(r.index+r[0].length);var n=r[1]?"bgClass":"textClass";null==t[n]?t[n]=r[2]:new RegExp("(?:^|s)"+r[2]+"(?:$|s)").test(t[n])||(t[n]+=" "+r[2])}return e}function tt(e,t,r,n,i,o,l){var s=r.flattenSpans;null==s&&(s=e.options.flattenSpans);var a,u=0,c=null,f=new ss(t,e.options.tabSize,n),h=e.options.addModeClass&&[null];for(""==t&&et(Ze(r,n.state),o);!f.eol();){if(f.pos>e.options.maxHighlightLength?(s=!1,l&&qe(e,t,n,f.pos),f.pos=t.length,a=null):a=et(Qe(r,f,n.state,h),o),h){var d=h[0].name;d&&(a="m-"+(a?d+" "+a:d))}if(!s||c!=a){for(;u<f.start;)i(u=Math.min(f.start,u+5e3),c);c=a}f.start=f.pos}for(;u<f.pos;){var p=Math.min(f.pos,u+5e3);i(p,c),u=p}}function rt(e,t,r){for(var n,i,o=e.doc,l=r?-1:t-(e.doc.mode.innerMode?1e3:100),s=t;s>l;--s){if(s<=o.first)return o.first;var a=M(o,s-1),u=a.stateAfter;if(u&&(!r||s+(u instanceof as?u.lookAhead:0)<=o.modeFrontier))return s;var c=f(a.text,null,e.options.tabSize);(null==i||n>c)&&(i=s-1,n=c)}return i}function nt(e,t){if(e.modeFrontier=Math.min(e.modeFrontier,t),!(e.highlightFrontier<t-10)){for(var r=e.first,n=t-1;n>r;n--){var i=M(e,n).stateAfter;if(i&&(!(i instanceof as)||n+i.lookAhead<t)){r=n+1;break}}e.highlightFrontier=Math.min(e.highlightFrontier,r)}}function it(e,t,r,n){e.text=t,e.stateAfter&&(e.stateAfter=null),e.styles&&(e.styles=null),null!=e.order&&(e.order=null),re(e),ne(e,r);var i=n?n(e):1;i!=e.height&&A(e,i)}function ot(e){e.parent=null,re(e)}function lt(e,t){if(!e||/^\s*$/.test(e))return null;var r=t.addModeClass?ps:ds;return r[e]||(r[e]=e.replace(/\S+/g,"cm-$&"))}function st(e,t){var r=i("span",null,null,ml?"padding-right: .1px":null),n={pre:i("pre",[r],"CodeMirror-line"),content:r,col:0,pos:0,cm:e,trailingSpace:!1,splitSpaces:(gl||ml)&&e.getOption("lineWrapping")};t.measure={};for(var o=0;o<=(t.rest?t.rest.length:0);o++){var l=o?t.rest[o-1]:t.line,s=void 0;n.pos=0,n.addToken=ut,ze(e.display.measure)&&(s=Se(l,e.doc.direction))&&(n.addToken=ft(n.addToken,s)),n.map=[],dt(l,n,_e(e,l,t!=e.display.externalMeasured&&W(l))),l.styleClasses&&(l.styleClasses.bgClass&&(n.bgClass=a(l.styleClasses.bgClass,n.bgClass||"")),l.styleClasses.textClass&&(n.textClass=a(l.styleClasses.textClass,n.textClass||""))),0==n.map.length&&n.map.push(0,0,n.content.appendChild(Ie(e.display.measure))),0==o?(t.measure.map=n.map,t.measure.cache={}):((t.measure.maps||(t.measure.maps=[])).push(n.map),(t.measure.caches||(t.measure.caches=[])).push({}))}if(ml){var u=n.content.lastChild;(/\bcm-tab\b/.test(u.className)||u.querySelector&&u.querySelector(".cm-tab"))&&(n.content.className="cm-tab-wrap-hack")}return Te(e,"renderLine",e,t.line,n.pre),n.pre.className&&(n.textClass=a(n.pre.className,n.textClass||"")),n}function at(e){var t=n("span","•","cm-invalidchar");return t.title="\\u"+e.charCodeAt(0).toString(16),t.setAttribute("aria-label",t.title),t}function ut(e,t,r,i,o,l,s){if(t){var a,u=e.splitSpaces?ct(t,e.trailingSpace):t,c=e.cm.state.specialChars,f=!1;if(c.test(t)){a=document.createDocumentFragment();for(var h=0;;){c.lastIndex=h;var d=c.exec(t),g=d?d.index-h:t.length-h;if(g){var v=document.createTextNode(u.slice(h,h+g));gl&&vl<9?a.appendChild(n("span",[v])):a.appendChild(v),e.map.push(e.pos,e.pos+g,v),e.col+=g,e.pos+=g}if(!d)break;h+=g+1;var m=void 0;if("\t"==d[0]){var y=e.cm.options.tabSize,b=y-e.col%y;(m=a.appendChild(n("span",p(b),"cm-tab"))).setAttribute("role","presentation"),m.setAttribute("cm-text","\t"),e.col+=b}else"\r"==d[0]||"\n"==d[0]?((m=a.appendChild(n("span","\r"==d[0]?"␍":"␤","cm-invalidchar"))).setAttribute("cm-text",d[0]),e.col+=1):((m=e.cm.options.specialCharPlaceholder(d[0])).setAttribute("cm-text",d[0]),gl&&vl<9?a.appendChild(n("span",[m])):a.appendChild(m),e.col+=1);e.map.push(e.pos,e.pos+1,m),e.pos++}}else e.col+=t.length,a=document.createTextNode(u),e.map.push(e.pos,e.pos+t.length,a),gl&&vl<9&&(f=!0),e.pos+=t.length;if(e.trailingSpace=32==u.charCodeAt(t.length-1),r||i||o||f||s){var w=r||"";i&&(w+=i),o&&(w+=o);var x=n("span",[a],w,s);return l&&(x.title=l),e.content.appendChild(x)}e.content.appendChild(a)}}function ct(e,t){if(e.length>1&&!/  /.test(e))return e;for(var r=t,n="",i=0;i<e.length;i++){var o=e.charAt(i);" "!=o||!r||i!=e.length-1&&32!=e.charCodeAt(i+1)||(o=" "),n+=o,r=" "==o}return n}function ft(e,t){return function(r,n,i,o,l,s,a){i=i?i+" cm-force-border":"cm-force-border";for(var u=r.pos,c=u+n.length;;){for(var f=void 0,h=0;h<t.length&&!((f=t[h]).to>u&&f.from<=u);h++);if(f.to>=c)return e(r,n,i,o,l,s,a);e(r,n.slice(0,f.to-u),i,o,null,s,a),o=null,n=n.slice(f.to-u),u=f.to}}}function ht(e,t,r,n){var i=!n&&r.widgetNode;i&&e.map.push(e.pos,e.pos+t,i),!n&&e.cm.display.input.needsContentAttribute&&(i||(i=e.content.appendChild(document.createElement("span"))),i.setAttribute("cm-marker",r.id)),i&&(e.cm.display.input.setUneditable(i),e.content.appendChild(i)),e.pos+=t,e.trailingSpace=!1}function dt(e,t,r){var n=e.markedSpans,i=e.text,o=0;if(n)for(var l,s,a,u,c,f,h,d=i.length,p=0,g=1,v="",m=0;;){if(m==p){a=u=c=f=s="",h=null,m=1/0;for(var y=[],b=void 0,w=0;w<n.length;++w){var x=n[w],C=x.marker;"bookmark"==C.type&&x.from==p&&C.widgetNode?y.push(C):x.from<=p&&(null==x.to||x.to>p||C.collapsed&&x.to==p&&x.from==p)?(null!=x.to&&x.to!=p&&m>x.to&&(m=x.to,u=""),C.className&&(a+=" "+C.className),C.css&&(s=(s?s+";":"")+C.css),C.startStyle&&x.from==p&&(c+=" "+C.startStyle),C.endStyle&&x.to==m&&(b||(b=[])).push(C.endStyle,x.to),C.title&&!f&&(f=C.title),C.collapsed&&(!h||le(h.marker,C)<0)&&(h=x)):x.from>p&&m>x.from&&(m=x.from)}if(b)for(var S=0;S<b.length;S+=2)b[S+1]==m&&(u+=" "+b[S]);if(!h||h.from==p)for(var L=0;L<y.length;++L)ht(t,0,y[L]);if(h&&(h.from||0)==p){if(ht(t,(null==h.to?d+1:h.to)-p,h.marker,null==h.from),null==h.to)return;h.to==p&&(h=!1)}}if(p>=d)break;for(var k=Math.min(d,m);;){if(v){var T=p+v.length;if(!h){var M=T>k?v.slice(0,k-p):v;t.addToken(t,M,l?l+a:a,c,p+M.length==m?u:"",f,s)}if(T>=k){v=v.slice(k-p),p=k;break}p=T,c=""}v=i.slice(o,o=r[g++]),l=lt(r[g++],t.cm.options)}}else for(var N=1;N<r.length;N+=2)t.addToken(t,i.slice(o,o=r[N]),lt(r[N+1],t.cm.options))}function pt(e,t,r){this.line=t,this.rest=de(t),this.size=this.rest?W(g(this.rest))-r+1:1,this.node=this.text=null,this.hidden=ve(e,t)}function gt(e,t,r){for(var n,i=[],o=t;o<r;o=n){var l=new pt(e.doc,M(e.doc,o),o);n=o+l.size,i.push(l)}return i}function vt(e){gs?gs.ops.push(e):e.ownsGroup=gs={ops:[e],delayedCallbacks:[]}}function mt(e){var t=e.delayedCallbacks,r=0;do{for(;r<t.length;r++)t[r].call(null);for(var n=0;n<e.ops.length;n++){var i=e.ops[n];if(i.cursorActivityHandlers)for(;i.cursorActivityCalled<i.cursorActivityHandlers.length;)i.cursorActivityHandlers[i.cursorActivityCalled++].call(null,i.cm)}}while(r<t.length)}function yt(e,t){var r=e.ownsGroup;if(r)try{mt(r)}finally{gs=null,t(r)}}function bt(e,t){var r=Le(e,t);if(r.length){var n,i=Array.prototype.slice.call(arguments,2);gs?n=gs.delayedCallbacks:vs?n=vs:(n=vs=[],setTimeout(wt,0));for(var o=0;o<r.length;++o)!function(e){n.push(function(){return r[e].apply(null,i)})}(o)}}function wt(){var e=vs;vs=null;for(var t=0;t<e.length;++t)e[t]()}function xt(e,t,r,n){for(var i=0;i<t.changes.length;i++){var o=t.changes[i];"text"==o?kt(e,t):"gutter"==o?Mt(e,t,r,n):"class"==o?Tt(e,t):"widget"==o&&Nt(e,t,n)}t.changes=null}function Ct(e){return e.node==e.text&&(e.node=n("div",null,null,"position: relative"),e.text.parentNode&&e.text.parentNode.replaceChild(e.node,e.text),e.node.appendChild(e.text),gl&&vl<8&&(e.node.style.zIndex=2)),e.node}function St(e,t){var r=t.bgClass?t.bgClass+" "+(t.line.bgClass||""):t.line.bgClass;if(r&&(r+=" CodeMirror-linebackground"),t.background)r?t.background.className=r:(t.background.parentNode.removeChild(t.background),t.background=null);else if(r){var i=Ct(t);t.background=i.insertBefore(n("div",null,r),i.firstChild),e.display.input.setUneditable(t.background)}}function Lt(e,t){var r=e.display.externalMeasured;return r&&r.line==t.line?(e.display.externalMeasured=null,t.measure=r.measure,r.built):st(e,t)}function kt(e,t){var r=t.text.className,n=Lt(e,t);t.text==t.node&&(t.node=n.pre),t.text.parentNode.replaceChild(n.pre,t.text),t.text=n.pre,n.bgClass!=t.bgClass||n.textClass!=t.textClass?(t.bgClass=n.bgClass,t.textClass=n.textClass,Tt(e,t)):r&&(t.text.className=r)}function Tt(e,t){St(e,t),t.line.wrapClass?Ct(t).className=t.line.wrapClass:t.node!=t.text&&(t.node.className="");var r=t.textClass?t.textClass+" "+(t.line.textClass||""):t.line.textClass;t.text.className=r||""}function Mt(e,t,r,i){if(t.gutter&&(t.node.removeChild(t.gutter),t.gutter=null),t.gutterBackground&&(t.node.removeChild(t.gutterBackground),t.gutterBackground=null),t.line.gutterClass){var o=Ct(t);t.gutterBackground=n("div",null,"CodeMirror-gutter-background "+t.line.gutterClass,"left: "+(e.options.fixedGutter?i.fixedPos:-i.gutterTotalWidth)+"px; width: "+i.gutterTotalWidth+"px"),e.display.input.setUneditable(t.gutterBackground),o.insertBefore(t.gutterBackground,t.text)}var l=t.line.gutterMarkers;if(e.options.lineNumbers||l){var s=Ct(t),a=t.gutter=n("div",null,"CodeMirror-gutter-wrapper","left: "+(e.options.fixedGutter?i.fixedPos:-i.gutterTotalWidth)+"px");if(e.display.input.setUneditable(a),s.insertBefore(a,t.text),t.line.gutterClass&&(a.className+=" "+t.line.gutterClass),!e.options.lineNumbers||l&&l["CodeMirror-linenumbers"]||(t.lineNumber=a.appendChild(n("div",F(e.options,r),"CodeMirror-linenumber CodeMirror-gutter-elt","left: "+i.gutterLeft["CodeMirror-linenumbers"]+"px; width: "+e.display.lineNumInnerWidth+"px"))),l)for(var u=0;u<e.options.gutters.length;++u){var c=e.options.gutters[u],f=l.hasOwnProperty(c)&&l[c];f&&a.appendChild(n("div",[f],"CodeMirror-gutter-elt","left: "+i.gutterLeft[c]+"px; width: "+i.gutterWidth[c]+"px"))}}}function Nt(e,t,r){t.alignable&&(t.alignable=null);for(var n=t.node.firstChild,i=void 0;n;n=i)i=n.nextSibling,"CodeMirror-linewidget"==n.className&&t.node.removeChild(n);At(e,t,r)}function Ot(e,t,r,n){var i=Lt(e,t);return t.text=t.node=i.pre,i.bgClass&&(t.bgClass=i.bgClass),i.textClass&&(t.textClass=i.textClass),Tt(e,t),Mt(e,t,r,n),At(e,t,n),t.node}function At(e,t,r){if(Wt(e,t.line,t,r,!0),t.rest)for(var n=0;n<t.rest.length;n++)Wt(e,t.rest[n],t,r,!1)}function Wt(e,t,r,i,o){if(t.widgets)for(var l=Ct(r),s=0,a=t.widgets;s<a.length;++s){var u=a[s],c=n("div",[u.node],"CodeMirror-linewidget");u.handleMouseEvents||c.setAttribute("cm-ignore-events","true"),Dt(u,c,r,i),e.display.input.setUneditable(c),o&&u.above?l.insertBefore(c,r.gutter||r.text):l.appendChild(c),bt(u,"redraw")}}function Dt(e,t,r,n){if(e.noHScroll){(r.alignable||(r.alignable=[])).push(t);var i=n.wrapperWidth;t.style.left=n.fixedPos+"px",e.coverGutter||(i-=n.gutterTotalWidth,t.style.paddingLeft=n.gutterTotalWidth+"px"),t.style.width=i+"px"}e.coverGutter&&(t.style.zIndex=5,t.style.position="relative",e.noHScroll||(t.style.marginLeft=-n.gutterTotalWidth+"px"))}function Ht(e){if(null!=e.height)return e.height;var t=e.doc.cm;if(!t)return 0;if(!o(document.body,e.node)){var i="position: relative;";e.coverGutter&&(i+="margin-left: -"+t.display.gutters.offsetWidth+"px;"),e.noHScroll&&(i+="width: "+t.display.wrapper.clientWidth+"px;"),r(t.display.measure,n("div",[e.node],null,i))}return e.height=e.node.parentNode.offsetHeight}function Ft(e,t){for(var r=Ee(t);r!=e.wrapper;r=r.parentNode)if(!r||1==r.nodeType&&"true"==r.getAttribute("cm-ignore-events")||r.parentNode==e.sizer&&r!=e.mover)return!0}function Et(e){return e.lineSpace.offsetTop}function Pt(e){return e.mover.offsetHeight-e.lineSpace.offsetHeight}function It(e){if(e.cachedPaddingH)return e.cachedPaddingH;var t=r(e.measure,n("pre","x")),i=window.getComputedStyle?window.getComputedStyle(t):t.currentStyle,o={left:parseInt(i.paddingLeft),right:parseInt(i.paddingRight)};return isNaN(o.left)||isNaN(o.right)||(e.cachedPaddingH=o),o}function zt(e){return Rl-e.display.nativeBarWidth}function Rt(e){return e.display.scroller.clientWidth-zt(e)-e.display.barWidth}function Bt(e){return e.display.scroller.clientHeight-zt(e)-e.display.barHeight}function Gt(e,t,r){var n=e.options.lineWrapping,i=n&&Rt(e);if(!t.measure.heights||n&&t.measure.width!=i){var o=t.measure.heights=[];if(n){t.measure.width=i;for(var l=t.text.firstChild.getClientRects(),s=0;s<l.length-1;s++){var a=l[s],u=l[s+1];Math.abs(a.bottom-u.bottom)>2&&o.push((a.bottom+u.top)/2-r.top)}}o.push(r.bottom-r.top)}}function Ut(e,t,r){if(e.line==t)return{map:e.measure.map,cache:e.measure.cache};for(var n=0;n<e.rest.length;n++)if(e.rest[n]==t)return{map:e.measure.maps[n],cache:e.measure.caches[n]};for(var i=0;i<e.rest.length;i++)if(W(e.rest[i])>r)return{map:e.measure.maps[i],cache:e.measure.caches[i],before:!0}}function Vt(e,t){var n=W(t=fe(t)),i=e.display.externalMeasured=new pt(e.doc,t,n);i.lineN=n;var o=i.built=st(e,i);return i.text=o.pre,r(e.display.lineMeasure,o.pre),i}function Kt(e,t,r,n){return Yt(e,Xt(e,t),r,n)}function jt(e,t){if(t>=e.display.viewFrom&&t<e.display.viewTo)return e.display.view[Lr(e,t)];var r=e.display.externalMeasured;return r&&t>=r.lineN&&t<r.lineN+r.size?r:void 0}function Xt(e,t){var r=W(t),n=jt(e,r);n&&!n.text?n=null:n&&n.changes&&(xt(e,n,r,br(e)),e.curOp.forceUpdate=!0),n||(n=Vt(e,t));var i=Ut(n,t,r);return{line:t,view:n,rect:null,map:i.map,cache:i.cache,before:i.before,hasHeights:!1}}function Yt(e,t,r,n,i){t.before&&(r=-1);var o,l=r+(n||"");return t.cache.hasOwnProperty(l)?o=t.cache[l]:(t.rect||(t.rect=t.view.text.getBoundingClientRect()),t.hasHeights||(Gt(e,t.view,t.rect),t.hasHeights=!0),(o=qt(e,t,r,n)).bogus||(t.cache[l]=o)),{left:o.left,right:o.right,top:i?o.rtop:o.top,bottom:i?o.rbottom:o.bottom}}function _t(e,t,r){for(var n,i,o,l,s,a,u=0;u<e.length;u+=3)if(s=e[u],a=e[u+1],t<s?(i=0,o=1,l="left"):t<a?o=(i=t-s)+1:(u==e.length-3||t==a&&e[u+3]>t)&&(i=(o=a-s)-1,t>=a&&(l="right")),null!=i){if(n=e[u+2],s==a&&r==(n.insertLeft?"left":"right")&&(l=r),"left"==r&&0==i)for(;u&&e[u-2]==e[u-3]&&e[u-1].insertLeft;)n=e[2+(u-=3)],l="left";if("right"==r&&i==a-s)for(;u<e.length-3&&e[u+3]==e[u+4]&&!e[u+5].insertLeft;)n=e[(u+=3)+2],l="right";break}return{node:n,start:i,end:o,collapse:l,coverStart:s,coverEnd:a}}function $t(e,t){var r=ms;if("left"==t)for(var n=0;n<e.length&&(r=e[n]).left==r.right;n++);else for(var i=e.length-1;i>=0&&(r=e[i]).left==r.right;i--);return r}function qt(e,t,r,n){var i,o=_t(t.map,r,n),l=o.node,s=o.start,a=o.end,u=o.collapse;if(3==l.nodeType){for(var c=0;c<4;c++){for(;s&&S(t.line.text.charAt(o.coverStart+s));)--s;for(;o.coverStart+a<o.coverEnd&&S(t.line.text.charAt(o.coverStart+a));)++a;if((i=gl&&vl<9&&0==s&&a==o.coverEnd-o.coverStart?l.parentNode.getBoundingClientRect():$t(Wl(l,s,a).getClientRects(),n)).left||i.right||0==s)break;a=s,s-=1,u="right"}gl&&vl<11&&(i=Zt(e.display.measure,i))}else{s>0&&(u=n="right");var f;i=e.options.lineWrapping&&(f=l.getClientRects()).length>1?f["right"==n?f.length-1:0]:l.getBoundingClientRect()}if(gl&&vl<9&&!s&&(!i||!i.left&&!i.right)){var h=l.parentNode.getClientRects()[0];i=h?{left:h.left,right:h.left+yr(e.display),top:h.top,bottom:h.bottom}:ms}for(var d=i.top-t.rect.top,p=i.bottom-t.rect.top,g=(d+p)/2,v=t.view.measure.heights,m=0;m<v.length-1&&!(g<v[m]);m++);var y=m?v[m-1]:0,b=v[m],w={left:("right"==u?i.right:i.left)-t.rect.left,right:("left"==u?i.left:i.right)-t.rect.left,top:y,bottom:b};return i.left||i.right||(w.bogus=!0),e.options.singleCursorHeightPerLine||(w.rtop=d,w.rbottom=p),w}function Zt(e,t){if(!window.screen||null==screen.logicalXDPI||screen.logicalXDPI==screen.deviceXDPI||!Re(e))return t;var r=screen.logicalXDPI/screen.deviceXDPI,n=screen.logicalYDPI/screen.deviceYDPI;return{left:t.left*r,right:t.right*r,top:t.top*n,bottom:t.bottom*n}}function Qt(e){if(e.measure&&(e.measure.cache={},e.measure.heights=null,e.rest))for(var t=0;t<e.rest.length;t++)e.measure.caches[t]={}}function Jt(e){e.display.externalMeasure=null,t(e.display.lineMeasure);for(var r=0;r<e.display.view.length;r++)Qt(e.display.view[r])}function er(e){Jt(e),e.display.cachedCharWidth=e.display.cachedTextHeight=e.display.cachedPaddingH=null,e.options.lineWrapping||(e.display.maxLineChanged=!0),e.display.lineNumChars=null}function tr(){return bl&&kl?-(document.body.getBoundingClientRect().left-parseInt(getComputedStyle(document.body).marginLeft)):window.pageXOffset||(document.documentElement||document.body).scrollLeft}function rr(){return bl&&kl?-(document.body.getBoundingClientRect().top-parseInt(getComputedStyle(document.body).marginTop)):window.pageYOffset||(document.documentElement||document.body).scrollTop}function nr(e){var t=0;if(e.widgets)for(var r=0;r<e.widgets.length;++r)e.widgets[r].above&&(t+=Ht(e.widgets[r]));return t}function ir(e,t,r,n,i){if(!i){var o=nr(t);r.top+=o,r.bottom+=o}if("line"==n)return r;n||(n="local");var l=ye(t);if("local"==n?l+=Et(e.display):l-=e.display.viewOffset,"page"==n||"window"==n){var s=e.display.lineSpace.getBoundingClientRect();l+=s.top+("window"==n?0:rr());var a=s.left+("window"==n?0:tr());r.left+=a,r.right+=a}return r.top+=l,r.bottom+=l,r}function or(e,t,r){if("div"==r)return t;var n=t.left,i=t.top;if("page"==r)n-=tr(),i-=rr();else if("local"==r||!r){var o=e.display.sizer.getBoundingClientRect();n+=o.left,i+=o.top}var l=e.display.lineSpace.getBoundingClientRect();return{left:n-l.left,top:i-l.top}}function lr(e,t,r,n,i){return n||(n=M(e.doc,t.line)),ir(e,n,Kt(e,n,t.ch,i),r)}function sr(e,t,r,n,i,o){function l(t,l){var s=Yt(e,i,t,l?"right":"left",o);return l?s.left=s.right:s.right=s.left,ir(e,n,s,r)}function s(e,t,r){var n=1==a[t].level;return l(r?e-1:e,n!=r)}n=n||M(e.doc,t.line),i||(i=Xt(e,n));var a=Se(n,e.doc.direction),u=t.ch,c=t.sticky;if(u>=n.text.length?(u=n.text.length,c="before"):u<=0&&(u=0,c="after"),!a)return l("before"==c?u-1:u,"before"==c);var f=Ce(a,u,c),h=$l,d=s(u,f,"before"==c);return null!=h&&(d.other=s(u,h,"before"!=c)),d}function ar(e,t){var r=0;t=U(e.doc,t),e.options.lineWrapping||(r=yr(e.display)*t.ch);var n=M(e.doc,t.line),i=ye(n)+Et(e.display);return{left:r,right:r,top:i,bottom:i+n.height}}function ur(e,t,r,n,i){var o=E(e,t,r);return o.xRel=i,n&&(o.outside=!0),o}function cr(e,t,r){var n=e.doc;if((r+=e.display.viewOffset)<0)return ur(n.first,0,null,!0,-1);var i=D(n,r),o=n.first+n.size-1;if(i>o)return ur(n.first+n.size-1,M(n,o).text.length,null,!0,1);t<0&&(t=0);for(var l=M(n,i);;){var s=pr(e,l,i,t,r),a=ue(l),u=a&&a.find(0,!0);if(!a||!(s.ch>u.from.ch||s.ch==u.from.ch&&s.xRel>0))return s;i=W(l=u.to.line)}}function fr(e,t,r,n){n-=nr(t);var i=t.text.length,o=k(function(t){return Yt(e,r,t-1).bottom<=n},i,0);return i=k(function(t){return Yt(e,r,t).top>n},o,i),{begin:o,end:i}}function hr(e,t,r,n){return r||(r=Xt(e,t)),fr(e,t,r,ir(e,t,Yt(e,r,n),"line").top)}function dr(e,t,r,n){return!(e.bottom<=r)&&(e.top>r||(n?e.left:e.right)>t)}function pr(e,t,r,n,i){i-=ye(t);var o=Xt(e,t),l=nr(t),s=0,a=t.text.length,u=!0,c=Se(t,e.doc.direction);if(c){var f=(e.options.lineWrapping?vr:gr)(e,t,r,o,c,n,i);s=(u=1!=f.level)?f.from:f.to-1,a=u?f.to:f.from-1}var h,d,p=null,g=null,v=k(function(t){var r=Yt(e,o,t);return r.top+=l,r.bottom+=l,!!dr(r,n,i,!1)&&(r.top<=i&&r.left<=n&&(p=t,g=r),!0)},s,a),m=!1;if(g){var y=n-g.left<g.right-n,b=y==u;v=p+(b?0:1),d=b?"after":"before",h=y?g.left:g.right}else{u||v!=a&&v!=s||v++,d=0==v?"after":v==t.text.length?"before":Yt(e,o,v-(u?1:0)).bottom+l<=i==u?"after":"before";var w=sr(e,E(r,v,d),"line",t,o);h=w.left,m=i<w.top||i>=w.bottom}return v=L(t.text,v,1),ur(r,v,d,m,n-h)}function gr(e,t,r,n,i,o,l){var s=k(function(s){var a=i[s],u=1!=a.level;return dr(sr(e,E(r,u?a.to:a.from,u?"before":"after"),"line",t,n),o,l,!0)},0,i.length-1),a=i[s];if(s>0){var u=1!=a.level,c=sr(e,E(r,u?a.from:a.to,u?"after":"before"),"line",t,n);dr(c,o,l,!0)&&c.top>l&&(a=i[s-1])}return a}function vr(e,t,r,n,i,o,l){for(var s=fr(e,t,n,l),a=s.begin,u=s.end,c=null,f=null,h=0;h<i.length;h++){var d=i[h];if(!(d.from>=u||d.to<=a)){var p=Yt(e,n,1!=d.level?Math.min(u,d.to)-1:Math.max(a,d.from)).right,g=p<o?o-p+1e9:p-o;(!c||f>g)&&(c=d,f=g)}}return c||(c=i[i.length-1]),c.from<a&&(c={from:a,to:c.to,level:c.level}),c.to>u&&(c={from:c.from,to:u,level:c.level}),c}function mr(e){if(null!=e.cachedTextHeight)return e.cachedTextHeight;if(null==hs){hs=n("pre");for(var i=0;i<49;++i)hs.appendChild(document.createTextNode("x")),hs.appendChild(n("br"));hs.appendChild(document.createTextNode("x"))}r(e.measure,hs);var o=hs.offsetHeight/50;return o>3&&(e.cachedTextHeight=o),t(e.measure),o||1}function yr(e){if(null!=e.cachedCharWidth)return e.cachedCharWidth;var t=n("span","xxxxxxxxxx"),i=n("pre",[t]);r(e.measure,i);var o=t.getBoundingClientRect(),l=(o.right-o.left)/10;return l>2&&(e.cachedCharWidth=l),l||10}function br(e){for(var t=e.display,r={},n={},i=t.gutters.clientLeft,o=t.gutters.firstChild,l=0;o;o=o.nextSibling,++l)r[e.options.gutters[l]]=o.offsetLeft+o.clientLeft+i,n[e.options.gutters[l]]=o.clientWidth;return{fixedPos:wr(t),gutterTotalWidth:t.gutters.offsetWidth,gutterLeft:r,gutterWidth:n,wrapperWidth:t.wrapper.clientWidth}}function wr(e){return e.scroller.getBoundingClientRect().left-e.sizer.getBoundingClientRect().left}function xr(e){var t=mr(e.display),r=e.options.lineWrapping,n=r&&Math.max(5,e.display.scroller.clientWidth/yr(e.display)-3);return function(i){if(ve(e.doc,i))return 0;var o=0;if(i.widgets)for(var l=0;l<i.widgets.length;l++)i.widgets[l].height&&(o+=i.widgets[l].height);return r?o+(Math.ceil(i.text.length/n)||1)*t:o+t}}function Cr(e){var t=e.doc,r=xr(e);t.iter(function(e){var t=r(e);t!=e.height&&A(e,t)})}function Sr(e,t,r,n){var i=e.display;if(!r&&"true"==Ee(t).getAttribute("cm-not-content"))return null;var o,l,s=i.lineSpace.getBoundingClientRect();try{o=t.clientX-s.left,l=t.clientY-s.top}catch(t){return null}var a,u=cr(e,o,l);if(n&&1==u.xRel&&(a=M(e.doc,u.line).text).length==u.ch){var c=f(a,a.length,e.options.tabSize)-a.length;u=E(u.line,Math.max(0,Math.round((o-It(e.display).left)/yr(e.display))-c))}return u}function Lr(e,t){if(t>=e.display.viewTo)return null;if((t-=e.display.viewFrom)<0)return null;for(var r=e.display.view,n=0;n<r.length;n++)if((t-=r[n].size)<0)return n}function kr(e){e.display.input.showSelection(e.display.input.prepareSelection())}function Tr(e,t){void 0===t&&(t=!0);for(var r=e.doc,n={},i=n.cursors=document.createDocumentFragment(),o=n.selection=document.createDocumentFragment(),l=0;l<r.sel.ranges.length;l++)if(t||l!=r.sel.primIndex){var s=r.sel.ranges[l];if(!(s.from().line>=e.display.viewTo||s.to().line<e.display.viewFrom)){var a=s.empty();(a||e.options.showCursorWhenSelecting)&&Mr(e,s.head,i),a||Or(e,s,o)}}return n}function Mr(e,t,r){var i=sr(e,t,"div",null,null,!e.options.singleCursorHeightPerLine),o=r.appendChild(n("div"," ","CodeMirror-cursor"));if(o.style.left=i.left+"px",o.style.top=i.top+"px",o.style.height=Math.max(0,i.bottom-i.top)*e.options.cursorHeight+"px",i.other){var l=r.appendChild(n("div"," ","CodeMirror-cursor CodeMirror-secondarycursor"));l.style.display="",l.style.left=i.other.left+"px",l.style.top=i.other.top+"px",l.style.height=.85*(i.other.bottom-i.other.top)+"px"}}function Nr(e,t){return e.top-t.top||e.left-t.left}function Or(e,t,r){function i(e,t,r,i){t<0&&(t=0),t=Math.round(t),i=Math.round(i),a.appendChild(n("div",null,"CodeMirror-selected","position: absolute; left: "+e+"px;\n                             top: "+t+"px; width: "+(null==r?f-e:r)+"px;\n                             height: "+(i-t)+"px"))}function o(t,r,n){function o(r,n){return lr(e,E(t,r),"div",u,n)}var l,a,u=M(s,t),h=u.text.length,d=Se(u,s.direction);return xe(d,r||0,null==n?h:n,function(t,s,p,g){var v=o(t,"ltr"==p?"left":"right"),m=o(s-1,"ltr"==p?"right":"left");if("ltr"==p){var y=null==r&&0==t?c:v.left,b=null==n&&s==h?f:m.right;m.top-v.top<=3?i(y,m.top,b-y,m.bottom):(i(y,v.top,null,v.bottom),v.bottom<m.top&&i(c,v.bottom,null,m.top),i(c,m.top,m.right,m.bottom))}else if(t<s){var w=null==r&&0==t?f:v.right,x=null==n&&s==h?c:m.left;if(m.top-v.top<=3)i(x,m.top,w-x,m.bottom);else{var C=c;if(g){var S=hr(e,u,null,t).end;C=o(S-(/\s/.test(u.text.charAt(S-1))?2:1),"left").left}i(C,v.top,w-C,v.bottom),v.bottom<m.top&&i(c,v.bottom,null,m.top);var L=null;d.length,L=o(hr(e,u,null,s).begin,"right").right-x,i(x,m.top,L,m.bottom)}}(!l||Nr(v,l)<0)&&(l=v),Nr(m,l)<0&&(l=m),(!a||Nr(v,a)<0)&&(a=v),Nr(m,a)<0&&(a=m)}),{start:l,end:a}}var l=e.display,s=e.doc,a=document.createDocumentFragment(),u=It(e.display),c=u.left,f=Math.max(l.sizerWidth,Rt(e)-l.sizer.offsetLeft)-u.right,h=t.from(),d=t.to();if(h.line==d.line)o(h.line,h.ch,d.ch);else{var p=M(s,h.line),g=M(s,d.line),v=fe(p)==fe(g),m=o(h.line,h.ch,v?p.text.length+1:null).end,y=o(d.line,v?0:null,d.ch).start;v&&(m.top<y.top-2?(i(m.right,m.top,null,m.bottom),i(c,y.top,y.left,y.bottom)):i(m.right,m.top,y.left-m.right,m.bottom)),m.bottom<y.top&&i(c,m.bottom,null,y.top)}r.appendChild(a)}function Ar(e){if(e.state.focused){var t=e.display;clearInterval(t.blinker);var r=!0;t.cursorDiv.style.visibility="",e.options.cursorBlinkRate>0?t.blinker=setInterval(function(){return t.cursorDiv.style.visibility=(r=!r)?"":"hidden"},e.options.cursorBlinkRate):e.options.cursorBlinkRate<0&&(t.cursorDiv.style.visibility="hidden")}}function Wr(e){e.state.focused||(e.display.input.focus(),Hr(e))}function Dr(e){e.state.delayingBlurEvent=!0,setTimeout(function(){e.state.delayingBlurEvent&&(e.state.delayingBlurEvent=!1,Fr(e))},100)}function Hr(e,t){e.state.delayingBlurEvent&&(e.state.delayingBlurEvent=!1),"nocursor"!=e.options.readOnly&&(e.state.focused||(Te(e,"focus",e,t),e.state.focused=!0,s(e.display.wrapper,"CodeMirror-focused"),e.curOp||e.display.selForContextMenu==e.doc.sel||(e.display.input.reset(),ml&&setTimeout(function(){return e.display.input.reset(!0)},20)),e.display.input.receivedFocus()),Ar(e))}function Fr(e,t){e.state.delayingBlurEvent||(e.state.focused&&(Te(e,"blur",e,t),e.state.focused=!1,Fl(e.display.wrapper,"CodeMirror-focused")),clearInterval(e.display.blinker),setTimeout(function(){e.state.focused||(e.display.shift=!1)},150))}function Er(e){for(var t=e.display,r=t.lineDiv.offsetTop,n=0;n<t.view.length;n++){var i=t.view[n],o=void 0;if(!i.hidden){if(gl&&vl<8){var l=i.node.offsetTop+i.node.offsetHeight;o=l-r,r=l}else{var s=i.node.getBoundingClientRect();o=s.bottom-s.top}var a=i.line.height-o;if(o<2&&(o=mr(t)),(a>.005||a<-.005)&&(A(i.line,o),Pr(i.line),i.rest))for(var u=0;u<i.rest.length;u++)Pr(i.rest[u])}}}function Pr(e){if(e.widgets)for(var t=0;t<e.widgets.length;++t)e.widgets[t].height=e.widgets[t].node.parentNode.offsetHeight}function Ir(e,t,r){var n=r&&null!=r.top?Math.max(0,r.top):e.scroller.scrollTop;n=Math.floor(n-Et(e));var i=r&&null!=r.bottom?r.bottom:n+e.wrapper.clientHeight,o=D(t,n),l=D(t,i);if(r&&r.ensure){var s=r.ensure.from.line,a=r.ensure.to.line;s<o?(o=s,l=D(t,ye(M(t,s))+e.wrapper.clientHeight)):Math.min(a,t.lastLine())>=l&&(o=D(t,ye(M(t,a))-e.wrapper.clientHeight),l=a)}return{from:o,to:Math.max(l,o+1)}}function zr(e){var t=e.display,r=t.view;if(t.alignWidgets||t.gutters.firstChild&&e.options.fixedGutter){for(var n=wr(t)-t.scroller.scrollLeft+e.doc.scrollLeft,i=t.gutters.offsetWidth,o=n+"px",l=0;l<r.length;l++)if(!r[l].hidden){e.options.fixedGutter&&(r[l].gutter&&(r[l].gutter.style.left=o),r[l].gutterBackground&&(r[l].gutterBackground.style.left=o));var s=r[l].alignable;if(s)for(var a=0;a<s.length;a++)s[a].style.left=o}e.options.fixedGutter&&(t.gutters.style.left=n+i+"px")}}function Rr(e){if(!e.options.lineNumbers)return!1;var t=e.doc,r=F(e.options,t.first+t.size-1),i=e.display;if(r.length!=i.lineNumChars){var o=i.measure.appendChild(n("div",[n("div",r)],"CodeMirror-linenumber CodeMirror-gutter-elt")),l=o.firstChild.offsetWidth,s=o.offsetWidth-l;return i.lineGutter.style.width="",i.lineNumInnerWidth=Math.max(l,i.lineGutter.offsetWidth-s)+1,i.lineNumWidth=i.lineNumInnerWidth+s,i.lineNumChars=i.lineNumInnerWidth?r.length:-1,i.lineGutter.style.width=i.lineNumWidth+"px",Wn(e),!0}return!1}function Br(e,t){if(!Me(e,"scrollCursorIntoView")){var r=e.display,i=r.sizer.getBoundingClientRect(),o=null;if(t.top+i.top<0?o=!0:t.bottom+i.top>(window.innerHeight||document.documentElement.clientHeight)&&(o=!1),null!=o&&!Sl){var l=n("div","​",null,"position: absolute;\n                         top: "+(t.top-r.viewOffset-Et(e.display))+"px;\n                         height: "+(t.bottom-t.top+zt(e)+r.barHeight)+"px;\n                         left: "+t.left+"px; width: "+Math.max(2,t.right-t.left)+"px;");e.display.lineSpace.appendChild(l),l.scrollIntoView(o),e.display.lineSpace.removeChild(l)}}}function Gr(e,t,r,n){null==n&&(n=0);var i;e.options.lineWrapping||t!=r||(r="before"==(t=t.ch?E(t.line,"before"==t.sticky?t.ch-1:t.ch,"after"):t).sticky?E(t.line,t.ch+1,"before"):t);for(var o=0;o<5;o++){var l=!1,s=sr(e,t),a=r&&r!=t?sr(e,r):s,u=Vr(e,i={left:Math.min(s.left,a.left),top:Math.min(s.top,a.top)-n,right:Math.max(s.left,a.left),bottom:Math.max(s.bottom,a.bottom)+n}),c=e.doc.scrollTop,f=e.doc.scrollLeft;if(null!=u.scrollTop&&(qr(e,u.scrollTop),Math.abs(e.doc.scrollTop-c)>1&&(l=!0)),null!=u.scrollLeft&&(Qr(e,u.scrollLeft),Math.abs(e.doc.scrollLeft-f)>1&&(l=!0)),!l)break}return i}function Ur(e,t){var r=Vr(e,t);null!=r.scrollTop&&qr(e,r.scrollTop),null!=r.scrollLeft&&Qr(e,r.scrollLeft)}function Vr(e,t){var r=e.display,n=mr(e.display);t.top<0&&(t.top=0);var i=e.curOp&&null!=e.curOp.scrollTop?e.curOp.scrollTop:r.scroller.scrollTop,o=Bt(e),l={};t.bottom-t.top>o&&(t.bottom=t.top+o);var s=e.doc.height+Pt(r),a=t.top<n,u=t.bottom>s-n;if(t.top<i)l.scrollTop=a?0:t.top;else if(t.bottom>i+o){var c=Math.min(t.top,(u?s:t.bottom)-o);c!=i&&(l.scrollTop=c)}var f=e.curOp&&null!=e.curOp.scrollLeft?e.curOp.scrollLeft:r.scroller.scrollLeft,h=Rt(e)-(e.options.fixedGutter?r.gutters.offsetWidth:0),d=t.right-t.left>h;return d&&(t.right=t.left+h),t.left<10?l.scrollLeft=0:t.left<f?l.scrollLeft=Math.max(0,t.left-(d?0:10)):t.right>h+f-3&&(l.scrollLeft=t.right+(d?0:10)-h),l}function Kr(e,t){null!=t&&(_r(e),e.curOp.scrollTop=(null==e.curOp.scrollTop?e.doc.scrollTop:e.curOp.scrollTop)+t)}function jr(e){_r(e);var t=e.getCursor();e.curOp.scrollToPos={from:t,to:t,margin:e.options.cursorScrollMargin}}function Xr(e,t,r){null==t&&null==r||_r(e),null!=t&&(e.curOp.scrollLeft=t),null!=r&&(e.curOp.scrollTop=r)}function Yr(e,t){_r(e),e.curOp.scrollToPos=t}function _r(e){var t=e.curOp.scrollToPos;t&&(e.curOp.scrollToPos=null,$r(e,ar(e,t.from),ar(e,t.to),t.margin))}function $r(e,t,r,n){var i=Vr(e,{left:Math.min(t.left,r.left),top:Math.min(t.top,r.top)-n,right:Math.max(t.right,r.right),bottom:Math.max(t.bottom,r.bottom)+n});Xr(e,i.scrollLeft,i.scrollTop)}function qr(e,t){Math.abs(e.doc.scrollTop-t)<2||(fl||On(e,{top:t}),Zr(e,t,!0),fl&&On(e),Cn(e,100))}function Zr(e,t,r){t=Math.min(e.display.scroller.scrollHeight-e.display.scroller.clientHeight,t),(e.display.scroller.scrollTop!=t||r)&&(e.doc.scrollTop=t,e.display.scrollbars.setScrollTop(t),e.display.scroller.scrollTop!=t&&(e.display.scroller.scrollTop=t))}function Qr(e,t,r,n){t=Math.min(t,e.display.scroller.scrollWidth-e.display.scroller.clientWidth),(r?t==e.doc.scrollLeft:Math.abs(e.doc.scrollLeft-t)<2)&&!n||(e.doc.scrollLeft=t,zr(e),e.display.scroller.scrollLeft!=t&&(e.display.scroller.scrollLeft=t),e.display.scrollbars.setScrollLeft(t))}function Jr(e){var t=e.display,r=t.gutters.offsetWidth,n=Math.round(e.doc.height+Pt(e.display));return{clientHeight:t.scroller.clientHeight,viewHeight:t.wrapper.clientHeight,scrollWidth:t.scroller.scrollWidth,clientWidth:t.scroller.clientWidth,viewWidth:t.wrapper.clientWidth,barLeft:e.options.fixedGutter?r:0,docHeight:n,scrollHeight:n+zt(e)+t.barHeight,nativeBarWidth:t.nativeBarWidth,gutterWidth:r}}function en(e,t){t||(t=Jr(e));var r=e.display.barWidth,n=e.display.barHeight;tn(e,t);for(var i=0;i<4&&r!=e.display.barWidth||n!=e.display.barHeight;i++)r!=e.display.barWidth&&e.options.lineWrapping&&Er(e),tn(e,Jr(e)),r=e.display.barWidth,n=e.display.barHeight}function tn(e,t){var r=e.display,n=r.scrollbars.update(t);r.sizer.style.paddingRight=(r.barWidth=n.right)+"px",r.sizer.style.paddingBottom=(r.barHeight=n.bottom)+"px",r.heightForcer.style.borderBottom=n.bottom+"px solid transparent",n.right&&n.bottom?(r.scrollbarFiller.style.display="block",r.scrollbarFiller.style.height=n.bottom+"px",r.scrollbarFiller.style.width=n.right+"px"):r.scrollbarFiller.style.display="",n.bottom&&e.options.coverGutterNextToScrollbar&&e.options.fixedGutter?(r.gutterFiller.style.display="block",r.gutterFiller.style.height=n.bottom+"px",r.gutterFiller.style.width=t.gutterWidth+"px"):r.gutterFiller.style.display=""}function rn(e){e.display.scrollbars&&(e.display.scrollbars.clear(),e.display.scrollbars.addClass&&Fl(e.display.wrapper,e.display.scrollbars.addClass)),e.display.scrollbars=new ws[e.options.scrollbarStyle](function(t){e.display.wrapper.insertBefore(t,e.display.scrollbarFiller),Ql(t,"mousedown",function(){e.state.focused&&setTimeout(function(){return e.display.input.focus()},0)}),t.setAttribute("cm-not-content","true")},function(t,r){"horizontal"==r?Qr(e,t):qr(e,t)},e),e.display.scrollbars.addClass&&s(e.display.wrapper,e.display.scrollbars.addClass)}function nn(e){e.curOp={cm:e,viewChanged:!1,startHeight:e.doc.height,forceUpdate:!1,updateInput:null,typing:!1,changeObjs:null,cursorActivityHandlers:null,cursorActivityCalled:0,selectionChanged:!1,updateMaxLine:!1,scrollLeft:null,scrollTop:null,scrollToPos:null,focus:!1,id:++xs},vt(e.curOp)}function on(e){yt(e.curOp,function(e){for(var t=0;t<e.ops.length;t++)e.ops[t].cm.curOp=null;ln(e)})}function ln(e){for(var t=e.ops,r=0;r<t.length;r++)sn(t[r]);for(var n=0;n<t.length;n++)an(t[n]);for(var i=0;i<t.length;i++)un(t[i]);for(var o=0;o<t.length;o++)cn(t[o]);for(var l=0;l<t.length;l++)fn(t[l])}function sn(e){var t=e.cm,r=t.display;Ln(t),e.updateMaxLine&&we(t),e.mustUpdate=e.viewChanged||e.forceUpdate||null!=e.scrollTop||e.scrollToPos&&(e.scrollToPos.from.line<r.viewFrom||e.scrollToPos.to.line>=r.viewTo)||r.maxLineChanged&&t.options.lineWrapping,e.update=e.mustUpdate&&new Cs(t,e.mustUpdate&&{top:e.scrollTop,ensure:e.scrollToPos},e.forceUpdate)}function an(e){e.updatedDisplay=e.mustUpdate&&Mn(e.cm,e.update)}function un(e){var t=e.cm,r=t.display;e.updatedDisplay&&Er(t),e.barMeasure=Jr(t),r.maxLineChanged&&!t.options.lineWrapping&&(e.adjustWidthTo=Kt(t,r.maxLine,r.maxLine.text.length).left+3,t.display.sizerWidth=e.adjustWidthTo,e.barMeasure.scrollWidth=Math.max(r.scroller.clientWidth,r.sizer.offsetLeft+e.adjustWidthTo+zt(t)+t.display.barWidth),e.maxScrollLeft=Math.max(0,r.sizer.offsetLeft+e.adjustWidthTo-Rt(t))),(e.updatedDisplay||e.selectionChanged)&&(e.preparedSelection=r.input.prepareSelection())}function cn(e){var t=e.cm;null!=e.adjustWidthTo&&(t.display.sizer.style.minWidth=e.adjustWidthTo+"px",e.maxScrollLeft<t.doc.scrollLeft&&Qr(t,Math.min(t.display.scroller.scrollLeft,e.maxScrollLeft),!0),t.display.maxLineChanged=!1);var r=e.focus&&e.focus==l();e.preparedSelection&&t.display.input.showSelection(e.preparedSelection,r),(e.updatedDisplay||e.startHeight!=t.doc.height)&&en(t,e.barMeasure),e.updatedDisplay&&Dn(t,e.barMeasure),e.selectionChanged&&Ar(t),t.state.focused&&e.updateInput&&t.display.input.reset(e.typing),r&&Wr(e.cm)}function fn(e){var t=e.cm,r=t.display,n=t.doc;e.updatedDisplay&&Nn(t,e.update),null==r.wheelStartX||null==e.scrollTop&&null==e.scrollLeft&&!e.scrollToPos||(r.wheelStartX=r.wheelStartY=null),null!=e.scrollTop&&Zr(t,e.scrollTop,e.forceScroll),null!=e.scrollLeft&&Qr(t,e.scrollLeft,!0,!0),e.scrollToPos&&Br(t,Gr(t,U(n,e.scrollToPos.from),U(n,e.scrollToPos.to),e.scrollToPos.margin));var i=e.maybeHiddenMarkers,o=e.maybeUnhiddenMarkers;if(i)for(var l=0;l<i.length;++l)i[l].lines.length||Te(i[l],"hide");if(o)for(var s=0;s<o.length;++s)o[s].lines.length&&Te(o[s],"unhide");r.wrapper.offsetHeight&&(n.scrollTop=t.display.scroller.scrollTop),e.changeObjs&&Te(t,"changes",t,e.changeObjs),e.update&&e.update.finish()}function hn(e,t){if(e.curOp)return t();nn(e);try{return t()}finally{on(e)}}function dn(e,t){return function(){if(e.curOp)return t.apply(e,arguments);nn(e);try{return t.apply(e,arguments)}finally{on(e)}}}function pn(e){return function(){if(this.curOp)return e.apply(this,arguments);nn(this);try{return e.apply(this,arguments)}finally{on(this)}}}function gn(e){return function(){var t=this.cm;if(!t||t.curOp)return e.apply(this,arguments);nn(t);try{return e.apply(this,arguments)}finally{on(t)}}}function vn(e,t,r,n){null==t&&(t=e.doc.first),null==r&&(r=e.doc.first+e.doc.size),n||(n=0);var i=e.display;if(n&&r<i.viewTo&&(null==i.updateLineNumbers||i.updateLineNumbers>t)&&(i.updateLineNumbers=t),e.curOp.viewChanged=!0,t>=i.viewTo)_l&&pe(e.doc,t)<i.viewTo&&yn(e);else if(r<=i.viewFrom)_l&&ge(e.doc,r+n)>i.viewFrom?yn(e):(i.viewFrom+=n,i.viewTo+=n);else if(t<=i.viewFrom&&r>=i.viewTo)yn(e);else if(t<=i.viewFrom){var o=bn(e,r,r+n,1);o?(i.view=i.view.slice(o.index),i.viewFrom=o.lineN,i.viewTo+=n):yn(e)}else if(r>=i.viewTo){var l=bn(e,t,t,-1);l?(i.view=i.view.slice(0,l.index),i.viewTo=l.lineN):yn(e)}else{var s=bn(e,t,t,-1),a=bn(e,r,r+n,1);s&&a?(i.view=i.view.slice(0,s.index).concat(gt(e,s.lineN,a.lineN)).concat(i.view.slice(a.index)),i.viewTo+=n):yn(e)}var u=i.externalMeasured;u&&(r<u.lineN?u.lineN+=n:t<u.lineN+u.size&&(i.externalMeasured=null))}function mn(e,t,r){e.curOp.viewChanged=!0;var n=e.display,i=e.display.externalMeasured;if(i&&t>=i.lineN&&t<i.lineN+i.size&&(n.externalMeasured=null),!(t<n.viewFrom||t>=n.viewTo)){var o=n.view[Lr(e,t)];if(null!=o.node){var l=o.changes||(o.changes=[]);-1==h(l,r)&&l.push(r)}}}function yn(e){e.display.viewFrom=e.display.viewTo=e.doc.first,e.display.view=[],e.display.viewOffset=0}function bn(e,t,r,n){var i,o=Lr(e,t),l=e.display.view;if(!_l||r==e.doc.first+e.doc.size)return{index:o,lineN:r};for(var s=e.display.viewFrom,a=0;a<o;a++)s+=l[a].size;if(s!=t){if(n>0){if(o==l.length-1)return null;i=s+l[o].size-t,o++}else i=s-t;t+=i,r+=i}for(;pe(e.doc,r)!=r;){if(o==(n<0?0:l.length-1))return null;r+=n*l[o-(n<0?1:0)].size,o+=n}return{index:o,lineN:r}}function wn(e,t,r){var n=e.display;0==n.view.length||t>=n.viewTo||r<=n.viewFrom?(n.view=gt(e,t,r),n.viewFrom=t):(n.viewFrom>t?n.view=gt(e,t,n.viewFrom).concat(n.view):n.viewFrom<t&&(n.view=n.view.slice(Lr(e,t))),n.viewFrom=t,n.viewTo<r?n.view=n.view.concat(gt(e,n.viewTo,r)):n.viewTo>r&&(n.view=n.view.slice(0,Lr(e,r)))),n.viewTo=r}function xn(e){for(var t=e.display.view,r=0,n=0;n<t.length;n++){var i=t[n];i.hidden||i.node&&!i.changes||++r}return r}function Cn(e,t){e.doc.highlightFrontier<e.display.viewTo&&e.state.highlight.set(t,u(Sn,e))}function Sn(e){var t=e.doc;if(!(t.highlightFrontier>=e.display.viewTo)){var r=+new Date+e.options.workTime,n=$e(e,t.highlightFrontier),i=[];t.iter(n.line,Math.min(t.first+t.size,e.display.viewTo+500),function(o){if(n.line>=e.display.viewFrom){var l=o.styles,s=o.text.length>e.options.maxHighlightLength?Ke(t.mode,n.state):null,a=Ye(e,o,n,!0);s&&(n.state=s),o.styles=a.styles;var u=o.styleClasses,c=a.classes;c?o.styleClasses=c:u&&(o.styleClasses=null);for(var f=!l||l.length!=o.styles.length||u!=c&&(!u||!c||u.bgClass!=c.bgClass||u.textClass!=c.textClass),h=0;!f&&h<l.length;++h)f=l[h]!=o.styles[h];f&&i.push(n.line),o.stateAfter=n.save(),n.nextLine()}else o.text.length<=e.options.maxHighlightLength&&qe(e,o.text,n),o.stateAfter=n.line%5==0?n.save():null,n.nextLine();if(+new Date>r)return Cn(e,e.options.workDelay),!0}),t.highlightFrontier=n.line,t.modeFrontier=Math.max(t.modeFrontier,n.line),i.length&&hn(e,function(){for(var t=0;t<i.length;t++)mn(e,i[t],"text")})}}function Ln(e){var t=e.display;!t.scrollbarsClipped&&t.scroller.offsetWidth&&(t.nativeBarWidth=t.scroller.offsetWidth-t.scroller.clientWidth,t.heightForcer.style.height=zt(e)+"px",t.sizer.style.marginBottom=-t.nativeBarWidth+"px",t.sizer.style.borderRightWidth=zt(e)+"px",t.scrollbarsClipped=!0)}function kn(e){if(e.hasFocus())return null;var t=l();if(!t||!o(e.display.lineDiv,t))return null;var r={activeElt:t};if(window.getSelection){var n=window.getSelection();n.anchorNode&&n.extend&&o(e.display.lineDiv,n.anchorNode)&&(r.anchorNode=n.anchorNode,r.anchorOffset=n.anchorOffset,r.focusNode=n.focusNode,r.focusOffset=n.focusOffset)}return r}function Tn(e){if(e&&e.activeElt&&e.activeElt!=l()&&(e.activeElt.focus(),e.anchorNode&&o(document.body,e.anchorNode)&&o(document.body,e.focusNode))){var t=window.getSelection(),r=document.createRange();r.setEnd(e.anchorNode,e.anchorOffset),r.collapse(!1),t.removeAllRanges(),t.addRange(r),t.extend(e.focusNode,e.focusOffset)}}function Mn(e,r){var n=e.display,i=e.doc;if(r.editorIsHidden)return yn(e),!1;if(!r.force&&r.visible.from>=n.viewFrom&&r.visible.to<=n.viewTo&&(null==n.updateLineNumbers||n.updateLineNumbers>=n.viewTo)&&n.renderedView==n.view&&0==xn(e))return!1;Rr(e)&&(yn(e),r.dims=br(e));var o=i.first+i.size,l=Math.max(r.visible.from-e.options.viewportMargin,i.first),s=Math.min(o,r.visible.to+e.options.viewportMargin);n.viewFrom<l&&l-n.viewFrom<20&&(l=Math.max(i.first,n.viewFrom)),n.viewTo>s&&n.viewTo-s<20&&(s=Math.min(o,n.viewTo)),_l&&(l=pe(e.doc,l),s=ge(e.doc,s));var a=l!=n.viewFrom||s!=n.viewTo||n.lastWrapHeight!=r.wrapperHeight||n.lastWrapWidth!=r.wrapperWidth;wn(e,l,s),n.viewOffset=ye(M(e.doc,n.viewFrom)),e.display.mover.style.top=n.viewOffset+"px";var u=xn(e);if(!a&&0==u&&!r.force&&n.renderedView==n.view&&(null==n.updateLineNumbers||n.updateLineNumbers>=n.viewTo))return!1;var c=kn(e);return u>4&&(n.lineDiv.style.display="none"),An(e,n.updateLineNumbers,r.dims),u>4&&(n.lineDiv.style.display=""),n.renderedView=n.view,Tn(c),t(n.cursorDiv),t(n.selectionDiv),n.gutters.style.height=n.sizer.style.minHeight=0,a&&(n.lastWrapHeight=r.wrapperHeight,n.lastWrapWidth=r.wrapperWidth,Cn(e,400)),n.updateLineNumbers=null,!0}function Nn(e,t){for(var r=t.viewport,n=!0;(n&&e.options.lineWrapping&&t.oldDisplayWidth!=Rt(e)||(r&&null!=r.top&&(r={top:Math.min(e.doc.height+Pt(e.display)-Bt(e),r.top)}),t.visible=Ir(e.display,e.doc,r),!(t.visible.from>=e.display.viewFrom&&t.visible.to<=e.display.viewTo)))&&Mn(e,t);n=!1){Er(e);var i=Jr(e);kr(e),en(e,i),Dn(e,i),t.force=!1}t.signal(e,"update",e),e.display.viewFrom==e.display.reportedViewFrom&&e.display.viewTo==e.display.reportedViewTo||(t.signal(e,"viewportChange",e,e.display.viewFrom,e.display.viewTo),e.display.reportedViewFrom=e.display.viewFrom,e.display.reportedViewTo=e.display.viewTo)}function On(e,t){var r=new Cs(e,t);if(Mn(e,r)){Er(e),Nn(e,r);var n=Jr(e);kr(e),en(e,n),Dn(e,n),r.finish()}}function An(e,r,n){function i(t){var r=t.nextSibling;return ml&&Ml&&e.display.currentWheelTarget==t?t.style.display="none":t.parentNode.removeChild(t),r}for(var o=e.display,l=e.options.lineNumbers,s=o.lineDiv,a=s.firstChild,u=o.view,c=o.viewFrom,f=0;f<u.length;f++){var d=u[f];if(d.hidden);else if(d.node&&d.node.parentNode==s){for(;a!=d.node;)a=i(a);var p=l&&null!=r&&r<=c&&d.lineNumber;d.changes&&(h(d.changes,"gutter")>-1&&(p=!1),xt(e,d,c,n)),p&&(t(d.lineNumber),d.lineNumber.appendChild(document.createTextNode(F(e.options,c)))),a=d.node.nextSibling}else{var g=Ot(e,d,c,n);s.insertBefore(g,a)}c+=d.size}for(;a;)a=i(a)}function Wn(e){var t=e.display.gutters.offsetWidth;e.display.sizer.style.marginLeft=t+"px"}function Dn(e,t){e.display.sizer.style.minHeight=t.docHeight+"px",e.display.heightForcer.style.top=t.docHeight+"px",e.display.gutters.style.height=t.docHeight+e.display.barHeight+zt(e)+"px"}function Hn(e){var r=e.display.gutters,i=e.options.gutters;t(r);for(var o=0;o<i.length;++o){var l=i[o],s=r.appendChild(n("div",null,"CodeMirror-gutter "+l));"CodeMirror-linenumbers"==l&&(e.display.lineGutter=s,s.style.width=(e.display.lineNumWidth||1)+"px")}r.style.display=o?"":"none",Wn(e)}function Fn(e){var t=h(e.gutters,"CodeMirror-linenumbers");-1==t&&e.lineNumbers?e.gutters=e.gutters.concat(["CodeMirror-linenumbers"]):t>-1&&!e.lineNumbers&&(e.gutters=e.gutters.slice(0),e.gutters.splice(t,1))}function En(e){var t=e.wheelDeltaX,r=e.wheelDeltaY;return null==t&&e.detail&&e.axis==e.HORIZONTAL_AXIS&&(t=e.detail),null==r&&e.detail&&e.axis==e.VERTICAL_AXIS?r=e.detail:null==r&&(r=e.wheelDelta),{x:t,y:r}}function Pn(e){var t=En(e);return t.x*=Ls,t.y*=Ls,t}function In(e,t){var r=En(t),n=r.x,i=r.y,o=e.display,l=o.scroller,s=l.scrollWidth>l.clientWidth,a=l.scrollHeight>l.clientHeight;if(n&&s||i&&a){if(i&&Ml&&ml)e:for(var u=t.target,c=o.view;u!=l;u=u.parentNode)for(var f=0;f<c.length;f++)if(c[f].node==u){e.display.currentWheelTarget=u;break e}if(n&&!fl&&!wl&&null!=Ls)return i&&a&&qr(e,Math.max(0,l.scrollTop+i*Ls)),Qr(e,Math.max(0,l.scrollLeft+n*Ls)),(!i||i&&a)&&We(t),void(o.wheelStartX=null);if(i&&null!=Ls){var h=i*Ls,d=e.doc.scrollTop,p=d+o.wrapper.clientHeight;h<0?d=Math.max(0,d+h-50):p=Math.min(e.doc.height,p+h+50),On(e,{top:d,bottom:p})}Ss<20&&(null==o.wheelStartX?(o.wheelStartX=l.scrollLeft,o.wheelStartY=l.scrollTop,o.wheelDX=n,o.wheelDY=i,setTimeout(function(){if(null!=o.wheelStartX){var e=l.scrollLeft-o.wheelStartX,t=l.scrollTop-o.wheelStartY,r=t&&o.wheelDY&&t/o.wheelDY||e&&o.wheelDX&&e/o.wheelDX;o.wheelStartX=o.wheelStartY=null,r&&(Ls=(Ls*Ss+r)/(Ss+1),++Ss)}},200)):(o.wheelDX+=n,o.wheelDY+=i))}}function zn(e,t){var r=e[t];e.sort(function(e,t){return P(e.from(),t.from())}),t=h(e,r);for(var n=1;n<e.length;n++){var i=e[n],o=e[n-1];if(P(o.to(),i.from())>=0){var l=B(o.from(),i.from()),s=R(o.to(),i.to()),a=o.empty()?i.from()==i.head:o.from()==o.head;n<=t&&--t,e.splice(--n,2,new Ts(a?s:l,a?l:s))}}return new ks(e,t)}function Rn(e,t){return new ks([new Ts(e,t||e)],0)}function Bn(e){return e.text?E(e.from.line+e.text.length-1,g(e.text).length+(1==e.text.length?e.from.ch:0)):e.to}function Gn(e,t){if(P(e,t.from)<0)return e;if(P(e,t.to)<=0)return Bn(t);var r=e.line+t.text.length-(t.to.line-t.from.line)-1,n=e.ch;return e.line==t.to.line&&(n+=Bn(t).ch-t.to.ch),E(r,n)}function Un(e,t){for(var r=[],n=0;n<e.sel.ranges.length;n++){var i=e.sel.ranges[n];r.push(new Ts(Gn(i.anchor,t),Gn(i.head,t)))}return zn(r,e.sel.primIndex)}function Vn(e,t,r){return e.line==t.line?E(r.line,e.ch-t.ch+r.ch):E(r.line+(e.line-t.line),e.ch)}function Kn(e,t,r){for(var n=[],i=E(e.first,0),o=i,l=0;l<t.length;l++){var s=t[l],a=Vn(s.from,i,o),u=Vn(Bn(s),i,o);if(i=s.to,o=u,"around"==r){var c=e.sel.ranges[l],f=P(c.head,c.anchor)<0;n[l]=new Ts(f?u:a,f?a:u)}else n[l]=new Ts(a,a)}return new ks(n,e.sel.primIndex)}function jn(e){e.doc.mode=Ue(e.options,e.doc.modeOption),Xn(e)}function Xn(e){e.doc.iter(function(e){e.stateAfter&&(e.stateAfter=null),e.styles&&(e.styles=null)}),e.doc.modeFrontier=e.doc.highlightFrontier=e.doc.first,Cn(e,100),e.state.modeGen++,e.curOp&&vn(e)}function Yn(e,t){return 0==t.from.ch&&0==t.to.ch&&""==g(t.text)&&(!e.cm||e.cm.options.wholeLineUpdateBefore)}function _n(e,t,r,n){function i(e){return r?r[e]:null}function o(e,r,i){it(e,r,i,n),bt(e,"change",e,t)}function l(e,t){for(var r=[],o=e;o<t;++o)r.push(new fs(u[o],i(o),n));return r}var s=t.from,a=t.to,u=t.text,c=M(e,s.line),f=M(e,a.line),h=g(u),d=i(u.length-1),p=a.line-s.line;if(t.full)e.insert(0,l(0,u.length)),e.remove(u.length,e.size-u.length);else if(Yn(e,t)){var v=l(0,u.length-1);o(f,f.text,d),p&&e.remove(s.line,p),v.length&&e.insert(s.line,v)}else if(c==f)if(1==u.length)o(c,c.text.slice(0,s.ch)+h+c.text.slice(a.ch),d);else{var m=l(1,u.length-1);m.push(new fs(h+c.text.slice(a.ch),d,n)),o(c,c.text.slice(0,s.ch)+u[0],i(0)),e.insert(s.line+1,m)}else if(1==u.length)o(c,c.text.slice(0,s.ch)+u[0]+f.text.slice(a.ch),i(0)),e.remove(s.line+1,p);else{o(c,c.text.slice(0,s.ch)+u[0],i(0)),o(f,h+f.text.slice(a.ch),d);var y=l(1,u.length-1);p>1&&e.remove(s.line+1,p-1),e.insert(s.line+1,y)}bt(e,"change",e,t)}function $n(e,t,r){function n(e,i,o){if(e.linked)for(var l=0;l<e.linked.length;++l){var s=e.linked[l];if(s.doc!=i){var a=o&&s.sharedHist;r&&!a||(t(s.doc,a),n(s.doc,e,a))}}}n(e,null,!0)}function qn(e,t){if(t.cm)throw new Error("This document is already in use.");e.doc=t,t.cm=e,Cr(e),jn(e),Zn(e),e.options.lineWrapping||we(e),e.options.mode=t.modeOption,vn(e)}function Zn(e){("rtl"==e.doc.direction?s:Fl)(e.display.lineDiv,"CodeMirror-rtl")}function Qn(e){hn(e,function(){Zn(e),vn(e)})}function Jn(e){this.done=[],this.undone=[],this.undoDepth=1/0,this.lastModTime=this.lastSelTime=0,this.lastOp=this.lastSelOp=null,this.lastOrigin=this.lastSelOrigin=null,this.generation=this.maxGeneration=e||1}function ei(e,t){var r={from:z(t.from),to:Bn(t),text:N(e,t.from,t.to)};return si(e,r,t.from.line,t.to.line+1),$n(e,function(e){return si(e,r,t.from.line,t.to.line+1)},!0),r}function ti(e){for(;e.length&&g(e).ranges;)e.pop()}function ri(e,t){return t?(ti(e.done),g(e.done)):e.done.length&&!g(e.done).ranges?g(e.done):e.done.length>1&&!e.done[e.done.length-2].ranges?(e.done.pop(),g(e.done)):void 0}function ni(e,t,r,n){var i=e.history;i.undone.length=0;var o,l,s=+new Date;if((i.lastOp==n||i.lastOrigin==t.origin&&t.origin&&("+"==t.origin.charAt(0)&&e.cm&&i.lastModTime>s-e.cm.options.historyEventDelay||"*"==t.origin.charAt(0)))&&(o=ri(i,i.lastOp==n)))l=g(o.changes),0==P(t.from,t.to)&&0==P(t.from,l.to)?l.to=Bn(t):o.changes.push(ei(e,t));else{var a=g(i.done);for(a&&a.ranges||li(e.sel,i.done),o={changes:[ei(e,t)],generation:i.generation},i.done.push(o);i.done.length>i.undoDepth;)i.done.shift(),i.done[0].ranges||i.done.shift()}i.done.push(r),i.generation=++i.maxGeneration,i.lastModTime=i.lastSelTime=s,i.lastOp=i.lastSelOp=n,i.lastOrigin=i.lastSelOrigin=t.origin,l||Te(e,"historyAdded")}function ii(e,t,r,n){var i=t.charAt(0);return"*"==i||"+"==i&&r.ranges.length==n.ranges.length&&r.somethingSelected()==n.somethingSelected()&&new Date-e.history.lastSelTime<=(e.cm?e.cm.options.historyEventDelay:500)}function oi(e,t,r,n){var i=e.history,o=n&&n.origin;r==i.lastSelOp||o&&i.lastSelOrigin==o&&(i.lastModTime==i.lastSelTime&&i.lastOrigin==o||ii(e,o,g(i.done),t))?i.done[i.done.length-1]=t:li(t,i.done),i.lastSelTime=+new Date,i.lastSelOrigin=o,i.lastSelOp=r,n&&!1!==n.clearRedo&&ti(i.undone)}function li(e,t){var r=g(t);r&&r.ranges&&r.equals(e)||t.push(e)}function si(e,t,r,n){var i=t["spans_"+e.id],o=0;e.iter(Math.max(e.first,r),Math.min(e.first+e.size,n),function(r){r.markedSpans&&((i||(i=t["spans_"+e.id]={}))[o]=r.markedSpans),++o})}function ai(e){if(!e)return null;for(var t,r=0;r<e.length;++r)e[r].marker.explicitlyCleared?t||(t=e.slice(0,r)):t&&t.push(e[r]);return t?t.length?t:null:e}function ui(e,t){var r=t["spans_"+e.id];if(!r)return null;for(var n=[],i=0;i<t.text.length;++i)n.push(ai(r[i]));return n}function ci(e,t){var r=ui(e,t),n=J(e,t);if(!r)return n;if(!n)return r;for(var i=0;i<r.length;++i){var o=r[i],l=n[i];if(o&&l)e:for(var s=0;s<l.length;++s){for(var a=l[s],u=0;u<o.length;++u)if(o[u].marker==a.marker)continue e;o.push(a)}else l&&(r[i]=l)}return r}function fi(e,t,r){for(var n=[],i=0;i<e.length;++i){var o=e[i];if(o.ranges)n.push(r?ks.prototype.deepCopy.call(o):o);else{var l=o.changes,s=[];n.push({changes:s});for(var a=0;a<l.length;++a){var u=l[a],c=void 0;if(s.push({from:u.from,to:u.to,text:u.text}),t)for(var f in u)(c=f.match(/^spans_(\d+)$/))&&h(t,Number(c[1]))>-1&&(g(s)[f]=u[f],delete u[f])}}}return n}function hi(e,t,r,n){if(n){var i=e.anchor;if(r){var o=P(t,i)<0;o!=P(r,i)<0?(i=t,t=r):o!=P(t,r)<0&&(t=r)}return new Ts(i,t)}return new Ts(r||t,t)}function di(e,t,r,n,i){null==i&&(i=e.cm&&(e.cm.display.shift||e.extend)),bi(e,new ks([hi(e.sel.primary(),t,r,i)],0),n)}function pi(e,t,r){for(var n=[],i=e.cm&&(e.cm.display.shift||e.extend),o=0;o<e.sel.ranges.length;o++)n[o]=hi(e.sel.ranges[o],t[o],null,i);bi(e,zn(n,e.sel.primIndex),r)}function gi(e,t,r,n){var i=e.sel.ranges.slice(0);i[t]=r,bi(e,zn(i,e.sel.primIndex),n)}function vi(e,t,r,n){bi(e,Rn(t,r),n)}function mi(e,t,r){var n={ranges:t.ranges,update:function(t){var r=this;this.ranges=[];for(var n=0;n<t.length;n++)r.ranges[n]=new Ts(U(e,t[n].anchor),U(e,t[n].head))},origin:r&&r.origin};return Te(e,"beforeSelectionChange",e,n),e.cm&&Te(e.cm,"beforeSelectionChange",e.cm,n),n.ranges!=t.ranges?zn(n.ranges,n.ranges.length-1):t}function yi(e,t,r){var n=e.history.done,i=g(n);i&&i.ranges?(n[n.length-1]=t,wi(e,t,r)):bi(e,t,r)}function bi(e,t,r){wi(e,t,r),oi(e,e.sel,e.cm?e.cm.curOp.id:NaN,r)}function wi(e,t,r){(Oe(e,"beforeSelectionChange")||e.cm&&Oe(e.cm,"beforeSelectionChange"))&&(t=mi(e,t,r)),xi(e,Si(e,t,r&&r.bias||(P(t.primary().head,e.sel.primary().head)<0?-1:1),!0)),r&&!1===r.scroll||!e.cm||jr(e.cm)}function xi(e,t){t.equals(e.sel)||(e.sel=t,e.cm&&(e.cm.curOp.updateInput=e.cm.curOp.selectionChanged=!0,Ne(e.cm)),bt(e,"cursorActivity",e))}function Ci(e){xi(e,Si(e,e.sel,null,!1))}function Si(e,t,r,n){for(var i,o=0;o<t.ranges.length;o++){var l=t.ranges[o],s=t.ranges.length==e.sel.ranges.length&&e.sel.ranges[o],a=ki(e,l.anchor,s&&s.anchor,r,n),u=ki(e,l.head,s&&s.head,r,n);(i||a!=l.anchor||u!=l.head)&&(i||(i=t.ranges.slice(0,o)),i[o]=new Ts(a,u))}return i?zn(i,t.primIndex):t}function Li(e,t,r,n,i){var o=M(e,t.line);if(o.markedSpans)for(var l=0;l<o.markedSpans.length;++l){var s=o.markedSpans[l],a=s.marker;if((null==s.from||(a.inclusiveLeft?s.from<=t.ch:s.from<t.ch))&&(null==s.to||(a.inclusiveRight?s.to>=t.ch:s.to>t.ch))){if(i&&(Te(a,"beforeCursorEnter"),a.explicitlyCleared)){if(o.markedSpans){--l;continue}break}if(!a.atomic)continue;if(r){var u=a.find(n<0?1:-1),c=void 0;if((n<0?a.inclusiveRight:a.inclusiveLeft)&&(u=Ti(e,u,-n,u&&u.line==t.line?o:null)),u&&u.line==t.line&&(c=P(u,r))&&(n<0?c<0:c>0))return Li(e,u,t,n,i)}var f=a.find(n<0?-1:1);return(n<0?a.inclusiveLeft:a.inclusiveRight)&&(f=Ti(e,f,n,f.line==t.line?o:null)),f?Li(e,f,t,n,i):null}}return t}function ki(e,t,r,n,i){var o=n||1,l=Li(e,t,r,o,i)||!i&&Li(e,t,r,o,!0)||Li(e,t,r,-o,i)||!i&&Li(e,t,r,-o,!0);return l||(e.cantEdit=!0,E(e.first,0))}function Ti(e,t,r,n){return r<0&&0==t.ch?t.line>e.first?U(e,E(t.line-1)):null:r>0&&t.ch==(n||M(e,t.line)).text.length?t.line<e.first+e.size-1?E(t.line+1,0):null:new E(t.line,t.ch+r)}function Mi(e){e.setSelection(E(e.firstLine(),0),E(e.lastLine()),Gl)}function Ni(e,t,r){var n={canceled:!1,from:t.from,to:t.to,text:t.text,origin:t.origin,cancel:function(){return n.canceled=!0}};return r&&(n.update=function(t,r,i,o){t&&(n.from=U(e,t)),r&&(n.to=U(e,r)),i&&(n.text=i),void 0!==o&&(n.origin=o)}),Te(e,"beforeChange",e,n),e.cm&&Te(e.cm,"beforeChange",e.cm,n),n.canceled?null:{from:n.from,to:n.to,text:n.text,origin:n.origin}}function Oi(e,t,r){if(e.cm){if(!e.cm.curOp)return dn(e.cm,Oi)(e,t,r);if(e.cm.state.suppressEdits)return}if(!(Oe(e,"beforeChange")||e.cm&&Oe(e.cm,"beforeChange"))||(t=Ni(e,t,!0))){var n=Yl&&!r&&te(e,t.from,t.to);if(n)for(var i=n.length-1;i>=0;--i)Ai(e,{from:n[i].from,to:n[i].to,text:i?[""]:t.text,origin:t.origin});else Ai(e,t)}}function Ai(e,t){if(1!=t.text.length||""!=t.text[0]||0!=P(t.from,t.to)){var r=Un(e,t);ni(e,t,r,e.cm?e.cm.curOp.id:NaN),Hi(e,t,r,J(e,t));var n=[];$n(e,function(e,r){r||-1!=h(n,e.history)||(zi(e.history,t),n.push(e.history)),Hi(e,t,null,J(e,t))})}}function Wi(e,t,r){if(!e.cm||!e.cm.state.suppressEdits||r){for(var n,i=e.history,o=e.sel,l="undo"==t?i.done:i.undone,s="undo"==t?i.undone:i.done,a=0;a<l.length&&(n=l[a],r?!n.ranges||n.equals(e.sel):n.ranges);a++);if(a!=l.length){for(i.lastOrigin=i.lastSelOrigin=null;(n=l.pop()).ranges;){if(li(n,s),r&&!n.equals(e.sel))return void bi(e,n,{clearRedo:!1});o=n}var u=[];li(o,s),s.push({changes:u,generation:i.generation}),i.generation=n.generation||++i.maxGeneration;for(var c=Oe(e,"beforeChange")||e.cm&&Oe(e.cm,"beforeChange"),f=n.changes.length-1;f>=0;--f){var d=function(r){var i=n.changes[r];if(i.origin=t,c&&!Ni(e,i,!1))return l.length=0,{};u.push(ei(e,i));var o=r?Un(e,i):g(l);Hi(e,i,o,ci(e,i)),!r&&e.cm&&e.cm.scrollIntoView({from:i.from,to:Bn(i)});var s=[];$n(e,function(e,t){t||-1!=h(s,e.history)||(zi(e.history,i),s.push(e.history)),Hi(e,i,null,ci(e,i))})}(f);if(d)return d.v}}}}function Di(e,t){if(0!=t&&(e.first+=t,e.sel=new ks(v(e.sel.ranges,function(e){return new Ts(E(e.anchor.line+t,e.anchor.ch),E(e.head.line+t,e.head.ch))}),e.sel.primIndex),e.cm)){vn(e.cm,e.first,e.first-t,t);for(var r=e.cm.display,n=r.viewFrom;n<r.viewTo;n++)mn(e.cm,n,"gutter")}}function Hi(e,t,r,n){if(e.cm&&!e.cm.curOp)return dn(e.cm,Hi)(e,t,r,n);if(t.to.line<e.first)Di(e,t.text.length-1-(t.to.line-t.from.line));else if(!(t.from.line>e.lastLine())){if(t.from.line<e.first){var i=t.text.length-1-(e.first-t.from.line);Di(e,i),t={from:E(e.first,0),to:E(t.to.line+i,t.to.ch),text:[g(t.text)],origin:t.origin}}var o=e.lastLine();t.to.line>o&&(t={from:t.from,to:E(o,M(e,o).text.length),text:[t.text[0]],origin:t.origin}),t.removed=N(e,t.from,t.to),r||(r=Un(e,t)),e.cm?Fi(e.cm,t,n):_n(e,t,n),wi(e,r,Gl)}}function Fi(e,t,r){var n=e.doc,i=e.display,o=t.from,l=t.to,s=!1,a=o.line;e.options.lineWrapping||(a=W(fe(M(n,o.line))),n.iter(a,l.line+1,function(e){if(e==i.maxLine)return s=!0,!0})),n.sel.contains(t.from,t.to)>-1&&Ne(e),_n(n,t,r,xr(e)),e.options.lineWrapping||(n.iter(a,o.line+t.text.length,function(e){var t=be(e);t>i.maxLineLength&&(i.maxLine=e,i.maxLineLength=t,i.maxLineChanged=!0,s=!1)}),s&&(e.curOp.updateMaxLine=!0)),nt(n,o.line),Cn(e,400);var u=t.text.length-(l.line-o.line)-1;t.full?vn(e):o.line!=l.line||1!=t.text.length||Yn(e.doc,t)?vn(e,o.line,l.line+1,u):mn(e,o.line,"text");var c=Oe(e,"changes"),f=Oe(e,"change");if(f||c){var h={from:o,to:l,text:t.text,removed:t.removed,origin:t.origin};f&&bt(e,"change",e,h),c&&(e.curOp.changeObjs||(e.curOp.changeObjs=[])).push(h)}e.display.selForContextMenu=null}function Ei(e,t,r,n,i){if(n||(n=r),P(n,r)<0){var o;r=(o=[n,r])[0],n=o[1]}"string"==typeof t&&(t=e.splitLines(t)),Oi(e,{from:r,to:n,text:t,origin:i})}function Pi(e,t,r,n){r<e.line?e.line+=n:t<e.line&&(e.line=t,e.ch=0)}function Ii(e,t,r,n){for(var i=0;i<e.length;++i){var o=e[i],l=!0;if(o.ranges){o.copied||((o=e[i]=o.deepCopy()).copied=!0);for(var s=0;s<o.ranges.length;s++)Pi(o.ranges[s].anchor,t,r,n),Pi(o.ranges[s].head,t,r,n)}else{for(var a=0;a<o.changes.length;++a){var u=o.changes[a];if(r<u.from.line)u.from=E(u.from.line+n,u.from.ch),u.to=E(u.to.line+n,u.to.ch);else if(t<=u.to.line){l=!1;break}}l||(e.splice(0,i+1),i=0)}}}function zi(e,t){var r=t.from.line,n=t.to.line,i=t.text.length-(n-r)-1;Ii(e.done,r,n,i),Ii(e.undone,r,n,i)}function Ri(e,t,r,n){var i=t,o=t;return"number"==typeof t?o=M(e,G(e,t)):i=W(t),null==i?null:(n(o,i)&&e.cm&&mn(e.cm,i,r),o)}function Bi(e){var t=this;this.lines=e,this.parent=null;for(var r=0,n=0;n<e.length;++n)e[n].parent=t,r+=e[n].height;this.height=r}function Gi(e){var t=this;this.children=e;for(var r=0,n=0,i=0;i<e.length;++i){var o=e[i];r+=o.chunkSize(),n+=o.height,o.parent=t}this.size=r,this.height=n,this.parent=null}function Ui(e,t,r){ye(t)<(e.curOp&&e.curOp.scrollTop||e.doc.scrollTop)&&Kr(e,r)}function Vi(e,t,r,n){var i=new Ms(e,r,n),o=e.cm;return o&&i.noHScroll&&(o.display.alignWidgets=!0),Ri(e,t,"widget",function(t){var r=t.widgets||(t.widgets=[]);if(null==i.insertAt?r.push(i):r.splice(Math.min(r.length-1,Math.max(0,i.insertAt)),0,i),i.line=t,o&&!ve(e,t)){var n=ye(t)<e.scrollTop;A(t,t.height+Ht(i)),n&&Kr(o,i.height),o.curOp.forceUpdate=!0}return!0}),bt(o,"lineWidgetAdded",o,i,"number"==typeof t?t:W(t)),i}function Ki(e,t,r,n,o){if(n&&n.shared)return ji(e,t,r,n,o);if(e.cm&&!e.cm.curOp)return dn(e.cm,Ki)(e,t,r,n,o);var l=new Os(e,o),s=P(t,r);if(n&&c(n,l,!1),s>0||0==s&&!1!==l.clearWhenEmpty)return l;if(l.replacedWith&&(l.collapsed=!0,l.widgetNode=i("span",[l.replacedWith],"CodeMirror-widget"),n.handleMouseEvents||l.widgetNode.setAttribute("cm-ignore-events","true"),n.insertLeft&&(l.widgetNode.insertLeft=!0)),l.collapsed){if(ce(e,t.line,t,r,l)||t.line!=r.line&&ce(e,r.line,t,r,l))throw new Error("Inserting collapsed marker partially overlapping an existing one");X()}l.addToHistory&&ni(e,{from:t,to:r,origin:"markText"},e.sel,NaN);var a,u=t.line,f=e.cm;if(e.iter(u,r.line+1,function(e){f&&l.collapsed&&!f.options.lineWrapping&&fe(e)==f.display.maxLine&&(a=!0),l.collapsed&&u!=t.line&&A(e,0),q(e,new Y(l,u==t.line?t.ch:null,u==r.line?r.ch:null)),++u}),l.collapsed&&e.iter(t.line,r.line+1,function(t){ve(e,t)&&A(t,0)}),l.clearOnEnter&&Ql(l,"beforeCursorEnter",function(){return l.clear()}),l.readOnly&&(j(),(e.history.done.length||e.history.undone.length)&&e.clearHistory()),l.collapsed&&(l.id=++Ns,l.atomic=!0),f){if(a&&(f.curOp.updateMaxLine=!0),l.collapsed)vn(f,t.line,r.line+1);else if(l.className||l.title||l.startStyle||l.endStyle||l.css)for(var h=t.line;h<=r.line;h++)mn(f,h,"text");l.atomic&&Ci(f.doc),bt(f,"markerAdded",f,l)}return l}function ji(e,t,r,n,i){(n=c(n)).shared=!1;var o=[Ki(e,t,r,n,i)],l=o[0],s=n.widgetNode;return $n(e,function(e){s&&(n.widgetNode=s.cloneNode(!0)),o.push(Ki(e,U(e,t),U(e,r),n,i));for(var a=0;a<e.linked.length;++a)if(e.linked[a].isParent)return;l=g(o)}),new As(o,l)}function Xi(e){return e.findMarks(E(e.first,0),e.clipPos(E(e.lastLine())),function(e){return e.parent})}function Yi(e,t){for(var r=0;r<t.length;r++){var n=t[r],i=n.find(),o=e.clipPos(i.from),l=e.clipPos(i.to);if(P(o,l)){var s=Ki(e,o,l,n.primary,n.primary.type);n.markers.push(s),s.parent=n}}}function _i(e){for(var t=0;t<e.length;t++)!function(t){var r=e[t],n=[r.primary.doc];$n(r.primary.doc,function(e){return n.push(e)});for(var i=0;i<r.markers.length;i++){var o=r.markers[i];-1==h(n,o.doc)&&(o.parent=null,r.markers.splice(i--,1))}}(t)}function $i(e){var t=this;if(Qi(t),!Me(t,e)&&!Ft(t.display,e)){We(e),gl&&(Hs=+new Date);var r=Sr(t,e,!0),n=e.dataTransfer.files;if(r&&!t.isReadOnly())if(n&&n.length&&window.FileReader&&window.File)for(var i=n.length,o=Array(i),l=0,s=0;s<i;++s)!function(e,n){if(!t.options.allowDropFileTypes||-1!=h(t.options.allowDropFileTypes,e.type)){var s=new FileReader;s.onload=dn(t,function(){var e=s.result;if(/[\x00-\x08\x0e-\x1f]{2}/.test(e)&&(e=""),o[n]=e,++l==i){var a={from:r=U(t.doc,r),to:r,text:t.doc.splitLines(o.join(t.doc.lineSeparator())),origin:"paste"};Oi(t.doc,a),yi(t.doc,Rn(r,Bn(a)))}}),s.readAsText(e)}}(n[s],s);else{if(t.state.draggingText&&t.doc.sel.contains(r)>-1)return t.state.draggingText(e),void setTimeout(function(){return t.display.input.focus()},20);try{var a=e.dataTransfer.getData("Text");if(a){var u;if(t.state.draggingText&&!t.state.draggingText.copy&&(u=t.listSelections()),wi(t.doc,Rn(r,r)),u)for(var c=0;c<u.length;++c)Ei(t.doc,"",u[c].anchor,u[c].head,"drag");t.replaceSelection(a,"around","paste"),t.display.input.focus()}}catch(e){}}}}function qi(e,t){if(gl&&(!e.state.draggingText||+new Date-Hs<100))Fe(t);else if(!Me(e,t)&&!Ft(e.display,t)&&(t.dataTransfer.setData("Text",e.getSelection()),t.dataTransfer.effectAllowed="copyMove",t.dataTransfer.setDragImage&&!xl)){var r=n("img",null,null,"position: fixed; left: 0; top: 0;");r.src="data:image/gif;base64,R0lGODlhAQABAAAAACH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==",wl&&(r.width=r.height=1,e.display.wrapper.appendChild(r),r._top=r.offsetTop),t.dataTransfer.setDragImage(r,0,0),wl&&r.parentNode.removeChild(r)}}function Zi(e,t){var i=Sr(e,t);if(i){var o=document.createDocumentFragment();Mr(e,i,o),e.display.dragCursor||(e.display.dragCursor=n("div",null,"CodeMirror-cursors CodeMirror-dragcursors"),e.display.lineSpace.insertBefore(e.display.dragCursor,e.display.cursorDiv)),r(e.display.dragCursor,o)}}function Qi(e){e.display.dragCursor&&(e.display.lineSpace.removeChild(e.display.dragCursor),e.display.dragCursor=null)}function Ji(e){if(document.getElementsByClassName)for(var t=document.getElementsByClassName("CodeMirror"),r=0;r<t.length;r++){var n=t[r].CodeMirror;n&&e(n)}}function eo(){Fs||(to(),Fs=!0)}function to(){var e;Ql(window,"resize",function(){null==e&&(e=setTimeout(function(){e=null,Ji(ro)},100))}),Ql(window,"blur",function(){return Ji(Fr)})}function ro(e){var t=e.display;t.lastWrapHeight==t.wrapper.clientHeight&&t.lastWrapWidth==t.wrapper.clientWidth||(t.cachedCharWidth=t.cachedTextHeight=t.cachedPaddingH=null,t.scrollbarsClipped=!1,e.setSize())}function no(e){var t=e.split(/-(?!$)/);e=t[t.length-1];for(var r,n,i,o,l=0;l<t.length-1;l++){var s=t[l];if(/^(cmd|meta|m)$/i.test(s))o=!0;else if(/^a(lt)?$/i.test(s))r=!0;else if(/^(c|ctrl|control)$/i.test(s))n=!0;else{if(!/^s(hift)?$/i.test(s))throw new Error("Unrecognized modifier name: "+s);i=!0}}return r&&(e="Alt-"+e),n&&(e="Ctrl-"+e),o&&(e="Cmd-"+e),i&&(e="Shift-"+e),e}function io(e){var t={};for(var r in e)if(e.hasOwnProperty(r)){var n=e[r];if(/^(name|fallthrough|(de|at)tach)$/.test(r))continue;if("..."==n){delete e[r];continue}for(var i=v(r.split(" "),no),o=0;o<i.length;o++){var l=void 0,s=void 0;o==i.length-1?(s=i.join(" "),l=n):(s=i.slice(0,o+1).join(" "),l="...");var a=t[s];if(a){if(a!=l)throw new Error("Inconsistent bindings for "+s)}else t[s]=l}delete e[r]}for(var u in t)e[u]=t[u];return e}function oo(e,t,r,n){var i=(t=uo(t)).call?t.call(e,n):t[e];if(!1===i)return"nothing";if("..."===i)return"multi";if(null!=i&&r(i))return"handled";if(t.fallthrough){if("[object Array]"!=Object.prototype.toString.call(t.fallthrough))return oo(e,t.fallthrough,r,n);for(var o=0;o<t.fallthrough.length;o++){var l=oo(e,t.fallthrough[o],r,n);if(l)return l}}}function lo(e){var t="string"==typeof e?e:Es[e.keyCode];return"Ctrl"==t||"Alt"==t||"Shift"==t||"Mod"==t}function so(e,t,r){var n=e;return t.altKey&&"Alt"!=n&&(e="Alt-"+e),(Dl?t.metaKey:t.ctrlKey)&&"Ctrl"!=n&&(e="Ctrl-"+e),(Dl?t.ctrlKey:t.metaKey)&&"Cmd"!=n&&(e="Cmd-"+e),!r&&t.shiftKey&&"Shift"!=n&&(e="Shift-"+e),e}function ao(e,t){if(wl&&34==e.keyCode&&e.char)return!1;var r=Es[e.keyCode];return null!=r&&!e.altGraphKey&&so(r,e,t)}function uo(e){return"string"==typeof e?Rs[e]:e}function co(e,t){for(var r=e.doc.sel.ranges,n=[],i=0;i<r.length;i++){for(var o=t(r[i]);n.length&&P(o.from,g(n).to)<=0;){var l=n.pop();if(P(l.from,o.from)<0){o.from=l.from;break}}n.push(o)}hn(e,function(){for(var t=n.length-1;t>=0;t--)Ei(e.doc,"",n[t].from,n[t].to,"+delete");jr(e)})}function fo(e,t,r){var n=L(e.text,t+r,r);return n<0||n>e.text.length?null:n}function ho(e,t,r){var n=fo(e,t.ch,r);return null==n?null:new E(t.line,n,r<0?"after":"before")}function po(e,t,r,n,i){if(e){var o=Se(r,t.doc.direction);if(o){var l,s=i<0?g(o):o[0],a=i<0==(1==s.level)?"after":"before";if(s.level>0){var u=Xt(t,r);l=i<0?r.text.length-1:0;var c=Yt(t,u,l).top;l=k(function(e){return Yt(t,u,e).top==c},i<0==(1==s.level)?s.from:s.to-1,l),"before"==a&&(l=fo(r,l,1))}else l=i<0?s.to:s.from;return new E(n,l,a)}}return new E(n,i<0?r.text.length:0,i<0?"before":"after")}function go(e,t,r,n){var i=Se(t,e.doc.direction);if(!i)return ho(t,r,n);r.ch>=t.text.length?(r.ch=t.text.length,r.sticky="before"):r.ch<=0&&(r.ch=0,r.sticky="after");var o=Ce(i,r.ch,r.sticky),l=i[o];if("ltr"==e.doc.direction&&l.level%2==0&&(n>0?l.to>r.ch:l.from<r.ch))return ho(t,r,n);var s,a=function(e,r){return fo(t,e instanceof E?e.ch:e,r)},u=function(r){return e.options.lineWrapping?(s=s||Xt(e,t),hr(e,t,s,r)):{begin:0,end:t.text.length}},c=u("before"==r.sticky?a(r,-1):r.ch);if("rtl"==e.doc.direction||1==l.level){var f=1==l.level==n<0,h=a(r,f?1:-1);if(null!=h&&(f?h<=l.to&&h<=c.end:h>=l.from&&h>=c.begin)){var d=f?"before":"after";return new E(r.line,h,d)}}var p=function(e,t,n){for(var o=function(e,t){return t?new E(r.line,a(e,1),"before"):new E(r.line,e,"after")};e>=0&&e<i.length;e+=t){var l=i[e],s=t>0==(1!=l.level),u=s?n.begin:a(n.end,-1);if(l.from<=u&&u<l.to)return o(u,s);if(u=s?l.from:a(l.to,-1),n.begin<=u&&u<n.end)return o(u,s)}},g=p(o+n,n,c);if(g)return g;var v=n>0?c.end:a(c.begin,-1);return null==v||n>0&&v==t.text.length||!(g=p(n>0?0:i.length-1,n,u(v)))?null:g}function vo(e,t){var r=M(e.doc,t),n=fe(r);return n!=r&&(t=W(n)),po(!0,e,n,t,1)}function mo(e,t){var r=M(e.doc,t),n=he(r);return n!=r&&(t=W(n)),po(!0,e,r,t,-1)}function yo(e,t){var r=vo(e,t.line),n=M(e.doc,r.line),i=Se(n,e.doc.direction);if(!i||0==i[0].level){var o=Math.max(0,n.text.search(/\S/)),l=t.line==r.line&&t.ch<=o&&t.ch;return E(r.line,l?0:o,r.sticky)}return r}function bo(e,t,r){if("string"==typeof t&&!(t=Bs[t]))return!1;e.display.input.ensurePolled();var n=e.display.shift,i=!1;try{e.isReadOnly()&&(e.state.suppressEdits=!0),r&&(e.display.shift=!1),i=t(e)!=Bl}finally{e.display.shift=n,e.state.suppressEdits=!1}return i}function wo(e,t,r){for(var n=0;n<e.state.keyMaps.length;n++){var i=oo(t,e.state.keyMaps[n],r,e);if(i)return i}return e.options.extraKeys&&oo(t,e.options.extraKeys,r,e)||oo(t,e.options.keyMap,r,e)}function xo(e,t,r,n){var i=e.state.keySeq;if(i){if(lo(t))return"handled";Gs.set(50,function(){e.state.keySeq==i&&(e.state.keySeq=null,e.display.input.reset())}),t=i+" "+t}var o=wo(e,t,n);return"multi"==o&&(e.state.keySeq=t),"handled"==o&&bt(e,"keyHandled",e,t,r),"handled"!=o&&"multi"!=o||(We(r),Ar(e)),i&&!o&&/\'$/.test(t)?(We(r),!0):!!o}function Co(e,t){var r=ao(t,!0);return!!r&&(t.shiftKey&&!e.state.keySeq?xo(e,"Shift-"+r,t,function(t){return bo(e,t,!0)})||xo(e,r,t,function(t){if("string"==typeof t?/^go[A-Z]/.test(t):t.motion)return bo(e,t)}):xo(e,r,t,function(t){return bo(e,t)}))}function So(e,t,r){return xo(e,"'"+r+"'",t,function(t){return bo(e,t,!0)})}function Lo(e){var t=this;if(t.curOp.focus=l(),!Me(t,e)){gl&&vl<11&&27==e.keyCode&&(e.returnValue=!1);var r=e.keyCode;t.display.shift=16==r||e.shiftKey;var n=Co(t,e);wl&&(Us=n?r:null,!n&&88==r&&!rs&&(Ml?e.metaKey:e.ctrlKey)&&t.replaceSelection("",null,"cut")),18!=r||/\bCodeMirror-crosshair\b/.test(t.display.lineDiv.className)||ko(t)}}function ko(e){function t(e){18!=e.keyCode&&e.altKey||(Fl(r,"CodeMirror-crosshair"),ke(document,"keyup",t),ke(document,"mouseover",t))}var r=e.display.lineDiv;s(r,"CodeMirror-crosshair"),Ql(document,"keyup",t),Ql(document,"mouseover",t)}function To(e){16==e.keyCode&&(this.doc.sel.shift=!1),Me(this,e)}function Mo(e){var t=this;if(!(Ft(t.display,e)||Me(t,e)||e.ctrlKey&&!e.altKey||Ml&&e.metaKey)){var r=e.keyCode,n=e.charCode;if(wl&&r==Us)return Us=null,void We(e);if(!wl||e.which&&!(e.which<10)||!Co(t,e)){var i=String.fromCharCode(null==n?r:n);"\b"!=i&&(So(t,e,i)||t.display.input.onKeyPress(e))}}}function No(e,t){var r=+new Date;return js&&js.compare(r,e,t)?(Ks=js=null,"triple"):Ks&&Ks.compare(r,e,t)?(js=new Vs(r,e,t),Ks=null,"double"):(Ks=new Vs(r,e,t),js=null,"single")}function Oo(e){var t=this,r=t.display;if(!(Me(t,e)||r.activeTouch&&r.input.supportsTouch()))if(r.input.ensurePolled(),r.shift=e.shiftKey,Ft(r,e))ml||(r.scroller.draggable=!1,setTimeout(function(){return r.scroller.draggable=!0},100));else if(!zo(t,e)){var n=Sr(t,e),i=Pe(e),o=n?No(n,i):"single";window.focus(),1==i&&t.state.selectingText&&t.state.selectingText(e),n&&Ao(t,i,n,o,e)||(1==i?n?Do(t,n,o,e):Ee(e)==r.scroller&&We(e):2==i?(n&&di(t.doc,n),setTimeout(function(){return r.input.focus()},20)):3==i&&(Hl?Ro(t,e):Dr(t)))}}function Ao(e,t,r,n,i){var o="Click";return"double"==n?o="Double"+o:"triple"==n&&(o="Triple"+o),o=(1==t?"Left":2==t?"Middle":"Right")+o,xo(e,so(o,i),i,function(t){if("string"==typeof t&&(t=Bs[t]),!t)return!1;var n=!1;try{e.isReadOnly()&&(e.state.suppressEdits=!0),n=t(e,r)!=Bl}finally{e.state.suppressEdits=!1}return n})}function Wo(e,t,r){var n=e.getOption("configureMouse"),i=n?n(e,t,r):{};if(null==i.unit){var o=Nl?r.shiftKey&&r.metaKey:r.altKey;i.unit=o?"rectangle":"single"==t?"char":"double"==t?"word":"line"}return(null==i.extend||e.doc.extend)&&(i.extend=e.doc.extend||r.shiftKey),null==i.addNew&&(i.addNew=Ml?r.metaKey:r.ctrlKey),null==i.moveOnDrag&&(i.moveOnDrag=!(Ml?r.altKey:r.ctrlKey)),i}function Do(e,t,r,n){gl?setTimeout(u(Wr,e),0):e.curOp.focus=l();var i,o=Wo(e,r,n),s=e.doc.sel;e.options.dragDrop&&Jl&&!e.isReadOnly()&&"single"==r&&(i=s.contains(t))>-1&&(P((i=s.ranges[i]).from(),t)<0||t.xRel>0)&&(P(i.to(),t)>0||t.xRel<0)?Ho(e,n,t,o):Eo(e,n,t,o)}function Ho(e,t,r,n){var i=e.display,o=!1,l=dn(e,function(t){ml&&(i.scroller.draggable=!1),e.state.draggingText=!1,ke(document,"mouseup",l),ke(document,"mousemove",s),ke(i.scroller,"dragstart",a),ke(i.scroller,"drop",l),o||(We(t),n.addNew||di(e.doc,r,null,null,n.extend),ml||gl&&9==vl?setTimeout(function(){document.body.focus(),i.input.focus()},20):i.input.focus())}),s=function(e){o=o||Math.abs(t.clientX-e.clientX)+Math.abs(t.clientY-e.clientY)>=10},a=function(){return o=!0};ml&&(i.scroller.draggable=!0),e.state.draggingText=l,l.copy=!n.moveOnDrag,i.scroller.dragDrop&&i.scroller.dragDrop(),Ql(document,"mouseup",l),Ql(document,"mousemove",s),Ql(i.scroller,"dragstart",a),Ql(i.scroller,"drop",l),Dr(e),setTimeout(function(){return i.input.focus()},20)}function Fo(e,t,r){if("char"==r)return new Ts(t,t);if("word"==r)return e.findWordAt(t);if("line"==r)return new Ts(E(t.line,0),U(e.doc,E(t.line+1,0)));var n=r(e,t);return new Ts(n.from,n.to)}function Eo(e,t,r,n){function i(t){if(0!=P(m,t))if(m=t,"rectangle"==n.unit){for(var i=[],o=e.options.tabSize,l=f(M(u,r.line).text,r.ch,o),s=f(M(u,t.line).text,t.ch,o),a=Math.min(l,s),g=Math.max(l,s),v=Math.min(r.line,t.line),y=Math.min(e.lastLine(),Math.max(r.line,t.line));v<=y;v++){var b=M(u,v).text,w=d(b,a,o);a==g?i.push(new Ts(E(v,w),E(v,w))):b.length>w&&i.push(new Ts(E(v,w),E(v,d(b,g,o))))}i.length||i.push(new Ts(r,r)),bi(u,zn(p.ranges.slice(0,h).concat(i),h),{origin:"*mouse",scroll:!1}),e.scrollIntoView(t)}else{var x,C=c,S=Fo(e,t,n.unit),L=C.anchor;P(S.anchor,L)>0?(x=S.head,L=B(C.from(),S.anchor)):(x=S.anchor,L=R(C.to(),S.head));var k=p.ranges.slice(0);k[h]=Po(e,new Ts(U(u,L),x)),bi(u,zn(k,h),Ul)}}function o(t){var r=++b,s=Sr(e,t,!0,"rectangle"==n.unit);if(s)if(0!=P(s,m)){e.curOp.focus=l(),i(s);var c=Ir(a,u);(s.line>=c.to||s.line<c.from)&&setTimeout(dn(e,function(){b==r&&o(t)}),150)}else{var f=t.clientY<y.top?-20:t.clientY>y.bottom?20:0;f&&setTimeout(dn(e,function(){b==r&&(a.scroller.scrollTop+=f,o(t))}),50)}}function s(t){e.state.selectingText=!1,b=1/0,We(t),a.input.focus(),ke(document,"mousemove",w),ke(document,"mouseup",x),u.history.lastSelOrigin=null}var a=e.display,u=e.doc;We(t);var c,h,p=u.sel,g=p.ranges;if(n.addNew&&!n.extend?(h=u.sel.contains(r),c=h>-1?g[h]:new Ts(r,r)):(c=u.sel.primary(),h=u.sel.primIndex),"rectangle"==n.unit)n.addNew||(c=new Ts(r,r)),r=Sr(e,t,!0,!0),h=-1;else{var v=Fo(e,r,n.unit);c=n.extend?hi(c,v.anchor,v.head,n.extend):v}n.addNew?-1==h?(h=g.length,bi(u,zn(g.concat([c]),h),{scroll:!1,origin:"*mouse"})):g.length>1&&g[h].empty()&&"char"==n.unit&&!n.extend?(bi(u,zn(g.slice(0,h).concat(g.slice(h+1)),0),{scroll:!1,origin:"*mouse"}),p=u.sel):gi(u,h,c,Ul):(h=0,bi(u,new ks([c],0),Ul),p=u.sel);var m=r,y=a.wrapper.getBoundingClientRect(),b=0,w=dn(e,function(e){Pe(e)?o(e):s(e)}),x=dn(e,s);e.state.selectingText=x,Ql(document,"mousemove",w),Ql(document,"mouseup",x)}function Po(e,t){var r=t.anchor,n=t.head,i=M(e.doc,r.line);if(0==P(r,n)&&r.sticky==n.sticky)return t;var o=Se(i);if(!o)return t;var l=Ce(o,r.ch,r.sticky),s=o[l];if(s.from!=r.ch&&s.to!=r.ch)return t;var a=l+(s.from==r.ch==(1!=s.level)?0:1);if(0==a||a==o.length)return t;var u;if(n.line!=r.line)u=(n.line-r.line)*("ltr"==e.doc.direction?1:-1)>0;else{var c=Ce(o,n.ch,n.sticky),f=c-l||(n.ch-r.ch)*(1==s.level?-1:1);u=c==a-1||c==a?f<0:f>0}var h=o[a+(u?-1:0)],d=u==(1==h.level),p=d?h.from:h.to,g=d?"after":"before";return r.ch==p&&r.sticky==g?t:new Ts(new E(r.line,p,g),n)}function Io(e,t,r,n){var i,o;if(t.touches)i=t.touches[0].clientX,o=t.touches[0].clientY;else try{i=t.clientX,o=t.clientY}catch(t){return!1}if(i>=Math.floor(e.display.gutters.getBoundingClientRect().right))return!1;n&&We(t);var l=e.display,s=l.lineDiv.getBoundingClientRect();if(o>s.bottom||!Oe(e,r))return He(t);o-=s.top-l.viewOffset;for(var a=0;a<e.options.gutters.length;++a){var u=l.gutters.childNodes[a];if(u&&u.getBoundingClientRect().right>=i)return Te(e,r,e,D(e.doc,o),e.options.gutters[a],t),He(t)}}function zo(e,t){return Io(e,t,"gutterClick",!0)}function Ro(e,t){Ft(e.display,t)||Bo(e,t)||Me(e,t,"contextmenu")||e.display.input.onContextMenu(t)}function Bo(e,t){return!!Oe(e,"gutterContextMenu")&&Io(e,t,"gutterContextMenu",!1)}function Go(e){e.display.wrapper.className=e.display.wrapper.className.replace(/\s*cm-s-\S+/g,"")+e.options.theme.replace(/(^|\s)\s*/g," cm-s-"),er(e)}function Uo(e){Hn(e),vn(e),zr(e)}function Vo(e,t,r){if(!t!=!(r&&r!=Xs)){var n=e.display.dragFunctions,i=t?Ql:ke;i(e.display.scroller,"dragstart",n.start),i(e.display.scroller,"dragenter",n.enter),i(e.display.scroller,"dragover",n.over),i(e.display.scroller,"dragleave",n.leave),i(e.display.scroller,"drop",n.drop)}}function Ko(e){e.options.lineWrapping?(s(e.display.wrapper,"CodeMirror-wrap"),e.display.sizer.style.minWidth="",e.display.sizerWidth=null):(Fl(e.display.wrapper,"CodeMirror-wrap"),we(e)),Cr(e),vn(e),er(e),setTimeout(function(){return en(e)},100)}function jo(e,t){var r=this;if(!(this instanceof jo))return new jo(e,t);this.options=t=t?c(t):{},c(Ys,t,!1),Fn(t);var n=t.value;"string"==typeof n&&(n=new Ds(n,t.mode,null,t.lineSeparator,t.direction)),this.doc=n;var i=new jo.inputStyles[t.inputStyle](this),o=this.display=new T(e,n,i);o.wrapper.CodeMirror=this,Hn(this),Go(this),t.lineWrapping&&(this.display.wrapper.className+=" CodeMirror-wrap"),rn(this),this.state={keyMaps:[],overlays:[],modeGen:0,overwrite:!1,delayingBlurEvent:!1,focused:!1,suppressEdits:!1,pasteIncoming:!1,cutIncoming:!1,selectingText:!1,draggingText:!1,highlight:new Pl,keySeq:null,specialChars:null},t.autofocus&&!Tl&&o.input.focus(),gl&&vl<11&&setTimeout(function(){return r.display.input.reset(!0)},20),Xo(this),eo(),nn(this),this.curOp.forceUpdate=!0,qn(this,n),t.autofocus&&!Tl||this.hasFocus()?setTimeout(u(Hr,this),20):Fr(this);for(var l in _s)_s.hasOwnProperty(l)&&_s[l](r,t[l],Xs);Rr(this),t.finishInit&&t.finishInit(this);for(var s=0;s<$s.length;++s)$s[s](r);on(this),ml&&t.lineWrapping&&"optimizelegibility"==getComputedStyle(o.lineDiv).textRendering&&(o.lineDiv.style.textRendering="auto")}function Xo(e){function t(){i.activeTouch&&(o=setTimeout(function(){return i.activeTouch=null},1e3),(l=i.activeTouch).end=+new Date)}function r(e){if(1!=e.touches.length)return!1;var t=e.touches[0];return t.radiusX<=1&&t.radiusY<=1}function n(e,t){if(null==t.left)return!0;var r=t.left-e.left,n=t.top-e.top;return r*r+n*n>400}var i=e.display;Ql(i.scroller,"mousedown",dn(e,Oo)),gl&&vl<11?Ql(i.scroller,"dblclick",dn(e,function(t){if(!Me(e,t)){var r=Sr(e,t);if(r&&!zo(e,t)&&!Ft(e.display,t)){We(t);var n=e.findWordAt(r);di(e.doc,n.anchor,n.head)}}})):Ql(i.scroller,"dblclick",function(t){return Me(e,t)||We(t)}),Hl||Ql(i.scroller,"contextmenu",function(t){return Ro(e,t)});var o,l={end:0};Ql(i.scroller,"touchstart",function(t){if(!Me(e,t)&&!r(t)&&!zo(e,t)){i.input.ensurePolled(),clearTimeout(o);var n=+new Date;i.activeTouch={start:n,moved:!1,prev:n-l.end<=300?l:null},1==t.touches.length&&(i.activeTouch.left=t.touches[0].pageX,i.activeTouch.top=t.touches[0].pageY)}}),Ql(i.scroller,"touchmove",function(){i.activeTouch&&(i.activeTouch.moved=!0)}),Ql(i.scroller,"touchend",function(r){var o=i.activeTouch;if(o&&!Ft(i,r)&&null!=o.left&&!o.moved&&new Date-o.start<300){var l,s=e.coordsChar(i.activeTouch,"page");l=!o.prev||n(o,o.prev)?new Ts(s,s):!o.prev.prev||n(o,o.prev.prev)?e.findWordAt(s):new Ts(E(s.line,0),U(e.doc,E(s.line+1,0))),e.setSelection(l.anchor,l.head),e.focus(),We(r)}t()}),Ql(i.scroller,"touchcancel",t),Ql(i.scroller,"scroll",function(){i.scroller.clientHeight&&(qr(e,i.scroller.scrollTop),Qr(e,i.scroller.scrollLeft,!0),Te(e,"scroll",e))}),Ql(i.scroller,"mousewheel",function(t){return In(e,t)}),Ql(i.scroller,"DOMMouseScroll",function(t){return In(e,t)}),Ql(i.wrapper,"scroll",function(){return i.wrapper.scrollTop=i.wrapper.scrollLeft=0}),i.dragFunctions={enter:function(t){Me(e,t)||Fe(t)},over:function(t){Me(e,t)||(Zi(e,t),Fe(t))},start:function(t){return qi(e,t)},drop:dn(e,$i),leave:function(t){Me(e,t)||Qi(e)}};var s=i.input.getField();Ql(s,"keyup",function(t){return To.call(e,t)}),Ql(s,"keydown",dn(e,Lo)),Ql(s,"keypress",dn(e,Mo)),Ql(s,"focus",function(t){return Hr(e,t)}),Ql(s,"blur",function(t){return Fr(e,t)})}function Yo(e,t,r,n){var i,o=e.doc;null==r&&(r="add"),"smart"==r&&(o.mode.indent?i=$e(e,t).state:r="prev");var l=e.options.tabSize,s=M(o,t),a=f(s.text,null,l);s.stateAfter&&(s.stateAfter=null);var u,c=s.text.match(/^\s*/)[0];if(n||/\S/.test(s.text)){if("smart"==r&&((u=o.mode.indent(i,s.text.slice(c.length),s.text))==Bl||u>150)){if(!n)return;r="prev"}}else u=0,r="not";"prev"==r?u=t>o.first?f(M(o,t-1).text,null,l):0:"add"==r?u=a+e.options.indentUnit:"subtract"==r?u=a-e.options.indentUnit:"number"==typeof r&&(u=a+r),u=Math.max(0,u);var h="",d=0;if(e.options.indentWithTabs)for(var g=Math.floor(u/l);g;--g)d+=l,h+="\t";if(d<u&&(h+=p(u-d)),h!=c)return Ei(o,h,E(t,0),E(t,c.length),"+input"),s.stateAfter=null,!0;for(var v=0;v<o.sel.ranges.length;v++){var m=o.sel.ranges[v];if(m.head.line==t&&m.head.ch<c.length){var y=E(t,c.length);gi(o,v,new Ts(y,y));break}}}function _o(e){qs=e}function $o(e,t,r,n,i){var o=e.doc;e.display.shift=!1,n||(n=o.sel);var l=e.state.pasteIncoming||"paste"==i,s=es(t),a=null;if(l&&n.ranges.length>1)if(qs&&qs.text.join("\n")==t){if(n.ranges.length%qs.text.length==0){a=[];for(var u=0;u<qs.text.length;u++)a.push(o.splitLines(qs.text[u]))}}else s.length==n.ranges.length&&e.options.pasteLinesPerSelection&&(a=v(s,function(e){return[e]}));for(var c,f=n.ranges.length-1;f>=0;f--){var h=n.ranges[f],d=h.from(),p=h.to();h.empty()&&(r&&r>0?d=E(d.line,d.ch-r):e.state.overwrite&&!l?p=E(p.line,Math.min(M(o,p.line).text.length,p.ch+g(s).length)):qs&&qs.lineWise&&qs.text.join("\n")==t&&(d=p=E(d.line,0))),c=e.curOp.updateInput;var m={from:d,to:p,text:a?a[f%a.length]:s,origin:i||(l?"paste":e.state.cutIncoming?"cut":"+input")};Oi(e.doc,m),bt(e,"inputRead",e,m)}t&&!l&&Zo(e,t),jr(e),e.curOp.updateInput=c,e.curOp.typing=!0,e.state.pasteIncoming=e.state.cutIncoming=!1}function qo(e,t){var r=e.clipboardData&&e.clipboardData.getData("Text");if(r)return e.preventDefault(),t.isReadOnly()||t.options.disableInput||hn(t,function(){return $o(t,r,0,null,"paste")}),!0}function Zo(e,t){if(e.options.electricChars&&e.options.smartIndent)for(var r=e.doc.sel,n=r.ranges.length-1;n>=0;n--){var i=r.ranges[n];if(!(i.head.ch>100||n&&r.ranges[n-1].head.line==i.head.line)){var o=e.getModeAt(i.head),l=!1;if(o.electricChars){for(var s=0;s<o.electricChars.length;s++)if(t.indexOf(o.electricChars.charAt(s))>-1){l=Yo(e,i.head.line,"smart");break}}else o.electricInput&&o.electricInput.test(M(e.doc,i.head.line).text.slice(0,i.head.ch))&&(l=Yo(e,i.head.line,"smart"));l&&bt(e,"electricInput",e,i.head.line)}}}function Qo(e){for(var t=[],r=[],n=0;n<e.doc.sel.ranges.length;n++){var i=e.doc.sel.ranges[n].head.line,o={anchor:E(i,0),head:E(i+1,0)};r.push(o),t.push(e.getRange(o.anchor,o.head))}return{text:t,ranges:r}}function Jo(e,t){e.setAttribute("autocorrect","off"),e.setAttribute("autocapitalize","off"),e.setAttribute("spellcheck",!!t)}function el(){var e=n("textarea",null,null,"position: absolute; bottom: -1em; padding: 0; width: 1px; height: 1em; outline: none"),t=n("div",[e],null,"overflow: hidden; position: relative; width: 3px; height: 0px;");return ml?e.style.width="1000px":e.setAttribute("wrap","off"),Ll&&(e.style.border="1px solid black"),Jo(e),t}function tl(e,t,r,n,i){function o(){var n=t.line+r;return!(n<e.first||n>=e.first+e.size)&&(t=new E(n,t.ch,t.sticky),u=M(e,n))}function l(n){var l;if(null==(l=i?go(e.cm,u,t,r):ho(u,t,r))){if(n||!o())return!1;t=po(i,e.cm,u,t.line,r)}else t=l;return!0}var s=t,a=r,u=M(e,t.line);if("char"==n)l();else if("column"==n)l(!0);else if("word"==n||"group"==n)for(var c=null,f="group"==n,h=e.cm&&e.cm.getHelper(t,"wordChars"),d=!0;!(r<0)||l(!d);d=!1){var p=u.text.charAt(t.ch)||"\n",g=x(p,h)?"w":f&&"\n"==p?"n":!f||/\s/.test(p)?null:"p";if(!f||d||g||(g="s"),c&&c!=g){r<0&&(r=1,l(),t.sticky="after");break}if(g&&(c=g),r>0&&!l(!d))break}var v=ki(e,t,s,a,!0);return I(s,v)&&(v.hitSide=!0),v}function rl(e,t,r,n){var i,o=e.doc,l=t.left;if("page"==n){var s=Math.min(e.display.wrapper.clientHeight,window.innerHeight||document.documentElement.clientHeight),a=Math.max(s-.5*mr(e.display),3);i=(r>0?t.bottom:t.top)+r*a}else"line"==n&&(i=r>0?t.bottom+3:t.top-3);for(var u;(u=cr(e,l,i)).outside;){if(r<0?i<=0:i>=o.height){u.hitSide=!0;break}i+=5*r}return u}function nl(e,t){var r=jt(e,t.line);if(!r||r.hidden)return null;var n=M(e.doc,t.line),i=Ut(r,n,t.line),o=Se(n,e.doc.direction),l="left";o&&(l=Ce(o,t.ch)%2?"right":"left");var s=_t(i.map,t.ch,l);return s.offset="right"==s.collapse?s.end:s.start,s}function il(e){for(var t=e;t;t=t.parentNode)if(/CodeMirror-gutter-wrapper/.test(t.className))return!0;return!1}function ol(e,t){return t&&(e.bad=!0),e}function ll(e,t,r,n,i){function o(e){return function(t){return t.id==e}}function l(){c&&(u+=f,c=!1)}function s(e){e&&(l(),u+=e)}function a(t){if(1==t.nodeType){var r=t.getAttribute("cm-text");if(null!=r)return void s(r||t.textContent.replace(/\u200b/g,""));var u,h=t.getAttribute("cm-marker");if(h){var d=e.findMarks(E(n,0),E(i+1,0),o(+h));return void(d.length&&(u=d[0].find(0))&&s(N(e.doc,u.from,u.to).join(f)))}if("false"==t.getAttribute("contenteditable"))return;var p=/^(pre|div|p)$/i.test(t.nodeName);p&&l();for(var g=0;g<t.childNodes.length;g++)a(t.childNodes[g]);p&&(c=!0)}else 3==t.nodeType&&s(t.nodeValue)}for(var u="",c=!1,f=e.doc.lineSeparator();a(t),t!=r;)t=t.nextSibling;return u}function sl(e,t,r){var n;if(t==e.display.lineDiv){if(!(n=e.display.lineDiv.childNodes[r]))return ol(e.clipPos(E(e.display.viewTo-1)),!0);t=null,r=0}else for(n=t;;n=n.parentNode){if(!n||n==e.display.lineDiv)return null;if(n.parentNode&&n.parentNode==e.display.lineDiv)break}for(var i=0;i<e.display.view.length;i++){var o=e.display.view[i];if(o.node==n)return al(o,t,r)}}function al(e,t,r){function n(t,r,n){for(var i=-1;i<(f?f.length:0);i++)for(var o=i<0?c.map:f[i],l=0;l<o.length;l+=3){var s=o[l+2];if(s==t||s==r){var a=W(i<0?e.line:e.rest[i]),u=o[l]+n;return(n<0||s!=t)&&(u=o[l+(n?1:0)]),E(a,u)}}}var i=e.text.firstChild,l=!1;if(!t||!o(i,t))return ol(E(W(e.line),0),!0);if(t==i&&(l=!0,t=i.childNodes[r],r=0,!t)){var s=e.rest?g(e.rest):e.line;return ol(E(W(s),s.text.length),l)}var a=3==t.nodeType?t:null,u=t;for(a||1!=t.childNodes.length||3!=t.firstChild.nodeType||(a=t.firstChild,r&&(r=a.nodeValue.length));u.parentNode!=i;)u=u.parentNode;var c=e.measure,f=c.maps,h=n(a,u,r);if(h)return ol(h,l);for(var d=u.nextSibling,p=a?a.nodeValue.length-r:0;d;d=d.nextSibling){if(h=n(d,d.firstChild,0))return ol(E(h.line,h.ch-p),l);p+=d.textContent.length}for(var v=u.previousSibling,m=r;v;v=v.previousSibling){if(h=n(v,v.firstChild,-1))return ol(E(h.line,h.ch+m),l);m+=v.textContent.length}}var ul=navigator.userAgent,cl=navigator.platform,fl=/gecko\/\d/i.test(ul),hl=/MSIE \d/.test(ul),dl=/Trident\/(?:[7-9]|\d{2,})\..*rv:(\d+)/.exec(ul),pl=/Edge\/(\d+)/.exec(ul),gl=hl||dl||pl,vl=gl&&(hl?document.documentMode||6:+(pl||dl)[1]),ml=!pl&&/WebKit\//.test(ul),yl=ml&&/Qt\/\d+\.\d+/.test(ul),bl=!pl&&/Chrome\//.test(ul),wl=/Opera\//.test(ul),xl=/Apple Computer/.test(navigator.vendor),Cl=/Mac OS X 1\d\D([8-9]|\d\d)\D/.test(ul),Sl=/PhantomJS/.test(ul),Ll=!pl&&/AppleWebKit/.test(ul)&&/Mobile\/\w+/.test(ul),kl=/Android/.test(ul),Tl=Ll||kl||/webOS|BlackBerry|Opera Mini|Opera Mobi|IEMobile/i.test(ul),Ml=Ll||/Mac/.test(cl),Nl=/\bCrOS\b/.test(ul),Ol=/win/i.test(cl),Al=wl&&ul.match(/Version\/(\d*\.\d*)/);Al&&(Al=Number(Al[1])),Al&&Al>=15&&(wl=!1,ml=!0);var Wl,Dl=Ml&&(yl||wl&&(null==Al||Al<12.11)),Hl=fl||gl&&vl>=9,Fl=function(t,r){var n=t.className,i=e(r).exec(n);if(i){var o=n.slice(i.index+i[0].length);t.className=n.slice(0,i.index)+(o?i[1]+o:"")}};Wl=document.createRange?function(e,t,r,n){var i=document.createRange();return i.setEnd(n||e,r),i.setStart(e,t),i}:function(e,t,r){var n=document.body.createTextRange();try{n.moveToElementText(e.parentNode)}catch(e){return n}return n.collapse(!0),n.moveEnd("character",r),n.moveStart("character",t),n};var El=function(e){e.select()};Ll?El=function(e){e.selectionStart=0,e.selectionEnd=e.value.length}:gl&&(El=function(e){try{e.select()}catch(e){}});var Pl=function(){this.id=null};Pl.prototype.set=function(e,t){clearTimeout(this.id),this.id=setTimeout(t,e)};var Il,zl,Rl=30,Bl={toString:function(){return"CodeMirror.Pass"}},Gl={scroll:!1},Ul={origin:"*mouse"},Vl={origin:"+move"},Kl=[""],jl=/[\u00df\u0587\u0590-\u05f4\u0600-\u06ff\u3040-\u309f\u30a0-\u30ff\u3400-\u4db5\u4e00-\u9fcc\uac00-\ud7af]/,Xl=/[\u0300-\u036f\u0483-\u0489\u0591-\u05bd\u05bf\u05c1\u05c2\u05c4\u05c5\u05c7\u0610-\u061a\u064b-\u065e\u0670\u06d6-\u06dc\u06de-\u06e4\u06e7\u06e8\u06ea-\u06ed\u0711\u0730-\u074a\u07a6-\u07b0\u07eb-\u07f3\u0816-\u0819\u081b-\u0823\u0825-\u0827\u0829-\u082d\u0900-\u0902\u093c\u0941-\u0948\u094d\u0951-\u0955\u0962\u0963\u0981\u09bc\u09be\u09c1-\u09c4\u09cd\u09d7\u09e2\u09e3\u0a01\u0a02\u0a3c\u0a41\u0a42\u0a47\u0a48\u0a4b-\u0a4d\u0a51\u0a70\u0a71\u0a75\u0a81\u0a82\u0abc\u0ac1-\u0ac5\u0ac7\u0ac8\u0acd\u0ae2\u0ae3\u0b01\u0b3c\u0b3e\u0b3f\u0b41-\u0b44\u0b4d\u0b56\u0b57\u0b62\u0b63\u0b82\u0bbe\u0bc0\u0bcd\u0bd7\u0c3e-\u0c40\u0c46-\u0c48\u0c4a-\u0c4d\u0c55\u0c56\u0c62\u0c63\u0cbc\u0cbf\u0cc2\u0cc6\u0ccc\u0ccd\u0cd5\u0cd6\u0ce2\u0ce3\u0d3e\u0d41-\u0d44\u0d4d\u0d57\u0d62\u0d63\u0dca\u0dcf\u0dd2-\u0dd4\u0dd6\u0ddf\u0e31\u0e34-\u0e3a\u0e47-\u0e4e\u0eb1\u0eb4-\u0eb9\u0ebb\u0ebc\u0ec8-\u0ecd\u0f18\u0f19\u0f35\u0f37\u0f39\u0f71-\u0f7e\u0f80-\u0f84\u0f86\u0f87\u0f90-\u0f97\u0f99-\u0fbc\u0fc6\u102d-\u1030\u1032-\u1037\u1039\u103a\u103d\u103e\u1058\u1059\u105e-\u1060\u1071-\u1074\u1082\u1085\u1086\u108d\u109d\u135f\u1712-\u1714\u1732-\u1734\u1752\u1753\u1772\u1773\u17b7-\u17bd\u17c6\u17c9-\u17d3\u17dd\u180b-\u180d\u18a9\u1920-\u1922\u1927\u1928\u1932\u1939-\u193b\u1a17\u1a18\u1a56\u1a58-\u1a5e\u1a60\u1a62\u1a65-\u1a6c\u1a73-\u1a7c\u1a7f\u1b00-\u1b03\u1b34\u1b36-\u1b3a\u1b3c\u1b42\u1b6b-\u1b73\u1b80\u1b81\u1ba2-\u1ba5\u1ba8\u1ba9\u1c2c-\u1c33\u1c36\u1c37\u1cd0-\u1cd2\u1cd4-\u1ce0\u1ce2-\u1ce8\u1ced\u1dc0-\u1de6\u1dfd-\u1dff\u200c\u200d\u20d0-\u20f0\u2cef-\u2cf1\u2de0-\u2dff\u302a-\u302f\u3099\u309a\ua66f-\ua672\ua67c\ua67d\ua6f0\ua6f1\ua802\ua806\ua80b\ua825\ua826\ua8c4\ua8e0-\ua8f1\ua926-\ua92d\ua947-\ua951\ua980-\ua982\ua9b3\ua9b6-\ua9b9\ua9bc\uaa29-\uaa2e\uaa31\uaa32\uaa35\uaa36\uaa43\uaa4c\uaab0\uaab2-\uaab4\uaab7\uaab8\uaabe\uaabf\uaac1\uabe5\uabe8\uabed\udc00-\udfff\ufb1e\ufe00-\ufe0f\ufe20-\ufe26\uff9e\uff9f]/,Yl=!1,_l=!1,$l=null,ql=function(){function e(e){return e<=247?r.charAt(e):1424<=e&&e<=1524?"R":1536<=e&&e<=1785?n.charAt(e-1536):1774<=e&&e<=2220?"r":8192<=e&&e<=8203?"w":8204==e?"b":"L"}function t(e,t,r){this.level=e,this.from=t,this.to=r}var r="bbbbbbbbbtstwsbbbbbbbbbbbbbbssstwNN%%%NNNNNN,N,N1111111111NNNNNNNLLLLLLLLLLLLLLLLLLLLLLLLLLNNNNNNLLLLLLLLLLLLLLLLLLLLLLLLLLNNNNbbbbbbsbbbbbbbbbbbbbbbbbbbbbbbbbb,N%%%%NNNNLNNNNN%%11NLNNN1LNNNNNLLLLLLLLLLLLLLLLLLLLLLLNLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLN",n="nnnnnnNNr%%r,rNNmmmmmmmmmmmrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrmmmmmmmmmmmmmmmmmmmmmnnnnnnnnnn%nnrrrmrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrmmmmmmmnNmmmmmmrrmmNmmmmrr1111111111",i=/[\u0590-\u05f4\u0600-\u06ff\u0700-\u08ac]/,o=/[stwN]/,l=/[LRr]/,s=/[Lb1n]/,a=/[1n]/;return function(r,n){var u="ltr"==n?"L":"R";if(0==r.length||"ltr"==n&&!i.test(r))return!1;for(var c=r.length,f=[],h=0;h<c;++h)f.push(e(r.charCodeAt(h)));for(var d=0,p=u;d<c;++d){var v=f[d];"m"==v?f[d]=p:p=v}for(var m=0,y=u;m<c;++m){var b=f[m];"1"==b&&"r"==y?f[m]="n":l.test(b)&&(y=b,"r"==b&&(f[m]="R"))}for(var w=1,x=f[0];w<c-1;++w){var C=f[w];"+"==C&&"1"==x&&"1"==f[w+1]?f[w]="1":","!=C||x!=f[w+1]||"1"!=x&&"n"!=x||(f[w]=x),x=C}for(var S=0;S<c;++S){var L=f[S];if(","==L)f[S]="N";else if("%"==L){var k=void 0;for(k=S+1;k<c&&"%"==f[k];++k);for(var T=S&&"!"==f[S-1]||k<c&&"1"==f[k]?"1":"N",M=S;M<k;++M)f[M]=T;S=k-1}}for(var N=0,O=u;N<c;++N){var A=f[N];"L"==O&&"1"==A?f[N]="L":l.test(A)&&(O=A)}for(var W=0;W<c;++W)if(o.test(f[W])){var D=void 0;for(D=W+1;D<c&&o.test(f[D]);++D);for(var H="L"==(W?f[W-1]:u),F=H==("L"==(D<c?f[D]:u))?H?"L":"R":u,E=W;E<D;++E)f[E]=F;W=D-1}for(var P,I=[],z=0;z<c;)if(s.test(f[z])){var R=z;for(++z;z<c&&s.test(f[z]);++z);I.push(new t(0,R,z))}else{var B=z,G=I.length;for(++z;z<c&&"L"!=f[z];++z);for(var U=B;U<z;)if(a.test(f[U])){B<U&&I.splice(G,0,new t(1,B,U));var V=U;for(++U;U<z&&a.test(f[U]);++U);I.splice(G,0,new t(2,V,U)),B=U}else++U;B<z&&I.splice(G,0,new t(1,B,z))}return 1==I[0].level&&(P=r.match(/^\s+/))&&(I[0].from=P[0].length,I.unshift(new t(0,0,P[0].length))),1==g(I).level&&(P=r.match(/\s+$/))&&(g(I).to-=P[0].length,I.push(new t(0,c-P[0].length,c))),"rtl"==n?I.reverse():I}}(),Zl=[],Ql=function(e,t,r){if(e.addEventListener)e.addEventListener(t,r,!1);else if(e.attachEvent)e.attachEvent("on"+t,r);else{var n=e._handlers||(e._handlers={});n[t]=(n[t]||Zl).concat(r)}},Jl=function(){if(gl&&vl<9)return!1;var e=n("div");return"draggable"in e||"dragDrop"in e}(),es=3!="\n\nb".split(/\n/).length?function(e){for(var t=0,r=[],n=e.length;t<=n;){var i=e.indexOf("\n",t);-1==i&&(i=e.length);var o=e.slice(t,"\r"==e.charAt(i-1)?i-1:i),l=o.indexOf("\r");-1!=l?(r.push(o.slice(0,l)),t+=l+1):(r.push(o),t=i+1)}return r}:function(e){return e.split(/\r\n?|\n/)},ts=window.getSelection?function(e){try{return e.selectionStart!=e.selectionEnd}catch(e){return!1}}:function(e){var t;try{t=e.ownerDocument.selection.createRange()}catch(e){}return!(!t||t.parentElement()!=e)&&0!=t.compareEndPoints("StartToEnd",t)},rs=function(){var e=n("div");return"oncopy"in e||(e.setAttribute("oncopy","return;"),"function"==typeof e.oncopy)}(),ns=null,is={},os={},ls={},ss=function(e,t,r){this.pos=this.start=0,this.string=e,this.tabSize=t||8,this.lastColumnPos=this.lastColumnValue=0,this.lineStart=0,this.lineOracle=r};ss.prototype.eol=function(){return this.pos>=this.string.length},ss.prototype.sol=function(){return this.pos==this.lineStart},ss.prototype.peek=function(){return this.string.charAt(this.pos)||void 0},ss.prototype.next=function(){if(this.pos<this.string.length)return this.string.charAt(this.pos++)},ss.prototype.eat=function(e){var t=this.string.charAt(this.pos);if("string"==typeof e?t==e:t&&(e.test?e.test(t):e(t)))return++this.pos,t},ss.prototype.eatWhile=function(e){for(var t=this.pos;this.eat(e););return this.pos>t},ss.prototype.eatSpace=function(){for(var e=this,t=this.pos;/[\s\u00a0]/.test(this.string.charAt(this.pos));)++e.pos;return this.pos>t},ss.prototype.skipToEnd=function(){this.pos=this.string.length},ss.prototype.skipTo=function(e){var t=this.string.indexOf(e,this.pos);if(t>-1)return this.pos=t,!0},ss.prototype.backUp=function(e){this.pos-=e},ss.prototype.column=function(){return this.lastColumnPos<this.start&&(this.lastColumnValue=f(this.string,this.start,this.tabSize,this.lastColumnPos,this.lastColumnValue),this.lastColumnPos=this.start),this.lastColumnValue-(this.lineStart?f(this.string,this.lineStart,this.tabSize):0)},ss.prototype.indentation=function(){return f(this.string,null,this.tabSize)-(this.lineStart?f(this.string,this.lineStart,this.tabSize):0)},ss.prototype.match=function(e,t,r){if("string"!=typeof e){var n=this.string.slice(this.pos).match(e);return n&&n.index>0?null:(n&&!1!==t&&(this.pos+=n[0].length),n)}var i=function(e){return r?e.toLowerCase():e};if(i(this.string.substr(this.pos,e.length))==i(e))return!1!==t&&(this.pos+=e.length),!0},ss.prototype.current=function(){return this.string.slice(this.start,this.pos)},ss.prototype.hideFirstChars=function(e,t){this.lineStart+=e;try{return t()}finally{this.lineStart-=e}},ss.prototype.lookAhead=function(e){var t=this.lineOracle;return t&&t.lookAhead(e)};var as=function(e,t){this.state=e,this.lookAhead=t},us=function(e,t,r,n){this.state=t,this.doc=e,this.line=r,this.maxLookAhead=n||0};us.prototype.lookAhead=function(e){var t=this.doc.getLine(this.line+e);return null!=t&&e>this.maxLookAhead&&(this.maxLookAhead=e),t},us.prototype.nextLine=function(){this.line++,this.maxLookAhead>0&&this.maxLookAhead--},us.fromSaved=function(e,t,r){return t instanceof as?new us(e,Ke(e.mode,t.state),r,t.lookAhead):new us(e,Ke(e.mode,t),r)},us.prototype.save=function(e){var t=!1!==e?Ke(this.doc.mode,this.state):this.state;return this.maxLookAhead>0?new as(t,this.maxLookAhead):t};var cs=function(e,t,r){this.start=e.start,this.end=e.pos,this.string=e.current(),this.type=t||null,this.state=r},fs=function(e,t,r){this.text=e,ne(this,t),this.height=r?r(this):1};fs.prototype.lineNo=function(){return W(this)},Ae(fs);var hs,ds={},ps={},gs=null,vs=null,ms={left:0,right:0,top:0,bottom:0},ys=function(e,t,r){this.cm=r;var i=this.vert=n("div",[n("div",null,null,"min-width: 1px")],"CodeMirror-vscrollbar"),o=this.horiz=n("div",[n("div",null,null,"height: 100%; min-height: 1px")],"CodeMirror-hscrollbar");e(i),e(o),Ql(i,"scroll",function(){i.clientHeight&&t(i.scrollTop,"vertical")}),Ql(o,"scroll",function(){o.clientWidth&&t(o.scrollLeft,"horizontal")}),this.checkedZeroWidth=!1,gl&&vl<8&&(this.horiz.style.minHeight=this.vert.style.minWidth="18px")};ys.prototype.update=function(e){var t=e.scrollWidth>e.clientWidth+1,r=e.scrollHeight>e.clientHeight+1,n=e.nativeBarWidth;if(r){this.vert.style.display="block",this.vert.style.bottom=t?n+"px":"0";var i=e.viewHeight-(t?n:0);this.vert.firstChild.style.height=Math.max(0,e.scrollHeight-e.clientHeight+i)+"px"}else this.vert.style.display="",this.vert.firstChild.style.height="0";if(t){this.horiz.style.display="block",this.horiz.style.right=r?n+"px":"0",this.horiz.style.left=e.barLeft+"px";var o=e.viewWidth-e.barLeft-(r?n:0);this.horiz.firstChild.style.width=Math.max(0,e.scrollWidth-e.clientWidth+o)+"px"}else this.horiz.style.display="",this.horiz.firstChild.style.width="0";return!this.checkedZeroWidth&&e.clientHeight>0&&(0==n&&this.zeroWidthHack(),this.checkedZeroWidth=!0),{right:r?n:0,bottom:t?n:0}},ys.prototype.setScrollLeft=function(e){this.horiz.scrollLeft!=e&&(this.horiz.scrollLeft=e),this.disableHoriz&&this.enableZeroWidthBar(this.horiz,this.disableHoriz,"horiz")},ys.prototype.setScrollTop=function(e){this.vert.scrollTop!=e&&(this.vert.scrollTop=e),this.disableVert&&this.enableZeroWidthBar(this.vert,this.disableVert,"vert")},ys.prototype.zeroWidthHack=function(){var e=Ml&&!Cl?"12px":"18px";this.horiz.style.height=this.vert.style.width=e,this.horiz.style.pointerEvents=this.vert.style.pointerEvents="none",this.disableHoriz=new Pl,this.disableVert=new Pl},ys.prototype.enableZeroWidthBar=function(e,t,r){function n(){var i=e.getBoundingClientRect();("vert"==r?document.elementFromPoint(i.right-1,(i.top+i.bottom)/2):document.elementFromPoint((i.right+i.left)/2,i.bottom-1))!=e?e.style.pointerEvents="none":t.set(1e3,n)}e.style.pointerEvents="auto",t.set(1e3,n)},ys.prototype.clear=function(){var e=this.horiz.parentNode;e.removeChild(this.horiz),e.removeChild(this.vert)};var bs=function(){};bs.prototype.update=function(){return{bottom:0,right:0}},bs.prototype.setScrollLeft=function(){},bs.prototype.setScrollTop=function(){},bs.prototype.clear=function(){};var ws={native:ys,null:bs},xs=0,Cs=function(e,t,r){var n=e.display;this.viewport=t,this.visible=Ir(n,e.doc,t),this.editorIsHidden=!n.wrapper.offsetWidth,this.wrapperHeight=n.wrapper.clientHeight,this.wrapperWidth=n.wrapper.clientWidth,this.oldDisplayWidth=Rt(e),this.force=r,this.dims=br(e),this.events=[]};Cs.prototype.signal=function(e,t){Oe(e,t)&&this.events.push(arguments)},Cs.prototype.finish=function(){for(var e=this,t=0;t<this.events.length;t++)Te.apply(null,e.events[t])};var Ss=0,Ls=null;gl?Ls=-.53:fl?Ls=15:bl?Ls=-.7:xl&&(Ls=-1/3);var ks=function(e,t){this.ranges=e,this.primIndex=t};ks.prototype.primary=function(){return this.ranges[this.primIndex]},ks.prototype.equals=function(e){var t=this;if(e==this)return!0;if(e.primIndex!=this.primIndex||e.ranges.length!=this.ranges.length)return!1;for(var r=0;r<this.ranges.length;r++){var n=t.ranges[r],i=e.ranges[r];if(!I(n.anchor,i.anchor)||!I(n.head,i.head))return!1}return!0},ks.prototype.deepCopy=function(){for(var e=this,t=[],r=0;r<this.ranges.length;r++)t[r]=new Ts(z(e.ranges[r].anchor),z(e.ranges[r].head));return new ks(t,this.primIndex)},ks.prototype.somethingSelected=function(){for(var e=this,t=0;t<this.ranges.length;t++)if(!e.ranges[t].empty())return!0;return!1},ks.prototype.contains=function(e,t){var r=this;t||(t=e);for(var n=0;n<this.ranges.length;n++){var i=r.ranges[n];if(P(t,i.from())>=0&&P(e,i.to())<=0)return n}return-1};var Ts=function(e,t){this.anchor=e,this.head=t};Ts.prototype.from=function(){return B(this.anchor,this.head)},Ts.prototype.to=function(){return R(this.anchor,this.head)},Ts.prototype.empty=function(){return this.head.line==this.anchor.line&&this.head.ch==this.anchor.ch},Bi.prototype={chunkSize:function(){return this.lines.length},removeInner:function(e,t){for(var r=this,n=e,i=e+t;n<i;++n){var o=r.lines[n];r.height-=o.height,ot(o),bt(o,"delete")}this.lines.splice(e,t)},collapse:function(e){e.push.apply(e,this.lines)},insertInner:function(e,t,r){var n=this;this.height+=r,this.lines=this.lines.slice(0,e).concat(t).concat(this.lines.slice(e));for(var i=0;i<t.length;++i)t[i].parent=n},iterN:function(e,t,r){for(var n=this,i=e+t;e<i;++e)if(r(n.lines[e]))return!0}},Gi.prototype={chunkSize:function(){return this.size},removeInner:function(e,t){var r=this;this.size-=t;for(var n=0;n<this.children.length;++n){var i=r.children[n],o=i.chunkSize();if(e<o){var l=Math.min(t,o-e),s=i.height;if(i.removeInner(e,l),r.height-=s-i.height,o==l&&(r.children.splice(n--,1),i.parent=null),0==(t-=l))break;e=0}else e-=o}if(this.size-t<25&&(this.children.length>1||!(this.children[0]instanceof Bi))){var a=[];this.collapse(a),this.children=[new Bi(a)],this.children[0].parent=this}},collapse:function(e){for(var t=this,r=0;r<this.children.length;++r)t.children[r].collapse(e)},insertInner:function(e,t,r){var n=this;this.size+=t.length,this.height+=r;for(var i=0;i<this.children.length;++i){var o=n.children[i],l=o.chunkSize();if(e<=l){if(o.insertInner(e,t,r),o.lines&&o.lines.length>50){for(var s=o.lines.length%25+25,a=s;a<o.lines.length;){var u=new Bi(o.lines.slice(a,a+=25));o.height-=u.height,n.children.splice(++i,0,u),u.parent=n}o.lines=o.lines.slice(0,s),n.maybeSpill()}break}e-=l}},maybeSpill:function(){if(!(this.children.length<=10)){var e=this;do{var t=new Gi(e.children.splice(e.children.length-5,5));if(e.parent){e.size-=t.size,e.height-=t.height;var r=h(e.parent.children,e);e.parent.children.splice(r+1,0,t)}else{var n=new Gi(e.children);n.parent=e,e.children=[n,t],e=n}t.parent=e.parent}while(e.children.length>10);e.parent.maybeSpill()}},iterN:function(e,t,r){for(var n=this,i=0;i<this.children.length;++i){var o=n.children[i],l=o.chunkSize();if(e<l){var s=Math.min(t,l-e);if(o.iterN(e,s,r))return!0;if(0==(t-=s))break;e=0}else e-=l}}};var Ms=function(e,t,r){var n=this;if(r)for(var i in r)r.hasOwnProperty(i)&&(n[i]=r[i]);this.doc=e,this.node=t};Ms.prototype.clear=function(){var e=this,t=this.doc.cm,r=this.line.widgets,n=this.line,i=W(n);if(null!=i&&r){for(var o=0;o<r.length;++o)r[o]==e&&r.splice(o--,1);r.length||(n.widgets=null);var l=Ht(this);A(n,Math.max(0,n.height-l)),t&&(hn(t,function(){Ui(t,n,-l),mn(t,i,"widget")}),bt(t,"lineWidgetCleared",t,this,i))}},Ms.prototype.changed=function(){var e=this,t=this.height,r=this.doc.cm,n=this.line;this.height=null;var i=Ht(this)-t;i&&(A(n,n.height+i),r&&hn(r,function(){r.curOp.forceUpdate=!0,Ui(r,n,i),bt(r,"lineWidgetChanged",r,e,W(n))}))},Ae(Ms);var Ns=0,Os=function(e,t){this.lines=[],this.type=t,this.doc=e,this.id=++Ns};Os.prototype.clear=function(){var e=this;if(!this.explicitlyCleared){var t=this.doc.cm,r=t&&!t.curOp;if(r&&nn(t),Oe(this,"clear")){var n=this.find();n&&bt(this,"clear",n.from,n.to)}for(var i=null,o=null,l=0;l<this.lines.length;++l){var s=e.lines[l],a=_(s.markedSpans,e);t&&!e.collapsed?mn(t,W(s),"text"):t&&(null!=a.to&&(o=W(s)),null!=a.from&&(i=W(s))),s.markedSpans=$(s.markedSpans,a),null==a.from&&e.collapsed&&!ve(e.doc,s)&&t&&A(s,mr(t.display))}if(t&&this.collapsed&&!t.options.lineWrapping)for(var u=0;u<this.lines.length;++u){var c=fe(e.lines[u]),f=be(c);f>t.display.maxLineLength&&(t.display.maxLine=c,t.display.maxLineLength=f,t.display.maxLineChanged=!0)}null!=i&&t&&this.collapsed&&vn(t,i,o+1),this.lines.length=0,this.explicitlyCleared=!0,this.atomic&&this.doc.cantEdit&&(this.doc.cantEdit=!1,t&&Ci(t.doc)),t&&bt(t,"markerCleared",t,this,i,o),r&&on(t),this.parent&&this.parent.clear()}},Os.prototype.find=function(e,t){var r=this;null==e&&"bookmark"==this.type&&(e=1);for(var n,i,o=0;o<this.lines.length;++o){var l=r.lines[o],s=_(l.markedSpans,r);if(null!=s.from&&(n=E(t?l:W(l),s.from),-1==e))return n;if(null!=s.to&&(i=E(t?l:W(l),s.to),1==e))return i}return n&&{from:n,to:i}},Os.prototype.changed=function(){var e=this,t=this.find(-1,!0),r=this,n=this.doc.cm;t&&n&&hn(n,function(){var i=t.line,o=W(t.line),l=jt(n,o);if(l&&(Qt(l),n.curOp.selectionChanged=n.curOp.forceUpdate=!0),n.curOp.updateMaxLine=!0,!ve(r.doc,i)&&null!=r.height){var s=r.height;r.height=null;var a=Ht(r)-s;a&&A(i,i.height+a)}bt(n,"markerChanged",n,e)})},Os.prototype.attachLine=function(e){if(!this.lines.length&&this.doc.cm){var t=this.doc.cm.curOp;t.maybeHiddenMarkers&&-1!=h(t.maybeHiddenMarkers,this)||(t.maybeUnhiddenMarkers||(t.maybeUnhiddenMarkers=[])).push(this)}this.lines.push(e)},Os.prototype.detachLine=function(e){if(this.lines.splice(h(this.lines,e),1),!this.lines.length&&this.doc.cm){var t=this.doc.cm.curOp;(t.maybeHiddenMarkers||(t.maybeHiddenMarkers=[])).push(this)}},Ae(Os);var As=function(e,t){var r=this;this.markers=e,this.primary=t;for(var n=0;n<e.length;++n)e[n].parent=r};As.prototype.clear=function(){var e=this;if(!this.explicitlyCleared){this.explicitlyCleared=!0;for(var t=0;t<this.markers.length;++t)e.markers[t].clear();bt(this,"clear")}},As.prototype.find=function(e,t){return this.primary.find(e,t)},Ae(As);var Ws=0,Ds=function(e,t,r,n,i){if(!(this instanceof Ds))return new Ds(e,t,r,n,i);null==r&&(r=0),Gi.call(this,[new Bi([new fs("",null)])]),this.first=r,this.scrollTop=this.scrollLeft=0,this.cantEdit=!1,this.cleanGeneration=1,this.modeFrontier=this.highlightFrontier=r;var o=E(r,0);this.sel=Rn(o),this.history=new Jn(null),this.id=++Ws,this.modeOption=t,this.lineSep=n,this.direction="rtl"==i?"rtl":"ltr",this.extend=!1,"string"==typeof e&&(e=this.splitLines(e)),_n(this,{from:o,to:o,text:e}),bi(this,Rn(o),Gl)};Ds.prototype=b(Gi.prototype,{constructor:Ds,iter:function(e,t,r){r?this.iterN(e-this.first,t-e,r):this.iterN(this.first,this.first+this.size,e)},insert:function(e,t){for(var r=0,n=0;n<t.length;++n)r+=t[n].height;this.insertInner(e-this.first,t,r)},remove:function(e,t){this.removeInner(e-this.first,t)},getValue:function(e){var t=O(this,this.first,this.first+this.size);return!1===e?t:t.join(e||this.lineSeparator())},setValue:gn(function(e){var t=E(this.first,0),r=this.first+this.size-1;Oi(this,{from:t,to:E(r,M(this,r).text.length),text:this.splitLines(e),origin:"setValue",full:!0},!0),this.cm&&Xr(this.cm,0,0),bi(this,Rn(t),Gl)}),replaceRange:function(e,t,r,n){Ei(this,e,t=U(this,t),r=r?U(this,r):t,n)},getRange:function(e,t,r){var n=N(this,U(this,e),U(this,t));return!1===r?n:n.join(r||this.lineSeparator())},getLine:function(e){var t=this.getLineHandle(e);return t&&t.text},getLineHandle:function(e){if(H(this,e))return M(this,e)},getLineNumber:function(e){return W(e)},getLineHandleVisualStart:function(e){return"number"==typeof e&&(e=M(this,e)),fe(e)},lineCount:function(){return this.size},firstLine:function(){return this.first},lastLine:function(){return this.first+this.size-1},clipPos:function(e){return U(this,e)},getCursor:function(e){var t=this.sel.primary();return null==e||"head"==e?t.head:"anchor"==e?t.anchor:"end"==e||"to"==e||!1===e?t.to():t.from()},listSelections:function(){return this.sel.ranges},somethingSelected:function(){return this.sel.somethingSelected()},setCursor:gn(function(e,t,r){vi(this,U(this,"number"==typeof e?E(e,t||0):e),null,r)}),setSelection:gn(function(e,t,r){vi(this,U(this,e),U(this,t||e),r)}),extendSelection:gn(function(e,t,r){di(this,U(this,e),t&&U(this,t),r)}),extendSelections:gn(function(e,t){pi(this,K(this,e),t)}),extendSelectionsBy:gn(function(e,t){pi(this,K(this,v(this.sel.ranges,e)),t)}),setSelections:gn(function(e,t,r){var n=this;if(e.length){for(var i=[],o=0;o<e.length;o++)i[o]=new Ts(U(n,e[o].anchor),U(n,e[o].head));null==t&&(t=Math.min(e.length-1,this.sel.primIndex)),bi(this,zn(i,t),r)}}),addSelection:gn(function(e,t,r){var n=this.sel.ranges.slice(0);n.push(new Ts(U(this,e),U(this,t||e))),bi(this,zn(n,n.length-1),r)}),getSelection:function(e){for(var t,r=this,n=this.sel.ranges,i=0;i<n.length;i++){var o=N(r,n[i].from(),n[i].to());t=t?t.concat(o):o}return!1===e?t:t.join(e||this.lineSeparator())},getSelections:function(e){for(var t=this,r=[],n=this.sel.ranges,i=0;i<n.length;i++){var o=N(t,n[i].from(),n[i].to());!1!==e&&(o=o.join(e||t.lineSeparator())),r[i]=o}return r},replaceSelection:function(e,t,r){for(var n=[],i=0;i<this.sel.ranges.length;i++)n[i]=e;this.replaceSelections(n,t,r||"+input")},replaceSelections:gn(function(e,t,r){for(var n=this,i=[],o=this.sel,l=0;l<o.ranges.length;l++){var s=o.ranges[l];i[l]={from:s.from(),to:s.to(),text:n.splitLines(e[l]),origin:r}}for(var a=t&&"end"!=t&&Kn(this,i,t),u=i.length-1;u>=0;u--)Oi(n,i[u]);a?yi(this,a):this.cm&&jr(this.cm)}),undo:gn(function(){Wi(this,"undo")}),redo:gn(function(){Wi(this,"redo")}),undoSelection:gn(function(){Wi(this,"undo",!0)}),redoSelection:gn(function(){Wi(this,"redo",!0)}),setExtending:function(e){this.extend=e},getExtending:function(){return this.extend},historySize:function(){for(var e=this.history,t=0,r=0,n=0;n<e.done.length;n++)e.done[n].ranges||++t;for(var i=0;i<e.undone.length;i++)e.undone[i].ranges||++r;return{undo:t,redo:r}},clearHistory:function(){this.history=new Jn(this.history.maxGeneration)},markClean:function(){this.cleanGeneration=this.changeGeneration(!0)},changeGeneration:function(e){return e&&(this.history.lastOp=this.history.lastSelOp=this.history.lastOrigin=null),this.history.generation},isClean:function(e){return this.history.generation==(e||this.cleanGeneration)},getHistory:function(){return{done:fi(this.history.done),undone:fi(this.history.undone)}},setHistory:function(e){var t=this.history=new Jn(this.history.maxGeneration);t.done=fi(e.done.slice(0),null,!0),t.undone=fi(e.undone.slice(0),null,!0)},setGutterMarker:gn(function(e,t,r){return Ri(this,e,"gutter",function(e){var n=e.gutterMarkers||(e.gutterMarkers={});return n[t]=r,!r&&C(n)&&(e.gutterMarkers=null),!0})}),clearGutter:gn(function(e){var t=this;this.iter(function(r){r.gutterMarkers&&r.gutterMarkers[e]&&Ri(t,r,"gutter",function(){return r.gutterMarkers[e]=null,C(r.gutterMarkers)&&(r.gutterMarkers=null),!0})})}),lineInfo:function(e){var t;if("number"==typeof e){if(!H(this,e))return null;if(t=e,!(e=M(this,e)))return null}else if(null==(t=W(e)))return null;return{line:t,handle:e,text:e.text,gutterMarkers:e.gutterMarkers,textClass:e.textClass,bgClass:e.bgClass,wrapClass:e.wrapClass,widgets:e.widgets}},addLineClass:gn(function(t,r,n){return Ri(this,t,"gutter"==r?"gutter":"class",function(t){var i="text"==r?"textClass":"background"==r?"bgClass":"gutter"==r?"gutterClass":"wrapClass";if(t[i]){if(e(n).test(t[i]))return!1;t[i]+=" "+n}else t[i]=n;return!0})}),removeLineClass:gn(function(t,r,n){return Ri(this,t,"gutter"==r?"gutter":"class",function(t){var i="text"==r?"textClass":"background"==r?"bgClass":"gutter"==r?"gutterClass":"wrapClass",o=t[i];if(!o)return!1;if(null==n)t[i]=null;else{var l=o.match(e(n));if(!l)return!1;var s=l.index+l[0].length;t[i]=o.slice(0,l.index)+(l.index&&s!=o.length?" ":"")+o.slice(s)||null}return!0})}),addLineWidget:gn(function(e,t,r){return Vi(this,e,t,r)}),removeLineWidget:function(e){e.clear()},markText:function(e,t,r){return Ki(this,U(this,e),U(this,t),r,r&&r.type||"range")},setBookmark:function(e,t){var r={replacedWith:t&&(null==t.nodeType?t.widget:t),insertLeft:t&&t.insertLeft,clearWhenEmpty:!1,shared:t&&t.shared,handleMouseEvents:t&&t.handleMouseEvents};return e=U(this,e),Ki(this,e,e,r,"bookmark")},findMarksAt:function(e){var t=[],r=M(this,(e=U(this,e)).line).markedSpans;if(r)for(var n=0;n<r.length;++n){var i=r[n];(null==i.from||i.from<=e.ch)&&(null==i.to||i.to>=e.ch)&&t.push(i.marker.parent||i.marker)}return t},findMarks:function(e,t,r){e=U(this,e),t=U(this,t);var n=[],i=e.line;return this.iter(e.line,t.line+1,function(o){var l=o.markedSpans;if(l)for(var s=0;s<l.length;s++){var a=l[s];null!=a.to&&i==e.line&&e.ch>=a.to||null==a.from&&i!=e.line||null!=a.from&&i==t.line&&a.from>=t.ch||r&&!r(a.marker)||n.push(a.marker.parent||a.marker)}++i}),n},getAllMarks:function(){var e=[];return this.iter(function(t){var r=t.markedSpans;if(r)for(var n=0;n<r.length;++n)null!=r[n].from&&e.push(r[n].marker)}),e},posFromIndex:function(e){var t,r=this.first,n=this.lineSeparator().length;return this.iter(function(i){var o=i.text.length+n;if(o>e)return t=e,!0;e-=o,++r}),U(this,E(r,t))},indexFromPos:function(e){var t=(e=U(this,e)).ch;if(e.line<this.first||e.ch<0)return 0;var r=this.lineSeparator().length;return this.iter(this.first,e.line,function(e){t+=e.text.length+r}),t},copy:function(e){var t=new Ds(O(this,this.first,this.first+this.size),this.modeOption,this.first,this.lineSep,this.direction);return t.scrollTop=this.scrollTop,t.scrollLeft=this.scrollLeft,t.sel=this.sel,t.extend=!1,e&&(t.history.undoDepth=this.history.undoDepth,t.setHistory(this.getHistory())),t},linkedDoc:function(e){e||(e={});var t=this.first,r=this.first+this.size;null!=e.from&&e.from>t&&(t=e.from),null!=e.to&&e.to<r&&(r=e.to);var n=new Ds(O(this,t,r),e.mode||this.modeOption,t,this.lineSep,this.direction);return e.sharedHist&&(n.history=this.history),(this.linked||(this.linked=[])).push({doc:n,sharedHist:e.sharedHist}),n.linked=[{doc:this,isParent:!0,sharedHist:e.sharedHist}],Yi(n,Xi(this)),n},unlinkDoc:function(e){var t=this;if(e instanceof jo&&(e=e.doc),this.linked)for(var r=0;r<this.linked.length;++r)if(t.linked[r].doc==e){t.linked.splice(r,1),e.unlinkDoc(t),_i(Xi(t));break}if(e.history==this.history){var n=[e.id];$n(e,function(e){return n.push(e.id)},!0),e.history=new Jn(null),e.history.done=fi(this.history.done,n),e.history.undone=fi(this.history.undone,n)}},iterLinkedDocs:function(e){$n(this,e)},getMode:function(){return this.mode},getEditor:function(){return this.cm},splitLines:function(e){return this.lineSep?e.split(this.lineSep):es(e)},lineSeparator:function(){return this.lineSep||"\n"},setDirection:gn(function(e){"rtl"!=e&&(e="ltr"),e!=this.direction&&(this.direction=e,this.iter(function(e){return e.order=null}),this.cm&&Qn(this.cm))})}),Ds.prototype.eachLine=Ds.prototype.iter;for(var Hs=0,Fs=!1,Es={3:"Enter",8:"Backspace",9:"Tab",13:"Enter",16:"Shift",17:"Ctrl",18:"Alt",19:"Pause",20:"CapsLock",27:"Esc",32:"Space",33:"PageUp",34:"PageDown",35:"End",36:"Home",37:"Left",38:"Up",39:"Right",40:"Down",44:"PrintScrn",45:"Insert",46:"Delete",59:";",61:"=",91:"Mod",92:"Mod",93:"Mod",106:"*",107:"=",109:"-",110:".",111:"/",127:"Delete",173:"-",186:";",187:"=",188:",",189:"-",190:".",191:"/",192:"`",219:"[",220:"\\",221:"]",222:"'",63232:"Up",63233:"Down",63234:"Left",63235:"Right",63272:"Delete",63273:"Home",63275:"End",63276:"PageUp",63277:"PageDown",63302:"Insert"},Ps=0;Ps<10;Ps++)Es[Ps+48]=Es[Ps+96]=String(Ps);for(var Is=65;Is<=90;Is++)Es[Is]=String.fromCharCode(Is);for(var zs=1;zs<=12;zs++)Es[zs+111]=Es[zs+63235]="F"+zs;var Rs={};Rs.basic={Left:"goCharLeft",Right:"goCharRight",Up:"goLineUp",Down:"goLineDown",End:"goLineEnd",Home:"goLineStartSmart",PageUp:"goPageUp",PageDown:"goPageDown",Delete:"delCharAfter",Backspace:"delCharBefore","Shift-Backspace":"delCharBefore",Tab:"defaultTab","Shift-Tab":"indentAuto",Enter:"newlineAndIndent",Insert:"toggleOverwrite",Esc:"singleSelection"},Rs.pcDefault={"Ctrl-A":"selectAll","Ctrl-D":"deleteLine","Ctrl-Z":"undo","Shift-Ctrl-Z":"redo","Ctrl-Y":"redo","Ctrl-Home":"goDocStart","Ctrl-End":"goDocEnd","Ctrl-Up":"goLineUp","Ctrl-Down":"goLineDown","Ctrl-Left":"goGroupLeft","Ctrl-Right":"goGroupRight","Alt-Left":"goLineStart","Alt-Right":"goLineEnd","Ctrl-Backspace":"delGroupBefore","Ctrl-Delete":"delGroupAfter","Ctrl-S":"save","Ctrl-F":"find","Ctrl-G":"findNext","Shift-Ctrl-G":"findPrev","Shift-Ctrl-F":"replace","Shift-Ctrl-R":"replaceAll","Ctrl-[":"indentLess","Ctrl-]":"indentMore","Ctrl-U":"undoSelection","Shift-Ctrl-U":"redoSelection","Alt-U":"redoSelection",fallthrough:"basic"},Rs.emacsy={"Ctrl-F":"goCharRight","Ctrl-B":"goCharLeft","Ctrl-P":"goLineUp","Ctrl-N":"goLineDown","Alt-F":"goWordRight","Alt-B":"goWordLeft","Ctrl-A":"goLineStart","Ctrl-E":"goLineEnd","Ctrl-V":"goPageDown","Shift-Ctrl-V":"goPageUp","Ctrl-D":"delCharAfter","Ctrl-H":"delCharBefore","Alt-D":"delWordAfter","Alt-Backspace":"delWordBefore","Ctrl-K":"killLine","Ctrl-T":"transposeChars","Ctrl-O":"openLine"},Rs.macDefault={"Cmd-A":"selectAll","Cmd-D":"deleteLine","Cmd-Z":"undo","Shift-Cmd-Z":"redo","Cmd-Y":"redo","Cmd-Home":"goDocStart","Cmd-Up":"goDocStart","Cmd-End":"goDocEnd","Cmd-Down":"goDocEnd","Alt-Left":"goGroupLeft","Alt-Right":"goGroupRight","Cmd-Left":"goLineLeft","Cmd-Right":"goLineRight","Alt-Backspace":"delGroupBefore","Ctrl-Alt-Backspace":"delGroupAfter","Alt-Delete":"delGroupAfter","Cmd-S":"save","Cmd-F":"find","Cmd-G":"findNext","Shift-Cmd-G":"findPrev","Cmd-Alt-F":"replace","Shift-Cmd-Alt-F":"replaceAll","Cmd-[":"indentLess","Cmd-]":"indentMore","Cmd-Backspace":"delWrappedLineLeft","Cmd-Delete":"delWrappedLineRight","Cmd-U":"undoSelection","Shift-Cmd-U":"redoSelection","Ctrl-Up":"goDocStart","Ctrl-Down":"goDocEnd",fallthrough:["basic","emacsy"]},Rs.default=Ml?Rs.macDefault:Rs.pcDefault;var Bs={selectAll:Mi,singleSelection:function(e){return e.setSelection(e.getCursor("anchor"),e.getCursor("head"),Gl)},killLine:function(e){return co(e,function(t){if(t.empty()){var r=M(e.doc,t.head.line).text.length;return t.head.ch==r&&t.head.line<e.lastLine()?{from:t.head,to:E(t.head.line+1,0)}:{from:t.head,to:E(t.head.line,r)}}return{from:t.from(),to:t.to()}})},deleteLine:function(e){return co(e,function(t){return{from:E(t.from().line,0),to:U(e.doc,E(t.to().line+1,0))}})},delLineLeft:function(e){return co(e,function(e){return{from:E(e.from().line,0),to:e.from()}})},delWrappedLineLeft:function(e){return co(e,function(t){var r=e.charCoords(t.head,"div").top+5;return{from:e.coordsChar({left:0,top:r},"div"),to:t.from()}})},delWrappedLineRight:function(e){return co(e,function(t){var r=e.charCoords(t.head,"div").top+5,n=e.coordsChar({left:e.display.lineDiv.offsetWidth+100,top:r},"div");return{from:t.from(),to:n}})},undo:function(e){return e.undo()},redo:function(e){return e.redo()},undoSelection:function(e){return e.undoSelection()},redoSelection:function(e){return e.redoSelection()},goDocStart:function(e){return e.extendSelection(E(e.firstLine(),0))},goDocEnd:function(e){return e.extendSelection(E(e.lastLine()))},goLineStart:function(e){return e.extendSelectionsBy(function(t){return vo(e,t.head.line)},{origin:"+move",bias:1})},goLineStartSmart:function(e){return e.extendSelectionsBy(function(t){return yo(e,t.head)},{origin:"+move",bias:1})},goLineEnd:function(e){return e.extendSelectionsBy(function(t){return mo(e,t.head.line)},{origin:"+move",bias:-1})},goLineRight:function(e){return e.extendSelectionsBy(function(t){var r=e.cursorCoords(t.head,"div").top+5;return e.coordsChar({left:e.display.lineDiv.offsetWidth+100,top:r},"div")},Vl)},goLineLeft:function(e){return e.extendSelectionsBy(function(t){var r=e.cursorCoords(t.head,"div").top+5;return e.coordsChar({left:0,top:r},"div")},Vl)},goLineLeftSmart:function(e){return e.extendSelectionsBy(function(t){var r=e.cursorCoords(t.head,"div").top+5,n=e.coordsChar({left:0,top:r},"div");return n.ch<e.getLine(n.line).search(/\S/)?yo(e,t.head):n},Vl)},goLineUp:function(e){return e.moveV(-1,"line")},goLineDown:function(e){return e.moveV(1,"line")},goPageUp:function(e){return e.moveV(-1,"page")},goPageDown:function(e){return e.moveV(1,"page")},goCharLeft:function(e){return e.moveH(-1,"char")},goCharRight:function(e){return e.moveH(1,"char")},goColumnLeft:function(e){return e.moveH(-1,"column")},goColumnRight:function(e){return e.moveH(1,"column")},goWordLeft:function(e){return e.moveH(-1,"word")},goGroupRight:function(e){return e.moveH(1,"group")},goGroupLeft:function(e){return e.moveH(-1,"group")},goWordRight:function(e){return e.moveH(1,"word")},delCharBefore:function(e){return e.deleteH(-1,"char")},delCharAfter:function(e){return e.deleteH(1,"char")},delWordBefore:function(e){return e.deleteH(-1,"word")},delWordAfter:function(e){return e.deleteH(1,"word")},delGroupBefore:function(e){return e.deleteH(-1,"group")},delGroupAfter:function(e){return e.deleteH(1,"group")},indentAuto:function(e){return e.indentSelection("smart")},indentMore:function(e){return e.indentSelection("add")},indentLess:function(e){return e.indentSelection("subtract")},insertTab:function(e){return e.replaceSelection("\t")},insertSoftTab:function(e){for(var t=[],r=e.listSelections(),n=e.options.tabSize,i=0;i<r.length;i++){var o=r[i].from(),l=f(e.getLine(o.line),o.ch,n);t.push(p(n-l%n))}e.replaceSelections(t)},defaultTab:function(e){e.somethingSelected()?e.indentSelection("add"):e.execCommand("insertTab")},transposeChars:function(e){return hn(e,function(){for(var t=e.listSelections(),r=[],n=0;n<t.length;n++)if(t[n].empty()){var i=t[n].head,o=M(e.doc,i.line).text;if(o)if(i.ch==o.length&&(i=new E(i.line,i.ch-1)),i.ch>0)i=new E(i.line,i.ch+1),e.replaceRange(o.charAt(i.ch-1)+o.charAt(i.ch-2),E(i.line,i.ch-2),i,"+transpose");else if(i.line>e.doc.first){var l=M(e.doc,i.line-1).text;l&&(i=new E(i.line,1),e.replaceRange(o.charAt(0)+e.doc.lineSeparator()+l.charAt(l.length-1),E(i.line-1,l.length-1),i,"+transpose"))}r.push(new Ts(i,i))}e.setSelections(r)})},newlineAndIndent:function(e){return hn(e,function(){for(var t=e.listSelections(),r=t.length-1;r>=0;r--)e.replaceRange(e.doc.lineSeparator(),t[r].anchor,t[r].head,"+input");t=e.listSelections();for(var n=0;n<t.length;n++)e.indentLine(t[n].from().line,null,!0);jr(e)})},openLine:function(e){return e.replaceSelection("\n","start")},toggleOverwrite:function(e){return e.toggleOverwrite()}},Gs=new Pl,Us=null,Vs=function(e,t,r){this.time=e,this.pos=t,this.button=r};Vs.prototype.compare=function(e,t,r){return this.time+400>e&&0==P(t,this.pos)&&r==this.button};var Ks,js,Xs={toString:function(){return"CodeMirror.Init"}},Ys={},_s={};jo.defaults=Ys,jo.optionHandlers=_s;var $s=[];jo.defineInitHook=function(e){return $s.push(e)};var qs=null,Zs=function(e){this.cm=e,this.lastAnchorNode=this.lastAnchorOffset=this.lastFocusNode=this.lastFocusOffset=null,this.polling=new Pl,this.composing=null,this.gracePeriod=!1,this.readDOMTimeout=null};Zs.prototype.init=function(e){function t(e){if(!Me(i,e)){if(i.somethingSelected())_o({lineWise:!1,text:i.getSelections()}),"cut"==e.type&&i.replaceSelection("",null,"cut");else{if(!i.options.lineWiseCopyCut)return;var t=Qo(i);_o({lineWise:!0,text:t.text}),"cut"==e.type&&i.operation(function(){i.setSelections(t.ranges,0,Gl),i.replaceSelection("",null,"cut")})}if(e.clipboardData){e.clipboardData.clearData();var r=qs.text.join("\n");if(e.clipboardData.setData("Text",r),e.clipboardData.getData("Text")==r)return void e.preventDefault()}var l=el(),s=l.firstChild;i.display.lineSpace.insertBefore(l,i.display.lineSpace.firstChild),s.value=qs.text.join("\n");var a=document.activeElement;El(s),setTimeout(function(){i.display.lineSpace.removeChild(l),a.focus(),a==o&&n.showPrimarySelection()},50)}}var r=this,n=this,i=n.cm,o=n.div=e.lineDiv;Jo(o,i.options.spellcheck),Ql(o,"paste",function(e){Me(i,e)||qo(e,i)||vl<=11&&setTimeout(dn(i,function(){return r.updateFromDOM()}),20)}),Ql(o,"compositionstart",function(e){r.composing={data:e.data,done:!1}}),Ql(o,"compositionupdate",function(e){r.composing||(r.composing={data:e.data,done:!1})}),Ql(o,"compositionend",function(e){r.composing&&(e.data!=r.composing.data&&r.readFromDOMSoon(),r.composing.done=!0)}),Ql(o,"touchstart",function(){return n.forceCompositionEnd()}),Ql(o,"input",function(){r.composing||r.readFromDOMSoon()}),Ql(o,"copy",t),Ql(o,"cut",t)},Zs.prototype.prepareSelection=function(){var e=Tr(this.cm,!1);return e.focus=this.cm.state.focused,e},Zs.prototype.showSelection=function(e,t){e&&this.cm.display.view.length&&((e.focus||t)&&this.showPrimarySelection(),this.showMultipleSelections(e))},Zs.prototype.showPrimarySelection=function(){var e=window.getSelection(),t=this.cm,r=t.doc.sel.primary(),n=r.from(),i=r.to();if(t.display.viewTo==t.display.viewFrom||n.line>=t.display.viewTo||i.line<t.display.viewFrom)e.removeAllRanges();else{var o=sl(t,e.anchorNode,e.anchorOffset),l=sl(t,e.focusNode,e.focusOffset);if(!o||o.bad||!l||l.bad||0!=P(B(o,l),n)||0!=P(R(o,l),i)){var s=t.display.view,a=n.line>=t.display.viewFrom&&nl(t,n)||{node:s[0].measure.map[2],offset:0},u=i.line<t.display.viewTo&&nl(t,i);if(!u){var c=s[s.length-1].measure,f=c.maps?c.maps[c.maps.length-1]:c.map;u={node:f[f.length-1],offset:f[f.length-2]-f[f.length-3]}}if(a&&u){var h,d=e.rangeCount&&e.getRangeAt(0);try{h=Wl(a.node,a.offset,u.offset,u.node)}catch(e){}h&&(!fl&&t.state.focused?(e.collapse(a.node,a.offset),h.collapsed||(e.removeAllRanges(),e.addRange(h))):(e.removeAllRanges(),e.addRange(h)),d&&null==e.anchorNode?e.addRange(d):fl&&this.startGracePeriod()),this.rememberSelection()}else e.removeAllRanges()}}},Zs.prototype.startGracePeriod=function(){var e=this;clearTimeout(this.gracePeriod),this.gracePeriod=setTimeout(function(){e.gracePeriod=!1,e.selectionChanged()&&e.cm.operation(function(){return e.cm.curOp.selectionChanged=!0})},20)},Zs.prototype.showMultipleSelections=function(e){r(this.cm.display.cursorDiv,e.cursors),r(this.cm.display.selectionDiv,e.selection)},Zs.prototype.rememberSelection=function(){var e=window.getSelection();this.lastAnchorNode=e.anchorNode,this.lastAnchorOffset=e.anchorOffset,this.lastFocusNode=e.focusNode,this.lastFocusOffset=e.focusOffset},Zs.prototype.selectionInEditor=function(){var e=window.getSelection();if(!e.rangeCount)return!1;var t=e.getRangeAt(0).commonAncestorContainer;return o(this.div,t)},Zs.prototype.focus=function(){"nocursor"!=this.cm.options.readOnly&&(this.selectionInEditor()||this.showSelection(this.prepareSelection(),!0),this.div.focus())},Zs.prototype.blur=function(){this.div.blur()},Zs.prototype.getField=function(){return this.div},Zs.prototype.supportsTouch=function(){return!0},Zs.prototype.receivedFocus=function(){function e(){t.cm.state.focused&&(t.pollSelection(),t.polling.set(t.cm.options.pollInterval,e))}var t=this;this.selectionInEditor()?this.pollSelection():hn(this.cm,function(){return t.cm.curOp.selectionChanged=!0}),this.polling.set(this.cm.options.pollInterval,e)},Zs.prototype.selectionChanged=function(){var e=window.getSelection();return e.anchorNode!=this.lastAnchorNode||e.anchorOffset!=this.lastAnchorOffset||e.focusNode!=this.lastFocusNode||e.focusOffset!=this.lastFocusOffset},Zs.prototype.pollSelection=function(){if(null==this.readDOMTimeout&&!this.gracePeriod&&this.selectionChanged()){var e=window.getSelection(),t=this.cm;if(kl&&bl&&this.cm.options.gutters.length&&il(e.anchorNode))return this.cm.triggerOnKeyDown({type:"keydown",keyCode:8,preventDefault:Math.abs}),this.blur(),void this.focus();if(!this.composing){this.rememberSelection();var r=sl(t,e.anchorNode,e.anchorOffset),n=sl(t,e.focusNode,e.focusOffset);r&&n&&hn(t,function(){bi(t.doc,Rn(r,n),Gl),(r.bad||n.bad)&&(t.curOp.selectionChanged=!0)})}}},Zs.prototype.pollContent=function(){null!=this.readDOMTimeout&&(clearTimeout(this.readDOMTimeout),this.readDOMTimeout=null);var e=this.cm,t=e.display,r=e.doc.sel.primary(),n=r.from(),i=r.to();if(0==n.ch&&n.line>e.firstLine()&&(n=E(n.line-1,M(e.doc,n.line-1).length)),i.ch==M(e.doc,i.line).text.length&&i.line<e.lastLine()&&(i=E(i.line+1,0)),n.line<t.viewFrom||i.line>t.viewTo-1)return!1;var o,l,s;n.line==t.viewFrom||0==(o=Lr(e,n.line))?(l=W(t.view[0].line),s=t.view[0].node):(l=W(t.view[o].line),s=t.view[o-1].node.nextSibling);var a,u,c=Lr(e,i.line);if(c==t.view.length-1?(a=t.viewTo-1,u=t.lineDiv.lastChild):(a=W(t.view[c+1].line)-1,u=t.view[c+1].node.previousSibling),!s)return!1;for(var f=e.doc.splitLines(ll(e,s,u,l,a)),h=N(e.doc,E(l,0),E(a,M(e.doc,a).text.length));f.length>1&&h.length>1;)if(g(f)==g(h))f.pop(),h.pop(),a--;else{if(f[0]!=h[0])break;f.shift(),h.shift(),l++}for(var d=0,p=0,v=f[0],m=h[0],y=Math.min(v.length,m.length);d<y&&v.charCodeAt(d)==m.charCodeAt(d);)++d;for(var b=g(f),w=g(h),x=Math.min(b.length-(1==f.length?d:0),w.length-(1==h.length?d:0));p<x&&b.charCodeAt(b.length-p-1)==w.charCodeAt(w.length-p-1);)++p;if(1==f.length&&1==h.length&&l==n.line)for(;d&&d>n.ch&&b.charCodeAt(b.length-p-1)==w.charCodeAt(w.length-p-1);)d--,p++;f[f.length-1]=b.slice(0,b.length-p).replace(/^\u200b+/,""),f[0]=f[0].slice(d).replace(/\u200b+$/,"");var C=E(l,d),S=E(a,h.length?g(h).length-p:0);return f.length>1||f[0]||P(C,S)?(Ei(e.doc,f,C,S,"+input"),!0):void 0},Zs.prototype.ensurePolled=function(){this.forceCompositionEnd()},Zs.prototype.reset=function(){this.forceCompositionEnd()},Zs.prototype.forceCompositionEnd=function(){this.composing&&(clearTimeout(this.readDOMTimeout),this.composing=null,this.updateFromDOM(),this.div.blur(),this.div.focus())},Zs.prototype.readFromDOMSoon=function(){var e=this;null==this.readDOMTimeout&&(this.readDOMTimeout=setTimeout(function(){if(e.readDOMTimeout=null,e.composing){if(!e.composing.done)return;e.composing=null}e.updateFromDOM()},80))},Zs.prototype.updateFromDOM=function(){var e=this;!this.cm.isReadOnly()&&this.pollContent()||hn(this.cm,function(){return vn(e.cm)})},Zs.prototype.setUneditable=function(e){e.contentEditable="false"},Zs.prototype.onKeyPress=function(e){0!=e.charCode&&(e.preventDefault(),this.cm.isReadOnly()||dn(this.cm,$o)(this.cm,String.fromCharCode(null==e.charCode?e.keyCode:e.charCode),0))},Zs.prototype.readOnlyChanged=function(e){this.div.contentEditable=String("nocursor"!=e)},Zs.prototype.onContextMenu=function(){},Zs.prototype.resetPosition=function(){},Zs.prototype.needsContentAttribute=!0;var Qs=function(e){this.cm=e,this.prevInput="",this.pollingFast=!1,this.polling=new Pl,this.hasSelection=!1,this.composing=null};Qs.prototype.init=function(e){function t(e){if(!Me(i,e)){if(i.somethingSelected())_o({lineWise:!1,text:i.getSelections()});else{if(!i.options.lineWiseCopyCut)return;var t=Qo(i);_o({lineWise:!0,text:t.text}),"cut"==e.type?i.setSelections(t.ranges,null,Gl):(n.prevInput="",l.value=t.text.join("\n"),El(l))}"cut"==e.type&&(i.state.cutIncoming=!0)}}var r=this,n=this,i=this.cm,o=this.wrapper=el(),l=this.textarea=o.firstChild;e.wrapper.insertBefore(o,e.wrapper.firstChild),Ll&&(l.style.width="0px"),Ql(l,"input",function(){gl&&vl>=9&&r.hasSelection&&(r.hasSelection=null),n.poll()}),Ql(l,"paste",function(e){Me(i,e)||qo(e,i)||(i.state.pasteIncoming=!0,n.fastPoll())}),Ql(l,"cut",t),Ql(l,"copy",t),Ql(e.scroller,"paste",function(t){Ft(e,t)||Me(i,t)||(i.state.pasteIncoming=!0,n.focus())}),Ql(e.lineSpace,"selectstart",function(t){Ft(e,t)||We(t)}),Ql(l,"compositionstart",function(){var e=i.getCursor("from");n.composing&&n.composing.range.clear(),n.composing={start:e,range:i.markText(e,i.getCursor("to"),{className:"CodeMirror-composing"})}}),Ql(l,"compositionend",function(){n.composing&&(n.poll(),n.composing.range.clear(),n.composing=null)})},Qs.prototype.prepareSelection=function(){var e=this.cm,t=e.display,r=e.doc,n=Tr(e);if(e.options.moveInputWithCursor){var i=sr(e,r.sel.primary().head,"div"),o=t.wrapper.getBoundingClientRect(),l=t.lineDiv.getBoundingClientRect();n.teTop=Math.max(0,Math.min(t.wrapper.clientHeight-10,i.top+l.top-o.top)),n.teLeft=Math.max(0,Math.min(t.wrapper.clientWidth-10,i.left+l.left-o.left))}return n},Qs.prototype.showSelection=function(e){var t=this.cm.display;r(t.cursorDiv,e.cursors),r(t.selectionDiv,e.selection),null!=e.teTop&&(this.wrapper.style.top=e.teTop+"px",this.wrapper.style.left=e.teLeft+"px")},Qs.prototype.reset=function(e){if(!this.contextMenuPending&&!this.composing){var t=this.cm;if(t.somethingSelected()){this.prevInput="";var r=t.getSelection();this.textarea.value=r,t.state.focused&&El(this.textarea),gl&&vl>=9&&(this.hasSelection=r)}else e||(this.prevInput=this.textarea.value="",gl&&vl>=9&&(this.hasSelection=null))}},Qs.prototype.getField=function(){return this.textarea},Qs.prototype.supportsTouch=function(){return!1},Qs.prototype.focus=function(){if("nocursor"!=this.cm.options.readOnly&&(!Tl||l()!=this.textarea))try{this.textarea.focus()}catch(e){}},Qs.prototype.blur=function(){this.textarea.blur()},Qs.prototype.resetPosition=function(){this.wrapper.style.top=this.wrapper.style.left=0},Qs.prototype.receivedFocus=function(){this.slowPoll()},Qs.prototype.slowPoll=function(){var e=this;this.pollingFast||this.polling.set(this.cm.options.pollInterval,function(){e.poll(),e.cm.state.focused&&e.slowPoll()})},Qs.prototype.fastPoll=function(){function e(){r.poll()||t?(r.pollingFast=!1,r.slowPoll()):(t=!0,r.polling.set(60,e))}var t=!1,r=this;r.pollingFast=!0,r.polling.set(20,e)},Qs.prototype.poll=function(){var e=this,t=this.cm,r=this.textarea,n=this.prevInput;if(this.contextMenuPending||!t.state.focused||ts(r)&&!n&&!this.composing||t.isReadOnly()||t.options.disableInput||t.state.keySeq)return!1;var i=r.value;if(i==n&&!t.somethingSelected())return!1;if(gl&&vl>=9&&this.hasSelection===i||Ml&&/[\uf700-\uf7ff]/.test(i))return t.display.input.reset(),!1;if(t.doc.sel==t.display.selForContextMenu){var o=i.charCodeAt(0);if(8203!=o||n||(n="​"),8666==o)return this.reset(),this.cm.execCommand("undo")}for(var l=0,s=Math.min(n.length,i.length);l<s&&n.charCodeAt(l)==i.charCodeAt(l);)++l;return hn(t,function(){$o(t,i.slice(l),n.length-l,null,e.composing?"*compose":null),i.length>1e3||i.indexOf("\n")>-1?r.value=e.prevInput="":e.prevInput=i,e.composing&&(e.composing.range.clear(),e.composing.range=t.markText(e.composing.start,t.getCursor("to"),{className:"CodeMirror-composing"}))}),!0},Qs.prototype.ensurePolled=function(){this.pollingFast&&this.poll()&&(this.pollingFast=!1)},Qs.prototype.onKeyPress=function(){gl&&vl>=9&&(this.hasSelection=null),this.fastPoll()},Qs.prototype.onContextMenu=function(e){function t(){if(null!=l.selectionStart){var e=i.somethingSelected(),t="​"+(e?l.value:"");l.value="⇚",l.value=t,n.prevInput=e?"":"​",l.selectionStart=1,l.selectionEnd=t.length,o.selForContextMenu=i.doc.sel}}function r(){if(n.contextMenuPending=!1,n.wrapper.style.cssText=c,l.style.cssText=u,gl&&vl<9&&o.scrollbars.setScrollTop(o.scroller.scrollTop=a),null!=l.selectionStart){(!gl||gl&&vl<9)&&t();var e=0,r=function(){o.selForContextMenu==i.doc.sel&&0==l.selectionStart&&l.selectionEnd>0&&"​"==n.prevInput?dn(i,Mi)(i):e++<10?o.detectingSelectAll=setTimeout(r,500):(o.selForContextMenu=null,o.input.reset())};o.detectingSelectAll=setTimeout(r,200)}}var n=this,i=n.cm,o=i.display,l=n.textarea,s=Sr(i,e),a=o.scroller.scrollTop;if(s&&!wl){i.options.resetSelectionOnContextMenu&&-1==i.doc.sel.contains(s)&&dn(i,bi)(i.doc,Rn(s),Gl);var u=l.style.cssText,c=n.wrapper.style.cssText;n.wrapper.style.cssText="position: absolute";var f=n.wrapper.getBoundingClientRect();l.style.cssText="position: absolute; width: 30px; height: 30px;\n      top: "+(e.clientY-f.top-5)+"px; left: "+(e.clientX-f.left-5)+"px;\n      z-index: 1000; background: "+(gl?"rgba(255, 255, 255, .05)":"transparent")+";\n      outline: none; border-width: 0; outline: none; overflow: hidden; opacity: .05; filter: alpha(opacity=5);";var h;if(ml&&(h=window.scrollY),o.input.focus(),ml&&window.scrollTo(null,h),o.input.reset(),i.somethingSelected()||(l.value=n.prevInput=" "),n.contextMenuPending=!0,o.selForContextMenu=i.doc.sel,clearTimeout(o.detectingSelectAll),gl&&vl>=9&&t(),Hl){Fe(e);var d=function(){ke(window,"mouseup",d),setTimeout(r,20)};Ql(window,"mouseup",d)}else setTimeout(r,50)}},Qs.prototype.readOnlyChanged=function(e){e||this.reset(),this.textarea.disabled="nocursor"==e},Qs.prototype.setUneditable=function(){},Qs.prototype.needsContentAttribute=!1,function(e){function t(t,n,i,o){e.defaults[t]=n,i&&(r[t]=o?function(e,t,r){r!=Xs&&i(e,t,r)}:i)}var r=e.optionHandlers;e.defineOption=t,e.Init=Xs,t("value","",function(e,t){return e.setValue(t)},!0),t("mode",null,function(e,t){e.doc.modeOption=t,jn(e)},!0),t("indentUnit",2,jn,!0),t("indentWithTabs",!1),t("smartIndent",!0),t("tabSize",4,function(e){Xn(e),er(e),vn(e)},!0),t("lineSeparator",null,function(e,t){if(e.doc.lineSep=t,t){var r=[],n=e.doc.first;e.doc.iter(function(e){for(var i=0;;){var o=e.text.indexOf(t,i);if(-1==o)break;i=o+t.length,r.push(E(n,o))}n++});for(var i=r.length-1;i>=0;i--)Ei(e.doc,t,r[i],E(r[i].line,r[i].ch+t.length))}}),t("specialChars",/[\u0000-\u001f\u007f-\u009f\u00ad\u061c\u200b-\u200f\u2028\u2029\ufeff]/g,function(e,t,r){e.state.specialChars=new RegExp(t.source+(t.test("\t")?"":"|\t"),"g"),r!=Xs&&e.refresh()}),t("specialCharPlaceholder",at,function(e){return e.refresh()},!0),t("electricChars",!0),t("inputStyle",Tl?"contenteditable":"textarea",function(){throw new Error("inputStyle can not (yet) be changed in a running editor")},!0),t("spellcheck",!1,function(e,t){return e.getInputField().spellcheck=t},!0),t("rtlMoveVisually",!Ol),t("wholeLineUpdateBefore",!0),t("theme","default",function(e){Go(e),Uo(e)},!0),t("keyMap","default",function(e,t,r){var n=uo(t),i=r!=Xs&&uo(r);i&&i.detach&&i.detach(e,n),n.attach&&n.attach(e,i||null)}),t("extraKeys",null),t("configureMouse",null),t("lineWrapping",!1,Ko,!0),t("gutters",[],function(e){Fn(e.options),Uo(e)},!0),t("fixedGutter",!0,function(e,t){e.display.gutters.style.left=t?wr(e.display)+"px":"0",e.refresh()},!0),t("coverGutterNextToScrollbar",!1,function(e){return en(e)},!0),t("scrollbarStyle","native",function(e){rn(e),en(e),e.display.scrollbars.setScrollTop(e.doc.scrollTop),e.display.scrollbars.setScrollLeft(e.doc.scrollLeft)},!0),t("lineNumbers",!1,function(e){Fn(e.options),Uo(e)},!0),t("firstLineNumber",1,Uo,!0),t("lineNumberFormatter",function(e){return e},Uo,!0),t("showCursorWhenSelecting",!1,kr,!0),t("resetSelectionOnContextMenu",!0),t("lineWiseCopyCut",!0),t("pasteLinesPerSelection",!0),t("readOnly",!1,function(e,t){"nocursor"==t&&(Fr(e),e.display.input.blur()),e.display.input.readOnlyChanged(t)}),t("disableInput",!1,function(e,t){t||e.display.input.reset()},!0),t("dragDrop",!0,Vo),t("allowDropFileTypes",null),t("cursorBlinkRate",530),t("cursorScrollMargin",0),t("cursorHeight",1,kr,!0),t("singleCursorHeightPerLine",!0,kr,!0),t("workTime",100),t("workDelay",100),t("flattenSpans",!0,Xn,!0),t("addModeClass",!1,Xn,!0),t("pollInterval",100),t("undoDepth",200,function(e,t){return e.doc.history.undoDepth=t}),t("historyEventDelay",1250),t("viewportMargin",10,function(e){return e.refresh()},!0),t("maxHighlightLength",1e4,Xn,!0),t("moveInputWithCursor",!0,function(e,t){t||e.display.input.resetPosition()}),t("tabindex",null,function(e,t){return e.display.input.getField().tabIndex=t||""}),t("autofocus",null),t("direction","ltr",function(e,t){return e.doc.setDirection(t)},!0)}(jo),function(e){var t=e.optionHandlers,r=e.helpers={};e.prototype={constructor:e,focus:function(){window.focus(),this.display.input.focus()},setOption:function(e,r){var n=this.options,i=n[e];n[e]==r&&"mode"!=e||(n[e]=r,t.hasOwnProperty(e)&&dn(this,t[e])(this,r,i),Te(this,"optionChange",this,e))},getOption:function(e){return this.options[e]},getDoc:function(){return this.doc},addKeyMap:function(e,t){this.state.keyMaps[t?"push":"unshift"](uo(e))},removeKeyMap:function(e){for(var t=this.state.keyMaps,r=0;r<t.length;++r)if(t[r]==e||t[r].name==e)return t.splice(r,1),!0},addOverlay:pn(function(t,r){var n=t.token?t:e.getMode(this.options,t);if(n.startState)throw new Error("Overlays may not be stateful.");m(this.state.overlays,{mode:n,modeSpec:t,opaque:r&&r.opaque,priority:r&&r.priority||0},function(e){return e.priority}),this.state.modeGen++,vn(this)}),removeOverlay:pn(function(e){for(var t=this,r=this.state.overlays,n=0;n<r.length;++n){var i=r[n].modeSpec;if(i==e||"string"==typeof e&&i.name==e)return r.splice(n,1),t.state.modeGen++,void vn(t)}}),indentLine:pn(function(e,t,r){"string"!=typeof t&&"number"!=typeof t&&(t=null==t?this.options.smartIndent?"smart":"prev":t?"add":"subtract"),H(this.doc,e)&&Yo(this,e,t,r)}),indentSelection:pn(function(e){for(var t=this,r=this.doc.sel.ranges,n=-1,i=0;i<r.length;i++){var o=r[i];if(o.empty())o.head.line>n&&(Yo(t,o.head.line,e,!0),n=o.head.line,i==t.doc.sel.primIndex&&jr(t));else{var l=o.from(),s=o.to(),a=Math.max(n,l.line);n=Math.min(t.lastLine(),s.line-(s.ch?0:1))+1;for(var u=a;u<n;++u)Yo(t,u,e);var c=t.doc.sel.ranges;0==l.ch&&r.length==c.length&&c[i].from().ch>0&&gi(t.doc,i,new Ts(l,c[i].to()),Gl)}}}),getTokenAt:function(e,t){return Je(this,e,t)},getLineTokens:function(e,t){return Je(this,E(e),t,!0)},getTokenTypeAt:function(e){e=U(this.doc,e);var t,r=_e(this,M(this.doc,e.line)),n=0,i=(r.length-1)/2,o=e.ch;if(0==o)t=r[2];else for(;;){var l=n+i>>1;if((l?r[2*l-1]:0)>=o)i=l;else{if(!(r[2*l+1]<o)){t=r[2*l+2];break}n=l+1}}var s=t?t.indexOf("overlay "):-1;return s<0?t:0==s?null:t.slice(0,s-1)},getModeAt:function(t){var r=this.doc.mode;return r.innerMode?e.innerMode(r,this.getTokenAt(t).state).mode:r},getHelper:function(e,t){return this.getHelpers(e,t)[0]},getHelpers:function(e,t){var n=this,i=[];if(!r.hasOwnProperty(t))return i;var o=r[t],l=this.getModeAt(e);if("string"==typeof l[t])o[l[t]]&&i.push(o[l[t]]);else if(l[t])for(var s=0;s<l[t].length;s++){var a=o[l[t][s]];a&&i.push(a)}else l.helperType&&o[l.helperType]?i.push(o[l.helperType]):o[l.name]&&i.push(o[l.name]);for(var u=0;u<o._global.length;u++){var c=o._global[u];c.pred(l,n)&&-1==h(i,c.val)&&i.push(c.val)}return i},getStateAfter:function(e,t){var r=this.doc;return e=G(r,null==e?r.first+r.size-1:e),$e(this,e+1,t).state},cursorCoords:function(e,t){var r,n=this.doc.sel.primary();return r=null==e?n.head:"object"==typeof e?U(this.doc,e):e?n.from():n.to(),sr(this,r,t||"page")},charCoords:function(e,t){return lr(this,U(this.doc,e),t||"page")},coordsChar:function(e,t){return e=or(this,e,t||"page"),cr(this,e.left,e.top)},lineAtHeight:function(e,t){return e=or(this,{top:e,left:0},t||"page").top,D(this.doc,e+this.display.viewOffset)},heightAtLine:function(e,t,r){var n,i=!1;if("number"==typeof e){var o=this.doc.first+this.doc.size-1;e<this.doc.first?e=this.doc.first:e>o&&(e=o,i=!0),n=M(this.doc,e)}else n=e;return ir(this,n,{top:0,left:0},t||"page",r||i).top+(i?this.doc.height-ye(n):0)},defaultTextHeight:function(){return mr(this.display)},defaultCharWidth:function(){return yr(this.display)},getViewport:function(){return{from:this.display.viewFrom,to:this.display.viewTo}},addWidget:function(e,t,r,n,i){var o=this.display,l=(e=sr(this,U(this.doc,e))).bottom,s=e.left;if(t.style.position="absolute",t.setAttribute("cm-ignore-events","true"),this.display.input.setUneditable(t),o.sizer.appendChild(t),"over"==n)l=e.top;else if("above"==n||"near"==n){var a=Math.max(o.wrapper.clientHeight,this.doc.height),u=Math.max(o.sizer.clientWidth,o.lineSpace.clientWidth);("above"==n||e.bottom+t.offsetHeight>a)&&e.top>t.offsetHeight?l=e.top-t.offsetHeight:e.bottom+t.offsetHeight<=a&&(l=e.bottom),s+t.offsetWidth>u&&(s=u-t.offsetWidth)}t.style.top=l+"px",t.style.left=t.style.right="","right"==i?(s=o.sizer.clientWidth-t.offsetWidth,t.style.right="0px"):("left"==i?s=0:"middle"==i&&(s=(o.sizer.clientWidth-t.offsetWidth)/2),t.style.left=s+"px"),r&&Ur(this,{left:s,top:l,right:s+t.offsetWidth,bottom:l+t.offsetHeight})},triggerOnKeyDown:pn(Lo),triggerOnKeyPress:pn(Mo),triggerOnKeyUp:To,triggerOnMouseDown:pn(Oo),execCommand:function(e){if(Bs.hasOwnProperty(e))return Bs[e].call(null,this)},triggerElectric:pn(function(e){Zo(this,e)}),findPosH:function(e,t,r,n){var i=this,o=1;t<0&&(o=-1,t=-t);for(var l=U(this.doc,e),s=0;s<t&&!(l=tl(i.doc,l,o,r,n)).hitSide;++s);return l},moveH:pn(function(e,t){var r=this;this.extendSelectionsBy(function(n){return r.display.shift||r.doc.extend||n.empty()?tl(r.doc,n.head,e,t,r.options.rtlMoveVisually):e<0?n.from():n.to()},Vl)}),deleteH:pn(function(e,t){var r=this.doc.sel,n=this.doc;r.somethingSelected()?n.replaceSelection("",null,"+delete"):co(this,function(r){var i=tl(n,r.head,e,t,!1);return e<0?{from:i,to:r.head}:{from:r.head,to:i}})}),findPosV:function(e,t,r,n){var i=this,o=1,l=n;t<0&&(o=-1,t=-t);for(var s=U(this.doc,e),a=0;a<t;++a){var u=sr(i,s,"div");if(null==l?l=u.left:u.left=l,(s=rl(i,u,o,r)).hitSide)break}return s},moveV:pn(function(e,t){var r=this,n=this.doc,i=[],o=!this.display.shift&&!n.extend&&n.sel.somethingSelected();if(n.extendSelectionsBy(function(l){if(o)return e<0?l.from():l.to();var s=sr(r,l.head,"div");null!=l.goalColumn&&(s.left=l.goalColumn),i.push(s.left);var a=rl(r,s,e,t);return"page"==t&&l==n.sel.primary()&&Kr(r,lr(r,a,"div").top-s.top),a},Vl),i.length)for(var l=0;l<n.sel.ranges.length;l++)n.sel.ranges[l].goalColumn=i[l]}),findWordAt:function(e){var t=M(this.doc,e.line).text,r=e.ch,n=e.ch;if(t){var i=this.getHelper(e,"wordChars");"before"!=e.sticky&&n!=t.length||!r?++n:--r;for(var o=t.charAt(r),l=x(o,i)?function(e){return x(e,i)}:/\s/.test(o)?function(e){return/\s/.test(e)}:function(e){return!/\s/.test(e)&&!x(e)};r>0&&l(t.charAt(r-1));)--r;for(;n<t.length&&l(t.charAt(n));)++n}return new Ts(E(e.line,r),E(e.line,n))},toggleOverwrite:function(e){null!=e&&e==this.state.overwrite||((this.state.overwrite=!this.state.overwrite)?s(this.display.cursorDiv,"CodeMirror-overwrite"):Fl(this.display.cursorDiv,"CodeMirror-overwrite"),Te(this,"overwriteToggle",this,this.state.overwrite))},hasFocus:function(){return this.display.input.getField()==l()},isReadOnly:function(){return!(!this.options.readOnly&&!this.doc.cantEdit)},scrollTo:pn(function(e,t){Xr(this,e,t)}),getScrollInfo:function(){var e=this.display.scroller;return{left:e.scrollLeft,top:e.scrollTop,height:e.scrollHeight-zt(this)-this.display.barHeight,width:e.scrollWidth-zt(this)-this.display.barWidth,clientHeight:Bt(this),clientWidth:Rt(this)}},scrollIntoView:pn(function(e,t){null==e?(e={from:this.doc.sel.primary().head,to:null},null==t&&(t=this.options.cursorScrollMargin)):"number"==typeof e?e={from:E(e,0),to:null}:null==e.from&&(e={from:e,to:null}),e.to||(e.to=e.from),e.margin=t||0,null!=e.from.line?Yr(this,e):$r(this,e.from,e.to,e.margin)}),setSize:pn(function(e,t){var r=this,n=function(e){return"number"==typeof e||/^\d+$/.test(String(e))?e+"px":e};null!=e&&(this.display.wrapper.style.width=n(e)),null!=t&&(this.display.wrapper.style.height=n(t)),this.options.lineWrapping&&Jt(this);var i=this.display.viewFrom;this.doc.iter(i,this.display.viewTo,function(e){if(e.widgets)for(var t=0;t<e.widgets.length;t++)if(e.widgets[t].noHScroll){mn(r,i,"widget");break}++i}),this.curOp.forceUpdate=!0,Te(this,"refresh",this)}),operation:function(e){return hn(this,e)},startOperation:function(){return nn(this)},endOperation:function(){return on(this)},refresh:pn(function(){var e=this.display.cachedTextHeight;vn(this),this.curOp.forceUpdate=!0,er(this),Xr(this,this.doc.scrollLeft,this.doc.scrollTop),Wn(this),(null==e||Math.abs(e-mr(this.display))>.5)&&Cr(this),Te(this,"refresh",this)}),swapDoc:pn(function(e){var t=this.doc;return t.cm=null,qn(this,e),er(this),this.display.input.reset(),Xr(this,e.scrollLeft,e.scrollTop),this.curOp.forceScroll=!0,bt(this,"swapDoc",this,t),t}),getInputField:function(){return this.display.input.getField()},getWrapperElement:function(){return this.display.wrapper},getScrollerElement:function(){return this.display.scroller},getGutterElement:function(){return this.display.gutters}},Ae(e),e.registerHelper=function(t,n,i){r.hasOwnProperty(t)||(r[t]=e[t]={_global:[]}),r[t][n]=i},e.registerGlobalHelper=function(t,n,i,o){e.registerHelper(t,n,o),r[t]._global.push({pred:i,val:o})}}(jo);var Js="iter insert remove copy getEditor constructor".split(" ");for(var ea in Ds.prototype)Ds.prototype.hasOwnProperty(ea)&&h(Js,ea)<0&&(jo.prototype[ea]=function(e){return function(){return e.apply(this.doc,arguments)}}(Ds.prototype[ea]));return Ae(Ds),jo.inputStyles={textarea:Qs,contenteditable:Zs},jo.defineMode=function(e){jo.defaults.mode||"null"==e||(jo.defaults.mode=e),Be.apply(this,arguments)},jo.defineMIME=function(e,t){os[e]=t},jo.defineMode("null",function(){return{token:function(e){return e.skipToEnd()}}}),jo.defineMIME("text/plain","null"),jo.defineExtension=function(e,t){jo.prototype[e]=t},jo.defineDocExtension=function(e,t){Ds.prototype[e]=t},jo.fromTextArea=function(e,t){function r(){e.value=a.getValue()}if(t=t?c(t):{},t.value=e.value,!t.tabindex&&e.tabIndex&&(t.tabindex=e.tabIndex),!t.placeholder&&e.placeholder&&(t.placeholder=e.placeholder),null==t.autofocus){var n=l();t.autofocus=n==e||null!=e.getAttribute("autofocus")&&n==document.body}var i;if(e.form&&(Ql(e.form,"submit",r),!t.leaveSubmitMethodAlone)){var o=e.form;i=o.submit;try{var s=o.submit=function(){r(),o.submit=i,o.submit(),o.submit=s}}catch(e){}}t.finishInit=function(t){t.save=r,t.getTextArea=function(){return e},t.toTextArea=function(){t.toTextArea=isNaN,r(),e.parentNode.removeChild(t.getWrapperElement()),e.style.display="",e.form&&(ke(e.form,"submit",r),"function"==typeof e.form.submit&&(e.form.submit=i))}},e.style.display="none";var a=jo(function(t){return e.parentNode.insertBefore(t,e.nextSibling)},t);return a},function(e){e.off=ke,e.on=Ql,e.wheelEventPixels=Pn,e.Doc=Ds,e.splitLines=es,e.countColumn=f,e.findColumn=d,e.isWordChar=w,e.Pass=Bl,e.signal=Te,e.Line=fs,e.changeEnd=Bn,e.scrollbarModel=ws,e.Pos=E,e.cmpPos=P,e.modes=is,e.mimeModes=os,e.resolveMode=Ge,e.getMode=Ue,e.modeExtensions=ls,e.extendMode=Ve,e.copyState=Ke,e.startState=Xe,e.innerMode=je,e.commands=Bs,e.keyMap=Rs,e.keyName=ao,e.isModifierKey=lo,e.lookupKey=oo,e.normalizeKeyMap=io,e.StringStream=ss,e.SharedTextMarker=As,e.TextMarker=Os,e.LineWidget=Ms,e.e_preventDefault=We,e.e_stopPropagation=De,e.e_stop=Fe,e.addClass=s,e.contains=o,e.rmClass=Fl,e.keyNames=Es}(jo),jo.version="5.30.0",jo});
      !function(e){"object"==typeof exports&&"object"==typeof module?e(require("../../lib/codemirror")):"function"==typeof define&&define.amd?define(["../../lib/codemirror"],e):e(CodeMirror)}(function(e){"use strict";function t(e,t,n,r,o,a){this.indented=e,this.column=t,this.type=n,this.info=r,this.align=o,this.prev=a}function n(e,n,r,o){var a=e.indented;return e.context&&"statement"==e.context.type&&"statement"!=r&&(a=e.context.indented),e.context=new t(a,n,r,o,null,e.context)}function r(e){var t=e.context.type;return")"!=t&&"]"!=t&&"}"!=t||(e.indented=e.context.indented),e.context=e.context.prev}function o(e,t,n){return"variable"==t.prevToken||"type"==t.prevToken||(!!/\S(?:[^- ]>|[*\]])\s*$|\*$/.test(e.string.slice(0,n))||(!(!t.typeAtEndOfLine||e.column()!=e.indentation())||void 0))}function a(e){for(;;){if(!e||"top"==e.type)return!0;if("}"==e.type&&"namespace"!=e.prev.info)return!1;e=e.prev}}function i(e){for(var t={},n=e.split(" "),r=0;r<n.length;++r)t[n[r]]=!0;return t}function l(e,t){return"function"==typeof e?e(t):e.propertyIsEnumerable(t)}function s(e,t){if(!t.startOfLine)return!1;for(var n,r=null;n=e.peek();){if("\\"==n&&e.match(/^.$/)){r=s;break}if("/"==n&&e.match(/^\/[\/\*]/,!1))break;e.next()}return t.tokenize=r,"meta"}function c(e,t){return"type"==t.prevToken&&"type"}function u(e){return e.eatWhile(/[\w\.']/),"number"}function d(e,t){if(e.backUp(1),e.match(/(R|u8R|uR|UR|LR)/)){var n=e.match(/"([^\s\\()]{0,16})\(/);return!!n&&(t.cpp11RawStringDelim=n[1],t.tokenize=m,m(e,t))}return e.match(/(u8|u|U|L)/)?!!e.match(/["']/,!1)&&"string":(e.next(),!1)}function f(e){var t=/(\w+)::~?(\w+)$/.exec(e);return t&&t[1]==t[2]}function p(e,t){for(var n;null!=(n=e.next());)if('"'==n&&!e.eat('"')){t.tokenize=null;break}return"string"}function m(e,t){var n=t.cpp11RawStringDelim.replace(/[^\w\s]/g,"\\$&");return e.match(new RegExp(".*?\\)"+n+'"'))?t.tokenize=null:e.skipToEnd(),"string"}function h(t,n){function r(e){if(e)for(var t in e)e.hasOwnProperty(t)&&o.push(t)}"string"==typeof t&&(t=[t]);var o=[];r(n.keywords),r(n.types),r(n.builtin),r(n.atoms),o.length&&(n.helperType=t[0],e.registerHelper("hintWords",t[0],o));for(var a=0;a<t.length;++a)e.defineMIME(t[a],n)}function g(e,t){for(var n=!1;!e.eol();){if(!n&&e.match('"""')){t.tokenize=null;break}n="\\"==e.next()&&!n}return"string"}function y(e){return function(t,n){for(var r,o=!1,a=!1;!t.eol();){if(!e&&!o&&t.match('"')){a=!0;break}if(e&&t.match('"""')){a=!0;break}r=t.next(),!o&&"$"==r&&t.match("{")&&t.skipTo("}"),o=!o&&"\\"==r&&!e}return!a&&e||(n.tokenize=null),"string"}}function x(e){return function(t,n){for(var r,o=!1,a=!1;!t.eol();){if(!o&&t.match('"')&&("single"==e||t.match('""'))){a=!0;break}if(!o&&t.match("``")){w=x(e),a=!0;break}r=t.next(),o="single"==e&&!o&&"\\"==r}return a&&(n.tokenize=null),"string"}}e.defineMode("clike",function(i,s){function c(e,t){var n=e.next();if(S[n]){var r=S[n](e,t);if(!1!==r)return r}if('"'==n||"'"==n)return t.tokenize=u(n),t.tokenize(e,t);if(D.test(n))return p=n,null;if(L.test(n)){if(e.backUp(1),e.match(I))return"number";e.next()}if("/"==n){if(e.eat("*"))return t.tokenize=d,d(e,t);if(e.eat("/"))return e.skipToEnd(),"comment"}if(F.test(n)){for(;!e.match(/^\/[\/*]/,!1)&&e.eat(F););return"operator"}if(e.eatWhile(z),P)for(;e.match(P);)e.eatWhile(z);var o=e.current();return l(x,o)?(l(w,o)&&(p="newstatement"),l(v,o)&&(m=!0),"keyword"):l(b,o)?"type":l(k,o)?(l(w,o)&&(p="newstatement"),"builtin"):l(_,o)?"atom":"variable"}function u(e){return function(t,n){for(var r,o=!1,a=!1;null!=(r=t.next());){if(r==e&&!o){a=!0;break}o=!o&&"\\"==r}return(a||!o&&!C)&&(n.tokenize=null),"string"}}function d(e,t){for(var n,r=!1;n=e.next();){if("/"==n&&r){t.tokenize=null;break}r="*"==n}return"comment"}function f(e,t){s.typeFirstDefinitions&&e.eol()&&a(t.context)&&(t.typeAtEndOfLine=o(e,t,e.pos))}var p,m,h=i.indentUnit,g=s.statementIndentUnit||h,y=s.dontAlignCalls,x=s.keywords||{},b=s.types||{},k=s.builtin||{},w=s.blockKeywords||{},v=s.defKeywords||{},_=s.atoms||{},S=s.hooks||{},C=s.multiLineStrings,T=!1!==s.indentStatements,M=!1!==s.indentSwitch,P=s.namespaceSeparator,D=s.isPunctuationChar||/[\[\]{}\(\),;\:\.]/,L=s.numberStart||/[\d\.]/,I=s.number||/^(?:0x[a-f\d]+|0b[01]+|(?:\d+\.?\d*|\.\d+)(?:e[-+]?\d+)?)(u|ll?|l|f)?/i,F=s.isOperatorChar||/[+\-*&%=<>!?|\/]/,z=s.isIdentifierChar||/[\w\$_\xa1-\uffff]/;return{startState:function(e){return{tokenize:null,context:new t((e||0)-h,0,"top",null,!1),indented:0,startOfLine:!0,prevToken:null}},token:function(e,t){var i=t.context;if(e.sol()&&(null==i.align&&(i.align=!1),t.indented=e.indentation(),t.startOfLine=!0),e.eatSpace())return f(e,t),null;p=m=null;var l=(t.tokenize||c)(e,t);if("comment"==l||"meta"==l)return l;if(null==i.align&&(i.align=!0),";"==p||":"==p||","==p&&e.match(/^\s*(?:\/\/.*)?$/,!1))for(;"statement"==t.context.type;)r(t);else if("{"==p)n(t,e.column(),"}");else if("["==p)n(t,e.column(),"]");else if("("==p)n(t,e.column(),")");else if("}"==p){for(;"statement"==i.type;)i=r(t);for("}"==i.type&&(i=r(t));"statement"==i.type;)i=r(t)}else p==i.type?r(t):T&&(("}"==i.type||"top"==i.type)&&";"!=p||"statement"==i.type&&"newstatement"==p)&&n(t,e.column(),"statement",e.current());if("variable"==l&&("def"==t.prevToken||s.typeFirstDefinitions&&o(e,t,e.start)&&a(t.context)&&e.match(/^\s*\(/,!1))&&(l="def"),S.token){var u=S.token(e,t,l);void 0!==u&&(l=u)}return"def"==l&&!1===s.styleDefs&&(l="variable"),t.startOfLine=!1,t.prevToken=m?"def":l||p,f(e,t),l},indent:function(t,n){if(t.tokenize!=c&&null!=t.tokenize||t.typeAtEndOfLine)return e.Pass;var r=t.context,o=n&&n.charAt(0);if("statement"==r.type&&"}"==o&&(r=r.prev),s.dontIndentStatements)for(;"statement"==r.type&&s.dontIndentStatements.test(r.info);)r=r.prev;if(S.indent){var a=S.indent(t,r,n);if("number"==typeof a)return a}var i=o==r.type,l=r.prev&&"switch"==r.prev.info;if(s.allmanIndentation&&/[{(]/.test(o)){for(;"top"!=r.type&&"}"!=r.type;)r=r.prev;return r.indented}return"statement"==r.type?r.indented+("{"==o?0:g):!r.align||y&&")"==r.type?")"!=r.type||i?r.indented+(i?0:h)+(i||!l||/^(?:case|default)\b/.test(n)?0:h):r.indented+g:r.column+(i?0:1)},electricInput:M?/^\s*(?:case .*?:|default:|\{\}?|\})$/:/^\s*[{}]$/,blockCommentStart:"/*",blockCommentEnd:"*/",lineComment:"//",fold:"brace"}});var b="auto if break case register continue return default do sizeof static else struct switch extern typedef union for goto while enum const volatile",k="int long char short double float unsigned signed void size_t ptrdiff_t";h(["text/x-csrc","text/x-c","text/x-chdr"],{name:"clike",keywords:i(b),types:i(k+" bool _Complex _Bool float_t double_t intptr_t intmax_t int8_t int16_t int32_t int64_t uintptr_t uintmax_t uint8_t uint16_t uint32_t uint64_t"),blockKeywords:i("case do else for if switch while struct"),defKeywords:i("struct"),typeFirstDefinitions:!0,atoms:i("null true false"),hooks:{"#":s,"*":c},modeProps:{fold:["brace","include"]}}),h(["text/x-c++src","text/x-c++hdr"],{name:"clike",keywords:i(b+" asm dynamic_cast namespace reinterpret_cast try explicit new static_cast typeid catch operator template typename class friend private this using const_cast inline public throw virtual delete mutable protected alignas alignof constexpr decltype nullptr noexcept thread_local final static_assert override"),types:i(k+" bool wchar_t"),blockKeywords:i("catch class do else finally for if struct switch try while"),defKeywords:i("class namespace struct enum union"),typeFirstDefinitions:!0,atoms:i("true false null"),dontIndentStatements:/^template$/,isIdentifierChar:/[\w\$_~\xa1-\uffff]/,hooks:{"#":s,"*":c,u:d,U:d,L:d,R:d,0:u,1:u,2:u,3:u,4:u,5:u,6:u,7:u,8:u,9:u,token:function(e,t,n){if("variable"==n&&"("==e.peek()&&(";"==t.prevToken||null==t.prevToken||"}"==t.prevToken)&&f(e.current()))return"def"}},namespaceSeparator:"::",modeProps:{fold:["brace","include"]}}),h("text/x-java",{name:"clike",keywords:i("abstract assert break case catch class const continue default do else enum extends final finally float for goto if implements import instanceof interface native new package private protected public return static strictfp super switch synchronized this throw throws transient try volatile while @interface"),types:i("byte short int long float double boolean char void Boolean Byte Character Double Float Integer Long Number Object Short String StringBuffer StringBuilder Void"),blockKeywords:i("catch class do else finally for if switch try while"),defKeywords:i("class interface package enum @interface"),typeFirstDefinitions:!0,atoms:i("true false null"),number:/^(?:0x[a-f\d_]+|0b[01_]+|(?:[\d_]+\.?\d*|\.\d+)(?:e[-+]?[\d_]+)?)(u|ll?|l|f)?/i,hooks:{"@":function(e){return!e.match("interface",!1)&&(e.eatWhile(/[\w\$_]/),"meta")}},modeProps:{fold:["brace","import"]}}),h("text/x-csharp",{name:"clike",keywords:i("abstract as async await base break case catch checked class const continue default delegate do else enum event explicit extern finally fixed for foreach goto if implicit in interface internal is lock namespace new operator out override params private protected public readonly ref return sealed sizeof stackalloc static struct switch this throw try typeof unchecked unsafe using virtual void volatile while add alias ascending descending dynamic from get global group into join let orderby partial remove select set value var yield"),types:i("Action Boolean Byte Char DateTime DateTimeOffset Decimal Double Func Guid Int16 Int32 Int64 Object SByte Single String Task TimeSpan UInt16 UInt32 UInt64 bool byte char decimal double short int long object sbyte float string ushort uint ulong"),blockKeywords:i("catch class do else finally for foreach if struct switch try while"),defKeywords:i("class interface namespace struct var"),typeFirstDefinitions:!0,atoms:i("true false null"),hooks:{"@":function(e,t){return e.eat('"')?(t.tokenize=p,p(e,t)):(e.eatWhile(/[\w\$_]/),"meta")}}}),h("text/x-scala",{name:"clike",keywords:i("abstract case catch class def do else extends final finally for forSome if implicit import lazy match new null object override package private protected return sealed super this throw trait try type val var while with yield _ assert assume require print println printf readLine readBoolean readByte readShort readChar readInt readLong readFloat readDouble"),types:i("AnyVal App Application Array BufferedIterator BigDecimal BigInt Char Console Either Enumeration Equiv Error Exception Fractional Function IndexedSeq Int Integral Iterable Iterator List Map Numeric Nil NotNull Option Ordered Ordering PartialFunction PartialOrdering Product Proxy Range Responder Seq Serializable Set Specializable Stream StringBuilder StringContext Symbol Throwable Traversable TraversableOnce Tuple Unit Vector Boolean Byte Character CharSequence Class ClassLoader Cloneable Comparable Compiler Double Exception Float Integer Long Math Number Object Package Pair Process Runtime Runnable SecurityManager Short StackTraceElement StrictMath String StringBuffer System Thread ThreadGroup ThreadLocal Throwable Triple Void"),multiLineStrings:!0,blockKeywords:i("catch class enum do else finally for forSome if match switch try while"),defKeywords:i("class enum def object package trait type val var"),atoms:i("true false null"),indentStatements:!1,indentSwitch:!1,isOperatorChar:/[+\-*&%=<>!?|\/#:@]/,hooks:{"@":function(e){return e.eatWhile(/[\w\$_]/),"meta"},'"':function(e,t){return!!e.match('""')&&(t.tokenize=g,t.tokenize(e,t))},"'":function(e){return e.eatWhile(/[\w\$_\xa1-\uffff]/),"atom"},"=":function(e,n){var r=n.context;return!("}"!=r.type||!r.align||!e.eat(">"))&&(n.context=new t(r.indented,r.column,r.type,r.info,null,r.prev),"operator")}},modeProps:{closeBrackets:{triples:'"'}}}),h("text/x-kotlin",{name:"clike",keywords:i("package as typealias class interface this super val var fun for is in This throw return break continue object if else while do try when !in !is as? file import where by get set abstract enum open inner override private public internal protected catch finally out final vararg reified dynamic companion constructor init sealed field property receiver param sparam lateinit data inline noinline tailrec external annotation crossinline const operator infix suspend"),types:i("Boolean Byte Character CharSequence Class ClassLoader Cloneable Comparable Compiler Double Exception Float Integer Long Math Number Object Package Pair Process Runtime Runnable SecurityManager Short StackTraceElement StrictMath String StringBuffer System Thread ThreadGroup ThreadLocal Throwable Triple Void"),intendSwitch:!1,indentStatements:!1,multiLineStrings:!0,number:/^(?:0x[a-f\d_]+|0b[01_]+|(?:[\d_]+\.?\d*|\.\d+)(?:e[-+]?[\d_]+)?)(u|ll?|l|f)?/i,blockKeywords:i("catch class do else finally for if where try while enum"),defKeywords:i("class val var object package interface fun"),atoms:i("true false null this"),hooks:{'"':function(e,t){return t.tokenize=y(e.match('""')),t.tokenize(e,t)}},modeProps:{closeBrackets:{triples:'"'}}}),h(["x-shader/x-vertex","x-shader/x-fragment"],{name:"clike",keywords:i("sampler1D sampler2D sampler3D samplerCube sampler1DShadow sampler2DShadow const attribute uniform varying break continue discard return for while do if else struct in out inout"),types:i("float int bool void vec2 vec3 vec4 ivec2 ivec3 ivec4 bvec2 bvec3 bvec4 mat2 mat3 mat4"),blockKeywords:i("for while do if else struct"),builtin:i("radians degrees sin cos tan asin acos atan pow exp log exp2 sqrt inversesqrt abs sign floor ceil fract mod min max clamp mix step smoothstep length distance dot cross normalize ftransform faceforward reflect refract matrixCompMult lessThan lessThanEqual greaterThan greaterThanEqual equal notEqual any all not texture1D texture1DProj texture1DLod texture1DProjLod texture2D texture2DProj texture2DLod texture2DProjLod texture3D texture3DProj texture3DLod texture3DProjLod textureCube textureCubeLod shadow1D shadow2D shadow1DProj shadow2DProj shadow1DLod shadow2DLod shadow1DProjLod shadow2DProjLod dFdx dFdy fwidth noise1 noise2 noise3 noise4"),atoms:i("true false gl_FragColor gl_SecondaryColor gl_Normal gl_Vertex gl_MultiTexCoord0 gl_MultiTexCoord1 gl_MultiTexCoord2 gl_MultiTexCoord3 gl_MultiTexCoord4 gl_MultiTexCoord5 gl_MultiTexCoord6 gl_MultiTexCoord7 gl_FogCoord gl_PointCoord gl_Position gl_PointSize gl_ClipVertex gl_FrontColor gl_BackColor gl_FrontSecondaryColor gl_BackSecondaryColor gl_TexCoord gl_FogFragCoord gl_FragCoord gl_FrontFacing gl_FragData gl_FragDepth gl_ModelViewMatrix gl_ProjectionMatrix gl_ModelViewProjectionMatrix gl_TextureMatrix gl_NormalMatrix gl_ModelViewMatrixInverse gl_ProjectionMatrixInverse gl_ModelViewProjectionMatrixInverse gl_TexureMatrixTranspose gl_ModelViewMatrixInverseTranspose gl_ProjectionMatrixInverseTranspose gl_ModelViewProjectionMatrixInverseTranspose gl_TextureMatrixInverseTranspose gl_NormalScale gl_DepthRange gl_ClipPlane gl_Point gl_FrontMaterial gl_BackMaterial gl_LightSource gl_LightModel gl_FrontLightModelProduct gl_BackLightModelProduct gl_TextureColor gl_EyePlaneS gl_EyePlaneT gl_EyePlaneR gl_EyePlaneQ gl_FogParameters gl_MaxLights gl_MaxClipPlanes gl_MaxTextureUnits gl_MaxTextureCoords gl_MaxVertexAttribs gl_MaxVertexUniformComponents gl_MaxVaryingFloats gl_MaxVertexTextureImageUnits gl_MaxTextureImageUnits gl_MaxFragmentUniformComponents gl_MaxCombineTextureImageUnits gl_MaxDrawBuffers"),indentSwitch:!1,hooks:{"#":s},modeProps:{fold:["brace","include"]}}),h("text/x-nesc",{name:"clike",keywords:i(b+"as atomic async call command component components configuration event generic implementation includes interface module new norace nx_struct nx_union post provides signal task uses abstract extends"),types:i(k),blockKeywords:i("case do else for if switch while struct"),atoms:i("null true false"),hooks:{"#":s},modeProps:{fold:["brace","include"]}}),h("text/x-objectivec",{name:"clike",keywords:i(b+"inline restrict _Bool _Complex _Imaginary BOOL Class bycopy byref id IMP in inout nil oneway out Protocol SEL self super atomic nonatomic retain copy readwrite readonly"),types:i(k),atoms:i("YES NO NULL NILL ON OFF true false"),hooks:{"@":function(e){return e.eatWhile(/[\w\$]/),"keyword"},"#":s,indent:function(e,t,n){if("statement"==t.type&&/^@\w/.test(n))return t.indented}},modeProps:{fold:"brace"}}),h("text/x-squirrel",{name:"clike",keywords:i("base break clone continue const default delete enum extends function in class foreach local resume return this throw typeof yield constructor instanceof static"),types:i(k),blockKeywords:i("case catch class else for foreach if switch try while"),defKeywords:i("function local class"),typeFirstDefinitions:!0,atoms:i("true false null"),hooks:{"#":s},modeProps:{fold:["brace","include"]}});var w=null;h("text/x-ceylon",{name:"clike",keywords:i("abstracts alias assembly assert assign break case catch class continue dynamic else exists extends finally for function given if import in interface is let module new nonempty object of out outer package return satisfies super switch then this throw try value void while"),types:function(e){var t=e.charAt(0);return t===t.toUpperCase()&&t!==t.toLowerCase()},blockKeywords:i("case catch class dynamic else finally for function if interface module new object switch try while"),defKeywords:i("class dynamic function interface module object package value"),builtin:i("abstract actual aliased annotation by default deprecated doc final formal late license native optional sealed see serializable shared suppressWarnings tagged throws variable"),isPunctuationChar:/[\[\]{}\(\),;\:\.`]/,isOperatorChar:/[+\-*&%=<>!?|^~:\/]/,numberStart:/[\d#$]/,number:/^(?:#[\da-fA-F_]+|\$[01_]+|[\d_]+[kMGTPmunpf]?|[\d_]+\.[\d_]+(?:[eE][-+]?\d+|[kMGTPmunpf]|)|)/i,multiLineStrings:!0,typeFirstDefinitions:!0,atoms:i("true false null larger smaller equal empty finished"),indentSwitch:!1,styleDefs:!1,hooks:{"@":function(e){return e.eatWhile(/[\w\$_]/),"meta"},'"':function(e,t){return t.tokenize=x(e.match('""')?"triple":"single"),t.tokenize(e,t)},"`":function(e,t){return!(!w||!e.match("`"))&&(t.tokenize=w,w=null,t.tokenize(e,t))},"'":function(e){return e.eatWhile(/[\w\$_\xa1-\uffff]/),"atom"},token:function(e,t,n){if(("variable"==n||"type"==n)&&"."==t.prevToken)return"variable-2"}},modeProps:{fold:["brace","import"],closeBrackets:{triples:'"'}}})});
      // -------------------------------------------------------------------------
//  Part of the CodeChecker project, under the Apache License v2.0 with
//  LLVM Exceptions. See LICENSE for license information.
//  SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
// -------------------------------------------------------------------------

var BugViewer = {
  _files : [],
  _reports : [],
  _lineWidgets : [],
  _navigationMenuItems : [],
  _sourceFileData : null,
  _currentReport : null,
  _lastBugEvent  : null,

  init : function (files, reports) {
    this._files = files;
    this._reports = reports;

    this.initEscapeChars();
  },

  initEscapeChars : function () {
    this.escapeChars = {
      ' ' : 'nbsp',
      '<' : 'lt',
      '>' : 'gt',
      '"' : 'quot',
      '&' : 'amp'
    };

    var regexString = '[';
    for (var key in this.escapeChars) {
      regexString += key;
    }
    regexString += ']';

    this.escapeRegExp = new RegExp( regexString, 'g');
  },

  escapeHTML : function (str) {
    var that = this;

    return str.replace(this.escapeRegExp, function (m) {
      return '&' + that.escapeChars[m] + ';';
    });
  },

  initByUrl : function () {
    if (!this._reports) return;

    var state = {};
    window.location.hash.substr(1).split('&').forEach(function (s) {
      var parts = s.split('=');
      state[parts[0]] = parts[1];
    });

    for (var key in this._reports) {
      var report = this._reports[key];
      if (report.reportHash === state['reportHash']) {
        this.navigate(report);
        return;
      }
    }

    this.navigate(this._reports[0]);
  },

  create : function () {
    this._content = document.getElementById('editor-wrapper');
    this._filepath = document.getElementById('file-path');
    this._checkerName = document.getElementById('checker-name');
    this._reviewStatusWrapper =
      document.getElementById('review-status-wrapper');
    this._reviewStatus = document.getElementById('review-status');
    this._editor = document.getElementById('editor');

    this._codeMirror = CodeMirror(this._editor, {
      mode: 'text/x-c++src',
      matchBrackets : true,
      lineNumbers : true,
      readOnly : true,
      foldGutter : true,
      extraKeys : {},
      viewportMargin : 100
    });

    this._createNavigationMenu();
  },

  navigate : function (report, item) {
    if (!item) {
      var items = this._navigationMenuItems.filter(function (navItem) {
        return navItem.report.reportHash === report.reportHash;
      });

      if (!items.length) return;

      item = items[0].widget;
    }

    this._selectedReport.classList.remove('active');
    this._selectedReport = item;
    this._selectedReport.classList.add('active');
    this.setReport(report);
  },

  _createNavigationMenu : function () {
    var that = this;

    var nav = document.getElementById('report-nav');
    var list = document.createElement('ul');
    this._reports.forEach(function (report) {
      var events = report['events'];
      var lastBugEvent = events[events.length - 1];
      var item = document.createElement('li');

      var severity = document.createElement('i');
      severity.className = 'severity-' + report.severity.toLowerCase();

      item.appendChild(severity);
      item.appendChild(document.createTextNode(lastBugEvent.message));

      item.addEventListener('click', function () {
        that.navigate(report, item);
      })
      list.appendChild(item);
      that._navigationMenuItems.push({ report : report, widget : item });
    });

    if (!this._selectedReport && list.childNodes.length) {
      this._selectedReport = list.childNodes[0];
      this._selectedReport.classList.add('active');
    }

    nav.appendChild(list);
  },

  setReport : function (report) {
    this._currentReport = report;
    var events = report['events'];
    var lastBugEvent = events[events.length - 1];
    this.setCurrentBugEvent(lastBugEvent, events.length - 1);
    this.setCheckerName(report.checkerName);
    this.setReviewStatus(report.reviewStatus);

    window.location.hash = '#reportHash=' + report.reportHash;
  },

  setCurrentBugEvent : function (event, idx) {
    this._currentBugEvent = event;
    this.setSourceFileData(this._files[event.location.file]);
    this.drawBugPath();

    this.jumpTo(event.location.line, 0);
    this.highlightBugEvent(event, idx);
  },

  highlightBugEvent : function (event, idx) {
    this._lineWidgets.forEach(function (widget) {
      var lineIdx = widget.node.getAttribute('idx');
      if (parseInt(lineIdx) === idx) {
        widget.node.classList.add('current');
      }
    });
  },

  setCheckerName : function (checkerName) {
    this._checkerName.innerHTML = checkerName;
  },

  setReviewStatus : function (status) {
    if (status) {
      var className =
        'review-status-' + status.toLowerCase().split(' ').join('-');
      this._reviewStatus.className = "review-status " + className;

      this._reviewStatus.innerHTML = status;
      this._reviewStatusWrapper.style.display = 'block';
    } else {
      this._reviewStatusWrapper.style.display = 'none';
    }
  },

  setSourceFileData : function (file) {
    if (this._sourceFileData && file.id === this._sourceFileData.id) {
      return;
    }

    this._sourceFileData = file;
    this._filepath.innerHTML = file.path;
    this._codeMirror.doc.setValue(file.content);
    this._refresh();
  },

  _refresh : function () {
    var that = this;
    setTimeout(function () {
      var fullHeight = parseInt(that._content.clientHeight);
      var headerHeight = that._filepath.clientHeight;

      that._codeMirror.setSize('auto', fullHeight - headerHeight);
      that._codeMirror.refresh();
    }, 200);
  },

  clearBubbles : function () {
    this._lineWidgets.forEach(function (widget) { widget.clear(); });
    this._lineWidgets = [];
  },

  getMessage : function (event, kind) {
    if (kind === 'macro') {
      var name = 'macro expansion' + (event.name ? ': ' + event.name : '');

      return '<span class="tag macro">' + name + '</span>'
        + this.escapeHTML(event.expansion).replace(/(?:\r\n|\r|\n)/g, '<br>');
    } else if (kind === 'note') {
      return '<span class="tag note">note</span>'
        +  this.escapeHTML(event.message).replace(/(?:\r\n|\r|\n)/g, '<br>');
    }
  },

  addExtraPathEvents : function (events, kind) {
    var that = this;

    if (!events) {
      return;
    }

    events.forEach(function (event) {
      if (event.location.file !== that._currentBugEvent.location.file) {
        return;
      }

      var left =
        that._codeMirror.defaultCharWidth() * event.location.col + 'px';

      var element = document.createElement('div');
      element.setAttribute('style', 'margin-left: ' + left);
      element.setAttribute('class', 'check-msg ' + kind);

      var msg = document.createElement('span');
      msg.innerHTML = that.getMessage(event, kind);
      element.appendChild(msg);

      that._lineWidgets.push(that._codeMirror.addLineWidget(
        event.location.line - 1, element));
    });
  },

  drawBugPath : function () {
    var that = this;

    this.clearBubbles();

    this.addExtraPathEvents(this._currentReport.macros, 'macro');
    this.addExtraPathEvents(this._currentReport.notes, 'note');

    // Processing bug path events.
    var currentEvents = this._currentReport.events;
    currentEvents.forEach(function (event, step) {
      if (event.location.file !== that._currentBugEvent.location.file)
        return;

      var left =
        that._codeMirror.defaultCharWidth() * event.location.col + 'px';
      var type = step === currentEvents.length - 1 ? 'error' : 'info';

      var element = document.createElement('div');
      element.setAttribute('style', 'margin-left: ' + left);
      element.setAttribute('class', 'check-msg ' + type);
      element.setAttribute('idx', step);

      var enumeration = document.createElement('span');
      enumeration.setAttribute('class', 'checker-enum ' + type);
      enumeration.innerHTML = step + 1;

      if (currentEvents.length > 1)
        element.appendChild(enumeration);

      var prevBugEvent = step - 1;
      if (step > 0) {
        var prevBug = document.createElement('span');
        prevBug.setAttribute('class', 'arrow left-arrow');
        prevBug.addEventListener('click', function () {
          var event = currentEvents[prevBugEvent];
          that.setCurrentBugEvent(event, prevBugEvent);
        });
        element.appendChild(prevBug);
      }

      var msg = document.createElement('span');
      msg.innerHTML = that.escapeHTML(event.message)
        .replace(/(?:\r\n|\r|\n)/g, '<br>');

      element.appendChild(msg);

      var nextBugEvent = step + 1;
      if (nextBugEvent < currentEvents.length) {
        var nextBug = document.createElement('span');
        nextBug.setAttribute('class', 'arrow right-arrow');
        nextBug.addEventListener('click', function () {
          var event = currentEvents[nextBugEvent];
          that.setCurrentBugEvent(event, nextBugEvent);
        });
        element.appendChild(nextBug);
      }


      that._lineWidgets.push(that._codeMirror.addLineWidget(
        event.location.line - 1, element));
    });
  },

  jumpTo : function (line, column) {
    var that = this;

    setTimeout(function () {
      var selPosPixel
        = that._codeMirror.charCoords({ line : line, ch : column }, 'local');
      var editorSize = {
        width  : that._editor.clientWidth,
        height : that._editor.clientHeight
      };

      that._codeMirror.scrollIntoView({
        top    : selPosPixel.top - 100,
        bottom : selPosPixel.top + editorSize.height - 150,
        left   : selPosPixel.left < editorSize.width - 100
               ? 0
               : selPosPixel.left - 50,
        right  : selPosPixel.left < editorSize.width - 100
               ? 10
               : selPosPixel.left + editorSize.width - 100
      });
    }, 0);
  }
}


      var data = {"files": {"1": {"id": 1, "path": "/home/runner/work/testcc/testcc/retdec/ext/luawrapper/include/LuaContext.hpp", "content": "/*\nCopyright (c) 2013, Pierre KRIEGER\nAll rights reserved.\n\nRedistribution and use in source and binary forms, with or without\nmodification, are permitted provided that the following conditions are met:\n    * Redistributions of source code must retain the above copyright\n      notice, this list of conditions and the following disclaimer.\n    * Redistributions in binary form must reproduce the above copyright\n      notice, this list of conditions and the following disclaimer in the\n      documentation and/or other materials provided with the distribution.\n    * Neither the name of the <organization> nor the\n      names of its contributors may be used to endorse or promote products\n      derived from this software without specific prior written permission.\n\nTHIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND\nANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\nWARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\nDISCLAIMED. IN NO EVENT SHALL <COPYRIGHT HOLDER> BE LIABLE FOR ANY\nDIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES\n(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;\nLOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\nON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS\nSOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n*/\n\n#ifndef INCLUDE_LUACONTEXT_HPP\n#define INCLUDE_LUACONTEXT_HPP\n\n#include <algorithm>\n#include <array>\n#include <cassert>\n#include <cmath>\n#include <cstring>\n#include <functional>\n#include <limits>\n#include <list>\n#include <map>\n#include <memory>\n#include <random>\n#include <set>\n#include <stdexcept>\n#include <string>\n#include <sstream>\n#include <tuple>\n#include <type_traits>\n#include <unordered_map>\n#include <boost/any.hpp>\n#include <boost/format.hpp>\n#include <boost/mpl/distance.hpp>\n#include <boost/mpl/transform.hpp>\n#include <boost/optional.hpp>\n#include <boost/variant.hpp>\n#include <boost/type_traits.hpp>\n#include <lua.hpp>\n\n#if defined(_MSC_VER) && _MSC_VER < 1900\n#   include \"misc/exception.hpp\"\n#endif\n\n#ifdef __GNUC__\n#   define ATTR_UNUSED __attribute__((unused))\n#else\n#   define ATTR_UNUSED\n#endif\n\n#define LUACONTEXT_GLOBAL_EQ \"e5ddced079fc405aa4937b386ca387d2\"\n#define EQ_FUNCTION_NAME \"__eq\"\n#define TOSTRING_FUNCTION_NAME \"__tostring\"\n\n/**\n * Defines a Lua context\n * A Lua context is used to interpret Lua code. Since everything in Lua is a variable (including functions),\n * we only provide few functions like readVariable and writeVariable.\n *\n * You can also write variables with C++ functions so that they are callable by Lua. Note however that you HAVE TO convert\n * your function to std::function (not directly std::bind or a lambda function) so the class can detect which argument types\n * it wants. These arguments may only be of basic types (int, float, etc.) or std::string.\n */\n\n#if defined(__GNUC__) && !defined(__clang__)\n#pragma GCC diagnostic push\n#pragma GCC diagnostic ignored \"-Wmaybe-uninitialized\"\n#endif\n\nclass LuaContext {\n    struct ValueInRegistry;\n    template<typename TFunctionObject, typename TFirstParamType> struct Binder;\n    template<typename T> struct IsOptional;\n    enum Globals_t { Globals }; // tag for \"global variables\"\npublic:\n    /**\n     * @param openDefaultLibs True if luaL_openlibs should be called\n     */\n    explicit LuaContext(bool openDefaultLibs = true)\n    {\n        // luaL_newstate can return null if allocation failed\n        mState = luaL_newstate();\n        if (mState == nullptr)\n            throw std::bad_alloc();\n\n        // setting the panic function\n        lua_atpanic(mState, [](lua_State* state) -> int {\n            const std::string str = lua_tostring(state, -1);\n            lua_pop(state, 1);\n            assert(false && \"lua_atpanic triggered\");\n            exit(0);\n        });\n\n        // opening default library if required to do so\n        if (openDefaultLibs)\n            luaL_openlibs(mState);\n\n         writeGlobalEq();\n    }\n\n    void writeGlobalEq() {\n      const auto eqFunction = [](lua_State* lua) -> int {\n        try {\n          lua_pushstring(lua, \"__eq\");\n          lua_gettable(lua, -2);\n          /* if not found, return false */\n          if (lua_isnil(lua, -1)) {\n            lua_pop(lua, -2);\n            lua_pushboolean(lua, false);\n            return 1;\n          }\n          lua_insert(lua, lua_gettop(lua)-2);\n          return callRaw(lua, PushedObject{lua, 3}, 1).release();\n        } catch(...) {\n          Pusher<std::exception_ptr>::push(lua, std::current_exception()).release();\n          luaError(lua);\n        }\n      };\n      lua_pushcfunction(mState, eqFunction);\n      lua_setglobal(mState, LUACONTEXT_GLOBAL_EQ);\n    };\n\n    /**\n     * Move constructor\n     */\n    LuaContext(LuaContext&& s) :\n        mState(s.mState)\n    {\n        s.mState = luaL_newstate();\n    }\n    \n    /**\n     * Move operator\n     */\n    LuaContext& operator=(LuaContext&& s) noexcept\n    {\n        std::swap(mState, s.mState);\n        return *this;\n    }\n\n    /**\n     * Copy is forbidden\n     */\n    LuaContext(const LuaContext&) = delete;\n    \n    /**\n     * Copy is forbidden\n     */\n    LuaContext& operator=(const LuaContext&) = delete;\n\n    /**\n     * Destructor\n     */\n    ~LuaContext() noexcept\n    {\n        assert(mState);\n        lua_close(mState);\n    }\n    \n    /**\n     * Thrown when an error happens during execution of lua code (like not enough parameters for a function)\n     */\n    class ExecutionErrorException : public std::runtime_error\n    {\n    public:\n        ExecutionErrorException(const std::string& msg) :\n            std::runtime_error(msg)\n        {\n        }\n    };\n\n    /**\n     * Thrown when a syntax error happens in a lua script\n     */\n    class SyntaxErrorException : public std::runtime_error\n    {\n    public:\n        SyntaxErrorException(const std::string& msg) :\n            std::runtime_error(msg)\n        {\n        }\n    };\n\n    /**\n     * Thrown when trying to cast a Lua variable to an unvalid type, eg. trying to read a number when the variable is a string\n     */\n    class WrongTypeException : public std::runtime_error\n    {\n    public:\n        WrongTypeException(std::string luaType_, const std::type_info& destination_) :\n            std::runtime_error(\"Trying to cast a lua variable from \\\"\" + luaType_ + \"\\\" to \\\"\" + destination_.name() + \"\\\"\"),\n            luaType(luaType_),\n            destination(destination_)\n        {\n        }\n        \n        std::string luaType;\n        const std::type_info& destination;\n    };\n\n    /**\n     * Function object that can call a function stored by Lua\n     * This type is copiable and movable, but not constructible. It can only be created through readVariable.\n     * @tparam TFunctionType    Function type (eg. \"int (int, bool)\")\n     */\n    template<typename TFunctionType>\n    class LuaFunctionCaller;\n\n    /**\n     * Opaque type that identifies a Lua object\n     */\n    struct LuaObject {\n        LuaObject() = default;\n        LuaObject(lua_State* state, int index=-1) {\n            this->objectInRegistry = std::make_shared<LuaContext::ValueInRegistry>(state, index);\n        }\n        std::shared_ptr<LuaContext::ValueInRegistry> objectInRegistry;\n    };\n\n    /**\n     * Opaque type that identifies a Lua thread\n     */\n    struct ThreadID {\n        ThreadID() = default;\n        ThreadID(ThreadID&& o) : state(o.state), threadInRegistry(std::move(o.threadInRegistry)) { }\n        ThreadID& operator=(ThreadID&& o) { std::swap(state, o.state); std::swap(threadInRegistry, o.threadInRegistry); return *this; }\n    public:\n        friend LuaContext;\n        lua_State* state;\n        std::unique_ptr<ValueInRegistry> threadInRegistry;\n    };\n\n    /**\n     * Type that is considered as an empty array\n     */\n    enum EmptyArray_t { EmptyArray };\n\n    /**\n     * Type for a metatable\n     */\n    enum Metatable_t { Metatable };\n\n    /**\n     * Executes lua code from the stream\n     * @param code      A stream that Lua will read its code from\n     */\n    void executeCode(std::istream& code)\n    {\n        auto toCall = load(mState, code);\n        call<std::tuple<>>(mState, std::move(toCall));\n    }\n\n    /**\n     * Executes lua code from the stream and returns a value\n     * @param code      A stream that Lua will read its code from\n     * @tparam TType    The type that the executing code should return\n     */\n    template<typename TType>\n    auto executeCode(std::istream& code)\n        -> TType\n    {\n        auto toCall = load(mState, code);\n        return call<TType>(mState, std::move(toCall));\n    }\n\n    /**\n     * Executes lua code given as parameter\n     * @param code      A string containing code that will be executed by Lua\n     */\n    void executeCode(const std::string& code)\n    {\n        executeCode(code.c_str());\n    }\n    \n    /*\n     * Executes Lua code from the stream and returns a value\n     * @param code      A string containing code that will be executed by Lua\n     * @tparam TType    The type that the executing code should return\n     */\n    template<typename TType>\n    auto executeCode(const std::string& code)\n        -> TType\n    {\n        return executeCode<TType>(code.c_str());\n    }\n\n    /**\n     * Executes Lua code\n     * @param code      A string containing code that will be executed by Lua\n     */\n    void executeCode(const char* code)\n    {\n        auto toCall = load(mState, code);\n        call<std::tuple<>>(mState, std::move(toCall));\n    }\n\n    /*\n     * Executes Lua code from the stream and returns a value\n     * @param code      A string containing code that will be executed by Lua\n     * @tparam TType    The type that the executing code should return\n     */\n    template<typename TType>\n    auto executeCode(const char* code)\n        -> TType\n    {\n        auto toCall = load(mState, code);\n        return call<TType>(mState, std::move(toCall));\n    }\n\n    /**\n     * Executes lua code from the stream\n     * @param code      A stream that Lua will read its code from\n     */\n    void executeCode(const ThreadID& thread, std::istream& code)\n    {\n        auto toCall = load(thread.state, code);\n        call<std::tuple<>>(thread.state, std::move(toCall));\n    }\n\n    /**\n     * Executes lua code from the stream and returns a value\n     * @param code      A stream that Lua will read its code from\n     * @tparam TType    The type that the executing code should return\n     */\n    template<typename TType>\n    auto executeCode(const ThreadID& thread, std::istream& code)\n        -> TType\n    {\n        auto toCall = load(thread.state, code);\n        return call<TType>(thread.state, std::move(toCall));\n    }\n\n    /**\n     * Executes lua code given as parameter\n     * @param code      A string containing code that will be executed by Lua\n     */\n    void executeCode(const ThreadID& thread, const std::string& code)\n    {\n        executeCode(thread, code.c_str());\n    }\n    \n    /*\n     * Executes Lua code from the stream and returns a value\n     * @param code      A string containing code that will be executed by Lua\n     * @tparam TType    The type that the executing code should return\n     */\n    template<typename TType>\n    auto executeCode(const ThreadID& thread, const std::string& code)\n        -> TType\n    {\n        return executeCode<TType>(thread, code.c_str());\n    }\n\n    /**\n     * Executes Lua code\n     * @param code      A string containing code that will be executed by Lua\n     */\n    void executeCode(const ThreadID& thread, const char* code)\n    {\n        auto toCall = load(thread.state, code);\n        call<std::tuple<>>(thread.state, std::move(toCall));\n    }\n\n    /*\n     * Executes Lua code from the stream and returns a value\n     * @param code      A string containing code that will be executed by Lua\n     * @tparam TType    The type that the executing code should return\n     */\n    template<typename TType>\n    auto executeCode(const ThreadID& thread, const char* code)\n        -> TType\n    {\n        auto toCall = load(thread.state, code);\n        return call<TType>(thread.state, std::move(toCall));\n    }\n    \n    /**\n     * Tells that Lua will be allowed to access an object's function\n     * This is the version \"registerFunction(name, &Foo::function)\"\n     */\n    template<typename TPointerToMemberFunction>\n    auto registerFunction(const std::string& name, TPointerToMemberFunction pointer)\n        -> typename std::enable_if<std::is_member_function_pointer<TPointerToMemberFunction>::value>::type\n    {\n        registerFunctionImpl(name, std::mem_fn(pointer), tag<TPointerToMemberFunction>{});\n    }\n\n    /**\n     * Tells that Lua will be allowed to access an object's function\n     * This is the version with an explicit template parameter: \"registerFunction<void (Foo::*)()>(name, [](Foo&) { })\"\n     * @param fn                Function object which takes as first parameter a reference to the object\n     * @tparam TFunctionType    Pointer-to-member function type\n     */\n    template<typename TFunctionType, typename TType>\n    void registerFunction(const std::string& functionName, TType fn)\n    {\n        static_assert(std::is_member_function_pointer<TFunctionType>::value, \"registerFunction must take a member function pointer type as template parameter\");\n        registerFunctionImpl(functionName, std::move(fn), tag<TFunctionType>{});\n    }\n\n    /**\n     * Tells that Lua will be allowed to access an object's function\n     * This is the alternative version with an explicit template parameter: \"registerFunction<Foo, void (*)()>(name, [](Foo&) { })\"\n     * @param fn                Function object which takes as first parameter a reference to the object\n     * @tparam TObject          Object to register this function to\n     * @tparam TFunctionType    Function type\n     */\n    template<typename TObject, typename TFunctionType, typename TType>\n    void registerFunction(const std::string& functionName, TType fn)\n    {\n        static_assert(std::is_function<TFunctionType>::value, \"registerFunction must take a function type as template parameter\");\n        registerFunctionImpl(functionName, std::move(fn), tag<TObject>{}, tag<TFunctionType>{});\n    }\n\n    /**\n     * Wrappers for registering \"__eq\" function in case we want to change this to something else some day\n     */\n\n    template<typename TPointerToMemberFunction>\n    auto registerEqFunction(TPointerToMemberFunction pointer)\n        -> typename std::enable_if<std::is_member_function_pointer<TPointerToMemberFunction>::value>::type\n    {\n        registerFunctionImpl(EQ_FUNCTION_NAME, std::mem_fn(pointer), tag<TPointerToMemberFunction>{});\n    }\n\n    template<typename TFunctionType, typename TType>\n    void registerEqFunction(TType fn)\n    {\n        static_assert(std::is_member_function_pointer<TFunctionType>::value, \"registerFunction must take a member function pointer type as template parameter\");\n        registerFunctionImpl(EQ_FUNCTION_NAME, std::move(fn), tag<TFunctionType>{});\n    }\n\n    template<typename TObject, typename TFunctionType, typename TType>\n    void registerEqFunction(TType fn)\n       {\n        static_assert(std::is_function<TFunctionType>::value, \"registerFunction must take a function type as template parameter\");\n        registerFunctionImpl(EQ_FUNCTION_NAME, std::move(fn), tag<TObject>{}, tag<TFunctionType>{});\n    }\n\n    /**\n     * Wrappers for registering \"__tostring\" function in case we want to change this to something else some day\n     */\n\n    template<typename TPointerToMemberFunction>\n    auto registerToStringFunction(TPointerToMemberFunction pointer)\n        -> typename std::enable_if<std::is_member_function_pointer<TPointerToMemberFunction>::value>::type\n    {\n        registerFunctionImpl(TOSTRING_FUNCTION_NAME, std::mem_fn(pointer), tag<TPointerToMemberFunction>{});\n    }\n\n    template<typename TFunctionType, typename TType>\n    void registerToStringFunction(TType fn)\n    {\n        static_assert(std::is_member_function_pointer<TFunctionType>::value, \"registerFunction must take a member function pointer type as template parameter\");\n        registerFunctionImpl(TOSTRING_FUNCTION_NAME, std::move(fn), tag<TFunctionType>{});\n    }\n\n    template<typename TObject, typename TFunctionType, typename TType>\n    void registerToStringFunction(TType fn)\n       {\n        static_assert(std::is_function<TFunctionType>::value, \"registerFunction must take a function type as template parameter\");\n        registerFunctionImpl(TOSTRING_FUNCTION_NAME, std::move(fn), tag<TObject>{}, tag<TFunctionType>{});\n    }\n\n    /**\n     * Inverse operation of registerFunction\n     * @tparam TType Type whose function belongs to\n     */\n    template<typename TType>\n    void unregisterFunction(const std::string& /*functionName*/)\n    {\n        lua_pushlightuserdata(mState, const_cast<std::type_info*>(&typeid(TType)));\n        lua_pushnil(mState);\n        lua_settable(mState, LUA_REGISTRYINDEX);\n        checkTypeRegistration(mState, &typeid(TType));\n        \n        lua_pushlightuserdata(mState, const_cast<std::type_info*>(&typeid(TType*)));\n        lua_pushnil(mState);\n        lua_settable(mState, LUA_REGISTRYINDEX);\n        checkTypeRegistration(mState, &typeid(TType*));\n        \n        lua_pushlightuserdata(mState, const_cast<std::type_info*>(&typeid(std::shared_ptr<TType>)));\n        lua_pushnil(mState);\n        lua_settable(mState, LUA_REGISTRYINDEX);\n        checkTypeRegistration(mState, &typeid(std::shared_ptr<TType>));\n    }\n    \n    /**\n     * Registers a member variable\n     * This is the version \"registerMember(name, &Foo::member)\"\n     */\n    template<typename TObject, typename TVarType>\n    void registerMember(const std::string& name, TVarType TObject::*member)\n    {\n        // implementation simply calls the custom member with getter and setter\n        const auto getter = [=](const TObject& obj) -> TVarType { return obj.*member; };\n        const auto setter = [=](TObject& obj, const TVarType& value) { obj.*member = value; };\n        registerMember<TVarType (TObject::*)>(name, getter, setter);\n    }\n\n    /**\n     * Registers a member variable\n     * This is the version \"registerMember<Foo, int>(name, getter, setter)\"\n     * @tparam TObject       Type to register the member to\n     * @tparam TVarType      Type of the member\n     * @param name           Name of the member to register\n     * @param readFunction   Function of type \"TVarType (const TObject&)\"\n     * @param writeFunction_  Function of type \"void (TObject&, const TVarType&)\"\n     */\n    template<typename TObject, typename TVarType, typename TReadFunction, typename TWriteFunction>\n    void registerMember(const std::string& name, TReadFunction readFunction, TWriteFunction writeFunction_)\n    {\n        registerMemberImpl<TObject,TVarType>(name, std::move(readFunction), std::move(writeFunction_));\n    }\n\n    /**\n     * Registers a member variable\n     * This is the version \"registerMember<int (Foo::*)>(name, getter, setter)\"\n     * @tparam TMemberType   Pointer to member object representing the type\n     * @param name           Name of the member to register\n     * @param readFunction   Function of type \"TVarType (const TObject&)\"\n     * @param writeFunction_  Function of type \"void (TObject&, const TVarType&)\"\n     */\n    template<typename TMemberType, typename TReadFunction, typename TWriteFunction>\n    void registerMember(const std::string& name, TReadFunction readFunction, TWriteFunction writeFunction_)\n    {\n        static_assert(std::is_member_object_pointer<TMemberType>::value, \"registerMember must take a member object pointer type as template parameter\");\n        registerMemberImpl(tag<TMemberType>{}, name, std::move(readFunction), std::move(writeFunction_));\n    }\n\n    /**\n     * Registers a non-modifiable member variable\n     * This is the version \"registerMember<Foo, int>(name, getter)\"\n     * @tparam TObject       Type to register the member to\n     * @tparam TVarType      Type of the member\n     * @param name           Name of the member to register\n     * @param readFunction   Function of type \"TVarType (const TObject&)\"\n     */\n    template<typename TObject, typename TVarType, typename TReadFunction>\n    void registerMember(const std::string& name, TReadFunction readFunction)\n    {\n        registerMemberImpl<TObject,TVarType>(name, std::move(readFunction));\n    }\n\n    /**\n     * Registers a non-modifiable member variable\n     * This is the version \"registerMember<int (Foo::*)>(name, getter)\"\n     * @tparam TMemberType   Pointer to member object representing the type\n     * @param name           Name of the member to register\n     * @param readFunction   Function of type \"TVarType (const TObject&)\"\n     */\n    template<typename TMemberType, typename TReadFunction>\n    void registerMember(const std::string& name, TReadFunction readFunction)\n    {\n        static_assert(std::is_member_object_pointer<TMemberType>::value, \"registerMember must take a member object pointer type as template parameter\");\n        registerMemberImpl(tag<TMemberType>{}, name, std::move(readFunction));\n    }\n\n    /**\n     * Registers a dynamic member variable\n     * This is the version \"registerMember<Foo, int>(getter, setter)\"\n     * @tparam TObject       Type to register the member to\n     * @tparam TVarType      Type of the member\n     * @param readFunction   Function of type \"TVarType (const TObject&, const std::string&)\"\n     * @param writeFunction_  Function of type \"void (TObject&, const std::string&, const TVarType&)\"\n     */\n    template<typename TObject, typename TVarType, typename TReadFunction, typename TWriteFunction>\n    void registerMember(TReadFunction readFunction, TWriteFunction writeFunction_)\n    {\n        registerMemberImpl<TObject,TVarType>(std::move(readFunction), std::move(writeFunction_));\n    }\n\n    /**\n     * Registers a dynamic member variable\n     * This is the version \"registerMember<int (Foo::*)>(getter, setter)\"\n     * @tparam TMemberType   Pointer to member object representing the type\n     * @param readFunction   Function of type \"TVarType (const TObject&, const std::string&)\"\n     * @param writeFunction_  Function of type \"void (TObject&, const std::string&, const TVarType&)\"\n     */\n    template<typename TMemberType, typename TReadFunction, typename TWriteFunction>\n    void registerMember(TReadFunction readFunction, TWriteFunction writeFunction_)\n    {\n        static_assert(std::is_member_object_pointer<TMemberType>::value, \"registerMember must take a member object pointer type as template parameter\");\n        registerMemberImpl(tag<TMemberType>{}, std::move(readFunction), std::move(writeFunction_));\n    }\n\n    /**\n     * Registers a dynamic non-modifiable member variable\n     * This is the version \"registerMember<Foo, int>(getter)\"\n     * @tparam TObject       Type to register the member to\n     * @tparam TVarType      Type of the member\n     * @param readFunction   Function of type \"TVarType (const TObject&, const std::string&)\"\n     */\n    template<typename TObject, typename TVarType, typename TReadFunction>\n    void registerMember(TReadFunction readFunction)\n    {\n        registerMemberImpl<TObject, TVarType>(std::move(readFunction));\n    }\n\n    /**\n     * Registers a dynamic non-modifiable member variable\n     * This is the version \"registerMember<int (Foo::*)>(getter)\"\n     * @tparam TMemberType   Pointer to member object representing the type\n     * @param readFunction   Function of type \"TVarType (const TObject&, const std::string&)\"\n     */\n    template<typename TMemberType, typename TReadFunction>\n    void registerMember(TReadFunction readFunction)\n    {\n        static_assert(std::is_member_object_pointer<TMemberType>::value, \"registerMember must take a member object pointer type as template parameter\");\n        registerMemberImpl(tag<TMemberType>{}, std::move(readFunction));\n    }\n\n    /**\n     * Creates a new thread\n     * A Lua thread is not really a thread, but rather an \"execution stack\".\n     * You can destroy the thread by calling destroyThread\n     * @sa destroyThread\n     */\n    auto createThread()\n        -> ThreadID\n    {\n        ThreadID result;\n\n        result.state = lua_newthread(mState);\n        result.threadInRegistry = std::unique_ptr<ValueInRegistry>(new ValueInRegistry(mState));\n        lua_pop(mState, 1);\n\n        return result;\n    }\n\n    /**\n     * Destroys a thread created with createThread\n     * @sa createThread\n     */\n    void destroyThread(ThreadID& id)\n    {\n        id.threadInRegistry.reset();\n    }\n    \n    /**\n     * Reads the content of a Lua variable\n     * \n     * @tparam TType                Type requested for the read\n     * @throw WrongTypeException    When the variable is not convertible to the requested type\n     * @sa writeVariable\n     *\n     * Readable types are all types accepted by writeVariable except nullptr, std::unique_ptr and function pointers\n     * Additionally supported:\n     *  - LuaFunctionCaller<FunctionType>, which is an alternative to std::function\n     *  - references to custom objects, in which case it will return the object in-place\n     *\n     * After the variable name, you can add other parameters.\n     * If the variable is an array, it will instead get the element of that array whose offset is the second parameter.\n     * Same applies for third, fourth, etc. parameters.\n    */\n    template<typename TType, typename... TTypes>\n    TType readVariable(const std::string& name, TTypes&&... elements) const\n    {\n        lua_getglobal(mState, name.c_str());\n        lookIntoStackTop(mState, std::forward<TTypes>(elements)...);\n        return readTopAndPop<TType>(mState, PushedObject{mState, 1});\n    }\n    \n    /**\n     * @sa readVariable\n     */\n    template<typename TType, typename... TTypes>\n    TType readVariable(const char* name, TTypes&&... elements) const\n    {\n        lua_getglobal(mState, name);\n        lookIntoStackTop(mState, std::forward<TTypes>(elements)...);\n        return readTopAndPop<TType>(mState, PushedObject{mState, 1});\n    }\n    \n    /**\n     * @sa readVariable\n     */\n    template<typename TType, typename... TTypes>\n    TType readVariable(const ThreadID& thread, const std::string& name, TTypes&&... elements) const\n    {\n        lua_getglobal(thread.state, name.c_str());\n        lookIntoStackTop(thread.state, std::forward<TTypes>(elements)...);\n        return readTopAndPop<TType>(thread.state, PushedObject{thread.state, 1});\n    }\n    \n    /**\n     * @sa readVariable\n     */\n    template<typename TType, typename... TTypes>\n    TType readVariable(const ThreadID& thread, const char* name, TTypes&&... elements) const\n    {\n        lua_getglobal(thread.state, name);\n        lookIntoStackTop(thread.state, std::forward<TTypes>(elements)...);\n        return readTopAndPop<TType>(thread.state, PushedObject{thread.state, 1});\n    }\n    \n    /**\n     * Changes the content of a Lua variable\n     * \n     * Accepted values are:\n     * - all base types (char, short, int, float, double, bool)\n     * - std::string\n     * - enums\n     * - std::vector<>\n     * - std::vector<std::pair<>>, std::map<> and std::unordered_map<> (the key and value must also be accepted values)\n     * - std::function<> (all parameters must be accepted values, and return type must be either an accepted value for readVariable or a tuple)\n     * - std::shared_ptr<> (std::unique_ptr<> are converted to std::shared_ptr<>)\n     * - nullptr (writes nil)\n     * - any object\n     *\n     * All objects are passed by copy and destroyed by the garbage collector if necessary.\n     */\n    template<typename... TData>\n    void writeVariable(TData&&... data) noexcept {\n        static_assert(sizeof...(TData) >= 2, \"You must pass at least a variable name and a value to writeVariable\");\n        typedef typename std::decay<typename std::tuple_element<sizeof...(TData) - 1,std::tuple<TData...>>::type>::type\n            RealDataType;\n        static_assert(!std::is_same<typename Tupleizer<RealDataType>::type,RealDataType>::value, \"Error: you can't use LuaContext::writeVariable with a tuple\");\n        \n        setTable<RealDataType>(mState, Globals, std::forward<TData>(data)...);\n    }\n    \n    /**\n     * Equivalent to writeVariable(varName, ..., std::function<TFunctionType>(data));\n     * This version is more efficient than writeVariable if you want to write functions\n     */\n    template<typename TFunctionType, typename... TData>\n    void writeFunction(TData&&... data) noexcept {\n        static_assert(sizeof...(TData) >= 2, \"You must pass at least a variable name and a value to writeFunction\");\n        \n        setTable<TFunctionType>(mState, Globals, std::forward<TData>(data)...);\n    }\n\n    /**\n     * Same as the other writeFunction, except that the template parameter is automatically detected\n     * This only works if the data is either a native function pointer, or contains one operator() (this is the case for lambdas)\n     */\n    template<typename... TData>\n    void writeFunction(TData&&... data) noexcept {\n        static_assert(sizeof...(TData) >= 2, \"You must pass at least a variable name and a value to writeFunction\");\n        typedef typename std::decay<typename std::tuple_element<sizeof...(TData) - 1,std::tuple<TData...>>::type>::type\n            RealDataType;\n        typedef typename FunctionTypeDetector<RealDataType>::type\n            DetectedFunctionType;\n        \n        return writeFunction<DetectedFunctionType>(std::forward<TData>(data)...);\n    }\n    \n\nprivate:\n    // the state is the most important variable in the class since it is our interface with Lua\n    //  - registered members and functions are stored in tables at offset &typeid(type) of the registry\n    //    each table has its getter functions at offset 0, getter members at offset 1, default getter at offset 2\n    //    offset 3 is unused, setter members at offset 4, default setter at offset 5\n    lua_State*                  mState;\n\n    \n    /**************************************************/\n    /*                 PUSH OBJECT                    */\n    /**************************************************/\n    struct PushedObject {\n        PushedObject(lua_State* state_, int num_ = 1) : state(state_), num(num_) {}\n        ~PushedObject() { assert(lua_gettop(state) >= num); if (num >= 1) lua_pop(state, num); }\n        \n        PushedObject& operator=(const PushedObject&) = delete;\n        PushedObject(const PushedObject&) = delete;\n        PushedObject& operator=(PushedObject&& other) { std::swap(state, other.state); std::swap(num, other.num); return *this; }\n        PushedObject(PushedObject&& other) : state(other.state), num(other.num) { other.num = 0; }\n\n        PushedObject operator+(PushedObject&& other) && { PushedObject obj(state, num + other.num); num = 0; other.num = 0; return obj; }\n        void operator+=(PushedObject&& other) { assert(state == other.state); num += other.num; other.num = 0; }\n        \n        auto getState() const -> lua_State* { return state; }\n        auto getNum() const -> int { return num; }\n\n        int release() { const auto n = num; num = 0; return n; }\n        void pop() { if (num >= 1) lua_pop(state, num); num = 0; }\n        void pop(int n) { assert(num >= n); lua_pop(state, n); num -= n; }\n\n    private:\n        lua_State* state;\n        int num = 0;\n    };\n    \n\n    /**************************************************/\n    /*                     MISC                       */\n    /**************************************************/\n    // type used as a tag\n    template<typename T>\n    struct tag {};\n\n    // tag for \"the registry\"\n    enum RegistryTag { Registry };\n    \n    // this function takes a value representing the offset to look into\n    // it will look into the top element of the stack and replace the element by its content at the given index\n    template<typename OffsetType1, typename... OffsetTypeOthers>\n    static void lookIntoStackTop(lua_State* state, OffsetType1&& offset1, OffsetTypeOthers&&... offsetOthers) {\n        static_assert(Pusher<typename std::decay<OffsetType1>::type>::minSize == 1 && Pusher<typename std::decay<OffsetType1>::type>::maxSize == 1, \"Impossible to have a multiple-values index\");\n        auto p1 = Pusher<typename std::decay<OffsetType1>::type>::push(state, offset1);\n        lua_gettable(state, -2);\n        lua_remove(state, -2);\n        p1.release();\n\n        lookIntoStackTop(state, std::forward<OffsetTypeOthers>(offsetOthers)...);\n    }\n\n    template<typename... OffsetTypeOthers>\n    static void lookIntoStackTop(lua_State* state, Metatable_t, OffsetTypeOthers&&... offsetOthers) {\n        lua_getmetatable(state, -1);\n        lua_remove(state, -2);\n\n        lookIntoStackTop(state, std::forward<OffsetTypeOthers>(offsetOthers)...);\n    }\n    \n    static void lookIntoStackTop(lua_State*) {\n    }\n    \n    // equivalent of lua_settable with t[k]=n, where t is the value at the index in the template parameter, k is the second parameter, n is the last parameter, and n is pushed by the function in the first parameter\n    // if there are more than 3 parameters, parameters 3 to n-1 are considered as sub-indices into the array\n    // the dataPusher MUST push only one thing on the stack\n    // TTableIndex must be either LUA_REGISTRYINDEX, LUA_GLOBALSINDEX, LUA_ENVINDEX, or the position of the element on the stack\n    template<typename TDataType, typename TIndex, typename TData>\n    static void setTable(lua_State* state, const PushedObject&, TIndex&& index, TData&& data) noexcept\n    {\n        static_assert(Pusher<typename std::decay<TIndex>::type>::minSize == 1 && Pusher<typename std::decay<TIndex>::type>::maxSize == 1, \"Impossible to have a multiple-values index\");\n        static_assert(Pusher<typename std::decay<TDataType>::type>::minSize == 1 && Pusher<typename std::decay<TDataType>::type>::maxSize == 1, \"Impossible to have a multiple-values data\");\n        \n        auto p1 = Pusher<typename std::decay<TIndex>::type>::push(state, index);\n        auto p2 = Pusher<typename std::decay<TDataType>::type>::push(state, std::forward<TData>(data));\n\n        lua_settable(state, -3);\n        p1.release();\n        p2.release();\n    }\n\n    template<typename TDataType, typename TData>\n    static void setTable(lua_State* state, const PushedObject&, const std::string& index, TData&& data) noexcept\n    {\n        static_assert(Pusher<typename std::decay<TDataType>::type>::minSize == 1 && Pusher<typename std::decay<TDataType>::type>::maxSize == 1, \"Impossible to have a multiple-values data\");\n\n        auto p1 = Pusher<typename std::decay<TDataType>::type>::push(state, std::forward<TData>(data));\n        lua_setfield(state, -2, index.c_str());\n        p1.release();\n    }\n\n    template<typename TDataType, typename TData>\n    static void setTable(lua_State* state, const PushedObject&, const char* index, TData&& data) noexcept\n    {\n        static_assert(Pusher<typename std::decay<TDataType>::type>::minSize == 1 && Pusher<typename std::decay<TDataType>::type>::maxSize == 1, \"Impossible to have a multiple-values data\");\n        \n        auto p1 = Pusher<typename std::decay<TDataType>::type>::push(state, std::forward<TData>(data));\n        lua_setfield(state, -2, index);\n        p1.release();\n    }\n\n    template<typename TDataType, typename TData>\n    static void setTable(lua_State* state, const PushedObject&, Metatable_t, TData&& data) noexcept\n    {\n        static_assert(Pusher<typename std::decay<TDataType>::type>::minSize == 1 && Pusher<typename std::decay<TDataType>::type>::maxSize == 1, \"Impossible to have a multiple-values data\");\n        \n        auto p1 = Pusher<typename std::decay<TDataType>::type>::push(state, std::forward<TData>(data));\n        lua_setmetatable(state, -2);\n        p1.release();\n    }\n\n    template<typename TDataType, typename TIndex1, typename TIndex2, typename TIndex3, typename... TIndices>\n    static auto setTable(lua_State* state, PushedObject&, TIndex1&& index1, TIndex2&& index2, TIndex3&& index3, TIndices&&... indices) noexcept\n        -> typename std::enable_if<!std::is_same<typename std::decay<TIndex1>::type, Metatable_t>::value>::type\n    {\n        static_assert(Pusher<typename std::decay<TIndex1>::type>::minSize == 1 && Pusher<typename std::decay<TIndex1>::type>::maxSize == 1, \"Impossible to have a multiple-values index\");\n        \n        auto p1 = Pusher<typename std::decay<TIndex1>::type>::push(state, std::forward<TIndex1>(index1));\n        lua_gettable(state, -2);\n\n        setTable<TDataType>(state, std::move(p1), std::forward<TIndex2>(index2), std::forward<TIndex3>(index3), std::forward<TIndices>(indices)...);\n    }\n\n    template<typename TDataType, typename TIndex1, typename TIndex2, typename TIndex3, typename... TIndices>\n    static auto setTable(lua_State* state, PushedObject&& pushedTable, TIndex1&& index1, TIndex2&& index2, TIndex3&& index3, TIndices&&... indices) noexcept\n        -> typename std::enable_if<!std::is_same<typename std::decay<TIndex1>::type, Metatable_t>::value>::type\n    {\n        static_assert(Pusher<typename std::decay<TIndex1>::type>::minSize == 1 && Pusher<typename std::decay<TIndex1>::type>::maxSize == 1, \"Impossible to have a multiple-values index\");\n        \n        auto p1 = Pusher<typename std::decay<TIndex1>::type>::push(state, std::forward<TIndex1>(index1)) + std::move(pushedTable);\n        lua_gettable(state, -2);\n\n        setTable<TDataType>(state, std::move(p1), std::forward<TIndex2>(index2), std::forward<TIndex3>(index3), std::forward<TIndices>(indices)...);\n    }\n\n    template<typename TDataType, typename TIndex2, typename TIndex3, typename... TIndices>\n    static void setTable(lua_State* state, PushedObject& pushedObject, Metatable_t, TIndex2&& index2, TIndex3&& index3, TIndices&&... indices) noexcept\n    {\n        if (lua_getmetatable(state, -1) == 0)\n        {\n            lua_newtable(state);\n            PushedObject p1{state, 1};\n\n            setTable<TDataType>(state, p1, std::forward<TIndex2>(index2), std::forward<TIndex3>(index3), std::forward<TIndices>(indices)...);\n\n            lua_setmetatable(state, -2);\n            p1.release();\n        }\n        else\n        {\n            setTable<TDataType>(state, pushedObject, std::forward<TIndex2>(index2), std::forward<TIndex3>(index3), std::forward<TIndices>(indices)...);\n        }\n    }\n\n    template<typename TDataType, typename TIndex2, typename TIndex3, typename... TIndices>\n    static void setTable(lua_State* state, PushedObject&& pushedObject, Metatable_t, TIndex2&& index2, TIndex3&& index3, TIndices&&... indices) noexcept\n    {\n        if (lua_getmetatable(state, -1) == 0)\n        {\n            lua_newtable(state);\n            PushedObject p1{state, 1};\n\n            setTable<TDataType>(state, p1, std::forward<TIndex2>(index2), std::forward<TIndex3>(index3), std::forward<TIndices>(indices)...);\n\n            lua_setmetatable(state, -2);\n            p1.release();\n        }\n        else\n        {\n            setTable<TDataType>(state, std::move(pushedObject), std::forward<TIndex2>(index2), std::forward<TIndex3>(index3), std::forward<TIndices>(indices)...);\n        }\n    }\n\n    template<typename TDataType, typename TIndex, typename TData>\n    static void setTable(lua_State* state, RegistryTag, TIndex&& index, TData&& data) noexcept\n    {\n        static_assert(Pusher<typename std::decay<TIndex>::type>::minSize == 1 && Pusher<typename std::decay<TIndex>::type>::maxSize == 1, \"Impossible to have a multiple-values index\");\n        static_assert(Pusher<typename std::decay<TDataType>::type>::minSize == 1 && Pusher<typename std::decay<TDataType>::type>::maxSize == 1, \"Impossible to have a multiple-values data\");\n        \n        auto p1 = Pusher<typename std::decay<TIndex>::type>::push(state, index);\n        auto p2 = Pusher<typename std::decay<TDataType>::type>::push(state, std::forward<TData>(data));\n\n        lua_settable(state, LUA_REGISTRYINDEX);\n        p1.release();\n        p2.release();\n    }\n\n    template<typename TDataType, typename TData>\n    static void setTable(lua_State* state, RegistryTag, const std::string& index, TData&& data) noexcept\n    {\n        static_assert(Pusher<typename std::decay<TDataType>::type>::minSize == 1 && Pusher<typename std::decay<TDataType>::type>::maxSize == 1, \"Impossible to have a multiple-values data\");\n\n        auto p1 = Pusher<typename std::decay<TDataType>::type>::push(state, std::forward<TData>(data));\n        lua_setfield(state, LUA_REGISTRYINDEX, index.c_str());\n        p1.release();\n    }\n\n    template<typename TDataType, typename TData>\n    static void setTable(lua_State* state, RegistryTag, const char* index, TData&& data) noexcept\n    {\n        static_assert(Pusher<typename std::decay<TDataType>::type>::minSize == 1 && Pusher<typename std::decay<TDataType>::type>::maxSize == 1, \"Impossible to have a multiple-values data\");\n\n        auto p1 = Pusher<typename std::decay<TDataType>::type>::push(state, std::forward<TData>(data));\n        lua_setfield(state, LUA_REGISTRYINDEX, index);\n        p1.release();\n    }\n\n    template<typename TDataType, typename TIndex1, typename TIndex2, typename TIndex3, typename... TIndices>\n    static void setTable(lua_State* state, RegistryTag, TIndex1&& index1, TIndex2&& index2, TIndex3&& index3, TIndices&&... indices) noexcept\n    {\n        static_assert(Pusher<typename std::decay<TIndex1>::type>::minSize == 1 && Pusher<typename std::decay<TIndex1>::type>::maxSize == 1, \"Impossible to have a multiple-values index\");\n        \n        auto p1 = Pusher<typename std::decay<TIndex1>::type>::push(state, std::forward<TIndex1>(index1));\n        lua_gettable(state, LUA_REGISTRYINDEX);\n\n        setTable<TDataType>(state, std::move(p1), std::forward<TIndex2>(index2), std::forward<TIndex3>(index3), std::forward<TIndices>(indices)...);\n    }\n\n    template<typename TDataType, typename TIndex, typename TData>\n    static void setTable(lua_State* state, Globals_t, TIndex&& index, TData&& data) noexcept\n    {\n        static_assert(Pusher<typename std::decay<TIndex>::type>::minSize == 1 && Pusher<typename std::decay<TIndex>::type>::maxSize == 1, \"Impossible to have a multiple-values index\");\n        static_assert(Pusher<typename std::decay<TDataType>::type>::minSize == 1 && Pusher<typename std::decay<TDataType>::type>::maxSize == 1, \"Impossible to have a multiple-values data\");\n        \n        \n#       if LUA_VERSION_NUM >= 502\n\n            lua_pushglobaltable(state);\n            PushedObject p3{state, 1};\n            auto p1 = Pusher<typename std::decay<TIndex>::type>::push(state, index);\n            auto p2 = Pusher<typename std::decay<TDataType>::type>::push(state, std::forward<TData>(data));\n            lua_settable(state, -3);\n\n#       else\n            \n            auto p1 = Pusher<typename std::decay<TIndex>::type>::push(state, index);\n            auto p2 = Pusher<typename std::decay<TDataType>::type>::push(state, std::forward<TData>(data));\n            lua_settable(state, LUA_GLOBALSINDEX);\n\n#       endif\n\n        p1.release();\n        p2.release();\n    }\n\n    template<typename TDataType, typename TData>\n    static void setTable(lua_State* state, Globals_t, const std::string& index, TData&& data) noexcept\n    {\n        static_assert(Pusher<typename std::decay<TDataType>::type>::minSize == 1 && Pusher<typename std::decay<TDataType>::type>::maxSize == 1, \"Impossible to have a multiple-values data\");\n\n        auto p1 = Pusher<typename std::decay<TDataType>::type>::push(state, std::forward<TData>(data));\n        lua_setglobal(state, index.c_str());\n        p1.release();\n    }\n\n    template<typename TDataType, typename TData>\n    static void setTable(lua_State* state, Globals_t, const char* index, TData&& data) noexcept\n    {\n        static_assert(Pusher<typename std::decay<TDataType>::type>::minSize == 1 && Pusher<typename std::decay<TDataType>::type>::maxSize == 1, \"Impossible to have a multiple-values data\");\n\n        auto p1 = Pusher<typename std::decay<TDataType>::type>::push(state, std::forward<TData>(data));\n        lua_setglobal(state, index);\n        p1.release();\n    }\n\n    template<typename TDataType, typename TIndex1, typename TIndex2, typename TIndex3, typename... TIndices>\n    static void setTable(lua_State* state, Globals_t, TIndex1&& index1, TIndex2&& index2, TIndex3&& index3, TIndices&&... indices) noexcept\n    {\n        static_assert(Pusher<typename std::decay<TIndex1>::type>::minSize == 1 && Pusher<typename std::decay<TIndex1>::type>::maxSize == 1, \"Impossible to have a multiple-values index\");\n        \n#       if LUA_VERSION_NUM >= 502\n\n            lua_pushglobaltable(state);\n            auto p1 = Pusher<typename std::decay<TIndex1>::type>::push(state, std::forward<TIndex1>(index1)) + PushedObject{state, 1};\n            lua_gettable(state, -2);\n\n#       else\n\n            auto p1 = Pusher<typename std::decay<TIndex1>::type>::push(state, std::forward<TIndex1>(index1));\n            lua_gettable(state, LUA_GLOBALSINDEX);\n\n#       endif\n\n        setTable<TDataType>(state, std::move(p1), std::forward<TIndex2>(index2), std::forward<TIndex3>(index3), std::forward<TIndices>(indices)...);\n    }\n\n    // TODO: g++ reports \"ambiguous overload\"\n    /*template<typename TDataType, typename TIndex2, typename TIndex3, typename... TIndices>\n    static void setTable(lua_State* state, Globals_t, const char* index, TIndex2&& index2, TIndex3&& index3, TIndices&&... indices) noexcept\n    {\n        lua_getglobal(state, index);\n        PushedObject p1{state, 1};\n\n        setTable<TDataType>(state, std::move(p1), std::forward<TIndex2>(index2), std::forward<TIndex3>(index3), std::forward<TIndices>(indices)...);\n    }\n\n    template<typename TDataType, typename TIndex2, typename TIndex3, typename... TIndices>\n    static void setTable(lua_State* state, Globals_t, const std::string& index, TIndex2&& index2, TIndex3&& index3, TIndices&&... indices) noexcept\n    {\n        lua_getglobal(state, index.c_str());\n        PushedObject p1{state, 1};\n\n        setTable<TDataType>(state, std::move(p1), std::forward<TIndex2>(index2), std::forward<TIndex3>(index3), std::forward<TIndices>(indices)...);\n    }*/\n\n    // simple function that reads the \"nb\" first top elements of the stack, pops them, and returns the value\n    // warning: first parameter is the number of parameters, not the parameter index\n    // if read generates an exception, stack is poped anyway\n    template<typename TReturnType>\n    static auto readTopAndPop(lua_State* state, PushedObject object)\n        -> TReturnType\n    {\n        auto val = Reader<typename std::decay<TReturnType>::type>::read(state, -object.getNum());\n        if (!val.is_initialized())\n            throw WrongTypeException{lua_typename(state, lua_type(state, -object.getNum())), typeid(TReturnType)};\n        return val.get();\n    }\n\n    // checks that the offsets for a type's registrations are set in the registry\n    static void checkTypeRegistration(lua_State* state, const std::type_info* type)\n    {\n        lua_pushlightuserdata(state, const_cast<std::type_info*>(type));\n        lua_gettable(state, LUA_REGISTRYINDEX);\n        if (!lua_isnil(state, -1)) {\n            lua_pop(state, 1);\n            return;\n        }\n        lua_pop(state, 1);\n\n        lua_pushlightuserdata(state, const_cast<std::type_info*>(type));\n        lua_newtable(state);\n\n        lua_pushinteger(state, 0);\n        lua_newtable(state);\n        lua_settable(state, -3);\n\n        lua_pushinteger(state, 1);\n        lua_newtable(state);\n        lua_settable(state, -3);\n\n        lua_pushinteger(state, 3);\n        lua_newtable(state);\n        lua_settable(state, -3);\n\n        lua_pushinteger(state, 4);\n        lua_newtable(state);\n        lua_settable(state, -3);\n\n        lua_settable(state, LUA_REGISTRYINDEX);\n    }\n\n    // \n#   ifdef _MSC_VER\n        __declspec(noreturn)\n#   else\n        [[noreturn]]\n#   endif\n    static void luaError(lua_State* state)\n    {\n        lua_error(state);\n        assert(false);\n        std::terminate();   // removes compilation warning\n    }\n    \n\n    /**************************************************/\n    /*            FUNCTIONS REGISTRATION              */\n    /**************************************************/\n    // the \"registerFunction\" public functions call this one\n    template<typename TFunctionType, typename TRetValue, typename TObject, typename... TOtherParams>\n    void registerFunctionImpl(const std::string& functionName, TFunctionType function, tag<TObject>, tag<TRetValue (TOtherParams...)>)\n    {\n        static_assert(std::is_class<TObject>::value || std::is_pointer<TObject>::value || std::is_union<TObject>::value , \"registerFunction can only be used for a class a union or a pointer\");\n\n        checkTypeRegistration(mState, &typeid(TObject));\n        setTable<TRetValue(TObject&, TOtherParams...)>(mState, Registry, &typeid(TObject), 0, functionName, function);\n        \n        checkTypeRegistration(mState, &typeid(TObject*));\n        setTable<TRetValue(TObject*, TOtherParams...)>(mState, Registry, &typeid(TObject*), 0, functionName, [=](TObject* obj, TOtherParams... rest) { assert(obj); return function(*obj, std::forward<TOtherParams>(rest)...); });\n        \n        checkTypeRegistration(mState, &typeid(std::shared_ptr<TObject>));\n        setTable<TRetValue(std::shared_ptr<TObject>, TOtherParams...)>(mState, Registry, &typeid(std::shared_ptr<TObject>), 0, functionName, [=](const std::shared_ptr<TObject>& obj, TOtherParams... rest) { assert(obj); return function(*obj, std::forward<TOtherParams>(rest)...); });\n    }\n    \n    template<typename TFunctionType, typename TRetValue, typename TObject, typename... TOtherParams>\n    void registerFunctionImpl(const std::string& functionName, TFunctionType function, tag<const TObject>, tag<TRetValue (TOtherParams...)> fTypeTag)\n    {\n        registerFunctionImpl(functionName, function, tag<TObject>{}, fTypeTag);\n\n        checkTypeRegistration(mState, &typeid(TObject const*));\n        setTable<TRetValue(TObject const*, TOtherParams...)>(mState, Registry, &typeid(TObject const*), 0, functionName, [=](TObject const* obj, TOtherParams... rest) { assert(obj); return function(*obj, std::forward<TOtherParams>(rest)...); });\n        \n        checkTypeRegistration(mState, &typeid(std::shared_ptr<TObject const>));\n        setTable<TRetValue(std::shared_ptr<TObject const>, TOtherParams...)>(mState, Registry, &typeid(std::shared_ptr<TObject const>), 0, functionName, [=](const std::shared_ptr<TObject const>& obj, TOtherParams... rest) { assert(obj); return function(*obj, std::forward<TOtherParams>(rest)...); });\n    }\n\n    template<typename TFunctionType, typename TRetValue, typename TObject, typename... TOtherParams>\n    void registerFunctionImpl(const std::string& functionName, TFunctionType function, tag<TRetValue (TObject::*)(TOtherParams...)>)\n    {\n        registerFunctionImpl(functionName, std::move(function), tag<TObject>{}, tag<TRetValue (TOtherParams...)>{});\n    }\n\n    template<typename TFunctionType, typename TRetValue, typename TObject, typename... TOtherParams>\n    void registerFunctionImpl(const std::string& functionName, TFunctionType function, tag<TRetValue (TObject::*)(TOtherParams...) const>)\n    {\n        registerFunctionImpl(functionName, std::move(function), tag<const TObject>{}, tag<TRetValue (TOtherParams...)>{});\n    }\n\n    template<typename TFunctionType, typename TRetValue, typename TObject, typename... TOtherParams>\n    void registerFunctionImpl(const std::string& functionName, TFunctionType function, tag<TRetValue (TObject::*)(TOtherParams...) volatile>)\n    {\n        registerFunctionImpl(functionName, std::move(function), tag<TObject>{}, tag<TRetValue (TOtherParams...)>{});\n    }\n\n    template<typename TFunctionType, typename TRetValue, typename TObject, typename... TOtherParams>\n    void registerFunctionImpl(const std::string& functionName, TFunctionType function, tag<TRetValue (TObject::*)(TOtherParams...) const volatile>)\n    {\n        registerFunctionImpl(functionName, std::move(function), tag<const TObject>{}, tag<TRetValue (TOtherParams...)>{});\n    }\n\n    // the \"registerMember\" public functions call this one\n    template<typename TObject, typename TVarType, typename TReadFunction>\n    void registerMemberImpl(const std::string& name, TReadFunction readFunction)\n    {\n        static_assert(std::is_class<TObject>::value || std::is_pointer<TObject>::value, \"registerMember can only be called on a class or a pointer\");\n        \n        checkTypeRegistration(mState, &typeid(TObject));\n        setTable<TVarType (TObject&)>(mState, Registry, &typeid(TObject), 1, name, [readFunction](TObject const& object) {\n            return readFunction(object);\n        });\n        \n        checkTypeRegistration(mState, &typeid(TObject*));\n        setTable<TVarType (TObject*)>(mState, Registry, &typeid(TObject*), 1, name, [readFunction](TObject const* object) {\n            assert(object);\n            return readFunction(*object);\n        });\n        \n        checkTypeRegistration(mState, &typeid(TObject const*));\n        setTable<TVarType (TObject const*)>(mState, Registry, &typeid(TObject const*), 1, name, [readFunction](TObject const* object) {\n            assert(object);\n            return readFunction(*object);\n        });\n        \n        checkTypeRegistration(mState, &typeid(std::shared_ptr<TObject>));\n        setTable<TVarType (std::shared_ptr<TObject>)>(mState, Registry, &typeid(std::shared_ptr<TObject>), 1, name, [readFunction](const std::shared_ptr<TObject>& object) {\n            assert(object);\n            return readFunction(*object);\n        });\n        \n        checkTypeRegistration(mState, &typeid(std::shared_ptr<TObject const>));\n        setTable<TVarType (std::shared_ptr<TObject const>)>(mState, Registry, &typeid(std::shared_ptr<TObject const>), 1, name, [readFunction](const std::shared_ptr<TObject const>& object) {\n            assert(object);\n            return readFunction(*object);\n        });\n    }\n\n    template<typename TObject, typename TVarType, typename TReadFunction, typename TWriteFunction>\n    void registerMemberImpl(const std::string& name, TReadFunction readFunction, TWriteFunction writeFunction_)\n    {\n        registerMemberImpl<TObject,TVarType>(name, readFunction);\n\n        setTable<void (TObject&, TVarType)>(mState, Registry, &typeid(TObject), 4, name, [writeFunction_](TObject& object, const TVarType& value) {\n            writeFunction_(object, value);\n        });\n        \n        setTable<void (TObject*, TVarType)>(mState, Registry, &typeid(TObject*), 4, name, [writeFunction_](TObject* object, const TVarType& value) {\n            assert(object);\n            writeFunction_(*object, value);\n        });\n        \n        setTable<void (std::shared_ptr<TObject>, TVarType)>(mState, Registry, &typeid(std::shared_ptr<TObject>), 4, name, [writeFunction_](std::shared_ptr<TObject> object, const TVarType& value) {\n            assert(object);\n            writeFunction_(*object, value);\n        });\n    }\n\n    template<typename TObject, typename TVarType, typename TReadFunction, typename TWriteFunction>\n    void registerMemberImpl(tag<TVarType (TObject::*)>, const std::string& name, TReadFunction readFunction, TWriteFunction writeFunction_)\n    {\n        registerMemberImpl<TObject,TVarType>(name, std::move(readFunction), std::move(writeFunction_));\n    }\n\n    template<typename TObject, typename TVarType, typename TReadFunction>\n    void registerMemberImpl(tag<TVarType(TObject::*)>, const std::string& name, TReadFunction readFunction)\n    {\n        registerMemberImpl<TObject, TVarType>(name, std::move(readFunction));\n    }\n\n    // the \"registerMember\" public functions call this one\n    template<typename TObject, typename TVarType, typename TReadFunction>\n    void registerMemberImpl(TReadFunction readFunction)\n    {\n        checkTypeRegistration(mState, &typeid(TObject));\n        setTable<TVarType (TObject const&, std::string)>(mState, Registry, &typeid(TObject), 2, [readFunction](TObject const& object, const std::string& name) {\n            return readFunction(object, name);\n        });\n        \n        checkTypeRegistration(mState, &typeid(TObject*));\n        setTable<TVarType (TObject*, std::string)>(mState, Registry, &typeid(TObject*), 2, [readFunction](TObject const* object, const std::string& name) {\n            assert(object);\n            return readFunction(*object, name);\n        });\n        \n        checkTypeRegistration(mState, &typeid(TObject const*));\n        setTable<TVarType (TObject const*, std::string)>(mState, Registry, &typeid(TObject const*), 2, [readFunction](TObject const* object, const std::string& name) {\n            assert(object);\n            return readFunction(*object, name);\n        });\n        \n        checkTypeRegistration(mState, &typeid(std::shared_ptr<TObject>));\n        setTable<TVarType (std::shared_ptr<TObject>, std::string)>(mState, Registry, &typeid(std::shared_ptr<TObject>), 2, [readFunction](const std::shared_ptr<TObject>& object, const std::string& name) {\n            assert(object);\n            return readFunction(*object, name);\n        });\n        \n        checkTypeRegistration(mState, &typeid(std::shared_ptr<TObject const>));\n        setTable<TVarType (std::shared_ptr<TObject const>, std::string)>(mState, Registry, &typeid(std::shared_ptr<TObject const>), 2, [readFunction](const std::shared_ptr<TObject const>& object, const std::string& name) {\n            assert(object);\n            return readFunction(*object, name);\n        });\n    }\n\n    template<typename TObject, typename TVarType, typename TReadFunction, typename TWriteFunction>\n    void registerMemberImpl(TReadFunction readFunction, TWriteFunction writeFunction_)\n    {\n        registerMemberImpl<TObject,TVarType>(readFunction);\n\n        setTable<void (TObject&, std::string, TVarType)>(mState, Registry, &typeid(TObject), 5, [writeFunction_](TObject& object, const std::string& name, const TVarType& value) {\n            writeFunction_(object, name, value);\n        });\n        \n        setTable<void (TObject*, std::string, TVarType)>(mState, Registry, &typeid(TObject*), 2, [writeFunction_](TObject* object, const std::string& name, const TVarType& value) {\n            assert(object);\n            writeFunction_(*object, name, value);\n        });\n        \n        setTable<void (std::shared_ptr<TObject>, std::string, TVarType)>(mState, Registry, &typeid(std::shared_ptr<TObject>), 2, [writeFunction_](const std::shared_ptr<TObject>& object, const std::string& name, const TVarType& value) {\n            assert(object);\n            writeFunction_(*object, name, value);\n        });\n    }\n\n    template<typename TObject, typename TVarType, typename TReadFunction, typename TWriteFunction>\n    void registerMemberImpl(tag<TVarType (TObject::*)>, TReadFunction readFunction, TWriteFunction writeFunction_)\n    {\n        registerMemberImpl<TObject,TVarType>(std::move(readFunction), std::move(writeFunction_));\n    }\n\n    template<typename TObject, typename TVarType, typename TReadFunction>\n    void registerMemberImpl(tag<TVarType(TObject::*)>, TReadFunction readFunction)\n    {\n        registerMemberImpl<TObject, TVarType>(std::move(readFunction));\n    }\n    \n\n    /**************************************************/\n    /*              LOADING AND CALLING               */\n    /**************************************************/\n    // this function loads data from the stream and pushes a function at the top of the stack\n    // throws in case of syntax error\n    static PushedObject load(lua_State* state, std::istream& code) {\n        // since the lua_load function requires a static function, we use this structure\n        // the Reader structure is at the same time an object storing an istream and a buffer,\n        //   and a static function provider\n        struct Reader {\n            Reader(std::istream& str) : stream(str) {}\n            std::istream&           stream;\n            std::array<char,512>    buffer;\n\n            // read function ; \"data\" must be an instance of Reader\n            static const char* read(lua_State* /*l*/, void* data, size_t* size) {\n                assert(size != nullptr);\n                assert(data != nullptr);\n                Reader& me = *static_cast<Reader*>(data);\n                if (me.stream.eof())    { *size = 0; return nullptr; }\n\n                me.stream.read(me.buffer.data(), me.buffer.size());\n                *size = static_cast<size_t>(me.stream.gcount());    // gcount could return a value larger than a size_t, but its maximum is me.buffer.size() so there's no problem\n                return me.buffer.data();\n            }\n        };\n\n        // we create an instance of Reader, and we call lua_load\n        Reader reader{code};\n        const auto loadReturnValue = lua_load(state, &Reader::read, &reader, \"chunk\"\n#           if LUA_VERSION_NUM >= 502\n                , nullptr\n#           endif\n        );\n\n        // now we have to check return value\n        if (loadReturnValue != 0) {\n            // there was an error during loading, an error message was pushed on the stack\n            const std::string errorMsg = lua_tostring(state, -1);\n            lua_pop(state, 1);\n            if (loadReturnValue == LUA_ERRMEM)\n                throw std::bad_alloc();\n            else if (loadReturnValue == LUA_ERRSYNTAX)\n                throw SyntaxErrorException{errorMsg};\n            throw std::runtime_error(\"Error while calling lua_load: \" + errorMsg);\n        }\n\n        return PushedObject{state, 1};\n    }\n    \n    // this function loads data and pushes a function at the top of the stack\n    // throws in case of syntax error\n    static PushedObject load(lua_State* state, const char* code) {\n        auto loadReturnValue = luaL_loadstring(state, code);\n\n        // now we have to check return value\n        if (loadReturnValue != 0) {\n            // there was an error during loading, an error message was pushed on the stack\n            const std::string errorMsg = lua_tostring(state, -1);\n            lua_pop(state, 1);\n            if (loadReturnValue == LUA_ERRMEM)\n                throw std::bad_alloc();\n            else if (loadReturnValue == LUA_ERRSYNTAX)\n                throw SyntaxErrorException{errorMsg};\n            throw std::runtime_error(\"Error while calling lua_load: \" + errorMsg);\n        }\n\n        return PushedObject{state, 1};\n    }\n\n    // this function calls what is on the top of the stack and removes it (just like lua_call)\n    // if an exception is triggered, the top of the stack will be removed anyway\n    template<typename TReturnType, typename... TParameters>\n    static auto call(lua_State* state, PushedObject toCall, TParameters&&... input)\n        -> TReturnType\n    {\n        typedef typename Tupleizer<TReturnType>::type\n            RealReturnType;\n        \n        // we push the parameters on the stack\n        auto inArguments = Pusher<std::tuple<TParameters&&...>>::push(state, std::forward_as_tuple(std::forward<TParameters>(input)...));\n\n        // \n        const int outArgumentsCount = std::tuple_size<RealReturnType>::value;\n        auto outArguments = callRaw(state, std::move(toCall) + std::move(inArguments), outArgumentsCount);\n\n        // pcall succeeded, we pop the returned values and return them\n        return readTopAndPop<TReturnType>(state, std::move(outArguments));\n    }\n    \n    // this function just calls lua_pcall and checks for errors\n    static PushedObject callRaw(lua_State* state, PushedObject functionAndArguments, const int outArguments)\n    {\n        // calling pcall automatically pops the parameters and pushes output\n        const auto pcallReturnValue = lua_pcall(state, functionAndArguments.getNum() - 1, outArguments, 0);\n        functionAndArguments.release();\n\n        // if pcall failed, analyzing the problem and throwing\n        if (pcallReturnValue != 0) {\n            PushedObject errorCode{state, 1};\n\n            // an error occurred during execution, either an error message or a std::exception_ptr was pushed on the stack\n            if (pcallReturnValue == LUA_ERRMEM) {\n                throw std::bad_alloc{};\n\n            } else if (pcallReturnValue == LUA_ERRRUN) {\n                if (lua_isstring(state, 1)) {\n                    // the error is a string\n                    const auto str = readTopAndPop<std::string>(state, std::move(errorCode));\n                    throw ExecutionErrorException{str};\n\n                } else {\n                    // an exception_ptr was pushed on the stack\n                    // rethrowing it with an additional ExecutionErrorException\n                    try {\n                        if (const auto exp = readTopAndPop<std::exception_ptr>(state, std::move(errorCode))) {\n                            std::rethrow_exception(exp);\n                        }\n                    } catch(const std::exception& e) {\n                        std::throw_with_nested(ExecutionErrorException{std::string{\"Exception thrown by a callback function: \"} + e.what()});\n                    } catch(...) {\n                        std::throw_with_nested(ExecutionErrorException{\"Exception thrown by a callback function called by Lua\"});\n                    }\n                    throw ExecutionErrorException{\"Unknown Lua error\"};\n                }\n            }\n        }\n\n        return PushedObject{state, outArguments};\n    }\n\n    \n    /**************************************************/\n    /*                PUSH FUNCTIONS                  */\n    /**************************************************/\n    template<typename T>\n    static PushedObject push(lua_State* state, T&& value)\n    {\n        return Pusher<typename std::decay<T>::type>::push(state, std::forward<T>(value));\n    }\n\n    // the Pusher structures allow you to push a value on the stack\n    //  - static const int minSize : minimum size on the stack that the value can have\n    //  - static const int maxSize : maximum size on the stack that the value can have\n    //  - static int push(const LuaContext&, ValueType) : pushes the value on the stack and returns the size on the stack\n\n    // implementation for custom objects\n    template<typename TType, typename = void>\n    struct Pusher {\n        static const int minSize = 1;\n        static const int maxSize = 1;\n\n        template<typename TType2>\n        static PushedObject push(lua_State* state, TType2&& value) noexcept {\n            // this function is called when lua's garbage collector wants to destroy our object\n            // we simply call its destructor\n            const auto garbageCallbackFunction = [](lua_State* lua) -> int {\n                assert(lua_gettop(lua) == 1);\n                TType* ptr = static_cast<TType*>(lua_touserdata(lua, 1));\n                assert(ptr);\n                ptr->~TType();\n                return 0;\n            };\n\n            // this function will be stored in __index in the metatable\n            const auto indexFunction = [](lua_State* lua) -> int {\n                try {\n                    assert(lua_gettop(lua) == 2);\n                    assert(lua_isuserdata(lua, 1));\n\n                    // searching for a handler\n                    lua_pushlightuserdata(lua, const_cast<std::type_info*>(&typeid(TType)));\n                    lua_gettable(lua, LUA_REGISTRYINDEX);\n                    assert(!lua_isnil(lua, -1));\n                    \n                    // looking into getter functions\n                    lua_pushinteger(lua, 0);\n                    lua_gettable(lua, -2);\n                    lua_pushvalue(lua, 2);\n                    lua_gettable(lua, -2);\n                    if (!lua_isnil(lua, -1))\n                        return 1;\n                    lua_pop(lua, 2);\n                    \n                    // looking into getter members\n                    lua_pushinteger(lua, 1);\n                    lua_gettable(lua, -2);\n                    lua_pushvalue(lua, 2);\n                    lua_gettable(lua, -2);\n                    if (!lua_isnil(lua, -1)) {\n                        lua_pushvalue(lua, 1);\n                        return callRaw(lua, PushedObject{lua, 2}, 1).release();\n                    }\n                    lua_pop(lua, 2);\n\n                    // looking into default getter\n                    lua_pushinteger(lua, 2);\n                    lua_gettable(lua, -2);\n                    if (lua_isnil(lua, -1))\n                        return 1;\n                    lua_pushvalue(lua, 1);\n                    lua_pushvalue(lua, 2);\n                    return callRaw(lua, PushedObject{lua, 3}, 1).release();\n\n                } catch (...) {\n                    Pusher<std::exception_ptr>::push(lua, std::current_exception()).release();\n                    luaError(lua);\n                }\n            };\n\n            // this function will be stored in __newindex in the metatable\n            const auto newIndexFunction = [](lua_State* lua) -> int {\n                try {\n                    assert(lua_gettop(lua) == 3);\n                    assert(lua_isuserdata(lua, 1));\n\n                    // searching for a handler\n                    lua_pushlightuserdata(lua, const_cast<std::type_info*>(&typeid(TType)));\n                    lua_rawget(lua, LUA_REGISTRYINDEX);\n                    assert(!lua_isnil(lua, -1));\n                    \n                    // looking into setter members\n                    lua_pushinteger(lua, 4);\n                    lua_rawget(lua, -2);\n                    lua_pushvalue(lua, 2);\n                    lua_rawget(lua, -2);\n                    if (!lua_isnil(lua, -1)) {\n                        lua_pushvalue(lua, 1);\n                        lua_pushvalue(lua, 3);\n                        callRaw(lua, PushedObject{lua, 3}, 0);\n                        lua_pop(lua, 2);\n                        return 0;\n                    }\n                    lua_pop(lua, 2);\n\n                    // looking into default setter\n                    lua_pushinteger(lua, 5);\n                    lua_rawget(lua, -2);\n                    if (lua_isnil(lua, -1))\n                    {\n                        lua_pop(lua, 2);\n                        lua_pushstring(lua, \"No setter found\");\n                        luaError(lua);\n                    }\n                    lua_pushvalue(lua, 1);\n                    lua_pushvalue(lua, 2);\n                    lua_pushvalue(lua, 3);\n                    callRaw(lua, PushedObject{lua, 4}, 0);\n                    lua_pop(lua, 1);\n                    return 0;\n\n                } catch (...) {\n                    Pusher<std::exception_ptr>::push(lua, std::current_exception()).release();\n                    luaError(lua);\n                }\n            };\n\n            const auto toStringFunction = [](lua_State* lua) -> int {\n               try {\n                    assert(lua_gettop(lua) == 1);\n                    assert(lua_isuserdata(lua, 1));\n                    lua_pushstring(lua, \"__tostring\");\n                    lua_gettable(lua, 1);\n                    if (lua_isnil(lua, -1))\n                    {\n                        const void *ptr = lua_topointer(lua, -2);\n                        lua_pop(lua, 1);\n                        lua_pushstring(lua, (boost::format(\"userdata 0x%08x\") % reinterpret_cast<intptr_t>(ptr)).str().c_str());\n                        return 1;\n                    }\n                    lua_pushvalue(lua, 1);\n\t\t    return callRaw(lua, PushedObject{lua, 2}, 1).release();\n                } catch (...) {\n                    Pusher<std::exception_ptr>::push(lua, std::current_exception()).release();\n                    luaError(lua);\n                }\n            };\n\n\n            // writing structure for this type into the registry\n            checkTypeRegistration(state, &typeid(TType));\n\n            // creating the object\n            // lua_newuserdata allocates memory in the internals of the lua library and returns it so we can fill it\n            //   and that's what we do with placement-new\n            const auto pointerLocation = static_cast<TType*>(lua_newuserdata(state, sizeof(TType)));\n            new (pointerLocation) TType(std::forward<TType2>(value));\n            PushedObject obj{state, 1};\n\n            // creating the metatable (over the object on the stack)\n            // lua_settable pops the key and value we just pushed, so stack management is easy\n            // all that remains on the stack after these function calls is the metatable\n            lua_newtable(state);\n            PushedObject pushedTable{state, 1};\n\n            // using the garbage collecting function we created above\n            if (!boost::has_trivial_destructor<TType>::value)\n            {\n                lua_pushstring(state, \"__gc\");\n                lua_pushcfunction(state, garbageCallbackFunction);\n                lua_settable(state, -3);\n            }\n\n            // the _typeid index of the metatable will store the type_info*\n            lua_pushstring(state, \"_typeid\");\n            lua_pushlightuserdata(state, const_cast<std::type_info*>(&typeid(TType)));\n            lua_settable(state, -3);\n\n            // using the index function we created above\n            lua_pushstring(state, \"__index\");\n            lua_pushcfunction(state, indexFunction);\n            lua_settable(state, -3);\n\n            // using the newindex function we created above\n            lua_pushstring(state, \"__newindex\");\n            lua_pushcfunction(state, newIndexFunction);\n            lua_settable(state, -3);\n\n            lua_pushstring(state, \"__tostring\");\n            lua_pushcfunction(state, toStringFunction);\n            lua_settable(state, -3);\n\n            lua_pushstring(state, \"__eq\");\n            lua_getglobal(state, LUACONTEXT_GLOBAL_EQ);\n            lua_settable(state, -3);\n\n\n            // at this point, the stack contains the object at offset -2 and the metatable at offset -1\n            // lua_setmetatable will bind the two together and pop the metatable\n            // our custom type remains on the stack (and that's what we want since this is a push function)\n            lua_setmetatable(state, -2);\n            pushedTable.release();\n            \n            return obj;\n        }\n    };\n    \n    // this structure has a \"size\" int static member which is equal to the total of the push min size of all the types\n    template<typename... TTypes>\n    struct PusherTotalMinSize;\n\n    // this structure has a \"size\" int static member which is equal to the total of the push max size of all the types\n    template<typename... TTypes>\n    struct PusherTotalMaxSize;\n    \n    // this structure has a \"size\" int static member which is equal to the maximum size of the push of all the types\n    template<typename... TTypes>\n    struct PusherMinSize;\n    \n    // this structure has a \"size\" int static member which is equal to the maximum size of the push of all the types\n    template<typename... TTypes>\n    struct PusherMaxSize;\n\n    \n    /**************************************************/\n    /*                READ FUNCTIONS                  */\n    /**************************************************/\n    // the \"Reader\" structures allow to read data from the stack\n    // - the \"ReturnType\" type is what is returned by the reader, and can be different than the template parameter (especially with references and constness)\n    // - the \"read\" static function will check and read at the same time, returning an empty optional if it is the wrong type\n    \n    template<typename TType, typename = void>\n    struct Reader {\n        typedef typename std::conditional<std::is_pointer<TType>::value, TType, TType&>::type\n            ReturnType;\n        \n        static auto read(lua_State* state, int index)\n            -> boost::optional<ReturnType>\n        {\n            if (!test(state, index))\n                return boost::none;\n            return boost::optional<ReturnType>(*static_cast<TType*>(lua_touserdata(state, index)));\n        }\n\n    private:\n        static bool test(lua_State* state, int index)\n        {\n            if (!lua_isuserdata(state, index))\n                return false;\n            if (!lua_getmetatable(state, index))\n                return false;\n\n            // now we have our metatable on the top of the stack\n            // retrieving its _typeid member\n            lua_pushstring(state, \"_typeid\");\n            lua_gettable(state, -2);\n            const auto storedTypeID = static_cast<const std::type_info*>(lua_touserdata(state, -1));\n            const auto typeIDToCompare = &typeid(TType);\n\n            // if wrong typeid, returning false\n            lua_pop(state, 2);\n            if (storedTypeID != typeIDToCompare)\n                return false;\n\n            return true;\n        }\n    };\n    \n    /**\n     * This functions reads multiple values starting at \"index\" and passes them to the callback\n     */\n    template<typename TRetValue, typename TCallback>\n    static auto readIntoFunction(lua_State* /*state*/, tag<TRetValue>, TCallback&& callback, int /*index*/)\n        -> TRetValue\n    {\n        return callback();\n    }\n    template<typename TRetValue, typename TCallback, typename TFirstType, typename... TTypes>\n    static auto readIntoFunction(lua_State* state, tag<TRetValue> retValueTag, TCallback&& callback, int index, tag<TFirstType>, tag<TTypes>... othersTags)\n        -> typename std::enable_if<IsOptional<TFirstType>::value, TRetValue>::type\n    {\n        if (index >= 0) {\n            Binder<TCallback, const TFirstType&> binder{ callback, {} };\n            return readIntoFunction(state, retValueTag, binder, index + 1, othersTags...);\n        }\n\n        const auto& firstElem = Reader<typename std::decay<TFirstType>::type>::read(state, index);\n        if (!firstElem)\n            throw WrongTypeException(lua_typename(state, lua_type(state, index)), typeid(TFirstType));\n\n        Binder<TCallback, const TFirstType&> binder{ callback, *firstElem };\n        return readIntoFunction(state, retValueTag, binder, index + 1, othersTags...);\n    }\n    template<typename TRetValue, typename TCallback, typename TFirstType, typename... TTypes>\n    static auto readIntoFunction(lua_State* state, tag<TRetValue> retValueTag, TCallback&& callback, int index, tag<TFirstType>, tag<TTypes>... othersTags)\n        -> typename std::enable_if<!IsOptional<TFirstType>::value, TRetValue>::type\n    {\n        if (index >= 0)\n            throw std::logic_error(\"Wrong number of parameters\");\n\n        const auto& firstElem = Reader<typename std::decay<TFirstType>::type>::read(state, index);\n        if (!firstElem)\n            throw WrongTypeException(lua_typename(state, lua_type(state, index)), typeid(TFirstType));\n\n        Binder<TCallback, const TFirstType&> binder{ callback, *firstElem };\n        return readIntoFunction(state, retValueTag, binder, index + 1, othersTags...);\n    }\n\n\n    /**************************************************/\n    /*                   UTILITIES                    */\n    /**************************************************/\n    // structure that will ensure that a certain value is stored somewhere in the registry\n    struct ValueInRegistry {\n        // this constructor will clone and hold the value at the specified index (or by default at the top of the stack) in the registry\n        ValueInRegistry(lua_State* lua_, int index=-1) : lua{lua_}\n        {\n            lua_pushlightuserdata(lua, this);\n            lua_pushvalue(lua, -1 + index);\n            lua_settable(lua, LUA_REGISTRYINDEX);\n        }\n        \n        // removing the function from the registry\n        ~ValueInRegistry()\n        {\n            lua_pushlightuserdata(lua, this);\n            lua_pushnil(lua);\n            lua_settable(lua, LUA_REGISTRYINDEX);\n        }\n\n        // loads the value and puts it at the top of the stack\n        PushedObject pop()\n        {\n            lua_pushlightuserdata(lua, this);\n            lua_gettable(lua, LUA_REGISTRYINDEX);\n            return PushedObject{lua, 1};\n        }\n\n        ValueInRegistry(const ValueInRegistry&) = delete;\n        ValueInRegistry& operator=(const ValueInRegistry&) = delete;\n\n    private:\n        lua_State* lua;\n    };\n    \n    // binds the first parameter of a function object\n    template<typename TFunctionObject, typename TFirstParamType>\n    struct Binder {\n        TFunctionObject function;\n        TFirstParamType param;\n\n        template<typename... TParams>\n        auto operator()(TParams&&... params)\n            -> decltype(function(param, std::forward<TParams>(params)...))\n        {\n            return function(param, std::forward<TParams>(params)...);\n        }\n    };\n    \n    // turns a type into a tuple\n    // void is turned into std::tuple<>\n    // existing tuples are untouched\n    template<typename T>\n    struct Tupleizer;\n\n    // this structure takes a pointer to a member function type and returns the base function type\n    template<typename TType>\n    struct RemoveMemberPointerFunction { typedef void type; };          // required because of a compiler bug\n\n    // this structure takes any object and detects its function type\n    template<typename TObjectType>\n    struct FunctionTypeDetector { typedef typename RemoveMemberPointerFunction<decltype(&std::decay<TObjectType>::type::operator())>::type type; };\n\n    // this structure takes a function arguments list and has the \"min\" and the \"max\" static const member variables, whose value equal to the min and max number of parameters for the function\n    // the only case where \"min != max\" is with boost::optional at the end of the list\n    template<typename... TArgumentsList>\n    struct FunctionArgumentsCounter {};\n    \n    // true is the template parameter is a boost::optional\n    template<typename T>\n    struct IsOptional : public std::false_type {};\n};\n\n/// @deprecated\nstatic LuaContext::EmptyArray_t ATTR_UNUSED\n    LuaEmptyArray {};\n/// @deprecated\nstatic LuaContext::Metatable_t ATTR_UNUSED\n    LuaMetatable {};\n    \n/**************************************************/\n/*            PARTIAL IMPLEMENTATIONS             */\n/**************************************************/\ntemplate<>\ninline auto LuaContext::readTopAndPop<void>(lua_State* /*state*/, PushedObject /*obj*/)\n    -> void\n{\n}\n\n// this structure takes a template parameter T\n// if T is a tuple, it returns T ; if T is not a tuple, it returns std::tuple<T>\n// we have to use this structure because std::tuple<std::tuple<...>> triggers a bug in both MSVC++ and GCC\ntemplate<typename T>\nstruct LuaContext::Tupleizer                        { typedef std::tuple<T>         type; };\ntemplate<typename... Args>\nstruct LuaContext::Tupleizer<std::tuple<Args...>>   { typedef std::tuple<Args...>   type; };\ntemplate<>\nstruct LuaContext::Tupleizer<void>                  { typedef std::tuple<>          type; };\n\n// this structure takes any object and detects its function type\ntemplate<typename TRetValue, typename... TParameters>\nstruct LuaContext::FunctionTypeDetector<TRetValue (TParameters...)>             { typedef TRetValue type(TParameters...); };\ntemplate<typename TObjectType>\nstruct LuaContext::FunctionTypeDetector<TObjectType*>                           { typedef typename FunctionTypeDetector<TObjectType>::type type; };\n\n// this structure takes a pointer to a member function type and returns the base function type\ntemplate<typename TType, typename TRetValue, typename... TParameters>\nstruct LuaContext::RemoveMemberPointerFunction<TRetValue (TType::*)(TParameters...)>                    { typedef TRetValue type(TParameters...); };\ntemplate<typename TType, typename TRetValue, typename... TParameters>\nstruct LuaContext::RemoveMemberPointerFunction<TRetValue (TType::*)(TParameters...) const>              { typedef TRetValue type(TParameters...); };\ntemplate<typename TType, typename TRetValue, typename... TParameters>\nstruct LuaContext::RemoveMemberPointerFunction<TRetValue (TType::*)(TParameters...) volatile>           { typedef TRetValue type(TParameters...); };\ntemplate<typename TType, typename TRetValue, typename... TParameters>\nstruct LuaContext::RemoveMemberPointerFunction<TRetValue (TType::*)(TParameters...) const volatile>     { typedef TRetValue type(TParameters...); };\n\n// implementation of PusherTotalMinSize\ntemplate<typename TFirst, typename... TTypes>\nstruct LuaContext::PusherTotalMinSize<TFirst, TTypes...> { static const int size = Pusher<typename std::decay<TFirst>::type>::minSize + PusherTotalMinSize<TTypes...>::size; };\ntemplate<>\nstruct LuaContext::PusherTotalMinSize<> { static const int size = 0; };\n\n// implementation of PusherTotalMaxSize\ntemplate<typename TFirst, typename... TTypes>\nstruct LuaContext::PusherTotalMaxSize<TFirst, TTypes...> { static const int size = Pusher<typename std::decay<TFirst>::type>::maxSize + PusherTotalMaxSize<TTypes...>::size; };\ntemplate<>\nstruct LuaContext::PusherTotalMaxSize<> { static const int size = 0; };\n\n// implementation of PusherMinSize\ntemplate<typename TFirst, typename TSecond, typename... TTypes>\nstruct LuaContext::PusherMinSize<TFirst, TSecond, TTypes...> \n{ \n    static const int size = Pusher<typename std::decay<TFirst>::type>::minSize < Pusher<typename std::decay<TSecond>::type>::minSize \n                            ? \n                            PusherMinSize<typename std::decay<TFirst>::type, TTypes...>::size \n                            : \n                            PusherMinSize<typename std::decay<TSecond>::type, TTypes...>::size;\n};\n\ntemplate<typename TFirst>\nstruct LuaContext::PusherMinSize<TFirst> { static const int size = Pusher<typename std::decay<TFirst>::type>::minSize; };\n\n// implementation of PusherMaxSize\ntemplate<typename TFirst, typename... TTypes>\nstruct LuaContext::PusherMaxSize<TFirst, TTypes...> { static const int size = Pusher<typename std::decay<TFirst>::type>::maxSize > PusherTotalMaxSize<TTypes...>::size ? Pusher<typename std::decay<TFirst>::type>::maxSize : PusherMaxSize<TTypes...>::size; };\ntemplate<>\nstruct LuaContext::PusherMaxSize<> { static const int size = 0; };\n\n// implementation of FunctionArgumentsCounter\ntemplate<typename TFirst, typename... TParams>\nstruct LuaContext::FunctionArgumentsCounter<TFirst, TParams...> {\n    typedef FunctionArgumentsCounter<TParams...>\n        SubType;\n    static const int min = (IsOptional<TFirst>::value && SubType::min == 0) ? 0 : 1 + SubType::min;\n    static const int max = 1 + SubType::max;\n};\ntemplate<>\nstruct LuaContext::FunctionArgumentsCounter<> {\n    static const int min = 0;\n    static const int max = 0;\n};\n\n// implementation of IsOptional\ntemplate<typename T>\nstruct LuaContext::IsOptional<boost::optional<T>> : public std::true_type {};\n\n// implementation of LuaFunctionCaller\ntemplate<typename TFunctionType>\nclass LuaContext::LuaFunctionCaller { static_assert(std::is_function<TFunctionType>::value, \"Template parameter of LuaFunctionCaller must be a function type\"); };\ntemplate<typename TRetValue, typename... TParams>\nclass LuaContext::LuaFunctionCaller<TRetValue (TParams...)>\n{\npublic:\n    TRetValue operator()(TParams&&... params) const\n    {\n        auto obj = valueHolder->pop();\n        return call<TRetValue>(state, std::move(obj), std::forward<TParams>(params)...);\n    }\n\nprivate:\n    std::shared_ptr<ValueInRegistry>    valueHolder;\n    lua_State*                          state;\n\nprivate:\n    friend LuaContext;\n    explicit LuaFunctionCaller(lua_State* state_, int index) :\n        valueHolder(std::make_shared<ValueInRegistry>(state_, index)),\n        state(state_)\n    {}\n};\n\n\n/**************************************************/\n/*                PUSH FUNCTIONS                  */\n/**************************************************/\n// specializations of the Pusher structure\n\n// opaque Lua references\ntemplate<>\nstruct LuaContext::Pusher<LuaContext::LuaObject> {\n    static const int minSize = 1;\n    static const int maxSize = 1;\n\n    static PushedObject push(lua_State* state, const LuaContext::LuaObject& value) noexcept {\n        if (value.objectInRegistry.get()) {\n            PushedObject obj = value.objectInRegistry->pop();\n            return obj;\n        } else {\n            lua_pushnil(state);\n            return PushedObject{state, 1};\n        }\n    }\n};\n\n// boolean\ntemplate<>\nstruct LuaContext::Pusher<bool> {\n    static const int minSize = 1;\n    static const int maxSize = 1;\n\n    static PushedObject push(lua_State* state, bool value) noexcept {\n        lua_pushboolean(state, value);\n        return PushedObject{state, 1};\n    }\n};\n\n// string\ntemplate<>\nstruct LuaContext::Pusher<std::string> {\n    static const int minSize = 1;\n    static const int maxSize = 1;\n\n    static PushedObject push(lua_State* state, const std::string& value) noexcept {\n        lua_pushlstring(state, value.c_str(), value.length());\n        return PushedObject{state, 1};\n    }\n};\n\n// const char*\ntemplate<>\nstruct LuaContext::Pusher<const char*> {\n    static const int minSize = 1;\n    static const int maxSize = 1;\n\n    static PushedObject push(lua_State* state, const char* value) noexcept {\n        lua_pushstring(state, value);\n        return PushedObject{state, 1};\n    }\n};\n\n// const char[N]\ntemplate<int N>\nstruct LuaContext::Pusher<const char[N]> {\n    static const int minSize = 1;\n    static const int maxSize = 1;\n\n    static PushedObject push(lua_State* state, const char* value) noexcept {\n        lua_pushstring(state, value);\n        return PushedObject{state, 1};\n    }\n};\n\n// floating numbers\ntemplate<typename T>\nstruct LuaContext::Pusher<T, typename std::enable_if<std::is_floating_point<T>::value>::type> {\n    static const int minSize = 1;\n    static const int maxSize = 1;\n\n    static PushedObject push(lua_State* state, T value) noexcept {\n        lua_pushnumber(state, value);\n        return PushedObject{state, 1};\n    }\n};\n\n// integers\ntemplate<typename T>\nstruct LuaContext::Pusher<T, typename std::enable_if<std::is_integral<T>::value>::type> {\n    static const int minSize = 1;\n    static const int maxSize = 1;\n\n    static PushedObject push(lua_State* state, T value) noexcept {\n        lua_pushinteger(state, value);\n        return PushedObject{state, 1};\n    }\n};\n\n// nil\ntemplate<>\nstruct LuaContext::Pusher<std::nullptr_t> {\n    static const int minSize = 1;\n    static const int maxSize = 1;\n\n    static PushedObject push(lua_State* state, std::nullptr_t) noexcept {\n        lua_pushnil(state);\n        return PushedObject{state, 1};\n    }\n};\n\n// empty arrays\ntemplate<>\nstruct LuaContext::Pusher<LuaContext::EmptyArray_t> {\n    static const int minSize = 1;\n    static const int maxSize = 1;\n\n    static PushedObject push(lua_State* state, EmptyArray_t) noexcept {\n        lua_newtable(state);\n        return PushedObject{state, 1};\n    }\n};\n\n// std::type_info* is a lightuserdata\ntemplate<>\nstruct LuaContext::Pusher<const std::type_info*> {\n    static const int minSize = 1;\n    static const int maxSize = 1;\n\n    static PushedObject push(lua_State* state, const std::type_info* ptr) noexcept {\n        lua_pushlightuserdata(state, const_cast<std::type_info*>(ptr));\n        return PushedObject{state, 1};\n    }\n};\n\n// thread\ntemplate<>\nstruct LuaContext::Pusher<LuaContext::ThreadID> {\n    static const int minSize = 1;\n    static const int maxSize = 1;\n\n    static PushedObject push(lua_State* state, const LuaContext::ThreadID& value) noexcept {\n        lua_pushthread(value.state);\n        return PushedObject{state, 1};\n    }\n};\n\n// maps\ntemplate<typename TKey, typename TValue>\nstruct LuaContext::Pusher<std::map<TKey,TValue>> {\n    static const int minSize = 1;\n    static const int maxSize = 1;\n\n    static PushedObject push(lua_State* state, const std::map<TKey,TValue>& value) noexcept {\n        static_assert(Pusher<typename std::decay<TKey>::type>::minSize == 1 && Pusher<typename std::decay<TKey>::type>::maxSize == 1, \"Can't push multiple elements for a table key\");\n        static_assert(Pusher<typename std::decay<TValue>::type>::minSize == 1 && Pusher<typename std::decay<TValue>::type>::maxSize == 1, \"Can't push multiple elements for a table value\");\n        \n        auto obj = Pusher<EmptyArray_t>::push(state, EmptyArray);\n\n        for (auto i = value.begin(), e = value.end(); i != e; ++i)\n            setTable<TValue>(state, obj, i->first, i->second);\n        \n        return obj;\n    }\n};\n\n// unordered_maps\ntemplate<typename TKey, typename TValue, typename THash, typename TKeyEqual>\nstruct LuaContext::Pusher<std::unordered_map<TKey,TValue,THash,TKeyEqual>> {\n    static const int minSize = 1;\n    static const int maxSize = 1;\n\n    static PushedObject push(lua_State* state, const std::unordered_map<TKey,TValue,THash,TKeyEqual>& value) noexcept {\n        static_assert(Pusher<typename std::decay<TKey>::type>::minSize == 1 && Pusher<typename std::decay<TKey>::type>::maxSize == 1, \"Can't push multiple elements for a table key\");\n        static_assert(Pusher<typename std::decay<TValue>::type>::minSize == 1 && Pusher<typename std::decay<TValue>::type>::maxSize == 1, \"Can't push multiple elements for a table value\");\n        \n        auto obj = Pusher<EmptyArray_t>::push(state, EmptyArray);\n\n        for (auto i = value.begin(), e = value.end(); i != e; ++i)\n            setTable<TValue>(state, obj, i->first, i->second);\n        \n        return obj;\n    }\n};\n\n// vectors of pairs\ntemplate<typename TType1, typename TType2>\nstruct LuaContext::Pusher<std::vector<std::pair<TType1,TType2>>> {\n    static const int minSize = 1;\n    static const int maxSize = 1;\n\n    static PushedObject push(lua_State* state, const std::vector<std::pair<TType1,TType2>>& value) noexcept {\n        static_assert(Pusher<typename std::decay<TType1>::type>::minSize == 1 && Pusher<typename std::decay<TType1>::type>::maxSize == 1, \"Can't push multiple elements for a table key\");\n        static_assert(Pusher<typename std::decay<TType2>::type>::minSize == 1 && Pusher<typename std::decay<TType2>::type>::maxSize == 1, \"Can't push multiple elements for a table value\");\n\n        auto obj = Pusher<EmptyArray_t>::push(state, EmptyArray);\n\n        for (auto i = value.begin(), e = value.end(); i != e; ++i)\n            setTable<TType2>(state, obj, i->first, i->second);\n        \n        return obj;\n    }\n};\n\n// vectors\ntemplate<typename TType>\nstruct LuaContext::Pusher<std::vector<TType>> {\n    static const int minSize = 1;\n    static const int maxSize = 1;\n\n    static PushedObject push(lua_State* state, const std::vector<TType>& value) noexcept {\n        static_assert(Pusher<typename std::decay<TType>::type>::minSize == 1 && Pusher<typename std::decay<TType>::type>::maxSize == 1, \"Can't push multiple elements for a table value\");\n        \n        auto obj = Pusher<EmptyArray_t>::push(state, EmptyArray);\n\n        for (unsigned int i = 0; i < value.size(); ++i)\n            setTable<TType>(state, obj, i + 1, value[i]);\n        \n        return obj;\n    }\n};\n\n// unique_ptr\ntemplate<typename TType>\nstruct LuaContext::Pusher<std::unique_ptr<TType>> {\n    static const int minSize = Pusher<std::shared_ptr<TType>>::minSize;\n    static const int maxSize = Pusher<std::shared_ptr<TType>>::maxSize;\n\n    static PushedObject push(lua_State* state, std::unique_ptr<TType> value) noexcept {\n        return Pusher<std::shared_ptr<TType>>::push(state, std::move(value));\n    }\n};\n\n// enum\ntemplate<typename TEnum>\nstruct LuaContext::Pusher<TEnum, typename std::enable_if<std::is_enum<TEnum>::value>::type> {\n    #if !defined(__clang__) || __clang_major__ > 3 || (__clang_major__ == 3 && __clang_minor__ > 3)\n        typedef typename std::underlying_type<TEnum>::type\n            RealType;\n    #else\n        // implementation when std::underlying_type is not supported\n        typedef unsigned long\n            RealType;\n    #endif\n\n    static const int minSize = Pusher<RealType>::minSize;\n    static const int maxSize = Pusher<RealType>::maxSize;\n\n    static PushedObject push(lua_State* state, TEnum value) noexcept {\n        return Pusher<RealType>::push(state, static_cast<RealType>(value));\n    }\n};\n\n// any function\n// this specialization is not directly called, but is called by other specializations\ntemplate<typename TReturnType, typename... TParameters>\nstruct LuaContext::Pusher<TReturnType (TParameters...)>\n{\n    static const int minSize = 1;\n    static const int maxSize = 1;\n\n    // counts the number of arguments\n    typedef FunctionArgumentsCounter<TParameters...>\n        LocalFunctionArgumentsCounter;\n\n    // this is the version of \"push\" for non-trivially destructible function objects\n    template<typename TFunctionObject>\n    static auto push(lua_State* state, TFunctionObject fn) noexcept\n        -> typename std::enable_if<!boost::has_trivial_destructor<TFunctionObject>::value, PushedObject>::type\n    {\n        // TODO: is_move_constructible not supported by some compilers\n        //static_assert(std::is_move_constructible<TFunctionObject>::value, \"The function object must be move-constructible\");\n\n        // when the lua script calls the thing we will push on the stack, we want \"fn\" to be executed\n        // if we used lua's cfunctions system, we could not detect when the function is no longer in use, which could cause problems\n        // so we use userdata instead\n        \n        // this function is called when the lua script tries to call our custom data type\n        // we transfer execution to the \"callback\" function below\n        const auto callCallback = [](lua_State* lua) -> int {\n            assert(lua_gettop(lua) >= 1);\n            assert(lua_isuserdata(lua, 1));\n            auto function = static_cast<TFunctionObject*>(lua_touserdata(lua, 1));\n            assert(function);\n\n            return callback(lua, function, lua_gettop(lua) - 1).release();\n        };\n\n        // this one is called when lua's garbage collector no longer needs our custom data type\n        // we call the function object's destructor\n        const auto garbageCallback = [](lua_State* lua) -> int {\n            assert(lua_gettop(lua) == 1);\n            auto function = static_cast<TFunctionObject*>(lua_touserdata(lua, 1));\n            assert(function);\n            function->~TFunctionObject();\n            return 0;\n        };\n\n        // creating the object\n        // lua_newuserdata allocates memory in the internals of the lua library and returns it so we can fill it\n        //   and that's what we do with placement-new\n        const auto functionLocation = static_cast<TFunctionObject*>(lua_newuserdata(state, sizeof(TFunctionObject)));\n        new (functionLocation) TFunctionObject(std::move(fn));\n\n        // creating the metatable (over the object on the stack)\n        // lua_settable pops the key and value we just pushed, so stack management is easy\n        // all that remains on the stack after these function calls is the metatable\n        lua_newtable(state);\n        lua_pushstring(state, \"__call\");\n        lua_pushcfunction(state, callCallback);\n        lua_settable(state, -3);\n\n        lua_pushstring(state, \"__gc\");\n        lua_pushcfunction(state, garbageCallback);\n        lua_settable(state, -3);\n\n        // at this point, the stack contains the object at offset -2 and the metatable at offset -1\n        // lua_setmetatable will bind the two together and pop the metatable\n        // our custom function remains on the stack (and that's what we want)\n        lua_setmetatable(state, -2);\n\n        return PushedObject{state, 1};\n    }\n\n    // this is the version of \"push\" for trivially destructible objects\n    template<typename TFunctionObject>\n    static auto push(lua_State* state, TFunctionObject fn) noexcept\n        -> typename std::enable_if<boost::has_trivial_destructor<TFunctionObject>::value, PushedObject>::type\n    {\n        // TODO: is_move_constructible not supported by some compilers\n        //static_assert(std::is_move_constructible<TFunctionObject>::value, \"The function object must be move-constructible\");\n\n        // when the lua script calls the thing we will push on the stack, we want \"fn\" to be executed\n        // since \"fn\" doesn't need to be destroyed, we simply push it on the stack\n\n        // this is the cfunction that is the callback\n        const auto function = [](lua_State* state_) -> int\n        {\n            // the function object is an upvalue\n            const auto toCall = static_cast<TFunctionObject*>(lua_touserdata(state_, lua_upvalueindex(1)));\n            return callback(state_, toCall, lua_gettop(state_)).release();\n        };\n\n        // we copy the function object onto the stack\n        const auto functionObjectLocation = static_cast<TFunctionObject*>(lua_newuserdata(state, sizeof(TFunctionObject)));\n        new (functionObjectLocation) TFunctionObject(std::move(fn));\n\n        // pushing the function with the function object as upvalue\n        lua_pushcclosure(state, function, 1);\n        return PushedObject{state, 1};\n    }\n    \n    // this is the version of \"push\" for pointer to functions\n    static auto push(lua_State* state, TReturnType (*fn)(TParameters...)) noexcept\n        -> PushedObject\n    {\n        // when the lua script calls the thing we will push on the stack, we want \"fn\" to be executed\n        // since \"fn\" doesn't need to be destroyed, we simply push it on the stack\n\n        // this is the cfunction that is the callback\n        const auto function = [](lua_State* state_) -> int\n        {\n            // the function object is an upvalue\n            const auto toCall = reinterpret_cast<TReturnType (*)(TParameters...)>(lua_touserdata(state_, lua_upvalueindex(1)));\n            return callback(state_, toCall, lua_gettop(state_)).release();\n        };\n\n        // we copy the function object onto the stack\n        lua_pushlightuserdata(state, reinterpret_cast<void*>(fn));\n\n        // pushing the function with the function object as upvalue\n        lua_pushcclosure(state, function, 1);\n        return PushedObject{state, 1};\n    }\n    \n    // this is the version of \"push\" for references to functions\n    static auto push(lua_State* state, TReturnType (&fn)(TParameters...)) noexcept\n        -> PushedObject\n    {\n        return push(state, &fn);\n    }\n\nprivate:\n    // callback that calls the function object\n    // this function is used by the callbacks and handles loading arguments from the stack and pushing the return value back\n    template<typename TFunctionObject>\n    static auto callback(lua_State* state, TFunctionObject* toCall, int argumentsCount)\n        -> PushedObject\n    {\n        // checking if number of parameters is correct\n        if (argumentsCount < LocalFunctionArgumentsCounter::min) {\n            // if not, using lua_error to return an error\n            luaL_where(state, 1);\n            lua_pushstring(state, \"This function requires at least \");\n            lua_pushnumber(state, LocalFunctionArgumentsCounter::min);\n            lua_pushstring(state, \" parameter(s)\");\n            lua_concat(state, 4);\n            luaError(state);\n\n        } else if (argumentsCount > LocalFunctionArgumentsCounter::max) {\n            // if not, using lua_error to return an error\n            luaL_where(state, 1);\n            lua_pushstring(state, \"This function requires at most \");\n            lua_pushnumber(state, LocalFunctionArgumentsCounter::max);\n            lua_pushstring(state, \" parameter(s)\");\n            lua_concat(state, 4);\n            luaError(state);\n        }\n                \n        // calling the function\n        try {\n            return callback2(state, *toCall, argumentsCount);\n\n        } catch (const WrongTypeException& ex) {\n            // wrong parameter type, using lua_error to return an error\n            luaL_where(state, 1);\n            lua_pushstring(state, \"Unable to convert parameter from \");\n            lua_pushstring(state, ex.luaType.c_str());\n            lua_pushstring(state, \" to \");\n            lua_pushstring(state, ex.destination.name());\n            lua_concat(state, 5);\n            luaError(state);\n\n        } catch (const std::exception& e) {\n          luaL_where(state, 1);\n          lua_pushstring(state, \"Caught exception: \");\n          lua_pushstring(state, e.what());\n          lua_concat(state, 3);\n          luaError(state);\n        } catch (...) {\n            Pusher<std::exception_ptr>::push(state, std::current_exception()).release();\n            luaError(state);\n        }\n    }\n    \n    template<typename TFunctionObject>\n    static auto callback2(lua_State* state, TFunctionObject&& toCall, int argumentsCount)\n        -> typename std::enable_if<!std::is_void<TReturnType>::value && !std::is_void<TFunctionObject>::value, PushedObject>::type\n    {\n        // pushing the result on the stack and returning number of pushed elements\n        typedef Pusher<typename std::decay<TReturnType>::type>\n            P;\n        return P::push(state, readIntoFunction(state, tag<TReturnType>{}, toCall, -argumentsCount, tag<TParameters>{}...));\n    }\n    \n    template<typename TFunctionObject>\n    static auto callback2(lua_State* state, TFunctionObject&& toCall, int argumentsCount)\n        -> typename std::enable_if<std::is_void<TReturnType>::value && !std::is_void<TFunctionObject>::value, PushedObject>::type\n    {\n        readIntoFunction(state, tag<TReturnType>{}, toCall, -argumentsCount, tag<TParameters>{}...);\n        return PushedObject{state, 0};\n    }\n};\n\n// C function pointers\ntemplate<typename TReturnType, typename... TParameters>\nstruct LuaContext::Pusher<TReturnType (*)(TParameters...)>\n{\n    // using the function-pushing implementation\n    typedef Pusher<TReturnType (TParameters...)>\n        SubPusher;\n    static const int minSize = SubPusher::minSize;\n    static const int maxSize = SubPusher::maxSize;\n\n    template<typename TType>\n    static PushedObject push(lua_State* state, TType value) noexcept {\n        return SubPusher::push(state, value);\n    }\n};\n\n// C function references\ntemplate<typename TReturnType, typename... TParameters>\nstruct LuaContext::Pusher<TReturnType (&)(TParameters...)>\n{\n    // using the function-pushing implementation\n    typedef Pusher<TReturnType(TParameters...)>\n        SubPusher;\n    static const int minSize = SubPusher::minSize;\n    static const int maxSize = SubPusher::maxSize;\n\n    template<typename TType>\n    static PushedObject push(lua_State* state, TType value) noexcept {\n        return SubPusher::push(state, value);\n    }\n};\n\n// std::function\ntemplate<typename TReturnType, typename... TParameters>\nstruct LuaContext::Pusher<std::function<TReturnType (TParameters...)>>\n{\n    // using the function-pushing implementation\n    typedef Pusher<TReturnType (TParameters...)>\n        SubPusher;\n    static const int minSize = SubPusher::minSize;\n    static const int maxSize = SubPusher::maxSize;\n\n    static PushedObject push(lua_State* state, const std::function<TReturnType (TParameters...)>& value) noexcept {\n        return SubPusher::push(state, value);\n    }\n};\n\n// boost::variant\ntemplate<typename... TTypes>\nstruct LuaContext::Pusher<boost::variant<TTypes...>>\n{\n    static const int minSize = PusherMinSize<TTypes...>::size;\n    static const int maxSize = PusherMaxSize<TTypes...>::size;\n\n    static PushedObject push(lua_State* state, const boost::variant<TTypes...>& value) noexcept {\n        PushedObject obj{state, 0};\n        VariantWriter writer{state, obj};\n        value.apply_visitor(writer);\n        return obj;\n    }\n\nprivate:\n    struct VariantWriter : public boost::static_visitor<> {\n        template<typename TType>\n        void operator()(TType value) noexcept\n        {\n            obj = Pusher<typename std::decay<TType>::type>::push(state, std::move(value));\n        }\n\n        VariantWriter(lua_State* state_, PushedObject& obj_) : state(state_), obj(obj_) {}\n        lua_State* state;\n        PushedObject& obj;\n    };\n};\n\n// boost::optional\ntemplate<typename TType>\nstruct LuaContext::Pusher<boost::optional<TType>> {\n    typedef Pusher<typename std::decay<TType>::type>\n        UnderlyingPusher;\n\n    static const int minSize = UnderlyingPusher::minSize < 1 ? UnderlyingPusher::minSize : 1;\n    static const int maxSize = UnderlyingPusher::maxSize > 1 ? UnderlyingPusher::maxSize : 1;\n\n    static PushedObject push(lua_State* state, const boost::optional<TType>& value) noexcept {\n        if (value) {\n            return UnderlyingPusher::push(state, value.get());\n        } else {\n            lua_pushnil(state);\n            return PushedObject{state, 1};\n        }\n    }\n};\n\n// tuple\ntemplate<typename... TTypes>\nstruct LuaContext::Pusher<std::tuple<TTypes...>> {\n    // TODO: NOT EXCEPTION SAFE /!\\ //\n    static const int minSize = PusherTotalMinSize<TTypes...>::size;\n    static const int maxSize = PusherTotalMaxSize<TTypes...>::size;\n\n    static PushedObject push(lua_State* state, const std::tuple<TTypes...>& value) noexcept {\n        return PushedObject{state, push2(state, value, std::integral_constant<int,0>{})};\n    }\n\n    static PushedObject push(lua_State* state, std::tuple<TTypes...>&& value) noexcept {\n        return PushedObject{state, push2(state, std::move(value), std::integral_constant<int,0>{})};\n    }\n\nprivate:\n    template<int N>\n    static int push2(lua_State* state, const std::tuple<TTypes...>& value, std::integral_constant<int,N>) noexcept {\n        typedef typename std::tuple_element<N,std::tuple<TTypes...>>::type ElemType;\n\n        return Pusher<typename std::decay<ElemType>::type>::push(state, std::get<N>(value)).release() +\n            push2(state, value, std::integral_constant<int,N+1>{});\n    }\n\n    template<int N>\n    static int push2(lua_State* state, std::tuple<TTypes...>&& value, std::integral_constant<int,N>) noexcept {\n        typedef typename std::tuple_element<N,std::tuple<TTypes...>>::type ElemType;\n\n        return Pusher<typename std::decay<ElemType>::type>::push(state, std::move(std::get<N>(value))).release() +\n            push2(state, std::move(value), std::integral_constant<int,N+1>{});\n    }\n    \n    static int push2(lua_State* /*state*/, const std::tuple<TTypes...>&, std::integral_constant<int,sizeof...(TTypes)>) noexcept {\n        return 0;\n    }\n    \n    static int push2(lua_State* /*state*/, std::tuple<TTypes...>&&, std::integral_constant<int,sizeof...(TTypes)>) noexcept {\n        return 0;\n    }\n};\n\n/**************************************************/\n/*                READ FUNCTIONS                  */\n/**************************************************/\n// specializations of the Reader structures\n\n// opaque Lua references\ntemplate<>\nstruct LuaContext::Reader<LuaContext::LuaObject>\n{\n    static auto read(lua_State* state, int index)\n        -> boost::optional<LuaContext::LuaObject>\n    {\n        LuaContext::LuaObject obj(state, index);\n        return obj;\n    }\n};\n\n// reading null\ntemplate<>\nstruct LuaContext::Reader<std::nullptr_t>\n{\n    static auto read(lua_State* state, int index)\n        -> boost::optional<std::nullptr_t>\n    {\n        if (!lua_isnil(state, index))\n            return boost::none;\n        return nullptr;\n    }\n};\n\n// integrals\ntemplate<typename TType>\nstruct LuaContext::Reader<\n            TType,\n            typename std::enable_if<std::is_integral<TType>::value>::type\n        >\n{\n    static auto read(lua_State* state, int index)\n        -> boost::optional<TType>\n    {\n#       if LUA_VERSION_NUM >= 502\n\n            int success;\n            auto value = lua_tointegerx(state, index, &success);\n            if (success == 0)\n                return boost::none;\n            return static_cast<TType>(value);\n\n#       else\n\n            if (!lua_isnumber(state, index))\n                return boost::none;\n            return static_cast<TType>(lua_tointeger(state, index));\n\n#       endif\n    }\n};\n\n// floating points\ntemplate<typename TType>\nstruct LuaContext::Reader<\n            TType,\n            typename std::enable_if<std::is_floating_point<TType>::value>::type\n        >\n{\n    static auto read(lua_State* state, int index)\n        -> boost::optional<TType>\n    {\n#       if LUA_VERSION_NUM >= 502\n\n            int success;\n            auto value = lua_tonumberx(state, index, &success);\n            if (success == 0)\n                return boost::none;\n            return static_cast<TType>(value);\n\n#       else\n\n            if (!lua_isnumber(state, index))\n                return boost::none;\n            return static_cast<TType>(lua_tonumber(state, index));\n\n#       endif\n    }\n};\n\n// boolean\ntemplate<>\nstruct LuaContext::Reader<bool>\n{\n    static auto read(lua_State* state, int index)\n        -> boost::optional<bool>\n    {\n        if (!lua_isboolean(state, index))\n            return boost::none;\n        return lua_toboolean(state, index) != 0;\n    }\n};\n\n// string\n// lua_tostring returns a temporary pointer, but that's not a problem since we copy\n//   the data into a std::string\ntemplate<>\nstruct LuaContext::Reader<std::string>\n{\n    static auto read(lua_State* state, int index)\n        -> boost::optional<std::string>\n    {\n        size_t len;\n        const auto val = lua_tolstring(state, index, &len);\n        if (val == 0)\n            return boost::none;\n        return std::string(val, len);\n    }\n};\n\n// enums\ntemplate<typename TType>\nstruct LuaContext::Reader<\n            TType,\n            typename std::enable_if<std::is_enum<TType>::value>::type\n        >\n{\n    static auto read(lua_State* state, int index)\n        -> boost::optional<TType>\n    {\n        if (!lua_isnumber(state, index) || fmod(lua_tonumber(state, index), 1.) != 0)\n            return boost::none;\n        return static_cast<TType>(lua_tointeger(state, index));\n    }\n};\n\n// LuaFunctionCaller\ntemplate<typename TRetValue, typename... TParameters>\nstruct LuaContext::Reader<LuaContext::LuaFunctionCaller<TRetValue (TParameters...)>>\n{\n    typedef LuaFunctionCaller<TRetValue (TParameters...)>\n        ReturnType;\n\n    static auto read(lua_State* state, int index)\n        -> boost::optional<ReturnType>\n    {\n        if (lua_isfunction(state, index) == 0 && lua_isuserdata(state, index) == 0)\n            return boost::none;\n        return ReturnType(state, index);\n    }\n};\n\n// function\ntemplate<typename TRetValue, typename... TParameters>\nstruct LuaContext::Reader<std::function<TRetValue (TParameters...)>>\n{\n    static auto read(lua_State* state, int index)\n        -> boost::optional<std::function<TRetValue (TParameters...)>>\n    {\n\t\tif (auto val = Reader<LuaContext::LuaFunctionCaller<TRetValue (TParameters...)>>::read(state, index))\n\t\t{\n\t\t\tstd::function<TRetValue (TParameters...)> f{*val};\n\t\t\treturn boost::optional<std::function<TRetValue (TParameters...)>>{std::move(f)};\n\t\t}\n\n        return boost::none;\n    }\n};\n\n// vector of pairs\ntemplate<typename TType1, typename TType2>\nstruct LuaContext::Reader<std::vector<std::pair<TType1,TType2>>>\n{\n    static auto read(lua_State* state, int index)\n        -> boost::optional<std::vector<std::pair<TType1, TType2>>>\n    {\n        if (!lua_istable(state, index))\n            return boost::none;\n\n        std::vector<std::pair<TType1, TType2>> result;\n\n        // we traverse the table at the top of the stack\n        lua_pushnil(state);     // first key\n        while (lua_next(state, (index > 0) ? index : (index - 1)) != 0) {\n            // now a key and its value are pushed on the stack\n            try {\n                auto val1 = Reader<TType1>::read(state, -2);\n                auto val2 = Reader<TType2>::read(state, -1);\n\n                if (!val1.is_initialized() || !val2.is_initialized()) {\n                    lua_pop(state, 2);      // we remove the value and the key\n                    return {};\n                }\n\n                result.push_back({ val1.get(), val2.get() });\n                lua_pop(state, 1);      // we remove the value but keep the key for the next iteration\n\n            } catch(...) {\n                lua_pop(state, 2);      // we remove the value and the key\n                return {};\n            }\n        }\n\n        return { std::move(result) };\n    }\n};\n\n// map\ntemplate<typename TKey, typename TValue>\nstruct LuaContext::Reader<std::map<TKey,TValue>>\n{\n    static auto read(lua_State* state, int index)\n        -> boost::optional<std::map<TKey,TValue>>\n    {\n        if (!lua_istable(state, index))\n            return boost::none;\n\n        std::map<TKey,TValue> result;\n\n        // we traverse the table at the top of the stack\n        lua_pushnil(state);     // first key\n        while (lua_next(state, (index > 0) ? index : (index - 1)) != 0) {\n            // now a key and its value are pushed on the stack\n            try {\n                auto key = Reader<TKey>::read(state, -2);\n                auto value = Reader<TValue>::read(state, -1);\n\n                if (!key.is_initialized() || !value.is_initialized()) {\n                    lua_pop(state, 2);      // we remove the value and the key\n                    return {};\n                }\n\n                result.insert({ key.get(), value.get() });\n                lua_pop(state, 1);      // we remove the value but keep the key for the next iteration\n\n            } catch(...) {\n                lua_pop(state, 2);      // we remove the value and the key\n                return {};\n            }\n        }\n\n        return { std::move(result) };\n    }\n};\n\n// unordered_map\ntemplate<typename TKey, typename TValue, typename THash, typename TKeyEqual>\nstruct LuaContext::Reader<std::unordered_map<TKey,TValue,THash,TKeyEqual>>\n{\n    static auto read(lua_State* state, int index)\n        -> boost::optional<std::unordered_map<TKey,TValue,THash,TKeyEqual>>\n    {\n        if (!lua_istable(state, index))\n            return boost::none;\n\n        std::unordered_map<TKey,TValue,THash,TKeyEqual> result;\n\n        // we traverse the table at the top of the stack\n        lua_pushnil(state);     // first key\n        while (lua_next(state, (index > 0) ? index : (index - 1)) != 0) {\n            // now a key and its value are pushed on the stack\n            try {\n                auto key = Reader<TKey>::read(state, -2);\n                auto value = Reader<TValue>::read(state, -1);\n\n                if (!key.is_initialized() || !value.is_initialized()) {\n                    lua_pop(state, 2);      // we remove the value and the key\n                    return {};\n                }\n\n                result.insert({ key.get(), value.get() });\n                lua_pop(state, 1);      // we remove the value but keep the key for the next iteration\n\n            } catch(...) {\n                lua_pop(state, 2);      // we remove the value and the key\n                return {};\n            }\n        }\n\n        return { std::move(result) };\n    }\n};\n\n// optional\n// IMPORTANT: optional means \"either nil or the value of the right type\"\n//  * if the value is nil, then an optional containing an empty optional is returned\n//  * if the value is of the right type, then an optional containing an optional containing the value is returned\n//  * if the value is of the wrong type, then an empty optional is returned\ntemplate<typename TType>\nstruct LuaContext::Reader<boost::optional<TType>>\n{\n    static auto read(lua_State* state, int index)\n        -> boost::optional<boost::optional<TType>>\n    {\n        if (lua_isnil(state, index))\n            return boost::optional<TType>{boost::none};\n        if (auto&& other = Reader<TType>::read(state, index))\n            return std::move(other);\n        return boost::none;\n    }\n};\n\n// variant\ntemplate<typename... TTypes>\nstruct LuaContext::Reader<boost::variant<TTypes...>>\n{\n\ttypedef boost::variant<TTypes...>\n\t\tReturnType;\n\nprivate:\n    // class doing operations for a range of types from TIterBegin to TIterEnd\n    template<typename TIterBegin, typename TIterEnd, typename = void>\n    struct VariantReader\n    {\n        using SubReader = Reader<typename std::decay<typename boost::mpl::deref<TIterBegin>::type>::type>;\n\n        static auto read(lua_State* state, int index)\n            -> boost::optional<ReturnType>\n        {\n            // note: using SubReader::read triggers a compilation error when used with a reference\n            if (const auto val = SubReader::read(state, index))\n                return boost::variant<TTypes...>{*val};\n            return VariantReader<typename boost::mpl::next<TIterBegin>::type, TIterEnd>::read(state, index);\n        }\n    };\n\n    // specialization of class above being called when list of remaining types is empty\n    template<typename TIterBegin, typename TIterEnd>\n    struct VariantReader<TIterBegin, TIterEnd, typename std::enable_if<boost::mpl::distance<TIterBegin, TIterEnd>::type::value == 0>::type>\n    {\n        static auto read(lua_State* /*state*/, int /*index*/)\n            -> boost::optional<ReturnType> \n        {\n            return boost::none;\n        }\n    };\n\n    // this is the main type\n    typedef VariantReader<typename boost::mpl::begin<typename ReturnType::types>::type, typename boost::mpl::end<typename ReturnType::types>::type>\n        MainVariantReader;\n\npublic:\n    static auto read(lua_State* state, int index)\n        -> boost::optional<ReturnType>\n    {\n        return MainVariantReader::read(state, index);\n    }\n};\n\n// reading a tuple\n// tuple have an additional argument for their functions, that is the maximum size to read\n// if maxSize is smaller than the tuple size, then the remaining parameters will be left to default value\ntemplate<>\nstruct LuaContext::Reader<std::tuple<>>\n{\n    static auto read(lua_State* /*state*/, int /*index*/, int /*maxSize*/ = 0)\n        -> boost::optional<std::tuple<>>\n    {\n        return std::tuple<>{};\n    }\n};\n\ntemplate<typename TFirst, typename... TOthers>\nstruct LuaContext::Reader<std::tuple<TFirst, TOthers...>,\n        typename std::enable_if<!LuaContext::IsOptional<TFirst>::value>::type       // TODO: replace by std::is_default_constructible when it works on every compiler\n    >\n{\n    // this is the \"TFirst is NOT default constructible\" version\n\n\ttypedef std::tuple<TFirst, TOthers...>\n\t\tReturnType;\n\n    static auto read(lua_State* state, int index, int maxSize = std::tuple_size<ReturnType>::value)\n        -> boost::optional<ReturnType>\n    {\n        if (maxSize <= 0)\n            return boost::none;\n\n        auto firstVal = Reader<TFirst>::read(state, index);\n        auto othersVal = Reader<std::tuple<TOthers...>>::read(state, index + 1, maxSize - 1);\n        \n        if (!firstVal || !othersVal)\n            return boost::none;\n\n        return std::tuple_cat(std::tuple<TFirst>(*firstVal), std::move(*othersVal));\n    }\n};\n\ntemplate<typename TFirst, typename... TOthers>\nstruct LuaContext::Reader<std::tuple<TFirst, TOthers...>,\n        typename std::enable_if<LuaContext::IsOptional<TFirst>::value>::type        // TODO: replace by std::is_default_constructible when it works on every compiler\n    >\n{\n    // this is the \"TFirst is default-constructible\" version\n\t\n\ttypedef std::tuple<TFirst, TOthers...>\n\t\tReturnType;\n    \n    static auto read(lua_State* state, int index, int maxSize = std::tuple_size<ReturnType>::value)\n        -> boost::optional<ReturnType>\n    {\n        auto othersVal = Reader<std::tuple<TOthers...>>::read(state, index + 1, maxSize - 1);\n        if (!othersVal)\n            return boost::none;\n        \n        if (maxSize <= 0)\n            return std::tuple_cat(std::tuple<TFirst>(), std::move(*othersVal));\n        \n        auto firstVal = Reader<TFirst>::read(state, index);\n        if (!firstVal)\n            return boost::none;\n\n        return std::tuple_cat(std::tuple<TFirst>(*firstVal), std::move(*othersVal));\n    }\n};\n\n#if defined(__GNUC__) && !defined(__clang__)\n#pragma GCC diagnostic pop\n#endif\n\n#endif\n"}, "2": {"id": 2, "path": "/usr/include/luajit-2.1/lua.h", "content": "/*\n** $Id: lua.h,v 1.218.1.5 2008/08/06 13:30:12 roberto Exp $\n** Lua - An Extensible Extension Language\n** Lua.org, PUC-Rio, Brazil (http://www.lua.org)\n** See Copyright Notice at the end of this file\n*/\n\n\n#ifndef lua_h\n#define lua_h\n\n#include <stdarg.h>\n#include <stddef.h>\n\n\n#include \"luaconf.h\"\n\n\n#define LUA_VERSION\t\"Lua 5.1\"\n#define LUA_RELEASE\t\"Lua 5.1.4\"\n#define LUA_VERSION_NUM\t501\n#define LUA_COPYRIGHT\t\"Copyright (C) 1994-2008 Lua.org, PUC-Rio\"\n#define LUA_AUTHORS\t\"R. Ierusalimschy, L. H. de Figueiredo & W. Celes\"\n\n\n/* mark for precompiled code (`<esc>Lua') */\n#define\tLUA_SIGNATURE\t\"\\033Lua\"\n\n/* option for multiple returns in `lua_pcall' and `lua_call' */\n#define LUA_MULTRET\t(-1)\n\n\n/*\n** pseudo-indices\n*/\n#define LUA_REGISTRYINDEX\t(-10000)\n#define LUA_ENVIRONINDEX\t(-10001)\n#define LUA_GLOBALSINDEX\t(-10002)\n#define lua_upvalueindex(i)\t(LUA_GLOBALSINDEX-(i))\n\n\n/* thread status */\n#define LUA_OK\t\t0\n#define LUA_YIELD\t1\n#define LUA_ERRRUN\t2\n#define LUA_ERRSYNTAX\t3\n#define LUA_ERRMEM\t4\n#define LUA_ERRERR\t5\n\n\ntypedef struct lua_State lua_State;\n\ntypedef int (*lua_CFunction) (lua_State *L);\n\n\n/*\n** functions that read/write blocks when loading/dumping Lua chunks\n*/\ntypedef const char * (*lua_Reader) (lua_State *L, void *ud, size_t *sz);\n\ntypedef int (*lua_Writer) (lua_State *L, const void* p, size_t sz, void* ud);\n\n\n/*\n** prototype for memory-allocation functions\n*/\ntypedef void * (*lua_Alloc) (void *ud, void *ptr, size_t osize, size_t nsize);\n\n\n/*\n** basic types\n*/\n#define LUA_TNONE\t\t(-1)\n\n#define LUA_TNIL\t\t0\n#define LUA_TBOOLEAN\t\t1\n#define LUA_TLIGHTUSERDATA\t2\n#define LUA_TNUMBER\t\t3\n#define LUA_TSTRING\t\t4\n#define LUA_TTABLE\t\t5\n#define LUA_TFUNCTION\t\t6\n#define LUA_TUSERDATA\t\t7\n#define LUA_TTHREAD\t\t8\n\n\n\n/* minimum Lua stack available to a C function */\n#define LUA_MINSTACK\t20\n\n\n/*\n** generic extra include file\n*/\n#if defined(LUA_USER_H)\n#include LUA_USER_H\n#endif\n\n\n/* type of numbers in Lua */\ntypedef LUA_NUMBER lua_Number;\n\n\n/* type for integer functions */\ntypedef LUA_INTEGER lua_Integer;\n\n\n\n/*\n** state manipulation\n*/\nLUA_API lua_State *(lua_newstate) (lua_Alloc f, void *ud);\nLUA_API void       (lua_close) (lua_State *L);\nLUA_API lua_State *(lua_newthread) (lua_State *L);\n\nLUA_API lua_CFunction (lua_atpanic) (lua_State *L, lua_CFunction panicf);\n\n\n/*\n** basic stack manipulation\n*/\nLUA_API int   (lua_gettop) (lua_State *L);\nLUA_API void  (lua_settop) (lua_State *L, int idx);\nLUA_API void  (lua_pushvalue) (lua_State *L, int idx);\nLUA_API void  (lua_remove) (lua_State *L, int idx);\nLUA_API void  (lua_insert) (lua_State *L, int idx);\nLUA_API void  (lua_replace) (lua_State *L, int idx);\nLUA_API int   (lua_checkstack) (lua_State *L, int sz);\n\nLUA_API void  (lua_xmove) (lua_State *from, lua_State *to, int n);\n\n\n/*\n** access functions (stack -> C)\n*/\n\nLUA_API int             (lua_isnumber) (lua_State *L, int idx);\nLUA_API int             (lua_isstring) (lua_State *L, int idx);\nLUA_API int             (lua_iscfunction) (lua_State *L, int idx);\nLUA_API int             (lua_isuserdata) (lua_State *L, int idx);\nLUA_API int             (lua_type) (lua_State *L, int idx);\nLUA_API const char     *(lua_typename) (lua_State *L, int tp);\n\nLUA_API int            (lua_equal) (lua_State *L, int idx1, int idx2);\nLUA_API int            (lua_rawequal) (lua_State *L, int idx1, int idx2);\nLUA_API int            (lua_lessthan) (lua_State *L, int idx1, int idx2);\n\nLUA_API lua_Number      (lua_tonumber) (lua_State *L, int idx);\nLUA_API lua_Integer     (lua_tointeger) (lua_State *L, int idx);\nLUA_API int             (lua_toboolean) (lua_State *L, int idx);\nLUA_API const char     *(lua_tolstring) (lua_State *L, int idx, size_t *len);\nLUA_API size_t          (lua_objlen) (lua_State *L, int idx);\nLUA_API lua_CFunction   (lua_tocfunction) (lua_State *L, int idx);\nLUA_API void\t       *(lua_touserdata) (lua_State *L, int idx);\nLUA_API lua_State      *(lua_tothread) (lua_State *L, int idx);\nLUA_API const void     *(lua_topointer) (lua_State *L, int idx);\n\n\n/*\n** push functions (C -> stack)\n*/\nLUA_API void  (lua_pushnil) (lua_State *L);\nLUA_API void  (lua_pushnumber) (lua_State *L, lua_Number n);\nLUA_API void  (lua_pushinteger) (lua_State *L, lua_Integer n);\nLUA_API void  (lua_pushlstring) (lua_State *L, const char *s, size_t l);\nLUA_API void  (lua_pushstring) (lua_State *L, const char *s);\nLUA_API const char *(lua_pushvfstring) (lua_State *L, const char *fmt,\n                                                      va_list argp);\nLUA_API const char *(lua_pushfstring) (lua_State *L, const char *fmt, ...);\nLUA_API void  (lua_pushcclosure) (lua_State *L, lua_CFunction fn, int n);\nLUA_API void  (lua_pushboolean) (lua_State *L, int b);\nLUA_API void  (lua_pushlightuserdata) (lua_State *L, void *p);\nLUA_API int   (lua_pushthread) (lua_State *L);\n\n\n/*\n** get functions (Lua -> stack)\n*/\nLUA_API void  (lua_gettable) (lua_State *L, int idx);\nLUA_API void  (lua_getfield) (lua_State *L, int idx, const char *k);\nLUA_API void  (lua_rawget) (lua_State *L, int idx);\nLUA_API void  (lua_rawgeti) (lua_State *L, int idx, int n);\nLUA_API void  (lua_createtable) (lua_State *L, int narr, int nrec);\nLUA_API void *(lua_newuserdata) (lua_State *L, size_t sz);\nLUA_API int   (lua_getmetatable) (lua_State *L, int objindex);\nLUA_API void  (lua_getfenv) (lua_State *L, int idx);\n\n\n/*\n** set functions (stack -> Lua)\n*/\nLUA_API void  (lua_settable) (lua_State *L, int idx);\nLUA_API void  (lua_setfield) (lua_State *L, int idx, const char *k);\nLUA_API void  (lua_rawset) (lua_State *L, int idx);\nLUA_API void  (lua_rawseti) (lua_State *L, int idx, int n);\nLUA_API int   (lua_setmetatable) (lua_State *L, int objindex);\nLUA_API int   (lua_setfenv) (lua_State *L, int idx);\n\n\n/*\n** `load' and `call' functions (load and run Lua code)\n*/\nLUA_API void  (lua_call) (lua_State *L, int nargs, int nresults);\nLUA_API int   (lua_pcall) (lua_State *L, int nargs, int nresults, int errfunc);\nLUA_API int   (lua_cpcall) (lua_State *L, lua_CFunction func, void *ud);\nLUA_API int   (lua_load) (lua_State *L, lua_Reader reader, void *dt,\n                                        const char *chunkname);\n\nLUA_API int (lua_dump) (lua_State *L, lua_Writer writer, void *data);\n\n\n/*\n** coroutine functions\n*/\nLUA_API int  (lua_yield) (lua_State *L, int nresults);\nLUA_API int  (lua_resume) (lua_State *L, int narg);\nLUA_API int  (lua_status) (lua_State *L);\n\n/*\n** garbage-collection function and options\n*/\n\n#define LUA_GCSTOP\t\t0\n#define LUA_GCRESTART\t\t1\n#define LUA_GCCOLLECT\t\t2\n#define LUA_GCCOUNT\t\t3\n#define LUA_GCCOUNTB\t\t4\n#define LUA_GCSTEP\t\t5\n#define LUA_GCSETPAUSE\t\t6\n#define LUA_GCSETSTEPMUL\t7\n#define LUA_GCISRUNNING\t\t9\n\nLUA_API int (lua_gc) (lua_State *L, int what, int data);\n\n\n/*\n** miscellaneous functions\n*/\n\nLUA_API int   (lua_error) (lua_State *L);\n\nLUA_API int   (lua_next) (lua_State *L, int idx);\n\nLUA_API void  (lua_concat) (lua_State *L, int n);\n\nLUA_API lua_Alloc (lua_getallocf) (lua_State *L, void **ud);\nLUA_API void lua_setallocf (lua_State *L, lua_Alloc f, void *ud);\n\n\n\n/*\n** ===============================================================\n** some useful macros\n** ===============================================================\n*/\n\n#define lua_pop(L,n)\t\tlua_settop(L, -(n)-1)\n\n#define lua_newtable(L)\t\tlua_createtable(L, 0, 0)\n\n#define lua_register(L,n,f) (lua_pushcfunction(L, (f)), lua_setglobal(L, (n)))\n\n#define lua_pushcfunction(L,f)\tlua_pushcclosure(L, (f), 0)\n\n#define lua_strlen(L,i)\t\tlua_objlen(L, (i))\n\n#define lua_isfunction(L,n)\t(lua_type(L, (n)) == LUA_TFUNCTION)\n#define lua_istable(L,n)\t(lua_type(L, (n)) == LUA_TTABLE)\n#define lua_islightuserdata(L,n)\t(lua_type(L, (n)) == LUA_TLIGHTUSERDATA)\n#define lua_isnil(L,n)\t\t(lua_type(L, (n)) == LUA_TNIL)\n#define lua_isboolean(L,n)\t(lua_type(L, (n)) == LUA_TBOOLEAN)\n#define lua_isthread(L,n)\t(lua_type(L, (n)) == LUA_TTHREAD)\n#define lua_isnone(L,n)\t\t(lua_type(L, (n)) == LUA_TNONE)\n#define lua_isnoneornil(L, n)\t(lua_type(L, (n)) <= 0)\n\n#define lua_pushliteral(L, s)\t\\\n\tlua_pushlstring(L, \"\" s, (sizeof(s)/sizeof(char))-1)\n\n#define lua_setglobal(L,s)\tlua_setfield(L, LUA_GLOBALSINDEX, (s))\n#define lua_getglobal(L,s)\tlua_getfield(L, LUA_GLOBALSINDEX, (s))\n\n#define lua_tostring(L,i)\tlua_tolstring(L, (i), NULL)\n\n\n\n/*\n** compatibility macros and functions\n*/\n\n#define lua_open()\tluaL_newstate()\n\n#define lua_getregistry(L)\tlua_pushvalue(L, LUA_REGISTRYINDEX)\n\n#define lua_getgccount(L)\tlua_gc(L, LUA_GCCOUNT, 0)\n\n#define lua_Chunkreader\t\tlua_Reader\n#define lua_Chunkwriter\t\tlua_Writer\n\n\n/* hack */\nLUA_API void lua_setlevel\t(lua_State *from, lua_State *to);\n\n\n/*\n** {======================================================================\n** Debug API\n** =======================================================================\n*/\n\n\n/*\n** Event codes\n*/\n#define LUA_HOOKCALL\t0\n#define LUA_HOOKRET\t1\n#define LUA_HOOKLINE\t2\n#define LUA_HOOKCOUNT\t3\n#define LUA_HOOKTAILRET 4\n\n\n/*\n** Event masks\n*/\n#define LUA_MASKCALL\t(1 << LUA_HOOKCALL)\n#define LUA_MASKRET\t(1 << LUA_HOOKRET)\n#define LUA_MASKLINE\t(1 << LUA_HOOKLINE)\n#define LUA_MASKCOUNT\t(1 << LUA_HOOKCOUNT)\n\ntypedef struct lua_Debug lua_Debug;  /* activation record */\n\n\n/* Functions to be called by the debuger in specific events */\ntypedef void (*lua_Hook) (lua_State *L, lua_Debug *ar);\n\n\nLUA_API int lua_getstack (lua_State *L, int level, lua_Debug *ar);\nLUA_API int lua_getinfo (lua_State *L, const char *what, lua_Debug *ar);\nLUA_API const char *lua_getlocal (lua_State *L, const lua_Debug *ar, int n);\nLUA_API const char *lua_setlocal (lua_State *L, const lua_Debug *ar, int n);\nLUA_API const char *lua_getupvalue (lua_State *L, int funcindex, int n);\nLUA_API const char *lua_setupvalue (lua_State *L, int funcindex, int n);\nLUA_API int lua_sethook (lua_State *L, lua_Hook func, int mask, int count);\nLUA_API lua_Hook lua_gethook (lua_State *L);\nLUA_API int lua_gethookmask (lua_State *L);\nLUA_API int lua_gethookcount (lua_State *L);\n\n/* From Lua 5.2. */\nLUA_API void *lua_upvalueid (lua_State *L, int idx, int n);\nLUA_API void lua_upvaluejoin (lua_State *L, int idx1, int n1, int idx2, int n2);\nLUA_API int lua_loadx (lua_State *L, lua_Reader reader, void *dt,\n\t\t       const char *chunkname, const char *mode);\nLUA_API const lua_Number *lua_version (lua_State *L);\nLUA_API void lua_copy (lua_State *L, int fromidx, int toidx);\nLUA_API lua_Number lua_tonumberx (lua_State *L, int idx, int *isnum);\nLUA_API lua_Integer lua_tointegerx (lua_State *L, int idx, int *isnum);\n\n/* From Lua 5.3. */\nLUA_API int lua_isyieldable (lua_State *L);\n\n\nstruct lua_Debug {\n  int event;\n  const char *name;\t/* (n) */\n  const char *namewhat;\t/* (n) `global', `local', `field', `method' */\n  const char *what;\t/* (S) `Lua', `C', `main', `tail' */\n  const char *source;\t/* (S) */\n  int currentline;\t/* (l) */\n  int nups;\t\t/* (u) number of upvalues */\n  int linedefined;\t/* (S) */\n  int lastlinedefined;\t/* (S) */\n  char short_src[LUA_IDSIZE]; /* (S) */\n  /* private part */\n  int i_ci;  /* active function */\n};\n\n/* }====================================================================== */\n\n\n/******************************************************************************\n* Copyright (C) 1994-2008 Lua.org, PUC-Rio.  All rights reserved.\n*\n* Permission is hereby granted, free of charge, to any person obtaining\n* a copy of this software and associated documentation files (the\n* \"Software\"), to deal in the Software without restriction, including\n* without limitation the rights to use, copy, modify, merge, publish,\n* distribute, sublicense, and/or sell copies of the Software, and to\n* permit persons to whom the Software is furnished to do so, subject to\n* the following conditions:\n*\n* The above copyright notice and this permission notice shall be\n* included in all copies or substantial portions of the Software.\n*\n* THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\n* EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n* MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.\n* IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY\n* CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,\n* TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE\n* SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n******************************************************************************/\n\n\n#endif\n"}, "3": {"id": 3, "path": "/usr/include/c++/7/bits/basic_string.h", "content": "// Components for manipulating sequences of characters -*- C++ -*-\n\n// Copyright (C) 1997-2017 Free Software Foundation, Inc.\n//\n// This file is part of the GNU ISO C++ Library.  This library is free\n// software; you can redistribute it and/or modify it under the\n// terms of the GNU General Public License as published by the\n// Free Software Foundation; either version 3, or (at your option)\n// any later version.\n\n// This library is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n\n// Under Section 7 of GPL version 3, you are granted additional\n// permissions described in the GCC Runtime Library Exception, version\n// 3.1, as published by the Free Software Foundation.\n\n// You should have received a copy of the GNU General Public License and\n// a copy of the GCC Runtime Library Exception along with this program;\n// see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n// <http://www.gnu.org/licenses/>.\n\n/** @file bits/basic_string.h\n *  This is an internal header file, included by other library headers.\n *  Do not attempt to use it directly. @headername{string}\n */\n\n//\n// ISO C++ 14882: 21 Strings library\n//\n\n#ifndef _BASIC_STRING_H\n#define _BASIC_STRING_H 1\n\n#pragma GCC system_header\n\n#include <ext/atomicity.h>\n#include <ext/alloc_traits.h>\n#include <debug/debug.h>\n\n#if __cplusplus >= 201103L\n#include <initializer_list>\n#endif\n\n#if __cplusplus > 201402L\n# include <string_view>\n#endif\n\n\nnamespace std _GLIBCXX_VISIBILITY(default)\n{\n_GLIBCXX_BEGIN_NAMESPACE_VERSION\n\n#if _GLIBCXX_USE_CXX11_ABI\n_GLIBCXX_BEGIN_NAMESPACE_CXX11\n  /**\n   *  @class basic_string basic_string.h <string>\n   *  @brief  Managing sequences of characters and character-like objects.\n   *\n   *  @ingroup strings\n   *  @ingroup sequences\n   *\n   *  @tparam _CharT  Type of character\n   *  @tparam _Traits  Traits for character type, defaults to\n   *                   char_traits<_CharT>.\n   *  @tparam _Alloc  Allocator type, defaults to allocator<_CharT>.\n   *\n   *  Meets the requirements of a <a href=\"tables.html#65\">container</a>, a\n   *  <a href=\"tables.html#66\">reversible container</a>, and a\n   *  <a href=\"tables.html#67\">sequence</a>.  Of the\n   *  <a href=\"tables.html#68\">optional sequence requirements</a>, only\n   *  @c push_back, @c at, and @c %array access are supported.\n   */\n  template<typename _CharT, typename _Traits, typename _Alloc>\n    class basic_string\n    {\n      typedef typename __gnu_cxx::__alloc_traits<_Alloc>::template\n\trebind<_CharT>::other _Char_alloc_type;\n      typedef __gnu_cxx::__alloc_traits<_Char_alloc_type> _Alloc_traits;\n\n      // Types:\n    public:\n      typedef _Traits\t\t\t\t\ttraits_type;\n      typedef typename _Traits::char_type\t\tvalue_type;\n      typedef _Char_alloc_type\t\t\t\tallocator_type;\n      typedef typename _Alloc_traits::size_type\t\tsize_type;\n      typedef typename _Alloc_traits::difference_type\tdifference_type;\n      typedef typename _Alloc_traits::reference\t\treference;\n      typedef typename _Alloc_traits::const_reference\tconst_reference;\n      typedef typename _Alloc_traits::pointer\t\tpointer;\n      typedef typename _Alloc_traits::const_pointer\tconst_pointer;\n      typedef __gnu_cxx::__normal_iterator<pointer, basic_string>  iterator;\n      typedef __gnu_cxx::__normal_iterator<const_pointer, basic_string>\n\t\t\t\t\t\t\tconst_iterator;\n      typedef std::reverse_iterator<const_iterator>\tconst_reverse_iterator;\n      typedef std::reverse_iterator<iterator>\t\treverse_iterator;\n\n      ///  Value returned by various member functions when they fail.\n      static const size_type\tnpos = static_cast<size_type>(-1);\n\n    private:\n      // type used for positions in insert, erase etc.\n#if __cplusplus < 201103L\n      typedef iterator __const_iterator;\n#else\n      typedef const_iterator __const_iterator;\n#endif\n\n#if __cplusplus > 201402L\n      // A helper type for avoiding boiler-plate.\n      typedef basic_string_view<_CharT, _Traits> __sv_type;\n\n      template<typename _Tp, typename _Res>\n\tusing _If_sv = enable_if_t<\n\t  __and_<is_convertible<const _Tp&, __sv_type>,\n\t\t __not_<is_convertible<const _Tp*, const basic_string*>>,\n\t\t __not_<is_convertible<const _Tp&, const _CharT*>>>::value,\n\t  _Res>;\n\n      // Allows an implicit conversion to __sv_type.\n      static __sv_type\n      _S_to_string_view(__sv_type __svt) noexcept\n      { return __svt; }\n\n      // Wraps a string_view by explicit conversion and thus\n      // allows to add an internal constructor that does not\n      // participate in overload resolution when a string_view\n      // is provided.\n      struct __sv_wrapper\n      {\n\texplicit __sv_wrapper(__sv_type __sv) noexcept : _M_sv(__sv) { }\n\t__sv_type _M_sv;\n      };\n#endif\n\n      // Use empty-base optimization: http://www.cantrip.org/emptyopt.html\n      struct _Alloc_hider : allocator_type // TODO check __is_final\n      {\n#if __cplusplus < 201103L\n\t_Alloc_hider(pointer __dat, const _Alloc& __a = _Alloc())\n\t: allocator_type(__a), _M_p(__dat) { }\n#else\n\t_Alloc_hider(pointer __dat, const _Alloc& __a)\n\t: allocator_type(__a), _M_p(__dat) { }\n\n\t_Alloc_hider(pointer __dat, _Alloc&& __a = _Alloc())\n\t: allocator_type(std::move(__a)), _M_p(__dat) { }\n#endif\n\n\tpointer _M_p; // The actual data.\n      };\n\n      _Alloc_hider\t_M_dataplus;\n      size_type\t\t_M_string_length;\n\n      enum { _S_local_capacity = 15 / sizeof(_CharT) };\n\n      union\n      {\n\t_CharT           _M_local_buf[_S_local_capacity + 1];\n\tsize_type        _M_allocated_capacity;\n      };\n\n      void\n      _M_data(pointer __p)\n      { _M_dataplus._M_p = __p; }\n\n      void\n      _M_length(size_type __length)\n      { _M_string_length = __length; }\n\n      pointer\n      _M_data() const\n      { return _M_dataplus._M_p; }\n\n      pointer\n      _M_local_data()\n      {\n#if __cplusplus >= 201103L\n\treturn std::pointer_traits<pointer>::pointer_to(*_M_local_buf);\n#else\n\treturn pointer(_M_local_buf);\n#endif\n      }\n\n      const_pointer\n      _M_local_data() const\n      {\n#if __cplusplus >= 201103L\n\treturn std::pointer_traits<const_pointer>::pointer_to(*_M_local_buf);\n#else\n\treturn const_pointer(_M_local_buf);\n#endif\n      }\n\n      void\n      _M_capacity(size_type __capacity)\n      { _M_allocated_capacity = __capacity; }\n\n      void\n      _M_set_length(size_type __n)\n      {\n\t_M_length(__n);\n\ttraits_type::assign(_M_data()[__n], _CharT());\n      }\n\n      bool\n      _M_is_local() const\n      { return _M_data() == _M_local_data(); }\n\n      // Create & Destroy\n      pointer\n      _M_create(size_type&, size_type);\n\n      void\n      _M_dispose()\n      {\n\tif (!_M_is_local())\n\t  _M_destroy(_M_allocated_capacity);\n      }\n\n      void\n      _M_destroy(size_type __size) throw()\n      { _Alloc_traits::deallocate(_M_get_allocator(), _M_data(), __size + 1); }\n\n      // _M_construct_aux is used to implement the 21.3.1 para 15 which\n      // requires special behaviour if _InIterator is an integral type\n      template<typename _InIterator>\n        void\n        _M_construct_aux(_InIterator __beg, _InIterator __end,\n\t\t\t std::__false_type)\n\t{\n          typedef typename iterator_traits<_InIterator>::iterator_category _Tag;\n          _M_construct(__beg, __end, _Tag());\n\t}\n\n      // _GLIBCXX_RESOLVE_LIB_DEFECTS\n      // 438. Ambiguity in the \"do the right thing\" clause\n      template<typename _Integer>\n        void\n        _M_construct_aux(_Integer __beg, _Integer __end, std::__true_type)\n\t{ _M_construct_aux_2(static_cast<size_type>(__beg), __end); }\n\n      void\n      _M_construct_aux_2(size_type __req, _CharT __c)\n      { _M_construct(__req, __c); }\n\n      template<typename _InIterator>\n        void\n        _M_construct(_InIterator __beg, _InIterator __end)\n\t{\n\t  typedef typename std::__is_integer<_InIterator>::__type _Integral;\n\t  _M_construct_aux(__beg, __end, _Integral());\n        }\n\n      // For Input Iterators, used in istreambuf_iterators, etc.\n      template<typename _InIterator>\n        void\n        _M_construct(_InIterator __beg, _InIterator __end,\n\t\t     std::input_iterator_tag);\n\n      // For forward_iterators up to random_access_iterators, used for\n      // string::iterator, _CharT*, etc.\n      template<typename _FwdIterator>\n        void\n        _M_construct(_FwdIterator __beg, _FwdIterator __end,\n\t\t     std::forward_iterator_tag);\n\n      void\n      _M_construct(size_type __req, _CharT __c);\n\n      allocator_type&\n      _M_get_allocator()\n      { return _M_dataplus; }\n\n      const allocator_type&\n      _M_get_allocator() const\n      { return _M_dataplus; }\n\n    private:\n\n#ifdef _GLIBCXX_DISAMBIGUATE_REPLACE_INST\n      // The explicit instantiations in misc-inst.cc require this due to\n      // https://gcc.gnu.org/bugzilla/show_bug.cgi?id=64063\n      template<typename _Tp, bool _Requires =\n\t       !__are_same<_Tp, _CharT*>::__value\n\t       && !__are_same<_Tp, const _CharT*>::__value\n\t       && !__are_same<_Tp, iterator>::__value\n\t       && !__are_same<_Tp, const_iterator>::__value>\n\tstruct __enable_if_not_native_iterator\n\t{ typedef basic_string& __type; };\n      template<typename _Tp>\n\tstruct __enable_if_not_native_iterator<_Tp, false> { };\n#endif\n\n      size_type\n      _M_check(size_type __pos, const char* __s) const\n      {\n\tif (__pos > this->size())\n\t  __throw_out_of_range_fmt(__N(\"%s: __pos (which is %zu) > \"\n\t\t\t\t       \"this->size() (which is %zu)\"),\n\t\t\t\t   __s, __pos, this->size());\n\treturn __pos;\n      }\n\n      void\n      _M_check_length(size_type __n1, size_type __n2, const char* __s) const\n      {\n\tif (this->max_size() - (this->size() - __n1) < __n2)\n\t  __throw_length_error(__N(__s));\n      }\n\n\n      // NB: _M_limit doesn't check for a bad __pos value.\n      size_type\n      _M_limit(size_type __pos, size_type __off) const _GLIBCXX_NOEXCEPT\n      {\n\tconst bool __testoff =  __off < this->size() - __pos;\n\treturn __testoff ? __off : this->size() - __pos;\n      }\n\n      // True if _Rep and source do not overlap.\n      bool\n      _M_disjunct(const _CharT* __s) const _GLIBCXX_NOEXCEPT\n      {\n\treturn (less<const _CharT*>()(__s, _M_data())\n\t\t|| less<const _CharT*>()(_M_data() + this->size(), __s));\n      }\n\n      // When __n = 1 way faster than the general multichar\n      // traits_type::copy/move/assign.\n      static void\n      _S_copy(_CharT* __d, const _CharT* __s, size_type __n)\n      {\n\tif (__n == 1)\n\t  traits_type::assign(*__d, *__s);\n\telse\n\t  traits_type::copy(__d, __s, __n);\n      }\n\n      static void\n      _S_move(_CharT* __d, const _CharT* __s, size_type __n)\n      {\n\tif (__n == 1)\n\t  traits_type::assign(*__d, *__s);\n\telse\n\t  traits_type::move(__d, __s, __n);\n      }\n\n      static void\n      _S_assign(_CharT* __d, size_type __n, _CharT __c)\n      {\n\tif (__n == 1)\n\t  traits_type::assign(*__d, __c);\n\telse\n\t  traits_type::assign(__d, __n, __c);\n      }\n\n      // _S_copy_chars is a separate template to permit specialization\n      // to optimize for the common case of pointers as iterators.\n      template<class _Iterator>\n        static void\n        _S_copy_chars(_CharT* __p, _Iterator __k1, _Iterator __k2)\n        {\n\t  for (; __k1 != __k2; ++__k1, (void)++__p)\n\t    traits_type::assign(*__p, *__k1); // These types are off.\n\t}\n\n      static void\n      _S_copy_chars(_CharT* __p, iterator __k1, iterator __k2) _GLIBCXX_NOEXCEPT\n      { _S_copy_chars(__p, __k1.base(), __k2.base()); }\n\n      static void\n      _S_copy_chars(_CharT* __p, const_iterator __k1, const_iterator __k2)\n      _GLIBCXX_NOEXCEPT\n      { _S_copy_chars(__p, __k1.base(), __k2.base()); }\n\n      static void\n      _S_copy_chars(_CharT* __p, _CharT* __k1, _CharT* __k2) _GLIBCXX_NOEXCEPT\n      { _S_copy(__p, __k1, __k2 - __k1); }\n\n      static void\n      _S_copy_chars(_CharT* __p, const _CharT* __k1, const _CharT* __k2)\n      _GLIBCXX_NOEXCEPT\n      { _S_copy(__p, __k1, __k2 - __k1); }\n\n      static int\n      _S_compare(size_type __n1, size_type __n2) _GLIBCXX_NOEXCEPT\n      {\n\tconst difference_type __d = difference_type(__n1 - __n2);\n\n\tif (__d > __gnu_cxx::__numeric_traits<int>::__max)\n\t  return __gnu_cxx::__numeric_traits<int>::__max;\n\telse if (__d < __gnu_cxx::__numeric_traits<int>::__min)\n\t  return __gnu_cxx::__numeric_traits<int>::__min;\n\telse\n\t  return int(__d);\n      }\n\n      void\n      _M_assign(const basic_string&);\n\n      void\n      _M_mutate(size_type __pos, size_type __len1, const _CharT* __s,\n\t\tsize_type __len2);\n\n      void\n      _M_erase(size_type __pos, size_type __n);\n\n    public:\n      // Construct/copy/destroy:\n      // NB: We overload ctors in some cases instead of using default\n      // arguments, per 17.4.4.4 para. 2 item 2.\n\n      /**\n       *  @brief  Default constructor creates an empty string.\n       */\n      basic_string()\n      _GLIBCXX_NOEXCEPT_IF(is_nothrow_default_constructible<_Alloc>::value)\n      : _M_dataplus(_M_local_data())\n      { _M_set_length(0); }\n\n      /**\n       *  @brief  Construct an empty string using allocator @a a.\n       */\n      explicit\n      basic_string(const _Alloc& __a) _GLIBCXX_NOEXCEPT\n      : _M_dataplus(_M_local_data(), __a)\n      { _M_set_length(0); }\n\n      /**\n       *  @brief  Construct string with copy of value of @a __str.\n       *  @param  __str  Source string.\n       */\n      basic_string(const basic_string& __str)\n      : _M_dataplus(_M_local_data(),\n\t\t    _Alloc_traits::_S_select_on_copy(__str._M_get_allocator()))\n      { _M_construct(__str._M_data(), __str._M_data() + __str.length()); }\n\n      // _GLIBCXX_RESOLVE_LIB_DEFECTS\n      // 2583. no way to supply an allocator for basic_string(str, pos)\n      /**\n       *  @brief  Construct string as copy of a substring.\n       *  @param  __str  Source string.\n       *  @param  __pos  Index of first character to copy from.\n       *  @param  __a  Allocator to use.\n       */\n      basic_string(const basic_string& __str, size_type __pos,\n\t\t   const _Alloc& __a = _Alloc())\n      : _M_dataplus(_M_local_data(), __a)\n      {\n\tconst _CharT* __start = __str._M_data()\n\t  + __str._M_check(__pos, \"basic_string::basic_string\");\n\t_M_construct(__start, __start + __str._M_limit(__pos, npos));\n      }\n\n      /**\n       *  @brief  Construct string as copy of a substring.\n       *  @param  __str  Source string.\n       *  @param  __pos  Index of first character to copy from.\n       *  @param  __n  Number of characters to copy.\n       */\n      basic_string(const basic_string& __str, size_type __pos,\n\t\t   size_type __n)\n      : _M_dataplus(_M_local_data())\n      {\n\tconst _CharT* __start = __str._M_data()\n\t  + __str._M_check(__pos, \"basic_string::basic_string\");\n\t_M_construct(__start, __start + __str._M_limit(__pos, __n));\n      }\n\n      /**\n       *  @brief  Construct string as copy of a substring.\n       *  @param  __str  Source string.\n       *  @param  __pos  Index of first character to copy from.\n       *  @param  __n  Number of characters to copy.\n       *  @param  __a  Allocator to use.\n       */\n      basic_string(const basic_string& __str, size_type __pos,\n\t\t   size_type __n, const _Alloc& __a)\n      : _M_dataplus(_M_local_data(), __a)\n      {\n\tconst _CharT* __start\n\t  = __str._M_data() + __str._M_check(__pos, \"string::string\");\n\t_M_construct(__start, __start + __str._M_limit(__pos, __n));\n      }\n\n      /**\n       *  @brief  Construct string initialized by a character %array.\n       *  @param  __s  Source character %array.\n       *  @param  __n  Number of characters to copy.\n       *  @param  __a  Allocator to use (default is default allocator).\n       *\n       *  NB: @a __s must have at least @a __n characters, &apos;\\\\0&apos;\n       *  has no special meaning.\n       */\n      basic_string(const _CharT* __s, size_type __n,\n\t\t   const _Alloc& __a = _Alloc())\n      : _M_dataplus(_M_local_data(), __a)\n      { _M_construct(__s, __s + __n); }\n\n      /**\n       *  @brief  Construct string as copy of a C string.\n       *  @param  __s  Source C string.\n       *  @param  __a  Allocator to use (default is default allocator).\n       */\n      basic_string(const _CharT* __s, const _Alloc& __a = _Alloc())\n      : _M_dataplus(_M_local_data(), __a)\n      { _M_construct(__s, __s ? __s + traits_type::length(__s) : __s+npos); }\n\n      /**\n       *  @brief  Construct string as multiple characters.\n       *  @param  __n  Number of characters.\n       *  @param  __c  Character to use.\n       *  @param  __a  Allocator to use (default is default allocator).\n       */\n      basic_string(size_type __n, _CharT __c, const _Alloc& __a = _Alloc())\n      : _M_dataplus(_M_local_data(), __a)\n      { _M_construct(__n, __c); }\n\n#if __cplusplus >= 201103L\n      /**\n       *  @brief  Move construct string.\n       *  @param  __str  Source string.\n       *\n       *  The newly-created string contains the exact contents of @a __str.\n       *  @a __str is a valid, but unspecified string.\n       **/\n      basic_string(basic_string&& __str) noexcept\n      : _M_dataplus(_M_local_data(), std::move(__str._M_get_allocator()))\n      {\n\tif (__str._M_is_local())\n\t  {\n\t    traits_type::copy(_M_local_buf, __str._M_local_buf,\n\t\t\t      _S_local_capacity + 1);\n\t  }\n\telse\n\t  {\n\t    _M_data(__str._M_data());\n\t    _M_capacity(__str._M_allocated_capacity);\n\t  }\n\n\t// Must use _M_length() here not _M_set_length() because\n\t// basic_stringbuf relies on writing into unallocated capacity so\n\t// we mess up the contents if we put a '\\0' in the string.\n\t_M_length(__str.length());\n\t__str._M_data(__str._M_local_data());\n\t__str._M_set_length(0);\n      }\n\n      /**\n       *  @brief  Construct string from an initializer %list.\n       *  @param  __l  std::initializer_list of characters.\n       *  @param  __a  Allocator to use (default is default allocator).\n       */\n      basic_string(initializer_list<_CharT> __l, const _Alloc& __a = _Alloc())\n      : _M_dataplus(_M_local_data(), __a)\n      { _M_construct(__l.begin(), __l.end()); }\n\n      basic_string(const basic_string& __str, const _Alloc& __a)\n      : _M_dataplus(_M_local_data(), __a)\n      { _M_construct(__str.begin(), __str.end()); }\n\n      basic_string(basic_string&& __str, const _Alloc& __a)\n      noexcept(_Alloc_traits::_S_always_equal())\n      : _M_dataplus(_M_local_data(), __a)\n      {\n\tif (__str._M_is_local())\n\t  {\n\t    traits_type::copy(_M_local_buf, __str._M_local_buf,\n\t\t\t      _S_local_capacity + 1);\n\t    _M_length(__str.length());\n\t    __str._M_set_length(0);\n\t  }\n\telse if (_Alloc_traits::_S_always_equal()\n\t    || __str.get_allocator() == __a)\n\t  {\n\t    _M_data(__str._M_data());\n\t    _M_length(__str.length());\n\t    _M_capacity(__str._M_allocated_capacity);\n\t    __str._M_data(__str._M_local_buf);\n\t    __str._M_set_length(0);\n\t  }\n\telse\n\t  _M_construct(__str.begin(), __str.end());\n      }\n\n#endif // C++11\n\n      /**\n       *  @brief  Construct string as copy of a range.\n       *  @param  __beg  Start of range.\n       *  @param  __end  End of range.\n       *  @param  __a  Allocator to use (default is default allocator).\n       */\n#if __cplusplus >= 201103L\n      template<typename _InputIterator,\n\t       typename = std::_RequireInputIter<_InputIterator>>\n#else\n      template<typename _InputIterator>\n#endif\n        basic_string(_InputIterator __beg, _InputIterator __end,\n\t\t     const _Alloc& __a = _Alloc())\n\t: _M_dataplus(_M_local_data(), __a)\n\t{ _M_construct(__beg, __end); }\n\n#if __cplusplus > 201402L\n      /**\n       *  @brief  Construct string from a substring of a string_view.\n       *  @param  __t   Source object convertible to string view.\n       *  @param  __pos The index of the first character to copy from __t.\n       *  @param  __n   The number of characters to copy from __t.\n       *  @param  __a   Allocator to use.\n       */\n      template<typename _Tp, typename = _If_sv<_Tp, void>>\n\tbasic_string(const _Tp& __t, size_type __pos, size_type __n,\n\t\t     const _Alloc& __a = _Alloc())\n\t: basic_string(_S_to_string_view(__t).substr(__pos, __n), __a) { }\n\n      /**\n       *  @brief  Construct string from a string_view.\n       *  @param  __t  Source object convertible to string view.\n       *  @param  __a  Allocator to use (default is default allocator).\n       */\n      template<typename _Tp, typename = _If_sv<_Tp, void>>\n\texplicit\n\tbasic_string(const _Tp& __t, const _Alloc& __a = _Alloc())\n\t: basic_string(__sv_wrapper(_S_to_string_view(__t)), __a) { }\n\n      /**\n       *  @brief  Only internally used: Construct string from a string view\n       *          wrapper.\n       *  @param  __svw  string view wrapper.\n       *  @param  __a  Allocator to use.\n       */\n      explicit\n      basic_string(__sv_wrapper __svw, const _Alloc& __a)\n      : basic_string(__svw._M_sv.data(), __svw._M_sv.size(), __a) { }\n#endif // C++17\n\n      /**\n       *  @brief  Destroy the string instance.\n       */\n      ~basic_string()\n      { _M_dispose(); }\n\n      /**\n       *  @brief  Assign the value of @a str to this string.\n       *  @param  __str  Source string.\n       */\n      basic_string&\n      operator=(const basic_string& __str)\n      {\n#if __cplusplus >= 201103L\n\tif (_Alloc_traits::_S_propagate_on_copy_assign())\n\t  {\n\t    if (!_Alloc_traits::_S_always_equal() && !_M_is_local()\n\t\t&& _M_get_allocator() != __str._M_get_allocator())\n\t      {\n\t\t// Propagating allocator cannot free existing storage so must\n\t\t// deallocate it before replacing current allocator.\n\t\tif (__str.size() <= _S_local_capacity)\n\t\t  {\n\t\t    _M_destroy(_M_allocated_capacity);\n\t\t    _M_data(_M_local_data());\n\t\t    _M_set_length(0);\n\t\t  }\n\t\telse\n\t\t  {\n\t\t    const auto __len = __str.size();\n\t\t    auto __alloc = __str._M_get_allocator();\n\t\t    // If this allocation throws there are no effects:\n\t\t    auto __ptr = _Alloc_traits::allocate(__alloc, __len + 1);\n\t\t    _M_destroy(_M_allocated_capacity);\n\t\t    _M_data(__ptr);\n\t\t    _M_capacity(__len);\n\t\t    _M_set_length(__len);\n\t\t  }\n\t      }\n\t    std::__alloc_on_copy(_M_get_allocator(), __str._M_get_allocator());\n\t  }\n#endif\n\treturn this->assign(__str);\n      }\n\n      /**\n       *  @brief  Copy contents of @a s into this string.\n       *  @param  __s  Source null-terminated string.\n       */\n      basic_string&\n      operator=(const _CharT* __s)\n      { return this->assign(__s); }\n\n      /**\n       *  @brief  Set value to string of length 1.\n       *  @param  __c  Source character.\n       *\n       *  Assigning to a character makes this string length 1 and\n       *  (*this)[0] == @a c.\n       */\n      basic_string&\n      operator=(_CharT __c)\n      {\n\tthis->assign(1, __c);\n\treturn *this;\n      }\n\n#if __cplusplus >= 201103L\n      /**\n       *  @brief  Move assign the value of @a str to this string.\n       *  @param  __str  Source string.\n       *\n       *  The contents of @a str are moved into this string (without copying).\n       *  @a str is a valid, but unspecified string.\n       **/\n      // PR 58265, this should be noexcept.\n      // _GLIBCXX_RESOLVE_LIB_DEFECTS\n      // 2063. Contradictory requirements for string move assignment\n      basic_string&\n      operator=(basic_string&& __str)\n      noexcept(_Alloc_traits::_S_nothrow_move())\n      {\n\tif (!_M_is_local() && _Alloc_traits::_S_propagate_on_move_assign()\n\t    && !_Alloc_traits::_S_always_equal()\n\t    && _M_get_allocator() != __str._M_get_allocator())\n\t  {\n\t    // Destroy existing storage before replacing allocator.\n\t    _M_destroy(_M_allocated_capacity);\n\t    _M_data(_M_local_data());\n\t    _M_set_length(0);\n\t  }\n\t// Replace allocator if POCMA is true.\n\tstd::__alloc_on_move(_M_get_allocator(), __str._M_get_allocator());\n\n\tif (__str._M_is_local())\n\t  {\n\t    // We've always got room for a short string, just copy it.\n\t    if (__str.size())\n\t      this->_S_copy(_M_data(), __str._M_data(), __str.size());\n\t    _M_set_length(__str.size());\n\t  }\n\telse if (_Alloc_traits::_S_propagate_on_move_assign()\n\t    || _Alloc_traits::_S_always_equal()\n\t    || _M_get_allocator() == __str._M_get_allocator())\n\t  {\n\t    // Just move the allocated pointer, our allocator can free it.\n\t    pointer __data = nullptr;\n\t    size_type __capacity;\n\t    if (!_M_is_local())\n\t      {\n\t\tif (_Alloc_traits::_S_always_equal())\n\t\t  {\n\t\t    // __str can reuse our existing storage.\n\t\t    __data = _M_data();\n\t\t    __capacity = _M_allocated_capacity;\n\t\t  }\n\t\telse // __str can't use it, so free it.\n\t\t  _M_destroy(_M_allocated_capacity);\n\t      }\n\n\t    _M_data(__str._M_data());\n\t    _M_length(__str.length());\n\t    _M_capacity(__str._M_allocated_capacity);\n\t    if (__data)\n\t      {\n\t\t__str._M_data(__data);\n\t\t__str._M_capacity(__capacity);\n\t      }\n\t    else\n\t      __str._M_data(__str._M_local_buf);\n\t  }\n\telse // Need to do a deep copy\n\t  assign(__str);\n\t__str.clear();\n\treturn *this;\n      }\n\n      /**\n       *  @brief  Set value to string constructed from initializer %list.\n       *  @param  __l  std::initializer_list.\n       */\n      basic_string&\n      operator=(initializer_list<_CharT> __l)\n      {\n\tthis->assign(__l.begin(), __l.size());\n\treturn *this;\n      }\n#endif // C++11\n\n#if __cplusplus > 201402L\n      /**\n       *  @brief  Set value to string constructed from a string_view.\n       *  @param  __svt  An object convertible to string_view.\n       */\n     template<typename _Tp>\n       _If_sv<_Tp, basic_string&>\n       operator=(const _Tp& __svt)\n       { return this->assign(__svt); }\n\n      /**\n       *  @brief  Convert to a string_view.\n       *  @return A string_view.\n       */\n      operator __sv_type() const noexcept\n      { return __sv_type(data(), size()); }\n#endif // C++17\n\n      // Iterators:\n      /**\n       *  Returns a read/write iterator that points to the first character in\n       *  the %string.\n       */\n      iterator\n      begin() _GLIBCXX_NOEXCEPT\n      { return iterator(_M_data()); }\n\n      /**\n       *  Returns a read-only (constant) iterator that points to the first\n       *  character in the %string.\n       */\n      const_iterator\n      begin() const _GLIBCXX_NOEXCEPT\n      { return const_iterator(_M_data()); }\n\n      /**\n       *  Returns a read/write iterator that points one past the last\n       *  character in the %string.\n       */\n      iterator\n      end() _GLIBCXX_NOEXCEPT\n      { return iterator(_M_data() + this->size()); }\n\n      /**\n       *  Returns a read-only (constant) iterator that points one past the\n       *  last character in the %string.\n       */\n      const_iterator\n      end() const _GLIBCXX_NOEXCEPT\n      { return const_iterator(_M_data() + this->size()); }\n\n      /**\n       *  Returns a read/write reverse iterator that points to the last\n       *  character in the %string.  Iteration is done in reverse element\n       *  order.\n       */\n      reverse_iterator\n      rbegin() _GLIBCXX_NOEXCEPT\n      { return reverse_iterator(this->end()); }\n\n      /**\n       *  Returns a read-only (constant) reverse iterator that points\n       *  to the last character in the %string.  Iteration is done in\n       *  reverse element order.\n       */\n      const_reverse_iterator\n      rbegin() const _GLIBCXX_NOEXCEPT\n      { return const_reverse_iterator(this->end()); }\n\n      /**\n       *  Returns a read/write reverse iterator that points to one before the\n       *  first character in the %string.  Iteration is done in reverse\n       *  element order.\n       */\n      reverse_iterator\n      rend() _GLIBCXX_NOEXCEPT\n      { return reverse_iterator(this->begin()); }\n\n      /**\n       *  Returns a read-only (constant) reverse iterator that points\n       *  to one before the first character in the %string.  Iteration\n       *  is done in reverse element order.\n       */\n      const_reverse_iterator\n      rend() const _GLIBCXX_NOEXCEPT\n      { return const_reverse_iterator(this->begin()); }\n\n#if __cplusplus >= 201103L\n      /**\n       *  Returns a read-only (constant) iterator that points to the first\n       *  character in the %string.\n       */\n      const_iterator\n      cbegin() const noexcept\n      { return const_iterator(this->_M_data()); }\n\n      /**\n       *  Returns a read-only (constant) iterator that points one past the\n       *  last character in the %string.\n       */\n      const_iterator\n      cend() const noexcept\n      { return const_iterator(this->_M_data() + this->size()); }\n\n      /**\n       *  Returns a read-only (constant) reverse iterator that points\n       *  to the last character in the %string.  Iteration is done in\n       *  reverse element order.\n       */\n      const_reverse_iterator\n      crbegin() const noexcept\n      { return const_reverse_iterator(this->end()); }\n\n      /**\n       *  Returns a read-only (constant) reverse iterator that points\n       *  to one before the first character in the %string.  Iteration\n       *  is done in reverse element order.\n       */\n      const_reverse_iterator\n      crend() const noexcept\n      { return const_reverse_iterator(this->begin()); }\n#endif\n\n    public:\n      // Capacity:\n      ///  Returns the number of characters in the string, not including any\n      ///  null-termination.\n      size_type\n      size() const _GLIBCXX_NOEXCEPT\n      { return _M_string_length; }\n\n      ///  Returns the number of characters in the string, not including any\n      ///  null-termination.\n      size_type\n      length() const _GLIBCXX_NOEXCEPT\n      { return _M_string_length; }\n\n      ///  Returns the size() of the largest possible %string.\n      size_type\n      max_size() const _GLIBCXX_NOEXCEPT\n      { return (_Alloc_traits::max_size(_M_get_allocator()) - 1) / 2; }\n\n      /**\n       *  @brief  Resizes the %string to the specified number of characters.\n       *  @param  __n  Number of characters the %string should contain.\n       *  @param  __c  Character to fill any new elements.\n       *\n       *  This function will %resize the %string to the specified\n       *  number of characters.  If the number is smaller than the\n       *  %string's current size the %string is truncated, otherwise\n       *  the %string is extended and new elements are %set to @a __c.\n       */\n      void\n      resize(size_type __n, _CharT __c);\n\n      /**\n       *  @brief  Resizes the %string to the specified number of characters.\n       *  @param  __n  Number of characters the %string should contain.\n       *\n       *  This function will resize the %string to the specified length.  If\n       *  the new size is smaller than the %string's current size the %string\n       *  is truncated, otherwise the %string is extended and new characters\n       *  are default-constructed.  For basic types such as char, this means\n       *  setting them to 0.\n       */\n      void\n      resize(size_type __n)\n      { this->resize(__n, _CharT()); }\n\n#if __cplusplus >= 201103L\n      ///  A non-binding request to reduce capacity() to size().\n      void\n      shrink_to_fit() noexcept\n      {\n#if __cpp_exceptions\n\tif (capacity() > size())\n\t  {\n\t    try\n\t      { reserve(0); }\n\t    catch(...)\n\t      { }\n\t  }\n#endif\n      }\n#endif\n\n      /**\n       *  Returns the total number of characters that the %string can hold\n       *  before needing to allocate more memory.\n       */\n      size_type\n      capacity() const _GLIBCXX_NOEXCEPT\n      {\n\treturn _M_is_local() ? size_type(_S_local_capacity)\n\t                     : _M_allocated_capacity;\n      }\n\n      /**\n       *  @brief  Attempt to preallocate enough memory for specified number of\n       *          characters.\n       *  @param  __res_arg  Number of characters required.\n       *  @throw  std::length_error  If @a __res_arg exceeds @c max_size().\n       *\n       *  This function attempts to reserve enough memory for the\n       *  %string to hold the specified number of characters.  If the\n       *  number requested is more than max_size(), length_error is\n       *  thrown.\n       *\n       *  The advantage of this function is that if optimal code is a\n       *  necessity and the user can determine the string length that will be\n       *  required, the user can reserve the memory in %advance, and thus\n       *  prevent a possible reallocation of memory and copying of %string\n       *  data.\n       */\n      void\n      reserve(size_type __res_arg = 0);\n\n      /**\n       *  Erases the string, making it empty.\n       */\n      void\n      clear() _GLIBCXX_NOEXCEPT\n      { _M_set_length(0); }\n\n      /**\n       *  Returns true if the %string is empty.  Equivalent to \n       *  <code>*this == \"\"</code>.\n       */\n      bool\n      empty() const _GLIBCXX_NOEXCEPT\n      { return this->size() == 0; }\n\n      // Element access:\n      /**\n       *  @brief  Subscript access to the data contained in the %string.\n       *  @param  __pos  The index of the character to access.\n       *  @return  Read-only (constant) reference to the character.\n       *\n       *  This operator allows for easy, array-style, data access.\n       *  Note that data access with this operator is unchecked and\n       *  out_of_range lookups are not defined. (For checked lookups\n       *  see at().)\n       */\n      const_reference\n      operator[] (size_type __pos) const _GLIBCXX_NOEXCEPT\n      {\n\t__glibcxx_assert(__pos <= size());\n\treturn _M_data()[__pos];\n      }\n\n      /**\n       *  @brief  Subscript access to the data contained in the %string.\n       *  @param  __pos  The index of the character to access.\n       *  @return  Read/write reference to the character.\n       *\n       *  This operator allows for easy, array-style, data access.\n       *  Note that data access with this operator is unchecked and\n       *  out_of_range lookups are not defined. (For checked lookups\n       *  see at().)\n       */\n      reference\n      operator[](size_type __pos)\n      {\n        // Allow pos == size() both in C++98 mode, as v3 extension,\n\t// and in C++11 mode.\n\t__glibcxx_assert(__pos <= size());\n        // In pedantic mode be strict in C++98 mode.\n\t_GLIBCXX_DEBUG_PEDASSERT(__cplusplus >= 201103L || __pos < size());\n\treturn _M_data()[__pos];\n      }\n\n      /**\n       *  @brief  Provides access to the data contained in the %string.\n       *  @param __n The index of the character to access.\n       *  @return  Read-only (const) reference to the character.\n       *  @throw  std::out_of_range  If @a n is an invalid index.\n       *\n       *  This function provides for safer data access.  The parameter is\n       *  first checked that it is in the range of the string.  The function\n       *  throws out_of_range if the check fails.\n       */\n      const_reference\n      at(size_type __n) const\n      {\n\tif (__n >= this->size())\n\t  __throw_out_of_range_fmt(__N(\"basic_string::at: __n \"\n\t\t\t\t       \"(which is %zu) >= this->size() \"\n\t\t\t\t       \"(which is %zu)\"),\n\t\t\t\t   __n, this->size());\n\treturn _M_data()[__n];\n      }\n\n      /**\n       *  @brief  Provides access to the data contained in the %string.\n       *  @param __n The index of the character to access.\n       *  @return  Read/write reference to the character.\n       *  @throw  std::out_of_range  If @a n is an invalid index.\n       *\n       *  This function provides for safer data access.  The parameter is\n       *  first checked that it is in the range of the string.  The function\n       *  throws out_of_range if the check fails.\n       */\n      reference\n      at(size_type __n)\n      {\n\tif (__n >= size())\n\t  __throw_out_of_range_fmt(__N(\"basic_string::at: __n \"\n\t\t\t\t       \"(which is %zu) >= this->size() \"\n\t\t\t\t       \"(which is %zu)\"),\n\t\t\t\t   __n, this->size());\n\treturn _M_data()[__n];\n      }\n\n#if __cplusplus >= 201103L\n      /**\n       *  Returns a read/write reference to the data at the first\n       *  element of the %string.\n       */\n      reference\n      front() noexcept\n      {\n\t__glibcxx_assert(!empty());\n\treturn operator[](0);\n      }\n\n      /**\n       *  Returns a read-only (constant) reference to the data at the first\n       *  element of the %string.\n       */\n      const_reference\n      front() const noexcept\n      {\n\t__glibcxx_assert(!empty());\n\treturn operator[](0);\n      }\n\n      /**\n       *  Returns a read/write reference to the data at the last\n       *  element of the %string.\n       */\n      reference\n      back() noexcept\n      {\n\t__glibcxx_assert(!empty());\n\treturn operator[](this->size() - 1);\n      }\n\n      /**\n       *  Returns a read-only (constant) reference to the data at the\n       *  last element of the %string.\n       */\n      const_reference\n      back() const noexcept\n      {\n\t__glibcxx_assert(!empty());\n\treturn operator[](this->size() - 1);\n      }\n#endif\n\n      // Modifiers:\n      /**\n       *  @brief  Append a string to this string.\n       *  @param __str  The string to append.\n       *  @return  Reference to this string.\n       */\n      basic_string&\n      operator+=(const basic_string& __str)\n      { return this->append(__str); }\n\n      /**\n       *  @brief  Append a C string.\n       *  @param __s  The C string to append.\n       *  @return  Reference to this string.\n       */\n      basic_string&\n      operator+=(const _CharT* __s)\n      { return this->append(__s); }\n\n      /**\n       *  @brief  Append a character.\n       *  @param __c  The character to append.\n       *  @return  Reference to this string.\n       */\n      basic_string&\n      operator+=(_CharT __c)\n      {\n\tthis->push_back(__c);\n\treturn *this;\n      }\n\n#if __cplusplus >= 201103L\n      /**\n       *  @brief  Append an initializer_list of characters.\n       *  @param __l  The initializer_list of characters to be appended.\n       *  @return  Reference to this string.\n       */\n      basic_string&\n      operator+=(initializer_list<_CharT> __l)\n      { return this->append(__l.begin(), __l.size()); }\n#endif // C++11\n\n#if __cplusplus > 201402L\n      /**\n       *  @brief  Append a string_view.\n       *  @param __svt  An object convertible to string_view to be appended.\n       *  @return  Reference to this string.\n       */\n      template<typename _Tp>\n\t_If_sv<_Tp, basic_string&>\n\toperator+=(const _Tp& __svt)\n\t{ return this->append(__svt); }\n#endif // C++17\n\n      /**\n       *  @brief  Append a string to this string.\n       *  @param __str  The string to append.\n       *  @return  Reference to this string.\n       */\n      basic_string&\n      append(const basic_string& __str)\n      { return _M_append(__str._M_data(), __str.size()); }\n\n      /**\n       *  @brief  Append a substring.\n       *  @param __str  The string to append.\n       *  @param __pos  Index of the first character of str to append.\n       *  @param __n  The number of characters to append.\n       *  @return  Reference to this string.\n       *  @throw  std::out_of_range if @a __pos is not a valid index.\n       *\n       *  This function appends @a __n characters from @a __str\n       *  starting at @a __pos to this string.  If @a __n is is larger\n       *  than the number of available characters in @a __str, the\n       *  remainder of @a __str is appended.\n       */\n      basic_string&\n      append(const basic_string& __str, size_type __pos, size_type __n = npos)\n      { return _M_append(__str._M_data()\n\t\t\t + __str._M_check(__pos, \"basic_string::append\"),\n\t\t\t __str._M_limit(__pos, __n)); }\n\n      /**\n       *  @brief  Append a C substring.\n       *  @param __s  The C string to append.\n       *  @param __n  The number of characters to append.\n       *  @return  Reference to this string.\n       */\n      basic_string&\n      append(const _CharT* __s, size_type __n)\n      {\n\t__glibcxx_requires_string_len(__s, __n);\n\t_M_check_length(size_type(0), __n, \"basic_string::append\");\n\treturn _M_append(__s, __n);\n      }\n\n      /**\n       *  @brief  Append a C string.\n       *  @param __s  The C string to append.\n       *  @return  Reference to this string.\n       */\n      basic_string&\n      append(const _CharT* __s)\n      {\n\t__glibcxx_requires_string(__s);\n\tconst size_type __n = traits_type::length(__s);\n\t_M_check_length(size_type(0), __n, \"basic_string::append\");\n\treturn _M_append(__s, __n);\n      }\n\n      /**\n       *  @brief  Append multiple characters.\n       *  @param __n  The number of characters to append.\n       *  @param __c  The character to use.\n       *  @return  Reference to this string.\n       *\n       *  Appends __n copies of __c to this string.\n       */\n      basic_string&\n      append(size_type __n, _CharT __c)\n      { return _M_replace_aux(this->size(), size_type(0), __n, __c); }\n\n#if __cplusplus >= 201103L\n      /**\n       *  @brief  Append an initializer_list of characters.\n       *  @param __l  The initializer_list of characters to append.\n       *  @return  Reference to this string.\n       */\n      basic_string&\n      append(initializer_list<_CharT> __l)\n      { return this->append(__l.begin(), __l.size()); }\n#endif // C++11\n\n      /**\n       *  @brief  Append a range of characters.\n       *  @param __first  Iterator referencing the first character to append.\n       *  @param __last  Iterator marking the end of the range.\n       *  @return  Reference to this string.\n       *\n       *  Appends characters in the range [__first,__last) to this string.\n       */\n#if __cplusplus >= 201103L\n      template<class _InputIterator,\n\t       typename = std::_RequireInputIter<_InputIterator>>\n#else\n      template<class _InputIterator>\n#endif\n        basic_string&\n        append(_InputIterator __first, _InputIterator __last)\n        { return this->replace(end(), end(), __first, __last); }\n\n#if __cplusplus > 201402L\n      /**\n       *  @brief  Append a string_view.\n       *  @param __svt  An object convertible to string_view to be appended.\n       *  @return  Reference to this string.\n       */\n      template<typename _Tp>\n        _If_sv<_Tp, basic_string&>\n        append(const _Tp& __svt)\n        {\n          __sv_type __sv = __svt;\n          return this->append(__sv.data(), __sv.size());\n        }\n\n      /**\n       *  @brief  Append a range of characters from a string_view.\n       *  @param __svt  An object convertible to string_view to be appended from.\n       *  @param __pos The position in the string_view to append from.\n       *  @param __n   The number of characters to append from the string_view.\n       *  @return  Reference to this string.\n       */\n      template<typename _Tp>\n        _If_sv<_Tp, basic_string&>\n\tappend(const _Tp& __svt, size_type __pos, size_type __n = npos)\n\t{\n\t  __sv_type __sv = __svt;\n\t  return _M_append(__sv.data()\n\t\t\t   + __sv._M_check(__pos, \"basic_string::append\"),\n\t\t\t   __sv._M_limit(__pos, __n));\n\t}\n#endif // C++17\n\n      /**\n       *  @brief  Append a single character.\n       *  @param __c  Character to append.\n       */\n      void\n      push_back(_CharT __c)\n      {\n\tconst size_type __size = this->size();\n\tif (__size + 1 > this->capacity())\n\t  this->_M_mutate(__size, size_type(0), 0, size_type(1));\n\ttraits_type::assign(this->_M_data()[__size], __c);\n\tthis->_M_set_length(__size + 1);\n      }\n\n      /**\n       *  @brief  Set value to contents of another string.\n       *  @param  __str  Source string to use.\n       *  @return  Reference to this string.\n       */\n      basic_string&\n      assign(const basic_string& __str)\n      {\n\tthis->_M_assign(__str);\n\treturn *this;\n      }\n\n#if __cplusplus >= 201103L\n      /**\n       *  @brief  Set value to contents of another string.\n       *  @param  __str  Source string to use.\n       *  @return  Reference to this string.\n       *\n       *  This function sets this string to the exact contents of @a __str.\n       *  @a __str is a valid, but unspecified string.\n       */\n      basic_string&\n      assign(basic_string&& __str)\n      noexcept(_Alloc_traits::_S_nothrow_move())\n      {\n\t// _GLIBCXX_RESOLVE_LIB_DEFECTS\n\t// 2063. Contradictory requirements for string move assignment\n\treturn *this = std::move(__str);\n      }\n#endif // C++11\n\n      /**\n       *  @brief  Set value to a substring of a string.\n       *  @param __str  The string to use.\n       *  @param __pos  Index of the first character of str.\n       *  @param __n  Number of characters to use.\n       *  @return  Reference to this string.\n       *  @throw  std::out_of_range if @a pos is not a valid index.\n       *\n       *  This function sets this string to the substring of @a __str\n       *  consisting of @a __n characters at @a __pos.  If @a __n is\n       *  is larger than the number of available characters in @a\n       *  __str, the remainder of @a __str is used.\n       */\n      basic_string&\n      assign(const basic_string& __str, size_type __pos, size_type __n = npos)\n      { return _M_replace(size_type(0), this->size(), __str._M_data()\n\t\t\t  + __str._M_check(__pos, \"basic_string::assign\"),\n\t\t\t  __str._M_limit(__pos, __n)); }\n\n      /**\n       *  @brief  Set value to a C substring.\n       *  @param __s  The C string to use.\n       *  @param __n  Number of characters to use.\n       *  @return  Reference to this string.\n       *\n       *  This function sets the value of this string to the first @a __n\n       *  characters of @a __s.  If @a __n is is larger than the number of\n       *  available characters in @a __s, the remainder of @a __s is used.\n       */\n      basic_string&\n      assign(const _CharT* __s, size_type __n)\n      {\n\t__glibcxx_requires_string_len(__s, __n);\n\treturn _M_replace(size_type(0), this->size(), __s, __n);\n      }\n\n      /**\n       *  @brief  Set value to contents of a C string.\n       *  @param __s  The C string to use.\n       *  @return  Reference to this string.\n       *\n       *  This function sets the value of this string to the value of @a __s.\n       *  The data is copied, so there is no dependence on @a __s once the\n       *  function returns.\n       */\n      basic_string&\n      assign(const _CharT* __s)\n      {\n\t__glibcxx_requires_string(__s);\n\treturn _M_replace(size_type(0), this->size(), __s,\n\t\t\t  traits_type::length(__s));\n      }\n\n      /**\n       *  @brief  Set value to multiple characters.\n       *  @param __n  Length of the resulting string.\n       *  @param __c  The character to use.\n       *  @return  Reference to this string.\n       *\n       *  This function sets the value of this string to @a __n copies of\n       *  character @a __c.\n       */\n      basic_string&\n      assign(size_type __n, _CharT __c)\n      { return _M_replace_aux(size_type(0), this->size(), __n, __c); }\n\n      /**\n       *  @brief  Set value to a range of characters.\n       *  @param __first  Iterator referencing the first character to append.\n       *  @param __last  Iterator marking the end of the range.\n       *  @return  Reference to this string.\n       *\n       *  Sets value of string to characters in the range [__first,__last).\n      */\n#if __cplusplus >= 201103L\n      template<class _InputIterator,\n\t       typename = std::_RequireInputIter<_InputIterator>>\n#else\n      template<class _InputIterator>\n#endif\n        basic_string&\n        assign(_InputIterator __first, _InputIterator __last)\n        { return this->replace(begin(), end(), __first, __last); }\n\n#if __cplusplus >= 201103L\n      /**\n       *  @brief  Set value to an initializer_list of characters.\n       *  @param __l  The initializer_list of characters to assign.\n       *  @return  Reference to this string.\n       */\n      basic_string&\n      assign(initializer_list<_CharT> __l)\n      { return this->assign(__l.begin(), __l.size()); }\n#endif // C++11\n\n#if __cplusplus > 201402L\n      /**\n       *  @brief  Set value from a string_view.\n       *  @param __svt  The source object convertible to string_view.\n       *  @return  Reference to this string.\n       */\n      template<typename _Tp>\n\t_If_sv<_Tp, basic_string&>\n\tassign(const _Tp& __svt)\n\t{\n\t  __sv_type __sv = __svt;\n\t  return this->assign(__sv.data(), __sv.size());\n\t}\n\n      /**\n       *  @brief  Set value from a range of characters in a string_view.\n       *  @param __svt  The source object convertible to string_view.\n       *  @param __pos  The position in the string_view to assign from.\n       *  @param __n  The number of characters to assign.\n       *  @return  Reference to this string.\n       */\n      template<typename _Tp>\n\t_If_sv<_Tp, basic_string&>\n\tassign(const _Tp& __svt, size_type __pos, size_type __n = npos)\n\t{\n\t  __sv_type __sv = __svt;\n\t  return _M_replace(size_type(0), this->size(), __sv.data()\n\t\t\t    + __sv._M_check(__pos, \"basic_string::assign\"),\n\t\t\t    __sv._M_limit(__pos, __n));\n\t}\n#endif // C++17\n\n#if __cplusplus >= 201103L\n      /**\n       *  @brief  Insert multiple characters.\n       *  @param __p  Const_iterator referencing location in string to\n       *              insert at.\n       *  @param __n  Number of characters to insert\n       *  @param __c  The character to insert.\n       *  @return  Iterator referencing the first inserted char.\n       *  @throw  std::length_error  If new length exceeds @c max_size().\n       *\n       *  Inserts @a __n copies of character @a __c starting at the\n       *  position referenced by iterator @a __p.  If adding\n       *  characters causes the length to exceed max_size(),\n       *  length_error is thrown.  The value of the string doesn't\n       *  change if an error is thrown.\n      */\n      iterator\n      insert(const_iterator __p, size_type __n, _CharT __c)\n      {\n\t_GLIBCXX_DEBUG_PEDASSERT(__p >= begin() && __p <= end());\n\tconst size_type __pos = __p - begin();\n\tthis->replace(__p, __p, __n, __c);\n\treturn iterator(this->_M_data() + __pos);\n      }\n#else\n      /**\n       *  @brief  Insert multiple characters.\n       *  @param __p  Iterator referencing location in string to insert at.\n       *  @param __n  Number of characters to insert\n       *  @param __c  The character to insert.\n       *  @throw  std::length_error  If new length exceeds @c max_size().\n       *\n       *  Inserts @a __n copies of character @a __c starting at the\n       *  position referenced by iterator @a __p.  If adding\n       *  characters causes the length to exceed max_size(),\n       *  length_error is thrown.  The value of the string doesn't\n       *  change if an error is thrown.\n      */\n      void\n      insert(iterator __p, size_type __n, _CharT __c)\n      {\tthis->replace(__p, __p, __n, __c);  }\n#endif\n\n#if __cplusplus >= 201103L\n      /**\n       *  @brief  Insert a range of characters.\n       *  @param __p  Const_iterator referencing location in string to\n       *              insert at.\n       *  @param __beg  Start of range.\n       *  @param __end  End of range.\n       *  @return  Iterator referencing the first inserted char.\n       *  @throw  std::length_error  If new length exceeds @c max_size().\n       *\n       *  Inserts characters in range [beg,end).  If adding characters\n       *  causes the length to exceed max_size(), length_error is\n       *  thrown.  The value of the string doesn't change if an error\n       *  is thrown.\n      */\n      template<class _InputIterator,\n\t       typename = std::_RequireInputIter<_InputIterator>>\n\titerator\n        insert(const_iterator __p, _InputIterator __beg, _InputIterator __end)\n        {\n\t  _GLIBCXX_DEBUG_PEDASSERT(__p >= begin() && __p <= end());\n\t  const size_type __pos = __p - begin();\n\t  this->replace(__p, __p, __beg, __end);\n\t  return iterator(this->_M_data() + __pos);\n\t}\n#else\n      /**\n       *  @brief  Insert a range of characters.\n       *  @param __p  Iterator referencing location in string to insert at.\n       *  @param __beg  Start of range.\n       *  @param __end  End of range.\n       *  @throw  std::length_error  If new length exceeds @c max_size().\n       *\n       *  Inserts characters in range [__beg,__end).  If adding\n       *  characters causes the length to exceed max_size(),\n       *  length_error is thrown.  The value of the string doesn't\n       *  change if an error is thrown.\n      */\n      template<class _InputIterator>\n        void\n        insert(iterator __p, _InputIterator __beg, _InputIterator __end)\n        { this->replace(__p, __p, __beg, __end); }\n#endif\n\n#if __cplusplus >= 201103L\n      /**\n       *  @brief  Insert an initializer_list of characters.\n       *  @param __p  Iterator referencing location in string to insert at.\n       *  @param __l  The initializer_list of characters to insert.\n       *  @throw  std::length_error  If new length exceeds @c max_size().\n       */\n      void\n      insert(iterator __p, initializer_list<_CharT> __l)\n      {\n\t_GLIBCXX_DEBUG_PEDASSERT(__p >= begin() && __p <= end());\n\tthis->insert(__p - begin(), __l.begin(), __l.size());\n      }\n#endif // C++11\n\n      /**\n       *  @brief  Insert value of a string.\n       *  @param __pos1  Iterator referencing location in string to insert at.\n       *  @param __str  The string to insert.\n       *  @return  Reference to this string.\n       *  @throw  std::length_error  If new length exceeds @c max_size().\n       *\n       *  Inserts value of @a __str starting at @a __pos1.  If adding\n       *  characters causes the length to exceed max_size(),\n       *  length_error is thrown.  The value of the string doesn't\n       *  change if an error is thrown.\n      */\n      basic_string&\n      insert(size_type __pos1, const basic_string& __str)\n      { return this->replace(__pos1, size_type(0),\n\t\t\t     __str._M_data(), __str.size()); }\n\n      /**\n       *  @brief  Insert a substring.\n       *  @param __pos1  Iterator referencing location in string to insert at.\n       *  @param __str  The string to insert.\n       *  @param __pos2  Start of characters in str to insert.\n       *  @param __n  Number of characters to insert.\n       *  @return  Reference to this string.\n       *  @throw  std::length_error  If new length exceeds @c max_size().\n       *  @throw  std::out_of_range  If @a pos1 > size() or\n       *  @a __pos2 > @a str.size().\n       *\n       *  Starting at @a pos1, insert @a __n character of @a __str\n       *  beginning with @a __pos2.  If adding characters causes the\n       *  length to exceed max_size(), length_error is thrown.  If @a\n       *  __pos1 is beyond the end of this string or @a __pos2 is\n       *  beyond the end of @a __str, out_of_range is thrown.  The\n       *  value of the string doesn't change if an error is thrown.\n      */\n      basic_string&\n      insert(size_type __pos1, const basic_string& __str,\n\t     size_type __pos2, size_type __n = npos)\n      { return this->replace(__pos1, size_type(0), __str._M_data()\n\t\t\t     + __str._M_check(__pos2, \"basic_string::insert\"),\n\t\t\t     __str._M_limit(__pos2, __n)); }\n\n      /**\n       *  @brief  Insert a C substring.\n       *  @param __pos  Iterator referencing location in string to insert at.\n       *  @param __s  The C string to insert.\n       *  @param __n  The number of characters to insert.\n       *  @return  Reference to this string.\n       *  @throw  std::length_error  If new length exceeds @c max_size().\n       *  @throw  std::out_of_range  If @a __pos is beyond the end of this\n       *  string.\n       *\n       *  Inserts the first @a __n characters of @a __s starting at @a\n       *  __pos.  If adding characters causes the length to exceed\n       *  max_size(), length_error is thrown.  If @a __pos is beyond\n       *  end(), out_of_range is thrown.  The value of the string\n       *  doesn't change if an error is thrown.\n      */\n      basic_string&\n      insert(size_type __pos, const _CharT* __s, size_type __n)\n      { return this->replace(__pos, size_type(0), __s, __n); }\n\n      /**\n       *  @brief  Insert a C string.\n       *  @param __pos  Iterator referencing location in string to insert at.\n       *  @param __s  The C string to insert.\n       *  @return  Reference to this string.\n       *  @throw  std::length_error  If new length exceeds @c max_size().\n       *  @throw  std::out_of_range  If @a pos is beyond the end of this\n       *  string.\n       *\n       *  Inserts the first @a n characters of @a __s starting at @a __pos.  If\n       *  adding characters causes the length to exceed max_size(),\n       *  length_error is thrown.  If @a __pos is beyond end(), out_of_range is\n       *  thrown.  The value of the string doesn't change if an error is\n       *  thrown.\n      */\n      basic_string&\n      insert(size_type __pos, const _CharT* __s)\n      {\n\t__glibcxx_requires_string(__s);\n\treturn this->replace(__pos, size_type(0), __s,\n\t\t\t     traits_type::length(__s));\n      }\n\n      /**\n       *  @brief  Insert multiple characters.\n       *  @param __pos  Index in string to insert at.\n       *  @param __n  Number of characters to insert\n       *  @param __c  The character to insert.\n       *  @return  Reference to this string.\n       *  @throw  std::length_error  If new length exceeds @c max_size().\n       *  @throw  std::out_of_range  If @a __pos is beyond the end of this\n       *  string.\n       *\n       *  Inserts @a __n copies of character @a __c starting at index\n       *  @a __pos.  If adding characters causes the length to exceed\n       *  max_size(), length_error is thrown.  If @a __pos > length(),\n       *  out_of_range is thrown.  The value of the string doesn't\n       *  change if an error is thrown.\n      */\n      basic_string&\n      insert(size_type __pos, size_type __n, _CharT __c)\n      { return _M_replace_aux(_M_check(__pos, \"basic_string::insert\"),\n\t\t\t      size_type(0), __n, __c); }\n\n      /**\n       *  @brief  Insert one character.\n       *  @param __p  Iterator referencing position in string to insert at.\n       *  @param __c  The character to insert.\n       *  @return  Iterator referencing newly inserted char.\n       *  @throw  std::length_error  If new length exceeds @c max_size().\n       *\n       *  Inserts character @a __c at position referenced by @a __p.\n       *  If adding character causes the length to exceed max_size(),\n       *  length_error is thrown.  If @a __p is beyond end of string,\n       *  out_of_range is thrown.  The value of the string doesn't\n       *  change if an error is thrown.\n      */\n      iterator\n      insert(__const_iterator __p, _CharT __c)\n      {\n\t_GLIBCXX_DEBUG_PEDASSERT(__p >= begin() && __p <= end());\n\tconst size_type __pos = __p - begin();\n\t_M_replace_aux(__pos, size_type(0), size_type(1), __c);\n\treturn iterator(_M_data() + __pos);\n      }\n\n#if __cplusplus > 201402L\n      /**\n       *  @brief  Insert a string_view.\n       *  @param __pos  Iterator referencing position in string to insert at.\n       *  @param __svt  The object convertible to string_view to insert.\n       *  @return  Reference to this string.\n      */\n      template<typename _Tp>\n\t_If_sv<_Tp, basic_string&>\n\tinsert(size_type __pos, const _Tp& __svt)\n\t{\n\t  __sv_type __sv = __svt;\n\t  return this->insert(__pos, __sv.data(), __sv.size());\n\t}\n\n      /**\n       *  @brief  Insert a string_view.\n       *  @param __pos  Iterator referencing position in string to insert at.\n       *  @param __svt  The object convertible to string_view to insert from.\n       *  @param __pos  Iterator referencing position in string_view to insert\n       *  from.\n       *  @param __n    The number of characters to insert.\n       *  @return  Reference to this string.\n      */\n      template<typename _Tp>\n\t_If_sv<_Tp, basic_string&>\n\tinsert(size_type __pos1, const _Tp& __svt,\n\t       size_type __pos2, size_type __n = npos)\n\t{\n\t  __sv_type __sv = __svt;\n\t  return this->replace(__pos1, size_type(0), __sv.data()\n\t\t\t       + __sv._M_check(__pos2, \"basic_string::insert\"),\n\t\t\t       __sv._M_limit(__pos2, __n));\n\t}\n#endif // C++17\n\n      /**\n       *  @brief  Remove characters.\n       *  @param __pos  Index of first character to remove (default 0).\n       *  @param __n  Number of characters to remove (default remainder).\n       *  @return  Reference to this string.\n       *  @throw  std::out_of_range  If @a pos is beyond the end of this\n       *  string.\n       *\n       *  Removes @a __n characters from this string starting at @a\n       *  __pos.  The length of the string is reduced by @a __n.  If\n       *  there are < @a __n characters to remove, the remainder of\n       *  the string is truncated.  If @a __p is beyond end of string,\n       *  out_of_range is thrown.  The value of the string doesn't\n       *  change if an error is thrown.\n      */\n      basic_string&\n      erase(size_type __pos = 0, size_type __n = npos)\n      {\n\t_M_check(__pos, \"basic_string::erase\");\n\tif (__n == npos)\n\t  this->_M_set_length(__pos);\n\telse if (__n != 0)\n\t  this->_M_erase(__pos, _M_limit(__pos, __n));\n\treturn *this;\n      }\n\n      /**\n       *  @brief  Remove one character.\n       *  @param __position  Iterator referencing the character to remove.\n       *  @return  iterator referencing same location after removal.\n       *\n       *  Removes the character at @a __position from this string. The value\n       *  of the string doesn't change if an error is thrown.\n      */\n      iterator\n      erase(__const_iterator __position)\n      {\n\t_GLIBCXX_DEBUG_PEDASSERT(__position >= begin()\n\t\t\t\t && __position < end());\n\tconst size_type __pos = __position - begin();\n\tthis->_M_erase(__pos, size_type(1));\n\treturn iterator(_M_data() + __pos);\n      }\n\n      /**\n       *  @brief  Remove a range of characters.\n       *  @param __first  Iterator referencing the first character to remove.\n       *  @param __last  Iterator referencing the end of the range.\n       *  @return  Iterator referencing location of first after removal.\n       *\n       *  Removes the characters in the range [first,last) from this string.\n       *  The value of the string doesn't change if an error is thrown.\n      */\n      iterator\n      erase(__const_iterator __first, __const_iterator __last)\n      {\n\t_GLIBCXX_DEBUG_PEDASSERT(__first >= begin() && __first <= __last\n\t\t\t\t && __last <= end());\n        const size_type __pos = __first - begin();\n\tif (__last == end())\n\t  this->_M_set_length(__pos);\n\telse\n\t  this->_M_erase(__pos, __last - __first);\n\treturn iterator(this->_M_data() + __pos);\n      }\n\n#if __cplusplus >= 201103L\n      /**\n       *  @brief  Remove the last character.\n       *\n       *  The string must be non-empty.\n       */\n      void\n      pop_back() noexcept\n      {\n\t__glibcxx_assert(!empty());\n\t_M_erase(size() - 1, 1);\n      }\n#endif // C++11\n\n      /**\n       *  @brief  Replace characters with value from another string.\n       *  @param __pos  Index of first character to replace.\n       *  @param __n  Number of characters to be replaced.\n       *  @param __str  String to insert.\n       *  @return  Reference to this string.\n       *  @throw  std::out_of_range  If @a pos is beyond the end of this\n       *  string.\n       *  @throw  std::length_error  If new length exceeds @c max_size().\n       *\n       *  Removes the characters in the range [__pos,__pos+__n) from\n       *  this string.  In place, the value of @a __str is inserted.\n       *  If @a __pos is beyond end of string, out_of_range is thrown.\n       *  If the length of the result exceeds max_size(), length_error\n       *  is thrown.  The value of the string doesn't change if an\n       *  error is thrown.\n      */\n      basic_string&\n      replace(size_type __pos, size_type __n, const basic_string& __str)\n      { return this->replace(__pos, __n, __str._M_data(), __str.size()); }\n\n      /**\n       *  @brief  Replace characters with value from another string.\n       *  @param __pos1  Index of first character to replace.\n       *  @param __n1  Number of characters to be replaced.\n       *  @param __str  String to insert.\n       *  @param __pos2  Index of first character of str to use.\n       *  @param __n2  Number of characters from str to use.\n       *  @return  Reference to this string.\n       *  @throw  std::out_of_range  If @a __pos1 > size() or @a __pos2 >\n       *  __str.size().\n       *  @throw  std::length_error  If new length exceeds @c max_size().\n       *\n       *  Removes the characters in the range [__pos1,__pos1 + n) from this\n       *  string.  In place, the value of @a __str is inserted.  If @a __pos is\n       *  beyond end of string, out_of_range is thrown.  If the length of the\n       *  result exceeds max_size(), length_error is thrown.  The value of the\n       *  string doesn't change if an error is thrown.\n      */\n      basic_string&\n      replace(size_type __pos1, size_type __n1, const basic_string& __str,\n\t      size_type __pos2, size_type __n2 = npos)\n      { return this->replace(__pos1, __n1, __str._M_data()\n\t\t\t     + __str._M_check(__pos2, \"basic_string::replace\"),\n\t\t\t     __str._M_limit(__pos2, __n2)); }\n\n      /**\n       *  @brief  Replace characters with value of a C substring.\n       *  @param __pos  Index of first character to replace.\n       *  @param __n1  Number of characters to be replaced.\n       *  @param __s  C string to insert.\n       *  @param __n2  Number of characters from @a s to use.\n       *  @return  Reference to this string.\n       *  @throw  std::out_of_range  If @a pos1 > size().\n       *  @throw  std::length_error  If new length exceeds @c max_size().\n       *\n       *  Removes the characters in the range [__pos,__pos + __n1)\n       *  from this string.  In place, the first @a __n2 characters of\n       *  @a __s are inserted, or all of @a __s if @a __n2 is too large.  If\n       *  @a __pos is beyond end of string, out_of_range is thrown.  If\n       *  the length of result exceeds max_size(), length_error is\n       *  thrown.  The value of the string doesn't change if an error\n       *  is thrown.\n      */\n      basic_string&\n      replace(size_type __pos, size_type __n1, const _CharT* __s,\n\t      size_type __n2)\n      {\n\t__glibcxx_requires_string_len(__s, __n2);\n\treturn _M_replace(_M_check(__pos, \"basic_string::replace\"),\n\t\t\t  _M_limit(__pos, __n1), __s, __n2);\n      }\n\n      /**\n       *  @brief  Replace characters with value of a C string.\n       *  @param __pos  Index of first character to replace.\n       *  @param __n1  Number of characters to be replaced.\n       *  @param __s  C string to insert.\n       *  @return  Reference to this string.\n       *  @throw  std::out_of_range  If @a pos > size().\n       *  @throw  std::length_error  If new length exceeds @c max_size().\n       *\n       *  Removes the characters in the range [__pos,__pos + __n1)\n       *  from this string.  In place, the characters of @a __s are\n       *  inserted.  If @a __pos is beyond end of string, out_of_range\n       *  is thrown.  If the length of result exceeds max_size(),\n       *  length_error is thrown.  The value of the string doesn't\n       *  change if an error is thrown.\n      */\n      basic_string&\n      replace(size_type __pos, size_type __n1, const _CharT* __s)\n      {\n\t__glibcxx_requires_string(__s);\n\treturn this->replace(__pos, __n1, __s, traits_type::length(__s));\n      }\n\n      /**\n       *  @brief  Replace characters with multiple characters.\n       *  @param __pos  Index of first character to replace.\n       *  @param __n1  Number of characters to be replaced.\n       *  @param __n2  Number of characters to insert.\n       *  @param __c  Character to insert.\n       *  @return  Reference to this string.\n       *  @throw  std::out_of_range  If @a __pos > size().\n       *  @throw  std::length_error  If new length exceeds @c max_size().\n       *\n       *  Removes the characters in the range [pos,pos + n1) from this\n       *  string.  In place, @a __n2 copies of @a __c are inserted.\n       *  If @a __pos is beyond end of string, out_of_range is thrown.\n       *  If the length of result exceeds max_size(), length_error is\n       *  thrown.  The value of the string doesn't change if an error\n       *  is thrown.\n      */\n      basic_string&\n      replace(size_type __pos, size_type __n1, size_type __n2, _CharT __c)\n      { return _M_replace_aux(_M_check(__pos, \"basic_string::replace\"),\n\t\t\t      _M_limit(__pos, __n1), __n2, __c); }\n\n      /**\n       *  @brief  Replace range of characters with string.\n       *  @param __i1  Iterator referencing start of range to replace.\n       *  @param __i2  Iterator referencing end of range to replace.\n       *  @param __str  String value to insert.\n       *  @return  Reference to this string.\n       *  @throw  std::length_error  If new length exceeds @c max_size().\n       *\n       *  Removes the characters in the range [__i1,__i2).  In place,\n       *  the value of @a __str is inserted.  If the length of result\n       *  exceeds max_size(), length_error is thrown.  The value of\n       *  the string doesn't change if an error is thrown.\n      */\n      basic_string&\n      replace(__const_iterator __i1, __const_iterator __i2,\n\t      const basic_string& __str)\n      { return this->replace(__i1, __i2, __str._M_data(), __str.size()); }\n\n      /**\n       *  @brief  Replace range of characters with C substring.\n       *  @param __i1  Iterator referencing start of range to replace.\n       *  @param __i2  Iterator referencing end of range to replace.\n       *  @param __s  C string value to insert.\n       *  @param __n  Number of characters from s to insert.\n       *  @return  Reference to this string.\n       *  @throw  std::length_error  If new length exceeds @c max_size().\n       *\n       *  Removes the characters in the range [__i1,__i2).  In place,\n       *  the first @a __n characters of @a __s are inserted.  If the\n       *  length of result exceeds max_size(), length_error is thrown.\n       *  The value of the string doesn't change if an error is\n       *  thrown.\n      */\n      basic_string&\n      replace(__const_iterator __i1, __const_iterator __i2,\n\t      const _CharT* __s, size_type __n)\n      {\n\t_GLIBCXX_DEBUG_PEDASSERT(begin() <= __i1 && __i1 <= __i2\n\t\t\t\t && __i2 <= end());\n\treturn this->replace(__i1 - begin(), __i2 - __i1, __s, __n);\n      }\n\n      /**\n       *  @brief  Replace range of characters with C string.\n       *  @param __i1  Iterator referencing start of range to replace.\n       *  @param __i2  Iterator referencing end of range to replace.\n       *  @param __s  C string value to insert.\n       *  @return  Reference to this string.\n       *  @throw  std::length_error  If new length exceeds @c max_size().\n       *\n       *  Removes the characters in the range [__i1,__i2).  In place,\n       *  the characters of @a __s are inserted.  If the length of\n       *  result exceeds max_size(), length_error is thrown.  The\n       *  value of the string doesn't change if an error is thrown.\n      */\n      basic_string&\n      replace(__const_iterator __i1, __const_iterator __i2, const _CharT* __s)\n      {\n\t__glibcxx_requires_string(__s);\n\treturn this->replace(__i1, __i2, __s, traits_type::length(__s));\n      }\n\n      /**\n       *  @brief  Replace range of characters with multiple characters\n       *  @param __i1  Iterator referencing start of range to replace.\n       *  @param __i2  Iterator referencing end of range to replace.\n       *  @param __n  Number of characters to insert.\n       *  @param __c  Character to insert.\n       *  @return  Reference to this string.\n       *  @throw  std::length_error  If new length exceeds @c max_size().\n       *\n       *  Removes the characters in the range [__i1,__i2).  In place,\n       *  @a __n copies of @a __c are inserted.  If the length of\n       *  result exceeds max_size(), length_error is thrown.  The\n       *  value of the string doesn't change if an error is thrown.\n      */\n      basic_string&\n      replace(__const_iterator __i1, __const_iterator __i2, size_type __n,\n\t      _CharT __c)\n      {\n\t_GLIBCXX_DEBUG_PEDASSERT(begin() <= __i1 && __i1 <= __i2\n\t\t\t\t && __i2 <= end());\n\treturn _M_replace_aux(__i1 - begin(), __i2 - __i1, __n, __c);\n      }\n\n      /**\n       *  @brief  Replace range of characters with range.\n       *  @param __i1  Iterator referencing start of range to replace.\n       *  @param __i2  Iterator referencing end of range to replace.\n       *  @param __k1  Iterator referencing start of range to insert.\n       *  @param __k2  Iterator referencing end of range to insert.\n       *  @return  Reference to this string.\n       *  @throw  std::length_error  If new length exceeds @c max_size().\n       *\n       *  Removes the characters in the range [__i1,__i2).  In place,\n       *  characters in the range [__k1,__k2) are inserted.  If the\n       *  length of result exceeds max_size(), length_error is thrown.\n       *  The value of the string doesn't change if an error is\n       *  thrown.\n      */\n#if __cplusplus >= 201103L\n      template<class _InputIterator,\n\t       typename = std::_RequireInputIter<_InputIterator>>\n        basic_string&\n        replace(const_iterator __i1, const_iterator __i2,\n\t\t_InputIterator __k1, _InputIterator __k2)\n        {\n\t  _GLIBCXX_DEBUG_PEDASSERT(begin() <= __i1 && __i1 <= __i2\n\t\t\t\t   && __i2 <= end());\n\t  __glibcxx_requires_valid_range(__k1, __k2);\n\t  return this->_M_replace_dispatch(__i1, __i2, __k1, __k2,\n\t\t\t\t\t   std::__false_type());\n\t}\n#else\n      template<class _InputIterator>\n#ifdef _GLIBCXX_DISAMBIGUATE_REPLACE_INST\n        typename __enable_if_not_native_iterator<_InputIterator>::__type\n#else\n        basic_string&\n#endif\n        replace(iterator __i1, iterator __i2,\n\t\t_InputIterator __k1, _InputIterator __k2)\n        {\n\t  _GLIBCXX_DEBUG_PEDASSERT(begin() <= __i1 && __i1 <= __i2\n\t\t\t\t   && __i2 <= end());\n\t  __glibcxx_requires_valid_range(__k1, __k2);\n\t  typedef typename std::__is_integer<_InputIterator>::__type _Integral;\n\t  return _M_replace_dispatch(__i1, __i2, __k1, __k2, _Integral());\n\t}\n#endif\n\n      // Specializations for the common case of pointer and iterator:\n      // useful to avoid the overhead of temporary buffering in _M_replace.\n      basic_string&\n      replace(__const_iterator __i1, __const_iterator __i2,\n\t      _CharT* __k1, _CharT* __k2)\n      {\n\t_GLIBCXX_DEBUG_PEDASSERT(begin() <= __i1 && __i1 <= __i2\n\t\t\t\t && __i2 <= end());\n\t__glibcxx_requires_valid_range(__k1, __k2);\n\treturn this->replace(__i1 - begin(), __i2 - __i1,\n\t\t\t     __k1, __k2 - __k1);\n      }\n\n      basic_string&\n      replace(__const_iterator __i1, __const_iterator __i2,\n\t      const _CharT* __k1, const _CharT* __k2)\n      {\n\t_GLIBCXX_DEBUG_PEDASSERT(begin() <= __i1 && __i1 <= __i2\n\t\t\t\t && __i2 <= end());\n\t__glibcxx_requires_valid_range(__k1, __k2);\n\treturn this->replace(__i1 - begin(), __i2 - __i1,\n\t\t\t     __k1, __k2 - __k1);\n      }\n\n      basic_string&\n      replace(__const_iterator __i1, __const_iterator __i2,\n\t      iterator __k1, iterator __k2)\n      {\n\t_GLIBCXX_DEBUG_PEDASSERT(begin() <= __i1 && __i1 <= __i2\n\t\t\t\t && __i2 <= end());\n\t__glibcxx_requires_valid_range(__k1, __k2);\n\treturn this->replace(__i1 - begin(), __i2 - __i1,\n\t\t\t     __k1.base(), __k2 - __k1);\n      }\n\n      basic_string&\n      replace(__const_iterator __i1, __const_iterator __i2,\n\t      const_iterator __k1, const_iterator __k2)\n      {\n\t_GLIBCXX_DEBUG_PEDASSERT(begin() <= __i1 && __i1 <= __i2\n\t\t\t\t && __i2 <= end());\n\t__glibcxx_requires_valid_range(__k1, __k2);\n\treturn this->replace(__i1 - begin(), __i2 - __i1,\n\t\t\t     __k1.base(), __k2 - __k1);\n      }\n\n#if __cplusplus >= 201103L\n      /**\n       *  @brief  Replace range of characters with initializer_list.\n       *  @param __i1  Iterator referencing start of range to replace.\n       *  @param __i2  Iterator referencing end of range to replace.\n       *  @param __l  The initializer_list of characters to insert.\n       *  @return  Reference to this string.\n       *  @throw  std::length_error  If new length exceeds @c max_size().\n       *\n       *  Removes the characters in the range [__i1,__i2).  In place,\n       *  characters in the range [__k1,__k2) are inserted.  If the\n       *  length of result exceeds max_size(), length_error is thrown.\n       *  The value of the string doesn't change if an error is\n       *  thrown.\n      */\n      basic_string& replace(const_iterator __i1, const_iterator __i2,\n\t\t\t    initializer_list<_CharT> __l)\n      { return this->replace(__i1, __i2, __l.begin(), __l.size()); }\n#endif // C++11\n\n#if __cplusplus > 201402L\n      /**\n       *  @brief  Replace range of characters with string_view.\n       *  @param __pos  The position to replace at.\n       *  @param __n    The number of characters to replace.\n       *  @param __svt  The object convertible to string_view to insert.\n       *  @return  Reference to this string.\n      */\n      template<typename _Tp>\n\t_If_sv<_Tp, basic_string&>\n\treplace(size_type __pos, size_type __n, const _Tp& __svt)\n\t{\n\t  __sv_type __sv = __svt;\n\t  return this->replace(__pos, __n, __sv.data(), __sv.size());\n\t}\n\n      /**\n       *  @brief  Replace range of characters with string_view.\n       *  @param __pos1  The position to replace at.\n       *  @param __n1    The number of characters to replace.\n       *  @param __svt   The object convertible to string_view to insert from.\n       *  @param __pos2  The position in the string_view to insert from.\n       *  @param __n2    The number of characters to insert.\n       *  @return  Reference to this string.\n      */\n      template<typename _Tp>\n\t_If_sv<_Tp, basic_string&>\n\treplace(size_type __pos1, size_type __n1, const _Tp& __svt,\n\t\tsize_type __pos2, size_type __n2 = npos)\n\t{\n\t  __sv_type __sv = __svt;\n\t  return this->replace(__pos1, __n1, __sv.data()\n\t\t\t       + __sv._M_check(__pos2, \"basic_string::replace\"),\n\t\t\t       __sv._M_limit(__pos2, __n2));\n\t}\n\n      /**\n       *  @brief  Replace range of characters with string_view.\n       *  @param __i1    An iterator referencing the start position\n          to replace at.\n       *  @param __i2    An iterator referencing the end position\n          for the replace.\n       *  @param __svt   The object convertible to string_view to insert from.\n       *  @return  Reference to this string.\n      */\n      template<typename _Tp>\n\t_If_sv<_Tp, basic_string&>\n\treplace(const_iterator __i1, const_iterator __i2, const _Tp& __svt)\n\t{\n\t  __sv_type __sv = __svt;\n\t  return this->replace(__i1 - begin(), __i2 - __i1, __sv);\n\t}\n#endif // C++17\n\n    private:\n      template<class _Integer>\n\tbasic_string&\n\t_M_replace_dispatch(const_iterator __i1, const_iterator __i2,\n\t\t\t    _Integer __n, _Integer __val, __true_type)\n        { return _M_replace_aux(__i1 - begin(), __i2 - __i1, __n, __val); }\n\n      template<class _InputIterator>\n\tbasic_string&\n\t_M_replace_dispatch(const_iterator __i1, const_iterator __i2,\n\t\t\t    _InputIterator __k1, _InputIterator __k2,\n\t\t\t    __false_type);\n\n      basic_string&\n      _M_replace_aux(size_type __pos1, size_type __n1, size_type __n2,\n\t\t     _CharT __c);\n\n      basic_string&\n      _M_replace(size_type __pos, size_type __len1, const _CharT* __s,\n\t\t const size_type __len2);\n\n      basic_string&\n      _M_append(const _CharT* __s, size_type __n);\n\n    public:\n\n      /**\n       *  @brief  Copy substring into C string.\n       *  @param __s  C string to copy value into.\n       *  @param __n  Number of characters to copy.\n       *  @param __pos  Index of first character to copy.\n       *  @return  Number of characters actually copied\n       *  @throw  std::out_of_range  If __pos > size().\n       *\n       *  Copies up to @a __n characters starting at @a __pos into the\n       *  C string @a __s.  If @a __pos is %greater than size(),\n       *  out_of_range is thrown.\n      */\n      size_type\n      copy(_CharT* __s, size_type __n, size_type __pos = 0) const;\n\n      /**\n       *  @brief  Swap contents with another string.\n       *  @param __s  String to swap with.\n       *\n       *  Exchanges the contents of this string with that of @a __s in constant\n       *  time.\n      */\n      void\n      swap(basic_string& __s) _GLIBCXX_NOEXCEPT;\n\n      // String operations:\n      /**\n       *  @brief  Return const pointer to null-terminated contents.\n       *\n       *  This is a handle to internal data.  Do not modify or dire things may\n       *  happen.\n      */\n      const _CharT*\n      c_str() const _GLIBCXX_NOEXCEPT\n      { return _M_data(); }\n\n      /**\n       *  @brief  Return const pointer to contents.\n       *\n       *  This is a pointer to internal data.  It is undefined to modify\n       *  the contents through the returned pointer. To get a pointer that\n       *  allows modifying the contents use @c &str[0] instead,\n       *  (or in C++17 the non-const @c str.data() overload).\n      */\n      const _CharT*\n      data() const _GLIBCXX_NOEXCEPT\n      { return _M_data(); }\n\n#if __cplusplus > 201402L\n      /**\n       *  @brief  Return non-const pointer to contents.\n       *\n       *  This is a pointer to the character sequence held by the string.\n       *  Modifying the characters in the sequence is allowed.\n      */\n      _CharT*\n      data() noexcept\n      { return _M_data(); }\n#endif\n\n      /**\n       *  @brief  Return copy of allocator used to construct this string.\n      */\n      allocator_type\n      get_allocator() const _GLIBCXX_NOEXCEPT\n      { return _M_get_allocator(); }\n\n      /**\n       *  @brief  Find position of a C substring.\n       *  @param __s  C string to locate.\n       *  @param __pos  Index of character to search from.\n       *  @param __n  Number of characters from @a s to search for.\n       *  @return  Index of start of first occurrence.\n       *\n       *  Starting from @a __pos, searches forward for the first @a\n       *  __n characters in @a __s within this string.  If found,\n       *  returns the index where it begins.  If not found, returns\n       *  npos.\n      */\n      size_type\n      find(const _CharT* __s, size_type __pos, size_type __n) const\n      _GLIBCXX_NOEXCEPT;\n\n      /**\n       *  @brief  Find position of a string.\n       *  @param __str  String to locate.\n       *  @param __pos  Index of character to search from (default 0).\n       *  @return  Index of start of first occurrence.\n       *\n       *  Starting from @a __pos, searches forward for value of @a __str within\n       *  this string.  If found, returns the index where it begins.  If not\n       *  found, returns npos.\n      */\n      size_type\n      find(const basic_string& __str, size_type __pos = 0) const\n      _GLIBCXX_NOEXCEPT\n      { return this->find(__str.data(), __pos, __str.size()); }\n\n#if __cplusplus > 201402L\n      /**\n       *  @brief  Find position of a string_view.\n       *  @param __svt  The object convertible to string_view to locate.\n       *  @param __pos  Index of character to search from (default 0).\n       *  @return  Index of start of first occurrence.\n      */\n      template<typename _Tp>\n\t_If_sv<_Tp, size_type>\n\tfind(const _Tp& __svt, size_type __pos = 0) const\n\tnoexcept(is_same<_Tp, __sv_type>::value)\n\t{\n\t  __sv_type __sv = __svt;\n\t  return this->find(__sv.data(), __pos, __sv.size());\n\t}\n#endif // C++17\n\n      /**\n       *  @brief  Find position of a C string.\n       *  @param __s  C string to locate.\n       *  @param __pos  Index of character to search from (default 0).\n       *  @return  Index of start of first occurrence.\n       *\n       *  Starting from @a __pos, searches forward for the value of @a\n       *  __s within this string.  If found, returns the index where\n       *  it begins.  If not found, returns npos.\n      */\n      size_type\n      find(const _CharT* __s, size_type __pos = 0) const _GLIBCXX_NOEXCEPT\n      {\n\t__glibcxx_requires_string(__s);\n\treturn this->find(__s, __pos, traits_type::length(__s));\n      }\n\n      /**\n       *  @brief  Find position of a character.\n       *  @param __c  Character to locate.\n       *  @param __pos  Index of character to search from (default 0).\n       *  @return  Index of first occurrence.\n       *\n       *  Starting from @a __pos, searches forward for @a __c within\n       *  this string.  If found, returns the index where it was\n       *  found.  If not found, returns npos.\n      */\n      size_type\n      find(_CharT __c, size_type __pos = 0) const _GLIBCXX_NOEXCEPT;\n\n      /**\n       *  @brief  Find last position of a string.\n       *  @param __str  String to locate.\n       *  @param __pos  Index of character to search back from (default end).\n       *  @return  Index of start of last occurrence.\n       *\n       *  Starting from @a __pos, searches backward for value of @a\n       *  __str within this string.  If found, returns the index where\n       *  it begins.  If not found, returns npos.\n      */\n      size_type\n      rfind(const basic_string& __str, size_type __pos = npos) const\n      _GLIBCXX_NOEXCEPT\n      { return this->rfind(__str.data(), __pos, __str.size()); }\n\n#if __cplusplus > 201402L\n      /**\n       *  @brief  Find last position of a string_view.\n       *  @param __svt  The object convertible to string_view to locate.\n       *  @param __pos  Index of character to search back from (default end).\n       *  @return  Index of start of last occurrence.\n      */\n      template<typename _Tp>\n\t_If_sv<_Tp, size_type>\n\trfind(const _Tp& __svt, size_type __pos = npos) const\n\tnoexcept(is_same<_Tp, __sv_type>::value)\n\t{\n\t  __sv_type __sv = __svt;\n\t  return this->rfind(__sv.data(), __pos, __sv.size());\n\t}\n#endif // C++17\n\n      /**\n       *  @brief  Find last position of a C substring.\n       *  @param __s  C string to locate.\n       *  @param __pos  Index of character to search back from.\n       *  @param __n  Number of characters from s to search for.\n       *  @return  Index of start of last occurrence.\n       *\n       *  Starting from @a __pos, searches backward for the first @a\n       *  __n characters in @a __s within this string.  If found,\n       *  returns the index where it begins.  If not found, returns\n       *  npos.\n      */\n      size_type\n      rfind(const _CharT* __s, size_type __pos, size_type __n) const\n      _GLIBCXX_NOEXCEPT;\n\n      /**\n       *  @brief  Find last position of a C string.\n       *  @param __s  C string to locate.\n       *  @param __pos  Index of character to start search at (default end).\n       *  @return  Index of start of  last occurrence.\n       *\n       *  Starting from @a __pos, searches backward for the value of\n       *  @a __s within this string.  If found, returns the index\n       *  where it begins.  If not found, returns npos.\n      */\n      size_type\n      rfind(const _CharT* __s, size_type __pos = npos) const\n      {\n\t__glibcxx_requires_string(__s);\n\treturn this->rfind(__s, __pos, traits_type::length(__s));\n      }\n\n      /**\n       *  @brief  Find last position of a character.\n       *  @param __c  Character to locate.\n       *  @param __pos  Index of character to search back from (default end).\n       *  @return  Index of last occurrence.\n       *\n       *  Starting from @a __pos, searches backward for @a __c within\n       *  this string.  If found, returns the index where it was\n       *  found.  If not found, returns npos.\n      */\n      size_type\n      rfind(_CharT __c, size_type __pos = npos) const _GLIBCXX_NOEXCEPT;\n\n      /**\n       *  @brief  Find position of a character of string.\n       *  @param __str  String containing characters to locate.\n       *  @param __pos  Index of character to search from (default 0).\n       *  @return  Index of first occurrence.\n       *\n       *  Starting from @a __pos, searches forward for one of the\n       *  characters of @a __str within this string.  If found,\n       *  returns the index where it was found.  If not found, returns\n       *  npos.\n      */\n      size_type\n      find_first_of(const basic_string& __str, size_type __pos = 0) const\n      _GLIBCXX_NOEXCEPT\n      { return this->find_first_of(__str.data(), __pos, __str.size()); }\n\n#if __cplusplus > 201402L\n      /**\n       *  @brief  Find position of a character of a string_view.\n       *  @param __svt  An object convertible to string_view containing\n       *                characters to locate.\n       *  @param __pos  Index of character to search from (default 0).\n       *  @return  Index of first occurrence.\n      */\n      template<typename _Tp>\n\t_If_sv<_Tp, size_type>\n\tfind_first_of(const _Tp& __svt, size_type __pos = 0) const\n\tnoexcept(is_same<_Tp, __sv_type>::value)\n\t{\n\t  __sv_type __sv = __svt;\n\t  return this->find_first_of(__sv.data(), __pos, __sv.size());\n\t}\n#endif // C++17\n\n      /**\n       *  @brief  Find position of a character of C substring.\n       *  @param __s  String containing characters to locate.\n       *  @param __pos  Index of character to search from.\n       *  @param __n  Number of characters from s to search for.\n       *  @return  Index of first occurrence.\n       *\n       *  Starting from @a __pos, searches forward for one of the\n       *  first @a __n characters of @a __s within this string.  If\n       *  found, returns the index where it was found.  If not found,\n       *  returns npos.\n      */\n      size_type\n      find_first_of(const _CharT* __s, size_type __pos, size_type __n) const\n      _GLIBCXX_NOEXCEPT;\n\n      /**\n       *  @brief  Find position of a character of C string.\n       *  @param __s  String containing characters to locate.\n       *  @param __pos  Index of character to search from (default 0).\n       *  @return  Index of first occurrence.\n       *\n       *  Starting from @a __pos, searches forward for one of the\n       *  characters of @a __s within this string.  If found, returns\n       *  the index where it was found.  If not found, returns npos.\n      */\n      size_type\n      find_first_of(const _CharT* __s, size_type __pos = 0) const\n      _GLIBCXX_NOEXCEPT\n      {\n\t__glibcxx_requires_string(__s);\n\treturn this->find_first_of(__s, __pos, traits_type::length(__s));\n      }\n\n      /**\n       *  @brief  Find position of a character.\n       *  @param __c  Character to locate.\n       *  @param __pos  Index of character to search from (default 0).\n       *  @return  Index of first occurrence.\n       *\n       *  Starting from @a __pos, searches forward for the character\n       *  @a __c within this string.  If found, returns the index\n       *  where it was found.  If not found, returns npos.\n       *\n       *  Note: equivalent to find(__c, __pos).\n      */\n      size_type\n      find_first_of(_CharT __c, size_type __pos = 0) const _GLIBCXX_NOEXCEPT\n      { return this->find(__c, __pos); }\n\n      /**\n       *  @brief  Find last position of a character of string.\n       *  @param __str  String containing characters to locate.\n       *  @param __pos  Index of character to search back from (default end).\n       *  @return  Index of last occurrence.\n       *\n       *  Starting from @a __pos, searches backward for one of the\n       *  characters of @a __str within this string.  If found,\n       *  returns the index where it was found.  If not found, returns\n       *  npos.\n      */\n      size_type\n      find_last_of(const basic_string& __str, size_type __pos = npos) const\n      _GLIBCXX_NOEXCEPT\n      { return this->find_last_of(__str.data(), __pos, __str.size()); }\n\n#if __cplusplus > 201402L\n      /**\n       *  @brief  Find last position of a character of string.\n       *  @param __svt  An object convertible to string_view containing\n       *                characters to locate.\n       *  @param __pos  Index of character to search back from (default end).\n       *  @return  Index of last occurrence.\n      */\n      template<typename _Tp>\n\t_If_sv<_Tp, size_type>\n\tfind_last_of(const _Tp& __svt, size_type __pos = npos) const\n\tnoexcept(is_same<_Tp, __sv_type>::value)\n\t{\n\t  __sv_type __sv = __svt;\n\t  return this->find_last_of(__sv.data(), __pos, __sv.size());\n\t}\n#endif // C++17\n\n      /**\n       *  @brief  Find last position of a character of C substring.\n       *  @param __s  C string containing characters to locate.\n       *  @param __pos  Index of character to search back from.\n       *  @param __n  Number of characters from s to search for.\n       *  @return  Index of last occurrence.\n       *\n       *  Starting from @a __pos, searches backward for one of the\n       *  first @a __n characters of @a __s within this string.  If\n       *  found, returns the index where it was found.  If not found,\n       *  returns npos.\n      */\n      size_type\n      find_last_of(const _CharT* __s, size_type __pos, size_type __n) const\n      _GLIBCXX_NOEXCEPT;\n\n      /**\n       *  @brief  Find last position of a character of C string.\n       *  @param __s  C string containing characters to locate.\n       *  @param __pos  Index of character to search back from (default end).\n       *  @return  Index of last occurrence.\n       *\n       *  Starting from @a __pos, searches backward for one of the\n       *  characters of @a __s within this string.  If found, returns\n       *  the index where it was found.  If not found, returns npos.\n      */\n      size_type\n      find_last_of(const _CharT* __s, size_type __pos = npos) const\n      _GLIBCXX_NOEXCEPT\n      {\n\t__glibcxx_requires_string(__s);\n\treturn this->find_last_of(__s, __pos, traits_type::length(__s));\n      }\n\n      /**\n       *  @brief  Find last position of a character.\n       *  @param __c  Character to locate.\n       *  @param __pos  Index of character to search back from (default end).\n       *  @return  Index of last occurrence.\n       *\n       *  Starting from @a __pos, searches backward for @a __c within\n       *  this string.  If found, returns the index where it was\n       *  found.  If not found, returns npos.\n       *\n       *  Note: equivalent to rfind(__c, __pos).\n      */\n      size_type\n      find_last_of(_CharT __c, size_type __pos = npos) const _GLIBCXX_NOEXCEPT\n      { return this->rfind(__c, __pos); }\n\n      /**\n       *  @brief  Find position of a character not in string.\n       *  @param __str  String containing characters to avoid.\n       *  @param __pos  Index of character to search from (default 0).\n       *  @return  Index of first occurrence.\n       *\n       *  Starting from @a __pos, searches forward for a character not contained\n       *  in @a __str within this string.  If found, returns the index where it\n       *  was found.  If not found, returns npos.\n      */\n      size_type\n      find_first_not_of(const basic_string& __str, size_type __pos = 0) const\n      _GLIBCXX_NOEXCEPT\n      { return this->find_first_not_of(__str.data(), __pos, __str.size()); }\n\n#if __cplusplus > 201402L\n      /**\n       *  @brief  Find position of a character not in a string_view.\n       *  @param __svt  A object convertible to string_view containing\n       *                characters to avoid.\n       *  @param __pos  Index of character to search from (default 0).\n       *  @return  Index of first occurrence.\n       */\n      template<typename _Tp>\n\t_If_sv<_Tp, size_type>\n\tfind_first_not_of(const _Tp& __svt, size_type __pos = 0) const\n\tnoexcept(is_same<_Tp, __sv_type>::value)\n\t{\n\t  __sv_type __sv = __svt;\n\t  return this->find_first_not_of(__sv.data(), __pos, __sv.size());\n\t}\n#endif // C++17\n\n      /**\n       *  @brief  Find position of a character not in C substring.\n       *  @param __s  C string containing characters to avoid.\n       *  @param __pos  Index of character to search from.\n       *  @param __n  Number of characters from __s to consider.\n       *  @return  Index of first occurrence.\n       *\n       *  Starting from @a __pos, searches forward for a character not\n       *  contained in the first @a __n characters of @a __s within\n       *  this string.  If found, returns the index where it was\n       *  found.  If not found, returns npos.\n      */\n      size_type\n      find_first_not_of(const _CharT* __s, size_type __pos,\n\t\t\tsize_type __n) const _GLIBCXX_NOEXCEPT;\n\n      /**\n       *  @brief  Find position of a character not in C string.\n       *  @param __s  C string containing characters to avoid.\n       *  @param __pos  Index of character to search from (default 0).\n       *  @return  Index of first occurrence.\n       *\n       *  Starting from @a __pos, searches forward for a character not\n       *  contained in @a __s within this string.  If found, returns\n       *  the index where it was found.  If not found, returns npos.\n      */\n      size_type\n      find_first_not_of(const _CharT* __s, size_type __pos = 0) const\n      _GLIBCXX_NOEXCEPT\n      {\n\t__glibcxx_requires_string(__s);\n\treturn this->find_first_not_of(__s, __pos, traits_type::length(__s));\n      }\n\n      /**\n       *  @brief  Find position of a different character.\n       *  @param __c  Character to avoid.\n       *  @param __pos  Index of character to search from (default 0).\n       *  @return  Index of first occurrence.\n       *\n       *  Starting from @a __pos, searches forward for a character\n       *  other than @a __c within this string.  If found, returns the\n       *  index where it was found.  If not found, returns npos.\n      */\n      size_type\n      find_first_not_of(_CharT __c, size_type __pos = 0) const\n      _GLIBCXX_NOEXCEPT;\n\n      /**\n       *  @brief  Find last position of a character not in string.\n       *  @param __str  String containing characters to avoid.\n       *  @param __pos  Index of character to search back from (default end).\n       *  @return  Index of last occurrence.\n       *\n       *  Starting from @a __pos, searches backward for a character\n       *  not contained in @a __str within this string.  If found,\n       *  returns the index where it was found.  If not found, returns\n       *  npos.\n      */\n      size_type\n      find_last_not_of(const basic_string& __str, size_type __pos = npos) const\n      _GLIBCXX_NOEXCEPT\n      { return this->find_last_not_of(__str.data(), __pos, __str.size()); }\n\n#if __cplusplus > 201402L\n      /**\n       *  @brief  Find last position of a character not in a string_view.\n       *  @param __svt  An object convertible to string_view containing\n       *                characters to avoid.\n       *  @param __pos  Index of character to search back from (default end).\n       *  @return  Index of last occurrence.\n       */\n      template<typename _Tp>\n\t_If_sv<_Tp, size_type>\n\tfind_last_not_of(const _Tp& __svt, size_type __pos = npos) const\n\tnoexcept(is_same<_Tp, __sv_type>::value)\n\t{\n\t  __sv_type __sv = __svt;\n\t  return this->find_last_not_of(__sv.data(), __pos, __sv.size());\n\t}\n#endif // C++17\n\n      /**\n       *  @brief  Find last position of a character not in C substring.\n       *  @param __s  C string containing characters to avoid.\n       *  @param __pos  Index of character to search back from.\n       *  @param __n  Number of characters from s to consider.\n       *  @return  Index of last occurrence.\n       *\n       *  Starting from @a __pos, searches backward for a character not\n       *  contained in the first @a __n characters of @a __s within this string.\n       *  If found, returns the index where it was found.  If not found,\n       *  returns npos.\n      */\n      size_type\n      find_last_not_of(const _CharT* __s, size_type __pos,\n\t\t       size_type __n) const _GLIBCXX_NOEXCEPT;\n      /**\n       *  @brief  Find last position of a character not in C string.\n       *  @param __s  C string containing characters to avoid.\n       *  @param __pos  Index of character to search back from (default end).\n       *  @return  Index of last occurrence.\n       *\n       *  Starting from @a __pos, searches backward for a character\n       *  not contained in @a __s within this string.  If found,\n       *  returns the index where it was found.  If not found, returns\n       *  npos.\n      */\n      size_type\n      find_last_not_of(const _CharT* __s, size_type __pos = npos) const\n      _GLIBCXX_NOEXCEPT\n      {\n\t__glibcxx_requires_string(__s);\n\treturn this->find_last_not_of(__s, __pos, traits_type::length(__s));\n      }\n\n      /**\n       *  @brief  Find last position of a different character.\n       *  @param __c  Character to avoid.\n       *  @param __pos  Index of character to search back from (default end).\n       *  @return  Index of last occurrence.\n       *\n       *  Starting from @a __pos, searches backward for a character other than\n       *  @a __c within this string.  If found, returns the index where it was\n       *  found.  If not found, returns npos.\n      */\n      size_type\n      find_last_not_of(_CharT __c, size_type __pos = npos) const\n      _GLIBCXX_NOEXCEPT;\n\n      /**\n       *  @brief  Get a substring.\n       *  @param __pos  Index of first character (default 0).\n       *  @param __n  Number of characters in substring (default remainder).\n       *  @return  The new string.\n       *  @throw  std::out_of_range  If __pos > size().\n       *\n       *  Construct and return a new string using the @a __n\n       *  characters starting at @a __pos.  If the string is too\n       *  short, use the remainder of the characters.  If @a __pos is\n       *  beyond the end of the string, out_of_range is thrown.\n      */\n      basic_string\n      substr(size_type __pos = 0, size_type __n = npos) const\n      { return basic_string(*this,\n\t\t\t    _M_check(__pos, \"basic_string::substr\"), __n); }\n\n      /**\n       *  @brief  Compare to a string.\n       *  @param __str  String to compare against.\n       *  @return  Integer < 0, 0, or > 0.\n       *\n       *  Returns an integer < 0 if this string is ordered before @a\n       *  __str, 0 if their values are equivalent, or > 0 if this\n       *  string is ordered after @a __str.  Determines the effective\n       *  length rlen of the strings to compare as the smallest of\n       *  size() and str.size().  The function then compares the two\n       *  strings by calling traits::compare(data(), str.data(),rlen).\n       *  If the result of the comparison is nonzero returns it,\n       *  otherwise the shorter one is ordered first.\n      */\n      int\n      compare(const basic_string& __str) const\n      {\n\tconst size_type __size = this->size();\n\tconst size_type __osize = __str.size();\n\tconst size_type __len = std::min(__size, __osize);\n\n\tint __r = traits_type::compare(_M_data(), __str.data(), __len);\n\tif (!__r)\n\t  __r = _S_compare(__size, __osize);\n\treturn __r;\n      }\n\n#if __cplusplus > 201402L\n      /**\n       *  @brief  Compare to a string_view.\n       *  @param __svt An object convertible to string_view to compare against.\n       *  @return  Integer < 0, 0, or > 0.\n       */\n      template<typename _Tp>\n\t_If_sv<_Tp, int>\n\tcompare(const _Tp& __svt) const\n\tnoexcept(is_same<_Tp, __sv_type>::value)\n\t{\n\t  __sv_type __sv = __svt;\n\t  const size_type __size = this->size();\n\t  const size_type __osize = __sv.size();\n\t  const size_type __len = std::min(__size, __osize);\n\n\t  int __r = traits_type::compare(_M_data(), __sv.data(), __len);\n\t  if (!__r)\n\t    __r = _S_compare(__size, __osize);\n\t  return __r;\n\t}\n\n      /**\n       *  @brief  Compare to a string_view.\n       *  @param __pos  A position in the string to start comparing from.\n       *  @param __n  The number of characters to compare.\n       *  @param __svt  An object convertible to string_view to compare\n       *                against.\n       *  @return  Integer < 0, 0, or > 0.\n       */\n      template<typename _Tp>\n\t_If_sv<_Tp, int>\n\tcompare(size_type __pos, size_type __n, const _Tp& __svt) const\n\tnoexcept(is_same<_Tp, __sv_type>::value)\n\t{\n\t  __sv_type __sv = __svt;\n\t  return __sv_type(*this).substr(__pos, __n).compare(__sv);\n\t}\n\n      /**\n       *  @brief  Compare to a string_view.\n       *  @param __pos1  A position in the string to start comparing from.\n       *  @param __n1  The number of characters to compare.\n       *  @param __svt  An object convertible to string_view to compare\n       *                against.\n       *  @param __pos2  A position in the string_view to start comparing from.\n       *  @param __n2  The number of characters to compare.\n       *  @return  Integer < 0, 0, or > 0.\n       */\n      template<typename _Tp>\n\t_If_sv<_Tp, int>\n\tcompare(size_type __pos1, size_type __n1, const _Tp& __svt,\n\t\tsize_type __pos2, size_type __n2 = npos) const\n\tnoexcept(is_same<_Tp, __sv_type>::value)\n\t{\n\t  __sv_type __sv = __svt;\n\t  return __sv_type(*this)\n\t    .substr(__pos1, __n1).compare(__sv.substr(__pos2, __n2));\n\t}\n#endif // C++17\n\n      /**\n       *  @brief  Compare substring to a string.\n       *  @param __pos  Index of first character of substring.\n       *  @param __n  Number of characters in substring.\n       *  @param __str  String to compare against.\n       *  @return  Integer < 0, 0, or > 0.\n       *\n       *  Form the substring of this string from the @a __n characters\n       *  starting at @a __pos.  Returns an integer < 0 if the\n       *  substring is ordered before @a __str, 0 if their values are\n       *  equivalent, or > 0 if the substring is ordered after @a\n       *  __str.  Determines the effective length rlen of the strings\n       *  to compare as the smallest of the length of the substring\n       *  and @a __str.size().  The function then compares the two\n       *  strings by calling\n       *  traits::compare(substring.data(),str.data(),rlen).  If the\n       *  result of the comparison is nonzero returns it, otherwise\n       *  the shorter one is ordered first.\n      */\n      int\n      compare(size_type __pos, size_type __n, const basic_string& __str) const;\n\n      /**\n       *  @brief  Compare substring to a substring.\n       *  @param __pos1  Index of first character of substring.\n       *  @param __n1  Number of characters in substring.\n       *  @param __str  String to compare against.\n       *  @param __pos2  Index of first character of substring of str.\n       *  @param __n2  Number of characters in substring of str.\n       *  @return  Integer < 0, 0, or > 0.\n       *\n       *  Form the substring of this string from the @a __n1\n       *  characters starting at @a __pos1.  Form the substring of @a\n       *  __str from the @a __n2 characters starting at @a __pos2.\n       *  Returns an integer < 0 if this substring is ordered before\n       *  the substring of @a __str, 0 if their values are equivalent,\n       *  or > 0 if this substring is ordered after the substring of\n       *  @a __str.  Determines the effective length rlen of the\n       *  strings to compare as the smallest of the lengths of the\n       *  substrings.  The function then compares the two strings by\n       *  calling\n       *  traits::compare(substring.data(),str.substr(pos2,n2).data(),rlen).\n       *  If the result of the comparison is nonzero returns it,\n       *  otherwise the shorter one is ordered first.\n      */\n      int\n      compare(size_type __pos1, size_type __n1, const basic_string& __str,\n\t      size_type __pos2, size_type __n2 = npos) const;\n\n      /**\n       *  @brief  Compare to a C string.\n       *  @param __s  C string to compare against.\n       *  @return  Integer < 0, 0, or > 0.\n       *\n       *  Returns an integer < 0 if this string is ordered before @a __s, 0 if\n       *  their values are equivalent, or > 0 if this string is ordered after\n       *  @a __s.  Determines the effective length rlen of the strings to\n       *  compare as the smallest of size() and the length of a string\n       *  constructed from @a __s.  The function then compares the two strings\n       *  by calling traits::compare(data(),s,rlen).  If the result of the\n       *  comparison is nonzero returns it, otherwise the shorter one is\n       *  ordered first.\n      */\n      int\n      compare(const _CharT* __s) const _GLIBCXX_NOEXCEPT;\n\n      // _GLIBCXX_RESOLVE_LIB_DEFECTS\n      // 5 String::compare specification questionable\n      /**\n       *  @brief  Compare substring to a C string.\n       *  @param __pos  Index of first character of substring.\n       *  @param __n1  Number of characters in substring.\n       *  @param __s  C string to compare against.\n       *  @return  Integer < 0, 0, or > 0.\n       *\n       *  Form the substring of this string from the @a __n1\n       *  characters starting at @a pos.  Returns an integer < 0 if\n       *  the substring is ordered before @a __s, 0 if their values\n       *  are equivalent, or > 0 if the substring is ordered after @a\n       *  __s.  Determines the effective length rlen of the strings to\n       *  compare as the smallest of the length of the substring and\n       *  the length of a string constructed from @a __s.  The\n       *  function then compares the two string by calling\n       *  traits::compare(substring.data(),__s,rlen).  If the result of\n       *  the comparison is nonzero returns it, otherwise the shorter\n       *  one is ordered first.\n      */\n      int\n      compare(size_type __pos, size_type __n1, const _CharT* __s) const;\n\n      /**\n       *  @brief  Compare substring against a character %array.\n       *  @param __pos  Index of first character of substring.\n       *  @param __n1  Number of characters in substring.\n       *  @param __s  character %array to compare against.\n       *  @param __n2  Number of characters of s.\n       *  @return  Integer < 0, 0, or > 0.\n       *\n       *  Form the substring of this string from the @a __n1\n       *  characters starting at @a __pos.  Form a string from the\n       *  first @a __n2 characters of @a __s.  Returns an integer < 0\n       *  if this substring is ordered before the string from @a __s,\n       *  0 if their values are equivalent, or > 0 if this substring\n       *  is ordered after the string from @a __s.  Determines the\n       *  effective length rlen of the strings to compare as the\n       *  smallest of the length of the substring and @a __n2.  The\n       *  function then compares the two strings by calling\n       *  traits::compare(substring.data(),s,rlen).  If the result of\n       *  the comparison is nonzero returns it, otherwise the shorter\n       *  one is ordered first.\n       *\n       *  NB: s must have at least n2 characters, &apos;\\\\0&apos; has\n       *  no special meaning.\n      */\n      int\n      compare(size_type __pos, size_type __n1, const _CharT* __s,\n\t      size_type __n2) const;\n\n      // Allow basic_stringbuf::__xfer_bufptrs to call _M_length:\n      template<typename, typename, typename> friend class basic_stringbuf;\n    };\n_GLIBCXX_END_NAMESPACE_CXX11\n#else  // !_GLIBCXX_USE_CXX11_ABI\n  // Reference-counted COW string implentation\n\n  /**\n   *  @class basic_string basic_string.h <string>\n   *  @brief  Managing sequences of characters and character-like objects.\n   *\n   *  @ingroup strings\n   *  @ingroup sequences\n   *\n   *  @tparam _CharT  Type of character\n   *  @tparam _Traits  Traits for character type, defaults to\n   *                   char_traits<_CharT>.\n   *  @tparam _Alloc  Allocator type, defaults to allocator<_CharT>.\n   *\n   *  Meets the requirements of a <a href=\"tables.html#65\">container</a>, a\n   *  <a href=\"tables.html#66\">reversible container</a>, and a\n   *  <a href=\"tables.html#67\">sequence</a>.  Of the\n   *  <a href=\"tables.html#68\">optional sequence requirements</a>, only\n   *  @c push_back, @c at, and @c %array access are supported.\n   *\n   *  @doctodo\n   *\n   *\n   *  Documentation?  What's that?\n   *  Nathan Myers <ncm@cantrip.org>.\n   *\n   *  A string looks like this:\n   *\n   *  @code\n   *                                        [_Rep]\n   *                                        _M_length\n   *   [basic_string<char_type>]            _M_capacity\n   *   _M_dataplus                          _M_refcount\n   *   _M_p ---------------->               unnamed array of char_type\n   *  @endcode\n   *\n   *  Where the _M_p points to the first character in the string, and\n   *  you cast it to a pointer-to-_Rep and subtract 1 to get a\n   *  pointer to the header.\n   *\n   *  This approach has the enormous advantage that a string object\n   *  requires only one allocation.  All the ugliness is confined\n   *  within a single %pair of inline functions, which each compile to\n   *  a single @a add instruction: _Rep::_M_data(), and\n   *  string::_M_rep(); and the allocation function which gets a\n   *  block of raw bytes and with room enough and constructs a _Rep\n   *  object at the front.\n   *\n   *  The reason you want _M_data pointing to the character %array and\n   *  not the _Rep is so that the debugger can see the string\n   *  contents. (Probably we should add a non-inline member to get\n   *  the _Rep for the debugger to use, so users can check the actual\n   *  string length.)\n   *\n   *  Note that the _Rep object is a POD so that you can have a\n   *  static <em>empty string</em> _Rep object already @a constructed before\n   *  static constructors have run.  The reference-count encoding is\n   *  chosen so that a 0 indicates one reference, so you never try to\n   *  destroy the empty-string _Rep object.\n   *\n   *  All but the last paragraph is considered pretty conventional\n   *  for a C++ string implementation.\n  */\n  // 21.3  Template class basic_string\n  template<typename _CharT, typename _Traits, typename _Alloc>\n    class basic_string\n    {\n      typedef typename _Alloc::template rebind<_CharT>::other _CharT_alloc_type;\n\n      // Types:\n    public:\n      typedef _Traits\t\t\t\t\t    traits_type;\n      typedef typename _Traits::char_type\t\t    value_type;\n      typedef _Alloc\t\t\t\t\t    allocator_type;\n      typedef typename _CharT_alloc_type::size_type\t    size_type;\n      typedef typename _CharT_alloc_type::difference_type   difference_type;\n      typedef typename _CharT_alloc_type::reference\t    reference;\n      typedef typename _CharT_alloc_type::const_reference   const_reference;\n      typedef typename _CharT_alloc_type::pointer\t    pointer;\n      typedef typename _CharT_alloc_type::const_pointer\t    const_pointer;\n      typedef __gnu_cxx::__normal_iterator<pointer, basic_string>  iterator;\n      typedef __gnu_cxx::__normal_iterator<const_pointer, basic_string>\n                                                            const_iterator;\n      typedef std::reverse_iterator<const_iterator>\tconst_reverse_iterator;\n      typedef std::reverse_iterator<iterator>\t\t    reverse_iterator;\n\n    private:\n      // _Rep: string representation\n      //   Invariants:\n      //   1. String really contains _M_length + 1 characters: due to 21.3.4\n      //      must be kept null-terminated.\n      //   2. _M_capacity >= _M_length\n      //      Allocated memory is always (_M_capacity + 1) * sizeof(_CharT).\n      //   3. _M_refcount has three states:\n      //      -1: leaked, one reference, no ref-copies allowed, non-const.\n      //       0: one reference, non-const.\n      //     n>0: n + 1 references, operations require a lock, const.\n      //   4. All fields==0 is an empty string, given the extra storage\n      //      beyond-the-end for a null terminator; thus, the shared\n      //      empty string representation needs no constructor.\n\n      struct _Rep_base\n      {\n\tsize_type\t\t_M_length;\n\tsize_type\t\t_M_capacity;\n\t_Atomic_word\t\t_M_refcount;\n      };\n\n      struct _Rep : _Rep_base\n      {\n\t// Types:\n\ttypedef typename _Alloc::template rebind<char>::other _Raw_bytes_alloc;\n\n\t// (Public) Data members:\n\n\t// The maximum number of individual char_type elements of an\n\t// individual string is determined by _S_max_size. This is the\n\t// value that will be returned by max_size().  (Whereas npos\n\t// is the maximum number of bytes the allocator can allocate.)\n\t// If one was to divvy up the theoretical largest size string,\n\t// with a terminating character and m _CharT elements, it'd\n\t// look like this:\n\t// npos = sizeof(_Rep) + (m * sizeof(_CharT)) + sizeof(_CharT)\n\t// Solving for m:\n\t// m = ((npos - sizeof(_Rep))/sizeof(CharT)) - 1\n\t// In addition, this implementation quarters this amount.\n\tstatic const size_type\t_S_max_size;\n\tstatic const _CharT\t_S_terminal;\n\n\t// The following storage is init'd to 0 by the linker, resulting\n        // (carefully) in an empty string with one reference.\n        static size_type _S_empty_rep_storage[];\n\n        static _Rep&\n        _S_empty_rep() _GLIBCXX_NOEXCEPT\n        { \n\t  // NB: Mild hack to avoid strict-aliasing warnings.  Note that\n\t  // _S_empty_rep_storage is never modified and the punning should\n\t  // be reasonably safe in this case.\n\t  void* __p = reinterpret_cast<void*>(&_S_empty_rep_storage);\n\t  return *reinterpret_cast<_Rep*>(__p);\n\t}\n\n        bool\n\t_M_is_leaked() const _GLIBCXX_NOEXCEPT\n        {\n#if defined(__GTHREADS)\n          // _M_refcount is mutated concurrently by _M_refcopy/_M_dispose,\n          // so we need to use an atomic load. However, _M_is_leaked\n          // predicate does not change concurrently (i.e. the string is either\n          // leaked or not), so a relaxed load is enough.\n          return __atomic_load_n(&this->_M_refcount, __ATOMIC_RELAXED) < 0;\n#else\n          return this->_M_refcount < 0;\n#endif\n        }\n\n        bool\n\t_M_is_shared() const _GLIBCXX_NOEXCEPT\n\t{\n#if defined(__GTHREADS)\n          // _M_refcount is mutated concurrently by _M_refcopy/_M_dispose,\n          // so we need to use an atomic load. Another thread can drop last\n          // but one reference concurrently with this check, so we need this\n          // load to be acquire to synchronize with release fetch_and_add in\n          // _M_dispose.\n          return __atomic_load_n(&this->_M_refcount, __ATOMIC_ACQUIRE) > 0;\n#else\n          return this->_M_refcount > 0;\n#endif\n        }\n\n        void\n\t_M_set_leaked() _GLIBCXX_NOEXCEPT\n        { this->_M_refcount = -1; }\n\n        void\n\t_M_set_sharable() _GLIBCXX_NOEXCEPT\n        { this->_M_refcount = 0; }\n\n\tvoid\n\t_M_set_length_and_sharable(size_type __n) _GLIBCXX_NOEXCEPT\n\t{\n#if _GLIBCXX_FULLY_DYNAMIC_STRING == 0\n\t  if (__builtin_expect(this != &_S_empty_rep(), false))\n#endif\n\t    {\n\t      this->_M_set_sharable();  // One reference.\n\t      this->_M_length = __n;\n\t      traits_type::assign(this->_M_refdata()[__n], _S_terminal);\n\t      // grrr. (per 21.3.4)\n\t      // You cannot leave those LWG people alone for a second.\n\t    }\n\t}\n\n\t_CharT*\n\t_M_refdata() throw()\n\t{ return reinterpret_cast<_CharT*>(this + 1); }\n\n\t_CharT*\n\t_M_grab(const _Alloc& __alloc1, const _Alloc& __alloc2)\n\t{\n\t  return (!_M_is_leaked() && __alloc1 == __alloc2)\n\t          ? _M_refcopy() : _M_clone(__alloc1);\n\t}\n\n\t// Create & Destroy\n\tstatic _Rep*\n\t_S_create(size_type, size_type, const _Alloc&);\n\n\tvoid\n\t_M_dispose(const _Alloc& __a) _GLIBCXX_NOEXCEPT\n\t{\n#if _GLIBCXX_FULLY_DYNAMIC_STRING == 0\n\t  if (__builtin_expect(this != &_S_empty_rep(), false))\n#endif\n\t    {\n\t      // Be race-detector-friendly.  For more info see bits/c++config.\n\t      _GLIBCXX_SYNCHRONIZATION_HAPPENS_BEFORE(&this->_M_refcount);\n              // Decrement of _M_refcount is acq_rel, because:\n              // - all but last decrements need to release to synchronize with\n              //   the last decrement that will delete the object.\n              // - the last decrement needs to acquire to synchronize with\n              //   all the previous decrements.\n              // - last but one decrement needs to release to synchronize with\n              //   the acquire load in _M_is_shared that will conclude that\n              //   the object is not shared anymore.\n\t      if (__gnu_cxx::__exchange_and_add_dispatch(&this->_M_refcount,\n\t\t\t\t\t\t\t -1) <= 0)\n\t\t{\n\t\t  _GLIBCXX_SYNCHRONIZATION_HAPPENS_AFTER(&this->_M_refcount);\n\t\t  _M_destroy(__a);\n\t\t}\n\t    }\n\t}  // XXX MT\n\n\tvoid\n\t_M_destroy(const _Alloc&) throw();\n\n\t_CharT*\n\t_M_refcopy() throw()\n\t{\n#if _GLIBCXX_FULLY_DYNAMIC_STRING == 0\n\t  if (__builtin_expect(this != &_S_empty_rep(), false))\n#endif\n            __gnu_cxx::__atomic_add_dispatch(&this->_M_refcount, 1);\n\t  return _M_refdata();\n\t}  // XXX MT\n\n\t_CharT*\n\t_M_clone(const _Alloc&, size_type __res = 0);\n      };\n\n      // Use empty-base optimization: http://www.cantrip.org/emptyopt.html\n      struct _Alloc_hider : _Alloc\n      {\n\t_Alloc_hider(_CharT* __dat, const _Alloc& __a) _GLIBCXX_NOEXCEPT\n\t: _Alloc(__a), _M_p(__dat) { }\n\n\t_CharT* _M_p; // The actual data.\n      };\n\n    public:\n      // Data Members (public):\n      // NB: This is an unsigned type, and thus represents the maximum\n      // size that the allocator can hold.\n      ///  Value returned by various member functions when they fail.\n      static const size_type\tnpos = static_cast<size_type>(-1);\n\n    private:\n      // Data Members (private):\n      mutable _Alloc_hider\t_M_dataplus;\n\n      _CharT*\n      _M_data() const _GLIBCXX_NOEXCEPT\n      { return  _M_dataplus._M_p; }\n\n      _CharT*\n      _M_data(_CharT* __p) _GLIBCXX_NOEXCEPT\n      { return (_M_dataplus._M_p = __p); }\n\n      _Rep*\n      _M_rep() const _GLIBCXX_NOEXCEPT\n      { return &((reinterpret_cast<_Rep*> (_M_data()))[-1]); }\n\n      // For the internal use we have functions similar to `begin'/`end'\n      // but they do not call _M_leak.\n      iterator\n      _M_ibegin() const _GLIBCXX_NOEXCEPT\n      { return iterator(_M_data()); }\n\n      iterator\n      _M_iend() const _GLIBCXX_NOEXCEPT\n      { return iterator(_M_data() + this->size()); }\n\n      void\n      _M_leak()    // for use in begin() & non-const op[]\n      {\n\tif (!_M_rep()->_M_is_leaked())\n\t  _M_leak_hard();\n      }\n\n      size_type\n      _M_check(size_type __pos, const char* __s) const\n      {\n\tif (__pos > this->size())\n\t  __throw_out_of_range_fmt(__N(\"%s: __pos (which is %zu) > \"\n\t\t\t\t       \"this->size() (which is %zu)\"),\n\t\t\t\t   __s, __pos, this->size());\n\treturn __pos;\n      }\n\n      void\n      _M_check_length(size_type __n1, size_type __n2, const char* __s) const\n      {\n\tif (this->max_size() - (this->size() - __n1) < __n2)\n\t  __throw_length_error(__N(__s));\n      }\n\n      // NB: _M_limit doesn't check for a bad __pos value.\n      size_type\n      _M_limit(size_type __pos, size_type __off) const _GLIBCXX_NOEXCEPT\n      {\n\tconst bool __testoff =  __off < this->size() - __pos;\n\treturn __testoff ? __off : this->size() - __pos;\n      }\n\n      // True if _Rep and source do not overlap.\n      bool\n      _M_disjunct(const _CharT* __s) const _GLIBCXX_NOEXCEPT\n      {\n\treturn (less<const _CharT*>()(__s, _M_data())\n\t\t|| less<const _CharT*>()(_M_data() + this->size(), __s));\n      }\n\n      // When __n = 1 way faster than the general multichar\n      // traits_type::copy/move/assign.\n      static void\n      _M_copy(_CharT* __d, const _CharT* __s, size_type __n) _GLIBCXX_NOEXCEPT\n      {\n\tif (__n == 1)\n\t  traits_type::assign(*__d, *__s);\n\telse\n\t  traits_type::copy(__d, __s, __n);\n      }\n\n      static void\n      _M_move(_CharT* __d, const _CharT* __s, size_type __n) _GLIBCXX_NOEXCEPT\n      {\n\tif (__n == 1)\n\t  traits_type::assign(*__d, *__s);\n\telse\n\t  traits_type::move(__d, __s, __n);\t  \n      }\n\n      static void\n      _M_assign(_CharT* __d, size_type __n, _CharT __c) _GLIBCXX_NOEXCEPT\n      {\n\tif (__n == 1)\n\t  traits_type::assign(*__d, __c);\n\telse\n\t  traits_type::assign(__d, __n, __c);\t  \n      }\n\n      // _S_copy_chars is a separate template to permit specialization\n      // to optimize for the common case of pointers as iterators.\n      template<class _Iterator>\n        static void\n        _S_copy_chars(_CharT* __p, _Iterator __k1, _Iterator __k2)\n        {\n\t  for (; __k1 != __k2; ++__k1, (void)++__p)\n\t    traits_type::assign(*__p, *__k1); // These types are off.\n\t}\n\n      static void\n      _S_copy_chars(_CharT* __p, iterator __k1, iterator __k2) _GLIBCXX_NOEXCEPT\n      { _S_copy_chars(__p, __k1.base(), __k2.base()); }\n\n      static void\n      _S_copy_chars(_CharT* __p, const_iterator __k1, const_iterator __k2)\n      _GLIBCXX_NOEXCEPT\n      { _S_copy_chars(__p, __k1.base(), __k2.base()); }\n\n      static void\n      _S_copy_chars(_CharT* __p, _CharT* __k1, _CharT* __k2) _GLIBCXX_NOEXCEPT\n      { _M_copy(__p, __k1, __k2 - __k1); }\n\n      static void\n      _S_copy_chars(_CharT* __p, const _CharT* __k1, const _CharT* __k2)\n      _GLIBCXX_NOEXCEPT\n      { _M_copy(__p, __k1, __k2 - __k1); }\n\n      static int\n      _S_compare(size_type __n1, size_type __n2) _GLIBCXX_NOEXCEPT\n      {\n\tconst difference_type __d = difference_type(__n1 - __n2);\n\n\tif (__d > __gnu_cxx::__numeric_traits<int>::__max)\n\t  return __gnu_cxx::__numeric_traits<int>::__max;\n\telse if (__d < __gnu_cxx::__numeric_traits<int>::__min)\n\t  return __gnu_cxx::__numeric_traits<int>::__min;\n\telse\n\t  return int(__d);\n      }\n\n      void\n      _M_mutate(size_type __pos, size_type __len1, size_type __len2);\n\n      void\n      _M_leak_hard();\n\n      static _Rep&\n      _S_empty_rep() _GLIBCXX_NOEXCEPT\n      { return _Rep::_S_empty_rep(); }\n\n#if __cplusplus > 201402L\n      // A helper type for avoiding boiler-plate.\n      typedef basic_string_view<_CharT, _Traits> __sv_type;\n\n      template<typename _Tp, typename _Res>\n\tusing _If_sv = enable_if_t<\n\t  __and_<is_convertible<const _Tp&, __sv_type>,\n\t\t __not_<is_convertible<const _Tp*, const basic_string*>>,\n\t\t __not_<is_convertible<const _Tp&, const _CharT*>>>::value,\n\t  _Res>;\n\n      // Allows an implicit conversion to __sv_type.\n      static __sv_type\n      _S_to_string_view(__sv_type __svt) noexcept\n      { return __svt; }\n\n      // Wraps a string_view by explicit conversion and thus\n      // allows to add an internal constructor that does not\n      // participate in overload resolution when a string_view\n      // is provided.\n      struct __sv_wrapper\n      {\n\texplicit __sv_wrapper(__sv_type __sv) noexcept : _M_sv(__sv) { }\n\t__sv_type _M_sv;\n      };\n#endif\n\n    public:\n      // Construct/copy/destroy:\n      // NB: We overload ctors in some cases instead of using default\n      // arguments, per 17.4.4.4 para. 2 item 2.\n\n      /**\n       *  @brief  Default constructor creates an empty string.\n       */\n      basic_string()\n#if _GLIBCXX_FULLY_DYNAMIC_STRING == 0\n      : _M_dataplus(_S_empty_rep()._M_refdata(), _Alloc()) { }\n#else\n      : _M_dataplus(_S_construct(size_type(), _CharT(), _Alloc()), _Alloc()){ }\n#endif\n\n      /**\n       *  @brief  Construct an empty string using allocator @a a.\n       */\n      explicit\n      basic_string(const _Alloc& __a);\n\n      // NB: per LWG issue 42, semantics different from IS:\n      /**\n       *  @brief  Construct string with copy of value of @a str.\n       *  @param  __str  Source string.\n       */\n      basic_string(const basic_string& __str);\n\n      // _GLIBCXX_RESOLVE_LIB_DEFECTS\n      // 2583. no way to supply an allocator for basic_string(str, pos)\n      /**\n       *  @brief  Construct string as copy of a substring.\n       *  @param  __str  Source string.\n       *  @param  __pos  Index of first character to copy from.\n       *  @param  __a  Allocator to use.\n       */\n      basic_string(const basic_string& __str, size_type __pos,\n\t\t   const _Alloc& __a = _Alloc());\n\n      /**\n       *  @brief  Construct string as copy of a substring.\n       *  @param  __str  Source string.\n       *  @param  __pos  Index of first character to copy from.\n       *  @param  __n  Number of characters to copy.\n       */\n      basic_string(const basic_string& __str, size_type __pos,\n\t\t   size_type __n);\n      /**\n       *  @brief  Construct string as copy of a substring.\n       *  @param  __str  Source string.\n       *  @param  __pos  Index of first character to copy from.\n       *  @param  __n  Number of characters to copy.\n       *  @param  __a  Allocator to use.\n       */\n      basic_string(const basic_string& __str, size_type __pos,\n\t\t   size_type __n, const _Alloc& __a);\n\n      /**\n       *  @brief  Construct string initialized by a character %array.\n       *  @param  __s  Source character %array.\n       *  @param  __n  Number of characters to copy.\n       *  @param  __a  Allocator to use (default is default allocator).\n       *\n       *  NB: @a __s must have at least @a __n characters, &apos;\\\\0&apos;\n       *  has no special meaning.\n       */\n      basic_string(const _CharT* __s, size_type __n,\n\t\t   const _Alloc& __a = _Alloc());\n      /**\n       *  @brief  Construct string as copy of a C string.\n       *  @param  __s  Source C string.\n       *  @param  __a  Allocator to use (default is default allocator).\n       */\n      basic_string(const _CharT* __s, const _Alloc& __a = _Alloc());\n      /**\n       *  @brief  Construct string as multiple characters.\n       *  @param  __n  Number of characters.\n       *  @param  __c  Character to use.\n       *  @param  __a  Allocator to use (default is default allocator).\n       */\n      basic_string(size_type __n, _CharT __c, const _Alloc& __a = _Alloc());\n\n#if __cplusplus >= 201103L\n      /**\n       *  @brief  Move construct string.\n       *  @param  __str  Source string.\n       *\n       *  The newly-created string contains the exact contents of @a __str.\n       *  @a __str is a valid, but unspecified string.\n       **/\n      basic_string(basic_string&& __str)\n#if _GLIBCXX_FULLY_DYNAMIC_STRING == 0\n      noexcept // FIXME C++11: should always be noexcept.\n#endif\n      : _M_dataplus(__str._M_dataplus)\n      {\n#if _GLIBCXX_FULLY_DYNAMIC_STRING == 0\n\t__str._M_data(_S_empty_rep()._M_refdata());\n#else\n\t__str._M_data(_S_construct(size_type(), _CharT(), get_allocator()));\n#endif\n      }\n\n      /**\n       *  @brief  Construct string from an initializer %list.\n       *  @param  __l  std::initializer_list of characters.\n       *  @param  __a  Allocator to use (default is default allocator).\n       */\n      basic_string(initializer_list<_CharT> __l, const _Alloc& __a = _Alloc());\n#endif // C++11\n\n      /**\n       *  @brief  Construct string as copy of a range.\n       *  @param  __beg  Start of range.\n       *  @param  __end  End of range.\n       *  @param  __a  Allocator to use (default is default allocator).\n       */\n      template<class _InputIterator>\n        basic_string(_InputIterator __beg, _InputIterator __end,\n\t\t     const _Alloc& __a = _Alloc());\n\n#if __cplusplus > 201402L\n      /**\n       *  @brief  Construct string from a substring of a string_view.\n       *  @param  __t   Source object convertible to string view.\n       *  @param  __pos The index of the first character to copy from __t.\n       *  @param  __n   The number of characters to copy from __t.\n       *  @param  __a   Allocator to use.\n       */\n      template<typename _Tp, typename = _If_sv<_Tp, void>>\n\tbasic_string(const _Tp& __t, size_type __pos, size_type __n,\n\t\t     const _Alloc& __a = _Alloc())\n\t: basic_string(_S_to_string_view(__t).substr(__pos, __n), __a) { }\n\n      /**\n       *  @brief  Construct string from a string_view.\n       *  @param  __t  Source object convertible to string view.\n       *  @param  __a  Allocator to use (default is default allocator).\n       */\n      template<typename _Tp, typename = _If_sv<_Tp, void>>\n\texplicit\n\tbasic_string(const _Tp& __t, const _Alloc& __a = _Alloc())\n\t: basic_string(__sv_wrapper(_S_to_string_view(__t)), __a) { }\n\n      /**\n       *  @brief  Only internally used: Construct string from a string view\n       *          wrapper.\n       *  @param  __svw  string view wrapper.\n       *  @param  __a  Allocator to use.\n       */\n      explicit\n      basic_string(__sv_wrapper __svw, const _Alloc& __a)\n      : basic_string(__svw._M_sv.data(), __svw._M_sv.size(), __a) { }\n#endif // C++17\n\n      /**\n       *  @brief  Destroy the string instance.\n       */\n      ~basic_string() _GLIBCXX_NOEXCEPT\n      { _M_rep()->_M_dispose(this->get_allocator()); }\n\n      /**\n       *  @brief  Assign the value of @a str to this string.\n       *  @param  __str  Source string.\n       */\n      basic_string&\n      operator=(const basic_string& __str) \n      { return this->assign(__str); }\n\n      /**\n       *  @brief  Copy contents of @a s into this string.\n       *  @param  __s  Source null-terminated string.\n       */\n      basic_string&\n      operator=(const _CharT* __s) \n      { return this->assign(__s); }\n\n      /**\n       *  @brief  Set value to string of length 1.\n       *  @param  __c  Source character.\n       *\n       *  Assigning to a character makes this string length 1 and\n       *  (*this)[0] == @a c.\n       */\n      basic_string&\n      operator=(_CharT __c) \n      { \n\tthis->assign(1, __c); \n\treturn *this;\n      }\n\n#if __cplusplus >= 201103L\n      /**\n       *  @brief  Move assign the value of @a str to this string.\n       *  @param  __str  Source string.\n       *\n       *  The contents of @a str are moved into this string (without copying).\n       *  @a str is a valid, but unspecified string.\n       **/\n      // PR 58265, this should be noexcept.\n      basic_string&\n      operator=(basic_string&& __str)\n      {\n\t// NB: DR 1204.\n\tthis->swap(__str);\n\treturn *this;\n      }\n\n      /**\n       *  @brief  Set value to string constructed from initializer %list.\n       *  @param  __l  std::initializer_list.\n       */\n      basic_string&\n      operator=(initializer_list<_CharT> __l)\n      {\n\tthis->assign(__l.begin(), __l.size());\n\treturn *this;\n      }\n#endif // C++11\n\n#if __cplusplus > 201402L\n      /**\n       *  @brief  Set value to string constructed from a string_view.\n       *  @param  __svt An object convertible to  string_view.\n       */\n      template<typename _Tp>\n\t_If_sv<_Tp, basic_string&>\n\toperator=(const _Tp& __svt)\n\t{ return this->assign(__svt); }\n\n      /**\n       *  @brief  Convert to a string_view.\n       *  @return A string_view.\n       */\n      operator __sv_type() const noexcept\n      { return __sv_type(data(), size()); }\n#endif // C++17\n\n      // Iterators:\n      /**\n       *  Returns a read/write iterator that points to the first character in\n       *  the %string.  Unshares the string.\n       */\n      iterator\n      begin() // FIXME C++11: should be noexcept.\n      {\n\t_M_leak();\n\treturn iterator(_M_data());\n      }\n\n      /**\n       *  Returns a read-only (constant) iterator that points to the first\n       *  character in the %string.\n       */\n      const_iterator\n      begin() const _GLIBCXX_NOEXCEPT\n      { return const_iterator(_M_data()); }\n\n      /**\n       *  Returns a read/write iterator that points one past the last\n       *  character in the %string.  Unshares the string.\n       */\n      iterator\n      end() // FIXME C++11: should be noexcept.\n      {\n\t_M_leak();\n\treturn iterator(_M_data() + this->size());\n      }\n\n      /**\n       *  Returns a read-only (constant) iterator that points one past the\n       *  last character in the %string.\n       */\n      const_iterator\n      end() const _GLIBCXX_NOEXCEPT\n      { return const_iterator(_M_data() + this->size()); }\n\n      /**\n       *  Returns a read/write reverse iterator that points to the last\n       *  character in the %string.  Iteration is done in reverse element\n       *  order.  Unshares the string.\n       */\n      reverse_iterator\n      rbegin() // FIXME C++11: should be noexcept.\n      { return reverse_iterator(this->end()); }\n\n      /**\n       *  Returns a read-only (constant) reverse iterator that points\n       *  to the last character in the %string.  Iteration is done in\n       *  reverse element order.\n       */\n      const_reverse_iterator\n      rbegin() const _GLIBCXX_NOEXCEPT\n      { return const_reverse_iterator(this->end()); }\n\n      /**\n       *  Returns a read/write reverse iterator that points to one before the\n       *  first character in the %string.  Iteration is done in reverse\n       *  element order.  Unshares the string.\n       */\n      reverse_iterator\n      rend() // FIXME C++11: should be noexcept.\n      { return reverse_iterator(this->begin()); }\n\n      /**\n       *  Returns a read-only (constant) reverse iterator that points\n       *  to one before the first character in the %string.  Iteration\n       *  is done in reverse element order.\n       */\n      const_reverse_iterator\n      rend() const _GLIBCXX_NOEXCEPT\n      { return const_reverse_iterator(this->begin()); }\n\n#if __cplusplus >= 201103L\n      /**\n       *  Returns a read-only (constant) iterator that points to the first\n       *  character in the %string.\n       */\n      const_iterator\n      cbegin() const noexcept\n      { return const_iterator(this->_M_data()); }\n\n      /**\n       *  Returns a read-only (constant) iterator that points one past the\n       *  last character in the %string.\n       */\n      const_iterator\n      cend() const noexcept\n      { return const_iterator(this->_M_data() + this->size()); }\n\n      /**\n       *  Returns a read-only (constant) reverse iterator that points\n       *  to the last character in the %string.  Iteration is done in\n       *  reverse element order.\n       */\n      const_reverse_iterator\n      crbegin() const noexcept\n      { return const_reverse_iterator(this->end()); }\n\n      /**\n       *  Returns a read-only (constant) reverse iterator that points\n       *  to one before the first character in the %string.  Iteration\n       *  is done in reverse element order.\n       */\n      const_reverse_iterator\n      crend() const noexcept\n      { return const_reverse_iterator(this->begin()); }\n#endif\n\n    public:\n      // Capacity:\n      ///  Returns the number of characters in the string, not including any\n      ///  null-termination.\n      size_type\n      size() const _GLIBCXX_NOEXCEPT\n      { return _M_rep()->_M_length; }\n\n      ///  Returns the number of characters in the string, not including any\n      ///  null-termination.\n      size_type\n      length() const _GLIBCXX_NOEXCEPT\n      { return _M_rep()->_M_length; }\n\n      ///  Returns the size() of the largest possible %string.\n      size_type\n      max_size() const _GLIBCXX_NOEXCEPT\n      { return _Rep::_S_max_size; }\n\n      /**\n       *  @brief  Resizes the %string to the specified number of characters.\n       *  @param  __n  Number of characters the %string should contain.\n       *  @param  __c  Character to fill any new elements.\n       *\n       *  This function will %resize the %string to the specified\n       *  number of characters.  If the number is smaller than the\n       *  %string's current size the %string is truncated, otherwise\n       *  the %string is extended and new elements are %set to @a __c.\n       */\n      void\n      resize(size_type __n, _CharT __c);\n\n      /**\n       *  @brief  Resizes the %string to the specified number of characters.\n       *  @param  __n  Number of characters the %string should contain.\n       *\n       *  This function will resize the %string to the specified length.  If\n       *  the new size is smaller than the %string's current size the %string\n       *  is truncated, otherwise the %string is extended and new characters\n       *  are default-constructed.  For basic types such as char, this means\n       *  setting them to 0.\n       */\n      void\n      resize(size_type __n)\n      { this->resize(__n, _CharT()); }\n\n#if __cplusplus >= 201103L\n      ///  A non-binding request to reduce capacity() to size().\n      void\n      shrink_to_fit() _GLIBCXX_NOEXCEPT\n      {\n#if __cpp_exceptions\n\tif (capacity() > size())\n\t  {\n\t    try\n\t      { reserve(0); }\n\t    catch(...)\n\t      { }\n\t  }\n#endif\n      }\n#endif\n\n      /**\n       *  Returns the total number of characters that the %string can hold\n       *  before needing to allocate more memory.\n       */\n      size_type\n      capacity() const _GLIBCXX_NOEXCEPT\n      { return _M_rep()->_M_capacity; }\n\n      /**\n       *  @brief  Attempt to preallocate enough memory for specified number of\n       *          characters.\n       *  @param  __res_arg  Number of characters required.\n       *  @throw  std::length_error  If @a __res_arg exceeds @c max_size().\n       *\n       *  This function attempts to reserve enough memory for the\n       *  %string to hold the specified number of characters.  If the\n       *  number requested is more than max_size(), length_error is\n       *  thrown.\n       *\n       *  The advantage of this function is that if optimal code is a\n       *  necessity and the user can determine the string length that will be\n       *  required, the user can reserve the memory in %advance, and thus\n       *  prevent a possible reallocation of memory and copying of %string\n       *  data.\n       */\n      void\n      reserve(size_type __res_arg = 0);\n\n      /**\n       *  Erases the string, making it empty.\n       */\n#if _GLIBCXX_FULLY_DYNAMIC_STRING == 0\n      void\n      clear() _GLIBCXX_NOEXCEPT\n      {\n\tif (_M_rep()->_M_is_shared())\n\t  {\n\t    _M_rep()->_M_dispose(this->get_allocator());\n\t    _M_data(_S_empty_rep()._M_refdata());\n\t  }\n\telse\n\t  _M_rep()->_M_set_length_and_sharable(0);\n      }\n#else\n      // PR 56166: this should not throw.\n      void\n      clear()\n      { _M_mutate(0, this->size(), 0); }\n#endif\n\n      /**\n       *  Returns true if the %string is empty.  Equivalent to \n       *  <code>*this == \"\"</code>.\n       */\n      bool\n      empty() const _GLIBCXX_NOEXCEPT\n      { return this->size() == 0; }\n\n      // Element access:\n      /**\n       *  @brief  Subscript access to the data contained in the %string.\n       *  @param  __pos  The index of the character to access.\n       *  @return  Read-only (constant) reference to the character.\n       *\n       *  This operator allows for easy, array-style, data access.\n       *  Note that data access with this operator is unchecked and\n       *  out_of_range lookups are not defined. (For checked lookups\n       *  see at().)\n       */\n      const_reference\n      operator[] (size_type __pos) const _GLIBCXX_NOEXCEPT\n      {\n\t__glibcxx_assert(__pos <= size());\n\treturn _M_data()[__pos];\n      }\n\n      /**\n       *  @brief  Subscript access to the data contained in the %string.\n       *  @param  __pos  The index of the character to access.\n       *  @return  Read/write reference to the character.\n       *\n       *  This operator allows for easy, array-style, data access.\n       *  Note that data access with this operator is unchecked and\n       *  out_of_range lookups are not defined. (For checked lookups\n       *  see at().)  Unshares the string.\n       */\n      reference\n      operator[](size_type __pos)\n      {\n        // Allow pos == size() both in C++98 mode, as v3 extension,\n\t// and in C++11 mode.\n\t__glibcxx_assert(__pos <= size());\n        // In pedantic mode be strict in C++98 mode.\n\t_GLIBCXX_DEBUG_PEDASSERT(__cplusplus >= 201103L || __pos < size());\n\t_M_leak();\n\treturn _M_data()[__pos];\n      }\n\n      /**\n       *  @brief  Provides access to the data contained in the %string.\n       *  @param __n The index of the character to access.\n       *  @return  Read-only (const) reference to the character.\n       *  @throw  std::out_of_range  If @a n is an invalid index.\n       *\n       *  This function provides for safer data access.  The parameter is\n       *  first checked that it is in the range of the string.  The function\n       *  throws out_of_range if the check fails.\n       */\n      const_reference\n      at(size_type __n) const\n      {\n\tif (__n >= this->size())\n\t  __throw_out_of_range_fmt(__N(\"basic_string::at: __n \"\n\t\t\t\t       \"(which is %zu) >= this->size() \"\n\t\t\t\t       \"(which is %zu)\"),\n\t\t\t\t   __n, this->size());\n\treturn _M_data()[__n];\n      }\n\n      /**\n       *  @brief  Provides access to the data contained in the %string.\n       *  @param __n The index of the character to access.\n       *  @return  Read/write reference to the character.\n       *  @throw  std::out_of_range  If @a n is an invalid index.\n       *\n       *  This function provides for safer data access.  The parameter is\n       *  first checked that it is in the range of the string.  The function\n       *  throws out_of_range if the check fails.  Success results in\n       *  unsharing the string.\n       */\n      reference\n      at(size_type __n)\n      {\n\tif (__n >= size())\n\t  __throw_out_of_range_fmt(__N(\"basic_string::at: __n \"\n\t\t\t\t       \"(which is %zu) >= this->size() \"\n\t\t\t\t       \"(which is %zu)\"),\n\t\t\t\t   __n, this->size());\n\t_M_leak();\n\treturn _M_data()[__n];\n      }\n\n#if __cplusplus >= 201103L\n      /**\n       *  Returns a read/write reference to the data at the first\n       *  element of the %string.\n       */\n      reference\n      front()\n      {\n\t__glibcxx_assert(!empty());\n\treturn operator[](0);\n      }\n\n      /**\n       *  Returns a read-only (constant) reference to the data at the first\n       *  element of the %string.\n       */\n      const_reference\n      front() const noexcept\n      {\n\t__glibcxx_assert(!empty());\n\treturn operator[](0);\n      }\n\n      /**\n       *  Returns a read/write reference to the data at the last\n       *  element of the %string.\n       */\n      reference\n      back()\n      {\n\t__glibcxx_assert(!empty());\n\treturn operator[](this->size() - 1);\n      }\n\n      /**\n       *  Returns a read-only (constant) reference to the data at the\n       *  last element of the %string.\n       */\n      const_reference\n      back() const noexcept\n      {\n\t__glibcxx_assert(!empty());\n\treturn operator[](this->size() - 1);\n      }\n#endif\n\n      // Modifiers:\n      /**\n       *  @brief  Append a string to this string.\n       *  @param __str  The string to append.\n       *  @return  Reference to this string.\n       */\n      basic_string&\n      operator+=(const basic_string& __str)\n      { return this->append(__str); }\n\n      /**\n       *  @brief  Append a C string.\n       *  @param __s  The C string to append.\n       *  @return  Reference to this string.\n       */\n      basic_string&\n      operator+=(const _CharT* __s)\n      { return this->append(__s); }\n\n      /**\n       *  @brief  Append a character.\n       *  @param __c  The character to append.\n       *  @return  Reference to this string.\n       */\n      basic_string&\n      operator+=(_CharT __c)\n      { \n\tthis->push_back(__c);\n\treturn *this;\n      }\n\n#if __cplusplus >= 201103L\n      /**\n       *  @brief  Append an initializer_list of characters.\n       *  @param __l  The initializer_list of characters to be appended.\n       *  @return  Reference to this string.\n       */\n      basic_string&\n      operator+=(initializer_list<_CharT> __l)\n      { return this->append(__l.begin(), __l.size()); }\n#endif // C++11\n\n#if __cplusplus > 201402L\n      /**\n       *  @brief  Append a string_view.\n       *  @param __svt The object convertible to string_view to be appended.\n       *  @return  Reference to this string.\n       */\n      template<typename _Tp>\n\t_If_sv<_Tp, basic_string&>\n\toperator+=(const _Tp& __svt)\n\t{ return this->append(__svt); }\n#endif // C++17\n\n      /**\n       *  @brief  Append a string to this string.\n       *  @param __str  The string to append.\n       *  @return  Reference to this string.\n       */\n      basic_string&\n      append(const basic_string& __str);\n\n      /**\n       *  @brief  Append a substring.\n       *  @param __str  The string to append.\n       *  @param __pos  Index of the first character of str to append.\n       *  @param __n  The number of characters to append.\n       *  @return  Reference to this string.\n       *  @throw  std::out_of_range if @a __pos is not a valid index.\n       *\n       *  This function appends @a __n characters from @a __str\n       *  starting at @a __pos to this string.  If @a __n is is larger\n       *  than the number of available characters in @a __str, the\n       *  remainder of @a __str is appended.\n       */\n      basic_string&\n      append(const basic_string& __str, size_type __pos, size_type __n = npos);\n\n      /**\n       *  @brief  Append a C substring.\n       *  @param __s  The C string to append.\n       *  @param __n  The number of characters to append.\n       *  @return  Reference to this string.\n       */\n      basic_string&\n      append(const _CharT* __s, size_type __n);\n\n      /**\n       *  @brief  Append a C string.\n       *  @param __s  The C string to append.\n       *  @return  Reference to this string.\n       */\n      basic_string&\n      append(const _CharT* __s)\n      {\n\t__glibcxx_requires_string(__s);\n\treturn this->append(__s, traits_type::length(__s));\n      }\n\n      /**\n       *  @brief  Append multiple characters.\n       *  @param __n  The number of characters to append.\n       *  @param __c  The character to use.\n       *  @return  Reference to this string.\n       *\n       *  Appends __n copies of __c to this string.\n       */\n      basic_string&\n      append(size_type __n, _CharT __c);\n\n#if __cplusplus >= 201103L\n      /**\n       *  @brief  Append an initializer_list of characters.\n       *  @param __l  The initializer_list of characters to append.\n       *  @return  Reference to this string.\n       */\n      basic_string&\n      append(initializer_list<_CharT> __l)\n      { return this->append(__l.begin(), __l.size()); }\n#endif // C++11\n\n      /**\n       *  @brief  Append a range of characters.\n       *  @param __first  Iterator referencing the first character to append.\n       *  @param __last  Iterator marking the end of the range.\n       *  @return  Reference to this string.\n       *\n       *  Appends characters in the range [__first,__last) to this string.\n       */\n      template<class _InputIterator>\n        basic_string&\n        append(_InputIterator __first, _InputIterator __last)\n        { return this->replace(_M_iend(), _M_iend(), __first, __last); }\n\n#if __cplusplus > 201402L\n      /**\n       *  @brief  Append a string_view.\n       *  @param __svt The object convertible to string_view to be appended.\n       *  @return  Reference to this string.\n       */\n      template<typename _Tp>\n\t_If_sv<_Tp, basic_string&>\n\tappend(const _Tp& __svt)\n\t{\n\t  __sv_type __sv = __svt;\n\t  return this->append(__sv.data(), __sv.size());\n\t}\n\n      /**\n       *  @brief  Append a range of characters from a string_view.\n       *  @param __svt The object convertible to string_view to be appended\n       *               from.\n       *  @param __pos The position in the string_view to append from.\n       *  @param __n   The number of characters to append from the string_view.\n       *  @return  Reference to this string.\n       */\n      template<typename _Tp>\n        _If_sv<_Tp, basic_string&>\n\tappend(const _Tp& __svt, size_type __pos, size_type __n = npos)\n\t{\n\t  __sv_type __sv = __svt;\n\t  return append(__sv.data()\n\t\t\t+ __sv._M_check(__pos, \"basic_string::append\"),\n\t\t\t__sv._M_limit(__pos, __n));\n\t}\n#endif // C++17\n\n      /**\n       *  @brief  Append a single character.\n       *  @param __c  Character to append.\n       */\n      void\n      push_back(_CharT __c)\n      { \n\tconst size_type __len = 1 + this->size();\n\tif (__len > this->capacity() || _M_rep()->_M_is_shared())\n\t  this->reserve(__len);\n\ttraits_type::assign(_M_data()[this->size()], __c);\n\t_M_rep()->_M_set_length_and_sharable(__len);\n      }\n\n      /**\n       *  @brief  Set value to contents of another string.\n       *  @param  __str  Source string to use.\n       *  @return  Reference to this string.\n       */\n      basic_string&\n      assign(const basic_string& __str);\n\n#if __cplusplus >= 201103L\n      /**\n       *  @brief  Set value to contents of another string.\n       *  @param  __str  Source string to use.\n       *  @return  Reference to this string.\n       *\n       *  This function sets this string to the exact contents of @a __str.\n       *  @a __str is a valid, but unspecified string.\n       */\n      // PR 58265, this should be noexcept.\n      basic_string&\n      assign(basic_string&& __str)\n      {\n\tthis->swap(__str);\n\treturn *this;\n      }\n#endif // C++11\n\n      /**\n       *  @brief  Set value to a substring of a string.\n       *  @param __str  The string to use.\n       *  @param __pos  Index of the first character of str.\n       *  @param __n  Number of characters to use.\n       *  @return  Reference to this string.\n       *  @throw  std::out_of_range if @a pos is not a valid index.\n       *\n       *  This function sets this string to the substring of @a __str\n       *  consisting of @a __n characters at @a __pos.  If @a __n is\n       *  is larger than the number of available characters in @a\n       *  __str, the remainder of @a __str is used.\n       */\n      basic_string&\n      assign(const basic_string& __str, size_type __pos, size_type __n = npos)\n      { return this->assign(__str._M_data()\n\t\t\t    + __str._M_check(__pos, \"basic_string::assign\"),\n\t\t\t    __str._M_limit(__pos, __n)); }\n\n      /**\n       *  @brief  Set value to a C substring.\n       *  @param __s  The C string to use.\n       *  @param __n  Number of characters to use.\n       *  @return  Reference to this string.\n       *\n       *  This function sets the value of this string to the first @a __n\n       *  characters of @a __s.  If @a __n is is larger than the number of\n       *  available characters in @a __s, the remainder of @a __s is used.\n       */\n      basic_string&\n      assign(const _CharT* __s, size_type __n);\n\n      /**\n       *  @brief  Set value to contents of a C string.\n       *  @param __s  The C string to use.\n       *  @return  Reference to this string.\n       *\n       *  This function sets the value of this string to the value of @a __s.\n       *  The data is copied, so there is no dependence on @a __s once the\n       *  function returns.\n       */\n      basic_string&\n      assign(const _CharT* __s)\n      {\n\t__glibcxx_requires_string(__s);\n\treturn this->assign(__s, traits_type::length(__s));\n      }\n\n      /**\n       *  @brief  Set value to multiple characters.\n       *  @param __n  Length of the resulting string.\n       *  @param __c  The character to use.\n       *  @return  Reference to this string.\n       *\n       *  This function sets the value of this string to @a __n copies of\n       *  character @a __c.\n       */\n      basic_string&\n      assign(size_type __n, _CharT __c)\n      { return _M_replace_aux(size_type(0), this->size(), __n, __c); }\n\n      /**\n       *  @brief  Set value to a range of characters.\n       *  @param __first  Iterator referencing the first character to append.\n       *  @param __last  Iterator marking the end of the range.\n       *  @return  Reference to this string.\n       *\n       *  Sets value of string to characters in the range [__first,__last).\n      */\n      template<class _InputIterator>\n        basic_string&\n        assign(_InputIterator __first, _InputIterator __last)\n        { return this->replace(_M_ibegin(), _M_iend(), __first, __last); }\n\n#if __cplusplus >= 201103L\n      /**\n       *  @brief  Set value to an initializer_list of characters.\n       *  @param __l  The initializer_list of characters to assign.\n       *  @return  Reference to this string.\n       */\n      basic_string&\n      assign(initializer_list<_CharT> __l)\n      { return this->assign(__l.begin(), __l.size()); }\n#endif // C++11\n\n#if __cplusplus > 201402L\n      /**\n       *  @brief  Set value from a string_view.\n       *  @param __svt The source object convertible to string_view.\n       *  @return  Reference to this string.\n       */\n      template<typename _Tp>\n\t_If_sv<_Tp, basic_string&>\n\tassign(const _Tp& __svt)\n\t{\n\t  __sv_type __sv = __svt;\n\t  return this->assign(__sv.data(), __sv.size());\n\t}\n\n      /**\n       *  @brief  Set value from a range of characters in a string_view.\n       *  @param __svt  The source object convertible to string_view.\n       *  @param __pos  The position in the string_view to assign from.\n       *  @param __n  The number of characters to assign.\n       *  @return  Reference to this string.\n       */\n      template<typename _Tp>\n        _If_sv<_Tp, basic_string&>\n        assign(const _Tp& __svt, size_type __pos, size_type __n = npos)\n\t{\n\t  __sv_type __sv = __svt;\n\t  return assign(__sv.data()\n\t\t\t+ __sv._M_check(__pos, \"basic_string::assign\"),\n\t\t\t__sv._M_limit(__pos, __n));\n\t}\n#endif // C++17\n\n      /**\n       *  @brief  Insert multiple characters.\n       *  @param __p  Iterator referencing location in string to insert at.\n       *  @param __n  Number of characters to insert\n       *  @param __c  The character to insert.\n       *  @throw  std::length_error  If new length exceeds @c max_size().\n       *\n       *  Inserts @a __n copies of character @a __c starting at the\n       *  position referenced by iterator @a __p.  If adding\n       *  characters causes the length to exceed max_size(),\n       *  length_error is thrown.  The value of the string doesn't\n       *  change if an error is thrown.\n      */\n      void\n      insert(iterator __p, size_type __n, _CharT __c)\n      {\tthis->replace(__p, __p, __n, __c);  }\n\n      /**\n       *  @brief  Insert a range of characters.\n       *  @param __p  Iterator referencing location in string to insert at.\n       *  @param __beg  Start of range.\n       *  @param __end  End of range.\n       *  @throw  std::length_error  If new length exceeds @c max_size().\n       *\n       *  Inserts characters in range [__beg,__end).  If adding\n       *  characters causes the length to exceed max_size(),\n       *  length_error is thrown.  The value of the string doesn't\n       *  change if an error is thrown.\n      */\n      template<class _InputIterator>\n        void\n        insert(iterator __p, _InputIterator __beg, _InputIterator __end)\n        { this->replace(__p, __p, __beg, __end); }\n\n#if __cplusplus >= 201103L\n      /**\n       *  @brief  Insert an initializer_list of characters.\n       *  @param __p  Iterator referencing location in string to insert at.\n       *  @param __l  The initializer_list of characters to insert.\n       *  @throw  std::length_error  If new length exceeds @c max_size().\n       */\n      void\n      insert(iterator __p, initializer_list<_CharT> __l)\n      {\n\t_GLIBCXX_DEBUG_PEDASSERT(__p >= _M_ibegin() && __p <= _M_iend());\n\tthis->insert(__p - _M_ibegin(), __l.begin(), __l.size());\n      }\n#endif // C++11\n\n      /**\n       *  @brief  Insert value of a string.\n       *  @param __pos1  Iterator referencing location in string to insert at.\n       *  @param __str  The string to insert.\n       *  @return  Reference to this string.\n       *  @throw  std::length_error  If new length exceeds @c max_size().\n       *\n       *  Inserts value of @a __str starting at @a __pos1.  If adding\n       *  characters causes the length to exceed max_size(),\n       *  length_error is thrown.  The value of the string doesn't\n       *  change if an error is thrown.\n      */\n      basic_string&\n      insert(size_type __pos1, const basic_string& __str)\n      { return this->insert(__pos1, __str, size_type(0), __str.size()); }\n\n      /**\n       *  @brief  Insert a substring.\n       *  @param __pos1  Iterator referencing location in string to insert at.\n       *  @param __str  The string to insert.\n       *  @param __pos2  Start of characters in str to insert.\n       *  @param __n  Number of characters to insert.\n       *  @return  Reference to this string.\n       *  @throw  std::length_error  If new length exceeds @c max_size().\n       *  @throw  std::out_of_range  If @a pos1 > size() or\n       *  @a __pos2 > @a str.size().\n       *\n       *  Starting at @a pos1, insert @a __n character of @a __str\n       *  beginning with @a __pos2.  If adding characters causes the\n       *  length to exceed max_size(), length_error is thrown.  If @a\n       *  __pos1 is beyond the end of this string or @a __pos2 is\n       *  beyond the end of @a __str, out_of_range is thrown.  The\n       *  value of the string doesn't change if an error is thrown.\n      */\n      basic_string&\n      insert(size_type __pos1, const basic_string& __str,\n\t     size_type __pos2, size_type __n = npos)\n      { return this->insert(__pos1, __str._M_data()\n\t\t\t    + __str._M_check(__pos2, \"basic_string::insert\"),\n\t\t\t    __str._M_limit(__pos2, __n)); }\n\n      /**\n       *  @brief  Insert a C substring.\n       *  @param __pos  Iterator referencing location in string to insert at.\n       *  @param __s  The C string to insert.\n       *  @param __n  The number of characters to insert.\n       *  @return  Reference to this string.\n       *  @throw  std::length_error  If new length exceeds @c max_size().\n       *  @throw  std::out_of_range  If @a __pos is beyond the end of this\n       *  string.\n       *\n       *  Inserts the first @a __n characters of @a __s starting at @a\n       *  __pos.  If adding characters causes the length to exceed\n       *  max_size(), length_error is thrown.  If @a __pos is beyond\n       *  end(), out_of_range is thrown.  The value of the string\n       *  doesn't change if an error is thrown.\n      */\n      basic_string&\n      insert(size_type __pos, const _CharT* __s, size_type __n);\n\n      /**\n       *  @brief  Insert a C string.\n       *  @param __pos  Iterator referencing location in string to insert at.\n       *  @param __s  The C string to insert.\n       *  @return  Reference to this string.\n       *  @throw  std::length_error  If new length exceeds @c max_size().\n       *  @throw  std::out_of_range  If @a pos is beyond the end of this\n       *  string.\n       *\n       *  Inserts the first @a n characters of @a __s starting at @a __pos.  If\n       *  adding characters causes the length to exceed max_size(),\n       *  length_error is thrown.  If @a __pos is beyond end(), out_of_range is\n       *  thrown.  The value of the string doesn't change if an error is\n       *  thrown.\n      */\n      basic_string&\n      insert(size_type __pos, const _CharT* __s)\n      {\n\t__glibcxx_requires_string(__s);\n\treturn this->insert(__pos, __s, traits_type::length(__s));\n      }\n\n      /**\n       *  @brief  Insert multiple characters.\n       *  @param __pos  Index in string to insert at.\n       *  @param __n  Number of characters to insert\n       *  @param __c  The character to insert.\n       *  @return  Reference to this string.\n       *  @throw  std::length_error  If new length exceeds @c max_size().\n       *  @throw  std::out_of_range  If @a __pos is beyond the end of this\n       *  string.\n       *\n       *  Inserts @a __n copies of character @a __c starting at index\n       *  @a __pos.  If adding characters causes the length to exceed\n       *  max_size(), length_error is thrown.  If @a __pos > length(),\n       *  out_of_range is thrown.  The value of the string doesn't\n       *  change if an error is thrown.\n      */\n      basic_string&\n      insert(size_type __pos, size_type __n, _CharT __c)\n      { return _M_replace_aux(_M_check(__pos, \"basic_string::insert\"),\n\t\t\t      size_type(0), __n, __c); }\n\n      /**\n       *  @brief  Insert one character.\n       *  @param __p  Iterator referencing position in string to insert at.\n       *  @param __c  The character to insert.\n       *  @return  Iterator referencing newly inserted char.\n       *  @throw  std::length_error  If new length exceeds @c max_size().\n       *\n       *  Inserts character @a __c at position referenced by @a __p.\n       *  If adding character causes the length to exceed max_size(),\n       *  length_error is thrown.  If @a __p is beyond end of string,\n       *  out_of_range is thrown.  The value of the string doesn't\n       *  change if an error is thrown.\n      */\n      iterator\n      insert(iterator __p, _CharT __c)\n      {\n\t_GLIBCXX_DEBUG_PEDASSERT(__p >= _M_ibegin() && __p <= _M_iend());\n\tconst size_type __pos = __p - _M_ibegin();\n\t_M_replace_aux(__pos, size_type(0), size_type(1), __c);\n\t_M_rep()->_M_set_leaked();\n\treturn iterator(_M_data() + __pos);\n      }\n\n#if __cplusplus > 201402L\n      /**\n       *  @brief  Insert a string_view.\n       *  @param __pos  Iterator referencing position in string to insert at.\n       *  @param __svt  The object convertible to string_view to insert.\n       *  @return  Reference to this string.\n      */\n      template<typename _Tp>\n\t_If_sv<_Tp, basic_string&>\n\tinsert(size_type __pos, const _Tp& __svt)\n\t{\n\t  __sv_type __sv = __svt;\n\t  return this->insert(__pos, __sv.data(), __sv.size());\n\t}\n\n      /**\n       *  @brief  Insert a string_view.\n       *  @param __pos  Iterator referencing position in string to insert at.\n       *  @param __svt  The object convertible to string_view to insert from.\n       *  @param __pos  Iterator referencing position in string_view to insert\n       *  from.\n       *  @param __n    The number of characters to insert.\n       *  @return  Reference to this string.\n      */\n      template<typename _Tp>\n        _If_sv<_Tp, basic_string&>\n        insert(size_type __pos1, const _Tp& __svt,\n\t       size_type __pos2, size_type __n = npos)\n\t{\n\t  __sv_type __sv = __svt;\n\t  return this->replace(__pos1, size_type(0), __sv.data()\n\t\t\t       + __sv._M_check(__pos2, \"basic_string::insert\"),\n\t\t\t       __sv._M_limit(__pos2, __n));\n\t}\n#endif // C++17\n\n      /**\n       *  @brief  Remove characters.\n       *  @param __pos  Index of first character to remove (default 0).\n       *  @param __n  Number of characters to remove (default remainder).\n       *  @return  Reference to this string.\n       *  @throw  std::out_of_range  If @a pos is beyond the end of this\n       *  string.\n       *\n       *  Removes @a __n characters from this string starting at @a\n       *  __pos.  The length of the string is reduced by @a __n.  If\n       *  there are < @a __n characters to remove, the remainder of\n       *  the string is truncated.  If @a __p is beyond end of string,\n       *  out_of_range is thrown.  The value of the string doesn't\n       *  change if an error is thrown.\n      */\n      basic_string&\n      erase(size_type __pos = 0, size_type __n = npos)\n      { \n\t_M_mutate(_M_check(__pos, \"basic_string::erase\"),\n\t\t  _M_limit(__pos, __n), size_type(0));\n\treturn *this;\n      }\n\n      /**\n       *  @brief  Remove one character.\n       *  @param __position  Iterator referencing the character to remove.\n       *  @return  iterator referencing same location after removal.\n       *\n       *  Removes the character at @a __position from this string. The value\n       *  of the string doesn't change if an error is thrown.\n      */\n      iterator\n      erase(iterator __position)\n      {\n\t_GLIBCXX_DEBUG_PEDASSERT(__position >= _M_ibegin()\n\t\t\t\t && __position < _M_iend());\n\tconst size_type __pos = __position - _M_ibegin();\n\t_M_mutate(__pos, size_type(1), size_type(0));\n\t_M_rep()->_M_set_leaked();\n\treturn iterator(_M_data() + __pos);\n      }\n\n      /**\n       *  @brief  Remove a range of characters.\n       *  @param __first  Iterator referencing the first character to remove.\n       *  @param __last  Iterator referencing the end of the range.\n       *  @return  Iterator referencing location of first after removal.\n       *\n       *  Removes the characters in the range [first,last) from this string.\n       *  The value of the string doesn't change if an error is thrown.\n      */\n      iterator\n      erase(iterator __first, iterator __last);\n \n#if __cplusplus >= 201103L\n      /**\n       *  @brief  Remove the last character.\n       *\n       *  The string must be non-empty.\n       */\n      void\n      pop_back() // FIXME C++11: should be noexcept.\n      {\n\t__glibcxx_assert(!empty());\n\terase(size() - 1, 1);\n      }\n#endif // C++11\n\n      /**\n       *  @brief  Replace characters with value from another string.\n       *  @param __pos  Index of first character to replace.\n       *  @param __n  Number of characters to be replaced.\n       *  @param __str  String to insert.\n       *  @return  Reference to this string.\n       *  @throw  std::out_of_range  If @a pos is beyond the end of this\n       *  string.\n       *  @throw  std::length_error  If new length exceeds @c max_size().\n       *\n       *  Removes the characters in the range [__pos,__pos+__n) from\n       *  this string.  In place, the value of @a __str is inserted.\n       *  If @a __pos is beyond end of string, out_of_range is thrown.\n       *  If the length of the result exceeds max_size(), length_error\n       *  is thrown.  The value of the string doesn't change if an\n       *  error is thrown.\n      */\n      basic_string&\n      replace(size_type __pos, size_type __n, const basic_string& __str)\n      { return this->replace(__pos, __n, __str._M_data(), __str.size()); }\n\n      /**\n       *  @brief  Replace characters with value from another string.\n       *  @param __pos1  Index of first character to replace.\n       *  @param __n1  Number of characters to be replaced.\n       *  @param __str  String to insert.\n       *  @param __pos2  Index of first character of str to use.\n       *  @param __n2  Number of characters from str to use.\n       *  @return  Reference to this string.\n       *  @throw  std::out_of_range  If @a __pos1 > size() or @a __pos2 >\n       *  __str.size().\n       *  @throw  std::length_error  If new length exceeds @c max_size().\n       *\n       *  Removes the characters in the range [__pos1,__pos1 + n) from this\n       *  string.  In place, the value of @a __str is inserted.  If @a __pos is\n       *  beyond end of string, out_of_range is thrown.  If the length of the\n       *  result exceeds max_size(), length_error is thrown.  The value of the\n       *  string doesn't change if an error is thrown.\n      */\n      basic_string&\n      replace(size_type __pos1, size_type __n1, const basic_string& __str,\n\t      size_type __pos2, size_type __n2 = npos)\n      { return this->replace(__pos1, __n1, __str._M_data()\n\t\t\t     + __str._M_check(__pos2, \"basic_string::replace\"),\n\t\t\t     __str._M_limit(__pos2, __n2)); }\n\n      /**\n       *  @brief  Replace characters with value of a C substring.\n       *  @param __pos  Index of first character to replace.\n       *  @param __n1  Number of characters to be replaced.\n       *  @param __s  C string to insert.\n       *  @param __n2  Number of characters from @a s to use.\n       *  @return  Reference to this string.\n       *  @throw  std::out_of_range  If @a pos1 > size().\n       *  @throw  std::length_error  If new length exceeds @c max_size().\n       *\n       *  Removes the characters in the range [__pos,__pos + __n1)\n       *  from this string.  In place, the first @a __n2 characters of\n       *  @a __s are inserted, or all of @a __s if @a __n2 is too large.  If\n       *  @a __pos is beyond end of string, out_of_range is thrown.  If\n       *  the length of result exceeds max_size(), length_error is\n       *  thrown.  The value of the string doesn't change if an error\n       *  is thrown.\n      */\n      basic_string&\n      replace(size_type __pos, size_type __n1, const _CharT* __s,\n\t      size_type __n2);\n\n      /**\n       *  @brief  Replace characters with value of a C string.\n       *  @param __pos  Index of first character to replace.\n       *  @param __n1  Number of characters to be replaced.\n       *  @param __s  C string to insert.\n       *  @return  Reference to this string.\n       *  @throw  std::out_of_range  If @a pos > size().\n       *  @throw  std::length_error  If new length exceeds @c max_size().\n       *\n       *  Removes the characters in the range [__pos,__pos + __n1)\n       *  from this string.  In place, the characters of @a __s are\n       *  inserted.  If @a __pos is beyond end of string, out_of_range\n       *  is thrown.  If the length of result exceeds max_size(),\n       *  length_error is thrown.  The value of the string doesn't\n       *  change if an error is thrown.\n      */\n      basic_string&\n      replace(size_type __pos, size_type __n1, const _CharT* __s)\n      {\n\t__glibcxx_requires_string(__s);\n\treturn this->replace(__pos, __n1, __s, traits_type::length(__s));\n      }\n\n      /**\n       *  @brief  Replace characters with multiple characters.\n       *  @param __pos  Index of first character to replace.\n       *  @param __n1  Number of characters to be replaced.\n       *  @param __n2  Number of characters to insert.\n       *  @param __c  Character to insert.\n       *  @return  Reference to this string.\n       *  @throw  std::out_of_range  If @a __pos > size().\n       *  @throw  std::length_error  If new length exceeds @c max_size().\n       *\n       *  Removes the characters in the range [pos,pos + n1) from this\n       *  string.  In place, @a __n2 copies of @a __c are inserted.\n       *  If @a __pos is beyond end of string, out_of_range is thrown.\n       *  If the length of result exceeds max_size(), length_error is\n       *  thrown.  The value of the string doesn't change if an error\n       *  is thrown.\n      */\n      basic_string&\n      replace(size_type __pos, size_type __n1, size_type __n2, _CharT __c)\n      { return _M_replace_aux(_M_check(__pos, \"basic_string::replace\"),\n\t\t\t      _M_limit(__pos, __n1), __n2, __c); }\n\n      /**\n       *  @brief  Replace range of characters with string.\n       *  @param __i1  Iterator referencing start of range to replace.\n       *  @param __i2  Iterator referencing end of range to replace.\n       *  @param __str  String value to insert.\n       *  @return  Reference to this string.\n       *  @throw  std::length_error  If new length exceeds @c max_size().\n       *\n       *  Removes the characters in the range [__i1,__i2).  In place,\n       *  the value of @a __str is inserted.  If the length of result\n       *  exceeds max_size(), length_error is thrown.  The value of\n       *  the string doesn't change if an error is thrown.\n      */\n      basic_string&\n      replace(iterator __i1, iterator __i2, const basic_string& __str)\n      { return this->replace(__i1, __i2, __str._M_data(), __str.size()); }\n\n      /**\n       *  @brief  Replace range of characters with C substring.\n       *  @param __i1  Iterator referencing start of range to replace.\n       *  @param __i2  Iterator referencing end of range to replace.\n       *  @param __s  C string value to insert.\n       *  @param __n  Number of characters from s to insert.\n       *  @return  Reference to this string.\n       *  @throw  std::length_error  If new length exceeds @c max_size().\n       *\n       *  Removes the characters in the range [__i1,__i2).  In place,\n       *  the first @a __n characters of @a __s are inserted.  If the\n       *  length of result exceeds max_size(), length_error is thrown.\n       *  The value of the string doesn't change if an error is\n       *  thrown.\n      */\n      basic_string&\n      replace(iterator __i1, iterator __i2, const _CharT* __s, size_type __n)\n      {\n\t_GLIBCXX_DEBUG_PEDASSERT(_M_ibegin() <= __i1 && __i1 <= __i2\n\t\t\t\t && __i2 <= _M_iend());\n\treturn this->replace(__i1 - _M_ibegin(), __i2 - __i1, __s, __n);\n      }\n\n      /**\n       *  @brief  Replace range of characters with C string.\n       *  @param __i1  Iterator referencing start of range to replace.\n       *  @param __i2  Iterator referencing end of range to replace.\n       *  @param __s  C string value to insert.\n       *  @return  Reference to this string.\n       *  @throw  std::length_error  If new length exceeds @c max_size().\n       *\n       *  Removes the characters in the range [__i1,__i2).  In place,\n       *  the characters of @a __s are inserted.  If the length of\n       *  result exceeds max_size(), length_error is thrown.  The\n       *  value of the string doesn't change if an error is thrown.\n      */\n      basic_string&\n      replace(iterator __i1, iterator __i2, const _CharT* __s)\n      {\n\t__glibcxx_requires_string(__s);\n\treturn this->replace(__i1, __i2, __s, traits_type::length(__s));\n      }\n\n      /**\n       *  @brief  Replace range of characters with multiple characters\n       *  @param __i1  Iterator referencing start of range to replace.\n       *  @param __i2  Iterator referencing end of range to replace.\n       *  @param __n  Number of characters to insert.\n       *  @param __c  Character to insert.\n       *  @return  Reference to this string.\n       *  @throw  std::length_error  If new length exceeds @c max_size().\n       *\n       *  Removes the characters in the range [__i1,__i2).  In place,\n       *  @a __n copies of @a __c are inserted.  If the length of\n       *  result exceeds max_size(), length_error is thrown.  The\n       *  value of the string doesn't change if an error is thrown.\n      */\n      basic_string&\n      replace(iterator __i1, iterator __i2, size_type __n, _CharT __c)\n      {\n\t_GLIBCXX_DEBUG_PEDASSERT(_M_ibegin() <= __i1 && __i1 <= __i2\n\t\t\t\t && __i2 <= _M_iend());\n\treturn _M_replace_aux(__i1 - _M_ibegin(), __i2 - __i1, __n, __c);\n      }\n\n      /**\n       *  @brief  Replace range of characters with range.\n       *  @param __i1  Iterator referencing start of range to replace.\n       *  @param __i2  Iterator referencing end of range to replace.\n       *  @param __k1  Iterator referencing start of range to insert.\n       *  @param __k2  Iterator referencing end of range to insert.\n       *  @return  Reference to this string.\n       *  @throw  std::length_error  If new length exceeds @c max_size().\n       *\n       *  Removes the characters in the range [__i1,__i2).  In place,\n       *  characters in the range [__k1,__k2) are inserted.  If the\n       *  length of result exceeds max_size(), length_error is thrown.\n       *  The value of the string doesn't change if an error is\n       *  thrown.\n      */\n      template<class _InputIterator>\n        basic_string&\n        replace(iterator __i1, iterator __i2,\n\t\t_InputIterator __k1, _InputIterator __k2)\n        {\n\t  _GLIBCXX_DEBUG_PEDASSERT(_M_ibegin() <= __i1 && __i1 <= __i2\n\t\t\t\t   && __i2 <= _M_iend());\n\t  __glibcxx_requires_valid_range(__k1, __k2);\n\t  typedef typename std::__is_integer<_InputIterator>::__type _Integral;\n\t  return _M_replace_dispatch(__i1, __i2, __k1, __k2, _Integral());\n\t}\n\n      // Specializations for the common case of pointer and iterator:\n      // useful to avoid the overhead of temporary buffering in _M_replace.\n      basic_string&\n      replace(iterator __i1, iterator __i2, _CharT* __k1, _CharT* __k2)\n      {\n\t_GLIBCXX_DEBUG_PEDASSERT(_M_ibegin() <= __i1 && __i1 <= __i2\n\t\t\t\t && __i2 <= _M_iend());\n\t__glibcxx_requires_valid_range(__k1, __k2);\n\treturn this->replace(__i1 - _M_ibegin(), __i2 - __i1,\n\t\t\t     __k1, __k2 - __k1);\n      }\n\n      basic_string&\n      replace(iterator __i1, iterator __i2,\n\t      const _CharT* __k1, const _CharT* __k2)\n      {\n\t_GLIBCXX_DEBUG_PEDASSERT(_M_ibegin() <= __i1 && __i1 <= __i2\n\t\t\t\t && __i2 <= _M_iend());\n\t__glibcxx_requires_valid_range(__k1, __k2);\n\treturn this->replace(__i1 - _M_ibegin(), __i2 - __i1,\n\t\t\t     __k1, __k2 - __k1);\n      }\n\n      basic_string&\n      replace(iterator __i1, iterator __i2, iterator __k1, iterator __k2)\n      {\n\t_GLIBCXX_DEBUG_PEDASSERT(_M_ibegin() <= __i1 && __i1 <= __i2\n\t\t\t\t && __i2 <= _M_iend());\n\t__glibcxx_requires_valid_range(__k1, __k2);\n\treturn this->replace(__i1 - _M_ibegin(), __i2 - __i1,\n\t\t\t     __k1.base(), __k2 - __k1);\n      }\n\n      basic_string&\n      replace(iterator __i1, iterator __i2,\n\t      const_iterator __k1, const_iterator __k2)\n      {\n\t_GLIBCXX_DEBUG_PEDASSERT(_M_ibegin() <= __i1 && __i1 <= __i2\n\t\t\t\t && __i2 <= _M_iend());\n\t__glibcxx_requires_valid_range(__k1, __k2);\n\treturn this->replace(__i1 - _M_ibegin(), __i2 - __i1,\n\t\t\t     __k1.base(), __k2 - __k1);\n      }\n\n#if __cplusplus >= 201103L\n      /**\n       *  @brief  Replace range of characters with initializer_list.\n       *  @param __i1  Iterator referencing start of range to replace.\n       *  @param __i2  Iterator referencing end of range to replace.\n       *  @param __l  The initializer_list of characters to insert.\n       *  @return  Reference to this string.\n       *  @throw  std::length_error  If new length exceeds @c max_size().\n       *\n       *  Removes the characters in the range [__i1,__i2).  In place,\n       *  characters in the range [__k1,__k2) are inserted.  If the\n       *  length of result exceeds max_size(), length_error is thrown.\n       *  The value of the string doesn't change if an error is\n       *  thrown.\n      */\n      basic_string& replace(iterator __i1, iterator __i2,\n\t\t\t    initializer_list<_CharT> __l)\n      { return this->replace(__i1, __i2, __l.begin(), __l.end()); }\n#endif // C++11\n\n#if __cplusplus > 201402L\n      /**\n       *  @brief  Replace range of characters with string_view.\n       *  @param __pos  The position to replace at.\n       *  @param __n    The number of characters to replace.\n       *  @param __svt  The object convertible to string_view to insert.\n       *  @return  Reference to this string.\n      */\n      template<typename _Tp>\n\t_If_sv<_Tp, basic_string&>\n\treplace(size_type __pos, size_type __n, const _Tp& __svt)\n\t{\n\t  __sv_type __sv = __svt;\n\t  return this->replace(__pos, __n, __sv.data(), __sv.size());\n\t}\n\n      /**\n       *  @brief  Replace range of characters with string_view.\n       *  @param __pos1  The position to replace at.\n       *  @param __n1    The number of characters to replace.\n       *  @param __svt   The object convertible to string_view to insert from.\n       *  @param __pos2  The position in the string_view to insert from.\n       *  @param __n2    The number of characters to insert.\n       *  @return  Reference to this string.\n      */\n      template<typename _Tp>\n        _If_sv<_Tp, basic_string&>\n        replace(size_type __pos1, size_type __n1, const _Tp& __svt,\n\t\tsize_type __pos2, size_type __n2 = npos)\n\t{\n\t  __sv_type __sv = __svt;\n\t  return this->replace(__pos1, __n1,\n\t      __sv.data() + __sv._M_check(__pos2, \"basic_string::replace\"),\n\t      __sv._M_limit(__pos2, __n2));\n\t}\n\n      /**\n       *  @brief  Replace range of characters with string_view.\n       *  @param __i1    An iterator referencing the start position\n          to replace at.\n       *  @param __i2    An iterator referencing the end position\n          for the replace.\n       *  @param __svt   The object convertible to string_view to insert from.\n       *  @return  Reference to this string.\n      */\n      template<typename _Tp>\n\t_If_sv<_Tp, basic_string&>\n\treplace(const_iterator __i1, const_iterator __i2, const _Tp& __svt)\n\t{\n\t  __sv_type __sv = __svt;\n\t  return this->replace(__i1 - begin(), __i2 - __i1, __sv);\n\t}\n#endif // C++17\n\n    private:\n      template<class _Integer>\n\tbasic_string&\n\t_M_replace_dispatch(iterator __i1, iterator __i2, _Integer __n,\n\t\t\t    _Integer __val, __true_type)\n        { return _M_replace_aux(__i1 - _M_ibegin(), __i2 - __i1, __n, __val); }\n\n      template<class _InputIterator>\n\tbasic_string&\n\t_M_replace_dispatch(iterator __i1, iterator __i2, _InputIterator __k1,\n\t\t\t    _InputIterator __k2, __false_type);\n\n      basic_string&\n      _M_replace_aux(size_type __pos1, size_type __n1, size_type __n2,\n\t\t     _CharT __c);\n\n      basic_string&\n      _M_replace_safe(size_type __pos1, size_type __n1, const _CharT* __s,\n\t\t      size_type __n2);\n\n      // _S_construct_aux is used to implement the 21.3.1 para 15 which\n      // requires special behaviour if _InIter is an integral type\n      template<class _InIterator>\n        static _CharT*\n        _S_construct_aux(_InIterator __beg, _InIterator __end,\n\t\t\t const _Alloc& __a, __false_type)\n\t{\n          typedef typename iterator_traits<_InIterator>::iterator_category _Tag;\n          return _S_construct(__beg, __end, __a, _Tag());\n\t}\n\n      // _GLIBCXX_RESOLVE_LIB_DEFECTS\n      // 438. Ambiguity in the \"do the right thing\" clause\n      template<class _Integer>\n        static _CharT*\n        _S_construct_aux(_Integer __beg, _Integer __end,\n\t\t\t const _Alloc& __a, __true_type)\n        { return _S_construct_aux_2(static_cast<size_type>(__beg),\n\t\t\t\t    __end, __a); }\n\n      static _CharT*\n      _S_construct_aux_2(size_type __req, _CharT __c, const _Alloc& __a)\n      { return _S_construct(__req, __c, __a); }\n\n      template<class _InIterator>\n        static _CharT*\n        _S_construct(_InIterator __beg, _InIterator __end, const _Alloc& __a)\n\t{\n\t  typedef typename std::__is_integer<_InIterator>::__type _Integral;\n\t  return _S_construct_aux(__beg, __end, __a, _Integral());\n        }\n\n      // For Input Iterators, used in istreambuf_iterators, etc.\n      template<class _InIterator>\n        static _CharT*\n         _S_construct(_InIterator __beg, _InIterator __end, const _Alloc& __a,\n\t\t      input_iterator_tag);\n\n      // For forward_iterators up to random_access_iterators, used for\n      // string::iterator, _CharT*, etc.\n      template<class _FwdIterator>\n        static _CharT*\n        _S_construct(_FwdIterator __beg, _FwdIterator __end, const _Alloc& __a,\n\t\t     forward_iterator_tag);\n\n      static _CharT*\n      _S_construct(size_type __req, _CharT __c, const _Alloc& __a);\n\n    public:\n\n      /**\n       *  @brief  Copy substring into C string.\n       *  @param __s  C string to copy value into.\n       *  @param __n  Number of characters to copy.\n       *  @param __pos  Index of first character to copy.\n       *  @return  Number of characters actually copied\n       *  @throw  std::out_of_range  If __pos > size().\n       *\n       *  Copies up to @a __n characters starting at @a __pos into the\n       *  C string @a __s.  If @a __pos is %greater than size(),\n       *  out_of_range is thrown.\n      */\n      size_type\n      copy(_CharT* __s, size_type __n, size_type __pos = 0) const;\n\n      /**\n       *  @brief  Swap contents with another string.\n       *  @param __s  String to swap with.\n       *\n       *  Exchanges the contents of this string with that of @a __s in constant\n       *  time.\n      */\n      // PR 58265, this should be noexcept.\n      void\n      swap(basic_string& __s);\n\n      // String operations:\n      /**\n       *  @brief  Return const pointer to null-terminated contents.\n       *\n       *  This is a handle to internal data.  Do not modify or dire things may\n       *  happen.\n      */\n      const _CharT*\n      c_str() const _GLIBCXX_NOEXCEPT\n      { return _M_data(); }\n\n      /**\n       *  @brief  Return const pointer to contents.\n       *\n       *  This is a pointer to internal data.  It is undefined to modify\n       *  the contents through the returned pointer. To get a pointer that\n       *  allows modifying the contents use @c &str[0] instead,\n       *  (or in C++17 the non-const @c str.data() overload).\n      */\n      const _CharT*\n      data() const _GLIBCXX_NOEXCEPT\n      { return _M_data(); }\n\n#if __cplusplus > 201402L\n      /**\n       *  @brief  Return non-const pointer to contents.\n       *\n       *  This is a pointer to the character sequence held by the string.\n       *  Modifying the characters in the sequence is allowed.\n      */\n      _CharT*\n      data() noexcept\n      {\n\t_M_leak();\n\treturn _M_data();\n      }\n#endif\n\n      /**\n       *  @brief  Return copy of allocator used to construct this string.\n      */\n      allocator_type\n      get_allocator() const _GLIBCXX_NOEXCEPT\n      { return _M_dataplus; }\n\n      /**\n       *  @brief  Find position of a C substring.\n       *  @param __s  C string to locate.\n       *  @param __pos  Index of character to search from.\n       *  @param __n  Number of characters from @a s to search for.\n       *  @return  Index of start of first occurrence.\n       *\n       *  Starting from @a __pos, searches forward for the first @a\n       *  __n characters in @a __s within this string.  If found,\n       *  returns the index where it begins.  If not found, returns\n       *  npos.\n      */\n      size_type\n      find(const _CharT* __s, size_type __pos, size_type __n) const\n      _GLIBCXX_NOEXCEPT;\n\n      /**\n       *  @brief  Find position of a string.\n       *  @param __str  String to locate.\n       *  @param __pos  Index of character to search from (default 0).\n       *  @return  Index of start of first occurrence.\n       *\n       *  Starting from @a __pos, searches forward for value of @a __str within\n       *  this string.  If found, returns the index where it begins.  If not\n       *  found, returns npos.\n      */\n      size_type\n      find(const basic_string& __str, size_type __pos = 0) const\n      _GLIBCXX_NOEXCEPT\n      { return this->find(__str.data(), __pos, __str.size()); }\n\n      /**\n       *  @brief  Find position of a C string.\n       *  @param __s  C string to locate.\n       *  @param __pos  Index of character to search from (default 0).\n       *  @return  Index of start of first occurrence.\n       *\n       *  Starting from @a __pos, searches forward for the value of @a\n       *  __s within this string.  If found, returns the index where\n       *  it begins.  If not found, returns npos.\n      */\n      size_type\n      find(const _CharT* __s, size_type __pos = 0) const _GLIBCXX_NOEXCEPT\n      {\n\t__glibcxx_requires_string(__s);\n\treturn this->find(__s, __pos, traits_type::length(__s));\n      }\n\n      /**\n       *  @brief  Find position of a character.\n       *  @param __c  Character to locate.\n       *  @param __pos  Index of character to search from (default 0).\n       *  @return  Index of first occurrence.\n       *\n       *  Starting from @a __pos, searches forward for @a __c within\n       *  this string.  If found, returns the index where it was\n       *  found.  If not found, returns npos.\n      */\n      size_type\n      find(_CharT __c, size_type __pos = 0) const _GLIBCXX_NOEXCEPT;\n\n#if __cplusplus > 201402L\n      /**\n       *  @brief  Find position of a string_view.\n       *  @param __svt  The object convertible to string_view to locate.\n       *  @param __pos  Index of character to search from (default 0).\n       *  @return  Index of start of first occurrence.\n      */\n      template<typename _Tp>\n\t_If_sv<_Tp, size_type>\n\tfind(const _Tp& __svt, size_type __pos = 0) const\n\tnoexcept(is_same<_Tp, __sv_type>::value)\n\t{\n\t  __sv_type __sv = __svt;\n\t  return this->find(__sv.data(), __pos, __sv.size());\n\t}\n#endif // C++17\n\n      /**\n       *  @brief  Find last position of a string.\n       *  @param __str  String to locate.\n       *  @param __pos  Index of character to search back from (default end).\n       *  @return  Index of start of last occurrence.\n       *\n       *  Starting from @a __pos, searches backward for value of @a\n       *  __str within this string.  If found, returns the index where\n       *  it begins.  If not found, returns npos.\n      */\n      size_type\n      rfind(const basic_string& __str, size_type __pos = npos) const\n      _GLIBCXX_NOEXCEPT\n      { return this->rfind(__str.data(), __pos, __str.size()); }\n\n      /**\n       *  @brief  Find last position of a C substring.\n       *  @param __s  C string to locate.\n       *  @param __pos  Index of character to search back from.\n       *  @param __n  Number of characters from s to search for.\n       *  @return  Index of start of last occurrence.\n       *\n       *  Starting from @a __pos, searches backward for the first @a\n       *  __n characters in @a __s within this string.  If found,\n       *  returns the index where it begins.  If not found, returns\n       *  npos.\n      */\n      size_type\n      rfind(const _CharT* __s, size_type __pos, size_type __n) const\n      _GLIBCXX_NOEXCEPT;\n\n      /**\n       *  @brief  Find last position of a C string.\n       *  @param __s  C string to locate.\n       *  @param __pos  Index of character to start search at (default end).\n       *  @return  Index of start of  last occurrence.\n       *\n       *  Starting from @a __pos, searches backward for the value of\n       *  @a __s within this string.  If found, returns the index\n       *  where it begins.  If not found, returns npos.\n      */\n      size_type\n      rfind(const _CharT* __s, size_type __pos = npos) const _GLIBCXX_NOEXCEPT\n      {\n\t__glibcxx_requires_string(__s);\n\treturn this->rfind(__s, __pos, traits_type::length(__s));\n      }\n\n      /**\n       *  @brief  Find last position of a character.\n       *  @param __c  Character to locate.\n       *  @param __pos  Index of character to search back from (default end).\n       *  @return  Index of last occurrence.\n       *\n       *  Starting from @a __pos, searches backward for @a __c within\n       *  this string.  If found, returns the index where it was\n       *  found.  If not found, returns npos.\n      */\n      size_type\n      rfind(_CharT __c, size_type __pos = npos) const _GLIBCXX_NOEXCEPT;\n\n#if __cplusplus > 201402L\n      /**\n       *  @brief  Find last position of a string_view.\n       *  @param __svt  The object convertible to string_view to locate.\n       *  @param __pos  Index of character to search back from (default end).\n       *  @return  Index of start of last occurrence.\n      */\n      template<typename _Tp>\n\t_If_sv<_Tp, size_type>\n\trfind(const _Tp& __svt, size_type __pos = npos) const\n\tnoexcept(is_same<_Tp, __sv_type>::value)\n\t{\n\t  __sv_type __sv = __svt;\n\t  return this->rfind(__sv.data(), __pos, __sv.size());\n\t}\n#endif // C++17\n\n      /**\n       *  @brief  Find position of a character of string.\n       *  @param __str  String containing characters to locate.\n       *  @param __pos  Index of character to search from (default 0).\n       *  @return  Index of first occurrence.\n       *\n       *  Starting from @a __pos, searches forward for one of the\n       *  characters of @a __str within this string.  If found,\n       *  returns the index where it was found.  If not found, returns\n       *  npos.\n      */\n      size_type\n      find_first_of(const basic_string& __str, size_type __pos = 0) const\n      _GLIBCXX_NOEXCEPT\n      { return this->find_first_of(__str.data(), __pos, __str.size()); }\n\n      /**\n       *  @brief  Find position of a character of C substring.\n       *  @param __s  String containing characters to locate.\n       *  @param __pos  Index of character to search from.\n       *  @param __n  Number of characters from s to search for.\n       *  @return  Index of first occurrence.\n       *\n       *  Starting from @a __pos, searches forward for one of the\n       *  first @a __n characters of @a __s within this string.  If\n       *  found, returns the index where it was found.  If not found,\n       *  returns npos.\n      */\n      size_type\n      find_first_of(const _CharT* __s, size_type __pos, size_type __n) const\n      _GLIBCXX_NOEXCEPT;\n\n      /**\n       *  @brief  Find position of a character of C string.\n       *  @param __s  String containing characters to locate.\n       *  @param __pos  Index of character to search from (default 0).\n       *  @return  Index of first occurrence.\n       *\n       *  Starting from @a __pos, searches forward for one of the\n       *  characters of @a __s within this string.  If found, returns\n       *  the index where it was found.  If not found, returns npos.\n      */\n      size_type\n      find_first_of(const _CharT* __s, size_type __pos = 0) const\n      _GLIBCXX_NOEXCEPT\n      {\n\t__glibcxx_requires_string(__s);\n\treturn this->find_first_of(__s, __pos, traits_type::length(__s));\n      }\n\n      /**\n       *  @brief  Find position of a character.\n       *  @param __c  Character to locate.\n       *  @param __pos  Index of character to search from (default 0).\n       *  @return  Index of first occurrence.\n       *\n       *  Starting from @a __pos, searches forward for the character\n       *  @a __c within this string.  If found, returns the index\n       *  where it was found.  If not found, returns npos.\n       *\n       *  Note: equivalent to find(__c, __pos).\n      */\n      size_type\n      find_first_of(_CharT __c, size_type __pos = 0) const _GLIBCXX_NOEXCEPT\n      { return this->find(__c, __pos); }\n\n#if __cplusplus > 201402L\n      /**\n       *  @brief  Find position of a character of a string_view.\n       *  @param __svt  An object convertible to string_view containing\n       *                characters to locate.\n       *  @param __pos  Index of character to search from (default 0).\n       *  @return  Index of first occurrence.\n      */\n      template<typename _Tp>\n\t_If_sv<_Tp, size_type>\n\tfind_first_of(const _Tp& __svt, size_type __pos = 0) const\n\tnoexcept(is_same<_Tp, __sv_type>::value)\n\t{\n\t  __sv_type __sv = __svt;\n\t  return this->find_first_of(__sv.data(), __pos, __sv.size());\n\t}\n#endif // C++17\n\n      /**\n       *  @brief  Find last position of a character of string.\n       *  @param __str  String containing characters to locate.\n       *  @param __pos  Index of character to search back from (default end).\n       *  @return  Index of last occurrence.\n       *\n       *  Starting from @a __pos, searches backward for one of the\n       *  characters of @a __str within this string.  If found,\n       *  returns the index where it was found.  If not found, returns\n       *  npos.\n      */\n      size_type\n      find_last_of(const basic_string& __str, size_type __pos = npos) const\n      _GLIBCXX_NOEXCEPT\n      { return this->find_last_of(__str.data(), __pos, __str.size()); }\n\n      /**\n       *  @brief  Find last position of a character of C substring.\n       *  @param __s  C string containing characters to locate.\n       *  @param __pos  Index of character to search back from.\n       *  @param __n  Number of characters from s to search for.\n       *  @return  Index of last occurrence.\n       *\n       *  Starting from @a __pos, searches backward for one of the\n       *  first @a __n characters of @a __s within this string.  If\n       *  found, returns the index where it was found.  If not found,\n       *  returns npos.\n      */\n      size_type\n      find_last_of(const _CharT* __s, size_type __pos, size_type __n) const\n      _GLIBCXX_NOEXCEPT;\n\n      /**\n       *  @brief  Find last position of a character of C string.\n       *  @param __s  C string containing characters to locate.\n       *  @param __pos  Index of character to search back from (default end).\n       *  @return  Index of last occurrence.\n       *\n       *  Starting from @a __pos, searches backward for one of the\n       *  characters of @a __s within this string.  If found, returns\n       *  the index where it was found.  If not found, returns npos.\n      */\n      size_type\n      find_last_of(const _CharT* __s, size_type __pos = npos) const\n      _GLIBCXX_NOEXCEPT\n      {\n\t__glibcxx_requires_string(__s);\n\treturn this->find_last_of(__s, __pos, traits_type::length(__s));\n      }\n\n      /**\n       *  @brief  Find last position of a character.\n       *  @param __c  Character to locate.\n       *  @param __pos  Index of character to search back from (default end).\n       *  @return  Index of last occurrence.\n       *\n       *  Starting from @a __pos, searches backward for @a __c within\n       *  this string.  If found, returns the index where it was\n       *  found.  If not found, returns npos.\n       *\n       *  Note: equivalent to rfind(__c, __pos).\n      */\n      size_type\n      find_last_of(_CharT __c, size_type __pos = npos) const _GLIBCXX_NOEXCEPT\n      { return this->rfind(__c, __pos); }\n\n#if __cplusplus > 201402L\n      /**\n       *  @brief  Find last position of a character of string.\n       *  @param __svt  An object convertible to string_view containing\n       *                characters to locate.\n       *  @param __pos  Index of character to search back from (default end).\n       *  @return  Index of last occurrence.\n      */\n      template<typename _Tp>\n\t_If_sv<_Tp, size_type>\n\tfind_last_of(const _Tp& __svt, size_type __pos = npos) const\n\tnoexcept(is_same<_Tp, __sv_type>::value)\n\t{\n\t  __sv_type __sv = __svt;\n\t  return this->find_last_of(__sv.data(), __pos, __sv.size());\n\t}\n#endif // C++17\n\n      /**\n       *  @brief  Find position of a character not in string.\n       *  @param __str  String containing characters to avoid.\n       *  @param __pos  Index of character to search from (default 0).\n       *  @return  Index of first occurrence.\n       *\n       *  Starting from @a __pos, searches forward for a character not contained\n       *  in @a __str within this string.  If found, returns the index where it\n       *  was found.  If not found, returns npos.\n      */\n      size_type\n      find_first_not_of(const basic_string& __str, size_type __pos = 0) const\n      _GLIBCXX_NOEXCEPT\n      { return this->find_first_not_of(__str.data(), __pos, __str.size()); }\n\n      /**\n       *  @brief  Find position of a character not in C substring.\n       *  @param __s  C string containing characters to avoid.\n       *  @param __pos  Index of character to search from.\n       *  @param __n  Number of characters from __s to consider.\n       *  @return  Index of first occurrence.\n       *\n       *  Starting from @a __pos, searches forward for a character not\n       *  contained in the first @a __n characters of @a __s within\n       *  this string.  If found, returns the index where it was\n       *  found.  If not found, returns npos.\n      */\n      size_type\n      find_first_not_of(const _CharT* __s, size_type __pos,\n\t\t\tsize_type __n) const _GLIBCXX_NOEXCEPT;\n\n      /**\n       *  @brief  Find position of a character not in C string.\n       *  @param __s  C string containing characters to avoid.\n       *  @param __pos  Index of character to search from (default 0).\n       *  @return  Index of first occurrence.\n       *\n       *  Starting from @a __pos, searches forward for a character not\n       *  contained in @a __s within this string.  If found, returns\n       *  the index where it was found.  If not found, returns npos.\n      */\n      size_type\n      find_first_not_of(const _CharT* __s, size_type __pos = 0) const\n      _GLIBCXX_NOEXCEPT\n      {\n\t__glibcxx_requires_string(__s);\n\treturn this->find_first_not_of(__s, __pos, traits_type::length(__s));\n      }\n\n      /**\n       *  @brief  Find position of a different character.\n       *  @param __c  Character to avoid.\n       *  @param __pos  Index of character to search from (default 0).\n       *  @return  Index of first occurrence.\n       *\n       *  Starting from @a __pos, searches forward for a character\n       *  other than @a __c within this string.  If found, returns the\n       *  index where it was found.  If not found, returns npos.\n      */\n      size_type\n      find_first_not_of(_CharT __c, size_type __pos = 0) const\n      _GLIBCXX_NOEXCEPT;\n\n#if __cplusplus > 201402L\n      /**\n       *  @brief  Find position of a character not in a string_view.\n       *  @param __svt  An object convertible to string_view containing\n       *                characters to avoid.\n       *  @param __pos  Index of character to search from (default 0).\n       *  @return  Index of first occurrence.\n       */\n      template<typename _Tp>\n\t_If_sv<_Tp, size_type>\n\tfind_first_not_of(const _Tp& __svt, size_type __pos = 0) const\n\tnoexcept(is_same<_Tp, __sv_type>::value)\n\t{\n\t  __sv_type __sv = __svt;\n\t  return this->find_first_not_of(__sv.data(), __pos, __sv.size());\n\t}\n#endif // C++17\n\n      /**\n       *  @brief  Find last position of a character not in string.\n       *  @param __str  String containing characters to avoid.\n       *  @param __pos  Index of character to search back from (default end).\n       *  @return  Index of last occurrence.\n       *\n       *  Starting from @a __pos, searches backward for a character\n       *  not contained in @a __str within this string.  If found,\n       *  returns the index where it was found.  If not found, returns\n       *  npos.\n      */\n      size_type\n      find_last_not_of(const basic_string& __str, size_type __pos = npos) const\n      _GLIBCXX_NOEXCEPT\n      { return this->find_last_not_of(__str.data(), __pos, __str.size()); }\n\n      /**\n       *  @brief  Find last position of a character not in C substring.\n       *  @param __s  C string containing characters to avoid.\n       *  @param __pos  Index of character to search back from.\n       *  @param __n  Number of characters from s to consider.\n       *  @return  Index of last occurrence.\n       *\n       *  Starting from @a __pos, searches backward for a character not\n       *  contained in the first @a __n characters of @a __s within this string.\n       *  If found, returns the index where it was found.  If not found,\n       *  returns npos.\n      */\n      size_type\n      find_last_not_of(const _CharT* __s, size_type __pos,\n\t\t       size_type __n) const _GLIBCXX_NOEXCEPT;\n      /**\n       *  @brief  Find last position of a character not in C string.\n       *  @param __s  C string containing characters to avoid.\n       *  @param __pos  Index of character to search back from (default end).\n       *  @return  Index of last occurrence.\n       *\n       *  Starting from @a __pos, searches backward for a character\n       *  not contained in @a __s within this string.  If found,\n       *  returns the index where it was found.  If not found, returns\n       *  npos.\n      */\n      size_type\n      find_last_not_of(const _CharT* __s, size_type __pos = npos) const\n      _GLIBCXX_NOEXCEPT\n      {\n\t__glibcxx_requires_string(__s);\n\treturn this->find_last_not_of(__s, __pos, traits_type::length(__s));\n      }\n\n      /**\n       *  @brief  Find last position of a different character.\n       *  @param __c  Character to avoid.\n       *  @param __pos  Index of character to search back from (default end).\n       *  @return  Index of last occurrence.\n       *\n       *  Starting from @a __pos, searches backward for a character other than\n       *  @a __c within this string.  If found, returns the index where it was\n       *  found.  If not found, returns npos.\n      */\n      size_type\n      find_last_not_of(_CharT __c, size_type __pos = npos) const\n      _GLIBCXX_NOEXCEPT;\n\n#if __cplusplus > 201402L\n      /**\n       *  @brief  Find last position of a character not in a string_view.\n       *  @param __svt  An object convertible to string_view containing\n       *                characters to avoid.\n       *  @param __pos  Index of character to search back from (default end).\n       *  @return  Index of last occurrence.\n       */\n      template<typename _Tp>\n\t_If_sv<_Tp, size_type>\n\tfind_last_not_of(const _Tp& __svt, size_type __pos = npos) const\n\tnoexcept(is_same<_Tp, __sv_type>::value)\n\t{\n\t  __sv_type __sv = __svt;\n\t  return this->find_last_not_of(__sv.data(), __pos, __sv.size());\n\t}\n#endif // C++17\n\n      /**\n       *  @brief  Get a substring.\n       *  @param __pos  Index of first character (default 0).\n       *  @param __n  Number of characters in substring (default remainder).\n       *  @return  The new string.\n       *  @throw  std::out_of_range  If __pos > size().\n       *\n       *  Construct and return a new string using the @a __n\n       *  characters starting at @a __pos.  If the string is too\n       *  short, use the remainder of the characters.  If @a __pos is\n       *  beyond the end of the string, out_of_range is thrown.\n      */\n      basic_string\n      substr(size_type __pos = 0, size_type __n = npos) const\n      { return basic_string(*this,\n\t\t\t    _M_check(__pos, \"basic_string::substr\"), __n); }\n\n      /**\n       *  @brief  Compare to a string.\n       *  @param __str  String to compare against.\n       *  @return  Integer < 0, 0, or > 0.\n       *\n       *  Returns an integer < 0 if this string is ordered before @a\n       *  __str, 0 if their values are equivalent, or > 0 if this\n       *  string is ordered after @a __str.  Determines the effective\n       *  length rlen of the strings to compare as the smallest of\n       *  size() and str.size().  The function then compares the two\n       *  strings by calling traits::compare(data(), str.data(),rlen).\n       *  If the result of the comparison is nonzero returns it,\n       *  otherwise the shorter one is ordered first.\n      */\n      int\n      compare(const basic_string& __str) const\n      {\n\tconst size_type __size = this->size();\n\tconst size_type __osize = __str.size();\n\tconst size_type __len = std::min(__size, __osize);\n\n\tint __r = traits_type::compare(_M_data(), __str.data(), __len);\n\tif (!__r)\n\t  __r = _S_compare(__size, __osize);\n\treturn __r;\n      }\n\n#if __cplusplus > 201402L\n      /**\n       *  @brief  Compare to a string_view.\n       *  @param __svt An object convertible to string_view to compare against.\n       *  @return  Integer < 0, 0, or > 0.\n       */\n      template<typename _Tp>\n\t_If_sv<_Tp, int>\n\tcompare(const _Tp& __svt) const\n\tnoexcept(is_same<_Tp, __sv_type>::value)\n\t{\n\t   __sv_type __sv = __svt;\n\t  const size_type __size = this->size();\n\t  const size_type __osize = __sv.size();\n\t  const size_type __len = std::min(__size, __osize);\n\n\t  int __r = traits_type::compare(_M_data(), __sv.data(), __len);\n\t  if (!__r)\n\t    __r = _S_compare(__size, __osize);\n\t  return __r;\n\t}\n\n      /**\n       *  @brief  Compare to a string_view.\n       *  @param __pos  A position in the string to start comparing from.\n       *  @param __n  The number of characters to compare.\n       *  @param __svt  An object convertible to string_view to compare\n       *                against.\n       *  @return  Integer < 0, 0, or > 0.\n       */\n      template<typename _Tp>\n\t_If_sv<_Tp, int>\n\tcompare(size_type __pos, size_type __n, const _Tp& __svt) const\n\tnoexcept(is_same<_Tp, __sv_type>::value)\n\t{\n\t  __sv_type __sv = __svt;\n\t  return __sv_type(*this).substr(__pos, __n).compare(__sv);\n\t}\n\n      /**\n       *  @brief  Compare to a string_view.\n       *  @param __pos1  A position in the string to start comparing from.\n       *  @param __n1  The number of characters to compare.\n       *  @param __svt   An object convertible to string_view to compare\n       *                 against.\n       *  @param __pos2  A position in the string_view to start comparing from.\n       *  @param __n2  The number of characters to compare.\n       *  @return  Integer < 0, 0, or > 0.\n       */\n      template<typename _Tp>\n\t_If_sv<_Tp, int>\n\tcompare(size_type __pos1, size_type __n1, const _Tp& __svt,\n\t\tsize_type __pos2, size_type __n2 = npos) const\n\tnoexcept(is_same<_Tp, __sv_type>::value)\n\t{\n\t  __sv_type __sv = __svt;\n\t  return __sv_type(*this)\n\t    .substr(__pos1, __n1).compare(__sv.substr(__pos2, __n2));\n\t}\n#endif // C++17\n\n      /**\n       *  @brief  Compare substring to a string.\n       *  @param __pos  Index of first character of substring.\n       *  @param __n  Number of characters in substring.\n       *  @param __str  String to compare against.\n       *  @return  Integer < 0, 0, or > 0.\n       *\n       *  Form the substring of this string from the @a __n characters\n       *  starting at @a __pos.  Returns an integer < 0 if the\n       *  substring is ordered before @a __str, 0 if their values are\n       *  equivalent, or > 0 if the substring is ordered after @a\n       *  __str.  Determines the effective length rlen of the strings\n       *  to compare as the smallest of the length of the substring\n       *  and @a __str.size().  The function then compares the two\n       *  strings by calling\n       *  traits::compare(substring.data(),str.data(),rlen).  If the\n       *  result of the comparison is nonzero returns it, otherwise\n       *  the shorter one is ordered first.\n      */\n      int\n      compare(size_type __pos, size_type __n, const basic_string& __str) const;\n\n      /**\n       *  @brief  Compare substring to a substring.\n       *  @param __pos1  Index of first character of substring.\n       *  @param __n1  Number of characters in substring.\n       *  @param __str  String to compare against.\n       *  @param __pos2  Index of first character of substring of str.\n       *  @param __n2  Number of characters in substring of str.\n       *  @return  Integer < 0, 0, or > 0.\n       *\n       *  Form the substring of this string from the @a __n1\n       *  characters starting at @a __pos1.  Form the substring of @a\n       *  __str from the @a __n2 characters starting at @a __pos2.\n       *  Returns an integer < 0 if this substring is ordered before\n       *  the substring of @a __str, 0 if their values are equivalent,\n       *  or > 0 if this substring is ordered after the substring of\n       *  @a __str.  Determines the effective length rlen of the\n       *  strings to compare as the smallest of the lengths of the\n       *  substrings.  The function then compares the two strings by\n       *  calling\n       *  traits::compare(substring.data(),str.substr(pos2,n2).data(),rlen).\n       *  If the result of the comparison is nonzero returns it,\n       *  otherwise the shorter one is ordered first.\n      */\n      int\n      compare(size_type __pos1, size_type __n1, const basic_string& __str,\n\t      size_type __pos2, size_type __n2 = npos) const;\n\n      /**\n       *  @brief  Compare to a C string.\n       *  @param __s  C string to compare against.\n       *  @return  Integer < 0, 0, or > 0.\n       *\n       *  Returns an integer < 0 if this string is ordered before @a __s, 0 if\n       *  their values are equivalent, or > 0 if this string is ordered after\n       *  @a __s.  Determines the effective length rlen of the strings to\n       *  compare as the smallest of size() and the length of a string\n       *  constructed from @a __s.  The function then compares the two strings\n       *  by calling traits::compare(data(),s,rlen).  If the result of the\n       *  comparison is nonzero returns it, otherwise the shorter one is\n       *  ordered first.\n      */\n      int\n      compare(const _CharT* __s) const _GLIBCXX_NOEXCEPT;\n\n      // _GLIBCXX_RESOLVE_LIB_DEFECTS\n      // 5 String::compare specification questionable\n      /**\n       *  @brief  Compare substring to a C string.\n       *  @param __pos  Index of first character of substring.\n       *  @param __n1  Number of characters in substring.\n       *  @param __s  C string to compare against.\n       *  @return  Integer < 0, 0, or > 0.\n       *\n       *  Form the substring of this string from the @a __n1\n       *  characters starting at @a pos.  Returns an integer < 0 if\n       *  the substring is ordered before @a __s, 0 if their values\n       *  are equivalent, or > 0 if the substring is ordered after @a\n       *  __s.  Determines the effective length rlen of the strings to\n       *  compare as the smallest of the length of the substring and\n       *  the length of a string constructed from @a __s.  The\n       *  function then compares the two string by calling\n       *  traits::compare(substring.data(),__s,rlen).  If the result of\n       *  the comparison is nonzero returns it, otherwise the shorter\n       *  one is ordered first.\n      */\n      int\n      compare(size_type __pos, size_type __n1, const _CharT* __s) const;\n\n      /**\n       *  @brief  Compare substring against a character %array.\n       *  @param __pos  Index of first character of substring.\n       *  @param __n1  Number of characters in substring.\n       *  @param __s  character %array to compare against.\n       *  @param __n2  Number of characters of s.\n       *  @return  Integer < 0, 0, or > 0.\n       *\n       *  Form the substring of this string from the @a __n1\n       *  characters starting at @a __pos.  Form a string from the\n       *  first @a __n2 characters of @a __s.  Returns an integer < 0\n       *  if this substring is ordered before the string from @a __s,\n       *  0 if their values are equivalent, or > 0 if this substring\n       *  is ordered after the string from @a __s.  Determines the\n       *  effective length rlen of the strings to compare as the\n       *  smallest of the length of the substring and @a __n2.  The\n       *  function then compares the two strings by calling\n       *  traits::compare(substring.data(),s,rlen).  If the result of\n       *  the comparison is nonzero returns it, otherwise the shorter\n       *  one is ordered first.\n       *\n       *  NB: s must have at least n2 characters, &apos;\\\\0&apos; has\n       *  no special meaning.\n      */\n      int\n      compare(size_type __pos, size_type __n1, const _CharT* __s,\n\t      size_type __n2) const;\n\n# ifdef _GLIBCXX_TM_TS_INTERNAL\n      friend void\n      ::_txnal_cow_string_C1_for_exceptions(void* that, const char* s,\n\t\t\t\t\t    void* exc);\n      friend const char*\n      ::_txnal_cow_string_c_str(const void *that);\n      friend void\n      ::_txnal_cow_string_D1(void *that);\n      friend void\n      ::_txnal_cow_string_D1_commit(void *that);\n# endif\n  };\n#endif  // !_GLIBCXX_USE_CXX11_ABI\n\n  // operator+\n  /**\n   *  @brief  Concatenate two strings.\n   *  @param __lhs  First string.\n   *  @param __rhs  Last string.\n   *  @return  New string with value of @a __lhs followed by @a __rhs.\n   */\n  template<typename _CharT, typename _Traits, typename _Alloc>\n    basic_string<_CharT, _Traits, _Alloc>\n    operator+(const basic_string<_CharT, _Traits, _Alloc>& __lhs,\n\t      const basic_string<_CharT, _Traits, _Alloc>& __rhs)\n    {\n      basic_string<_CharT, _Traits, _Alloc> __str(__lhs);\n      __str.append(__rhs);\n      return __str;\n    }\n\n  /**\n   *  @brief  Concatenate C string and string.\n   *  @param __lhs  First string.\n   *  @param __rhs  Last string.\n   *  @return  New string with value of @a __lhs followed by @a __rhs.\n   */\n  template<typename _CharT, typename _Traits, typename _Alloc>\n    basic_string<_CharT,_Traits,_Alloc>\n    operator+(const _CharT* __lhs,\n\t      const basic_string<_CharT,_Traits,_Alloc>& __rhs);\n\n  /**\n   *  @brief  Concatenate character and string.\n   *  @param __lhs  First string.\n   *  @param __rhs  Last string.\n   *  @return  New string with @a __lhs followed by @a __rhs.\n   */\n  template<typename _CharT, typename _Traits, typename _Alloc>\n    basic_string<_CharT,_Traits,_Alloc>\n    operator+(_CharT __lhs, const basic_string<_CharT,_Traits,_Alloc>& __rhs);\n\n  /**\n   *  @brief  Concatenate string and C string.\n   *  @param __lhs  First string.\n   *  @param __rhs  Last string.\n   *  @return  New string with @a __lhs followed by @a __rhs.\n   */\n  template<typename _CharT, typename _Traits, typename _Alloc>\n    inline basic_string<_CharT, _Traits, _Alloc>\n    operator+(const basic_string<_CharT, _Traits, _Alloc>& __lhs,\n\t      const _CharT* __rhs)\n    {\n      basic_string<_CharT, _Traits, _Alloc> __str(__lhs);\n      __str.append(__rhs);\n      return __str;\n    }\n\n  /**\n   *  @brief  Concatenate string and character.\n   *  @param __lhs  First string.\n   *  @param __rhs  Last string.\n   *  @return  New string with @a __lhs followed by @a __rhs.\n   */\n  template<typename _CharT, typename _Traits, typename _Alloc>\n    inline basic_string<_CharT, _Traits, _Alloc>\n    operator+(const basic_string<_CharT, _Traits, _Alloc>& __lhs, _CharT __rhs)\n    {\n      typedef basic_string<_CharT, _Traits, _Alloc>\t__string_type;\n      typedef typename __string_type::size_type\t\t__size_type;\n      __string_type __str(__lhs);\n      __str.append(__size_type(1), __rhs);\n      return __str;\n    }\n\n#if __cplusplus >= 201103L\n  template<typename _CharT, typename _Traits, typename _Alloc>\n    inline basic_string<_CharT, _Traits, _Alloc>\n    operator+(basic_string<_CharT, _Traits, _Alloc>&& __lhs,\n\t      const basic_string<_CharT, _Traits, _Alloc>& __rhs)\n    { return std::move(__lhs.append(__rhs)); }\n\n  template<typename _CharT, typename _Traits, typename _Alloc>\n    inline basic_string<_CharT, _Traits, _Alloc>\n    operator+(const basic_string<_CharT, _Traits, _Alloc>& __lhs,\n\t      basic_string<_CharT, _Traits, _Alloc>&& __rhs)\n    { return std::move(__rhs.insert(0, __lhs)); }\n\n  template<typename _CharT, typename _Traits, typename _Alloc>\n    inline basic_string<_CharT, _Traits, _Alloc>\n    operator+(basic_string<_CharT, _Traits, _Alloc>&& __lhs,\n\t      basic_string<_CharT, _Traits, _Alloc>&& __rhs)\n    {\n      const auto __size = __lhs.size() + __rhs.size();\n      const bool __cond = (__size > __lhs.capacity()\n\t\t\t   && __size <= __rhs.capacity());\n      return __cond ? std::move(__rhs.insert(0, __lhs))\n\t            : std::move(__lhs.append(__rhs));\n    }\n\n  template<typename _CharT, typename _Traits, typename _Alloc>\n    inline basic_string<_CharT, _Traits, _Alloc>\n    operator+(const _CharT* __lhs,\n\t      basic_string<_CharT, _Traits, _Alloc>&& __rhs)\n    { return std::move(__rhs.insert(0, __lhs)); }\n\n  template<typename _CharT, typename _Traits, typename _Alloc>\n    inline basic_string<_CharT, _Traits, _Alloc>\n    operator+(_CharT __lhs,\n\t      basic_string<_CharT, _Traits, _Alloc>&& __rhs)\n    { return std::move(__rhs.insert(0, 1, __lhs)); }\n\n  template<typename _CharT, typename _Traits, typename _Alloc>\n    inline basic_string<_CharT, _Traits, _Alloc>\n    operator+(basic_string<_CharT, _Traits, _Alloc>&& __lhs,\n\t      const _CharT* __rhs)\n    { return std::move(__lhs.append(__rhs)); }\n\n  template<typename _CharT, typename _Traits, typename _Alloc>\n    inline basic_string<_CharT, _Traits, _Alloc>\n    operator+(basic_string<_CharT, _Traits, _Alloc>&& __lhs,\n\t      _CharT __rhs)\n    { return std::move(__lhs.append(1, __rhs)); }\n#endif\n\n  // operator ==\n  /**\n   *  @brief  Test equivalence of two strings.\n   *  @param __lhs  First string.\n   *  @param __rhs  Second string.\n   *  @return  True if @a __lhs.compare(@a __rhs) == 0.  False otherwise.\n   */\n  template<typename _CharT, typename _Traits, typename _Alloc>\n    inline bool\n    operator==(const basic_string<_CharT, _Traits, _Alloc>& __lhs,\n\t       const basic_string<_CharT, _Traits, _Alloc>& __rhs)\n    _GLIBCXX_NOEXCEPT\n    { return __lhs.compare(__rhs) == 0; }\n\n  template<typename _CharT>\n    inline\n    typename __gnu_cxx::__enable_if<__is_char<_CharT>::__value, bool>::__type\n    operator==(const basic_string<_CharT>& __lhs,\n\t       const basic_string<_CharT>& __rhs) _GLIBCXX_NOEXCEPT\n    { return (__lhs.size() == __rhs.size()\n\t      && !std::char_traits<_CharT>::compare(__lhs.data(), __rhs.data(),\n\t\t\t\t\t\t    __lhs.size())); }\n\n  /**\n   *  @brief  Test equivalence of C string and string.\n   *  @param __lhs  C string.\n   *  @param __rhs  String.\n   *  @return  True if @a __rhs.compare(@a __lhs) == 0.  False otherwise.\n   */\n  template<typename _CharT, typename _Traits, typename _Alloc>\n    inline bool\n    operator==(const _CharT* __lhs,\n\t       const basic_string<_CharT, _Traits, _Alloc>& __rhs)\n    { return __rhs.compare(__lhs) == 0; }\n\n  /**\n   *  @brief  Test equivalence of string and C string.\n   *  @param __lhs  String.\n   *  @param __rhs  C string.\n   *  @return  True if @a __lhs.compare(@a __rhs) == 0.  False otherwise.\n   */\n  template<typename _CharT, typename _Traits, typename _Alloc>\n    inline bool\n    operator==(const basic_string<_CharT, _Traits, _Alloc>& __lhs,\n\t       const _CharT* __rhs)\n    { return __lhs.compare(__rhs) == 0; }\n\n  // operator !=\n  /**\n   *  @brief  Test difference of two strings.\n   *  @param __lhs  First string.\n   *  @param __rhs  Second string.\n   *  @return  True if @a __lhs.compare(@a __rhs) != 0.  False otherwise.\n   */\n  template<typename _CharT, typename _Traits, typename _Alloc>\n    inline bool\n    operator!=(const basic_string<_CharT, _Traits, _Alloc>& __lhs,\n\t       const basic_string<_CharT, _Traits, _Alloc>& __rhs)\n    _GLIBCXX_NOEXCEPT\n    { return !(__lhs == __rhs); }\n\n  /**\n   *  @brief  Test difference of C string and string.\n   *  @param __lhs  C string.\n   *  @param __rhs  String.\n   *  @return  True if @a __rhs.compare(@a __lhs) != 0.  False otherwise.\n   */\n  template<typename _CharT, typename _Traits, typename _Alloc>\n    inline bool\n    operator!=(const _CharT* __lhs,\n\t       const basic_string<_CharT, _Traits, _Alloc>& __rhs)\n    { return !(__lhs == __rhs); }\n\n  /**\n   *  @brief  Test difference of string and C string.\n   *  @param __lhs  String.\n   *  @param __rhs  C string.\n   *  @return  True if @a __lhs.compare(@a __rhs) != 0.  False otherwise.\n   */\n  template<typename _CharT, typename _Traits, typename _Alloc>\n    inline bool\n    operator!=(const basic_string<_CharT, _Traits, _Alloc>& __lhs,\n\t       const _CharT* __rhs)\n    { return !(__lhs == __rhs); }\n\n  // operator <\n  /**\n   *  @brief  Test if string precedes string.\n   *  @param __lhs  First string.\n   *  @param __rhs  Second string.\n   *  @return  True if @a __lhs precedes @a __rhs.  False otherwise.\n   */\n  template<typename _CharT, typename _Traits, typename _Alloc>\n    inline bool\n    operator<(const basic_string<_CharT, _Traits, _Alloc>& __lhs,\n\t      const basic_string<_CharT, _Traits, _Alloc>& __rhs)\n    _GLIBCXX_NOEXCEPT\n    { return __lhs.compare(__rhs) < 0; }\n\n  /**\n   *  @brief  Test if string precedes C string.\n   *  @param __lhs  String.\n   *  @param __rhs  C string.\n   *  @return  True if @a __lhs precedes @a __rhs.  False otherwise.\n   */\n  template<typename _CharT, typename _Traits, typename _Alloc>\n    inline bool\n    operator<(const basic_string<_CharT, _Traits, _Alloc>& __lhs,\n\t      const _CharT* __rhs)\n    { return __lhs.compare(__rhs) < 0; }\n\n  /**\n   *  @brief  Test if C string precedes string.\n   *  @param __lhs  C string.\n   *  @param __rhs  String.\n   *  @return  True if @a __lhs precedes @a __rhs.  False otherwise.\n   */\n  template<typename _CharT, typename _Traits, typename _Alloc>\n    inline bool\n    operator<(const _CharT* __lhs,\n\t      const basic_string<_CharT, _Traits, _Alloc>& __rhs)\n    { return __rhs.compare(__lhs) > 0; }\n\n  // operator >\n  /**\n   *  @brief  Test if string follows string.\n   *  @param __lhs  First string.\n   *  @param __rhs  Second string.\n   *  @return  True if @a __lhs follows @a __rhs.  False otherwise.\n   */\n  template<typename _CharT, typename _Traits, typename _Alloc>\n    inline bool\n    operator>(const basic_string<_CharT, _Traits, _Alloc>& __lhs,\n\t      const basic_string<_CharT, _Traits, _Alloc>& __rhs)\n    _GLIBCXX_NOEXCEPT\n    { return __lhs.compare(__rhs) > 0; }\n\n  /**\n   *  @brief  Test if string follows C string.\n   *  @param __lhs  String.\n   *  @param __rhs  C string.\n   *  @return  True if @a __lhs follows @a __rhs.  False otherwise.\n   */\n  template<typename _CharT, typename _Traits, typename _Alloc>\n    inline bool\n    operator>(const basic_string<_CharT, _Traits, _Alloc>& __lhs,\n\t      const _CharT* __rhs)\n    { return __lhs.compare(__rhs) > 0; }\n\n  /**\n   *  @brief  Test if C string follows string.\n   *  @param __lhs  C string.\n   *  @param __rhs  String.\n   *  @return  True if @a __lhs follows @a __rhs.  False otherwise.\n   */\n  template<typename _CharT, typename _Traits, typename _Alloc>\n    inline bool\n    operator>(const _CharT* __lhs,\n\t      const basic_string<_CharT, _Traits, _Alloc>& __rhs)\n    { return __rhs.compare(__lhs) < 0; }\n\n  // operator <=\n  /**\n   *  @brief  Test if string doesn't follow string.\n   *  @param __lhs  First string.\n   *  @param __rhs  Second string.\n   *  @return  True if @a __lhs doesn't follow @a __rhs.  False otherwise.\n   */\n  template<typename _CharT, typename _Traits, typename _Alloc>\n    inline bool\n    operator<=(const basic_string<_CharT, _Traits, _Alloc>& __lhs,\n\t       const basic_string<_CharT, _Traits, _Alloc>& __rhs)\n    _GLIBCXX_NOEXCEPT\n    { return __lhs.compare(__rhs) <= 0; }\n\n  /**\n   *  @brief  Test if string doesn't follow C string.\n   *  @param __lhs  String.\n   *  @param __rhs  C string.\n   *  @return  True if @a __lhs doesn't follow @a __rhs.  False otherwise.\n   */\n  template<typename _CharT, typename _Traits, typename _Alloc>\n    inline bool\n    operator<=(const basic_string<_CharT, _Traits, _Alloc>& __lhs,\n\t       const _CharT* __rhs)\n    { return __lhs.compare(__rhs) <= 0; }\n\n  /**\n   *  @brief  Test if C string doesn't follow string.\n   *  @param __lhs  C string.\n   *  @param __rhs  String.\n   *  @return  True if @a __lhs doesn't follow @a __rhs.  False otherwise.\n   */\n  template<typename _CharT, typename _Traits, typename _Alloc>\n    inline bool\n    operator<=(const _CharT* __lhs,\n\t       const basic_string<_CharT, _Traits, _Alloc>& __rhs)\n    { return __rhs.compare(__lhs) >= 0; }\n\n  // operator >=\n  /**\n   *  @brief  Test if string doesn't precede string.\n   *  @param __lhs  First string.\n   *  @param __rhs  Second string.\n   *  @return  True if @a __lhs doesn't precede @a __rhs.  False otherwise.\n   */\n  template<typename _CharT, typename _Traits, typename _Alloc>\n    inline bool\n    operator>=(const basic_string<_CharT, _Traits, _Alloc>& __lhs,\n\t       const basic_string<_CharT, _Traits, _Alloc>& __rhs)\n    _GLIBCXX_NOEXCEPT\n    { return __lhs.compare(__rhs) >= 0; }\n\n  /**\n   *  @brief  Test if string doesn't precede C string.\n   *  @param __lhs  String.\n   *  @param __rhs  C string.\n   *  @return  True if @a __lhs doesn't precede @a __rhs.  False otherwise.\n   */\n  template<typename _CharT, typename _Traits, typename _Alloc>\n    inline bool\n    operator>=(const basic_string<_CharT, _Traits, _Alloc>& __lhs,\n\t       const _CharT* __rhs)\n    { return __lhs.compare(__rhs) >= 0; }\n\n  /**\n   *  @brief  Test if C string doesn't precede string.\n   *  @param __lhs  C string.\n   *  @param __rhs  String.\n   *  @return  True if @a __lhs doesn't precede @a __rhs.  False otherwise.\n   */\n  template<typename _CharT, typename _Traits, typename _Alloc>\n    inline bool\n    operator>=(const _CharT* __lhs,\n\t     const basic_string<_CharT, _Traits, _Alloc>& __rhs)\n    { return __rhs.compare(__lhs) <= 0; }\n\n  /**\n   *  @brief  Swap contents of two strings.\n   *  @param __lhs  First string.\n   *  @param __rhs  Second string.\n   *\n   *  Exchanges the contents of @a __lhs and @a __rhs in constant time.\n   */\n  template<typename _CharT, typename _Traits, typename _Alloc>\n    inline void\n    swap(basic_string<_CharT, _Traits, _Alloc>& __lhs,\n\t basic_string<_CharT, _Traits, _Alloc>& __rhs)\n    _GLIBCXX_NOEXCEPT_IF(noexcept(__lhs.swap(__rhs)))\n    { __lhs.swap(__rhs); }\n\n\n  /**\n   *  @brief  Read stream into a string.\n   *  @param __is  Input stream.\n   *  @param __str  Buffer to store into.\n   *  @return  Reference to the input stream.\n   *\n   *  Stores characters from @a __is into @a __str until whitespace is\n   *  found, the end of the stream is encountered, or str.max_size()\n   *  is reached.  If is.width() is non-zero, that is the limit on the\n   *  number of characters stored into @a __str.  Any previous\n   *  contents of @a __str are erased.\n   */\n  template<typename _CharT, typename _Traits, typename _Alloc>\n    basic_istream<_CharT, _Traits>&\n    operator>>(basic_istream<_CharT, _Traits>& __is,\n\t       basic_string<_CharT, _Traits, _Alloc>& __str);\n\n  template<>\n    basic_istream<char>&\n    operator>>(basic_istream<char>& __is, basic_string<char>& __str);\n\n  /**\n   *  @brief  Write string to a stream.\n   *  @param __os  Output stream.\n   *  @param __str  String to write out.\n   *  @return  Reference to the output stream.\n   *\n   *  Output characters of @a __str into os following the same rules as for\n   *  writing a C string.\n   */\n  template<typename _CharT, typename _Traits, typename _Alloc>\n    inline basic_ostream<_CharT, _Traits>&\n    operator<<(basic_ostream<_CharT, _Traits>& __os,\n\t       const basic_string<_CharT, _Traits, _Alloc>& __str)\n    {\n      // _GLIBCXX_RESOLVE_LIB_DEFECTS\n      // 586. string inserter not a formatted function\n      return __ostream_insert(__os, __str.data(), __str.size());\n    }\n\n  /**\n   *  @brief  Read a line from stream into a string.\n   *  @param __is  Input stream.\n   *  @param __str  Buffer to store into.\n   *  @param __delim  Character marking end of line.\n   *  @return  Reference to the input stream.\n   *\n   *  Stores characters from @a __is into @a __str until @a __delim is\n   *  found, the end of the stream is encountered, or str.max_size()\n   *  is reached.  Any previous contents of @a __str are erased.  If\n   *  @a __delim is encountered, it is extracted but not stored into\n   *  @a __str.\n   */\n  template<typename _CharT, typename _Traits, typename _Alloc>\n    basic_istream<_CharT, _Traits>&\n    getline(basic_istream<_CharT, _Traits>& __is,\n\t    basic_string<_CharT, _Traits, _Alloc>& __str, _CharT __delim);\n\n  /**\n   *  @brief  Read a line from stream into a string.\n   *  @param __is  Input stream.\n   *  @param __str  Buffer to store into.\n   *  @return  Reference to the input stream.\n   *\n   *  Stores characters from is into @a __str until &apos;\\n&apos; is\n   *  found, the end of the stream is encountered, or str.max_size()\n   *  is reached.  Any previous contents of @a __str are erased.  If\n   *  end of line is encountered, it is extracted but not stored into\n   *  @a __str.\n   */\n  template<typename _CharT, typename _Traits, typename _Alloc>\n    inline basic_istream<_CharT, _Traits>&\n    getline(basic_istream<_CharT, _Traits>& __is,\n\t    basic_string<_CharT, _Traits, _Alloc>& __str)\n    { return std::getline(__is, __str, __is.widen('\\n')); }\n\n#if __cplusplus >= 201103L\n  /// Read a line from an rvalue stream into a string.\n  template<typename _CharT, typename _Traits, typename _Alloc>\n    inline basic_istream<_CharT, _Traits>&\n    getline(basic_istream<_CharT, _Traits>&& __is,\n\t    basic_string<_CharT, _Traits, _Alloc>& __str, _CharT __delim)\n    { return std::getline(__is, __str, __delim); }\n\n  /// Read a line from an rvalue stream into a string.\n  template<typename _CharT, typename _Traits, typename _Alloc>\n    inline basic_istream<_CharT, _Traits>&\n    getline(basic_istream<_CharT, _Traits>&& __is,\n\t    basic_string<_CharT, _Traits, _Alloc>& __str)\n    { return std::getline(__is, __str); }\n#endif\n\n  template<>\n    basic_istream<char>&\n    getline(basic_istream<char>& __in, basic_string<char>& __str,\n\t    char __delim);\n\n#ifdef _GLIBCXX_USE_WCHAR_T\n  template<>\n    basic_istream<wchar_t>&\n    getline(basic_istream<wchar_t>& __in, basic_string<wchar_t>& __str,\n\t    wchar_t __delim);\n#endif  \n\n_GLIBCXX_END_NAMESPACE_VERSION\n} // namespace\n\n#if __cplusplus >= 201103L\n\n#include <ext/string_conversions.h>\n\nnamespace std _GLIBCXX_VISIBILITY(default)\n{\n_GLIBCXX_BEGIN_NAMESPACE_VERSION\n_GLIBCXX_BEGIN_NAMESPACE_CXX11\n\n#if _GLIBCXX_USE_C99_STDLIB\n  // 21.4 Numeric Conversions [string.conversions].\n  inline int\n  stoi(const string& __str, size_t* __idx = 0, int __base = 10)\n  { return __gnu_cxx::__stoa<long, int>(&std::strtol, \"stoi\", __str.c_str(),\n\t\t\t\t\t__idx, __base); }\n\n  inline long\n  stol(const string& __str, size_t* __idx = 0, int __base = 10)\n  { return __gnu_cxx::__stoa(&std::strtol, \"stol\", __str.c_str(),\n\t\t\t     __idx, __base); }\n\n  inline unsigned long\n  stoul(const string& __str, size_t* __idx = 0, int __base = 10)\n  { return __gnu_cxx::__stoa(&std::strtoul, \"stoul\", __str.c_str(),\n\t\t\t     __idx, __base); }\n\n  inline long long\n  stoll(const string& __str, size_t* __idx = 0, int __base = 10)\n  { return __gnu_cxx::__stoa(&std::strtoll, \"stoll\", __str.c_str(),\n\t\t\t     __idx, __base); }\n\n  inline unsigned long long\n  stoull(const string& __str, size_t* __idx = 0, int __base = 10)\n  { return __gnu_cxx::__stoa(&std::strtoull, \"stoull\", __str.c_str(),\n\t\t\t     __idx, __base); }\n\n  // NB: strtof vs strtod.\n  inline float\n  stof(const string& __str, size_t* __idx = 0)\n  { return __gnu_cxx::__stoa(&std::strtof, \"stof\", __str.c_str(), __idx); }\n\n  inline double\n  stod(const string& __str, size_t* __idx = 0)\n  { return __gnu_cxx::__stoa(&std::strtod, \"stod\", __str.c_str(), __idx); }\n\n  inline long double\n  stold(const string& __str, size_t* __idx = 0)\n  { return __gnu_cxx::__stoa(&std::strtold, \"stold\", __str.c_str(), __idx); }\n#endif // _GLIBCXX_USE_C99_STDLIB\n\n#if _GLIBCXX_USE_C99_STDIO\n  // NB: (v)snprintf vs sprintf.\n\n  // DR 1261.\n  inline string\n  to_string(int __val)\n  { return __gnu_cxx::__to_xstring<string>(&std::vsnprintf, 4 * sizeof(int),\n\t\t\t\t\t   \"%d\", __val); }\n\n  inline string\n  to_string(unsigned __val)\n  { return __gnu_cxx::__to_xstring<string>(&std::vsnprintf,\n\t\t\t\t\t   4 * sizeof(unsigned),\n\t\t\t\t\t   \"%u\", __val); }\n\n  inline string\n  to_string(long __val)\n  { return __gnu_cxx::__to_xstring<string>(&std::vsnprintf, 4 * sizeof(long),\n\t\t\t\t\t   \"%ld\", __val); }\n\n  inline string\n  to_string(unsigned long __val)\n  { return __gnu_cxx::__to_xstring<string>(&std::vsnprintf,\n\t\t\t\t\t   4 * sizeof(unsigned long),\n\t\t\t\t\t   \"%lu\", __val); }\n\n  inline string\n  to_string(long long __val)\n  { return __gnu_cxx::__to_xstring<string>(&std::vsnprintf,\n\t\t\t\t\t   4 * sizeof(long long),\n\t\t\t\t\t   \"%lld\", __val); }\n\n  inline string\n  to_string(unsigned long long __val)\n  { return __gnu_cxx::__to_xstring<string>(&std::vsnprintf,\n\t\t\t\t\t   4 * sizeof(unsigned long long),\n\t\t\t\t\t   \"%llu\", __val); }\n\n  inline string\n  to_string(float __val)\n  {\n    const int __n = \n      __gnu_cxx::__numeric_traits<float>::__max_exponent10 + 20;\n    return __gnu_cxx::__to_xstring<string>(&std::vsnprintf, __n,\n\t\t\t\t\t   \"%f\", __val);\n  }\n\n  inline string\n  to_string(double __val)\n  {\n    const int __n = \n      __gnu_cxx::__numeric_traits<double>::__max_exponent10 + 20;\n    return __gnu_cxx::__to_xstring<string>(&std::vsnprintf, __n,\n\t\t\t\t\t   \"%f\", __val);\n  }\n\n  inline string\n  to_string(long double __val)\n  {\n    const int __n = \n      __gnu_cxx::__numeric_traits<long double>::__max_exponent10 + 20;\n    return __gnu_cxx::__to_xstring<string>(&std::vsnprintf, __n,\n\t\t\t\t\t   \"%Lf\", __val);\n  }\n#endif // _GLIBCXX_USE_C99_STDIO\n\n#if defined(_GLIBCXX_USE_WCHAR_T) && _GLIBCXX_USE_C99_WCHAR\n  inline int \n  stoi(const wstring& __str, size_t* __idx = 0, int __base = 10)\n  { return __gnu_cxx::__stoa<long, int>(&std::wcstol, \"stoi\", __str.c_str(),\n\t\t\t\t\t__idx, __base); }\n\n  inline long \n  stol(const wstring& __str, size_t* __idx = 0, int __base = 10)\n  { return __gnu_cxx::__stoa(&std::wcstol, \"stol\", __str.c_str(),\n\t\t\t     __idx, __base); }\n\n  inline unsigned long\n  stoul(const wstring& __str, size_t* __idx = 0, int __base = 10)\n  { return __gnu_cxx::__stoa(&std::wcstoul, \"stoul\", __str.c_str(),\n\t\t\t     __idx, __base); }\n\n  inline long long\n  stoll(const wstring& __str, size_t* __idx = 0, int __base = 10)\n  { return __gnu_cxx::__stoa(&std::wcstoll, \"stoll\", __str.c_str(),\n\t\t\t     __idx, __base); }\n\n  inline unsigned long long\n  stoull(const wstring& __str, size_t* __idx = 0, int __base = 10)\n  { return __gnu_cxx::__stoa(&std::wcstoull, \"stoull\", __str.c_str(),\n\t\t\t     __idx, __base); }\n\n  // NB: wcstof vs wcstod.\n  inline float\n  stof(const wstring& __str, size_t* __idx = 0)\n  { return __gnu_cxx::__stoa(&std::wcstof, \"stof\", __str.c_str(), __idx); }\n\n  inline double\n  stod(const wstring& __str, size_t* __idx = 0)\n  { return __gnu_cxx::__stoa(&std::wcstod, \"stod\", __str.c_str(), __idx); }\n\n  inline long double\n  stold(const wstring& __str, size_t* __idx = 0)\n  { return __gnu_cxx::__stoa(&std::wcstold, \"stold\", __str.c_str(), __idx); }\n\n#ifndef _GLIBCXX_HAVE_BROKEN_VSWPRINTF\n  // DR 1261.\n  inline wstring\n  to_wstring(int __val)\n  { return __gnu_cxx::__to_xstring<wstring>(&std::vswprintf, 4 * sizeof(int),\n\t\t\t\t\t    L\"%d\", __val); }\n\n  inline wstring\n  to_wstring(unsigned __val)\n  { return __gnu_cxx::__to_xstring<wstring>(&std::vswprintf,\n\t\t\t\t\t    4 * sizeof(unsigned),\n\t\t\t\t\t    L\"%u\", __val); }\n\n  inline wstring\n  to_wstring(long __val)\n  { return __gnu_cxx::__to_xstring<wstring>(&std::vswprintf, 4 * sizeof(long),\n\t\t\t\t\t    L\"%ld\", __val); }\n\n  inline wstring\n  to_wstring(unsigned long __val)\n  { return __gnu_cxx::__to_xstring<wstring>(&std::vswprintf,\n\t\t\t\t\t    4 * sizeof(unsigned long),\n\t\t\t\t\t    L\"%lu\", __val); }\n\n  inline wstring\n  to_wstring(long long __val)\n  { return __gnu_cxx::__to_xstring<wstring>(&std::vswprintf,\n\t\t\t\t\t    4 * sizeof(long long),\n\t\t\t\t\t    L\"%lld\", __val); }\n\n  inline wstring\n  to_wstring(unsigned long long __val)\n  { return __gnu_cxx::__to_xstring<wstring>(&std::vswprintf,\n\t\t\t\t\t    4 * sizeof(unsigned long long),\n\t\t\t\t\t    L\"%llu\", __val); }\n\n  inline wstring\n  to_wstring(float __val)\n  {\n    const int __n =\n      __gnu_cxx::__numeric_traits<float>::__max_exponent10 + 20;\n    return __gnu_cxx::__to_xstring<wstring>(&std::vswprintf, __n,\n\t\t\t\t\t    L\"%f\", __val);\n  }\n\n  inline wstring\n  to_wstring(double __val)\n  {\n    const int __n =\n      __gnu_cxx::__numeric_traits<double>::__max_exponent10 + 20;\n    return __gnu_cxx::__to_xstring<wstring>(&std::vswprintf, __n,\n\t\t\t\t\t    L\"%f\", __val);\n  }\n\n  inline wstring\n  to_wstring(long double __val)\n  {\n    const int __n =\n      __gnu_cxx::__numeric_traits<long double>::__max_exponent10 + 20;\n    return __gnu_cxx::__to_xstring<wstring>(&std::vswprintf, __n,\n\t\t\t\t\t    L\"%Lf\", __val);\n  }\n#endif // _GLIBCXX_HAVE_BROKEN_VSWPRINTF\n#endif // _GLIBCXX_USE_WCHAR_T && _GLIBCXX_USE_C99_WCHAR\n\n_GLIBCXX_END_NAMESPACE_CXX11\n_GLIBCXX_END_NAMESPACE_VERSION\n} // namespace\n\n#endif /* C++11 */\n\n#if __cplusplus >= 201103L\n\n#include <bits/functional_hash.h>\n\nnamespace std _GLIBCXX_VISIBILITY(default)\n{\n_GLIBCXX_BEGIN_NAMESPACE_VERSION\n\n  // DR 1182.\n\n#ifndef _GLIBCXX_COMPATIBILITY_CXX0X\n  /// std::hash specialization for string.\n  template<>\n    struct hash<string>\n    : public __hash_base<size_t, string>\n    {\n      size_t\n      operator()(const string& __s) const noexcept\n      { return std::_Hash_impl::hash(__s.data(), __s.length()); }\n    };\n\n  template<>\n    struct __is_fast_hash<hash<string>> : std::false_type\n    { };\n\n#ifdef _GLIBCXX_USE_WCHAR_T\n  /// std::hash specialization for wstring.\n  template<>\n    struct hash<wstring>\n    : public __hash_base<size_t, wstring>\n    {\n      size_t\n      operator()(const wstring& __s) const noexcept\n      { return std::_Hash_impl::hash(__s.data(),\n                                     __s.length() * sizeof(wchar_t)); }\n    };\n\n  template<>\n    struct __is_fast_hash<hash<wstring>> : std::false_type\n    { };\n#endif\n#endif /* _GLIBCXX_COMPATIBILITY_CXX0X */\n\n#ifdef _GLIBCXX_USE_C99_STDINT_TR1\n  /// std::hash specialization for u16string.\n  template<>\n    struct hash<u16string>\n    : public __hash_base<size_t, u16string>\n    {\n      size_t\n      operator()(const u16string& __s) const noexcept\n      { return std::_Hash_impl::hash(__s.data(),\n                                     __s.length() * sizeof(char16_t)); }\n    };\n\n  template<>\n    struct __is_fast_hash<hash<u16string>> : std::false_type\n    { };\n\n  /// std::hash specialization for u32string.\n  template<>\n    struct hash<u32string>\n    : public __hash_base<size_t, u32string>\n    {\n      size_t\n      operator()(const u32string& __s) const noexcept\n      { return std::_Hash_impl::hash(__s.data(),\n                                     __s.length() * sizeof(char32_t)); }\n    };\n\n  template<>\n    struct __is_fast_hash<hash<u32string>> : std::false_type\n    { };\n#endif\n\n_GLIBCXX_END_NAMESPACE_VERSION\n\n#if __cplusplus > 201103L\n\n#define __cpp_lib_string_udls 201304\n\n  inline namespace literals\n  {\n  inline namespace string_literals\n  {\n_GLIBCXX_BEGIN_NAMESPACE_VERSION\n\n    _GLIBCXX_DEFAULT_ABI_TAG\n    inline basic_string<char>\n    operator\"\"s(const char* __str, size_t __len)\n    { return basic_string<char>{__str, __len}; }\n\n#ifdef _GLIBCXX_USE_WCHAR_T\n    _GLIBCXX_DEFAULT_ABI_TAG\n    inline basic_string<wchar_t>\n    operator\"\"s(const wchar_t* __str, size_t __len)\n    { return basic_string<wchar_t>{__str, __len}; }\n#endif\n\n#ifdef _GLIBCXX_USE_C99_STDINT_TR1\n    _GLIBCXX_DEFAULT_ABI_TAG\n    inline basic_string<char16_t>\n    operator\"\"s(const char16_t* __str, size_t __len)\n    { return basic_string<char16_t>{__str, __len}; }\n\n    _GLIBCXX_DEFAULT_ABI_TAG\n    inline basic_string<char32_t>\n    operator\"\"s(const char32_t* __str, size_t __len)\n    { return basic_string<char32_t>{__str, __len}; }\n#endif\n\n_GLIBCXX_END_NAMESPACE_VERSION\n  } // inline namespace string_literals\n  } // inline namespace literals\n\n#endif // __cplusplus > 201103L\n\n} // namespace std\n\n#endif // C++11\n\n#endif /* _BASIC_STRING_H */\n"}, "4": {"id": 4, "path": "/usr/include/assert.h", "content": "/* Copyright (C) 1991-2018 Free Software Foundation, Inc.\n   This file is part of the GNU C Library.\n\n   The GNU C Library is free software; you can redistribute it and/or\n   modify it under the terms of the GNU Lesser General Public\n   License as published by the Free Software Foundation; either\n   version 2.1 of the License, or (at your option) any later version.\n\n   The GNU C Library is distributed in the hope that it will be useful,\n   but WITHOUT ANY WARRANTY; without even the implied warranty of\n   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n   Lesser General Public License for more details.\n\n   You should have received a copy of the GNU Lesser General Public\n   License along with the GNU C Library; if not, see\n   <http://www.gnu.org/licenses/>.  */\n\n/*\n *\tISO C99 Standard: 7.2 Diagnostics\t<assert.h>\n */\n\n#ifdef\t_ASSERT_H\n\n# undef\t_ASSERT_H\n# undef\tassert\n# undef __ASSERT_VOID_CAST\n\n# ifdef\t__USE_GNU\n#  undef assert_perror\n# endif\n\n#endif /* assert.h\t*/\n\n#define\t_ASSERT_H\t1\n#include <features.h>\n\n#if defined __cplusplus && __GNUC_PREREQ (2,95)\n# define __ASSERT_VOID_CAST static_cast<void>\n#else\n# define __ASSERT_VOID_CAST (void)\n#endif\n\n/* void assert (int expression);\n\n   If NDEBUG is defined, do nothing.\n   If not, and EXPRESSION is zero, print an error message and abort.  */\n\n#ifdef\tNDEBUG\n\n# define assert(expr)\t\t(__ASSERT_VOID_CAST (0))\n\n/* void assert_perror (int errnum);\n\n   If NDEBUG is defined, do nothing.  If not, and ERRNUM is not zero, print an\n   error message with the error text for ERRNUM and abort.\n   (This is a GNU extension.) */\n\n# ifdef\t__USE_GNU\n#  define assert_perror(errnum)\t(__ASSERT_VOID_CAST (0))\n# endif\n\n#else /* Not NDEBUG.  */\n\n#ifndef _ASSERT_H_DECLS\n#define _ASSERT_H_DECLS\n__BEGIN_DECLS\n\n/* This prints an \"Assertion failed\" message and aborts.  */\nextern void __assert_fail (const char *__assertion, const char *__file,\n\t\t\t   unsigned int __line, const char *__function)\n     __THROW __attribute__ ((__noreturn__));\n\n/* Likewise, but prints the error text for ERRNUM.  */\nextern void __assert_perror_fail (int __errnum, const char *__file,\n\t\t\t\t  unsigned int __line, const char *__function)\n     __THROW __attribute__ ((__noreturn__));\n\n\n/* The following is not at all used here but needed for standard\n   compliance.  */\nextern void __assert (const char *__assertion, const char *__file, int __line)\n     __THROW __attribute__ ((__noreturn__));\n\n\n__END_DECLS\n#endif /* Not _ASSERT_H_DECLS */\n\n/* When possible, define assert so that it does not add extra\n   parentheses around EXPR.  Otherwise, those added parentheses would\n   suppress warnings we'd expect to be detected by gcc's -Wparentheses.  */\n# if defined __cplusplus\n#  define assert(expr)\t\t\t\t\t\t\t\\\n     (static_cast <bool> (expr)\t\t\t\t\t\t\\\n      ? void (0)\t\t\t\t\t\t\t\\\n      : __assert_fail (#expr, __FILE__, __LINE__, __ASSERT_FUNCTION))\n# elif !defined __GNUC__ || defined __STRICT_ANSI__\n#  define assert(expr)\t\t\t\t\t\t\t\\\n    ((expr)\t\t\t\t\t\t\t\t\\\n     ? __ASSERT_VOID_CAST (0)\t\t\t\t\t\t\\\n     : __assert_fail (#expr, __FILE__, __LINE__, __ASSERT_FUNCTION))\n# else\n/* The first occurrence of EXPR is not evaluated due to the sizeof,\n   but will trigger any pedantic warnings masked by the __extension__\n   for the second occurrence.  The ternary operator is required to\n   support function pointers and bit fields in this context, and to\n   suppress the evaluation of variable length arrays.  */\n#  define assert(expr)\t\t\t\t\t\t\t\\\n  ((void) sizeof ((expr) ? 1 : 0), __extension__ ({\t\t\t\\\n      if (expr)\t\t\t\t\t\t\t\t\\\n        ; /* empty */\t\t\t\t\t\t\t\\\n      else\t\t\t\t\t\t\t\t\\\n        __assert_fail (#expr, __FILE__, __LINE__, __ASSERT_FUNCTION);\t\\\n    }))\n# endif\n\n# ifdef\t__USE_GNU\n#  define assert_perror(errnum)\t\t\t\t\t\t\\\n  (!(errnum)\t\t\t\t\t\t\t\t\\\n   ? __ASSERT_VOID_CAST (0)\t\t\t\t\t\t\\\n   : __assert_perror_fail ((errnum), __FILE__, __LINE__, __ASSERT_FUNCTION))\n# endif\n\n/* Version 2.4 and later of GCC define a magical variable `__PRETTY_FUNCTION__'\n   which contains the name of the function currently being defined.\n   This is broken in G++ before version 2.6.\n   C9x has a similar variable called __func__, but prefer the GCC one since\n   it demangles C++ function names.  */\n# if defined __cplusplus ? __GNUC_PREREQ (2, 6) : __GNUC_PREREQ (2, 4)\n#   define __ASSERT_FUNCTION\t__extension__ __PRETTY_FUNCTION__\n# else\n#  if defined __STDC_VERSION__ && __STDC_VERSION__ >= 199901L\n#   define __ASSERT_FUNCTION\t__func__\n#  else\n#   define __ASSERT_FUNCTION\t((const char *) 0)\n#  endif\n# endif\n\n#endif /* NDEBUG.  */\n\n\n#if defined __USE_ISOC11 && !defined __cplusplus\n# undef static_assert\n# define static_assert _Static_assert\n#endif\n"}, "5": {"id": 5, "path": "/usr/include/c++/7/bits/unique_ptr.h", "content": "// unique_ptr implementation -*- C++ -*-\n\n// Copyright (C) 2008-2017 Free Software Foundation, Inc.\n//\n// This file is part of the GNU ISO C++ Library.  This library is free\n// software; you can redistribute it and/or modify it under the\n// terms of the GNU General Public License as published by the\n// Free Software Foundation; either version 3, or (at your option)\n// any later version.\n\n// This library is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n\n// Under Section 7 of GPL version 3, you are granted additional\n// permissions described in the GCC Runtime Library Exception, version\n// 3.1, as published by the Free Software Foundation.\n\n// You should have received a copy of the GNU General Public License and\n// a copy of the GCC Runtime Library Exception along with this program;\n// see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n// <http://www.gnu.org/licenses/>.\n\n/** @file bits/unique_ptr.h\n *  This is an internal header file, included by other library headers.\n *  Do not attempt to use it directly. @headername{memory}\n */\n\n#ifndef _UNIQUE_PTR_H\n#define _UNIQUE_PTR_H 1\n\n#include <bits/c++config.h>\n#include <debug/assertions.h>\n#include <type_traits>\n#include <utility>\n#include <tuple>\n#include <bits/stl_function.h>\n#include <bits/functional_hash.h>\n\nnamespace std _GLIBCXX_VISIBILITY(default)\n{\n_GLIBCXX_BEGIN_NAMESPACE_VERSION\n\n  /**\n   * @addtogroup pointer_abstractions\n   * @{\n   */\n\n#if _GLIBCXX_USE_DEPRECATED\n  template<typename> class auto_ptr;\n#endif\n\n  /// Primary template of default_delete, used by unique_ptr\n  template<typename _Tp>\n    struct default_delete\n    {\n      /// Default constructor\n      constexpr default_delete() noexcept = default;\n\n      /** @brief Converting constructor.\n       *\n       * Allows conversion from a deleter for arrays of another type, @p _Up,\n       * only if @p _Up* is convertible to @p _Tp*.\n       */\n      template<typename _Up, typename = typename\n\t       enable_if<is_convertible<_Up*, _Tp*>::value>::type>\n        default_delete(const default_delete<_Up>&) noexcept { }\n\n      /// Calls @c delete @p __ptr\n      void\n      operator()(_Tp* __ptr) const\n      {\n\tstatic_assert(!is_void<_Tp>::value,\n\t\t      \"can't delete pointer to incomplete type\");\n\tstatic_assert(sizeof(_Tp)>0,\n\t\t      \"can't delete pointer to incomplete type\");\n\tdelete __ptr;\n      }\n    };\n\n  // _GLIBCXX_RESOLVE_LIB_DEFECTS\n  // DR 740 - omit specialization for array objects with a compile time length\n  /// Specialization for arrays, default_delete.\n  template<typename _Tp>\n    struct default_delete<_Tp[]>\n    {\n    public:\n      /// Default constructor\n      constexpr default_delete() noexcept = default;\n\n      /** @brief Converting constructor.\n       *\n       * Allows conversion from a deleter for arrays of another type, such as\n       * a const-qualified version of @p _Tp.\n       *\n       * Conversions from types derived from @c _Tp are not allowed because\n       * it is unsafe to @c delete[] an array of derived types through a\n       * pointer to the base type.\n       */\n      template<typename _Up, typename = typename\n\t       enable_if<is_convertible<_Up(*)[], _Tp(*)[]>::value>::type>\n        default_delete(const default_delete<_Up[]>&) noexcept { }\n\n      /// Calls @c delete[] @p __ptr\n      template<typename _Up>\n      typename enable_if<is_convertible<_Up(*)[], _Tp(*)[]>::value>::type\n\toperator()(_Up* __ptr) const\n      {\n\tstatic_assert(sizeof(_Tp)>0,\n\t\t      \"can't delete pointer to incomplete type\");\n\tdelete [] __ptr;\n      }\n    };\n\n  template <typename _Tp, typename _Dp>\n    class __uniq_ptr_impl\n    {\n      template <typename _Up, typename _Ep, typename = void>\n\tstruct _Ptr\n\t{\n\t  using type = _Up*;\n\t};\n\n      template <typename _Up, typename _Ep>\n\tstruct\n\t_Ptr<_Up, _Ep, __void_t<typename remove_reference<_Ep>::type::pointer>>\n\t{\n\t  using type = typename remove_reference<_Ep>::type::pointer;\n\t};\n\n    public:\n      using _DeleterConstraint = enable_if<\n        __and_<__not_<is_pointer<_Dp>>,\n\t       is_default_constructible<_Dp>>::value>;\n\n      using pointer = typename _Ptr<_Tp, _Dp>::type;\n\n      __uniq_ptr_impl() = default;\n      __uniq_ptr_impl(pointer __p) : _M_t() { _M_ptr() = __p; }\n\n      template<typename _Del>\n      __uniq_ptr_impl(pointer __p, _Del&& __d)\n\t: _M_t(__p, std::forward<_Del>(__d)) { }\n\n      pointer&   _M_ptr() { return std::get<0>(_M_t); }\n      pointer    _M_ptr() const { return std::get<0>(_M_t); }\n      _Dp&       _M_deleter() { return std::get<1>(_M_t); }\n      const _Dp& _M_deleter() const { return std::get<1>(_M_t); }\n\n    private:\n      tuple<pointer, _Dp> _M_t;\n    };\n\n  /// 20.7.1.2 unique_ptr for single objects.\n  template <typename _Tp, typename _Dp = default_delete<_Tp>>\n    class unique_ptr\n    {\n      template <class _Up>\n      using _DeleterConstraint =\n\ttypename __uniq_ptr_impl<_Tp, _Up>::_DeleterConstraint::type;\n\n      __uniq_ptr_impl<_Tp, _Dp> _M_t;\n\n    public:\n      using pointer\t  = typename __uniq_ptr_impl<_Tp, _Dp>::pointer;\n      using element_type  = _Tp;\n      using deleter_type  = _Dp;\n\n      // helper template for detecting a safe conversion from another\n      // unique_ptr\n      template<typename _Up, typename _Ep>\n\tusing __safe_conversion_up = __and_<\n\t  is_convertible<typename unique_ptr<_Up, _Ep>::pointer, pointer>,\n\t  __not_<is_array<_Up>>\n        >;\n\n      // Constructors.\n\n      /// Default constructor, creates a unique_ptr that owns nothing.\n      template <typename _Up = _Dp,\n\t\ttypename = _DeleterConstraint<_Up>>\n\tconstexpr unique_ptr() noexcept\n\t: _M_t()\n\t{ }\n\n      /** Takes ownership of a pointer.\n       *\n       * @param __p  A pointer to an object of @c element_type\n       *\n       * The deleter will be value-initialized.\n       */\n      template <typename _Up = _Dp,\n\t\ttypename = _DeleterConstraint<_Up>>\n\texplicit\n\tunique_ptr(pointer __p) noexcept\n\t: _M_t(__p)\n        { }\n\n      /** Takes ownership of a pointer.\n       *\n       * @param __p  A pointer to an object of @c element_type\n       * @param __d  A reference to a deleter.\n       *\n       * The deleter will be initialized with @p __d\n       */\n      unique_ptr(pointer __p,\n\t  typename conditional<is_reference<deleter_type>::value,\n\t    deleter_type, const deleter_type&>::type __d) noexcept\n      : _M_t(__p, __d) { }\n\n      /** Takes ownership of a pointer.\n       *\n       * @param __p  A pointer to an object of @c element_type\n       * @param __d  An rvalue reference to a deleter.\n       *\n       * The deleter will be initialized with @p std::move(__d)\n       */\n      unique_ptr(pointer __p,\n\t  typename remove_reference<deleter_type>::type&& __d) noexcept\n      : _M_t(std::move(__p), std::move(__d))\n      { static_assert(!std::is_reference<deleter_type>::value,\n\t\t      \"rvalue deleter bound to reference\"); }\n\n      /// Creates a unique_ptr that owns nothing.\n      template <typename _Up = _Dp,\n\t\ttypename = _DeleterConstraint<_Up>>\n\tconstexpr unique_ptr(nullptr_t) noexcept : _M_t() { }\n\n      // Move constructors.\n\n      /// Move constructor.\n      unique_ptr(unique_ptr&& __u) noexcept\n      : _M_t(__u.release(), std::forward<deleter_type>(__u.get_deleter())) { }\n\n      /** @brief Converting constructor from another type\n       *\n       * Requires that the pointer owned by @p __u is convertible to the\n       * type of pointer owned by this object, @p __u does not own an array,\n       * and @p __u has a compatible deleter type.\n       */\n      template<typename _Up, typename _Ep, typename = _Require<\n               __safe_conversion_up<_Up, _Ep>,\n\t       typename conditional<is_reference<_Dp>::value,\n\t\t\t\t    is_same<_Ep, _Dp>,\n\t\t\t\t    is_convertible<_Ep, _Dp>>::type>>\n\tunique_ptr(unique_ptr<_Up, _Ep>&& __u) noexcept\n\t: _M_t(__u.release(), std::forward<_Ep>(__u.get_deleter()))\n\t{ }\n\n#if _GLIBCXX_USE_DEPRECATED\n      /// Converting constructor from @c auto_ptr\n      template<typename _Up, typename = _Require<\n\t       is_convertible<_Up*, _Tp*>, is_same<_Dp, default_delete<_Tp>>>>\n\tunique_ptr(auto_ptr<_Up>&& __u) noexcept;\n#endif\n\n      /// Destructor, invokes the deleter if the stored pointer is not null.\n      ~unique_ptr() noexcept\n      {\n\tauto& __ptr = _M_t._M_ptr();\n\tif (__ptr != nullptr)\n\t  get_deleter()(__ptr);\n\t__ptr = pointer();\n      }\n\n      // Assignment.\n\n      /** @brief Move assignment operator.\n       *\n       * @param __u  The object to transfer ownership from.\n       *\n       * Invokes the deleter first if this object owns a pointer.\n       */\n      unique_ptr&\n      operator=(unique_ptr&& __u) noexcept\n      {\n\treset(__u.release());\n\tget_deleter() = std::forward<deleter_type>(__u.get_deleter());\n\treturn *this;\n      }\n\n      /** @brief Assignment from another type.\n       *\n       * @param __u  The object to transfer ownership from, which owns a\n       *             convertible pointer to a non-array object.\n       *\n       * Invokes the deleter first if this object owns a pointer.\n       */\n      template<typename _Up, typename _Ep>\n        typename enable_if< __and_<\n          __safe_conversion_up<_Up, _Ep>,\n          is_assignable<deleter_type&, _Ep&&>\n          >::value,\n          unique_ptr&>::type\n\toperator=(unique_ptr<_Up, _Ep>&& __u) noexcept\n\t{\n\t  reset(__u.release());\n\t  get_deleter() = std::forward<_Ep>(__u.get_deleter());\n\t  return *this;\n\t}\n\n      /// Reset the %unique_ptr to empty, invoking the deleter if necessary.\n      unique_ptr&\n      operator=(nullptr_t) noexcept\n      {\n\treset();\n\treturn *this;\n      }\n\n      // Observers.\n\n      /// Dereference the stored pointer.\n      typename add_lvalue_reference<element_type>::type\n      operator*() const\n      {\n\t__glibcxx_assert(get() != pointer());\n\treturn *get();\n      }\n\n      /// Return the stored pointer.\n      pointer\n      operator->() const noexcept\n      {\n\t_GLIBCXX_DEBUG_PEDASSERT(get() != pointer());\n\treturn get();\n      }\n\n      /// Return the stored pointer.\n      pointer\n      get() const noexcept\n      { return _M_t._M_ptr(); }\n\n      /// Return a reference to the stored deleter.\n      deleter_type&\n      get_deleter() noexcept\n      { return _M_t._M_deleter(); }\n\n      /// Return a reference to the stored deleter.\n      const deleter_type&\n      get_deleter() const noexcept\n      { return _M_t._M_deleter(); }\n\n      /// Return @c true if the stored pointer is not null.\n      explicit operator bool() const noexcept\n      { return get() == pointer() ? false : true; }\n\n      // Modifiers.\n\n      /// Release ownership of any stored pointer.\n      pointer\n      release() noexcept\n      {\n\tpointer __p = get();\n\t_M_t._M_ptr() = pointer();\n\treturn __p;\n      }\n\n      /** @brief Replace the stored pointer.\n       *\n       * @param __p  The new pointer to store.\n       *\n       * The deleter will be invoked if a pointer is already owned.\n       */\n      void\n      reset(pointer __p = pointer()) noexcept\n      {\n\tusing std::swap;\n\tswap(_M_t._M_ptr(), __p);\n\tif (__p != pointer())\n\t  get_deleter()(__p);\n      }\n\n      /// Exchange the pointer and deleter with another object.\n      void\n      swap(unique_ptr& __u) noexcept\n      {\n\tusing std::swap;\n\tswap(_M_t, __u._M_t);\n      }\n\n      // Disable copy from lvalue.\n      unique_ptr(const unique_ptr&) = delete;\n      unique_ptr& operator=(const unique_ptr&) = delete;\n  };\n\n  /// 20.7.1.3 unique_ptr for array objects with a runtime length\n  // [unique.ptr.runtime]\n  // _GLIBCXX_RESOLVE_LIB_DEFECTS\n  // DR 740 - omit specialization for array objects with a compile time length\n  template<typename _Tp, typename _Dp>\n    class unique_ptr<_Tp[], _Dp>\n    {\n      template <typename _Up>\n      using _DeleterConstraint =\n\ttypename __uniq_ptr_impl<_Tp, _Up>::_DeleterConstraint::type;\n\n      __uniq_ptr_impl<_Tp, _Dp> _M_t;\n\n      template<typename _Up>\n\tusing __remove_cv = typename remove_cv<_Up>::type;\n\n      // like is_base_of<_Tp, _Up> but false if unqualified types are the same\n      template<typename _Up>\n\tusing __is_derived_Tp\n\t  = __and_< is_base_of<_Tp, _Up>,\n\t\t    __not_<is_same<__remove_cv<_Tp>, __remove_cv<_Up>>> >;\n\n    public:\n      using pointer\t  = typename __uniq_ptr_impl<_Tp, _Dp>::pointer;\n      using element_type  = _Tp;\n      using deleter_type  = _Dp;\n\n      // helper template for detecting a safe conversion from another\n      // unique_ptr\n      template<typename _Up, typename _Ep,\n               typename _UPtr = unique_ptr<_Up, _Ep>,\n\t       typename _UP_pointer = typename _UPtr::pointer,\n\t       typename _UP_element_type = typename _UPtr::element_type>\n\tusing __safe_conversion_up = __and_<\n          is_array<_Up>,\n          is_same<pointer, element_type*>,\n          is_same<_UP_pointer, _UP_element_type*>,\n          is_convertible<_UP_element_type(*)[], element_type(*)[]>\n        >;\n\n      // helper template for detecting a safe conversion from a raw pointer\n      template<typename _Up>\n        using __safe_conversion_raw = __and_<\n          __or_<__or_<is_same<_Up, pointer>,\n                      is_same<_Up, nullptr_t>>,\n                __and_<is_pointer<_Up>,\n                       is_same<pointer, element_type*>,\n                       is_convertible<\n                         typename remove_pointer<_Up>::type(*)[],\n                         element_type(*)[]>\n                >\n          >\n        >;\n\n      // Constructors.\n\n      /// Default constructor, creates a unique_ptr that owns nothing.\n      template <typename _Up = _Dp,\n\t\ttypename = _DeleterConstraint<_Up>>\n\tconstexpr unique_ptr() noexcept\n\t: _M_t()\n\t{ }\n\n      /** Takes ownership of a pointer.\n       *\n       * @param __p  A pointer to an array of a type safely convertible\n       * to an array of @c element_type\n       *\n       * The deleter will be value-initialized.\n       */\n      template<typename _Up,\n\t       typename _Vp = _Dp,\n\t       typename = _DeleterConstraint<_Vp>,\n\t       typename = typename enable_if<\n                 __safe_conversion_raw<_Up>::value, bool>::type>\n\texplicit\n\tunique_ptr(_Up __p) noexcept\n\t: _M_t(__p)\n        { }\n\n      /** Takes ownership of a pointer.\n       *\n       * @param __p  A pointer to an array of a type safely convertible\n       * to an array of @c element_type\n       * @param __d  A reference to a deleter.\n       *\n       * The deleter will be initialized with @p __d\n       */\n      template<typename _Up,\n               typename = typename enable_if<\n                 __safe_conversion_raw<_Up>::value, bool>::type>\n      unique_ptr(_Up __p,\n                 typename conditional<is_reference<deleter_type>::value,\n                 deleter_type, const deleter_type&>::type __d) noexcept\n      : _M_t(__p, __d) { }\n\n      /** Takes ownership of a pointer.\n       *\n       * @param __p  A pointer to an array of a type safely convertible\n       * to an array of @c element_type\n       * @param __d  A reference to a deleter.\n       *\n       * The deleter will be initialized with @p std::move(__d)\n       */\n      template<typename _Up,\n               typename = typename enable_if<\n                 __safe_conversion_raw<_Up>::value, bool>::type>\n      unique_ptr(_Up __p, typename\n\t\t remove_reference<deleter_type>::type&& __d) noexcept\n      : _M_t(std::move(__p), std::move(__d))\n      { static_assert(!is_reference<deleter_type>::value,\n\t\t      \"rvalue deleter bound to reference\"); }\n\n      /// Move constructor.\n      unique_ptr(unique_ptr&& __u) noexcept\n      : _M_t(__u.release(), std::forward<deleter_type>(__u.get_deleter())) { }\n\n      /// Creates a unique_ptr that owns nothing.\n      template <typename _Up = _Dp,\n\t\ttypename = _DeleterConstraint<_Up>>\n\tconstexpr unique_ptr(nullptr_t) noexcept : _M_t() { }\n\n      template<typename _Up, typename _Ep, typename = _Require<\n\t       __safe_conversion_up<_Up, _Ep>,\n\t       typename conditional<is_reference<_Dp>::value,\n\t\t\t\t    is_same<_Ep, _Dp>,\n\t\t\t\t    is_convertible<_Ep, _Dp>>::type>>\n\tunique_ptr(unique_ptr<_Up, _Ep>&& __u) noexcept\n\t: _M_t(__u.release(), std::forward<_Ep>(__u.get_deleter()))\n\t{ }\n\n      /// Destructor, invokes the deleter if the stored pointer is not null.\n      ~unique_ptr()\n      {\n\tauto& __ptr = _M_t._M_ptr();\n\tif (__ptr != nullptr)\n\t  get_deleter()(__ptr);\n\t__ptr = pointer();\n      }\n\n      // Assignment.\n\n      /** @brief Move assignment operator.\n       *\n       * @param __u  The object to transfer ownership from.\n       *\n       * Invokes the deleter first if this object owns a pointer.\n       */\n      unique_ptr&\n      operator=(unique_ptr&& __u) noexcept\n      {\n\treset(__u.release());\n\tget_deleter() = std::forward<deleter_type>(__u.get_deleter());\n\treturn *this;\n      }\n\n      /** @brief Assignment from another type.\n       *\n       * @param __u  The object to transfer ownership from, which owns a\n       *             convertible pointer to an array object.\n       *\n       * Invokes the deleter first if this object owns a pointer.\n       */\n      template<typename _Up, typename _Ep>\n\ttypename\n\tenable_if<__and_<__safe_conversion_up<_Up, _Ep>,\n                         is_assignable<deleter_type&, _Ep&&>\n                  >::value,\n                  unique_ptr&>::type\n\toperator=(unique_ptr<_Up, _Ep>&& __u) noexcept\n\t{\n\t  reset(__u.release());\n\t  get_deleter() = std::forward<_Ep>(__u.get_deleter());\n\t  return *this;\n\t}\n\n      /// Reset the %unique_ptr to empty, invoking the deleter if necessary.\n      unique_ptr&\n      operator=(nullptr_t) noexcept\n      {\n\treset();\n\treturn *this;\n      }\n\n      // Observers.\n\n      /// Access an element of owned array.\n      typename std::add_lvalue_reference<element_type>::type\n      operator[](size_t __i) const\n      {\n\t__glibcxx_assert(get() != pointer());\n\treturn get()[__i];\n      }\n\n      /// Return the stored pointer.\n      pointer\n      get() const noexcept\n      { return _M_t._M_ptr(); }\n\n      /// Return a reference to the stored deleter.\n      deleter_type&\n      get_deleter() noexcept\n      { return _M_t._M_deleter(); }\n\n      /// Return a reference to the stored deleter.\n      const deleter_type&\n      get_deleter() const noexcept\n      { return _M_t._M_deleter(); }\n\n      /// Return @c true if the stored pointer is not null.\n      explicit operator bool() const noexcept\n      { return get() == pointer() ? false : true; }\n\n      // Modifiers.\n\n      /// Release ownership of any stored pointer.\n      pointer\n      release() noexcept\n      {\n\tpointer __p = get();\n\t_M_t._M_ptr() = pointer();\n\treturn __p;\n      }\n\n      /** @brief Replace the stored pointer.\n       *\n       * @param __p  The new pointer to store.\n       *\n       * The deleter will be invoked if a pointer is already owned.\n       */\n      template <typename _Up,\n                typename = _Require<\n                  __or_<is_same<_Up, pointer>,\n                        __and_<is_same<pointer, element_type*>,\n                               is_pointer<_Up>,\n                               is_convertible<\n                                 typename remove_pointer<_Up>::type(*)[],\n                                 element_type(*)[]\n                               >\n                        >\n                  >\n               >>\n      void\n      reset(_Up __p) noexcept\n      {\n\tpointer __ptr = __p;\n\tusing std::swap;\n\tswap(_M_t._M_ptr(), __ptr);\n\tif (__ptr != nullptr)\n\t  get_deleter()(__ptr);\n      }\n\n      void reset(nullptr_t = nullptr) noexcept\n      {\n        reset(pointer());\n      }\n\n      /// Exchange the pointer and deleter with another object.\n      void\n      swap(unique_ptr& __u) noexcept\n      {\n\tusing std::swap;\n\tswap(_M_t, __u._M_t);\n      }\n\n      // Disable copy from lvalue.\n      unique_ptr(const unique_ptr&) = delete;\n      unique_ptr& operator=(const unique_ptr&) = delete;\n    };\n\n  template<typename _Tp, typename _Dp>\n    inline\n#if __cplusplus > 201402L || !defined(__STRICT_ANSI__) // c++1z or gnu++11\n    // Constrained free swap overload, see p0185r1\n    typename enable_if<__is_swappable<_Dp>::value>::type\n#else\n    void\n#endif\n    swap(unique_ptr<_Tp, _Dp>& __x,\n\t unique_ptr<_Tp, _Dp>& __y) noexcept\n    { __x.swap(__y); }\n\n#if __cplusplus > 201402L || !defined(__STRICT_ANSI__) // c++1z or gnu++11\n  template<typename _Tp, typename _Dp>\n    typename enable_if<!__is_swappable<_Dp>::value>::type\n    swap(unique_ptr<_Tp, _Dp>&,\n\t unique_ptr<_Tp, _Dp>&) = delete;\n#endif\n\n  template<typename _Tp, typename _Dp,\n\t   typename _Up, typename _Ep>\n    inline bool\n    operator==(const unique_ptr<_Tp, _Dp>& __x,\n\t       const unique_ptr<_Up, _Ep>& __y)\n    { return __x.get() == __y.get(); }\n\n  template<typename _Tp, typename _Dp>\n    inline bool\n    operator==(const unique_ptr<_Tp, _Dp>& __x, nullptr_t) noexcept\n    { return !__x; }\n\n  template<typename _Tp, typename _Dp>\n    inline bool\n    operator==(nullptr_t, const unique_ptr<_Tp, _Dp>& __x) noexcept\n    { return !__x; }\n\n  template<typename _Tp, typename _Dp,\n\t   typename _Up, typename _Ep>\n    inline bool\n    operator!=(const unique_ptr<_Tp, _Dp>& __x,\n\t       const unique_ptr<_Up, _Ep>& __y)\n    { return __x.get() != __y.get(); }\n\n  template<typename _Tp, typename _Dp>\n    inline bool\n    operator!=(const unique_ptr<_Tp, _Dp>& __x, nullptr_t) noexcept\n    { return (bool)__x; }\n\n  template<typename _Tp, typename _Dp>\n    inline bool\n    operator!=(nullptr_t, const unique_ptr<_Tp, _Dp>& __x) noexcept\n    { return (bool)__x; }\n\n  template<typename _Tp, typename _Dp,\n\t   typename _Up, typename _Ep>\n    inline bool\n    operator<(const unique_ptr<_Tp, _Dp>& __x,\n\t      const unique_ptr<_Up, _Ep>& __y)\n    {\n      typedef typename\n\tstd::common_type<typename unique_ptr<_Tp, _Dp>::pointer,\n\t                 typename unique_ptr<_Up, _Ep>::pointer>::type _CT;\n      return std::less<_CT>()(__x.get(), __y.get());\n    }\n\n  template<typename _Tp, typename _Dp>\n    inline bool\n    operator<(const unique_ptr<_Tp, _Dp>& __x, nullptr_t)\n    { return std::less<typename unique_ptr<_Tp, _Dp>::pointer>()(__x.get(),\n\t\t\t\t\t\t\t\t nullptr); }\n\n  template<typename _Tp, typename _Dp>\n    inline bool\n    operator<(nullptr_t, const unique_ptr<_Tp, _Dp>& __x)\n    { return std::less<typename unique_ptr<_Tp, _Dp>::pointer>()(nullptr,\n\t\t\t\t\t\t\t\t __x.get()); }\n\n  template<typename _Tp, typename _Dp,\n\t   typename _Up, typename _Ep>\n    inline bool\n    operator<=(const unique_ptr<_Tp, _Dp>& __x,\n\t       const unique_ptr<_Up, _Ep>& __y)\n    { return !(__y < __x); }\n\n  template<typename _Tp, typename _Dp>\n    inline bool\n    operator<=(const unique_ptr<_Tp, _Dp>& __x, nullptr_t)\n    { return !(nullptr < __x); }\n\n  template<typename _Tp, typename _Dp>\n    inline bool\n    operator<=(nullptr_t, const unique_ptr<_Tp, _Dp>& __x)\n    { return !(__x < nullptr); }\n\n  template<typename _Tp, typename _Dp,\n\t   typename _Up, typename _Ep>\n    inline bool\n    operator>(const unique_ptr<_Tp, _Dp>& __x,\n\t      const unique_ptr<_Up, _Ep>& __y)\n    { return (__y < __x); }\n\n  template<typename _Tp, typename _Dp>\n    inline bool\n    operator>(const unique_ptr<_Tp, _Dp>& __x, nullptr_t)\n    { return std::less<typename unique_ptr<_Tp, _Dp>::pointer>()(nullptr,\n\t\t\t\t\t\t\t\t __x.get()); }\n\n  template<typename _Tp, typename _Dp>\n    inline bool\n    operator>(nullptr_t, const unique_ptr<_Tp, _Dp>& __x)\n    { return std::less<typename unique_ptr<_Tp, _Dp>::pointer>()(__x.get(),\n\t\t\t\t\t\t\t\t nullptr); }\n\n  template<typename _Tp, typename _Dp,\n\t   typename _Up, typename _Ep>\n    inline bool\n    operator>=(const unique_ptr<_Tp, _Dp>& __x,\n\t       const unique_ptr<_Up, _Ep>& __y)\n    { return !(__x < __y); }\n\n  template<typename _Tp, typename _Dp>\n    inline bool\n    operator>=(const unique_ptr<_Tp, _Dp>& __x, nullptr_t)\n    { return !(__x < nullptr); }\n\n  template<typename _Tp, typename _Dp>\n    inline bool\n    operator>=(nullptr_t, const unique_ptr<_Tp, _Dp>& __x)\n    { return !(nullptr < __x); }\n\n  /// std::hash specialization for unique_ptr.\n  template<typename _Tp, typename _Dp>\n    struct hash<unique_ptr<_Tp, _Dp>>\n    : public __hash_base<size_t, unique_ptr<_Tp, _Dp>>,\n    private __poison_hash<typename unique_ptr<_Tp, _Dp>::pointer>\n    {\n      size_t\n      operator()(const unique_ptr<_Tp, _Dp>& __u) const noexcept\n      {\n\ttypedef unique_ptr<_Tp, _Dp> _UP;\n\treturn std::hash<typename _UP::pointer>()(__u.get());\n      }\n    };\n\n#if __cplusplus > 201103L\n\n#define __cpp_lib_make_unique 201304\n\n  template<typename _Tp>\n    struct _MakeUniq\n    { typedef unique_ptr<_Tp> __single_object; };\n\n  template<typename _Tp>\n    struct _MakeUniq<_Tp[]>\n    { typedef unique_ptr<_Tp[]> __array; };\n\n  template<typename _Tp, size_t _Bound>\n    struct _MakeUniq<_Tp[_Bound]>\n    { struct __invalid_type { }; };\n\n  /// std::make_unique for single objects\n  template<typename _Tp, typename... _Args>\n    inline typename _MakeUniq<_Tp>::__single_object\n    make_unique(_Args&&... __args)\n    { return unique_ptr<_Tp>(new _Tp(std::forward<_Args>(__args)...)); }\n\n  /// std::make_unique for arrays of unknown bound\n  template<typename _Tp>\n    inline typename _MakeUniq<_Tp>::__array\n    make_unique(size_t __num)\n    { return unique_ptr<_Tp>(new remove_extent_t<_Tp>[__num]()); }\n\n  /// Disable std::make_unique for arrays of known bound\n  template<typename _Tp, typename... _Args>\n    inline typename _MakeUniq<_Tp>::__invalid_type\n    make_unique(_Args&&...) = delete;\n#endif\n\n  // @} group pointer_abstractions\n\n_GLIBCXX_END_NAMESPACE_VERSION\n} // namespace\n\n#endif /* _UNIQUE_PTR_H */\n"}, "6": {"id": 6, "path": "/usr/include/boost/optional/detail/optional_reference_spec.hpp", "content": "// Copyright (C) 2015-2016 Andrzej Krzemienski.\n//\n// Use, modification, and distribution is subject to the Boost Software\n// License, Version 1.0. (See accompanying file LICENSE_1_0.txt or copy at\n// http://www.boost.org/LICENSE_1_0.txt)\n//\n// See http://www.boost.org/libs/optional for documentation.\n//\n// You are welcome to contact the author at:\n//  akrzemi1@gmail.com\n\n#ifndef BOOST_OPTIONAL_DETAIL_OPTIONAL_REFERENCE_SPEC_AJK_03OCT2015_HPP\n#define BOOST_OPTIONAL_DETAIL_OPTIONAL_REFERENCE_SPEC_AJK_03OCT2015_HPP\n\n#ifdef BOOST_OPTIONAL_CONFIG_NO_PROPER_ASSIGN_FROM_CONST_INT\n#include <boost/type_traits/is_integral.hpp>\n#include <boost/type_traits/is_const.hpp>\n#endif\n\n# if 1\n\nnamespace boost {\n\nnamespace detail {\n\n#ifndef BOOST_OPTIONAL_DETAIL_NO_RVALUE_REFERENCES\n\ntemplate <class From>\nvoid prevent_binding_rvalue()\n{\n#ifndef BOOST_OPTIONAL_CONFIG_ALLOW_BINDING_TO_RVALUES\n    BOOST_STATIC_ASSERT_MSG(boost::is_lvalue_reference<From>::value, \n                            \"binding rvalue references to optional lvalue references is disallowed\");\n#endif    \n}\n\ntemplate <class T>\nBOOST_DEDUCED_TYPENAME boost::remove_reference<T>::type& forward_reference(T&& r)\n{\n    BOOST_STATIC_ASSERT_MSG(boost::is_lvalue_reference<T>::value, \n                            \"binding rvalue references to optional lvalue references is disallowed\");\n    return boost::forward<T>(r);\n}\n\n#endif // BOOST_OPTIONAL_DETAIL_NO_RVALUE_REFERENCES\n\n\ntemplate <class T>\nstruct is_const_integral\n{\n  static const bool value = boost::is_const<T>::value && boost::is_integral<T>::value;\n};\n\ntemplate <class T>\nstruct is_const_integral_bad_for_conversion\n{\n#if (!defined BOOST_OPTIONAL_CONFIG_ALLOW_BINDING_TO_RVALUES) && (defined BOOST_OPTIONAL_CONFIG_NO_PROPER_CONVERT_FROM_CONST_INT)\n  static const bool value = boost::is_const<T>::value && boost::is_integral<T>::value;\n#else\n  static const bool value = false;\n#endif\n};\n\ntemplate <class From>\nvoid prevent_assignment_from_false_const_integral()\n{\n#ifndef BOOST_OPTIONAL_CONFIG_ALLOW_BINDING_TO_RVALUES\n#ifdef BOOST_OPTIONAL_CONFIG_NO_PROPER_ASSIGN_FROM_CONST_INT\n    // MSVC compiler without rvalue refernces: we need to disable the asignment from\n    // const integral lvalue reference, as it may be an invalid temporary\n    BOOST_STATIC_ASSERT_MSG(!is_const_integral<From>::value, \n                            \"binding const lvalue references to integral types is disabled in this compiler\");\n#endif\n#endif   \n}\n\n\ntemplate <class T>\nstruct is_optional_\n{\n  static const bool value = false;\n};\n\ntemplate <class U>\nstruct is_optional_< ::boost::optional<U> >\n{\n  static const bool value = true;\n};\n\ntemplate <class T>\nstruct is_no_optional\n{\n  static const bool value = !is_optional_<BOOST_DEDUCED_TYPENAME boost::decay<T>::type>::value;\n};\n\n\ntemplate <class T, class U>\n  struct is_same_decayed\n  {\n    static const bool value = ::boost::is_same<T, BOOST_DEDUCED_TYPENAME ::boost::remove_reference<U>::type>::value\n                           || ::boost::is_same<T, const BOOST_DEDUCED_TYPENAME ::boost::remove_reference<U>::type>::value;\n  };\n\ntemplate <class T, class U>\nstruct no_unboxing_cond\n{\n  static const bool value = is_no_optional<U>::value && !is_same_decayed<T, U>::value;\n};\n\n\n} // namespace detail\n\ntemplate <class T>\nclass optional<T&> : public optional_detail::optional_tag\n{\n    T* ptr_;\n    \npublic:\n    typedef T& value_type;\n    typedef T& reference_type;\n    typedef T& reference_const_type;\n    typedef T& rval_reference_type;\n    typedef T* pointer_type;\n    typedef T* pointer_const_type;\n    \n    optional() BOOST_NOEXCEPT : ptr_() {}\n    optional(none_t) BOOST_NOEXCEPT : ptr_() {}  \n\n    template <class U>\n        explicit optional(const optional<U&>& rhs) BOOST_NOEXCEPT : ptr_(rhs.get_ptr()) {}\n    optional(const optional& rhs) BOOST_NOEXCEPT : ptr_(rhs.get_ptr()) {}\n    \n    // the following two implement a 'conditionally explicit' constructor: condition is a hack for buggy compilers with srewed conversion construction from const int\n    template <class U>\n      explicit optional(U& rhs, BOOST_DEDUCED_TYPENAME boost::enable_if_c<detail::is_same_decayed<T, U>::value && detail::is_const_integral_bad_for_conversion<U>::value>::type* = 0) BOOST_NOEXCEPT\n      : ptr_(boost::addressof(rhs)) {}\n      \n    template <class U>\n      optional(U& rhs, BOOST_DEDUCED_TYPENAME boost::enable_if_c<detail::is_same_decayed<T, U>::value && !detail::is_const_integral_bad_for_conversion<U>::value>::type* = 0) BOOST_NOEXCEPT\n      : ptr_(boost::addressof(rhs)) {}\n\n    optional& operator=(const optional& rhs) BOOST_NOEXCEPT { ptr_ = rhs.get_ptr(); return *this; }\n    template <class U>\n        optional& operator=(const optional<U&>& rhs) BOOST_NOEXCEPT { ptr_ = rhs.get_ptr(); return *this; }\n    optional& operator=(none_t) BOOST_NOEXCEPT { ptr_ = 0; return *this; }\n    \n    \n    void swap(optional& rhs) BOOST_NOEXCEPT { std::swap(ptr_, rhs.ptr_); }\n    T& get() const { BOOST_ASSERT(ptr_); return   *ptr_; }\n\n    T* get_ptr() const BOOST_NOEXCEPT { return ptr_; }\n    T* operator->() const { BOOST_ASSERT(ptr_); return ptr_; }\n    T& operator*() const { BOOST_ASSERT(ptr_); return *ptr_; }\n    T& value() const { return ptr_ ? *ptr_ : (throw_exception(bad_optional_access()), *ptr_); }\n    \n    bool operator!() const BOOST_NOEXCEPT { return ptr_ == 0; }  \n    BOOST_EXPLICIT_OPERATOR_BOOL_NOEXCEPT()\n      \n    void reset() BOOST_NOEXCEPT { ptr_ = 0; }\n\n    bool is_initialized() const BOOST_NOEXCEPT { return ptr_ != 0; }\n    \n#ifndef BOOST_OPTIONAL_DETAIL_NO_RVALUE_REFERENCES   \n \n    optional(T&& /* rhs */) BOOST_NOEXCEPT { detail::prevent_binding_rvalue<T&&>(); }\n    \n    template <class R>\n        optional(R&& r, BOOST_DEDUCED_TYPENAME boost::enable_if<detail::no_unboxing_cond<T, R> >::type* = 0) BOOST_NOEXCEPT\n        : ptr_(boost::addressof(r)) { detail::prevent_binding_rvalue<R>(); }\n        \n    template <class R>\n        optional(bool cond, R&& r, BOOST_DEDUCED_TYPENAME boost::enable_if<detail::is_no_optional<R> >::type* = 0) BOOST_NOEXCEPT\n        : ptr_(cond ? boost::addressof(r) : 0) { detail::prevent_binding_rvalue<R>(); }\n        \n    template <class R>\n        BOOST_DEDUCED_TYPENAME boost::enable_if<detail::is_no_optional<R>, optional<T&>&>::type\n        operator=(R&& r) BOOST_NOEXCEPT { detail::prevent_binding_rvalue<R>(); ptr_ = boost::addressof(r); return *this; }\n        \n    template <class R>\n        void emplace(R&& r, BOOST_DEDUCED_TYPENAME boost::enable_if<detail::is_no_optional<R> >::type* = 0) BOOST_NOEXCEPT\n        { detail::prevent_binding_rvalue<R>(); ptr_ = boost::addressof(r); }\n        \n    template <class R>\n      T& get_value_or(R&& r, BOOST_DEDUCED_TYPENAME boost::enable_if<detail::is_no_optional<R> >::type* = 0) const BOOST_NOEXCEPT\n      { detail::prevent_binding_rvalue<R>(); return ptr_ ? *ptr_ : r; }\n      \n    template <class R>\n        T& value_or(R&& r, BOOST_DEDUCED_TYPENAME boost::enable_if<detail::is_no_optional<R> >::type* = 0) const BOOST_NOEXCEPT\n        { detail::prevent_binding_rvalue<R>(); return ptr_ ? *ptr_ : r; }\n        \n    template <class R>\n      void reset(R&& r, BOOST_DEDUCED_TYPENAME boost::enable_if<detail::is_no_optional<R> >::type* = 0) BOOST_NOEXCEPT\n      { detail::prevent_binding_rvalue<R>(); ptr_ = boost::addressof(r); }\n      \n    template <class F>\n        T& value_or_eval(F f) const { return ptr_ ? *ptr_ : detail::forward_reference(f()); }\n      \n#else  // BOOST_OPTIONAL_DETAIL_NO_RVALUE_REFERENCES\n\n    \n    // the following two implement a 'conditionally explicit' constructor\n    template <class U>\n      explicit optional(U& v, BOOST_DEDUCED_TYPENAME boost::enable_if_c<detail::no_unboxing_cond<T, U>::value && detail::is_const_integral_bad_for_conversion<U>::value >::type* = 0) BOOST_NOEXCEPT\n      : ptr_(boost::addressof(v)) { }\n      \n    template <class U>\n      optional(U& v, BOOST_DEDUCED_TYPENAME boost::enable_if_c<detail::no_unboxing_cond<T, U>::value && !detail::is_const_integral_bad_for_conversion<U>::value >::type* = 0) BOOST_NOEXCEPT\n      : ptr_(boost::addressof(v)) { }\n        \n    template <class U>\n      optional(bool cond, U& v, BOOST_DEDUCED_TYPENAME boost::enable_if<detail::is_no_optional<U> >::type* = 0) BOOST_NOEXCEPT : ptr_(cond ? boost::addressof(v) : 0) {}\n\n    template <class U>\n      BOOST_DEDUCED_TYPENAME boost::enable_if<detail::is_no_optional<U>, optional<T&>&>::type\n      operator=(U& v) BOOST_NOEXCEPT\n      {\n        detail::prevent_assignment_from_false_const_integral<U>();\n        ptr_ = boost::addressof(v); return *this;\n      }\n\n    template <class U>\n        void emplace(U& v, BOOST_DEDUCED_TYPENAME boost::enable_if<detail::is_no_optional<U> >::type* = 0) BOOST_NOEXCEPT\n        { ptr_ = boost::addressof(v); }\n        \n    template <class U>\n      T& get_value_or(U& v, BOOST_DEDUCED_TYPENAME boost::enable_if<detail::is_no_optional<U> >::type* = 0) const BOOST_NOEXCEPT\n      { return ptr_ ? *ptr_ : v; }\n      \n    template <class U>\n        T& value_or(U& v, BOOST_DEDUCED_TYPENAME boost::enable_if<detail::is_no_optional<U> >::type* = 0) const BOOST_NOEXCEPT\n        { return ptr_ ? *ptr_ : v; }\n        \n    template <class U>\n      void reset(U& v, BOOST_DEDUCED_TYPENAME boost::enable_if<detail::is_no_optional<U> >::type* = 0) BOOST_NOEXCEPT\n      { ptr_ = boost::addressof(v); }\n      \n    template <class F>\n      T& value_or_eval(F f) const { return ptr_ ? *ptr_ : f(); }\n      \n#endif // BOOST_OPTIONAL_DETAIL_NO_RVALUE_REFERENCES\n};\n\ntemplate <class T> \n  void swap ( optional<T&>& x, optional<T&>& y) BOOST_NOEXCEPT\n{\n  x.swap(y);\n}\n\n} // namespace boost\n\n#endif // 1/0\n\n#endif // header guard\n"}, "7": {"id": 7, "path": "/usr/include/boost/config/detail/suffix.hpp", "content": "//  Boost config.hpp configuration header file  ------------------------------//\n//  boostinspect:ndprecated_macros -- tell the inspect tool to ignore this file\n\n//  Copyright (c) 2001-2003 John Maddock\n//  Copyright (c) 2001 Darin Adler\n//  Copyright (c) 2001 Peter Dimov\n//  Copyright (c) 2002 Bill Kempf\n//  Copyright (c) 2002 Jens Maurer\n//  Copyright (c) 2002-2003 David Abrahams\n//  Copyright (c) 2003 Gennaro Prota\n//  Copyright (c) 2003 Eric Friedman\n//  Copyright (c) 2010 Eric Jourdanneau, Joel Falcou\n// Distributed under the Boost Software License, Version 1.0. (See\n// accompanying file LICENSE_1_0.txt or copy at\n// http://www.boost.org/LICENSE_1_0.txt)\n\n//  See http://www.boost.org/ for most recent version.\n\n//  Boost config.hpp policy and rationale documentation has been moved to\n//  http://www.boost.org/libs/config/\n//\n//  This file is intended to be stable, and relatively unchanging.\n//  It should contain boilerplate code only - no compiler specific\n//  code unless it is unavoidable - no changes unless unavoidable.\n\n#ifndef BOOST_CONFIG_SUFFIX_HPP\n#define BOOST_CONFIG_SUFFIX_HPP\n\n#if defined(__GNUC__) && (__GNUC__ >= 4)\n//\n// Some GCC-4.x versions issue warnings even when __extension__ is used,\n// so use this as a workaround:\n//\n#pragma GCC system_header\n#endif\n\n//\n// ensure that visibility macros are always defined, thus symplifying use\n//\n#ifndef BOOST_SYMBOL_EXPORT\n# define BOOST_SYMBOL_EXPORT\n#endif\n#ifndef BOOST_SYMBOL_IMPORT\n# define BOOST_SYMBOL_IMPORT\n#endif\n#ifndef BOOST_SYMBOL_VISIBLE\n# define BOOST_SYMBOL_VISIBLE\n#endif\n\n//\n// look for long long by looking for the appropriate macros in <limits.h>.\n// Note that we use limits.h rather than climits for maximal portability,\n// remember that since these just declare a bunch of macros, there should be\n// no namespace issues from this.\n//\n#if !defined(BOOST_HAS_LONG_LONG) && !defined(BOOST_NO_LONG_LONG)                                              \\\n   && !defined(BOOST_MSVC) && !defined(__BORLANDC__)\n# include <limits.h>\n# if (defined(ULLONG_MAX) || defined(ULONG_LONG_MAX) || defined(ULONGLONG_MAX))\n#   define BOOST_HAS_LONG_LONG\n# else\n#   define BOOST_NO_LONG_LONG\n# endif\n#endif\n\n// GCC 3.x will clean up all of those nasty macro definitions that\n// BOOST_NO_CTYPE_FUNCTIONS is intended to help work around, so undefine\n// it under GCC 3.x.\n#if defined(__GNUC__) && (__GNUC__ >= 3) && defined(BOOST_NO_CTYPE_FUNCTIONS)\n#  undef BOOST_NO_CTYPE_FUNCTIONS\n#endif\n\n//\n// Assume any extensions are in namespace std:: unless stated otherwise:\n//\n#  ifndef BOOST_STD_EXTENSION_NAMESPACE\n#    define BOOST_STD_EXTENSION_NAMESPACE std\n#  endif\n\n//\n// If cv-qualified specializations are not allowed, then neither are cv-void ones:\n//\n#  if defined(BOOST_NO_CV_SPECIALIZATIONS) \\\n      && !defined(BOOST_NO_CV_VOID_SPECIALIZATIONS)\n#     define BOOST_NO_CV_VOID_SPECIALIZATIONS\n#  endif\n\n//\n// If there is no numeric_limits template, then it can't have any compile time\n// constants either!\n//\n#  if defined(BOOST_NO_LIMITS) \\\n      && !defined(BOOST_NO_LIMITS_COMPILE_TIME_CONSTANTS)\n#     define BOOST_NO_LIMITS_COMPILE_TIME_CONSTANTS\n#     define BOOST_NO_MS_INT64_NUMERIC_LIMITS\n#     define BOOST_NO_LONG_LONG_NUMERIC_LIMITS\n#  endif\n\n//\n// if there is no long long then there is no specialisation\n// for numeric_limits<long long> either:\n//\n#if !defined(BOOST_HAS_LONG_LONG) && !defined(BOOST_NO_LONG_LONG_NUMERIC_LIMITS)\n#  define BOOST_NO_LONG_LONG_NUMERIC_LIMITS\n#endif\n\n//\n// if there is no __int64 then there is no specialisation\n// for numeric_limits<__int64> either:\n//\n#if !defined(BOOST_HAS_MS_INT64) && !defined(BOOST_NO_MS_INT64_NUMERIC_LIMITS)\n#  define BOOST_NO_MS_INT64_NUMERIC_LIMITS\n#endif\n\n//\n// if member templates are supported then so is the\n// VC6 subset of member templates:\n//\n#  if !defined(BOOST_NO_MEMBER_TEMPLATES) \\\n       && !defined(BOOST_MSVC6_MEMBER_TEMPLATES)\n#     define BOOST_MSVC6_MEMBER_TEMPLATES\n#  endif\n\n//\n// Without partial specialization, can't test for partial specialisation bugs:\n//\n#  if defined(BOOST_NO_TEMPLATE_PARTIAL_SPECIALIZATION) \\\n      && !defined(BOOST_BCB_PARTIAL_SPECIALIZATION_BUG)\n#     define BOOST_BCB_PARTIAL_SPECIALIZATION_BUG\n#  endif\n\n//\n// Without partial specialization, we can't have array-type partial specialisations:\n//\n#  if defined(BOOST_NO_TEMPLATE_PARTIAL_SPECIALIZATION) \\\n      && !defined(BOOST_NO_ARRAY_TYPE_SPECIALIZATIONS)\n#     define BOOST_NO_ARRAY_TYPE_SPECIALIZATIONS\n#  endif\n\n//\n// Without partial specialization, std::iterator_traits can't work:\n//\n#  if defined(BOOST_NO_TEMPLATE_PARTIAL_SPECIALIZATION) \\\n      && !defined(BOOST_NO_STD_ITERATOR_TRAITS)\n#     define BOOST_NO_STD_ITERATOR_TRAITS\n#  endif\n\n//\n// Without partial specialization, partial\n// specialization with default args won't work either:\n//\n#  if defined(BOOST_NO_TEMPLATE_PARTIAL_SPECIALIZATION) \\\n      && !defined(BOOST_NO_PARTIAL_SPECIALIZATION_IMPLICIT_DEFAULT_ARGS)\n#     define BOOST_NO_PARTIAL_SPECIALIZATION_IMPLICIT_DEFAULT_ARGS\n#  endif\n\n//\n// Without member template support, we can't have template constructors\n// in the standard library either:\n//\n#  if defined(BOOST_NO_MEMBER_TEMPLATES) \\\n      && !defined(BOOST_MSVC6_MEMBER_TEMPLATES) \\\n      && !defined(BOOST_NO_TEMPLATED_ITERATOR_CONSTRUCTORS)\n#     define BOOST_NO_TEMPLATED_ITERATOR_CONSTRUCTORS\n#  endif\n\n//\n// Without member template support, we can't have a conforming\n// std::allocator template either:\n//\n#  if defined(BOOST_NO_MEMBER_TEMPLATES) \\\n      && !defined(BOOST_MSVC6_MEMBER_TEMPLATES) \\\n      && !defined(BOOST_NO_STD_ALLOCATOR)\n#     define BOOST_NO_STD_ALLOCATOR\n#  endif\n\n//\n// without ADL support then using declarations will break ADL as well:\n//\n#if defined(BOOST_NO_ARGUMENT_DEPENDENT_LOOKUP) && !defined(BOOST_FUNCTION_SCOPE_USING_DECLARATION_BREAKS_ADL)\n#  define BOOST_FUNCTION_SCOPE_USING_DECLARATION_BREAKS_ADL\n#endif\n\n//\n// Without typeid support we have no dynamic RTTI either:\n//\n#if defined(BOOST_NO_TYPEID) && !defined(BOOST_NO_RTTI)\n#  define BOOST_NO_RTTI\n#endif\n\n//\n// If we have a standard allocator, then we have a partial one as well:\n//\n#if !defined(BOOST_NO_STD_ALLOCATOR)\n#  define BOOST_HAS_PARTIAL_STD_ALLOCATOR\n#endif\n\n//\n// We can't have a working std::use_facet if there is no std::locale:\n//\n#  if defined(BOOST_NO_STD_LOCALE) && !defined(BOOST_NO_STD_USE_FACET)\n#     define BOOST_NO_STD_USE_FACET\n#  endif\n\n//\n// We can't have a std::messages facet if there is no std::locale:\n//\n#  if defined(BOOST_NO_STD_LOCALE) && !defined(BOOST_NO_STD_MESSAGES)\n#     define BOOST_NO_STD_MESSAGES\n#  endif\n\n//\n// We can't have a working std::wstreambuf if there is no std::locale:\n//\n#  if defined(BOOST_NO_STD_LOCALE) && !defined(BOOST_NO_STD_WSTREAMBUF)\n#     define BOOST_NO_STD_WSTREAMBUF\n#  endif\n\n//\n// We can't have a <cwctype> if there is no <cwchar>:\n//\n#  if defined(BOOST_NO_CWCHAR) && !defined(BOOST_NO_CWCTYPE)\n#     define BOOST_NO_CWCTYPE\n#  endif\n\n//\n// We can't have a swprintf if there is no <cwchar>:\n//\n#  if defined(BOOST_NO_CWCHAR) && !defined(BOOST_NO_SWPRINTF)\n#     define BOOST_NO_SWPRINTF\n#  endif\n\n//\n// If Win32 support is turned off, then we must turn off\n// threading support also, unless there is some other\n// thread API enabled:\n//\n#if defined(BOOST_DISABLE_WIN32) && defined(_WIN32) \\\n   && !defined(BOOST_DISABLE_THREADS) && !defined(BOOST_HAS_PTHREADS)\n#  define BOOST_DISABLE_THREADS\n#endif\n\n//\n// Turn on threading support if the compiler thinks that it's in\n// multithreaded mode.  We put this here because there are only a\n// limited number of macros that identify this (if there's any missing\n// from here then add to the appropriate compiler section):\n//\n#if (defined(__MT__) || defined(_MT) || defined(_REENTRANT) \\\n    || defined(_PTHREADS) || defined(__APPLE__) || defined(__DragonFly__)) \\\n    && !defined(BOOST_HAS_THREADS)\n#  define BOOST_HAS_THREADS\n#endif\n\n//\n// Turn threading support off if BOOST_DISABLE_THREADS is defined:\n//\n#if defined(BOOST_DISABLE_THREADS) && defined(BOOST_HAS_THREADS)\n#  undef BOOST_HAS_THREADS\n#endif\n\n//\n// Turn threading support off if we don't recognise the threading API:\n//\n#if defined(BOOST_HAS_THREADS) && !defined(BOOST_HAS_PTHREADS)\\\n      && !defined(BOOST_HAS_WINTHREADS) && !defined(BOOST_HAS_BETHREADS)\\\n      && !defined(BOOST_HAS_MPTASKS)\n#  undef BOOST_HAS_THREADS\n#endif\n\n//\n// Turn threading detail macros off if we don't (want to) use threading\n//\n#ifndef BOOST_HAS_THREADS\n#  undef BOOST_HAS_PTHREADS\n#  undef BOOST_HAS_PTHREAD_MUTEXATTR_SETTYPE\n#  undef BOOST_HAS_PTHREAD_YIELD\n#  undef BOOST_HAS_PTHREAD_DELAY_NP\n#  undef BOOST_HAS_WINTHREADS\n#  undef BOOST_HAS_BETHREADS\n#  undef BOOST_HAS_MPTASKS\n#endif\n\n//\n// If the compiler claims to be C99 conformant, then it had better\n// have a <stdint.h>:\n//\n#  if defined(__STDC_VERSION__) && (__STDC_VERSION__ >= 199901)\n#     define BOOST_HAS_STDINT_H\n#     ifndef BOOST_HAS_LOG1P\n#        define BOOST_HAS_LOG1P\n#     endif\n#     ifndef BOOST_HAS_EXPM1\n#        define BOOST_HAS_EXPM1\n#     endif\n#  endif\n\n//\n// Define BOOST_NO_SLIST and BOOST_NO_HASH if required.\n// Note that this is for backwards compatibility only.\n//\n#  if !defined(BOOST_HAS_SLIST) && !defined(BOOST_NO_SLIST)\n#     define BOOST_NO_SLIST\n#  endif\n\n#  if !defined(BOOST_HAS_HASH) && !defined(BOOST_NO_HASH)\n#     define BOOST_NO_HASH\n#  endif\n\n//\n// Set BOOST_SLIST_HEADER if not set already:\n//\n#if defined(BOOST_HAS_SLIST) && !defined(BOOST_SLIST_HEADER)\n#  define BOOST_SLIST_HEADER <slist>\n#endif\n\n//\n// Set BOOST_HASH_SET_HEADER if not set already:\n//\n#if defined(BOOST_HAS_HASH) && !defined(BOOST_HASH_SET_HEADER)\n#  define BOOST_HASH_SET_HEADER <hash_set>\n#endif\n\n//\n// Set BOOST_HASH_MAP_HEADER if not set already:\n//\n#if defined(BOOST_HAS_HASH) && !defined(BOOST_HASH_MAP_HEADER)\n#  define BOOST_HASH_MAP_HEADER <hash_map>\n#endif\n\n//  BOOST_HAS_ABI_HEADERS\n//  This macro gets set if we have headers that fix the ABI,\n//  and prevent ODR violations when linking to external libraries:\n#if defined(BOOST_ABI_PREFIX) && defined(BOOST_ABI_SUFFIX) && !defined(BOOST_HAS_ABI_HEADERS)\n#  define BOOST_HAS_ABI_HEADERS\n#endif\n\n#if defined(BOOST_HAS_ABI_HEADERS) && defined(BOOST_DISABLE_ABI_HEADERS)\n#  undef BOOST_HAS_ABI_HEADERS\n#endif\n\n//  BOOST_NO_STDC_NAMESPACE workaround  --------------------------------------//\n//  Because std::size_t usage is so common, even in boost headers which do not\n//  otherwise use the C library, the <cstddef> workaround is included here so\n//  that ugly workaround code need not appear in many other boost headers.\n//  NOTE WELL: This is a workaround for non-conforming compilers; <cstddef>\n//  must still be #included in the usual places so that <cstddef> inclusion\n//  works as expected with standard conforming compilers.  The resulting\n//  double inclusion of <cstddef> is harmless.\n\n# if defined(BOOST_NO_STDC_NAMESPACE) && defined(__cplusplus)\n#   include <cstddef>\n    namespace std { using ::ptrdiff_t; using ::size_t; }\n# endif\n\n//  Workaround for the unfortunate min/max macros defined by some platform headers\n\n#define BOOST_PREVENT_MACRO_SUBSTITUTION\n\n#ifndef BOOST_USING_STD_MIN\n#  define BOOST_USING_STD_MIN() using std::min\n#endif\n\n#ifndef BOOST_USING_STD_MAX\n#  define BOOST_USING_STD_MAX() using std::max\n#endif\n\n//  BOOST_NO_STD_MIN_MAX workaround  -----------------------------------------//\n\n#  if defined(BOOST_NO_STD_MIN_MAX) && defined(__cplusplus)\n\nnamespace std {\n  template <class _Tp>\n  inline const _Tp& min BOOST_PREVENT_MACRO_SUBSTITUTION (const _Tp& __a, const _Tp& __b) {\n    return __b < __a ? __b : __a;\n  }\n  template <class _Tp>\n  inline const _Tp& max BOOST_PREVENT_MACRO_SUBSTITUTION (const _Tp& __a, const _Tp& __b) {\n    return  __a < __b ? __b : __a;\n  }\n}\n\n#  endif\n\n// BOOST_STATIC_CONSTANT workaround --------------------------------------- //\n// On compilers which don't allow in-class initialization of static integral\n// constant members, we must use enums as a workaround if we want the constants\n// to be available at compile-time. This macro gives us a convenient way to\n// declare such constants.\n\n#  ifdef BOOST_NO_INCLASS_MEMBER_INITIALIZATION\n#       define BOOST_STATIC_CONSTANT(type, assignment) enum { assignment }\n#  else\n#     define BOOST_STATIC_CONSTANT(type, assignment) static const type assignment\n#  endif\n\n// BOOST_USE_FACET / HAS_FACET workaround ----------------------------------//\n// When the standard library does not have a conforming std::use_facet there\n// are various workarounds available, but they differ from library to library.\n// The same problem occurs with has_facet.\n// These macros provide a consistent way to access a locale's facets.\n// Usage:\n//    replace\n//       std::use_facet<Type>(loc);\n//    with\n//       BOOST_USE_FACET(Type, loc);\n//    Note do not add a std:: prefix to the front of BOOST_USE_FACET!\n//  Use for BOOST_HAS_FACET is analogous.\n\n#if defined(BOOST_NO_STD_USE_FACET)\n#  ifdef BOOST_HAS_TWO_ARG_USE_FACET\n#     define BOOST_USE_FACET(Type, loc) std::use_facet(loc, static_cast<Type*>(0))\n#     define BOOST_HAS_FACET(Type, loc) std::has_facet(loc, static_cast<Type*>(0))\n#  elif defined(BOOST_HAS_MACRO_USE_FACET)\n#     define BOOST_USE_FACET(Type, loc) std::_USE(loc, Type)\n#     define BOOST_HAS_FACET(Type, loc) std::_HAS(loc, Type)\n#  elif defined(BOOST_HAS_STLP_USE_FACET)\n#     define BOOST_USE_FACET(Type, loc) (*std::_Use_facet<Type >(loc))\n#     define BOOST_HAS_FACET(Type, loc) std::has_facet< Type >(loc)\n#  endif\n#else\n#  define BOOST_USE_FACET(Type, loc) std::use_facet< Type >(loc)\n#  define BOOST_HAS_FACET(Type, loc) std::has_facet< Type >(loc)\n#endif\n\n// BOOST_NESTED_TEMPLATE workaround ------------------------------------------//\n// Member templates are supported by some compilers even though they can't use\n// the A::template member<U> syntax, as a workaround replace:\n//\n// typedef typename A::template rebind<U> binder;\n//\n// with:\n//\n// typedef typename A::BOOST_NESTED_TEMPLATE rebind<U> binder;\n\n#ifndef BOOST_NO_MEMBER_TEMPLATE_KEYWORD\n#  define BOOST_NESTED_TEMPLATE template\n#else\n#  define BOOST_NESTED_TEMPLATE\n#endif\n\n// BOOST_UNREACHABLE_RETURN(x) workaround -------------------------------------//\n// Normally evaluates to nothing, unless BOOST_NO_UNREACHABLE_RETURN_DETECTION\n// is defined, in which case it evaluates to return x; Use when you have a return\n// statement that can never be reached.\n\n#ifndef BOOST_UNREACHABLE_RETURN\n#  ifdef BOOST_NO_UNREACHABLE_RETURN_DETECTION\n#     define BOOST_UNREACHABLE_RETURN(x) return x;\n#  else\n#     define BOOST_UNREACHABLE_RETURN(x)\n#  endif\n#endif\n\n// BOOST_DEDUCED_TYPENAME workaround ------------------------------------------//\n//\n// Some compilers don't support the use of `typename' for dependent\n// types in deduced contexts, e.g.\n//\n//     template <class T> void f(T, typename T::type);\n//                                  ^^^^^^^^\n// Replace these declarations with:\n//\n//     template <class T> void f(T, BOOST_DEDUCED_TYPENAME T::type);\n\n#ifndef BOOST_NO_DEDUCED_TYPENAME\n#  define BOOST_DEDUCED_TYPENAME typename\n#else\n#  define BOOST_DEDUCED_TYPENAME\n#endif\n\n#ifndef BOOST_NO_TYPENAME_WITH_CTOR\n#  define BOOST_CTOR_TYPENAME typename\n#else\n#  define BOOST_CTOR_TYPENAME\n#endif\n\n// long long workaround ------------------------------------------//\n// On gcc (and maybe other compilers?) long long is alway supported\n// but it's use may generate either warnings (with -ansi), or errors\n// (with -pedantic -ansi) unless it's use is prefixed by __extension__\n//\n#if defined(BOOST_HAS_LONG_LONG) && defined(__cplusplus)\nnamespace boost{\n#  ifdef __GNUC__\n   __extension__ typedef long long long_long_type;\n   __extension__ typedef unsigned long long ulong_long_type;\n#  else\n   typedef long long long_long_type;\n   typedef unsigned long long ulong_long_type;\n#  endif\n}\n#endif\n// same again for __int128:\n#if defined(BOOST_HAS_INT128) && defined(__cplusplus)\nnamespace boost{\n#  ifdef __GNUC__\n   __extension__ typedef __int128 int128_type;\n   __extension__ typedef unsigned __int128 uint128_type;\n#  else\n   typedef __int128 int128_type;\n   typedef unsigned __int128 uint128_type;\n#  endif\n}\n#endif\n// same again for __float128:\n#if defined(BOOST_HAS_FLOAT128) && defined(__cplusplus)\nnamespace boost {\n#  ifdef __GNUC__\n   __extension__ typedef __float128 float128_type;\n#  else\n   typedef __float128 float128_type;\n#  endif\n}\n#endif\n\n// BOOST_[APPEND_]EXPLICIT_TEMPLATE_[NON_]TYPE macros --------------------------//\n\n// These macros are obsolete. Port away and remove.\n\n#  define BOOST_EXPLICIT_TEMPLATE_TYPE(t)\n#  define BOOST_EXPLICIT_TEMPLATE_TYPE_SPEC(t)\n#  define BOOST_EXPLICIT_TEMPLATE_NON_TYPE(t, v)\n#  define BOOST_EXPLICIT_TEMPLATE_NON_TYPE_SPEC(t, v)\n\n#  define BOOST_APPEND_EXPLICIT_TEMPLATE_TYPE(t)\n#  define BOOST_APPEND_EXPLICIT_TEMPLATE_TYPE_SPEC(t)\n#  define BOOST_APPEND_EXPLICIT_TEMPLATE_NON_TYPE(t, v)\n#  define BOOST_APPEND_EXPLICIT_TEMPLATE_NON_TYPE_SPEC(t, v)\n\n// When BOOST_NO_STD_TYPEINFO is defined, we can just import\n// the global definition into std namespace:\n#if defined(BOOST_NO_STD_TYPEINFO) && defined(__cplusplus)\n#include <typeinfo>\nnamespace std{ using ::type_info; }\n#endif\n\n// ---------------------------------------------------------------------------//\n\n//\n// Helper macro BOOST_STRINGIZE:\n// Converts the parameter X to a string after macro replacement\n// on X has been performed.\n//\n#define BOOST_STRINGIZE(X) BOOST_DO_STRINGIZE(X)\n#define BOOST_DO_STRINGIZE(X) #X\n\n//\n// Helper macro BOOST_JOIN:\n// The following piece of macro magic joins the two\n// arguments together, even when one of the arguments is\n// itself a macro (see 16.3.1 in C++ standard).  The key\n// is that macro expansion of macro arguments does not\n// occur in BOOST_DO_JOIN2 but does in BOOST_DO_JOIN.\n//\n#define BOOST_JOIN( X, Y ) BOOST_DO_JOIN( X, Y )\n#define BOOST_DO_JOIN( X, Y ) BOOST_DO_JOIN2(X,Y)\n#define BOOST_DO_JOIN2( X, Y ) X##Y\n\n//\n// Set some default values for compiler/library/platform names.\n// These are for debugging config setup only:\n//\n#  ifndef BOOST_COMPILER\n#     define BOOST_COMPILER \"Unknown ISO C++ Compiler\"\n#  endif\n#  ifndef BOOST_STDLIB\n#     define BOOST_STDLIB \"Unknown ISO standard library\"\n#  endif\n#  ifndef BOOST_PLATFORM\n#     if defined(unix) || defined(__unix) || defined(_XOPEN_SOURCE) \\\n         || defined(_POSIX_SOURCE)\n#        define BOOST_PLATFORM \"Generic Unix\"\n#     else\n#        define BOOST_PLATFORM \"Unknown\"\n#     endif\n#  endif\n\n//\n// Set some default values GPU support\n//\n#  ifndef BOOST_GPU_ENABLED\n#  define BOOST_GPU_ENABLED\n#  endif\n\n// BOOST_RESTRICT ---------------------------------------------//\n// Macro to use in place of 'restrict' keyword variants\n#if !defined(BOOST_RESTRICT)\n#  if defined(_MSC_VER)\n#    define BOOST_RESTRICT __restrict\n#    if !defined(BOOST_NO_RESTRICT_REFERENCES) && (_MSC_FULL_VER < 190023026)\n#      define BOOST_NO_RESTRICT_REFERENCES\n#    endif\n#  elif defined(__GNUC__) && __GNUC__ > 3\n     // Clang also defines __GNUC__ (as 4)\n#    define BOOST_RESTRICT __restrict__\n#  else\n#    define BOOST_RESTRICT\n#    if !defined(BOOST_NO_RESTRICT_REFERENCES)\n#      define BOOST_NO_RESTRICT_REFERENCES\n#    endif\n#  endif\n#endif\n\n// BOOST_FORCEINLINE ---------------------------------------------//\n// Macro to use in place of 'inline' to force a function to be inline\n#if !defined(BOOST_FORCEINLINE)\n#  if defined(_MSC_VER)\n#    define BOOST_FORCEINLINE __forceinline\n#  elif defined(__GNUC__) && __GNUC__ > 3\n     // Clang also defines __GNUC__ (as 4)\n#    define BOOST_FORCEINLINE inline __attribute__ ((__always_inline__))\n#  else\n#    define BOOST_FORCEINLINE inline\n#  endif\n#endif\n\n// BOOST_NOINLINE ---------------------------------------------//\n// Macro to use in place of 'inline' to prevent a function to be inlined\n#if !defined(BOOST_NOINLINE)\n#  if defined(_MSC_VER)\n#    define BOOST_NOINLINE __declspec(noinline)\n#  elif defined(__GNUC__) && __GNUC__ > 3\n     // Clang also defines __GNUC__ (as 4)\n#    if defined(__CUDACC__)\n       // nvcc doesn't always parse __noinline__,\n       // see: https://svn.boost.org/trac/boost/ticket/9392\n#      define BOOST_NOINLINE __attribute__ ((noinline))\n#    else\n#      define BOOST_NOINLINE __attribute__ ((__noinline__))\n#    endif\n#  else\n#    define BOOST_NOINLINE\n#  endif\n#endif\n\n// BOOST_NORETURN ---------------------------------------------//\n// Macro to use before a function declaration/definition to designate\n// the function as not returning normally (i.e. with a return statement\n// or by leaving the function scope, if the function return type is void).\n#if !defined(BOOST_NORETURN)\n#  if defined(_MSC_VER)\n#    define BOOST_NORETURN __declspec(noreturn)\n#  elif defined(__GNUC__)\n#    define BOOST_NORETURN __attribute__ ((__noreturn__))\n#  elif defined(__has_attribute) && defined(__SUNPRO_CC) && (__SUNPRO_CC > 0x5130)\n#    if __has_attribute(noreturn)\n#      define BOOST_NORETURN [[noreturn]]\n#    endif\n#  elif defined(__has_cpp_attribute) \n#    if __has_cpp_attribute(noreturn)\n#      define BOOST_NORETURN [[noreturn]]\n#    endif\n#  endif\n#endif\n\n#if !defined(BOOST_NORETURN)\n#  define BOOST_NO_NORETURN\n#  define BOOST_NORETURN\n#endif\n\n// Branch prediction hints\n// These macros are intended to wrap conditional expressions that yield true or false\n//\n//  if (BOOST_LIKELY(var == 10))\n//  {\n//     // the most probable code here\n//  }\n//\n#if !defined(BOOST_LIKELY)\n#  define BOOST_LIKELY(x) x\n#endif\n#if !defined(BOOST_UNLIKELY)\n#  define BOOST_UNLIKELY(x) x\n#endif\n\n// Type and data alignment specification\n//\n#if !defined(BOOST_ALIGNMENT)\n#  if !defined(BOOST_NO_CXX11_ALIGNAS)\n#    define BOOST_ALIGNMENT(x) alignas(x)\n#  elif defined(_MSC_VER)\n#    define BOOST_ALIGNMENT(x) __declspec(align(x))\n#  elif defined(__GNUC__)\n#    define BOOST_ALIGNMENT(x) __attribute__ ((__aligned__(x)))\n#  else\n#    define BOOST_NO_ALIGNMENT\n#    define BOOST_ALIGNMENT(x)\n#  endif\n#endif\n\n// Lack of non-public defaulted functions is implied by the lack of any defaulted functions\n#if !defined(BOOST_NO_CXX11_NON_PUBLIC_DEFAULTED_FUNCTIONS) && defined(BOOST_NO_CXX11_DEFAULTED_FUNCTIONS)\n#  define BOOST_NO_CXX11_NON_PUBLIC_DEFAULTED_FUNCTIONS\n#endif\n\n// Defaulted and deleted function declaration helpers\n// These macros are intended to be inside a class definition.\n// BOOST_DEFAULTED_FUNCTION accepts the function declaration and its\n// body, which will be used if the compiler doesn't support defaulted functions.\n// BOOST_DELETED_FUNCTION only accepts the function declaration. It\n// will expand to a private function declaration, if the compiler doesn't support\n// deleted functions. Because of this it is recommended to use BOOST_DELETED_FUNCTION\n// in the end of the class definition.\n//\n//  class my_class\n//  {\n//  public:\n//      // Default-constructible\n//      BOOST_DEFAULTED_FUNCTION(my_class(), {})\n//      // Copying prohibited\n//      BOOST_DELETED_FUNCTION(my_class(my_class const&))\n//      BOOST_DELETED_FUNCTION(my_class& operator= (my_class const&))\n//  };\n//\n#if !(defined(BOOST_NO_CXX11_DEFAULTED_FUNCTIONS) || defined(BOOST_NO_CXX11_NON_PUBLIC_DEFAULTED_FUNCTIONS))\n#   define BOOST_DEFAULTED_FUNCTION(fun, body) fun = default;\n#else\n#   define BOOST_DEFAULTED_FUNCTION(fun, body) fun body\n#endif\n\n#if !defined(BOOST_NO_CXX11_DELETED_FUNCTIONS)\n#   define BOOST_DELETED_FUNCTION(fun) fun = delete;\n#else\n#   define BOOST_DELETED_FUNCTION(fun) private: fun;\n#endif\n\n//\n// Set BOOST_NO_DECLTYPE_N3276 when BOOST_NO_DECLTYPE is defined\n//\n#if defined(BOOST_NO_CXX11_DECLTYPE) && !defined(BOOST_NO_CXX11_DECLTYPE_N3276)\n#define BOOST_NO_CXX11_DECLTYPE_N3276 BOOST_NO_CXX11_DECLTYPE\n#endif\n\n//  -------------------- Deprecated macros for 1.50 ---------------------------\n//  These will go away in a future release\n\n//  Use BOOST_NO_CXX11_HDR_UNORDERED_SET or BOOST_NO_CXX11_HDR_UNORDERED_MAP\n//           instead of BOOST_NO_STD_UNORDERED\n#if defined(BOOST_NO_CXX11_HDR_UNORDERED_MAP) || defined (BOOST_NO_CXX11_HDR_UNORDERED_SET)\n# ifndef BOOST_NO_CXX11_STD_UNORDERED\n#  define BOOST_NO_CXX11_STD_UNORDERED\n# endif\n#endif\n\n//  Use BOOST_NO_CXX11_HDR_INITIALIZER_LIST instead of BOOST_NO_INITIALIZER_LISTS\n#if defined(BOOST_NO_CXX11_HDR_INITIALIZER_LIST) && !defined(BOOST_NO_INITIALIZER_LISTS)\n#  define BOOST_NO_INITIALIZER_LISTS\n#endif\n\n//  Use BOOST_NO_CXX11_HDR_ARRAY instead of BOOST_NO_0X_HDR_ARRAY\n#if defined(BOOST_NO_CXX11_HDR_ARRAY) && !defined(BOOST_NO_0X_HDR_ARRAY)\n#  define BOOST_NO_0X_HDR_ARRAY\n#endif\n//  Use BOOST_NO_CXX11_HDR_CHRONO instead of BOOST_NO_0X_HDR_CHRONO\n#if defined(BOOST_NO_CXX11_HDR_CHRONO) && !defined(BOOST_NO_0X_HDR_CHRONO)\n#  define BOOST_NO_0X_HDR_CHRONO\n#endif\n//  Use BOOST_NO_CXX11_HDR_CODECVT instead of BOOST_NO_0X_HDR_CODECVT\n#if defined(BOOST_NO_CXX11_HDR_CODECVT) && !defined(BOOST_NO_0X_HDR_CODECVT)\n#  define BOOST_NO_0X_HDR_CODECVT\n#endif\n//  Use BOOST_NO_CXX11_HDR_CONDITION_VARIABLE instead of BOOST_NO_0X_HDR_CONDITION_VARIABLE\n#if defined(BOOST_NO_CXX11_HDR_CONDITION_VARIABLE) && !defined(BOOST_NO_0X_HDR_CONDITION_VARIABLE)\n#  define BOOST_NO_0X_HDR_CONDITION_VARIABLE\n#endif\n//  Use BOOST_NO_CXX11_HDR_FORWARD_LIST instead of BOOST_NO_0X_HDR_FORWARD_LIST\n#if defined(BOOST_NO_CXX11_HDR_FORWARD_LIST) && !defined(BOOST_NO_0X_HDR_FORWARD_LIST)\n#  define BOOST_NO_0X_HDR_FORWARD_LIST\n#endif\n//  Use BOOST_NO_CXX11_HDR_FUTURE instead of BOOST_NO_0X_HDR_FUTURE\n#if defined(BOOST_NO_CXX11_HDR_FUTURE) && !defined(BOOST_NO_0X_HDR_FUTURE)\n#  define BOOST_NO_0X_HDR_FUTURE\n#endif\n\n//  Use BOOST_NO_CXX11_HDR_INITIALIZER_LIST\n//  instead of BOOST_NO_0X_HDR_INITIALIZER_LIST or BOOST_NO_INITIALIZER_LISTS\n#ifdef BOOST_NO_CXX11_HDR_INITIALIZER_LIST\n# ifndef BOOST_NO_0X_HDR_INITIALIZER_LIST\n#  define BOOST_NO_0X_HDR_INITIALIZER_LIST\n# endif\n# ifndef BOOST_NO_INITIALIZER_LISTS\n#  define BOOST_NO_INITIALIZER_LISTS\n# endif\n#endif\n\n//  Use BOOST_NO_CXX11_HDR_MUTEX instead of BOOST_NO_0X_HDR_MUTEX\n#if defined(BOOST_NO_CXX11_HDR_MUTEX) && !defined(BOOST_NO_0X_HDR_MUTEX)\n#  define BOOST_NO_0X_HDR_MUTEX\n#endif\n//  Use BOOST_NO_CXX11_HDR_RANDOM instead of BOOST_NO_0X_HDR_RANDOM\n#if defined(BOOST_NO_CXX11_HDR_RANDOM) && !defined(BOOST_NO_0X_HDR_RANDOM)\n#  define BOOST_NO_0X_HDR_RANDOM\n#endif\n//  Use BOOST_NO_CXX11_HDR_RATIO instead of BOOST_NO_0X_HDR_RATIO\n#if defined(BOOST_NO_CXX11_HDR_RATIO) && !defined(BOOST_NO_0X_HDR_RATIO)\n#  define BOOST_NO_0X_HDR_RATIO\n#endif\n//  Use BOOST_NO_CXX11_HDR_REGEX instead of BOOST_NO_0X_HDR_REGEX\n#if defined(BOOST_NO_CXX11_HDR_REGEX) && !defined(BOOST_NO_0X_HDR_REGEX)\n#  define BOOST_NO_0X_HDR_REGEX\n#endif\n//  Use BOOST_NO_CXX11_HDR_SYSTEM_ERROR instead of BOOST_NO_0X_HDR_SYSTEM_ERROR\n#if defined(BOOST_NO_CXX11_HDR_SYSTEM_ERROR) && !defined(BOOST_NO_0X_HDR_SYSTEM_ERROR)\n#  define BOOST_NO_0X_HDR_SYSTEM_ERROR\n#endif\n//  Use BOOST_NO_CXX11_HDR_THREAD instead of BOOST_NO_0X_HDR_THREAD\n#if defined(BOOST_NO_CXX11_HDR_THREAD) && !defined(BOOST_NO_0X_HDR_THREAD)\n#  define BOOST_NO_0X_HDR_THREAD\n#endif\n//  Use BOOST_NO_CXX11_HDR_TUPLE instead of BOOST_NO_0X_HDR_TUPLE\n#if defined(BOOST_NO_CXX11_HDR_TUPLE) && !defined(BOOST_NO_0X_HDR_TUPLE)\n#  define BOOST_NO_0X_HDR_TUPLE\n#endif\n//  Use BOOST_NO_CXX11_HDR_TYPE_TRAITS instead of BOOST_NO_0X_HDR_TYPE_TRAITS\n#if defined(BOOST_NO_CXX11_HDR_TYPE_TRAITS) && !defined(BOOST_NO_0X_HDR_TYPE_TRAITS)\n#  define BOOST_NO_0X_HDR_TYPE_TRAITS\n#endif\n//  Use BOOST_NO_CXX11_HDR_TYPEINDEX instead of BOOST_NO_0X_HDR_TYPEINDEX\n#if defined(BOOST_NO_CXX11_HDR_TYPEINDEX) && !defined(BOOST_NO_0X_HDR_TYPEINDEX)\n#  define BOOST_NO_0X_HDR_TYPEINDEX\n#endif\n//  Use BOOST_NO_CXX11_HDR_UNORDERED_MAP instead of BOOST_NO_0X_HDR_UNORDERED_MAP\n#if defined(BOOST_NO_CXX11_HDR_UNORDERED_MAP) && !defined(BOOST_NO_0X_HDR_UNORDERED_MAP)\n#  define BOOST_NO_0X_HDR_UNORDERED_MAP\n#endif\n//  Use BOOST_NO_CXX11_HDR_UNORDERED_SET instead of BOOST_NO_0X_HDR_UNORDERED_SET\n#if defined(BOOST_NO_CXX11_HDR_UNORDERED_SET) && !defined(BOOST_NO_0X_HDR_UNORDERED_SET)\n#  define BOOST_NO_0X_HDR_UNORDERED_SET\n#endif\n\n//  ------------------ End of deprecated macros for 1.50 ---------------------------\n\n//  -------------------- Deprecated macros for 1.51 ---------------------------\n//  These will go away in a future release\n\n//  Use     BOOST_NO_CXX11_AUTO_DECLARATIONS instead of   BOOST_NO_AUTO_DECLARATIONS\n#if defined(BOOST_NO_CXX11_AUTO_DECLARATIONS) && !defined(BOOST_NO_AUTO_DECLARATIONS)\n#  define BOOST_NO_AUTO_DECLARATIONS\n#endif\n//  Use     BOOST_NO_CXX11_AUTO_MULTIDECLARATIONS instead of   BOOST_NO_AUTO_MULTIDECLARATIONS\n#if defined(BOOST_NO_CXX11_AUTO_MULTIDECLARATIONS) && !defined(BOOST_NO_AUTO_MULTIDECLARATIONS)\n#  define BOOST_NO_AUTO_MULTIDECLARATIONS\n#endif\n//  Use     BOOST_NO_CXX11_CHAR16_T instead of   BOOST_NO_CHAR16_T\n#if defined(BOOST_NO_CXX11_CHAR16_T) && !defined(BOOST_NO_CHAR16_T)\n#  define BOOST_NO_CHAR16_T\n#endif\n//  Use     BOOST_NO_CXX11_CHAR32_T instead of   BOOST_NO_CHAR32_T\n#if defined(BOOST_NO_CXX11_CHAR32_T) && !defined(BOOST_NO_CHAR32_T)\n#  define BOOST_NO_CHAR32_T\n#endif\n//  Use     BOOST_NO_CXX11_TEMPLATE_ALIASES instead of   BOOST_NO_TEMPLATE_ALIASES\n#if defined(BOOST_NO_CXX11_TEMPLATE_ALIASES) && !defined(BOOST_NO_TEMPLATE_ALIASES)\n#  define BOOST_NO_TEMPLATE_ALIASES\n#endif\n//  Use     BOOST_NO_CXX11_CONSTEXPR instead of   BOOST_NO_CONSTEXPR\n#if defined(BOOST_NO_CXX11_CONSTEXPR) && !defined(BOOST_NO_CONSTEXPR)\n#  define BOOST_NO_CONSTEXPR\n#endif\n//  Use     BOOST_NO_CXX11_DECLTYPE_N3276 instead of   BOOST_NO_DECLTYPE_N3276\n#if defined(BOOST_NO_CXX11_DECLTYPE_N3276) && !defined(BOOST_NO_DECLTYPE_N3276)\n#  define BOOST_NO_DECLTYPE_N3276\n#endif\n//  Use     BOOST_NO_CXX11_DECLTYPE instead of   BOOST_NO_DECLTYPE\n#if defined(BOOST_NO_CXX11_DECLTYPE) && !defined(BOOST_NO_DECLTYPE)\n#  define BOOST_NO_DECLTYPE\n#endif\n//  Use     BOOST_NO_CXX11_DEFAULTED_FUNCTIONS instead of   BOOST_NO_DEFAULTED_FUNCTIONS\n#if defined(BOOST_NO_CXX11_DEFAULTED_FUNCTIONS) && !defined(BOOST_NO_DEFAULTED_FUNCTIONS)\n#  define BOOST_NO_DEFAULTED_FUNCTIONS\n#endif\n//  Use     BOOST_NO_CXX11_DELETED_FUNCTIONS instead of   BOOST_NO_DELETED_FUNCTIONS\n#if defined(BOOST_NO_CXX11_DELETED_FUNCTIONS) && !defined(BOOST_NO_DELETED_FUNCTIONS)\n#  define BOOST_NO_DELETED_FUNCTIONS\n#endif\n//  Use     BOOST_NO_CXX11_EXPLICIT_CONVERSION_OPERATORS instead of   BOOST_NO_EXPLICIT_CONVERSION_OPERATORS\n#if defined(BOOST_NO_CXX11_EXPLICIT_CONVERSION_OPERATORS) && !defined(BOOST_NO_EXPLICIT_CONVERSION_OPERATORS)\n#  define BOOST_NO_EXPLICIT_CONVERSION_OPERATORS\n#endif\n//  Use     BOOST_NO_CXX11_EXTERN_TEMPLATE instead of   BOOST_NO_EXTERN_TEMPLATE\n#if defined(BOOST_NO_CXX11_EXTERN_TEMPLATE) && !defined(BOOST_NO_EXTERN_TEMPLATE)\n#  define BOOST_NO_EXTERN_TEMPLATE\n#endif\n//  Use     BOOST_NO_CXX11_FUNCTION_TEMPLATE_DEFAULT_ARGS instead of   BOOST_NO_FUNCTION_TEMPLATE_DEFAULT_ARGS\n#if defined(BOOST_NO_CXX11_FUNCTION_TEMPLATE_DEFAULT_ARGS) && !defined(BOOST_NO_FUNCTION_TEMPLATE_DEFAULT_ARGS)\n#  define BOOST_NO_FUNCTION_TEMPLATE_DEFAULT_ARGS\n#endif\n//  Use     BOOST_NO_CXX11_LAMBDAS instead of   BOOST_NO_LAMBDAS\n#if defined(BOOST_NO_CXX11_LAMBDAS) && !defined(BOOST_NO_LAMBDAS)\n#  define BOOST_NO_LAMBDAS\n#endif\n//  Use     BOOST_NO_CXX11_LOCAL_CLASS_TEMPLATE_PARAMETERS instead of   BOOST_NO_LOCAL_CLASS_TEMPLATE_PARAMETERS\n#if defined(BOOST_NO_CXX11_LOCAL_CLASS_TEMPLATE_PARAMETERS) && !defined(BOOST_NO_LOCAL_CLASS_TEMPLATE_PARAMETERS)\n#  define BOOST_NO_LOCAL_CLASS_TEMPLATE_PARAMETERS\n#endif\n//  Use     BOOST_NO_CXX11_NOEXCEPT instead of   BOOST_NO_NOEXCEPT\n#if defined(BOOST_NO_CXX11_NOEXCEPT) && !defined(BOOST_NO_NOEXCEPT)\n#  define BOOST_NO_NOEXCEPT\n#endif\n//  Use     BOOST_NO_CXX11_NULLPTR instead of   BOOST_NO_NULLPTR\n#if defined(BOOST_NO_CXX11_NULLPTR) && !defined(BOOST_NO_NULLPTR)\n#  define BOOST_NO_NULLPTR\n#endif\n//  Use     BOOST_NO_CXX11_RAW_LITERALS instead of   BOOST_NO_RAW_LITERALS\n#if defined(BOOST_NO_CXX11_RAW_LITERALS) && !defined(BOOST_NO_RAW_LITERALS)\n#  define BOOST_NO_RAW_LITERALS\n#endif\n//  Use     BOOST_NO_CXX11_RVALUE_REFERENCES instead of   BOOST_NO_RVALUE_REFERENCES\n#if defined(BOOST_NO_CXX11_RVALUE_REFERENCES) && !defined(BOOST_NO_RVALUE_REFERENCES)\n#  define BOOST_NO_RVALUE_REFERENCES\n#endif\n//  Use     BOOST_NO_CXX11_SCOPED_ENUMS instead of   BOOST_NO_SCOPED_ENUMS\n#if defined(BOOST_NO_CXX11_SCOPED_ENUMS) && !defined(BOOST_NO_SCOPED_ENUMS)\n#  define BOOST_NO_SCOPED_ENUMS\n#endif\n//  Use     BOOST_NO_CXX11_STATIC_ASSERT instead of   BOOST_NO_STATIC_ASSERT\n#if defined(BOOST_NO_CXX11_STATIC_ASSERT) && !defined(BOOST_NO_STATIC_ASSERT)\n#  define BOOST_NO_STATIC_ASSERT\n#endif\n//  Use     BOOST_NO_CXX11_STD_UNORDERED instead of   BOOST_NO_STD_UNORDERED\n#if defined(BOOST_NO_CXX11_STD_UNORDERED) && !defined(BOOST_NO_STD_UNORDERED)\n#  define BOOST_NO_STD_UNORDERED\n#endif\n//  Use     BOOST_NO_CXX11_UNICODE_LITERALS instead of   BOOST_NO_UNICODE_LITERALS\n#if defined(BOOST_NO_CXX11_UNICODE_LITERALS) && !defined(BOOST_NO_UNICODE_LITERALS)\n#  define BOOST_NO_UNICODE_LITERALS\n#endif\n//  Use     BOOST_NO_CXX11_UNIFIED_INITIALIZATION_SYNTAX instead of   BOOST_NO_UNIFIED_INITIALIZATION_SYNTAX\n#if defined(BOOST_NO_CXX11_UNIFIED_INITIALIZATION_SYNTAX) && !defined(BOOST_NO_UNIFIED_INITIALIZATION_SYNTAX)\n#  define BOOST_NO_UNIFIED_INITIALIZATION_SYNTAX\n#endif\n//  Use     BOOST_NO_CXX11_VARIADIC_TEMPLATES instead of   BOOST_NO_VARIADIC_TEMPLATES\n#if defined(BOOST_NO_CXX11_VARIADIC_TEMPLATES) && !defined(BOOST_NO_VARIADIC_TEMPLATES)\n#  define BOOST_NO_VARIADIC_TEMPLATES\n#endif\n//  Use     BOOST_NO_CXX11_VARIADIC_MACROS instead of   BOOST_NO_VARIADIC_MACROS\n#if defined(BOOST_NO_CXX11_VARIADIC_MACROS) && !defined(BOOST_NO_VARIADIC_MACROS)\n#  define BOOST_NO_VARIADIC_MACROS\n#endif\n//  Use     BOOST_NO_CXX11_NUMERIC_LIMITS instead of   BOOST_NO_NUMERIC_LIMITS_LOWEST\n#if defined(BOOST_NO_CXX11_NUMERIC_LIMITS) && !defined(BOOST_NO_NUMERIC_LIMITS_LOWEST)\n#  define BOOST_NO_NUMERIC_LIMITS_LOWEST\n#endif\n//  ------------------ End of deprecated macros for 1.51 ---------------------------\n\n\n\n//\n// Helper macros BOOST_NOEXCEPT, BOOST_NOEXCEPT_IF, BOOST_NOEXCEPT_EXPR\n// These aid the transition to C++11 while still supporting C++03 compilers\n//\n#ifdef BOOST_NO_CXX11_NOEXCEPT\n#  define BOOST_NOEXCEPT\n#  define BOOST_NOEXCEPT_OR_NOTHROW throw()\n#  define BOOST_NOEXCEPT_IF(Predicate)\n#  define BOOST_NOEXCEPT_EXPR(Expression) false\n#else\n#  define BOOST_NOEXCEPT noexcept\n#  define BOOST_NOEXCEPT_OR_NOTHROW noexcept\n#  define BOOST_NOEXCEPT_IF(Predicate) noexcept((Predicate))\n#  define BOOST_NOEXCEPT_EXPR(Expression) noexcept((Expression))\n#endif\n//\n// Helper macro BOOST_FALLTHROUGH\n// Fallback definition of BOOST_FALLTHROUGH macro used to mark intended\n// fall-through between case labels in a switch statement. We use a definition\n// that requires a semicolon after it to avoid at least one type of misuse even\n// on unsupported compilers.\n//\n#ifndef BOOST_FALLTHROUGH\n#  define BOOST_FALLTHROUGH ((void)0)\n#endif\n\n//\n// constexpr workarounds\n//\n#if defined(BOOST_NO_CXX11_CONSTEXPR)\n#define BOOST_CONSTEXPR\n#define BOOST_CONSTEXPR_OR_CONST const\n#else\n#define BOOST_CONSTEXPR constexpr\n#define BOOST_CONSTEXPR_OR_CONST constexpr\n#endif\n#if defined(BOOST_NO_CXX14_CONSTEXPR)\n#define BOOST_CXX14_CONSTEXPR\n#else\n#define BOOST_CXX14_CONSTEXPR constexpr\n#endif\n\n//\n// Unused variable/typedef workarounds:\n//\n#ifndef BOOST_ATTRIBUTE_UNUSED\n#  define BOOST_ATTRIBUTE_UNUSED\n#endif\n\n#define BOOST_STATIC_CONSTEXPR  static BOOST_CONSTEXPR_OR_CONST\n\n//\n// Set BOOST_HAS_STATIC_ASSERT when BOOST_NO_CXX11_STATIC_ASSERT is not defined\n//\n#if !defined(BOOST_NO_CXX11_STATIC_ASSERT) && !defined(BOOST_HAS_STATIC_ASSERT)\n#  define BOOST_HAS_STATIC_ASSERT\n#endif\n\n//\n// Set BOOST_HAS_RVALUE_REFS when BOOST_NO_CXX11_RVALUE_REFERENCES is not defined\n//\n#if !defined(BOOST_NO_CXX11_RVALUE_REFERENCES) && !defined(BOOST_HAS_RVALUE_REFS)\n#define BOOST_HAS_RVALUE_REFS\n#endif\n\n//\n// Set BOOST_HAS_VARIADIC_TMPL when BOOST_NO_CXX11_VARIADIC_TEMPLATES is not defined\n//\n#if !defined(BOOST_NO_CXX11_VARIADIC_TEMPLATES) && !defined(BOOST_HAS_VARIADIC_TMPL)\n#define BOOST_HAS_VARIADIC_TMPL\n#endif\n//\n// Set BOOST_NO_CXX11_FIXED_LENGTH_VARIADIC_TEMPLATE_EXPANSION_PACKS when\n// BOOST_NO_CXX11_VARIADIC_TEMPLATES is set:\n//\n#if defined(BOOST_NO_CXX11_VARIADIC_TEMPLATES) && !defined(BOOST_NO_CXX11_FIXED_LENGTH_VARIADIC_TEMPLATE_EXPANSION_PACKS)\n#  define BOOST_NO_CXX11_FIXED_LENGTH_VARIADIC_TEMPLATE_EXPANSION_PACKS\n#endif\n\n//\n// Finish off with checks for macros that are depricated / no longer supported,\n// if any of these are set then it's very likely that much of Boost will no\n// longer work.  So stop with a #error for now, but give the user a chance\n// to continue at their own risk if they really want to:\n//\n#if defined(BOOST_NO_TEMPLATE_PARTIAL_SPECIALIZATION) && !defined(BOOST_CONFIG_ALLOW_DEPRECATED)\n#  error \"You are using a compiler which lacks features which are now a minimum requirement in order to use Boost, define BOOST_CONFIG_ALLOW_DEPRECATED if you want to continue at your own risk!!!\"\n#endif\n\n#endif\n"}, "9": {"id": 9, "path": "/home/runner/work/testcc/testcc/retdec/pdns/ascii.hh", "content": "/*\n * This file is part of PowerDNS or dnsdist.\n * Copyright -- PowerDNS.COM B.V. and its contributors\n *\n * This program is free software; you can redistribute it and/or modify\n * it under the terms of version 2 of the GNU General Public License as\n * published by the Free Software Foundation.\n *\n * In addition, for the avoidance of any doubt, permission is granted to\n * link this program with OpenSSL and to (re)distribute the binaries\n * produced as the result of such linking.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with this program; if not, write to the Free Software\n * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.\n */\n#pragma once\n\ninline bool dns_isspace(char c)\n{\n  return c==' ' || c=='\\t' || c=='\\r' || c=='\\n';\n}\n\ninline unsigned char dns_toupper(unsigned char c)\n{\n  if(c>='a' && c<='z')\n    c+='A'-'a';\n  return c;\n}\n\ninline unsigned char dns_tolower(unsigned char c)\n{\n  if(c>='A' && c<='Z')\n    c+='a'-'A';\n  return c;\n}\n"}, "10": {"id": 10, "path": "/home/runner/work/testcc/testcc/retdec/pdns/auth-caches.hh", "content": "/*\n * This file is part of PowerDNS or dnsdist.\n * Copyright -- PowerDNS.COM B.V. and its contributors\n *\n * This program is free software; you can redistribute it and/or modify\n * it under the terms of version 2 of the GNU General Public License as\n * published by the Free Software Foundation.\n *\n * In addition, for the avoidance of any doubt, permission is granted to\n * link this program with OpenSSL and to (re)distribute the binaries\n * produced as the result of such linking.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with this program; if not, write to the Free Software\n * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.\n */\n#pragma once\n#include <string>\n#include <cstdint>\n\n#include \"dnsname.hh\"\n\nuint64_t purgeAuthCaches(); /* empty all caches */\nuint64_t purgeAuthCaches(const std::string& match); /* remove specific entries from all caches, can be $ terminated */\nuint64_t purgeAuthCachesExact(const DNSName& qname); /* remove specific entries from all caches, no wildcard matching */\n"}, "11": {"id": 11, "path": "/home/runner/work/testcc/testcc/retdec/pdns/auth-packetcache.hh", "content": "/*\n * This file is part of PowerDNS or dnsdist.\n * Copyright -- PowerDNS.COM B.V. and its contributors\n *\n * This program is free software; you can redistribute it and/or modify\n * it under the terms of version 2 of the GNU General Public License as\n * published by the Free Software Foundation.\n *\n * In addition, for the avoidance of any doubt, permission is granted to\n * link this program with OpenSSL and to (re)distribute the binaries\n * produced as the result of such linking.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with this program; if not, write to the Free Software\n * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.\n */\n#pragma once\n#include <string>\n#include <map>\n#include \"dns.hh\"\n#include <boost/version.hpp>\n#include \"namespaces.hh\"\nusing namespace ::boost::multi_index;\n\n#include <boost/multi_index/hashed_index.hpp> \n\n#include \"dnspacket.hh\"\n#include \"lock.hh\"\n#include \"packetcache.hh\"\n\n/** This class performs 'whole packet caching'. Feed it a question packet and it will\n    try to find an answer. If you have an answer, insert it to have it cached for later use. \n    Take care not to replace existing cache entries. While this works, it is wasteful. Only\n    insert packets that where not found by get()\n\n    Locking! \n\n    The cache itself is protected by a read/write lock. Because deleting is a two step process, which \n    first marks and then sweeps, a second lock is present to prevent simultaneous inserts and deletes.\n*/\n\nclass AuthPacketCache : public PacketCache\n{\npublic:\n  AuthPacketCache(size_t mapsCount=1024);\n  ~AuthPacketCache();\n\n  void insert(DNSPacket& q, DNSPacket& r, uint32_t maxTTL);  //!< We copy the contents of *p into our cache. Do not needlessly call this to insert questions already in the cache as it wastes resources\n\n  bool get(DNSPacket& p, DNSPacket& q); //!< You need to spoof in the right ID with the DNSPacket.spoofID() method.\n\n  void cleanup(); //!< force the cache to preen itself from expired packets\n  uint64_t purge();\n  uint64_t purge(const std::string& match); // could be $ terminated. Is not a dnsname!\n  uint64_t purgeExact(const DNSName& qname); // no wildcard matching here\n\n  uint64_t size() const { return *d_statnumentries; };\n\n  void setMaxEntries(uint64_t maxEntries) \n  {\n    d_maxEntries = maxEntries;\n    for (auto& shard : d_maps) {\n      shard.reserve(maxEntries / d_maps.size());\n    }\n  }\n  void setTTL(uint32_t ttl)\n  {\n    d_ttl = ttl;\n  }\n  bool enabled()\n  {\n    return (d_ttl > 0);\n  }\nprivate:\n\n  struct CacheEntry\n  {\n    mutable string query;\n    mutable string value;\n    DNSName qname;\n\n    mutable time_t created{0};\n    mutable time_t ttd{0};\n    uint32_t hash{0};\n    uint16_t qtype{0};\n    bool tcp{false};\n  };\n\n  struct HashTag{};\n  struct NameTag{};\n  struct SequencedTag{};\n  typedef multi_index_container<\n    CacheEntry,\n    indexed_by <\n      hashed_non_unique<tag<HashTag>, member<CacheEntry,uint32_t,&CacheEntry::hash> >,\n      ordered_non_unique<tag<NameTag>, member<CacheEntry,DNSName,&CacheEntry::qname>, CanonDNSNameCompare >,\n      /* Note that this sequence holds 'least recently inserted or replaced', not least recently used.\n         Making it a LRU would require taking a write-lock when fetching from the cache, making the RW-lock inefficient compared to a mutex */\n      sequenced<tag<SequencedTag>>\n      >\n    > cmap_t;\n\n  struct MapCombo\n  {\n    MapCombo() {\n    }\n    ~MapCombo() {\n    }\n    MapCombo(const MapCombo&) = delete; \n    MapCombo& operator=(const MapCombo&) = delete;\n\n    void reserve(size_t numberOfEntries);\n\n    ReadWriteLock d_mut;\n    cmap_t d_map;\n  };\n\n  vector<MapCombo> d_maps;\n  MapCombo& getMap(const DNSName& name)\n  {\n    return d_maps[name.hash() % d_maps.size()];\n  }\n\n  static bool entryMatches(cmap_t::index<HashTag>::type::iterator& iter, const std::string& query, const DNSName& qname, uint16_t qtype, bool tcp);\n  bool getEntryLocked(cmap_t& map, const std::string& query, uint32_t hash, const DNSName &qname, uint16_t qtype, bool tcp, time_t now, string& entry);\n  void cleanupIfNeeded();\n\n  AtomicCounter d_ops{0};\n  AtomicCounter *d_statnumhit;\n  AtomicCounter *d_statnummiss;\n  AtomicCounter *d_statnumentries;\n\n  uint64_t d_maxEntries{0};\n  time_t d_lastclean; // doesn't need to be atomic\n  unsigned long d_nextclean{4096};\n  unsigned int d_cleaninterval{4096};\n  uint32_t d_ttl{0};\n  bool d_cleanskipped{false};\n\n  static const unsigned int s_mincleaninterval=1000, s_maxcleaninterval=300000;\n};\n"}, "12": {"id": 12, "path": "/usr/include/boost/multi_index_container.hpp", "content": "/* Multiply indexed container.\n *\n * Copyright 2003-2014 Joaquin M Lopez Munoz.\n * Distributed under the Boost Software License, Version 1.0.\n * (See accompanying file LICENSE_1_0.txt or copy at\n * http://www.boost.org/LICENSE_1_0.txt)\n *\n * See http://www.boost.org/libs/multi_index for library home page.\n */\n\n#ifndef BOOST_MULTI_INDEX_HPP\n#define BOOST_MULTI_INDEX_HPP\n\n#if defined(_MSC_VER)\n#pragma once\n#endif\n\n#include <boost/config.hpp> /* keep it first to prevent nasty warns in MSVC */\n#include <algorithm>\n#include <boost/detail/allocator_utilities.hpp>\n#include <boost/detail/no_exceptions_support.hpp>\n#include <boost/detail/workaround.hpp>\n#include <boost/move/core.hpp>\n#include <boost/mpl/at.hpp>\n#include <boost/mpl/contains.hpp>\n#include <boost/mpl/find_if.hpp>\n#include <boost/mpl/identity.hpp>\n#include <boost/mpl/int.hpp>\n#include <boost/mpl/size.hpp>\n#include <boost/mpl/deref.hpp>\n#include <boost/multi_index_container_fwd.hpp>\n#include <boost/multi_index/detail/access_specifier.hpp>\n#include <boost/multi_index/detail/adl_swap.hpp>\n#include <boost/multi_index/detail/base_type.hpp>\n#include <boost/multi_index/detail/do_not_copy_elements_tag.hpp>\n#include <boost/multi_index/detail/converter.hpp>\n#include <boost/multi_index/detail/header_holder.hpp>\n#include <boost/multi_index/detail/has_tag.hpp>\n#include <boost/multi_index/detail/no_duplicate_tags.hpp>\n#include <boost/multi_index/detail/safe_mode.hpp>\n#include <boost/multi_index/detail/scope_guard.hpp>\n#include <boost/multi_index/detail/vartempl_support.hpp>\n#include <boost/static_assert.hpp>\n#include <boost/type_traits/is_same.hpp>\n#include <boost/utility/base_from_member.hpp>\n\n#if !defined(BOOST_NO_CXX11_HDR_INITIALIZER_LIST)\n#include <initializer_list>\n#endif\n\n#if !defined(BOOST_MULTI_INDEX_DISABLE_SERIALIZATION)\n#include <boost/multi_index/detail/archive_constructed.hpp>\n#include <boost/multi_index/detail/serialization_version.hpp>\n#include <boost/serialization/collection_size_type.hpp>\n#include <boost/serialization/nvp.hpp>\n#include <boost/serialization/split_member.hpp>\n#include <boost/serialization/version.hpp>\n#include <boost/throw_exception.hpp> \n#endif\n\n#if defined(BOOST_MULTI_INDEX_ENABLE_INVARIANT_CHECKING)\n#include <boost/multi_index/detail/invariant_assert.hpp>\n#define BOOST_MULTI_INDEX_CHECK_INVARIANT_OF(x)                              \\\n  detail::scope_guard BOOST_JOIN(check_invariant_,__LINE__)=                 \\\n    detail::make_obj_guard(x,&multi_index_container::check_invariant_);      \\\n  BOOST_JOIN(check_invariant_,__LINE__).touch();\n#define BOOST_MULTI_INDEX_CHECK_INVARIANT                                    \\\n  BOOST_MULTI_INDEX_CHECK_INVARIANT_OF(*this)\n#else\n#define BOOST_MULTI_INDEX_CHECK_INVARIANT_OF(x)\n#define BOOST_MULTI_INDEX_CHECK_INVARIANT\n#endif\n\nnamespace boost{\n\nnamespace multi_index{\n\n#if BOOST_WORKAROUND(BOOST_MSVC,BOOST_TESTED_AT(1500))\n#pragma warning(push)\n#pragma warning(disable:4522) /* spurious warning on multiple operator=()'s */\n#endif\n\ntemplate<typename Value,typename IndexSpecifierList,typename Allocator>\nclass multi_index_container:\n  private ::boost::base_from_member<\n    typename boost::detail::allocator::rebind_to<\n      Allocator,\n      typename detail::multi_index_node_type<\n        Value,IndexSpecifierList,Allocator>::type\n    >::type>,\n  BOOST_MULTI_INDEX_PRIVATE_IF_MEMBER_TEMPLATE_FRIENDS detail::header_holder<\n    typename boost::detail::allocator::rebind_to<\n      Allocator,\n      typename detail::multi_index_node_type<\n        Value,IndexSpecifierList,Allocator>::type\n    >::type::pointer,\n    multi_index_container<Value,IndexSpecifierList,Allocator> >,\n  public detail::multi_index_base_type<\n    Value,IndexSpecifierList,Allocator>::type\n{\n#if defined(BOOST_MULTI_INDEX_ENABLE_INVARIANT_CHECKING)&&\\\n    BOOST_WORKAROUND(__MWERKS__,<=0x3003)\n/* The \"ISO C++ Template Parser\" option in CW8.3 has a problem with the\n * lifetime of const references bound to temporaries --precisely what\n * scopeguards are.\n */\n\n#pragma parse_mfunc_templ off\n#endif\n\nprivate:\n  BOOST_COPYABLE_AND_MOVABLE(multi_index_container)\n\n#if !defined(BOOST_NO_MEMBER_TEMPLATE_FRIENDS)\n  template <typename,typename,typename> friend class  detail::index_base;\n  template <typename,typename>          friend struct detail::header_holder;\n  template <typename,typename>          friend struct detail::converter;\n#endif\n\n  typedef typename detail::multi_index_base_type<\n      Value,IndexSpecifierList,Allocator>::type   super;\n  typedef typename\n  boost::detail::allocator::rebind_to<\n    Allocator,\n    typename super::node_type\n  >::type                                         node_allocator;\n  typedef ::boost::base_from_member<\n    node_allocator>                               bfm_allocator;\n  typedef detail::header_holder<\n    typename node_allocator::pointer,\n    multi_index_container>                        bfm_header;\n\n\npublic:\n  /* All types are inherited from super, a few are explicitly\n   * brought forward here to save us some typename's.\n   */\n\n  typedef typename super::ctor_args_list           ctor_args_list;\n  typedef IndexSpecifierList                       index_specifier_type_list;\n \n  typedef typename super::index_type_list          index_type_list;\n\n  typedef typename super::iterator_type_list       iterator_type_list;\n  typedef typename super::const_iterator_type_list const_iterator_type_list;\n  typedef typename super::value_type               value_type;\n  typedef typename super::final_allocator_type     allocator_type;\n  typedef typename super::iterator                 iterator;\n  typedef typename super::const_iterator           const_iterator;\n\n  BOOST_STATIC_ASSERT(\n    detail::no_duplicate_tags_in_index_list<index_type_list>::value);\n\n  /* global project() needs to see this publicly */\n\n  typedef typename super::node_type node_type;\n\n  /* construct/copy/destroy */\n\n  explicit multi_index_container(\n\n#if BOOST_WORKAROUND(__IBMCPP__,<=600)\n    /* VisualAge seems to have an ETI issue with the default values\n     * for arguments args_list and al.\n     */\n\n    const ctor_args_list& args_list=\n      typename mpl::identity<multi_index_container>::type::\n        ctor_args_list(),\n    const allocator_type& al=\n      typename mpl::identity<multi_index_container>::type::\n        allocator_type()):\n#else\n    const ctor_args_list& args_list=ctor_args_list(),\n    const allocator_type& al=allocator_type()):\n#endif\n\n    bfm_allocator(al),\n    super(args_list,bfm_allocator::member),\n    node_count(0)\n  {\n    BOOST_MULTI_INDEX_CHECK_INVARIANT;\n  }\n\n  explicit multi_index_container(const allocator_type& al):\n    bfm_allocator(al),\n    super(ctor_args_list(),bfm_allocator::member),\n    node_count(0)\n  {\n    BOOST_MULTI_INDEX_CHECK_INVARIANT;\n  }\n  \n  template<typename InputIterator>\n  multi_index_container(\n    InputIterator first,InputIterator last,\n\n#if BOOST_WORKAROUND(__IBMCPP__,<=600)\n    /* VisualAge seems to have an ETI issue with the default values\n     * for arguments args_list and al.\n     */\n\n    const ctor_args_list& args_list=\n      typename mpl::identity<multi_index_container>::type::\n        ctor_args_list(),\n    const allocator_type& al=\n      typename mpl::identity<multi_index_container>::type::\n        allocator_type()):\n#else\n    const ctor_args_list& args_list=ctor_args_list(),\n    const allocator_type& al=allocator_type()):\n#endif\n\n    bfm_allocator(al),\n    super(args_list,bfm_allocator::member),\n    node_count(0)\n  {\n    BOOST_MULTI_INDEX_CHECK_INVARIANT;\n    BOOST_TRY{\n      iterator hint=super::end();\n      for(;first!=last;++first){\n        hint=super::make_iterator(\n          insert_ref_(*first,hint.get_node()).first);\n        ++hint;\n      }\n    }\n    BOOST_CATCH(...){\n      clear_();\n      BOOST_RETHROW;\n    }\n    BOOST_CATCH_END\n  }\n\n#if !defined(BOOST_NO_CXX11_HDR_INITIALIZER_LIST)\n  multi_index_container(\n    std::initializer_list<Value> list,\n    const ctor_args_list& args_list=ctor_args_list(),\n    const allocator_type& al=allocator_type()):\n    bfm_allocator(al),\n    super(args_list,bfm_allocator::member),\n    node_count(0)\n  {\n    BOOST_MULTI_INDEX_CHECK_INVARIANT;\n    BOOST_TRY{\n      typedef const Value* init_iterator;\n\n      iterator hint=super::end();\n      for(init_iterator first=list.begin(),last=list.end();\n          first!=last;++first){\n        hint=super::make_iterator(insert_(*first,hint.get_node()).first);\n        ++hint;\n      }\n    }\n    BOOST_CATCH(...){\n      clear_();\n      BOOST_RETHROW;\n    }\n    BOOST_CATCH_END\n  }\n#endif\n\n  multi_index_container(\n    const multi_index_container<Value,IndexSpecifierList,Allocator>& x):\n    bfm_allocator(x.bfm_allocator::member),\n    bfm_header(),\n    super(x),\n    node_count(0)\n  {\n    copy_map_type map(bfm_allocator::member,x.size(),x.header(),header());\n    for(const_iterator it=x.begin(),it_end=x.end();it!=it_end;++it){\n      map.clone(it.get_node());\n    }\n    super::copy_(x,map);\n    map.release();\n    node_count=x.size();\n\n    /* Not until this point are the indices required to be consistent,\n     * hence the position of the invariant checker.\n     */\n\n    BOOST_MULTI_INDEX_CHECK_INVARIANT;\n  }\n\n  multi_index_container(BOOST_RV_REF(multi_index_container) x):\n    bfm_allocator(x.bfm_allocator::member),\n    bfm_header(),\n    super(x,detail::do_not_copy_elements_tag()),\n    node_count(0)\n  {\n    BOOST_MULTI_INDEX_CHECK_INVARIANT;\n    BOOST_MULTI_INDEX_CHECK_INVARIANT_OF(x);\n    swap_elements_(x);\n  }\n\n  ~multi_index_container()\n  {\n    delete_all_nodes_();\n  }\n\n#if defined(BOOST_NO_CXX11_RVALUE_REFERENCES)\n  /* As per http://www.boost.org/doc/html/move/emulation_limitations.html\n   * #move.emulation_limitations.assignment_operator\n   */\n\n  multi_index_container<Value,IndexSpecifierList,Allocator>& operator=(\n    const multi_index_container<Value,IndexSpecifierList,Allocator>& x)\n  {\n    multi_index_container y(x);\n    this->swap(y);\n    return *this;\n  }\n#endif\n\n  multi_index_container<Value,IndexSpecifierList,Allocator>& operator=(\n    BOOST_COPY_ASSIGN_REF(multi_index_container) x)\n  {\n    multi_index_container y(x);\n    this->swap(y);\n    return *this;\n  }\n\n  multi_index_container<Value,IndexSpecifierList,Allocator>& operator=(\n    BOOST_RV_REF(multi_index_container) x)\n  {\n    this->swap(x);\n    return *this;\n  }\n\n#if !defined(BOOST_NO_CXX11_HDR_INITIALIZER_LIST)\n  multi_index_container<Value,IndexSpecifierList,Allocator>& operator=(\n    std::initializer_list<Value> list)\n  {\n    BOOST_MULTI_INDEX_CHECK_INVARIANT;\n    typedef const Value* init_iterator;\n\n    multi_index_container x(*this,detail::do_not_copy_elements_tag());    \n    iterator hint=x.end();\n    for(init_iterator first=list.begin(),last=list.end();\n        first!=last;++first){\n      hint=x.make_iterator(x.insert_(*first,hint.get_node()).first);\n      ++hint;\n    }\n    x.swap_elements_(*this);\n    return*this;\n  }\n#endif\n\n  allocator_type get_allocator()const BOOST_NOEXCEPT\n  {\n    return allocator_type(bfm_allocator::member);\n  }\n\n  /* retrieval of indices by number */\n\n#if !defined(BOOST_NO_MEMBER_TEMPLATES)\n  template<int N>\n  struct nth_index\n  {\n    BOOST_STATIC_ASSERT(N>=0&&N<mpl::size<index_type_list>::type::value);\n    typedef typename mpl::at_c<index_type_list,N>::type type;\n  };\n\n  template<int N>\n  typename nth_index<N>::type& get()BOOST_NOEXCEPT\n  {\n    BOOST_STATIC_ASSERT(N>=0&&N<mpl::size<index_type_list>::type::value);\n    return *this;\n  }\n\n  template<int N>\n  const typename nth_index<N>::type& get()const BOOST_NOEXCEPT\n  {\n    BOOST_STATIC_ASSERT(N>=0&&N<mpl::size<index_type_list>::type::value);\n    return *this;\n  }\n#endif\n\n  /* retrieval of indices by tag */\n\n#if !defined(BOOST_NO_MEMBER_TEMPLATES)\n  template<typename Tag>\n  struct index\n  {\n    typedef typename mpl::find_if<\n      index_type_list,\n      detail::has_tag<Tag>\n    >::type                                    iter;\n\n    BOOST_STATIC_CONSTANT(\n      bool,index_found=!(is_same<iter,typename mpl::end<index_type_list>::type >::value));\n    BOOST_STATIC_ASSERT(index_found);\n\n    typedef typename mpl::deref<iter>::type    type;\n  };\n\n  template<typename Tag>\n  typename index<Tag>::type& get()BOOST_NOEXCEPT\n  {\n    return *this;\n  }\n\n  template<typename Tag>\n  const typename index<Tag>::type& get()const BOOST_NOEXCEPT\n  {\n    return *this;\n  }\n#endif\n\n  /* projection of iterators by number */\n\n#if !defined(BOOST_NO_MEMBER_TEMPLATES)\n  template<int N>\n  struct nth_index_iterator\n  {\n    typedef typename nth_index<N>::type::iterator type;\n  };\n\n  template<int N>\n  struct nth_index_const_iterator\n  {\n    typedef typename nth_index<N>::type::const_iterator type;\n  };\n\n  template<int N,typename IteratorType>\n  typename nth_index_iterator<N>::type project(IteratorType it)\n  {\n    typedef typename nth_index<N>::type index_type;\n\n#if !defined(__SUNPRO_CC)||!(__SUNPRO_CC<0x580) /* fails in Sun C++ 5.7 */\n    BOOST_STATIC_ASSERT(\n      (mpl::contains<iterator_type_list,IteratorType>::value));\n#endif\n\n    BOOST_MULTI_INDEX_CHECK_VALID_ITERATOR(it);\n    BOOST_MULTI_INDEX_CHECK_IS_OWNER(\n      it,static_cast<typename IteratorType::container_type&>(*this));\n\n    return index_type::make_iterator(static_cast<node_type*>(it.get_node()));\n  }\n\n  template<int N,typename IteratorType>\n  typename nth_index_const_iterator<N>::type project(IteratorType it)const\n  {\n    typedef typename nth_index<N>::type index_type;\n\n#if !defined(__SUNPRO_CC)||!(__SUNPRO_CC<0x580) /* fails in Sun C++ 5.7 */\n    BOOST_STATIC_ASSERT((\n      mpl::contains<iterator_type_list,IteratorType>::value||\n      mpl::contains<const_iterator_type_list,IteratorType>::value));\n#endif\n\n    BOOST_MULTI_INDEX_CHECK_VALID_ITERATOR(it);\n    BOOST_MULTI_INDEX_CHECK_IS_OWNER(\n      it,static_cast<const typename IteratorType::container_type&>(*this));\n    return index_type::make_iterator(static_cast<node_type*>(it.get_node()));\n  }\n#endif\n\n  /* projection of iterators by tag */\n\n#if !defined(BOOST_NO_MEMBER_TEMPLATES)\n  template<typename Tag>\n  struct index_iterator\n  {\n    typedef typename index<Tag>::type::iterator type;\n  };\n\n  template<typename Tag>\n  struct index_const_iterator\n  {\n    typedef typename index<Tag>::type::const_iterator type;\n  };\n\n  template<typename Tag,typename IteratorType>\n  typename index_iterator<Tag>::type project(IteratorType it)\n  {\n    typedef typename index<Tag>::type index_type;\n\n#if !defined(__SUNPRO_CC)||!(__SUNPRO_CC<0x580) /* fails in Sun C++ 5.7 */\n    BOOST_STATIC_ASSERT(\n      (mpl::contains<iterator_type_list,IteratorType>::value));\n#endif\n\n    BOOST_MULTI_INDEX_CHECK_VALID_ITERATOR(it);\n    BOOST_MULTI_INDEX_CHECK_IS_OWNER(\n      it,static_cast<typename IteratorType::container_type&>(*this));\n    return index_type::make_iterator(static_cast<node_type*>(it.get_node()));\n  }\n\n  template<typename Tag,typename IteratorType>\n  typename index_const_iterator<Tag>::type project(IteratorType it)const\n  {\n    typedef typename index<Tag>::type index_type;\n\n#if !defined(__SUNPRO_CC)||!(__SUNPRO_CC<0x580) /* fails in Sun C++ 5.7 */\n    BOOST_STATIC_ASSERT((\n      mpl::contains<iterator_type_list,IteratorType>::value||\n      mpl::contains<const_iterator_type_list,IteratorType>::value));\n#endif\n\n    BOOST_MULTI_INDEX_CHECK_VALID_ITERATOR(it);\n    BOOST_MULTI_INDEX_CHECK_IS_OWNER(\n      it,static_cast<const typename IteratorType::container_type&>(*this));\n    return index_type::make_iterator(static_cast<node_type*>(it.get_node()));\n  }\n#endif\n\nBOOST_MULTI_INDEX_PROTECTED_IF_MEMBER_TEMPLATE_FRIENDS:\n  typedef typename super::copy_map_type copy_map_type;\n\n#if !defined(BOOST_NO_CXX11_HDR_INITIALIZER_LIST)\n  multi_index_container(\n    const multi_index_container<Value,IndexSpecifierList,Allocator>& x,\n    detail::do_not_copy_elements_tag):\n    bfm_allocator(x.bfm_allocator::member),\n    bfm_header(),\n    super(x,detail::do_not_copy_elements_tag()),\n    node_count(0)\n  {\n    BOOST_MULTI_INDEX_CHECK_INVARIANT;\n  }\n#endif\n\n  node_type* header()const\n  {\n    return &*bfm_header::member;\n  }\n\n  node_type* allocate_node()\n  {\n    return &*bfm_allocator::member.allocate(1);\n  }\n\n  void deallocate_node(node_type* x)\n  {\n    typedef typename node_allocator::pointer node_pointer;\n    bfm_allocator::member.deallocate(static_cast<node_pointer>(x),1);\n  }\n\n  bool empty_()const\n  {\n    return node_count==0;\n  }\n\n  std::size_t size_()const\n  {\n    return node_count;\n  }\n\n  std::size_t max_size_()const\n  {\n    return static_cast<std::size_t >(-1);\n  }\n\n  template<typename Variant>\n  std::pair<node_type*,bool> insert_(const Value& v,Variant variant)\n  {\n    node_type* x=0;\n    node_type* res=super::insert_(v,x,variant);\n    if(res==x){\n      ++node_count;\n      return std::pair<node_type*,bool>(res,true);\n    }\n    else{\n      return std::pair<node_type*,bool>(res,false);\n    }\n  }\n\n  std::pair<node_type*,bool> insert_(const Value& v)\n  {\n    return insert_(v,detail::lvalue_tag());\n  }\n\n  std::pair<node_type*,bool> insert_rv_(const Value& v)\n  {\n    return insert_(v,detail::rvalue_tag());\n  }\n\n  template<typename T>\n  std::pair<node_type*,bool> insert_ref_(T& t)\n  {\n    node_type* x=allocate_node();\n    BOOST_TRY{\n      new(&x->value()) value_type(t);\n      BOOST_TRY{\n        node_type* res=super::insert_(x->value(),x,detail::emplaced_tag());\n        if(res==x){\n          ++node_count;\n          return std::pair<node_type*,bool>(res,true);\n        }\n        else{\n          boost::detail::allocator::destroy(&x->value());\n          deallocate_node(x);\n          return std::pair<node_type*,bool>(res,false);\n        }\n      }\n      BOOST_CATCH(...){\n        boost::detail::allocator::destroy(&x->value());\n        BOOST_RETHROW;\n      }\n      BOOST_CATCH_END\n    }\n    BOOST_CATCH(...){\n      deallocate_node(x);\n      BOOST_RETHROW;\n    }\n    BOOST_CATCH_END\n  }\n\n  std::pair<node_type*,bool> insert_ref_(const value_type& x)\n  {\n    return insert_(x);\n  }\n\n  std::pair<node_type*,bool> insert_ref_(value_type& x)\n  {\n    return insert_(x);\n  }\n\n  template<BOOST_MULTI_INDEX_TEMPLATE_PARAM_PACK>\n  std::pair<node_type*,bool> emplace_(\n    BOOST_MULTI_INDEX_FUNCTION_PARAM_PACK)\n  {\n    node_type* x=allocate_node();\n    BOOST_TRY{\n      detail::vartempl_placement_new(\n        &x->value(),BOOST_MULTI_INDEX_FORWARD_PARAM_PACK);\n      BOOST_TRY{\n        node_type* res=super::insert_(x->value(),x,detail::emplaced_tag());\n        if(res==x){\n          ++node_count;\n          return std::pair<node_type*,bool>(res,true);\n        }\n        else{\n          boost::detail::allocator::destroy(&x->value());\n          deallocate_node(x);\n          return std::pair<node_type*,bool>(res,false);\n        }\n      }\n      BOOST_CATCH(...){\n        boost::detail::allocator::destroy(&x->value());\n        BOOST_RETHROW;\n      }\n      BOOST_CATCH_END\n    }\n    BOOST_CATCH(...){\n      deallocate_node(x);\n      BOOST_RETHROW;\n    }\n    BOOST_CATCH_END\n  }\n\n  template<typename Variant>\n  std::pair<node_type*,bool> insert_(\n    const Value& v,node_type* position,Variant variant)\n  {\n    node_type* x=0;\n    node_type* res=super::insert_(v,position,x,variant);\n    if(res==x){\n      ++node_count;\n      return std::pair<node_type*,bool>(res,true);\n    }\n    else{\n      return std::pair<node_type*,bool>(res,false);\n    }\n  }\n\n  std::pair<node_type*,bool> insert_(const Value& v,node_type* position)\n  {\n    return insert_(v,position,detail::lvalue_tag());\n  }\n\n  std::pair<node_type*,bool> insert_rv_(const Value& v,node_type* position)\n  {\n    return insert_(v,position,detail::rvalue_tag());\n  }\n\n  template<typename T>\n  std::pair<node_type*,bool> insert_ref_(\n    T& t,node_type* position)\n  {\n    node_type* x=allocate_node();\n    BOOST_TRY{\n      new(&x->value()) value_type(t);\n      BOOST_TRY{\n        node_type* res=super::insert_(\n          x->value(),position,x,detail::emplaced_tag());\n        if(res==x){\n          ++node_count;\n          return std::pair<node_type*,bool>(res,true);\n        }\n        else{\n          boost::detail::allocator::destroy(&x->value());\n          deallocate_node(x);\n          return std::pair<node_type*,bool>(res,false);\n        }\n      }\n      BOOST_CATCH(...){\n        boost::detail::allocator::destroy(&x->value());\n        BOOST_RETHROW;\n      }\n      BOOST_CATCH_END\n    }\n    BOOST_CATCH(...){\n      deallocate_node(x);\n      BOOST_RETHROW;\n    }\n    BOOST_CATCH_END\n  }\n\n  std::pair<node_type*,bool> insert_ref_(\n    const value_type& x,node_type* position)\n  {\n    return insert_(x,position);\n  }\n\n  std::pair<node_type*,bool> insert_ref_(\n    value_type& x,node_type* position)\n  {\n    return insert_(x,position);\n  }\n\n  template<BOOST_MULTI_INDEX_TEMPLATE_PARAM_PACK>\n  std::pair<node_type*,bool> emplace_hint_(\n    node_type* position,\n    BOOST_MULTI_INDEX_FUNCTION_PARAM_PACK)\n  {\n    node_type* x=allocate_node();\n    BOOST_TRY{\n      detail::vartempl_placement_new(\n        &x->value(),BOOST_MULTI_INDEX_FORWARD_PARAM_PACK);\n      BOOST_TRY{\n        node_type* res=super::insert_(\n          x->value(),position,x,detail::emplaced_tag());\n        if(res==x){\n          ++node_count;\n          return std::pair<node_type*,bool>(res,true);\n        }\n        else{\n          boost::detail::allocator::destroy(&x->value());\n          deallocate_node(x);\n          return std::pair<node_type*,bool>(res,false);\n        }\n      }\n      BOOST_CATCH(...){\n        boost::detail::allocator::destroy(&x->value());\n        BOOST_RETHROW;\n      }\n      BOOST_CATCH_END\n    }\n    BOOST_CATCH(...){\n      deallocate_node(x);\n      BOOST_RETHROW;\n    }\n    BOOST_CATCH_END\n  }\n\n  void erase_(node_type* x)\n  {\n    --node_count;\n    super::erase_(x);\n    deallocate_node(x);\n  }\n\n  void delete_node_(node_type* x)\n  {\n    super::delete_node_(x);\n    deallocate_node(x);\n  }\n\n  void delete_all_nodes_()\n  {\n    super::delete_all_nodes_();\n  }\n\n  void clear_()\n  {\n    delete_all_nodes_();\n    super::clear_();\n    node_count=0;\n  }\n\n  void swap_(multi_index_container<Value,IndexSpecifierList,Allocator>& x)\n  {\n    if(bfm_allocator::member!=x.bfm_allocator::member){\n      detail::adl_swap(bfm_allocator::member,x.bfm_allocator::member);\n    }\n    std::swap(bfm_header::member,x.bfm_header::member);\n    super::swap_(x);\n    std::swap(node_count,x.node_count);\n  }\n\n  void swap_elements_(\n    multi_index_container<Value,IndexSpecifierList,Allocator>& x)\n  {\n    std::swap(bfm_header::member,x.bfm_header::member);\n    super::swap_elements_(x);\n    std::swap(node_count,x.node_count);\n  }\n\n  bool replace_(const Value& k,node_type* x)\n  {\n    return super::replace_(k,x,detail::lvalue_tag());\n  }\n\n  bool replace_rv_(const Value& k,node_type* x)\n  {\n    return super::replace_(k,x,detail::rvalue_tag());\n  }\n\n  template<typename Modifier>\n  bool modify_(Modifier& mod,node_type* x)\n  {\n    mod(const_cast<value_type&>(x->value()));\n\n    BOOST_TRY{\n      if(!super::modify_(x)){\n        deallocate_node(x);\n        --node_count;\n        return false;\n      }\n      else return true;\n    }\n    BOOST_CATCH(...){\n      deallocate_node(x);\n      --node_count;\n      BOOST_RETHROW;\n    }\n    BOOST_CATCH_END\n  }\n\n  template<typename Modifier,typename Rollback>\n  bool modify_(Modifier& mod,Rollback& back_,node_type* x)\n  {\n    mod(const_cast<value_type&>(x->value()));\n\n    bool b;\n    BOOST_TRY{\n      b=super::modify_rollback_(x);\n    }\n    BOOST_CATCH(...){\n      BOOST_TRY{\n        back_(const_cast<value_type&>(x->value()));\n        BOOST_RETHROW;\n      }\n      BOOST_CATCH(...){\n        this->erase_(x);\n        BOOST_RETHROW;\n      }\n      BOOST_CATCH_END\n    }\n    BOOST_CATCH_END\n\n    BOOST_TRY{\n      if(!b){\n        back_(const_cast<value_type&>(x->value()));\n        return false;\n      }\n      else return true;\n    }\n    BOOST_CATCH(...){\n      this->erase_(x);\n      BOOST_RETHROW;\n    }\n    BOOST_CATCH_END\n  }\n\n#if !defined(BOOST_MULTI_INDEX_DISABLE_SERIALIZATION)\n  /* serialization */\n\n  friend class boost::serialization::access;\n\n  BOOST_SERIALIZATION_SPLIT_MEMBER()\n\n  typedef typename super::index_saver_type        index_saver_type;\n  typedef typename super::index_loader_type       index_loader_type;\n\n  template<class Archive>\n  void save(Archive& ar,const unsigned int version)const\n  {\n    const serialization::collection_size_type       s(size_());\n    const detail::serialization_version<value_type> value_version;\n    ar<<serialization::make_nvp(\"count\",s);\n    ar<<serialization::make_nvp(\"value_version\",value_version);\n\n    index_saver_type sm(bfm_allocator::member,s);\n\n    for(iterator it=super::begin(),it_end=super::end();it!=it_end;++it){\n      serialization::save_construct_data_adl(ar,&*it,value_version);\n      ar<<serialization::make_nvp(\"item\",*it);\n      sm.add(it.get_node(),ar,version);\n    }\n    sm.add_track(header(),ar,version);\n\n    super::save_(ar,version,sm);\n  }\n\n  template<class Archive>\n  void load(Archive& ar,const unsigned int version)\n  {\n    BOOST_MULTI_INDEX_CHECK_INVARIANT;\n\n    clear_(); \n    serialization::collection_size_type       s;\n    detail::serialization_version<value_type> value_version;\n    if(version<1){\n      std::size_t sz;\n      ar>>serialization::make_nvp(\"count\",sz);\n      s=static_cast<serialization::collection_size_type>(sz);\n    }\n    else{\n      ar>>serialization::make_nvp(\"count\",s);\n    }\n    if(version<2){\n      value_version=0;\n    }\n    else{\n      ar>>serialization::make_nvp(\"value_version\",value_version);\n    }\n\n    index_loader_type lm(bfm_allocator::member,s);\n\n    for(std::size_t n=0;n<s;++n){\n      detail::archive_constructed<Value> value(\"item\",ar,value_version);\n      std::pair<node_type*,bool> p=insert_(\n        value.get(),super::end().get_node());\n      if(!p.second)throw_exception(\n        archive::archive_exception(\n          archive::archive_exception::other_exception));\n      ar.reset_object_address(&p.first->value(),&value.get());\n      lm.add(p.first,ar,version);\n    }\n    lm.add_track(header(),ar,version);\n\n    super::load_(ar,version,lm);\n  }\n#endif\n\n#if defined(BOOST_MULTI_INDEX_ENABLE_INVARIANT_CHECKING)\n  /* invariant stuff */\n\n  bool invariant_()const\n  {\n    return super::invariant_();\n  }\n\n  void check_invariant_()const\n  {\n    BOOST_MULTI_INDEX_INVARIANT_ASSERT(invariant_());\n  }\n#endif\n\nprivate:\n  std::size_t node_count;\n\n#if defined(BOOST_MULTI_INDEX_ENABLE_INVARIANT_CHECKING)&&\\\n    BOOST_WORKAROUND(__MWERKS__,<=0x3003)\n#pragma parse_mfunc_templ reset\n#endif\n};\n\n#if BOOST_WORKAROUND(BOOST_MSVC,BOOST_TESTED_AT(1500))\n#pragma warning(pop) /* C4522 */\n#endif\n\n/* retrieval of indices by number */\n\ntemplate<typename MultiIndexContainer,int N>\nstruct nth_index\n{\n  BOOST_STATIC_CONSTANT(\n    int,\n    M=mpl::size<typename MultiIndexContainer::index_type_list>::type::value);\n  BOOST_STATIC_ASSERT(N>=0&&N<M);\n  typedef typename mpl::at_c<\n    typename MultiIndexContainer::index_type_list,N>::type type;\n};\n\ntemplate<int N,typename Value,typename IndexSpecifierList,typename Allocator>\ntypename nth_index<\n  multi_index_container<Value,IndexSpecifierList,Allocator>,N>::type&\nget(\n  multi_index_container<Value,IndexSpecifierList,Allocator>& m)BOOST_NOEXCEPT\n{\n  typedef multi_index_container<\n    Value,IndexSpecifierList,Allocator>    multi_index_type;\n  typedef typename nth_index<\n    multi_index_container<\n      Value,IndexSpecifierList,Allocator>,\n    N\n  >::type                                  index_type;\n\n  BOOST_STATIC_ASSERT(N>=0&&\n    N<\n    mpl::size<\n      BOOST_DEDUCED_TYPENAME multi_index_type::index_type_list\n    >::type::value);\n\n  return detail::converter<multi_index_type,index_type>::index(m);\n}\n\ntemplate<int N,typename Value,typename IndexSpecifierList,typename Allocator>\nconst typename nth_index<\n  multi_index_container<Value,IndexSpecifierList,Allocator>,N>::type&\nget(\n  const multi_index_container<Value,IndexSpecifierList,Allocator>& m\n)BOOST_NOEXCEPT\n{\n  typedef multi_index_container<\n    Value,IndexSpecifierList,Allocator>    multi_index_type;\n  typedef typename nth_index<\n    multi_index_container<\n      Value,IndexSpecifierList,Allocator>,\n    N\n  >::type                                  index_type;\n\n  BOOST_STATIC_ASSERT(N>=0&&\n    N<\n    mpl::size<\n      BOOST_DEDUCED_TYPENAME multi_index_type::index_type_list\n    >::type::value);\n\n  return detail::converter<multi_index_type,index_type>::index(m);\n}\n\n/* retrieval of indices by tag */\n\ntemplate<typename MultiIndexContainer,typename Tag>\nstruct index\n{\n  typedef typename MultiIndexContainer::index_type_list index_type_list;\n\n  typedef typename mpl::find_if<\n    index_type_list,\n    detail::has_tag<Tag>\n  >::type                                      iter;\n\n  BOOST_STATIC_CONSTANT(\n    bool,index_found=!(is_same<iter,typename mpl::end<index_type_list>::type >::value));\n  BOOST_STATIC_ASSERT(index_found);\n\n  typedef typename mpl::deref<iter>::type       type;\n};\n\ntemplate<\n  typename Tag,typename Value,typename IndexSpecifierList,typename Allocator\n>\ntypename ::boost::multi_index::index<\n  multi_index_container<Value,IndexSpecifierList,Allocator>,Tag>::type&\nget(\n  multi_index_container<Value,IndexSpecifierList,Allocator>& m)BOOST_NOEXCEPT\n{\n  typedef multi_index_container<\n    Value,IndexSpecifierList,Allocator>         multi_index_type;\n  typedef typename ::boost::multi_index::index<\n    multi_index_container<\n      Value,IndexSpecifierList,Allocator>,\n    Tag\n  >::type                                       index_type;\n\n  return detail::converter<multi_index_type,index_type>::index(m);\n}\n\ntemplate<\n  typename Tag,typename Value,typename IndexSpecifierList,typename Allocator\n>\nconst typename ::boost::multi_index::index<\n  multi_index_container<Value,IndexSpecifierList,Allocator>,Tag>::type&\nget(\n  const multi_index_container<Value,IndexSpecifierList,Allocator>& m\n)BOOST_NOEXCEPT\n{\n  typedef multi_index_container<\n    Value,IndexSpecifierList,Allocator>         multi_index_type;\n  typedef typename ::boost::multi_index::index<\n    multi_index_container<\n      Value,IndexSpecifierList,Allocator>,\n    Tag\n  >::type                                       index_type;\n\n  return detail::converter<multi_index_type,index_type>::index(m);\n}\n\n/* projection of iterators by number */\n\ntemplate<typename MultiIndexContainer,int N>\nstruct nth_index_iterator\n{\n  typedef typename nth_index<MultiIndexContainer,N>::type::iterator type;\n};\n\ntemplate<typename MultiIndexContainer,int N>\nstruct nth_index_const_iterator\n{\n  typedef typename nth_index<MultiIndexContainer,N>::type::const_iterator type;\n};\n\ntemplate<\n  int N,typename IteratorType,\n  typename Value,typename IndexSpecifierList,typename Allocator>\ntypename nth_index_iterator<\n  multi_index_container<Value,IndexSpecifierList,Allocator>,N>::type\nproject(\n  multi_index_container<Value,IndexSpecifierList,Allocator>& m,\n  IteratorType it)\n{\n  typedef multi_index_container<\n    Value,IndexSpecifierList,Allocator>                multi_index_type;\n  typedef typename nth_index<multi_index_type,N>::type index_type;\n\n#if !defined(__SUNPRO_CC)||!(__SUNPRO_CC<0x580) /* Sun C++ 5.7 fails */\n  BOOST_STATIC_ASSERT((\n    mpl::contains<\n      BOOST_DEDUCED_TYPENAME multi_index_type::iterator_type_list,\n      IteratorType>::value));\n#endif\n\n  BOOST_MULTI_INDEX_CHECK_VALID_ITERATOR(it);\n\n#if defined(BOOST_MULTI_INDEX_ENABLE_SAFE_MODE)\n  typedef detail::converter<\n    multi_index_type,\n    BOOST_DEDUCED_TYPENAME IteratorType::container_type> converter;\n  BOOST_MULTI_INDEX_CHECK_IS_OWNER(it,converter::index(m));\n#endif\n\n  return detail::converter<multi_index_type,index_type>::iterator(\n    m,static_cast<typename multi_index_type::node_type*>(it.get_node()));\n}\n\ntemplate<\n  int N,typename IteratorType,\n  typename Value,typename IndexSpecifierList,typename Allocator>\ntypename nth_index_const_iterator<\n  multi_index_container<Value,IndexSpecifierList,Allocator>,N>::type\nproject(\n  const multi_index_container<Value,IndexSpecifierList,Allocator>& m,\n  IteratorType it)\n{\n  typedef multi_index_container<\n    Value,IndexSpecifierList,Allocator>                multi_index_type;\n  typedef typename nth_index<multi_index_type,N>::type index_type;\n\n#if !defined(__SUNPRO_CC)||!(__SUNPRO_CC<0x580) /* Sun C++ 5.7 fails */\n  BOOST_STATIC_ASSERT((\n    mpl::contains<\n      BOOST_DEDUCED_TYPENAME multi_index_type::iterator_type_list,\n      IteratorType>::value||\n    mpl::contains<\n      BOOST_DEDUCED_TYPENAME multi_index_type::const_iterator_type_list,\n      IteratorType>::value));\n#endif\n\n  BOOST_MULTI_INDEX_CHECK_VALID_ITERATOR(it);\n\n#if defined(BOOST_MULTI_INDEX_ENABLE_SAFE_MODE)\n  typedef detail::converter<\n    multi_index_type,\n    BOOST_DEDUCED_TYPENAME IteratorType::container_type> converter;\n  BOOST_MULTI_INDEX_CHECK_IS_OWNER(it,converter::index(m));\n#endif\n\n  return detail::converter<multi_index_type,index_type>::const_iterator(\n    m,static_cast<typename multi_index_type::node_type*>(it.get_node()));\n}\n\n/* projection of iterators by tag */\n\ntemplate<typename MultiIndexContainer,typename Tag>\nstruct index_iterator\n{\n  typedef typename ::boost::multi_index::index<\n    MultiIndexContainer,Tag>::type::iterator    type;\n};\n\ntemplate<typename MultiIndexContainer,typename Tag>\nstruct index_const_iterator\n{\n  typedef typename ::boost::multi_index::index<\n    MultiIndexContainer,Tag>::type::const_iterator type;\n};\n\ntemplate<\n  typename Tag,typename IteratorType,\n  typename Value,typename IndexSpecifierList,typename Allocator>\ntypename index_iterator<\n  multi_index_container<Value,IndexSpecifierList,Allocator>,Tag>::type\nproject(\n  multi_index_container<Value,IndexSpecifierList,Allocator>& m,\n  IteratorType it)\n{\n  typedef multi_index_container<\n    Value,IndexSpecifierList,Allocator>         multi_index_type;\n  typedef typename ::boost::multi_index::index<\n    multi_index_type,Tag>::type                 index_type;\n\n#if !defined(__SUNPRO_CC)||!(__SUNPRO_CC<0x580) /* Sun C++ 5.7 fails */\n  BOOST_STATIC_ASSERT((\n    mpl::contains<\n      BOOST_DEDUCED_TYPENAME multi_index_type::iterator_type_list,\n      IteratorType>::value));\n#endif\n\n  BOOST_MULTI_INDEX_CHECK_VALID_ITERATOR(it);\n\n#if defined(BOOST_MULTI_INDEX_ENABLE_SAFE_MODE)\n  typedef detail::converter<\n    multi_index_type,\n    BOOST_DEDUCED_TYPENAME IteratorType::container_type> converter;\n  BOOST_MULTI_INDEX_CHECK_IS_OWNER(it,converter::index(m));\n#endif\n\n  return detail::converter<multi_index_type,index_type>::iterator(\n    m,static_cast<typename multi_index_type::node_type*>(it.get_node()));\n}\n\ntemplate<\n  typename Tag,typename IteratorType,\n  typename Value,typename IndexSpecifierList,typename Allocator>\ntypename index_const_iterator<\n  multi_index_container<Value,IndexSpecifierList,Allocator>,Tag>::type\nproject(\n  const multi_index_container<Value,IndexSpecifierList,Allocator>& m,\n  IteratorType it)\n{\n  typedef multi_index_container<\n    Value,IndexSpecifierList,Allocator>         multi_index_type;\n  typedef typename ::boost::multi_index::index<\n    multi_index_type,Tag>::type                 index_type;\n\n#if !defined(__SUNPRO_CC)||!(__SUNPRO_CC<0x580) /* Sun C++ 5.7 fails */\n  BOOST_STATIC_ASSERT((\n    mpl::contains<\n      BOOST_DEDUCED_TYPENAME multi_index_type::iterator_type_list,\n      IteratorType>::value||\n    mpl::contains<\n      BOOST_DEDUCED_TYPENAME multi_index_type::const_iterator_type_list,\n      IteratorType>::value));\n#endif\n\n  BOOST_MULTI_INDEX_CHECK_VALID_ITERATOR(it);\n\n#if defined(BOOST_MULTI_INDEX_ENABLE_SAFE_MODE)\n  typedef detail::converter<\n    multi_index_type,\n    BOOST_DEDUCED_TYPENAME IteratorType::container_type> converter;\n  BOOST_MULTI_INDEX_CHECK_IS_OWNER(it,converter::index(m));\n#endif\n\n  return detail::converter<multi_index_type,index_type>::const_iterator(\n    m,static_cast<typename multi_index_type::node_type*>(it.get_node()));\n}\n\n/* Comparison. Simple forward to first index. */\n\ntemplate<\n  typename Value1,typename IndexSpecifierList1,typename Allocator1,\n  typename Value2,typename IndexSpecifierList2,typename Allocator2\n>\nbool operator==(\n  const multi_index_container<Value1,IndexSpecifierList1,Allocator1>& x,\n  const multi_index_container<Value2,IndexSpecifierList2,Allocator2>& y)\n{\n  return get<0>(x)==get<0>(y);\n}\n\ntemplate<\n  typename Value1,typename IndexSpecifierList1,typename Allocator1,\n  typename Value2,typename IndexSpecifierList2,typename Allocator2\n>\nbool operator<(\n  const multi_index_container<Value1,IndexSpecifierList1,Allocator1>& x,\n  const multi_index_container<Value2,IndexSpecifierList2,Allocator2>& y)\n{\n  return get<0>(x)<get<0>(y);\n}\n\ntemplate<\n  typename Value1,typename IndexSpecifierList1,typename Allocator1,\n  typename Value2,typename IndexSpecifierList2,typename Allocator2\n>\nbool operator!=(\n  const multi_index_container<Value1,IndexSpecifierList1,Allocator1>& x,\n  const multi_index_container<Value2,IndexSpecifierList2,Allocator2>& y)\n{\n  return get<0>(x)!=get<0>(y);\n}\n\ntemplate<\n  typename Value1,typename IndexSpecifierList1,typename Allocator1,\n  typename Value2,typename IndexSpecifierList2,typename Allocator2\n>\nbool operator>(\n  const multi_index_container<Value1,IndexSpecifierList1,Allocator1>& x,\n  const multi_index_container<Value2,IndexSpecifierList2,Allocator2>& y)\n{\n  return get<0>(x)>get<0>(y);\n}\n\ntemplate<\n  typename Value1,typename IndexSpecifierList1,typename Allocator1,\n  typename Value2,typename IndexSpecifierList2,typename Allocator2\n>\nbool operator>=(\n  const multi_index_container<Value1,IndexSpecifierList1,Allocator1>& x,\n  const multi_index_container<Value2,IndexSpecifierList2,Allocator2>& y)\n{\n  return get<0>(x)>=get<0>(y);\n}\n\ntemplate<\n  typename Value1,typename IndexSpecifierList1,typename Allocator1,\n  typename Value2,typename IndexSpecifierList2,typename Allocator2\n>\nbool operator<=(\n  const multi_index_container<Value1,IndexSpecifierList1,Allocator1>& x,\n  const multi_index_container<Value2,IndexSpecifierList2,Allocator2>& y)\n{\n  return get<0>(x)<=get<0>(y);\n}\n\n/*  specialized algorithms */\n\ntemplate<typename Value,typename IndexSpecifierList,typename Allocator>\nvoid swap(\n  multi_index_container<Value,IndexSpecifierList,Allocator>& x,\n  multi_index_container<Value,IndexSpecifierList,Allocator>& y)\n{\n  x.swap(y);\n}\n\n} /* namespace multi_index */\n\n#if !defined(BOOST_MULTI_INDEX_DISABLE_SERIALIZATION)\n/* class version = 1 : we now serialize the size through\n * boost::serialization::collection_size_type.\n * class version = 2 : proper use of {save|load}_construct_data.\n */\n\nnamespace serialization {\ntemplate<typename Value,typename IndexSpecifierList,typename Allocator>\nstruct version<\n  boost::multi_index_container<Value,IndexSpecifierList,Allocator>\n>\n{\n  BOOST_STATIC_CONSTANT(int,value=2);\n};\n} /* namespace serialization */\n#endif\n\n/* Associated global functions are promoted to namespace boost, except\n * comparison operators and swap, which are meant to be Koenig looked-up.\n */\n\nusing multi_index::get;\nusing multi_index::project;\n\n} /* namespace boost */\n\n#undef BOOST_MULTI_INDEX_CHECK_INVARIANT\n#undef BOOST_MULTI_INDEX_CHECK_INVARIANT_OF\n\n#endif\n"}, "13": {"id": 13, "path": "/home/runner/work/testcc/testcc/retdec/pdns/dnsname.hh", "content": "/*\n * This file is part of PowerDNS or dnsdist.\n * Copyright -- PowerDNS.COM B.V. and its contributors\n *\n * This program is free software; you can redistribute it and/or modify\n * it under the terms of version 2 of the GNU General Public License as\n * published by the Free Software Foundation.\n *\n * In addition, for the avoidance of any doubt, permission is granted to\n * link this program with OpenSSL and to (re)distribute the binaries\n * produced as the result of such linking.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with this program; if not, write to the Free Software\n * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.\n */\n#pragma once\n#include <cstring>\n#include <string>\n#include <vector>\n#include <set>\n#include <deque>\n#include <strings.h>\n#include <stdexcept>\n#include <sstream>\n#include <iterator>\n#include <unordered_set>\n\n#include <boost/version.hpp>\n\n// it crashes on OSX and doesn't compile on OpenBSD\n#if BOOST_VERSION >= 105300 && ! defined( __APPLE__ ) && ! defined(__OpenBSD__)\n#include <boost/container/string.hpp>\n#endif\n\n#include \"ascii.hh\"\n\nuint32_t burtleCI(const unsigned char* k, uint32_t length, uint32_t init);\n\n// #include \"dns.hh\"\n// #include \"logger.hh\"\n\n//#include <ext/vstring.h>\n\n/* Quest in life: \n     accept escaped ascii presentations of DNS names and store them \"natively\"\n     accept a DNS packet with an offset, and extract a DNS name from it\n     build up DNSNames with prepend and append of 'raw' unescaped labels\n\n   Be able to turn them into ASCII and \"DNS name in a packet\" again on request\n\n   Provide some common operators for comparison, detection of being part of another domain \n\n   NOTE: For now, everything MUST be . terminated, otherwise it is an error\n*/\n\nclass DNSName\n{\npublic:\n  DNSName()  {}          //!< Constructs an *empty* DNSName, NOT the root!\n  // Work around assertion in some boost versions that do not like self-assignment of boost::container::string\n  DNSName& operator=(const DNSName& rhs)\n  {\n    if (this != &rhs) {\n      d_storage = rhs.d_storage;\n    }\n    return *this;\n  }\n  DNSName& operator=(const DNSName&& rhs)\n  {\n    if (this != &rhs) {\n      d_storage = std::move(rhs.d_storage);\n    }\n    return *this;\n  }\n  DNSName(const DNSName& a) = default;\n  DNSName(DNSName&& a) = default;\n  explicit DNSName(const char* p): DNSName(p, std::strlen(p)) {} //!< Constructs from a human formatted, escaped presentation\n  explicit DNSName(const char* p, size_t len);      //!< Constructs from a human formatted, escaped presentation\n  explicit DNSName(const std::string& str) : DNSName(str.c_str(), str.length()) {}; //!< Constructs from a human formatted, escaped presentation\n  DNSName(const char* p, int len, int offset, bool uncompress, uint16_t* qtype=nullptr, uint16_t* qclass=nullptr, unsigned int* consumed=nullptr, uint16_t minOffset=0); //!< Construct from a DNS Packet, taking the first question if offset=12. If supplied, consumed is set to the number of bytes consumed from the packet, which will not be equal to the wire length of the resulting name in case of compression.\n  \n  bool isPartOf(const DNSName& rhs) const;   //!< Are we part of the rhs name? Note that name.isPartOf(name).\n  inline bool operator==(const DNSName& rhs) const; //!< DNS-native comparison (case insensitive) - empty compares to empty\n  bool operator!=(const DNSName& other) const { return !(*this == other); }\n\n  std::string toString(const std::string& separator=\".\", const bool trailing=true) const;              //!< Our human-friendly, escaped, representation\n  std::string toLogString() const; //!< like plain toString, but returns (empty) on empty names\n  std::string toStringNoDot() const { return toString(\".\", false); }\n  std::string toStringRootDot() const { if(isRoot()) return \".\"; else return toString(\".\", false); }\n  std::string toDNSString() const;           //!< Our representation in DNS native format\n  std::string toDNSStringLC() const;           //!< Our representation in DNS native format, lower cased\n  void appendRawLabel(const std::string& str); //!< Append this unescaped label\n  void appendRawLabel(const char* start, unsigned int length); //!< Append this unescaped label\n  void prependRawLabel(const std::string& str); //!< Prepend this unescaped label\n  std::vector<std::string> getRawLabels() const; //!< Individual raw unescaped labels\n  std::string getRawLabel(unsigned int pos) const; //!< Get the specified raw unescaped label\n  DNSName getLastLabel() const; //!< Get the DNSName of the last label\n  bool chopOff();                               //!< Turn www.powerdns.com. into powerdns.com., returns false for .\n  DNSName makeRelative(const DNSName& zone) const;\n  DNSName makeLowerCase() const\n  {\n    DNSName ret(*this);\n    ret.makeUsLowerCase();\n    return ret;\n  }\n  void makeUsLowerCase()\n  {\n    for(auto & c : d_storage) {\n      c=dns_tolower(c);\n    }\n  }\n  void makeUsRelative(const DNSName& zone);\n  DNSName getCommonLabels(const DNSName& other) const; //!< Return the list of common labels from the top, for example 'c.d' for 'a.b.c.d' and 'x.y.c.d'\n  DNSName labelReverse() const;\n  bool isWildcard() const;\n  bool isHostname() const;\n  unsigned int countLabels() const;\n  size_t wirelength() const; //!< Number of total bytes in the name\n  bool empty() const { return d_storage.empty(); }\n  bool isRoot() const { return d_storage.size()==1 && d_storage[0]==0; }\n  void clear() { d_storage.clear(); }\n  void trimToLabels(unsigned int);\n  size_t hash(size_t init=0) const\n  {\n    return burtleCI((const unsigned char*)d_storage.c_str(), d_storage.size(), init);\n  }\n  DNSName& operator+=(const DNSName& rhs)\n  {\n    if(d_storage.size() + rhs.d_storage.size() > 256) // one extra byte for the second root label\n      throw std::range_error(\"name too long\");\n    if(rhs.empty())\n      return *this;\n\n    if(d_storage.empty())\n      d_storage+=rhs.d_storage;\n    else\n      d_storage.replace(d_storage.length()-1, rhs.d_storage.length(), rhs.d_storage);\n\n    return *this;\n  }\n\n  bool operator<(const DNSName& rhs)  const // this delivers _some_ kind of ordering, but not one useful in a DNS context. Really fast though.\n  {\n    return std::lexicographical_compare(d_storage.rbegin(), d_storage.rend(), \n\t\t\t\t rhs.d_storage.rbegin(), rhs.d_storage.rend(),\n\t\t\t\t [](const unsigned char& a, const unsigned char& b) {\n\t\t\t\t\t  return dns_tolower(a) < dns_tolower(b);\n\t\t\t\t\t}); // note that this is case insensitive, including on the label lengths\n  }\n\n  inline bool canonCompare(const DNSName& rhs) const;\n  bool slowCanonCompare(const DNSName& rhs) const;  \n\n#if BOOST_VERSION >= 105300 && ! defined( __APPLE__ ) && ! defined(__OpenBSD__)\n  typedef boost::container::string string_t;\n#else\n  typedef std::string string_t;\n#endif\n  const string_t& getStorage() const {\n    return d_storage;\n  }\n\n  bool has8bitBytes() const; /* returns true if at least one byte of the labels forming the name is not included in [A-Za-z0-9_*./@ \\\\:-] */\n\nprivate:\n  string_t d_storage;\n\n  void packetParser(const char* p, int len, int offset, bool uncompress, uint16_t* qtype, uint16_t* qclass, unsigned int* consumed, int depth, uint16_t minOffset);\n  static void appendEscapedLabel(std::string& appendTo, const char* orig, size_t len);\n  static std::string unescapeLabel(const std::string& orig);\n};\n\nsize_t hash_value(DNSName const& d);\n\n\ninline bool DNSName::canonCompare(const DNSName& rhs) const\n{\n  //      01234567890abcd\n  // us:  1a3www4ds9a2nl\n  // rhs: 3www6online3com\n  // to compare, we start at the back, is nl < com? no -> done\n  //\n  // 0,2,6,a\n  // 0,4,a\n  \n  uint8_t ourpos[64], rhspos[64];\n  uint8_t ourcount=0, rhscount=0;\n  //cout<<\"Asked to compare \"<<toString()<<\" to \"<<rhs.toString()<<endl;\n  for(const unsigned char* p = (const unsigned char*)d_storage.c_str(); p < (const unsigned char*)d_storage.c_str() + d_storage.size() && *p && ourcount < sizeof(ourpos); p+=*p+1)\n    ourpos[ourcount++]=(p-(const unsigned char*)d_storage.c_str());\n  for(const unsigned char* p = (const unsigned char*)rhs.d_storage.c_str(); p < (const unsigned char*)rhs.d_storage.c_str() + rhs.d_storage.size() && *p && rhscount < sizeof(rhspos); p+=*p+1)\n    rhspos[rhscount++]=(p-(const unsigned char*)rhs.d_storage.c_str());\n\n  if(ourcount == sizeof(ourpos) || rhscount==sizeof(rhspos)) {\n    return slowCanonCompare(rhs);\n  }\n  \n  for(;;) {\n    if(ourcount == 0 && rhscount != 0)\n      return true;\n    if(rhscount == 0)\n      return false;\n    ourcount--;\n    rhscount--;\n\n    bool res=std::lexicographical_compare(\n\t\t\t\t\t  d_storage.c_str() + ourpos[ourcount] + 1, \n\t\t\t\t\t  d_storage.c_str() + ourpos[ourcount] + 1 + *(d_storage.c_str() + ourpos[ourcount]),\n\t\t\t\t\t  rhs.d_storage.c_str() + rhspos[rhscount] + 1, \n\t\t\t\t\t  rhs.d_storage.c_str() + rhspos[rhscount] + 1 + *(rhs.d_storage.c_str() + rhspos[rhscount]),\n\t\t\t\t\t  [](const unsigned char& a, const unsigned char& b) {\n\t\t\t\t\t    return dns_tolower(a) < dns_tolower(b);\n\t\t\t\t\t  });\n    \n    //    cout<<\"Forward: \"<<res<<endl;\n    if(res)\n      return true;\n\n    res=std::lexicographical_compare(\t  rhs.d_storage.c_str() + rhspos[rhscount] + 1, \n\t\t\t\t\t  rhs.d_storage.c_str() + rhspos[rhscount] + 1 + *(rhs.d_storage.c_str() + rhspos[rhscount]),\n\t\t\t\t\t  d_storage.c_str() + ourpos[ourcount] + 1, \n\t\t\t\t\t  d_storage.c_str() + ourpos[ourcount] + 1 + *(d_storage.c_str() + ourpos[ourcount]),\n\t\t\t\t\t  [](const unsigned char& a, const unsigned char& b) {\n\t\t\t\t\t    return dns_tolower(a) < dns_tolower(b);\n\t\t\t\t\t  });\n    //    cout<<\"Reverse: \"<<res<<endl;\n    if(res)\n      return false;\n  }\n  return false;\n}\n\n\nstruct CanonDNSNameCompare: public std::binary_function<DNSName, DNSName, bool>\n{\n  bool operator()(const DNSName&a, const DNSName& b) const\n  {\n    return a.canonCompare(b);\n  }\n};\n\ninline DNSName operator+(const DNSName& lhs, const DNSName& rhs)\n{\n  DNSName ret=lhs;\n  ret += rhs;\n  return ret;\n}\n\ntemplate<typename T>\nstruct SuffixMatchTree\n{\n  SuffixMatchTree(const std::string& name=\"\", bool endNode_=false) : d_name(name), endNode(endNode_)\n  {}\n\n  SuffixMatchTree(const SuffixMatchTree& rhs): d_name(rhs.d_name), children(rhs.children), endNode(rhs.endNode)\n  {\n    if (endNode) {\n      d_value = rhs.d_value;\n    }\n  }\n  SuffixMatchTree & operator=(const SuffixMatchTree &rhs)\n  {\n    d_name = rhs.d_name;\n    children = rhs.children;\n    endNode = rhs.endNode;\n    if (endNode) {\n      d_value = rhs.d_value;\n    }\n    return *this;\n  }\n  \n  std::string d_name;\n  mutable std::set<SuffixMatchTree> children;\n  mutable bool endNode;\n  mutable T d_value;\n  bool operator<(const SuffixMatchTree& rhs) const\n  {\n    return strcasecmp(d_name.c_str(), rhs.d_name.c_str()) < 0;\n  }\n  typedef SuffixMatchTree value_type;\n\n  template<typename V>\n  void visit(const V& v) const {\n    for(const auto& c : children)\n      c.visit(v);\n    if(endNode)\n      v(*this);\n  }\n\n  void add(const DNSName& name, const T& t)\n  {\n    add(name.getRawLabels(), t);\n  }\n\n  void add(std::vector<std::string> labels, const T& value) const\n  {\n    if(labels.empty()) { // this allows insertion of the root\n      endNode=true;\n      d_value=value;\n    }\n    else if(labels.size()==1) {\n      auto res=children.emplace(*labels.begin(), true);\n      if(!res.second) {\n        // we might already have had the node as an\n        // intermediary one, but it's now an end node\n        if(!res.first->endNode) {\n          res.first->endNode = true;\n        }\n      }\n      res.first->d_value = value;\n    }\n    else {\n      auto res=children.emplace(*labels.rbegin(), false);\n      labels.pop_back();\n      res.first->add(labels, value);\n    }\n  }\n\n  void remove(const DNSName &name) const\n  {\n    remove(name.getRawLabels());\n  }\n\n  /* Removes the node at `labels`, also make sure that no empty\n   * children will be left behind in memory\n   */\n  void remove(std::vector<std::string> labels) const\n  {\n    if (labels.empty()) { // this allows removal of the root\n      endNode = false;\n      return;\n    }\n\n    SuffixMatchTree smt(*labels.rbegin());\n    auto child = children.find(smt);\n    if (child == children.end()) {\n      // No subnode found, we're done\n      return;\n    }\n\n    // We have found a child\n    labels.pop_back();\n    if (labels.empty()) {\n      // The child is no longer an endnode\n      child->endNode = false;\n\n      // If the child has no further children, just remove it from the set.\n      if (child->children.empty()) {\n        children.erase(child);\n      }\n      return;\n    }\n\n    // We are not at the end, let the child figure out what to do\n    child->remove(labels);\n  }\n\n  T* lookup(const DNSName& name)  const\n  {\n    if(children.empty()) { // speed up empty set\n      if(endNode)\n        return &d_value;\n      return nullptr;\n    }\n\n    return lookup(name.getRawLabels());\n  }\n\n  T* lookup(std::vector<std::string> labels) const\n  {\n    if(labels.empty()) { // optimization\n      if(endNode)\n        return &d_value;\n      return nullptr;\n    }\n\n    SuffixMatchTree smn(*labels.rbegin());\n    auto child = children.find(smn);\n    if(child == children.end()) {\n      if(endNode)\n        return &d_value;\n      return nullptr;\n    }\n    labels.pop_back();\n    auto result = child->lookup(labels);\n    if (result) {\n      return result;\n    }\n    return endNode ? &d_value : nullptr;\n  }\n\n  // Returns all end-nodes, fully qualified (not as separate labels)\n  std::vector<DNSName> getNodes() const {\n    std::vector<DNSName> ret;\n    if (endNode) {\n      ret.push_back(DNSName(d_name));\n    }\n    for (const auto& child : children) {\n      auto nodes = child.getNodes();\n      for (const auto &node: nodes) {\n        ret.push_back(node + DNSName(d_name));\n      }\n    }\n    return ret;\n  }\n};\n\n/* Quest in life: serve as a rapid block list. If you add a DNSName to a root SuffixMatchNode,\n   anything part of that domain will return 'true' in check */\nstruct SuffixMatchNode\n{\n  public:\n    SuffixMatchNode()\n    {}\n    SuffixMatchTree<bool> d_tree;\n\n    void add(const DNSName& dnsname)\n    {\n      d_tree.add(dnsname, true);\n      d_nodes.insert(dnsname);\n    }\n\n    void add(const std::string& name)\n    {\n      add(DNSName(name));\n    }\n\n    void add(std::vector<std::string> labels)\n    {\n      d_tree.add(labels, true);\n      DNSName tmp;\n      while (!labels.empty()) {\n        tmp.appendRawLabel(labels.back());\n        labels.pop_back(); // This is safe because we have a copy of labels\n      }\n      d_nodes.insert(tmp);\n    }\n\n    void remove(const DNSName& name)\n    {\n      d_tree.remove(name);\n      d_nodes.erase(name);\n    }\n\n    void remove(std::vector<std::string> labels)\n    {\n      d_tree.remove(labels);\n      DNSName tmp;\n      while (!labels.empty()) {\n        tmp.appendRawLabel(labels.back());\n        labels.pop_back(); // This is safe because we have a copy of labels\n      }\n      d_nodes.erase(tmp);\n    }\n\n    bool check(const DNSName& dnsname) const\n    {\n      return d_tree.lookup(dnsname) != nullptr;\n    }\n\n    std::string toString() const\n    {\n      std::string ret;\n      bool first = true;\n      for (const auto& n : d_nodes) {\n        if (!first) {\n          ret += \", \";\n        }\n        first = false;\n        ret += n.toString();\n      }\n      return ret;\n    }\n\n  private:\n    mutable std::set<DNSName> d_nodes; // Only used for string generation\n};\n\nstd::ostream & operator<<(std::ostream &os, const DNSName& d);\nnamespace std {\n    template <>\n    struct hash<DNSName> {\n        size_t operator () (const DNSName& dn) const { return dn.hash(0); }\n    };\n}\n\nDNSName::string_t segmentDNSNameRaw(const char* input, size_t inputlen); // from ragel\nbool DNSName::operator==(const DNSName& rhs) const\n{\n  if(rhs.empty() != empty() || rhs.d_storage.size() != d_storage.size())\n    return false;\n\n  auto us = d_storage.cbegin();\n  auto p = rhs.d_storage.cbegin();\n  for(; us != d_storage.cend() && p != rhs.d_storage.cend(); ++us, ++p) { \n    if(dns_tolower(*p) != dns_tolower(*us))\n      return false;\n  }\n  return true;\n}\n\nextern const DNSName g_rootdnsname, g_wildcarddnsname;\n\nstruct DNSNameSet: public std::unordered_set<DNSName> {\n    std::string toString() const {\n        std::ostringstream oss;\n        std::copy(begin(), end(), std::ostream_iterator<DNSName>(oss, \"\\n\"));\n        return oss.str();\n    }\n};\n"}, "14": {"id": 14, "path": "/home/runner/work/testcc/testcc/retdec/pdns/auth-querycache.hh", "content": "/*\n * This file is part of PowerDNS or dnsdist.\n * Copyright -- PowerDNS.COM B.V. and its contributors\n *\n * This program is free software; you can redistribute it and/or modify\n * it under the terms of version 2 of the GNU General Public License as\n * published by the Free Software Foundation.\n *\n * In addition, for the avoidance of any doubt, permission is granted to\n * link this program with OpenSSL and to (re)distribute the binaries\n * produced as the result of such linking.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with this program; if not, write to the Free Software\n * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.\n */\n#pragma once\n#include <string>\n#include <map>\n#include \"dns.hh\"\n#include <boost/version.hpp>\n#include \"namespaces.hh\"\nusing namespace ::boost::multi_index;\n\n#include <boost/multi_index/hashed_index.hpp> \n\n#include \"dns.hh\"\n#include \"dnspacket.hh\"\n#include \"lock.hh\"\n\nclass AuthQueryCache : public boost::noncopyable\n{\npublic:\n  AuthQueryCache(size_t mapsCount=1024);\n  ~AuthQueryCache();\n\n  void insert(const DNSName &qname, const QType& qtype, vector<DNSZoneRecord>&& content, uint32_t ttl, int zoneID);\n\n  bool getEntry(const DNSName &qname, const QType& qtype, vector<DNSZoneRecord>& entry, int zoneID);\n\n  size_t size() { return *d_statnumentries; } //!< number of entries in the cache\n  void cleanup(); //!< force the cache to preen itself from expired querys\n  uint64_t purge();\n  uint64_t purge(const std::string& match); // could be $ terminated. Is not a dnsname!\n  uint64_t purgeExact(const DNSName& qname); // no wildcard matching here\n\n  map<char,uint64_t> getCounts();\n\n  void setMaxEntries(uint64_t maxEntries)\n  {\n    d_maxEntries = maxEntries;\n    for (auto& shard : d_maps) {\n      shard.reserve(maxEntries / d_maps.size());\n    }\n  }\nprivate:\n\n  struct CacheEntry\n  {\n    DNSName qname;\n    mutable vector<DNSZoneRecord> drs;\n    mutable time_t created{0};\n    mutable time_t ttd{0};\n    uint16_t qtype{0};\n    int zoneID{-1};\n  };\n\n  struct HashTag{};\n  struct NameTag{};\n  struct SequencedTag{};\n  typedef multi_index_container<\n    CacheEntry,\n    indexed_by <\n      hashed_unique<tag<HashTag>, composite_key<CacheEntry,\n                                                         member<CacheEntry,DNSName,&CacheEntry::qname>,\n                                                         member<CacheEntry,uint16_t,&CacheEntry::qtype>,\n                                                         member<CacheEntry,int, &CacheEntry::zoneID> > > ,\n      ordered_non_unique<tag<NameTag>, member<CacheEntry,DNSName,&CacheEntry::qname>, CanonDNSNameCompare >,\n      /* Note that this sequence holds 'least recently inserted or replaced', not least recently used.\n         Making it a LRU would require taking a write-lock when fetching from the cache, making the RW-lock inefficient compared to a mutex */\n      sequenced<tag<SequencedTag>>\n                           >\n  > cmap_t;\n\n\n  struct MapCombo\n  {\n    MapCombo() {\n    }\n    ~MapCombo() {\n    }\n    MapCombo(const MapCombo &) = delete; \n    MapCombo & operator=(const MapCombo &) = delete;\n\n    void reserve(size_t numberOfEntries);\n\n    ReadWriteLock d_mut;\n    cmap_t d_map;\n  };\n\n  vector<MapCombo> d_maps;\n  MapCombo& getMap(const DNSName& qname)\n  {\n    return d_maps[qname.hash() % d_maps.size()];\n  }\n\n  bool getEntryLocked(cmap_t& map, const DNSName &content, uint16_t qtype, vector<DNSZoneRecord>& entry, int zoneID, time_t now);\n  void cleanupIfNeeded();\n\n  AtomicCounter d_ops{0};\n  AtomicCounter *d_statnumhit;\n  AtomicCounter *d_statnummiss;\n  AtomicCounter *d_statnumentries;\n\n  uint64_t d_maxEntries{0};\n  time_t d_lastclean; // doesn't need to be atomic\n  unsigned long d_nextclean{4096};\n  unsigned int d_cleaninterval{4096};\n  bool d_cleanskipped{false};\n\n  static const unsigned int s_mincleaninterval=1000, s_maxcleaninterval=300000;\n};\n"}, "16": {"id": 16, "path": "/home/runner/work/testcc/testcc/retdec/pdns/comment.hh", "content": "/*\n * This file is part of PowerDNS or dnsdist.\n * Copyright -- PowerDNS.COM B.V. and its contributors\n *\n * This program is free software; you can redistribute it and/or modify\n * it under the terms of version 2 of the GNU General Public License as\n * published by the Free Software Foundation.\n *\n * In addition, for the avoidance of any doubt, permission is granted to\n * link this program with OpenSSL and to (re)distribute the binaries\n * produced as the result of such linking.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with this program; if not, write to the Free Software\n * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.\n */\n#pragma once\n#include \"utility.hh\"\n#include \"qtype.hh\"\n#include <sys/types.h>\n\nclass Comment\n{\npublic:\n  Comment() : modified_at(0), domain_id(0)  {};\n  ~Comment() {};\n\n  // data\n  DNSName qname; //!< the name of the associated RRset, for example: www.powerdns.com\n  time_t modified_at;\n  string account; //!< account last updating this comment\n  string content; //!< The actual comment. Example: blah blah\n\n  int domain_id;\n  QType qtype; //!< qtype of the associated RRset, ie A, CNAME, MX etc\n};\n"}, "17": {"id": 17, "path": "/home/runner/work/testcc/testcc/retdec/pdns/common_startup.hh", "content": "/*\n * This file is part of PowerDNS or dnsdist.\n * Copyright -- PowerDNS.COM B.V. and its contributors\n *\n * This program is free software; you can redistribute it and/or modify\n * it under the terms of version 2 of the GNU General Public License as\n * published by the Free Software Foundation.\n *\n * In addition, for the avoidance of any doubt, permission is granted to\n * link this program with OpenSSL and to (re)distribute the binaries\n * produced as the result of such linking.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with this program; if not, write to the Free Software\n * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.\n */\n#pragma once\n#include \"auth-packetcache.hh\"\n#include \"auth-querycache.hh\"\n#include \"utility.hh\"\n#include \"arguments.hh\"\n#include \"communicator.hh\"\n#include \"distributor.hh\"\n#include \"dnspacket.hh\"\n#include \"dnsproxy.hh\"\n#include \"dynlistener.hh\"\n#include \"nameserver.hh\"\n#include \"statbag.hh\"\n#include \"tcpreceiver.hh\"\n#include \"dnsseckeeper.hh\"\n\nextern ArgvMap theArg;\nextern StatBag S;  //!< Statistics are gathered across PDNS via the StatBag class S\nextern AuthPacketCache PC; //!< This is the main PacketCache, shared across all threads\nextern AuthQueryCache QC;\nextern std::unique_ptr<DNSProxy> DP;\nextern std::unique_ptr<DynListener> dl;\nextern CommunicatorClass Communicator;\nextern std::shared_ptr<UDPNameserver> N;\nextern vector<std::shared_ptr<UDPNameserver> > g_udpReceivers;\nextern int avg_latency;\nextern std::unique_ptr<TCPNameserver> TN;\nextern void declareArguments();\nextern void declareStats();\nextern void mainthread();\nextern int isGuarded( char ** );\nvoid carbonDumpThread();\nextern bool g_anyToTcp;\nextern bool g_8bitDNS;\n#ifdef HAVE_LUA_RECORDS\nextern bool g_doLuaRecord;\nextern bool g_LuaRecordSharedState;\nextern time_t g_luaHealthChecksInterval;\nextern time_t g_luaHealthChecksExpireDelay;\n#endif // HAVE_LUA_RECORDS\n"}, "18": {"id": 18, "path": "/home/runner/work/testcc/testcc/retdec/pdns/distributor.hh", "content": "/*\n * This file is part of PowerDNS or dnsdist.\n * Copyright -- PowerDNS.COM B.V. and its contributors\n *\n * This program is free software; you can redistribute it and/or modify\n * it under the terms of version 2 of the GNU General Public License as\n * published by the Free Software Foundation.\n *\n * In addition, for the avoidance of any doubt, permission is granted to\n * link this program with OpenSSL and to (re)distribute the binaries\n * produced as the result of such linking.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with this program; if not, write to the Free Software\n * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.\n */\n#pragma once\n#include <string>\n#include <deque>\n#include <queue>\n#include <vector>\n#include <thread>\n#include <pthread.h>\n#include \"threadname.hh\"\n#include <unistd.h>\n#include \"logger.hh\"\n#include \"dns.hh\"\n#include \"dnsbackend.hh\"\n#include \"pdnsexception.hh\"\n#include \"arguments.hh\"\n#include <atomic>\n#include \"statbag.hh\"\n\nextern StatBag S;\n\n/** the Distributor template class enables you to multithread slow question/answer \n    processes. \n    \n    Questions are posed to the Distributor, which returns the answer via a callback.\n\n    The Distributor spawns sufficient backends, and if they thrown an exception,\n    it will cycle the backend but drop the query that was active during the exception.\n*/\n\ntemplate<class Answer, class Question, class Backend> class Distributor\n{\npublic:\n  static Distributor* Create(int n=1); //!< Create a new Distributor with \\param n threads\n  typedef std::function<void(std::unique_ptr<Answer>&)> callback_t;\n  virtual int question(Question&, callback_t callback) =0; //!< Submit a question to the Distributor\n  virtual int getQueueSize() =0; //!< Returns length of question queue\n  virtual bool isOverloaded() =0;\n  virtual ~Distributor() { cerr<<__func__<<endl;}\n};\n\ntemplate<class Answer, class Question, class Backend> class SingleThreadDistributor\n    : public Distributor<Answer, Question, Backend>\n{\npublic:\n  SingleThreadDistributor(const SingleThreadDistributor&) = delete;\n  void operator=(const SingleThreadDistributor&) = delete;\n  SingleThreadDistributor();\n  typedef std::function<void(std::unique_ptr<Answer>&)> callback_t;\n  int question(Question&, callback_t callback) override; //!< Submit a question to the Distributor\n  int getQueueSize() override {\n    return 0;\n  }\n\n  bool isOverloaded() override\n  {\n    return false;\n  }\n\nprivate:\n  std::unique_ptr<Backend> b{nullptr};\n};\n\ntemplate<class Answer, class Question, class Backend> class MultiThreadDistributor\n    : public Distributor<Answer, Question, Backend>\n{\npublic:\n  MultiThreadDistributor(const MultiThreadDistributor&) = delete;\n  void operator=(const MultiThreadDistributor&) = delete;\n  MultiThreadDistributor(int n);\n  typedef std::function<void(std::unique_ptr<Answer>&)> callback_t;\n  int question(Question&, callback_t callback) override; //!< Submit a question to the Distributor\n  void distribute(int n);\n  int getQueueSize() override {\n    return d_queued;\n  }\n\n  struct QuestionData\n  {\n    QuestionData(const Question& query): Q(query)\n    {\n    }\n\n    Question Q;\n    callback_t callback;\n    int id;\n  };\n\n  bool isOverloaded() override\n  {\n    return d_overloadQueueLength && (d_queued > d_overloadQueueLength);\n  }\n\nprivate:\n  int nextid;\n  time_t d_last_started;\n  unsigned int d_overloadQueueLength, d_maxQueueLength;\n  int d_num_threads;\n  std::atomic<unsigned int> d_queued{0};\n  std::vector<std::pair<int,int>> d_pipes;\n};\n\n//template<class Answer, class Question, class Backend>::nextid;\ntemplate<class Answer, class Question, class Backend> Distributor<Answer,Question,Backend>* Distributor<Answer,Question,Backend>::Create(int n)\n{\n    if( n == 1 )\n      return new SingleThreadDistributor<Answer,Question,Backend>();\n    else\n      return new MultiThreadDistributor<Answer,Question,Backend>( n );\n}\n\ntemplate<class Answer, class Question, class Backend>SingleThreadDistributor<Answer,Question,Backend>::SingleThreadDistributor()\n{\n  g_log<<Logger::Error<<\"Only asked for 1 backend thread - operating unthreaded\"<<endl;\n  try {\n    b=make_unique<Backend>();\n  }\n  catch(const PDNSException &AE) {\n    g_log<<Logger::Error<<\"Distributor caught fatal exception: \"<<AE.reason<<endl;\n    _exit(1);\n  }\n  catch(const std::exception& e) {\n    g_log<<Logger::Error<<\"Distributor caught fatal exception: \"<<e.what()<<endl;\n    _exit(1);\n  }\n  catch(...) {\n    g_log<<Logger::Error<<\"Caught an unknown exception when creating backend, probably\"<<endl;\n    _exit(1);\n  }\n}\n\ntemplate<class Answer, class Question, class Backend>MultiThreadDistributor<Answer,Question,Backend>::MultiThreadDistributor(int n)\n{\n  d_num_threads=n;\n  d_overloadQueueLength=::arg().asNum(\"overload-queue-length\");\n  d_maxQueueLength=::arg().asNum(\"max-queue-length\");\n  nextid=0;\n  d_last_started=time(0);\n\n  for(int i=0; i < n; ++i) {\n    int fds[2];\n    if(pipe(fds) < 0)\n      unixDie(\"Creating pipe\");\n    d_pipes.push_back({fds[0],fds[1]});\n  }\n  \n  if (n<1) {\n    g_log<<Logger::Error<<\"Asked for fewer than 1 threads, nothing to do\"<<endl;\n    _exit(1);\n  }\n\n  g_log<<Logger::Warning<<\"About to create \"<<n<<\" backend threads for UDP\"<<endl;\n  for(int i=0;i<n;i++) {\n    std::thread t(std::bind(&MultiThreadDistributor<Answer,Question,Backend>::distribute, this, i));\n    t.detach();\n    Utility::usleep(50000); // we've overloaded mysql in the past :-)\n  }\n  g_log<<Logger::Warning<<\"Done launching threads, ready to distribute questions\"<<endl;\n}\n\n\n// start of a new thread\ntemplate<class Answer, class Question, class Backend>void MultiThreadDistributor<Answer,Question,Backend>::distribute(int ournum)\n{\n  setThreadName(\"pdns/distributo\");\n\n  try {\n    std::unique_ptr<Backend> b= make_unique<Backend>(); // this will answer our questions\n    int queuetimeout=::arg().asNum(\"queue-limit\"); \n\n    for(;;) {\n    \n      QuestionData* tempQD = nullptr;\n      if(read(d_pipes.at(ournum).first, &tempQD, sizeof(tempQD)) != sizeof(tempQD))\n\tunixDie(\"read\");\n      --d_queued;\n      std::unique_ptr<QuestionData> QD = std::unique_ptr<QuestionData>(tempQD);\n      tempQD = nullptr;\n      std::unique_ptr<Answer> a = nullptr;\n\n      if(queuetimeout && QD->Q.d_dt.udiff()>queuetimeout*1000) {\n        S.inc(\"timedout-packets\");\n        continue;\n      }        \n\n      bool allowRetry=true;\nretry:\n      // this is the only point where we interact with the backend (synchronous)\n      try {\n        if (!b) {\n          allowRetry=false;\n          b=make_unique<Backend>();\n        }\n        a=b->question(QD->Q);\n      }\n      catch(const PDNSException &e) {\n        b.reset();\n        if (!allowRetry) {\n          g_log<<Logger::Error<<\"Backend error: \"<<e.reason<<endl;\n          a=QD->Q.replyPacket();\n\n          a->setRcode(RCode::ServFail);\n          S.inc(\"servfail-packets\");\n          S.ringAccount(\"servfail-queries\", QD->Q.qdomain, QD->Q.qtype);\n        } else {\n          g_log<<Logger::Notice<<\"Backend error (retry once): \"<<e.reason<<endl;\n          goto retry;\n        }\n      }\n      catch(...) {\n        b.reset();\n        if (!allowRetry) {\n          g_log<<Logger::Error<<\"Caught unknown exception in Distributor thread \"<<(long)pthread_self()<<endl;\n          a=QD->Q.replyPacket();\n\n          a->setRcode(RCode::ServFail);\n          S.inc(\"servfail-packets\");\n          S.ringAccount(\"servfail-queries\", QD->Q.qdomain, QD->Q.qtype);\n        } else {\n          g_log<<Logger::Warning<<\"Caught unknown exception in Distributor thread \"<<(long)pthread_self()<<\" (retry once)\"<<endl;\n          goto retry;\n        }\n      }\n\n      QD->callback(a);\n      QD.reset();\n    }\n\n    b.reset();\n  }\n  catch(const PDNSException &AE) {\n    g_log<<Logger::Error<<\"Distributor caught fatal exception: \"<<AE.reason<<endl;\n    _exit(1);\n  }\n  catch(const std::exception& e) {\n    g_log<<Logger::Error<<\"Distributor caught fatal exception: \"<<e.what()<<endl;\n    _exit(1);\n  }\n  catch(...) {\n    g_log<<Logger::Error<<\"Caught an unknown exception when creating backend, probably\"<<endl;\n    _exit(1);\n  }\n}\n\ntemplate<class Answer, class Question, class Backend>int SingleThreadDistributor<Answer,Question,Backend>::question(Question& q, callback_t callback)\n{\n  std::unique_ptr<Answer> a = nullptr;\n  bool allowRetry=true;\nretry:\n  try {\n    if (!b) {\n      allowRetry=false;\n      b=make_unique<Backend>();\n    }\n    a=b->question(q); // a can be NULL!\n  }\n  catch(const PDNSException &e) {\n    b.reset();\n    if (!allowRetry) {\n      g_log<<Logger::Error<<\"Backend error: \"<<e.reason<<endl;\n      a=q.replyPacket();\n\n      a->setRcode(RCode::ServFail);\n      S.inc(\"servfail-packets\");\n      S.ringAccount(\"servfail-queries\", q.qdomain, q.qtype);\n    } else {\n      g_log<<Logger::Notice<<\"Backend error (retry once): \"<<e.reason<<endl;\n      goto retry;\n    }\n  }\n  catch(...) {\n    b.reset();\n    if (!allowRetry) {\n      g_log<<Logger::Error<<\"Caught unknown exception in Distributor thread \"<<(unsigned long)pthread_self()<<endl;\n      a=q.replyPacket();\n\n      a->setRcode(RCode::ServFail);\n      S.inc(\"servfail-packets\");\n      S.ringAccount(\"servfail-queries\", q.qdomain, q.qtype);\n    } else {\n      g_log<<Logger::Warning<<\"Caught unknown exception in Distributor thread \"<<(unsigned long)pthread_self()<<\" (retry once)\"<<endl;\n      goto retry;\n    }\n  }\n  callback(a);\n  return 0;\n}\n\nstruct DistributorFatal{};\n\ntemplate<class Answer, class Question, class Backend>int MultiThreadDistributor<Answer,Question,Backend>::question(Question& q, callback_t callback)\n{\n  // this is passed to other process over pipe and released there\n  auto QD=new QuestionData(q);\n  auto ret = QD->id = nextid++; // might be deleted after write!\n  QD->callback=callback;\n\n  ++d_queued;\n  if(write(d_pipes.at(QD->id % d_pipes.size()).second, &QD, sizeof(QD)) != sizeof(QD)) {\n    --d_queued;\n    delete QD;\n    unixDie(\"write\");\n  }\n\n  if(d_queued > d_maxQueueLength) {\n    g_log<<Logger::Error<< d_queued <<\" questions waiting for database/backend attention. Limit is \"<<::arg().asNum(\"max-queue-length\")<<\", respawning\"<<endl;\n    // this will leak the entire contents of all pipes, nothing will be freed. Respawn when this happens!\n    throw DistributorFatal();\n  }\n\n  return ret;\n}\n"}, "19": {"id": 19, "path": "/home/runner/work/testcc/testcc/retdec/pdns/communicator.hh", "content": "/*\n * This file is part of PowerDNS or dnsdist.\n * Copyright -- PowerDNS.COM B.V. and its contributors\n *\n * This program is free software; you can redistribute it and/or modify\n * it under the terms of version 2 of the GNU General Public License as\n * published by the Free Software Foundation.\n *\n * In addition, for the avoidance of any doubt, permission is granted to\n * link this program with OpenSSL and to (re)distribute the binaries\n * produced as the result of such linking.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with this program; if not, write to the Free Software\n * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.\n */\n#pragma once\n#include <pthread.h>\n#include <string>\n#include <semaphore.h>\n#include <queue>\n#include <list>\n#include <limits>\n#include <boost/multi_index_container.hpp>\n#include <boost/multi_index/identity.hpp>\n#include <boost/multi_index/sequenced_index.hpp>\nusing namespace boost::multi_index;\n\n#include <unistd.h>\n#include <fcntl.h>\n#include <netdb.h>\n\n#include \"lock.hh\"\n#include \"packethandler.hh\"\n\n#include \"namespaces.hh\"\n#include \"dns_random.hh\"\n\nstruct SuckRequest\n{\n  DNSName domain;\n  ComboAddress master;\n  bool force;\n  bool operator<(const SuckRequest& b) const\n  {\n    return tie(domain, master) < tie(b.domain, b.master);\n  }\n};\n\nstruct IDTag{};\n\ntypedef multi_index_container<\n  SuckRequest,\n  indexed_by<\n    sequenced<>,\n    ordered_unique<tag<IDTag>, identity<SuckRequest> >\n  >\n> UniQueue;\ntypedef UniQueue::index<IDTag>::type domains_by_name_t;\n\nclass NotificationQueue\n{\npublic:\n  void add(const DNSName &domain, const string &ip)\n  {\n    const ComboAddress caIp(ip);\n\n    NotificationRequest nr;\n    nr.domain   = domain;\n    nr.ip       = caIp.toStringWithPort();\n    nr.attempts = 0;\n    nr.id       = dns_random_uint16();\n    nr.next     = time(0);\n\n    d_nqueue.push_back(nr);\n  }\n\n  bool removeIf(const string &remote, uint16_t id, const DNSName &domain)\n  {\n    ServiceTuple stRemote, stQueued;\n    parseService(remote, stRemote);\n\n    for(d_nqueue_t::iterator i=d_nqueue.begin(); i!=d_nqueue.end(); ++i) {\n      parseService(i->ip, stQueued);\n      if(i->id==id && stQueued.host == stRemote.host && i->domain==domain) {\n        d_nqueue.erase(i);\n        return true;\n      }\n    }\n    return false;\n  }\n\n  bool getOne(DNSName &domain, string &ip, uint16_t *id, bool &purged)\n  {\n    for(d_nqueue_t::iterator i=d_nqueue.begin();i!=d_nqueue.end();++i) \n      if(i->next <= time(0)) {\n        i->attempts++;\n        purged=false;\n        i->next=time(0)+1+(1<<i->attempts);\n        domain=i->domain;\n        ip=i->ip;\n        *id=i->id;\n        purged=false;\n        if(i->attempts>4) {\n          purged=true;\n          d_nqueue.erase(i);\n        }\n        return true;\n      }\n    return false;\n  }\n\n  time_t earliest()\n  {\n    time_t early=std::numeric_limits<time_t>::max() - 1; \n    for(d_nqueue_t::const_iterator i=d_nqueue.begin();i!=d_nqueue.end();++i) \n      early=min(early,i->next);\n    return early-time(0);\n  }\n\n  void dump();\n\nprivate:\n  struct NotificationRequest\n  {\n    DNSName domain;\n    string ip;\n    time_t next;\n    int attempts;\n    uint16_t id;\n  };\n\n  typedef std::list<NotificationRequest> d_nqueue_t;\n  d_nqueue_t d_nqueue;\n\n};\n\nstruct ZoneStatus;\n\n/** this class contains a thread that communicates with other nameserver and does housekeeping.\n    Initially, it is notified only of zones that need to be pulled in because they have been updated. */\n\nclass CommunicatorClass\n{\npublic:\n  CommunicatorClass() \n  {\n    d_tickinterval=60;\n    d_masterschanged=d_slaveschanged=true;\n    d_nsock4 = -1;\n    d_nsock6 = -1;\n    d_preventSelfNotification = false;\n  }\n  time_t doNotifications(PacketHandler *P);\n  void go();\n  \n  \n  void drillHole(const DNSName &domain, const string &ip);\n  bool justNotified(const DNSName &domain, const string &ip);\n  void addSuckRequest(const DNSName &domain, const ComboAddress& master, bool force=false);\n  void addSlaveCheckRequest(const DomainInfo& di, const ComboAddress& remote);\n  void addTrySuperMasterRequest(const DNSPacket& p);\n  void notify(const DNSName &domain, const string &ip);\n  void mainloop();\n  void retrievalLoopThread();\n  void sendNotification(int sock, const DNSName &domain, const ComboAddress& remote, uint16_t id, UeberBackend* B);\n  bool notifyDomain(const DNSName &domain, UeberBackend* B);\nprivate:\n  void loadArgsIntoSet(const char *listname, set<string> &listset);\n  void makeNotifySockets();\n  void queueNotifyDomain(const DomainInfo& di, UeberBackend* B);\n  int d_nsock4, d_nsock6;\n  map<pair<DNSName,string>,time_t>d_holes;\n  std::mutex d_holelock;\n  void suck(const DNSName &domain, const ComboAddress& remote, bool force=false);\n  void ixfrSuck(const DNSName &domain, const TSIGTriplet& tt, const ComboAddress& laddr, const ComboAddress& remote, std::unique_ptr<AuthLua4>& pdl,\n                ZoneStatus& zs, vector<DNSRecord>* axfr);\n\n  void slaveRefresh(PacketHandler *P);\n  void masterUpdateCheck(PacketHandler *P);\n  std::mutex d_lock;\n  \n  UniQueue d_suckdomains;\n  set<DNSName> d_inprogress;\n  \n  Semaphore d_suck_sem;\n  Semaphore d_any_sem;\n  time_t d_tickinterval;\n  set<DomainInfo> d_tocheck;\n  struct cmp {\n    bool operator()(const DNSPacket& a, const DNSPacket& b) const {\n      return a.qdomain < b.qdomain;\n    };\n  };\n\n  std::set<DNSPacket, cmp> d_potentialsupermasters;\n\n  set<string> d_alsoNotify;\n  NotificationQueue d_nq;\n  NetmaskGroup d_onlyNotify;\n  bool d_masterschanged, d_slaveschanged;\n  bool d_preventSelfNotification;\n\n  // Used to keep some state on domains that failed their freshness checks.\n  // uint64_t == counter of the number of failures (increased by 1 every consecutive slave-cycle-interval that the domain fails)\n  // time_t == wait at least until this time before attempting a new check\n  map<DNSName, pair<uint64_t, time_t> > d_failedSlaveRefresh;\n\n  struct RemoveSentinel\n  {\n    explicit RemoveSentinel(const DNSName& dn, CommunicatorClass* cc) : d_dn(dn), d_cc(cc)\n    {}\n    \n    ~RemoveSentinel()\n    {\n      try {\n        std::lock_guard<std::mutex> l(d_cc->d_lock);\n        d_cc->d_inprogress.erase(d_dn);\n      }\n      catch(...) {\n      }\n    }\n    DNSName d_dn;\n    CommunicatorClass* d_cc;\n};\n\n};\n\n// class that one day might be more than a function to help you get IP addresses for a nameserver\nclass FindNS\n{\npublic:\n  vector<string> lookup(const DNSName &name, UeberBackend *b)\n  {\n    vector<string> addresses;\n\n    this->resolve_name(&addresses, name);\n    \n    if(b) {\n        b->lookup(QType(QType::ANY),name,-1);\n        DNSZoneRecord rr;\n        while(b->get(rr))\n          if(rr.dr.d_type == QType::A || rr.dr.d_type==QType::AAAA)\n            addresses.push_back(rr.dr.d_content->getZoneRepresentation());   // SOL if you have a CNAME for an NS\n    }\n    return addresses;\n  }\n\nprivate:\n  void resolve_name(vector<string>* addresses, const DNSName& name)\n  {\n    struct addrinfo* res;\n    struct addrinfo hints;\n    memset(&hints, 0, sizeof(hints));\n    hints.ai_socktype = SOCK_DGRAM; // otherwise we get everything in triplicate (!)\n    for(int n = 0; n < 2; ++n) {\n      hints.ai_family = n ? AF_INET : AF_INET6;\n      ComboAddress remote;\n      remote.sin4.sin_family = AF_INET6;\n      if(!getaddrinfo(name.toString().c_str(), 0, &hints, &res)) {\n        struct addrinfo* address = res;\n        do {\n          if (address->ai_addrlen <= sizeof(remote)) {\n            remote.setSockaddr(address->ai_addr, address->ai_addrlen);\n            addresses->push_back(remote.toString());\n          }\n        } while((address = address->ai_next));\n        freeaddrinfo(res);\n      }\n    }\n  }\n};\n"}, "20": {"id": 20, "path": "/home/runner/work/testcc/testcc/retdec/pdns/iputils.hh", "content": "/*\n * This file is part of PowerDNS or dnsdist.\n * Copyright -- PowerDNS.COM B.V. and its contributors\n *\n * This program is free software; you can redistribute it and/or modify\n * it under the terms of version 2 of the GNU General Public License as\n * published by the Free Software Foundation.\n *\n * In addition, for the avoidance of any doubt, permission is granted to\n * link this program with OpenSSL and to (re)distribute the binaries\n * produced as the result of such linking.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with this program; if not, write to the Free Software\n * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.\n */\n#pragma once\n#include <string>\n#include <sys/socket.h>\n#include <netinet/in.h>\n#include <arpa/inet.h>\n#include <iostream>\n#include <stdio.h>\n#include <functional>\n#include <bitset>\n#include \"pdnsexception.hh\"\n#include \"misc.hh\"\n#include <sys/socket.h>\n#include <netdb.h>\n#include <sstream>\n#include <boost/tuple/tuple.hpp>\n#include <boost/tuple/tuple_comparison.hpp>\n\n#include \"namespaces.hh\"\n\n#ifdef __APPLE__\n#include <libkern/OSByteOrder.h>\n\n#define htobe16(x) OSSwapHostToBigInt16(x)\n#define htole16(x) OSSwapHostToLittleInt16(x)\n#define be16toh(x) OSSwapBigToHostInt16(x)\n#define le16toh(x) OSSwapLittleToHostInt16(x)\n\n#define htobe32(x) OSSwapHostToBigInt32(x)\n#define htole32(x) OSSwapHostToLittleInt32(x)\n#define be32toh(x) OSSwapBigToHostInt32(x)\n#define le32toh(x) OSSwapLittleToHostInt32(x)\n\n#define htobe64(x) OSSwapHostToBigInt64(x)\n#define htole64(x) OSSwapHostToLittleInt64(x)\n#define be64toh(x) OSSwapBigToHostInt64(x)\n#define le64toh(x) OSSwapLittleToHostInt64(x)\n#endif\n\n#ifdef __sun\n\n#define htobe16(x) BE_16(x)\n#define htole16(x) LE_16(x)\n#define be16toh(x) BE_IN16(&(x))\n#define le16toh(x) LE_IN16(&(x))\n\n#define htobe32(x) BE_32(x)\n#define htole32(x) LE_32(x)\n#define be32toh(x) BE_IN32(&(x))\n#define le32toh(x) LE_IN32(&(x))\n\n#define htobe64(x) BE_64(x)\n#define htole64(x) LE_64(x)\n#define be64toh(x) BE_IN64(&(x))\n#define le64toh(x) LE_IN64(&(x))\n\n#endif\n\n#ifdef __FreeBSD__\n#include <sys/endian.h>\n#endif\n\n#if defined(__NetBSD__) && defined(IP_PKTINFO) && !defined(IP_SENDSRCADDR)\n// The IP_PKTINFO option in NetBSD was incompatible with Linux until a\n// change that also introduced IP_SENDSRCADDR for FreeBSD compatibility.\n#undef IP_PKTINFO\n#endif\n\nunion ComboAddress {\n  struct sockaddr_in sin4;\n  struct sockaddr_in6 sin6;\n\n  bool operator==(const ComboAddress& rhs) const\n  {\n    if(boost::tie(sin4.sin_family, sin4.sin_port) != boost::tie(rhs.sin4.sin_family, rhs.sin4.sin_port))\n      return false;\n    if(sin4.sin_family == AF_INET)\n      return sin4.sin_addr.s_addr == rhs.sin4.sin_addr.s_addr;\n    else\n      return memcmp(&sin6.sin6_addr.s6_addr, &rhs.sin6.sin6_addr.s6_addr, sizeof(sin6.sin6_addr.s6_addr))==0;\n  }\n\n  bool operator!=(const ComboAddress& rhs) const\n  {\n    return(!operator==(rhs));\n  }\n\n  bool operator<(const ComboAddress& rhs) const\n  {\n    if(sin4.sin_family == 0) {\n      return false;\n    }\n    if(boost::tie(sin4.sin_family, sin4.sin_port) < boost::tie(rhs.sin4.sin_family, rhs.sin4.sin_port))\n      return true;\n    if(boost::tie(sin4.sin_family, sin4.sin_port) > boost::tie(rhs.sin4.sin_family, rhs.sin4.sin_port))\n      return false;\n\n    if(sin4.sin_family == AF_INET)\n      return sin4.sin_addr.s_addr < rhs.sin4.sin_addr.s_addr;\n    else\n      return memcmp(&sin6.sin6_addr.s6_addr, &rhs.sin6.sin6_addr.s6_addr, sizeof(sin6.sin6_addr.s6_addr)) < 0;\n  }\n\n  bool operator>(const ComboAddress& rhs) const\n  {\n    return rhs.operator<(*this);\n  }\n\n  struct addressOnlyHash\n  {\n    uint32_t operator()(const ComboAddress& ca) const\n    {\n      const unsigned char* start;\n      int len;\n      if(ca.sin4.sin_family == AF_INET) {\n        start =(const unsigned char*)&ca.sin4.sin_addr.s_addr;\n        len=4;\n      }\n      else {\n        start =(const unsigned char*)&ca.sin6.sin6_addr.s6_addr;\n        len=16;\n      }\n      return burtle(start, len, 0);\n    }\n  };\n\n  struct addressOnlyLessThan: public std::binary_function<ComboAddress, ComboAddress, bool>\n  {\n    bool operator()(const ComboAddress& a, const ComboAddress& b) const\n    {\n      if(a.sin4.sin_family < b.sin4.sin_family)\n        return true;\n      if(a.sin4.sin_family > b.sin4.sin_family)\n        return false;\n      if(a.sin4.sin_family == AF_INET)\n        return a.sin4.sin_addr.s_addr < b.sin4.sin_addr.s_addr;\n      else\n        return memcmp(&a.sin6.sin6_addr.s6_addr, &b.sin6.sin6_addr.s6_addr, sizeof(a.sin6.sin6_addr.s6_addr)) < 0;\n    }\n  };\n\n  struct addressOnlyEqual: public std::binary_function<ComboAddress, ComboAddress, bool>\n  {\n    bool operator()(const ComboAddress& a, const ComboAddress& b) const\n    {\n      if(a.sin4.sin_family != b.sin4.sin_family)\n        return false;\n      if(a.sin4.sin_family == AF_INET)\n        return a.sin4.sin_addr.s_addr == b.sin4.sin_addr.s_addr;\n      else\n        return !memcmp(&a.sin6.sin6_addr.s6_addr, &b.sin6.sin6_addr.s6_addr, sizeof(a.sin6.sin6_addr.s6_addr));\n    }\n  };\n\n\n  socklen_t getSocklen() const\n  {\n    if(sin4.sin_family == AF_INET)\n      return sizeof(sin4);\n    else\n      return sizeof(sin6);\n  }\n\n  ComboAddress()\n  {\n    sin4.sin_family=AF_INET;\n    sin4.sin_addr.s_addr=0;\n    sin4.sin_port=0;\n    sin6.sin6_scope_id = 0;\n    sin6.sin6_flowinfo = 0;\n  }\n\n  ComboAddress(const struct sockaddr *sa, socklen_t salen) {\n    setSockaddr(sa, salen);\n  };\n\n  ComboAddress(const struct sockaddr_in6 *sa) {\n    setSockaddr((const struct sockaddr*)sa, sizeof(struct sockaddr_in6));\n  };\n\n  ComboAddress(const struct sockaddr_in *sa) {\n    setSockaddr((const struct sockaddr*)sa, sizeof(struct sockaddr_in));\n  };\n\n  void setSockaddr(const struct sockaddr *sa, socklen_t salen) {\n    if (salen > sizeof(struct sockaddr_in6)) throw PDNSException(\"ComboAddress can't handle other than sockaddr_in or sockaddr_in6\");\n    memcpy(this, sa, salen);\n  }\n\n  // 'port' sets a default value in case 'str' does not set a port\n  explicit ComboAddress(const string& str, uint16_t port=0)\n  {\n    memset(&sin6, 0, sizeof(sin6));\n    sin4.sin_family = AF_INET;\n    sin4.sin_port = 0;\n    if(makeIPv4sockaddr(str, &sin4)) {\n      sin6.sin6_family = AF_INET6;\n      if(makeIPv6sockaddr(str, &sin6) < 0)\n        throw PDNSException(\"Unable to convert presentation address '\"+ str +\"'\");\n\n    }\n    if(!sin4.sin_port) // 'str' overrides port!\n      sin4.sin_port=htons(port);\n  }\n\n  bool isIPv6() const\n  {\n    return sin4.sin_family == AF_INET6;\n  }\n  bool isIPv4() const\n  {\n    return sin4.sin_family == AF_INET;\n  }\n\n  bool isMappedIPv4()  const\n  {\n    if(sin4.sin_family!=AF_INET6)\n      return false;\n\n    int n=0;\n    const unsigned char*ptr = (unsigned char*) &sin6.sin6_addr.s6_addr;\n    for(n=0; n < 10; ++n)\n      if(ptr[n])\n        return false;\n\n    for(; n < 12; ++n)\n      if(ptr[n]!=0xff)\n        return false;\n\n    return true;\n  }\n\n  ComboAddress mapToIPv4() const\n  {\n    if(!isMappedIPv4())\n      throw PDNSException(\"ComboAddress can't map non-mapped IPv6 address back to IPv4\");\n    ComboAddress ret;\n    ret.sin4.sin_family=AF_INET;\n    ret.sin4.sin_port=sin4.sin_port;\n\n    const unsigned char*ptr = (unsigned char*) &sin6.sin6_addr.s6_addr;\n    ptr+=(sizeof(sin6.sin6_addr.s6_addr) - sizeof(ret.sin4.sin_addr.s_addr));\n    memcpy(&ret.sin4.sin_addr.s_addr, ptr, sizeof(ret.sin4.sin_addr.s_addr));\n    return ret;\n  }\n\n  string toString() const\n  {\n    char host[1024];\n    int retval = 0;\n    if(sin4.sin_family && !(retval = getnameinfo((struct sockaddr*) this, getSocklen(), host, sizeof(host),0, 0, NI_NUMERICHOST)))\n      return string(host);\n    else\n      return \"invalid \"+string(gai_strerror(retval));\n  }\n\n  string toStringWithPort() const\n  {\n    if(sin4.sin_family==AF_INET)\n      return toString() + \":\" + std::to_string(ntohs(sin4.sin_port));\n    else\n      return \"[\"+toString() + \"]:\" + std::to_string(ntohs(sin4.sin_port));\n  }\n\n  string toStringWithPortExcept(int port) const\n  {\n    if(ntohs(sin4.sin_port) == port)\n      return toString();\n    if(sin4.sin_family==AF_INET)\n      return toString() + \":\" + std::to_string(ntohs(sin4.sin_port));\n    else\n      return \"[\"+toString() + \"]:\" + std::to_string(ntohs(sin4.sin_port));\n  }\n\n  string toLogString() const\n  {\n    return toStringWithPortExcept(53);\n  }\n\n  void truncate(unsigned int bits) noexcept;\n\n  uint16_t getPort() const\n  {\n    return ntohs(sin4.sin_port);\n  }\n\n  void setPort(uint16_t port)\n  {\n    sin4.sin_port = htons(port);\n  }\n\n  void reset()\n  {\n    memset(&sin4, 0, sizeof(sin4));\n    memset(&sin6, 0, sizeof(sin6));\n  }\n\n  //! Get the total number of address bits (either 32 or 128 depending on IP version)\n  uint8_t getBits() const\n  {\n    if (isIPv4())\n      return 32;\n    if (isIPv6())\n      return 128;\n    return 0;\n  }\n  /** Get the value of the bit at the provided bit index. When the index >= 0,\n      the index is relative to the LSB starting at index zero. When the index < 0,\n      the index is relative to the MSB starting at index -1 and counting down.\n   */\n  bool getBit(int index) const\n  {\n    if(isIPv4()) {\n      if (index >= 32)\n        return false;\n      if (index < 0) {\n        if (index < -32)\n          return false;\n        index = 32 + index;\n      }\n\n      uint32_t ls_addr = ntohl(sin4.sin_addr.s_addr);\n\n      return ((ls_addr & (1<<index)) != 0x00000000);\n    }\n    if(isIPv6()) {\n      if (index >= 128)\n        return false;\n      if (index < 0) {\n        if (index < -128)\n          return false;\n        index = 128 + index;\n      }\n\n      uint8_t *ls_addr = (uint8_t*)sin6.sin6_addr.s6_addr;\n      uint8_t byte_idx = index / 8;\n      uint8_t bit_idx = index % 8;\n\n      return ((ls_addr[15-byte_idx] & (1 << bit_idx)) != 0x00);\n    }\n    return false;\n  }\n};\n\n/** This exception is thrown by the Netmask class and by extension by the NetmaskGroup class */\nclass NetmaskException: public PDNSException\n{\npublic:\n  NetmaskException(const string &a) : PDNSException(a) {}\n};\n\ninline ComboAddress makeComboAddress(const string& str)\n{\n  ComboAddress address;\n  address.sin4.sin_family=AF_INET;\n  if(inet_pton(AF_INET, str.c_str(), &address.sin4.sin_addr) <= 0) {\n    address.sin4.sin_family=AF_INET6;\n    if(makeIPv6sockaddr(str, &address.sin6) < 0)\n      throw NetmaskException(\"Unable to convert '\"+str+\"' to a netmask\");\n  }\n  return address;\n}\n\ninline ComboAddress makeComboAddressFromRaw(uint8_t version, const char* raw, size_t len)\n{\n  ComboAddress address;\n\n  if (version == 4) {\n    address.sin4.sin_family = AF_INET;\n    if (len != sizeof(address.sin4.sin_addr)) throw NetmaskException(\"invalid raw address length\");\n    memcpy(&address.sin4.sin_addr, raw, sizeof(address.sin4.sin_addr));\n  }\n  else if (version == 6) {\n    address.sin6.sin6_family = AF_INET6;\n    if (len != sizeof(address.sin6.sin6_addr)) throw NetmaskException(\"invalid raw address length\");\n    memcpy(&address.sin6.sin6_addr, raw, sizeof(address.sin6.sin6_addr));\n  }\n  else throw NetmaskException(\"invalid address family\");\n\n  return address;\n}\n\ninline ComboAddress makeComboAddressFromRaw(uint8_t version, const string &str)\n{\n  return makeComboAddressFromRaw(version, str.c_str(), str.size());\n}\n\n/** This class represents a netmask and can be queried to see if a certain\n    IP address is matched by this mask */\nclass Netmask\n{\npublic:\n  Netmask()\n  {\n    d_network.sin4.sin_family = 0; // disable this doing anything useful\n    d_network.sin4.sin_port = 0; // this guarantees d_network compares identical\n    d_mask = 0;\n    d_bits = 0;\n  }\n\n  Netmask(const ComboAddress& network, uint8_t bits=0xff): d_network(network)\n  {\n    d_network.sin4.sin_port = 0;\n    setBits(network.isIPv4() ? std::min(bits, static_cast<uint8_t>(32)) : std::min(bits, static_cast<uint8_t>(128)));\n  }\n\n  void setBits(uint8_t value)\n  {\n    d_bits = value;\n\n    if (d_bits < 32) {\n      d_mask = ~(0xFFFFFFFF >> d_bits);\n    }\n    else {\n      // note that d_mask is unused for IPv6\n      d_mask = 0xFFFFFFFF;\n    }\n\n    if (isIPv4()) {\n      d_network.sin4.sin_addr.s_addr = htonl(ntohl(d_network.sin4.sin_addr.s_addr) & d_mask);\n    }\n    else if (isIPv6()) {\n      uint8_t bytes = d_bits/8;\n      uint8_t *us = (uint8_t*) &d_network.sin6.sin6_addr.s6_addr;\n      uint8_t bits = d_bits % 8;\n      uint8_t mask = (uint8_t) ~(0xFF>>bits);\n\n      if (bytes < sizeof(d_network.sin6.sin6_addr.s6_addr)) {\n        us[bytes] &= mask;\n      }\n\n      for(size_t idx = bytes + 1; idx < sizeof(d_network.sin6.sin6_addr.s6_addr); ++idx) {\n        us[idx] = 0;\n      }\n    }\n  }\n\n  //! Constructor supplies the mask, which cannot be changed\n  Netmask(const string &mask)\n  {\n    pair<string,string> split = splitField(mask,'/');\n    d_network = makeComboAddress(split.first);\n\n    if (!split.second.empty()) {\n      setBits(static_cast<uint8_t>(pdns_stou(split.second)));\n    }\n    else if (d_network.sin4.sin_family == AF_INET) {\n      setBits(32);\n    }\n    else {\n      setBits(128);\n    }\n  }\n\n  bool match(const ComboAddress& ip) const\n  {\n    return match(&ip);\n  }\n\n  //! If this IP address in socket address matches\n  bool match(const ComboAddress *ip) const\n  {\n    if(d_network.sin4.sin_family != ip->sin4.sin_family) {\n      return false;\n    }\n    if(d_network.sin4.sin_family == AF_INET) {\n      return match4(htonl((unsigned int)ip->sin4.sin_addr.s_addr));\n    }\n    if(d_network.sin6.sin6_family == AF_INET6) {\n      uint8_t bytes=d_bits/8, n;\n      const uint8_t *us=(const uint8_t*) &d_network.sin6.sin6_addr.s6_addr;\n      const uint8_t *them=(const uint8_t*) &ip->sin6.sin6_addr.s6_addr;\n\n      for(n=0; n < bytes; ++n) {\n        if(us[n]!=them[n]) {\n          return false;\n        }\n      }\n      // still here, now match remaining bits\n      uint8_t bits= d_bits % 8;\n      uint8_t mask= (uint8_t) ~(0xFF>>bits);\n\n      return((us[n]) == (them[n] & mask));\n    }\n    return false;\n  }\n\n  //! If this ASCII IP address matches\n  bool match(const string &ip) const\n  {\n    ComboAddress address=makeComboAddress(ip);\n    return match(&address);\n  }\n\n  //! If this IP address in native format matches\n  bool match4(uint32_t ip) const\n  {\n    return (ip & d_mask) == (ntohl(d_network.sin4.sin_addr.s_addr));\n  }\n\n  string toString() const\n  {\n    return d_network.toString()+\"/\"+std::to_string((unsigned int)d_bits);\n  }\n\n  string toStringNoMask() const\n  {\n    return d_network.toString();\n  }\n\n  const ComboAddress& getNetwork() const\n  {\n    return d_network;\n  }\n\n  const ComboAddress& getMaskedNetwork() const\n  {\n    return getNetwork();\n  }\n\n  uint8_t getBits() const\n  {\n    return d_bits;\n  }\n\n  bool isIPv6() const\n  {\n    return d_network.sin6.sin6_family == AF_INET6;\n  }\n\n  bool isIPv4() const\n  {\n    return d_network.sin4.sin_family == AF_INET;\n  }\n\n  bool operator<(const Netmask& rhs) const\n  {\n    if (empty() && !rhs.empty())\n      return false;\n\n    if (!empty() && rhs.empty())\n      return true;\n\n    if (d_bits > rhs.d_bits)\n      return true;\n    if (d_bits < rhs.d_bits)\n      return false;\n\n    return d_network < rhs.d_network;\n  }\n\n  bool operator>(const Netmask& rhs) const\n  {\n    return rhs.operator<(*this);\n  }\n\n  bool operator==(const Netmask& rhs) const\n  {\n    return tie(d_network, d_bits) == tie(rhs.d_network, rhs.d_bits);\n  }\n\n  bool empty() const\n  {\n    return d_network.sin4.sin_family==0;\n  }\n\n  //! Get normalized version of the netmask. This means that all address bits below the network bits are zero.\n  Netmask getNormalized() const {\n    return Netmask(getMaskedNetwork(), d_bits);\n  }\n  //! Get Netmask for super network of this one (i.e. with fewer network bits)\n  Netmask getSuper(uint8_t bits) const {\n    return Netmask(d_network, std::min(d_bits, bits));\n  }\n\n  //! Get the total number of address bits for this netmask (either 32 or 128 depending on IP version)\n  uint8_t getAddressBits() const\n  {\n    return d_network.getBits();\n  }\n\n  /** Get the value of the bit at the provided bit index. When the index >= 0,\n      the index is relative to the LSB starting at index zero. When the index < 0,\n      the index is relative to the MSB starting at index -1 and counting down.\n      When the index points outside the network bits, it always yields zero.\n   */\n  bool getBit(int bit) const\n  {\n    if (bit < -d_bits)\n      return false;\n    if (bit >= 0) {\n      if(isIPv4()) {\n        if (bit >= 32 || bit < (32 - d_bits))\n          return false;\n      }\n      if(isIPv6()) {\n        if (bit >= 128 || bit < (128 - d_bits))\n          return false;\n      }\n    }\n    return d_network.getBit(bit);\n  }\nprivate:\n  ComboAddress d_network;\n  uint32_t d_mask;\n  uint8_t d_bits;\n};\n\n/** Binary tree map implementation with <Netmask,T> pair.\n *\n * This is an binary tree implementation for storing attributes for IPv4 and IPv6 prefixes.\n * The most simple use case is simple NetmaskTree<bool> used by NetmaskGroup, which only\n * wants to know if given IP address is matched in the prefixes stored.\n *\n * This element is useful for anything that needs to *STORE* prefixes, and *MATCH* IP addresses\n * to a *LIST* of *PREFIXES*. Not the other way round.\n *\n * You can store IPv4 and IPv6 addresses to same tree, separate payload storage is kept per AFI.\n * Network prefixes (Netmasks) are always recorded in normalized fashion, meaning that only\n * the network bits are set. This is what is returned in the insert() and lookup() return\n * values.\n *\n * Use swap if you need to move the tree to another NetmaskTree instance, it is WAY faster\n * than using copy ctor or assignment operator, since it moves the nodes and tree root to\n * new home instead of actually recreating the tree.\n *\n * Please see NetmaskGroup for example of simple use case. Other usecases can be found\n * from GeoIPBackend and Sortlist, and from dnsdist.\n */\ntemplate <typename T>\nclass NetmaskTree {\npublic:\n  class Iterator;\n\n  typedef Netmask key_type;\n  typedef T value_type;\n  typedef std::pair<const key_type,value_type> node_type;\n  typedef size_t size_type;\n  typedef class Iterator iterator;\n\nprivate:\n  /** Single node in tree, internal use only.\n    */\n  class TreeNode : boost::noncopyable {\n  public:\n    explicit TreeNode() noexcept :\n      parent(nullptr), node(), assigned(false), d_bits(0) {\n    }\n    explicit TreeNode(const key_type& key) noexcept :\n      parent(nullptr), node({key.getNormalized(), value_type()}),\n      assigned(false), d_bits(key.getAddressBits()) {\n    }\n\n    //<! Makes a left leaf node with specified key.\n    TreeNode* make_left(const key_type& key) {\n      d_bits = node.first.getBits();\n      left = make_unique<TreeNode>(key);\n      left->parent = this;\n      return left.get();\n    }\n\n    //<! Makes a right leaf node with specified key.\n    TreeNode* make_right(const key_type& key) {\n      d_bits = node.first.getBits();\n      right = make_unique<TreeNode>(key);\n      right->parent = this;\n      return right.get();\n    }\n\n    //<! Splits branch at indicated bit position by inserting key\n    TreeNode* split(const key_type& key, int bits) {\n      if (parent == nullptr) {\n        // not to be called on the root node\n        throw std::logic_error(\n          \"NetmaskTree::TreeNode::split(): must not be called on root node\");\n      }\n\n      // determine reference from parent\n      unique_ptr<TreeNode>& parent_ref =\n        (parent->left.get() == this ? parent->left : parent->right);\n      if (parent_ref.get() != this) {\n        throw std::logic_error(\n          \"NetmaskTree::TreeNode::split(): parent node reference is invalid\");\n      }\n\n      // create new tree node for the new key\n      TreeNode* new_node = new TreeNode(key);\n      new_node->d_bits = bits;\n\n      // attach the new node under our former parent\n      unique_ptr<TreeNode> new_child(new_node);\n      std::swap(parent_ref, new_child); // hereafter new_child points to \"this\"\n      new_node->parent = parent;\n\n      // attach \"this\" node below the new node\n      // (left or right depending on bit)\n      new_child->parent = new_node;\n      if (new_child->node.first.getBit(-1-bits)) {\n        std::swap(new_node->right, new_child);\n      } else {\n        std::swap(new_node->left, new_child);\n      }\n\n      return new_node;\n    }\n\n    //<! Forks branch for new key at indicated bit position\n    TreeNode* fork(const key_type& key, int bits) {\n      if (parent == nullptr) {\n        // not to be called on the root node\n        throw std::logic_error(\n          \"NetmaskTree::TreeNode::fork(): must not be called on root node\");\n      }\n\n      // determine reference from parent\n      unique_ptr<TreeNode>& parent_ref =\n        (parent->left.get() == this ? parent->left : parent->right);\n      if (parent_ref.get() != this) {\n        throw std::logic_error(\n          \"NetmaskTree::TreeNode::fork(): parent node reference is invalid\");\n      }\n\n      // create new tree node for the branch point\n      TreeNode* branch_node = new TreeNode(node.first.getSuper(bits));\n      branch_node->d_bits = bits;\n\n      // attach the branch node under our former parent\n      unique_ptr<TreeNode> new_child1(branch_node);\n      std::swap(parent_ref, new_child1); // hereafter new_child1 points to \"this\"\n      branch_node->parent = parent;\n\n      // create second new leaf node for the new key\n      TreeNode* new_node = new TreeNode(key);\n      unique_ptr<TreeNode> new_child2(new_node);\n\n      // attach the new child nodes below the branch node\n      // (left or right depending on bit)\n      new_child1->parent = branch_node;\n      new_child2->parent = branch_node;\n      if (new_child1->node.first.getBit(-1-bits)) {\n        std::swap(branch_node->right, new_child1);\n        std::swap(branch_node->left, new_child2);\n      } else {\n        std::swap(branch_node->right, new_child2);\n        std::swap(branch_node->left, new_child1);\n      }\n\n      return new_node;\n    }\n\n    //<! Traverse left branch depth-first\n    TreeNode *traverse_l()\n    {\n      TreeNode *tnode = this;\n\n      while (tnode->left)\n        tnode = tnode->left.get();\n      return tnode;\n    }\n\n    //<! Traverse tree depth-first and in-order (L-N-R)\n    TreeNode *traverse_lnr()\n    {\n      TreeNode *tnode = this;\n\n      // precondition: descended left as deep as possible\n      if (tnode->right) {\n        // descend right\n        tnode = tnode->right.get();\n        // descend left as deep as possible and return next node\n        return tnode->traverse_l();\n      }\n\n      // ascend to parent\n      while (tnode->parent != nullptr) {\n        TreeNode *prev_child = tnode;\n        tnode = tnode->parent;\n\n        // return this node, but only when we come from the left child branch\n        if (tnode->left && tnode->left.get() == prev_child)\n          return tnode;\n      }\n      return nullptr;\n    }\n\n    //<! Traverse only assigned nodes\n    TreeNode *traverse_lnr_assigned()\n    {\n      TreeNode *tnode = traverse_lnr();\n\n      while (tnode != nullptr && !tnode->assigned)\n        tnode = tnode->traverse_lnr();\n      return tnode;\n    }\n\n    unique_ptr<TreeNode> left;\n    unique_ptr<TreeNode> right;\n    TreeNode* parent;\n\n    node_type node;\n    bool assigned; //<! Whether this node is assigned-to by the application\n\n    int d_bits; //<! How many bits have been used so far\n  };\n\n  void cleanup_tree(TreeNode* node)\n  {\n    // only cleanup this node if it has no children and node not assigned\n    if (!(node->left || node->right || node->assigned)) {\n      // get parent node ptr\n      TreeNode* pparent = node->parent;\n      // delete this node\n      if (pparent) {\n        if (pparent->left.get() == node)\n          pparent->left.reset();\n        else\n          pparent->right.reset();\n        // now recurse up to the parent\n        cleanup_tree(pparent);\n      }\n    }\n  }\n\n  void copyTree(const NetmaskTree& rhs)\n  {\n    TreeNode *node;\n\n    node = rhs.d_root.get();\n    if (node != nullptr)\n      node = node->traverse_l();\n    while (node != nullptr) {\n      if (node->assigned)\n        insert(node->node.first).second = node->node.second;\n      node = node->traverse_lnr();\n    }\n  }\n\npublic:\n  class Iterator {\n  public:\n    typedef node_type value_type;\n    typedef node_type& reference;\n    typedef node_type* pointer;\n    typedef std::forward_iterator_tag iterator_category;\n    typedef size_type difference_type;\n\n  private:\n    friend class NetmaskTree;\n\n    const NetmaskTree* d_tree;\n    TreeNode* d_node;\n\n    Iterator(const NetmaskTree* tree, TreeNode* node): d_tree(tree), d_node(node) {\n    }\n\n  public:\n    Iterator(): d_tree(nullptr), d_node(nullptr) {}\n\n    Iterator& operator++() // prefix\n    {\n      if (d_node == nullptr) {\n        throw std::logic_error(\n          \"NetmaskTree::Iterator::operator++: iterator is invalid\");\n      }\n      d_node = d_node->traverse_lnr_assigned();\n      return *this;\n    }\n    Iterator operator++(int) // postfix\n    {\n      Iterator tmp(*this);\n      operator++();\n      return tmp;\n    }\n\n    reference operator*()\n    {\n      if (d_node == nullptr) {\n        throw std::logic_error(\n          \"NetmaskTree::Iterator::operator*: iterator is invalid\");\n      }\n      return d_node->node;\n    }\n\n    pointer operator->()\n    {\n      if (d_node == nullptr) {\n        throw std::logic_error(\n          \"NetmaskTree::Iterator::operator->: iterator is invalid\");\n      }\n      return &d_node->node;\n    }\n\n    bool operator==(const Iterator& rhs)\n    {\n      return (d_tree == rhs.d_tree && d_node == rhs.d_node);\n    }\n    bool operator!=(const Iterator& rhs)\n    {\n      return !(*this == rhs);\n    }\n  };\n\npublic:\n  NetmaskTree() noexcept: d_root(new TreeNode()), d_left(nullptr), d_size(0) {\n  }\n\n  NetmaskTree(const NetmaskTree& rhs): d_root(new TreeNode()), d_left(nullptr), d_size(0) {\n    copyTree(rhs);\n  }\n\n  NetmaskTree& operator=(const NetmaskTree& rhs) {\n    clear();\n    copyTree(rhs);\n    return *this;\n  }\n\n  const iterator begin() const {\n    return Iterator(this, d_left);\n  }\n  const iterator end() const {\n    return Iterator(this, nullptr);\n  }\n  iterator begin() {\n    return Iterator(this, d_left);\n  }\n  iterator end() {\n    return Iterator(this, nullptr);\n  }\n\n  node_type& insert(const string &mask) {\n    return insert(key_type(mask));\n  }\n\n  //<! Creates new value-pair in tree and returns it.\n  node_type& insert(const key_type& key) {\n    TreeNode* node;\n    bool is_left = true;\n\n    // we turn left on IPv4 and right on IPv6\n    if (key.isIPv4()) {\n      node = d_root->left.get();\n      if (node == nullptr) {\n        node = new TreeNode(key);\n        node->assigned = true;\n        node->parent = d_root.get();\n\n        d_root->left = unique_ptr<TreeNode>(node);\n        d_size++;\n        d_left = node;\n        return node->node;\n      }\n    } else if (key.isIPv6()) {\n      node = d_root->right.get();\n      if (node == nullptr) {\n        node = new TreeNode(key);\n        node->assigned = true;\n        node->parent = d_root.get();\n\n        d_root->right = unique_ptr<TreeNode>(node);\n        d_size++;\n        if (!d_root->left)\n          d_left = node;\n        return node->node;\n      }\n      if (d_root->left)\n        is_left = false;\n    } else\n      throw NetmaskException(\"invalid address family\");\n\n    // we turn left on 0 and right on 1\n    int bits = 0;\n    for(; bits < key.getBits(); bits++) {\n      bool vall = key.getBit(-1-bits);\n\n      if (bits >= node->d_bits) {\n        // the end of the current node is reached; continue with the next\n        if (vall) {\n          if (node->left || node->assigned)\n            is_left = false;\n          if (!node->right) {\n            // the right branch doesn't exist yet; attach our key here\n            node = node->make_right(key);\n            break;\n          }\n          node = node->right.get();\n        } else {\n          if (!node->left) {\n            // the left branch doesn't exist yet; attach our key here\n            node = node->make_left(key);\n            break;\n          }\n          node = node->left.get();\n        }\n        continue;\n      }\n      if (bits >= node->node.first.getBits()) {\n        // the matching branch ends here, yet the key netmask has more bits; add a\n        // child node below the existing branch leaf.\n        if (vall) {\n          if (node->assigned)\n            is_left = false;\n          node = node->make_right(key);\n        } else {\n          node = node->make_left(key);\n        }\n        break;\n      }\n      bool valr = node->node.first.getBit(-1-bits);\n      if (vall != valr) {\n        if (vall)\n          is_left = false;\n        // the branch matches just upto this point, yet continues in a different\n        // direction; fork the branch.\n        node = node->fork(key, bits);\n        break;\n      }\n    }\n\n    if (node->node.first.getBits() > key.getBits()) {\n      // key is a super-network of the matching node; split the branch and\n      // insert a node for the key above the matching node.\n      node = node->split(key, key.getBits());\n    }\n\n    if (node->left)\n      is_left = false;\n\n    node_type& value = node->node;\n\n    if (!node->assigned) {\n      // only increment size if not assigned before\n      d_size++;\n      // update the pointer to the left-most tree node\n      if (is_left)\n        d_left = node;\n      node->assigned = true;\n    } else {\n      // tree node exists for this value\n      if (is_left && d_left != node) {\n        throw std::logic_error(\n          \"NetmaskTree::insert(): lost track of left-most node in tree\");\n      }\n    }\n\n    return value;\n  }\n\n  //<! Creates or updates value\n  void insert_or_assign(const key_type& mask, const value_type& value) {\n    insert(mask).second = value;\n  }\n\n  void insert_or_assign(const string& mask, const value_type& value) {\n    insert(key_type(mask)).second = value;\n  }\n\n  //<! check if given key is present in TreeMap\n  bool has_key(const key_type& key) const {\n    const node_type *ptr = lookup(key);\n    return ptr && ptr->first == key;\n  }\n\n  //<! Returns \"best match\" for key_type, which might not be value\n  const node_type* lookup(const key_type& value) const {\n    return lookup(value.getNetwork(), value.getBits());\n  }\n\n  //<! Perform best match lookup for value, using at most max_bits\n  const node_type* lookup(const ComboAddress& value, int max_bits = 128) const {\n    TreeNode *node = nullptr;\n\n    uint8_t addr_bits = value.getBits();\n    if (max_bits < 0 || max_bits > addr_bits)\n      max_bits = addr_bits;\n\n    if (value.isIPv4())\n      node = d_root->left.get();\n    else if (value.isIPv6())\n      node = d_root->right.get();\n    else\n      throw NetmaskException(\"invalid address family\");\n    if (node == nullptr) return nullptr;\n\n    node_type *ret = nullptr;\n\n    int bits = 0;\n    for(; bits < max_bits; bits++) {\n      bool vall = value.getBit(-1-bits);\n      if (bits >= node->d_bits) {\n        // the end of the current node is reached; continue with the next\n        // (we keep track of last assigned node)\n        if (node->assigned && bits == node->node.first.getBits())\n          ret = &node->node;\n        if (vall) {\n          if (!node->right)\n            break;\n          node = node->right.get();\n        } else {\n          if (!node->left)\n            break;\n          node = node->left.get();\n        }\n        continue;\n      }\n      if (bits >= node->node.first.getBits()) {\n        // the matching branch ends here\n        break;\n      }\n      bool valr = node->node.first.getBit(-1-bits);\n      if (vall != valr) {\n        // the branch matches just upto this point, yet continues in a different\n        // direction\n        break;\n      }\n    }\n    // needed if we did not find one in loop\n    if (node->assigned && bits == node->node.first.getBits())\n      ret = &node->node;\n\n    // this can be nullptr.\n    return ret;\n  }\n\n  //<! Removes key from TreeMap.\n  void erase(const key_type& key) {\n    TreeNode *node = nullptr;\n\n    if (key.isIPv4())\n      node = d_root->left.get();\n    else if (key.isIPv6())\n      node = d_root->right.get();\n    else\n      throw NetmaskException(\"invalid address family\");\n    // no tree, no value\n    if (node == nullptr) return;\n\n    int bits = 0;\n    for(; node && bits < key.getBits(); bits++) {\n      bool vall = key.getBit(-1-bits);\n      if (bits >= node->d_bits) {\n        // the end of the current node is reached; continue with the next\n        if (vall) {\n          node = node->right.get();\n        } else {\n          node = node->left.get();\n        }\n        continue;\n      }\n      if (bits >= node->node.first.getBits()) {\n        // the matching branch ends here\n        if (key.getBits() != node->node.first.getBits())\n          node = nullptr;\n        break;\n      }\n      bool valr = node->node.first.getBit(-1-bits);\n      if (vall != valr) {\n        // the branch matches just upto this point, yet continues in a different\n        // direction\n        node = nullptr;\n        break;\n      }\n    }\n    if (node) {\n      if (d_size == 0) {\n        throw std::logic_error(\n          \"NetmaskTree::erase(): size of tree is zero before erase\");\n      }\n      d_size--;\n      node->assigned = false;\n      node->node.second = value_type();\n\n      if (node == d_left)\n        d_left = d_left->traverse_lnr_assigned();\n\n      cleanup_tree(node);\n    }\n  }\n\n  void erase(const string& key) {\n    erase(key_type(key));\n  }\n\n  //<! checks whether the container is empty.\n  bool empty() const {\n    return (d_size == 0);\n  }\n\n  //<! returns the number of elements\n  size_type size() const {\n    return d_size;\n  }\n\n  //<! See if given ComboAddress matches any prefix\n  bool match(const ComboAddress& value) const {\n    return (lookup(value) != nullptr);\n  }\n\n  bool match(const std::string& value) const {\n    return match(ComboAddress(value));\n  }\n\n  //<! Clean out the tree\n  void clear() {\n    d_root.reset(new TreeNode());\n    d_left = nullptr;\n    d_size = 0;\n  }\n\n  //<! swaps the contents with another NetmaskTree\n  void swap(NetmaskTree& rhs) {\n    std::swap(d_root, rhs.d_root);\n    std::swap(d_left, rhs.d_left);\n    std::swap(d_size, rhs.d_size);\n  }\n\nprivate:\n  unique_ptr<TreeNode> d_root; //<! Root of our tree\n  TreeNode *d_left;\n  size_type d_size;\n};\n\n/** This class represents a group of supplemental Netmask classes. An IP address matchs\n    if it is matched by zero or more of the Netmask classes within.\n*/\nclass NetmaskGroup\n{\npublic:\n  NetmaskGroup() noexcept {\n  }\n\n  //! If this IP address is matched by any of the classes within\n\n  bool match(const ComboAddress *ip) const\n  {\n    const auto &ret = tree.lookup(*ip);\n    if(ret) return ret->second;\n    return false;\n  }\n\n  bool match(const ComboAddress& ip) const\n  {\n    return match(&ip);\n  }\n\n  bool lookup(const ComboAddress* ip, Netmask* nmp) const\n  {\n    const auto &ret = tree.lookup(*ip);\n    if (ret) {\n      if (nmp != nullptr)\n        *nmp = ret->first;\n\n      return ret->second;\n    }\n    return false;\n  }\n\n  bool lookup(const ComboAddress& ip, Netmask* nmp) const\n  {\n    return lookup(&ip, nmp);\n  }\n\n  //! Add this string to the list of possible matches\n  void addMask(const string &ip, bool positive=true)\n  {\n    if(!ip.empty() && ip[0] == '!') {\n      addMask(Netmask(ip.substr(1)), false);\n    } else {\n      addMask(Netmask(ip), positive);\n    }\n  }\n\n  //! Add this Netmask to the list of possible matches\n  void addMask(const Netmask& nm, bool positive=true)\n  {\n    tree.insert(nm).second=positive;\n  }\n\n  //! Delete this Netmask from the list of possible matches\n  void deleteMask(const Netmask& nm)\n  {\n    tree.erase(nm);\n  }\n\n  void deleteMask(const std::string& ip)\n  {\n    if (!ip.empty())\n      deleteMask(Netmask(ip));\n  }\n\n  void clear()\n  {\n    tree.clear();\n  }\n\n  bool empty() const\n  {\n    return tree.empty();\n  }\n\n  size_t size() const\n  {\n    return tree.size();\n  }\n\n  string toString() const\n  {\n    ostringstream str;\n    for(auto iter = tree.begin(); iter != tree.end(); ++iter) {\n      if(iter != tree.begin())\n        str <<\", \";\n      if(!(iter->second))\n        str<<\"!\";\n      str<<iter->first.toString();\n    }\n    return str.str();\n  }\n\n  void toStringVector(vector<string>* vec) const\n  {\n    for(auto iter = tree.begin(); iter != tree.end(); ++iter) {\n      vec->push_back((iter->second ? \"\" : \"!\") + iter->first.toString());\n    }\n  }\n\n  void toMasks(const string &ips)\n  {\n    vector<string> parts;\n    stringtok(parts, ips, \", \\t\");\n\n    for (vector<string>::const_iterator iter = parts.begin(); iter != parts.end(); ++iter)\n      addMask(*iter);\n  }\n\nprivate:\n  NetmaskTree<bool> tree;\n};\n\nstruct SComboAddress\n{\n  SComboAddress(const ComboAddress& orig) : ca(orig) {}\n  ComboAddress ca;\n  bool operator<(const SComboAddress& rhs) const\n  {\n    return ComboAddress::addressOnlyLessThan()(ca, rhs.ca);\n  }\n  operator const ComboAddress&()\n  {\n    return ca;\n  }\n};\n\nclass NetworkError : public runtime_error\n{\npublic:\n  NetworkError(const string& why=\"Network Error\") : runtime_error(why.c_str())\n  {}\n  NetworkError(const char *why=\"Network Error\") : runtime_error(why)\n  {}\n};\n\nint SSocket(int family, int type, int flags);\nint SConnect(int sockfd, const ComboAddress& remote);\n/* tries to connect to remote for a maximum of timeout seconds.\n   sockfd should be set to non-blocking beforehand.\n   returns 0 on success (the socket is writable), throw a\n   runtime_error otherwise */\nint SConnectWithTimeout(int sockfd, const ComboAddress& remote, int timeout);\nint SBind(int sockfd, const ComboAddress& local);\nint SAccept(int sockfd, ComboAddress& remote);\nint SListen(int sockfd, int limit);\nint SSetsockopt(int sockfd, int level, int opname, int value);\nvoid setSocketIgnorePMTU(int sockfd);\nbool setReusePort(int sockfd);\n\n#if defined(IP_PKTINFO)\n  #define GEN_IP_PKTINFO IP_PKTINFO\n#elif defined(IP_RECVDSTADDR)\n  #define GEN_IP_PKTINFO IP_RECVDSTADDR\n#endif\n\nbool IsAnyAddress(const ComboAddress& addr);\nbool HarvestDestinationAddress(const struct msghdr* msgh, ComboAddress* destination);\nbool HarvestTimestamp(struct msghdr* msgh, struct timeval* tv);\nvoid fillMSGHdr(struct msghdr* msgh, struct iovec* iov, cmsgbuf_aligned* cbuf, size_t cbufsize, char* data, size_t datalen, ComboAddress* addr);\nssize_t sendfromto(int sock, const char* data, size_t len, int flags, const ComboAddress& from, const ComboAddress& to);\nsize_t sendMsgWithOptions(int fd, const char* buffer, size_t len, const ComboAddress* dest, const ComboAddress* local, unsigned int localItf, int flags);\n\n/* requires a non-blocking, connected TCP socket */\nbool isTCPSocketUsable(int sock);\n\nextern template class NetmaskTree<bool>;\n"}, "21": {"id": 21, "path": "/home/runner/work/testcc/testcc/retdec/pdns/ueberbackend.hh", "content": "/*\n * This file is part of PowerDNS or dnsdist.\n * Copyright -- PowerDNS.COM B.V. and its contributors\n *\n * This program is free software; you can redistribute it and/or modify\n * it under the terms of version 2 of the GNU General Public License as\n * published by the Free Software Foundation.\n *\n * In addition, for the avoidance of any doubt, permission is granted to\n * link this program with OpenSSL and to (re)distribute the binaries\n * produced as the result of such linking.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with this program; if not, write to the Free Software\n * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.\n */\n#pragma once\n#include <vector>\n#include <map>\n#include <string>\n#include <algorithm>\n#include <mutex>\n#include <condition_variable>\n\n#include <boost/utility.hpp>\n\n#include \"dnspacket.hh\"\n#include \"dnsbackend.hh\"\n#include \"namespaces.hh\"\n\n/** This is a very magic backend that allows us to load modules dynamically,\n    and query them in order. This is persistent over all UeberBackend instantiations\n    across multiple threads. \n\n    The UeberBackend is transparent for exceptions, which should fall straight through.\n*/\n\nclass UeberBackend : public boost::noncopyable\n{\npublic:\n  UeberBackend(const string &pname=\"default\");\n  ~UeberBackend();\n\n  bool superMasterBackend(const string &ip, const DNSName &domain, const vector<DNSResourceRecord>&nsset, string *nameserver, string *account, DNSBackend **db);\n\n  bool superMasterAdd(const string &ip, const string &nameserver, const string &account); \n\n  /** Tracks all created UeberBackend instances for us. We use this vector to notify\n      existing threads of new modules \n  */\n  static vector<UeberBackend *>instances;\n  static std::mutex instances_lock;\n\n  static bool loadmodule(const string &name);\n  static bool loadModules(const vector<string>& modules, const string& path);\n\n  static void go(void);\n\n  /** This contains all registered backends. The DynListener modifies this list for us when\n      new modules are loaded */\n  vector<DNSBackend*> backends; \n\n  void cleanup();\n\n  //! the very magic handle for UeberBackend questions\n  class handle\n  {\n  public:\n    bool get(DNSZoneRecord &dr);\n    handle();\n    ~handle();\n\n    //! The UeberBackend class where this handle belongs to\n    UeberBackend *parent;\n    //! The current real backend, which is answering questions\n    DNSBackend *d_hinterBackend;\n\n    //! DNSPacket who asked this question\n    DNSPacket* pkt_p;\n    DNSName qname;\n\n    //! Index of the current backend within the backends vector\n    unsigned int i;\n    QType qtype;\n\n  private:\n\n    static AtomicCounter instances;\n  };\n\n  void lookup(const QType &, const DNSName &qdomain, int zoneId, DNSPacket *pkt_p=nullptr);\n\n  /** Determines if we are authoritative for a zone, and at what level */\n  bool getAuth(const DNSName &target, const QType &qtype, SOAData* sd, bool cachedOk=true);\n  bool getSOA(const DNSName &domain, SOAData &sd);\n  /** Load SOA info from backends, ignoring the cache.*/\n  bool getSOAUncached(const DNSName &domain, SOAData &sd);\n  bool get(DNSZoneRecord &r);\n  void getAllDomains(vector<DomainInfo> *domains, bool include_disabled=false);\n\n  void getUnfreshSlaveInfos(vector<DomainInfo>* domains);\n  void getUpdatedMasters(vector<DomainInfo>* domains);\n  bool getDomainInfo(const DNSName &domain, DomainInfo &di, bool getSerial=true);\n  bool createDomain(const DNSName &domain, const DomainInfo::DomainKind kind, const vector<ComboAddress> &masters, const string &account);\n  \n  bool doesDNSSEC();\n  bool addDomainKey(const DNSName& name, const DNSBackend::KeyData& key, int64_t& id);\n  bool getDomainKeys(const DNSName& name, std::vector<DNSBackend::KeyData>& keys);\n  bool getAllDomainMetadata(const DNSName& name, std::map<std::string, std::vector<std::string> >& meta);\n  bool getDomainMetadata(const DNSName& name, const std::string& kind, std::vector<std::string>& meta);\n  bool setDomainMetadata(const DNSName& name, const std::string& kind, const std::vector<std::string>& meta);\n\n  bool removeDomainKey(const DNSName& name, unsigned int id);\n  bool activateDomainKey(const DNSName& name, unsigned int id);\n  bool deactivateDomainKey(const DNSName& name, unsigned int id);\n  bool publishDomainKey(const DNSName& name, unsigned int id);\n  bool unpublishDomainKey(const DNSName& name, unsigned int id);\n\n  bool getTSIGKey(const DNSName& name, DNSName* algorithm, string* content);\n  bool setTSIGKey(const DNSName& name, const DNSName& algorithm, const string& content);\n  bool deleteTSIGKey(const DNSName& name);\n  bool getTSIGKeys(std::vector< struct TSIGKey > &keys);\n\n  void alsoNotifies(const DNSName &domain, set<string> *ips); \n  void rediscover(string* status=0);\n  void reload();\n  bool searchRecords(const string &pattern, int maxResults, vector<DNSResourceRecord>& result);\n  bool searchComments(const string &pattern, int maxResults, vector<Comment>& result);\nprivate:\n  handle d_handle;\n  vector<DNSZoneRecord> d_answers;\n  vector<DNSZoneRecord>::const_iterator d_cachehandleiter;\n\n  static std::mutex d_mut;\n  static std::condition_variable d_cond;\n\n  struct Question\n  {\n    DNSName qname;\n    int zoneId;\n    QType qtype;\n  }d_question;\n\n  unsigned int d_cache_ttl, d_negcache_ttl;\n  int d_domain_id;\n  int d_ancount;\n\n  bool d_negcached;\n  bool d_cached;\n  static bool d_go;\n  bool d_stale;\n\n  int cacheHas(const Question &q, vector<DNSZoneRecord> &rrs);\n  void addNegCache(const Question &q);\n  void addCache(const Question &q, vector<DNSZoneRecord>&& rrs);\n  \n};\n"}, "22": {"id": 22, "path": "/home/runner/work/testcc/testcc/retdec/pdns/dnsparser.hh", "content": "/*\n * This file is part of PowerDNS or dnsdist.\n * Copyright -- PowerDNS.COM B.V. and its contributors\n *\n * This program is free software; you can redistribute it and/or modify\n * it under the terms of version 2 of the GNU General Public License as\n * published by the Free Software Foundation.\n *\n * In addition, for the avoidance of any doubt, permission is granted to\n * link this program with OpenSSL and to (re)distribute the binaries\n * produced as the result of such linking.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with this program; if not, write to the Free Software\n * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.\n */\n#pragma once\n#include <map>\n#include <sstream>\n#include <stdexcept>\n#include <iostream>\n#include <vector>\n#include <errno.h>\n// #include <netinet/in.h>\n#include \"misc.hh\"\n\n#include <boost/tuple/tuple.hpp>\n#include <boost/tuple/tuple_comparison.hpp>\n#include \"dns.hh\"\n#include \"dnswriter.hh\"\n#include \"dnsname.hh\"\n#include \"pdnsexception.hh\"\n#include \"iputils.hh\"\n\n/** DNS records have three representations:\n    1) in the packet\n    2) parsed in a class, ready for use\n    3) in the zone\n\n    We should implement bidirectional transitions between 1&2 and 2&3.\n    Currently we have: 1 -> 2\n                       2 -> 3\n\n    We can add:        2 -> 1  easily by reversing the packetwriter\n    And we might be able to reverse 2 -> 3 as well\n*/\n    \n#include \"namespaces.hh\"\n#include \"namespaces.hh\"\n\nclass MOADNSException : public runtime_error\n{\npublic:\n  MOADNSException(const string& str) : runtime_error(str)\n  {}\n};\n\n\nclass MOADNSParser;\n\nclass PacketReader\n{\npublic:\n  PacketReader(const std::string& content, uint16_t initialPos=sizeof(dnsheader))\n    : d_pos(initialPos), d_startrecordpos(initialPos), d_content(content)\n  {\n    if(content.size() > std::numeric_limits<uint16_t>::max())\n      throw std::out_of_range(\"packet too large\");\n\n    d_recordlen = (uint16_t) content.size();\n    not_used = 0;\n  }\n\n  uint32_t get32BitInt();\n  uint16_t get16BitInt();\n  uint8_t get8BitInt();\n  \n  void xfr48BitInt(uint64_t& val);\n\n  void xfr32BitInt(uint32_t& val)\n  {\n    val=get32BitInt();\n  }\n\n  void xfrIP(uint32_t& val)\n  {\n    xfr32BitInt(val);\n    val=htonl(val);\n  }\n\n  void xfrIP6(std::string &val) {\n    xfrBlob(val, 16);\n  }\n\n  void xfrCAWithoutPort(uint8_t version, ComboAddress &val) {\n    string blob;\n    if (version == 4) xfrBlob(blob, 4);\n    else if (version == 6) xfrBlob(blob, 16);\n    else throw runtime_error(\"invalid IP protocol\");\n    val = makeComboAddressFromRaw(version, blob);\n  }\n\n  void xfrCAPort(ComboAddress &val) {\n    uint16_t port;\n    xfr16BitInt(port);\n    val.sin4.sin_port = port;\n  }\n\n  void xfrTime(uint32_t& val)\n  {\n    xfr32BitInt(val);\n  }\n\n\n  void xfr16BitInt(uint16_t& val)\n  {\n    val=get16BitInt();\n  }\n\n  void xfrType(uint16_t& val)\n  {\n    xfr16BitInt(val);\n  }\n\n\n  void xfr8BitInt(uint8_t& val)\n  {\n    val=get8BitInt();\n  }\n\n\n  void xfrName(DNSName &name, bool compress=false, bool noDot=false)\n  {\n    name=getName();\n  }\n\n  void xfrText(string &text, bool multi=false, bool lenField=true)\n  {\n    text=getText(multi, lenField);\n  }\n\n  void xfrUnquotedText(string &text, bool lenField){\n    text=getUnquotedText(lenField);\n  }\n\n  void xfrBlob(string& blob);\n  void xfrBlobNoSpaces(string& blob, int len);\n  void xfrBlob(string& blob, int length);\n  void xfrHexBlob(string& blob, bool keepReading=false);\n\n  void getDnsrecordheader(struct dnsrecordheader &ah);\n  void copyRecord(vector<unsigned char>& dest, uint16_t len);\n  void copyRecord(unsigned char* dest, uint16_t len);\n\n  DNSName getName();\n  string getText(bool multi, bool lenField);\n  string getUnquotedText(bool lenField);\n\n\n  bool eof() { return true; };\n  const string getRemaining() const {\n    return \"\";\n  };\n\n  uint16_t getPosition() const\n  {\n    return d_pos;\n  }\n\n  void skip(uint16_t n)\n  {\n    d_pos += n;\n  }\n\nprivate:\n  uint16_t d_pos;\n  uint16_t d_startrecordpos; // needed for getBlob later on\n  uint16_t d_recordlen;      // ditto\n  uint16_t not_used; // Aligns the whole class on 8-byte boundaries\n  const std::string& d_content;\n};\n\nstruct DNSRecord;\n\nclass DNSRecordContent\n{\npublic:\n  static std::shared_ptr<DNSRecordContent> mastermake(const DNSRecord &dr, PacketReader& pr);\n  static std::shared_ptr<DNSRecordContent> mastermake(const DNSRecord &dr, PacketReader& pr, uint16_t opcode);\n  static std::shared_ptr<DNSRecordContent> mastermake(uint16_t qtype, uint16_t qclass, const string& zone);\n\n  virtual std::string getZoneRepresentation(bool noDot=false) const = 0;\n  virtual ~DNSRecordContent() {}\n  virtual void toPacket(DNSPacketWriter& pw)=0;\n  virtual string serialize(const DNSName& qname, bool canonic=false, bool lowerCase=false) // it would rock if this were const, but it is too hard\n  {\n    vector<uint8_t> packet;\n    DNSPacketWriter pw(packet, g_rootdnsname, 1);\n    if(canonic)\n      pw.setCanonic(true);\n\n    if(lowerCase)\n      pw.setLowercase(true);\n\n    pw.startRecord(qname, this->getType());\n    this->toPacket(pw);\n    \n    string record;\n    pw.getRecordPayload(record); // needs to be called before commit()\n    return record;\n  }\n\n  virtual bool operator==(const DNSRecordContent& rhs) const\n  {\n    return typeid(*this)==typeid(rhs) && this->getZoneRepresentation() == rhs.getZoneRepresentation();\n  }\n  \n  static shared_ptr<DNSRecordContent> deserialize(const DNSName& qname, uint16_t qtype, const string& serialized);\n\n  void doRecordCheck(const struct DNSRecord&){}\n\n  typedef std::shared_ptr<DNSRecordContent> makerfunc_t(const struct DNSRecord& dr, PacketReader& pr);\n  typedef std::shared_ptr<DNSRecordContent> zmakerfunc_t(const string& str);\n\n  static void regist(uint16_t cl, uint16_t ty, makerfunc_t* f, zmakerfunc_t* z, const char* name)\n  {\n    if(f)\n      getTypemap()[make_pair(cl,ty)]=f;\n    if(z)\n      getZmakermap()[make_pair(cl,ty)]=z;\n\n    getT2Namemap().insert(make_pair(make_pair(cl,ty), name));\n    getN2Typemap().insert(make_pair(name, make_pair(cl,ty)));\n  }\n\n  static void unregist(uint16_t cl, uint16_t ty) \n  {\n    pair<uint16_t, uint16_t> key=make_pair(cl, ty);\n    getTypemap().erase(key);\n    getZmakermap().erase(key);\n  }\n\n  static uint16_t TypeToNumber(const string& name)\n  {\n    n2typemap_t::const_iterator iter = getN2Typemap().find(toUpper(name));\n    if(iter != getN2Typemap().end())\n      return iter->second.second;\n    \n    if(boost::starts_with(name, \"TYPE\") || boost::starts_with(name, \"type\"))\n      return (uint16_t) pdns_stou(name.substr(4));\n    \n    throw runtime_error(\"Unknown DNS type '\"+name+\"'\");\n  }\n\n  static const string NumberToType(uint16_t num, uint16_t classnum=1)\n  {\n    t2namemap_t::const_iterator iter = getT2Namemap().find(make_pair(classnum, num));\n    if(iter == getT2Namemap().end()) \n      return \"TYPE\" + std::to_string(num);\n      //      throw runtime_error(\"Unknown DNS type with numerical id \"+std::to_string(num));\n    return iter->second;\n  }\n\n  virtual uint16_t getType() const = 0;\n\nprotected:\n  typedef std::map<std::pair<uint16_t, uint16_t>, makerfunc_t* > typemap_t;\n  typedef std::map<std::pair<uint16_t, uint16_t>, zmakerfunc_t* > zmakermap_t;\n  typedef std::map<std::pair<uint16_t, uint16_t>, string > t2namemap_t;\n  typedef std::map<string, std::pair<uint16_t, uint16_t> > n2typemap_t;\n  static typemap_t& getTypemap();\n  static t2namemap_t& getT2Namemap();\n  static n2typemap_t& getN2Typemap();\n  static zmakermap_t& getZmakermap();\n};\n\nstruct DNSRecord\n{\n  DNSRecord() : d_type(0), d_class(QClass::IN), d_ttl(0), d_clen(0), d_place(DNSResourceRecord::ANSWER)\n  {}\n  explicit DNSRecord(const DNSResourceRecord& rr);\n  DNSName d_name;\n  std::shared_ptr<DNSRecordContent> d_content;\n  uint16_t d_type;\n  uint16_t d_class;\n  uint32_t d_ttl;\n  uint16_t d_clen;\n  DNSResourceRecord::Place d_place;\n\n  bool operator<(const DNSRecord& rhs) const\n  {\n    if(tie(d_name, d_type, d_class, d_ttl) < tie(rhs.d_name, rhs.d_type, rhs.d_class, rhs.d_ttl))\n      return true;\n    \n    if(tie(d_name, d_type, d_class, d_ttl) != tie(rhs.d_name, rhs.d_type, rhs.d_class, rhs.d_ttl))\n      return false;\n    \n    string lzrp, rzrp;\n    if(d_content)\n      lzrp=toLower(d_content->getZoneRepresentation());\n    if(rhs.d_content)\n      rzrp=toLower(rhs.d_content->getZoneRepresentation());\n    \n    return lzrp < rzrp;\n  }\n\n  // this orders in canonical order and keeps the SOA record on top\n  static bool prettyCompare(const DNSRecord& a, const DNSRecord& b) \n  {\n    auto aType = (a.d_type == QType::SOA) ? 0 : a.d_type; \n    auto bType = (b.d_type == QType::SOA) ? 0 : b.d_type; \n\n    if(a.d_name.canonCompare(b.d_name))\n      return true;\n    if(b.d_name.canonCompare(a.d_name))\n      return false;\n\n    if(tie(aType, a.d_class, a.d_ttl) < tie(bType, b.d_class, b.d_ttl))\n      return true;\n    \n    if(tie(aType, a.d_class, a.d_ttl) != tie(bType, b.d_class, b.d_ttl))\n      return false;\n    \n    string lzrp, rzrp;\n    if(a.d_content)\n      lzrp=toLower(a.d_content->getZoneRepresentation());\n    if(b.d_content)\n      rzrp=toLower(b.d_content->getZoneRepresentation());\n    \n    return lzrp < rzrp;\n  }\n\n\n  bool operator==(const DNSRecord& rhs) const\n  {\n    if(d_type != rhs.d_type || d_class != rhs.d_class || d_name != rhs.d_name)\n      return false;\n    \n    return *d_content == *rhs.d_content;\n  }\n};\n\nstruct DNSZoneRecord\n{\n  int domain_id{-1};\n  uint8_t scopeMask{0};\n  int signttl{0};\n  DNSName wildcardname;\n  bool auth{true};\n  DNSRecord dr;\n};\n\n\n//! This class can be used to parse incoming packets, and is copyable\nclass MOADNSParser : public boost::noncopyable\n{\npublic:\n  //! Parse from a string\n  MOADNSParser(bool query, const string& buffer): d_tsigPos(0)\n  {\n    init(query, buffer);\n  }\n\n  //! Parse from a pointer and length\n  MOADNSParser(bool query, const char *packet, unsigned int len) : d_tsigPos(0)\n  {\n    init(query, std::string(packet, len));\n  }\n\n  DNSName d_qname;\n  uint16_t d_qclass, d_qtype;\n  //uint8_t d_rcode;\n  dnsheader d_header;\n\n  typedef vector<pair<DNSRecord, uint16_t > > answers_t;\n  \n  //! All answers contained in this packet (everything *but* the question section)\n  answers_t d_answers;\n\n  uint16_t getTSIGPos() const\n  {\n    return d_tsigPos;\n  }\nprivate:\n  void init(bool query, const std::string& packet);\n  uint16_t d_tsigPos;\n};\n\nstring simpleCompress(const string& label, const string& root=\"\");\nvoid ageDNSPacket(char* packet, size_t length, uint32_t seconds);\nvoid ageDNSPacket(std::string& packet, uint32_t seconds);\nvoid editDNSPacketTTL(char* packet, size_t length, std::function<uint32_t(uint8_t, uint16_t, uint16_t, uint32_t)> visitor);\nuint32_t getDNSPacketMinTTL(const char* packet, size_t length, bool* seenAuthSOA=nullptr);\nuint32_t getDNSPacketLength(const char* packet, size_t length);\nuint16_t getRecordsOfTypeCount(const char* packet, size_t length, uint8_t section, uint16_t type);\nbool getEDNSUDPPayloadSizeAndZ(const char* packet, size_t length, uint16_t* payloadSize, uint16_t* z);\n\ntemplate<typename T>\nstd::shared_ptr<T> getRR(const DNSRecord& dr)\n{\n  return std::dynamic_pointer_cast<T>(dr.d_content);\n}\n\n/** Simple DNSPacketMangler. Ritual is: get a pointer into the packet and moveOffset() to beyond your needs\n *  If you survive that, feel free to read from the pointer */\nclass DNSPacketMangler\n{\npublic:\n  explicit DNSPacketMangler(std::string& packet)\n    : d_packet((char*) packet.c_str()), d_length(packet.length()), d_notyouroffset(12), d_offset(d_notyouroffset)\n  {}\n  DNSPacketMangler(char* packet, size_t length)\n    : d_packet(packet), d_length(length), d_notyouroffset(12), d_offset(d_notyouroffset)\n  {}\n\n  /*! Advances past a wire-format domain name\n   * The name is not checked for adherence to length restrictions.\n   * Compression pointers are not followed.\n   */\n  void skipDomainName()\n  {\n    uint8_t len;\n    while((len=get8BitInt())) {\n      if(len >= 0xc0) { // extended label\n        get8BitInt();\n        return;\n      }\n      skipBytes(len);\n    }\n  }\n\n  void skipBytes(uint16_t bytes)\n  {\n    moveOffset(bytes);\n  }\n  void rewindBytes(uint16_t by)\n  {\n    rewindOffset(by);\n  }\n  uint32_t get32BitInt()\n  {\n    const char* p = d_packet + d_offset;\n    moveOffset(4);\n    uint32_t ret;\n    memcpy(&ret, (void*)p, sizeof(ret));\n    return ntohl(ret);\n  }\n  uint16_t get16BitInt()\n  {\n    const char* p = d_packet + d_offset;\n    moveOffset(2);\n    uint16_t ret;\n    memcpy(&ret, (void*)p, sizeof(ret));\n    return ntohs(ret);\n  }\n\n  uint8_t get8BitInt()\n  {\n    const char* p = d_packet + d_offset;\n    moveOffset(1);\n    return *p;\n  }\n\n  void skipRData()\n  {\n    int toskip = get16BitInt();\n    moveOffset(toskip);\n  }\n\n  void decreaseAndSkip32BitInt(uint32_t decrease)\n  {\n    const char *p = d_packet + d_offset;\n    moveOffset(4);\n\n    uint32_t tmp;\n    memcpy(&tmp, (void*) p, sizeof(tmp));\n    tmp = ntohl(tmp);\n    tmp-=decrease;\n    tmp = htonl(tmp);\n    memcpy(d_packet + d_offset-4, (const char*)&tmp, sizeof(tmp));\n  }\n\n  void setAndSkip32BitInt(uint32_t value)\n  {\n    moveOffset(4);\n\n    value = htonl(value);\n    memcpy(d_packet + d_offset-4, (const char*)&value, sizeof(value));\n  }\n\n  uint32_t getOffset() const\n  {\n    return d_offset;\n  }\n\nprivate:\n  void moveOffset(uint16_t by)\n  {\n    d_notyouroffset += by;\n    if(d_notyouroffset > d_length)\n      throw std::out_of_range(\"dns packet out of range: \"+std::to_string(d_notyouroffset) +\" > \"\n      + std::to_string(d_length) );\n  }\n\n  void rewindOffset(uint16_t by)\n  {\n    if(d_notyouroffset < by)\n      throw std::out_of_range(\"Rewinding dns packet out of range: \"+std::to_string(d_notyouroffset) +\" < \"\n                              + std::to_string(by));\n    d_notyouroffset -= by;\n    if(d_notyouroffset < 12)\n      throw std::out_of_range(\"Rewinding dns packet out of range: \"+std::to_string(d_notyouroffset) +\" < \"\n                              + std::to_string(12));\n  }\n\n  char* d_packet;\n  size_t d_length;\n\n  uint32_t d_notyouroffset;  // only 'moveOffset' can touch this\n  const uint32_t&  d_offset; // look.. but don't touch\n};\n"}, "8": {"id": 8, "path": "/home/runner/work/testcc/testcc/retdec/pdns/arguments.hh", "content": "/*\n * This file is part of PowerDNS or dnsdist.\n * Copyright -- PowerDNS.COM B.V. and its contributors\n *\n * This program is free software; you can redistribute it and/or modify\n * it under the terms of version 2 of the GNU General Public License as\n * published by the Free Software Foundation.\n *\n * In addition, for the avoidance of any doubt, permission is granted to\n * link this program with OpenSSL and to (re)distribute the binaries\n * produced as the result of such linking.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with this program; if not, write to the Free Software\n * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.\n */\n#pragma once\n#include <map>\n#include <set>\n#include <string>\n#include <vector>\n#include <fstream>\n#include <iostream>\n#include \"misc.hh\"\n#include \"pdnsexception.hh\"\n#include <sys/types.h>\n#include <pwd.h>\n#include <grp.h>\n\n#include \"namespaces.hh\"\n\ntypedef PDNSException ArgException;\n\n/** This class helps parsing argc and argv into a map of parameters. We have 3 kinds of formats:\n\n\n    -w           this leads to a key/value pair of \"w\"/void\n\n    --port=25    \"port\"/\"25\"\n\n    --daemon     \"daemon\"/void\n\n    We do not support \"--port 25\" syntax.\n\n    It can also read from a file. This file can contain '#' to delimit comments.\n\n    Some sample code:\n\n    \\code\n\n    ArgvMap R;\n  \n    R.set(\"port\")=\"25\";  // use this to specify default parameters\n    R.file(\"./default.conf\"); // parse configuration file\n    \n    R.parse(argc, argv); // read the arguments from main()\n    \n    cout<<\"Will we be a daemon?: \"<<R.isset(\"daemon\")<<endl;\n    cout<<\"Our port will be \"<<R[\"port\"]<<endl;\n    \n    map<string,string>::const_iterator i;\n    cout<<\"via iterator\"<<endl;\n    for(i=R.begin();i!=R.end();i++)\n    cout<<i->first<<\"=\"<<i->second<<endl;\n    \\endcode\n*/\n\n\n\nclass ArgvMap\n{\npublic:\n  ArgvMap();\n  void parse(int &argc, char **argv, bool lax=false); //!< use this to parse from argc and argv\n  void laxParse(int &argc, char **argv) //!< use this to parse from argc and argv\n  {\n    parse(argc,argv,true);\n  }\n  void preParse(int &argc, char **argv, const string &arg); //!< use this to preparse a single var\n  bool preParseFile(const char *fname, const string &arg, const string& theDefault=\"\"); //!< use this to preparse a single var in configuration\n\n  bool file(const char *fname, bool lax=false); //!< Parses a file with parameters\n  bool file(const char *fname, bool lax, bool included); \n  bool laxFile(const char *fname) \n  {\n    return file(fname,true);\n  }\n  bool parseFile(const char *fname, const string& arg, bool lax); //<! parse one line\n  typedef map<string,string> param_t; //!< use this if you need to know the content of the map\n  bool parmIsset(const string &var); //!< Checks if a parameter is set to *a* value\n  bool mustDo(const string &var); //!< if a switch is given, if we must do something (--help)\n  int asNum(const string &var, int def=0); //!< return a variable value as a number or the default if the variable is empty\n  mode_t asMode(const string &var); //!< return value interpreted as octal number\n  uid_t asUid(const string &var); //!< return user id, resolves if necessary\n  gid_t asGid(const string &var); //!< return group id, resolves if necessary\n  double asDouble(const string &var); //!< return a variable value as a number\n  string &set(const string &); //!< Gives a writable reference and allocates space for it\n  string &set(const string &, const string &); //!< Does the same but also allows one to specify a help message\n  void setCmd(const string &, const string &); //!< Add a command flag\n  string &setSwitch(const string &, const string &); //!< Add a switch flag\n  string helpstring(string prefix=\"\"); //!< generates the --help\n  string configstring(bool current, bool full); //!< generates the --config\n  bool contains(const string &var, const string &val);\n  bool isEmpty(const string &var); //!< checks if variable has value\n  void setDefault(const string &var, const string &value);\n  void setDefaults();\n\n  vector<string>list();\n  string getHelp(const string &item);\n\n  const param_t::const_iterator begin(); //!< iterator semantics\n  const param_t::const_iterator end(); //!< iterator semantics\n  const string &operator[](const string &); //!< iterator semantics\n  const vector<string>&getCommands();\n  void gatherIncludes(std::vector<std::string> &extraConfigs);\nprivate:\n  void parseOne(const string &unparsed, const string &parseOnly=\"\", bool lax=false);\n  typedef map<string,string> params_t;\n  params_t params;\n  map<string,string> helpmap;\n  map<string,string> defaultmap;\n  map<string,string> d_typeMap;\n  vector<string> d_cmds;\n  std::set<string> d_cleared;\n};\n\nextern ArgvMap &arg();\n"}, "23": {"id": 23, "path": "/home/runner/work/testcc/testcc/retdec/pdns/dns.hh", "content": "/*\n * This file is part of PowerDNS or dnsdist.\n * Copyright -- PowerDNS.COM B.V. and its contributors\n *\n * This program is free software; you can redistribute it and/or modify\n * it under the terms of version 2 of the GNU General Public License as\n * published by the Free Software Foundation.\n *\n * In addition, for the avoidance of any doubt, permission is granted to\n * link this program with OpenSSL and to (re)distribute the binaries\n * produced as the result of such linking.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with this program; if not, write to the Free Software\n * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.\n */\n#pragma once\n#include <boost/multi_index_container.hpp>\n#include <boost/multi_index/ordered_index.hpp>\n#include <boost/tuple/tuple_comparison.hpp>\n#include <boost/multi_index/key_extractors.hpp>\n#include <boost/multi_index/sequenced_index.hpp>\n#include \"qtype.hh\"\n#include \"dnsname.hh\"\n#include <time.h>\n#include <sys/types.h>\n\n#undef BADSIG  // signal.h SIG_ERR\n\nclass DNSBackend;\nstruct DNSRecord;\n\nstruct SOAData\n{\n  SOAData() : ttl(0), serial(0), refresh(0), retry(0), expire(0), minimum(0), db(0), domain_id(-1) {};\n\n  DNSName qname;\n  DNSName nameserver;\n  DNSName hostmaster;\n  uint32_t ttl;\n  uint32_t serial;\n  uint32_t refresh;\n  uint32_t retry;\n  uint32_t expire;\n  uint32_t minimum;\n  DNSBackend *db;\n  int domain_id;\n\n  uint32_t getNegativeTTL() const { return min(ttl, minimum); }\n};\n\nclass RCode\n{\npublic:\n  enum rcodes_ { NoError=0, FormErr=1, ServFail=2, NXDomain=3, NotImp=4, Refused=5, YXDomain=6, YXRRSet=7, NXRRSet=8, NotAuth=9, NotZone=10};\n  static std::string to_s(uint8_t rcode);\n  static std::vector<std::string> rcodes_s;\n};\n\nclass ERCode\n{\npublic:\n  enum rcodes_ { BADVERS=16, BADSIG=16, BADKEY=17, BADTIME=18, BADMODE=19, BADNAME=20, BADALG=21, BADTRUNC=22, BADCOOKIE=23 };\n  static std::string to_s(uint8_t rcode);\n};\n\nclass Opcode\n{\npublic:\n  enum { Query=0, IQuery=1, Status=2, Notify=4, Update=5 };\n  static std::string to_s(uint8_t opcode);\n};\n\n// enum for policy decisions, used by both auth and recursor. Not all values supported everywhere.\nnamespace PolicyDecision { enum returnTypes { PASS=-1, DROP=-2, TRUNCATE=-3 }; };\n\n//! This class represents a resource record\nclass DNSResourceRecord\n{\npublic:\n  DNSResourceRecord() : last_modified(0), ttl(0), signttl(0), domain_id(-1), qclass(1), scopeMask(0), auth(1), disabled(0) {};\n  static DNSResourceRecord fromWire(const DNSRecord& d);\n\n  enum Place : uint8_t {QUESTION=0, ANSWER=1, AUTHORITY=2, ADDITIONAL=3}; //!< Type describing the positioning within, say, a DNSPacket\n\n  void setContent(const string& content);\n  string getZoneRepresentation(bool noDot=false) const;\n\n  // data\n  DNSName qname; //!< the name of this record, for example: www.powerdns.com\n  DNSName wildcardname;\n  string content; //!< what this record points to. Example: 10.1.2.3\n\n  // Aligned on 8-byte boundaries on systems where time_t is 8 bytes and int\n  // is 4 bytes, aka modern linux on x86_64\n  time_t last_modified; //!< For autocalculating SOA serial numbers - the backend needs to fill this in\n\n  uint32_t ttl; //!< Time To Live of this record\n  uint32_t signttl; //!< If non-zero, use this TTL as original TTL in the RRSIG\n\n  int domain_id; //!< If a backend implements this, the domain_id of the zone this record is in\n  QType qtype; //!< qtype of this record, ie A, CNAME, MX etc\n  uint16_t qclass; //!< class of this record\n\n  uint8_t scopeMask;\n  bool auth;\n  bool disabled;\n\n  bool operator==(const DNSResourceRecord& rhs);\n\n  bool operator<(const DNSResourceRecord &b) const\n  {\n    if(qname < b.qname)\n      return true;\n    if(qname == b.qname)\n      return(content < b.content);\n    return false;\n  }\n};\n\n#define GCCPACKATTRIBUTE __attribute__((packed))\n\nstruct dnsrecordheader\n{\n  uint16_t d_type;\n  uint16_t d_class;\n  uint32_t d_ttl;\n  uint16_t d_clen;\n} GCCPACKATTRIBUTE;\n\nstruct EDNS0Record\n{\n  uint8_t extRCode, version;\n  uint16_t extFlags;\n} GCCPACKATTRIBUTE;\n\nstatic_assert(sizeof(EDNS0Record) == 4, \"EDNS0Record size must be 4\");\n\n#if defined(__FreeBSD__) || defined(__APPLE__) || defined(__OpenBSD__) || defined(__DragonFly__) || defined(__FreeBSD_kernel__) || defined(__NetBSD__)\n#include <machine/endian.h>\n#elif __linux__ || __GNU__\n# include <endian.h>\n\n#else  // with thanks to <arpa/nameser.h> \n\n# define LITTLE_ENDIAN   1234    /* least-significant byte first (vax, pc) */\n# define BIG_ENDIAN      4321    /* most-significant byte first (IBM, net) */\n# define PDP_ENDIAN      3412    /* LSB first in word, MSW first in long (pdp) */\n\n#if defined(vax) || defined(ns32000) || defined(sun386) || defined(i386) || \\\n        defined(__i386) || defined(__ia64) || defined(__amd64) || \\\n        defined(MIPSEL) || defined(_MIPSEL) || defined(BIT_ZERO_ON_RIGHT) || \\\n        defined(__alpha__) || defined(__alpha) || \\\n        (defined(__Lynx__) && defined(__x86__))\n# define BYTE_ORDER      LITTLE_ENDIAN\n#endif\n\n#if defined(sel) || defined(pyr) || defined(mc68000) || defined(sparc) || \\\n    defined(__sparc) || \\\n    defined(is68k) || defined(tahoe) || defined(ibm032) || defined(ibm370) || \\\n    defined(MIPSEB) || defined(_MIPSEB) || defined(_IBMR2) || defined(DGUX) ||\\\n    defined(apollo) || defined(__convex__) || defined(_CRAY) || \\\n    defined(__hppa) || defined(__hp9000) || \\\n    defined(__hp9000s300) || defined(__hp9000s700) || \\\n    defined(__hp3000s900) || defined(MPE) || \\\n    defined(BIT_ZERO_ON_LEFT) || defined(m68k) || \\\n        (defined(__Lynx__) && \\\n        (defined(__68k__) || defined(__sparc__) || defined(__powerpc__)))\n# define BYTE_ORDER      BIG_ENDIAN\n#endif\n\n#endif\n\nstruct dnsheader {\n        unsigned        id :16;         /* query identification number */\n#if BYTE_ORDER == BIG_ENDIAN\n                        /* fields in third byte */\n        unsigned        qr: 1;          /* response flag */\n        unsigned        opcode: 4;      /* purpose of message */\n        unsigned        aa: 1;          /* authoritative answer */\n        unsigned        tc: 1;          /* truncated message */\n        unsigned        rd: 1;          /* recursion desired */\n                        /* fields in fourth byte */\n        unsigned        ra: 1;          /* recursion available */\n        unsigned        unused :1;      /* unused bits (MBZ as of 4.9.3a3) */\n        unsigned        ad: 1;          /* authentic data from named */\n        unsigned        cd: 1;          /* checking disabled by resolver */\n        unsigned        rcode :4;       /* response code */\n#elif BYTE_ORDER == LITTLE_ENDIAN || BYTE_ORDER == PDP_ENDIAN\n                        /* fields in third byte */\n        unsigned        rd :1;          /* recursion desired */\n        unsigned        tc :1;          /* truncated message */\n        unsigned        aa :1;          /* authoritative answer */\n        unsigned        opcode :4;      /* purpose of message */\n        unsigned        qr :1;          /* response flag */\n                        /* fields in fourth byte */\n        unsigned        rcode :4;       /* response code */\n        unsigned        cd: 1;          /* checking disabled by resolver */\n        unsigned        ad: 1;          /* authentic data from named */\n        unsigned        unused :1;      /* unused bits (MBZ as of 4.9.3a3) */\n        unsigned        ra :1;          /* recursion available */\n#endif\n                        /* remaining bytes */\n        unsigned        qdcount :16;    /* number of question entries */\n        unsigned        ancount :16;    /* number of answer entries */\n        unsigned        nscount :16;    /* number of authority entries */\n        unsigned        arcount :16;    /* number of resource entries */\n};\n\nstatic_assert(sizeof(dnsheader) == 12, \"dnsheader size must be 12\");\n\ninline uint16_t * getFlagsFromDNSHeader(struct dnsheader * dh)\n{\n  return (uint16_t*) (((char *) dh) + sizeof(uint16_t));\n}\n\n#define DNS_TYPE_SIZE (2)\n#define DNS_CLASS_SIZE (2)\n#define DNS_TTL_SIZE (4)\n#define DNS_RDLENGTH_SIZE (2)\n#define EDNS_EXTENDED_RCODE_SIZE (1)\n#define EDNS_VERSION_SIZE (1)\n#define EDNS_OPTION_CODE_SIZE (2)\n#define EDNS_OPTION_LENGTH_SIZE (2)\n\n#if BYTE_ORDER == BIG_ENDIAN\n#define FLAGS_RD_OFFSET (8)\n#define FLAGS_CD_OFFSET (12)\n#elif BYTE_ORDER == LITTLE_ENDIAN || BYTE_ORDER == PDP_ENDIAN\n#define FLAGS_RD_OFFSET (0)\n#define FLAGS_CD_OFFSET (12)\n#endif\n\nextern time_t s_starttime;\n\nuint32_t hashQuestion(const char* packet, uint16_t len, uint32_t init);\n\nstruct TSIGTriplet\n{\n  DNSName name, algo;\n  string secret;\n};\n\nstring &attodot(string &str);  //!< for when you need to insert an email address in the SOA\n"}, "25": {"id": 25, "path": "/home/runner/work/testcc/testcc/retdec/pdns/dnsbackend.hh", "content": "/*\n * This file is part of PowerDNS or dnsdist.\n * Copyright -- PowerDNS.COM B.V. and its contributors\n *\n * This program is free software; you can redistribute it and/or modify\n * it under the terms of version 2 of the GNU General Public License as\n * published by the Free Software Foundation.\n *\n * In addition, for the avoidance of any doubt, permission is granted to\n * link this program with OpenSSL and to (re)distribute the binaries\n * produced as the result of such linking.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with this program; if not, write to the Free Software\n * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.\n */\n#pragma once\n\nclass DNSPacket;\n\n#include \"utility.hh\"\n#include <string>\n#include <vector>\n#include <map>\n#include <sys/types.h>\n#include \"pdnsexception.hh\"\n#include <set>\n#include <iostream>\n#include <sys/socket.h>\n#include <dirent.h>\n#include \"misc.hh\"\n#include \"qtype.hh\"\n#include \"dns.hh\"\n#include <vector>\n#include \"namespaces.hh\"\n#include \"comment.hh\"\n#include \"dnsname.hh\"\n#include \"dnsrecords.hh\"\n#include \"iputils.hh\"\n\nclass DNSBackend;  \nstruct DomainInfo\n{\n  DomainInfo() : last_check(0), backend(NULL), id(0), notified_serial(0), serial(0), kind(DomainInfo::Native) {}\n\n  DNSName zone;\n  time_t last_check;\n  string account;\n  vector<ComboAddress> masters; \n  DNSBackend *backend;\n\n  uint32_t id;\n  uint32_t notified_serial;\n\n  uint32_t serial;\n  enum DomainKind : uint8_t { Master, Slave, Native } kind;\n  \n  bool operator<(const DomainInfo& rhs) const\n  {\n    return zone < rhs.zone;\n  }\n\n  const char *getKindString() const\n  {\n    return DomainInfo::getKindString(kind);\n  }\n\n  static const char *getKindString(enum DomainKind kind)\n  {\n    const char *kinds[]={\"Master\", \"Slave\", \"Native\"};\n    return kinds[kind];\n  }\n\n  static DomainKind stringToKind(const string& kind)\n  {\n    if(pdns_iequals(kind,\"SLAVE\"))\n      return DomainInfo::Slave;\n    else if(pdns_iequals(kind,\"MASTER\"))\n      return DomainInfo::Master;\n    else\n      return DomainInfo::Native;\n  }\n\n  bool isMaster(const ComboAddress& ip) const\n  {\n    for( const auto& master: masters) {\n      if(ComboAddress::addressOnlyEqual()(ip, master))\n        return true;\n    }\n    return false;\n  }\n\n};\n\nstruct TSIGKey {\n   DNSName name;\n   DNSName algorithm;\n   std::string key;\n};\n\nclass DNSPacket;\n\n//! This virtual base class defines the interface for backends for PowerDNS.\n/** To create a backend, inherit from this class and implement functions for all virtual methods.\n    Methods should not throw an exception if they are sure they did not find the requested data. However,\n    if an error occurred which prevented them temporarily from performing a lockup, they should throw a DBException,\n    which will cause the nameserver to send out a ServFail or take other evasive action. Probably only locking\n    issues should lead to DBExceptions.\n\n    More serious errors, which may indicate that the database connection is hosed, or a configuration error occurred, should\n    lead to the throwing of an PDNSException. This exception will fall straight through the UeberBackend and the PacketHandler\n    and be caught by the Distributor, which will delete your DNSBackend instance and spawn a new one.\n*/\nclass DNSBackend\n{\npublic:\n  //! lookup() initiates a lookup. A lookup without results should not throw!\n  virtual void lookup(const QType &qtype, const DNSName &qdomain, int zoneId=-1, DNSPacket *pkt_p=nullptr)=0;\n  virtual bool get(DNSResourceRecord &)=0; //!< retrieves one DNSResource record, returns false if no more were available\n  virtual bool get(DNSZoneRecord &r);\n\n  //! Initiates a list of the specified domain\n  /** Once initiated, DNSResourceRecord objects can be retrieved using get(). Should return false\n      if the backend does not consider itself responsible for the id passed.\n      \\param domain_id ID of which a list is requested\n  */\n  virtual bool list(const DNSName &target, int domain_id, bool include_disabled=false)=0;\n\n  virtual ~DNSBackend(){};\n\n  //! fills the soadata struct with the SOA details. Returns false if there is no SOA.\n  virtual bool getSOA(const DNSName &name, SOAData &soadata);\n\n  virtual bool replaceRRSet(uint32_t domain_id, const DNSName& qname, const QType& qt, const vector<DNSResourceRecord>& rrset)\n  {\n    return false;\n  }\n\n  virtual bool listSubZone(const DNSName &zone, int domain_id)\n  {\n    return false;\n  }\n\n  // the DNSSEC related (getDomainMetadata has broader uses too)\n  bool isDnssecDomainMetadata (const string& name) {\n    return (name == \"PRESIGNED\" || name == \"NSEC3PARAM\" || name == \"NSEC3NARROW\");\n  }\n  virtual bool getAllDomainMetadata(const DNSName& name, std::map<std::string, std::vector<std::string> >& meta) { return false; };\n  virtual bool getDomainMetadata(const DNSName& name, const std::string& kind, std::vector<std::string>& meta) { return false; }\n  virtual bool getDomainMetadataOne(const DNSName& name, const std::string& kind, std::string& value)\n  {\n    std::vector<std::string> meta;\n    if (getDomainMetadata(name, kind, meta)) {\n      if(!meta.empty()) {\n        value = *meta.begin();\n        return true;\n      }\n    }\n    return false;\n  }\n\n  virtual bool setDomainMetadata(const DNSName& name, const std::string& kind, const std::vector<std::string>& meta) {return false;}\n  virtual bool setDomainMetadataOne(const DNSName& name, const std::string& kind, const std::string& value)\n  {\n    const std::vector<std::string> meta(1, value);\n    return setDomainMetadata(name, kind, meta);\n  }\n\n\n  virtual void getAllDomains(vector<DomainInfo> *domains, bool include_disabled=false) { }\n\n  /** Determines if we are authoritative for a zone, and at what level */\n  virtual bool getAuth(const DNSName &target, SOAData *sd);\n\n  struct KeyData {\n    std::string content;\n    unsigned int id;\n    unsigned int flags;\n    bool active;\n    bool published;\n  };\n\n  virtual bool getDomainKeys(const DNSName& name, std::vector<KeyData>& keys) { return false;}\n  virtual bool removeDomainKey(const DNSName& name, unsigned int id) { return false; }\n  virtual bool addDomainKey(const DNSName& name, const KeyData& key, int64_t& id){ return false; }\n  virtual bool activateDomainKey(const DNSName& name, unsigned int id) { return false; }\n  virtual bool deactivateDomainKey(const DNSName& name, unsigned int id) { return false; }\n  virtual bool publishDomainKey(const DNSName& name, unsigned int id) { return false; }\n  virtual bool unpublishDomainKey(const DNSName& name, unsigned int id) { return false; }\n\n  virtual bool getTSIGKey(const DNSName& name, DNSName* algorithm, string* content) { return false; }\n  virtual bool setTSIGKey(const DNSName& name, const DNSName& algorithm, const string& content) { return false; }\n  virtual bool deleteTSIGKey(const DNSName& name) { return false; }\n  virtual bool getTSIGKeys(std::vector< struct TSIGKey > &keys) { return false; }\n\n  virtual bool getBeforeAndAfterNamesAbsolute(uint32_t id, const DNSName& qname, DNSName& unhashed, DNSName& before, DNSName& after)\n  {\n    std::cerr<<\"Default beforeAndAfterAbsolute called!\"<<std::endl;\n    abort();\n    return false;\n  }\n\n  virtual bool getBeforeAndAfterNames(uint32_t id, const DNSName& zonename, const DNSName& qname, DNSName& before, DNSName& after);\n\n  virtual bool updateDNSSECOrderNameAndAuth(uint32_t domain_id, const DNSName& qname, const DNSName& ordername, bool auth, const uint16_t qtype=QType::ANY)\n  {\n    return false;\n  }\n\n  virtual bool updateEmptyNonTerminals(uint32_t domain_id, set<DNSName>& insert, set<DNSName>& erase, bool remove)\n  {\n    return false;\n  }\n\n  virtual bool doesDNSSEC()\n  {\n    return false;\n  }\n\n  // end DNSSEC\n\n  // comments support\n  virtual bool listComments(uint32_t domain_id)\n  {\n    return false; // unsupported by this backend\n  }\n\n  virtual bool getComment(Comment& comment)\n  {\n    return false;\n  }\n\n  virtual void feedComment(const Comment& comment)\n  {\n  }\n\n  virtual bool replaceComments(const uint32_t domain_id, const DNSName& qname, const QType& qt, const vector<Comment>& comments)\n  {\n    return false;\n  }\n\n  //! returns true if master ip is master for domain name.\n  //! starts the transaction for updating domain qname (FIXME: what is id?)\n  virtual bool startTransaction(const DNSName &qname, int id=-1)\n  {\n    return false;\n  }\n\n  //! commits the transaction started by startTransaction\n  virtual bool commitTransaction()\n  {\n    return false;\n  }\n\n  //! aborts the transaction started by strartTransaction, should leave state unaltered\n  virtual bool abortTransaction()\n  {\n    return false;\n  }\n\n  virtual void reload()\n  {\n  }\n\n  virtual void rediscover(string* status=0)\n  {\n  }\n\n  //! feeds a record to a zone, needs a call to startTransaction first\n  virtual bool feedRecord(const DNSResourceRecord &rr, const DNSName &ordername, bool ordernameIsNSEC3=false)\n  {\n    return false; // no problem!\n  }\n  virtual bool feedEnts(int domain_id, map<DNSName,bool> &nonterm)\n  {\n    return false;\n  }\n  virtual bool feedEnts3(int domain_id, const DNSName &domain, map<DNSName,bool> &nonterm, const NSEC3PARAMRecordContent& ns3prc, bool narrow)\n  {\n    return false;\n  }\n\n  //! if this returns true, DomainInfo di contains information about the domain\n  virtual bool getDomainInfo(const DNSName &domain, DomainInfo &di, bool getSerial=true)\n  {\n    return false;\n  }\n  //! slave capable backends should return a list of slaves that should be rechecked for staleness\n  virtual void getUnfreshSlaveInfos(vector<DomainInfo>* domains)\n  {\n  }\n\n  //! get a list of IP addresses that should also be notified for a domain\n  virtual void alsoNotifies(const DNSName &domain, set<string> *ips)\n  {\n  }\n\n  //! get list of domains that have been changed since their last notification to slaves\n  virtual void getUpdatedMasters(vector<DomainInfo>* domains)\n  {\n  }\n  \n  //! Called by PowerDNS to inform a backend that a domain has been checked for freshness\n  virtual void setFresh(uint32_t domain_id)\n  {\n\n  }\n  //! Called by PowerDNS to inform a backend that the changes in the domain have been reported to slaves\n  virtual void setNotified(uint32_t id, uint32_t serial)\n  {\n  }\n\n  //! Called when the Master list of a domain should be changed\n  virtual bool setMasters(const DNSName &domain, const vector<ComboAddress> &masters)\n  {\n    return false;\n  }\n\n  //! Called when the Kind of a domain should be changed (master -> native and similar)\n  virtual bool setKind(const DNSName &domain, const DomainInfo::DomainKind kind)\n  {\n    return false;\n  }\n\n  //! Called when the Account of a domain should be changed\n  virtual bool setAccount(const DNSName &domain, const string &account)\n  {\n    return false;\n  }\n\n  //! Can be called to seed the getArg() function with a prefix\n  void setArgPrefix(const string &prefix);\n\n  //! Add an entry for a super master\n  virtual bool superMasterAdd(const string &ip, const string &nameserver, const string &account) \n  {\n    return false; \n  }\n\n  //! determine if ip is a supermaster or a domain\n  virtual bool superMasterBackend(const string &ip, const DNSName &domain, const vector<DNSResourceRecord>&nsset, string *nameserver, string *account, DNSBackend **db)\n  {\n    return false;\n  }\n\n  //! called by PowerDNS to create a new domain\n  virtual bool createDomain(const DNSName &domain, const DomainInfo::DomainKind kind, const vector<ComboAddress> &masters, const string &account)\n  {\n    return false;\n  }\n\n  //! called by PowerDNS to create a slave record for a superMaster\n  virtual bool createSlaveDomain(const string &ip, const DNSName &domain, const string &nameserver, const string &account)\n  {\n    return false;\n  }\n\n  //! called to delete a domain, incl. all metadata, zone contents, etc.\n  virtual bool deleteDomain(const DNSName &domain)\n  {\n    return false;\n  }\n\n  virtual string directBackendCmd(const string &query)\n  {\n    return \"directBackendCmd not supported for this backend\\n\";\n  }\n\n  //! Search for records, returns true if search was done successfully.\n  virtual bool searchRecords(const string &pattern, int maxResults, vector<DNSResourceRecord>& result)\n  {\n    return false;\n  }\n\n  //! Search for comments, returns true if search was done successfully.\n  virtual bool searchComments(const string &pattern, int maxResults, vector<Comment>& result)\n  {\n    return false;\n  }\n\n  const string& getPrefix() { return d_prefix; };\nprotected:\n  bool mustDo(const string &key);\n  const string &getArg(const string &key);\n  int getArgAsNum(const string &key);\n\nprivate:\n  string d_prefix;\n};\n\nclass BackendFactory\n{\npublic:\n  BackendFactory(const string &name) : d_name(name) {}\n  virtual ~BackendFactory(){}\n  virtual DNSBackend *make(const string &suffix)=0;\n  virtual DNSBackend *makeMetadataOnly(const string &suffix)\n  {\n    return this->make(suffix);\n  }\n  virtual void declareArguments(const string &suffix=\"\"){}\n  const string &getName() const;\n  \nprotected:\n  void declare(const string &suffix, const string &param, const string &explanation, const string &value);\n\nprivate:\n  const string d_name;\n};\n\nclass BackendMakerClass\n{\npublic:\n  void report(BackendFactory *bf);\n  void launch(const string &instr);\n  vector<DNSBackend *> all(bool skipBIND=false);\n  void load(const string &module);\n  size_t numLauncheable() const;\n  vector<string> getModules();\n  void clear();\n\nprivate:\n  void load_all();\n  typedef map<string,BackendFactory *>d_repository_t;\n  d_repository_t d_repository;\n  vector<pair<string,string> >d_instances;\n};\n\nextern BackendMakerClass &BackendMakers();\n\n//! Exception that can be thrown by a DNSBackend to indicate a failure\nclass DBException : public PDNSException\n{\npublic:\n  DBException(const string &reason_) : PDNSException(reason_){}\n};\n\n/** helper function for both DNSPacket and addSOARecord() - converts a line into a struct, for easier parsing */\nvoid fillSOAData(const string &content, SOAData &data);\n// same but more karmic\nvoid fillSOAData(const DNSZoneRecord& in, SOAData& data);\n// the reverse\nstd::shared_ptr<DNSRecordContent> makeSOAContent(const SOAData& sd);\n"}, "26": {"id": 26, "path": "/usr/include/c++/7/bits/stl_vector.h", "content": "// Vector implementation -*- C++ -*-\n\n// Copyright (C) 2001-2017 Free Software Foundation, Inc.\n//\n// This file is part of the GNU ISO C++ Library.  This library is free\n// software; you can redistribute it and/or modify it under the\n// terms of the GNU General Public License as published by the\n// Free Software Foundation; either version 3, or (at your option)\n// any later version.\n\n// This library is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n\n// Under Section 7 of GPL version 3, you are granted additional\n// permissions described in the GCC Runtime Library Exception, version\n// 3.1, as published by the Free Software Foundation.\n\n// You should have received a copy of the GNU General Public License and\n// a copy of the GCC Runtime Library Exception along with this program;\n// see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n// <http://www.gnu.org/licenses/>.\n\n/*\n *\n * Copyright (c) 1994\n * Hewlett-Packard Company\n *\n * Permission to use, copy, modify, distribute and sell this software\n * and its documentation for any purpose is hereby granted without fee,\n * provided that the above copyright notice appear in all copies and\n * that both that copyright notice and this permission notice appear\n * in supporting documentation.  Hewlett-Packard Company makes no\n * representations about the suitability of this software for any\n * purpose.  It is provided \"as is\" without express or implied warranty.\n *\n *\n * Copyright (c) 1996\n * Silicon Graphics Computer Systems, Inc.\n *\n * Permission to use, copy, modify, distribute and sell this software\n * and its documentation for any purpose is hereby granted without fee,\n * provided that the above copyright notice appear in all copies and\n * that both that copyright notice and this permission notice appear\n * in supporting documentation.  Silicon Graphics makes no\n * representations about the suitability of this  software for any\n * purpose.  It is provided \"as is\" without express or implied warranty.\n */\n\n/** @file bits/stl_vector.h\n *  This is an internal header file, included by other library headers.\n *  Do not attempt to use it directly. @headername{vector}\n */\n\n#ifndef _STL_VECTOR_H\n#define _STL_VECTOR_H 1\n\n#include <bits/stl_iterator_base_funcs.h>\n#include <bits/functexcept.h>\n#include <bits/concept_check.h>\n#if __cplusplus >= 201103L\n#include <initializer_list>\n#endif\n\n#include <debug/assertions.h>\n\nnamespace std _GLIBCXX_VISIBILITY(default)\n{\n_GLIBCXX_BEGIN_NAMESPACE_CONTAINER\n\n  /// See bits/stl_deque.h's _Deque_base for an explanation.\n  template<typename _Tp, typename _Alloc>\n    struct _Vector_base\n    {\n      typedef typename __gnu_cxx::__alloc_traits<_Alloc>::template\n\trebind<_Tp>::other _Tp_alloc_type;\n      typedef typename __gnu_cxx::__alloc_traits<_Tp_alloc_type>::pointer\n       \tpointer;\n\n      struct _Vector_impl\n      : public _Tp_alloc_type\n      {\n\tpointer _M_start;\n\tpointer _M_finish;\n\tpointer _M_end_of_storage;\n\n\t_Vector_impl()\n\t: _Tp_alloc_type(), _M_start(), _M_finish(), _M_end_of_storage()\n\t{ }\n\n\t_Vector_impl(_Tp_alloc_type const& __a) _GLIBCXX_NOEXCEPT\n\t: _Tp_alloc_type(__a), _M_start(), _M_finish(), _M_end_of_storage()\n\t{ }\n\n#if __cplusplus >= 201103L\n\t_Vector_impl(_Tp_alloc_type&& __a) noexcept\n\t: _Tp_alloc_type(std::move(__a)),\n\t  _M_start(), _M_finish(), _M_end_of_storage()\n\t{ }\n#endif\n\n\tvoid _M_swap_data(_Vector_impl& __x) _GLIBCXX_NOEXCEPT\n\t{\n\t  std::swap(_M_start, __x._M_start);\n\t  std::swap(_M_finish, __x._M_finish);\n\t  std::swap(_M_end_of_storage, __x._M_end_of_storage);\n\t}\n      };\n\n    public:\n      typedef _Alloc allocator_type;\n\n      _Tp_alloc_type&\n      _M_get_Tp_allocator() _GLIBCXX_NOEXCEPT\n      { return *static_cast<_Tp_alloc_type*>(&this->_M_impl); }\n\n      const _Tp_alloc_type&\n      _M_get_Tp_allocator() const _GLIBCXX_NOEXCEPT\n      { return *static_cast<const _Tp_alloc_type*>(&this->_M_impl); }\n\n      allocator_type\n      get_allocator() const _GLIBCXX_NOEXCEPT\n      { return allocator_type(_M_get_Tp_allocator()); }\n\n      _Vector_base()\n      : _M_impl() { }\n\n      _Vector_base(const allocator_type& __a) _GLIBCXX_NOEXCEPT\n      : _M_impl(__a) { }\n\n      _Vector_base(size_t __n)\n      : _M_impl()\n      { _M_create_storage(__n); }\n\n      _Vector_base(size_t __n, const allocator_type& __a)\n      : _M_impl(__a)\n      { _M_create_storage(__n); }\n\n#if __cplusplus >= 201103L\n      _Vector_base(_Tp_alloc_type&& __a) noexcept\n      : _M_impl(std::move(__a)) { }\n\n      _Vector_base(_Vector_base&& __x) noexcept\n      : _M_impl(std::move(__x._M_get_Tp_allocator()))\n      { this->_M_impl._M_swap_data(__x._M_impl); }\n\n      _Vector_base(_Vector_base&& __x, const allocator_type& __a)\n      : _M_impl(__a)\n      {\n\tif (__x.get_allocator() == __a)\n\t  this->_M_impl._M_swap_data(__x._M_impl);\n\telse\n\t  {\n\t    size_t __n = __x._M_impl._M_finish - __x._M_impl._M_start;\n\t    _M_create_storage(__n);\n\t  }\n      }\n#endif\n\n      ~_Vector_base() _GLIBCXX_NOEXCEPT\n      { _M_deallocate(this->_M_impl._M_start, this->_M_impl._M_end_of_storage\n\t\t      - this->_M_impl._M_start); }\n\n    public:\n      _Vector_impl _M_impl;\n\n      pointer\n      _M_allocate(size_t __n)\n      {\n\ttypedef __gnu_cxx::__alloc_traits<_Tp_alloc_type> _Tr;\n\treturn __n != 0 ? _Tr::allocate(_M_impl, __n) : pointer();\n      }\n\n      void\n      _M_deallocate(pointer __p, size_t __n)\n      {\n\ttypedef __gnu_cxx::__alloc_traits<_Tp_alloc_type> _Tr;\n\tif (__p)\n\t  _Tr::deallocate(_M_impl, __p, __n);\n      }\n\n    private:\n      void\n      _M_create_storage(size_t __n)\n      {\n\tthis->_M_impl._M_start = this->_M_allocate(__n);\n\tthis->_M_impl._M_finish = this->_M_impl._M_start;\n\tthis->_M_impl._M_end_of_storage = this->_M_impl._M_start + __n;\n      }\n    };\n\n\n  /**\n   *  @brief A standard container which offers fixed time access to\n   *  individual elements in any order.\n   *\n   *  @ingroup sequences\n   *\n   *  @tparam _Tp  Type of element.\n   *  @tparam _Alloc  Allocator type, defaults to allocator<_Tp>.\n   *\n   *  Meets the requirements of a <a href=\"tables.html#65\">container</a>, a\n   *  <a href=\"tables.html#66\">reversible container</a>, and a\n   *  <a href=\"tables.html#67\">sequence</a>, including the\n   *  <a href=\"tables.html#68\">optional sequence requirements</a> with the\n   *  %exception of @c push_front and @c pop_front.\n   *\n   *  In some terminology a %vector can be described as a dynamic\n   *  C-style array, it offers fast and efficient access to individual\n   *  elements in any order and saves the user from worrying about\n   *  memory and size allocation.  Subscripting ( @c [] ) access is\n   *  also provided as with C-style arrays.\n  */\n  template<typename _Tp, typename _Alloc = std::allocator<_Tp> >\n    class vector : protected _Vector_base<_Tp, _Alloc>\n    {\n#ifdef _GLIBCXX_CONCEPT_CHECKS\n      // Concept requirements.\n      typedef typename _Alloc::value_type\t\t_Alloc_value_type;\n# if __cplusplus < 201103L\n      __glibcxx_class_requires(_Tp, _SGIAssignableConcept)\n# endif\n      __glibcxx_class_requires2(_Tp, _Alloc_value_type, _SameTypeConcept)\n#endif\n\n      typedef _Vector_base<_Tp, _Alloc>\t\t\t_Base;\n      typedef typename _Base::_Tp_alloc_type\t\t_Tp_alloc_type;\n      typedef __gnu_cxx::__alloc_traits<_Tp_alloc_type>\t_Alloc_traits;\n\n    public:\n      typedef _Tp\t\t\t\t\tvalue_type;\n      typedef typename _Base::pointer\t\t\tpointer;\n      typedef typename _Alloc_traits::const_pointer\tconst_pointer;\n      typedef typename _Alloc_traits::reference\t\treference;\n      typedef typename _Alloc_traits::const_reference\tconst_reference;\n      typedef __gnu_cxx::__normal_iterator<pointer, vector> iterator;\n      typedef __gnu_cxx::__normal_iterator<const_pointer, vector>\n      const_iterator;\n      typedef std::reverse_iterator<const_iterator>\tconst_reverse_iterator;\n      typedef std::reverse_iterator<iterator>\t\treverse_iterator;\n      typedef size_t\t\t\t\t\tsize_type;\n      typedef ptrdiff_t\t\t\t\t\tdifference_type;\n      typedef _Alloc\t\t\t\t\tallocator_type;\n\n    protected:\n      using _Base::_M_allocate;\n      using _Base::_M_deallocate;\n      using _Base::_M_impl;\n      using _Base::_M_get_Tp_allocator;\n\n    public:\n      // [23.2.4.1] construct/copy/destroy\n      // (assign() and get_allocator() are also listed in this section)\n\n      /**\n       *  @brief  Creates a %vector with no elements.\n       */\n      vector()\n#if __cplusplus >= 201103L\n      noexcept(is_nothrow_default_constructible<_Alloc>::value)\n#endif\n      : _Base() { }\n\n      /**\n       *  @brief  Creates a %vector with no elements.\n       *  @param  __a  An allocator object.\n       */\n      explicit\n      vector(const allocator_type& __a) _GLIBCXX_NOEXCEPT\n      : _Base(__a) { }\n\n#if __cplusplus >= 201103L\n      /**\n       *  @brief  Creates a %vector with default constructed elements.\n       *  @param  __n  The number of elements to initially create.\n       *  @param  __a  An allocator.\n       *\n       *  This constructor fills the %vector with @a __n default\n       *  constructed elements.\n       */\n      explicit\n      vector(size_type __n, const allocator_type& __a = allocator_type())\n      : _Base(__n, __a)\n      { _M_default_initialize(__n); }\n\n      /**\n       *  @brief  Creates a %vector with copies of an exemplar element.\n       *  @param  __n  The number of elements to initially create.\n       *  @param  __value  An element to copy.\n       *  @param  __a  An allocator.\n       *\n       *  This constructor fills the %vector with @a __n copies of @a __value.\n       */\n      vector(size_type __n, const value_type& __value,\n\t     const allocator_type& __a = allocator_type())\n      : _Base(__n, __a)\n      { _M_fill_initialize(__n, __value); }\n#else\n      /**\n       *  @brief  Creates a %vector with copies of an exemplar element.\n       *  @param  __n  The number of elements to initially create.\n       *  @param  __value  An element to copy.\n       *  @param  __a  An allocator.\n       *\n       *  This constructor fills the %vector with @a __n copies of @a __value.\n       */\n      explicit\n      vector(size_type __n, const value_type& __value = value_type(),\n\t     const allocator_type& __a = allocator_type())\n      : _Base(__n, __a)\n      { _M_fill_initialize(__n, __value); }\n#endif\n\n      /**\n       *  @brief  %Vector copy constructor.\n       *  @param  __x  A %vector of identical element and allocator types.\n       *\n       *  All the elements of @a __x are copied, but any unused capacity in\n       *  @a __x  will not be copied\n       *  (i.e. capacity() == size() in the new %vector).\n       *\n       *  The newly-created %vector uses a copy of the allocator object used\n       *  by @a __x (unless the allocator traits dictate a different object).\n       */\n      vector(const vector& __x)\n      : _Base(__x.size(),\n\t_Alloc_traits::_S_select_on_copy(__x._M_get_Tp_allocator()))\n      {\n\tthis->_M_impl._M_finish =\n\t  std::__uninitialized_copy_a(__x.begin(), __x.end(),\n\t\t\t\t      this->_M_impl._M_start,\n\t\t\t\t      _M_get_Tp_allocator());\n      }\n\n#if __cplusplus >= 201103L\n      /**\n       *  @brief  %Vector move constructor.\n       *  @param  __x  A %vector of identical element and allocator types.\n       *\n       *  The newly-created %vector contains the exact contents of @a __x.\n       *  The contents of @a __x are a valid, but unspecified %vector.\n       */\n      vector(vector&& __x) noexcept\n      : _Base(std::move(__x)) { }\n\n      /// Copy constructor with alternative allocator\n      vector(const vector& __x, const allocator_type& __a)\n      : _Base(__x.size(), __a)\n      {\n\tthis->_M_impl._M_finish =\n\t  std::__uninitialized_copy_a(__x.begin(), __x.end(),\n\t\t\t\t      this->_M_impl._M_start,\n\t\t\t\t      _M_get_Tp_allocator());\n      }\n\n      /// Move constructor with alternative allocator\n      vector(vector&& __rv, const allocator_type& __m)\n      noexcept(_Alloc_traits::_S_always_equal())\n      : _Base(std::move(__rv), __m)\n      {\n\tif (__rv.get_allocator() != __m)\n\t  {\n\t    this->_M_impl._M_finish =\n\t      std::__uninitialized_move_a(__rv.begin(), __rv.end(),\n\t\t\t\t\t  this->_M_impl._M_start,\n\t\t\t\t\t  _M_get_Tp_allocator());\n\t    __rv.clear();\n\t  }\n      }\n\n      /**\n       *  @brief  Builds a %vector from an initializer list.\n       *  @param  __l  An initializer_list.\n       *  @param  __a  An allocator.\n       *\n       *  Create a %vector consisting of copies of the elements in the\n       *  initializer_list @a __l.\n       *\n       *  This will call the element type's copy constructor N times\n       *  (where N is @a __l.size()) and do no memory reallocation.\n       */\n      vector(initializer_list<value_type> __l,\n\t     const allocator_type& __a = allocator_type())\n      : _Base(__a)\n      {\n\t_M_range_initialize(__l.begin(), __l.end(),\n\t\t\t    random_access_iterator_tag());\n      }\n#endif\n\n      /**\n       *  @brief  Builds a %vector from a range.\n       *  @param  __first  An input iterator.\n       *  @param  __last  An input iterator.\n       *  @param  __a  An allocator.\n       *\n       *  Create a %vector consisting of copies of the elements from\n       *  [first,last).\n       *\n       *  If the iterators are forward, bidirectional, or\n       *  random-access, then this will call the elements' copy\n       *  constructor N times (where N is distance(first,last)) and do\n       *  no memory reallocation.  But if only input iterators are\n       *  used, then this will do at most 2N calls to the copy\n       *  constructor, and logN memory reallocations.\n       */\n#if __cplusplus >= 201103L\n      template<typename _InputIterator,\n\t       typename = std::_RequireInputIter<_InputIterator>>\n\tvector(_InputIterator __first, _InputIterator __last,\n\t       const allocator_type& __a = allocator_type())\n\t: _Base(__a)\n\t{ _M_initialize_dispatch(__first, __last, __false_type()); }\n#else\n      template<typename _InputIterator>\n\tvector(_InputIterator __first, _InputIterator __last,\n\t       const allocator_type& __a = allocator_type())\n\t: _Base(__a)\n\t{\n\t  // Check whether it's an integral type.  If so, it's not an iterator.\n\t  typedef typename std::__is_integer<_InputIterator>::__type _Integral;\n\t  _M_initialize_dispatch(__first, __last, _Integral());\n\t}\n#endif\n\n      /**\n       *  The dtor only erases the elements, and note that if the\n       *  elements themselves are pointers, the pointed-to memory is\n       *  not touched in any way.  Managing the pointer is the user's\n       *  responsibility.\n       */\n      ~vector() _GLIBCXX_NOEXCEPT\n      { std::_Destroy(this->_M_impl._M_start, this->_M_impl._M_finish,\n\t\t      _M_get_Tp_allocator()); }\n\n      /**\n       *  @brief  %Vector assignment operator.\n       *  @param  __x  A %vector of identical element and allocator types.\n       *\n       *  All the elements of @a __x are copied, but any unused capacity in\n       *  @a __x will not be copied.\n       *\n       *  Whether the allocator is copied depends on the allocator traits.\n       */\n      vector&\n      operator=(const vector& __x);\n\n#if __cplusplus >= 201103L\n      /**\n       *  @brief  %Vector move assignment operator.\n       *  @param  __x  A %vector of identical element and allocator types.\n       *\n       *  The contents of @a __x are moved into this %vector (without copying,\n       *  if the allocators permit it).\n       *  Afterwards @a __x is a valid, but unspecified %vector.\n       *\n       *  Whether the allocator is moved depends on the allocator traits.\n       */\n      vector&\n      operator=(vector&& __x) noexcept(_Alloc_traits::_S_nothrow_move())\n      {\n\tconstexpr bool __move_storage =\n\t  _Alloc_traits::_S_propagate_on_move_assign()\n\t  || _Alloc_traits::_S_always_equal();\n\t_M_move_assign(std::move(__x), __bool_constant<__move_storage>());\n\treturn *this;\n      }\n\n      /**\n       *  @brief  %Vector list assignment operator.\n       *  @param  __l  An initializer_list.\n       *\n       *  This function fills a %vector with copies of the elements in the\n       *  initializer list @a __l.\n       *\n       *  Note that the assignment completely changes the %vector and\n       *  that the resulting %vector's size is the same as the number\n       *  of elements assigned.\n       */\n      vector&\n      operator=(initializer_list<value_type> __l)\n      {\n\tthis->_M_assign_aux(__l.begin(), __l.end(),\n\t\t\t    random_access_iterator_tag());\n\treturn *this;\n      }\n#endif\n\n      /**\n       *  @brief  Assigns a given value to a %vector.\n       *  @param  __n  Number of elements to be assigned.\n       *  @param  __val  Value to be assigned.\n       *\n       *  This function fills a %vector with @a __n copies of the given\n       *  value.  Note that the assignment completely changes the\n       *  %vector and that the resulting %vector's size is the same as\n       *  the number of elements assigned.\n       */\n      void\n      assign(size_type __n, const value_type& __val)\n      { _M_fill_assign(__n, __val); }\n\n      /**\n       *  @brief  Assigns a range to a %vector.\n       *  @param  __first  An input iterator.\n       *  @param  __last   An input iterator.\n       *\n       *  This function fills a %vector with copies of the elements in the\n       *  range [__first,__last).\n       *\n       *  Note that the assignment completely changes the %vector and\n       *  that the resulting %vector's size is the same as the number\n       *  of elements assigned.\n       */\n#if __cplusplus >= 201103L\n      template<typename _InputIterator,\n\t       typename = std::_RequireInputIter<_InputIterator>>\n\tvoid\n\tassign(_InputIterator __first, _InputIterator __last)\n\t{ _M_assign_dispatch(__first, __last, __false_type()); }\n#else\n      template<typename _InputIterator>\n\tvoid\n\tassign(_InputIterator __first, _InputIterator __last)\n\t{\n\t  // Check whether it's an integral type.  If so, it's not an iterator.\n\t  typedef typename std::__is_integer<_InputIterator>::__type _Integral;\n\t  _M_assign_dispatch(__first, __last, _Integral());\n\t}\n#endif\n\n#if __cplusplus >= 201103L\n      /**\n       *  @brief  Assigns an initializer list to a %vector.\n       *  @param  __l  An initializer_list.\n       *\n       *  This function fills a %vector with copies of the elements in the\n       *  initializer list @a __l.\n       *\n       *  Note that the assignment completely changes the %vector and\n       *  that the resulting %vector's size is the same as the number\n       *  of elements assigned.\n       */\n      void\n      assign(initializer_list<value_type> __l)\n      {\n\tthis->_M_assign_aux(__l.begin(), __l.end(),\n\t\t\t    random_access_iterator_tag());\n      }\n#endif\n\n      /// Get a copy of the memory allocation object.\n      using _Base::get_allocator;\n\n      // iterators\n      /**\n       *  Returns a read/write iterator that points to the first\n       *  element in the %vector.  Iteration is done in ordinary\n       *  element order.\n       */\n      iterator\n      begin() _GLIBCXX_NOEXCEPT\n      { return iterator(this->_M_impl._M_start); }\n\n      /**\n       *  Returns a read-only (constant) iterator that points to the\n       *  first element in the %vector.  Iteration is done in ordinary\n       *  element order.\n       */\n      const_iterator\n      begin() const _GLIBCXX_NOEXCEPT\n      { return const_iterator(this->_M_impl._M_start); }\n\n      /**\n       *  Returns a read/write iterator that points one past the last\n       *  element in the %vector.  Iteration is done in ordinary\n       *  element order.\n       */\n      iterator\n      end() _GLIBCXX_NOEXCEPT\n      { return iterator(this->_M_impl._M_finish); }\n\n      /**\n       *  Returns a read-only (constant) iterator that points one past\n       *  the last element in the %vector.  Iteration is done in\n       *  ordinary element order.\n       */\n      const_iterator\n      end() const _GLIBCXX_NOEXCEPT\n      { return const_iterator(this->_M_impl._M_finish); }\n\n      /**\n       *  Returns a read/write reverse iterator that points to the\n       *  last element in the %vector.  Iteration is done in reverse\n       *  element order.\n       */\n      reverse_iterator\n      rbegin() _GLIBCXX_NOEXCEPT\n      { return reverse_iterator(end()); }\n\n      /**\n       *  Returns a read-only (constant) reverse iterator that points\n       *  to the last element in the %vector.  Iteration is done in\n       *  reverse element order.\n       */\n      const_reverse_iterator\n      rbegin() const _GLIBCXX_NOEXCEPT\n      { return const_reverse_iterator(end()); }\n\n      /**\n       *  Returns a read/write reverse iterator that points to one\n       *  before the first element in the %vector.  Iteration is done\n       *  in reverse element order.\n       */\n      reverse_iterator\n      rend() _GLIBCXX_NOEXCEPT\n      { return reverse_iterator(begin()); }\n\n      /**\n       *  Returns a read-only (constant) reverse iterator that points\n       *  to one before the first element in the %vector.  Iteration\n       *  is done in reverse element order.\n       */\n      const_reverse_iterator\n      rend() const _GLIBCXX_NOEXCEPT\n      { return const_reverse_iterator(begin()); }\n\n#if __cplusplus >= 201103L\n      /**\n       *  Returns a read-only (constant) iterator that points to the\n       *  first element in the %vector.  Iteration is done in ordinary\n       *  element order.\n       */\n      const_iterator\n      cbegin() const noexcept\n      { return const_iterator(this->_M_impl._M_start); }\n\n      /**\n       *  Returns a read-only (constant) iterator that points one past\n       *  the last element in the %vector.  Iteration is done in\n       *  ordinary element order.\n       */\n      const_iterator\n      cend() const noexcept\n      { return const_iterator(this->_M_impl._M_finish); }\n\n      /**\n       *  Returns a read-only (constant) reverse iterator that points\n       *  to the last element in the %vector.  Iteration is done in\n       *  reverse element order.\n       */\n      const_reverse_iterator\n      crbegin() const noexcept\n      { return const_reverse_iterator(end()); }\n\n      /**\n       *  Returns a read-only (constant) reverse iterator that points\n       *  to one before the first element in the %vector.  Iteration\n       *  is done in reverse element order.\n       */\n      const_reverse_iterator\n      crend() const noexcept\n      { return const_reverse_iterator(begin()); }\n#endif\n\n      // [23.2.4.2] capacity\n      /**  Returns the number of elements in the %vector.  */\n      size_type\n      size() const _GLIBCXX_NOEXCEPT\n      { return size_type(this->_M_impl._M_finish - this->_M_impl._M_start); }\n\n      /**  Returns the size() of the largest possible %vector.  */\n      size_type\n      max_size() const _GLIBCXX_NOEXCEPT\n      { return _Alloc_traits::max_size(_M_get_Tp_allocator()); }\n\n#if __cplusplus >= 201103L\n      /**\n       *  @brief  Resizes the %vector to the specified number of elements.\n       *  @param  __new_size  Number of elements the %vector should contain.\n       *\n       *  This function will %resize the %vector to the specified\n       *  number of elements.  If the number is smaller than the\n       *  %vector's current size the %vector is truncated, otherwise\n       *  default constructed elements are appended.\n       */\n      void\n      resize(size_type __new_size)\n      {\n\tif (__new_size > size())\n\t  _M_default_append(__new_size - size());\n\telse if (__new_size < size())\n\t  _M_erase_at_end(this->_M_impl._M_start + __new_size);\n      }\n\n      /**\n       *  @brief  Resizes the %vector to the specified number of elements.\n       *  @param  __new_size  Number of elements the %vector should contain.\n       *  @param  __x  Data with which new elements should be populated.\n       *\n       *  This function will %resize the %vector to the specified\n       *  number of elements.  If the number is smaller than the\n       *  %vector's current size the %vector is truncated, otherwise\n       *  the %vector is extended and new elements are populated with\n       *  given data.\n       */\n      void\n      resize(size_type __new_size, const value_type& __x)\n      {\n\tif (__new_size > size())\n\t  _M_fill_insert(end(), __new_size - size(), __x);\n\telse if (__new_size < size())\n\t  _M_erase_at_end(this->_M_impl._M_start + __new_size);\n      }\n#else\n      /**\n       *  @brief  Resizes the %vector to the specified number of elements.\n       *  @param  __new_size  Number of elements the %vector should contain.\n       *  @param  __x  Data with which new elements should be populated.\n       *\n       *  This function will %resize the %vector to the specified\n       *  number of elements.  If the number is smaller than the\n       *  %vector's current size the %vector is truncated, otherwise\n       *  the %vector is extended and new elements are populated with\n       *  given data.\n       */\n      void\n      resize(size_type __new_size, value_type __x = value_type())\n      {\n\tif (__new_size > size())\n\t  _M_fill_insert(end(), __new_size - size(), __x);\n\telse if (__new_size < size())\n\t  _M_erase_at_end(this->_M_impl._M_start + __new_size);\n      }\n#endif\n\n#if __cplusplus >= 201103L\n      /**  A non-binding request to reduce capacity() to size().  */\n      void\n      shrink_to_fit()\n      { _M_shrink_to_fit(); }\n#endif\n\n      /**\n       *  Returns the total number of elements that the %vector can\n       *  hold before needing to allocate more memory.\n       */\n      size_type\n      capacity() const _GLIBCXX_NOEXCEPT\n      { return size_type(this->_M_impl._M_end_of_storage\n\t\t\t - this->_M_impl._M_start); }\n\n      /**\n       *  Returns true if the %vector is empty.  (Thus begin() would\n       *  equal end().)\n       */\n      bool\n      empty() const _GLIBCXX_NOEXCEPT\n      { return begin() == end(); }\n\n      /**\n       *  @brief  Attempt to preallocate enough memory for specified number of\n       *          elements.\n       *  @param  __n  Number of elements required.\n       *  @throw  std::length_error  If @a n exceeds @c max_size().\n       *\n       *  This function attempts to reserve enough memory for the\n       *  %vector to hold the specified number of elements.  If the\n       *  number requested is more than max_size(), length_error is\n       *  thrown.\n       *\n       *  The advantage of this function is that if optimal code is a\n       *  necessity and the user can determine the number of elements\n       *  that will be required, the user can reserve the memory in\n       *  %advance, and thus prevent a possible reallocation of memory\n       *  and copying of %vector data.\n       */\n      void\n      reserve(size_type __n);\n\n      // element access\n      /**\n       *  @brief  Subscript access to the data contained in the %vector.\n       *  @param __n The index of the element for which data should be\n       *  accessed.\n       *  @return  Read/write reference to data.\n       *\n       *  This operator allows for easy, array-style, data access.\n       *  Note that data access with this operator is unchecked and\n       *  out_of_range lookups are not defined. (For checked lookups\n       *  see at().)\n       */\n      reference\n      operator[](size_type __n) _GLIBCXX_NOEXCEPT\n      {\n\t__glibcxx_requires_subscript(__n);\n\treturn *(this->_M_impl._M_start + __n);\n      }\n\n      /**\n       *  @brief  Subscript access to the data contained in the %vector.\n       *  @param __n The index of the element for which data should be\n       *  accessed.\n       *  @return  Read-only (constant) reference to data.\n       *\n       *  This operator allows for easy, array-style, data access.\n       *  Note that data access with this operator is unchecked and\n       *  out_of_range lookups are not defined. (For checked lookups\n       *  see at().)\n       */\n      const_reference\n      operator[](size_type __n) const _GLIBCXX_NOEXCEPT\n      {\n\t__glibcxx_requires_subscript(__n);\n\treturn *(this->_M_impl._M_start + __n);\n      }\n\n    protected:\n      /// Safety check used only from at().\n      void\n      _M_range_check(size_type __n) const\n      {\n\tif (__n >= this->size())\n\t  __throw_out_of_range_fmt(__N(\"vector::_M_range_check: __n \"\n\t\t\t\t       \"(which is %zu) >= this->size() \"\n\t\t\t\t       \"(which is %zu)\"),\n\t\t\t\t   __n, this->size());\n      }\n\n    public:\n      /**\n       *  @brief  Provides access to the data contained in the %vector.\n       *  @param __n The index of the element for which data should be\n       *  accessed.\n       *  @return  Read/write reference to data.\n       *  @throw  std::out_of_range  If @a __n is an invalid index.\n       *\n       *  This function provides for safer data access.  The parameter\n       *  is first checked that it is in the range of the vector.  The\n       *  function throws out_of_range if the check fails.\n       */\n      reference\n      at(size_type __n)\n      {\n\t_M_range_check(__n);\n\treturn (*this)[__n];\n      }\n\n      /**\n       *  @brief  Provides access to the data contained in the %vector.\n       *  @param __n The index of the element for which data should be\n       *  accessed.\n       *  @return  Read-only (constant) reference to data.\n       *  @throw  std::out_of_range  If @a __n is an invalid index.\n       *\n       *  This function provides for safer data access.  The parameter\n       *  is first checked that it is in the range of the vector.  The\n       *  function throws out_of_range if the check fails.\n       */\n      const_reference\n      at(size_type __n) const\n      {\n\t_M_range_check(__n);\n\treturn (*this)[__n];\n      }\n\n      /**\n       *  Returns a read/write reference to the data at the first\n       *  element of the %vector.\n       */\n      reference\n      front() _GLIBCXX_NOEXCEPT\n      {\n\t__glibcxx_requires_nonempty();\n\treturn *begin();\n      }\n\n      /**\n       *  Returns a read-only (constant) reference to the data at the first\n       *  element of the %vector.\n       */\n      const_reference\n      front() const _GLIBCXX_NOEXCEPT\n      {\n\t__glibcxx_requires_nonempty();\n\treturn *begin();\n      }\n\n      /**\n       *  Returns a read/write reference to the data at the last\n       *  element of the %vector.\n       */\n      reference\n      back() _GLIBCXX_NOEXCEPT\n      {\n\t__glibcxx_requires_nonempty();\n\treturn *(end() - 1);\n      }\n\n      /**\n       *  Returns a read-only (constant) reference to the data at the\n       *  last element of the %vector.\n       */\n      const_reference\n      back() const _GLIBCXX_NOEXCEPT\n      {\n\t__glibcxx_requires_nonempty();\n\treturn *(end() - 1);\n      }\n\n      // _GLIBCXX_RESOLVE_LIB_DEFECTS\n      // DR 464. Suggestion for new member functions in standard containers.\n      // data access\n      /**\n       *   Returns a pointer such that [data(), data() + size()) is a valid\n       *   range.  For a non-empty %vector, data() == &front().\n       */\n      _Tp*\n      data() _GLIBCXX_NOEXCEPT\n      { return _M_data_ptr(this->_M_impl._M_start); }\n\n      const _Tp*\n      data() const _GLIBCXX_NOEXCEPT\n      { return _M_data_ptr(this->_M_impl._M_start); }\n\n      // [23.2.4.3] modifiers\n      /**\n       *  @brief  Add data to the end of the %vector.\n       *  @param  __x  Data to be added.\n       *\n       *  This is a typical stack operation.  The function creates an\n       *  element at the end of the %vector and assigns the given data\n       *  to it.  Due to the nature of a %vector this operation can be\n       *  done in constant time if the %vector has preallocated space\n       *  available.\n       */\n      void\n      push_back(const value_type& __x)\n      {\n\tif (this->_M_impl._M_finish != this->_M_impl._M_end_of_storage)\n\t  {\n\t    _Alloc_traits::construct(this->_M_impl, this->_M_impl._M_finish,\n\t\t\t\t     __x);\n\t    ++this->_M_impl._M_finish;\n\t  }\n\telse\n\t  _M_realloc_insert(end(), __x);\n      }\n\n#if __cplusplus >= 201103L\n      void\n      push_back(value_type&& __x)\n      { emplace_back(std::move(__x)); }\n\n      template<typename... _Args>\n#if __cplusplus > 201402L\n\treference\n#else\n\tvoid\n#endif\n\templace_back(_Args&&... __args);\n#endif\n\n      /**\n       *  @brief  Removes last element.\n       *\n       *  This is a typical stack operation. It shrinks the %vector by one.\n       *\n       *  Note that no data is returned, and if the last element's\n       *  data is needed, it should be retrieved before pop_back() is\n       *  called.\n       */\n      void\n      pop_back() _GLIBCXX_NOEXCEPT\n      {\n\t__glibcxx_requires_nonempty();\n\t--this->_M_impl._M_finish;\n\t_Alloc_traits::destroy(this->_M_impl, this->_M_impl._M_finish);\n      }\n\n#if __cplusplus >= 201103L\n      /**\n       *  @brief  Inserts an object in %vector before specified iterator.\n       *  @param  __position  A const_iterator into the %vector.\n       *  @param  __args  Arguments.\n       *  @return  An iterator that points to the inserted data.\n       *\n       *  This function will insert an object of type T constructed\n       *  with T(std::forward<Args>(args)...) before the specified location.\n       *  Note that this kind of operation could be expensive for a %vector\n       *  and if it is frequently used the user should consider using\n       *  std::list.\n       */\n      template<typename... _Args>\n\titerator\n\templace(const_iterator __position, _Args&&... __args)\n\t{ return _M_emplace_aux(__position, std::forward<_Args>(__args)...); }\n\n      /**\n       *  @brief  Inserts given value into %vector before specified iterator.\n       *  @param  __position  A const_iterator into the %vector.\n       *  @param  __x  Data to be inserted.\n       *  @return  An iterator that points to the inserted data.\n       *\n       *  This function will insert a copy of the given value before\n       *  the specified location.  Note that this kind of operation\n       *  could be expensive for a %vector and if it is frequently\n       *  used the user should consider using std::list.\n       */\n      iterator\n      insert(const_iterator __position, const value_type& __x);\n#else\n      /**\n       *  @brief  Inserts given value into %vector before specified iterator.\n       *  @param  __position  An iterator into the %vector.\n       *  @param  __x  Data to be inserted.\n       *  @return  An iterator that points to the inserted data.\n       *\n       *  This function will insert a copy of the given value before\n       *  the specified location.  Note that this kind of operation\n       *  could be expensive for a %vector and if it is frequently\n       *  used the user should consider using std::list.\n       */\n      iterator\n      insert(iterator __position, const value_type& __x);\n#endif\n\n#if __cplusplus >= 201103L\n      /**\n       *  @brief  Inserts given rvalue into %vector before specified iterator.\n       *  @param  __position  A const_iterator into the %vector.\n       *  @param  __x  Data to be inserted.\n       *  @return  An iterator that points to the inserted data.\n       *\n       *  This function will insert a copy of the given rvalue before\n       *  the specified location.  Note that this kind of operation\n       *  could be expensive for a %vector and if it is frequently\n       *  used the user should consider using std::list.\n       */\n      iterator\n      insert(const_iterator __position, value_type&& __x)\n      { return _M_insert_rval(__position, std::move(__x)); }\n\n      /**\n       *  @brief  Inserts an initializer_list into the %vector.\n       *  @param  __position  An iterator into the %vector.\n       *  @param  __l  An initializer_list.\n       *\n       *  This function will insert copies of the data in the\n       *  initializer_list @a l into the %vector before the location\n       *  specified by @a position.\n       *\n       *  Note that this kind of operation could be expensive for a\n       *  %vector and if it is frequently used the user should\n       *  consider using std::list.\n       */\n      iterator\n      insert(const_iterator __position, initializer_list<value_type> __l)\n      {\n\tauto __offset = __position - cbegin();\n\t_M_range_insert(begin() + __offset, __l.begin(), __l.end(),\n\t\t\tstd::random_access_iterator_tag());\n\treturn begin() + __offset;\n      }\n#endif\n\n#if __cplusplus >= 201103L\n      /**\n       *  @brief  Inserts a number of copies of given data into the %vector.\n       *  @param  __position  A const_iterator into the %vector.\n       *  @param  __n  Number of elements to be inserted.\n       *  @param  __x  Data to be inserted.\n       *  @return  An iterator that points to the inserted data.\n       *\n       *  This function will insert a specified number of copies of\n       *  the given data before the location specified by @a position.\n       *\n       *  Note that this kind of operation could be expensive for a\n       *  %vector and if it is frequently used the user should\n       *  consider using std::list.\n       */\n      iterator\n      insert(const_iterator __position, size_type __n, const value_type& __x)\n      {\n\tdifference_type __offset = __position - cbegin();\n\t_M_fill_insert(begin() + __offset, __n, __x);\n\treturn begin() + __offset;\n      }\n#else\n      /**\n       *  @brief  Inserts a number of copies of given data into the %vector.\n       *  @param  __position  An iterator into the %vector.\n       *  @param  __n  Number of elements to be inserted.\n       *  @param  __x  Data to be inserted.\n       *\n       *  This function will insert a specified number of copies of\n       *  the given data before the location specified by @a position.\n       *\n       *  Note that this kind of operation could be expensive for a\n       *  %vector and if it is frequently used the user should\n       *  consider using std::list.\n       */\n      void\n      insert(iterator __position, size_type __n, const value_type& __x)\n      { _M_fill_insert(__position, __n, __x); }\n#endif\n\n#if __cplusplus >= 201103L\n      /**\n       *  @brief  Inserts a range into the %vector.\n       *  @param  __position  A const_iterator into the %vector.\n       *  @param  __first  An input iterator.\n       *  @param  __last   An input iterator.\n       *  @return  An iterator that points to the inserted data.\n       *\n       *  This function will insert copies of the data in the range\n       *  [__first,__last) into the %vector before the location specified\n       *  by @a pos.\n       *\n       *  Note that this kind of operation could be expensive for a\n       *  %vector and if it is frequently used the user should\n       *  consider using std::list.\n       */\n      template<typename _InputIterator,\n\t       typename = std::_RequireInputIter<_InputIterator>>\n\titerator\n\tinsert(const_iterator __position, _InputIterator __first,\n\t       _InputIterator __last)\n\t{\n\t  difference_type __offset = __position - cbegin();\n\t  _M_insert_dispatch(begin() + __offset,\n\t\t\t     __first, __last, __false_type());\n\t  return begin() + __offset;\n\t}\n#else\n      /**\n       *  @brief  Inserts a range into the %vector.\n       *  @param  __position  An iterator into the %vector.\n       *  @param  __first  An input iterator.\n       *  @param  __last   An input iterator.\n       *\n       *  This function will insert copies of the data in the range\n       *  [__first,__last) into the %vector before the location specified\n       *  by @a pos.\n       *\n       *  Note that this kind of operation could be expensive for a\n       *  %vector and if it is frequently used the user should\n       *  consider using std::list.\n       */\n      template<typename _InputIterator>\n\tvoid\n\tinsert(iterator __position, _InputIterator __first,\n\t       _InputIterator __last)\n\t{\n\t  // Check whether it's an integral type.  If so, it's not an iterator.\n\t  typedef typename std::__is_integer<_InputIterator>::__type _Integral;\n\t  _M_insert_dispatch(__position, __first, __last, _Integral());\n\t}\n#endif\n\n      /**\n       *  @brief  Remove element at given position.\n       *  @param  __position  Iterator pointing to element to be erased.\n       *  @return  An iterator pointing to the next element (or end()).\n       *\n       *  This function will erase the element at the given position and thus\n       *  shorten the %vector by one.\n       *\n       *  Note This operation could be expensive and if it is\n       *  frequently used the user should consider using std::list.\n       *  The user is also cautioned that this function only erases\n       *  the element, and that if the element is itself a pointer,\n       *  the pointed-to memory is not touched in any way.  Managing\n       *  the pointer is the user's responsibility.\n       */\n      iterator\n#if __cplusplus >= 201103L\n      erase(const_iterator __position)\n      { return _M_erase(begin() + (__position - cbegin())); }\n#else\n      erase(iterator __position)\n      { return _M_erase(__position); }\n#endif\n\n      /**\n       *  @brief  Remove a range of elements.\n       *  @param  __first  Iterator pointing to the first element to be erased.\n       *  @param  __last  Iterator pointing to one past the last element to be\n       *                  erased.\n       *  @return  An iterator pointing to the element pointed to by @a __last\n       *           prior to erasing (or end()).\n       *\n       *  This function will erase the elements in the range\n       *  [__first,__last) and shorten the %vector accordingly.\n       *\n       *  Note This operation could be expensive and if it is\n       *  frequently used the user should consider using std::list.\n       *  The user is also cautioned that this function only erases\n       *  the elements, and that if the elements themselves are\n       *  pointers, the pointed-to memory is not touched in any way.\n       *  Managing the pointer is the user's responsibility.\n       */\n      iterator\n#if __cplusplus >= 201103L\n      erase(const_iterator __first, const_iterator __last)\n      {\n\tconst auto __beg = begin();\n\tconst auto __cbeg = cbegin();\n\treturn _M_erase(__beg + (__first - __cbeg), __beg + (__last - __cbeg));\n      }\n#else\n      erase(iterator __first, iterator __last)\n      { return _M_erase(__first, __last); }\n#endif\n\n      /**\n       *  @brief  Swaps data with another %vector.\n       *  @param  __x  A %vector of the same element and allocator types.\n       *\n       *  This exchanges the elements between two vectors in constant time.\n       *  (Three pointers, so it should be quite fast.)\n       *  Note that the global std::swap() function is specialized such that\n       *  std::swap(v1,v2) will feed to this function.\n       *\n       *  Whether the allocators are swapped depends on the allocator traits.\n       */\n      void\n      swap(vector& __x) _GLIBCXX_NOEXCEPT\n      {\n#if __cplusplus >= 201103L\n\t__glibcxx_assert(_Alloc_traits::propagate_on_container_swap::value\n\t\t\t || _M_get_Tp_allocator() == __x._M_get_Tp_allocator());\n#endif\n\tthis->_M_impl._M_swap_data(__x._M_impl);\n\t_Alloc_traits::_S_on_swap(_M_get_Tp_allocator(),\n\t\t\t\t  __x._M_get_Tp_allocator());\n      }\n\n      /**\n       *  Erases all the elements.  Note that this function only erases the\n       *  elements, and that if the elements themselves are pointers, the\n       *  pointed-to memory is not touched in any way.  Managing the pointer is\n       *  the user's responsibility.\n       */\n      void\n      clear() _GLIBCXX_NOEXCEPT\n      { _M_erase_at_end(this->_M_impl._M_start); }\n\n    protected:\n      /**\n       *  Memory expansion handler.  Uses the member allocation function to\n       *  obtain @a n bytes of memory, and then copies [first,last) into it.\n       */\n      template<typename _ForwardIterator>\n\tpointer\n\t_M_allocate_and_copy(size_type __n,\n\t\t\t     _ForwardIterator __first, _ForwardIterator __last)\n\t{\n\t  pointer __result = this->_M_allocate(__n);\n\t  __try\n\t    {\n\t      std::__uninitialized_copy_a(__first, __last, __result,\n\t\t\t\t\t  _M_get_Tp_allocator());\n\t      return __result;\n\t    }\n\t  __catch(...)\n\t    {\n\t      _M_deallocate(__result, __n);\n\t      __throw_exception_again;\n\t    }\n\t}\n\n\n      // Internal constructor functions follow.\n\n      // Called by the range constructor to implement [23.1.1]/9\n\n      // _GLIBCXX_RESOLVE_LIB_DEFECTS\n      // 438. Ambiguity in the \"do the right thing\" clause\n      template<typename _Integer>\n\tvoid\n\t_M_initialize_dispatch(_Integer __n, _Integer __value, __true_type)\n\t{\n\t  this->_M_impl._M_start = _M_allocate(static_cast<size_type>(__n));\n\t  this->_M_impl._M_end_of_storage =\n\t    this->_M_impl._M_start + static_cast<size_type>(__n);\n\t  _M_fill_initialize(static_cast<size_type>(__n), __value);\n\t}\n\n      // Called by the range constructor to implement [23.1.1]/9\n      template<typename _InputIterator>\n\tvoid\n\t_M_initialize_dispatch(_InputIterator __first, _InputIterator __last,\n\t\t\t       __false_type)\n\t{\n\t  typedef typename std::iterator_traits<_InputIterator>::\n\t    iterator_category _IterCategory;\n\t  _M_range_initialize(__first, __last, _IterCategory());\n\t}\n\n      // Called by the second initialize_dispatch above\n      template<typename _InputIterator>\n\tvoid\n\t_M_range_initialize(_InputIterator __first, _InputIterator __last,\n\t\t\t    std::input_iterator_tag)\n\t{\n\t  __try {\n\t    for (; __first != __last; ++__first)\n#if __cplusplus >= 201103L\n\t      emplace_back(*__first);\n#else\n\t      push_back(*__first);\n#endif\n\t  } __catch(...) {\n\t    clear();\n\t    __throw_exception_again;\n\t  }\n\t}\n\n      // Called by the second initialize_dispatch above\n      template<typename _ForwardIterator>\n\tvoid\n\t_M_range_initialize(_ForwardIterator __first, _ForwardIterator __last,\n\t\t\t    std::forward_iterator_tag)\n\t{\n\t  const size_type __n = std::distance(__first, __last);\n\t  this->_M_impl._M_start = this->_M_allocate(__n);\n\t  this->_M_impl._M_end_of_storage = this->_M_impl._M_start + __n;\n\t  this->_M_impl._M_finish =\n\t    std::__uninitialized_copy_a(__first, __last,\n\t\t\t\t\tthis->_M_impl._M_start,\n\t\t\t\t\t_M_get_Tp_allocator());\n\t}\n\n      // Called by the first initialize_dispatch above and by the\n      // vector(n,value,a) constructor.\n      void\n      _M_fill_initialize(size_type __n, const value_type& __value)\n      {\n\tthis->_M_impl._M_finish =\n\t  std::__uninitialized_fill_n_a(this->_M_impl._M_start, __n, __value,\n\t\t\t\t\t_M_get_Tp_allocator());\n      }\n\n#if __cplusplus >= 201103L\n      // Called by the vector(n) constructor.\n      void\n      _M_default_initialize(size_type __n)\n      {\n\tthis->_M_impl._M_finish =\n\t  std::__uninitialized_default_n_a(this->_M_impl._M_start, __n,\n\t\t\t\t\t   _M_get_Tp_allocator());\n      }\n#endif\n\n      // Internal assign functions follow.  The *_aux functions do the actual\n      // assignment work for the range versions.\n\n      // Called by the range assign to implement [23.1.1]/9\n\n      // _GLIBCXX_RESOLVE_LIB_DEFECTS\n      // 438. Ambiguity in the \"do the right thing\" clause\n      template<typename _Integer>\n\tvoid\n\t_M_assign_dispatch(_Integer __n, _Integer __val, __true_type)\n\t{ _M_fill_assign(__n, __val); }\n\n      // Called by the range assign to implement [23.1.1]/9\n      template<typename _InputIterator>\n\tvoid\n\t_M_assign_dispatch(_InputIterator __first, _InputIterator __last,\n\t\t\t   __false_type)\n\t{ _M_assign_aux(__first, __last, std::__iterator_category(__first)); }\n\n      // Called by the second assign_dispatch above\n      template<typename _InputIterator>\n\tvoid\n\t_M_assign_aux(_InputIterator __first, _InputIterator __last,\n\t\t      std::input_iterator_tag);\n\n      // Called by the second assign_dispatch above\n      template<typename _ForwardIterator>\n\tvoid\n\t_M_assign_aux(_ForwardIterator __first, _ForwardIterator __last,\n\t\t      std::forward_iterator_tag);\n\n      // Called by assign(n,t), and the range assign when it turns out\n      // to be the same thing.\n      void\n      _M_fill_assign(size_type __n, const value_type& __val);\n\n      // Internal insert functions follow.\n\n      // Called by the range insert to implement [23.1.1]/9\n\n      // _GLIBCXX_RESOLVE_LIB_DEFECTS\n      // 438. Ambiguity in the \"do the right thing\" clause\n      template<typename _Integer>\n\tvoid\n\t_M_insert_dispatch(iterator __pos, _Integer __n, _Integer __val,\n\t\t\t   __true_type)\n\t{ _M_fill_insert(__pos, __n, __val); }\n\n      // Called by the range insert to implement [23.1.1]/9\n      template<typename _InputIterator>\n\tvoid\n\t_M_insert_dispatch(iterator __pos, _InputIterator __first,\n\t\t\t   _InputIterator __last, __false_type)\n\t{\n\t  _M_range_insert(__pos, __first, __last,\n\t\t\t  std::__iterator_category(__first));\n\t}\n\n      // Called by the second insert_dispatch above\n      template<typename _InputIterator>\n\tvoid\n\t_M_range_insert(iterator __pos, _InputIterator __first,\n\t\t\t_InputIterator __last, std::input_iterator_tag);\n\n      // Called by the second insert_dispatch above\n      template<typename _ForwardIterator>\n\tvoid\n\t_M_range_insert(iterator __pos, _ForwardIterator __first,\n\t\t\t_ForwardIterator __last, std::forward_iterator_tag);\n\n      // Called by insert(p,n,x), and the range insert when it turns out to be\n      // the same thing.\n      void\n      _M_fill_insert(iterator __pos, size_type __n, const value_type& __x);\n\n#if __cplusplus >= 201103L\n      // Called by resize(n).\n      void\n      _M_default_append(size_type __n);\n\n      bool\n      _M_shrink_to_fit();\n#endif\n\n#if __cplusplus < 201103L\n      // Called by insert(p,x)\n      void\n      _M_insert_aux(iterator __position, const value_type& __x);\n\n      void\n      _M_realloc_insert(iterator __position, const value_type& __x);\n#else\n      // A value_type object constructed with _Alloc_traits::construct()\n      // and destroyed with _Alloc_traits::destroy().\n      struct _Temporary_value\n      {\n\ttemplate<typename... _Args>\n\t  explicit\n\t  _Temporary_value(vector* __vec, _Args&&... __args) : _M_this(__vec)\n\t  {\n\t    _Alloc_traits::construct(_M_this->_M_impl, _M_ptr(),\n\t\t\t\t     std::forward<_Args>(__args)...);\n\t  }\n\n\t~_Temporary_value()\n\t{ _Alloc_traits::destroy(_M_this->_M_impl, _M_ptr()); }\n\n\tvalue_type&\n\t_M_val() { return *reinterpret_cast<_Tp*>(&__buf); }\n\n      private:\n\tpointer\n\t_M_ptr() { return pointer_traits<pointer>::pointer_to(_M_val()); }\n\n\tvector* _M_this;\n\ttypename aligned_storage<sizeof(_Tp), alignof(_Tp)>::type __buf;\n      };\n\n      // Called by insert(p,x) and other functions when insertion needs to\n      // reallocate or move existing elements. _Arg is either _Tp& or _Tp.\n      template<typename _Arg>\n\tvoid\n\t_M_insert_aux(iterator __position, _Arg&& __arg);\n\n      template<typename... _Args>\n\tvoid\n\t_M_realloc_insert(iterator __position, _Args&&... __args);\n\n      // Either move-construct at the end, or forward to _M_insert_aux.\n      iterator\n      _M_insert_rval(const_iterator __position, value_type&& __v);\n\n      // Try to emplace at the end, otherwise forward to _M_insert_aux.\n      template<typename... _Args>\n\titerator\n\t_M_emplace_aux(const_iterator __position, _Args&&... __args);\n\n      // Emplacing an rvalue of the correct type can use _M_insert_rval.\n      iterator\n      _M_emplace_aux(const_iterator __position, value_type&& __v)\n      { return _M_insert_rval(__position, std::move(__v)); }\n#endif\n\n      // Called by _M_fill_insert, _M_insert_aux etc.\n      size_type\n      _M_check_len(size_type __n, const char* __s) const\n      {\n\tif (max_size() - size() < __n)\n\t  __throw_length_error(__N(__s));\n\n\tconst size_type __len = size() + std::max(size(), __n);\n\treturn (__len < size() || __len > max_size()) ? max_size() : __len;\n      }\n\n      // Internal erase functions follow.\n\n      // Called by erase(q1,q2), clear(), resize(), _M_fill_assign,\n      // _M_assign_aux.\n      void\n      _M_erase_at_end(pointer __pos) _GLIBCXX_NOEXCEPT\n      {\n\tstd::_Destroy(__pos, this->_M_impl._M_finish, _M_get_Tp_allocator());\n\tthis->_M_impl._M_finish = __pos;\n      }\n\n      iterator\n      _M_erase(iterator __position);\n\n      iterator\n      _M_erase(iterator __first, iterator __last);\n\n#if __cplusplus >= 201103L\n    private:\n      // Constant-time move assignment when source object's memory can be\n      // moved, either because the source's allocator will move too\n      // or because the allocators are equal.\n      void\n      _M_move_assign(vector&& __x, std::true_type) noexcept\n      {\n\tvector __tmp(get_allocator());\n\tthis->_M_impl._M_swap_data(__tmp._M_impl);\n\tthis->_M_impl._M_swap_data(__x._M_impl);\n\tstd::__alloc_on_move(_M_get_Tp_allocator(), __x._M_get_Tp_allocator());\n      }\n\n      // Do move assignment when it might not be possible to move source\n      // object's memory, resulting in a linear-time operation.\n      void\n      _M_move_assign(vector&& __x, std::false_type)\n      {\n\tif (__x._M_get_Tp_allocator() == this->_M_get_Tp_allocator())\n\t  _M_move_assign(std::move(__x), std::true_type());\n\telse\n\t  {\n\t    // The rvalue's allocator cannot be moved and is not equal,\n\t    // so we need to individually move each element.\n\t    this->assign(std::__make_move_if_noexcept_iterator(__x.begin()),\n\t\t\t std::__make_move_if_noexcept_iterator(__x.end()));\n\t    __x.clear();\n\t  }\n      }\n#endif\n\n      template<typename _Up>\n\t_Up*\n\t_M_data_ptr(_Up* __ptr) const _GLIBCXX_NOEXCEPT\n\t{ return __ptr; }\n\n#if __cplusplus >= 201103L\n      template<typename _Ptr>\n\ttypename std::pointer_traits<_Ptr>::element_type*\n\t_M_data_ptr(_Ptr __ptr) const\n\t{ return empty() ? nullptr : std::__addressof(*__ptr); }\n#else\n      template<typename _Up>\n\t_Up*\n\t_M_data_ptr(_Up* __ptr) _GLIBCXX_NOEXCEPT\n\t{ return __ptr; }\n\n      template<typename _Ptr>\n\tvalue_type*\n\t_M_data_ptr(_Ptr __ptr)\n\t{ return __ptr.operator->(); }\n\n      template<typename _Ptr>\n\tconst value_type*\n\t_M_data_ptr(_Ptr __ptr) const\n\t{ return __ptr.operator->(); }\n#endif\n    };\n\n\n  /**\n   *  @brief  Vector equality comparison.\n   *  @param  __x  A %vector.\n   *  @param  __y  A %vector of the same type as @a __x.\n   *  @return  True iff the size and elements of the vectors are equal.\n   *\n   *  This is an equivalence relation.  It is linear in the size of the\n   *  vectors.  Vectors are considered equivalent if their sizes are equal,\n   *  and if corresponding elements compare equal.\n  */\n  template<typename _Tp, typename _Alloc>\n    inline bool\n    operator==(const vector<_Tp, _Alloc>& __x, const vector<_Tp, _Alloc>& __y)\n    { return (__x.size() == __y.size()\n\t      && std::equal(__x.begin(), __x.end(), __y.begin())); }\n\n  /**\n   *  @brief  Vector ordering relation.\n   *  @param  __x  A %vector.\n   *  @param  __y  A %vector of the same type as @a __x.\n   *  @return  True iff @a __x is lexicographically less than @a __y.\n   *\n   *  This is a total ordering relation.  It is linear in the size of the\n   *  vectors.  The elements must be comparable with @c <.\n   *\n   *  See std::lexicographical_compare() for how the determination is made.\n  */\n  template<typename _Tp, typename _Alloc>\n    inline bool\n    operator<(const vector<_Tp, _Alloc>& __x, const vector<_Tp, _Alloc>& __y)\n    { return std::lexicographical_compare(__x.begin(), __x.end(),\n\t\t\t\t\t  __y.begin(), __y.end()); }\n\n  /// Based on operator==\n  template<typename _Tp, typename _Alloc>\n    inline bool\n    operator!=(const vector<_Tp, _Alloc>& __x, const vector<_Tp, _Alloc>& __y)\n    { return !(__x == __y); }\n\n  /// Based on operator<\n  template<typename _Tp, typename _Alloc>\n    inline bool\n    operator>(const vector<_Tp, _Alloc>& __x, const vector<_Tp, _Alloc>& __y)\n    { return __y < __x; }\n\n  /// Based on operator<\n  template<typename _Tp, typename _Alloc>\n    inline bool\n    operator<=(const vector<_Tp, _Alloc>& __x, const vector<_Tp, _Alloc>& __y)\n    { return !(__y < __x); }\n\n  /// Based on operator<\n  template<typename _Tp, typename _Alloc>\n    inline bool\n    operator>=(const vector<_Tp, _Alloc>& __x, const vector<_Tp, _Alloc>& __y)\n    { return !(__x < __y); }\n\n  /// See std::vector::swap().\n  template<typename _Tp, typename _Alloc>\n    inline void\n    swap(vector<_Tp, _Alloc>& __x, vector<_Tp, _Alloc>& __y)\n    _GLIBCXX_NOEXCEPT_IF(noexcept(__x.swap(__y)))\n    { __x.swap(__y); }\n\n_GLIBCXX_END_NAMESPACE_CONTAINER\n} // namespace std\n\n#endif /* _STL_VECTOR_H */\n"}, "28": {"id": 28, "path": "/home/runner/work/testcc/testcc/retdec/pdns/dnspacket.hh", "content": "/*\n * This file is part of PowerDNS or dnsdist.\n * Copyright -- PowerDNS.COM B.V. and its contributors\n *\n * This program is free software; you can redistribute it and/or modify\n * it under the terms of version 2 of the GNU General Public License as\n * published by the Free Software Foundation.\n *\n * In addition, for the avoidance of any doubt, permission is granted to\n * link this program with OpenSSL and to (re)distribute the binaries\n * produced as the result of such linking.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with this program; if not, write to the Free Software\n * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.\n */\n#pragma once\n#include <cstdio>\n#include <cstring>\n#include <cstdlib>\n#include <sys/types.h>\n#include \"iputils.hh\"\n#include \"ednssubnet.hh\"\n#include <unordered_set>\n#include <sys/socket.h>\n#include <netinet/in.h>\n#include <sys/time.h>\n#include <unistd.h>\n#include <arpa/inet.h>\n\n#include <iostream>\n#include <string>\n#include <vector>\n#include \"qtype.hh\"\n#include \"dns.hh\"\n#include \"misc.hh\"\n#include \"utility.hh\"\n#include \"logger.hh\"\n#include \"pdnsexception.hh\"\n#include \"dnsrecords.hh\"\n\nclass UeberBackend;\nclass DNSSECKeeper;\n\n\n//! This class represents DNS packets, either received or to be sent.\nclass DNSPacket\n{\npublic:\n  DNSPacket(bool isQuery);\n  DNSPacket(const DNSPacket &orig) = default;\n  DNSPacket & operator=(const DNSPacket &) = default;\n\n  int noparse(const char *mesg, size_t len); //!< just suck the data inward\n  int parse(const char *mesg, size_t len); //!< parse a raw UDP or TCP packet and suck the data inward\n  const string& getString(); //!< for serialization - just passes the whole packet\n\n  // address & socket manipulation\n  void setRemote(const ComboAddress*);\n  ComboAddress getRemote() const;\n  Netmask getRealRemote() const;\n  ComboAddress getLocal() const\n  {\n    ComboAddress ca;\n    socklen_t len=sizeof(ca);\n    getsockname(d_socket, (sockaddr*)&ca, &len);\n    return ca;\n  }\n  uint16_t getRemotePort() const;\n\n  boost::optional<ComboAddress> d_anyLocal;\n\n  Utility::sock_t getSocket() const\n  {\n    return d_socket;\n  }\n  void setSocket(Utility::sock_t sock);\n\n\n  // these manipulate 'd'\n  void setA(bool); //!< make this packet authoritative - manipulates 'd'\n  void setID(uint16_t); //!< set the DNS id of this packet - manipulates 'd'\n  void setRA(bool); //!< set the Recursion Available flag - manipulates 'd'\n  void setRD(bool); //!< set the Recursion Desired flag - manipulates 'd'\n  void setAnswer(bool); //!< Make this packet an answer - clears the 'stringbuffer' first, if passed 'true', does nothing otherwise, manipulates 'd'\n\n  void setOpcode(uint16_t);  //!< set the Opcode of this packet - manipulates 'd'\n  void setRcode(int v); //!< set the Rcode of this packet - manipulates 'd'\n\n  void clearRecords(); //!< when building a packet, wipe all previously added records (clears 'rrs')\n\n  /** Add a DNSZoneRecord to this packet. A DNSPacket (as does a DNS Packet) has 4 kinds of resource records. Questions, \n      Answers, Authority and Additional. See RFC 1034 and 1035 for details. You can specify where a record needs to go in the\n      DNSZoneRecord d_place field */\n  void addRecord(DNSZoneRecord&&);  // adds to 'rrs'\n\n  void setQuestion(int op, const DNSName &qdomain, int qtype);  // wipes 'd', sets a random id, creates start of packet (domain, type, class etc)\n\n  DTime d_dt; //!< the time this packet was created. replyPacket() copies this in for you, so d_dt becomes the time spent processing the question+answer\n  void wrapup();  // writes out queued rrs, and generates the binary packet. also shuffles. also rectifies dnsheader 'd', and copies it to the stringbuffer\n  void spoofQuestion(const DNSPacket& qd); //!< paste in the exact right case of the question. Useful for PacketCache\n  unsigned int getMinTTL(); //!< returns lowest TTL of any record in the packet\n  bool isEmpty(); //!< returns true if there are no rrs in the packet\n\n  vector<DNSZoneRecord*> getAPRecords(); //!< get a vector with DNSZoneRecords that need additional processing\n  vector<DNSZoneRecord*> getAnswerRecords(); //!< get a vector with DNSZoneRecords that are answers\n  void setCompress(bool compress);\n\n  std::unique_ptr<DNSPacket> replyPacket() const; //!< convenience function that creates a virgin answer packet to this question\n\n  void commitD(); //!< copies 'd' into the stringbuffer\n  unsigned int getMaxReplyLen(); //!< retrieve the maximum length of the packet we should send in response\n  void setMaxReplyLen(int bytes); //!< set the max reply len (used when retrieving from the packet cache, and this changed)\n\n  bool couldBeCached() const; //!< returns 0 if this query should bypass the packet cache\n  bool hasEDNSSubnet() const;\n  bool hasEDNS() const;\n  uint8_t getEDNSVersion() const { return d_ednsversion; };\n  void setEDNSRcode(uint16_t extRCode)\n  {\n    // WARNING: this is really 12 bits\n    d_ednsrcode=extRCode;\n  };\n  uint8_t getEDNSRCode() const { return d_ednsrcode; };\n  uint32_t getHash() const { return d_hash; };\n  void setHash(uint32_t hash) { d_hash = hash; };\n\n  //////// DATA !\n\n  DNSName qdomain;  //!< qname of the question 4 - unsure how this is used\n  DNSName qdomainwild;  //!< wildcard matched by qname, used by LuaPolicyEngine\n  DNSName qdomainzone;  //!< zone name for the answer (as reflected in SOA for negative responses), used by LuaPolicyEngine\n  string d_peer_principal;\n  const DNSName& getTSIGKeyname() const;\n\n  struct dnsheader d; //!< dnsheader at the start of the databuffer 12\n\n  TSIGRecordContent d_trc; //72\n\n  ComboAddress d_remote; //28\n  TSIGHashEnum d_tsig_algo{TSIG_MD5}; //4\n\n  int d_ednsRawPacketSizeLimit{-1}; // only used for Lua record\n  uint16_t qclass{QClass::IN};  //!< class of the question - should always be INternet 2\n  QType qtype;  //!< type of the question 2\n\n  bool d_tcp{false};\n  bool d_dnssecOk{false};\n  bool d_havetsig{false};\n\n  bool getTSIGDetails(TSIGRecordContent* tr, DNSName* keyname, uint16_t* tsigPos=nullptr) const;\n  void setTSIGDetails(const TSIGRecordContent& tr, const DNSName& keyname, const string& secret, const string& previous, bool timersonly=false);\n  bool getTKEYRecord(TKEYRecordContent* tr, DNSName* keyname) const;\n\n  vector<DNSZoneRecord>& getRRS() { return d_rrs; }\n  bool checkForCorrectTSIG(UeberBackend* B, DNSName* keyname, string* secret, TSIGRecordContent* trc) const;\n\n  static uint16_t s_udpTruncationThreshold; \n  static bool s_doEDNSSubnetProcessing;\n\nprivate:\n  void pasteQ(const char *question, int length); //!< set the question of this packet, useful for crafting replies\n\n  string d_tsigsecret;\n  DNSName d_tsigkeyname;\n  string d_tsigprevious;\n\n  vector<DNSZoneRecord> d_rrs; // 8\n  std::unordered_set<size_t> d_dedup;\n  string d_rawpacket; // this is where everything lives 8\n  EDNSSubnetOpts d_eso;\n\n  int d_maxreplylen{0};\n  int d_socket{-1}; // 4\n  uint32_t d_hash{0};\n  // WARNING! This is really 12 bits\n  uint16_t d_ednsrcode{0};\n  uint8_t d_ednsversion{0};\n\n  bool d_wrapped{false}; // 1\n  bool d_compress{true}; // 1\n  bool d_tsigtimersonly{false};\n  bool d_wantsnsid{false};\n  bool d_haveednssubnet{false};\n  bool d_haveednssection{false};\n  bool d_isQuery;\n};\n"}, "29": {"id": 29, "path": "/usr/include/netinet/in.h", "content": "/* Copyright (C) 1991-2018 Free Software Foundation, Inc.\n   This file is part of the GNU C Library.\n\n   The GNU C Library is free software; you can redistribute it and/or\n   modify it under the terms of the GNU Lesser General Public\n   License as published by the Free Software Foundation; either\n   version 2.1 of the License, or (at your option) any later version.\n\n   The GNU C Library is distributed in the hope that it will be useful,\n   but WITHOUT ANY WARRANTY; without even the implied warranty of\n   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n   Lesser General Public License for more details.\n\n   You should have received a copy of the GNU Lesser General Public\n   License along with the GNU C Library; if not, see\n   <http://www.gnu.org/licenses/>.  */\n\n#ifndef\t_NETINET_IN_H\n#define\t_NETINET_IN_H\t1\n\n#include <features.h>\n#include <bits/stdint-uintn.h>\n#include <sys/socket.h>\n#include <bits/types.h>\n\n\n__BEGIN_DECLS\n\n/* Internet address.  */\ntypedef uint32_t in_addr_t;\nstruct in_addr\n  {\n    in_addr_t s_addr;\n  };\n\n/* Get system-specific definitions.  */\n#include <bits/in.h>\n\n/* Standard well-defined IP protocols.  */\nenum\n  {\n    IPPROTO_IP = 0,\t   /* Dummy protocol for TCP.  */\n#define IPPROTO_IP\t\tIPPROTO_IP\n    IPPROTO_ICMP = 1,\t   /* Internet Control Message Protocol.  */\n#define IPPROTO_ICMP\t\tIPPROTO_ICMP\n    IPPROTO_IGMP = 2,\t   /* Internet Group Management Protocol. */\n#define IPPROTO_IGMP\t\tIPPROTO_IGMP\n    IPPROTO_IPIP = 4,\t   /* IPIP tunnels (older KA9Q tunnels use 94).  */\n#define IPPROTO_IPIP\t\tIPPROTO_IPIP\n    IPPROTO_TCP = 6,\t   /* Transmission Control Protocol.  */\n#define IPPROTO_TCP\t\tIPPROTO_TCP\n    IPPROTO_EGP = 8,\t   /* Exterior Gateway Protocol.  */\n#define IPPROTO_EGP\t\tIPPROTO_EGP\n    IPPROTO_PUP = 12,\t   /* PUP protocol.  */\n#define IPPROTO_PUP\t\tIPPROTO_PUP\n    IPPROTO_UDP = 17,\t   /* User Datagram Protocol.  */\n#define IPPROTO_UDP\t\tIPPROTO_UDP\n    IPPROTO_IDP = 22,\t   /* XNS IDP protocol.  */\n#define IPPROTO_IDP\t\tIPPROTO_IDP\n    IPPROTO_TP = 29,\t   /* SO Transport Protocol Class 4.  */\n#define IPPROTO_TP\t\tIPPROTO_TP\n    IPPROTO_DCCP = 33,\t   /* Datagram Congestion Control Protocol.  */\n#define IPPROTO_DCCP\t\tIPPROTO_DCCP\n    IPPROTO_IPV6 = 41,     /* IPv6 header.  */\n#define IPPROTO_IPV6\t\tIPPROTO_IPV6\n    IPPROTO_RSVP = 46,\t   /* Reservation Protocol.  */\n#define IPPROTO_RSVP\t\tIPPROTO_RSVP\n    IPPROTO_GRE = 47,\t   /* General Routing Encapsulation.  */\n#define IPPROTO_GRE\t\tIPPROTO_GRE\n    IPPROTO_ESP = 50,      /* encapsulating security payload.  */\n#define IPPROTO_ESP\t\tIPPROTO_ESP\n    IPPROTO_AH = 51,       /* authentication header.  */\n#define IPPROTO_AH\t\tIPPROTO_AH\n    IPPROTO_MTP = 92,\t   /* Multicast Transport Protocol.  */\n#define IPPROTO_MTP\t\tIPPROTO_MTP\n    IPPROTO_BEETPH = 94,   /* IP option pseudo header for BEET.  */\n#define IPPROTO_BEETPH\t\tIPPROTO_BEETPH\n    IPPROTO_ENCAP = 98,\t   /* Encapsulation Header.  */\n#define IPPROTO_ENCAP\t\tIPPROTO_ENCAP\n    IPPROTO_PIM = 103,\t   /* Protocol Independent Multicast.  */\n#define IPPROTO_PIM\t\tIPPROTO_PIM\n    IPPROTO_COMP = 108,\t   /* Compression Header Protocol.  */\n#define IPPROTO_COMP\t\tIPPROTO_COMP\n    IPPROTO_SCTP = 132,\t   /* Stream Control Transmission Protocol.  */\n#define IPPROTO_SCTP\t\tIPPROTO_SCTP\n    IPPROTO_UDPLITE = 136, /* UDP-Lite protocol.  */\n#define IPPROTO_UDPLITE\t\tIPPROTO_UDPLITE\n    IPPROTO_MPLS = 137,    /* MPLS in IP.  */\n#define IPPROTO_MPLS\t\tIPPROTO_MPLS\n    IPPROTO_RAW = 255,\t   /* Raw IP packets.  */\n#define IPPROTO_RAW\t\tIPPROTO_RAW\n    IPPROTO_MAX\n  };\n\n/* If __USE_KERNEL_IPV6_DEFS is 1 then the user has included the kernel\n   network headers first and we should use those ABI-identical definitions\n   instead of our own, otherwise 0.  */\n#if !__USE_KERNEL_IPV6_DEFS\nenum\n  {\n    IPPROTO_HOPOPTS = 0,   /* IPv6 Hop-by-Hop options.  */\n#define IPPROTO_HOPOPTS\t\tIPPROTO_HOPOPTS\n    IPPROTO_ROUTING = 43,  /* IPv6 routing header.  */\n#define IPPROTO_ROUTING\t\tIPPROTO_ROUTING\n    IPPROTO_FRAGMENT = 44, /* IPv6 fragmentation header.  */\n#define IPPROTO_FRAGMENT\tIPPROTO_FRAGMENT\n    IPPROTO_ICMPV6 = 58,   /* ICMPv6.  */\n#define IPPROTO_ICMPV6\t\tIPPROTO_ICMPV6\n    IPPROTO_NONE = 59,     /* IPv6 no next header.  */\n#define IPPROTO_NONE\t\tIPPROTO_NONE\n    IPPROTO_DSTOPTS = 60,  /* IPv6 destination options.  */\n#define IPPROTO_DSTOPTS\t\tIPPROTO_DSTOPTS\n    IPPROTO_MH = 135       /* IPv6 mobility header.  */\n#define IPPROTO_MH\t\tIPPROTO_MH\n  };\n#endif /* !__USE_KERNEL_IPV6_DEFS */\n\n/* Type to represent a port.  */\ntypedef uint16_t in_port_t;\n\n/* Standard well-known ports.  */\nenum\n  {\n    IPPORT_ECHO = 7,\t\t/* Echo service.  */\n    IPPORT_DISCARD = 9,\t\t/* Discard transmissions service.  */\n    IPPORT_SYSTAT = 11,\t\t/* System status service.  */\n    IPPORT_DAYTIME = 13,\t/* Time of day service.  */\n    IPPORT_NETSTAT = 15,\t/* Network status service.  */\n    IPPORT_FTP = 21,\t\t/* File Transfer Protocol.  */\n    IPPORT_TELNET = 23,\t\t/* Telnet protocol.  */\n    IPPORT_SMTP = 25,\t\t/* Simple Mail Transfer Protocol.  */\n    IPPORT_TIMESERVER = 37,\t/* Timeserver service.  */\n    IPPORT_NAMESERVER = 42,\t/* Domain Name Service.  */\n    IPPORT_WHOIS = 43,\t\t/* Internet Whois service.  */\n    IPPORT_MTP = 57,\n\n    IPPORT_TFTP = 69,\t\t/* Trivial File Transfer Protocol.  */\n    IPPORT_RJE = 77,\n    IPPORT_FINGER = 79,\t\t/* Finger service.  */\n    IPPORT_TTYLINK = 87,\n    IPPORT_SUPDUP = 95,\t\t/* SUPDUP protocol.  */\n\n\n    IPPORT_EXECSERVER = 512,\t/* execd service.  */\n    IPPORT_LOGINSERVER = 513,\t/* rlogind service.  */\n    IPPORT_CMDSERVER = 514,\n    IPPORT_EFSSERVER = 520,\n\n    /* UDP ports.  */\n    IPPORT_BIFFUDP = 512,\n    IPPORT_WHOSERVER = 513,\n    IPPORT_ROUTESERVER = 520,\n\n    /* Ports less than this value are reserved for privileged processes.  */\n    IPPORT_RESERVED = 1024,\n\n    /* Ports greater this value are reserved for (non-privileged) servers.  */\n    IPPORT_USERRESERVED = 5000\n  };\n\n/* Definitions of the bits in an Internet address integer.\n\n   On subnets, host and network parts are found according to\n   the subnet mask, not these masks.  */\n\n#define\tIN_CLASSA(a)\t\t((((in_addr_t)(a)) & 0x80000000) == 0)\n#define\tIN_CLASSA_NET\t\t0xff000000\n#define\tIN_CLASSA_NSHIFT\t24\n#define\tIN_CLASSA_HOST\t\t(0xffffffff & ~IN_CLASSA_NET)\n#define\tIN_CLASSA_MAX\t\t128\n\n#define\tIN_CLASSB(a)\t\t((((in_addr_t)(a)) & 0xc0000000) == 0x80000000)\n#define\tIN_CLASSB_NET\t\t0xffff0000\n#define\tIN_CLASSB_NSHIFT\t16\n#define\tIN_CLASSB_HOST\t\t(0xffffffff & ~IN_CLASSB_NET)\n#define\tIN_CLASSB_MAX\t\t65536\n\n#define\tIN_CLASSC(a)\t\t((((in_addr_t)(a)) & 0xe0000000) == 0xc0000000)\n#define\tIN_CLASSC_NET\t\t0xffffff00\n#define\tIN_CLASSC_NSHIFT\t8\n#define\tIN_CLASSC_HOST\t\t(0xffffffff & ~IN_CLASSC_NET)\n\n#define\tIN_CLASSD(a)\t\t((((in_addr_t)(a)) & 0xf0000000) == 0xe0000000)\n#define\tIN_MULTICAST(a)\t\tIN_CLASSD(a)\n\n#define\tIN_EXPERIMENTAL(a)\t((((in_addr_t)(a)) & 0xe0000000) == 0xe0000000)\n#define\tIN_BADCLASS(a)\t\t((((in_addr_t)(a)) & 0xf0000000) == 0xf0000000)\n\n/* Address to accept any incoming messages.  */\n#define\tINADDR_ANY\t\t((in_addr_t) 0x00000000)\n/* Address to send to all hosts.  */\n#define\tINADDR_BROADCAST\t((in_addr_t) 0xffffffff)\n/* Address indicating an error return.  */\n#define\tINADDR_NONE\t\t((in_addr_t) 0xffffffff)\n\n/* Network number for local host loopback.  */\n#define\tIN_LOOPBACKNET\t\t127\n/* Address to loopback in software to local host.  */\n#ifndef INADDR_LOOPBACK\n# define INADDR_LOOPBACK\t((in_addr_t) 0x7f000001) /* Inet 127.0.0.1.  */\n#endif\n\n/* Defines for Multicast INADDR.  */\n#define INADDR_UNSPEC_GROUP\t((in_addr_t) 0xe0000000) /* 224.0.0.0 */\n#define INADDR_ALLHOSTS_GROUP\t((in_addr_t) 0xe0000001) /* 224.0.0.1 */\n#define INADDR_ALLRTRS_GROUP    ((in_addr_t) 0xe0000002) /* 224.0.0.2 */\n#define INADDR_MAX_LOCAL_GROUP  ((in_addr_t) 0xe00000ff) /* 224.0.0.255 */\n\n#if !__USE_KERNEL_IPV6_DEFS\n/* IPv6 address */\nstruct in6_addr\n  {\n    union\n      {\n\tuint8_t\t__u6_addr8[16];\n\tuint16_t __u6_addr16[8];\n\tuint32_t __u6_addr32[4];\n      } __in6_u;\n#define s6_addr\t\t\t__in6_u.__u6_addr8\n#ifdef __USE_MISC\n# define s6_addr16\t\t__in6_u.__u6_addr16\n# define s6_addr32\t\t__in6_u.__u6_addr32\n#endif\n  };\n#endif /* !__USE_KERNEL_IPV6_DEFS */\n\nextern const struct in6_addr in6addr_any;        /* :: */\nextern const struct in6_addr in6addr_loopback;   /* ::1 */\n#define IN6ADDR_ANY_INIT { { { 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0 } } }\n#define IN6ADDR_LOOPBACK_INIT { { { 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1 } } }\n\n#define INET_ADDRSTRLEN 16\n#define INET6_ADDRSTRLEN 46\n\n\n/* Structure describing an Internet socket address.  */\nstruct sockaddr_in\n  {\n    __SOCKADDR_COMMON (sin_);\n    in_port_t sin_port;\t\t\t/* Port number.  */\n    struct in_addr sin_addr;\t\t/* Internet address.  */\n\n    /* Pad to size of `struct sockaddr'.  */\n    unsigned char sin_zero[sizeof (struct sockaddr) -\n\t\t\t   __SOCKADDR_COMMON_SIZE -\n\t\t\t   sizeof (in_port_t) -\n\t\t\t   sizeof (struct in_addr)];\n  };\n\n#if !__USE_KERNEL_IPV6_DEFS\n/* Ditto, for IPv6.  */\nstruct sockaddr_in6\n  {\n    __SOCKADDR_COMMON (sin6_);\n    in_port_t sin6_port;\t/* Transport layer port # */\n    uint32_t sin6_flowinfo;\t/* IPv6 flow information */\n    struct in6_addr sin6_addr;\t/* IPv6 address */\n    uint32_t sin6_scope_id;\t/* IPv6 scope-id */\n  };\n#endif /* !__USE_KERNEL_IPV6_DEFS */\n\n#ifdef __USE_MISC\n/* IPv4 multicast request.  */\nstruct ip_mreq\n  {\n    /* IP multicast address of group.  */\n    struct in_addr imr_multiaddr;\n\n    /* Local IP address of interface.  */\n    struct in_addr imr_interface;\n  };\n\nstruct ip_mreq_source\n  {\n    /* IP multicast address of group.  */\n    struct in_addr imr_multiaddr;\n\n    /* IP address of interface.  */\n    struct in_addr imr_interface;\n\n    /* IP address of source.  */\n    struct in_addr imr_sourceaddr;\n  };\n#endif\n\n#if !__USE_KERNEL_IPV6_DEFS\n/* Likewise, for IPv6.  */\nstruct ipv6_mreq\n  {\n    /* IPv6 multicast address of group */\n    struct in6_addr ipv6mr_multiaddr;\n\n    /* local interface */\n    unsigned int ipv6mr_interface;\n  };\n#endif /* !__USE_KERNEL_IPV6_DEFS */\n\n#ifdef __USE_MISC\n/* Multicast group request.  */\nstruct group_req\n  {\n    /* Interface index.  */\n    uint32_t gr_interface;\n\n    /* Group address.  */\n    struct sockaddr_storage gr_group;\n  };\n\nstruct group_source_req\n  {\n    /* Interface index.  */\n    uint32_t gsr_interface;\n\n    /* Group address.  */\n    struct sockaddr_storage gsr_group;\n\n    /* Source address.  */\n    struct sockaddr_storage gsr_source;\n  };\n\n\n/* Full-state filter operations.  */\nstruct ip_msfilter\n  {\n    /* IP multicast address of group.  */\n    struct in_addr imsf_multiaddr;\n\n    /* Local IP address of interface.  */\n    struct in_addr imsf_interface;\n\n    /* Filter mode.  */\n    uint32_t imsf_fmode;\n\n    /* Number of source addresses.  */\n    uint32_t imsf_numsrc;\n    /* Source addresses.  */\n    struct in_addr imsf_slist[1];\n  };\n\n#define IP_MSFILTER_SIZE(numsrc) (sizeof (struct ip_msfilter) \\\n\t\t\t\t  - sizeof (struct in_addr)\t\t      \\\n\t\t\t\t  + (numsrc) * sizeof (struct in_addr))\n\nstruct group_filter\n  {\n    /* Interface index.  */\n    uint32_t gf_interface;\n\n    /* Group address.  */\n    struct sockaddr_storage gf_group;\n\n    /* Filter mode.  */\n    uint32_t gf_fmode;\n\n    /* Number of source addresses.  */\n    uint32_t gf_numsrc;\n    /* Source addresses.  */\n    struct sockaddr_storage gf_slist[1];\n};\n\n#define GROUP_FILTER_SIZE(numsrc) (sizeof (struct group_filter) \\\n\t\t\t\t   - sizeof (struct sockaddr_storage)\t      \\\n\t\t\t\t   + ((numsrc)\t\t\t\t      \\\n\t\t\t\t      * sizeof (struct sockaddr_storage)))\n#endif\n\n/* Functions to convert between host and network byte order.\n\n   Please note that these functions normally take `unsigned long int' or\n   `unsigned short int' values as arguments and also return them.  But\n   this was a short-sighted decision since on different systems the types\n   may have different representations but the values are always the same.  */\n\nextern uint32_t ntohl (uint32_t __netlong) __THROW __attribute__ ((__const__));\nextern uint16_t ntohs (uint16_t __netshort)\n     __THROW __attribute__ ((__const__));\nextern uint32_t htonl (uint32_t __hostlong)\n     __THROW __attribute__ ((__const__));\nextern uint16_t htons (uint16_t __hostshort)\n     __THROW __attribute__ ((__const__));\n\n#include <endian.h>\n\n/* Get machine dependent optimized versions of byte swapping functions.  */\n#include <bits/byteswap.h>\n#include <bits/uintn-identity.h>\n\n#ifdef __OPTIMIZE__\n/* We can optimize calls to the conversion functions.  Either nothing has\n   to be done or we are using directly the byte-swapping functions which\n   often can be inlined.  */\n# if __BYTE_ORDER == __BIG_ENDIAN\n/* The host byte order is the same as network byte order,\n   so these functions are all just identity.  */\n# define ntohl(x)\t__uint32_identity (x)\n# define ntohs(x)\t__uint16_identity (x)\n# define htonl(x)\t__uint32_identity (x)\n# define htons(x)\t__uint16_identity (x)\n# else\n#  if __BYTE_ORDER == __LITTLE_ENDIAN\n#   define ntohl(x)\t__bswap_32 (x)\n#   define ntohs(x)\t__bswap_16 (x)\n#   define htonl(x)\t__bswap_32 (x)\n#   define htons(x)\t__bswap_16 (x)\n#  endif\n# endif\n#endif\n\n#ifdef __GNUC__\n# define IN6_IS_ADDR_UNSPECIFIED(a) \\\n  (__extension__\t\t\t\t\t\t\t      \\\n   ({ const struct in6_addr *__a = (const struct in6_addr *) (a);\t      \\\n      __a->__in6_u.__u6_addr32[0] == 0\t\t\t\t\t      \\\n      && __a->__in6_u.__u6_addr32[1] == 0\t\t\t\t      \\\n      && __a->__in6_u.__u6_addr32[2] == 0\t\t\t\t      \\\n      && __a->__in6_u.__u6_addr32[3] == 0; }))\n\n# define IN6_IS_ADDR_LOOPBACK(a) \\\n  (__extension__\t\t\t\t\t\t\t      \\\n   ({ const struct in6_addr *__a = (const struct in6_addr *) (a);\t      \\\n      __a->__in6_u.__u6_addr32[0] == 0\t\t\t\t\t      \\\n      && __a->__in6_u.__u6_addr32[1] == 0\t\t\t\t      \\\n      && __a->__in6_u.__u6_addr32[2] == 0\t\t\t\t      \\\n      && __a->__in6_u.__u6_addr32[3] == htonl (1); }))\n\n# define IN6_IS_ADDR_LINKLOCAL(a) \\\n  (__extension__\t\t\t\t\t\t\t      \\\n   ({ const struct in6_addr *__a = (const struct in6_addr *) (a);\t      \\\n      (__a->__in6_u.__u6_addr32[0] & htonl (0xffc00000)) == htonl (0xfe800000); }))\n\n# define IN6_IS_ADDR_SITELOCAL(a) \\\n  (__extension__\t\t\t\t\t\t\t      \\\n   ({ const struct in6_addr *__a = (const struct in6_addr *) (a);\t      \\\n      (__a->__in6_u.__u6_addr32[0] & htonl (0xffc00000)) == htonl (0xfec00000); }))\n\n# define IN6_IS_ADDR_V4MAPPED(a) \\\n  (__extension__\t\t\t\t\t\t\t      \\\n   ({ const struct in6_addr *__a = (const struct in6_addr *) (a);\t      \\\n      __a->__in6_u.__u6_addr32[0] == 0\t\t\t\t\t      \\\n      && __a->__in6_u.__u6_addr32[1] == 0\t\t\t\t      \\\n      && __a->__in6_u.__u6_addr32[2] == htonl (0xffff); }))\n\n# define IN6_IS_ADDR_V4COMPAT(a) \\\n  (__extension__\t\t\t\t\t\t\t      \\\n   ({ const struct in6_addr *__a = (const struct in6_addr *) (a);\t      \\\n      __a->__in6_u.__u6_addr32[0] == 0\t\t\t\t\t      \\\n      && __a->__in6_u.__u6_addr32[1] == 0\t\t\t\t      \\\n      && __a->__in6_u.__u6_addr32[2] == 0\t\t\t\t      \\\n      && ntohl (__a->__in6_u.__u6_addr32[3]) > 1; }))\n\n# define IN6_ARE_ADDR_EQUAL(a,b) \\\n  (__extension__\t\t\t\t\t\t\t      \\\n   ({ const struct in6_addr *__a = (const struct in6_addr *) (a);\t      \\\n      const struct in6_addr *__b = (const struct in6_addr *) (b);\t      \\\n      __a->__in6_u.__u6_addr32[0] == __b->__in6_u.__u6_addr32[0]\t      \\\n      && __a->__in6_u.__u6_addr32[1] == __b->__in6_u.__u6_addr32[1]\t      \\\n      && __a->__in6_u.__u6_addr32[2] == __b->__in6_u.__u6_addr32[2]\t      \\\n      && __a->__in6_u.__u6_addr32[3] == __b->__in6_u.__u6_addr32[3]; }))\n#else\n# define IN6_IS_ADDR_UNSPECIFIED(a) \\\n\t(((const uint32_t *) (a))[0] == 0\t\t\t\t      \\\n\t && ((const uint32_t *) (a))[1] == 0\t\t\t\t      \\\n\t && ((const uint32_t *) (a))[2] == 0\t\t\t\t      \\\n\t && ((const uint32_t *) (a))[3] == 0)\n\n# define IN6_IS_ADDR_LOOPBACK(a) \\\n\t(((const uint32_t *) (a))[0] == 0\t\t\t\t      \\\n\t && ((const uint32_t *) (a))[1] == 0\t\t\t\t      \\\n\t && ((const uint32_t *) (a))[2] == 0\t\t\t\t      \\\n\t && ((const uint32_t *) (a))[3] == htonl (1))\n\n# define IN6_IS_ADDR_LINKLOCAL(a) \\\n\t((((const uint32_t *) (a))[0] & htonl (0xffc00000))\t\t      \\\n\t == htonl (0xfe800000))\n\n# define IN6_IS_ADDR_SITELOCAL(a) \\\n\t((((const uint32_t *) (a))[0] & htonl (0xffc00000))\t\t      \\\n\t == htonl (0xfec00000))\n\n# define IN6_IS_ADDR_V4MAPPED(a) \\\n\t((((const uint32_t *) (a))[0] == 0)\t\t\t\t      \\\n\t && (((const uint32_t *) (a))[1] == 0)\t\t\t\t      \\\n\t && (((const uint32_t *) (a))[2] == htonl (0xffff)))\n\n# define IN6_IS_ADDR_V4COMPAT(a) \\\n\t((((const uint32_t *) (a))[0] == 0)\t\t\t\t      \\\n\t && (((const uint32_t *) (a))[1] == 0)\t\t\t\t      \\\n\t && (((const uint32_t *) (a))[2] == 0)\t\t\t\t      \\\n\t && (ntohl (((const uint32_t *) (a))[3]) > 1))\n\n# define IN6_ARE_ADDR_EQUAL(a,b) \\\n\t((((const uint32_t *) (a))[0] == ((const uint32_t *) (b))[0])\t      \\\n\t && (((const uint32_t *) (a))[1] == ((const uint32_t *) (b))[1])      \\\n\t && (((const uint32_t *) (a))[2] == ((const uint32_t *) (b))[2])      \\\n\t && (((const uint32_t *) (a))[3] == ((const uint32_t *) (b))[3]))\n#endif\n\n#define IN6_IS_ADDR_MULTICAST(a) (((const uint8_t *) (a))[0] == 0xff)\n\n#ifdef __USE_MISC\n/* Bind socket to a privileged IP port.  */\nextern int bindresvport (int __sockfd, struct sockaddr_in *__sock_in) __THROW;\n\n/* The IPv6 version of this function.  */\nextern int bindresvport6 (int __sockfd, struct sockaddr_in6 *__sock_in)\n     __THROW;\n#endif\n\n\n#define IN6_IS_ADDR_MC_NODELOCAL(a) \\\n\t(IN6_IS_ADDR_MULTICAST(a)\t\t\t\t\t      \\\n\t && ((((const uint8_t *) (a))[1] & 0xf) == 0x1))\n\n#define IN6_IS_ADDR_MC_LINKLOCAL(a) \\\n\t(IN6_IS_ADDR_MULTICAST(a)\t\t\t\t\t      \\\n\t && ((((const uint8_t *) (a))[1] & 0xf) == 0x2))\n\n#define IN6_IS_ADDR_MC_SITELOCAL(a) \\\n\t(IN6_IS_ADDR_MULTICAST(a)\t\t\t\t\t      \\\n\t && ((((const uint8_t *) (a))[1] & 0xf) == 0x5))\n\n#define IN6_IS_ADDR_MC_ORGLOCAL(a) \\\n\t(IN6_IS_ADDR_MULTICAST(a)\t\t\t\t\t      \\\n\t && ((((const uint8_t *) (a))[1] & 0xf) == 0x8))\n\n#define IN6_IS_ADDR_MC_GLOBAL(a) \\\n\t(IN6_IS_ADDR_MULTICAST(a)\t\t\t\t\t      \\\n\t && ((((const uint8_t *) (a))[1] & 0xf) == 0xe))\n\n\n#ifdef __USE_GNU\nstruct cmsghdr;\t\t\t/* Forward declaration.  */\n\n#if !__USE_KERNEL_IPV6_DEFS\n/* IPv6 packet information.  */\nstruct in6_pktinfo\n  {\n    struct in6_addr ipi6_addr;\t/* src/dst IPv6 address */\n    unsigned int ipi6_ifindex;\t/* send/recv interface index */\n  };\n\n/* IPv6 MTU information.  */\nstruct ip6_mtuinfo\n  {\n    struct sockaddr_in6 ip6m_addr; /* dst address including zone ID */\n    uint32_t ip6m_mtu;\t\t   /* path MTU in host byte order */\n  };\n#endif /* !__USE_KERNEL_IPV6_DEFS */\n\n/* Obsolete hop-by-hop and Destination Options Processing (RFC 2292).  */\nextern int inet6_option_space (int __nbytes)\n     __THROW __attribute_deprecated__;\nextern int inet6_option_init (void *__bp, struct cmsghdr **__cmsgp,\n\t\t\t      int __type) __THROW __attribute_deprecated__;\nextern int inet6_option_append (struct cmsghdr *__cmsg,\n\t\t\t\tconst uint8_t *__typep, int __multx,\n\t\t\t\tint __plusy) __THROW __attribute_deprecated__;\nextern uint8_t *inet6_option_alloc (struct cmsghdr *__cmsg, int __datalen,\n\t\t\t\t    int __multx, int __plusy)\n     __THROW __attribute_deprecated__;\nextern int inet6_option_next (const struct cmsghdr *__cmsg,\n\t\t\t      uint8_t **__tptrp)\n     __THROW __attribute_deprecated__;\nextern int inet6_option_find (const struct cmsghdr *__cmsg,\n\t\t\t      uint8_t **__tptrp, int __type)\n     __THROW __attribute_deprecated__;\n\n\n/* Hop-by-Hop and Destination Options Processing (RFC 3542).  */\nextern int inet6_opt_init (void *__extbuf, socklen_t __extlen) __THROW;\nextern int inet6_opt_append (void *__extbuf, socklen_t __extlen, int __offset,\n\t\t\t     uint8_t __type, socklen_t __len, uint8_t __align,\n\t\t\t     void **__databufp) __THROW;\nextern int inet6_opt_finish (void *__extbuf, socklen_t __extlen, int __offset)\n     __THROW;\nextern int inet6_opt_set_val (void *__databuf, int __offset, void *__val,\n\t\t\t      socklen_t __vallen) __THROW;\nextern int inet6_opt_next (void *__extbuf, socklen_t __extlen, int __offset,\n\t\t\t   uint8_t *__typep, socklen_t *__lenp,\n\t\t\t   void **__databufp) __THROW;\nextern int inet6_opt_find (void *__extbuf, socklen_t __extlen, int __offset,\n\t\t\t   uint8_t __type, socklen_t *__lenp,\n\t\t\t   void **__databufp) __THROW;\nextern int inet6_opt_get_val (void *__databuf, int __offset, void *__val,\n\t\t\t      socklen_t __vallen) __THROW;\n\n\n/* Routing Header Option (RFC 3542).  */\nextern socklen_t inet6_rth_space (int __type, int __segments) __THROW;\nextern void *inet6_rth_init (void *__bp, socklen_t __bp_len, int __type,\n\t\t\t     int __segments) __THROW;\nextern int inet6_rth_add (void *__bp, const struct in6_addr *__addr) __THROW;\nextern int inet6_rth_reverse (const void *__in, void *__out) __THROW;\nextern int inet6_rth_segments (const void *__bp) __THROW;\nextern struct in6_addr *inet6_rth_getaddr (const void *__bp, int __index)\n     __THROW;\n\n\n/* Multicast source filter support.  */\n\n/* Get IPv4 source filter.  */\nextern int getipv4sourcefilter (int __s, struct in_addr __interface_addr,\n\t\t\t\tstruct in_addr __group, uint32_t *__fmode,\n\t\t\t\tuint32_t *__numsrc, struct in_addr *__slist)\n     __THROW;\n\n/* Set IPv4 source filter.  */\nextern int setipv4sourcefilter (int __s, struct in_addr __interface_addr,\n\t\t\t\tstruct in_addr __group, uint32_t __fmode,\n\t\t\t\tuint32_t __numsrc,\n\t\t\t\tconst struct in_addr *__slist)\n     __THROW;\n\n\n/* Get source filter.  */\nextern int getsourcefilter (int __s, uint32_t __interface_addr,\n\t\t\t    const struct sockaddr *__group,\n\t\t\t    socklen_t __grouplen, uint32_t *__fmode,\n\t\t\t    uint32_t *__numsrc,\n\t\t\t    struct sockaddr_storage *__slist) __THROW;\n\n/* Set source filter.  */\nextern int setsourcefilter (int __s, uint32_t __interface_addr,\n\t\t\t    const struct sockaddr *__group,\n\t\t\t    socklen_t __grouplen, uint32_t __fmode,\n\t\t\t    uint32_t __numsrc,\n\t\t\t    const struct sockaddr_storage *__slist) __THROW;\n#endif\t/* use GNU */\n\n__END_DECLS\n\n#endif\t/* netinet/in.h */\n"}, "30": {"id": 30, "path": "/usr/include/x86_64-linux-gnu/bits/byteswap.h", "content": "/* Macros to swap the order of bytes in integer values.\n   Copyright (C) 1997-2018 Free Software Foundation, Inc.\n   This file is part of the GNU C Library.\n\n   The GNU C Library is free software; you can redistribute it and/or\n   modify it under the terms of the GNU Lesser General Public\n   License as published by the Free Software Foundation; either\n   version 2.1 of the License, or (at your option) any later version.\n\n   The GNU C Library is distributed in the hope that it will be useful,\n   but WITHOUT ANY WARRANTY; without even the implied warranty of\n   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n   Lesser General Public License for more details.\n\n   You should have received a copy of the GNU Lesser General Public\n   License along with the GNU C Library; if not, see\n   <http://www.gnu.org/licenses/>.  */\n\n#if !defined _BYTESWAP_H && !defined _NETINET_IN_H && !defined _ENDIAN_H\n# error \"Never use <bits/byteswap.h> directly; include <byteswap.h> instead.\"\n#endif\n\n#ifndef _BITS_BYTESWAP_H\n#define _BITS_BYTESWAP_H 1\n\n#include <features.h>\n#include <bits/types.h>\n#include <bits/wordsize.h>\n\n/* Swap bytes in 16 bit value.  */\n#define __bswap_constant_16(x) \\\n     ((unsigned short int) ((((x) >> 8) & 0xff) | (((x) & 0xff) << 8)))\n\n/* Get __bswap_16.  */\n#include <bits/byteswap-16.h>\n\n/* Swap bytes in 32 bit value.  */\n#define __bswap_constant_32(x) \\\n     ((((x) & 0xff000000) >> 24) | (((x) & 0x00ff0000) >>  8) |\t\t      \\\n      (((x) & 0x0000ff00) <<  8) | (((x) & 0x000000ff) << 24))\n\n#ifdef __GNUC__\n# if __GNUC_PREREQ (4, 3)\nstatic __inline unsigned int\n__bswap_32 (unsigned int __bsx)\n{\n  return __builtin_bswap32 (__bsx);\n}\n# elif __GNUC__ >= 2\n#  if __WORDSIZE == 64 || (defined __i486__ || defined __pentium__\t      \\\n\t\t\t   || defined __pentiumpro__ || defined __pentium4__  \\\n\t\t\t   || defined __k8__ || defined __athlon__\t      \\\n\t\t\t   || defined __k6__ || defined __nocona__\t      \\\n\t\t\t   || defined __core2__ || defined __geode__\t      \\\n\t\t\t   || defined __amdfam10__)\n/* To swap the bytes in a word the i486 processors and up provide the\n   `bswap' opcode.  On i386 we have to use three instructions.  */\n#   define __bswap_32(x) \\\n      (__extension__\t\t\t\t\t\t\t      \\\n       ({ unsigned int __v, __x = (x);\t\t\t\t\t      \\\n\t  if (__builtin_constant_p (__x))\t\t\t\t      \\\n\t    __v = __bswap_constant_32 (__x);\t\t\t\t      \\\n\t  else\t\t\t\t\t\t\t\t      \\\n\t    __asm__ (\"bswap %0\" : \"=r\" (__v) : \"0\" (__x));\t\t      \\\n\t  __v; }))\n#  else\n#   define __bswap_32(x)\t\t\t\t\t\t      \\\n      (__extension__\t\t\t\t\t\t\t      \\\n       ({ unsigned int __v, __x = (x);\t\t\t\t\t      \\\n\t  if (__builtin_constant_p (__x))\t\t\t\t      \\\n\t    __v = __bswap_constant_32 (__x);\t\t\t\t      \\\n\t  else\t\t\t\t\t\t\t\t      \\\n\t    __asm__ (\"rorw $8, %w0;\"\t\t\t\t\t      \\\n\t\t     \"rorl $16, %0;\"\t\t\t\t\t      \\\n\t\t     \"rorw $8, %w0\"\t\t\t\t\t      \\\n\t\t     : \"=r\" (__v)\t\t\t\t\t      \\\n\t\t     : \"0\" (__x)\t\t\t\t\t      \\\n\t\t     : \"cc\");\t\t\t\t\t\t      \\\n\t  __v; }))\n#  endif\n# else\n#  define __bswap_32(x) \\\n     (__extension__\t\t\t\t\t\t\t      \\\n      ({ unsigned int __x = (x); __bswap_constant_32 (__x); }))\n# endif\n#else\nstatic __inline unsigned int\n__bswap_32 (unsigned int __bsx)\n{\n  return __bswap_constant_32 (__bsx);\n}\n#endif\n\n\n#if __GNUC_PREREQ (2, 0)\n/* Swap bytes in 64 bit value.  */\n# define __bswap_constant_64(x) \\\n     (__extension__ ((((x) & 0xff00000000000000ull) >> 56)\t\t      \\\n\t\t     | (((x) & 0x00ff000000000000ull) >> 40)\t\t      \\\n\t\t     | (((x) & 0x0000ff0000000000ull) >> 24)\t\t      \\\n\t\t     | (((x) & 0x000000ff00000000ull) >> 8)\t\t      \\\n\t\t     | (((x) & 0x00000000ff000000ull) << 8)\t\t      \\\n\t\t     | (((x) & 0x0000000000ff0000ull) << 24)\t\t      \\\n\t\t     | (((x) & 0x000000000000ff00ull) << 40)\t\t      \\\n\t\t     | (((x) & 0x00000000000000ffull) << 56)))\n\n# if __GNUC_PREREQ (4, 3)\nstatic __inline __uint64_t\n__bswap_64 (__uint64_t __bsx)\n{\n  return __builtin_bswap64 (__bsx);\n}\n# elif __WORDSIZE == 64\n#  define __bswap_64(x) \\\n     (__extension__\t\t\t\t\t\t\t      \\\n      ({ __uint64_t __v, __x = (x);\t\t\t\t\t      \\\n\t if (__builtin_constant_p (__x))\t\t\t\t      \\\n\t   __v = __bswap_constant_64 (__x);\t\t\t\t      \\\n\t else\t\t\t\t\t\t\t\t      \\\n\t   __asm__ (\"bswap %q0\" : \"=r\" (__v) : \"0\" (__x));\t\t      \\\n\t __v; }))\n# else\n#  define __bswap_64(x) \\\n     (__extension__                                                           \\\n      ({ union { __extension__ __uint64_t __ll;\t\t                      \\\n\t\t unsigned int __l[2]; } __w, __r;                             \\\n\t if (__builtin_constant_p (x))                                        \\\n\t   __r.__ll = __bswap_constant_64 (x);                                \\\n\t else                                                                 \\\n\t   {                                                                  \\\n\t     __w.__ll = (x);                                                  \\\n\t     __r.__l[0] = __bswap_32 (__w.__l[1]);                            \\\n\t     __r.__l[1] = __bswap_32 (__w.__l[0]);                            \\\n\t   }                                                                  \\\n\t __r.__ll; }))\n# endif\n#else\n# define __bswap_constant_64(x) \\\n     ((((x) & 0xff00000000000000ull) >> 56)\t\t\t\t      \\\n      | (((x) & 0x00ff000000000000ull) >> 40)\t\t\t\t      \\\n      | (((x) & 0x0000ff0000000000ull) >> 24)\t\t\t\t      \\\n      | (((x) & 0x000000ff00000000ull) >> 8)\t\t\t\t      \\\n      | (((x) & 0x00000000ff000000ull) << 8)\t\t\t\t      \\\n      | (((x) & 0x0000000000ff0000ull) << 24)\t\t\t\t      \\\n      | (((x) & 0x000000000000ff00ull) << 40)\t\t\t\t      \\\n      | (((x) & 0x00000000000000ffull) << 56))\n\nstatic __inline __uint64_t\n__bswap_64 (__uint64_t __bsx)\n{\n  return __bswap_constant_64 (__bsx);\n}\n#endif\n\n#endif /* _BITS_BYTESWAP_H */\n"}, "32": {"id": 32, "path": "/home/runner/work/testcc/testcc/retdec/pdns/misc.hh", "content": "/*\n * This file is part of PowerDNS or dnsdist.\n * Copyright -- PowerDNS.COM B.V. and its contributors\n *\n * This program is free software; you can redistribute it and/or modify\n * it under the terms of version 2 of the GNU General Public License as\n * published by the Free Software Foundation.\n *\n * In addition, for the avoidance of any doubt, permission is granted to\n * link this program with OpenSSL and to (re)distribute the binaries\n * produced as the result of such linking.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with this program; if not, write to the Free Software\n * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.\n */\n#pragma once\n#include <inttypes.h>\n#include <cstring>\n#include <cstdio>\n#include <regex.h>\n#include <limits.h>\n#include <type_traits>\n#include <boost/algorithm/string.hpp>\n#include <boost/multi_index_container.hpp>\n#include <boost/multi_index/ordered_index.hpp>\n#include <boost/tuple/tuple_comparison.hpp>\n#include <boost/multi_index/key_extractors.hpp>\n#include <boost/multi_index/sequenced_index.hpp>\n\nusing namespace ::boost::multi_index;\n\n#include \"dns.hh\"\n#include <atomic>\n#include <sys/time.h>\n#include <sys/types.h>\n#include <sys/socket.h>\n#include <time.h>\n#include <syslog.h>\n#include <deque>\n#include <stdexcept>\n#include <string>\n#include <ctype.h>\n#include <vector>\n\n#include \"namespaces.hh\"\n#include \"dnsname.hh\"\n\ntypedef enum { TSIG_MD5, TSIG_SHA1, TSIG_SHA224, TSIG_SHA256, TSIG_SHA384, TSIG_SHA512, TSIG_GSS } TSIGHashEnum;\n\nstring nowTime();\nconst string unquotify(const string &item);\nstring humanDuration(time_t passed);\nbool stripDomainSuffix(string *qname, const string &domain);\nvoid stripLine(string &line);\nstring getHostname();\nstring urlEncode(const string &text);\nint waitForData(int fd, int seconds, int useconds=0);\nint waitFor2Data(int fd1, int fd2, int seconds, int useconds, int* fd);\nint waitForMultiData(const set<int>& fds, const int seconds, const int useconds, int* fd);\nint waitForRWData(int fd, bool waitForRead, int seconds, int useconds, bool* error=nullptr, bool* disconnected=nullptr);\nuint16_t getShort(const unsigned char *p);\nuint16_t getShort(const char *p);\nuint32_t getLong(const unsigned char *p);\nuint32_t getLong(const char *p);\nbool getTSIGHashEnum(const DNSName& algoName, TSIGHashEnum& algoEnum);\nDNSName getTSIGAlgoName(TSIGHashEnum& algoEnum);\n\nint logFacilityToLOG(unsigned int facility);\n\nstruct ServiceTuple\n{\n  string host;\n  uint16_t port;\n};\nvoid parseService(const string &descr, ServiceTuple &st);\n\ntemplate <typename Container>\nvoid\nstringtok (Container &container, string const &in,\n           const char * const delimiters = \" \\t\\n\")\n{\n  const string::size_type len = in.length();\n  string::size_type i = 0;\n\n  while (i<len) {\n    // eat leading whitespace\n    i = in.find_first_not_of (delimiters, i);\n    if (i == string::npos)\n      return;   // nothing left but white space\n\n    // find the end of the token\n    string::size_type j = in.find_first_of (delimiters, i);\n\n    // push token\n    if (j == string::npos) {\n      container.push_back (in.substr(i));\n      return;\n    } else\n      container.push_back (in.substr(i, j-i));\n\n    // set up for next loop\n    i = j + 1;\n  }\n}\n\ntemplate<typename T> bool rfc1982LessThan(T a, T b)\n{\n  static_assert(std::is_unsigned<T>::value, \"rfc1982LessThan only works for unsigned types\");\n  typedef typename std::make_signed<T>::type signed_t;\n  return static_cast<signed_t>(a - b) < 0;\n}\n\n// fills container with ranges, so {posbegin,posend}\ntemplate <typename Container>\nvoid\nvstringtok (Container &container, string const &in,\n           const char * const delimiters = \" \\t\\n\")\n{\n  const string::size_type len = in.length();\n  string::size_type i = 0;\n\n  while (i<len) {\n    // eat leading whitespace\n    i = in.find_first_not_of (delimiters, i);\n    if (i == string::npos)\n      return;   // nothing left but white space\n\n    // find the end of the token\n    string::size_type j = in.find_first_of (delimiters, i);\n\n    // push token\n    if (j == string::npos) {\n      container.push_back (make_pair(i, len));\n      return;\n    } else\n      container.push_back (make_pair(i, j));\n\n    // set up for next loop\n    i = j + 1;\n  }\n}\n\nsize_t writen2(int fd, const void *buf, size_t count);\ninline size_t writen2(int fd, const std::string &s) { return writen2(fd, s.data(), s.size()); }\nsize_t readn2(int fd, void* buffer, size_t len);\nsize_t readn2WithTimeout(int fd, void* buffer, size_t len, int idleTimeout, int totalTimeout=0);\nsize_t writen2WithTimeout(int fd, const void * buffer, size_t len, int timeout);\n\nvoid toLowerInPlace(string& str);\nconst string toLower(const string &upper);\nconst string toLowerCanonic(const string &upper);\nbool IpToU32(const string &str, uint32_t *ip);\nstring U32ToIP(uint32_t);\nstring stringerror(int);\nstring stringerror();\nstring itoa(int i);\nstring uitoa(unsigned int i);\nstring bitFlip(const string &str);\n\nvoid dropPrivs(int uid, int gid);\nvoid cleanSlashes(string &str);\n\n#if defined(_POSIX_THREAD_CPUTIME) && defined(CLOCK_THREAD_CPUTIME_ID)\n/** CPUTime measurements */\nclass CPUTime\n{\npublic:\n  void start()\n  {\n    clock_gettime(CLOCK_THREAD_CPUTIME_ID, &d_start);\n  }\n  uint64_t ndiff()\n  {\n    struct timespec now;\n    clock_gettime(CLOCK_THREAD_CPUTIME_ID, &now);\n    return 1000000000ULL*(now.tv_sec - d_start.tv_sec) + (now.tv_nsec - d_start.tv_nsec);\n  }\nprivate:\n  struct timespec d_start;\n};\n#endif\n\n/** The DTime class can be used for timing statistics with microsecond resolution.\nOn 32 bits systems this means that 2147 seconds is the longest time that can be measured. */\nclass DTime\n{\npublic:\n  DTime(); //!< Does not set the timer for you! Saves lots of gettimeofday() calls\n  DTime(const DTime &dt) = default;\n  DTime & operator=(const DTime &dt) = default;\n  time_t time();\n  inline void set();  //!< Reset the timer\n  inline int udiff(); //!< Return the number of microseconds since the timer was last set.\n  inline int udiffNoReset(); //!< Return the number of microseconds since the timer was last set.\n  void setTimeval(const struct timeval& tv)\n  {\n    d_set=tv;\n  }\n  struct timeval getTimeval()\n  {\n    return d_set;\n  }\nprivate:\n  struct timeval d_set;\n};\n\ninline void DTime::set()\n{\n  gettimeofday(&d_set,0);\n}\n\ninline int DTime::udiff()\n{\n  int res=udiffNoReset();\n  gettimeofday(&d_set,0);\n  return res;\n}\n\ninline int DTime::udiffNoReset()\n{\n  struct timeval now;\n\n  gettimeofday(&now,0);\n  int ret=1000000*(now.tv_sec-d_set.tv_sec)+(now.tv_usec-d_set.tv_usec);\n  return ret;\n}\n\ninline void toLowerInPlace(string& str)\n{\n  const size_t length = str.length();\n  char c;\n  for (size_t i = 0; i < length; ++i) {\n    c = dns_tolower(str[i]);\n    if (c != str[i]) {\n      str[i] = c;\n    }\n  }\n}\n\ninline const string toLower(const string &upper)\n{\n  string reply(upper);\n\n  toLowerInPlace(reply);\n\n  return reply;\n}\n\ninline const string toLowerCanonic(const string &upper)\n{\n  string reply(upper);\n  if(!upper.empty()) {\n    unsigned int i, limit= ( unsigned int ) reply.length();\n    unsigned char c;\n    for(i = 0; i < limit ; i++) {\n      c = dns_tolower(upper[i]);\n      if(c != upper[i])\n        reply[i] = c;\n    }\n    if(upper[i-1]=='.')\n      reply.resize(i-1);\n  }\n\n  return reply;\n}\n\n\n\n// Make s uppercase:\ninline string toUpper( const string& s )\n{\n        string r(s);\n        for( unsigned int i = 0; i < s.length(); i++ ) {\n          r[i] = dns_toupper(r[i]);\n        }\n        return r;\n}\n\ninline double getTime()\n{\n  struct timeval now;\n  gettimeofday(&now,0);\n\n  return now.tv_sec+now.tv_usec/1000000.0;\n}\n\ninline void unixDie(const string &why)\n{\n  throw runtime_error(why+\": \"+stringerror());\n}\n\nstring makeHexDump(const string& str);\n\nvoid normalizeTV(struct timeval& tv);\nconst struct timeval operator+(const struct timeval& lhs, const struct timeval& rhs);\nconst struct timeval operator-(const struct timeval& lhs, const struct timeval& rhs);\ninline float makeFloat(const struct timeval& tv)\n{\n  return tv.tv_sec + tv.tv_usec/1000000.0f;\n}\n\ninline bool operator<(const struct timeval& lhs, const struct timeval& rhs)\n{\n  return make_pair(lhs.tv_sec, lhs.tv_usec) < make_pair(rhs.tv_sec, rhs.tv_usec);\n}\n\ninline bool operator<(const struct timespec& lhs, const struct timespec& rhs)\n{\n  return tie(lhs.tv_sec, lhs.tv_nsec) < tie(rhs.tv_sec, rhs.tv_nsec);\n}\n\n\ninline bool pdns_ilexicographical_compare(const std::string& a, const std::string& b)  __attribute__((pure));\ninline bool pdns_ilexicographical_compare(const std::string& a, const std::string& b)\n{\n  const unsigned char *aPtr = (const unsigned char*)a.c_str(), *bPtr = (const unsigned char*)b.c_str();\n  const unsigned char *aEptr = aPtr + a.length(), *bEptr = bPtr + b.length();\n  while(aPtr != aEptr && bPtr != bEptr) {\n    if ((*aPtr != *bPtr) && (dns_tolower(*aPtr) - dns_tolower(*bPtr)))\n      return (dns_tolower(*aPtr) - dns_tolower(*bPtr)) < 0;\n    aPtr++;\n    bPtr++;\n  }\n  if(aPtr == aEptr && bPtr == bEptr) // strings are equal (in length)\n    return false;\n  return aPtr == aEptr; // true if first string was shorter\n}\n\ninline bool pdns_iequals(const std::string& a, const std::string& b) __attribute__((pure));\ninline bool pdns_iequals(const std::string& a, const std::string& b)\n{\n  if (a.length() != b.length())\n    return false;\n\n  const char *aPtr = a.c_str(), *bPtr = b.c_str();\n  const char *aEptr = aPtr + a.length();\n  while(aPtr != aEptr) {\n    if((*aPtr != *bPtr) && (dns_tolower(*aPtr) != dns_tolower(*bPtr)))\n      return false;\n    aPtr++;\n    bPtr++;\n  }\n  return true;\n}\n\ninline bool pdns_iequals_ch(const char a, const char b) __attribute__((pure));\ninline bool pdns_iequals_ch(const char a, const char b)\n{\n  if ((a != b) && (dns_tolower(a) != dns_tolower(b)))\n    return false;\n\n  return true;\n}\n\n\ntypedef unsigned long AtomicCounterInner;\ntypedef std::atomic<AtomicCounterInner> AtomicCounter ;\n\n// FIXME400 this should probably go? \nstruct CIStringCompare: public std::binary_function<string, string, bool>\n{\n  bool operator()(const string& a, const string& b) const\n  {\n    return pdns_ilexicographical_compare(a, b);\n  }\n};\n\nstruct CIStringComparePOSIX\n{\n   bool operator() (const std::string& lhs, const std::string& rhs)\n   {\n      std::string::const_iterator a,b;\n      const std::locale &loc = std::locale(\"POSIX\");\n      a=lhs.begin();b=rhs.begin();\n      while(a!=lhs.end()) {\n          if (b==rhs.end() || std::tolower(*b,loc)<std::tolower(*a,loc)) return false;\n          else if (std::tolower(*a,loc)<std::tolower(*b,loc)) return true;\n          ++a;++b;\n      }\n      return (b!=rhs.end());\n   }\n};\n\nstruct CIStringPairCompare: public std::binary_function<pair<string, uint16_t>, pair<string,uint16_t>, bool>\n{\n  bool operator()(const pair<string, uint16_t>& a, const pair<string, uint16_t>& b) const\n  {\n    if(pdns_ilexicographical_compare(a.first, b.first))\n\treturn true;\n    if(pdns_ilexicographical_compare(b.first, a.first))\n\treturn false;\n    return a.second < b.second;\n  }\n};\n\ninline size_t pdns_ci_find(const string& haystack, const string& needle)\n{\n  string::const_iterator it = std::search(haystack.begin(), haystack.end(),\n    needle.begin(), needle.end(), pdns_iequals_ch);\n  if (it == haystack.end()) {\n    // not found\n    return string::npos;\n  } else {\n    return it - haystack.begin();\n  }\n}\n\npair<string, string> splitField(const string& inp, char sepa);\n\ninline bool isCanonical(const string& qname)\n{\n  if(qname.empty())\n    return false;\n  return qname[qname.size()-1]=='.';\n}\n\ninline DNSName toCanonic(const DNSName& zone, const string& qname)\n{\n  if(qname.size()==1 && qname[0]=='@')\n    return zone;\n  if(isCanonical(qname))\n    return DNSName(qname);\n  return DNSName(qname) += zone;\n}\n\nstring stripDot(const string& dom);\n\nint makeIPv6sockaddr(const std::string& addr, struct sockaddr_in6* ret);\nint makeIPv4sockaddr(const std::string& str, struct sockaddr_in* ret);\nint makeUNsockaddr(const std::string& path, struct sockaddr_un* ret);\nbool stringfgets(FILE* fp, std::string& line);\n\ntemplate<typename Index>\nstd::pair<typename Index::iterator,bool>\nreplacing_insert(Index& i,const typename Index::value_type& x)\n{\n  std::pair<typename Index::iterator,bool> res=i.insert(x);\n  if(!res.second)res.second=i.replace(res.first,x);\n  return res;\n}\n\n/** very small regex wrapper */\nclass Regex\n{\npublic:\n  /** constructor that accepts the expression to regex */\n  Regex(const string &expr);\n\n  ~Regex()\n  {\n    regfree(&d_preg);\n  }\n  /** call this to find out if 'line' matches your expression */\n  bool match(const string &line) const\n  {\n    return regexec(&d_preg,line.c_str(),0,0,0)==0;\n  }\n  bool match(const DNSName& name) const\n  {\n    return match(name.toStringNoDot());\n  }\n\nprivate:\n  regex_t d_preg;\n};\n\nclass SimpleMatch\n{\npublic:\n  SimpleMatch(const string &mask, bool caseFold = false): d_mask(mask), d_fold(caseFold)\n  {\n  }\n \n  bool match(string::const_iterator mi, string::const_iterator mend, string::const_iterator vi, string::const_iterator vend)\n  {\n    for(;;++mi) {\n      if (mi == mend) {\n        return vi == vend;\n      } else if (*mi == '?') {\n        if (vi == vend) return false;\n        ++vi;\n      } else if (*mi == '*') {\n        while(*mi == '*') ++mi;\n        if (mi == d_mask.end()) return true;\n        while(vi != vend) {\n          if (match(mi,mend,vi,vend)) return true;\n          ++vi;\n        }\n        return false;\n      } else {\n        if ((mi == mend && vi != vend)||\n            (mi != mend && vi == vend)) return false;\n        if (d_fold) {\n          if (dns_tolower(*mi) != dns_tolower(*vi)) return false;\n        } else {\n          if (*mi != *vi) return false;\n        }\n        ++vi;\n      }\n    }\n  }\n\n  bool match(const string& value) {\n    return match(d_mask.begin(), d_mask.end(), value.begin(), value.end());\n  }\n\n  bool match(const DNSName& name) {\n    return match(name.toStringNoDot());\n  }\n\nprivate:\n  string d_mask;\n  bool d_fold;\n};\n\nunion ComboAddress;\n\n// An aligned type to hold cmsgbufs. See https://man.openbsd.org/CMSG_DATA\ntypedef union { struct cmsghdr hdr; char buf[256]; } cmsgbuf_aligned;\n\n/* itfIndex is an interface index, as returned by if_nametoindex(). 0 means default. */\nvoid addCMsgSrcAddr(struct msghdr* msgh, cmsgbuf_aligned* cbuf, const ComboAddress* source, int itfIndex);\n\nunsigned int getFilenumLimit(bool hardOrSoft=0);\nvoid setFilenumLimit(unsigned int lim);\nbool readFileIfThere(const char* fname, std::string* line);\nuint32_t burtle(const unsigned char* k, uint32_t length, uint32_t init);\nbool setSocketTimestamps(int fd);\n\n//! Sets the socket into blocking mode.\nbool setBlocking( int sock );\n\n//! Sets the socket into non-blocking mode.\nbool setNonBlocking( int sock );\nbool setTCPNoDelay(int sock);\nbool setReuseAddr(int sock);\nbool isNonBlocking(int sock);\nbool setReceiveSocketErrors(int sock, int af);\nint closesocket(int fd);\nbool setCloseOnExec(int sock);\n\nsize_t getPipeBufferSize(int fd);\nbool setPipeBufferSize(int fd, size_t size);\n\nuint64_t udpErrorStats(const std::string& str);\nuint64_t getRealMemoryUsage(const std::string&);\nuint64_t getSpecialMemoryUsage(const std::string&);\nuint64_t getOpenFileDescriptors(const std::string&);\nuint64_t getCPUTimeUser(const std::string&);\nuint64_t getCPUTimeSystem(const std::string&);\nuint64_t getCPUIOWait(const std::string&);\nuint64_t getCPUSteal(const std::string&);\nstd::string getMACAddress(const ComboAddress& ca);\ntemplate<typename T, typename... Args>\nstd::unique_ptr<T> make_unique(Args&&... args)\n{\n    return std::unique_ptr<T>(new T(std::forward<Args>(args)...));\n}\n\n\ntemplate<typename T>\nconst T& defTer(const T& a, const T& b)\n{\n  return a ? a : b;\n}\n\ntemplate<typename P, typename T>\nT valueOrEmpty(const P val) {\n  if (!val) return T{};\n  return T(val);\n}\n\n\n// I'm not very OCD, but I appreciate loglines like \"processing 1 delta\", \"processing 2 deltas\" :-)\ntemplate <typename Integer>\nconst char* addS(Integer siz, typename std::enable_if<std::is_integral<Integer>::value>::type*P=0)\n{\n  if(!siz || siz > 1)\n    return \"s\";\n  else return \"\";\n}\n\ntemplate<typename C>\nconst char* addS(const C& c, typename std::enable_if<std::is_class<C>::value>::type*P=0)\n{\n  return addS(c.size());\n}\n\ntemplate<typename C>\nconst typename C::value_type::second_type* rplookup(const C& c, const typename C::value_type::first_type& key)\n{\n  auto fnd = c.find(key);\n  if(fnd == c.end())\n    return 0;\n  return &fnd->second;\n}\n\ndouble DiffTime(const struct timespec& first, const struct timespec& second);\ndouble DiffTime(const struct timeval& first, const struct timeval& second);\nuid_t strToUID(const string &str);\ngid_t strToGID(const string &str);\n\nunsigned int pdns_stou(const std::string& str, size_t * idx = 0, int base = 10);\n\nbool isSettingThreadCPUAffinitySupported();\nint mapThreadToCPUList(pthread_t tid, const std::set<int>& cpus);\n\nstd::vector<ComboAddress> getResolvers(const std::string& resolvConfPath);\n\nDNSName reverseNameFromIP(const ComboAddress& ip);\n\nstd::string getCarbonHostName();\n"}, "33": {"id": 33, "path": "/usr/include/x86_64-linux-gnu/bits/byteswap-16.h", "content": "/* Macros to swap the order of bytes in 16-bit integer values.\n   Copyright (C) 2012-2018 Free Software Foundation, Inc.\n   This file is part of the GNU C Library.\n\n   The GNU C Library is free software; you can redistribute it and/or\n   modify it under the terms of the GNU Lesser General Public\n   License as published by the Free Software Foundation; either\n   version 2.1 of the License, or (at your option) any later version.\n\n   The GNU C Library is distributed in the hope that it will be useful,\n   but WITHOUT ANY WARRANTY; without even the implied warranty of\n   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n   Lesser General Public License for more details.\n\n   You should have received a copy of the GNU Lesser General Public\n   License along with the GNU C Library; if not, see\n   <http://www.gnu.org/licenses/>.  */\n\n#ifndef _BITS_BYTESWAP_H\n# error \"Never use <bits/byteswap-16.h> directly; include <byteswap.h> instead.\"\n#endif\n\n#ifdef __GNUC__\n# if __GNUC__ >= 2\n#  define __bswap_16(x) \\\n     (__extension__\t\t\t\t\t\t\t      \\\n      ({ unsigned short int __v, __x = (unsigned short int) (x);\t      \\\n\t if (__builtin_constant_p (__x))\t\t\t\t      \\\n\t   __v = __bswap_constant_16 (__x);\t\t\t\t      \\\n\t else\t\t\t\t\t\t\t\t      \\\n\t   __asm__ (\"rorw $8, %w0\"\t\t\t\t\t      \\\n\t\t    : \"=r\" (__v)\t\t\t\t\t      \\\n\t\t    : \"0\" (__x)\t\t\t\t\t\t      \\\n\t\t    : \"cc\");\t\t\t\t\t\t      \\\n\t __v; }))\n# else\n/* This is better than nothing.  */\n#  define __bswap_16(x) \\\n     (__extension__\t\t\t\t\t\t\t      \\\n      ({ unsigned short int __x = (unsigned short int) (x);\t\t      \\\n\t __bswap_constant_16 (__x); }))\n# endif\n#else\nstatic __inline unsigned short int\n__bswap_16 (unsigned short int __bsx)\n{\n  return __bswap_constant_16 (__bsx);\n}\n#endif\n"}, "34": {"id": 34, "path": "/home/runner/work/testcc/testcc/retdec/pdns/dnsproxy.hh", "content": "/*\n * This file is part of PowerDNS or dnsdist.\n * Copyright -- PowerDNS.COM B.V. and its contributors\n *\n * This program is free software; you can redistribute it and/or modify\n * it under the terms of version 2 of the GNU General Public License as\n * published by the Free Software Foundation.\n *\n * In addition, for the avoidance of any doubt, permission is granted to\n * link this program with OpenSSL and to (re)distribute the binaries\n * produced as the result of such linking.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with this program; if not, write to the Free Software\n * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.\n */\n#pragma once\n#include <map>\n#include <mutex>\n#include <sys/socket.h>\n#include <netinet/in.h>\n#include <arpa/inet.h>\n#include \"dnspacket.hh\"\n#include \"lock.hh\"\n#include \"iputils.hh\"\n\n#include \"namespaces.hh\"\n\n/**\n\nhow will this work.\n\nThis is a thread that just throws packets around. Should handle ~1000 packets/second.\n\nConsists of a thread receiving packets back from the backend and retransmitting them to the original client.\n\nFurthermore, it provides a member function that reports the packet to the connection tracker and actually sends it out. \n\nThe sending happens from a source port that is determined by the constructor, but IS random. Furthermore, the ID is XOR-ed with a random value\nto make sure outside parties can't spoof us.\n\nTo fix: how to remove the stale entries that will surely accumulate\n*/\n\nclass DNSProxy\n{\npublic:\n  DNSProxy(const string &ip); //!< creates socket\n  ~DNSProxy(); //<! dtor for DNSProxy\n  void go(); //!< launches the actual thread\n  bool completePacket(std::unique_ptr<DNSPacket>& r, const DNSName& target,const DNSName& aname, const uint8_t scopeMask);\n\n  void mainloop();                  //!< this is the main loop that receives reply packets and sends them out again\n  bool recurseFor(DNSPacket* p);\nprivate:\n  struct ConntrackEntry\n  {\n    time_t created;\n    boost::optional<ComboAddress> anyLocal;\n    DNSName qname;\n    std::unique_ptr<DNSPacket> complete;\n    DNSName aname;\n    uint8_t anameScopeMask;\n    ComboAddress remote;\n    uint16_t id;\n    uint16_t qtype;\n    int outsock;\n  };\n\n  typedef map<int,ConntrackEntry> map_t;\n\n  // Data\n  ComboAddress d_remote;\n  AtomicCounter* d_resanswers;\n  AtomicCounter* d_udpanswers;\n  AtomicCounter* d_resquestions;\n  std::mutex d_lock;\n  map_t d_conntrack;\n  int d_sock;\n  int getID_locked();\n  uint16_t d_xor;\n};\n"}, "35": {"id": 35, "path": "/home/runner/work/testcc/testcc/retdec/pdns/dnsrecords.hh", "content": "/*\n * This file is part of PowerDNS or dnsdist.\n * Copyright -- PowerDNS.COM B.V. and its contributors\n *\n * This program is free software; you can redistribute it and/or modify\n * it under the terms of version 2 of the GNU General Public License as\n * published by the Free Software Foundation.\n *\n * In addition, for the avoidance of any doubt, permission is granted to\n * link this program with OpenSSL and to (re)distribute the binaries\n * produced as the result of such linking.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with this program; if not, write to the Free Software\n * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.\n */\n#pragma once\n#ifdef HAVE_CONFIG_H\n#include \"config.h\"\n#endif\n\n#include \"dnsparser.hh\"\n#include \"dnswriter.hh\"\n#include \"rcpgenerator.hh\"\n#include <set>\n#include <bitset>\n#include \"namespaces.hh\"\n#include \"iputils.hh\"\n\n#define includeboilerplate(RNAME)   RNAME##RecordContent(const DNSRecord& dr, PacketReader& pr); \\\n  RNAME##RecordContent(const string& zoneData);                                                  \\\n  static void report(void);                                                                      \\\n  static void unreport(void);                                                                    \\\n  static std::shared_ptr<DNSRecordContent> make(const DNSRecord &dr, PacketReader& pr);          \\\n  static std::shared_ptr<DNSRecordContent> make(const string& zonedata);                         \\\n  string getZoneRepresentation(bool noDot=false) const override;                                 \\\n  void toPacket(DNSPacketWriter& pw) override;                                                   \\\n  uint16_t getType() const override { return QType::RNAME; }                                   \\\n  template<class Convertor> void xfrPacket(Convertor& conv, bool noDot=false);\n\nclass NAPTRRecordContent : public DNSRecordContent\n{\npublic:\n  NAPTRRecordContent(uint16_t order, uint16_t preference, string flags, string services, string regexp, DNSName replacement);\n\n  includeboilerplate(NAPTR)\n  template<class Convertor> void xfrRecordContent(Convertor& conv);\nprivate:\n  uint16_t d_order, d_preference;\n  string d_flags, d_services, d_regexp;\n  DNSName d_replacement;\n};\n\n\nclass ARecordContent : public DNSRecordContent\n{\npublic:\n  explicit ARecordContent(const ComboAddress& ca);\n  explicit ARecordContent(uint32_t ip);\n  includeboilerplate(A)\n  void doRecordCheck(const DNSRecord& dr);\n  ComboAddress getCA(int port=0) const;\n  bool operator==(const DNSRecordContent& rhs) const override\n  {\n    if(typeid(*this) != typeid(rhs))\n      return false;\n    return d_ip == dynamic_cast<const ARecordContent&>(rhs).d_ip;\n  }\nprivate:\n  uint32_t d_ip;\n};\n\nclass AAAARecordContent : public DNSRecordContent\n{\npublic:\n  AAAARecordContent(std::string &val);\n  explicit AAAARecordContent(const ComboAddress& ca);\n  includeboilerplate(AAAA)\n  ComboAddress getCA(int port=0) const;\n  bool operator==(const DNSRecordContent& rhs) const override\n  {\n    if(typeid(*this) != typeid(rhs))\n      return false;\n    return d_ip6 == dynamic_cast<const decltype(this)>(&rhs)->d_ip6;\n  }\nprivate:\n  string d_ip6; // why??\n};\n\nclass MXRecordContent : public DNSRecordContent\n{\npublic:\n  MXRecordContent(uint16_t preference, const DNSName& mxname);\n\n  includeboilerplate(MX)\n\n  uint16_t d_preference;\n  DNSName d_mxname;\n\n  bool operator==(const DNSRecordContent& rhs) const override\n  {\n    if(typeid(*this) != typeid(rhs))\n      return false;\n    auto rrhs =dynamic_cast<const decltype(this)>(&rhs);\n    return std::tie(d_preference, d_mxname) == std::tie(rrhs->d_preference, rrhs->d_mxname);\n  }\n\n};\n\nclass KXRecordContent : public DNSRecordContent\n{\npublic:\n  KXRecordContent(uint16_t preference, const DNSName& exchanger);\n\n  includeboilerplate(KX)\n\nprivate:\n  uint16_t d_preference;\n  DNSName d_exchanger;\n};\n\nclass IPSECKEYRecordContent : public DNSRecordContent\n{\npublic:\n  IPSECKEYRecordContent(uint16_t preference, uint8_t gatewaytype, uint8_t algo, const DNSName& gateway, const string& publickey);\n\n  includeboilerplate(IPSECKEY)\n\nprivate:\n  uint32_t d_ip4;\n  DNSName d_gateway;\n  string d_publickey;\n  string d_ip6;\n  uint8_t d_preference, d_gatewaytype, d_algorithm;\n};\n\nclass DHCIDRecordContent : public DNSRecordContent\n{\npublic:\n  includeboilerplate(DHCID)\n\nprivate:\n  string d_content;\n};\n\n\nclass SRVRecordContent : public DNSRecordContent\n{\npublic:\n  SRVRecordContent(uint16_t preference, uint16_t weight, uint16_t port, const DNSName& target);\n\n  includeboilerplate(SRV)\n\n  uint16_t d_weight, d_port;\n  DNSName d_target;\n  uint16_t d_preference;\n};\n\nclass TSIGRecordContent : public DNSRecordContent\n{\npublic:\n  includeboilerplate(TSIG)\n  TSIGRecordContent() {}\n\n  uint16_t d_origID{0};\n  uint16_t d_fudge{0};\n\n  DNSName d_algoName;\n  string d_mac;\n  string d_otherData;\n  uint64_t d_time{0};\n  //  uint16_t d_macSize;\n  uint16_t d_eRcode{0};\n  // uint16_t d_otherLen\n};\n\n\nclass TXTRecordContent : public DNSRecordContent\n{\npublic:\n  includeboilerplate(TXT)\n\n  string d_text;\n};\n\n#ifdef HAVE_LUA_RECORDS\nclass LUARecordContent : public DNSRecordContent\n{\npublic:\n  includeboilerplate(LUA)\n  string getCode() const;\n  uint16_t d_type;\n  string d_code;\n};\n#endif\n\nclass ENTRecordContent : public DNSRecordContent\n{\npublic:\n  includeboilerplate(ENT)\n};\n\nclass SPFRecordContent : public DNSRecordContent\n{\npublic:\n  includeboilerplate(SPF)\n  const std::string& getText() const\n  {\n    return d_text;\n  }\n\nprivate:\n  string d_text;\n};\n\n\nclass NSRecordContent : public DNSRecordContent\n{\npublic:\n  includeboilerplate(NS)\n  explicit NSRecordContent(const DNSName& content) : d_content(content){}\n  const DNSName& getNS() const { return d_content; }\n  bool operator==(const DNSRecordContent& rhs) const override\n  {\n    if(typeid(*this) != typeid(rhs))\n      return false;\n    auto rrhs =dynamic_cast<const decltype(this)>(&rhs);\n    return d_content == rrhs->d_content;\n  }\n\nprivate:\n  DNSName d_content;\n};\n\nclass PTRRecordContent : public DNSRecordContent\n{\npublic:\n  includeboilerplate(PTR)\n  explicit PTRRecordContent(const DNSName& content) : d_content(content){}\n  const DNSName& getContent() const { return d_content; }\nprivate:\n  DNSName d_content;\n};\n\nclass CNAMERecordContent : public DNSRecordContent\n{\npublic:\n  includeboilerplate(CNAME)\n  CNAMERecordContent(const DNSName& content) : d_content(content){}\n  DNSName getTarget() const { return d_content; }\nprivate:\n  DNSName d_content;\n};\n\nclass ALIASRecordContent : public DNSRecordContent\n{\npublic:\n  includeboilerplate(ALIAS)\n\n  DNSName d_content;\n};\n\n\nclass DNAMERecordContent : public DNSRecordContent\n{\npublic:\n  includeboilerplate(DNAME)\n  DNAMERecordContent(const DNSName& content) : d_content(content){}\n  const DNSName& getTarget() const { return d_content; }\nprivate:\n  DNSName d_content;\n};\n\n\nclass MBRecordContent : public DNSRecordContent\n{\npublic:\n  includeboilerplate(MB)\n\nprivate:\n  DNSName d_madname;\n};\n\nclass MGRecordContent : public DNSRecordContent\n{\npublic:\n  includeboilerplate(MG)\n\nprivate:\n  DNSName d_mgmname;\n};\n\nclass MRRecordContent : public DNSRecordContent\n{\npublic:\n  includeboilerplate(MR)\n\nprivate:\n  DNSName d_alias;\n};\n\nclass MINFORecordContent : public DNSRecordContent\n{\npublic:\n  includeboilerplate(MINFO)\n\nprivate:\n  DNSName d_rmailbx;\n  DNSName d_emailbx;\n};\n\nclass OPTRecordContent : public DNSRecordContent\n{\npublic:\n  OPTRecordContent(){}\n  includeboilerplate(OPT)\n  void getData(vector<pair<uint16_t, string> > &opts);\nprivate:\n  string d_data;\n};\n\n\nclass HINFORecordContent : public DNSRecordContent\n{\npublic:\n  includeboilerplate(HINFO)\n\nprivate:\n  string d_cpu, d_host;\n};\n\nclass RPRecordContent : public DNSRecordContent\n{\npublic:\n  includeboilerplate(RP)\n\nprivate:\n  DNSName d_mbox, d_info;\n};\n\n\nclass DNSKEYRecordContent : public DNSRecordContent\n{\npublic:\n  DNSKEYRecordContent();\n  includeboilerplate(DNSKEY)\n  uint16_t getTag() const;\n  uint16_t getTag();\n\n  uint16_t d_flags{0};\n  uint8_t d_protocol{0};\n  uint8_t d_algorithm{0};\n  string d_key;\n  bool operator<(const DNSKEYRecordContent& rhs) const\n  {\n    return tie(d_flags, d_protocol, d_algorithm, d_key) < \n      tie(rhs.d_flags, rhs.d_protocol, rhs.d_algorithm, rhs.d_key);\n  }\n};\n\nclass CDNSKEYRecordContent : public DNSRecordContent\n{\npublic:\n  CDNSKEYRecordContent();\n  includeboilerplate(CDNSKEY)\n  uint16_t getTag();\n\n  uint16_t d_flags{0};\n  uint8_t d_protocol{0};\n  uint8_t d_algorithm{0};\n  string d_key;\n};\n\nclass DSRecordContent : public DNSRecordContent\n{\npublic:\n  DSRecordContent();\n  bool operator==(const DNSRecordContent& rhs) const override\n  {\n    if(typeid(*this) != typeid(rhs))\n      return false;\n    auto rrhs =dynamic_cast<const decltype(this)>(&rhs);\n    return tie(d_tag, d_algorithm, d_digesttype, d_digest) ==\n      tie(rrhs->d_tag, rrhs->d_algorithm, rrhs->d_digesttype, rrhs->d_digest);\n  }\n  bool operator<(const DSRecordContent& rhs) const\n  {\n    return tie(d_tag, d_algorithm, d_digesttype, d_digest) <\n      tie(rhs.d_tag, rhs.d_algorithm, rhs.d_digesttype, rhs.d_digest);\n  }\n\n  includeboilerplate(DS)\n\n  uint16_t d_tag{0};\n  uint8_t d_algorithm{0}, d_digesttype{0};\n  string d_digest;\n};\n\nclass CDSRecordContent : public DNSRecordContent\n{\npublic:\n  CDSRecordContent();\n  includeboilerplate(CDS)\n\n  uint16_t d_tag{0};\n  uint8_t d_algorithm{0}, d_digesttype{0};\n  string d_digest;\n};\n\nclass DLVRecordContent : public DNSRecordContent\n{\npublic:\n  DLVRecordContent();\n  includeboilerplate(DLV)\n\n  uint16_t d_tag{0};\n  uint8_t d_algorithm{0}, d_digesttype{0};\n  string d_digest;\n};\n\n\nclass SSHFPRecordContent : public DNSRecordContent\n{\npublic:\n  includeboilerplate(SSHFP)\n\nprivate:\n  uint8_t d_algorithm, d_fptype;\n  string d_fingerprint;\n};\n\nclass KEYRecordContent : public DNSRecordContent\n{\npublic:\n  includeboilerplate(KEY)\n\nprivate:\n  uint16_t d_flags;\n  uint8_t d_protocol, d_algorithm;\n  string d_certificate;\n};\n\nclass AFSDBRecordContent : public DNSRecordContent\n{\npublic:\n  includeboilerplate(AFSDB)\n\nprivate:\n  uint16_t d_subtype;\n  DNSName d_hostname;\n};\n\n\nclass CERTRecordContent : public DNSRecordContent\n{\npublic:\n  includeboilerplate(CERT)\n\nprivate:\n  uint16_t d_type, d_tag;\n  string d_certificate;\n  uint8_t d_algorithm;\n};\n\nclass TLSARecordContent : public DNSRecordContent\n{\npublic:\n  includeboilerplate(TLSA)\n\nprivate:\n  uint8_t d_certusage, d_selector, d_matchtype;\n  string d_cert;\n};\n\nclass SMIMEARecordContent : public DNSRecordContent\n{\npublic:\n  includeboilerplate(SMIMEA)\n\nprivate:\n  uint8_t d_certusage, d_selector, d_matchtype;\n  string d_cert;\n};\n\nclass OPENPGPKEYRecordContent : public DNSRecordContent\n{\npublic:\n  includeboilerplate(OPENPGPKEY)\n\nprivate:\n  string d_keyring;\n};\n\n\nclass RRSIGRecordContent : public DNSRecordContent\n{\npublic:\n  RRSIGRecordContent(); \n  includeboilerplate(RRSIG)\n\n  uint16_t d_type{0};\n  uint16_t d_tag{0};\n  DNSName d_signer;\n  string d_signature;\n  uint32_t d_originalttl{0}, d_sigexpire{0}, d_siginception{0};\n  uint8_t d_algorithm{0}, d_labels{0};\n};\n\n//namespace {\n  struct soatimes \n  {\n    uint32_t serial;\n    uint32_t refresh;\n    uint32_t retry;\n    uint32_t expire;\n    uint32_t minimum;\n  };\n//}\n\nclass RKEYRecordContent : public DNSRecordContent\n{\npublic:\n  RKEYRecordContent();\n  includeboilerplate(RKEY)\n  uint16_t d_flags{0};\n  uint8_t d_protocol{0}, d_algorithm{0};\n  string d_key;\n};\n\nclass SOARecordContent : public DNSRecordContent\n{\npublic:\n  includeboilerplate(SOA)\n  SOARecordContent(const DNSName& mname, const DNSName& rname, const struct soatimes& st);\n\n  DNSName d_mname;\n  DNSName d_rname;\n  struct soatimes d_st;\n};\n\nclass NSECBitmap\n{\npublic:\n  NSECBitmap(): d_bitset(nullptr)\n  {\n  }\n  NSECBitmap(const NSECBitmap& rhs): d_set(rhs.d_set)\n  {\n    if (rhs.d_bitset) {\n      d_bitset = std::unique_ptr<std::bitset<nbTypes>>(new std::bitset<nbTypes>(*(rhs.d_bitset)));\n    }\n  }\n  NSECBitmap& operator=(const NSECBitmap& rhs)\n  {\n    d_set = rhs.d_set;\n\n    if (rhs.d_bitset) {\n      d_bitset = std::unique_ptr<std::bitset<nbTypes>>(new std::bitset<nbTypes>(*(rhs.d_bitset)));\n    }\n\n    return *this;\n  }\n  NSECBitmap(NSECBitmap&& rhs): d_bitset(std::move(rhs.d_bitset)), d_set(std::move(rhs.d_set))\n  {\n  }\n  bool isSet(uint16_t type) const\n  {\n    if (d_bitset) {\n      return d_bitset->test(type);\n    }\n    return d_set.count(type);\n  }\n  void set(uint16_t type)\n  {\n    if (!d_bitset) {\n      if (d_set.size() >= 200) {\n        migrateToBitSet();\n      }\n    }\n    if (d_bitset) {\n      d_bitset->set(type);\n    }\n    else {\n      d_set.insert(type);\n    }\n  }\n  size_t count() const\n  {\n    if (d_bitset) {\n      return d_bitset->count();\n    }\n    else {\n      return d_set.size();\n    }\n  }\n\n  void fromPacket(PacketReader& pr);\n  void toPacket(DNSPacketWriter& pw);\n  std::string getZoneRepresentation() const;\n\n  static constexpr size_t const nbTypes = 65536;\n\nprivate:\n\n  void migrateToBitSet()\n  {\n    d_bitset = std::unique_ptr<std::bitset<nbTypes>>(new std::bitset<nbTypes>());\n    for (const auto& type : d_set) {\n      d_bitset->set(type);\n    }\n    d_set.clear();\n  }\n  /* using a dynamic set is very efficient for a small number of\n     types covered (~200), but uses a lot of memory (up to 3MB)\n     when there are a lot of them.\n     So we start with the set, but allocate and switch to a bitset\n     if the number of covered types increases a lot */\n  std::unique_ptr<std::bitset<nbTypes>> d_bitset;\n  std::set<uint16_t> d_set;\n};\n\nclass NSECRecordContent : public DNSRecordContent\n{\npublic:\n  static void report(void);\n  NSECRecordContent()\n  {}\n  NSECRecordContent(const string& content, const string& zone=\"\"); //FIXME400: DNSName& zone?\n\n  static std::shared_ptr<DNSRecordContent> make(const DNSRecord &dr, PacketReader& pr);\n  static std::shared_ptr<DNSRecordContent> make(const string& content);\n  string getZoneRepresentation(bool noDot=false) const override;\n  void toPacket(DNSPacketWriter& pw) override;\n  uint16_t getType() const override\n  {\n    return QType::NSEC;\n  }\n  bool isSet(uint16_t type) const\n  {\n    return d_bitmap.isSet(type);\n  }\n  void set(uint16_t type)\n  {\n    d_bitmap.set(type);\n  }\n  void set(const NSECBitmap& bitmap)\n  {\n    d_bitmap = bitmap;\n  }\n  size_t numberOfTypesSet() const\n  {\n    return d_bitmap.count();\n  }\n\n  DNSName d_next;\nprivate:\n  NSECBitmap d_bitmap;\n};\n\nclass NSEC3RecordContent : public DNSRecordContent\n{\npublic:\n  static void report(void);\n  NSEC3RecordContent()\n  {}\n  NSEC3RecordContent(const string& content, const string& zone=\"\"); //FIXME400: DNSName& zone?\n\n  static std::shared_ptr<DNSRecordContent> make(const DNSRecord &dr, PacketReader& pr);\n  static std::shared_ptr<DNSRecordContent> make(const string& content);\n  string getZoneRepresentation(bool noDot=false) const override;\n  void toPacket(DNSPacketWriter& pw) override;\n\n  uint8_t d_algorithm{0}, d_flags{0};\n  uint16_t d_iterations{0};\n  string d_salt;\n  string d_nexthash;\n\n  uint16_t getType() const override\n  {\n    return QType::NSEC3;\n  }\n  bool isSet(uint16_t type) const\n  {\n    return d_bitmap.isSet(type);\n  }\n  void set(uint16_t type)\n  {\n    d_bitmap.set(type);\n  }\n  void set(const NSECBitmap& bitmap)\n  {\n    d_bitmap = bitmap;\n  }\n  size_t numberOfTypesSet() const\n  {\n    return d_bitmap.count();\n  }\n\nprivate:\n  NSECBitmap d_bitmap;\n};\n\n\nclass NSEC3PARAMRecordContent : public DNSRecordContent\n{\npublic:\n  static void report(void);\n  NSEC3PARAMRecordContent()\n  {}\n  NSEC3PARAMRecordContent(const string& content, const string& zone=\"\"); // FIXME400: DNSName& zone?\n\n  static std::shared_ptr<DNSRecordContent> make(const DNSRecord &dr, PacketReader& pr);\n  static std::shared_ptr<DNSRecordContent> make(const string& content);\n  string getZoneRepresentation(bool noDot=false) const override;\n  void toPacket(DNSPacketWriter& pw) override;\n\n  uint16_t getType() const override\n  {\n    return QType::NSEC3PARAM;\n  }\n\n\n  uint8_t d_algorithm{0}, d_flags{0};\n  uint16_t d_iterations{0};\n  string d_salt;\n};\n\n\nclass LOCRecordContent : public DNSRecordContent\n{\npublic:\n  static void report(void);\n  LOCRecordContent()\n  {}\n  LOCRecordContent(const string& content, const string& zone=\"\");\n\n  static std::shared_ptr<DNSRecordContent> make(const DNSRecord &dr, PacketReader& pr);\n  static std::shared_ptr<DNSRecordContent> make(const string& content);\n  string getZoneRepresentation(bool noDot=false) const override;\n  void toPacket(DNSPacketWriter& pw) override;\n\n  uint8_t d_version{0}, d_size{0}, d_horizpre{0}, d_vertpre{0};\n  uint32_t d_latitude{0}, d_longitude{0}, d_altitude{0};\n  uint16_t getType() const override\n  {\n    return QType::LOC;\n  }\n\nprivate:\n};\n\nclass EUI48RecordContent : public DNSRecordContent \n{\npublic:\n  EUI48RecordContent() {};\n  static void report(void);\n  static std::shared_ptr<DNSRecordContent> make(const DNSRecord &dr, PacketReader& pr);\n  static std::shared_ptr<DNSRecordContent> make(const string& zone); // FIXME400: DNSName& zone?\n  string getZoneRepresentation(bool noDot=false) const override;\n  void toPacket(DNSPacketWriter& pw) override;\n  uint16_t getType() const override { return QType::EUI48; }\nprivate:\n // storage for the bytes\n uint8_t d_eui48[6]; \n};\n\nclass EUI64RecordContent : public DNSRecordContent\n{\npublic:\n  EUI64RecordContent() {};\n  static void report(void);\n  static std::shared_ptr<DNSRecordContent> make(const DNSRecord &dr, PacketReader& pr);\n  static std::shared_ptr<DNSRecordContent> make(const string& zone); // FIXME400: DNSName& zone?\n  string getZoneRepresentation(bool noDot=false) const override;\n  void toPacket(DNSPacketWriter& pw) override;\n  uint16_t getType() const override { return QType::EUI64; }\nprivate:\n // storage for the bytes\n uint8_t d_eui64[8];\n};\n\n#define APL_FAMILY_IPV4 1\n#define APL_FAMILY_IPV6 2\ntypedef struct s_APLRDataElement {\n  uint16_t d_family;\n  uint8_t d_prefix;\n  bool d_n : 1;\n  unsigned int d_afdlength : 7;\n  union u_d_ip {\n      uint8_t d_ip4[4];\n      uint8_t d_ip6[16];\n  } d_ip;\n} APLRDataElement;\nclass APLRecordContent : public DNSRecordContent\n{\npublic:\n  APLRecordContent() {};\n  includeboilerplate(APL)\nprivate:\n  std::vector<APLRDataElement> aplrdata;\n  APLRDataElement parseAPLElement(const string &element);\n};\n\n\nclass TKEYRecordContent : public DNSRecordContent\n{\npublic:\n  TKEYRecordContent();\n  includeboilerplate(TKEY)\n\n  // storage for the bytes\n  uint16_t d_othersize{0};\n  uint16_t d_mode{0};\n  uint32_t d_inception{0};\n  uint32_t d_expiration{0};\n\n  DNSName d_algo;\n  string d_key;\n  string d_other;\n\n  uint16_t d_error{0};\n  uint16_t d_keysize{0};\nprivate:\n};\n\nclass URIRecordContent : public DNSRecordContent {\n  public:\n    includeboilerplate(URI)\n  private:\n    uint16_t d_priority, d_weight;\n    string d_target;\n};\n\nclass CAARecordContent : public DNSRecordContent {\n  public:\n    includeboilerplate(CAA)\n  private:\n    uint8_t d_flags;\n    string d_tag, d_value;\n};\n\n#define boilerplate(RNAME, RTYPE)                                                                         \\\nstd::shared_ptr<RNAME##RecordContent::DNSRecordContent> RNAME##RecordContent::make(const DNSRecord& dr, PacketReader& pr) \\\n{                                                                                                  \\\n  return std::make_shared<RNAME##RecordContent>(dr, pr);                                           \\\n}                                                                                                  \\\n                                                                                                   \\\nRNAME##RecordContent::RNAME##RecordContent(const DNSRecord& dr, PacketReader& pr)                  \\\n{                                                                                                  \\\n  doRecordCheck(dr);                                                                               \\\n  xfrPacket(pr);                                                                                   \\\n}                                                                                                  \\\n                                                                                                   \\\nstd::shared_ptr<RNAME##RecordContent::DNSRecordContent> RNAME##RecordContent::make(const string& zonedata)         \\\n{                                                                                                  \\\n  return std::make_shared<RNAME##RecordContent>(zonedata);                                         \\\n}                                                                                                  \\\n                                                                                                   \\\nvoid RNAME##RecordContent::toPacket(DNSPacketWriter& pw)                                           \\\n{                                                                                                  \\\n  this->xfrPacket(pw);                                                                             \\\n}                                                                                                  \\\n                                                                                                   \\\nvoid RNAME##RecordContent::report(void)                                                            \\\n{                                                                                                  \\\n  regist(1, RTYPE, &RNAME##RecordContent::make, &RNAME##RecordContent::make, #RNAME);              \\\n  regist(254, RTYPE, &RNAME##RecordContent::make, &RNAME##RecordContent::make, #RNAME);            \\\n}                                                                                                  \\\nvoid RNAME##RecordContent::unreport(void)                                                          \\\n{                                                                                                  \\\n  unregist(1, RTYPE);                                                                              \\\n  unregist(254, RTYPE);                                                                            \\\n}                                                                                                  \\\n                                                                                                   \\\nRNAME##RecordContent::RNAME##RecordContent(const string& zoneData)                                 \\\n{                                                                                                  \\\n  try {                                                                                            \\\n    RecordTextReader rtr(zoneData);                                                                \\\n    xfrPacket(rtr);                                                                                \\\n  }                                                                                                \\\n  catch(RecordTextException& rte) {                                                                \\\n    throw MOADNSException(\"Parsing record content (try 'pdnsutil check-zone'): \"+string(rte.what()));  \\\n  }                                                                                                \\\n}                                                                                                  \\\n                                                                                                   \\\nstring RNAME##RecordContent::getZoneRepresentation(bool noDot) const                               \\\n{                                                                                                  \\\n  string ret;                                                                                      \\\n  RecordTextWriter rtw(ret, noDot);                                                                       \\\n  const_cast<RNAME##RecordContent*>(this)->xfrPacket(rtw);                                         \\\n  return ret;                                                                                      \\\n}                                                                                                  \n                                                                                           \n\n#define boilerplate_conv(RNAME, TYPE, CONV)                       \\\nboilerplate(RNAME, TYPE)                                          \\\ntemplate<class Convertor>                                         \\\nvoid RNAME##RecordContent::xfrPacket(Convertor& conv, bool noDot) \\\n{                                                                 \\\n  CONV;                                                           \\\n  if (conv.eof() == false) throw MOADNSException(\"When parsing \" #RNAME \" trailing data was not parsed: '\" + conv.getRemaining() + \"'\"); \\\n}                                                                 \\\n\nstruct EDNSOpts\n{\n  enum zFlags { DNSSECOK=32768 };\n  vector<pair<uint16_t, string> > d_options;\n  uint16_t d_packetsize{0};\n  uint16_t d_extFlags{0};\n  uint8_t d_extRCode, d_version;\n};\n//! Convenience function that fills out EDNS0 options, and returns true if there are any\n\nclass MOADNSParser;\nbool getEDNSOpts(const MOADNSParser& mdp, EDNSOpts* eo);\nDNSRecord makeOpt(const uint16_t udpsize, const uint16_t extRCode, const uint16_t extFlags);\nvoid reportBasicTypes();\nvoid reportOtherTypes();\nvoid reportAllTypes();\nComboAddress getAddr(const DNSRecord& dr, uint16_t defport=0);\nvoid checkHostnameCorrectness(const DNSResourceRecord& rr);\n"}, "37": {"id": 37, "path": "/home/runner/work/testcc/testcc/retdec/pdns/dnssecinfra.hh", "content": "/*\n * This file is part of PowerDNS or dnsdist.\n * Copyright -- PowerDNS.COM B.V. and its contributors\n *\n * This program is free software; you can redistribute it and/or modify\n * it under the terms of version 2 of the GNU General Public License as\n * published by the Free Software Foundation.\n *\n * In addition, for the avoidance of any doubt, permission is granted to\n * link this program with OpenSSL and to (re)distribute the binaries\n * produced as the result of such linking.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with this program; if not, write to the Free Software\n * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.\n */\n#pragma once\n#include \"dnsrecords.hh\"\n\n#include <string>\n#include <vector>\n#include <map>\n#include \"misc.hh\"\n\nclass UeberBackend;\n\n// rules of the road: Algorithm must be set in 'make' for each KeyEngine, and will NEVER change!\n\nclass DNSCryptoKeyEngine\n{\n  public:\n    explicit DNSCryptoKeyEngine(unsigned int algorithm) : d_algorithm(algorithm) {}\n    virtual ~DNSCryptoKeyEngine() {};\n    virtual string getName() const = 0;\n    \n    typedef std::map<std::string, std::string> stormap_t;\n    typedef std::vector<std::pair<std::string, std::string > > storvector_t;\n    virtual void create(unsigned int bits)=0;\n    virtual storvector_t convertToISCVector() const =0;\n    std::string convertToISC() const ;\n    virtual std::string sign(const std::string& msg) const =0;\n    virtual std::string hash(const std::string& msg) const\n    {\n       throw std::runtime_error(\"hash() function not implemented\");\n       return msg;\n    }\n    virtual bool verify(const std::string& msg, const std::string& signature) const =0;\n    \n    virtual std::string getPubKeyHash()const =0;\n    virtual std::string getPublicKeyString()const =0;\n    virtual int getBits() const =0;\n    virtual unsigned int getAlgorithm() const\n    {\n      return d_algorithm;\n    }\n \n    virtual void fromISCMap(DNSKEYRecordContent& drc, stormap_t& stormap)=0;\n    virtual void fromPEMString(DNSKEYRecordContent& drc, const std::string& raw)\n    {\n      throw std::runtime_error(\"Can't import from PEM string\");\n    }\n    virtual void fromPublicKeyString(const std::string& content) = 0;\n    virtual bool checkKey(vector<string> *errorMessages = nullptr) const\n    {\n      return true;\n    }\n    static shared_ptr<DNSCryptoKeyEngine> makeFromISCFile(DNSKEYRecordContent& drc, const char* fname);\n    static shared_ptr<DNSCryptoKeyEngine> makeFromISCString(DNSKEYRecordContent& drc, const std::string& content);\n    static shared_ptr<DNSCryptoKeyEngine> makeFromPEMString(DNSKEYRecordContent& drc, const std::string& raw);\n    static shared_ptr<DNSCryptoKeyEngine> makeFromPublicKeyString(unsigned int algorithm, const std::string& raw);\n    static shared_ptr<DNSCryptoKeyEngine> make(unsigned int algorithm);\n    static bool isAlgorithmSupported(unsigned int algo);\n    static bool isDigestSupported(uint8_t digest);\n    \n    typedef shared_ptr<DNSCryptoKeyEngine> maker_t(unsigned int algorithm);\n    \n    static void report(unsigned int algorithm, maker_t* maker, bool fallback=false);\n    static void testMakers(unsigned int algorithm, maker_t* creator, maker_t* signer, maker_t* verifier);\n    static vector<pair<uint8_t, string>> listAllAlgosWithBackend();\n    static bool testAll();\n    static bool testOne(int algo);\n  private:\n    \n    typedef std::map<unsigned int, maker_t*> makers_t;\n    typedef std::map<unsigned int, vector<maker_t*> > allmakers_t;\n    static makers_t& getMakers()\n    {\n      static makers_t s_makers;\n      return s_makers;\n    }\n    static allmakers_t& getAllMakers()\n    {\n      static allmakers_t s_allmakers;\n      return s_allmakers;\n    }\n  protected:\n    const unsigned int d_algorithm;\n};\n\nstruct DNSSECPrivateKey\n{\n  uint16_t getTag() const\n  {\n    return getDNSKEY().getTag();\n  }\n  \n  const shared_ptr<DNSCryptoKeyEngine> getKey() const\n  {\n    return d_key;\n  }\n  \n  void setKey(const shared_ptr<DNSCryptoKeyEngine> key)\n  {\n    d_key = key;\n    d_algorithm = key->getAlgorithm();\n  }\n  DNSKEYRecordContent getDNSKEY() const;\n\n  uint16_t d_flags;\n  uint8_t d_algorithm;\n\nprivate:\n  shared_ptr<DNSCryptoKeyEngine> d_key;\n};\n\n\n\nstruct CanonicalCompare: public std::binary_function<string, string, bool>  \n{\n  bool operator()(const std::string& a, const std::string& b) {\n    std::vector<std::string> avect, bvect;\n\n    stringtok(avect, a, \".\");\n    stringtok(bvect, b, \".\");\n    \n    reverse(avect.begin(), avect.end());\n    reverse(bvect.begin(), bvect.end());\n    \n    return avect < bvect;\n  }\n};\n\nstruct sharedDNSSECRecordCompare {\n    bool operator() (const shared_ptr<DNSRecordContent>& a, const shared_ptr<DNSRecordContent>& b) const {\n      return a->serialize(g_rootdnsname, true, true) < b->serialize(g_rootdnsname, true, true);\n    }\n};\n\ntypedef std::set<std::shared_ptr<DNSRecordContent>, sharedDNSSECRecordCompare> sortedRecords_t;\n\nstring getMessageForRRSET(const DNSName& qname, const RRSIGRecordContent& rrc, const sortedRecords_t& signRecords, bool processRRSIGLabels = false);\n\nDSRecordContent makeDSFromDNSKey(const DNSName& qname, const DNSKEYRecordContent& drc, uint8_t digest);\n\nclass DNSSECKeeper; \n\nuint32_t getStartOfWeek();\n\nstring hashQNameWithSalt(const NSEC3PARAMRecordContent& ns3prc, const DNSName& qname);\nstring hashQNameWithSalt(const std::string& salt, unsigned int iterations, const DNSName& qname);\n\nvoid incrementHash(std::string& raw);\nvoid decrementHash(std::string& raw);\n\nvoid addRRSigs(DNSSECKeeper& dk, UeberBackend& db, const std::set<DNSName>& authMap, vector<DNSZoneRecord>& rrs);\n\nvoid addTSIG(DNSPacketWriter& pw, TSIGRecordContent& trc, const DNSName& tsigkeyname, const string& tsigsecret, const string& tsigprevious, bool timersonly);\nbool validateTSIG(const std::string& packet, size_t sigPos, const TSIGTriplet& tt, const TSIGRecordContent& trc, const std::string& previousMAC, const std::string& theirMAC, bool timersOnly, unsigned int dnsHeaderOffset=0);\n\nuint64_t signatureCacheSize(const std::string& str);\n"}, "38": {"id": 38, "path": "/home/runner/work/testcc/testcc/retdec/pdns/dnsseckeeper.hh", "content": "/*\n * This file is part of PowerDNS or dnsdist.\n * Copyright -- PowerDNS.COM B.V. and its contributors\n *\n * This program is free software; you can redistribute it and/or modify\n * it under the terms of version 2 of the GNU General Public License as\n * published by the Free Software Foundation.\n *\n * In addition, for the avoidance of any doubt, permission is granted to\n * link this program with OpenSSL and to (re)distribute the binaries\n * produced as the result of such linking.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with this program; if not, write to the Free Software\n * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.\n */\n#pragma once\n#include <string>\n#include <string.h>\n#include <vector>\n#include <boost/logic/tribool.hpp>\n#include <boost/multi_index_container.hpp>\n#include <boost/multi_index/hashed_index.hpp>\n#include <boost/multi_index/ordered_index.hpp>\n#include <boost/tuple/tuple_comparison.hpp>\n#include <boost/multi_index/key_extractors.hpp>\n#include <boost/multi_index/sequenced_index.hpp>\n#include \"dnssecinfra.hh\"\n#include \"dnsrecords.hh\"\n#include \"ueberbackend.hh\"\n#include \"lock.hh\"\n\nusing namespace ::boost::multi_index;\n\nclass DNSSECKeeper : public boost::noncopyable\n{\npublic:\n  enum keytype_t { KSK, ZSK, CSK };\n  enum keyalgorithm_t : uint8_t {\n    RSAMD5=1,\n    DH=2,\n    DSA=3,\n    RSASHA1=5,\n    DSANSEC3SHA1=6,\n    RSASHA1NSEC3SHA1=7,\n    RSASHA256=8,\n    RSASHA512=10,\n    ECCGOST=12,\n    ECDSA256=13,\n    ECDSA384=14,\n    ED25519=15,\n    ED448=16\n  };\n\n  enum dsdigestalgorithm_t : uint8_t {\n    DIGEST_SHA1=1,\n    DIGEST_SHA256=2,\n    DIGEST_GOST=3,\n    DIGEST_SHA384=4\n  };\n\n  struct KeyMetaData\n  {\n    string fname;\n    unsigned int id;\n    bool active;\n    keytype_t keyType;\n    bool hasSEPBit;\n    bool published;\n  };\n  typedef std::pair<DNSSECPrivateKey, KeyMetaData> keymeta_t;\n  typedef std::vector<keymeta_t > keyset_t;\n\n  static string keyTypeToString(const keytype_t &keyType)\n  {\n    switch(keyType) {\n      case DNSSECKeeper::KSK:\n        return(\"KSK\");\n      case DNSSECKeeper::ZSK:\n        return(\"ZSK\");\n      case DNSSECKeeper::CSK:\n        return(\"CSK\");\n      default:\n        return(\"UNKNOWN\");\n    }\n  }\n\n  /*\n   * Returns the algorithm number based on the mnemonic (or old PowerDNS value of) a string.\n   * See https://www.iana.org/assignments/dns-sec-alg-numbers/dns-sec-alg-numbers.xhtml for the mapping\n   */\n  static int shorthand2algorithm(const string &algorithm)\n  {\n    if (pdns_iequals(algorithm, \"rsamd5\")) return RSAMD5;\n    if (pdns_iequals(algorithm, \"dh\")) return DH;\n    if (pdns_iequals(algorithm, \"dsa\")) return DSA;\n    if (pdns_iequals(algorithm, \"rsasha1\")) return RSASHA1;\n    if (pdns_iequals(algorithm, \"dsa-nsec3-sha1\")) return DSANSEC3SHA1;\n    if (pdns_iequals(algorithm, \"rsasha1-nsec3-sha1\")) return RSASHA1NSEC3SHA1;\n    if (pdns_iequals(algorithm, \"rsasha256\")) return RSASHA256;\n    if (pdns_iequals(algorithm, \"rsasha512\")) return RSASHA512;\n    if (pdns_iequals(algorithm, \"ecc-gost\")) return ECCGOST;\n    if (pdns_iequals(algorithm, \"gost\")) return ECCGOST;\n    if (pdns_iequals(algorithm, \"ecdsa256\")) return ECDSA256;\n    if (pdns_iequals(algorithm, \"ecdsap256sha256\")) return ECDSA256;\n    if (pdns_iequals(algorithm, \"ecdsa384\")) return ECDSA384;\n    if (pdns_iequals(algorithm, \"ecdsap384sha384\")) return ECDSA384;\n    if (pdns_iequals(algorithm, \"ed25519\")) return ED25519;\n    if (pdns_iequals(algorithm, \"ed448\")) return ED448;\n    if (pdns_iequals(algorithm, \"indirect\")) return 252;\n    if (pdns_iequals(algorithm, \"privatedns\")) return 253;\n    if (pdns_iequals(algorithm, \"privateoid\")) return 254;\n    return -1;\n  }\n\n  /*\n   * Returns the mnemonic from https://www.iana.org/assignments/dns-sec-alg-numbers/dns-sec-alg-numbers.xhtml\n   */\n  static string algorithm2name(uint8_t algo) {\n    switch(algo) {\n      case 0:\n      case 4:\n      case 9:\n      case 11:\n        return \"Reserved\";\n      case RSAMD5:\n        return \"RSAMD5\";\n      case DH:\n        return \"DH\";\n      case DSA:\n        return \"DSA\";\n      case RSASHA1:\n        return \"RSASHA1\";\n      case DSANSEC3SHA1:\n        return \"DSA-NSEC3-SHA1\";\n      case RSASHA1NSEC3SHA1:\n        return \"RSASHA1-NSEC3-SHA1\";\n      case RSASHA256:\n        return \"RSASHA256\";\n      case RSASHA512:\n        return \"RSASHA512\";\n      case ECCGOST:\n        return \"ECC-GOST\";\n      case ECDSA256:\n        return \"ECDSAP256SHA256\";\n      case ECDSA384:\n        return \"ECDSAP384SHA384\";\n      case ED25519:\n        return \"ED25519\";\n      case ED448:\n        return \"ED448\";\n      case 252:\n        return \"INDIRECT\";\n      case 253:\n        return \"PRIVATEDNS\";\n      case 254:\n        return \"PRIVATEOID\";\n      default:\n        return \"Unallocated/Reserved\";\n    }\n  }\n\nprivate:\n  UeberBackend* d_keymetadb;\n  bool d_ourDB;\n\npublic:\n  DNSSECKeeper() : d_keymetadb( new UeberBackend(\"key-only\")), d_ourDB(true)\n  {\n    \n  }\n  \n  DNSSECKeeper(UeberBackend* db) : d_keymetadb(db), d_ourDB(false)\n  {\n  }\n  \n  ~DNSSECKeeper()\n  {\n    if(d_ourDB)\n      delete d_keymetadb;\n  }\n\n  static uint64_t dbdnssecCacheSizes(const std::string& str);\n  static void clearAllCaches();\n  static bool clearKeyCache(const DNSName& name);\n  static bool clearMetaCache(const DNSName& name);\n  static void clearCaches(const DNSName& name);\n\n  bool doesDNSSEC();\n  bool isSecuredZone(const DNSName& zone);\n  keyset_t getEntryPoints(const DNSName& zname);\n  keyset_t getKeys(const DNSName& zone, bool useCache = true);\n  DNSSECPrivateKey getKeyById(const DNSName& zone, unsigned int id);\n  bool addKey(const DNSName& zname, bool setSEPBit, int algorithm, int64_t& id, int bits=0, bool active=true, bool published=true);\n  bool addKey(const DNSName& zname, const DNSSECPrivateKey& dpk, int64_t& id, bool active=true, bool published=true);\n  bool removeKey(const DNSName& zname, unsigned int id);\n  bool activateKey(const DNSName& zname, unsigned int id);\n  bool deactivateKey(const DNSName& zname, unsigned int id);\n  bool publishKey(const DNSName& zname, unsigned int id);\n  bool unpublishKey(const DNSName& zname, unsigned int id);\n  bool checkKeys(const DNSName& zname, vector<string>* errorMessages = nullptr);\n\n  bool getNSEC3PARAM(const DNSName& zname, NSEC3PARAMRecordContent* n3p=0, bool* narrow=0);\n  bool checkNSEC3PARAM(const NSEC3PARAMRecordContent& ns3p, string& msg);\n  bool setNSEC3PARAM(const DNSName& zname, const NSEC3PARAMRecordContent& n3p, const bool& narrow=false);\n  bool unsetNSEC3PARAM(const DNSName& zname);\n  bool getPreRRSIGs(UeberBackend& db, const DNSName& signer, const DNSName& qname, const DNSName& wildcardname, const QType& qtype, DNSResourceRecord::Place, vector<DNSZoneRecord>& rrsigs, uint32_t signTTL);\n  bool isPresigned(const DNSName& zname);\n  bool setPresigned(const DNSName& zname);\n  bool unsetPresigned(const DNSName& zname);\n  bool setPublishCDNSKEY(const DNSName& zname);\n  void getPublishCDNSKEY(const DNSName& zname, std::string& value);\n  bool unsetPublishCDNSKEY(const DNSName& zname);\n  bool setPublishCDS(const DNSName& zname, const string& digestAlgos);\n  void getPublishCDS(const DNSName& zname, std::string& value);\n  bool unsetPublishCDS(const DNSName& zname);\n\n  bool TSIGGrantsAccess(const DNSName& zone, const DNSName& keyname);\n  bool getTSIGForAccess(const DNSName& zone, const ComboAddress& master, DNSName* keyname);\n  \n  void startTransaction(const DNSName& zone, int zone_id)\n  {\n    (*d_keymetadb->backends.begin())->startTransaction(zone, zone_id);\n  }\n  \n  void commitTransaction()\n  {\n    (*d_keymetadb->backends.begin())->commitTransaction();\n  }\n  \n  void getFromMetaOrDefault(const DNSName& zname, const std::string& key, std::string& value, const std::string& defaultvalue);\n  bool getFromMeta(const DNSName& zname, const std::string& key, std::string& value);\n  void getSoaEdit(const DNSName& zname, std::string& value);\n  bool unSecureZone(const DNSName& zone, std::string& error, std::string& info);\n  bool rectifyZone(const DNSName& zone, std::string& error, std::string& info, bool doTransaction);\n\n  static void setMaxEntries(size_t maxEntries);\n\n  typedef std::map<std::string, std::vector<std::string> > METAValues;\nprivate:\n\n\n  struct KeyCacheEntry\n  {\n    typedef vector<DNSSECKeeper::keymeta_t> keys_t;\n  \n    uint32_t getTTD() const\n    {\n      return d_ttd;\n    }\n  \n    DNSName d_domain;\n    mutable keys_t d_keys;\n    unsigned int d_ttd;\n  };\n  \n  struct METACacheEntry\n  {\n    time_t getTTD() const\n    {\n      return d_ttd;\n    }\n\n    DNSName d_domain;\n    mutable METAValues d_value;\n    time_t d_ttd;\n  };\n  \n  struct KeyCacheTag{};\n  struct CompositeTag{};\n  struct SequencedTag{};\n  \n  typedef multi_index_container<\n    KeyCacheEntry,\n    indexed_by<\n      hashed_unique<tag<KeyCacheTag>,member<KeyCacheEntry, DNSName, &KeyCacheEntry::d_domain> >,\n      sequenced<tag<SequencedTag>>\n    >\n  > keycache_t;\n\n  typedef multi_index_container<\n    METACacheEntry,\n    indexed_by<\n      ordered_unique<member<METACacheEntry, DNSName, &METACacheEntry::d_domain> >,\n      sequenced<tag<SequencedTag>>\n    >\n  > metacache_t;\n\n  void cleanup();\n\n  static keycache_t s_keycache;\n  static metacache_t s_metacache;\n  static ReadWriteLock s_metacachelock;\n  static ReadWriteLock s_keycachelock;\n  static AtomicCounter s_ops;\n  static time_t s_last_prune;\n  static size_t s_maxEntries;\n\npublic:\n  void preRemoval(const KeyCacheEntry&)\n  {\n  }\n  void preRemoval(const METACacheEntry&)\n  {\n  }\n};\n\nclass DNSPacket;\nuint32_t localtime_format_YYYYMMDDSS(time_t t, uint32_t seq);\n// for SOA-EDIT\nuint32_t calculateEditSOA(uint32_t old_serial, DNSSECKeeper& dk, const DNSName& zonename);\nuint32_t calculateEditSOA(uint32_t old_serial, const string& kind, const DNSName& zonename);\n// for SOA-EDIT-DNSUPDATE/API\nbool increaseSOARecord(DNSResourceRecord& dr, const string& increaseKind, const string& editKind);\nbool makeIncreasedSOARecord(SOAData& sd, const string& increaseKind, const string& editKind, DNSResourceRecord& rrout);\nDNSZoneRecord makeEditedDNSZRFromSOAData(DNSSECKeeper& dk, const SOAData& sd, DNSResourceRecord::Place place=DNSResourceRecord::ANSWER);\n"}, "31": {"id": 31, "path": "/home/runner/work/testcc/testcc/retdec/pdns/dnswriter.hh", "content": "/*\n * This file is part of PowerDNS or dnsdist.\n * Copyright -- PowerDNS.COM B.V. and its contributors\n *\n * This program is free software; you can redistribute it and/or modify\n * it under the terms of version 2 of the GNU General Public License as\n * published by the Free Software Foundation.\n *\n * In addition, for the avoidance of any doubt, permission is granted to\n * link this program with OpenSSL and to (re)distribute the binaries\n * produced as the result of such linking.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with this program; if not, write to the Free Software\n * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.\n */\n#pragma once\n#include <string>\n#include <vector>\n#include <map>\n#include \"dns.hh\"\n#include \"dnsname.hh\"\n#include \"namespaces.hh\"\n#include \"iputils.hh\"\n#include <arpa/inet.h>\n\n\n/** this class can be used to write DNS packets. It knows about DNS in the sense that it makes\n    the packet header and record headers.\n\n    The model is:\n\n    packetheader (recordheader recordcontent)*\n\n    The packetheader needs to be updated with the amount of packets of each kind (answer, auth, additional)\n\n    Each recordheader contains the length of a dns record.\n\n    Calling convention:\n\n    vector<uint8_t> content;\n    DNSPacketWriter dpw(content, const string& qname, uint16_t qtype, uint16_t qclass=QClass:IN);  // sets the question\n    dpw.startrecord(\"this.is.an.ip.address.\", ns_t_a);    // does nothing, except store qname and qtype\n    dpw.xfr32BitInt(0x01020304);                         // adds 4 bytes (0x01020304) to the record buffer\n    dpw.startrecord(\"this.is.an.ip.address.\", ns_t_a);    // aha! writes out dnsrecord header containing qname and qtype and length 4, plus the recordbuffer, which gets emptied\n                                                         // new qname and qtype are stored\n    dpw.xfr32BitInt(0x04030201);                         // adds 4 bytes (0x04030201) to the record buffer\n    dpw.commit();                                        // writes out dnsrecord header containing qname and qtype and length 4, plus the recordbuffer\n\n    // content now contains the ready packet, with 1 question and 2 answers\n\n*/\n\nclass DNSPacketWriter : public boost::noncopyable\n{\n\npublic:\n  //! Start a DNS Packet in the vector passed, with question qname, qtype and qclass\n  DNSPacketWriter(vector<uint8_t>& content, const DNSName& qname, uint16_t  qtype, uint16_t qclass=QClass::IN, uint8_t opcode=0);\n\n  /** Start a new DNS record within this packet for namq, qtype, ttl, class and in the requested place. Note that packets can only be written in natural order -\n      ANSWER, AUTHORITY, ADDITIONAL */\n  void startRecord(const DNSName& name, uint16_t qtype, uint32_t ttl=3600, uint16_t qclass=QClass::IN, DNSResourceRecord::Place place=DNSResourceRecord::ANSWER, bool compress=true);\n\n  /** Shorthand way to add an Opt-record, for example for EDNS0 purposes */\n  typedef vector<pair<uint16_t,std::string> > optvect_t;\n  void addOpt(const uint16_t udpsize, const uint16_t extRCode, const uint16_t ednsFlags, const optvect_t& options=optvect_t(), const uint8_t version=0);\n\n  /** needs to be called after the last record is added, but can be called again and again later on. Is called internally by startRecord too.\n      The content of the vector<> passed to the constructor is inconsistent until commit is called.\n   */\n  void commit();\n\n  uint32_t size(); // needs to be 32 bit because otherwise we don't see the wrap coming when it happened!\n\n  /** Should the packet have grown too big for the writer's liking, rollback removes the record currently being written */\n  void rollback();\n\n  /** Discard all content except the question section */\n  void truncate();\n\n  void xfr48BitInt(uint64_t val);\n  void xfr32BitInt(uint32_t val);\n  void xfr16BitInt(uint16_t val);\n  void xfrType(uint16_t val)\n  {\n    xfr16BitInt(val);\n  }\n  void xfrIP(const uint32_t& val)\n  {\n    xfr32BitInt(htonl(val));\n  }\n  void xfrIP6(const std::string& val)\n  {\n    xfrBlob(val,16);\n  }\n\n  void xfrCAWithoutPort(uint8_t version, ComboAddress &val)\n  {\n    if (version == 4) xfrIP(val.sin4.sin_addr.s_addr);\n    else if (version == 6) {\n      string blob;\n      blob.assign((const char*)val.sin6.sin6_addr.s6_addr, 16);\n      xfrBlob(blob, 16);\n    }\n    else throw runtime_error(\"invalid IP protocol\");\n  }\n\n  void xfrCAPort(ComboAddress &val)\n  {\n    uint16_t port;\n    port = val.sin4.sin_port;\n    xfr16BitInt(port);\n  }\n\n  void xfrTime(const uint32_t& val)\n  {\n    xfr32BitInt(val);\n  }\n\n  void xfr8BitInt(uint8_t val);\n\n  void xfrName(const DNSName& label, bool compress=false, bool noDot=false);\n  void xfrText(const string& text, bool multi=false, bool lenField=true);\n  void xfrUnquotedText(const string& text, bool lenField);\n  void xfrBlob(const string& blob, int len=-1);\n  void xfrBlobNoSpaces(const string& blob, int len=-1);\n  void xfrHexBlob(const string& blob, bool keepReading=false);\n\n  dnsheader* getHeader();\n  void getRecordPayload(string& records); // call __before commit__\n\n  void setCanonic(bool val)\n  {\n    d_canonic=val;\n  }\n\n  void setLowercase(bool val)\n  {\n    d_lowerCase=val;\n  }\n  vector <uint8_t>& getContent()\n  {\n    return d_content;\n  }\n  bool eof() { return true; } // we don't know how long the record should be\n\n  const string getRemaining() const {\n    return \"\";\n  }\nprivate:\n  uint16_t lookupName(const DNSName& name, uint16_t* matchlen);\n  vector<uint16_t> d_namepositions;\n  // We declare 1 uint_16 in the public section, these 3 align on a 8-byte boundary\n  uint16_t d_sor;\n  uint16_t d_rollbackmarker; // start of last complete packet, for rollback\n\n  vector <uint8_t>& d_content;\n  DNSName d_qname;\n\n  uint16_t d_truncatemarker; // end of header, for truncate\n  DNSResourceRecord::Place d_recordplace;\n  bool d_canonic, d_lowerCase, d_compress{false};\n};\n\ntypedef vector<pair<string::size_type, string::size_type> > labelparts_t;\n// bool labeltokUnescape(labelparts_t& parts, const DNSName& label);\nstd::vector<string> segmentDNSText(const string& text); // from dnslabeltext.rl\nstd::deque<string> segmentDNSName(const string& input); // from dnslabeltext.rl\n"}, "39": {"id": 39, "path": "/home/runner/work/testcc/testcc/retdec/pdns/dynhandler.cc", "content": "/*\n * This file is part of PowerDNS or dnsdist.\n * Copyright -- PowerDNS.COM B.V. and its contributors\n *\n * This program is free software; you can redistribute it and/or modify\n * it under the terms of version 2 of the GNU General Public License as\n * published by the Free Software Foundation.\n *\n * In addition, for the avoidance of any doubt, permission is granted to\n * link this program with OpenSSL and to (re)distribute the binaries\n * produced as the result of such linking.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with this program; if not, write to the Free Software\n * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.\n */\n#ifdef HAVE_CONFIG_H\n#include \"config.h\"\n#endif\n#include \"auth-caches.hh\"\n#include \"auth-querycache.hh\"\n#include \"auth-packetcache.hh\"\n#include \"utility.hh\"\n#include \"dynhandler.hh\"\n#include \"statbag.hh\"\n#include \"logger.hh\"\n#include \"dns.hh\"\n#include \"arguments.hh\"\n#include <signal.h>\n#include \"misc.hh\"\n#include \"communicator.hh\"\n#include \"dnsseckeeper.hh\"\n#include \"nameserver.hh\"\n#include \"responsestats.hh\"\n#include \"ueberbackend.hh\"\n#include \"common_startup.hh\"\n\nextern ResponseStats g_rs;\n\nstatic bool s_pleasequit;\nstatic string d_status;\n\nbool DLQuitPlease()\n{\n  return s_pleasequit;\n}\n\nstring DLQuitHandler(const vector<string>&parts, Utility::pid_t ppid)\n{\n  string ret=\"No return value\";\n  if(parts[0]==\"QUIT\") {\n    s_pleasequit=true;\n    ret=\"Scheduling exit\";\n    g_log<<Logger::Error<<\"Scheduling exit on remote request\"<<endl;\n  }\n  return ret;\n}\n\nstatic void dokill(int)\n{\n  exit(0);\n}\n\nstring DLCurrentConfigHandler(const vector<string>&parts, Utility::pid_t ppid)\n{\n  if(parts.size() > 1) {\n    if(parts.size() == 2 && parts[1] == \"diff\") {\n      return ::arg().configstring(true, false);\n    }\n    return \"Syntax: current-config [diff]\";\n  }\n  return ::arg().configstring(true, true);\n}\n\nstring DLRQuitHandler(const vector<string>&parts, Utility::pid_t ppid)\n{\n  signal(SIGALRM, dokill);\n  alarm(1);\n  return \"Exiting\";\n}\n\nstring DLPingHandler(const vector<string>&parts, Utility::pid_t ppid)\n{\n  return \"PONG\";\n}\n\nstring DLShowHandler(const vector<string>&parts, Utility::pid_t ppid) {\n  try {\n    extern StatBag S;\n    string ret(\"Wrong number of parameters\");\n    if (parts.size() == 2) {\n      if (parts[1] == \"*\")\n        ret = S.directory();\n      else\n        ret = S.getValueStr(parts[1]);\n    }\n\n    return ret;\n  }\n  catch (...) {\n    return \"Unknown\";\n  }\n}\n\nvoid setStatus(const string &str)\n{\n  d_status=str;\n}\n\nstring DLStatusHandler(const vector<string>&parts, Utility::pid_t ppid)\n{\n  ostringstream os;\n  os<<ppid<<\": \"<<d_status;\n  return os.str();\n}\n\nstring DLUptimeHandler(const vector<string>&parts, Utility::pid_t ppid)\n{\n  ostringstream os;\n  os<<humanDuration(time(0)-s_starttime);\n  return os.str();\n}\n\nstring DLPurgeHandler(const vector<string>&parts, Utility::pid_t ppid)\n{\n  ostringstream os;\n  int ret=0;\n\n  if(parts.size()>1) {\n    for (vector<string>::const_iterator i=++parts.begin();i<parts.end();++i) {\n      g_log<<Logger::Warning<<\"Cache clear request for '\"<<*i<<\"' received from operator\"<<endl;\n      ret+=purgeAuthCaches(*i);\n      if(!boost::ends_with(*i, \"$\"))\n        DNSSECKeeper::clearCaches(DNSName(*i));\n      else\n        DNSSECKeeper::clearAllCaches(); // at least we do what we promise.. and a bit more!\n    }\n  }\n  else {\n    g_log<<Logger::Warning<<\"Cache clear request received from operator\"<<endl;\n    ret = purgeAuthCaches();\n    DNSSECKeeper::clearAllCaches();\n  }\n\n  os<<ret;\n  return os.str();\n}\n\nstring DLCCHandler(const vector<string>&parts, Utility::pid_t ppid)\n{\n  extern AuthPacketCache PC;\n  extern AuthQueryCache QC;\n  map<char,uint64_t> counts=QC.getCounts();\n  uint64_t packetEntries = PC.size();\n  ostringstream os;\n  bool first=true;\n  for(map<char,uint64_t>::const_iterator i=counts.begin();i!=counts.end();++i) {\n    if(!first) \n      os<<\", \";\n    first=false;\n\n    if(i->first=='!')\n      os<<\"negative queries: \";\n    else if(i->first=='Q')\n      os<<\"queries: \";\n    else \n      os<<\"unknown: \";\n\n    os<<i->second;\n  }\n  os<<\"packets: \"<<packetEntries;\n\n  return os.str();\n}\n\nstring DLQTypesHandler(const vector<string>&parts, Utility::pid_t ppid)\n{\n  return g_rs.getQTypeReport();\n}\n\nstring DLRSizesHandler(const vector<string>&parts, Utility::pid_t ppid)\n{\n  typedef map<uint16_t, uint64_t> respsizes_t;\n  respsizes_t respsizes = g_rs.getSizeResponseCounts();\n  ostringstream os;\n  boost::format fmt(\"%d\\t%d\\n\");\n  for(const respsizes_t::value_type& val :  respsizes) {\n    os << (fmt % val.first % val.second).str();\n  }\n  return os.str();\n}\n\nstring DLRemotesHandler(const vector<string>&parts, Utility::pid_t ppid)\n{\n  extern StatBag S;\n  typedef vector<pair<string, unsigned int> > totals_t;\n  totals_t totals = S.getRing(\"remotes\");\n  string ret;\n  boost::format fmt(\"%s\\t%d\\n\");\n  for(totals_t::value_type& val :  totals) {\n    ret += (fmt % val.first % val.second).str();\n  }\n  return ret;\n}\n\nstring DLSettingsHandler(const vector<string>&parts, Utility::pid_t ppid)\n{\n  static const char *whitelist[]={\"query-logging\",0};\n  const char **p;\n\n  if(parts.size()!=3) {\n    return \"Syntax: set variable value\";\n  }\n  \n  for(p=whitelist;*p;p++)\n    if(*p==parts[1])\n      break;\n  if(*p) {\n    ::arg().set(parts[1])=parts[2];\n    g_log<<Logger::Warning<<\"Configuration change for setting '\"<<parts[1]<<\"' to value '\"<<parts[2]<<\"' received from operator\"<<endl;\n    return \"done\";\n  }\n  else\n    return \"This setting cannot be changed at runtime, or no such setting\";\n\n}\n\nstring DLVersionHandler(const vector<string>&parts, Utility::pid_t ppid)\n{\n  return VERSION;\n}\n\nstring DLNotifyRetrieveHandler(const vector<string>&parts, Utility::pid_t ppid)\n{\n  extern CommunicatorClass Communicator;\n  ostringstream os;\n  if(parts.size()!=2 && parts.size()!=3)\n    return \"syntax: retrieve domain [ip]\";\n\n  DNSName domain;\n  try {\n    domain = DNSName(parts[1]);\n  } catch (...) {\n    return \"Failed to parse domain as valid DNS name\";\n  }\n\n  ComboAddress master_ip;\n  bool override_master = false;\n  if (parts.size() == 3) {\n    try {\n      master_ip = ComboAddress{parts[2], 53};\n    } catch (...) {\n      return \"Invalid master address\";\n    }\n    override_master = true;\n  }\n\n  DomainInfo di;\n  UeberBackend B;\n  if(!B.getDomainInfo(domain, di)) {\n    return \" Domain '\"+domain.toString()+\"' unknown\";\n  }\n\n  if (override_master) {\n    di.masters.clear();\n    di.masters.push_back(master_ip);\n  }\n\n  if(!override_master && (di.kind != DomainInfo::Slave || di.masters.empty()))\n    return \"Domain '\"+domain.toString()+\"' is not a slave domain (or has no master defined)\";\n\n  shuffle(di.masters.begin(), di.masters.end(), pdns::dns_random_engine());\n  const auto& master = di.masters.front();\n  Communicator.addSuckRequest(domain, master, override_master);\n  g_log<<Logger::Warning<<\"Retrieval request for domain '\"<<domain<<\"' from master '\"<<master<<\"' received from operator\"<<endl;\n  return \"Added retrieval request for '\"+domain.toLogString()+\"' from master \"+master.toLogString();\n}\n\nstring DLNotifyHostHandler(const vector<string>&parts, Utility::pid_t ppid)\n{\n  extern CommunicatorClass Communicator;\n  ostringstream os;\n  if(parts.size()!=3)\n    return \"syntax: notify-host domain ip\";\n  if(!::arg().mustDo(\"master\") && !(::arg().mustDo(\"slave\") && ::arg().mustDo(\"slave-renotify\")))\n      return \"PowerDNS not configured as master or slave with re-notifications\";\n\n  DNSName domain;\n  try {\n    domain = DNSName(parts[1]);\n  } catch (...) {\n    return \"Failed to parse domain as valid DNS name\";\n  }\n\n  try {\n    ComboAddress ca(parts[2]);\n  } catch(...)\n  {\n    return \"Unable to convert '\"+parts[2]+\"' to an IP address\";\n  }\n  \n  g_log<<Logger::Warning<<\"Notification request to host \"<<parts[2]<<\" for domain '\"<<domain<<\"' received from operator\"<<endl;\n  Communicator.notify(domain, parts[2]);\n  return \"Added to queue\";\n}\n\nstring DLNotifyHandler(const vector<string>&parts, Utility::pid_t ppid)\n{\n  extern CommunicatorClass Communicator;\n  UeberBackend B;\n  if(parts.size()!=2)\n    return \"syntax: notify domain\";\n  if(!::arg().mustDo(\"master\") && !(::arg().mustDo(\"slave\") && ::arg().mustDo(\"slave-renotify\")))\n      return \"PowerDNS not configured as master or slave with re-notifications\";\n  g_log<<Logger::Warning<<\"Notification request for domain '\"<<parts[1]<<\"' received from operator\"<<endl;\n\n  if (parts[1] == \"*\") {\n    vector<DomainInfo> domains;\n    B.getAllDomains(&domains);\n\n    int total = 0;\n    int notified = 0;\n    for (const auto& di : domains) {\n      if (di.kind == DomainInfo::Master || di.kind == DomainInfo::Slave) { // MASTER and Slave if slave-renotify is enabled\n        total++;\n        if(Communicator.notifyDomain(di.zone, &B))\n          notified++;\n      }\n    }\n\n    if (total != notified)\n      return itoa(notified)+\" out of \"+itoa(total)+\" zones added to queue - see log\";\n    return \"Added \"+itoa(total)+\" MASTER/SLAVE zones to queue\";\n  } else {\n    DNSName domain;\n    try {\n      domain = DNSName(parts[1]);\n    } catch (...) {\n      return \"Failed to parse domain as valid DNS name\";\n    }\n    if(!Communicator.notifyDomain(DNSName(parts[1]), &B))\n      return \"Failed to add to the queue - see log\";\n    return \"Added to queue\";\n  }\n}\n\nstring DLRediscoverHandler(const vector<string>&parts, Utility::pid_t ppid)\n{\n  UeberBackend B;\n  try {\n    g_log<<Logger::Error<<\"Rediscovery was requested\"<<endl;\n    string status=\"Ok\";\n    B.rediscover(&status);\n    return status;\n  }\n  catch(PDNSException &ae) {\n    return ae.reason;\n  }\n\n}\n\nstring DLReloadHandler(const vector<string>&parts, Utility::pid_t ppid)\n{\n  UeberBackend B;\n  B.reload();\n  g_log<<Logger::Error<<\"Reload was requested\"<<endl;\n  return \"Ok\";\n}\n\n\nstring DLListZones(const vector<string>&parts, Utility::pid_t ppid)\n{\n  UeberBackend B;\n  g_log<<Logger::Notice<<\"Received request to list zones.\"<<endl;\n  vector<DomainInfo> domains;\n  B.getAllDomains(&domains);\n  ostringstream ret;\n  int kindFilter = -1;\n  if (parts.size() > 1) {\n    if (toUpper(parts[1]) == \"MASTER\")\n      kindFilter = 0;\n    else if (toUpper(parts[1]) == \"SLAVE\")\n      kindFilter = 1;\n    else if (toUpper(parts[1]) == \"NATIVE\")\n      kindFilter = 2;\n  }\n\n  int count = 0;\n\n  for (const auto& di: domains) {\n    if (di.kind == kindFilter || kindFilter == -1) {\n      ret<<di.zone.toString()<<endl;\n      count++;\n    }\n  }\n  if (kindFilter != -1)\n    ret<<parts[1]<<\" zonecount:\"<<count;\n  else\n    ret<<\"All zonecount:\"<<count;\n\n  return ret.str();\n}\n\n#ifdef HAVE_P11KIT1\nextern bool PKCS11ModuleSlotLogin(const std::string& module, const string& tokenId, const std::string& pin);\n#endif\n\nstring DLTokenLogin(const vector<string>&parts, Utility::pid_t ppid)\n{\n#ifndef HAVE_P11KIT1\n  return \"PKCS#11 support not compiled in\";\n#else\n  if (parts.size() != 4) {\n    return \"invalid number of parameters, needs 4, got \" + std::to_string(parts.size());\n  }\n\n  if (PKCS11ModuleSlotLogin(parts[1], parts[2], parts[3])) {\n    return \"logged in\";\n  } else {\n    return \"could not log in, check logs\";\n  }\n#endif\n}\n"}, "40": {"id": 40, "path": "/home/runner/work/testcc/testcc/retdec/pdns/nameserver.hh", "content": "/*\n * This file is part of PowerDNS or dnsdist.\n * Copyright -- PowerDNS.COM B.V. and its contributors\n *\n * This program is free software; you can redistribute it and/or modify\n * it under the terms of version 2 of the GNU General Public License as\n * published by the Free Software Foundation.\n *\n * In addition, for the avoidance of any doubt, permission is granted to\n * link this program with OpenSSL and to (re)distribute the binaries\n * produced as the result of such linking.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with this program; if not, write to the Free Software\n * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.\n */\n#pragma once\n#include <poll.h>\n#include <sys/types.h>\n#include <sys/socket.h>\n#include <netinet/in.h>\n#include <sys/time.h>\n#include <unistd.h>\n#include <arpa/inet.h>\n#include <netdb.h>\n#include <vector>\n\n#include \"statbag.hh\"\n#include \"namespaces.hh\"\n#include \"dnspacket.hh\"\n#include \"responsestats.hh\"\n\n/** This is the main class. It opens a socket on udp port 53 and waits for packets. Those packets can \n    be retrieved with the receive() member function, which returns a DNSPacket.\n\n    Some sample code in main():\n    \\code\n    typedef Distributor<DNSPacket,DNSPacket,PacketHandler> DNSDistributor;\n    DNSDistributor D(6); // the big dispatcher!\n    \n    pthread_t qtid, atid;\n    N=new UDPNameserver;\n    \n    pthread_create(&qtid,0,qthread,static_cast<void *>(&D)); // receives packets\n    pthread_create(&atid,0,athread,static_cast<void *>(&D)); // sends packets\n    \\endcode\n\n    Code for qthread:\n    \\code\n    void *qthread(void *p)\n    {\n      DNSDistributor *D=static_cast<DNSDistributor *>(p);\n    \n      DNSPacket *P;\n    \n      while((P=N->receive())) // receive a packet\n      {\n         D->question(P); // and give to the distributor, they will delete it\n      }\n      return 0;\n    }\n\n    \\endcode\n\n*/\n\n#ifdef __linux__\n#ifndef SO_REUSEPORT\n#define SO_REUSEPORT 15\n#endif\n#endif\n\nclass UDPNameserver\n{\npublic:\n  UDPNameserver( bool additional_socket = false );  //!< Opens the socket\n  bool receive(DNSPacket& packet, std::string& buffer); //!< call this in a while or for(;;) loop to get packets\n  void send(DNSPacket&); //!< send a DNSPacket. Will call DNSPacket::truncate() if over 512 bytes\n  inline bool canReusePort() {\n    return d_can_reuseport;\n  };\n  \nprivate:\n  bool d_additional_socket;\n  bool d_can_reuseport{false};\n  vector<int> d_sockets;\n  void bindAddresses();\n  vector<pollfd> d_rfds;\n};\n\nbool AddressIsUs(const ComboAddress& remote);\n\nextern ResponseStats g_rs;\n"}, "27": {"id": 27, "path": "/usr/include/c++/7/sstream", "content": "// String based streams -*- C++ -*-\n\n// Copyright (C) 1997-2017 Free Software Foundation, Inc.\n//\n// This file is part of the GNU ISO C++ Library.  This library is free\n// software; you can redistribute it and/or modify it under the\n// terms of the GNU General Public License as published by the\n// Free Software Foundation; either version 3, or (at your option)\n// any later version.\n\n// This library is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n\n// Under Section 7 of GPL version 3, you are granted additional\n// permissions described in the GCC Runtime Library Exception, version\n// 3.1, as published by the Free Software Foundation.\n\n// You should have received a copy of the GNU General Public License and\n// a copy of the GCC Runtime Library Exception along with this program;\n// see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n// <http://www.gnu.org/licenses/>.\n\n/** @file include/sstream\n *  This is a Standard C++ Library header.\n */\n\n//\n// ISO C++ 14882: 27.7  String-based streams\n//\n\n#ifndef _GLIBCXX_SSTREAM\n#define _GLIBCXX_SSTREAM 1\n\n#pragma GCC system_header\n\n#include <istream>\n#include <ostream>\n\nnamespace std _GLIBCXX_VISIBILITY(default)\n{\n_GLIBCXX_BEGIN_NAMESPACE_VERSION\n_GLIBCXX_BEGIN_NAMESPACE_CXX11\n\n  // [27.7.1] template class basic_stringbuf\n  /**\n   *  @brief  The actual work of input and output (for std::string).\n   *  @ingroup io\n   *\n   *  @tparam _CharT  Type of character stream.\n   *  @tparam _Traits  Traits for character type, defaults to\n   *                   char_traits<_CharT>.\n   *  @tparam _Alloc  Allocator type, defaults to allocator<_CharT>.\n   *\n   *  This class associates either or both of its input and output sequences\n   *  with a sequence of characters, which can be initialized from, or made\n   *  available as, a @c std::basic_string.  (Paraphrased from [27.7.1]/1.)\n   *\n   *  For this class, open modes (of type @c ios_base::openmode) have\n   *  @c in set if the input sequence can be read, and @c out set if the\n   *  output sequence can be written.\n  */\n  template<typename _CharT, typename _Traits, typename _Alloc>\n    class basic_stringbuf : public basic_streambuf<_CharT, _Traits>\n    {\n      struct __xfer_bufptrs;\n    public:\n      // Types:\n      typedef _CharT \t\t\t\t\tchar_type;\n      typedef _Traits \t\t\t\t\ttraits_type;\n      // _GLIBCXX_RESOLVE_LIB_DEFECTS\n      // 251. basic_stringbuf missing allocator_type\n      typedef _Alloc\t\t\t\t       \tallocator_type;\n      typedef typename traits_type::int_type \t\tint_type;\n      typedef typename traits_type::pos_type \t\tpos_type;\n      typedef typename traits_type::off_type \t\toff_type;\n\n      typedef basic_streambuf<char_type, traits_type>  \t__streambuf_type;\n      typedef basic_string<char_type, _Traits, _Alloc> \t__string_type;\n      typedef typename __string_type::size_type\t\t__size_type;\n\n    protected:\n      /// Place to stash in || out || in | out settings for current stringbuf.\n      ios_base::openmode \t_M_mode;\n\n      // Data Members:\n      __string_type \t\t_M_string;\n\n    public:\n      // Constructors:\n      /**\n       *  @brief  Starts with an empty string buffer.\n       *  @param  __mode  Whether the buffer can read, or write, or both.\n       *\n       *  The default constructor initializes the parent class using its\n       *  own default ctor.\n      */\n      explicit\n      basic_stringbuf(ios_base::openmode __mode = ios_base::in | ios_base::out)\n      : __streambuf_type(), _M_mode(__mode), _M_string()\n      { }\n\n      /**\n       *  @brief  Starts with an existing string buffer.\n       *  @param  __str  A string to copy as a starting buffer.\n       *  @param  __mode  Whether the buffer can read, or write, or both.\n       *\n       *  This constructor initializes the parent class using its\n       *  own default ctor.\n      */\n      explicit\n      basic_stringbuf(const __string_type& __str,\n\t\t      ios_base::openmode __mode = ios_base::in | ios_base::out)\n      : __streambuf_type(), _M_mode(), _M_string(__str.data(), __str.size())\n      { _M_stringbuf_init(__mode); }\n\n#if __cplusplus >= 201103L\n      basic_stringbuf(const basic_stringbuf&) = delete;\n\n      basic_stringbuf(basic_stringbuf&& __rhs)\n      : basic_stringbuf(std::move(__rhs), __xfer_bufptrs(__rhs, this))\n      { __rhs._M_sync(const_cast<char_type*>(__rhs._M_string.data()), 0, 0); }\n\n      // 27.8.2.2 Assign and swap:\n\n      basic_stringbuf&\n      operator=(const basic_stringbuf&) = delete;\n\n      basic_stringbuf&\n      operator=(basic_stringbuf&& __rhs)\n      {\n\t__xfer_bufptrs __st{__rhs, this};\n\tconst __streambuf_type& __base = __rhs;\n\t__streambuf_type::operator=(__base);\n\tthis->pubimbue(__rhs.getloc());\n\t_M_mode = __rhs._M_mode;\n\t_M_string = std::move(__rhs._M_string);\n\t__rhs._M_sync(const_cast<char_type*>(__rhs._M_string.data()), 0, 0);\n\treturn *this;\n      }\n\n      void\n      swap(basic_stringbuf& __rhs)\n      {\n\t__xfer_bufptrs __l_st{*this, std::__addressof(__rhs)};\n\t__xfer_bufptrs __r_st{__rhs, this};\n\t__streambuf_type& __base = __rhs;\n\t__streambuf_type::swap(__base);\n\t__rhs.pubimbue(this->pubimbue(__rhs.getloc()));\n\tstd::swap(_M_mode, __rhs._M_mode);\n\tstd::swap(_M_string, __rhs._M_string);\n      }\n#endif\n\n      // Get and set:\n      /**\n       *  @brief  Copying out the string buffer.\n       *  @return  A copy of one of the underlying sequences.\n       *\n       *  <em>If the buffer is only created in input mode, the underlying\n       *  character sequence is equal to the input sequence; otherwise, it\n       *  is equal to the output sequence.</em> [27.7.1.2]/1\n      */\n      __string_type\n      str() const\n      {\n\t__string_type __ret;\n\tif (this->pptr())\n\t  {\n\t    // The current egptr() may not be the actual string end.\n\t    if (this->pptr() > this->egptr())\n\t      __ret = __string_type(this->pbase(), this->pptr());\n\t    else\n \t      __ret = __string_type(this->pbase(), this->egptr());\n\t  }\n\telse\n\t  __ret = _M_string;\n\treturn __ret;\n      }\n\n      /**\n       *  @brief  Setting a new buffer.\n       *  @param  __s  The string to use as a new sequence.\n       *\n       *  Deallocates any previous stored sequence, then copies @a s to\n       *  use as a new one.\n      */\n      void\n      str(const __string_type& __s)\n      {\n\t// Cannot use _M_string = __s, since v3 strings are COW\n\t// (not always true now but assign() always works).\n\t_M_string.assign(__s.data(), __s.size());\n\t_M_stringbuf_init(_M_mode);\n      }\n\n    protected:\n      // Common initialization code goes here.\n      void\n      _M_stringbuf_init(ios_base::openmode __mode)\n      {\n\t_M_mode = __mode;\n\t__size_type __len = 0;\n\tif (_M_mode & (ios_base::ate | ios_base::app))\n\t  __len = _M_string.size();\n\t_M_sync(const_cast<char_type*>(_M_string.data()), 0, __len);\n      }\n\n      virtual streamsize\n      showmanyc()\n      {\n\tstreamsize __ret = -1;\n\tif (_M_mode & ios_base::in)\n\t  {\n\t    _M_update_egptr();\n\t    __ret = this->egptr() - this->gptr();\n\t  }\n\treturn __ret;\n      }\n\n      virtual int_type\n      underflow();\n\n      virtual int_type\n      pbackfail(int_type __c = traits_type::eof());\n\n      virtual int_type\n      overflow(int_type __c = traits_type::eof());\n\n      /**\n       *  @brief  Manipulates the buffer.\n       *  @param  __s  Pointer to a buffer area.\n       *  @param  __n  Size of @a __s.\n       *  @return  @c this\n       *\n       *  If no buffer has already been created, and both @a __s and @a __n are\n       *  non-zero, then @c __s is used as a buffer; see\n       *  https://gcc.gnu.org/onlinedocs/libstdc++/manual/streambufs.html#io.streambuf.buffering\n       *  for more.\n      */\n      virtual __streambuf_type*\n      setbuf(char_type* __s, streamsize __n)\n      {\n\tif (__s && __n >= 0)\n\t  {\n\t    // This is implementation-defined behavior, and assumes\n\t    // that an external char_type array of length __n exists\n\t    // and has been pre-allocated. If this is not the case,\n\t    // things will quickly blow up.\n\n\t    // Step 1: Destroy the current internal array.\n\t    _M_string.clear();\n\n\t    // Step 2: Use the external array.\n\t    _M_sync(__s, __n, 0);\n\t  }\n\treturn this;\n      }\n\n      virtual pos_type\n      seekoff(off_type __off, ios_base::seekdir __way,\n\t      ios_base::openmode __mode = ios_base::in | ios_base::out);\n\n      virtual pos_type\n      seekpos(pos_type __sp,\n\t      ios_base::openmode __mode = ios_base::in | ios_base::out);\n\n      // Internal function for correctly updating the internal buffer\n      // for a particular _M_string, due to initialization or re-sizing\n      // of an existing _M_string.\n      void\n      _M_sync(char_type* __base, __size_type __i, __size_type __o);\n\n      // Internal function for correctly updating egptr() to the actual\n      // string end.\n      void\n      _M_update_egptr()\n      {\n\tconst bool __testin = _M_mode & ios_base::in;\n\tif (this->pptr() && this->pptr() > this->egptr())\n\t  {\n\t    if (__testin)\n\t      this->setg(this->eback(), this->gptr(), this->pptr());\n\t    else\n\t      this->setg(this->pptr(), this->pptr(), this->pptr());\n\t  }\n      }\n\n      // Works around the issue with pbump, part of the protected\n      // interface of basic_streambuf, taking just an int.\n      void\n      _M_pbump(char_type* __pbeg, char_type* __pend, off_type __off);\n\n    private:\n#if __cplusplus >= 201103L\n#if _GLIBCXX_USE_CXX11_ABI\n      // This type captures the state of the gptr / pptr pointers as offsets\n      // so they can be restored in another object after moving the string.\n      struct __xfer_bufptrs\n      {\n\t__xfer_bufptrs(const basic_stringbuf& __from, basic_stringbuf* __to)\n\t: _M_to{__to}, _M_goff{-1, -1, -1}, _M_poff{-1, -1, -1}\n\t{\n\t  const _CharT* const __str = __from._M_string.data();\n\t  const _CharT* __end = nullptr;\n\t  if (__from.eback())\n\t    {\n\t      _M_goff[0] = __from.eback() - __str;\n\t      _M_goff[1] = __from.gptr() - __str;\n\t      _M_goff[2] = __from.egptr() - __str;\n\t      __end = __from.egptr();\n\t    }\n\t  if (__from.pbase())\n\t    {\n\t      _M_poff[0] = __from.pbase() - __str;\n\t      _M_poff[1] = __from.pptr() - __from.pbase();\n\t      _M_poff[2] = __from.epptr() - __str;\n\t      if (__from.pptr() > __end)\n\t\t__end = __from.pptr();\n\t    }\n\n\t  // Set _M_string length to the greater of the get and put areas.\n\t  if (__end)\n\t    {\n\t      // The const_cast avoids changing this constructor's signature,\n\t      // because it is exported from the dynamic library.\n\t      auto& __mut_from = const_cast<basic_stringbuf&>(__from);\n\t      __mut_from._M_string._M_length(__end - __str);\n\t    }\n\t}\n\n\t~__xfer_bufptrs()\n\t{\n\t  char_type* __str = const_cast<char_type*>(_M_to->_M_string.data());\n\t  if (_M_goff[0] != -1)\n\t    _M_to->setg(__str+_M_goff[0], __str+_M_goff[1], __str+_M_goff[2]);\n\t  if (_M_poff[0] != -1)\n\t    _M_to->_M_pbump(__str+_M_poff[0], __str+_M_poff[2], _M_poff[1]);\n\t}\n\n\tbasic_stringbuf* _M_to;\n\toff_type _M_goff[3];\n\toff_type _M_poff[3];\n      };\n#else\n      // This type does nothing when using Copy-On-Write strings.\n      struct __xfer_bufptrs\n      {\n\t__xfer_bufptrs(const basic_stringbuf&, basic_stringbuf*) { }\n      };\n#endif\n\n      // The move constructor initializes an __xfer_bufptrs temporary then\n      // delegates to this constructor to performs moves during its lifetime.\n      basic_stringbuf(basic_stringbuf&& __rhs, __xfer_bufptrs&&)\n      : __streambuf_type(static_cast<const __streambuf_type&>(__rhs)),\n      _M_mode(__rhs._M_mode), _M_string(std::move(__rhs._M_string))\n      { }\n#endif\n    };\n\n\n  // [27.7.2] Template class basic_istringstream\n  /**\n   *  @brief  Controlling input for std::string.\n   *  @ingroup io\n   *\n   *  @tparam _CharT  Type of character stream.\n   *  @tparam _Traits  Traits for character type, defaults to\n   *                   char_traits<_CharT>.\n   *  @tparam _Alloc  Allocator type, defaults to allocator<_CharT>.\n   *\n   *  This class supports reading from objects of type std::basic_string,\n   *  using the inherited functions from std::basic_istream.  To control\n   *  the associated sequence, an instance of std::basic_stringbuf is used,\n   *  which this page refers to as @c sb.\n  */\n  template<typename _CharT, typename _Traits, typename _Alloc>\n    class basic_istringstream : public basic_istream<_CharT, _Traits>\n    {\n    public:\n      // Types:\n      typedef _CharT \t\t\t\t\tchar_type;\n      typedef _Traits \t\t\t\t\ttraits_type;\n      // _GLIBCXX_RESOLVE_LIB_DEFECTS\n      // 251. basic_stringbuf missing allocator_type\n      typedef _Alloc\t\t\t\t       \tallocator_type;\n      typedef typename traits_type::int_type \t\tint_type;\n      typedef typename traits_type::pos_type \t\tpos_type;\n      typedef typename traits_type::off_type \t\toff_type;\n\n      // Non-standard types:\n      typedef basic_string<_CharT, _Traits, _Alloc> \t__string_type;\n      typedef basic_stringbuf<_CharT, _Traits, _Alloc> \t__stringbuf_type;\n      typedef basic_istream<char_type, traits_type>\t__istream_type;\n\n    private:\n      __stringbuf_type\t_M_stringbuf;\n\n    public:\n      // Constructors:\n      /**\n       *  @brief  Default constructor starts with an empty string buffer.\n       *  @param  __mode  Whether the buffer can read, or write, or both.\n       *\n       *  @c ios_base::in is automatically included in @a __mode.\n       *\n       *  Initializes @c sb using @c __mode|in, and passes @c &sb to the base\n       *  class initializer.  Does not allocate any buffer.\n       *\n       *  That's a lie.  We initialize the base class with NULL, because the\n       *  string class does its own memory management.\n      */\n      explicit\n      basic_istringstream(ios_base::openmode __mode = ios_base::in)\n      : __istream_type(), _M_stringbuf(__mode | ios_base::in)\n      { this->init(&_M_stringbuf); }\n\n      /**\n       *  @brief  Starts with an existing string buffer.\n       *  @param  __str  A string to copy as a starting buffer.\n       *  @param  __mode  Whether the buffer can read, or write, or both.\n       *\n       *  @c ios_base::in is automatically included in @a mode.\n       *\n       *  Initializes @c sb using @a str and @c mode|in, and passes @c &sb\n       *  to the base class initializer.\n       *\n       *  That's a lie.  We initialize the base class with NULL, because the\n       *  string class does its own memory management.\n      */\n      explicit\n      basic_istringstream(const __string_type& __str,\n\t\t\t  ios_base::openmode __mode = ios_base::in)\n      : __istream_type(), _M_stringbuf(__str, __mode | ios_base::in)\n      { this->init(&_M_stringbuf); }\n\n      /**\n       *  @brief  The destructor does nothing.\n       *\n       *  The buffer is deallocated by the stringbuf object, not the\n       *  formatting stream.\n      */\n      ~basic_istringstream()\n      { }\n\n#if __cplusplus >= 201103L\n      basic_istringstream(const basic_istringstream&) = delete;\n\n      basic_istringstream(basic_istringstream&& __rhs)\n      : __istream_type(std::move(__rhs)),\n      _M_stringbuf(std::move(__rhs._M_stringbuf))\n      { __istream_type::set_rdbuf(&_M_stringbuf); }\n\n      // 27.8.3.2 Assign and swap:\n\n      basic_istringstream&\n      operator=(const basic_istringstream&) = delete;\n\n      basic_istringstream&\n      operator=(basic_istringstream&& __rhs)\n      {\n\t__istream_type::operator=(std::move(__rhs));\n\t_M_stringbuf = std::move(__rhs._M_stringbuf);\n\treturn *this;\n      }\n\n      void\n      swap(basic_istringstream& __rhs)\n      {\n\t__istream_type::swap(__rhs);\n\t_M_stringbuf.swap(__rhs._M_stringbuf);\n      }\n#endif\n\n      // Members:\n      /**\n       *  @brief  Accessing the underlying buffer.\n       *  @return  The current basic_stringbuf buffer.\n       *\n       *  This hides both signatures of std::basic_ios::rdbuf().\n      */\n      __stringbuf_type*\n      rdbuf() const\n      { return const_cast<__stringbuf_type*>(&_M_stringbuf); }\n\n      /**\n       *  @brief  Copying out the string buffer.\n       *  @return  @c rdbuf()->str()\n      */\n      __string_type\n      str() const\n      { return _M_stringbuf.str(); }\n\n      /**\n       *  @brief  Setting a new buffer.\n       *  @param  __s  The string to use as a new sequence.\n       *\n       *  Calls @c rdbuf()->str(s).\n      */\n      void\n      str(const __string_type& __s)\n      { _M_stringbuf.str(__s); }\n    };\n\n\n  // [27.7.3] Template class basic_ostringstream\n  /**\n   *  @brief  Controlling output for std::string.\n   *  @ingroup io\n   *\n   *  @tparam _CharT  Type of character stream.\n   *  @tparam _Traits  Traits for character type, defaults to\n   *                   char_traits<_CharT>.\n   *  @tparam _Alloc  Allocator type, defaults to allocator<_CharT>.\n   *\n   *  This class supports writing to objects of type std::basic_string,\n   *  using the inherited functions from std::basic_ostream.  To control\n   *  the associated sequence, an instance of std::basic_stringbuf is used,\n   *  which this page refers to as @c sb.\n  */\n  template <typename _CharT, typename _Traits, typename _Alloc>\n    class basic_ostringstream : public basic_ostream<_CharT, _Traits>\n    {\n    public:\n      // Types:\n      typedef _CharT \t\t\t\t\tchar_type;\n      typedef _Traits \t\t\t\t\ttraits_type;\n      // _GLIBCXX_RESOLVE_LIB_DEFECTS\n      // 251. basic_stringbuf missing allocator_type\n      typedef _Alloc\t\t\t\t       \tallocator_type;\n      typedef typename traits_type::int_type \t\tint_type;\n      typedef typename traits_type::pos_type \t\tpos_type;\n      typedef typename traits_type::off_type \t\toff_type;\n\n      // Non-standard types:\n      typedef basic_string<_CharT, _Traits, _Alloc> \t__string_type;\n      typedef basic_stringbuf<_CharT, _Traits, _Alloc> \t__stringbuf_type;\n      typedef basic_ostream<char_type, traits_type>\t__ostream_type;\n\n    private:\n      __stringbuf_type\t_M_stringbuf;\n\n    public:\n      // Constructors/destructor:\n      /**\n       *  @brief  Default constructor starts with an empty string buffer.\n       *  @param  __mode  Whether the buffer can read, or write, or both.\n       *\n       *  @c ios_base::out is automatically included in @a mode.\n       *\n       *  Initializes @c sb using @c mode|out, and passes @c &sb to the base\n       *  class initializer.  Does not allocate any buffer.\n       *\n       *  That's a lie.  We initialize the base class with NULL, because the\n       *  string class does its own memory management.\n      */\n      explicit\n      basic_ostringstream(ios_base::openmode __mode = ios_base::out)\n      : __ostream_type(), _M_stringbuf(__mode | ios_base::out)\n      { this->init(&_M_stringbuf); }\n\n      /**\n       *  @brief  Starts with an existing string buffer.\n       *  @param  __str  A string to copy as a starting buffer.\n       *  @param  __mode  Whether the buffer can read, or write, or both.\n       *\n       *  @c ios_base::out is automatically included in @a mode.\n       *\n       *  Initializes @c sb using @a str and @c mode|out, and passes @c &sb\n       *  to the base class initializer.\n       *\n       *  That's a lie.  We initialize the base class with NULL, because the\n       *  string class does its own memory management.\n      */\n      explicit\n      basic_ostringstream(const __string_type& __str,\n\t\t\t  ios_base::openmode __mode = ios_base::out)\n      : __ostream_type(), _M_stringbuf(__str, __mode | ios_base::out)\n      { this->init(&_M_stringbuf); }\n\n      /**\n       *  @brief  The destructor does nothing.\n       *\n       *  The buffer is deallocated by the stringbuf object, not the\n       *  formatting stream.\n      */\n      ~basic_ostringstream()\n      { }\n\n#if __cplusplus >= 201103L\n      basic_ostringstream(const basic_ostringstream&) = delete;\n\n      basic_ostringstream(basic_ostringstream&& __rhs)\n      : __ostream_type(std::move(__rhs)),\n      _M_stringbuf(std::move(__rhs._M_stringbuf))\n      { __ostream_type::set_rdbuf(&_M_stringbuf); }\n\n      // 27.8.3.2 Assign and swap:\n\n      basic_ostringstream&\n      operator=(const basic_ostringstream&) = delete;\n\n      basic_ostringstream&\n      operator=(basic_ostringstream&& __rhs)\n      {\n\t__ostream_type::operator=(std::move(__rhs));\n\t_M_stringbuf = std::move(__rhs._M_stringbuf);\n\treturn *this;\n      }\n\n      void\n      swap(basic_ostringstream& __rhs)\n      {\n\t__ostream_type::swap(__rhs);\n\t_M_stringbuf.swap(__rhs._M_stringbuf);\n      }\n#endif\n\n      // Members:\n      /**\n       *  @brief  Accessing the underlying buffer.\n       *  @return  The current basic_stringbuf buffer.\n       *\n       *  This hides both signatures of std::basic_ios::rdbuf().\n      */\n      __stringbuf_type*\n      rdbuf() const\n      { return const_cast<__stringbuf_type*>(&_M_stringbuf); }\n\n      /**\n       *  @brief  Copying out the string buffer.\n       *  @return  @c rdbuf()->str()\n      */\n      __string_type\n      str() const\n      { return _M_stringbuf.str(); }\n\n      /**\n       *  @brief  Setting a new buffer.\n       *  @param  __s  The string to use as a new sequence.\n       *\n       *  Calls @c rdbuf()->str(s).\n      */\n      void\n      str(const __string_type& __s)\n      { _M_stringbuf.str(__s); }\n    };\n\n\n  // [27.7.4] Template class basic_stringstream\n  /**\n   *  @brief  Controlling input and output for std::string.\n   *  @ingroup io\n   *\n   *  @tparam _CharT  Type of character stream.\n   *  @tparam _Traits  Traits for character type, defaults to\n   *                   char_traits<_CharT>.\n   *  @tparam _Alloc  Allocator type, defaults to allocator<_CharT>.\n   *\n   *  This class supports reading from and writing to objects of type\n   *  std::basic_string, using the inherited functions from\n   *  std::basic_iostream.  To control the associated sequence, an instance\n   *  of std::basic_stringbuf is used, which this page refers to as @c sb.\n  */\n  template <typename _CharT, typename _Traits, typename _Alloc>\n    class basic_stringstream : public basic_iostream<_CharT, _Traits>\n    {\n    public:\n      // Types:\n      typedef _CharT \t\t\t\t\tchar_type;\n      typedef _Traits \t\t\t\t\ttraits_type;\n      // _GLIBCXX_RESOLVE_LIB_DEFECTS\n      // 251. basic_stringbuf missing allocator_type\n      typedef _Alloc\t\t\t\t       \tallocator_type;\n      typedef typename traits_type::int_type \t\tint_type;\n      typedef typename traits_type::pos_type \t\tpos_type;\n      typedef typename traits_type::off_type \t\toff_type;\n\n      // Non-standard Types:\n      typedef basic_string<_CharT, _Traits, _Alloc> \t__string_type;\n      typedef basic_stringbuf<_CharT, _Traits, _Alloc> \t__stringbuf_type;\n      typedef basic_iostream<char_type, traits_type>\t__iostream_type;\n\n    private:\n      __stringbuf_type\t_M_stringbuf;\n\n    public:\n      // Constructors/destructors\n      /**\n       *  @brief  Default constructor starts with an empty string buffer.\n       *  @param  __m  Whether the buffer can read, or write, or both.\n       *\n       *  Initializes @c sb using the mode from @c __m, and passes @c\n       *  &sb to the base class initializer.  Does not allocate any\n       *  buffer.\n       *\n       *  That's a lie.  We initialize the base class with NULL, because the\n       *  string class does its own memory management.\n      */\n      explicit\n      basic_stringstream(ios_base::openmode __m = ios_base::out | ios_base::in)\n      : __iostream_type(), _M_stringbuf(__m)\n      { this->init(&_M_stringbuf); }\n\n      /**\n       *  @brief  Starts with an existing string buffer.\n       *  @param  __str  A string to copy as a starting buffer.\n       *  @param  __m  Whether the buffer can read, or write, or both.\n       *\n       *  Initializes @c sb using @a __str and @c __m, and passes @c &sb\n       *  to the base class initializer.\n       *\n       *  That's a lie.  We initialize the base class with NULL, because the\n       *  string class does its own memory management.\n      */\n      explicit\n      basic_stringstream(const __string_type& __str,\n\t\t\t ios_base::openmode __m = ios_base::out | ios_base::in)\n      : __iostream_type(), _M_stringbuf(__str, __m)\n      { this->init(&_M_stringbuf); }\n\n      /**\n       *  @brief  The destructor does nothing.\n       *\n       *  The buffer is deallocated by the stringbuf object, not the\n       *  formatting stream.\n      */\n      ~basic_stringstream()\n      { }\n\n#if __cplusplus >= 201103L\n      basic_stringstream(const basic_stringstream&) = delete;\n\n      basic_stringstream(basic_stringstream&& __rhs)\n      : __iostream_type(std::move(__rhs)),\n      _M_stringbuf(std::move(__rhs._M_stringbuf))\n      { __iostream_type::set_rdbuf(&_M_stringbuf); }\n\n      // 27.8.3.2 Assign and swap:\n\n      basic_stringstream&\n      operator=(const basic_stringstream&) = delete;\n\n      basic_stringstream&\n      operator=(basic_stringstream&& __rhs)\n      {\n\t__iostream_type::operator=(std::move(__rhs));\n\t_M_stringbuf = std::move(__rhs._M_stringbuf);\n\treturn *this;\n      }\n\n      void\n      swap(basic_stringstream& __rhs)\n      {\n\t__iostream_type::swap(__rhs);\n\t_M_stringbuf.swap(__rhs._M_stringbuf);\n      }\n#endif\n\n      // Members:\n      /**\n       *  @brief  Accessing the underlying buffer.\n       *  @return  The current basic_stringbuf buffer.\n       *\n       *  This hides both signatures of std::basic_ios::rdbuf().\n      */\n      __stringbuf_type*\n      rdbuf() const\n      { return const_cast<__stringbuf_type*>(&_M_stringbuf); }\n\n      /**\n       *  @brief  Copying out the string buffer.\n       *  @return  @c rdbuf()->str()\n      */\n      __string_type\n      str() const\n      { return _M_stringbuf.str(); }\n\n      /**\n       *  @brief  Setting a new buffer.\n       *  @param  __s  The string to use as a new sequence.\n       *\n       *  Calls @c rdbuf()->str(s).\n      */\n      void\n      str(const __string_type& __s)\n      { _M_stringbuf.str(__s); }\n    };\n\n#if __cplusplus >= 201103L\n  /// Swap specialization for stringbufs.\n  template <class _CharT, class _Traits, class _Allocator>\n    inline void\n    swap(basic_stringbuf<_CharT, _Traits, _Allocator>& __x,\n\t basic_stringbuf<_CharT, _Traits, _Allocator>& __y)\n    { __x.swap(__y); }\n\n  /// Swap specialization for istringstreams.\n  template <class _CharT, class _Traits, class _Allocator>\n    inline void\n    swap(basic_istringstream<_CharT, _Traits, _Allocator>& __x,\n\t basic_istringstream<_CharT, _Traits, _Allocator>& __y)\n    { __x.swap(__y); }\n\n  /// Swap specialization for ostringstreams.\n  template <class _CharT, class _Traits, class _Allocator>\n    inline void\n    swap(basic_ostringstream<_CharT, _Traits, _Allocator>& __x,\n\t basic_ostringstream<_CharT, _Traits, _Allocator>& __y)\n    { __x.swap(__y); }\n\n  /// Swap specialization for stringstreams.\n  template <class _CharT, class _Traits, class _Allocator>\n    inline void\n    swap(basic_stringstream<_CharT, _Traits, _Allocator>& __x,\n\t basic_stringstream<_CharT, _Traits, _Allocator>& __y)\n    { __x.swap(__y); }\n#endif\n\n_GLIBCXX_END_NAMESPACE_CXX11\n_GLIBCXX_END_NAMESPACE_VERSION\n} // namespace\n\n#include <bits/sstream.tcc>\n\n#endif /* _GLIBCXX_SSTREAM */\n"}, "0": {"id": 0, "path": "/home/runner/work/testcc/testcc/retdec/config.h", "content": "/* config.h.  Generated from config.h.in by configure.  */\n/* config.h.in.  Generated from configure.ac by autoheader.  */\n\n/* Set to the user and host that builds PowerDNS */\n#define BUILD_HOST \"root@fv-az54.ajj5pmxu4xruzl4yndc50brjjg.bx.internal.cloudapp.net\"\n\n/* Define to 1 if you want to enable GSS-TSIG support */\n/* #undef ENABLE_GSS_TSIG */\n\n/* Define to 1 if you have the `accept4' function. */\n#define HAVE_ACCEPT4 1\n\n/* Define to 1 if you have the `arc4random' function. */\n/* #undef HAVE_ARC4RANDOM */\n\n/* Defined if the requested minimum BOOST version is satisfied */\n#define HAVE_BOOST 1\n\n/* Define to 1 if you have <boost/archive/text_oarchive.hpp> */\n/* #undef HAVE_BOOST_ARCHIVE_TEXT_OARCHIVE_HPP */\n\n/* Define to 1 if you have boost >= 1.48 */\n#define HAVE_BOOST_GE_148 1\n\n/* Defined if the Boost program_options library is available */\n#define HAVE_BOOST_PROGRAM_OPTIONS 1\n\n/* Define to 1 if you have <boost/program_options.hpp> */\n#define HAVE_BOOST_PROGRAM_OPTIONS_HPP 1\n\n/* Defined if the Boost serialization library is available */\n/* #undef HAVE_BOOST_SERIALIZATION */\n\n/* Define to 1 if you have <boost/test/unit_test.hpp> */\n/* #undef HAVE_BOOST_TEST_UNIT_TEST_HPP */\n\n/* Defined if the Boost unit_test_framework library is available */\n/* #undef HAVE_BOOST_UNIT_TEST_FRAMEWORK */\n\n/* Define to 1 if you have CDB */\n/* #undef HAVE_CDB */\n\n/* Define to 1 if you have the <cdb.h> header file. */\n/* #undef HAVE_CDB_H */\n\n/* Define to 1 if you have clock_gettime */\n#define HAVE_CLOCK_GETTIME 1\n\n/* Define to 1 if you have the `crypto_box_curve25519xchacha20poly1305_easy'\n   function. */\n#define HAVE_CRYPTO_BOX_CURVE25519XCHACHA20POLY1305_EASY 1\n\n/* Define to 1 if you have the `crypto_box_easy_afternm' function. */\n#define HAVE_CRYPTO_BOX_EASY_AFTERNM 1\n\n/* Define to 1 if you have the `CRYPTO_memcmp' function. */\n#define HAVE_CRYPTO_MEMCMP 1\n\n/* define if the compiler supports basic C++11 syntax */\n/* #undef HAVE_CXX11 */\n\n/* Define to 1 if you have the declaration of `NID_ED25519', and to 0 if you\n   don't. */\n#define HAVE_DECL_NID_ED25519 1\n\n/* Define to 1 if you have the declaration of `NID_ED448', and to 0 if you\n   don't. */\n#define HAVE_DECL_NID_ED448 1\n\n/* Define to 1 if you have the declaration of `NID_secp384r1', and to 0 if you\n   don't. */\n#define HAVE_DECL_NID_SECP384R1 1\n\n/* Define to 1 if you have the declaration of `NID_X9_62_prime256v1', and to 0\n   if you don't. */\n#define HAVE_DECL_NID_X9_62_PRIME256V1 1\n\n/* Define to 1 if you have the <dlfcn.h> header file. */\n#define HAVE_DLFCN_H 1\n\n/* Define to 1 if you have the `EVP_MD_CTX_free' function. */\n#define HAVE_EVP_MD_CTX_FREE 1\n\n/* Define to 1 if you have the `EVP_MD_CTX_new' function. */\n#define HAVE_EVP_MD_CTX_NEW 1\n\n/* Define if ASAN fiber annotation interface is available. */\n/* #undef HAVE_FIBER_SANITIZER */\n\n/* Define this if you have GeoIP */\n/* #undef HAVE_GEOIP */\n\n/* Define to 1 if you have the `getrandom' function. */\n#define HAVE_GETRANDOM 1\n\n/* Define to 1 if you have the `gmtime_r' function. */\n#define HAVE_GMTIME_R 1\n\n/* Define to 1 if you have the <inttypes.h> header file. */\n#define HAVE_INTTYPES_H 1\n\n/* Define to 1 to enable unsafe rng KISS */\n/* #undef HAVE_KISS_RNG */\n\n/* Define to 1 if you have the `krb5_get_init_creds_opt_set_default_flags'\n   function. */\n/* #undef HAVE_KRB5_GET_INIT_CREDS_OPT_SET_DEFAULT_FLAGS */\n\n/* Define to 1 if you have the <krb5.h> header file. */\n/* #undef HAVE_KRB5_H */\n\n/* Define to 1 if you have the <lber.h> header file. */\n/* #undef HAVE_LBER_H */\n\n/* Define to 1 if you have the <ldap.h> header file. */\n/* #undef HAVE_LDAP_H */\n\n/* Define to 1 if you have ldap_initialize */\n/* #undef HAVE_LDAP_INITIALIZE */\n\n/* Define to 1 if you have ldap_sasl_bind */\n/* #undef HAVE_LDAP_SASL_BIND */\n\n/* Define to 1 if you have OpenSSL libcrypto */\n#define HAVE_LIBCRYPTO 1\n\n/* define to 1 if OpenSSL ecdsa support is available. */\n#define HAVE_LIBCRYPTO_ECDSA 1\n\n/* define to 1 if OpenSSL ed25519 support is available. */\n#define HAVE_LIBCRYPTO_ED25519 1\n\n/* define to 1 if OpenSSL ed448 support is available. */\n#define HAVE_LIBCRYPTO_ED448 1\n\n/* define to 1 if OpenSSL EDDSA support is available. */\n#define HAVE_LIBCRYPTO_EDDSA 1\n\n/* Define to 1 if you have a functional curl library. */\n#define HAVE_LIBCURL 1\n\n/* Define to 1 if you have libdecaf */\n/* #undef HAVE_LIBDECAF */\n\n/* Have -lldap */\n/* #undef HAVE_LIBLDAP */\n\n/* Have -lldap_r */\n/* #undef HAVE_LIBLDAP_R */\n\n/* Define to 1 if you have libsodium */\n#define HAVE_LIBSODIUM 1\n\n/* Define to 1 if you have libzmq */\n/* #undef HAVE_LIBZMQ */\n\n/* Define to 1 if you have LMDB */\n/* #undef HAVE_LMDB */\n\n/* Define to 1 if you have the <lmdb.h> header file. */\n/* #undef HAVE_LMDB_H */\n\n/* Define to 1 if you have the `localtime_r' function. */\n#define HAVE_LOCALTIME_R 1\n\n/* Define to 1 if you have lua */\n#define HAVE_LUA 1\n\n/* Define if enabling LUA records. */\n/* #undef HAVE_LUA_RECORDS */\n\n/* Define to 1 if you have the <memory.h> header file. */\n#define HAVE_MEMORY_H 1\n\n/* Define to 1 if you have mmap */\n#define HAVE_MMAP 1\n\n/* Define this if you have Maxmind DB */\n/* #undef HAVE_MMDB */\n\n/* Define to 1 if you have the `OPENSSL_init_crypto' function. */\n#define HAVE_OPENSSL_INIT_CRYPTO 1\n\n/* Define to 1 if you have p11-kit-1 */\n/* #undef HAVE_P11KIT1 */\n\n/* Define to 1 if you have 0.20 or newer P11-kit */\n/* #undef HAVE_P11KIT1_V2 */\n\n/* Define if using protobuf. */\n/* #undef HAVE_PROTOBUF */\n\n/* Define to 1 if you have the <pthread_np.h> header file. */\n/* #undef HAVE_PTHREAD_NP_H */\n\n/* 1-arg pthread_setname_np */\n/* #undef HAVE_PTHREAD_SETNAME_NP_1 */\n\n/* 2-arg pthread_setname_np */\n#define HAVE_PTHREAD_SETNAME_NP_2 1\n\n/* 3-arg pthread_setname_np */\n/* #undef HAVE_PTHREAD_SETNAME_NP_3 */\n\n/* 2-arg pthread_set_name_np */\n/* #undef HAVE_PTHREAD_SET_NAME_NP_2 */\n\n/* 2-arg void pthread_set_name_np */\n/* #undef HAVE_PTHREAD_SET_NAME_NP_2_VOID */\n\n/* Define to 1 if you have the `randombytes_stir' function. */\n#define HAVE_RANDOMBYTES_STIR 1\n\n/* Define to 1 if you have the `RAND_bytes' function. */\n#define HAVE_RAND_BYTES 1\n\n/* Define to 1 if you have the `RAND_pseudo_bytes' function. */\n#define HAVE_RAND_PSEUDO_BYTES 1\n\n/* Define to 1 if you have the `recvmmsg' function. */\n#define HAVE_RECVMMSG 1\n\n/* Define to 1 if you have the `RSA_get0_key' function. */\n#define HAVE_RSA_GET0_KEY 1\n\n/* Define to 1 if you have the <sanitizer/common_interface_defs.h> header\n   file. */\n/* #undef HAVE_SANITIZER_COMMON_INTERFACE_DEFS_H */\n\n/* Define to 1 if __sanitizer_finish_switch_fiber takes only a pointer */\n/* #undef HAVE_SANITIZER_FINISH_SWITCH_FIBER_SINGLE_PTR */\n\n/* Define to 1 if __sanitizer_finish_switch_fiber takes three pointers */\n/* #undef HAVE_SANITIZER_FINISH_SWITCH_FIBER_THREE_PTRS */\n\n/* Define to 1 if you have the `sched_setscheduler' function. */\n#define HAVE_SCHED_SETSCHEDULER 1\n\n/* Define to 1 if you have the `sendmmsg' function. */\n#define HAVE_SENDMMSG 1\n\n/* Define to 1 if you have sqlite3 */\n/* #undef HAVE_SQLITE3 */\n\n/* Define to 1 if you have the <stdint.h> header file. */\n#define HAVE_STDINT_H 1\n\n/* Define to 1 if you have the <stdlib.h> header file. */\n#define HAVE_STDLIB_H 1\n\n/* Define to 1 if you have the `strcasestr' function. */\n#define HAVE_STRCASESTR 1\n\n/* Define to 1 if you have the <strings.h> header file. */\n#define HAVE_STRINGS_H 1\n\n/* Define to 1 if you have the <string.h> header file. */\n#define HAVE_STRING_H 1\n\n/* Systemd available and enabled */\n#define HAVE_SYSTEMD 1\n\n/* Define to 1 if you have the <sys/mman.h> header file. */\n#define HAVE_SYS_MMAN_H 1\n\n/* Define to 1 if you have the <sys/stat.h> header file. */\n#define HAVE_SYS_STAT_H 1\n\n/* Define to 1 if you have the <sys/types.h> header file. */\n#define HAVE_SYS_TYPES_H 1\n\n/* tm_gmtoff is available. */\n#define HAVE_TM_GMTOFF 1\n\n/* Define to 1 if you have the <unistd.h> header file. */\n#define HAVE_UNISTD_H 1\n\n/* Define to 1 if the ZeroMQ 3.x or greater API is available */\n/* #undef HAVE_ZMQ_MSG_SEND */\n\n/* Defined if libcurl supports AsynchDNS */\n#define LIBCURL_FEATURE_ASYNCHDNS 1\n\n/* Defined if libcurl supports IDN */\n#define LIBCURL_FEATURE_IDN 1\n\n/* Defined if libcurl supports IPv6 */\n#define LIBCURL_FEATURE_IPV6 1\n\n/* Defined if libcurl supports KRB4 */\n/* #undef LIBCURL_FEATURE_KRB4 */\n\n/* Defined if libcurl supports libz */\n#define LIBCURL_FEATURE_LIBZ 1\n\n/* Defined if libcurl supports NTLM */\n#define LIBCURL_FEATURE_NTLM 1\n\n/* Defined if libcurl supports SSL */\n#define LIBCURL_FEATURE_SSL 1\n\n/* Defined if libcurl supports SSPI */\n/* #undef LIBCURL_FEATURE_SSPI */\n\n/* Defined if libcurl supports DICT */\n#define LIBCURL_PROTOCOL_DICT 1\n\n/* Defined if libcurl supports FILE */\n#define LIBCURL_PROTOCOL_FILE 1\n\n/* Defined if libcurl supports FTP */\n#define LIBCURL_PROTOCOL_FTP 1\n\n/* Defined if libcurl supports FTPS */\n#define LIBCURL_PROTOCOL_FTPS 1\n\n/* Defined if libcurl supports HTTP */\n#define LIBCURL_PROTOCOL_HTTP 1\n\n/* Defined if libcurl supports HTTPS */\n#define LIBCURL_PROTOCOL_HTTPS 1\n\n/* Defined if libcurl supports IMAP */\n#define LIBCURL_PROTOCOL_IMAP 1\n\n/* Defined if libcurl supports LDAP */\n#define LIBCURL_PROTOCOL_LDAP 1\n\n/* Defined if libcurl supports POP3 */\n#define LIBCURL_PROTOCOL_POP3 1\n\n/* Defined if libcurl supports RTSP */\n#define LIBCURL_PROTOCOL_RTSP 1\n\n/* Defined if libcurl supports SMTP */\n#define LIBCURL_PROTOCOL_SMTP 1\n\n/* Defined if libcurl supports TELNET */\n#define LIBCURL_PROTOCOL_TELNET 1\n\n/* Defined if libcurl supports TFTP */\n#define LIBCURL_PROTOCOL_TFTP 1\n\n/* Define to the sub-directory where libtool stores uninstalled libraries. */\n#define LT_OBJDIR \".libs/\"\n\n/* Define to 1 if you want to benefit from malloc trace */\n/* #undef MALLOC_TRACE */\n\n/* If your OS is so broken that it needs an additional prototype */\n/* #undef NEED_INET_NTOP_PROTO */\n\n/* If POSIX typedefs need to be defined */\n/* #undef NEED_POSIX_TYPEDEF */\n\n/* Name of package */\n#define PACKAGE \"pdns\"\n\n/* Set to the package version used for secpoll */\n/* #undef PACKAGEVERSION */\n\n/* Define to the address where bug reports for this package should be sent. */\n#define PACKAGE_BUGREPORT \"\"\n\n/* Define to the full name of this package. */\n#define PACKAGE_NAME \"pdns\"\n\n/* Define to the full name and version of this package. */\n#define PACKAGE_STRING \"pdns 0.0.19515.0.master.g4af4367659\"\n\n/* Define to the one symbol short name of this package. */\n#define PACKAGE_TARNAME \"pdns\"\n\n/* Define to the home page for this package. */\n#define PACKAGE_URL \"\"\n\n/* Define to the version of this package. */\n#define PACKAGE_VERSION \"0.0.19515.0.master.g4af4367659\"\n\n/* pdns configure arguments */\n#define PDNS_CONFIG_ARGS \" '--with-modules=' '--disable-lua-records'\"\n\n/* Built-in modules */\n#define PDNS_MODULES \"\"\n\n/* Define to 1 if you have the ZeroMQ connector */\n/* #undef REMOTEBACKEND_ZEROMQ */\n\n/* Define to 1 for reproducible builds */\n/* #undef REPRODUCIBLE */\n\n/* Define to 1 if you have the ANSI C header files. */\n#define STDC_HEADERS 1\n\n/* Define to 1 if your <sys/time.h> declares `struct tm'. */\n/* #undef TM_IN_SYS_TIME */\n\n/* Define to 1 if verbose logging is enabled */\n/* #undef VERBOSELOG */\n\n/* Version number of package */\n#define VERSION \"0.0.19515.0.master.g4af4367659\"\n\n/* Define to 1 if `lex' declares `yytext' as a `char *' by default, not a\n   `char[]'. */\n/* #undef YYTEXT_POINTER */\n\n/* Define _GNU_SOURCE so that we get all necessary prototypes */\n#define _GNU_SOURCE 1\n\n/* Define curl_free() as free() if our version of curl lacks curl_free. */\n/* #undef curl_free */\n"}, "41": {"id": 41, "path": "/home/runner/work/testcc/testcc/retdec/pdns/dynhandler.hh", "content": "/*\n * This file is part of PowerDNS or dnsdist.\n * Copyright -- PowerDNS.COM B.V. and its contributors\n *\n * This program is free software; you can redistribute it and/or modify\n * it under the terms of version 2 of the GNU General Public License as\n * published by the Free Software Foundation.\n *\n * In addition, for the avoidance of any doubt, permission is granted to\n * link this program with OpenSSL and to (re)distribute the binaries\n * produced as the result of such linking.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with this program; if not, write to the Free Software\n * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.\n */\n#pragma once\n#include <vector>\n#include <string>\n#include <stdlib.h>\n#include <sys/types.h>\n\n#include <unistd.h>\n\n#include \"namespaces.hh\"\n\n\nbool DLQuitPlease();\nvoid setStatus(const string &str);\nstring DLQuitHandler(const vector<string>&parts, Utility::pid_t ppid);\nstring DLRQuitHandler(const vector<string>&parts, Utility::pid_t ppid);\nstring DLPingHandler(const vector<string>&parts, Utility::pid_t ppid);\nstring DLShowHandler(const vector<string>&parts, Utility::pid_t ppid);\nstring DLUptimeHandler(const vector<string>&parts, Utility::pid_t ppid);\nstring DLSettingsHandler(const vector<string>&parts, Utility::pid_t ppid);\nstring DLRespSizeHandler(const vector<string>&parts, Utility::pid_t ppid);\nstring DLCCHandler(const vector<string>&parts, Utility::pid_t ppid);\nstring DLQTypesHandler(const vector<string>&parts, Utility::pid_t ppid);\nstring DLRSizesHandler(const vector<string>&parts, Utility::pid_t ppid);\nstring DLRemotesHandler(const vector<string>&parts, Utility::pid_t ppid);\nstring DLStatusHandler(const vector<string>&parts, Utility::pid_t ppid);\nstring DLNotifyHandler(const vector<string>&parts, Utility::pid_t ppid);\nstring DLNotifyHostHandler(const vector<string>&parts, Utility::pid_t ppid);\nstring DLReloadHandler(const vector<string>&parts, Utility::pid_t ppid);\nstring DLRediscoverHandler(const vector<string>&parts, Utility::pid_t ppid);\nstring DLVersionHandler(const vector<string>&parts, Utility::pid_t ppid);\nstring DLPurgeHandler(const vector<string>&parts, Utility::pid_t ppid);\nstring DLNotifyRetrieveHandler(const vector<string>&parts, Utility::pid_t ppid);\nstring DLCurrentConfigHandler(const vector<string>&parts, Utility::pid_t ppid);\nstring DLListZones(const vector<string>&parts, Utility::pid_t ppid);\nstring DLTokenLogin(const vector<string>&parts, Utility::pid_t ppid);\n"}, "42": {"id": 42, "path": "/home/runner/work/testcc/testcc/retdec/pdns/dynlistener.hh", "content": "/*\n * This file is part of PowerDNS or dnsdist.\n * Copyright -- PowerDNS.COM B.V. and its contributors\n *\n * This program is free software; you can redistribute it and/or modify\n * it under the terms of version 2 of the GNU General Public License as\n * published by the Free Software Foundation.\n *\n * In addition, for the avoidance of any doubt, permission is granted to\n * link this program with OpenSSL and to (re)distribute the binaries\n * produced as the result of such linking.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with this program; if not, write to the Free Software\n * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.\n */\n#pragma once\n#include <string>\n#include <vector>\n#include <sys/types.h>\n#include <errno.h>\n#include <iostream>\n#include <sstream>\n#include \"iputils.hh\"\n#include <boost/utility.hpp>\n#include <unistd.h>\n#include <sys/un.h>\n#include <dlfcn.h>\n#include <sys/socket.h>\n#include <netinet/in.h>\n\n#include \"namespaces.hh\"\n\nclass DynListener : public boost::noncopyable\n{\npublic:\n  explicit DynListener(const string &pname=\"\");\n  explicit DynListener(const ComboAddress& addr);\n  ~DynListener();\n  void go();\n  void theListener();\n\n  typedef string g_funk_t(const vector<string> &parts, Utility::pid_t ppid); // guido!\n  typedef struct { g_funk_t *func; string args; string usage; } g_funkwithusage_t;\n  typedef map<string,g_funkwithusage_t> g_funkdb_t;\n  \n  static void registerFunc(const string &name, g_funk_t *gf, const string &usage=\"\", const string &args=\"\");\n  static void registerRestFunc(g_funk_t *gf);\n  static g_funk_t* getFunc(const string& fname) { return s_funcdb[fname].func; } \nprivate:\n  void sendlines(const string &lines);\n  string getHelp();\n  string getLine();\n\n  void listenOnUnixDomain(const std::string& fname);\n  void listenOnTCP(const ComboAddress&);\n  void createSocketAndBind(int family, struct sockaddr*local, size_t len);\n\n  NetmaskGroup d_tcprange;\n  int d_s{-1};\n  int d_client{-1};\n  bool d_nonlocal;\n  bool d_tcp{false};\n  pid_t d_ppid{0};\n  \n  string d_socketname;\n  ComboAddress d_socketaddress;\n  static g_funkdb_t s_funcdb;\n  static g_funk_t* s_restfunc;\n  bool testLive(const string& fname);\n};\n"}, "43": {"id": 43, "path": "/home/runner/work/testcc/testcc/retdec/pdns/ednsoptions.hh", "content": "/*\n * This file is part of PowerDNS or dnsdist.\n * Copyright -- PowerDNS.COM B.V. and its contributors\n *\n * This program is free software; you can redistribute it and/or modify\n * it under the terms of version 2 of the GNU General Public License as\n * published by the Free Software Foundation.\n *\n * In addition, for the avoidance of any doubt, permission is granted to\n * link this program with OpenSSL and to (re)distribute the binaries\n * produced as the result of such linking.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with this program; if not, write to the Free Software\n * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.\n */\n#pragma once\n#include \"namespaces.hh\"\n\nstruct EDNSOptionCode\n{\n  enum EDNSOptionCodeEnum {NSID=3, DAU=5, DHU=6, N3U=7, ECS=8, EXPIRE=9, COOKIE=10, TCPKEEPALIVE=11, PADDING=12, CHAIN=13, KEYTAG=14};\n};\n\n/* extract a specific EDNS0 option from a pointer on the beginning rdLen of the OPT RR */\nint getEDNSOption(char* optRR, size_t len, uint16_t wantedOption, char ** optionValue, size_t * optionValueSize);\n\nstruct EDNSOptionViewValue\n{\n  const char* content{nullptr};\n  uint16_t size{0};\n};\n\nstruct EDNSOptionView\n{\n  std::vector<EDNSOptionViewValue> values;\n};\n\ntypedef std::map<uint16_t, EDNSOptionView> EDNSOptionViewMap;\n\n/* extract all EDNS0 options from a pointer on the beginning rdLen of the OPT RR */\nint getEDNSOptions(const char* optRR, size_t len, EDNSOptionViewMap& options);\n/* extract all EDNS0 options from the content (so after rdLen) of the OPT RR */\nbool getEDNSOptionsFromContent(const std::string& content, std::vector<std::pair<uint16_t, std::string>>& options);\n\nvoid generateEDNSOption(uint16_t optionCode, const std::string& payload, std::string& res);\n"}, "44": {"id": 44, "path": "/home/runner/work/testcc/testcc/retdec/pdns/ednssubnet.hh", "content": "/*\n * This file is part of PowerDNS or dnsdist.\n * Copyright -- PowerDNS.COM B.V. and its contributors\n *\n * This program is free software; you can redistribute it and/or modify\n * it under the terms of version 2 of the GNU General Public License as\n * published by the Free Software Foundation.\n *\n * In addition, for the avoidance of any doubt, permission is granted to\n * link this program with OpenSSL and to (re)distribute the binaries\n * produced as the result of such linking.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with this program; if not, write to the Free Software\n * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.\n */\n#pragma once\n#include \"namespaces.hh\"\n#include \"iputils.hh\"\n#include \"dnsname.hh\"\n\nstruct EDNSSubnetOpts\n{\n\tNetmask source;\n\tNetmask scope;\n};\n\nbool getEDNSSubnetOptsFromString(const string& options, EDNSSubnetOpts* eso);\nbool getEDNSSubnetOptsFromString(const char* options, unsigned int len, EDNSSubnetOpts* eso);\nstring makeEDNSSubnetOptsString(const EDNSSubnetOpts& eso);\n"}, "45": {"id": 45, "path": "/home/runner/work/testcc/testcc/retdec/pdns/gss_context.hh", "content": "/*\n * This file is part of PowerDNS or dnsdist.\n * Copyright -- PowerDNS.COM B.V. and its contributors\n *\n * This program is free software; you can redistribute it and/or modify\n * it under the terms of version 2 of the GNU General Public License as\n * published by the Free Software Foundation.\n *\n * In addition, for the avoidance of any doubt, permission is granted to\n * link this program with OpenSSL and to (re)distribute the binaries\n * produced as the result of such linking.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with this program; if not, write to the Free Software\n * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.\n */\n#pragma once\n\n#ifdef ENABLE_GSS_TSIG\n#include <gssapi/gssapi.h>\n#include <gssapi/gssapi_krb5.h>\n#include <gssapi/gssapi_ext.h>\n#endif\n\n//! Generic errors\nenum GssContextError {\n  GSS_CONTEXT_NO_ERROR,\n  GSS_CONTEXT_UNSUPPORTED,\n  GSS_CONTEXT_NOT_FOUND,\n  GSS_CONTEXT_NOT_INITIALIZED,\n  GSS_CONTEXT_INVALID,\n  GSS_CONTEXT_EXPIRED,\n  GSS_CONTEXT_ALREADY_INITIALIZED\n};\n\n//! GSS context types\nenum GssContextType {\n  GSS_CONTEXT_NONE,\n  GSS_CONTEXT_INIT,\n  GSS_CONTEXT_ACCEPT\n};\n\nclass GssSecContext;\n\n/*! Class for representing GSS names, such as host/host.domain.com@REALM.\n*/\nclass GssName {\npublic:\n  //! Initialize to empty name\n  GssName() {\n    setName(\"\");\n  };\n\n  //! Initialize using specific name\n  GssName(const std::string& name) {\n    setName(name);\n  };\n\n  //! Parse name into native representation\n  bool setName(const std::string& name) {\n#ifdef ENABLE_GSS_TSIG\n    gss_buffer_desc buffer;\n    d_name = GSS_C_NO_NAME;\n\n    if (!name.empty()) {\n      buffer.length = name.size();\n      buffer.value = (void*)name.c_str();\n      d_maj = gss_import_name(&d_min, &buffer, (gss_OID)GSS_KRB5_NT_PRINCIPAL_NAME, &d_name);\n      return d_maj == GSS_S_COMPLETE;\n    }\n\n    return true;\n#endif\n    return false;\n  };\n\n  ~GssName() {\n#ifdef ENABLE_GSS_TSIG\n     if (d_name != GSS_C_NO_NAME)\n       gss_release_name(&d_min, &d_name);\n#endif\n  };\n\n  //! Compare two Gss Names, if no gss support is compiled in, returns false always\n  //! This is not necessarily same as string comparison between two non-parsed names\n  bool operator==(const GssName& rhs) {\n#ifdef ENABLE_GSS_TSIG\n    OM_uint32 maj,min;\n    int result;\n    maj = gss_compare_name(&min, d_name, rhs.d_name, &result);\n    return (maj == GSS_S_COMPLETE && result != 0);\n#endif\n    return false;\n  }\n\n  //! Compare two Gss Names, if no gss support is compiled in, returns false always\n  //! This is not necessarily same as string comparison between two non-parsed names\n  bool match(const std::string& name) {\n#ifdef ENABLE_GSS_TSIG\n    OM_uint32 maj,min;\n    int result;\n    gss_name_t comp;\n    gss_buffer_desc buffer;\n    buffer.length = name.size();\n    buffer.value = (void*)name.c_str();\n    maj = gss_import_name(&min, &buffer, (gss_OID)GSS_KRB5_NT_PRINCIPAL_NAME, &comp);\n    if (maj != GSS_S_COMPLETE)\n      throw PDNSException(\"Could not import \" + name + \": \" + std::to_string(maj) + string(\",\") + std::to_string(min));\n    // do comparison\n    maj = gss_compare_name(&min, d_name, comp, &result);\n    gss_release_name(&min, &comp);\n    return (maj == GSS_S_COMPLETE && result != 0);\n#else\n   return false;\n#endif\n  };\n\n  //! Check if GSS name was parsed successfully.\n  bool valid() {\n#ifdef ENABLE_GSS_TSIG\n    return d_maj == GSS_S_COMPLETE;\n#else\n    return false;\n#endif\n  }\nprivate:\n#ifdef ENABLE_GSS_TSIG\n  OM_uint32 d_maj,d_min;\n  gss_name_t d_name;\n#endif\n};\n\nclass GssContext {\npublic:\n  static bool supported(); //<! Returns true if GSS is supported in the first place\n  GssContext(); //<! Construct new GSS context with random name\n  GssContext(const DNSName& label); //<! Create or open existing named context\n\n  void setLocalPrincipal(const std::string& name); //<! Set our gss name\n  bool getLocalPrincipal(std::string& name); //<! Get our name\n  void setPeerPrincipal(const std::string& name); //<! Set remote name (do not use after negotiation)\n  bool getPeerPrincipal(std::string &name); //<! Return remote name, returns actual name after negotiation\n\n  void generateLabel(const std::string& suffix); //<! Generate random context name using suffix (such as mydomain.com)\n  void setLabel(const DNSName& label); //<! Set context name to this label\n  const DNSName& getLabel() { return d_label; } //<! Return context name\n\n  bool init(const std::string &input, std::string& output); //<! Perform GSS Initiate Security Context handshake\n  bool accept(const std::string &input, std::string& output); //<! Perform GSS Accept Security Context handshake\n  bool destroy(); //<! Release the cached context\n  bool expired(); //<! Check if context is expired\n  bool valid(); //<! Check if context is valid\n\n  bool sign(const std::string &input, std::string& output); //<! Sign something using gss\n  bool verify(const std::string &input, const std::string &signature); //<! Validate gss signature with something\n\n  GssContextError getError(); //<! Get error\n  const std::vector<std::string> getErrorStrings() { return d_gss_errors; } //<! Get native error texts\n private:\n  void release(); //<! Release context\n  void initialize(); //<! Initialize context\n#ifdef ENABLE_GSS_TSIG\n  void processError(const string& method, OM_uint32 maj, OM_uint32 min); //<! Process and fill error text vector\n#endif\n  DNSName d_label; //<! Context name\n  std::string d_peerPrincipal; //<! Remote name\n  std::string d_localPrincipal; //<! Our name\n  GssContextError d_error; //<! Context error\n  GssContextType d_type; //<! Context type\n  std::vector<std::string> d_gss_errors; //<! Native error string(s)\n  boost::shared_ptr<GssSecContext> d_ctx; //<! Attached security context\n};\n\nbool gss_add_signature(const DNSName& context, const std::string& message, std::string& mac); //<! Create signature\nbool gss_verify_signature(const DNSName& context, const std::string& message, const std::string& mac); //<! Validate signature\n"}, "47": {"id": 47, "path": "/home/runner/work/testcc/testcc/retdec/pdns/lock.hh", "content": "/*\n * This file is part of PowerDNS or dnsdist.\n * Copyright -- PowerDNS.COM B.V. and its contributors\n *\n * This program is free software; you can redistribute it and/or modify\n * it under the terms of version 2 of the GNU General Public License as\n * published by the Free Software Foundation.\n *\n * In addition, for the avoidance of any doubt, permission is granted to\n * link this program with OpenSSL and to (re)distribute the binaries\n * produced as the result of such linking.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with this program; if not, write to the Free Software\n * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.\n */\n#pragma once\n#include <pthread.h>\n#include <errno.h>\n#include \"misc.hh\"\n#include \"pdnsexception.hh\"\n\nclass ReadWriteLock\n{\npublic:\n  ReadWriteLock()\n  {\n    if (pthread_rwlock_init(&d_lock, nullptr) != 0) {\n      throw std::runtime_error(\"Error creating a read-write lock: \" + stringerror());\n    }\n  }\n\n  ~ReadWriteLock() {\n    /* might have been moved */\n    pthread_rwlock_destroy(&d_lock);\n  }\n\n  ReadWriteLock(const ReadWriteLock& rhs) = delete;\n  ReadWriteLock& operator=(const ReadWriteLock& rhs) = delete;\n\n  pthread_rwlock_t* getLock()\n  {\n    return &d_lock;\n  }\n\nprivate:\n  pthread_rwlock_t d_lock;\n};\n\nclass ReadLock\n{\npublic:\n  ReadLock(ReadWriteLock& lock): ReadLock(lock.getLock())\n  {\n  }\n\n  ReadLock(ReadWriteLock* lock): ReadLock(lock->getLock())\n  {\n  }\n\n  ~ReadLock()\n  {\n    if(d_lock) // may have been moved\n      pthread_rwlock_unlock(d_lock);\n  }\n\n  ReadLock(ReadLock&& rhs)\n  {\n    d_lock = rhs.d_lock;\n    rhs.d_lock = nullptr;\n  }\n  ReadLock(const ReadLock& rhs) = delete;\n  ReadLock& operator=(const ReadLock& rhs) = delete;\n\nprivate:\n  ReadLock(pthread_rwlock_t *lock) : d_lock(lock)\n  {\n    int err;\n    if((err = pthread_rwlock_rdlock(d_lock))) {\n      throw PDNSException(\"error acquiring rwlock readlock: \"+stringerror(err));\n    }\n  }\n\n pthread_rwlock_t *d_lock;\n};\n\nclass WriteLock\n{\npublic:\n  WriteLock(ReadWriteLock& lock): WriteLock(lock.getLock())\n  {\n  }\n\n  WriteLock(ReadWriteLock* lock): WriteLock(lock->getLock())\n  {\n  }\n\n  WriteLock(WriteLock&& rhs)\n  {\n    d_lock = rhs.d_lock;\n    rhs.d_lock=0;\n  }\n\n  ~WriteLock()\n  {\n    if(d_lock) // might have been moved\n      pthread_rwlock_unlock(d_lock);\n  }\n\n  WriteLock(const WriteLock& rhs) = delete;\n  WriteLock& operator=(const WriteLock& rhs) = delete;\n\nprivate:\n  WriteLock(pthread_rwlock_t *lock) : d_lock(lock)\n  {\n    int err;\n    if((err = pthread_rwlock_wrlock(d_lock))) {\n      throw PDNSException(\"error acquiring rwlock wrlock: \"+stringerror(err));\n    }\n  }\n\n  pthread_rwlock_t *d_lock;\n};\n\nclass TryReadLock\n{\npublic:\n  TryReadLock(ReadWriteLock& lock): TryReadLock(lock.getLock())\n  {\n  }\n\n  TryReadLock(ReadWriteLock* lock): TryReadLock(lock->getLock())\n  {\n  }\n\n  TryReadLock(TryReadLock&& rhs)\n  {\n    d_lock = rhs.d_lock;\n    rhs.d_lock = nullptr;\n    d_havelock = rhs.d_havelock;\n    rhs.d_havelock = false;\n  }\n\n  ~TryReadLock()\n  {\n    if(d_havelock && d_lock)\n      pthread_rwlock_unlock(d_lock);\n  }\n\n  TryReadLock(const TryReadLock& rhs) = delete;\n  TryReadLock& operator=(const TryReadLock& rhs) = delete;\n\n  bool gotIt()\n  {\n    return d_havelock;\n  }\n\nprivate:\n  TryReadLock(pthread_rwlock_t *lock) : d_lock(lock)\n  {\n    int err;\n    if((err = pthread_rwlock_tryrdlock(d_lock)) && err!=EBUSY) {\n      throw PDNSException(\"error acquiring rwlock tryrdlock: \"+stringerror(err));\n    }\n    d_havelock=(err==0);\n  }\n\n  pthread_rwlock_t *d_lock;\n  bool d_havelock;\n};\n\nclass TryWriteLock\n{\npublic:\n  TryWriteLock(ReadWriteLock& lock): TryWriteLock(lock.getLock())\n  {\n  }\n\n  TryWriteLock(ReadWriteLock* lock): TryWriteLock(lock->getLock())\n  {\n  }\n\n  TryWriteLock(TryWriteLock&& rhs)\n  {\n    d_lock = rhs.d_lock;\n    rhs.d_lock = nullptr;\n    d_havelock = rhs.d_havelock;\n    rhs.d_havelock = false;\n  }\n\n  ~TryWriteLock()\n  {\n    if(d_havelock && d_lock) // we might be moved\n      pthread_rwlock_unlock(d_lock);\n  }\n\n  TryWriteLock(const TryWriteLock& rhs) = delete;\n  TryWriteLock& operator=(const TryWriteLock& rhs) = delete;\n\n  bool gotIt()\n  {\n    return d_havelock;\n  }\n\nprivate:\n  TryWriteLock(pthread_rwlock_t *lock) : d_lock(lock)\n  {\n    d_havelock=false;\n    int err;\n    if((err = pthread_rwlock_trywrlock(d_lock)) && err!=EBUSY) {\n      throw PDNSException(\"error acquiring rwlock tryrwlock: \"+stringerror(err));\n    }\n    d_havelock=(err==0);\n  }\n\n  pthread_rwlock_t *d_lock;\n  bool d_havelock;\n};\n\n"}, "48": {"id": 48, "path": "/home/runner/work/testcc/testcc/retdec/pdns/logger.hh", "content": "/*\n * This file is part of PowerDNS or dnsdist.\n * Copyright -- PowerDNS.COM B.V. and its contributors\n *\n * This program is free software; you can redistribute it and/or modify\n * it under the terms of version 2 of the GNU General Public License as\n * published by the Free Software Foundation.\n *\n * In addition, for the avoidance of any doubt, permission is granted to\n * link this program with OpenSSL and to (re)distribute the binaries\n * produced as the result of such linking.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with this program; if not, write to the Free Software\n * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.\n */\n#pragma once\n\n#include <string>\n#include <ctime>\n#include <iostream>\n#include <sstream>\n#include <syslog.h>\n\n#include \"namespaces.hh\"\n#include \"dnsname.hh\"\n#include \"iputils.hh\"\n\n//! The Logger class can be used to log messages in various ways.\nclass Logger\n{\npublic:\n  Logger(const string &, int facility=LOG_DAEMON); //!< pass the identification you wish to appear in the log\n\n  //! The urgency of a log message\n  enum Urgency {All=32767,Alert=LOG_ALERT, Critical=LOG_CRIT, Error=LOG_ERR, Warning=LOG_WARNING,\n                Notice=LOG_NOTICE,Info=LOG_INFO, Debug=LOG_DEBUG, None=-1};\n\n  /** Log a message.\n      \\param msg Message you wish to log\n      \\param u Urgency of the message you wish to log\n  */\n  void log(const string &msg, Urgency u=Notice) noexcept;\n\n  void setFacility(int f){d_facility=f;open();} //!< Choose logging facility\n  void setFlag(int f){flags|=f;open();} //!< set a syslog flag\n  void setName(const string &);\n\n  //! set lower limit of urgency needed for console display. Messages of this urgency, and higher, will be displayed\n  void toConsole(Urgency);\n  void setLoglevel( Urgency );\n\n  void disableSyslog(bool d) {\n    d_disableSyslog = d;\n  }\n\n  void setTimestamps(bool t) {\n    d_timestamps = t;\n  }\n\n  void setPrefixed(bool p) {\n    d_prefixed = p;\n  }\n\n  //! Log to a file.\n  void toFile( const string & filename );\n  \n  void resetFlags(){flags=0;open();} //!< zero the flags\n  /** Use this to stream to your log, like this:\n      \\code\n      g_log<<\"This is an informational message\"<<endl; // logged at default loglevel (Info)\n      g_log<<Logger::Warning<<\"Out of diskspace\"<<endl; // Logged as a warning \n      g_log<<\"This is an informational message\"<<endl; // logged AGAIN at default loglevel (Info)\n      \\endcode\n  */\n  Logger& operator<<(const char *s);\n  Logger& operator<<(const string &s);   //!< log a string\n  Logger& operator<<(const DNSName&); \n  Logger& operator<<(const ComboAddress&); //!< log an address\n  Logger& operator<<(Urgency);    //!< set the urgency, << style\n\n  // Using const & since otherwise SyncRes:: values induce (illegal) copies\n  template<typename T> Logger & operator<<(const T & i) {\n\tostringstream tmp;\n\ttmp<<i;\n\t*this<<tmp.str();\n\treturn *this;\n  }\n\n  Logger& operator<<(std::ostream & (&)(std::ostream &)); //!< this is to recognise the endl, and to commit the log\n\nprivate:\n  struct PerThread\n  {\n    PerThread() : d_urgency(Info)\n    {}\n    string d_output;\n    Urgency d_urgency;\n  };\n  PerThread& getPerThread();\n  void open();\n\n  static thread_local PerThread t_perThread;\n  string name;\n  int flags;\n  int d_facility;\n  Urgency d_loglevel;\n  Urgency consoleUrgency;\n  bool opened;\n  bool d_disableSyslog;\n  bool d_timestamps{true};\n  bool d_prefixed{false};\n};\n\nLogger& getLogger();\n\n#define g_log getLogger()\n\n#ifdef VERBOSELOG\n#define DLOG(x) x\n#else\n#define DLOG(x) ((void)0)\n#endif\n"}, "50": {"id": 50, "path": "/home/runner/work/testcc/testcc/retdec/pdns/lua-auth4.hh", "content": "#pragma once\n#include \"iputils.hh\"\n#include \"dnsname.hh\"\n#include \"dnspacket.hh\"\n#include \"dnsparser.hh\"\n#include <unordered_map>\n#ifdef HAVE_CONFIG_H\n#include \"config.h\"\n#endif\n#include \"lua-base4.hh\"\n\nclass AuthLua4 : public BaseLua4\n{\npublic:\n  AuthLua4();\n  bool updatePolicy(const DNSName &qname, QType qtype, const DNSName &zonename, const DNSPacket& packet);\n  bool axfrfilter(const ComboAddress&, const DNSName&, const DNSResourceRecord&, std::vector<DNSResourceRecord>&);\n  LuaContext* getLua();\n\n  std::unique_ptr<DNSPacket> prequery(const DNSPacket& p);\n\n  ~AuthLua4(); // this is so unique_ptr works with an incomplete type\nprotected:\n  virtual void postPrepareContext() override;\n  virtual void postLoad() override;\nprivate:\n  struct UpdatePolicyQuery {\n    DNSName qname;\n    DNSName zonename;\n    uint16_t qtype;\n    ComboAddress local, remote;\n    Netmask realRemote;\n    DNSName tsigName;\n    std::string peerPrincipal;\n  };\n\n  typedef std::function<bool(const UpdatePolicyQuery&)> luacall_update_policy_t;\n  typedef std::function<std::tuple<int, std::unordered_map<int, std::unordered_map<std::string,boost::variant<unsigned int,std::string> > > >(const ComboAddress&, const DNSName&, const DNSResourceRecord&)> luacall_axfr_filter_t;\n  typedef std::function<bool(DNSPacket*)> luacall_prequery_t;\n\n  luacall_update_policy_t d_update_policy;\n  luacall_axfr_filter_t d_axfr_filter;\n  luacall_prequery_t d_prequery;\n};\nstd::vector<shared_ptr<DNSRecordContent>> luaSynth(const std::string& code, const DNSName& qname,\n                                                   const DNSName& zone, int zoneid, const DNSPacket& dnsp, uint16_t qtype);\n"}, "51": {"id": 51, "path": "/home/runner/work/testcc/testcc/retdec/pdns/lua-base4.hh", "content": "#pragma once\n#include \"namespaces.hh\"\n#include <boost/variant/variant.hpp>\n#ifdef HAVE_CONFIG_H\n#include \"config.h\"\n#endif\n#include \"ext/luawrapper/include/LuaContext.hpp\"\n\nclass BaseLua4 : public boost::noncopyable\n{\nprotected:\n  std::unique_ptr<LuaContext> d_lw; // this is way on top because it must get destroyed _last_\n\npublic:\n  BaseLua4();\n  void loadFile(const std::string &fname);\n  void loadString(const std::string &script);\n  void loadStream(std::istream &is);\n  virtual ~BaseLua4(); // this is so unique_ptr works with an incomplete type\nprotected:\n  void prepareContext();\n  virtual void postPrepareContext() = 0;\n  virtual void postLoad() = 0;\n  typedef vector<pair<string, int> > in_t;\n  vector<pair<string, boost::variant<int, in_t, struct timeval* > > > d_pd;\n  typedef vector<pair<string, boost::variant<string,bool,int,double> > > Features;\n  virtual void getFeatures(Features&);\n};\n"}, "52": {"id": 52, "path": "/home/runner/work/testcc/testcc/retdec/pdns/responsestats.hh", "content": "/*\n * This file is part of PowerDNS or dnsdist.\n * Copyright -- PowerDNS.COM B.V. and its contributors\n *\n * This program is free software; you can redistribute it and/or modify\n * it under the terms of version 2 of the GNU General Public License as\n * published by the Free Software Foundation.\n *\n * In addition, for the avoidance of any doubt, permission is granted to\n * link this program with OpenSSL and to (re)distribute the binaries\n * produced as the result of such linking.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with this program; if not, write to the Free Software\n * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.\n */\n#pragma once\n#include \"misc.hh\"\n#include \"dnspacket.hh\"\n\nclass ResponseStats\n{\npublic:\n  ResponseStats();\n\n  void submitResponse(DNSPacket &p, bool udpOrTCP);\n  void submitResponse(uint16_t qtype, uint16_t respsize, bool udpOrTCP);\n  void submitResponse(uint16_t qtype, uint16_t respsize, uint8_t rcode, bool udpOrTCP);\n  map<uint16_t, uint64_t> getQTypeResponseCounts();\n  map<uint16_t, uint64_t> getSizeResponseCounts();\n  map<uint8_t, uint64_t> getRCodeResponseCounts();\n  string getQTypeReport();\n\nprivate:\n  boost::scoped_array<std::atomic<unsigned long>> d_qtypecounters;\n  boost::scoped_array<std::atomic<unsigned long>> d_rcodecounters;\n  typedef vector<pair<uint16_t, uint64_t> > sizecounters_t;\n  sizecounters_t d_sizecounters;\n};\n\nextern ResponseStats g_rs;\n"}, "54": {"id": 54, "path": "/home/runner/work/testcc/testcc/retdec/pdns/packetcache.hh", "content": "/*\n * This file is part of PowerDNS or dnsdist.\n * Copyright -- PowerDNS.COM B.V. and its contributors\n *\n * This program is free software; you can redistribute it and/or modify\n * it under the terms of version 2 of the GNU General Public License as\n * published by the Free Software Foundation.\n *\n * In addition, for the avoidance of any doubt, permission is granted to\n * link this program with OpenSSL and to (re)distribute the binaries\n * produced as the result of such linking.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with this program; if not, write to the Free Software\n * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.\n */\n#pragma once\n#include \"ednsoptions.hh\"\n#include \"misc.hh\"\n#include \"iputils.hh\"\n\nclass PacketCache : public boost::noncopyable\n{\npublic:\n  static uint32_t canHashPacket(const std::string& packet, uint16_t* ecsBegin, uint16_t* ecsEnd)\n  {\n    uint32_t ret = 0;\n    ret = burtle(reinterpret_cast<const unsigned char*>(packet.c_str()) + 2, sizeof(dnsheader) - 2, ret); // rest of dnsheader, skip id\n    size_t packetSize = packet.size();\n    size_t pos = sizeof(dnsheader);\n    const char* end = packet.c_str() + packetSize;\n    const char* p = packet.c_str() + pos;\n\n    for(; p < end && *p; ++p, ++pos) { // XXX if you embed a 0 in your qname we'll stop lowercasing there\n      const unsigned char l = dns_tolower(*p); // label lengths can safely be lower cased\n      ret=burtle(&l, 1, ret);\n    }                           // XXX the embedded 0 in the qname will break the subnet stripping\n\n    const struct dnsheader* dh = reinterpret_cast<const struct dnsheader*>(packet.c_str());\n    const char* skipBegin = p;\n    const char* skipEnd = p;\n    if (ecsBegin != nullptr && ecsEnd != nullptr) {\n      *ecsBegin = 0;\n      *ecsEnd = 0;\n    }\n    /* we need at least 1 (final empty label) + 2 (QTYPE) + 2 (QCLASS)\n       + OPT root label (1), type (2), class (2) and ttl (4)\n       + the OPT RR rdlen (2)\n       = 16\n    */\n    if(ntohs(dh->arcount)==1 && (pos+16) < packetSize) {\n      char* optionBegin = nullptr;\n      size_t optionLen = 0;\n      /* skip the final empty label (1), the qtype (2), qclass (2) */\n      /* root label (1), type (2), class (2) and ttl (4) */\n      int res = getEDNSOption(const_cast<char*>(reinterpret_cast<const char*>(p)) + 14, end - (p + 14), EDNSOptionCode::ECS, &optionBegin, &optionLen);\n      if (res == 0) {\n        skipBegin = optionBegin;\n        skipEnd = optionBegin + optionLen;\n        if (ecsBegin != nullptr && ecsEnd != nullptr) {\n          *ecsBegin = optionBegin - packet.c_str();\n          *ecsEnd = *ecsBegin + optionLen;\n        }\n      }\n    }\n    if (skipBegin > p) {\n      ret = burtle(reinterpret_cast<const unsigned char*>(p), skipBegin-p, ret);\n    }\n    if (skipEnd < end) {\n      ret = burtle(reinterpret_cast<const unsigned char*>(skipEnd), end-skipEnd, ret);\n    }\n\n    return ret;\n  }\n\n  static uint32_t canHashPacket(const std::string& packet)\n  {\n    uint32_t ret = 0;\n    ret = burtle(reinterpret_cast<const unsigned char*>(packet.c_str()) + 2, sizeof(dnsheader) - 2, ret); // rest of dnsheader, skip id\n    size_t packetSize = packet.size();\n    size_t pos = sizeof(dnsheader);\n    const char* end = packet.c_str() + packetSize;\n    const char* p = packet.c_str() + pos;\n\n    for(; p < end && *p; ++p) { // XXX if you embed a 0 in your qname we'll stop lowercasing there\n      const unsigned char l = dns_tolower(*p); // label lengths can safely be lower cased\n      ret=burtle(&l, 1, ret);\n    }                           // XXX the embedded 0 in the qname will break the subnet stripping\n\n    if (p < end) {\n      ret = burtle(reinterpret_cast<const unsigned char*>(p), end-p, ret);\n    }\n\n    return ret;\n  }\n\n  static bool queryHeaderMatches(const std::string& cachedQuery, const std::string& query)\n  {\n    if (cachedQuery.size() != query.size()) {\n      return false;\n    }\n\n    return (cachedQuery.compare(/* skip the ID */ 2, sizeof(dnsheader) - 2, query, 2, sizeof(dnsheader) - 2) == 0);\n  }\n\n  static bool queryMatches(const std::string& cachedQuery, const std::string& query, const DNSName& qname)\n  {\n    if (!queryHeaderMatches(cachedQuery, query)) {\n      return false;\n    }\n\n    size_t pos = sizeof(dnsheader) + qname.wirelength();\n\n    return (cachedQuery.compare(pos, cachedQuery.size() - pos, query, pos, query.size() - pos) == 0);\n  }\n\n  static bool queryMatches(const std::string& cachedQuery, const std::string& query, const DNSName& qname, uint16_t ecsBegin, uint16_t ecsEnd)\n  {\n    if (!queryHeaderMatches(cachedQuery, query)) {\n      return false;\n    }\n\n    size_t pos = sizeof(dnsheader) + qname.wirelength();\n\n    if (ecsBegin != 0 && ecsBegin >= pos && ecsEnd > ecsBegin) {\n      if (cachedQuery.compare(pos, ecsBegin - pos, query, pos, ecsBegin - pos) != 0) {\n        return false;\n      }\n\n      if (cachedQuery.compare(ecsEnd, cachedQuery.size() - ecsEnd, query, ecsEnd, query.size() - ecsEnd) != 0) {\n        return false;\n      }\n    }\n    else {\n      if (cachedQuery.compare(pos, cachedQuery.size() - pos, query, pos, query.size() - pos) != 0) {\n        return false;\n      }\n    }\n\n    return true;\n  }\n\n};\n"}, "55": {"id": 55, "path": "/home/runner/work/testcc/testcc/retdec/pdns/packethandler.hh", "content": "/*\n * This file is part of PowerDNS or dnsdist.\n * Copyright -- PowerDNS.COM B.V. and its contributors\n *\n * This program is free software; you can redistribute it and/or modify\n * it under the terms of version 2 of the GNU General Public License as\n * published by the Free Software Foundation.\n *\n * In addition, for the avoidance of any doubt, permission is granted to\n * link this program with OpenSSL and to (re)distribute the binaries\n * produced as the result of such linking.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with this program; if not, write to the Free Software\n * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.\n */\n#pragma once\n#include <sys/socket.h>\n#include <netinet/in.h>\n#include <arpa/inet.h>\n#include \"ueberbackend.hh\"\n#include \"dnspacket.hh\"\n#include \"packetcache.hh\"\n#include \"dnsseckeeper.hh\"\n#include \"lua-auth4.hh\"\n#include \"gss_context.hh\"\n\n#include \"namespaces.hh\"\n\n// silly Solaris people define PC\n#undef PC\n\n/** Central DNS logic according to RFC1034. Ask this class a question in the form of a DNSPacket\n    and it will return, synchronously, a DNSPacket answer, suitable for \n    sending out over the network. \n\n    The PacketHandler gives your question to the PacketCache for possible inclusion\n    in the cache.\n\n    In order to do so, the PacketHandler contains a reference to the global extern PacketCache PC\n\n    It also contains an UeberBackend instance for answering the subqueries needed to generate\n    a complete reply.\n\n*/\nclass NSEC3PARAMRecordContent;\n\nclass PacketHandler\n{\npublic:\n  std::unique_ptr<DNSPacket> doQuestion(DNSPacket&); //!< hand us a DNS packet with a question, we give you an answer\n  std::unique_ptr<DNSPacket> question(DNSPacket&); //!< hand us a DNS packet with a question, we give you an answer\n  PacketHandler(); \n  ~PacketHandler(); // defined in packethandler.cc, and does --count\n  static int numRunning(){return s_count;}; //!< Returns the number of running PacketHandlers. Called by Distributor\n \n  UeberBackend *getBackend();\n\n  int trySuperMasterSynchronous(const DNSPacket& p, const DNSName& tsigkeyname);\n  static NetmaskGroup s_allowNotifyFrom;\n  static set<string> s_forwardNotify;\n\nprivate:\n  int trySuperMaster(const DNSPacket& p, const DNSName& tsigkeyname);\n  int processNotify(const DNSPacket& );\n  void addRootReferral(DNSPacket& r);\n  int doChaosRequest(const DNSPacket& p, std::unique_ptr<DNSPacket>& r, DNSName &target) const;\n  bool addDNSKEY(DNSPacket& p, std::unique_ptr<DNSPacket>& r, const SOAData& sd);\n  bool addCDNSKEY(DNSPacket& p, std::unique_ptr<DNSPacket>& r, const SOAData& sd);\n  bool addCDS(DNSPacket& p, std::unique_ptr<DNSPacket>& r, const SOAData& sd);\n  bool addNSEC3PARAM(const DNSPacket& p, std::unique_ptr<DNSPacket>& r, const SOAData& sd);\n  int doAdditionalProcessingAndDropAA(DNSPacket& p, std::unique_ptr<DNSPacket>& r, const SOAData& sd, bool retargeted);\n  void addNSECX(DNSPacket& p, std::unique_ptr<DNSPacket>& r, const DNSName &target, const DNSName &wildcard, const DNSName &auth, int mode);\n  void addNSEC(DNSPacket& p, std::unique_ptr<DNSPacket>& r, const DNSName &target, const DNSName &wildcard, const DNSName& auth, int mode);\n  void addNSEC3(DNSPacket& p, std::unique_ptr<DNSPacket>& r, const DNSName &target, const DNSName &wildcard, const DNSName& auth, const NSEC3PARAMRecordContent& nsec3param, bool narrow, int mode);\n  void emitNSEC(std::unique_ptr<DNSPacket>& r, const SOAData& sd, const DNSName& name, const DNSName& next, int mode);\n  void emitNSEC3(std::unique_ptr<DNSPacket>& r, const SOAData& sd, const NSEC3PARAMRecordContent &ns3rc, const DNSName& unhashed, const string& begin, const string& end, int mode);\n  int processUpdate(DNSPacket& p);\n  int forwardPacket(const string &msgPrefix, const DNSPacket& p, const DomainInfo& di);\n  uint performUpdate(const string &msgPrefix, const DNSRecord *rr, DomainInfo *di, bool isPresigned, bool* narrow, bool* haveNSEC3, NSEC3PARAMRecordContent *ns3pr, bool *updatedSerial);\n  int checkUpdatePrescan(const DNSRecord *rr);\n  int checkUpdatePrerequisites(const DNSRecord *rr, DomainInfo *di);\n  void increaseSerial(const string &msgPrefix, const DomainInfo *di, bool haveNSEC3, bool narrow, const NSEC3PARAMRecordContent *ns3pr);\n\n  void makeNXDomain(DNSPacket& p, std::unique_ptr<DNSPacket>& r, const DNSName& target, const DNSName& wildcard, const SOAData& sd);\n  void makeNOError(DNSPacket& p, std::unique_ptr<DNSPacket>& r, const DNSName& target, const DNSName& wildcard, const SOAData& sd, int mode);\n  vector<DNSZoneRecord> getBestReferralNS(DNSPacket& p, const SOAData& sd, const DNSName &target);\n  vector<DNSZoneRecord> getBestDNAMESynth(DNSPacket& p, const SOAData& sd, DNSName &target);\n  bool tryDNAME(DNSPacket& p, std::unique_ptr<DNSPacket>& r, const SOAData& sd, DNSName &target);\n  bool tryReferral(DNSPacket& p, std::unique_ptr<DNSPacket>& r, const SOAData& sd, const DNSName &target, bool retargeted);\n\n  bool getBestWildcard(DNSPacket& p, const SOAData& sd, const DNSName &target, DNSName &wildcard, vector<DNSZoneRecord>* ret);\n  bool tryWildcard(DNSPacket& p, std::unique_ptr<DNSPacket>& r, const SOAData& sd, DNSName &target, DNSName &wildcard, bool& retargeted, bool& nodata);\n  bool addDSforNS(DNSPacket& p, std::unique_ptr<DNSPacket>& r, const SOAData& sd, const DNSName& dsname);\n  void completeANYRecords(DNSPacket& p, std::unique_ptr<DNSPacket>& r, const SOAData& sd, const DNSName &target);\n\n  void tkeyHandler(const DNSPacket& p, std::unique_ptr<DNSPacket>& r); //<! process TKEY record, and adds TKEY record to (r)eply, or error code.\n\n  static AtomicCounter s_count;\n  static std::mutex s_rfc2136lock;\n  bool d_logDNSDetails;\n  bool d_doIPv6AdditionalProcessing;\n  bool d_doDNAME;\n  bool d_doExpandALIAS;\n  bool d_dnssec;\n  std::unique_ptr<AuthLua4> d_pdl;\n  std::unique_ptr<AuthLua4> d_update_policy_lua;\n\n  UeberBackend B; // every thread an own instance\n  DNSSECKeeper d_dk; // B is shared with DNSSECKeeper\n};\n\n"}, "46": {"id": 46, "path": "/home/runner/work/testcc/testcc/retdec/pdns/pdnsexception.hh", "content": "/*\n * This file is part of PowerDNS or dnsdist.\n * Copyright -- PowerDNS.COM B.V. and its contributors\n *\n * This program is free software; you can redistribute it and/or modify\n * it under the terms of version 2 of the GNU General Public License as\n * published by the Free Software Foundation.\n *\n * In addition, for the avoidance of any doubt, permission is granted to\n * link this program with OpenSSL and to (re)distribute the binaries\n * produced as the result of such linking.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with this program; if not, write to the Free Software\n * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.\n */\n#pragma once\n#include<string>\n\n#include \"namespaces.hh\"\n\n//! Generic Exception thrown \nclass PDNSException\n{\npublic:\n  PDNSException() : reason(\"Unspecified\") {};\n  PDNSException(string r) : reason(r) {};\n  \n  string reason; //! Print this to tell the user what went wrong\n};\n\nclass TimeoutException : public PDNSException\n{\npublic:\n  TimeoutException() : PDNSException() {}\n  TimeoutException(string r) : PDNSException(r) {}\n};\n"}, "56": {"id": 56, "path": "/home/runner/work/testcc/testcc/retdec/pdns/qtype.hh", "content": "/*\n * This file is part of PowerDNS or dnsdist.\n * Copyright -- PowerDNS.COM B.V. and its contributors\n *\n * This program is free software; you can redistribute it and/or modify\n * it under the terms of version 2 of the GNU General Public License as\n * published by the Free Software Foundation.\n *\n * In addition, for the avoidance of any doubt, permission is granted to\n * link this program with OpenSSL and to (re)distribute the binaries\n * produced as the result of such linking.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with this program; if not, write to the Free Software\n * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.\n */\n#pragma once\n#include <string>\n#include <vector>\n#include \"namespaces.hh\"\n\n/** The QType class is meant to deal easily with the different kind of resource types, like 'A', 'NS',\n *  'CNAME' etcetera. These types have both a name and a number. This class can seamlessly move between\n *   them. Use it like this:\n\n\\code\n   QType t;\n   t=\"CNAME\";\n   cout<<t.getCode()<<endl; // prints '5'\n   t=6;\n   cout<<t.getName()<<endl; // prints 'SOA'\n\\endcode\n\n*/\n\n\n\nclass QType\n{\npublic:\n  QType(); //!< Naked constructor\n  explicit QType(uint16_t); //!< convert from an integer to a QType\n  QType(const QType& orig) : code(orig.code)\n  {\n  }\n  QType &operator=(uint16_t);  //!< Assigns integers to us\n  QType &operator=(const char *); //!< Assigns strings to us\n  QType &operator=(const string &); //!< Assigns strings to us\n  QType &operator=(const QType&rhs)  //!< Assigns strings to us\n  {\n    code=rhs.code;\n    return *this;\n  }\n\n  bool operator<(const QType& rhs) const \n  {\n    return code < rhs.code;\n  }\n\n  const string getName() const; //!< Get a string representation of this type\n  uint16_t getCode() const; //!< Get the integer representation of this type\n  bool isSupportedType();\n  bool isMetadataType();\n\n  static int chartocode(const char *p); //!< convert a character string to a code\n  enum typeenum : uint16_t {\n    ENT=0,\n    A=1,\n    NS=2,\n    CNAME=5,\n    SOA=6,\n    MB=7,\n    MG=8,\n    MR=9,\n    PTR=12,\n    HINFO=13,\n    MINFO=14,\n    MX=15,\n    TXT=16,\n    RP=17,\n    AFSDB=18,\n    SIG=24,\n    KEY=25,\n    AAAA=28,\n    LOC=29,\n    SRV=33,\n    NAPTR=35,\n    KX=36,\n    CERT=37,\n    A6=38,\n    DNAME=39,\n    OPT=41,\n    APL=42,\n    DS=43,\n    SSHFP=44,\n    IPSECKEY=45,\n    RRSIG=46,\n    NSEC=47,\n    DNSKEY=48,\n    DHCID=49,\n    NSEC3=50,\n    NSEC3PARAM=51,\n    TLSA=52,\n    SMIMEA=53,\n    RKEY=57,\n    CDS=59,\n    CDNSKEY=60,\n    OPENPGPKEY=61,\n    SPF=99,\n    EUI48=108,\n    EUI64=109,\n    TKEY=249,\n    TSIG=250,\n    IXFR=251,\n    AXFR=252,\n    MAILB=253,\n    MAILA=254,\n    ANY=255,\n    URI=256,\n    CAA=257,\n    DLV=32769,\n    ADDR=65400,\n    ALIAS=65401,\n    LUA=65402\n  };\n\n  QType(typeenum orig) : code(orig)\n  {\n  }\n\n  typedef pair<string,uint16_t> namenum;\n  static vector<namenum> names;\n\n  inline bool operator==(const QType &comp) const {\n    return(comp.code==code);\n  }\n\n  inline bool operator!=(const QType &comp) const {\n    return(comp.code!=code);\n  }\n\n  inline bool operator==(QType::typeenum comp) const {\n    return(comp==code);\n  }\n\n  inline bool operator!=(QType::typeenum comp) const {\n    return(comp!=code);\n  }\n\n  inline bool operator==(uint16_t comp) const {\n    return(comp==code);\n  }\n\n  inline bool operator!=(uint16_t comp) const {\n    return(comp!=code);\n  }\n\nprivate:\n  static class init {\n    public:\n    void qtype_insert(const char* a, uint16_t num) \n    {\n      names.push_back(make_pair(string(a), num));\n    }\n\n    init()\n    {\n      qtype_insert(\"A\", 1);\n      qtype_insert(\"NS\", 2);\n      qtype_insert(\"CNAME\", 5);\n      qtype_insert(\"SOA\", 6);\n      qtype_insert(\"MB\", 7);\n      qtype_insert(\"MG\", 8);\n      qtype_insert(\"MR\", 9);\n      qtype_insert(\"PTR\", 12);\n      qtype_insert(\"HINFO\", 13);\n      qtype_insert(\"MINFO\", 14);\n      qtype_insert(\"MX\", 15);\n      qtype_insert(\"TXT\", 16);\n      qtype_insert(\"RP\", 17);\n      qtype_insert(\"AFSDB\", 18);\n      qtype_insert(\"SIG\", 24);\n      qtype_insert(\"KEY\", 25);\n      qtype_insert(\"AAAA\", 28);\n      qtype_insert(\"LOC\", 29);\n      qtype_insert(\"SRV\", 33);\n      qtype_insert(\"NAPTR\", 35);\n      qtype_insert(\"KX\", 36);\n      qtype_insert(\"CERT\", 37);\n      qtype_insert(\"A6\", 38);\n      qtype_insert(\"DNAME\", 39);\n      qtype_insert(\"OPT\", 41);\n      qtype_insert(\"APL\", 42);\n      qtype_insert(\"DS\", 43);\n      qtype_insert(\"SSHFP\", 44);\n      qtype_insert(\"IPSECKEY\", 45);\n      qtype_insert(\"RRSIG\", 46);\n      qtype_insert(\"NSEC\", 47);\n      qtype_insert(\"DNSKEY\", 48);\n      qtype_insert(\"DHCID\", 49);\n      qtype_insert(\"NSEC3\", 50);\n      qtype_insert(\"NSEC3PARAM\", 51);\n      qtype_insert(\"TLSA\", 52);\n      qtype_insert(\"SMIMEA\", 53);\n      qtype_insert(\"RKEY\", 57);\n      qtype_insert(\"CDS\", 59);\n      qtype_insert(\"CDNSKEY\", 60);\n      qtype_insert(\"OPENPGPKEY\", 61);\n      qtype_insert(\"SPF\", 99);\n      qtype_insert(\"EUI48\", 108);\n      qtype_insert(\"EUI64\", 109);\n      qtype_insert(\"TKEY\", 249);\n//      qtype_insert(\"TSIG\", 250);\n      qtype_insert(\"IXFR\", 251);\n      qtype_insert(\"AXFR\", 252);\n      qtype_insert(\"MAILB\", 253);\n      qtype_insert(\"MAILA\", 254);\n      qtype_insert(\"ANY\", 255);\n      qtype_insert(\"URI\", 256);\n      qtype_insert(\"CAA\", 257);\n      qtype_insert(\"DLV\", 32769);\n      qtype_insert(\"ADDR\", 65400);\n      qtype_insert(\"ALIAS\", 65401);\n      qtype_insert(\"LUA\", 65402);\n    }\n  } initializer;\n\n  uint16_t code;\n};\n\nstruct QClass\n{\n  enum QClassEnum {IN=1, CHAOS=3, NONE=254, ANY=255};\n};\n"}, "57": {"id": 57, "path": "/home/runner/work/testcc/testcc/retdec/pdns/rcpgenerator.hh", "content": "/*\n * This file is part of PowerDNS or dnsdist.\n * Copyright -- PowerDNS.COM B.V. and its contributors\n *\n * This program is free software; you can redistribute it and/or modify\n * it under the terms of version 2 of the GNU General Public License as\n * published by the Free Software Foundation.\n *\n * In addition, for the avoidance of any doubt, permission is granted to\n * link this program with OpenSSL and to (re)distribute the binaries\n * produced as the result of such linking.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with this program; if not, write to the Free Software\n * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.\n */\n#pragma once\n#include <inttypes.h>\n#include <string>\n#include <stdexcept>\n\n#include \"namespaces.hh\"\n#include \"dnsname.hh\"\n#include \"iputils.hh\"\n\nclass RecordTextException : public runtime_error\n{\npublic:\n  RecordTextException(const string& str) : runtime_error(str)\n  {}\n};\n\nclass RecordTextReader\n{\npublic:\n  RecordTextReader(const string& str, const DNSName& zone=DNSName(\"\"));\n  void xfr64BitInt(uint64_t& val);\n  void xfr48BitInt(uint64_t& val);\n  void xfr32BitInt(uint32_t& val);\n  void xfr16BitInt(uint16_t& val);\n  void xfr8BitInt(uint8_t& val);\n\n  void xfrType(uint16_t& val);\n  void xfrIP(uint32_t& val);\n  void xfrIP6(std::string& val);\n  void xfrCAWithoutPort(uint8_t version, ComboAddress &val);\n  void xfrCAPort(ComboAddress &val);\n  void xfrTime(uint32_t& val);\n\n  void xfrName(DNSName& val, bool compress=false, bool noDot=false);\n  void xfrText(string& val, bool multi=false, bool lenField=true);\n  void xfrUnquotedText(string& val, bool lenField=true);\n  void xfrHexBlob(string& val, bool keepReading=false);\n  void xfrBase32HexBlob(string& val);\n\n  void xfrBlobNoSpaces(string& val, int len=-1);\n  void xfrBlob(string& val, int len=-1);\n\n  const string getRemaining() const {\n    return d_string.substr(d_pos);\n  }\n\n  bool eof();\nprivate:\n  string d_string;\n  DNSName d_zone;\n  string::size_type d_pos;\n  string::size_type d_end;\n  void skipSpaces();\n};\n\nclass RecordTextWriter\n{\npublic:\n  RecordTextWriter(string& str, bool noDot=false);\n  void xfr48BitInt(const uint64_t& val);\n  void xfr32BitInt(const uint32_t& val);\n  void xfr16BitInt(const uint16_t& val);\n  void xfr8BitInt(const uint8_t& val);\n  void xfrIP(const uint32_t& val);\n  void xfrIP6(const std::string& val);\n  void xfrCAWithoutPort(uint8_t version, ComboAddress &val);\n  void xfrCAPort(ComboAddress &val);\n  void xfrTime(const uint32_t& val);\n  void xfrBase32HexBlob(const string& val);\n\n  void xfrType(const uint16_t& val);\n  void xfrName(const DNSName& val, bool compress=false, bool noDot=false);\n  void xfrText(const string& val, bool multi=false, bool lenField=true);\n  void xfrUnquotedText(const string& val, bool lenField=true);\n  void xfrBlobNoSpaces(const string& val, int len=-1);\n  void xfrBlob(const string& val, int len=-1);\n  void xfrHexBlob(const string& val, bool keepReading=false);\n  bool eof() { return true; };\n\n  const string getRemaining() const {\n     return \"\";\n  }\nprivate:\n  string& d_string;\n  bool d_nodot;\n};\n"}, "58": {"id": 58, "path": "/home/runner/work/testcc/testcc/retdec/pdns/statbag.hh", "content": "/*\n * This file is part of PowerDNS or dnsdist.\n * Copyright -- PowerDNS.COM B.V. and its contributors\n *\n * This program is free software; you can redistribute it and/or modify\n * it under the terms of version 2 of the GNU General Public License as\n * published by the Free Software Foundation.\n *\n * In addition, for the avoidance of any doubt, permission is granted to\n * link this program with OpenSSL and to (re)distribute the binaries\n * produced as the result of such linking.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with this program; if not, write to the Free Software\n * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.\n */\n#pragma once\n#include <pthread.h>\n#include <map>\n#include <mutex>\n#include <functional>\n#include <string>\n#include <vector>\n#include \"lock.hh\"\n#include \"namespaces.hh\"\n#include \"iputils.hh\"\n#include \"circular_buffer.hh\"\n\n\ntemplate<typename T, typename Comp=std::less<T> >\nclass StatRing\n{\npublic:\n  StatRing(unsigned int size=10000);\n  // Some older C++ libs have trouble emplacing without a copy-constructor, so provide one\n  StatRing(const StatRing &);\n  StatRing & operator=(const StatRing &) = delete;\n  \n  void account(const T &item);\n\n  uint64_t getSize() const;\n  uint64_t getEntriesCount() const;\n  void resize(unsigned int newsize);  \n  void reset();\n  void setHelp(const string &str);\n  string getHelp();\n\n  vector<pair<T, unsigned int> > get() const;\nprivate:\n  static bool popisort(const pair<T,int> &a, const pair<T,int> &b) \n  {\n    return (a.second > b.second);\n  }\n\n  boost::circular_buffer<T> d_items;\n  mutable std::mutex d_lock;\n  string d_help;\n};\n\nenum class StatType : uint8_t {\n  counter = 1,\n  gauge = 2,\n};\n\n//! use this to gather and query statistics\nclass StatBag\n{\n  map<string, std::unique_ptr<AtomicCounter>> d_stats;\n  map<string, string> d_keyDescrips;\n  map<string, StatType> d_statTypes;\n  map<string,StatRing<string, CIStringCompare> >d_rings;\n  map<string,StatRing<SComboAddress> >d_comboRings;\n  map<string,StatRing<std::tuple<DNSName, QType> > >d_dnsnameqtyperings;\n  typedef boost::function<uint64_t(const std::string&)> func_t;\n  typedef map<string, func_t> funcstats_t;\n  funcstats_t d_funcstats;\n  bool d_doRings;\n\n  std::set<string> d_blacklist;\n\n  void registerRingStats(const string& name);\n\npublic:\n  StatBag(); //!< Naked constructor. You need to declare keys before this class becomes useful\n  ~StatBag();\n  void declare(const string &key, const string &descrip=\"\", StatType statType=StatType::counter); //!< Before you can store or access a key, you need to declare it\n  void declare(const string &key, const string &descrip, func_t func, StatType statType); //!< Before you can store or access a key, you need to declare it\n\n  void declareRing(const string &name, const string &title, unsigned int size=10000);\n  void declareComboRing(const string &name, const string &help, unsigned int size=10000);\n  void declareDNSNameQTypeRing(const string &name, const string &help, unsigned int size=10000);\n  vector<pair<string, unsigned int> >getRing(const string &name);\n  string getRingTitle(const string &name);\n  void ringAccount(const char* name, const string &item)\n  {\n    if(d_doRings)  {\n      if(!d_rings.count(name))\n\tthrow runtime_error(\"Attempting to account to non-existent ring '\"+std::string(name)+\"'\");\n\n      d_rings[name].account(item);\n    }\n  }\n  void ringAccount(const char* name, const ComboAddress &item)\n  {\n    if(d_doRings) {\n      if(!d_comboRings.count(name))\n\tthrow runtime_error(\"Attempting to account to non-existent comboRing '\"+std::string(name)+\"'\");\n      d_comboRings[name].account(item);\n    }\n  }\n  void ringAccount(const char* name, const DNSName &dnsname, const QType &qtype)\n  {\n    if(d_doRings) {\n      if(!d_dnsnameqtyperings.count(name))\n\tthrow runtime_error(\"Attempting to account to non-existent dnsname+qtype ring '\"+std::string(name)+\"'\");\n      d_dnsnameqtyperings[name].account(std::make_tuple(dnsname, qtype));\n    }\n  }\n\n  void doRings()\n  {\n    d_doRings=true;\n  }\n\n  vector<string>listRings();\n  bool ringExists(const string &name);\n  void resetRing(const string &name);\n  void resizeRing(const string &name, unsigned int newsize);\n  uint64_t getRingSize(const string &name);\n  uint64_t getRingEntriesCount(const string &name);\n\n  string directory(); //!< Returns a list of all data stored\n  vector<string> getEntries(); //!< returns a vector with datums (items)\n  string getDescrip(const string &item); //!< Returns the description of this datum/item\n  StatType getStatType(const string &item); //!< Returns the stats type for the metrics endpoint\n  void exists(const string &key); //!< call this function to throw an exception in case a key does not exist\n  inline void deposit(const string &key, int value); //!< increment the statistics behind this key by value amount\n  inline void inc(const string &key); //!< increase this key's value by one\n  void set(const string &key, unsigned long value); //!< set this key's value\n  unsigned long read(const string &key); //!< read the value behind this key\n  unsigned long readZero(const string &key); //!< read the value behind this key, and zero it afterwards\n  AtomicCounter *getPointer(const string &key); //!< get a direct pointer to the value behind a key. Use this for high performance increments\n  string getValueStr(const string &key); //!< read a value behind a key, and return it as a string\n  string getValueStrZero(const string &key); //!< read a value behind a key, and return it as a string, and zero afterwards\n  void blacklist(const string &str);\n\n  bool d_allowRedeclare; // only set this true during tests, never in production code\n};\n\ninline void StatBag::deposit(const string &key, int value)\n{\n  exists(key);\n\n  *d_stats[key]+=value;\n}\n\ninline void StatBag::inc(const string &key)\n{\n  deposit(key,1);\n}\n"}, "59": {"id": 59, "path": "/home/runner/work/testcc/testcc/retdec/pdns/tcpreceiver.hh", "content": "/*\n * This file is part of PowerDNS or dnsdist.\n * Copyright -- PowerDNS.COM B.V. and its contributors\n *\n * This program is free software; you can redistribute it and/or modify\n * it under the terms of version 2 of the GNU General Public License as\n * published by the Free Software Foundation.\n *\n * In addition, for the avoidance of any doubt, permission is granted to\n * link this program with OpenSSL and to (re)distribute the binaries\n * produced as the result of such linking.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with this program; if not, write to the Free Software\n * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.\n */\n#pragma once\n#include \"dns.hh\"\n#include \"iputils.hh\"\n#include \"dnsbackend.hh\"\n#include \"packethandler.hh\"\n#include <vector>\n#include <mutex>\n#include <poll.h>\n#include <sys/select.h>\n#include <sys/socket.h>\n#include <netinet/in.h>\n#include <arpa/inet.h>\n#include <sys/stat.h>\n#include <unistd.h>\n#include <netdb.h>\n#include <sys/uio.h>\n#include <sys/select.h>\n\n#include \"namespaces.hh\"\n\nclass TCPNameserver\n{\npublic:\n  TCPNameserver();\n  ~TCPNameserver();\n  void go();\n  unsigned int numTCPConnections();\nprivate:\n\n  static void sendPacket(std::unique_ptr<DNSPacket>& p, int outsock);\n  static int readLength(int fd, ComboAddress *remote);\n  static void getQuestion(int fd, char *mesg, int pktlen, const ComboAddress& remote, unsigned int totalTime);\n  static int doAXFR(const DNSName &target, std::unique_ptr<DNSPacket>& q, int outsock);\n  static int doIXFR(std::unique_ptr<DNSPacket>& q, int outsock);\n  static bool canDoAXFR(std::unique_ptr<DNSPacket>& q);\n  static void doConnection(int fd);\n  static void decrementClientCount(const ComboAddress& remote);\n  void thread(void);\n  static std::mutex s_plock;\n  static std::mutex s_clientsCountMutex;\n  static std::map<ComboAddress,size_t,ComboAddress::addressOnlyLessThan> s_clientsCount;\n  static std::unique_ptr<PacketHandler> s_P;\n  static std::unique_ptr<Semaphore> d_connectionroom_sem;\n  static unsigned int d_maxTCPConnections;\n  static NetmaskGroup d_ng;\n  static size_t d_maxTransactionsPerConn;\n  static size_t d_maxConnectionsPerClient;\n  static unsigned int d_idleTimeout;\n  static unsigned int d_maxConnectionDuration;\n\n  vector<int>d_sockets;\n  vector<struct pollfd> d_prfds;\n};\n"}, "60": {"id": 60, "path": "/home/runner/work/testcc/testcc/retdec/pdns/threadname.hh", "content": "/*\n * This file is part of PowerDNS or dnsdist.\n * Copyright -- PowerDNS.COM B.V. and its contributors\n *\n * This program is free software; you can redistribute it and/or modify\n * it under the terms of version 2 of the GNU General Public License as\n * published by the Free Software Foundation.\n *\n * In addition, for the avoidance of any doubt, permission is granted to\n * link this program with OpenSSL and to (re)distribute the binaries\n * produced as the result of such linking.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with this program; if not, write to the Free Software\n * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.\n */\n#pragma once\n#include <string>\n\nvoid setThreadName(const std::string& threadName);\n"}, "61": {"id": 61, "path": "/home/runner/work/testcc/testcc/retdec/pdns/utility.hh", "content": "/*\n * This file is part of PowerDNS or dnsdist.\n * Copyright -- PowerDNS.COM B.V. and its contributors\n *\n * This program is free software; you can redistribute it and/or modify\n * it under the terms of version 2 of the GNU General Public License as\n * published by the Free Software Foundation.\n *\n * In addition, for the avoidance of any doubt, permission is granted to\n * link this program with OpenSSL and to (re)distribute the binaries\n * produced as the result of such linking.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with this program; if not, write to the Free Software\n * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.\n */\n// Utility class specification.\n#pragma once\n\n#ifdef NEED_POSIX_TYPEDEF\ntypedef unsigned char uint8_t;\ntypedef unsigned short int uint16_t;\ntypedef unsigned int uint32_t;\ntypedef unsigned long long uint64_t;\n#endif\n\n#include <arpa/inet.h>\n#include <netinet/in.h>\n#include <sys/socket.h>\n#include <sys/time.h>\n#include <sys/uio.h>\n#include <signal.h>\n#include <pthread.h>\n#include <semaphore.h>\n#include <signal.h>\n#include <errno.h>\n#include <unistd.h>\n#include <string>\n\n#include \"namespaces.hh\"\n\n//! A semaphore class.\nclass Semaphore\n{\nprivate:\n  typedef int sem_value_t;\n\n#if defined(_AIX) || defined(__APPLE__)\n  uint32_t       m_magic;\n  pthread_mutex_t m_lock;\n  pthread_cond_t  m_gtzero;\n  sem_value_t     m_count;\n  uint32_t       m_nwaiters;\n#else\n  std::unique_ptr<sem_t> m_pSemaphore;\n#endif\n\nprotected:\npublic:\n  Semaphore(const Semaphore&) = delete;\n  void operator=(const Semaphore&) = delete;\n  //! Default constructor.\n  Semaphore( unsigned int value = 0 );\n\n  //! Destructor.\n  ~Semaphore( void );\n\n  //! Posts to a semaphore.\n  int post( void );\n\n  //! Waits for a semaphore.\n  int wait( void );\n\n  //! Tries to wait for a semaphore.\n  int tryWait( void );\n\n  //! Retrieves the semaphore value.\n  int getValue( Semaphore::sem_value_t *sval );\n};\n\n//! This is a utility class used for platform independent abstraction.\nclass Utility\n{\npublic:\n  typedef ::iovec iovec;\n  typedef ::pid_t pid_t;\n  typedef int sock_t;\n  typedef ::socklen_t socklen_t;\n\n  //! Connect with timeout\n  // Returns:\n  //    > 0 on success\n  //    -1 on error\n  //    0 on timeout\n  static int timed_connect(sock_t sock,\n    const sockaddr *addr,\n    socklen_t sockaddr_size,\n    int timeout_sec,\n    int timeout_usec);\n\n  //! Returns the process id of the current process.\n  static pid_t getpid( void );\n\n  //! Gets the current time.\n  static int gettimeofday( struct timeval *tv, void *tz = NULL );\n\n  //! Converts an address from dot and numbers format to binary data.\n  static int inet_aton( const char *cp, struct in_addr *inp );\n\n  //! Converts an address from presentation format to network format.\n  static int inet_pton( int af, const char *src, void *dst );\n\n  //! The inet_ntop() function converts an address from network format (usually a struct in_addr or some other binary form, in network byte order) to presentation format.\n  static const char *inet_ntop( int af, const char *src, char *dst, size_t size );\n\n  //! Writes a vector.\n  static int writev( Utility::sock_t socket, const iovec *vector, size_t count );\n\n  //! Sets the random seed.\n  static void srandom(void);\n\n  //! Drops the program's group privileges.\n  static void dropGroupPrivs( uid_t uid, gid_t gid );\n\n  //! Drops the program's user privileges.\n  static void dropUserPrivs( uid_t uid );\n  \n  //! Sets the socket into Bind-any mode\n  static void setBindAny ( int af, Utility::sock_t socket );\n  \n  //! Sleeps for a number of seconds.\n  static unsigned int sleep( unsigned int seconds );\n  \n  //! Sleeps for a number of microseconds.\n  static void usleep( unsigned long usec );\n\n  static time_t timegm(struct tm *tm);\n  \n};\n"}, "63": {"id": 63, "path": "/usr/include/luajit-2.1/lauxlib.h", "content": "/*\n** $Id: lauxlib.h,v 1.88.1.1 2007/12/27 13:02:25 roberto Exp $\n** Auxiliary functions for building Lua libraries\n** See Copyright Notice in lua.h\n*/\n\n\n#ifndef lauxlib_h\n#define lauxlib_h\n\n\n#include <stddef.h>\n#include <stdio.h>\n\n#include \"lua.h\"\n\n\n/* extra error code for `luaL_load' */\n#define LUA_ERRFILE     (LUA_ERRERR+1)\n\ntypedef struct luaL_Reg {\n  const char *name;\n  lua_CFunction func;\n} luaL_Reg;\n\nLUALIB_API void (luaL_openlib) (lua_State *L, const char *libname,\n                                const luaL_Reg *l, int nup);\nLUALIB_API void (luaL_register) (lua_State *L, const char *libname,\n                                const luaL_Reg *l);\nLUALIB_API int (luaL_getmetafield) (lua_State *L, int obj, const char *e);\nLUALIB_API int (luaL_callmeta) (lua_State *L, int obj, const char *e);\nLUALIB_API int (luaL_typerror) (lua_State *L, int narg, const char *tname);\nLUALIB_API int (luaL_argerror) (lua_State *L, int numarg, const char *extramsg);\nLUALIB_API const char *(luaL_checklstring) (lua_State *L, int numArg,\n                                                          size_t *l);\nLUALIB_API const char *(luaL_optlstring) (lua_State *L, int numArg,\n                                          const char *def, size_t *l);\nLUALIB_API lua_Number (luaL_checknumber) (lua_State *L, int numArg);\nLUALIB_API lua_Number (luaL_optnumber) (lua_State *L, int nArg, lua_Number def);\n\nLUALIB_API lua_Integer (luaL_checkinteger) (lua_State *L, int numArg);\nLUALIB_API lua_Integer (luaL_optinteger) (lua_State *L, int nArg,\n                                          lua_Integer def);\n\nLUALIB_API void (luaL_checkstack) (lua_State *L, int sz, const char *msg);\nLUALIB_API void (luaL_checktype) (lua_State *L, int narg, int t);\nLUALIB_API void (luaL_checkany) (lua_State *L, int narg);\n\nLUALIB_API int   (luaL_newmetatable) (lua_State *L, const char *tname);\nLUALIB_API void *(luaL_checkudata) (lua_State *L, int ud, const char *tname);\n\nLUALIB_API void (luaL_where) (lua_State *L, int lvl);\nLUALIB_API int (luaL_error) (lua_State *L, const char *fmt, ...);\n\nLUALIB_API int (luaL_checkoption) (lua_State *L, int narg, const char *def,\n                                   const char *const lst[]);\n\n/* pre-defined references */\n#define LUA_NOREF       (-2)\n#define LUA_REFNIL      (-1)\n\nLUALIB_API int (luaL_ref) (lua_State *L, int t);\nLUALIB_API void (luaL_unref) (lua_State *L, int t, int ref);\n\nLUALIB_API int (luaL_loadfile) (lua_State *L, const char *filename);\nLUALIB_API int (luaL_loadbuffer) (lua_State *L, const char *buff, size_t sz,\n                                  const char *name);\nLUALIB_API int (luaL_loadstring) (lua_State *L, const char *s);\n\nLUALIB_API lua_State *(luaL_newstate) (void);\n\n\nLUALIB_API const char *(luaL_gsub) (lua_State *L, const char *s, const char *p,\n                                                  const char *r);\n\nLUALIB_API const char *(luaL_findtable) (lua_State *L, int idx,\n                                         const char *fname, int szhint);\n\n/* From Lua 5.2. */\nLUALIB_API int luaL_fileresult(lua_State *L, int stat, const char *fname);\nLUALIB_API int luaL_execresult(lua_State *L, int stat);\nLUALIB_API int (luaL_loadfilex) (lua_State *L, const char *filename,\n\t\t\t\t const char *mode);\nLUALIB_API int (luaL_loadbufferx) (lua_State *L, const char *buff, size_t sz,\n\t\t\t\t   const char *name, const char *mode);\nLUALIB_API void luaL_traceback (lua_State *L, lua_State *L1, const char *msg,\n\t\t\t\tint level);\nLUALIB_API void (luaL_setfuncs) (lua_State *L, const luaL_Reg *l, int nup);\nLUALIB_API void (luaL_pushmodule) (lua_State *L, const char *modname,\n\t\t\t\t   int sizehint);\nLUALIB_API void *(luaL_testudata) (lua_State *L, int ud, const char *tname);\nLUALIB_API void (luaL_setmetatable) (lua_State *L, const char *tname);\n\n\n/*\n** ===============================================================\n** some useful macros\n** ===============================================================\n*/\n\n#define luaL_argcheck(L, cond,numarg,extramsg)\t\\\n\t\t((void)((cond) || luaL_argerror(L, (numarg), (extramsg))))\n#define luaL_checkstring(L,n)\t(luaL_checklstring(L, (n), NULL))\n#define luaL_optstring(L,n,d)\t(luaL_optlstring(L, (n), (d), NULL))\n#define luaL_checkint(L,n)\t((int)luaL_checkinteger(L, (n)))\n#define luaL_optint(L,n,d)\t((int)luaL_optinteger(L, (n), (d)))\n#define luaL_checklong(L,n)\t((long)luaL_checkinteger(L, (n)))\n#define luaL_optlong(L,n,d)\t((long)luaL_optinteger(L, (n), (d)))\n\n#define luaL_typename(L,i)\tlua_typename(L, lua_type(L,(i)))\n\n#define luaL_dofile(L, fn) \\\n\t(luaL_loadfile(L, fn) || lua_pcall(L, 0, LUA_MULTRET, 0))\n\n#define luaL_dostring(L, s) \\\n\t(luaL_loadstring(L, s) || lua_pcall(L, 0, LUA_MULTRET, 0))\n\n#define luaL_getmetatable(L,n)\t(lua_getfield(L, LUA_REGISTRYINDEX, (n)))\n\n#define luaL_opt(L,f,n,d)\t(lua_isnoneornil(L,(n)) ? (d) : f(L,(n)))\n\n/* From Lua 5.2. */\n#define luaL_newlibtable(L, l) \\\n\tlua_createtable(L, 0, sizeof(l)/sizeof((l)[0]) - 1)\n#define luaL_newlib(L, l)\t(luaL_newlibtable(L, l), luaL_setfuncs(L, l, 0))\n\n/*\n** {======================================================\n** Generic Buffer manipulation\n** =======================================================\n*/\n\n\n\ntypedef struct luaL_Buffer {\n  char *p;\t\t\t/* current position in buffer */\n  int lvl;  /* number of strings in the stack (level) */\n  lua_State *L;\n  char buffer[LUAL_BUFFERSIZE];\n} luaL_Buffer;\n\n#define luaL_addchar(B,c) \\\n  ((void)((B)->p < ((B)->buffer+LUAL_BUFFERSIZE) || luaL_prepbuffer(B)), \\\n   (*(B)->p++ = (char)(c)))\n\n/* compatibility only */\n#define luaL_putchar(B,c)\tluaL_addchar(B,c)\n\n#define luaL_addsize(B,n)\t((B)->p += (n))\n\nLUALIB_API void (luaL_buffinit) (lua_State *L, luaL_Buffer *B);\nLUALIB_API char *(luaL_prepbuffer) (luaL_Buffer *B);\nLUALIB_API void (luaL_addlstring) (luaL_Buffer *B, const char *s, size_t l);\nLUALIB_API void (luaL_addstring) (luaL_Buffer *B, const char *s);\nLUALIB_API void (luaL_addvalue) (luaL_Buffer *B);\nLUALIB_API void (luaL_pushresult) (luaL_Buffer *B);\n\n\n/* }====================================================== */\n\n#endif\n"}, "64": {"id": 64, "path": "/usr/include/luajit-2.1/lua.hpp", "content": "// C++ wrapper for LuaJIT header files.\n\nextern \"C\" {\n#include \"lua.h\"\n#include \"lauxlib.h\"\n#include \"lualib.h\"\n#include \"luajit.h\"\n}\n\n"}, "65": {"id": 65, "path": "/usr/include/luajit-2.1/luaconf.h", "content": "/*\n** Configuration header.\n** Copyright (C) 2005-2017 Mike Pall. See Copyright Notice in luajit.h\n*/\n\n#ifndef luaconf_h\n#define luaconf_h\n\n#ifndef WINVER\n#define WINVER 0x0501\n#endif\n#include <limits.h>\n#include <stddef.h>\n\n/* Default path for loading Lua and C modules with require(). */\n#if defined(_WIN32)\n/*\n** In Windows, any exclamation mark ('!') in the path is replaced by the\n** path of the directory of the executable file of the current process.\n*/\n#define LUA_LDIR\t\"!\\\\lua\\\\\"\n#define LUA_CDIR\t\"!\\\\\"\n#define LUA_PATH_DEFAULT \\\n  \".\\\\?.lua;\" LUA_LDIR\"?.lua;\" LUA_LDIR\"?\\\\init.lua;\"\n#define LUA_CPATH_DEFAULT \\\n  \".\\\\?.dll;\" LUA_CDIR\"?.dll;\" LUA_CDIR\"loadall.dll\"\n#else\n/*\n** Note to distribution maintainers: do NOT patch the following lines!\n** Please read ../doc/install.html#distro and pass PREFIX=/usr instead.\n*/\n#ifndef LUA_MULTILIB\n#define LUA_MULTILIB\t\"lib\"\n#endif\n#ifndef LUA_LMULTILIB\n#define LUA_LMULTILIB\t\"lib\"\n#endif\n#define LUA_LROOT\t\"/usr/local\"\n#define LUA_LUADIR\t\"/lua/5.1/\"\n#define LUA_LJDIR\t\"/luajit-2.1.0-beta3/\"\n\n#ifdef LUA_ROOT\n#define LUA_JROOT\tLUA_ROOT\n#define LUA_RLDIR\tLUA_ROOT \"/share\" LUA_LUADIR\n#define LUA_RCDIR\tLUA_ROOT \"/\" LUA_MULTILIB LUA_LUADIR\n#define LUA_RLPATH\t\";\" LUA_RLDIR \"?.lua;\" LUA_RLDIR \"?/init.lua\"\n#define LUA_RCPATH\t\";\" LUA_RCDIR \"?.so\"\n#else\n#define LUA_JROOT\tLUA_LROOT\n#define LUA_RLPATH\n#define LUA_RCPATH\n#endif\n\n#define LUA_JPATH\t\";\" LUA_JROOT \"/share\" LUA_LJDIR \"?.lua\"\n#define LUA_LLDIR\tLUA_LROOT \"/share\" LUA_LUADIR\n#define LUA_LCDIR\tLUA_LROOT \"/\" LUA_LMULTILIB LUA_LUADIR\n#define LUA_LLPATH\t\";\" LUA_LLDIR \"?.lua;\" LUA_LLDIR \"?/init.lua\"\n#define LUA_LCPATH1\t\";\" LUA_LCDIR \"?.so\"\n#define LUA_LCPATH2\t\";\" LUA_LCDIR \"loadall.so\"\n\n#define LUA_PATH_DEFAULT\t\"./?.lua\" LUA_JPATH LUA_LLPATH LUA_RLPATH\n#define LUA_CPATH_DEFAULT\t\"./?.so\" LUA_LCPATH1 LUA_RCPATH LUA_LCPATH2\n#endif\n\n/* Environment variable names for path overrides and initialization code. */\n#define LUA_PATH\t\"LUA_PATH\"\n#define LUA_CPATH\t\"LUA_CPATH\"\n#define LUA_INIT\t\"LUA_INIT\"\n\n/* Special file system characters. */\n#if defined(_WIN32)\n#define LUA_DIRSEP\t\"\\\\\"\n#else\n#define LUA_DIRSEP\t\"/\"\n#endif\n#define LUA_PATHSEP\t\";\"\n#define LUA_PATH_MARK\t\"?\"\n#define LUA_EXECDIR\t\"!\"\n#define LUA_IGMARK\t\"-\"\n#define LUA_PATH_CONFIG \\\n  LUA_DIRSEP \"\\n\" LUA_PATHSEP \"\\n\" LUA_PATH_MARK \"\\n\" \\\n  LUA_EXECDIR \"\\n\" LUA_IGMARK \"\\n\"\n\n/* Quoting in error messages. */\n#define LUA_QL(x)\t\"'\" x \"'\"\n#define LUA_QS\t\tLUA_QL(\"%s\")\n\n/* Various tunables. */\n#define LUAI_MAXSTACK\t65500\t/* Max. # of stack slots for a thread (<64K). */\n#define LUAI_MAXCSTACK\t8000\t/* Max. # of stack slots for a C func (<10K). */\n#define LUAI_GCPAUSE\t200\t/* Pause GC until memory is at 200%. */\n#define LUAI_GCMUL\t200\t/* Run GC at 200% of allocation speed. */\n#define LUA_MAXCAPTURES\t32\t/* Max. pattern captures. */\n\n/* Configuration for the frontend (the luajit executable). */\n#if defined(luajit_c)\n#define LUA_PROGNAME\t\"luajit\"  /* Fallback frontend name. */\n#define LUA_PROMPT\t\"> \"\t/* Interactive prompt. */\n#define LUA_PROMPT2\t\">> \"\t/* Continuation prompt. */\n#define LUA_MAXINPUT\t512\t/* Max. input line length. */\n#endif\n\n/* Note: changing the following defines breaks the Lua 5.1 ABI. */\n#define LUA_INTEGER\tptrdiff_t\n#define LUA_IDSIZE\t60\t/* Size of lua_Debug.short_src. */\n/*\n** Size of lauxlib and io.* on-stack buffers. Weird workaround to avoid using\n** unreasonable amounts of stack space, but still retain ABI compatibility.\n** Blame Lua for depending on BUFSIZ in the ABI, blame **** for wrecking it.\n*/\n#define LUAL_BUFFERSIZE\t(BUFSIZ > 16384 ? 8192 : BUFSIZ)\n\n/* The following defines are here only for compatibility with luaconf.h\n** from the standard Lua distribution. They must not be changed for LuaJIT.\n*/\n#define LUA_NUMBER_DOUBLE\n#define LUA_NUMBER\t\tdouble\n#define LUAI_UACNUMBER\t\tdouble\n#define LUA_NUMBER_SCAN\t\t\"%lf\"\n#define LUA_NUMBER_FMT\t\t\"%.14g\"\n#define lua_number2str(s, n)\tsprintf((s), LUA_NUMBER_FMT, (n))\n#define LUAI_MAXNUMBER2STR\t32\n#define LUA_INTFRMLEN\t\t\"l\"\n#define LUA_INTFRM_T\t\tlong\n\n/* Linkage of public API functions. */\n#if defined(LUA_BUILD_AS_DLL)\n#if defined(LUA_CORE) || defined(LUA_LIB)\n#define LUA_API\t\t__declspec(dllexport)\n#else\n#define LUA_API\t\t__declspec(dllimport)\n#endif\n#else\n#define LUA_API\t\textern\n#endif\n\n#define LUALIB_API\tLUA_API\n\n/* Support for internal assertions. */\n#if defined(LUA_USE_ASSERT) || defined(LUA_USE_APICHECK)\n#include <assert.h>\n#endif\n#ifdef LUA_USE_ASSERT\n#define lua_assert(x)\t\tassert(x)\n#endif\n#ifdef LUA_USE_APICHECK\n#define luai_apicheck(L, o)\t{ (void)L; assert(o); }\n#else\n#define luai_apicheck(L, o)\t{ (void)L; }\n#endif\n\n#endif\n"}, "66": {"id": 66, "path": "/usr/include/luajit-2.1/luajit.h", "content": "/*\n** LuaJIT -- a Just-In-Time Compiler for Lua. http://luajit.org/\n**\n** Copyright (C) 2005-2017 Mike Pall. All rights reserved.\n**\n** Permission is hereby granted, free of charge, to any person obtaining\n** a copy of this software and associated documentation files (the\n** \"Software\"), to deal in the Software without restriction, including\n** without limitation the rights to use, copy, modify, merge, publish,\n** distribute, sublicense, and/or sell copies of the Software, and to\n** permit persons to whom the Software is furnished to do so, subject to\n** the following conditions:\n**\n** The above copyright notice and this permission notice shall be\n** included in all copies or substantial portions of the Software.\n**\n** THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\n** EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n** MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.\n** IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY\n** CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,\n** TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE\n** SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n**\n** [ MIT license: http://www.opensource.org/licenses/mit-license.php ]\n*/\n\n#ifndef _LUAJIT_H\n#define _LUAJIT_H\n\n#include \"lua.h\"\n\n#define LUAJIT_VERSION\t\t\"LuaJIT 2.1.0-beta3\"\n#define LUAJIT_VERSION_NUM\t20100  /* Version 2.1.0 = 02.01.00. */\n#define LUAJIT_VERSION_SYM\tluaJIT_version_2_1_0_beta3\n#define LUAJIT_COPYRIGHT\t\"Copyright (C) 2005-2017 Mike Pall\"\n#define LUAJIT_URL\t\t\"http://luajit.org/\"\n\n/* Modes for luaJIT_setmode. */\n#define LUAJIT_MODE_MASK\t0x00ff\n\nenum {\n  LUAJIT_MODE_ENGINE,\t\t/* Set mode for whole JIT engine. */\n  LUAJIT_MODE_DEBUG,\t\t/* Set debug mode (idx = level). */\n\n  LUAJIT_MODE_FUNC,\t\t/* Change mode for a function. */\n  LUAJIT_MODE_ALLFUNC,\t\t/* Recurse into subroutine protos. */\n  LUAJIT_MODE_ALLSUBFUNC,\t/* Change only the subroutines. */\n\n  LUAJIT_MODE_TRACE,\t\t/* Flush a compiled trace. */\n\n  LUAJIT_MODE_WRAPCFUNC = 0x10,\t/* Set wrapper mode for C function calls. */\n\n  LUAJIT_MODE_MAX\n};\n\n/* Flags or'ed in to the mode. */\n#define LUAJIT_MODE_OFF\t\t0x0000\t/* Turn feature off. */\n#define LUAJIT_MODE_ON\t\t0x0100\t/* Turn feature on. */\n#define LUAJIT_MODE_FLUSH\t0x0200\t/* Flush JIT-compiled code. */\n\n/* LuaJIT public C API. */\n\n/* Control the JIT engine. */\nLUA_API int luaJIT_setmode(lua_State *L, int idx, int mode);\n\n/* Low-overhead profiling API. */\ntypedef void (*luaJIT_profile_callback)(void *data, lua_State *L,\n\t\t\t\t\tint samples, int vmstate);\nLUA_API void luaJIT_profile_start(lua_State *L, const char *mode,\n\t\t\t\t  luaJIT_profile_callback cb, void *data);\nLUA_API void luaJIT_profile_stop(lua_State *L);\nLUA_API const char *luaJIT_profile_dumpstack(lua_State *L, const char *fmt,\n\t\t\t\t\t     int depth, size_t *len);\n\n#endif\n"}, "67": {"id": 67, "path": "/usr/include/luajit-2.1/lualib.h", "content": "/*\n** Standard library header.\n** Copyright (C) 2005-2017 Mike Pall. See Copyright Notice in luajit.h\n*/\n\n#ifndef _LUALIB_H\n#define _LUALIB_H\n\n#include \"lua.h\"\n\n#define LUA_FILEHANDLE\t\"FILE*\"\n\n#define LUA_COLIBNAME\t\"coroutine\"\n#define LUA_MATHLIBNAME\t\"math\"\n#define LUA_STRLIBNAME\t\"string\"\n#define LUA_TABLIBNAME\t\"table\"\n#define LUA_IOLIBNAME\t\"io\"\n#define LUA_OSLIBNAME\t\"os\"\n#define LUA_LOADLIBNAME\t\"package\"\n#define LUA_DBLIBNAME\t\"debug\"\n#define LUA_BITLIBNAME\t\"bit\"\n#define LUA_JITLIBNAME\t\"jit\"\n#define LUA_FFILIBNAME\t\"ffi\"\n\nLUALIB_API int luaopen_base(lua_State *L);\nLUALIB_API int luaopen_math(lua_State *L);\nLUALIB_API int luaopen_string(lua_State *L);\nLUALIB_API int luaopen_table(lua_State *L);\nLUALIB_API int luaopen_io(lua_State *L);\nLUALIB_API int luaopen_os(lua_State *L);\nLUALIB_API int luaopen_package(lua_State *L);\nLUALIB_API int luaopen_debug(lua_State *L);\nLUALIB_API int luaopen_bit(lua_State *L);\nLUALIB_API int luaopen_jit(lua_State *L);\nLUALIB_API int luaopen_ffi(lua_State *L);\n\nLUALIB_API void luaL_openlibs(lua_State *L);\n\n#ifndef lua_assert\n#define lua_assert(x)\t((void)0)\n#endif\n\n#endif\n"}}, "reports": [{"events": [{"location": {"col": 9, "file": 1, "line": 28}, "message": "LUACONTEXT_HPP (fixit)"}, {"location": {"col": 9, "file": 1, "line": 28}, "message": "header guard does not follow preferred style"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/ext/luawrapper/include/LuaContext.hpp", "reportHash": "0853743a9eb97130d78e1f814c21a252", "checkerName": "llvm-header-guard", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 10, "file": 1, "line": 33}, "message": "<boost/any.hpp> (fixit)"}, {"location": {"col": 1, "file": 1, "line": 33}, "message": "#includes are not sorted properly"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/ext/luawrapper/include/LuaContext.hpp", "reportHash": "2be7489f9b3aef90e96f464d84209da0", "checkerName": "llvm-include-order", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 25, "file": 1, "line": 96}, "message": "declaring a parameter with a default argument is disallowed"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/ext/luawrapper/include/LuaContext.hpp", "reportHash": "3c7f9942268643a2933d40af6018dae0", "checkerName": "fuchsia-default-arguments", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 32, "file": 1, "line": 100}, "message": "{ (fixit)"}, {"location": {"col": 31, "file": 1, "line": 100}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/ext/luawrapper/include/LuaContext.hpp", "reportHash": "71c4eb242db91d067af352863f627b0c", "checkerName": "google-readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 27, "file": 2, "line": 281}, "message": "expanded from macro 'lua_tostring'"}, {"location": {"col": 39, "file": 3, "line": 509}, "message": "default parameter was declared here"}, {"location": {"col": 37, "file": 1, "line": 105}, "message": "calling a function that uses a default argument is disallowed"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/ext/luawrapper/include/LuaContext.hpp", "reportHash": "b243862ab3fcea7f6ccaee84ffd79b1f", "checkerName": "fuchsia-default-arguments", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 51, "file": 4, "line": 95}, "message": "expanded from macro 'assert'"}, {"location": {"col": 30, "file": 4, "line": 129}, "message": "expanded from macro '__ASSERT_FUNCTION'"}, {"location": {"col": 13, "file": 1, "line": 107}, "message": "do not implicitly decay an array into a pointer; consider using gsl::array_view or an explicit cast instead"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/ext/luawrapper/include/LuaContext.hpp", "reportHash": "0a2f62198f26047b8fd3cdbac692d9ed", "checkerName": "hicpp-no-array-decay", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 30, "file": 1, "line": 112}, "message": "{ (fixit)"}, {"location": {"col": 29, "file": 1, "line": 112}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/ext/luawrapper/include/LuaContext.hpp", "reportHash": "e5bfcea050eccdb739759b879a7d3438", "checkerName": "readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 34, "file": 1, "line": 126}, "message": "0 (fixit)"}, {"location": {"col": 34, "file": 1, "line": 126}, "message": "implicit conversion bool -> 'int'"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/ext/luawrapper/include/LuaContext.hpp", "reportHash": "0e4bcff6dfc6c208f75a066e2cfcc344", "checkerName": "readability-implicit-bool-conversion", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 62, "file": 2, "line": 278}, "message": "expanded from macro 'lua_setglobal'"}, {"location": {"col": 7, "file": 1, "line": 137}, "message": "do not implicitly decay an array into a pointer; consider using gsl::array_view or an explicit cast instead"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/ext/luawrapper/include/LuaContext.hpp", "reportHash": "799c8d8168a25ac52ececd36673c9771", "checkerName": "hicpp-no-array-decay", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 5, "file": 1, "line": 143}, "message": "move constructors should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/ext/luawrapper/include/LuaContext.hpp", "reportHash": "765f9937a16a6b638f84d62ee5e2ceb3", "checkerName": "performance-noexcept-move-constructor", "reviewStatus": null, "severity": "MEDIUM"}, {"events": [{"location": {"col": 51, "file": 4, "line": 95}, "message": "expanded from macro 'assert'"}, {"location": {"col": 30, "file": 4, "line": 129}, "message": "expanded from macro '__ASSERT_FUNCTION'"}, {"location": {"col": 9, "file": 1, "line": 173}, "message": "do not implicitly decay an array into a pointer; consider using gsl::array_view or an explicit cast instead"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/ext/luawrapper/include/LuaContext.hpp", "reportHash": "13dcb23d9e4c9246131443b199dc2d26", "checkerName": "hicpp-no-array-decay", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 9, "file": 1, "line": 183}, "message": "explicit (fixit)"}, {"location": {"col": 9, "file": 1, "line": 183}, "message": "single-argument constructors must be marked explicit to avoid unintentional implicit conversions"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/ext/luawrapper/include/LuaContext.hpp", "reportHash": "fece34d9b2288d9cfeb37dcb356625f2", "checkerName": "hicpp-explicit-conversions", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 9, "file": 1, "line": 195}, "message": "explicit (fixit)"}, {"location": {"col": 9, "file": 1, "line": 195}, "message": "single-argument constructors must be marked explicit to avoid unintentional implicit conversions"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/ext/luawrapper/include/LuaContext.hpp", "reportHash": "58c0da1ce896e19d57c1cf41ea794b4d", "checkerName": "hicpp-explicit-conversions", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 28, "file": 1, "line": 207}, "message": "const      & (fixit)"}, {"location": {"col": 40, "file": 1, "line": 207}, "message": "the parameter 'luaType_' is copied for each invocation but only used as a const reference; consider making it a const reference"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/ext/luawrapper/include/LuaContext.hpp", "reportHash": "0f858f8e29b025f247071c28bee877b7", "checkerName": "performance-unnecessary-value-param", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 9, "file": 1, "line": 231}, "message": "explicit (fixit)"}, {"location": {"col": 9, "file": 1, "line": 231}, "message": "constructors that are callable with a single argument must be marked explicit to avoid unintentional implicit conversions"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/ext/luawrapper/include/LuaContext.hpp", "reportHash": "1227f74a82f9ac1b334105313d0ac968", "checkerName": "google-explicit-constructor", "reviewStatus": null, "severity": "MEDIUM"}, {"events": [{"location": {"col": 37, "file": 1, "line": 231}, "message": "declaring a parameter with a default argument is disallowed"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/ext/luawrapper/include/LuaContext.hpp", "reportHash": "fb6c938ce305e2e17dd3b7dc57f925af", "checkerName": "fuchsia-default-arguments", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 12, "file": 1, "line": 240}, "message": "class 'ThreadID' defines a move constructor and a move assignment operator but does not define a destructor, a copy constructor or a copy assignment operator"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/ext/luawrapper/include/LuaContext.hpp", "reportHash": "f149f89e9b1241df0f7172c358aca931", "checkerName": "cppcoreguidelines-special-member-functions", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 12, "file": 1, "line": 240}, "message": "constructor does not initialize these fields: state"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/ext/luawrapper/include/LuaContext.hpp", "reportHash": "f381ba97416bface25d9bf947c710cea", "checkerName": "cppcoreguidelines-pro-type-member-init", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 9, "file": 1, "line": 241}, "message": "constructor does not initialize these fields: state"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/ext/luawrapper/include/LuaContext.hpp", "reportHash": "4e4167e33ee392516396dd2b7f803f8e", "checkerName": "cppcoreguidelines-pro-type-member-init", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 9, "file": 1, "line": 242}, "message": "move constructors should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/ext/luawrapper/include/LuaContext.hpp", "reportHash": "e1e0e3970588d57e420c1febfa394cd5", "checkerName": "hicpp-noexcept-move", "reviewStatus": null, "severity": "MEDIUM"}, {"events": [{"location": {"col": 19, "file": 1, "line": 243}, "message": "move assignment operators should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/ext/luawrapper/include/LuaContext.hpp", "reportHash": "e0337c7dee8d8276ebb2ecb397d5fa1a", "checkerName": "performance-noexcept-move-constructor", "reviewStatus": null, "severity": "MEDIUM"}, {"events": [{"location": {"col": 39, "file": 1, "line": 489}, "message": "do not use const_cast"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/ext/luawrapper/include/LuaContext.hpp", "reportHash": "0a8b419f425d8d9a3446490ccb63cbdf", "checkerName": "cppcoreguidelines-pro-type-const-cast", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 39, "file": 1, "line": 494}, "message": "do not use const_cast"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/ext/luawrapper/include/LuaContext.hpp", "reportHash": "a93ed0ae88c33479841d699388c6b98a", "checkerName": "cppcoreguidelines-pro-type-const-cast", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 39, "file": 1, "line": 499}, "message": "do not use const_cast"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/ext/luawrapper/include/LuaContext.hpp", "reportHash": "edaaaed6b23ee8abf4290b0af43f0ac7", "checkerName": "cppcoreguidelines-pro-type-const-cast", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 35, "file": 1, "line": 642}, "message": "std::make_unique (fixit)"}, {"location": {"col": 35, "file": 1, "line": 642}, "message": "use std::make_unique instead"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/ext/luawrapper/include/LuaContext.hpp", "reportHash": "bd6e0b539f1029bd2b536335cf472a4a", "checkerName": "modernize-make-unique", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 42, "file": 1, "line": 1774}, "message": "default parameter was declared here"}, {"location": {"col": 72, "file": 1, "line": 642}, "message": "calling a function that uses a default argument is disallowed"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/ext/luawrapper/include/LuaContext.hpp", "reportHash": "4836ff3487da33a03e5e9c5feb14c734", "checkerName": "fuchsia-default-arguments", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 34, "file": 1, "line": 652}, "message": "non-const reference parameter 'id', make it const or use a pointer"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/ext/luawrapper/include/LuaContext.hpp", "reportHash": "847ebca92df93691c8f9472c70c0ea94", "checkerName": "google-runtime-references", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 13, "file": 5, "line": 366}, "message": "default parameter was declared here"}, {"location": {"col": 9, "file": 1, "line": 654}, "message": "calling a function that uses a default argument is disallowed"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/ext/luawrapper/include/LuaContext.hpp", "reportHash": "efa22280662eecd48f6edd40680bf1c4", "checkerName": "fuchsia-default-arguments", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 9, "file": 1, "line": 733}, "message": "use 'using' instead of 'typedef'"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/ext/luawrapper/include/LuaContext.hpp", "reportHash": "559a2197551bf62a0990d95d38b96191", "checkerName": "modernize-use-using", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 9, "file": 1, "line": 758}, "message": "use 'using' instead of 'typedef'"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/ext/luawrapper/include/LuaContext.hpp", "reportHash": "559a2197551bf62a0990d95d38b96191", "checkerName": "modernize-use-using", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 9, "file": 1, "line": 760}, "message": "using DetectedFunctionType = typename FunctionTypeDetector<RealDataType>::type (fixit)"}, {"location": {"col": 9, "file": 1, "line": 760}, "message": "use 'using' instead of 'typedef'"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/ext/luawrapper/include/LuaContext.hpp", "reportHash": "a6e42c837a16bfb2f6ee5d9f31d3b1b2", "checkerName": "modernize-use-using", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 9, "file": 1, "line": 779}, "message": "explicit (fixit)"}, {"location": {"col": 9, "file": 1, "line": 779}, "message": "constructors that are callable with a single argument must be marked explicit to avoid unintentional implicit conversions"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/ext/luawrapper/include/LuaContext.hpp", "reportHash": "d8c95731cba7466b120bbd27f343ec67", "checkerName": "google-explicit-constructor", "reviewStatus": null, "severity": "MEDIUM"}, {"events": [{"location": {"col": 41, "file": 1, "line": 779}, "message": "declaring a parameter with a default argument is disallowed"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/ext/luawrapper/include/LuaContext.hpp", "reportHash": "0752d2fa2d4f488d8f13760605c9080c", "checkerName": "fuchsia-default-arguments", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 51, "file": 4, "line": 95}, "message": "expanded from macro 'assert'"}, {"location": {"col": 30, "file": 4, "line": 129}, "message": "expanded from macro '__ASSERT_FUNCTION'"}, {"location": {"col": 27, "file": 1, "line": 780}, "message": "do not implicitly decay an array into a pointer; consider using gsl::array_view or an explicit cast instead"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/ext/luawrapper/include/LuaContext.hpp", "reportHash": "ff14409717aea4f5c71fb8650fca76a4", "checkerName": "cppcoreguidelines-pro-bounds-array-to-pointer-decay", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 75, "file": 1, "line": 780}, "message": "{ (fixit)"}, {"location": {"col": 74, "file": 1, "line": 780}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/ext/luawrapper/include/LuaContext.hpp", "reportHash": "beca60934b889d50470231a137931c49", "checkerName": "hicpp-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 23, "file": 1, "line": 784}, "message": "move assignment operators should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/ext/luawrapper/include/LuaContext.hpp", "reportHash": "46c233644700602d543738019a905b53", "checkerName": "hicpp-noexcept-move", "reviewStatus": null, "severity": "MEDIUM"}, {"events": [{"location": {"col": 9, "file": 1, "line": 785}, "message": "move constructors should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/ext/luawrapper/include/LuaContext.hpp", "reportHash": "50c8b4dc30f62ce04b6bc647e09d8baf", "checkerName": "hicpp-noexcept-move", "reviewStatus": null, "severity": "MEDIUM"}, {"events": [{"location": {"col": 9, "file": 1, "line": 787}, "message": "cannot overload 'operator+'"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/ext/luawrapper/include/LuaContext.hpp", "reportHash": "014dd8e078c21c8f062f55bcc32fb84a", "checkerName": "fuchsia-overloaded-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 9, "file": 1, "line": 788}, "message": "cannot overload 'operator+='"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/ext/luawrapper/include/LuaContext.hpp", "reportHash": "17b21df00b96c1257b4d8418d0c9b912", "checkerName": "fuchsia-overloaded-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 51, "file": 4, "line": 95}, "message": "expanded from macro 'assert'"}, {"location": {"col": 30, "file": 4, "line": 129}, "message": "expanded from macro '__ASSERT_FUNCTION'"}, {"location": {"col": 49, "file": 1, "line": 788}, "message": "do not implicitly decay an array into a pointer; consider using gsl::array_view or an explicit cast instead"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/ext/luawrapper/include/LuaContext.hpp", "reportHash": "195091ab4fe462c7d677b7b6bf9ad0da", "checkerName": "cppcoreguidelines-pro-bounds-array-to-pointer-decay", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 36, "file": 1, "line": 794}, "message": "{ (fixit)"}, {"location": {"col": 35, "file": 1, "line": 794}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/ext/luawrapper/include/LuaContext.hpp", "reportHash": "e2a85a5cbc6c975d822f4c41d0743f68", "checkerName": "readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 51, "file": 4, "line": 95}, "message": "expanded from macro 'assert'"}, {"location": {"col": 30, "file": 4, "line": 129}, "message": "expanded from macro '__ASSERT_FUNCTION'"}, {"location": {"col": 27, "file": 1, "line": 795}, "message": "do not implicitly decay an array into a pointer; consider using gsl::array_view or an explicit cast instead"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/ext/luawrapper/include/LuaContext.hpp", "reportHash": "198025024fbdc68caabb405605823533", "checkerName": "cppcoreguidelines-pro-bounds-array-to-pointer-decay", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 64, "file": 1, "line": 827}, "message": "/*unused*/ (fixit)"}, {"location": {"col": 63, "file": 1, "line": 827}, "message": "all parameters should be named in a function"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/ext/luawrapper/include/LuaContext.hpp", "reportHash": "bcd1a5180deb484cdf7748f1a4098daa", "checkerName": "readability-named-parameter", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 45, "file": 1, "line": 834}, "message": "/*unused*/ (fixit)"}, {"location": {"col": 44, "file": 1, "line": 834}, "message": "all parameters should be named in a function"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/ext/luawrapper/include/LuaContext.hpp", "reportHash": "75c3619cf5d17256f6e25668b463624e", "checkerName": "readability-named-parameter", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 64, "file": 1, "line": 842}, "message": "/*unused*/ (fixit)"}, {"location": {"col": 63, "file": 1, "line": 842}, "message": "all parameters should be named in a function"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/ext/luawrapper/include/LuaContext.hpp", "reportHash": "90ef644a91be06616c4dbe2ec9f2a5c7", "checkerName": "readability-named-parameter", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 64, "file": 1, "line": 856}, "message": "/*unused*/ (fixit)"}, {"location": {"col": 63, "file": 1, "line": 856}, "message": "all parameters should be named in a function"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/ext/luawrapper/include/LuaContext.hpp", "reportHash": "c1c40d875d567ca5712bd0cd99264595", "checkerName": "readability-named-parameter", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 64, "file": 1, "line": 866}, "message": "/*unused*/ (fixit)"}, {"location": {"col": 63, "file": 1, "line": 866}, "message": "all parameters should be named in a function"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/ext/luawrapper/include/LuaContext.hpp", "reportHash": "5960d5e40ad69c42dd1552d151fbff9a", "checkerName": "readability-named-parameter", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 64, "file": 1, "line": 876}, "message": "/*unused*/   /*unused*/ (fixit)"}, {"location": {"col": 63, "file": 1, "line": 876}, "message": "all parameters should be named in a function"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/ext/luawrapper/include/LuaContext.hpp", "reportHash": "d705a9aa0cda31911307f6779b706fa5", "checkerName": "readability-named-parameter", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 58, "file": 1, "line": 886}, "message": "/*unused*/ (fixit)"}, {"location": {"col": 57, "file": 1, "line": 886}, "message": "all parameters should be named in a function"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/ext/luawrapper/include/LuaContext.hpp", "reportHash": "175903b78570252ef8667f24b616bed3", "checkerName": "readability-named-parameter", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 57, "file": 1, "line": 886}, "message": "non-const reference parameter at index 1, make it const or use a pointer"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/ext/luawrapper/include/LuaContext.hpp", "reportHash": "c45a8ec36a73e0ec1752d865a47335ea", "checkerName": "google-runtime-references", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 58, "file": 1, "line": 910}, "message": "non-const reference parameter 'pushedObject', make it const or use a pointer"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/ext/luawrapper/include/LuaContext.hpp", "reportHash": "0575a6251094735ebd3dab4021e49406", "checkerName": "google-runtime-references", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 84, "file": 1, "line": 910}, "message": "/*unused*/ (fixit)"}, {"location": {"col": 83, "file": 1, "line": 910}, "message": "all parameters should be named in a function"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/ext/luawrapper/include/LuaContext.hpp", "reportHash": "8eb7c7d4baabaa6d4ade1eaa506974b4", "checkerName": "readability-named-parameter", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 85, "file": 1, "line": 929}, "message": "/*unused*/ (fixit)"}, {"location": {"col": 84, "file": 1, "line": 929}, "message": "all parameters should be named in a function"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/ext/luawrapper/include/LuaContext.hpp", "reportHash": "62723ca0ecdd51ea915bd1899f74b9fa", "checkerName": "readability-named-parameter", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 56, "file": 1, "line": 948}, "message": "/*unused*/ (fixit)"}, {"location": {"col": 55, "file": 1, "line": 948}, "message": "all parameters should be named in a function"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/ext/luawrapper/include/LuaContext.hpp", "reportHash": "2bd90d7e379daba73a565a41d3e62062", "checkerName": "readability-named-parameter", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 56, "file": 1, "line": 962}, "message": "/*unused*/ (fixit)"}, {"location": {"col": 55, "file": 1, "line": 962}, "message": "all parameters should be named in a function"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/ext/luawrapper/include/LuaContext.hpp", "reportHash": "0b2d38aa147eab0ba327ca147a7d8ce8", "checkerName": "readability-named-parameter", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 56, "file": 1, "line": 972}, "message": "/*unused*/ (fixit)"}, {"location": {"col": 55, "file": 1, "line": 972}, "message": "all parameters should be named in a function"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/ext/luawrapper/include/LuaContext.hpp", "reportHash": "33c024d175863f724c2a16686cfd77a6", "checkerName": "readability-named-parameter", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 56, "file": 1, "line": 982}, "message": "/*unused*/ (fixit)"}, {"location": {"col": 55, "file": 1, "line": 982}, "message": "all parameters should be named in a function"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/ext/luawrapper/include/LuaContext.hpp", "reportHash": "386b93d83e1103af7e6d250b88adc50f", "checkerName": "readability-named-parameter", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 54, "file": 1, "line": 993}, "message": "/*unused*/ (fixit)"}, {"location": {"col": 53, "file": 1, "line": 993}, "message": "all parameters should be named in a function"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/ext/luawrapper/include/LuaContext.hpp", "reportHash": "42187730ad8bf302242cd305bb4ee5c9", "checkerName": "readability-named-parameter", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 54, "file": 1, "line": 1020}, "message": "/*unused*/ (fixit)"}, {"location": {"col": 53, "file": 1, "line": 1020}, "message": "all parameters should be named in a function"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/ext/luawrapper/include/LuaContext.hpp", "reportHash": "f65d8ac65455442c11db9f1effffaa7b", "checkerName": "readability-named-parameter", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 54, "file": 1, "line": 1030}, "message": "/*unused*/ (fixit)"}, {"location": {"col": 53, "file": 1, "line": 1030}, "message": "all parameters should be named in a function"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/ext/luawrapper/include/LuaContext.hpp", "reportHash": "c59d3fe453876c98257232dccc2a3695", "checkerName": "readability-named-parameter", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 54, "file": 1, "line": 1040}, "message": "/*unused*/ (fixit)"}, {"location": {"col": 53, "file": 1, "line": 1040}, "message": "all parameters should be named in a function"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/ext/luawrapper/include/LuaContext.hpp", "reportHash": "167cbabf491990cfacf21f276772ccd1", "checkerName": "readability-named-parameter", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 5, "file": 1, "line": 1060}, "message": "// TODO(root): g++ reports \"ambiguous overload\" (fixit)"}, {"location": {"col": 5, "file": 1, "line": 1060}, "message": "missing username/bug in TODO"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/ext/luawrapper/include/LuaContext.hpp", "reportHash": "f4e4bf7fc45450b9fb2140f43efea384", "checkerName": "google-readability-todo", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 59, "file": 1, "line": 2895}, "message": "default parameter was declared here"}, {"location": {"col": 20, "file": 1, "line": 1086}, "message": "calling a function that uses a default argument is disallowed"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/ext/luawrapper/include/LuaContext.hpp", "reportHash": "56069d6bc54bf29cf95eb66926c69366", "checkerName": "fuchsia-default-arguments", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 36, "file": 1, "line": 1087}, "message": "{ (fixit)"}, {"location": {"col": 35, "file": 1, "line": 1087}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/ext/luawrapper/include/LuaContext.hpp", "reportHash": "f46c9cc708180bd669671dcfcd2cae44", "checkerName": "google-readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 39, "file": 3, "line": 509}, "message": "default parameter was declared here"}, {"location": {"col": 38, "file": 1, "line": 1088}, "message": "calling a function that uses a default argument is disallowed"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/ext/luawrapper/include/LuaContext.hpp", "reportHash": "5bed9f8bc278cc7fba3c8a76fbd8310d", "checkerName": "fuchsia-default-arguments", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 38, "file": 1, "line": 1095}, "message": "do not use const_cast"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/ext/luawrapper/include/LuaContext.hpp", "reportHash": "7407c47a2164e3c06de66079986fdcb8", "checkerName": "cppcoreguidelines-pro-type-const-cast", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 38, "file": 1, "line": 1103}, "message": "do not use const_cast"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/ext/luawrapper/include/LuaContext.hpp", "reportHash": "7407c47a2164e3c06de66079986fdcb8", "checkerName": "cppcoreguidelines-pro-type-const-cast", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 51, "file": 4, "line": 95}, "message": "expanded from macro 'assert'"}, {"location": {"col": 30, "file": 4, "line": 129}, "message": "expanded from macro '__ASSERT_FUNCTION'"}, {"location": {"col": 9, "file": 1, "line": 1134}, "message": "do not implicitly decay an array into a pointer; consider using gsl::array_view or an explicit cast instead"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/ext/luawrapper/include/LuaContext.hpp", "reportHash": "76b394a2a2c4f5474d22675f1884d5cd", "checkerName": "cppcoreguidelines-pro-bounds-array-to-pointer-decay", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 101, "file": 1, "line": 1144}, "message": "/*unused*/                        /*unused*/ (fixit)"}, {"location": {"col": 100, "file": 1, "line": 1144}, "message": "all parameters should be named in a function"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/ext/luawrapper/include/LuaContext.hpp", "reportHash": "4c2c7bab9a59874369c584cc02cb6407", "checkerName": "readability-named-parameter", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 107, "file": 1, "line": 1159}, "message": "/*unused*/ (fixit)"}, {"location": {"col": 106, "file": 1, "line": 1159}, "message": "all parameters should be named in a function"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/ext/luawrapper/include/LuaContext.hpp", "reportHash": "b1729622812b4ec88bc9045213a19fb6", "checkerName": "readability-named-parameter", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 133, "file": 1, "line": 1171}, "message": "/*unused*/ (fixit)"}, {"location": {"col": 132, "file": 1, "line": 1171}, "message": "all parameters should be named in a function"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/ext/luawrapper/include/LuaContext.hpp", "reportHash": "8f478c0c778ec13af989a9edd365e7cc", "checkerName": "readability-named-parameter", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 139, "file": 1, "line": 1177}, "message": "/*unused*/ (fixit)"}, {"location": {"col": 138, "file": 1, "line": 1177}, "message": "all parameters should be named in a function"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/ext/luawrapper/include/LuaContext.hpp", "reportHash": "bf19fc1e921d5786c6fa6666eaf630e6", "checkerName": "readability-named-parameter", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 142, "file": 1, "line": 1183}, "message": "/*unused*/ (fixit)"}, {"location": {"col": 141, "file": 1, "line": 1183}, "message": "all parameters should be named in a function"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/ext/luawrapper/include/LuaContext.hpp", "reportHash": "d34194d19fd4d6750ecf844f057ed6a1", "checkerName": "readability-named-parameter", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 148, "file": 1, "line": 1189}, "message": "/*unused*/ (fixit)"}, {"location": {"col": 147, "file": 1, "line": 1189}, "message": "all parameters should be named in a function"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/ext/luawrapper/include/LuaContext.hpp", "reportHash": "1f133c29be8897afdb6e2e049793a9dc", "checkerName": "readability-named-parameter", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 56, "file": 1, "line": 1251}, "message": "/*unused*/ (fixit)"}, {"location": {"col": 55, "file": 1, "line": 1251}, "message": "all parameters should be named in a function"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/ext/luawrapper/include/LuaContext.hpp", "reportHash": "7f632cf731bb5c36d6f2b58a65dbf61c", "checkerName": "readability-named-parameter", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 55, "file": 1, "line": 1257}, "message": "/*unused*/ (fixit)"}, {"location": {"col": 54, "file": 1, "line": 1257}, "message": "all parameters should be named in a function"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/ext/luawrapper/include/LuaContext.hpp", "reportHash": "98fa6a49fe439f8c582952413545203e", "checkerName": "readability-named-parameter", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 56, "file": 1, "line": 1317}, "message": "/*unused*/ (fixit)"}, {"location": {"col": 55, "file": 1, "line": 1317}, "message": "all parameters should be named in a function"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/ext/luawrapper/include/LuaContext.hpp", "reportHash": "fa7e312015e3ff9aa59da597003b03dd", "checkerName": "readability-named-parameter", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 55, "file": 1, "line": 1323}, "message": "/*unused*/ (fixit)"}, {"location": {"col": 54, "file": 1, "line": 1323}, "message": "all parameters should be named in a function"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/ext/luawrapper/include/LuaContext.hpp", "reportHash": "504bf80c9933a103e0c3c3a4802ad22a", "checkerName": "readability-named-parameter", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 13, "file": 1, "line": 1339}, "message": "constructor does not initialize these fields: buffer"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/ext/luawrapper/include/LuaContext.hpp", "reportHash": "010aff20506b591eacfeba5241a0c4ad", "checkerName": "cppcoreguidelines-pro-type-member-init", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 13, "file": 1, "line": 1339}, "message": "explicit (fixit)"}, {"location": {"col": 13, "file": 1, "line": 1339}, "message": "single-argument constructors must be marked explicit to avoid unintentional implicit conversions"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/ext/luawrapper/include/LuaContext.hpp", "reportHash": "1fae6f5db602e184167d521b2eb5e140", "checkerName": "google-explicit-constructor", "reviewStatus": null, "severity": "MEDIUM"}, {"events": [{"location": {"col": 51, "file": 4, "line": 95}, "message": "expanded from macro 'assert'"}, {"location": {"col": 30, "file": 4, "line": 129}, "message": "expanded from macro '__ASSERT_FUNCTION'"}, {"location": {"col": 17, "file": 1, "line": 1345}, "message": "do not implicitly decay an array into a pointer; consider using gsl::array_view or an explicit cast instead"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/ext/luawrapper/include/LuaContext.hpp", "reportHash": "634e68ff088a2bd66029ac3374fd6b83", "checkerName": "hicpp-no-array-decay", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 51, "file": 4, "line": 95}, "message": "expanded from macro 'assert'"}, {"location": {"col": 30, "file": 4, "line": 129}, "message": "expanded from macro '__ASSERT_FUNCTION'"}, {"location": {"col": 17, "file": 1, "line": 1346}, "message": "do not implicitly decay an array into a pointer; consider using gsl::array_view or an explicit cast instead"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/ext/luawrapper/include/LuaContext.hpp", "reportHash": "aec89dcea00d10954da91f47a1be6584", "checkerName": "cppcoreguidelines-pro-bounds-array-to-pointer-decay", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 27, "file": 2, "line": 281}, "message": "expanded from macro 'lua_tostring'"}, {"location": {"col": 39, "file": 3, "line": 509}, "message": "default parameter was declared here"}, {"location": {"col": 42, "file": 1, "line": 1367}, "message": "calling a function that uses a default argument is disallowed"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/ext/luawrapper/include/LuaContext.hpp", "reportHash": "3fa7e49e0b0de6d655ed46e6b9d2bf5d", "checkerName": "fuchsia-default-arguments", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 48, "file": 1, "line": 1369}, "message": "{ (fixit)"}, {"location": {"col": 47, "file": 1, "line": 1369}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/ext/luawrapper/include/LuaContext.hpp", "reportHash": "6e3e5c59f104759dc9516814f184027a", "checkerName": "google-readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 13, "file": 1, "line": 1371}, "message": "do not use 'else' after 'throw'"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/ext/luawrapper/include/LuaContext.hpp", "reportHash": "e36151f81833f89c9cc9e8eb12791d44", "checkerName": "readability-else-after-return", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 56, "file": 1, "line": 1371}, "message": "{ (fixit)"}, {"location": {"col": 55, "file": 1, "line": 1371}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/ext/luawrapper/include/LuaContext.hpp", "reportHash": "8a452bea55cac3cff545f8a75375aeb4", "checkerName": "google-readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 27, "file": 2, "line": 281}, "message": "expanded from macro 'lua_tostring'"}, {"location": {"col": 39, "file": 3, "line": 509}, "message": "default parameter was declared here"}, {"location": {"col": 42, "file": 1, "line": 1387}, "message": "calling a function that uses a default argument is disallowed"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/ext/luawrapper/include/LuaContext.hpp", "reportHash": "3fa7e49e0b0de6d655ed46e6b9d2bf5d", "checkerName": "fuchsia-default-arguments", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 48, "file": 1, "line": 1389}, "message": "{ (fixit)"}, {"location": {"col": 47, "file": 1, "line": 1389}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/ext/luawrapper/include/LuaContext.hpp", "reportHash": "6e3e5c59f104759dc9516814f184027a", "checkerName": "google-readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 13, "file": 1, "line": 1391}, "message": "do not use 'else' after 'throw'"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/ext/luawrapper/include/LuaContext.hpp", "reportHash": "e36151f81833f89c9cc9e8eb12791d44", "checkerName": "readability-else-after-return", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 56, "file": 1, "line": 1391}, "message": "{ (fixit)"}, {"location": {"col": 55, "file": 1, "line": 1391}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/ext/luawrapper/include/LuaContext.hpp", "reportHash": "8a452bea55cac3cff545f8a75375aeb4", "checkerName": "google-readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 9, "file": 1, "line": 1405}, "message": "using RealReturnType = typename Tupleizer<TReturnType>::type (fixit)"}, {"location": {"col": 9, "file": 1, "line": 1405}, "message": "use 'using' instead of 'typedef'"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/ext/luawrapper/include/LuaContext.hpp", "reportHash": "b717d3e4a9813c33feb02b9e5436fd10", "checkerName": "modernize-use-using", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 15, "file": 1, "line": 1434}, "message": "do not use 'else' after 'throw'"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/ext/luawrapper/include/LuaContext.hpp", "reportHash": "0fc65f872998f055f8409f33c4ba0622", "checkerName": "readability-else-after-return", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 44, "file": 1, "line": 1435}, "message": "!= 0 (fixit)"}, {"location": {"col": 21, "file": 1, "line": 1435}, "message": "implicit conversion 'int' -> bool"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/ext/luawrapper/include/LuaContext.hpp", "reportHash": "2f1d253d0ae99ebeaadfbef67f208e22", "checkerName": "readability-implicit-bool-conversion", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 19, "file": 1, "line": 1440}, "message": "do not use 'else' after 'throw'"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/ext/luawrapper/include/LuaContext.hpp", "reportHash": "30fd906572e8704b0f8336a7644fd15d", "checkerName": "readability-else-after-return", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 39, "file": 3, "line": 509}, "message": "default parameter was declared here"}, {"location": {"col": 72, "file": 1, "line": 1448}, "message": "calling a function that uses a default argument is disallowed"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/ext/luawrapper/include/LuaContext.hpp", "reportHash": "c8613c3c05838bfc3c088c40486af8c9", "checkerName": "fuchsia-default-arguments", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 39, "file": 3, "line": 509}, "message": "default parameter was declared here"}, {"location": {"col": 72, "file": 1, "line": 1450}, "message": "calling a function that uses a default argument is disallowed"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/ext/luawrapper/include/LuaContext.hpp", "reportHash": "04705abfdb6d8c659175ee9b9ef1fb77", "checkerName": "fuchsia-default-arguments", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 39, "file": 3, "line": 509}, "message": "default parameter was declared here"}, {"location": {"col": 51, "file": 1, "line": 1452}, "message": "calling a function that uses a default argument is disallowed"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/ext/luawrapper/include/LuaContext.hpp", "reportHash": "b85e9c29736d482288a182e59454e614", "checkerName": "fuchsia-default-arguments", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 51, "file": 4, "line": 95}, "message": "expanded from macro 'assert'"}, {"location": {"col": 30, "file": 4, "line": 129}, "message": "expanded from macro '__ASSERT_FUNCTION'"}, {"location": {"col": 17, "file": 1, "line": 1486}, "message": "do not implicitly decay an array into a pointer; consider using gsl::array_view or an explicit cast instead"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/ext/luawrapper/include/LuaContext.hpp", "reportHash": "549d9bce29d94b7509e9e48a76fe7fc1", "checkerName": "hicpp-no-array-decay", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 17, "file": 1, "line": 1487}, "message": "auto (fixit)"}, {"location": {"col": 17, "file": 1, "line": 1487}, "message": "use auto when initializing with a cast to avoid duplicating the type name"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/ext/luawrapper/include/LuaContext.hpp", "reportHash": "b1efbf62623ea83127006527471df697", "checkerName": "modernize-use-auto", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 51, "file": 4, "line": 95}, "message": "expanded from macro 'assert'"}, {"location": {"col": 30, "file": 4, "line": 129}, "message": "expanded from macro '__ASSERT_FUNCTION'"}, {"location": {"col": 17, "file": 1, "line": 1488}, "message": "do not implicitly decay an array into a pointer; consider using gsl::array_view or an explicit cast instead"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/ext/luawrapper/include/LuaContext.hpp", "reportHash": "ca4762f50cbdfcd3344801888272532d", "checkerName": "cppcoreguidelines-pro-bounds-array-to-pointer-decay", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 51, "file": 4, "line": 95}, "message": "expanded from macro 'assert'"}, {"location": {"col": 30, "file": 4, "line": 129}, "message": "expanded from macro '__ASSERT_FUNCTION'"}, {"location": {"col": 21, "file": 1, "line": 1496}, "message": "do not implicitly decay an array into a pointer; consider using gsl::array_view or an explicit cast instead"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/ext/luawrapper/include/LuaContext.hpp", "reportHash": "87261c455da5040c11b654adee7460e0", "checkerName": "hicpp-no-array-decay", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 51, "file": 4, "line": 95}, "message": "expanded from macro 'assert'"}, {"location": {"col": 30, "file": 4, "line": 129}, "message": "expanded from macro '__ASSERT_FUNCTION'"}, {"location": {"col": 21, "file": 1, "line": 1497}, "message": "do not implicitly decay an array into a pointer; consider using gsl::array_view or an explicit cast instead"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/ext/luawrapper/include/LuaContext.hpp", "reportHash": "123a0095324c95e31aab655c3ae200c0", "checkerName": "hicpp-no-array-decay", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 48, "file": 1, "line": 1500}, "message": "do not use const_cast"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/ext/luawrapper/include/LuaContext.hpp", "reportHash": "11bfd6d6abf10e7c44ce8859f98a066c", "checkerName": "cppcoreguidelines-pro-type-const-cast", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 51, "file": 4, "line": 95}, "message": "expanded from macro 'assert'"}, {"location": {"col": 30, "file": 4, "line": 129}, "message": "expanded from macro '__ASSERT_FUNCTION'"}, {"location": {"col": 21, "file": 1, "line": 1502}, "message": "do not implicitly decay an array into a pointer; consider using gsl::array_view or an explicit cast instead"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/ext/luawrapper/include/LuaContext.hpp", "reportHash": "ee6e0151dcb06ac496f134479586e32b", "checkerName": "hicpp-no-array-decay", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 46, "file": 1, "line": 1509}, "message": "{ (fixit)"}, {"location": {"col": 45, "file": 1, "line": 1509}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/ext/luawrapper/include/LuaContext.hpp", "reportHash": "425d07f81dc7d51b58295e02fe8ad630", "checkerName": "readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 45, "file": 1, "line": 1527}, "message": "{ (fixit)"}, {"location": {"col": 44, "file": 1, "line": 1527}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/ext/luawrapper/include/LuaContext.hpp", "reportHash": "cca70ea9e4a97afb51d36befb104a759", "checkerName": "readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 51, "file": 4, "line": 95}, "message": "expanded from macro 'assert'"}, {"location": {"col": 30, "file": 4, "line": 129}, "message": "expanded from macro '__ASSERT_FUNCTION'"}, {"location": {"col": 21, "file": 1, "line": 1542}, "message": "do not implicitly decay an array into a pointer; consider using gsl::array_view or an explicit cast instead"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/ext/luawrapper/include/LuaContext.hpp", "reportHash": "ac2b7988516ef7d17d463a0cf0d82d53", "checkerName": "hicpp-no-array-decay", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 51, "file": 4, "line": 95}, "message": "expanded from macro 'assert'"}, {"location": {"col": 30, "file": 4, "line": 129}, "message": "expanded from macro '__ASSERT_FUNCTION'"}, {"location": {"col": 21, "file": 1, "line": 1543}, "message": "do not implicitly decay an array into a pointer; consider using gsl::array_view or an explicit cast instead"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/ext/luawrapper/include/LuaContext.hpp", "reportHash": "53521711e2cc2086c6be3b51e2baaa92", "checkerName": "cppcoreguidelines-pro-bounds-array-to-pointer-decay", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 48, "file": 1, "line": 1546}, "message": "do not use const_cast"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/ext/luawrapper/include/LuaContext.hpp", "reportHash": "11bfd6d6abf10e7c44ce8859f98a066c", "checkerName": "cppcoreguidelines-pro-type-const-cast", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 51, "file": 4, "line": 95}, "message": "expanded from macro 'assert'"}, {"location": {"col": 30, "file": 4, "line": 129}, "message": "expanded from macro '__ASSERT_FUNCTION'"}, {"location": {"col": 21, "file": 1, "line": 1548}, "message": "do not implicitly decay an array into a pointer; consider using gsl::array_view or an explicit cast instead"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/ext/luawrapper/include/LuaContext.hpp", "reportHash": "2b5196dfd559c8fb5a6c80c95c673c29", "checkerName": "cppcoreguidelines-pro-bounds-array-to-pointer-decay", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 51, "file": 4, "line": 95}, "message": "expanded from macro 'assert'"}, {"location": {"col": 30, "file": 4, "line": 129}, "message": "expanded from macro '__ASSERT_FUNCTION'"}, {"location": {"col": 21, "file": 1, "line": 1588}, "message": "do not implicitly decay an array into a pointer; consider using gsl::array_view or an explicit cast instead"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/ext/luawrapper/include/LuaContext.hpp", "reportHash": "84c2cadd88beaff770c092bcda66b530", "checkerName": "cppcoreguidelines-pro-bounds-array-to-pointer-decay", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 51, "file": 4, "line": 95}, "message": "expanded from macro 'assert'"}, {"location": {"col": 30, "file": 4, "line": 129}, "message": "expanded from macro '__ASSERT_FUNCTION'"}, {"location": {"col": 21, "file": 1, "line": 1589}, "message": "do not implicitly decay an array into a pointer; consider using gsl::array_view or an explicit cast instead"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/ext/luawrapper/include/LuaContext.hpp", "reportHash": "53521711e2cc2086c6be3b51e2baaa92", "checkerName": "cppcoreguidelines-pro-bounds-array-to-pointer-decay", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 81, "file": 1, "line": 1596}, "message": "do not use reinterpret_cast"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/ext/luawrapper/include/LuaContext.hpp", "reportHash": "587ec379d207b7591cdb9a8e040a4a42", "checkerName": "cppcoreguidelines-pro-type-reinterpret-cast", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 42, "file": 1, "line": 1634}, "message": "do not use const_cast"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/ext/luawrapper/include/LuaContext.hpp", "reportHash": "14a983e4e562082a9bedef06b4671251", "checkerName": "cppcoreguidelines-pro-type-const-cast", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 62, "file": 2, "line": 279}, "message": "expanded from macro 'lua_getglobal'"}, {"location": {"col": 13, "file": 1, "line": 1652}, "message": "do not implicitly decay an array into a pointer; consider using gsl::array_view or an explicit cast instead"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/ext/luawrapper/include/LuaContext.hpp", "reportHash": "141d5935f4ebb9af920670a75505a132", "checkerName": "cppcoreguidelines-pro-bounds-array-to-pointer-decay", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 9, "file": 1, "line": 1692}, "message": "use 'using' instead of 'typedef'"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/ext/luawrapper/include/LuaContext.hpp", "reportHash": "2aec3b23e34e5d268d9ef00c1e47d7f3", "checkerName": "modernize-use-using", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 38, "file": 1, "line": 1698}, "message": "{ (fixit)"}, {"location": {"col": 37, "file": 1, "line": 1698}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/ext/luawrapper/include/LuaContext.hpp", "reportHash": "8b1b36b933fbe67ca679b8a015855cbd", "checkerName": "google-readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 24, "file": 6, "line": 139}, "message": "default parameter was declared here"}, {"location": {"col": 34, "file": 7, "line": 467}, "message": "expanded from macro 'BOOST_DEDUCED_TYPENAME'"}, {"location": {"col": 20, "file": 1, "line": 1700}, "message": "calling a function that uses a default argument is disallowed"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/ext/luawrapper/include/LuaContext.hpp", "reportHash": "0d06522120a69bcd645dfcedfcb0e0fd", "checkerName": "fuchsia-default-arguments", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 47, "file": 1, "line": 1706}, "message": "== 0 (fixit)"}, {"location": {"col": 18, "file": 1, "line": 1706}, "message": "implicit conversion 'int' -> bool"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/ext/luawrapper/include/LuaContext.hpp", "reportHash": "53dd06fc40c6663c1ca7290cc5709934", "checkerName": "readability-implicit-bool-conversion", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 48, "file": 1, "line": 1706}, "message": "{ (fixit)"}, {"location": {"col": 47, "file": 1, "line": 1706}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/ext/luawrapper/include/LuaContext.hpp", "reportHash": "2146be97a467ebaea98fa1b537ef9334", "checkerName": "readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 49, "file": 1, "line": 1708}, "message": "== 0 (fixit)"}, {"location": {"col": 18, "file": 1, "line": 1708}, "message": "implicit conversion 'int' -> bool"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/ext/luawrapper/include/LuaContext.hpp", "reportHash": "d0badbff2b810edb8e8f08eb713a15e5", "checkerName": "readability-implicit-bool-conversion", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 50, "file": 1, "line": 1708}, "message": "{ (fixit)"}, {"location": {"col": 49, "file": 1, "line": 1708}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/ext/luawrapper/include/LuaContext.hpp", "reportHash": "f437f07a29eb7b150d4ed18d968711bd", "checkerName": "hicpp-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 50, "file": 1, "line": 1720}, "message": "{ (fixit)"}, {"location": {"col": 49, "file": 1, "line": 1720}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/ext/luawrapper/include/LuaContext.hpp", "reportHash": "f644a5966d9324ba7dae45e968636261", "checkerName": "readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 24, "file": 1, "line": 1721}, "message": "redundant boolean literal in conditional return statement"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/ext/luawrapper/include/LuaContext.hpp", "reportHash": "684b421e1f9ae10632555c812143bf5f", "checkerName": "readability-simplify-boolean-expr", "reviewStatus": null, "severity": "MEDIUM"}, {"events": [{"location": {"col": 71, "file": 1, "line": 1731}, "message": "/*unused*/ (fixit)"}, {"location": {"col": 70, "file": 1, "line": 1731}, "message": "all parameters should be named in a function"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/ext/luawrapper/include/LuaContext.hpp", "reportHash": "ccb662ec67c05dcc18ed8eadeb2c6287", "checkerName": "readability-named-parameter", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 129, "file": 1, "line": 1737}, "message": "/*unused*/ (fixit)"}, {"location": {"col": 128, "file": 1, "line": 1737}, "message": "all parameters should be named in a function"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/ext/luawrapper/include/LuaContext.hpp", "reportHash": "d8f52b3af150fbae93f51769ae24d0a6", "checkerName": "readability-named-parameter", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 25, "file": 1, "line": 1746}, "message": "{ (fixit)"}, {"location": {"col": 24, "file": 1, "line": 1746}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/ext/luawrapper/include/LuaContext.hpp", "reportHash": "11c1851338e49c2b7d0fc44f6d7f32fb", "checkerName": "readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 39, "file": 3, "line": 509}, "message": "default parameter was declared here"}, {"location": {"col": 38, "file": 1, "line": 1747}, "message": "calling a function that uses a default argument is disallowed"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/ext/luawrapper/include/LuaContext.hpp", "reportHash": "0b4701fcaaa11b14a3a9b2d6205f1015", "checkerName": "fuchsia-default-arguments", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 129, "file": 1, "line": 1753}, "message": "/*unused*/ (fixit)"}, {"location": {"col": 128, "file": 1, "line": 1753}, "message": "all parameters should be named in a function"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/ext/luawrapper/include/LuaContext.hpp", "reportHash": "d8f52b3af150fbae93f51769ae24d0a6", "checkerName": "readability-named-parameter", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 25, "file": 1, "line": 1756}, "message": "{ (fixit)"}, {"location": {"col": 24, "file": 1, "line": 1756}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/ext/luawrapper/include/LuaContext.hpp", "reportHash": "deee969a77302a5b734c9982f9d36409", "checkerName": "readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 25, "file": 1, "line": 1760}, "message": "{ (fixit)"}, {"location": {"col": 24, "file": 1, "line": 1760}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/ext/luawrapper/include/LuaContext.hpp", "reportHash": "891cfb70002f611f04d6196f9f48f2c3", "checkerName": "google-readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 39, "file": 3, "line": 509}, "message": "default parameter was declared here"}, {"location": {"col": 38, "file": 1, "line": 1761}, "message": "calling a function that uses a default argument is disallowed"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/ext/luawrapper/include/LuaContext.hpp", "reportHash": "0b4701fcaaa11b14a3a9b2d6205f1015", "checkerName": "fuchsia-default-arguments", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 12, "file": 1, "line": 1772}, "message": "class 'ValueInRegistry' defines a non-default destructor, a copy constructor and a copy assignment operator but does not define a move constructor or a move assignment operator"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/ext/luawrapper/include/LuaContext.hpp", "reportHash": "170dbe0f33e98dee1ef12169bc46cd11", "checkerName": "cppcoreguidelines-special-member-functions", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 9, "file": 1, "line": 1774}, "message": "explicit (fixit)"}, {"location": {"col": 9, "file": 1, "line": 1774}, "message": "constructors that are callable with a single argument must be marked explicit to avoid unintentional implicit conversions"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/ext/luawrapper/include/LuaContext.hpp", "reportHash": "aeb34e1b3d8759e7430b3e62b4d7a9d5", "checkerName": "hicpp-explicit-conversions", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 42, "file": 1, "line": 1774}, "message": "declaring a parameter with a default argument is disallowed"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/ext/luawrapper/include/LuaContext.hpp", "reportHash": "3daf024f5bfde398de694b312cb58395", "checkerName": "fuchsia-default-arguments", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 9, "file": 1, "line": 1811}, "message": "cannot overload 'operator()'"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/ext/luawrapper/include/LuaContext.hpp", "reportHash": "41bf4c1232fbbedfca553070242405b3", "checkerName": "fuchsia-overloaded-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 42, "file": 1, "line": 1826}, "message": "using type = void (fixit)"}, {"location": {"col": 42, "file": 1, "line": 1826}, "message": "use 'using' instead of 'typedef'"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/ext/luawrapper/include/LuaContext.hpp", "reportHash": "9fd39fb88aeb70a50471079167c78e46", "checkerName": "modernize-use-using", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 35, "file": 1, "line": 1830}, "message": "using type = typename RemoveMemberPointerFunction<decltype(&std::decay<TObjectType>::type::operator())>::type (fixit)"}, {"location": {"col": 35, "file": 1, "line": 1830}, "message": "use 'using' instead of 'typedef'"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/ext/luawrapper/include/LuaContext.hpp", "reportHash": "f4efbd983d575bca2e536b46cb0280cd", "checkerName": "modernize-use-using", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 55, "file": 1, "line": 1862}, "message": "using type = std::tuple<T> (fixit)"}, {"location": {"col": 55, "file": 1, "line": 1862}, "message": "use 'using' instead of 'typedef'"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/ext/luawrapper/include/LuaContext.hpp", "reportHash": "cfbd677e6caade4e7e520fb85760b11a", "checkerName": "modernize-use-using", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 55, "file": 1, "line": 1864}, "message": "using type = std::tuple<> (fixit)"}, {"location": {"col": 55, "file": 1, "line": 1864}, "message": "use 'using' instead of 'typedef'"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/ext/luawrapper/include/LuaContext.hpp", "reportHash": "6836ba324416a108e092808ddbade43f", "checkerName": "modernize-use-using", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 55, "file": 1, "line": 1866}, "message": "using type = std::tuple<> (fixit)"}, {"location": {"col": 55, "file": 1, "line": 1866}, "message": "use 'using' instead of 'typedef'"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/ext/luawrapper/include/LuaContext.hpp", "reportHash": "ee5aff69f3369efe83d8e5b28bc39023", "checkerName": "modernize-use-using", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 83, "file": 1, "line": 1870}, "message": "using type = TRetValue (TParameters...) (fixit)"}, {"location": {"col": 83, "file": 1, "line": 1870}, "message": "use 'using' instead of 'typedef'"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/ext/luawrapper/include/LuaContext.hpp", "reportHash": "c9cd88ec4a75f4137c8f13adf14cca38", "checkerName": "modernize-use-using", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 83, "file": 1, "line": 1872}, "message": "using type = typename FunctionTypeDetector<TObjectType>::type (fixit)"}, {"location": {"col": 83, "file": 1, "line": 1872}, "message": "use 'using' instead of 'typedef'"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/ext/luawrapper/include/LuaContext.hpp", "reportHash": "605e8d75b56a88167a6da90ce841d13c", "checkerName": "modernize-use-using", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 107, "file": 1, "line": 1876}, "message": "using type = TRetValue (TParameters...) (fixit)"}, {"location": {"col": 107, "file": 1, "line": 1876}, "message": "use 'using' instead of 'typedef'"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/ext/luawrapper/include/LuaContext.hpp", "reportHash": "088d95868dccf0f8e596fc38cbfa48ba", "checkerName": "modernize-use-using", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 107, "file": 1, "line": 1878}, "message": "using type = TRetValue (TParameters...) (fixit)"}, {"location": {"col": 107, "file": 1, "line": 1878}, "message": "use 'using' instead of 'typedef'"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/ext/luawrapper/include/LuaContext.hpp", "reportHash": "9ff32a124ef7a03ead2d3951a7c00906", "checkerName": "modernize-use-using", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 107, "file": 1, "line": 1880}, "message": "using type = TRetValue (TParameters...) (fixit)"}, {"location": {"col": 107, "file": 1, "line": 1880}, "message": "use 'using' instead of 'typedef'"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/ext/luawrapper/include/LuaContext.hpp", "reportHash": "ca64297a5dc8de8b20aa74faebfe29fd", "checkerName": "modernize-use-using", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 107, "file": 1, "line": 1882}, "message": "using type = TRetValue (TParameters...) (fixit)"}, {"location": {"col": 107, "file": 1, "line": 1882}, "message": "use 'using' instead of 'typedef'"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/ext/luawrapper/include/LuaContext.hpp", "reportHash": "afb10f248cb0a259f3818853d8edbe2c", "checkerName": "modernize-use-using", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 5, "file": 1, "line": 1919}, "message": "using SubType = FunctionArgumentsCounter<TParams...> (fixit)"}, {"location": {"col": 5, "file": 1, "line": 1919}, "message": "use 'using' instead of 'typedef'"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/ext/luawrapper/include/LuaContext.hpp", "reportHash": "1e33f4368645dda2775a9ec0dff48666", "checkerName": "modernize-use-using", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 5, "file": 1, "line": 1941}, "message": "cannot overload 'operator()'"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/ext/luawrapper/include/LuaContext.hpp", "reportHash": "7def0e2b2fb4dd0673274fce47fb8d13", "checkerName": "fuchsia-overloaded-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 42, "file": 1, "line": 1972}, "message": "!= nullptr (fixit)"}, {"location": {"col": 13, "file": 1, "line": 1972}, "message": "implicit conversion 'std::__shared_ptr<LuaContext::ValueInRegistry, __gnu_cxx::_S_atomic>::element_type *' (aka 'LuaContext::ValueInRegistry *') -> bool"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/ext/luawrapper/include/LuaContext.hpp", "reportHash": "15514caf07cb126902219cac275eac74", "checkerName": "readability-implicit-bool-conversion", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 13, "file": 1, "line": 1972}, "message": "value.objectInRegistry (fixit)"}, {"location": {"col": 13, "file": 1, "line": 1972}, "message": "redundant get() call on smart pointer"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/ext/luawrapper/include/LuaContext.hpp", "reportHash": "04fa571d763402f35777302f412d6e14", "checkerName": "google-readability-redundant-smartptr-get", "reviewStatus": null, "severity": "MEDIUM"}, {"events": [{"location": {"col": 11, "file": 1, "line": 1975}, "message": "do not use 'else' after 'return'"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/ext/luawrapper/include/LuaContext.hpp", "reportHash": "f30932d7afa615aa543d25841a324436", "checkerName": "readability-else-after-return", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 32, "file": 1, "line": 1989}, "message": "static_cast<int>() (fixit)"}, {"location": {"col": 32, "file": 1, "line": 1989}, "message": "implicit conversion bool -> 'int'"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/ext/luawrapper/include/LuaContext.hpp", "reportHash": "064171d2886f5904ea0059a77aa55c75", "checkerName": "readability-implicit-bool-conversion", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 61, "file": 1, "line": 2072}, "message": "/*unused*/ (fixit)"}, {"location": {"col": 60, "file": 1, "line": 2072}, "message": "all parameters should be named in a function"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/ext/luawrapper/include/LuaContext.hpp", "reportHash": "fa803d597d5db6b5f563386381537715", "checkerName": "readability-named-parameter", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 38, "file": 1, "line": 2085}, "message": "do not use const_cast"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/ext/luawrapper/include/LuaContext.hpp", "reportHash": "8614f1f684e04539d0032ade3db51b26", "checkerName": "cppcoreguidelines-pro-type-const-cast", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 68, "file": 1, "line": 2114}, "message": "{ (fixit)"}, {"location": {"col": 67, "file": 1, "line": 2114}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/ext/luawrapper/include/LuaContext.hpp", "reportHash": "23d5b6dac8d554ab56032c344e6b00c6", "checkerName": "google-readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 68, "file": 1, "line": 2133}, "message": "{ (fixit)"}, {"location": {"col": 67, "file": 1, "line": 2133}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/ext/luawrapper/include/LuaContext.hpp", "reportHash": "23d5b6dac8d554ab56032c344e6b00c6", "checkerName": "google-readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 68, "file": 1, "line": 2152}, "message": "{ (fixit)"}, {"location": {"col": 67, "file": 1, "line": 2152}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/ext/luawrapper/include/LuaContext.hpp", "reportHash": "23d5b6dac8d554ab56032c344e6b00c6", "checkerName": "google-readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 57, "file": 1, "line": 2170}, "message": "{ (fixit)"}, {"location": {"col": 56, "file": 1, "line": 2170}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/ext/luawrapper/include/LuaContext.hpp", "reportHash": "db007abdaa7fdf5235d9701262cd3e9a", "checkerName": "google-readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 9, "file": 1, "line": 2192}, "message": "using RealType = typename std::underlying_type<TEnum>::type (fixit)"}, {"location": {"col": 9, "file": 1, "line": 2192}, "message": "use 'using' instead of 'typedef'"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/ext/luawrapper/include/LuaContext.hpp", "reportHash": "d6ac6d752e37072ecfeb222254db6d21", "checkerName": "modernize-use-using", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 5, "file": 1, "line": 2217}, "message": "using LocalFunctionArgumentsCounter = FunctionArgumentsCounter<TParameters...> (fixit)"}, {"location": {"col": 5, "file": 1, "line": 2217}, "message": "use 'using' instead of 'typedef'"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/ext/luawrapper/include/LuaContext.hpp", "reportHash": "ceb5a4c15ab0d30986c3a143bbaa8a90", "checkerName": "modernize-use-using", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 9, "file": 1, "line": 2225}, "message": "// TODO(root): is_move_constructible not supported by some compilers (fixit)"}, {"location": {"col": 9, "file": 1, "line": 2225}, "message": "missing username/bug in TODO"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/ext/luawrapper/include/LuaContext.hpp", "reportHash": "79571bf514c27f69263a8450b478e749", "checkerName": "google-readability-todo", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 9, "file": 1, "line": 2284}, "message": "// TODO(root): is_move_constructible not supported by some compilers (fixit)"}, {"location": {"col": 9, "file": 1, "line": 2284}, "message": "missing username/bug in TODO"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/ext/luawrapper/include/LuaContext.hpp", "reportHash": "79571bf514c27f69263a8450b478e749", "checkerName": "google-readability-todo", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 33, "file": 1, "line": 2318}, "message": "do not use reinterpret_cast"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/ext/luawrapper/include/LuaContext.hpp", "reportHash": "9ae653cf651c8c898b349e1cdcae8cb1", "checkerName": "cppcoreguidelines-pro-type-reinterpret-cast", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 38, "file": 1, "line": 2323}, "message": "do not use reinterpret_cast"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/ext/luawrapper/include/LuaContext.hpp", "reportHash": "10ad72a1846d43d1b4fdfcdbfb760808", "checkerName": "cppcoreguidelines-pro-type-reinterpret-cast", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 9, "file": 1, "line": 2395}, "message": "using P = Pusher<typename std::decay<TReturnType>::type> (fixit)"}, {"location": {"col": 9, "file": 1, "line": 2395}, "message": "use 'using' instead of 'typedef'"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/ext/luawrapper/include/LuaContext.hpp", "reportHash": "17e1eafd31c4401c51c362ee643eb2c9", "checkerName": "modernize-use-using", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 5, "file": 1, "line": 2414}, "message": "using SubPusher = Pusher<TReturnType (TParameters...)> (fixit)"}, {"location": {"col": 5, "file": 1, "line": 2414}, "message": "use 'using' instead of 'typedef'"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/ext/luawrapper/include/LuaContext.hpp", "reportHash": "f4999b64ea56df40d0e69c363696199d", "checkerName": "modernize-use-using", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 5, "file": 1, "line": 2430}, "message": "using SubPusher = Pusher<TReturnType (TParameters...)> (fixit)"}, {"location": {"col": 5, "file": 1, "line": 2430}, "message": "use 'using' instead of 'typedef'"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/ext/luawrapper/include/LuaContext.hpp", "reportHash": "6bbe60f3bcbf7e1c5c477fdf36f5b742", "checkerName": "modernize-use-using", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 5, "file": 1, "line": 2446}, "message": "using SubPusher = Pusher<TReturnType (TParameters...)> (fixit)"}, {"location": {"col": 5, "file": 1, "line": 2446}, "message": "use 'using' instead of 'typedef'"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/ext/luawrapper/include/LuaContext.hpp", "reportHash": "f4999b64ea56df40d0e69c363696199d", "checkerName": "modernize-use-using", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 9, "file": 1, "line": 2473}, "message": "cannot overload 'operator()'"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/ext/luawrapper/include/LuaContext.hpp", "reportHash": "f51499b7073e92536e0ce55d08caaa30", "checkerName": "fuchsia-overloaded-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 56, "file": 1, "line": 2478}, "message": "non-const reference parameter 'obj_', make it const or use a pointer"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/ext/luawrapper/include/LuaContext.hpp", "reportHash": "7b98d92f4a94726aca4626ce7b337a31", "checkerName": "google-runtime-references", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 5, "file": 1, "line": 2487}, "message": "using UnderlyingPusher = Pusher<typename std::decay<TType>::type> (fixit)"}, {"location": {"col": 5, "file": 1, "line": 2487}, "message": "use 'using' instead of 'typedef'"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/ext/luawrapper/include/LuaContext.hpp", "reportHash": "89618167c120e8473108ff1cea6912a5", "checkerName": "modernize-use-using", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 11, "file": 1, "line": 2496}, "message": "do not use 'else' after 'return'"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/ext/luawrapper/include/LuaContext.hpp", "reportHash": "f30932d7afa615aa543d25841a324436", "checkerName": "readability-else-after-return", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 5, "file": 1, "line": 2506}, "message": "// TODO(root): NOT EXCEPTION SAFE /!\\ // (fixit)"}, {"location": {"col": 5, "file": 1, "line": 2506}, "message": "missing username/bug in TODO"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/ext/luawrapper/include/LuaContext.hpp", "reportHash": "35559a6a073ac7b838ca1cc261a914ee", "checkerName": "google-readability-todo", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 106, "file": 1, "line": 2520}, "message": "/*unused*/ (fixit)"}, {"location": {"col": 105, "file": 1, "line": 2520}, "message": "all parameters should be named in a function"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/ext/luawrapper/include/LuaContext.hpp", "reportHash": "5b8bef0a6f0acf27818edd00d939d105", "checkerName": "readability-named-parameter", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 9, "file": 1, "line": 2521}, "message": "use 'using' instead of 'typedef'"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/ext/luawrapper/include/LuaContext.hpp", "reportHash": "d1d883836f8f8194d77009f88b0d02d2", "checkerName": "modernize-use-using", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 101, "file": 1, "line": 2528}, "message": "/*unused*/ (fixit)"}, {"location": {"col": 100, "file": 1, "line": 2528}, "message": "all parameters should be named in a function"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/ext/luawrapper/include/LuaContext.hpp", "reportHash": "5aa2b01a600c1d06c1bb652c55b36212", "checkerName": "readability-named-parameter", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 9, "file": 1, "line": 2529}, "message": "use 'using' instead of 'typedef'"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/ext/luawrapper/include/LuaContext.hpp", "reportHash": "d1d883836f8f8194d77009f88b0d02d2", "checkerName": "modernize-use-using", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 73, "file": 1, "line": 2535}, "message": "/*unused*/                                     /*unused*/ (fixit)"}, {"location": {"col": 72, "file": 1, "line": 2535}, "message": "all parameters should be named in a function"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/ext/luawrapper/include/LuaContext.hpp", "reportHash": "2be6029ddd4debb6621223edd53aa6e9", "checkerName": "readability-named-parameter", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 68, "file": 1, "line": 2539}, "message": "/*unused*/                                     /*unused*/ (fixit)"}, {"location": {"col": 67, "file": 1, "line": 2539}, "message": "all parameters should be named in a function"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/ext/luawrapper/include/LuaContext.hpp", "reportHash": "31a44b86d5af5a92c9e58f4a344ead4e", "checkerName": "readability-named-parameter", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 39, "file": 1, "line": 2568}, "message": "{ (fixit)"}, {"location": {"col": 38, "file": 1, "line": 2568}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/ext/luawrapper/include/LuaContext.hpp", "reportHash": "7020c95e66622e9642e1214fd8f4dbda", "checkerName": "hicpp-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 45, "file": 1, "line": 2594}, "message": "== 0 (fixit)"}, {"location": {"col": 18, "file": 1, "line": 2594}, "message": "implicit conversion 'int' -> bool"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/ext/luawrapper/include/LuaContext.hpp", "reportHash": "5448f274563f9f811e747b604f853760", "checkerName": "readability-implicit-bool-conversion", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 46, "file": 1, "line": 2594}, "message": "{ (fixit)"}, {"location": {"col": 45, "file": 1, "line": 2594}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/ext/luawrapper/include/LuaContext.hpp", "reportHash": "f830fd727cfe570ba55d9bf0e147bfec", "checkerName": "google-readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 45, "file": 1, "line": 2622}, "message": "== 0 (fixit)"}, {"location": {"col": 18, "file": 1, "line": 2622}, "message": "implicit conversion 'int' -> bool"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/ext/luawrapper/include/LuaContext.hpp", "reportHash": "5448f274563f9f811e747b604f853760", "checkerName": "readability-implicit-bool-conversion", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 46, "file": 1, "line": 2622}, "message": "{ (fixit)"}, {"location": {"col": 45, "file": 1, "line": 2622}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/ext/luawrapper/include/LuaContext.hpp", "reportHash": "430f4475c2354b0f6d522cc920802c3b", "checkerName": "readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 43, "file": 1, "line": 2637}, "message": "{ (fixit)"}, {"location": {"col": 42, "file": 1, "line": 2637}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/ext/luawrapper/include/LuaContext.hpp", "reportHash": "712f4efed409099b74aa9104e4d33bc4", "checkerName": "readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 20, "file": 1, "line": 2654}, "message": "nullptr (fixit)"}, {"location": {"col": 20, "file": 1, "line": 2654}, "message": "use nullptr"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/ext/luawrapper/include/LuaContext.hpp", "reportHash": "6b9928367fcc6e35c55674fa9dba7a3f", "checkerName": "modernize-use-nullptr", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 23, "file": 1, "line": 2654}, "message": "{ (fixit)"}, {"location": {"col": 22, "file": 1, "line": 2654}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/ext/luawrapper/include/LuaContext.hpp", "reportHash": "20a451c6eba82ef54b752ffb723ddd50", "checkerName": "readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 6, "file": 3, "line": 500}, "message": "default parameter was declared here"}, {"location": {"col": 16, "file": 1, "line": 2656}, "message": "calling a function that uses a default argument is disallowed"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/ext/luawrapper/include/LuaContext.hpp", "reportHash": "16ce1eee957856f47c131896e210aa90", "checkerName": "fuchsia-default-arguments", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 13, "file": 1, "line": 2670}, "message": "(                           == 0) (fixit)"}, {"location": {"col": 14, "file": 1, "line": 2670}, "message": "implicit conversion 'int' -> bool"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/ext/luawrapper/include/LuaContext.hpp", "reportHash": "4624dabc068271d303cf0b28d3b98bdf", "checkerName": "readability-implicit-bool-conversion", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 87, "file": 1, "line": 2670}, "message": "{ (fixit)"}, {"location": {"col": 86, "file": 1, "line": 2670}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/ext/luawrapper/include/LuaContext.hpp", "reportHash": "e7c55d0b2b0d8aefba30d34ccdb1b3d0", "checkerName": "google-readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 5, "file": 1, "line": 2680}, "message": "using ReturnType = LuaFunctionCaller<TRetValue (TParameters...)> (fixit)"}, {"location": {"col": 5, "file": 1, "line": 2680}, "message": "use 'using' instead of 'typedef'"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/ext/luawrapper/include/LuaContext.hpp", "reportHash": "d9331d11abff53181f02348427302a47", "checkerName": "modernize-use-using", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 85, "file": 1, "line": 2686}, "message": "{ (fixit)"}, {"location": {"col": 84, "file": 1, "line": 2686}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/ext/luawrapper/include/LuaContext.hpp", "reportHash": "18c002fba2d5a87486692e2e8dd0f071", "checkerName": "hicpp-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 41, "file": 1, "line": 2716}, "message": "{ (fixit)"}, {"location": {"col": 40, "file": 1, "line": 2716}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/ext/luawrapper/include/LuaContext.hpp", "reportHash": "036c6b7563a092b1ae91b5f4086c5377", "checkerName": "google-readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 41, "file": 1, "line": 2754}, "message": "{ (fixit)"}, {"location": {"col": 40, "file": 1, "line": 2754}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/ext/luawrapper/include/LuaContext.hpp", "reportHash": "79bc9c685bb54c0f590d45bf6bd2573d", "checkerName": "readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 41, "file": 1, "line": 2792}, "message": "{ (fixit)"}, {"location": {"col": 40, "file": 1, "line": 2792}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/ext/luawrapper/include/LuaContext.hpp", "reportHash": "54af166c077721c734a3fa24e373ce4c", "checkerName": "hicpp-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 38, "file": 1, "line": 2834}, "message": "{ (fixit)"}, {"location": {"col": 37, "file": 1, "line": 2834}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/ext/luawrapper/include/LuaContext.hpp", "reportHash": "483d6e39360b3b7e32ff13e7d8030094", "checkerName": "readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 63, "file": 1, "line": 2836}, "message": "{ (fixit)"}, {"location": {"col": 62, "file": 1, "line": 2836}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/ext/luawrapper/include/LuaContext.hpp", "reportHash": "e4cf1e8cc9bd8207045c7f64c570837a", "checkerName": "google-readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 9, "file": 1, "line": 2846}, "message": "using ReturnType = boost::variant<TTypes...> (fixit)"}, {"location": {"col": 2, "file": 1, "line": 2846}, "message": "use 'using' instead of 'typedef'"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/ext/luawrapper/include/LuaContext.hpp", "reportHash": "a335b0a668f43aac3e6538415537e071", "checkerName": "modernize-use-using", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 65, "file": 1, "line": 2860}, "message": "{ (fixit)"}, {"location": {"col": 64, "file": 1, "line": 2860}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/ext/luawrapper/include/LuaContext.hpp", "reportHash": "3aa403302c2e7240d01651889d5a4a22", "checkerName": "google-readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 5, "file": 1, "line": 2878}, "message": "use 'using' instead of 'typedef'"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/ext/luawrapper/include/LuaContext.hpp", "reportHash": "b9f665b12537b6f0eb334691a125d76f", "checkerName": "modernize-use-using", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 59, "file": 1, "line": 2895}, "message": "declaring a parameter with a default argument is disallowed"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/ext/luawrapper/include/LuaContext.hpp", "reportHash": "07515a29c908ab55e09914896dce5c7a", "checkerName": "fuchsia-default-arguments", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 85, "file": 1, "line": 2904}, "message": "// TODO(root): replace by std::is_default_constructible when it works on every compiler (fixit)"}, {"location": {"col": 85, "file": 1, "line": 2904}, "message": "missing username/bug in TODO"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/ext/luawrapper/include/LuaContext.hpp", "reportHash": "3013b7ac02e05fde5106592fb083b8a7", "checkerName": "google-readability-todo", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 2, "file": 1, "line": 2909}, "message": "use 'using' instead of 'typedef'"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/ext/luawrapper/include/LuaContext.hpp", "reportHash": "b13a8050c5d1b86f05a0a185a7bce32b", "checkerName": "modernize-use-using", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 51, "file": 1, "line": 2912}, "message": "declaring a parameter with a default argument is disallowed"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/ext/luawrapper/include/LuaContext.hpp", "reportHash": "a26c5755dad022403d29e47b981b4bd8", "checkerName": "fuchsia-default-arguments", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 27, "file": 1, "line": 2915}, "message": "{ (fixit)"}, {"location": {"col": 26, "file": 1, "line": 2915}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/ext/luawrapper/include/LuaContext.hpp", "reportHash": "d7fd723b9b21eff853fb71c8a375de92", "checkerName": "google-readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 38, "file": 1, "line": 2921}, "message": "{ (fixit)"}, {"location": {"col": 37, "file": 1, "line": 2921}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/ext/luawrapper/include/LuaContext.hpp", "reportHash": "44c35a7553f159587ad232cedc1cc132", "checkerName": "readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 85, "file": 1, "line": 2930}, "message": "// TODO(root): replace by std::is_default_constructible when it works on every compiler (fixit)"}, {"location": {"col": 85, "file": 1, "line": 2930}, "message": "missing username/bug in TODO"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/ext/luawrapper/include/LuaContext.hpp", "reportHash": "b06408b80752891b70f226f54456737e", "checkerName": "google-readability-todo", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 2, "file": 1, "line": 2935}, "message": "use 'using' instead of 'typedef'"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/ext/luawrapper/include/LuaContext.hpp", "reportHash": "b13a8050c5d1b86f05a0a185a7bce32b", "checkerName": "modernize-use-using", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 51, "file": 1, "line": 2938}, "message": "declaring a parameter with a default argument is disallowed"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/ext/luawrapper/include/LuaContext.hpp", "reportHash": "a26c5755dad022403d29e47b981b4bd8", "checkerName": "fuchsia-default-arguments", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 25, "file": 1, "line": 2942}, "message": "{ (fixit)"}, {"location": {"col": 24, "file": 1, "line": 2942}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/ext/luawrapper/include/LuaContext.hpp", "reportHash": "1ded0ba4ab0020096f56e1860a811a60", "checkerName": "hicpp-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 27, "file": 1, "line": 2945}, "message": "{ (fixit)"}, {"location": {"col": 26, "file": 1, "line": 2945}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/ext/luawrapper/include/LuaContext.hpp", "reportHash": "afbb402a26b0f171f9433e705a35aea8", "checkerName": "readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 24, "file": 1, "line": 2949}, "message": "{ (fixit)"}, {"location": {"col": 23, "file": 1, "line": 2949}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/ext/luawrapper/include/LuaContext.hpp", "reportHash": "8d71a152029c140053c594500b5b0916", "checkerName": "google-readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 24, "file": 9, "line": 31}, "message": "{ (fixit)"}, {"location": {"col": 23, "file": 9, "line": 31}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/pdns/ascii.hh", "reportHash": "815f8300dde8faae69768cd70324de4a", "checkerName": "google-readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 1, "file": 10, "line": 1}, "message": "header is missing header guard"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/pdns/auth-caches.hh", "reportHash": "059b8b5541007adefdef165a9e951d8c", "checkerName": "llvm-header-guard", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 10, "file": 10, "line": 23}, "message": "<cstdint> (fixit)"}, {"location": {"col": 1, "file": 10, "line": 23}, "message": "#includes are not sorted properly"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/pdns/auth-caches.hh", "reportHash": "90c87853b6f5f3a3b2824048d7b3d0a5", "checkerName": "llvm-include-order", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 1, "file": 11, "line": 1}, "message": "header is missing header guard"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/pdns/auth-packetcache.hh", "reportHash": "dbbfc2f085a8166211e1aae55f7e5311", "checkerName": "llvm-header-guard", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 10, "file": 11, "line": 23}, "message": "\"dns.hh\" (fixit)"}, {"location": {"col": 1, "file": 11, "line": 23}, "message": "#includes are not sorted properly"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/pdns/auth-packetcache.hh", "reportHash": "dbdc410c3abf2982fd9c926ef091143f", "checkerName": "llvm-include-order", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 1, "file": 11, "line": 28}, "message": "do not use namespace using-directives; use using-declarations instead"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/pdns/auth-packetcache.hh", "reportHash": "3167b8583074ef3c7112b015389f5cd1", "checkerName": "google-build-using-namespace", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 1, "file": 11, "line": 28}, "message": "using declarations in the global namespace in headers are prohibited"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/pdns/auth-packetcache.hh", "reportHash": "94354dcf97e02bf4a3edf14734ecc891", "checkerName": "google-global-names-in-headers", "reviewStatus": null, "severity": "HIGH"}, {"events": [{"location": {"col": 7, "file": 11, "line": 47}, "message": "class 'AuthPacketCache' defines a non-default destructor but does not define a copy constructor, a copy assignment operator, a move constructor or a move assignment operator"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/pdns/auth-packetcache.hh", "reportHash": "a03e232c95e20ce066a6c131d3863ceb", "checkerName": "hicpp-special-member-functions", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 3, "file": 11, "line": 50}, "message": "explicit (fixit)"}, {"location": {"col": 3, "file": 11, "line": 50}, "message": "single-argument constructors must be marked explicit to avoid unintentional implicit conversions"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/pdns/auth-packetcache.hh", "reportHash": "303b198fdef54fa0b998d8f4b83a55d4", "checkerName": "google-explicit-constructor", "reviewStatus": null, "severity": "MEDIUM"}, {"events": [{"location": {"col": 19, "file": 11, "line": 50}, "message": "declaring a parameter with a default argument is disallowed"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/pdns/auth-packetcache.hh", "reportHash": "0e9c4c81280376e22df654a3e9345943", "checkerName": "fuchsia-default-arguments", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 26, "file": 11, "line": 53}, "message": "non-const reference parameter 'q', make it const or use a pointer"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/pdns/auth-packetcache.hh", "reportHash": "b2d1d7a91d489f7faa4b111b3304b92f", "checkerName": "google-runtime-references", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 40, "file": 11, "line": 53}, "message": "non-const reference parameter 'r', make it const or use a pointer"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/pdns/auth-packetcache.hh", "reportHash": "6c06d7e3265134411d5262d215bf17ae", "checkerName": "google-runtime-references", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 23, "file": 11, "line": 55}, "message": "non-const reference parameter 'p', make it const or use a pointer"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/pdns/auth-packetcache.hh", "reportHash": "0f39410782306f1b276442c4b39c9364", "checkerName": "google-runtime-references", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 37, "file": 11, "line": 55}, "message": "non-const reference parameter 'q', make it const or use a pointer"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/pdns/auth-packetcache.hh", "reportHash": "77083d660861ece8afec6b8f3802fce7", "checkerName": "google-runtime-references", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 3, "file": 11, "line": 97}, "message": "use 'using' instead of 'typedef'"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/pdns/auth-packetcache.hh", "reportHash": "c1fb639f54f89804a7e48681621cb778", "checkerName": "modernize-use-using", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 10, "file": 11, "line": 108}, "message": "class 'MapCombo' defines a non-default destructor, a copy constructor and a copy assignment operator but does not define a move constructor or a move assignment operator"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/pdns/auth-packetcache.hh", "reportHash": "c292d93910e0cfeb68d2538192b7cc85", "checkerName": "hicpp-special-member-functions", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 5, "file": 12, "line": 175}, "message": "default parameter was declared here"}, {"location": {"col": 5, "file": 11, "line": 110}, "message": "calling a function that uses a default argument is disallowed"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/pdns/auth-packetcache.hh", "reportHash": "6ebb8c278c2eb240d3055d1cff2beed6", "checkerName": "fuchsia-default-arguments", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 16, "file": 11, "line": 110}, "message": "= default; (fixit)"}, {"location": {"col": 5, "file": 11, "line": 110}, "message": "use '= default' to define a trivial default constructor"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/pdns/auth-packetcache.hh", "reportHash": "e345cc35073124bcff06b2998ad2e33e", "checkerName": "hicpp-use-equals-default", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 17, "file": 11, "line": 112}, "message": "= default; (fixit)"}, {"location": {"col": 5, "file": 11, "line": 112}, "message": "use '= default' to define a trivial destructor"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/pdns/auth-packetcache.hh", "reportHash": "b722ec31599ef18d87c5d08571281927", "checkerName": "hicpp-use-equals-default", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 15, "file": 13, "line": 129}, "message": "default parameter was declared here"}, {"location": {"col": 19, "file": 11, "line": 126}, "message": "calling a function that uses a default argument is disallowed"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/pdns/auth-packetcache.hh", "reportHash": "82a4676a0b961621be562d85f33124a5", "checkerName": "fuchsia-default-arguments", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 68, "file": 11, "line": 129}, "message": "non-const reference parameter 'iter', make it const or use a pointer"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/pdns/auth-packetcache.hh", "reportHash": "ccb2b63a6077e758ff39cf5154d0bc2e", "checkerName": "google-runtime-references", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 31, "file": 11, "line": 130}, "message": "non-const reference parameter 'map', make it const or use a pointer"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/pdns/auth-packetcache.hh", "reportHash": "9d7a1a360caf15f3bdd93cab58665816", "checkerName": "google-runtime-references", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 145, "file": 11, "line": 130}, "message": "non-const reference parameter 'entry', make it const or use a pointer"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/pdns/auth-packetcache.hh", "reportHash": "40213034eefc1533fb497ad8367c00a8", "checkerName": "google-runtime-references", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 3, "file": 11, "line": 140}, "message": "consider replacing 'unsigned long' with 'uint64'"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/pdns/auth-packetcache.hh", "reportHash": "d40a9bbe1c4d1414362f6563ee876e2c", "checkerName": "google-runtime-int", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 1, "file": 14, "line": 1}, "message": "header is missing header guard"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/pdns/auth-querycache.hh", "reportHash": "c20de9c615a773b68c85ed60ba8cb47e", "checkerName": "llvm-header-guard", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 10, "file": 14, "line": 23}, "message": "\"dns.hh\" (fixit)"}, {"location": {"col": 1, "file": 14, "line": 23}, "message": "#includes are not sorted properly"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/pdns/auth-querycache.hh", "reportHash": "a7b666d0777f0f22e75713c03490a8b3", "checkerName": "llvm-include-order", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 1, "file": 14, "line": 28}, "message": "do not use namespace using-directives; use using-declarations instead"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/pdns/auth-querycache.hh", "reportHash": "4f17205385e7f0dec0f8f49ba5765daa", "checkerName": "google-build-using-namespace", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 1, "file": 14, "line": 28}, "message": "using declarations in the global namespace in headers are prohibited"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/pdns/auth-querycache.hh", "reportHash": "0eb908a067e48572a36609481711441f", "checkerName": "google-global-names-in-headers", "reviewStatus": null, "severity": "HIGH"}, {"events": [{"location": {"col": 7, "file": 14, "line": 36}, "message": "class 'AuthQueryCache' defines a non-default destructor but does not define a copy constructor, a copy assignment operator, a move constructor or a move assignment operator"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/pdns/auth-querycache.hh", "reportHash": "7499390308722c293434736817d7d8fb", "checkerName": "hicpp-special-member-functions", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 3, "file": 14, "line": 39}, "message": "explicit (fixit)"}, {"location": {"col": 3, "file": 14, "line": 39}, "message": "single-argument constructors must be marked explicit to avoid unintentional implicit conversions"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/pdns/auth-querycache.hh", "reportHash": "4601c3c29b207df3ccc08f284b7b05a1", "checkerName": "google-explicit-constructor", "reviewStatus": null, "severity": "MEDIUM"}, {"events": [{"location": {"col": 18, "file": 14, "line": 39}, "message": "declaring a parameter with a default argument is disallowed"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/pdns/auth-querycache.hh", "reportHash": "6699c2c8ba2c84a642a70f151739301b", "checkerName": "fuchsia-default-arguments", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 82, "file": 14, "line": 44}, "message": "non-const reference parameter 'entry', make it const or use a pointer"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/pdns/auth-querycache.hh", "reportHash": "a2e87295bfca5aa6ce8eca2666942fe3", "checkerName": "google-runtime-references", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 3, "file": 14, "line": 76}, "message": "use 'using' instead of 'typedef'"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/pdns/auth-querycache.hh", "reportHash": "084be36472621d5fd92ab7b006a9e300", "checkerName": "modernize-use-using", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 10, "file": 14, "line": 91}, "message": "class 'MapCombo' defines a non-default destructor, a copy constructor and a copy assignment operator but does not define a move constructor or a move assignment operator"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/pdns/auth-querycache.hh", "reportHash": "76b84efccecba5aa465e205995b488a3", "checkerName": "cppcoreguidelines-special-member-functions", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 5, "file": 12, "line": 174}, "message": "default parameter was declared here"}, {"location": {"col": 5, "file": 14, "line": 93}, "message": "calling a function that uses a default argument is disallowed"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/pdns/auth-querycache.hh", "reportHash": "329e643df1bec7fbab65dafd8ed3923b", "checkerName": "fuchsia-default-arguments", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 16, "file": 14, "line": 93}, "message": "= default; (fixit)"}, {"location": {"col": 5, "file": 14, "line": 93}, "message": "use '= default' to define a trivial default constructor"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/pdns/auth-querycache.hh", "reportHash": "e42864de3f109f026ff4189c5aa787d6", "checkerName": "hicpp-use-equals-default", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 17, "file": 14, "line": 95}, "message": "= default; (fixit)"}, {"location": {"col": 5, "file": 14, "line": 95}, "message": "use '= default' to define a trivial destructor"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/pdns/auth-querycache.hh", "reportHash": "eb0b08bd8692bda315f1800330116e90", "checkerName": "hicpp-use-equals-default", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 15, "file": 13, "line": 129}, "message": "default parameter was declared here"}, {"location": {"col": 19, "file": 14, "line": 109}, "message": "calling a function that uses a default argument is disallowed"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/pdns/auth-querycache.hh", "reportHash": "711eda2ace7fe5c988ab425bc39be46c", "checkerName": "fuchsia-default-arguments", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 31, "file": 14, "line": 112}, "message": "non-const reference parameter 'map', make it const or use a pointer"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/pdns/auth-querycache.hh", "reportHash": "66b489f529e913a289a012556ebdad7e", "checkerName": "google-runtime-references", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 99, "file": 14, "line": 112}, "message": "non-const reference parameter 'entry', make it const or use a pointer"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/pdns/auth-querycache.hh", "reportHash": "43bd0d73f31f2276d3c01b9b91638571", "checkerName": "google-runtime-references", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 3, "file": 14, "line": 122}, "message": "consider replacing 'unsigned long' with 'uint64'"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/pdns/auth-querycache.hh", "reportHash": "83ea56627e0abef9fe0c0a58dfbc7bef", "checkerName": "google-runtime-int", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 1, "file": 16, "line": 1}, "message": "header is missing header guard"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/pdns/comment.hh", "reportHash": "4d080ad6d945015b258bed6fb71575a5", "checkerName": "llvm-header-guard", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 10, "file": 16, "line": 23}, "message": "\"qtype.hh\" (fixit)"}, {"location": {"col": 1, "file": 16, "line": 23}, "message": "#includes are not sorted properly"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/pdns/comment.hh", "reportHash": "94811281be6249dcba026a5270321f37", "checkerName": "llvm-include-order", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 7, "file": 16, "line": 27}, "message": "class 'Comment' defines a non-default destructor but does not define a copy constructor, a copy assignment operator, a move constructor or a move assignment operator"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/pdns/comment.hh", "reportHash": "d09e994bb7ac33b5f0b8cb5d54e14bbd", "checkerName": "hicpp-special-member-functions", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 14, "file": 16, "line": 31}, "message": "= default; (fixit)"}, {"location": {"col": 3, "file": 16, "line": 31}, "message": "use '= default' to define a trivial destructor"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/pdns/comment.hh", "reportHash": "d348d4aac8cbc065d0bd754c33533386", "checkerName": "hicpp-use-equals-default", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 21, "file": 16, "line": 35}, "message": "{0} (fixit)"}, {"location": {"col": 10, "file": 16, "line": 35}, "message": "use default member initializer for 'modified_at'"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/pdns/comment.hh", "reportHash": "3de5998dc9fc42c2e106f13b3dfe8593", "checkerName": "modernize-use-default-member-init", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 16, "file": 16, "line": 39}, "message": "{0} (fixit)"}, {"location": {"col": 7, "file": 16, "line": 39}, "message": "use default member initializer for 'domain_id'"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/pdns/comment.hh", "reportHash": "504ae1b66c362342a2b39b46f7c6240a", "checkerName": "modernize-use-default-member-init", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 1, "file": 17, "line": 1}, "message": "header is missing header guard"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/pdns/common_startup.hh", "reportHash": "9bedde61af18fbd599681dd7f7403214", "checkerName": "llvm-header-guard", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 10, "file": 17, "line": 23}, "message": "\"arguments.hh\" (fixit)"}, {"location": {"col": 1, "file": 17, "line": 23}, "message": "#includes are not sorted properly"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/pdns/common_startup.hh", "reportHash": "c44e5a922839c0336a12ccb3f82fc276", "checkerName": "llvm-include-order", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 16, "file": 18, "line": 39}, "message": "previously declared here"}, {"location": {"col": 16, "file": 17, "line": 38}, "message": "redundant 'S' declaration"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/pdns/common_startup.hh", "reportHash": "a41fa668daf3adb5567a2be7fe684894", "checkerName": "readability-redundant-declaration", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 1, "file": 19, "line": 1}, "message": "header is missing header guard"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/pdns/communicator.hh", "reportHash": "9aaa843f010d51143dcb74cfcad2cf3a", "checkerName": "llvm-header-guard", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 10, "file": 19, "line": 23}, "message": "<boost/multi_index/identity.hpp> (fixit)"}, {"location": {"col": 1, "file": 19, "line": 23}, "message": "#includes are not sorted properly"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/pdns/communicator.hh", "reportHash": "182d54b1932fc64ec9b7e7caee593d92", "checkerName": "llvm-include-order", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 1, "file": 19, "line": 32}, "message": "do not use namespace using-directives; use using-declarations instead"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/pdns/communicator.hh", "reportHash": "71dd0e8246d610120116b1aa8d09423d", "checkerName": "google-build-using-namespace", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 1, "file": 19, "line": 32}, "message": "using declarations in the global namespace in headers are prohibited"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/pdns/communicator.hh", "reportHash": "b244f15f0030424a2e14b44bcecc85cd", "checkerName": "google-global-names-in-headers", "reviewStatus": null, "severity": "HIGH"}, {"events": [{"location": {"col": 10, "file": 19, "line": 34}, "message": "<fcntl.h> (fixit)"}, {"location": {"col": 1, "file": 19, "line": 34}, "message": "#includes are not sorted properly"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/pdns/communicator.hh", "reportHash": "4897579fe03f8b6166c7109262f21cf6", "checkerName": "llvm-include-order", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 10, "file": 19, "line": 41}, "message": "\"dns_random.hh\" (fixit)"}, {"location": {"col": 1, "file": 19, "line": 41}, "message": "#includes are not sorted properly"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/pdns/communicator.hh", "reportHash": "83bd344382e248cc349eeeb9f3d7c382", "checkerName": "llvm-include-order", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 3, "file": 19, "line": 49}, "message": "cannot overload 'operator<'"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/pdns/communicator.hh", "reportHash": "8ef7a5f6824c878d59b38d93968d25b6", "checkerName": "fuchsia-overloaded-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 1, "file": 19, "line": 57}, "message": "use 'using' instead of 'typedef'"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/pdns/communicator.hh", "reportHash": "7c07820d58f146874da13a37edf30b9a", "checkerName": "modernize-use-using", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 1, "file": 19, "line": 64}, "message": "using domains_by_name_t = UniQueue::index<IDTag>::type (fixit)"}, {"location": {"col": 1, "file": 19, "line": 64}, "message": "use 'using' instead of 'typedef'"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/pdns/communicator.hh", "reportHash": "6cfd5c7b888b49b469a2bbde2de32261", "checkerName": "modernize-use-using", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 44, "file": 20, "line": 211}, "message": "default parameter was declared here"}, {"location": {"col": 24, "file": 19, "line": 71}, "message": "calling a function that uses a default argument is disallowed"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/pdns/communicator.hh", "reportHash": "d9524399746eb478b435bf255ef259c5", "checkerName": "fuchsia-default-arguments", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 24, "file": 19, "line": 75}, "message": "do not access members of unions; use (boost::)variant instead"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/pdns/communicator.hh", "reportHash": "ccf47f6f2e2f516c1106697f1681254b", "checkerName": "cppcoreguidelines-pro-type-union-access", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 24, "file": 19, "line": 78}, "message": "nullptr (fixit)"}, {"location": {"col": 24, "file": 19, "line": 78}, "message": "use nullptr"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/pdns/communicator.hh", "reportHash": "eaf708bc631328e7b3b51400f47b98bd", "checkerName": "hicpp-use-nullptr", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 9, "file": 19, "line": 88}, "message": "auto (fixit)"}, {"location": {"col": 9, "file": 19, "line": 88}, "message": "use auto when declaring iterators"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/pdns/communicator.hh", "reportHash": "9aa60bbd70589618cf535cb83e7ff4bc", "checkerName": "hicpp-use-auto", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 24, "file": 19, "line": 98}, "message": "non-const reference parameter 'domain', make it const or use a pointer"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/pdns/communicator.hh", "reportHash": "51c7d1612a2c1c21f0a027b0529fd8e5", "checkerName": "google-runtime-references", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 40, "file": 19, "line": 98}, "message": "non-const reference parameter 'ip', make it const or use a pointer"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/pdns/communicator.hh", "reportHash": "9ddb2c6d390bcde04e4471ccbdc0390c", "checkerName": "google-runtime-references", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 64, "file": 19, "line": 98}, "message": "non-const reference parameter 'purged', make it const or use a pointer"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/pdns/communicator.hh", "reportHash": "8391d286fa0bba131a9bf62982030bca", "checkerName": "google-runtime-references", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 9, "file": 19, "line": 100}, "message": "auto (fixit)"}, {"location": {"col": 9, "file": 19, "line": 100}, "message": "use auto when declaring iterators"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/pdns/communicator.hh", "reportHash": "d8f61caf2f89ef7bf747c45d9ccb1860", "checkerName": "hicpp-use-auto", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 72, "file": 19, "line": 100}, "message": "{ (fixit)"}, {"location": {"col": 71, "file": 19, "line": 100}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/pdns/communicator.hh", "reportHash": "ecb1c654a7fec5d3cd2e506008235ddd", "checkerName": "readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 26, "file": 19, "line": 101}, "message": "nullptr (fixit)"}, {"location": {"col": 26, "file": 19, "line": 101}, "message": "use nullptr"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/pdns/communicator.hh", "reportHash": "6d521ea779ef327a8296060aa22468c9", "checkerName": "hicpp-use-nullptr", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 22, "file": 19, "line": 104}, "message": "nullptr (fixit)"}, {"location": {"col": 22, "file": 19, "line": 104}, "message": "use nullptr"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/pdns/communicator.hh", "reportHash": "1754275beffb1cec91475c0711e9306a", "checkerName": "hicpp-use-nullptr", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 28, "file": 19, "line": 104}, "message": "use of a signed integer operand with a binary bitwise operator"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/pdns/communicator.hh", "reportHash": "7ceb71487b9b2bca4a3091ef7cc17ef3", "checkerName": "hicpp-signed-bitwise", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 78, "file": 19, "line": 121}, "message": "{ (fixit)"}, {"location": {"col": 77, "file": 19, "line": 121}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/pdns/communicator.hh", "reportHash": "d13371b33cc7d2bbadcb20e09263c926", "checkerName": "google-readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 23, "file": 19, "line": 123}, "message": "nullptr (fixit)"}, {"location": {"col": 23, "file": 19, "line": 123}, "message": "use nullptr"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/pdns/communicator.hh", "reportHash": "148cba360f53f642e74c8861e189ac49", "checkerName": "modernize-use-nullptr", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 10, "file": 19, "line": 129}, "message": "constructor does not initialize these fields: next, attempts, id"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/pdns/communicator.hh", "reportHash": "e5067fcaf25d6afdea6e3d4a957090e8", "checkerName": "cppcoreguidelines-pro-type-member-init", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 3, "file": 19, "line": 138}, "message": "using d_nqueue_t = std::list<NotificationRequest> (fixit)"}, {"location": {"col": 3, "file": 19, "line": 138}, "message": "use 'using' instead of 'typedef'"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/pdns/communicator.hh", "reportHash": "7bff11cf0da4cee749bbce3e8d79de6e", "checkerName": "modernize-use-using", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 5, "file": 12, "line": 174}, "message": "default parameter was declared here"}, {"location": {"col": 3, "file": 19, "line": 151}, "message": "calling a function that uses a default argument is disallowed"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/pdns/communicator.hh", "reportHash": "6399ed5755323379cea77f4706e41d90", "checkerName": "fuchsia-default-arguments", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 74, "file": 19, "line": 165}, "message": "declaring a parameter with a default argument is disallowed"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/pdns/communicator.hh", "reportHash": "5289bad4779fe7b79b94365decb4a288", "checkerName": "fuchsia-default-arguments", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 59, "file": 19, "line": 174}, "message": "non-const reference parameter 'listset', make it const or use a pointer"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/pdns/communicator.hh", "reportHash": "e9f7c2e6c40bd44e13541ac6cf66da84", "checkerName": "google-runtime-references", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 64, "file": 19, "line": 180}, "message": "declaring a parameter with a default argument is disallowed"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/pdns/communicator.hh", "reportHash": "0c5a3414bcd74b12838b571ec20ddcbc", "checkerName": "fuchsia-default-arguments", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 145, "file": 19, "line": 181}, "message": "non-const reference parameter 'pdl', make it const or use a pointer"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/pdns/communicator.hh", "reportHash": "f065556fccb31b020c52ee9cc7fb6d63", "checkerName": "google-runtime-references", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 29, "file": 19, "line": 182}, "message": "non-const reference parameter 'zs', make it const or use a pointer"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/pdns/communicator.hh", "reportHash": "bf93a771ff23ed111ed9b492e17d9cd8", "checkerName": "google-runtime-references", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 5, "file": 19, "line": 196}, "message": "cannot overload 'operator()'"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/pdns/communicator.hh", "reportHash": "563825f981bd11de18cf06f9458717c4", "checkerName": "fuchsia-overloaded-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 10, "file": 19, "line": 214}, "message": "class 'RemoveSentinel' defines a non-default destructor but does not define a copy constructor, a copy assignment operator, a move constructor or a move assignment operator"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/pdns/communicator.hh", "reportHash": "345c7e896e9e69bc971f5604d0e4a040", "checkerName": "cppcoreguidelines-special-member-functions", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 29, "file": 19, "line": 216}, "message": "DNSName                                          std::move() (fixit)"}, {"location": {"col": 29, "file": 19, "line": 216}, "message": "pass by value and use std::move"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/pdns/communicator.hh", "reportHash": "853ec6d6072e7105e8c59c7835cdd2ea", "checkerName": "modernize-pass-by-value", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 10, "file": 19, "line": 244}, "message": "!= nullptr (fixit)"}, {"location": {"col": 8, "file": 19, "line": 244}, "message": "implicit conversion 'UeberBackend *' -> bool"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/pdns/communicator.hh", "reportHash": "adf0e6fa9d35e2e6d4356463d0041b52", "checkerName": "readability-implicit-bool-conversion", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 66, "file": 21, "line": 96}, "message": "default parameter was declared here"}, {"location": {"col": 9, "file": 19, "line": 245}, "message": "calling a function that uses a default argument is disallowed"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/pdns/communicator.hh", "reportHash": "14ebc6c8541283df19274aa6195e59bc", "checkerName": "fuchsia-default-arguments", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 27, "file": 19, "line": 247}, "message": "{ (fixit)"}, {"location": {"col": 26, "file": 19, "line": 247}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/pdns/communicator.hh", "reportHash": "7d30dcde80d7e80ed05c4bba4ca4e4fa", "checkerName": "google-readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 69, "file": 19, "line": 248}, "message": "{ (fixit)"}, {"location": {"col": 68, "file": 19, "line": 248}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/pdns/communicator.hh", "reportHash": "bcb68d5071e158aab99a65df5882267b", "checkerName": "google-readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 45, "file": 22, "line": 197}, "message": "default parameter was declared here"}, {"location": {"col": 33, "file": 19, "line": 249}, "message": "calling a function that uses a default argument is disallowed"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/pdns/communicator.hh", "reportHash": "32eb2df44637e299193aa7a2cb8187b7", "checkerName": "fuchsia-default-arguments", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 26, "file": 19, "line": 258}, "message": "{} (fixit)"}, {"location": {"col": 5, "file": 19, "line": 258}, "message": "uninitialized record type: 'hints'"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/pdns/communicator.hh", "reportHash": "bd21cadd6c803929cc632d0ed3deb3f7", "checkerName": "cppcoreguidelines-pro-type-member-init", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 27, "file": 19, "line": 262}, "message": "!= 0 (fixit)"}, {"location": {"col": 25, "file": 19, "line": 262}, "message": "implicit conversion 'int' -> bool"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/pdns/communicator.hh", "reportHash": "7dc1abd4c8e75337981ee0b1f3fd778a", "checkerName": "readability-implicit-bool-conversion", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 14, "file": 19, "line": 264}, "message": "do not access members of unions; use (boost::)variant instead"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/pdns/communicator.hh", "reportHash": "ec30b036e3f1bbd4154d4d477015ad4e", "checkerName": "cppcoreguidelines-pro-type-union-access", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 65, "file": 19, "line": 265}, "message": "== 0 (fixit)"}, {"location": {"col": 11, "file": 19, "line": 265}, "message": "implicit conversion 'int' -> bool"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/pdns/communicator.hh", "reportHash": "bbbfc3576ffd963bb649c1859ae12dea", "checkerName": "readability-implicit-bool-conversion", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 24, "file": 13, "line": 92}, "message": "default parameter was declared here"}, {"location": {"col": 23, "file": 19, "line": 265}, "message": "calling a function that uses a default argument is disallowed"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/pdns/communicator.hh", "reportHash": "5dca7f347664f464ac068c96d2043a25", "checkerName": "fuchsia-default-arguments", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 48, "file": 19, "line": 265}, "message": "nullptr (fixit)"}, {"location": {"col": 48, "file": 19, "line": 265}, "message": "use nullptr"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/pdns/communicator.hh", "reportHash": "ef0e6446f6c9e1e652766c843f1a31ea", "checkerName": "hicpp-use-nullptr", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 20, "file": 19, "line": 269}, "message": "do not access members of unions; use (boost::)variant instead"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/pdns/communicator.hh", "reportHash": "4811fbec5208590b7ef6e52b2f99bc91", "checkerName": "cppcoreguidelines-pro-type-union-access", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 41, "file": 19, "line": 270}, "message": "do not access members of unions; use (boost::)variant instead"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/pdns/communicator.hh", "reportHash": "dca73329e4f1df43daaa39d143bd55ce", "checkerName": "cppcoreguidelines-pro-type-union-access", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 46, "file": 19, "line": 272}, "message": "!= nullptr (fixit)"}, {"location": {"col": 17, "file": 19, "line": 272}, "message": "implicit conversion 'struct addrinfo *' -> bool"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/pdns/communicator.hh", "reportHash": "b9a38217e8dd6a32fcd2565485dca2e6", "checkerName": "readability-implicit-bool-conversion", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 1, "file": 18, "line": 1}, "message": "header is missing header guard"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/pdns/distributor.hh", "reportHash": "7cda49a99869bd31d3552994c94b1ab4", "checkerName": "llvm-header-guard", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 10, "file": 18, "line": 23}, "message": "\"arguments.hh\" (fixit)"}, {"location": {"col": 1, "file": 18, "line": 23}, "message": "#includes are not sorted properly"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/pdns/distributor.hh", "reportHash": "5b0640f65da4cf5e8652061ffe7a7b39", "checkerName": "llvm-include-order", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 61, "file": 18, "line": 50}, "message": "class 'Distributor' defines a non-default destructor but does not define a copy constructor, a copy assignment operator, a move constructor or a move assignment operator"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/pdns/distributor.hh", "reportHash": "548e9148602e82b1ff1c84059baf3064", "checkerName": "cppcoreguidelines-special-member-functions", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 30, "file": 18, "line": 53}, "message": "declaring a parameter with a default argument is disallowed"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/pdns/distributor.hh", "reportHash": "f95464794fe4722291942e222f02d060", "checkerName": "fuchsia-default-arguments", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 3, "file": 18, "line": 54}, "message": "using callback_t = std::function<void (std::unique_ptr<Answer> &)> (fixit)"}, {"location": {"col": 3, "file": 18, "line": 54}, "message": "use 'using' instead of 'typedef'"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/pdns/distributor.hh", "reportHash": "053f4f8ebb2cb166a58fb27af45539bf", "checkerName": "modernize-use-using", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 61, "file": 18, "line": 61}, "message": "class 'SingleThreadDistributor' defines a copy constructor and a copy assignment operator but does not define a destructor, a move constructor or a move assignment operator"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/pdns/distributor.hh", "reportHash": "2018a1c66caae5ee3c626d019dd21cad", "checkerName": "cppcoreguidelines-special-member-functions", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 3, "file": 18, "line": 68}, "message": "using callback_t = std::function<void (std::unique_ptr<Answer> &)> (fixit)"}, {"location": {"col": 3, "file": 18, "line": 68}, "message": "use 'using' instead of 'typedef'"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/pdns/distributor.hh", "reportHash": "053f4f8ebb2cb166a58fb27af45539bf", "checkerName": "modernize-use-using", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 26, "file": 18, "line": 69}, "message": "/*q*/ (fixit)"}, {"location": {"col": 25, "file": 18, "line": 69}, "message": "all parameters should be named in a function"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/pdns/distributor.hh", "reportHash": "76b3d133a13049e4dbbb4b0d7296c718", "checkerName": "readability-named-parameter", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 61, "file": 18, "line": 83}, "message": "class 'MultiThreadDistributor' defines a copy constructor and a copy assignment operator but does not define a destructor, a move constructor or a move assignment operator"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/pdns/distributor.hh", "reportHash": "4ed087a01004f62a892f0e804a53a971", "checkerName": "cppcoreguidelines-special-member-functions", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 3, "file": 18, "line": 89}, "message": "explicit (fixit)"}, {"location": {"col": 3, "file": 18, "line": 89}, "message": "single-argument constructors must be marked explicit to avoid unintentional implicit conversions"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/pdns/distributor.hh", "reportHash": "1a68425cde685dec487a538872d42b3f", "checkerName": "hicpp-explicit-conversions", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 3, "file": 18, "line": 90}, "message": "using callback_t = std::function<void (std::unique_ptr<Answer> &)> (fixit)"}, {"location": {"col": 3, "file": 18, "line": 90}, "message": "use 'using' instead of 'typedef'"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/pdns/distributor.hh", "reportHash": "053f4f8ebb2cb166a58fb27af45539bf", "checkerName": "modernize-use-using", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 26, "file": 18, "line": 91}, "message": "/*q*/ (fixit)"}, {"location": {"col": 25, "file": 18, "line": 91}, "message": "all parameters should be named in a function"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/pdns/distributor.hh", "reportHash": "76b3d133a13049e4dbbb4b0d7296c718", "checkerName": "readability-named-parameter", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 23, "file": 18, "line": 92}, "message": "ournum (fixit)"}, {"location": {"col": 108, "file": 18, "line": 182}, "message": "the definition seen here"}, {"location": {"col": 8, "file": 18, "line": 92}, "message": "differing parameters are named here: ('n'), in definition: ('ournum')"}, {"location": {"col": 8, "file": 18, "line": 92}, "message": "function 'MultiThreadDistributor::distribute' has a definition with different parameter names"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/pdns/distributor.hh", "reportHash": "98e892230b39fc4f1c8c834b0b6e395a", "checkerName": "readability-inconsistent-declaration-parameter-name", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 5, "file": 18, "line": 99}, "message": "constructor does not initialize these fields: id"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/pdns/distributor.hh", "reportHash": "a5efc8717669a26d661a8e9eb543c2f5", "checkerName": "cppcoreguidelines-pro-type-member-init", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 5, "file": 18, "line": 99}, "message": "explicit (fixit)"}, {"location": {"col": 5, "file": 18, "line": 99}, "message": "single-argument constructors must be marked explicit to avoid unintentional implicit conversions"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/pdns/distributor.hh", "reportHash": "a36b570d99295b0133548d9d97ab2504", "checkerName": "google-explicit-constructor", "reviewStatus": null, "severity": "MEDIUM"}, {"events": [{"location": {"col": 18, "file": 18, "line": 125}, "message": "{ (fixit)"}, {"location": {"col": 17, "file": 18, "line": 125}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/pdns/distributor.hh", "reportHash": "349d243f48d7e9b0e8629ae40e802bc4", "checkerName": "google-readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 7, "file": 18, "line": 126}, "message": "returning a newly created resource of type 'Distributor<Answer, Question, Backend> *' or 'gsl::owner<>' from a function whose return type is not 'gsl::owner<>'"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/pdns/distributor.hh", "reportHash": "2dd3f5a382bf956bcef26ffb009f08b4", "checkerName": "cppcoreguidelines-owning-memory", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 5, "file": 18, "line": 127}, "message": "do not use 'else' after 'return'"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/pdns/distributor.hh", "reportHash": "06c8b4c005d3bbdb147d50f95425c985", "checkerName": "readability-else-after-return", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 10, "file": 18, "line": 127}, "message": "{ (fixit)"}, {"location": {"col": 9, "file": 18, "line": 127}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/pdns/distributor.hh", "reportHash": "22c2272a95556be637783ebeea174dd3", "checkerName": "google-readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 32, "file": 8, "line": 97}, "message": "default parameter was declared here"}, {"location": {"col": 25, "file": 18, "line": 154}, "message": "calling a function that uses a default argument is disallowed"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/pdns/distributor.hh", "reportHash": "23cffb9d18d0f3a7f6dc0ab1159169ec", "checkerName": "fuchsia-default-arguments", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 39, "file": 3, "line": 509}, "message": "default parameter was declared here"}, {"location": {"col": 39, "file": 18, "line": 154}, "message": "calling a function that uses a default argument is disallowed"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/pdns/distributor.hh", "reportHash": "3283f4c97acd3329fc6330eb728e4582", "checkerName": "fuchsia-default-arguments", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 32, "file": 8, "line": 97}, "message": "default parameter was declared here"}, {"location": {"col": 20, "file": 18, "line": 155}, "message": "calling a function that uses a default argument is disallowed"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/pdns/distributor.hh", "reportHash": "c00ef2d9ba082f0962fb36d69687aafe", "checkerName": "fuchsia-default-arguments", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 39, "file": 3, "line": 509}, "message": "default parameter was declared here"}, {"location": {"col": 34, "file": 18, "line": 155}, "message": "calling a function that uses a default argument is disallowed"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/pdns/distributor.hh", "reportHash": "9c454c46e49cd159b9787d9cb9917f1f", "checkerName": "fuchsia-default-arguments", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 23, "file": 18, "line": 157}, "message": "nullptr (fixit)"}, {"location": {"col": 23, "file": 18, "line": 157}, "message": "use nullptr"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/pdns/distributor.hh", "reportHash": "a1097da3b3df85fe80949f3251b0e7f1", "checkerName": "hicpp-use-nullptr", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 13, "file": 18, "line": 161}, "message": "do not implicitly decay an array into a pointer; consider using gsl::array_view or an explicit cast instead"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/pdns/distributor.hh", "reportHash": "1f57346ace5c4201f20b267eb3794e55", "checkerName": "hicpp-no-array-decay", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 23, "file": 18, "line": 161}, "message": "{ (fixit)"}, {"location": {"col": 22, "file": 18, "line": 161}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/pdns/distributor.hh", "reportHash": "bba8ac2bb837765e8095db59d1313801", "checkerName": "google-readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 39, "file": 3, "line": 509}, "message": "default parameter was declared here"}, {"location": {"col": 15, "file": 18, "line": 162}, "message": "calling a function that uses a default argument is disallowed"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/pdns/distributor.hh", "reportHash": "6b9e42ff86918417e86a7b4f2e9bf7e2", "checkerName": "fuchsia-default-arguments", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 39, "file": 3, "line": 509}, "message": "default parameter was declared here"}, {"location": {"col": 17, "file": 18, "line": 184}, "message": "calling a function that uses a default argument is disallowed"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/pdns/distributor.hh", "reportHash": "57b5ae2993e8f116c51fc10b3733eb63", "checkerName": "fuchsia-default-arguments", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 32, "file": 8, "line": 97}, "message": "default parameter was declared here"}, {"location": {"col": 22, "file": 18, "line": 188}, "message": "calling a function that uses a default argument is disallowed"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/pdns/distributor.hh", "reportHash": "170cb47bd1f576b640b62da52274647f", "checkerName": "fuchsia-default-arguments", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 39, "file": 3, "line": 509}, "message": "default parameter was declared here"}, {"location": {"col": 36, "file": 18, "line": 188}, "message": "calling a function that uses a default argument is disallowed"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/pdns/distributor.hh", "reportHash": "9390c2377fa21e668a94306ab2c3614b", "checkerName": "fuchsia-default-arguments", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 85, "file": 18, "line": 193}, "message": "{ (fixit)"}, {"location": {"col": 84, "file": 18, "line": 193}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/pdns/distributor.hh", "reportHash": "82d19442dd0232cdaa3f9755ff30ce29", "checkerName": "readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 39, "file": 3, "line": 509}, "message": "default parameter was declared here"}, {"location": {"col": 10, "file": 18, "line": 194}, "message": "calling a function that uses a default argument is disallowed"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/pdns/distributor.hh", "reportHash": "ad69d3aea8a401d36c44bd09830d246b", "checkerName": "fuchsia-default-arguments", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 39, "file": 3, "line": 509}, "message": "default parameter was declared here"}, {"location": {"col": 15, "file": 18, "line": 201}, "message": "calling a function that uses a default argument is disallowed"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/pdns/distributor.hh", "reportHash": "413a7c30cd9d0750bdfcbae590f0d6f2", "checkerName": "fuchsia-default-arguments", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 39, "file": 3, "line": 509}, "message": "default parameter was declared here"}, {"location": {"col": 17, "file": 18, "line": 222}, "message": "calling a function that uses a default argument is disallowed"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/pdns/distributor.hh", "reportHash": "ca0533f6d4f8fa662c7ca2a85711090b", "checkerName": "fuchsia-default-arguments", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 84, "file": 18, "line": 232}, "message": "static_cast<long>(  ) (fixit)"}, {"location": {"col": 84, "file": 18, "line": 232}, "message": "C-style casts are discouraged; use static_cast"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/pdns/distributor.hh", "reportHash": "0935948368b417929b8854e7b4828435", "checkerName": "google-readability-casting", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 85, "file": 18, "line": 232}, "message": "consider replacing 'long' with 'int64'"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/pdns/distributor.hh", "reportHash": "f94560c3d597dedec47972dbc127cb6d", "checkerName": "google-runtime-int", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 39, "file": 3, "line": 509}, "message": "default parameter was declared here"}, {"location": {"col": 17, "file": 18, "line": 236}, "message": "calling a function that uses a default argument is disallowed"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/pdns/distributor.hh", "reportHash": "ca0533f6d4f8fa662c7ca2a85711090b", "checkerName": "fuchsia-default-arguments", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 86, "file": 18, "line": 239}, "message": "static_cast<long>(  ) (fixit)"}, {"location": {"col": 86, "file": 18, "line": 239}, "message": "C-style casts are discouraged; use static_cast"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/pdns/distributor.hh", "reportHash": "52366641681cd17578fa498319801292", "checkerName": "google-readability-casting", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 87, "file": 18, "line": 239}, "message": "consider replacing 'long' with 'int64'"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/pdns/distributor.hh", "reportHash": "1ec44d22bacba4914cab64905aef08a6", "checkerName": "google-runtime-int", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 39, "file": 3, "line": 509}, "message": "default parameter was declared here"}, {"location": {"col": 13, "file": 18, "line": 283}, "message": "calling a function that uses a default argument is disallowed"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/pdns/distributor.hh", "reportHash": "549df95604721ace4042ad7f439d3fd7", "checkerName": "fuchsia-default-arguments", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 80, "file": 18, "line": 293}, "message": "static_cast<unsigned long>(  ) (fixit)"}, {"location": {"col": 80, "file": 18, "line": 293}, "message": "C-style casts are discouraged; use static_cast (if needed, the cast may be redundant)"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/pdns/distributor.hh", "reportHash": "20921f9aca0dacb503b15ab7fcd81636", "checkerName": "google-readability-casting", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 81, "file": 18, "line": 293}, "message": "consider replacing 'unsigned long' with 'uint64'"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/pdns/distributor.hh", "reportHash": "ec7ae6301a3ba7c7a8c1bed7597a0869", "checkerName": "google-runtime-int", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 39, "file": 3, "line": 509}, "message": "default parameter was declared here"}, {"location": {"col": 13, "file": 18, "line": 297}, "message": "calling a function that uses a default argument is disallowed"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/pdns/distributor.hh", "reportHash": "549df95604721ace4042ad7f439d3fd7", "checkerName": "fuchsia-default-arguments", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 82, "file": 18, "line": 300}, "message": "static_cast<unsigned long>(  ) (fixit)"}, {"location": {"col": 82, "file": 18, "line": 300}, "message": "C-style casts are discouraged; use static_cast (if needed, the cast may be redundant)"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/pdns/distributor.hh", "reportHash": "23f08388b6109ef6b6e1e3f0017bbdff", "checkerName": "google-readability-casting", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 83, "file": 18, "line": 300}, "message": "consider replacing 'unsigned long' with 'uint64'"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/pdns/distributor.hh", "reportHash": "efe54c12afab3e71de44c08557c0de72", "checkerName": "google-runtime-int", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 3, "file": 18, "line": 313}, "message": "type deduction did not result in an owner"}, {"location": {"col": 3, "file": 18, "line": 313}, "message": "initializing non-owner 'auto' with a newly created 'gsl::owner<>'"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/pdns/distributor.hh", "reportHash": "0d85a591259b65a482bc049024090015", "checkerName": "cppcoreguidelines-owning-memory", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 3, "file": 18, "line": 313}, "message": "variable declared here"}, {"location": {"col": 5, "file": 18, "line": 320}, "message": "deleting a pointer through a type that is not marked 'gsl::owner<>'; consider using a smart pointer instead"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/pdns/distributor.hh", "reportHash": "42b58c67e9cfdd6aa03ce3fcf4fe93ea", "checkerName": "cppcoreguidelines-owning-memory", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 39, "file": 3, "line": 509}, "message": "default parameter was declared here"}, {"location": {"col": 13, "file": 18, "line": 321}, "message": "calling a function that uses a default argument is disallowed"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/pdns/distributor.hh", "reportHash": "346ef3a045d2caf39b410bbc2af41e68", "checkerName": "fuchsia-default-arguments", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 32, "file": 8, "line": 97}, "message": "default parameter was declared here"}, {"location": {"col": 103, "file": 18, "line": 325}, "message": "calling a function that uses a default argument is disallowed"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/pdns/distributor.hh", "reportHash": "41e202c9b393448cb12d8abad42f58ef", "checkerName": "fuchsia-default-arguments", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 39, "file": 3, "line": 509}, "message": "default parameter was declared here"}, {"location": {"col": 117, "file": 18, "line": 325}, "message": "calling a function that uses a default argument is disallowed"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/pdns/distributor.hh", "reportHash": "d324832175d4fbd1044ff0a1ca811659", "checkerName": "fuchsia-default-arguments", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 1, "file": 18, "line": 308}, "message": "type defined here"}, {"location": {"col": 11, "file": 18, "line": 327}, "message": "throwing an exception whose type 'DistributorFatal' is not derived from 'std::exception'"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/pdns/distributor.hh", "reportHash": "b454eba195129efe8d1301641199952a", "checkerName": "hicpp-exception-baseclass", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 25, "file": 23, "line": 118}, "message": "{ (fixit)"}, {"location": {"col": 24, "file": 23, "line": 118}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/pdns/dns.hh", "reportHash": "35717c67f5414b6c389a4bb11b08e84b", "checkerName": "google-readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 1, "file": 25, "line": 1}, "message": "header is missing header guard"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/pdns/dnsbackend.hh", "reportHash": "da9911b21b0c0037f98a474a94ba1660", "checkerName": "llvm-header-guard", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 10, "file": 25, "line": 26}, "message": "\"comment.hh\" (fixit)"}, {"location": {"col": 1, "file": 25, "line": 26}, "message": "#includes are not sorted properly"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/pdns/dnsbackend.hh", "reportHash": "c8921c05a1e380bc2713b789255172f0", "checkerName": "llvm-include-order", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 41, "file": 25, "line": 49}, "message": "nullptr (fixit)"}, {"location": {"col": 41, "file": 25, "line": 49}, "message": "use nullptr"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/pdns/dnsbackend.hh", "reportHash": "a9c455c71e8135d6bc7bac3736fd8a51", "checkerName": "modernize-use-nullptr", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 20, "file": 25, "line": 52}, "message": "{0} (fixit)"}, {"location": {"col": 10, "file": 25, "line": 52}, "message": "use default member initializer for 'last_check'"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/pdns/dnsbackend.hh", "reportHash": "d9ecc4822c5b38c7261e88b537e288a6", "checkerName": "modernize-use-default-member-init", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 14, "file": 25, "line": 57}, "message": "{0} (fixit)"}, {"location": {"col": 12, "file": 25, "line": 57}, "message": "use default member initializer for 'id'"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/pdns/dnsbackend.hh", "reportHash": "c6fc5d75ffc11d241f1e0d7e50e56ec5", "checkerName": "modernize-use-default-member-init", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 27, "file": 25, "line": 58}, "message": "{0} (fixit)"}, {"location": {"col": 12, "file": 25, "line": 58}, "message": "use default member initializer for 'notified_serial'"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/pdns/dnsbackend.hh", "reportHash": "48be7b0634ce5c08f62040f5af47df0d", "checkerName": "modernize-use-default-member-init", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 18, "file": 25, "line": 60}, "message": "{0} (fixit)"}, {"location": {"col": 12, "file": 25, "line": 60}, "message": "use default member initializer for 'serial'"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/pdns/dnsbackend.hh", "reportHash": "7de6a8cb3f9168db39492799d04d7cc3", "checkerName": "modernize-use-default-member-init", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 59, "file": 25, "line": 61}, "message": "{DomainInfo::Native} (fixit)"}, {"location": {"col": 55, "file": 25, "line": 61}, "message": "use default member initializer for 'kind'"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/pdns/dnsbackend.hh", "reportHash": "3f995d407bc8796035fdea94fffe6596", "checkerName": "modernize-use-default-member-init", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 3, "file": 25, "line": 63}, "message": "cannot overload 'operator<'"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/pdns/dnsbackend.hh", "reportHash": "04a5de38b3e5634f1928355a7cfa8735", "checkerName": "fuchsia-overloaded-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 12, "file": 25, "line": 76}, "message": "do not use array subscript when the index is not an integer constant expression; use gsl::at() instead"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/pdns/dnsbackend.hh", "reportHash": "d977e158791fb6729e7fd179a87de58e", "checkerName": "cppcoreguidelines-pro-bounds-constant-array-index", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 39, "file": 3, "line": 509}, "message": "default parameter was declared here"}, {"location": {"col": 26, "file": 25, "line": 81}, "message": "calling a function that uses a default argument is disallowed"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/pdns/dnsbackend.hh", "reportHash": "f21ac5bb6ab1b6652d55588fe91b5385", "checkerName": "fuchsia-default-arguments", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 36, "file": 25, "line": 81}, "message": "{ (fixit)"}, {"location": {"col": 35, "file": 25, "line": 81}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/pdns/dnsbackend.hh", "reportHash": "51728462d379c36216ab5decf99edee1", "checkerName": "google-readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 5, "file": 25, "line": 83}, "message": "do not use 'else' after 'return'"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/pdns/dnsbackend.hh", "reportHash": "6b04728e92c63b23d787b6b63c7c807e", "checkerName": "readability-else-after-return", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 39, "file": 3, "line": 509}, "message": "default parameter was declared here"}, {"location": {"col": 31, "file": 25, "line": 83}, "message": "calling a function that uses a default argument is disallowed"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/pdns/dnsbackend.hh", "reportHash": "2aae7f60a4c63c9c18ecac9ff141885d", "checkerName": "fuchsia-default-arguments", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 42, "file": 25, "line": 83}, "message": "{ (fixit)"}, {"location": {"col": 41, "file": 25, "line": 83}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/pdns/dnsbackend.hh", "reportHash": "91a9e50658c1441571ce9322360b00cc", "checkerName": "readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 10, "file": 25, "line": 85}, "message": "{ (fixit)"}, {"location": {"col": 9, "file": 25, "line": 85}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/pdns/dnsbackend.hh", "reportHash": "4e6c1587265445cd20760e6a67271b57", "checkerName": "hicpp-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 56, "file": 25, "line": 92}, "message": "{ (fixit)"}, {"location": {"col": 55, "file": 25, "line": 92}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/pdns/dnsbackend.hh", "reportHash": "6985775669f54907544de7bf98569d33", "checkerName": "google-readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 7, "file": 25, "line": 119}, "message": "class 'DNSBackend' defines a non-default destructor but does not define a copy constructor, a copy assignment operator, a move constructor or a move assignment operator"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/pdns/dnsbackend.hh", "reportHash": "d6ea7634056016b42a1716fb59299686", "checkerName": "cppcoreguidelines-special-member-functions", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 16, "file": 25, "line": 123}, "message": "default arguments on virtual or override methods are prohibited"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/pdns/dnsbackend.hh", "reportHash": "808c028af40bb54baf12f3341000a64f", "checkerName": "google-default-arguments", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 67, "file": 25, "line": 123}, "message": "declaring a parameter with a default argument is disallowed"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/pdns/dnsbackend.hh", "reportHash": "6e5db6c446d3bd80f94b5ee1d04fc48b", "checkerName": "fuchsia-default-arguments", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 82, "file": 25, "line": 123}, "message": "declaring a parameter with a default argument is disallowed"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/pdns/dnsbackend.hh", "reportHash": "b9e38efd7409601975e0056d2ac85eff", "checkerName": "fuchsia-default-arguments", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 39, "file": 25, "line": 124}, "message": "non-const reference parameter at index 0, make it const or use a pointer"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/pdns/dnsbackend.hh", "reportHash": "189c8df7cf96ffb98b6dea77a483e18d", "checkerName": "google-runtime-references", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 35, "file": 25, "line": 125}, "message": "non-const reference parameter 'r', make it const or use a pointer"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/pdns/dnsbackend.hh", "reportHash": "7e5828037a6438870a0d251ee46e51e8", "checkerName": "google-runtime-references", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 16, "file": 25, "line": 132}, "message": "default arguments on virtual or override methods are prohibited"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/pdns/dnsbackend.hh", "reportHash": "1d74b86128e8d9d2219c94d77b604c6c", "checkerName": "google-default-arguments", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 59, "file": 25, "line": 132}, "message": "declaring a parameter with a default argument is disallowed"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/pdns/dnsbackend.hh", "reportHash": "86fc22e2a75a2fffb7483d7a51ebc237", "checkerName": "fuchsia-default-arguments", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 24, "file": 25, "line": 134}, "message": "= default; (fixit)"}, {"location": {"col": 11, "file": 25, "line": 134}, "message": "use '= default' to define a trivial destructor"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/pdns/dnsbackend.hh", "reportHash": "64b7a99114c3c5306b28f51ec0a1447e", "checkerName": "hicpp-use-equals-default", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 53, "file": 25, "line": 137}, "message": "non-const reference parameter 'soadata', make it const or use a pointer"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/pdns/dnsbackend.hh", "reportHash": "feb6688178d645674e0b8a16bdb7f400", "checkerName": "google-runtime-references", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 39, "file": 25, "line": 139}, "message": "/*domain_id*/ (fixit)"}, {"location": {"col": 38, "file": 25, "line": 139}, "message": "parameter 'domain_id' is unused"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/pdns/dnsbackend.hh", "reportHash": "bccc6ebacfbe50abc809ef044e38915c", "checkerName": "misc-unused-parameters", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 65, "file": 25, "line": 139}, "message": "/*qname*/ (fixit)"}, {"location": {"col": 64, "file": 25, "line": 139}, "message": "parameter 'qname' is unused"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/pdns/dnsbackend.hh", "reportHash": "b9fc5f0dcca6a312319f3cd0b313d000", "checkerName": "misc-unused-parameters", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 85, "file": 25, "line": 139}, "message": "/*qt*/ (fixit)"}, {"location": {"col": 84, "file": 25, "line": 139}, "message": "parameter 'qt' is unused"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/pdns/dnsbackend.hh", "reportHash": "f864eae2ac6d6fb45b77a5e6a6a867a0", "checkerName": "misc-unused-parameters", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 122, "file": 25, "line": 139}, "message": "/*rrset*/ (fixit)"}, {"location": {"col": 121, "file": 25, "line": 139}, "message": "parameter 'rrset' is unused"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/pdns/dnsbackend.hh", "reportHash": "9ef34d6d1361d91f0564c6a0b554a6ec", "checkerName": "misc-unused-parameters", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 44, "file": 25, "line": 144}, "message": "/*zone*/ (fixit)"}, {"location": {"col": 43, "file": 25, "line": 144}, "message": "parameter 'zone' is unused"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/pdns/dnsbackend.hh", "reportHash": "7b860d7723cc887b05b5f3823406cf23", "checkerName": "misc-unused-parameters", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 54, "file": 25, "line": 144}, "message": "/*domain_id*/ (fixit)"}, {"location": {"col": 53, "file": 25, "line": 144}, "message": "parameter 'domain_id' is unused"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/pdns/dnsbackend.hh", "reportHash": "52993feb465daba7d846a535510e2526", "checkerName": "misc-unused-parameters", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 53, "file": 25, "line": 153}, "message": "/*name*/ (fixit)"}, {"location": {"col": 52, "file": 25, "line": 153}, "message": "parameter 'name' is unused"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/pdns/dnsbackend.hh", "reportHash": "56832535b4bd727fd1b22369906c8e1d", "checkerName": "misc-unused-parameters", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 108, "file": 25, "line": 153}, "message": "non-const reference parameter 'meta', make it const or use a pointer"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/pdns/dnsbackend.hh", "reportHash": "f8453dafd253b9f77b22e81f6a39543d", "checkerName": "google-runtime-references", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 109, "file": 25, "line": 153}, "message": "/*meta*/ (fixit)"}, {"location": {"col": 108, "file": 25, "line": 153}, "message": "parameter 'meta' is unused"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/pdns/dnsbackend.hh", "reportHash": "f19e8cad90ffcd3ea9e57d1d3ca24818", "checkerName": "misc-unused-parameters", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 50, "file": 25, "line": 154}, "message": "/*name*/ (fixit)"}, {"location": {"col": 49, "file": 25, "line": 154}, "message": "parameter 'name' is unused"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/pdns/dnsbackend.hh", "reportHash": "cc0b824a718a70ae165b37cde16e6f35", "checkerName": "misc-unused-parameters", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 75, "file": 25, "line": 154}, "message": "/*kind*/ (fixit)"}, {"location": {"col": 74, "file": 25, "line": 154}, "message": "parameter 'kind' is unused"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/pdns/dnsbackend.hh", "reportHash": "1b6749092dd4e616648e61fa86c7657d", "checkerName": "misc-unused-parameters", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 106, "file": 25, "line": 154}, "message": "non-const reference parameter 'meta', make it const or use a pointer"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/pdns/dnsbackend.hh", "reportHash": "8434dc0562515ef0013b3dba0ded6cbd", "checkerName": "google-runtime-references", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 107, "file": 25, "line": 154}, "message": "/*meta*/ (fixit)"}, {"location": {"col": 106, "file": 25, "line": 154}, "message": "parameter 'meta' is unused"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/pdns/dnsbackend.hh", "reportHash": "b6ddcc75fd2c22d3ad9d038e19226650", "checkerName": "misc-unused-parameters", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 96, "file": 25, "line": 155}, "message": "non-const reference parameter 'value', make it const or use a pointer"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/pdns/dnsbackend.hh", "reportHash": "8f8c1bc96e052dea144b15157005c7cd", "checkerName": "google-runtime-references", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 50, "file": 25, "line": 167}, "message": "/*name*/ (fixit)"}, {"location": {"col": 49, "file": 25, "line": 167}, "message": "parameter 'name' is unused"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/pdns/dnsbackend.hh", "reportHash": "69d4d2e38e5578636f3057bc04fdf904", "checkerName": "misc-unused-parameters", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 75, "file": 25, "line": 167}, "message": "/*kind*/ (fixit)"}, {"location": {"col": 74, "file": 25, "line": 167}, "message": "parameter 'kind' is unused"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/pdns/dnsbackend.hh", "reportHash": "0b22f26981dee4fc9464f4679f8e60ed", "checkerName": "misc-unused-parameters", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 113, "file": 25, "line": 167}, "message": "/*meta*/ (fixit)"}, {"location": {"col": 112, "file": 25, "line": 167}, "message": "parameter 'meta' is unused"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/pdns/dnsbackend.hh", "reportHash": "4891de042a655e66f7dc1e044c834c67", "checkerName": "misc-unused-parameters", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 7, "file": 26, "line": 296}, "message": "default parameter was declared here"}, {"location": {"col": 36, "file": 25, "line": 170}, "message": "calling a function that uses a default argument is disallowed"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/pdns/dnsbackend.hh", "reportHash": "a270010bf9fdae9cc8dbecda08024741", "checkerName": "fuchsia-default-arguments", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 16, "file": 25, "line": 175}, "message": "default arguments on virtual or override methods are prohibited"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/pdns/dnsbackend.hh", "reportHash": "e101957d08580e466af727d994cc6ee6", "checkerName": "google-default-arguments", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 51, "file": 25, "line": 175}, "message": "/*domains*/ (fixit)"}, {"location": {"col": 50, "file": 25, "line": 175}, "message": "parameter 'domains' is unused"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/pdns/dnsbackend.hh", "reportHash": "e08172ef3d185735b071f2956f28470a", "checkerName": "misc-unused-parameters", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 59, "file": 25, "line": 175}, "message": "declaring a parameter with a default argument is disallowed"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/pdns/dnsbackend.hh", "reportHash": "494342ea2de3bceb32bb7fec16fd77ca", "checkerName": "fuchsia-default-arguments", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 65, "file": 25, "line": 175}, "message": "/*include_disabled*/ (fixit)"}, {"location": {"col": 64, "file": 25, "line": 175}, "message": "parameter 'include_disabled' is unused"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/pdns/dnsbackend.hh", "reportHash": "cf8c09d31634bd3a17926da6199e7a04", "checkerName": "misc-unused-parameters", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 46, "file": 25, "line": 188}, "message": "/*name*/ (fixit)"}, {"location": {"col": 45, "file": 25, "line": 188}, "message": "parameter 'name' is unused"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/pdns/dnsbackend.hh", "reportHash": "959cfc8ccd644d4eb0b6b0b4b0e1d7be", "checkerName": "misc-unused-parameters", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 73, "file": 25, "line": 188}, "message": "non-const reference parameter 'keys', make it const or use a pointer"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/pdns/dnsbackend.hh", "reportHash": "61d5031137fadb28c417a56c161ffcab", "checkerName": "google-runtime-references", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 74, "file": 25, "line": 188}, "message": "/*keys*/ (fixit)"}, {"location": {"col": 73, "file": 25, "line": 188}, "message": "parameter 'keys' is unused"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/pdns/dnsbackend.hh", "reportHash": "f2ddc1d6e170cd4bf0fd5b6f5c25c805", "checkerName": "misc-unused-parameters", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 48, "file": 25, "line": 189}, "message": "/*name*/ (fixit)"}, {"location": {"col": 47, "file": 25, "line": 189}, "message": "parameter 'name' is unused"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/pdns/dnsbackend.hh", "reportHash": "e891114366936cd602e226bb36f8d6fa", "checkerName": "misc-unused-parameters", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 67, "file": 25, "line": 189}, "message": "/*id*/ (fixit)"}, {"location": {"col": 66, "file": 25, "line": 189}, "message": "parameter 'id' is unused"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/pdns/dnsbackend.hh", "reportHash": "833098be54763ce3ad1c9719e6d23e03", "checkerName": "misc-unused-parameters", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 45, "file": 25, "line": 190}, "message": "/*name*/ (fixit)"}, {"location": {"col": 44, "file": 25, "line": 190}, "message": "parameter 'name' is unused"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/pdns/dnsbackend.hh", "reportHash": "8fa3cc53be543c2cc496a3e3412146ca", "checkerName": "misc-unused-parameters", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 66, "file": 25, "line": 190}, "message": "/*key*/ (fixit)"}, {"location": {"col": 65, "file": 25, "line": 190}, "message": "parameter 'key' is unused"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/pdns/dnsbackend.hh", "reportHash": "b9999ad323ac789d7d44eeaf33edf97f", "checkerName": "misc-unused-parameters", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 79, "file": 25, "line": 190}, "message": "non-const reference parameter 'id', make it const or use a pointer"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/pdns/dnsbackend.hh", "reportHash": "5d6e02e73ca48765e2458245f67136b8", "checkerName": "google-runtime-references", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 80, "file": 25, "line": 190}, "message": "/*id*/ (fixit)"}, {"location": {"col": 79, "file": 25, "line": 190}, "message": "parameter 'id' is unused"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/pdns/dnsbackend.hh", "reportHash": "b86a51374aa81489473c8d49a1224a72", "checkerName": "misc-unused-parameters", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 50, "file": 25, "line": 191}, "message": "/*name*/ (fixit)"}, {"location": {"col": 49, "file": 25, "line": 191}, "message": "parameter 'name' is unused"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/pdns/dnsbackend.hh", "reportHash": "17fd624335c2bfc8595bd7f08f8bb135", "checkerName": "misc-unused-parameters", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 69, "file": 25, "line": 191}, "message": "/*id*/ (fixit)"}, {"location": {"col": 68, "file": 25, "line": 191}, "message": "parameter 'id' is unused"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/pdns/dnsbackend.hh", "reportHash": "40ef67bdc11cbe3c324af59264a9df72", "checkerName": "misc-unused-parameters", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 52, "file": 25, "line": 192}, "message": "/*name*/ (fixit)"}, {"location": {"col": 51, "file": 25, "line": 192}, "message": "parameter 'name' is unused"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/pdns/dnsbackend.hh", "reportHash": "d4e9bcd2166946253c993e6ff837261a", "checkerName": "misc-unused-parameters", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 71, "file": 25, "line": 192}, "message": "/*id*/ (fixit)"}, {"location": {"col": 70, "file": 25, "line": 192}, "message": "parameter 'id' is unused"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/pdns/dnsbackend.hh", "reportHash": "e6543bf02da4cb6d335ab2899c3bda7e", "checkerName": "misc-unused-parameters", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 49, "file": 25, "line": 193}, "message": "/*name*/ (fixit)"}, {"location": {"col": 48, "file": 25, "line": 193}, "message": "parameter 'name' is unused"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/pdns/dnsbackend.hh", "reportHash": "b8636d9625314dd5b0413b993a9f6299", "checkerName": "misc-unused-parameters", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 68, "file": 25, "line": 193}, "message": "/*id*/ (fixit)"}, {"location": {"col": 67, "file": 25, "line": 193}, "message": "parameter 'id' is unused"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/pdns/dnsbackend.hh", "reportHash": "12f622fa6b48da6595180f0bb0649ea6", "checkerName": "misc-unused-parameters", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 51, "file": 25, "line": 194}, "message": "/*name*/ (fixit)"}, {"location": {"col": 50, "file": 25, "line": 194}, "message": "parameter 'name' is unused"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/pdns/dnsbackend.hh", "reportHash": "e5576fd041b6d9602916ac218ceca9c3", "checkerName": "misc-unused-parameters", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 70, "file": 25, "line": 194}, "message": "/*id*/ (fixit)"}, {"location": {"col": 69, "file": 25, "line": 194}, "message": "parameter 'id' is unused"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/pdns/dnsbackend.hh", "reportHash": "2a8dab394477b98d2993c94fc3dfc5a2", "checkerName": "misc-unused-parameters", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 43, "file": 25, "line": 196}, "message": "/*name*/ (fixit)"}, {"location": {"col": 42, "file": 25, "line": 196}, "message": "parameter 'name' is unused"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/pdns/dnsbackend.hh", "reportHash": "bac2a6a13fdbfdc07420173dc26ce40a", "checkerName": "misc-unused-parameters", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 58, "file": 25, "line": 196}, "message": "/*algorithm*/ (fixit)"}, {"location": {"col": 57, "file": 25, "line": 196}, "message": "parameter 'algorithm' is unused"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/pdns/dnsbackend.hh", "reportHash": "bcc0155fa16c28cc3b6c9b088600ef72", "checkerName": "misc-unused-parameters", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 77, "file": 25, "line": 196}, "message": "/*content*/ (fixit)"}, {"location": {"col": 76, "file": 25, "line": 196}, "message": "parameter 'content' is unused"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/pdns/dnsbackend.hh", "reportHash": "82c0a0ef7dc546b247fea26d618e8122", "checkerName": "misc-unused-parameters", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 43, "file": 25, "line": 197}, "message": "/*name*/ (fixit)"}, {"location": {"col": 42, "file": 25, "line": 197}, "message": "parameter 'name' is unused"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/pdns/dnsbackend.hh", "reportHash": "3753cc9768ca8f4998090806fd49fd93", "checkerName": "misc-unused-parameters", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 64, "file": 25, "line": 197}, "message": "/*algorithm*/ (fixit)"}, {"location": {"col": 63, "file": 25, "line": 197}, "message": "parameter 'algorithm' is unused"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/pdns/dnsbackend.hh", "reportHash": "fd042810430506238b2bcb883c0d751b", "checkerName": "misc-unused-parameters", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 89, "file": 25, "line": 197}, "message": "/*content*/ (fixit)"}, {"location": {"col": 88, "file": 25, "line": 197}, "message": "parameter 'content' is unused"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/pdns/dnsbackend.hh", "reportHash": "49b8495e9cd9462b335c403fced91418", "checkerName": "misc-unused-parameters", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 46, "file": 25, "line": 198}, "message": "/*name*/ (fixit)"}, {"location": {"col": 45, "file": 25, "line": 198}, "message": "parameter 'name' is unused"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/pdns/dnsbackend.hh", "reportHash": "4a7457e6165a2b17b4735563dddafe12", "checkerName": "misc-unused-parameters", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 59, "file": 25, "line": 199}, "message": "non-const reference parameter 'keys', make it const or use a pointer"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/pdns/dnsbackend.hh", "reportHash": "9e50cfa83c14c126846a1a8d04656534", "checkerName": "google-runtime-references", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 60, "file": 25, "line": 199}, "message": "/*keys*/ (fixit)"}, {"location": {"col": 59, "file": 25, "line": 199}, "message": "parameter 'keys' is unused"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/pdns/dnsbackend.hh", "reportHash": "fbb5d326ff15a32f830aa4ba6c8c14e0", "checkerName": "misc-unused-parameters", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 57, "file": 25, "line": 201}, "message": "/*id*/ (fixit)"}, {"location": {"col": 56, "file": 25, "line": 201}, "message": "parameter 'id' is unused"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/pdns/dnsbackend.hh", "reportHash": "d3cce9f3276ef9ec4ded2166726671e9", "checkerName": "misc-unused-parameters", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 76, "file": 25, "line": 201}, "message": "/*qname*/ (fixit)"}, {"location": {"col": 75, "file": 25, "line": 201}, "message": "parameter 'qname' is unused"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/pdns/dnsbackend.hh", "reportHash": "4d96346dad12e54040a1c04b0c2f17ba", "checkerName": "misc-unused-parameters", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 91, "file": 25, "line": 201}, "message": "non-const reference parameter 'unhashed', make it const or use a pointer"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/pdns/dnsbackend.hh", "reportHash": "88c68666ab91888feb96bfa2c5e7d09f", "checkerName": "google-runtime-references", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 92, "file": 25, "line": 201}, "message": "/*unhashed*/ (fixit)"}, {"location": {"col": 91, "file": 25, "line": 201}, "message": "parameter 'unhashed' is unused"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/pdns/dnsbackend.hh", "reportHash": "82c147f0eff2068308525b4c8c7f196b", "checkerName": "misc-unused-parameters", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 110, "file": 25, "line": 201}, "message": "non-const reference parameter 'before', make it const or use a pointer"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/pdns/dnsbackend.hh", "reportHash": "de1998056753689c8d5f58b54e5e6bc2", "checkerName": "google-runtime-references", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 111, "file": 25, "line": 201}, "message": "/*before*/ (fixit)"}, {"location": {"col": 110, "file": 25, "line": 201}, "message": "parameter 'before' is unused"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/pdns/dnsbackend.hh", "reportHash": "22232afdffd63819ba5791b5e60b3f01", "checkerName": "misc-unused-parameters", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 127, "file": 25, "line": 201}, "message": "non-const reference parameter 'after', make it const or use a pointer"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/pdns/dnsbackend.hh", "reportHash": "8eafd049da4b986d091344f9b283710d", "checkerName": "google-runtime-references", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 128, "file": 25, "line": 201}, "message": "/*after*/ (fixit)"}, {"location": {"col": 127, "file": 25, "line": 201}, "message": "parameter 'after' is unused"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/pdns/dnsbackend.hh", "reportHash": "8ec6d91974583912a659b431e72ea68f", "checkerName": "misc-unused-parameters", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 108, "file": 25, "line": 208}, "message": "non-const reference parameter 'before', make it const or use a pointer"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/pdns/dnsbackend.hh", "reportHash": "9ccb148bce402cef3174f0e1520b445e", "checkerName": "google-runtime-references", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 125, "file": 25, "line": 208}, "message": "non-const reference parameter 'after', make it const or use a pointer"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/pdns/dnsbackend.hh", "reportHash": "f7460cb0bbd5314e6e390f80d9467ac9", "checkerName": "google-runtime-references", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 16, "file": 25, "line": 210}, "message": "default arguments on virtual or override methods are prohibited"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/pdns/dnsbackend.hh", "reportHash": "f92a2694c6eac75db935ab9a1778da19", "checkerName": "google-default-arguments", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 55, "file": 25, "line": 210}, "message": "/*domain_id*/ (fixit)"}, {"location": {"col": 54, "file": 25, "line": 210}, "message": "parameter 'domain_id' is unused"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/pdns/dnsbackend.hh", "reportHash": "967903eebe6200d5a42847751480a0b2", "checkerName": "misc-unused-parameters", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 81, "file": 25, "line": 210}, "message": "/*qname*/ (fixit)"}, {"location": {"col": 80, "file": 25, "line": 210}, "message": "parameter 'qname' is unused"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/pdns/dnsbackend.hh", "reportHash": "a8dc63950d10e8330d856a4857bfae22", "checkerName": "misc-unused-parameters", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 103, "file": 25, "line": 210}, "message": "/*ordername*/ (fixit)"}, {"location": {"col": 102, "file": 25, "line": 210}, "message": "parameter 'ordername' is unused"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/pdns/dnsbackend.hh", "reportHash": "dc1f38dcba82e1731bece9aef799dd5e", "checkerName": "misc-unused-parameters", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 119, "file": 25, "line": 210}, "message": "/*auth*/ (fixit)"}, {"location": {"col": 118, "file": 25, "line": 210}, "message": "parameter 'auth' is unused"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/pdns/dnsbackend.hh", "reportHash": "a9eb4efead2f2d7b96cfb249a5218152", "checkerName": "misc-unused-parameters", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 124, "file": 25, "line": 210}, "message": "declaring a parameter with a default argument is disallowed"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/pdns/dnsbackend.hh", "reportHash": "6a9014c1b8433acce5eacc9fe5475dd0", "checkerName": "fuchsia-default-arguments", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 140, "file": 25, "line": 210}, "message": "/*qtype*/ (fixit)"}, {"location": {"col": 139, "file": 25, "line": 210}, "message": "parameter 'qtype' is unused"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/pdns/dnsbackend.hh", "reportHash": "f5b010a0c450588c3b60a9336ef285fb", "checkerName": "misc-unused-parameters", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 50, "file": 25, "line": 215}, "message": "/*domain_id*/ (fixit)"}, {"location": {"col": 49, "file": 25, "line": 215}, "message": "parameter 'domain_id' is unused"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/pdns/dnsbackend.hh", "reportHash": "6febed1858d7e3c697c4c0c3a1788857", "checkerName": "misc-unused-parameters", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 74, "file": 25, "line": 215}, "message": "non-const reference parameter 'insert', make it const or use a pointer"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/pdns/dnsbackend.hh", "reportHash": "9034118082d6a4a9e04a78b80e4a4eb3", "checkerName": "google-runtime-references", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 75, "file": 25, "line": 215}, "message": "/*insert*/ (fixit)"}, {"location": {"col": 74, "file": 25, "line": 215}, "message": "parameter 'insert' is unused"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/pdns/dnsbackend.hh", "reportHash": "45b0c33afb49b3314169707a8ff41581", "checkerName": "misc-unused-parameters", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 96, "file": 25, "line": 215}, "message": "non-const reference parameter 'erase', make it const or use a pointer"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/pdns/dnsbackend.hh", "reportHash": "9ae248e8b333e98b8c3e20cda8dc0209", "checkerName": "google-runtime-references", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 97, "file": 25, "line": 215}, "message": "/*erase*/ (fixit)"}, {"location": {"col": 96, "file": 25, "line": 215}, "message": "parameter 'erase' is unused"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/pdns/dnsbackend.hh", "reportHash": "0e9580c7e7ebc8b244d275f8142a58cc", "checkerName": "misc-unused-parameters", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 109, "file": 25, "line": 215}, "message": "/*remove*/ (fixit)"}, {"location": {"col": 108, "file": 25, "line": 215}, "message": "parameter 'remove' is unused"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/pdns/dnsbackend.hh", "reportHash": "41de0b1896b98762a5c0a662ded8234c", "checkerName": "misc-unused-parameters", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 39, "file": 25, "line": 228}, "message": "/*domain_id*/ (fixit)"}, {"location": {"col": 38, "file": 25, "line": 228}, "message": "parameter 'domain_id' is unused"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/pdns/dnsbackend.hh", "reportHash": "8c22b9f50d644fc2bc31cb81652fd4f1", "checkerName": "misc-unused-parameters", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 36, "file": 25, "line": 233}, "message": "non-const reference parameter 'comment', make it const or use a pointer"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/pdns/dnsbackend.hh", "reportHash": "f224858572efe58c114c315cd8713c1a", "checkerName": "google-runtime-references", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 37, "file": 25, "line": 233}, "message": "/*comment*/ (fixit)"}, {"location": {"col": 36, "file": 25, "line": 233}, "message": "parameter 'comment' is unused"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/pdns/dnsbackend.hh", "reportHash": "bec967cf4dfbafac670935c8829f22aa", "checkerName": "misc-unused-parameters", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 44, "file": 25, "line": 238}, "message": "/*comment*/ (fixit)"}, {"location": {"col": 43, "file": 25, "line": 238}, "message": "parameter 'comment' is unused"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/pdns/dnsbackend.hh", "reportHash": "6861511dd543a29dc61029521b4c58d4", "checkerName": "misc-unused-parameters", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 48, "file": 25, "line": 242}, "message": "/*domain_id*/ (fixit)"}, {"location": {"col": 47, "file": 25, "line": 242}, "message": "parameter 'domain_id' is unused"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/pdns/dnsbackend.hh", "reportHash": "c2c568c0bfa824aab1e663cc8419e4fa", "checkerName": "misc-unused-parameters", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 74, "file": 25, "line": 242}, "message": "/*qname*/ (fixit)"}, {"location": {"col": 73, "file": 25, "line": 242}, "message": "parameter 'qname' is unused"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/pdns/dnsbackend.hh", "reportHash": "6ddb7593e32cd61d18148ea017a0959f", "checkerName": "misc-unused-parameters", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 94, "file": 25, "line": 242}, "message": "/*qt*/ (fixit)"}, {"location": {"col": 93, "file": 25, "line": 242}, "message": "parameter 'qt' is unused"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/pdns/dnsbackend.hh", "reportHash": "b12eabd783218ae647637d6d4ed34838", "checkerName": "misc-unused-parameters", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 121, "file": 25, "line": 242}, "message": "/*comments*/ (fixit)"}, {"location": {"col": 120, "file": 25, "line": 242}, "message": "parameter 'comments' is unused"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/pdns/dnsbackend.hh", "reportHash": "6da71ee375bbcc99768e09f9177e95b1", "checkerName": "misc-unused-parameters", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 16, "file": 25, "line": 249}, "message": "default arguments on virtual or override methods are prohibited"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/pdns/dnsbackend.hh", "reportHash": "a999179fda1e469263c497470920e780", "checkerName": "google-default-arguments", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 49, "file": 25, "line": 249}, "message": "/*qname*/ (fixit)"}, {"location": {"col": 48, "file": 25, "line": 249}, "message": "parameter 'qname' is unused"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/pdns/dnsbackend.hh", "reportHash": "b630fffae8dbc19b8379f81eca337343", "checkerName": "misc-unused-parameters", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 55, "file": 25, "line": 249}, "message": "declaring a parameter with a default argument is disallowed"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/pdns/dnsbackend.hh", "reportHash": "8dfe619b5e1b7d76b5a48e3cf9eeb4f6", "checkerName": "fuchsia-default-arguments", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 60, "file": 25, "line": 249}, "message": "/*id*/ (fixit)"}, {"location": {"col": 59, "file": 25, "line": 249}, "message": "parameter 'id' is unused"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/pdns/dnsbackend.hh", "reportHash": "a86dbeac87855fac506abf8df53cec6e", "checkerName": "misc-unused-parameters", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 16, "file": 25, "line": 270}, "message": "default arguments on virtual or override methods are prohibited"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/pdns/dnsbackend.hh", "reportHash": "817cfa2573c8bb7ea6b3f9642445b5e3", "checkerName": "google-default-arguments", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 27, "file": 25, "line": 270}, "message": "declaring a parameter with a default argument is disallowed"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/pdns/dnsbackend.hh", "reportHash": "5117366d5d6c5243c075d33a784cb4f2", "checkerName": "fuchsia-default-arguments", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 36, "file": 25, "line": 270}, "message": "/*status*/ (fixit)"}, {"location": {"col": 35, "file": 25, "line": 270}, "message": "parameter 'status' is unused"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/pdns/dnsbackend.hh", "reportHash": "e6b27f5db313a43abebb094ac5cff089", "checkerName": "misc-unused-parameters", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 1, "file": 25, "line": 270}, "message": "note: this fix will not be applied because it overlaps with another fix (fixit)"}, {"location": {"col": 42, "file": 25, "line": 270}, "message": "use nullptr"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/pdns/dnsbackend.hh", "reportHash": "20201699b8a352a56c89ebf04dd63fa1", "checkerName": "hicpp-use-nullptr", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 16, "file": 25, "line": 275}, "message": "default arguments on virtual or override methods are prohibited"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/pdns/dnsbackend.hh", "reportHash": "ff662c4903925c7f8967e156682eaded", "checkerName": "google-default-arguments", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 53, "file": 25, "line": 275}, "message": "/*rr*/ (fixit)"}, {"location": {"col": 52, "file": 25, "line": 275}, "message": "parameter 'rr' is unused"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/pdns/dnsbackend.hh", "reportHash": "fb32ff33daab1d638d107e9325853abf", "checkerName": "misc-unused-parameters", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 72, "file": 25, "line": 275}, "message": "/*ordername*/ (fixit)"}, {"location": {"col": 71, "file": 25, "line": 275}, "message": "parameter 'ordername' is unused"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/pdns/dnsbackend.hh", "reportHash": "8d06e71929ef352be0f2b94c2c8a1cc1", "checkerName": "misc-unused-parameters", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 82, "file": 25, "line": 275}, "message": "declaring a parameter with a default argument is disallowed"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/pdns/dnsbackend.hh", "reportHash": "a88a5e79523f1c01fc734a823b3d0429", "checkerName": "fuchsia-default-arguments", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 88, "file": 25, "line": 275}, "message": "/*ordernameIsNSEC3*/ (fixit)"}, {"location": {"col": 87, "file": 25, "line": 275}, "message": "parameter 'ordernameIsNSEC3' is unused"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/pdns/dnsbackend.hh", "reportHash": "4ebdcf7add425c3694004877450bc017", "checkerName": "misc-unused-parameters", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 30, "file": 25, "line": 279}, "message": "/*domain_id*/ (fixit)"}, {"location": {"col": 29, "file": 25, "line": 279}, "message": "parameter 'domain_id' is unused"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/pdns/dnsbackend.hh", "reportHash": "a3df586cc4c894bba6b99999adc7b614", "checkerName": "misc-unused-parameters", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 59, "file": 25, "line": 279}, "message": "non-const reference parameter 'nonterm', make it const or use a pointer"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/pdns/dnsbackend.hh", "reportHash": "f28ba254f2b2370bc5cc4aa51906cf47", "checkerName": "google-runtime-references", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 60, "file": 25, "line": 279}, "message": "/*nonterm*/ (fixit)"}, {"location": {"col": 59, "file": 25, "line": 279}, "message": "parameter 'nonterm' is unused"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/pdns/dnsbackend.hh", "reportHash": "a0e75ef787da0e183340410a04d8dc38", "checkerName": "misc-unused-parameters", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 31, "file": 25, "line": 283}, "message": "/*domain_id*/ (fixit)"}, {"location": {"col": 30, "file": 25, "line": 283}, "message": "parameter 'domain_id' is unused"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/pdns/dnsbackend.hh", "reportHash": "7454d5e7be190765074df3a5721d1ae3", "checkerName": "misc-unused-parameters", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 57, "file": 25, "line": 283}, "message": "/*domain*/ (fixit)"}, {"location": {"col": 56, "file": 25, "line": 283}, "message": "parameter 'domain' is unused"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/pdns/dnsbackend.hh", "reportHash": "da3043c8cf25dd2d4376dda48c029cf2", "checkerName": "misc-unused-parameters", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 83, "file": 25, "line": 283}, "message": "non-const reference parameter 'nonterm', make it const or use a pointer"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/pdns/dnsbackend.hh", "reportHash": "9660c7ea6121d58028854098f5dddc74", "checkerName": "google-runtime-references", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 84, "file": 25, "line": 283}, "message": "/*nonterm*/ (fixit)"}, {"location": {"col": 83, "file": 25, "line": 283}, "message": "parameter 'nonterm' is unused"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/pdns/dnsbackend.hh", "reportHash": "1bf12086038e4acb52ad82280beb6b9c", "checkerName": "misc-unused-parameters", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 124, "file": 25, "line": 283}, "message": "/*ns3prc*/ (fixit)"}, {"location": {"col": 123, "file": 25, "line": 283}, "message": "parameter 'ns3prc' is unused"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/pdns/dnsbackend.hh", "reportHash": "06d822b9d37eeabe2ebbbd2bdeabd2a9", "checkerName": "misc-unused-parameters", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 137, "file": 25, "line": 283}, "message": "/*narrow*/ (fixit)"}, {"location": {"col": 136, "file": 25, "line": 283}, "message": "parameter 'narrow' is unused"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/pdns/dnsbackend.hh", "reportHash": "11dc03825699ba90d515f35600a5c3a6", "checkerName": "misc-unused-parameters", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 16, "file": 25, "line": 289}, "message": "default arguments on virtual or override methods are prohibited"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/pdns/dnsbackend.hh", "reportHash": "2395507b4c3c1e7e375b0655f60b1e50", "checkerName": "google-default-arguments", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 46, "file": 25, "line": 289}, "message": "/*domain*/ (fixit)"}, {"location": {"col": 45, "file": 25, "line": 289}, "message": "parameter 'domain' is unused"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/pdns/dnsbackend.hh", "reportHash": "6151d40e12109d2a978db1e837f9c216", "checkerName": "misc-unused-parameters", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 65, "file": 25, "line": 289}, "message": "non-const reference parameter 'di', make it const or use a pointer"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/pdns/dnsbackend.hh", "reportHash": "3ed4d7cc038631be45426030edcff983", "checkerName": "google-runtime-references", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 66, "file": 25, "line": 289}, "message": "/*di*/ (fixit)"}, {"location": {"col": 65, "file": 25, "line": 289}, "message": "parameter 'di' is unused"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/pdns/dnsbackend.hh", "reportHash": "d91656e43712e9a8bc691084a758184f", "checkerName": "misc-unused-parameters", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 69, "file": 25, "line": 289}, "message": "declaring a parameter with a default argument is disallowed"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/pdns/dnsbackend.hh", "reportHash": "1a78a7cc072114dc78ca07140cdb7166", "checkerName": "fuchsia-default-arguments", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 75, "file": 25, "line": 289}, "message": "/*getSerial*/ (fixit)"}, {"location": {"col": 74, "file": 25, "line": 289}, "message": "parameter 'getSerial' is unused"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/pdns/dnsbackend.hh", "reportHash": "061aa5bbd5c937f8890b6bb786de6d3e", "checkerName": "misc-unused-parameters", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 58, "file": 25, "line": 294}, "message": "/*domains*/ (fixit)"}, {"location": {"col": 57, "file": 25, "line": 294}, "message": "parameter 'domains' is unused"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/pdns/dnsbackend.hh", "reportHash": "f35d8bbaabbe569d7b63e7fbae5c5f19", "checkerName": "misc-unused-parameters", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 45, "file": 25, "line": 299}, "message": "/*domain*/ (fixit)"}, {"location": {"col": 44, "file": 25, "line": 299}, "message": "parameter 'domain' is unused"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/pdns/dnsbackend.hh", "reportHash": "fe56ed9e78bef632d4f745535ca1df50", "checkerName": "misc-unused-parameters", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 66, "file": 25, "line": 299}, "message": "/*ips*/ (fixit)"}, {"location": {"col": 65, "file": 25, "line": 299}, "message": "parameter 'ips' is unused"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/pdns/dnsbackend.hh", "reportHash": "0c8b05780a9ce42397b9c972001ed85d", "checkerName": "misc-unused-parameters", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 55, "file": 25, "line": 304}, "message": "/*domains*/ (fixit)"}, {"location": {"col": 54, "file": 25, "line": 304}, "message": "parameter 'domains' is unused"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/pdns/dnsbackend.hh", "reportHash": "5b0583d00b36af171b44a72ef8c1e674", "checkerName": "misc-unused-parameters", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 35, "file": 25, "line": 309}, "message": "/*domain_id*/ (fixit)"}, {"location": {"col": 34, "file": 25, "line": 309}, "message": "parameter 'domain_id' is unused"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/pdns/dnsbackend.hh", "reportHash": "6088ed6d62e73681aa5e06abbbc23f58", "checkerName": "misc-unused-parameters", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 38, "file": 25, "line": 314}, "message": "/*id*/ (fixit)"}, {"location": {"col": 37, "file": 25, "line": 314}, "message": "parameter 'id' is unused"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/pdns/dnsbackend.hh", "reportHash": "60d994c2e79fd044d021c34c5f9ed9ab", "checkerName": "misc-unused-parameters", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 51, "file": 25, "line": 314}, "message": "/*serial*/ (fixit)"}, {"location": {"col": 50, "file": 25, "line": 314}, "message": "parameter 'serial' is unused"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/pdns/dnsbackend.hh", "reportHash": "c858374425cf3af839bafb0f8a39c08f", "checkerName": "misc-unused-parameters", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 43, "file": 25, "line": 319}, "message": "/*domain*/ (fixit)"}, {"location": {"col": 42, "file": 25, "line": 319}, "message": "parameter 'domain' is unused"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/pdns/dnsbackend.hh", "reportHash": "8267a8c2750dcfff2de7c37039793944", "checkerName": "misc-unused-parameters", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 79, "file": 25, "line": 319}, "message": "/*masters*/ (fixit)"}, {"location": {"col": 78, "file": 25, "line": 319}, "message": "parameter 'masters' is unused"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/pdns/dnsbackend.hh", "reportHash": "2327eb74f58682739747191f035a89c2", "checkerName": "misc-unused-parameters", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 40, "file": 25, "line": 325}, "message": "/*domain*/ (fixit)"}, {"location": {"col": 39, "file": 25, "line": 325}, "message": "parameter 'domain' is unused"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/pdns/dnsbackend.hh", "reportHash": "966701f99cfaf026370ab9fed1b08c0d", "checkerName": "misc-unused-parameters", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 77, "file": 25, "line": 325}, "message": "/*kind*/ (fixit)"}, {"location": {"col": 76, "file": 25, "line": 325}, "message": "parameter 'kind' is unused"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/pdns/dnsbackend.hh", "reportHash": "99540c8fc408b0b90163c9e2c981d4c5", "checkerName": "misc-unused-parameters", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 43, "file": 25, "line": 331}, "message": "/*domain*/ (fixit)"}, {"location": {"col": 42, "file": 25, "line": 331}, "message": "parameter 'domain' is unused"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/pdns/dnsbackend.hh", "reportHash": "18109a180b5c68e74bbb17f16f490ee1", "checkerName": "misc-unused-parameters", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 65, "file": 25, "line": 331}, "message": "/*account*/ (fixit)"}, {"location": {"col": 64, "file": 25, "line": 331}, "message": "parameter 'account' is unused"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/pdns/dnsbackend.hh", "reportHash": "e3b90525549c62c4e8856b804444f881", "checkerName": "misc-unused-parameters", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 46, "file": 25, "line": 340}, "message": "/*ip*/ (fixit)"}, {"location": {"col": 45, "file": 25, "line": 340}, "message": "parameter 'ip' is unused"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/pdns/dnsbackend.hh", "reportHash": "28472e9cb716a768a4c1da91b0f3b43a", "checkerName": "misc-unused-parameters", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 64, "file": 25, "line": 340}, "message": "/*nameserver*/ (fixit)"}, {"location": {"col": 63, "file": 25, "line": 340}, "message": "parameter 'nameserver' is unused"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/pdns/dnsbackend.hh", "reportHash": "e91c776afbede2af7ef77b994a6d2ae7", "checkerName": "misc-unused-parameters", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 90, "file": 25, "line": 340}, "message": "/*account*/ (fixit)"}, {"location": {"col": 89, "file": 25, "line": 340}, "message": "parameter 'account' is unused"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/pdns/dnsbackend.hh", "reportHash": "cdb07471b6093c683f724d86b55e705d", "checkerName": "misc-unused-parameters", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 50, "file": 25, "line": 346}, "message": "/*ip*/ (fixit)"}, {"location": {"col": 49, "file": 25, "line": 346}, "message": "parameter 'ip' is unused"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/pdns/dnsbackend.hh", "reportHash": "f12326b985eaef35fad03ac27a249dc7", "checkerName": "misc-unused-parameters", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 69, "file": 25, "line": 346}, "message": "/*domain*/ (fixit)"}, {"location": {"col": 68, "file": 25, "line": 346}, "message": "parameter 'domain' is unused"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/pdns/dnsbackend.hh", "reportHash": "1a048f4f71265c8a668d70b02c6677e8", "checkerName": "misc-unused-parameters", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 109, "file": 25, "line": 346}, "message": "/*nsset*/ (fixit)"}, {"location": {"col": 108, "file": 25, "line": 346}, "message": "parameter 'nsset' is unused"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/pdns/dnsbackend.hh", "reportHash": "b92af2f046afd50f441e2d4672e1715d", "checkerName": "misc-unused-parameters", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 124, "file": 25, "line": 346}, "message": "/*nameserver*/ (fixit)"}, {"location": {"col": 123, "file": 25, "line": 346}, "message": "parameter 'nameserver' is unused"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/pdns/dnsbackend.hh", "reportHash": "15f6c070b6e856dec782487c52fb62ff", "checkerName": "misc-unused-parameters", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 144, "file": 25, "line": 346}, "message": "/*account*/ (fixit)"}, {"location": {"col": 143, "file": 25, "line": 346}, "message": "parameter 'account' is unused"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/pdns/dnsbackend.hh", "reportHash": "50ab32f5313471bc6e2069bdda99fa46", "checkerName": "misc-unused-parameters", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 166, "file": 25, "line": 346}, "message": "/*db*/ (fixit)"}, {"location": {"col": 165, "file": 25, "line": 346}, "message": "parameter 'db' is unused"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/pdns/dnsbackend.hh", "reportHash": "24ac0020d584e78ff239c11fe102f5f6", "checkerName": "misc-unused-parameters", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 45, "file": 25, "line": 352}, "message": "/*domain*/ (fixit)"}, {"location": {"col": 44, "file": 25, "line": 352}, "message": "parameter 'domain' is unused"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/pdns/dnsbackend.hh", "reportHash": "11b03f9d79d7489e0730e5ef53fe022d", "checkerName": "misc-unused-parameters", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 82, "file": 25, "line": 352}, "message": "/*kind*/ (fixit)"}, {"location": {"col": 81, "file": 25, "line": 352}, "message": "parameter 'kind' is unused"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/pdns/dnsbackend.hh", "reportHash": "12d5f235101f27fbf54378c9a022b348", "checkerName": "misc-unused-parameters", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 116, "file": 25, "line": 352}, "message": "/*masters*/ (fixit)"}, {"location": {"col": 115, "file": 25, "line": 352}, "message": "parameter 'masters' is unused"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/pdns/dnsbackend.hh", "reportHash": "017124754d683e070806ccb8e0db7a89", "checkerName": "misc-unused-parameters", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 139, "file": 25, "line": 352}, "message": "/*account*/ (fixit)"}, {"location": {"col": 138, "file": 25, "line": 352}, "message": "parameter 'account' is unused"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/pdns/dnsbackend.hh", "reportHash": "53775a94478ce548e23a1d3df6812a07", "checkerName": "misc-unused-parameters", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 49, "file": 25, "line": 358}, "message": "/*ip*/ (fixit)"}, {"location": {"col": 48, "file": 25, "line": 358}, "message": "parameter 'ip' is unused"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/pdns/dnsbackend.hh", "reportHash": "8ec4d77374dc9974518a11ec63eb88af", "checkerName": "misc-unused-parameters", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 68, "file": 25, "line": 358}, "message": "/*domain*/ (fixit)"}, {"location": {"col": 67, "file": 25, "line": 358}, "message": "parameter 'domain' is unused"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/pdns/dnsbackend.hh", "reportHash": "6dd7a94f0479697e83ff40f149d1a4ad", "checkerName": "misc-unused-parameters", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 90, "file": 25, "line": 358}, "message": "/*nameserver*/ (fixit)"}, {"location": {"col": 89, "file": 25, "line": 358}, "message": "parameter 'nameserver' is unused"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/pdns/dnsbackend.hh", "reportHash": "e9a1f8eea3a55c45a8420719ee3295e7", "checkerName": "misc-unused-parameters", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 116, "file": 25, "line": 358}, "message": "/*account*/ (fixit)"}, {"location": {"col": 115, "file": 25, "line": 358}, "message": "parameter 'account' is unused"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/pdns/dnsbackend.hh", "reportHash": "f216e671e164a26307c985eb37ed89f4", "checkerName": "misc-unused-parameters", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 45, "file": 25, "line": 364}, "message": "/*domain*/ (fixit)"}, {"location": {"col": 44, "file": 25, "line": 364}, "message": "parameter 'domain' is unused"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/pdns/dnsbackend.hh", "reportHash": "303745fe670887ebfcb34c48cc45541e", "checkerName": "misc-unused-parameters", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 50, "file": 25, "line": 369}, "message": "/*query*/ (fixit)"}, {"location": {"col": 49, "file": 25, "line": 369}, "message": "parameter 'query' is unused"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/pdns/dnsbackend.hh", "reportHash": "72f4722f562de3117772b6f77c914586", "checkerName": "misc-unused-parameters", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 39, "file": 3, "line": 509}, "message": "default parameter was declared here"}, {"location": {"col": 12, "file": 25, "line": 371}, "message": "calling a function that uses a default argument is disallowed"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/pdns/dnsbackend.hh", "reportHash": "a0d94115318a2db9dd03f2e9550fd755", "checkerName": "fuchsia-default-arguments", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 45, "file": 25, "line": 375}, "message": "/*pattern*/ (fixit)"}, {"location": {"col": 44, "file": 25, "line": 375}, "message": "parameter 'pattern' is unused"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/pdns/dnsbackend.hh", "reportHash": "50a513b2e127bd45988e80e757f04657", "checkerName": "misc-unused-parameters", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 58, "file": 25, "line": 375}, "message": "/*maxResults*/ (fixit)"}, {"location": {"col": 57, "file": 25, "line": 375}, "message": "parameter 'maxResults' is unused"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/pdns/dnsbackend.hh", "reportHash": "33daf111d1a80068ca6f9320ca298fff", "checkerName": "misc-unused-parameters", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 96, "file": 25, "line": 375}, "message": "non-const reference parameter 'result', make it const or use a pointer"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/pdns/dnsbackend.hh", "reportHash": "83ee7e90202082cab180fe426d08e311", "checkerName": "google-runtime-references", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 97, "file": 25, "line": 375}, "message": "/*result*/ (fixit)"}, {"location": {"col": 96, "file": 25, "line": 375}, "message": "parameter 'result' is unused"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/pdns/dnsbackend.hh", "reportHash": "32dc1f628c8347588d3dc248e5c3e07f", "checkerName": "misc-unused-parameters", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 46, "file": 25, "line": 381}, "message": "/*pattern*/ (fixit)"}, {"location": {"col": 45, "file": 25, "line": 381}, "message": "parameter 'pattern' is unused"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/pdns/dnsbackend.hh", "reportHash": "2309c6a716b5661fa39724978096993e", "checkerName": "misc-unused-parameters", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 59, "file": 25, "line": 381}, "message": "/*maxResults*/ (fixit)"}, {"location": {"col": 58, "file": 25, "line": 381}, "message": "parameter 'maxResults' is unused"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/pdns/dnsbackend.hh", "reportHash": "44adb9771cff2e291f87b0d3eac3ba67", "checkerName": "misc-unused-parameters", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 87, "file": 25, "line": 381}, "message": "non-const reference parameter 'result', make it const or use a pointer"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/pdns/dnsbackend.hh", "reportHash": "56c100f3d2edc3a14186c9de2dbc2d87", "checkerName": "google-runtime-references", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 88, "file": 25, "line": 381}, "message": "/*result*/ (fixit)"}, {"location": {"col": 87, "file": 25, "line": 381}, "message": "parameter 'result' is unused"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/pdns/dnsbackend.hh", "reportHash": "faeadddd4c8381a030d6985234516572", "checkerName": "misc-unused-parameters", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 7, "file": 25, "line": 396}, "message": "class 'BackendFactory' defines a non-default destructor but does not define a copy constructor, a copy assignment operator, a move constructor or a move assignment operator"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/pdns/dnsbackend.hh", "reportHash": "7e133c87fd04c9d415e987b31a4c413c", "checkerName": "hicpp-special-member-functions", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 3, "file": 25, "line": 399}, "message": "explicit (fixit)"}, {"location": {"col": 3, "file": 25, "line": 399}, "message": "single-argument constructors must be marked explicit to avoid unintentional implicit conversions"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/pdns/dnsbackend.hh", "reportHash": "c532649cf8aad00af3d3ef4e37945bb2", "checkerName": "google-explicit-constructor", "reviewStatus": null, "severity": "MEDIUM"}, {"events": [{"location": {"col": 18, "file": 25, "line": 399}, "message": "string                       std::move() (fixit)"}, {"location": {"col": 18, "file": 25, "line": 399}, "message": "pass by value and use std::move"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/pdns/dnsbackend.hh", "reportHash": "5003ffe0a25a911dd1c8674d3cd18ccc", "checkerName": "modernize-pass-by-value", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 28, "file": 25, "line": 400}, "message": "= default; (fixit)"}, {"location": {"col": 11, "file": 25, "line": 400}, "message": "use '= default' to define a trivial destructor"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/pdns/dnsbackend.hh", "reportHash": "d3ea2c2081077e986b2b22cfa33de03b", "checkerName": "modernize-use-equals-default", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 16, "file": 25, "line": 406}, "message": "default arguments on virtual or override methods are prohibited"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/pdns/dnsbackend.hh", "reportHash": "731b241377b4f7dc7f7b111ab13a2e00", "checkerName": "google-default-arguments", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 33, "file": 25, "line": 406}, "message": "declaring a parameter with a default argument is disallowed"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/pdns/dnsbackend.hh", "reportHash": "8bf5b44bfa7d9623cd05950c41227a81", "checkerName": "fuchsia-default-arguments", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 48, "file": 25, "line": 406}, "message": "/*suffix*/ (fixit)"}, {"location": {"col": 47, "file": 25, "line": 406}, "message": "parameter 'suffix' is unused"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/pdns/dnsbackend.hh", "reportHash": "64f4c1be5e912160c6bd8a1e43f59fb0", "checkerName": "misc-unused-parameters", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 39, "file": 3, "line": 509}, "message": "default parameter was declared here"}, {"location": {"col": 54, "file": 25, "line": 406}, "message": "calling a function that uses a default argument is disallowed"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/pdns/dnsbackend.hh", "reportHash": "7be4880842d71268ff423e77aecd21f6", "checkerName": "fuchsia-default-arguments", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 28, "file": 25, "line": 421}, "message": "declaring a parameter with a default argument is disallowed"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/pdns/dnsbackend.hh", "reportHash": "96d6a23cac196b68f37d52cfa29bcb07", "checkerName": "fuchsia-default-arguments", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 3, "file": 25, "line": 429}, "message": "use 'using' instead of 'typedef'"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/pdns/dnsbackend.hh", "reportHash": "3271e483a90de94942bbcdd7008b157e", "checkerName": "modernize-use-using", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 3, "file": 25, "line": 440}, "message": "explicit (fixit)"}, {"location": {"col": 3, "file": 25, "line": 440}, "message": "single-argument constructors must be marked explicit to avoid unintentional implicit conversions"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/pdns/dnsbackend.hh", "reportHash": "7794b4dc6b69ec1016b720d397261ace", "checkerName": "google-explicit-constructor", "reviewStatus": null, "severity": "MEDIUM"}, {"events": [{"location": {"col": 50, "file": 25, "line": 444}, "message": "non-const reference parameter 'data', make it const or use a pointer"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/pdns/dnsbackend.hh", "reportHash": "a575139424c684177e8d58984c2708d3", "checkerName": "google-runtime-references", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 52, "file": 25, "line": 446}, "message": "non-const reference parameter 'data', make it const or use a pointer"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/pdns/dnsbackend.hh", "reportHash": "57d3e6f6ae7ff8d43b7d8a1b4831d5f7", "checkerName": "google-runtime-references", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 7, "file": 13, "line": 62}, "message": "class 'DNSName' defines a copy constructor, a copy assignment operator, a move constructor and a move assignment operator but does not define a destructor"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/pdns/dnsname.hh", "reportHash": "f54c6a73c76f5487c1df9dad31553036", "checkerName": "hicpp-special-member-functions", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 3, "file": 13, "line": 74}, "message": "operator=() should take 'DNSName const&', 'DNSName&&' or 'DNSName'"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/pdns/dnsname.hh", "reportHash": "af515cf657789c81fe4145bbc08a8c35", "checkerName": "cppcoreguidelines-c-copy-assignment-signature", "reviewStatus": null, "severity": "MEDIUM"}, {"events": [{"location": {"col": 12, "file": 13, "line": 74}, "message": "move assignment operators should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/pdns/dnsname.hh", "reportHash": "1c8fe265df3abd581154b7664dbcb697", "checkerName": "hicpp-noexcept-move", "reviewStatus": null, "severity": "MEDIUM"}, {"events": [{"location": {"col": 19, "file": 13, "line": 77}, "message": "std::move of the const expression has no effect; remove std::move()"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/pdns/dnsname.hh", "reportHash": "1c38e85f453562738bfe54211b5bd8b4", "checkerName": "performance-move-const-arg", "reviewStatus": null, "severity": "MEDIUM"}, {"events": [{"location": {"col": 54, "file": 13, "line": 95}, "message": "{           } (fixit)"}, {"location": {"col": 53, "file": 13, "line": 95}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/pdns/dnsname.hh", "reportHash": "bed05225e3c3de362cb76abff089ab9f", "checkerName": "hicpp-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 71, "file": 13, "line": 95}, "message": "{ (fixit)"}, {"location": {"col": 70, "file": 13, "line": 95}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/pdns/dnsname.hh", "reportHash": "eabf30b1c7750f40b71b095cc5c1a62b", "checkerName": "hicpp-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 55, "file": 13, "line": 135}, "message": "{ (fixit)"}, {"location": {"col": 54, "file": 13, "line": 135}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/pdns/dnsname.hh", "reportHash": "79795a049368b14daa8839f820b0a214", "checkerName": "google-readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 10, "file": 13, "line": 142}, "message": "{ (fixit)"}, {"location": {"col": 9, "file": 13, "line": 142}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/pdns/dnsname.hh", "reportHash": "ccd45117aad65fba7f5be4de57d1ced8", "checkerName": "google-readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 13, "file": 13, "line": 195}, "message": "auto (fixit)"}, {"location": {"col": 13, "file": 13, "line": 195}, "message": "use auto when initializing with a cast to avoid duplicating the type name"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/pdns/dnsname.hh", "reportHash": "33c240c473a6875a0f93446993a3f189", "checkerName": "modernize-use-auto", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 181, "file": 13, "line": 195}, "message": "{ (fixit)"}, {"location": {"col": 180, "file": 13, "line": 195}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/pdns/dnsname.hh", "reportHash": "e3deeb4613573bc6630fbaceaf1fe6d6", "checkerName": "readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 40, "file": 13, "line": 205}, "message": "{ (fixit)"}, {"location": {"col": 39, "file": 13, "line": 205}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/pdns/dnsname.hh", "reportHash": "12eb913b9d9a2d24f0f1adc5d5033ae8", "checkerName": "hicpp-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 23, "file": 13, "line": 207}, "message": "{ (fixit)"}, {"location": {"col": 22, "file": 13, "line": 207}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/pdns/dnsname.hh", "reportHash": "0735fc0a5ae6aca425f42dac5012df02", "checkerName": "google-readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 13, "file": 13, "line": 233}, "message": "{ (fixit)"}, {"location": {"col": 12, "file": 13, "line": 233}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/pdns/dnsname.hh", "reportHash": "e64fc62df39bb2a00e8cefe2f2ce341e", "checkerName": "hicpp-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 8, "file": 13, "line": 256}, "message": "class 'SuffixMatchTree' defines a copy constructor and a copy assignment operator but does not define a destructor, a move constructor or a move assignment operator"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/pdns/dnsname.hh", "reportHash": "ce11c25266334719ff970ddedda6a035", "checkerName": "hicpp-special-member-functions", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 3, "file": 13, "line": 258}, "message": "explicit (fixit)"}, {"location": {"col": 3, "file": 13, "line": 258}, "message": "constructors that are callable with a single argument must be marked explicit to avoid unintentional implicit conversions"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/pdns/dnsname.hh", "reportHash": "2ac853aab379801827ddce916e6afd4a", "checkerName": "hicpp-explicit-conversions", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 3, "file": 13, "line": 286}, "message": "using value_type = SuffixMatchTree<T> (fixit)"}, {"location": {"col": 3, "file": 13, "line": 286}, "message": "use 'using' instead of 'typedef'"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/pdns/dnsname.hh", "reportHash": "33bd925de2f66725253be92a75c94f94", "checkerName": "modernize-use-using", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 17, "file": 13, "line": 292}, "message": "{ (fixit)"}, {"location": {"col": 16, "file": 13, "line": 292}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/pdns/dnsname.hh", "reportHash": "97110a782174b395f9e17004a5360c81", "checkerName": "readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 19, "file": 13, "line": 378}, "message": "{ (fixit)"}, {"location": {"col": 18, "file": 13, "line": 378}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/pdns/dnsname.hh", "reportHash": "601b57d23217d5df63794e9435213b7f", "checkerName": "readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 19, "file": 13, "line": 386}, "message": "{ (fixit)"}, {"location": {"col": 18, "file": 13, "line": 386}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/pdns/dnsname.hh", "reportHash": "478f51b0dc8b9e94ec17a16a9c37b688", "checkerName": "hicpp-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 5, "file": 13, "line": 419}, "message": "use '= default' to define a trivial default constructor"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/pdns/dnsname.hh", "reportHash": "d3420418c9f7cb5dad538f69058607fc", "checkerName": "modernize-use-equals-default", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 45, "file": 13, "line": 502}, "message": "{ (fixit)"}, {"location": {"col": 44, "file": 13, "line": 502}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/pdns/dnsname.hh", "reportHash": "1a8b89db59f26a1c6f0661dc26f867be", "checkerName": "google-readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 1, "file": 28, "line": 1}, "message": "header is missing header guard"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/pdns/dnspacket.hh", "reportHash": "e4d2d2120613d48d31204f877bcbd5a8", "checkerName": "llvm-header-guard", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 10, "file": 28, "line": 23}, "message": "\"ednssubnet.hh\" (fixit)"}, {"location": {"col": 1, "file": 28, "line": 23}, "message": "#includes are not sorted properly"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/pdns/dnspacket.hh", "reportHash": "1475624148185736437a835977601fa2", "checkerName": "llvm-include-order", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 10, "file": 28, "line": 36}, "message": "\"dns.hh\" (fixit)"}, {"location": {"col": 1, "file": 28, "line": 36}, "message": "#includes are not sorted properly"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/pdns/dnspacket.hh", "reportHash": "095eefc5ebb7e75ab31ef64c5b8b8720", "checkerName": "llvm-include-order", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 7, "file": 28, "line": 52}, "message": "class 'DNSPacket' defines a copy constructor and a copy assignment operator but does not define a destructor, a move constructor or a move assignment operator"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/pdns/dnspacket.hh", "reportHash": "232634787413f20ccf325ce367ffadf0", "checkerName": "cppcoreguidelines-special-member-functions", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 3, "file": 28, "line": 55}, "message": "explicit (fixit)"}, {"location": {"col": 3, "file": 28, "line": 55}, "message": "single-argument constructors must be marked explicit to avoid unintentional implicit conversions"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/pdns/dnspacket.hh", "reportHash": "9c4a597028d032d2e089cb828dcb228e", "checkerName": "hicpp-explicit-conversions", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 27, "file": 28, "line": 71}, "message": "reinterpret_cast<sockaddr*>( ) (fixit)"}, {"location": {"col": 27, "file": 28, "line": 71}, "message": "C-style casts are discouraged; use reinterpret_cast"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/pdns/dnspacket.hh", "reportHash": "2b7ff67a59bfcf2c0bf25d98cf0390c8", "checkerName": "google-readability-casting", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 27, "file": 28, "line": 71}, "message": "do not use C-style cast to convert between unrelated types"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/pdns/dnspacket.hh", "reportHash": "d1a3035533fbeed6f36d2c4d429004c8", "checkerName": "cppcoreguidelines-pro-type-cstyle-cast", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 64, "file": 28, "line": 156}, "message": "declaring a parameter with a default argument is disallowed"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/pdns/dnspacket.hh", "reportHash": "3d2659840a55c0ad0249e4ad45e61fe9", "checkerName": "fuchsia-default-arguments", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 122, "file": 28, "line": 157}, "message": "declaring a parameter with a default argument is disallowed"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/pdns/dnspacket.hh", "reportHash": "4915e0441a9f26685d21d159a366aeaf", "checkerName": "fuchsia-default-arguments", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 1, "file": 22, "line": 28}, "message": "note: this fix will not be applied because it overlaps with another fix (fixit)"}, {"location": {"col": 10, "file": 22, "line": 28}, "message": "inclusion of deprecated C++ header 'errno.h'; consider using 'cerrno' instead"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/pdns/dnsparser.hh", "reportHash": "0ad0d777fa17520e04d28a058dfd45ea", "checkerName": "hicpp-deprecated-headers", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 3, "file": 22, "line": 59}, "message": "explicit (fixit)"}, {"location": {"col": 3, "file": 22, "line": 59}, "message": "single-argument constructors must be marked explicit to avoid unintentional implicit conversions"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/pdns/dnsparser.hh", "reportHash": "00dbdd9d32df65fa39757aaa73d88656", "checkerName": "hicpp-explicit-conversions", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 3, "file": 22, "line": 69}, "message": "explicit (fixit)"}, {"location": {"col": 3, "file": 22, "line": 69}, "message": "constructors that are callable with a single argument must be marked explicit to avoid unintentional implicit conversions"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/pdns/dnsparser.hh", "reportHash": "0bb1db3d470740869ce0dce8ad593cd7", "checkerName": "hicpp-explicit-conversions", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 63, "file": 22, "line": 72}, "message": "{ (fixit)"}, {"location": {"col": 62, "file": 22, "line": 72}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/pdns/dnsparser.hh", "reportHash": "7c7c46dad7d2835157f4e65f5278ea9a", "checkerName": "hicpp-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 21, "file": 29, "line": 403}, "message": "expanded from macro 'htonl'"}, {"location": {"col": 12, "file": 30, "line": 62}, "message": "expanded from macro '__bswap_32'"}, {"location": {"col": 38, "file": 30, "line": 40}, "message": "expanded from macro '__bswap_constant_32'"}, {"location": {"col": 9, "file": 22, "line": 93}, "message": "use of a signed integer operand with a binary bitwise operator"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/pdns/dnsparser.hh", "reportHash": "72dccc58111f899977d64fb58d5052fb", "checkerName": "hicpp-signed-bitwise", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 23, "file": 22, "line": 102}, "message": "{ (fixit)"}, {"location": {"col": 22, "file": 22, "line": 102}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/pdns/dnsparser.hh", "reportHash": "44d09d121851b99555ed4786e72731f3", "checkerName": "hicpp-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 10, "file": 22, "line": 104}, "message": "{ (fixit)"}, {"location": {"col": 9, "file": 22, "line": 104}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/pdns/dnsparser.hh", "reportHash": "21da934617955de82277b4fe509fe40a", "checkerName": "google-readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 7, "file": 22, "line": 190}, "message": "class 'DNSRecordContent' defines a non-default destructor but does not define a copy constructor, a copy assignment operator, a move constructor or a move assignment operator"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/pdns/dnsparser.hh", "reportHash": "5ba2f6e704d1eb6020ffafe2f70c89c0", "checkerName": "cppcoreguidelines-special-member-functions", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 17, "file": 22, "line": 204}, "message": "{ (fixit)"}, {"location": {"col": 16, "file": 22, "line": 204}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/pdns/dnsparser.hh", "reportHash": "0429462f10b22b29b827e006835a1c18", "checkerName": "readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 38, "file": 22, "line": 251}, "message": "{ (fixit)"}, {"location": {"col": 37, "file": 22, "line": 251}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/pdns/dnsparser.hh", "reportHash": "6bf994a4e792513ee23d7fd5595c9370", "checkerName": "readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 78, "file": 22, "line": 254}, "message": "{ (fixit)"}, {"location": {"col": 77, "file": 22, "line": 254}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/pdns/dnsparser.hh", "reportHash": "c8d58502cee14c5de62e6b5c4fbe97d1", "checkerName": "readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 48, "file": 32, "line": 609}, "message": "default parameter was declared here"}, {"location": {"col": 25, "file": 22, "line": 255}, "message": "calling a function that uses a default argument is disallowed"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/pdns/dnsparser.hh", "reportHash": "af42341d0e4c1084144b24a664b42c15", "checkerName": "fuchsia-default-arguments", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 38, "file": 22, "line": 263}, "message": "{ (fixit)"}, {"location": {"col": 37, "file": 22, "line": 263}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/pdns/dnsparser.hh", "reportHash": "b0408e55064a6af658d747abb9403895", "checkerName": "google-readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 100, "file": 22, "line": 300}, "message": "{ (fixit)"}, {"location": {"col": 99, "file": 22, "line": 300}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/pdns/dnsparser.hh", "reportHash": "5623327293cefc17d62dac80a7a10103", "checkerName": "google-readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 23, "file": 22, "line": 306}, "message": "{ (fixit)"}, {"location": {"col": 22, "file": 22, "line": 306}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/pdns/dnsparser.hh", "reportHash": "67722f6d9c63d3e778bf3ace8781f048", "checkerName": "google-readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 21, "file": 22, "line": 332}, "message": "{ (fixit)"}, {"location": {"col": 20, "file": 22, "line": 332}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/pdns/dnsparser.hh", "reportHash": "6abda1cfcf8e7801c28bd8797dc20ef7", "checkerName": "readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 80, "file": 22, "line": 341}, "message": "{ (fixit)"}, {"location": {"col": 79, "file": 22, "line": 341}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/pdns/dnsparser.hh", "reportHash": "14b892899867402f5503f78e05d412ab", "checkerName": "hicpp-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 21, "file": 29, "line": 401}, "message": "expanded from macro 'ntohl'"}, {"location": {"col": 8, "file": 30, "line": 61}, "message": "expanded from macro '__bswap_32'"}, {"location": {"col": 12, "file": 22, "line": 451}, "message": "do not call c-style vararg functions"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/pdns/dnsparser.hh", "reportHash": "844901a9a0a7aede76622b5d5d443179", "checkerName": "cppcoreguidelines-pro-type-vararg", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 21, "file": 29, "line": 401}, "message": "expanded from macro 'ntohl'"}, {"location": {"col": 12, "file": 30, "line": 62}, "message": "expanded from macro '__bswap_32'"}, {"location": {"col": 8, "file": 30, "line": 39}, "message": "expanded from macro '__bswap_constant_32'"}, {"location": {"col": 12, "file": 22, "line": 451}, "message": "use of a signed integer operand with a binary bitwise operator"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/pdns/dnsparser.hh", "reportHash": "a11e48256b3c117ebac874ea739af44a", "checkerName": "hicpp-signed-bitwise", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 21, "file": 29, "line": 402}, "message": "expanded from macro 'ntohs'"}, {"location": {"col": 7, "file": 33, "line": 28}, "message": "expanded from macro '__bswap_16'"}, {"location": {"col": 12, "file": 22, "line": 459}, "message": "do not call c-style vararg functions"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/pdns/dnsparser.hh", "reportHash": "10d8eae86a406451766817d9aacd5a1c", "checkerName": "cppcoreguidelines-pro-type-vararg", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 21, "file": 29, "line": 401}, "message": "expanded from macro 'ntohl'"}, {"location": {"col": 12, "file": 30, "line": 62}, "message": "expanded from macro '__bswap_32'"}, {"location": {"col": 37, "file": 30, "line": 40}, "message": "expanded from macro '__bswap_constant_32'"}, {"location": {"col": 11, "file": 22, "line": 482}, "message": "use of a signed integer operand with a binary bitwise operator"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/pdns/dnsparser.hh", "reportHash": "20d327df83049896be25f69f67edf553", "checkerName": "hicpp-signed-bitwise", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 21, "file": 29, "line": 403}, "message": "expanded from macro 'htonl'"}, {"location": {"col": 12, "file": 30, "line": 62}, "message": "expanded from macro '__bswap_32'"}, {"location": {"col": 9, "file": 30, "line": 40}, "message": "expanded from macro '__bswap_constant_32'"}, {"location": {"col": 11, "file": 22, "line": 484}, "message": "use of a signed integer operand with a binary bitwise operator"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/pdns/dnsparser.hh", "reportHash": "13a1e56b2630b70f55a8ea086c5c4ab6", "checkerName": "hicpp-signed-bitwise", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 21, "file": 29, "line": 403}, "message": "expanded from macro 'htonl'"}, {"location": {"col": 12, "file": 30, "line": 62}, "message": "expanded from macro '__bswap_32'"}, {"location": {"col": 8, "file": 30, "line": 39}, "message": "expanded from macro '__bswap_constant_32'"}, {"location": {"col": 13, "file": 22, "line": 492}, "message": "use of a signed integer operand with a binary bitwise operator"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/pdns/dnsparser.hh", "reportHash": "9b22a07614e5d57edf1d5a757cd4b916", "checkerName": "hicpp-signed-bitwise", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 36, "file": 22, "line": 505}, "message": "{ (fixit)"}, {"location": {"col": 35, "file": 22, "line": 505}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/pdns/dnsparser.hh", "reportHash": "2543c3e13c47552075885afb1c00da1e", "checkerName": "readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 1, "file": 34, "line": 1}, "message": "header is missing header guard"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/pdns/dnsproxy.hh", "reportHash": "13648f92ba6586e7bf39026e2400618c", "checkerName": "llvm-header-guard", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 10, "file": 34, "line": 23}, "message": "\"dnspacket.hh\" (fixit)"}, {"location": {"col": 1, "file": 34, "line": 23}, "message": "#includes are not sorted properly"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/pdns/dnsproxy.hh", "reportHash": "e7142dcb87652a0e952a19d4de7b5a45", "checkerName": "llvm-include-order", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 7, "file": 34, "line": 50}, "message": "class 'DNSProxy' defines a non-default destructor but does not define a copy constructor, a copy assignment operator, a move constructor or a move assignment operator"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/pdns/dnsproxy.hh", "reportHash": "ae6d9c98243c07f0de502ad01d0f32db", "checkerName": "cppcoreguidelines-special-member-functions", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 3, "file": 34, "line": 53}, "message": "explicit (fixit)"}, {"location": {"col": 3, "file": 34, "line": 53}, "message": "single-argument constructors must be marked explicit to avoid unintentional implicit conversions"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/pdns/dnsproxy.hh", "reportHash": "e579ec7420aa4ba1a4049092854d8cf3", "checkerName": "google-explicit-constructor", "reviewStatus": null, "severity": "MEDIUM"}, {"events": [{"location": {"col": 51, "file": 34, "line": 56}, "message": "non-const reference parameter 'r', make it const or use a pointer"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/pdns/dnsproxy.hh", "reportHash": "d16208f5cfb316fd141a9bd0585bda4d", "checkerName": "google-runtime-references", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 98, "file": 34, "line": 56}, "message": "parameter 'scopeMask' is const-qualified in the function declaration; const-qualification of parameters only has an effect in function definitions"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/pdns/dnsproxy.hh", "reportHash": "b2f2d93dfc82a02635efb3208ba5c725", "checkerName": "readability-avoid-const-params-in-decls", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 3, "file": 34, "line": 75}, "message": "use 'using' instead of 'typedef'"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/pdns/dnsproxy.hh", "reportHash": "780e4b25305cf3015c0d2187d51df01b", "checkerName": "modernize-use-using", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 84, "file": 35, "line": 39}, "message": "expanded from macro 'includeboilerplate'"}, {"location": {"col": 3, "file": 35, "line": 51}, "message": "non-const reference parameter 'pr', make it const or use a pointer"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/pdns/dnsrecords.hh", "reportHash": "2f0145bf8c8dae5794db01924a418a67", "checkerName": "google-runtime-references", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 32, "file": 35, "line": 41}, "message": "expanded from macro 'includeboilerplate'"}, {"location": {"col": 3, "file": 35, "line": 65}, "message": "declaring a parameter with a default argument is disallowed"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/pdns/dnsrecords.hh", "reportHash": "36115b23ac5f859eee41af2e51ab98d6", "checkerName": "fuchsia-default-arguments", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 84, "file": 35, "line": 39}, "message": "expanded from macro 'includeboilerplate'"}, {"location": {"col": 3, "file": 35, "line": 65}, "message": "non-const reference parameter 'pr', make it const or use a pointer"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/pdns/dnsrecords.hh", "reportHash": "e536e7f44f41cbbbf64114d79f9c0f70", "checkerName": "google-runtime-references", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 38, "file": 35, "line": 70}, "message": "{ (fixit)"}, {"location": {"col": 37, "file": 35, "line": 70}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/pdns/dnsrecords.hh", "reportHash": "2d1ecd7803d09caf1ae7c306610907f4", "checkerName": "readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 3, "file": 35, "line": 81}, "message": "explicit (fixit)"}, {"location": {"col": 3, "file": 35, "line": 81}, "message": "single-argument constructors must be marked explicit to avoid unintentional implicit conversions"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/pdns/dnsrecords.hh", "reportHash": "f562ad1b55fb295cb4899ac804feaebc", "checkerName": "hicpp-explicit-conversions", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 38, "file": 35, "line": 87}, "message": "{ (fixit)"}, {"location": {"col": 37, "file": 35, "line": 87}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/pdns/dnsrecords.hh", "reportHash": "2d1ecd7803d09caf1ae7c306610907f4", "checkerName": "readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 32, "file": 35, "line": 41}, "message": "expanded from macro 'includeboilerplate'"}, {"location": {"col": 3, "file": 35, "line": 100}, "message": "declaring a parameter with a default argument is disallowed"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/pdns/dnsrecords.hh", "reportHash": "847e5514dc65c06ff6023cc95c1e517e", "checkerName": "fuchsia-default-arguments", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 38, "file": 35, "line": 107}, "message": "{ (fixit)"}, {"location": {"col": 37, "file": 35, "line": 107}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/pdns/dnsrecords.hh", "reportHash": "2d1ecd7803d09caf1ae7c306610907f4", "checkerName": "readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 84, "file": 35, "line": 39}, "message": "expanded from macro 'includeboilerplate'"}, {"location": {"col": 3, "file": 35, "line": 120}, "message": "non-const reference parameter 'pr', make it const or use a pointer"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/pdns/dnsrecords.hh", "reportHash": "c7cefa7b84cb85cb393d00af9b5c15b2", "checkerName": "google-runtime-references", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 3, "file": 35, "line": 36}, "message": "expanded from macro 'includeboilerplate'"}, {"location": {"col": 3, "file": 35, "line": 120}, "message": "single-argument constructors must be marked explicit to avoid unintentional implicit conversions"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/pdns/dnsrecords.hh", "reportHash": "9f022ac5f10fa7923a3311f45698884a", "checkerName": "hicpp-explicit-conversions", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 93, "file": 35, "line": 35}, "message": "expanded from macro 'includeboilerplate'"}, {"location": {"col": 3, "file": 35, "line": 132}, "message": "non-const reference parameter 'pr', make it const or use a pointer"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/pdns/dnsrecords.hh", "reportHash": "5049f4f394bf0d7b9984ffd5bb20b6f1", "checkerName": "google-runtime-references", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 3, "file": 35, "line": 36}, "message": "expanded from macro 'includeboilerplate'"}, {"location": {"col": 3, "file": 35, "line": 132}, "message": "single-argument constructors must be marked explicit to avoid unintentional implicit conversions"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/pdns/dnsrecords.hh", "reportHash": "cd437c3700f96d1d4ca2adfaf3c22808", "checkerName": "google-explicit-constructor", "reviewStatus": null, "severity": "MEDIUM"}, {"events": [{"location": {"col": 84, "file": 35, "line": 39}, "message": "expanded from macro 'includeboilerplate'"}, {"location": {"col": 3, "file": 35, "line": 167}, "message": "non-const reference parameter 'pr', make it const or use a pointer"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/pdns/dnsrecords.hh", "reportHash": "ba1c8e98d0b6b72d190f915d08c4ce29", "checkerName": "google-runtime-references", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 3, "file": 35, "line": 36}, "message": "expanded from macro 'includeboilerplate'"}, {"location": {"col": 3, "file": 35, "line": 167}, "message": "single-argument constructors must be marked explicit to avoid unintentional implicit conversions"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/pdns/dnsrecords.hh", "reportHash": "86b25c57881d5005c7636b03078aac18", "checkerName": "google-explicit-constructor", "reviewStatus": null, "severity": "MEDIUM"}, {"events": [{"location": {"col": 23, "file": 35, "line": 168}, "message": "= default; (fixit)"}, {"location": {"col": 3, "file": 35, "line": 168}, "message": "use '= default' to define a trivial default constructor"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/pdns/dnsrecords.hh", "reportHash": "64e7e988604c18e9578edacd5f52e3a1", "checkerName": "modernize-use-equals-default", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 84, "file": 35, "line": 39}, "message": "expanded from macro 'includeboilerplate'"}, {"location": {"col": 3, "file": 35, "line": 186}, "message": "non-const reference parameter 'pr', make it const or use a pointer"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/pdns/dnsrecords.hh", "reportHash": "5dc06c51effb95c9e25dcd120b05d400", "checkerName": "google-runtime-references", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 3, "file": 35, "line": 36}, "message": "expanded from macro 'includeboilerplate'"}, {"location": {"col": 3, "file": 35, "line": 186}, "message": "single-argument constructors must be marked explicit to avoid unintentional implicit conversions"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/pdns/dnsrecords.hh", "reportHash": "65693fcd0902bd95933664aa0025fd59", "checkerName": "hicpp-explicit-conversions", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 84, "file": 35, "line": 39}, "message": "expanded from macro 'includeboilerplate'"}, {"location": {"col": 3, "file": 35, "line": 205}, "message": "non-const reference parameter 'pr', make it const or use a pointer"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/pdns/dnsrecords.hh", "reportHash": "f156438e81bf31f19f20779b14784880", "checkerName": "google-runtime-references", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 3, "file": 35, "line": 36}, "message": "expanded from macro 'includeboilerplate'"}, {"location": {"col": 3, "file": 35, "line": 211}, "message": "single-argument constructors must be marked explicit to avoid unintentional implicit conversions"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/pdns/dnsrecords.hh", "reportHash": "56f0c3a8f74f790177c1f51f507f6203", "checkerName": "hicpp-explicit-conversions", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 32, "file": 35, "line": 41}, "message": "expanded from macro 'includeboilerplate'"}, {"location": {"col": 3, "file": 35, "line": 225}, "message": "declaring a parameter with a default argument is disallowed"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/pdns/dnsrecords.hh", "reportHash": "3d68b1c862cb02304096f31fea7bd09d", "checkerName": "fuchsia-default-arguments", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 3, "file": 35, "line": 36}, "message": "expanded from macro 'includeboilerplate'"}, {"location": {"col": 3, "file": 35, "line": 225}, "message": "single-argument constructors must be marked explicit to avoid unintentional implicit conversions"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/pdns/dnsrecords.hh", "reportHash": "02d7141f45c0aa9ad702420c20abe487", "checkerName": "hicpp-explicit-conversions", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 38, "file": 35, "line": 230}, "message": "{ (fixit)"}, {"location": {"col": 37, "file": 35, "line": 230}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/pdns/dnsrecords.hh", "reportHash": "54945e176673f55620a2bda94a5a146e", "checkerName": "hicpp-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 84, "file": 35, "line": 39}, "message": "expanded from macro 'includeboilerplate'"}, {"location": {"col": 3, "file": 35, "line": 263}, "message": "non-const reference parameter 'pr', make it const or use a pointer"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/pdns/dnsrecords.hh", "reportHash": "14c1a30fa87cdd86a3536d9d3a54d4da", "checkerName": "google-runtime-references", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 3, "file": 35, "line": 36}, "message": "expanded from macro 'includeboilerplate'"}, {"location": {"col": 3, "file": 35, "line": 263}, "message": "single-argument constructors must be marked explicit to avoid unintentional implicit conversions"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/pdns/dnsrecords.hh", "reportHash": "39f95627d99977f4e2775ac649ba033d", "checkerName": "hicpp-explicit-conversions", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 84, "file": 35, "line": 39}, "message": "expanded from macro 'includeboilerplate'"}, {"location": {"col": 3, "file": 35, "line": 272}, "message": "non-const reference parameter 'pr', make it const or use a pointer"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/pdns/dnsrecords.hh", "reportHash": "e7b0de14bbb9a20f01bf86529805a9ea", "checkerName": "google-runtime-references", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 61, "file": 35, "line": 44}, "message": "expanded from macro 'includeboilerplate'"}, {"location": {"col": 3, "file": 35, "line": 283}, "message": "declaring a parameter with a default argument is disallowed"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/pdns/dnsrecords.hh", "reportHash": "6e9bf0f1ad9cbb76e8f3e33596276a72", "checkerName": "fuchsia-default-arguments", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 84, "file": 35, "line": 39}, "message": "expanded from macro 'includeboilerplate'"}, {"location": {"col": 3, "file": 35, "line": 283}, "message": "non-const reference parameter 'pr', make it const or use a pointer"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/pdns/dnsrecords.hh", "reportHash": "1849dcfe371b934fc706950850af14fa", "checkerName": "google-runtime-references", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 3, "file": 35, "line": 36}, "message": "expanded from macro 'includeboilerplate'"}, {"location": {"col": 3, "file": 35, "line": 283}, "message": "single-argument constructors must be marked explicit to avoid unintentional implicit conversions"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/pdns/dnsrecords.hh", "reportHash": "4061637feb3927e6e379135a0c2d56c8", "checkerName": "hicpp-explicit-conversions", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 32, "file": 35, "line": 41}, "message": "expanded from macro 'includeboilerplate'"}, {"location": {"col": 3, "file": 35, "line": 292}, "message": "declaring a parameter with a default argument is disallowed"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/pdns/dnsrecords.hh", "reportHash": "c82f17be72c6bb328008f813d924c23d", "checkerName": "fuchsia-default-arguments", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 93, "file": 35, "line": 35}, "message": "expanded from macro 'includeboilerplate'"}, {"location": {"col": 3, "file": 35, "line": 292}, "message": "non-const reference parameter 'pr', make it const or use a pointer"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/pdns/dnsrecords.hh", "reportHash": "bc1fa200e561186dc43191ffc1a1bf54", "checkerName": "google-runtime-references", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 3, "file": 35, "line": 36}, "message": "expanded from macro 'includeboilerplate'"}, {"location": {"col": 3, "file": 35, "line": 292}, "message": "single-argument constructors must be marked explicit to avoid unintentional implicit conversions"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/pdns/dnsrecords.hh", "reportHash": "e5e19d72790d08fa511505524dd07c68", "checkerName": "google-explicit-constructor", "reviewStatus": null, "severity": "MEDIUM"}, {"events": [{"location": {"col": 61, "file": 35, "line": 44}, "message": "expanded from macro 'includeboilerplate'"}, {"location": {"col": 3, "file": 35, "line": 301}, "message": "declaring a parameter with a default argument is disallowed"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/pdns/dnsrecords.hh", "reportHash": "e5a9da77fad540ec4face6dc794043d3", "checkerName": "fuchsia-default-arguments", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 84, "file": 35, "line": 39}, "message": "expanded from macro 'includeboilerplate'"}, {"location": {"col": 3, "file": 35, "line": 301}, "message": "non-const reference parameter 'pr', make it const or use a pointer"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/pdns/dnsrecords.hh", "reportHash": "17c2d2366fcdc409d46e2694b26dec07", "checkerName": "google-runtime-references", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 3, "file": 35, "line": 36}, "message": "expanded from macro 'includeboilerplate'"}, {"location": {"col": 3, "file": 35, "line": 301}, "message": "single-argument constructors must be marked explicit to avoid unintentional implicit conversions"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/pdns/dnsrecords.hh", "reportHash": "4e96c7dcbdc398025fe6329d0bf1057e", "checkerName": "hicpp-explicit-conversions", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 84, "file": 35, "line": 39}, "message": "expanded from macro 'includeboilerplate'"}, {"location": {"col": 3, "file": 35, "line": 310}, "message": "non-const reference parameter 'pr', make it const or use a pointer"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/pdns/dnsrecords.hh", "reportHash": "ee681d55fe40f2f9346b1cdd16bc30b4", "checkerName": "google-runtime-references", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 3, "file": 35, "line": 36}, "message": "expanded from macro 'includeboilerplate'"}, {"location": {"col": 3, "file": 35, "line": 321}, "message": "single-argument constructors must be marked explicit to avoid unintentional implicit conversions"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/pdns/dnsrecords.hh", "reportHash": "eb2d57cc8a17d698f8e1632976902dc2", "checkerName": "hicpp-explicit-conversions", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 61, "file": 35, "line": 44}, "message": "expanded from macro 'includeboilerplate'"}, {"location": {"col": 3, "file": 35, "line": 340}, "message": "declaring a parameter with a default argument is disallowed"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/pdns/dnsrecords.hh", "reportHash": "0cfd022265e3e66526c984bb4218f900", "checkerName": "fuchsia-default-arguments", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 93, "file": 35, "line": 35}, "message": "expanded from macro 'includeboilerplate'"}, {"location": {"col": 3, "file": 35, "line": 351}, "message": "non-const reference parameter 'pr', make it const or use a pointer"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/pdns/dnsrecords.hh", "reportHash": "4b0f7dc4582e5babebc9ddfdda80eccc", "checkerName": "google-runtime-references", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 93, "file": 35, "line": 35}, "message": "expanded from macro 'includeboilerplate'"}, {"location": {"col": 3, "file": 35, "line": 370}, "message": "non-const reference parameter 'pr', make it const or use a pointer"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/pdns/dnsrecords.hh", "reportHash": "bd4abae95eb01c7595367037d17d8619", "checkerName": "google-runtime-references", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 3, "file": 35, "line": 36}, "message": "expanded from macro 'includeboilerplate'"}, {"location": {"col": 3, "file": 35, "line": 370}, "message": "single-argument constructors must be marked explicit to avoid unintentional implicit conversions"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/pdns/dnsrecords.hh", "reportHash": "47a86d74e621a226b33f429c67be2f67", "checkerName": "google-explicit-constructor", "reviewStatus": null, "severity": "MEDIUM"}, {"events": [{"location": {"col": 93, "file": 35, "line": 35}, "message": "expanded from macro 'includeboilerplate'"}, {"location": {"col": 3, "file": 35, "line": 397}, "message": "non-const reference parameter 'pr', make it const or use a pointer"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/pdns/dnsrecords.hh", "reportHash": "23efd84d30f66f13770d7c0f1e87f56e", "checkerName": "google-runtime-references", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 93, "file": 35, "line": 35}, "message": "expanded from macro 'includeboilerplate'"}, {"location": {"col": 3, "file": 35, "line": 408}, "message": "non-const reference parameter 'pr', make it const or use a pointer"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/pdns/dnsrecords.hh", "reportHash": "000f88138f959eaf0a65b826914cedd7", "checkerName": "google-runtime-references", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 3, "file": 35, "line": 36}, "message": "expanded from macro 'includeboilerplate'"}, {"location": {"col": 3, "file": 35, "line": 408}, "message": "single-argument constructors must be marked explicit to avoid unintentional implicit conversions"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/pdns/dnsrecords.hh", "reportHash": "ebb3febebb6adef067ec92437a6efb3a", "checkerName": "google-explicit-constructor", "reviewStatus": null, "severity": "MEDIUM"}, {"events": [{"location": {"col": 61, "file": 35, "line": 44}, "message": "expanded from macro 'includeboilerplate'"}, {"location": {"col": 3, "file": 35, "line": 419}, "message": "declaring a parameter with a default argument is disallowed"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/pdns/dnsrecords.hh", "reportHash": "a499a59af6f694ff51fd4204d4deaed0", "checkerName": "fuchsia-default-arguments", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 93, "file": 35, "line": 35}, "message": "expanded from macro 'includeboilerplate'"}, {"location": {"col": 3, "file": 35, "line": 430}, "message": "non-const reference parameter 'pr', make it const or use a pointer"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/pdns/dnsrecords.hh", "reportHash": "e4498c3bfaaa4c73461e28b495838685", "checkerName": "google-runtime-references", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 3, "file": 35, "line": 36}, "message": "expanded from macro 'includeboilerplate'"}, {"location": {"col": 3, "file": 35, "line": 430}, "message": "single-argument constructors must be marked explicit to avoid unintentional implicit conversions"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/pdns/dnsrecords.hh", "reportHash": "2d7591009aca2275c221781a0cf2fc1a", "checkerName": "google-explicit-constructor", "reviewStatus": null, "severity": "MEDIUM"}, {"events": [{"location": {"col": 3, "file": 35, "line": 36}, "message": "expanded from macro 'includeboilerplate'"}, {"location": {"col": 3, "file": 35, "line": 440}, "message": "single-argument constructors must be marked explicit to avoid unintentional implicit conversions"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/pdns/dnsrecords.hh", "reportHash": "598c4a9063f9636a6d8e9c14a3831b5c", "checkerName": "google-explicit-constructor", "reviewStatus": null, "severity": "MEDIUM"}, {"events": [{"location": {"col": 32, "file": 35, "line": 41}, "message": "expanded from macro 'includeboilerplate'"}, {"location": {"col": 3, "file": 35, "line": 451}, "message": "declaring a parameter with a default argument is disallowed"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/pdns/dnsrecords.hh", "reportHash": "c4f4b885239b307d9f30bfe9ee5ae479", "checkerName": "fuchsia-default-arguments", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 93, "file": 35, "line": 35}, "message": "expanded from macro 'includeboilerplate'"}, {"location": {"col": 3, "file": 35, "line": 451}, "message": "non-const reference parameter 'pr', make it const or use a pointer"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/pdns/dnsrecords.hh", "reportHash": "46b5106479dd916556f1f3f2752b96a2", "checkerName": "google-runtime-references", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 3, "file": 35, "line": 36}, "message": "expanded from macro 'includeboilerplate'"}, {"location": {"col": 3, "file": 35, "line": 462}, "message": "single-argument constructors must be marked explicit to avoid unintentional implicit conversions"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/pdns/dnsrecords.hh", "reportHash": "d144d38132827ef30f42b17b66ef01cf", "checkerName": "hicpp-explicit-conversions", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 61, "file": 35, "line": 44}, "message": "expanded from macro 'includeboilerplate'"}, {"location": {"col": 3, "file": 35, "line": 483}, "message": "declaring a parameter with a default argument is disallowed"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/pdns/dnsrecords.hh", "reportHash": "ce45795634a6a4c01ee4cbd96d8fa8d5", "checkerName": "fuchsia-default-arguments", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 93, "file": 35, "line": 35}, "message": "expanded from macro 'includeboilerplate'"}, {"location": {"col": 3, "file": 35, "line": 493}, "message": "non-const reference parameter 'pr', make it const or use a pointer"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/pdns/dnsrecords.hh", "reportHash": "54621ff16d9b88b56ccf36c4db8fe912", "checkerName": "google-runtime-references", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 61, "file": 35, "line": 44}, "message": "expanded from macro 'includeboilerplate'"}, {"location": {"col": 3, "file": 35, "line": 504}, "message": "declaring a parameter with a default argument is disallowed"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/pdns/dnsrecords.hh", "reportHash": "bc3e0d86970cb8ab2a01d00a4ec50ed8", "checkerName": "fuchsia-default-arguments", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 93, "file": 35, "line": 35}, "message": "expanded from macro 'includeboilerplate'"}, {"location": {"col": 3, "file": 35, "line": 504}, "message": "non-const reference parameter 'pr', make it const or use a pointer"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/pdns/dnsrecords.hh", "reportHash": "edf4d7412ae61d6d553ebce7989534cb", "checkerName": "google-runtime-references", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 3, "file": 35, "line": 36}, "message": "expanded from macro 'includeboilerplate'"}, {"location": {"col": 3, "file": 35, "line": 504}, "message": "single-argument constructors must be marked explicit to avoid unintentional implicit conversions"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/pdns/dnsrecords.hh", "reportHash": "5a0aae72df6877ac9abd59a635a38ec3", "checkerName": "google-explicit-constructor", "reviewStatus": null, "severity": "MEDIUM"}, {"events": [{"location": {"col": 93, "file": 35, "line": 35}, "message": "expanded from macro 'includeboilerplate'"}, {"location": {"col": 3, "file": 35, "line": 529}, "message": "non-const reference parameter 'pr', make it const or use a pointer"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/pdns/dnsrecords.hh", "reportHash": "f6176fa3e2362ecf9d77192ca2258605", "checkerName": "google-runtime-references", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 3, "file": 35, "line": 36}, "message": "expanded from macro 'includeboilerplate'"}, {"location": {"col": 3, "file": 35, "line": 529}, "message": "single-argument constructors must be marked explicit to avoid unintentional implicit conversions"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/pdns/dnsrecords.hh", "reportHash": "4da1354f6ed45906bddd635edf1c2f40", "checkerName": "google-explicit-constructor", "reviewStatus": null, "severity": "MEDIUM"}, {"events": [{"location": {"col": 61, "file": 35, "line": 44}, "message": "expanded from macro 'includeboilerplate'"}, {"location": {"col": 3, "file": 35, "line": 538}, "message": "declaring a parameter with a default argument is disallowed"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/pdns/dnsrecords.hh", "reportHash": "7ef400ab4c619fd156b560e5325311ee", "checkerName": "fuchsia-default-arguments", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 84, "file": 35, "line": 39}, "message": "expanded from macro 'includeboilerplate'"}, {"location": {"col": 3, "file": 35, "line": 538}, "message": "non-const reference parameter 'pr', make it const or use a pointer"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/pdns/dnsrecords.hh", "reportHash": "2d39d380e1813a91a9617b9549dbc676", "checkerName": "google-runtime-references", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 3, "file": 35, "line": 631}, "message": "use '= default' to define a trivial default constructor"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/pdns/dnsrecords.hh", "reportHash": "3c1dc4436f3115d8272d5f288193dba4", "checkerName": "hicpp-use-equals-default", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 32, "file": 35, "line": 41}, "message": "expanded from macro 'includeboilerplate'"}, {"location": {"col": 3, "file": 35, "line": 803}, "message": "declaring a parameter with a default argument is disallowed"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/pdns/dnsrecords.hh", "reportHash": "e3a6db4bcbb0d6182b4da629b7a7a421", "checkerName": "fuchsia-default-arguments", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 61, "file": 35, "line": 44}, "message": "expanded from macro 'includeboilerplate'"}, {"location": {"col": 3, "file": 35, "line": 814}, "message": "declaring a parameter with a default argument is disallowed"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/pdns/dnsrecords.hh", "reportHash": "defb2774060d7bcb02452be2a45906ba", "checkerName": "fuchsia-default-arguments", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 93, "file": 35, "line": 35}, "message": "expanded from macro 'includeboilerplate'"}, {"location": {"col": 5, "file": 35, "line": 833}, "message": "non-const reference parameter 'pr', make it const or use a pointer"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/pdns/dnsrecords.hh", "reportHash": "c1ab2ea3ba63c7954b1d86eb53b29c48", "checkerName": "google-runtime-references", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 3, "file": 35, "line": 36}, "message": "expanded from macro 'includeboilerplate'"}, {"location": {"col": 5, "file": 35, "line": 833}, "message": "single-argument constructors must be marked explicit to avoid unintentional implicit conversions"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/pdns/dnsrecords.hh", "reportHash": "6d0135eb9897cb9fd1713fb8a748eba5", "checkerName": "google-explicit-constructor", "reviewStatus": null, "severity": "MEDIUM"}, {"events": [{"location": {"col": 61, "file": 35, "line": 44}, "message": "expanded from macro 'includeboilerplate'"}, {"location": {"col": 5, "file": 35, "line": 841}, "message": "declaring a parameter with a default argument is disallowed"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/pdns/dnsrecords.hh", "reportHash": "848ef3f173578ee1ad5578c979f7a0e7", "checkerName": "fuchsia-default-arguments", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 3, "file": 35, "line": 36}, "message": "expanded from macro 'includeboilerplate'"}, {"location": {"col": 5, "file": 35, "line": 841}, "message": "single-argument constructors must be marked explicit to avoid unintentional implicit conversions"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/pdns/dnsrecords.hh", "reportHash": "c6cd4759ee03079595334ef5522ee056", "checkerName": "google-explicit-constructor", "reviewStatus": null, "severity": "MEDIUM"}, {"events": [{"location": {"col": 1, "file": 37, "line": 1}, "message": "header is missing header guard"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/pdns/dnssecinfra.hh", "reportHash": "be944b5b469c6dcb51fa4a0c844c0c15", "checkerName": "llvm-header-guard", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 10, "file": 37, "line": 25}, "message": "\"misc.hh\" (fixit)"}, {"location": {"col": 1, "file": 37, "line": 25}, "message": "#includes are not sorted properly"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/pdns/dnssecinfra.hh", "reportHash": "a3b0e5398b6465f31fd122a9bcf43302", "checkerName": "llvm-include-order", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 7, "file": 37, "line": 34}, "message": "class 'DNSCryptoKeyEngine' defines a non-default destructor but does not define a copy constructor, a copy assignment operator, a move constructor or a move assignment operator"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/pdns/dnssecinfra.hh", "reportHash": "67a07a461fea4402aec4fb3272c71740", "checkerName": "cppcoreguidelines-special-member-functions", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 35, "file": 37, "line": 38}, "message": "= default; (fixit)"}, {"location": {"col": 13, "file": 37, "line": 38}, "message": "use '= default' to define a trivial destructor"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/pdns/dnssecinfra.hh", "reportHash": "878519c581324a291a26b27b1f26b77c", "checkerName": "modernize-use-equals-default", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 5, "file": 37, "line": 41}, "message": "use 'using' instead of 'typedef'"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/pdns/dnssecinfra.hh", "reportHash": "c185de79e33c65a32cfafa6e7c3de807", "checkerName": "modernize-use-using", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 5, "file": 37, "line": 42}, "message": "use 'using' instead of 'typedef'"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/pdns/dnssecinfra.hh", "reportHash": "f3cda18bf6237c25743a169865f133cc", "checkerName": "modernize-use-using", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 50, "file": 37, "line": 62}, "message": "non-const reference parameter 'drc', make it const or use a pointer"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/pdns/dnssecinfra.hh", "reportHash": "60b696dd04707553b6fd5f5cab55c1b0", "checkerName": "google-runtime-references", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 66, "file": 37, "line": 62}, "message": "non-const reference parameter 'stormap', make it const or use a pointer"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/pdns/dnssecinfra.hh", "reportHash": "a8e66f57d4868c6a98de3a9f62a5e441", "checkerName": "google-runtime-references", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 53, "file": 37, "line": 63}, "message": "non-const reference parameter 'drc', make it const or use a pointer"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/pdns/dnssecinfra.hh", "reportHash": "abf489b5e998f5d7f912b4d2cca5c5ee", "checkerName": "google-runtime-references", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 54, "file": 37, "line": 63}, "message": "/*drc*/ (fixit)"}, {"location": {"col": 53, "file": 37, "line": 63}, "message": "parameter 'drc' is unused"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/pdns/dnssecinfra.hh", "reportHash": "8990330bb4b9b36714d85d87693019bb", "checkerName": "misc-unused-parameters", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 78, "file": 37, "line": 63}, "message": "/*raw*/ (fixit)"}, {"location": {"col": 77, "file": 37, "line": 63}, "message": "parameter 'raw' is unused"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/pdns/dnssecinfra.hh", "reportHash": "22eefd51da7cfcbb138213b4f000bc24", "checkerName": "misc-unused-parameters", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 18, "file": 37, "line": 68}, "message": "default arguments on virtual or override methods are prohibited"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/pdns/dnssecinfra.hh", "reportHash": "a02c8318ffeeacfba666a2ad832ec1c4", "checkerName": "google-default-arguments", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 27, "file": 37, "line": 68}, "message": "declaring a parameter with a default argument is disallowed"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/pdns/dnssecinfra.hh", "reportHash": "3e1700b388dc92159190352c04ef0434", "checkerName": "fuchsia-default-arguments", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 44, "file": 37, "line": 68}, "message": "/*errorMessages*/ (fixit)"}, {"location": {"col": 43, "file": 37, "line": 68}, "message": "parameter 'errorMessages' is unused"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/pdns/dnssecinfra.hh", "reportHash": "af7ea7415a95b0cfa8eb8205c6c94337", "checkerName": "misc-unused-parameters", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 80, "file": 37, "line": 72}, "message": "non-const reference parameter 'drc', make it const or use a pointer"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/pdns/dnssecinfra.hh", "reportHash": "4f1507eac7aadf9655f1552a589df709", "checkerName": "google-runtime-references", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 82, "file": 37, "line": 73}, "message": "non-const reference parameter 'drc', make it const or use a pointer"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/pdns/dnssecinfra.hh", "reportHash": "490410e255940309ef91351fa49ee992", "checkerName": "google-runtime-references", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 82, "file": 37, "line": 74}, "message": "non-const reference parameter 'drc', make it const or use a pointer"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/pdns/dnssecinfra.hh", "reportHash": "df45e319814947642764fe39ecd380b8", "checkerName": "google-runtime-references", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 5, "file": 37, "line": 80}, "message": "using maker_t = shared_ptr<DNSCryptoKeyEngine> (unsigned int) (fixit)"}, {"location": {"col": 5, "file": 37, "line": 80}, "message": "use 'using' instead of 'typedef'"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/pdns/dnssecinfra.hh", "reportHash": "a8e52381b6b25cffcd99e5c2897daa6f", "checkerName": "modernize-use-using", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 64, "file": 37, "line": 82}, "message": "declaring a parameter with a default argument is disallowed"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/pdns/dnssecinfra.hh", "reportHash": "6a1557ee75251ee6b0d6b8d249ba5381", "checkerName": "fuchsia-default-arguments", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 5, "file": 37, "line": 89}, "message": "use 'using' instead of 'typedef'"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/pdns/dnssecinfra.hh", "reportHash": "591f2a3974c076d9dcc32ed311a18551", "checkerName": "modernize-use-using", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 5, "file": 37, "line": 90}, "message": "use 'using' instead of 'typedef'"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/pdns/dnssecinfra.hh", "reportHash": "4ef94a9d91ba487ca188a4fb5c2de95a", "checkerName": "modernize-use-using", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 51, "file": 37, "line": 117}, "message": "& (fixit)"}, {"location": {"col": 52, "file": 37, "line": 117}, "message": "the const qualified parameter 'key' is copied for each invocation; consider making it a reference"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/pdns/dnssecinfra.hh", "reportHash": "af69fae15179d7c370fd1818c55d8aba", "checkerName": "performance-unnecessary-value-param", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 3, "file": 37, "line": 135}, "message": "cannot overload 'operator()'"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/pdns/dnssecinfra.hh", "reportHash": "83a77af08a0961e3019a36680c2ca343", "checkerName": "fuchsia-overloaded-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 5, "file": 37, "line": 149}, "message": "cannot overload 'operator()'"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/pdns/dnssecinfra.hh", "reportHash": "bbdc5732470deb3fd06ad10cb6a94253", "checkerName": "fuchsia-overloaded-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 1, "file": 37, "line": 154}, "message": "use 'using' instead of 'typedef'"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/pdns/dnssecinfra.hh", "reportHash": "b4a95b370843448dfb347b5ffaaeb5a9", "checkerName": "modernize-use-using", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 116, "file": 37, "line": 156}, "message": "declaring a parameter with a default argument is disallowed"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/pdns/dnssecinfra.hh", "reportHash": "2105a6ade5e8730449053c7a26be7187", "checkerName": "fuchsia-default-arguments", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 33, "file": 37, "line": 167}, "message": "non-const reference parameter 'raw', make it const or use a pointer"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/pdns/dnssecinfra.hh", "reportHash": "2ddaa11919500c67c087dd66b14103f5", "checkerName": "google-runtime-references", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 33, "file": 37, "line": 168}, "message": "non-const reference parameter 'raw', make it const or use a pointer"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/pdns/dnssecinfra.hh", "reportHash": "57cf8694881770be058ced71f25fa274", "checkerName": "google-runtime-references", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 30, "file": 37, "line": 170}, "message": "non-const reference parameter 'dk', make it const or use a pointer"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/pdns/dnssecinfra.hh", "reportHash": "4322ef1d8a61ec962fde42d190ca8504", "checkerName": "google-runtime-references", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 48, "file": 37, "line": 170}, "message": "non-const reference parameter 'db', make it const or use a pointer"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/pdns/dnssecinfra.hh", "reportHash": "79dffd28a342b60bcfd3de6228fa6be8", "checkerName": "google-runtime-references", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 109, "file": 37, "line": 170}, "message": "non-const reference parameter 'rrs', make it const or use a pointer"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/pdns/dnssecinfra.hh", "reportHash": "757b6decc2d8a7134443530cc8883298", "checkerName": "google-runtime-references", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 31, "file": 37, "line": 172}, "message": "non-const reference parameter 'pw', make it const or use a pointer"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/pdns/dnssecinfra.hh", "reportHash": "c0b03c87efc69bbdaa0604f358426626", "checkerName": "google-runtime-references", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 54, "file": 37, "line": 172}, "message": "non-const reference parameter 'trc', make it const or use a pointer"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/pdns/dnssecinfra.hh", "reportHash": "a8f442e9199cb0eb848c832108fa3af7", "checkerName": "google-runtime-references", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 192, "file": 37, "line": 173}, "message": "declaring a parameter with a default argument is disallowed"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/pdns/dnssecinfra.hh", "reportHash": "46817bb2ecc7a30785c3ccd507c6cbb1", "checkerName": "fuchsia-default-arguments", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 1, "file": 38, "line": 1}, "message": "header is missing header guard"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/pdns/dnsseckeeper.hh", "reportHash": "c167777236019459418eefe826b331ef", "checkerName": "llvm-header-guard", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 10, "file": 38, "line": 23}, "message": "\"dnsrecords.hh\" (fixit)"}, {"location": {"col": 1, "file": 38, "line": 23}, "message": "#includes are not sorted properly"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/pdns/dnsseckeeper.hh", "reportHash": "e2d088d5588aa7a5aeda237549b553c8", "checkerName": "llvm-include-order", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 1, "file": 38, "line": 24}, "message": "note: this fix will not be applied because it overlaps with another fix (fixit)"}, {"location": {"col": 10, "file": 38, "line": 24}, "message": "inclusion of deprecated C++ header 'string.h'; consider using 'cstring' instead"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/pdns/dnsseckeeper.hh", "reportHash": "52bd5ef3a01f39459314b892dc3fedb7", "checkerName": "hicpp-deprecated-headers", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 1, "file": 38, "line": 38}, "message": "do not use namespace using-directives; use using-declarations instead"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/pdns/dnsseckeeper.hh", "reportHash": "7f33a516cdcd6b99f149e5eaaa78cad0", "checkerName": "google-build-using-namespace", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 1, "file": 38, "line": 38}, "message": "using declarations in the global namespace in headers are prohibited"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/pdns/dnsseckeeper.hh", "reportHash": "4ac68dab5922002004eb2770bdd964b8", "checkerName": "google-global-names-in-headers", "reviewStatus": null, "severity": "HIGH"}, {"events": [{"location": {"col": 7, "file": 38, "line": 40}, "message": "class 'DNSSECKeeper' defines a non-default destructor but does not define a copy constructor, a copy assignment operator, a move constructor or a move assignment operator"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/pdns/dnsseckeeper.hh", "reportHash": "cf226bb8ac0c5a59993baeb07bec497a", "checkerName": "cppcoreguidelines-special-member-functions", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 3, "file": 38, "line": 76}, "message": "use 'using' instead of 'typedef'"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/pdns/dnsseckeeper.hh", "reportHash": "ef63d9a99b66cbc0770180d1c16fd2cd", "checkerName": "modernize-use-using", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 3, "file": 38, "line": 77}, "message": "using keyset_t = std::vector<keymeta_t> (fixit)"}, {"location": {"col": 3, "file": 38, "line": 77}, "message": "use 'using' instead of 'typedef'"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/pdns/dnsseckeeper.hh", "reportHash": "9de03afd1898c78c385f1e48e9776361", "checkerName": "modernize-use-using", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 39, "file": 3, "line": 509}, "message": "default parameter was declared here"}, {"location": {"col": 15, "file": 38, "line": 83}, "message": "calling a function that uses a default argument is disallowed"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/pdns/dnsseckeeper.hh", "reportHash": "cbed29beaff29c6245aacd85ee4df383", "checkerName": "fuchsia-default-arguments", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 15, "file": 38, "line": 83}, "message": "do not implicitly decay an array into a pointer; consider using gsl::array_view or an explicit cast instead"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/pdns/dnsseckeeper.hh", "reportHash": "adc7287ef3b3d72a8d3c04989d63da88", "checkerName": "hicpp-no-array-decay", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 39, "file": 3, "line": 509}, "message": "default parameter was declared here"}, {"location": {"col": 15, "file": 38, "line": 85}, "message": "calling a function that uses a default argument is disallowed"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/pdns/dnsseckeeper.hh", "reportHash": "a8dc71cc71b921fef3e0015c42c3e57f", "checkerName": "fuchsia-default-arguments", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 15, "file": 38, "line": 85}, "message": "do not implicitly decay an array into a pointer; consider using gsl::array_view or an explicit cast instead"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/pdns/dnsseckeeper.hh", "reportHash": "81de0029bcaa60dfba968c8cc12305d0", "checkerName": "hicpp-no-array-decay", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 39, "file": 3, "line": 509}, "message": "default parameter was declared here"}, {"location": {"col": 15, "file": 38, "line": 87}, "message": "calling a function that uses a default argument is disallowed"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/pdns/dnsseckeeper.hh", "reportHash": "5718051a412f6817660a3bb7b681f2d9", "checkerName": "fuchsia-default-arguments", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 15, "file": 38, "line": 87}, "message": "do not implicitly decay an array into a pointer; consider using gsl::array_view or an explicit cast instead"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/pdns/dnsseckeeper.hh", "reportHash": "a49c0a79e59c6753bdcc22a17fde08a5", "checkerName": "hicpp-no-array-decay", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 39, "file": 3, "line": 509}, "message": "default parameter was declared here"}, {"location": {"col": 15, "file": 38, "line": 89}, "message": "calling a function that uses a default argument is disallowed"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/pdns/dnsseckeeper.hh", "reportHash": "2134be34d895dbc42c91f55dbeb2a1e5", "checkerName": "fuchsia-default-arguments", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 15, "file": 38, "line": 89}, "message": "do not implicitly decay an array into a pointer; consider using gsl::array_view or an explicit cast instead"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/pdns/dnsseckeeper.hh", "reportHash": "62770638ace04cdb1e22ffe0fff25056", "checkerName": "hicpp-no-array-decay", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 39, "file": 3, "line": 509}, "message": "default parameter was declared here"}, {"location": {"col": 33, "file": 38, "line": 99}, "message": "calling a function that uses a default argument is disallowed"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/pdns/dnsseckeeper.hh", "reportHash": "cb84cf5b7485ad57909913922f7fd24d", "checkerName": "fuchsia-default-arguments", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 44, "file": 38, "line": 99}, "message": "{ (fixit)"}, {"location": {"col": 43, "file": 38, "line": 99}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/pdns/dnsseckeeper.hh", "reportHash": "e5aec4a9ba01704ad2656afe83d9f617", "checkerName": "readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 39, "file": 3, "line": 509}, "message": "default parameter was declared here"}, {"location": {"col": 33, "file": 38, "line": 100}, "message": "calling a function that uses a default argument is disallowed"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/pdns/dnsseckeeper.hh", "reportHash": "264fedcb6967b21bef617975191a5e49", "checkerName": "fuchsia-default-arguments", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 40, "file": 38, "line": 100}, "message": "{ (fixit)"}, {"location": {"col": 39, "file": 38, "line": 100}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/pdns/dnsseckeeper.hh", "reportHash": "23d80369fd84cad4e520556248a81423", "checkerName": "readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 39, "file": 3, "line": 509}, "message": "default parameter was declared here"}, {"location": {"col": 33, "file": 38, "line": 101}, "message": "calling a function that uses a default argument is disallowed"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/pdns/dnsseckeeper.hh", "reportHash": "209c3e957d186ed1dd9cf67fec7c6745", "checkerName": "fuchsia-default-arguments", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 41, "file": 38, "line": 101}, "message": "{ (fixit)"}, {"location": {"col": 40, "file": 38, "line": 101}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/pdns/dnsseckeeper.hh", "reportHash": "be10290455393e40dee2d51137ca1a1e", "checkerName": "readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 39, "file": 3, "line": 509}, "message": "default parameter was declared here"}, {"location": {"col": 33, "file": 38, "line": 102}, "message": "calling a function that uses a default argument is disallowed"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/pdns/dnsseckeeper.hh", "reportHash": "09d0e427113eee207825dac79d0cce58", "checkerName": "fuchsia-default-arguments", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 45, "file": 38, "line": 102}, "message": "{ (fixit)"}, {"location": {"col": 44, "file": 38, "line": 102}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/pdns/dnsseckeeper.hh", "reportHash": "30eedebc0a3a3126b0e7e28273134230", "checkerName": "readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 39, "file": 3, "line": 509}, "message": "default parameter was declared here"}, {"location": {"col": 33, "file": 38, "line": 103}, "message": "calling a function that uses a default argument is disallowed"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/pdns/dnsseckeeper.hh", "reportHash": "e11964b2c97dafd4c53eb1a2be07598b", "checkerName": "fuchsia-default-arguments", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 52, "file": 38, "line": 103}, "message": "{ (fixit)"}, {"location": {"col": 51, "file": 38, "line": 103}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/pdns/dnsseckeeper.hh", "reportHash": "6c9c832d8a26ee8c28763e731de3bfb2", "checkerName": "readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 39, "file": 3, "line": 509}, "message": "default parameter was declared here"}, {"location": {"col": 33, "file": 38, "line": 104}, "message": "calling a function that uses a default argument is disallowed"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/pdns/dnsseckeeper.hh", "reportHash": "399ccde2a0565c4e945fa5eed9218e87", "checkerName": "fuchsia-default-arguments", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 56, "file": 38, "line": 104}, "message": "{ (fixit)"}, {"location": {"col": 55, "file": 38, "line": 104}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/pdns/dnsseckeeper.hh", "reportHash": "dfb1499a9dce2d90d67a23c5f5cf155e", "checkerName": "hicpp-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 39, "file": 3, "line": 509}, "message": "default parameter was declared here"}, {"location": {"col": 33, "file": 38, "line": 105}, "message": "calling a function that uses a default argument is disallowed"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/pdns/dnsseckeeper.hh", "reportHash": "c69b00fdc41eeb6c9002848df2b363d8", "checkerName": "fuchsia-default-arguments", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 47, "file": 38, "line": 105}, "message": "{ (fixit)"}, {"location": {"col": 46, "file": 38, "line": 105}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/pdns/dnsseckeeper.hh", "reportHash": "90ceb1b9b638341e648247a46a616bd7", "checkerName": "hicpp-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 39, "file": 3, "line": 509}, "message": "default parameter was declared here"}, {"location": {"col": 33, "file": 38, "line": 106}, "message": "calling a function that uses a default argument is disallowed"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/pdns/dnsseckeeper.hh", "reportHash": "59fe7df4bcf1dbb24a5ec0d40e9256fc", "checkerName": "fuchsia-default-arguments", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 47, "file": 38, "line": 106}, "message": "{ (fixit)"}, {"location": {"col": 46, "file": 38, "line": 106}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/pdns/dnsseckeeper.hh", "reportHash": "3cd6fcc759dbd235f31b82b58369d32d", "checkerName": "hicpp-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 39, "file": 3, "line": 509}, "message": "default parameter was declared here"}, {"location": {"col": 33, "file": 38, "line": 107}, "message": "calling a function that uses a default argument is disallowed"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/pdns/dnsseckeeper.hh", "reportHash": "32f63cd36e07302aafa36d48c94e8054", "checkerName": "fuchsia-default-arguments", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 46, "file": 38, "line": 107}, "message": "{ (fixit)"}, {"location": {"col": 45, "file": 38, "line": 107}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/pdns/dnsseckeeper.hh", "reportHash": "cc36bebe121fd4b190f03a9ff90ec37e", "checkerName": "readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 39, "file": 3, "line": 509}, "message": "default parameter was declared here"}, {"location": {"col": 33, "file": 38, "line": 108}, "message": "calling a function that uses a default argument is disallowed"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/pdns/dnsseckeeper.hh", "reportHash": "7a5f45808c438b44f442f9de3be6c419", "checkerName": "fuchsia-default-arguments", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 42, "file": 38, "line": 108}, "message": "{ (fixit)"}, {"location": {"col": 41, "file": 38, "line": 108}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/pdns/dnsseckeeper.hh", "reportHash": "700d0db34d13e2a81d8d175c812f6994", "checkerName": "readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 39, "file": 3, "line": 509}, "message": "default parameter was declared here"}, {"location": {"col": 33, "file": 38, "line": 109}, "message": "calling a function that uses a default argument is disallowed"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/pdns/dnsseckeeper.hh", "reportHash": "0d3c12e767aad517487dbee4734ff7ae", "checkerName": "fuchsia-default-arguments", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 46, "file": 38, "line": 109}, "message": "{ (fixit)"}, {"location": {"col": 45, "file": 38, "line": 109}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/pdns/dnsseckeeper.hh", "reportHash": "5c2013785cba80fe569eb1c590fc5a97", "checkerName": "readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 39, "file": 3, "line": 509}, "message": "default parameter was declared here"}, {"location": {"col": 33, "file": 38, "line": 110}, "message": "calling a function that uses a default argument is disallowed"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/pdns/dnsseckeeper.hh", "reportHash": "4b23bc2be552236709c964943dae853e", "checkerName": "fuchsia-default-arguments", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 53, "file": 38, "line": 110}, "message": "{ (fixit)"}, {"location": {"col": 52, "file": 38, "line": 110}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/pdns/dnsseckeeper.hh", "reportHash": "16f18355968d4ad6d42a6569a6daf43f", "checkerName": "readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 39, "file": 3, "line": 509}, "message": "default parameter was declared here"}, {"location": {"col": 33, "file": 38, "line": 111}, "message": "calling a function that uses a default argument is disallowed"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/pdns/dnsseckeeper.hh", "reportHash": "eabfa0bfef8cee5bf47d4f654ce3984b", "checkerName": "fuchsia-default-arguments", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 46, "file": 38, "line": 111}, "message": "{ (fixit)"}, {"location": {"col": 45, "file": 38, "line": 111}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/pdns/dnsseckeeper.hh", "reportHash": "210fceae4ed4f845a11cb6c021a4e592", "checkerName": "readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 39, "file": 3, "line": 509}, "message": "default parameter was declared here"}, {"location": {"col": 33, "file": 38, "line": 112}, "message": "calling a function that uses a default argument is disallowed"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/pdns/dnsseckeeper.hh", "reportHash": "58b2a3f8b1ddd2880ae8ea0fd6c38fd6", "checkerName": "fuchsia-default-arguments", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 53, "file": 38, "line": 112}, "message": "{ (fixit)"}, {"location": {"col": 52, "file": 38, "line": 112}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/pdns/dnsseckeeper.hh", "reportHash": "b71e5c1296598b6a688604417349200c", "checkerName": "readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 39, "file": 3, "line": 509}, "message": "default parameter was declared here"}, {"location": {"col": 33, "file": 38, "line": 113}, "message": "calling a function that uses a default argument is disallowed"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/pdns/dnsseckeeper.hh", "reportHash": "c99966b200006b67540d1d3bebc7fb96", "checkerName": "fuchsia-default-arguments", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 45, "file": 38, "line": 113}, "message": "{ (fixit)"}, {"location": {"col": 44, "file": 38, "line": 113}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/pdns/dnsseckeeper.hh", "reportHash": "8143871b17054ea83c19a6cec0569200", "checkerName": "readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 39, "file": 3, "line": 509}, "message": "default parameter was declared here"}, {"location": {"col": 33, "file": 38, "line": 114}, "message": "calling a function that uses a default argument is disallowed"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/pdns/dnsseckeeper.hh", "reportHash": "8f6343c5b285f368717bcde067ef9234", "checkerName": "fuchsia-default-arguments", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 43, "file": 38, "line": 114}, "message": "{ (fixit)"}, {"location": {"col": 42, "file": 38, "line": 114}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/pdns/dnsseckeeper.hh", "reportHash": "4d612f03b0b10f592eb6b4a00b51d979", "checkerName": "readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 39, "file": 3, "line": 509}, "message": "default parameter was declared here"}, {"location": {"col": 33, "file": 38, "line": 115}, "message": "calling a function that uses a default argument is disallowed"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/pdns/dnsseckeeper.hh", "reportHash": "e903ec8802247810fab2623c62b2b71e", "checkerName": "fuchsia-default-arguments", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 46, "file": 38, "line": 115}, "message": "{ (fixit)"}, {"location": {"col": 45, "file": 38, "line": 115}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/pdns/dnsseckeeper.hh", "reportHash": "5340614a84c635f848a6b580d9dca3da", "checkerName": "readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 39, "file": 3, "line": 509}, "message": "default parameter was declared here"}, {"location": {"col": 33, "file": 38, "line": 116}, "message": "calling a function that uses a default argument is disallowed"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/pdns/dnsseckeeper.hh", "reportHash": "aa944b850e019321ca38483d9177ca93", "checkerName": "fuchsia-default-arguments", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 48, "file": 38, "line": 116}, "message": "{ (fixit)"}, {"location": {"col": 47, "file": 38, "line": 116}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/pdns/dnsseckeeper.hh", "reportHash": "2a09b417e8fb8142351bdc50b6320d19", "checkerName": "readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 39, "file": 3, "line": 509}, "message": "default parameter was declared here"}, {"location": {"col": 33, "file": 38, "line": 117}, "message": "calling a function that uses a default argument is disallowed"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/pdns/dnsseckeeper.hh", "reportHash": "05fb33ad83fb6f3366d6caa24898ac22", "checkerName": "fuchsia-default-arguments", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 48, "file": 38, "line": 117}, "message": "{ (fixit)"}, {"location": {"col": 47, "file": 38, "line": 117}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/pdns/dnsseckeeper.hh", "reportHash": "a1998a93392909c58dca10cd6b13bbc9", "checkerName": "readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 39, "file": 3, "line": 509}, "message": "default parameter was declared here"}, {"location": {"col": 16, "file": 38, "line": 130}, "message": "calling a function that uses a default argument is disallowed"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/pdns/dnsseckeeper.hh", "reportHash": "72899796cca18bc48146daa85a743364", "checkerName": "fuchsia-default-arguments", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 39, "file": 3, "line": 509}, "message": "default parameter was declared here"}, {"location": {"col": 16, "file": 38, "line": 132}, "message": "calling a function that uses a default argument is disallowed"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/pdns/dnsseckeeper.hh", "reportHash": "bb93d0e9587ead98abb008c5810e4c53", "checkerName": "fuchsia-default-arguments", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 39, "file": 3, "line": 509}, "message": "default parameter was declared here"}, {"location": {"col": 16, "file": 38, "line": 134}, "message": "calling a function that uses a default argument is disallowed"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/pdns/dnsseckeeper.hh", "reportHash": "7c720e39574a866a80e9a72b7ba1e825", "checkerName": "fuchsia-default-arguments", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 39, "file": 3, "line": 509}, "message": "default parameter was declared here"}, {"location": {"col": 16, "file": 38, "line": 136}, "message": "calling a function that uses a default argument is disallowed"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/pdns/dnsseckeeper.hh", "reportHash": "14698da100eb3f6302d231ad0471c012", "checkerName": "fuchsia-default-arguments", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 39, "file": 3, "line": 509}, "message": "default parameter was declared here"}, {"location": {"col": 16, "file": 38, "line": 138}, "message": "calling a function that uses a default argument is disallowed"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/pdns/dnsseckeeper.hh", "reportHash": "c32140eea7a6949c53f8f8a9540af9ae", "checkerName": "fuchsia-default-arguments", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 39, "file": 3, "line": 509}, "message": "default parameter was declared here"}, {"location": {"col": 16, "file": 38, "line": 140}, "message": "calling a function that uses a default argument is disallowed"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/pdns/dnsseckeeper.hh", "reportHash": "57dd8d4510d652704a5c9916c3a3a408", "checkerName": "fuchsia-default-arguments", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 39, "file": 3, "line": 509}, "message": "default parameter was declared here"}, {"location": {"col": 16, "file": 38, "line": 142}, "message": "calling a function that uses a default argument is disallowed"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/pdns/dnsseckeeper.hh", "reportHash": "8ff9224291cb90a5452ef0115ef492da", "checkerName": "fuchsia-default-arguments", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 39, "file": 3, "line": 509}, "message": "default parameter was declared here"}, {"location": {"col": 16, "file": 38, "line": 144}, "message": "calling a function that uses a default argument is disallowed"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/pdns/dnsseckeeper.hh", "reportHash": "261d2bb53619eea1b020a2bb70703e38", "checkerName": "fuchsia-default-arguments", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 39, "file": 3, "line": 509}, "message": "default parameter was declared here"}, {"location": {"col": 16, "file": 38, "line": 146}, "message": "calling a function that uses a default argument is disallowed"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/pdns/dnsseckeeper.hh", "reportHash": "84170f787db62fddfa65cd323059a4a8", "checkerName": "fuchsia-default-arguments", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 39, "file": 3, "line": 509}, "message": "default parameter was declared here"}, {"location": {"col": 16, "file": 38, "line": 148}, "message": "calling a function that uses a default argument is disallowed"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/pdns/dnsseckeeper.hh", "reportHash": "ab63daf8624553b86ea47bad0aedf7ae", "checkerName": "fuchsia-default-arguments", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 39, "file": 3, "line": 509}, "message": "default parameter was declared here"}, {"location": {"col": 16, "file": 38, "line": 150}, "message": "calling a function that uses a default argument is disallowed"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/pdns/dnsseckeeper.hh", "reportHash": "591f2215723da610774d5598e28a8f7c", "checkerName": "fuchsia-default-arguments", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 39, "file": 3, "line": 509}, "message": "default parameter was declared here"}, {"location": {"col": 16, "file": 38, "line": 152}, "message": "calling a function that uses a default argument is disallowed"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/pdns/dnsseckeeper.hh", "reportHash": "40ffa1af9c297053c62a476057be5985", "checkerName": "fuchsia-default-arguments", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 39, "file": 3, "line": 509}, "message": "default parameter was declared here"}, {"location": {"col": 16, "file": 38, "line": 154}, "message": "calling a function that uses a default argument is disallowed"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/pdns/dnsseckeeper.hh", "reportHash": "0ce7e91b43179f3116ea6203da6e6783", "checkerName": "fuchsia-default-arguments", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 39, "file": 3, "line": 509}, "message": "default parameter was declared here"}, {"location": {"col": 16, "file": 38, "line": 156}, "message": "calling a function that uses a default argument is disallowed"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/pdns/dnsseckeeper.hh", "reportHash": "b20432bf1652f3d83057aae26fcee21c", "checkerName": "fuchsia-default-arguments", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 39, "file": 3, "line": 509}, "message": "default parameter was declared here"}, {"location": {"col": 16, "file": 38, "line": 158}, "message": "calling a function that uses a default argument is disallowed"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/pdns/dnsseckeeper.hh", "reportHash": "cb7859890f827d2b1ce304b854f7605a", "checkerName": "fuchsia-default-arguments", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 39, "file": 3, "line": 509}, "message": "default parameter was declared here"}, {"location": {"col": 16, "file": 38, "line": 160}, "message": "calling a function that uses a default argument is disallowed"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/pdns/dnsseckeeper.hh", "reportHash": "8961f2bf77c6349bb4a3931dfc1e5710", "checkerName": "fuchsia-default-arguments", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 39, "file": 3, "line": 509}, "message": "default parameter was declared here"}, {"location": {"col": 16, "file": 38, "line": 162}, "message": "calling a function that uses a default argument is disallowed"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/pdns/dnsseckeeper.hh", "reportHash": "20594af1aabb394de3fa51151dbef801", "checkerName": "fuchsia-default-arguments", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 39, "file": 3, "line": 509}, "message": "default parameter was declared here"}, {"location": {"col": 16, "file": 38, "line": 164}, "message": "calling a function that uses a default argument is disallowed"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/pdns/dnsseckeeper.hh", "reportHash": "d3e693f3951bac9858f50e317bdad943", "checkerName": "fuchsia-default-arguments", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 15, "file": 38, "line": 170}, "message": "{true} (fixit)"}, {"location": {"col": 8, "file": 38, "line": 170}, "message": "use default member initializer for 'd_ourDB'"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/pdns/dnsseckeeper.hh", "reportHash": "ce13ce88689914ba1054ed9db2f9704b", "checkerName": "modernize-use-default-member-init", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 39, "file": 3, "line": 509}, "message": "default parameter was declared here"}, {"location": {"col": 50, "file": 38, "line": 173}, "message": "calling a function that uses a default argument is disallowed"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/pdns/dnsseckeeper.hh", "reportHash": "55c9951ff93d7189111fa6d9b0851c46", "checkerName": "fuchsia-default-arguments", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 3, "file": 38, "line": 178}, "message": "explicit (fixit)"}, {"location": {"col": 3, "file": 38, "line": 178}, "message": "single-argument constructors must be marked explicit to avoid unintentional implicit conversions"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/pdns/dnsseckeeper.hh", "reportHash": "e0d9c4ab5f08c2952795b7c0a0d4c1c1", "checkerName": "hicpp-explicit-conversions", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 17, "file": 38, "line": 184}, "message": "{ (fixit)"}, {"location": {"col": 16, "file": 38, "line": 184}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/pdns/dnsseckeeper.hh", "reportHash": "16ec183f3eedc3a7726b27b165193eb4", "checkerName": "readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 41, "file": 38, "line": 197}, "message": "declaring a parameter with a default argument is disallowed"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/pdns/dnsseckeeper.hh", "reportHash": "32e766b2c8f8faf30305551b9d5b71ac", "checkerName": "fuchsia-default-arguments", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 77, "file": 38, "line": 199}, "message": "non-const reference parameter 'id', make it const or use a pointer"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/pdns/dnsseckeeper.hh", "reportHash": "f432ff8f0e85ea2fafb74e9b22eab601", "checkerName": "google-runtime-references", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 81, "file": 38, "line": 199}, "message": "declaring a parameter with a default argument is disallowed"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/pdns/dnsseckeeper.hh", "reportHash": "a76677d7b69820d4d4d953e713be59ed", "checkerName": "fuchsia-default-arguments", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 93, "file": 38, "line": 199}, "message": "declaring a parameter with a default argument is disallowed"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/pdns/dnsseckeeper.hh", "reportHash": "bf5aa64dc9cfe4c4b5ab783e1dd3aec7", "checkerName": "fuchsia-default-arguments", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 111, "file": 38, "line": 199}, "message": "declaring a parameter with a default argument is disallowed"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/pdns/dnsseckeeper.hh", "reportHash": "fc9221e8a1d7bcde0b7209befa773ccd", "checkerName": "fuchsia-default-arguments", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 75, "file": 38, "line": 200}, "message": "non-const reference parameter 'id', make it const or use a pointer"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/pdns/dnsseckeeper.hh", "reportHash": "33ffc9dc953523aec08a553066608734", "checkerName": "google-runtime-references", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 79, "file": 38, "line": 200}, "message": "declaring a parameter with a default argument is disallowed"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/pdns/dnsseckeeper.hh", "reportHash": "1393895104081e32ba7eb1aee86732b9", "checkerName": "fuchsia-default-arguments", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 97, "file": 38, "line": 200}, "message": "declaring a parameter with a default argument is disallowed"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/pdns/dnsseckeeper.hh", "reportHash": "7d56b8237daa4836d4b6e6bbe20327a8", "checkerName": "fuchsia-default-arguments", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 40, "file": 38, "line": 206}, "message": "declaring a parameter with a default argument is disallowed"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/pdns/dnsseckeeper.hh", "reportHash": "0846409f0e7bf4d8cbcb0dec6f0744ec", "checkerName": "fuchsia-default-arguments", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 44, "file": 38, "line": 208}, "message": "declaring a parameter with a default argument is disallowed"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/pdns/dnsseckeeper.hh", "reportHash": "0dd208db151f661d94820be21ba56651", "checkerName": "fuchsia-default-arguments", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 1, "file": 38, "line": 208}, "message": "note: this fix will not be applied because it overlaps with another fix (fixit)"}, {"location": {"col": 73, "file": 38, "line": 208}, "message": "use nullptr"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/pdns/dnsseckeeper.hh", "reportHash": "4c9d2afb9121dcb553df1e549fcdc6bc", "checkerName": "modernize-use-nullptr", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 76, "file": 38, "line": 208}, "message": "declaring a parameter with a default argument is disallowed"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/pdns/dnsseckeeper.hh", "reportHash": "9502abcd825b25061faf81d51c9229bb", "checkerName": "fuchsia-default-arguments", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 1, "file": 38, "line": 208}, "message": "note: this fix will not be applied because it overlaps with another fix (fixit)"}, {"location": {"col": 89, "file": 38, "line": 208}, "message": "use nullptr"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/pdns/dnsseckeeper.hh", "reportHash": "7ed66b5306c47d77e47e3a35b088acfa", "checkerName": "modernize-use-nullptr", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 69, "file": 38, "line": 209}, "message": "non-const reference parameter 'msg', make it const or use a pointer"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/pdns/dnsseckeeper.hh", "reportHash": "c17838a7cbd7bb21096a58a7896e3e51", "checkerName": "google-runtime-references", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 80, "file": 38, "line": 210}, "message": "declaring a parameter with a default argument is disallowed"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/pdns/dnsseckeeper.hh", "reportHash": "d0e02e5ceb8375929f8db6a917c17f3f", "checkerName": "fuchsia-default-arguments", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 35, "file": 38, "line": 212}, "message": "non-const reference parameter 'db', make it const or use a pointer"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/pdns/dnsseckeeper.hh", "reportHash": "9cbfb01b23cd1963abbdbbcb9e4e4f4c", "checkerName": "google-runtime-references", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 182, "file": 38, "line": 212}, "message": "non-const reference parameter 'rrsigs', make it const or use a pointer"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/pdns/dnsseckeeper.hh", "reportHash": "c68c05e1a7a4c1c61053ffee4bb7bf60", "checkerName": "google-runtime-references", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 61, "file": 38, "line": 217}, "message": "non-const reference parameter 'value', make it const or use a pointer"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/pdns/dnsseckeeper.hh", "reportHash": "a6c993a5655d6678598d1f2752c50a2e", "checkerName": "google-runtime-references", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 57, "file": 38, "line": 220}, "message": "non-const reference parameter 'value', make it const or use a pointer"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/pdns/dnsseckeeper.hh", "reportHash": "59a04266defb85f0025766b223cfd521", "checkerName": "google-runtime-references", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 88, "file": 38, "line": 236}, "message": "non-const reference parameter 'value', make it const or use a pointer"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/pdns/dnsseckeeper.hh", "reportHash": "daa27b9ed920b0dde91b41fb4da28e4e", "checkerName": "google-runtime-references", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 79, "file": 38, "line": 237}, "message": "non-const reference parameter 'value', make it const or use a pointer"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/pdns/dnsseckeeper.hh", "reportHash": "84275db2bc1e3081e91197dbce41f676", "checkerName": "google-runtime-references", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 54, "file": 38, "line": 238}, "message": "non-const reference parameter 'value', make it const or use a pointer"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/pdns/dnsseckeeper.hh", "reportHash": "d107c5fcab73fa9ec3dd5c7ae95e5dfb", "checkerName": "google-runtime-references", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 55, "file": 38, "line": 239}, "message": "non-const reference parameter 'error', make it const or use a pointer"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/pdns/dnsseckeeper.hh", "reportHash": "798c800e8654f01d11150e70de7f3488", "checkerName": "google-runtime-references", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 75, "file": 38, "line": 239}, "message": "non-const reference parameter 'info', make it const or use a pointer"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/pdns/dnsseckeeper.hh", "reportHash": "ab213c910d316e0256323a456eb036a1", "checkerName": "google-runtime-references", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 54, "file": 38, "line": 240}, "message": "non-const reference parameter 'error', make it const or use a pointer"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/pdns/dnsseckeeper.hh", "reportHash": "891103f690d77a5c087d54fd8be9b452", "checkerName": "google-runtime-references", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 74, "file": 38, "line": 240}, "message": "non-const reference parameter 'info', make it const or use a pointer"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/pdns/dnsseckeeper.hh", "reportHash": "1532fe89267349d1ac4f9f37a6174c50", "checkerName": "google-runtime-references", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 3, "file": 38, "line": 244}, "message": "use 'using' instead of 'typedef'"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/pdns/dnsseckeeper.hh", "reportHash": "707d355cce748a9d589ea4c03b90c90e", "checkerName": "modernize-use-using", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 5, "file": 38, "line": 250}, "message": "using keys_t = vector<DNSSECKeeper::keymeta_t> (fixit)"}, {"location": {"col": 5, "file": 38, "line": 250}, "message": "use 'using' instead of 'typedef'"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/pdns/dnsseckeeper.hh", "reportHash": "c4acd9aac40433a073ccaf90a1a792ee", "checkerName": "modernize-use-using", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 3, "file": 38, "line": 278}, "message": "use 'using' instead of 'typedef'"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/pdns/dnsseckeeper.hh", "reportHash": "59b4fa56eaf620f416f100e608eb7d54", "checkerName": "modernize-use-using", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 3, "file": 38, "line": 286}, "message": "use 'using' instead of 'typedef'"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/pdns/dnsseckeeper.hh", "reportHash": "59b4fa56eaf620f416f100e608eb7d54", "checkerName": "modernize-use-using", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 40, "file": 38, "line": 305}, "message": "/*unused*/ (fixit)"}, {"location": {"col": 39, "file": 38, "line": 305}, "message": "all parameters should be named in a function"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/pdns/dnsseckeeper.hh", "reportHash": "0bd0ecf7e832fa087a3f25f50adbcb49", "checkerName": "readability-named-parameter", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 41, "file": 38, "line": 308}, "message": "/*unused*/ (fixit)"}, {"location": {"col": 40, "file": 38, "line": 308}, "message": "all parameters should be named in a function"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/pdns/dnsseckeeper.hh", "reportHash": "c1d0241358cb8c79ab36d2a5ab87938f", "checkerName": "readability-named-parameter", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 62, "file": 38, "line": 316}, "message": "non-const reference parameter 'dk', make it const or use a pointer"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/pdns/dnsseckeeper.hh", "reportHash": "6bcff2e9e9beea666ff7d704ebc8692a", "checkerName": "google-runtime-references", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 43, "file": 38, "line": 319}, "message": "non-const reference parameter 'dr', make it const or use a pointer"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/pdns/dnsseckeeper.hh", "reportHash": "fae1851dfd8a39edc5f017d9d7a2bd98", "checkerName": "google-runtime-references", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 38, "file": 38, "line": 320}, "message": "non-const reference parameter 'sd', make it const or use a pointer"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/pdns/dnsseckeeper.hh", "reportHash": "780a45375287447e972ce7c136e1cd40", "checkerName": "google-runtime-references", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 113, "file": 38, "line": 320}, "message": "non-const reference parameter 'rrout', make it const or use a pointer"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/pdns/dnsseckeeper.hh", "reportHash": "366dbbd832789839274bf989963a4f98", "checkerName": "google-runtime-references", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 56, "file": 38, "line": 321}, "message": "non-const reference parameter 'dk', make it const or use a pointer"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/pdns/dnsseckeeper.hh", "reportHash": "527c8ff82a5f24b92ceb20114249d642", "checkerName": "google-runtime-references", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 79, "file": 38, "line": 321}, "message": "declaring a parameter with a default argument is disallowed"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/pdns/dnsseckeeper.hh", "reportHash": "1e8730f5c44a11a1664e251104ed5f35", "checkerName": "fuchsia-default-arguments", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 21, "file": 29, "line": 403}, "message": "expanded from macro 'htonl'"}, {"location": {"col": 8, "file": 30, "line": 61}, "message": "expanded from macro '__bswap_32'"}, {"location": {"col": 17, "file": 31, "line": 96}, "message": "do not call c-style vararg functions"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/pdns/dnswriter.hh", "reportHash": "b3cdfb7df1f43fec6a6251b1243f1b37", "checkerName": "hicpp-vararg", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 21, "file": 29, "line": 403}, "message": "expanded from macro 'htonl'"}, {"location": {"col": 12, "file": 30, "line": 62}, "message": "expanded from macro '__bswap_32'"}, {"location": {"col": 8, "file": 30, "line": 39}, "message": "expanded from macro '__bswap_constant_32'"}, {"location": {"col": 17, "file": 31, "line": 96}, "message": "use of a signed integer operand with a binary bitwise operator"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/pdns/dnswriter.hh", "reportHash": "b764731eb71092d363c749b191be6c1f", "checkerName": "hicpp-signed-bitwise", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 10, "file": 39, "line": 25}, "message": "\"arguments.hh\" (fixit)"}, {"location": {"col": 1, "file": 39, "line": 25}, "message": "#includes are not sorted properly"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/pdns/dynhandler.cc", "reportHash": "5a77828e4b2422d1a599cfb227132c45", "checkerName": "llvm-include-order", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 1, "file": 39, "line": 34}, "message": "note: this fix will not be applied because it overlaps with another fix (fixit)"}, {"location": {"col": 10, "file": 39, "line": 34}, "message": "inclusion of deprecated C++ header 'signal.h'; consider using 'csignal' instead"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/pdns/dynhandler.cc", "reportHash": "f64e677e494281fd23b0810244467522", "checkerName": "hicpp-deprecated-headers", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 22, "file": 40, "line": 98}, "message": "previously declared here"}, {"location": {"col": 22, "file": 39, "line": 43}, "message": "redundant 'g_rs' declaration"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/pdns/dynhandler.cc", "reportHash": "7c8215ab9aa81830e611f8ce843e4867", "checkerName": "readability-redundant-declaration", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 66, "file": 39, "line": 53}, "message": "/*ppid*/ (fixit)"}, {"location": {"col": 65, "file": 39, "line": 53}, "message": "parameter 'ppid' is unused"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/pdns/dynhandler.cc", "reportHash": "d48a4cfa793986f8531fcea56d923a95", "checkerName": "misc-unused-parameters", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 39, "file": 3, "line": 509}, "message": "default parameter was declared here"}, {"location": {"col": 14, "file": 39, "line": 55}, "message": "calling a function that uses a default argument is disallowed"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/pdns/dynhandler.cc", "reportHash": "99277f12d9a353e735e9b69eb1a38229", "checkerName": "fuchsia-default-arguments", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 24, "file": 39, "line": 64}, "message": "/*unused*/ (fixit)"}, {"location": {"col": 23, "file": 39, "line": 64}, "message": "all parameters should be named in a function"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/pdns/dynhandler.cc", "reportHash": "bb5b0f6fa1218ec8d87d5d9292a73031", "checkerName": "readability-named-parameter", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 75, "file": 39, "line": 69}, "message": "/*ppid*/ (fixit)"}, {"location": {"col": 74, "file": 39, "line": 69}, "message": "parameter 'ppid' is unused"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/pdns/dynhandler.cc", "reportHash": "f3395aee9b6e3afb0ee097f1abd288a6", "checkerName": "misc-unused-parameters", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 39, "file": 3, "line": 509}, "message": "default parameter was declared here"}, {"location": {"col": 12, "file": 39, "line": 75}, "message": "calling a function that uses a default argument is disallowed"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/pdns/dynhandler.cc", "reportHash": "0b763ae0343d7da73c5ac5a052140189", "checkerName": "fuchsia-default-arguments", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 45, "file": 39, "line": 80}, "message": "/*parts*/ (fixit)"}, {"location": {"col": 44, "file": 39, "line": 80}, "message": "parameter 'parts' is unused"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/pdns/dynhandler.cc", "reportHash": "c96dcca112c537891b78f5c43c3db2f5", "checkerName": "misc-unused-parameters", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 67, "file": 39, "line": 80}, "message": "/*ppid*/ (fixit)"}, {"location": {"col": 66, "file": 39, "line": 80}, "message": "parameter 'ppid' is unused"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/pdns/dynhandler.cc", "reportHash": "2bef9dae758f16e9e7e44dedde5d951b", "checkerName": "misc-unused-parameters", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 39, "file": 3, "line": 509}, "message": "default parameter was declared here"}, {"location": {"col": 10, "file": 39, "line": 84}, "message": "calling a function that uses a default argument is disallowed"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/pdns/dynhandler.cc", "reportHash": "e0f96440c09c42549cdc772ed48ddde5", "checkerName": "fuchsia-default-arguments", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 44, "file": 39, "line": 87}, "message": "/*parts*/ (fixit)"}, {"location": {"col": 43, "file": 39, "line": 87}, "message": "parameter 'parts' is unused"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/pdns/dynhandler.cc", "reportHash": "b0e6d268a2ca300a7e5b01132a40061e", "checkerName": "misc-unused-parameters", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 66, "file": 39, "line": 87}, "message": "/*ppid*/ (fixit)"}, {"location": {"col": 65, "file": 39, "line": 87}, "message": "parameter 'ppid' is unused"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/pdns/dynhandler.cc", "reportHash": "3c892c38cf7d9ac92f3d53e04d4014ca", "checkerName": "misc-unused-parameters", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 39, "file": 3, "line": 509}, "message": "default parameter was declared here"}, {"location": {"col": 10, "file": 39, "line": 89}, "message": "calling a function that uses a default argument is disallowed"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/pdns/dynhandler.cc", "reportHash": "8e6cc16d37f90f1b7fc410892433bbb5", "checkerName": "fuchsia-default-arguments", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 66, "file": 39, "line": 92}, "message": "/*ppid*/ (fixit)"}, {"location": {"col": 65, "file": 39, "line": 92}, "message": "parameter 'ppid' is unused"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/pdns/dynhandler.cc", "reportHash": "5a546b15dc378c5c1eccc5d029dba0e0", "checkerName": "misc-unused-parameters", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 16, "file": 17, "line": 38}, "message": "previously declared here"}, {"location": {"col": 20, "file": 39, "line": 94}, "message": "redundant 'S' declaration"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/pdns/dynhandler.cc", "reportHash": "5f851d176c876e3ba42f3bddf2861520", "checkerName": "readability-redundant-declaration", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 39, "file": 3, "line": 509}, "message": "default parameter was declared here"}, {"location": {"col": 12, "file": 39, "line": 95}, "message": "calling a function that uses a default argument is disallowed"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/pdns/dynhandler.cc", "reportHash": "1cf18049cf595c7afdf218799d336adf", "checkerName": "fuchsia-default-arguments", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 28, "file": 39, "line": 97}, "message": "{ (fixit)"}, {"location": {"col": 27, "file": 39, "line": 97}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/pdns/dynhandler.cc", "reportHash": "ed6aa9b7ce77bcb8fa4f3f892dcb13d1", "checkerName": "readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 12, "file": 39, "line": 99}, "message": "{ (fixit)"}, {"location": {"col": 11, "file": 39, "line": 99}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/pdns/dynhandler.cc", "reportHash": "75ae6a228747d3f68e7e6525e651bfa9", "checkerName": "readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 39, "file": 3, "line": 509}, "message": "default parameter was declared here"}, {"location": {"col": 12, "file": 39, "line": 106}, "message": "calling a function that uses a default argument is disallowed"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/pdns/dynhandler.cc", "reportHash": "9800e26102a0cffb48ab5aaa3dcd5b48", "checkerName": "fuchsia-default-arguments", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 46, "file": 39, "line": 115}, "message": "/*parts*/ (fixit)"}, {"location": {"col": 45, "file": 39, "line": 115}, "message": "parameter 'parts' is unused"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/pdns/dynhandler.cc", "reportHash": "32ac7b4a9363304857c8cce09aac566e", "checkerName": "misc-unused-parameters", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 27, "file": 27, "line": 560}, "message": "default parameter was declared here"}, {"location": {"col": 17, "file": 39, "line": 117}, "message": "calling a function that uses a default argument is disallowed"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/pdns/dynhandler.cc", "reportHash": "a2be9f5f13b8b774eb0866919076d7f3", "checkerName": "fuchsia-default-arguments", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 46, "file": 39, "line": 122}, "message": "/*parts*/ (fixit)"}, {"location": {"col": 45, "file": 39, "line": 122}, "message": "parameter 'parts' is unused"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/pdns/dynhandler.cc", "reportHash": "178e8136d4598bf15f19d7354eafc937", "checkerName": "misc-unused-parameters", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 68, "file": 39, "line": 122}, "message": "/*ppid*/ (fixit)"}, {"location": {"col": 67, "file": 39, "line": 122}, "message": "parameter 'ppid' is unused"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/pdns/dynhandler.cc", "reportHash": "5a8cc074f5153130aa438f13466b702e", "checkerName": "misc-unused-parameters", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 27, "file": 27, "line": 560}, "message": "default parameter was declared here"}, {"location": {"col": 17, "file": 39, "line": 124}, "message": "calling a function that uses a default argument is disallowed"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/pdns/dynhandler.cc", "reportHash": "a2be9f5f13b8b774eb0866919076d7f3", "checkerName": "fuchsia-default-arguments", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 26, "file": 39, "line": 125}, "message": "nullptr (fixit)"}, {"location": {"col": 26, "file": 39, "line": 125}, "message": "use nullptr"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/pdns/dynhandler.cc", "reportHash": "89ca9b6016ff0ca5c3e9b686ff61e421", "checkerName": "hicpp-use-nullptr", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 67, "file": 39, "line": 129}, "message": "/*ppid*/ (fixit)"}, {"location": {"col": 66, "file": 39, "line": 129}, "message": "parameter 'ppid' is unused"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/pdns/dynhandler.cc", "reportHash": "c06d768450bbf6ecd57fe3c1ee8c7853", "checkerName": "misc-unused-parameters", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 27, "file": 27, "line": 560}, "message": "default parameter was declared here"}, {"location": {"col": 17, "file": 39, "line": 131}, "message": "calling a function that uses a default argument is disallowed"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/pdns/dynhandler.cc", "reportHash": "a2be9f5f13b8b774eb0866919076d7f3", "checkerName": "fuchsia-default-arguments", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 10, "file": 39, "line": 135}, "message": "auto (fixit)"}, {"location": {"col": 10, "file": 39, "line": 135}, "message": "use auto when declaring iterators"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/pdns/dynhandler.cc", "reportHash": "99ae2ba61dc936633e24de45ff76b34f", "checkerName": "hicpp-use-auto", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 38, "file": 39, "line": 138}, "message": "{ (fixit)"}, {"location": {"col": 37, "file": 39, "line": 138}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/pdns/dynhandler.cc", "reportHash": "e954752a260ec21d046e221480880177", "checkerName": "google-readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 12, "file": 39, "line": 140}, "message": "{ (fixit)"}, {"location": {"col": 11, "file": 39, "line": 140}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/pdns/dynhandler.cc", "reportHash": "246c0f607b61eda90495989b9c24db39", "checkerName": "google-readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 42, "file": 39, "line": 154}, "message": "/*parts*/ (fixit)"}, {"location": {"col": 41, "file": 39, "line": 154}, "message": "parameter 'parts' is unused"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/pdns/dynhandler.cc", "reportHash": "55abaa2aef375420ba5a34f1b8ea4847", "checkerName": "misc-unused-parameters", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 64, "file": 39, "line": 154}, "message": "/*ppid*/ (fixit)"}, {"location": {"col": 63, "file": 39, "line": 154}, "message": "parameter 'ppid' is unused"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/pdns/dynhandler.cc", "reportHash": "c0d7143ee5552da8e1ef1f72e237e8d9", "checkerName": "misc-unused-parameters", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 24, "file": 17, "line": 39}, "message": "previously declared here"}, {"location": {"col": 26, "file": 39, "line": 156}, "message": "redundant 'PC' declaration"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/pdns/dynhandler.cc", "reportHash": "e9eac306f45a075450c42599306ccf19", "checkerName": "readability-redundant-declaration", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 23, "file": 17, "line": 40}, "message": "previously declared here"}, {"location": {"col": 25, "file": 39, "line": 157}, "message": "redundant 'QC' declaration"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/pdns/dynhandler.cc", "reportHash": "5cb1d119db1ca2ebf673548a04619d19", "checkerName": "readability-redundant-declaration", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 27, "file": 27, "line": 560}, "message": "default parameter was declared here"}, {"location": {"col": 17, "file": 39, "line": 160}, "message": "calling a function that uses a default argument is disallowed"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/pdns/dynhandler.cc", "reportHash": "a2be9f5f13b8b774eb0866919076d7f3", "checkerName": "fuchsia-default-arguments", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 16, "file": 39, "line": 163}, "message": "{ (fixit)"}, {"location": {"col": 15, "file": 39, "line": 163}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/pdns/dynhandler.cc", "reportHash": "3733f0a419da65906481dbefc6d7b838", "checkerName": "google-readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 23, "file": 39, "line": 167}, "message": "{ (fixit)"}, {"location": {"col": 22, "file": 39, "line": 167}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/pdns/dynhandler.cc", "reportHash": "82b02870e0a5632431fcb403bc181cdd", "checkerName": "google-readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 28, "file": 39, "line": 169}, "message": "{ (fixit)"}, {"location": {"col": 27, "file": 39, "line": 169}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/pdns/dynhandler.cc", "reportHash": "e46fff456f1b306aa84f45a29027c5dc", "checkerName": "google-readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 10, "file": 39, "line": 171}, "message": "{ (fixit)"}, {"location": {"col": 9, "file": 39, "line": 171}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/pdns/dynhandler.cc", "reportHash": "661acd9298a8d0d3be9da7eb1682c532", "checkerName": "readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 46, "file": 39, "line": 181}, "message": "/*parts*/ (fixit)"}, {"location": {"col": 45, "file": 39, "line": 181}, "message": "parameter 'parts' is unused"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/pdns/dynhandler.cc", "reportHash": "ceb88e4c4179e250e656c248960fa4f6", "checkerName": "misc-unused-parameters", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 68, "file": 39, "line": 181}, "message": "/*ppid*/ (fixit)"}, {"location": {"col": 67, "file": 39, "line": 181}, "message": "parameter 'ppid' is unused"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/pdns/dynhandler.cc", "reportHash": "9a662bd01c5f23012ab410ead80a42dc", "checkerName": "misc-unused-parameters", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 46, "file": 39, "line": 186}, "message": "/*parts*/ (fixit)"}, {"location": {"col": 45, "file": 39, "line": 186}, "message": "parameter 'parts' is unused"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/pdns/dynhandler.cc", "reportHash": "0034fac07f3d5e76d65ac0061c8760af", "checkerName": "misc-unused-parameters", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 68, "file": 39, "line": 186}, "message": "/*ppid*/ (fixit)"}, {"location": {"col": 67, "file": 39, "line": 186}, "message": "parameter 'ppid' is unused"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/pdns/dynhandler.cc", "reportHash": "66a77fe69f2b55539e70df39b7289c2c", "checkerName": "misc-unused-parameters", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 3, "file": 39, "line": 188}, "message": "use 'using' instead of 'typedef'"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/pdns/dynhandler.cc", "reportHash": "b49fb4b6cbcff51bc8221cf8c2e4f58f", "checkerName": "modernize-use-using", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 27, "file": 27, "line": 560}, "message": "default parameter was declared here"}, {"location": {"col": 17, "file": 39, "line": 190}, "message": "calling a function that uses a default argument is disallowed"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/pdns/dynhandler.cc", "reportHash": "a2be9f5f13b8b774eb0866919076d7f3", "checkerName": "fuchsia-default-arguments", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 47, "file": 39, "line": 198}, "message": "/*parts*/ (fixit)"}, {"location": {"col": 46, "file": 39, "line": 198}, "message": "parameter 'parts' is unused"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/pdns/dynhandler.cc", "reportHash": "3d08e315dc0684a954e4b1250bb8cd75", "checkerName": "misc-unused-parameters", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 69, "file": 39, "line": 198}, "message": "/*ppid*/ (fixit)"}, {"location": {"col": 68, "file": 39, "line": 198}, "message": "parameter 'ppid' is unused"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/pdns/dynhandler.cc", "reportHash": "acc19fc5db523010c57befbcfa0225d1", "checkerName": "misc-unused-parameters", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 20, "file": 39, "line": 94}, "message": "previously declared here"}, {"location": {"col": 18, "file": 39, "line": 200}, "message": "redundant 'S' declaration"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/pdns/dynhandler.cc", "reportHash": "6735a7abe6668cec0cd639a49b19686f", "checkerName": "readability-redundant-declaration", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 3, "file": 39, "line": 201}, "message": "use 'using' instead of 'typedef'"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/pdns/dynhandler.cc", "reportHash": "92135ecabcda9e08e08b6c937d9fed35", "checkerName": "modernize-use-using", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 39, "file": 3, "line": 509}, "message": "default parameter was declared here"}, {"location": {"col": 31, "file": 39, "line": 202}, "message": "calling a function that uses a default argument is disallowed"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/pdns/dynhandler.cc", "reportHash": "ba5bb800d90d615203797c07e912d0af", "checkerName": "fuchsia-default-arguments", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 70, "file": 39, "line": 211}, "message": "/*ppid*/ (fixit)"}, {"location": {"col": 69, "file": 39, "line": 211}, "message": "parameter 'ppid' is unused"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/pdns/dynhandler.cc", "reportHash": "add11d22af13612eec15b864af6f3d77", "checkerName": "misc-unused-parameters", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 51, "file": 39, "line": 213}, "message": "nullptr (fixit)"}, {"location": {"col": 51, "file": 39, "line": 213}, "message": "use nullptr"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/pdns/dynhandler.cc", "reportHash": "bffa1bdc5abd9196b2a1035a04258af3", "checkerName": "modernize-use-nullptr", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 39, "file": 3, "line": 509}, "message": "default parameter was declared here"}, {"location": {"col": 12, "file": 39, "line": 217}, "message": "calling a function that uses a default argument is disallowed"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/pdns/dynhandler.cc", "reportHash": "d781f07cea82997144945cf88af44eea", "checkerName": "fuchsia-default-arguments", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 9, "file": 39, "line": 220}, "message": "do not implicitly decay an array into a pointer; consider using gsl::array_view or an explicit cast instead"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/pdns/dynhandler.cc", "reportHash": "c9f1e7adbdbfce50e96cdeb26911382c", "checkerName": "hicpp-no-array-decay", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 22, "file": 39, "line": 220}, "message": "!= nullptr (fixit)"}, {"location": {"col": 19, "file": 39, "line": 220}, "message": "implicit conversion 'const char *' -> bool"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/pdns/dynhandler.cc", "reportHash": "efd68f41f5449654210c3bb110c0d6d2", "checkerName": "readability-implicit-bool-conversion", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 23, "file": 39, "line": 220}, "message": "do not use pointer arithmetic"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/pdns/dynhandler.cc", "reportHash": "9f882406c2e0268cdc3b719c56b8012f", "checkerName": "cppcoreguidelines-pro-bounds-pointer-arithmetic", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 27, "file": 39, "line": 220}, "message": "{ (fixit)"}, {"location": {"col": 26, "file": 39, "line": 220}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/pdns/dynhandler.cc", "reportHash": "36702c1d09caf04d8b31472ebf39df03", "checkerName": "google-readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 22, "file": 39, "line": 221}, "message": "{ (fixit)"}, {"location": {"col": 21, "file": 39, "line": 221}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/pdns/dynhandler.cc", "reportHash": "67cbbb12cd363197c859e9dcdf6a4968", "checkerName": "google-readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 9, "file": 39, "line": 223}, "message": "!= nullptr (fixit)"}, {"location": {"col": 6, "file": 39, "line": 223}, "message": "implicit conversion 'const char *' -> bool"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/pdns/dynhandler.cc", "reportHash": "41307a90326f385e90ca44b7314b72db", "checkerName": "readability-implicit-bool-conversion", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 39, "file": 3, "line": 509}, "message": "default parameter was declared here"}, {"location": {"col": 12, "file": 39, "line": 226}, "message": "calling a function that uses a default argument is disallowed"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/pdns/dynhandler.cc", "reportHash": "02006324cb83b7107904ae14bd70fca9", "checkerName": "fuchsia-default-arguments", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 3, "file": 39, "line": 228}, "message": "do not use 'else' after 'return'"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/pdns/dynhandler.cc", "reportHash": "ac515c621d1d08de64d3c9a8dc8ec67c", "checkerName": "readability-else-after-return", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 8, "file": 39, "line": 228}, "message": "{ (fixit)"}, {"location": {"col": 7, "file": 39, "line": 228}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/pdns/dynhandler.cc", "reportHash": "f8d9a3d0ad64a33103ea6e6b3cef4b9d", "checkerName": "hicpp-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 39, "file": 3, "line": 509}, "message": "default parameter was declared here"}, {"location": {"col": 12, "file": 39, "line": 229}, "message": "calling a function that uses a default argument is disallowed"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/pdns/dynhandler.cc", "reportHash": "f5255a2c241d75b393b959ac84c90520", "checkerName": "fuchsia-default-arguments", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 47, "file": 39, "line": 233}, "message": "/*parts*/ (fixit)"}, {"location": {"col": 46, "file": 39, "line": 233}, "message": "parameter 'parts' is unused"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/pdns/dynhandler.cc", "reportHash": "7a9907709babf83b6f4a305c74e25b2e", "checkerName": "misc-unused-parameters", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 69, "file": 39, "line": 233}, "message": "/*ppid*/ (fixit)"}, {"location": {"col": 68, "file": 39, "line": 233}, "message": "parameter 'ppid' is unused"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/pdns/dynhandler.cc", "reportHash": "831c21cd32c6131c24d934dc66463bb4", "checkerName": "misc-unused-parameters", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 17, "file": 0, "line": 402}, "message": "expanded from macro 'VERSION'"}, {"location": {"col": 39, "file": 3, "line": 509}, "message": "default parameter was declared here"}, {"location": {"col": 10, "file": 39, "line": 235}, "message": "calling a function that uses a default argument is disallowed"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/pdns/dynhandler.cc", "reportHash": "e915ccdae62ca42100920a4c163106e5", "checkerName": "fuchsia-default-arguments", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 76, "file": 39, "line": 238}, "message": "/*ppid*/ (fixit)"}, {"location": {"col": 75, "file": 39, "line": 238}, "message": "parameter 'ppid' is unused"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/pdns/dynhandler.cc", "reportHash": "6b4f6770446f5323e967984ecff0cc67", "checkerName": "misc-unused-parameters", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 26, "file": 17, "line": 43}, "message": "previously declared here"}, {"location": {"col": 28, "file": 39, "line": 240}, "message": "redundant 'Communicator' declaration"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/pdns/dynhandler.cc", "reportHash": "76d16504dfaa130ef0a9438407e0b4e3", "checkerName": "readability-redundant-declaration", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 27, "file": 27, "line": 560}, "message": "default parameter was declared here"}, {"location": {"col": 17, "file": 39, "line": 241}, "message": "calling a function that uses a default argument is disallowed"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/pdns/dynhandler.cc", "reportHash": "a2be9f5f13b8b774eb0866919076d7f3", "checkerName": "fuchsia-default-arguments", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 42, "file": 39, "line": 242}, "message": "{ (fixit)"}, {"location": {"col": 41, "file": 39, "line": 242}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/pdns/dynhandler.cc", "reportHash": "cba3f5b290f05df21708c72889a42b80", "checkerName": "google-readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 39, "file": 3, "line": 509}, "message": "default parameter was declared here"}, {"location": {"col": 12, "file": 39, "line": 243}, "message": "calling a function that uses a default argument is disallowed"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/pdns/dynhandler.cc", "reportHash": "30dc3ca3ef38795379bf00fa6c0008e8", "checkerName": "fuchsia-default-arguments", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 39, "file": 3, "line": 509}, "message": "default parameter was declared here"}, {"location": {"col": 12, "file": 39, "line": 249}, "message": "calling a function that uses a default argument is disallowed"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/pdns/dynhandler.cc", "reportHash": "e25956039a032c42a4d9875ec94e720c", "checkerName": "fuchsia-default-arguments", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 39, "file": 3, "line": 509}, "message": "default parameter was declared here"}, {"location": {"col": 14, "file": 39, "line": 258}, "message": "calling a function that uses a default argument is disallowed"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/pdns/dynhandler.cc", "reportHash": "7862425f032ca9ba0b256d89b5fd10be", "checkerName": "fuchsia-default-arguments", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 16, "file": 21, "line": 46}, "message": "default parameter was declared here"}, {"location": {"col": 16, "file": 39, "line": 264}, "message": "calling a function that uses a default argument is disallowed"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/pdns/dynhandler.cc", "reportHash": "d94f2895a1ce83cbfc15154aea0be2c8", "checkerName": "fuchsia-default-arguments", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 61, "file": 21, "line": 108}, "message": "default parameter was declared here"}, {"location": {"col": 7, "file": 39, "line": 265}, "message": "calling a function that uses a default argument is disallowed"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/pdns/dynhandler.cc", "reportHash": "605e86f6bd9eb951488234a1894af78b", "checkerName": "fuchsia-default-arguments", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 58, "file": 13, "line": 92}, "message": "default parameter was declared here"}, {"location": {"col": 24, "file": 39, "line": 266}, "message": "calling a function that uses a default argument is disallowed"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/pdns/dynhandler.cc", "reportHash": "032fa73ab65d993e96197ed7fee3778c", "checkerName": "fuchsia-default-arguments", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 80, "file": 39, "line": 274}, "message": "{ (fixit)"}, {"location": {"col": 79, "file": 39, "line": 274}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/pdns/dynhandler.cc", "reportHash": "45a51c52fe7eb79436dd858f4ab95258", "checkerName": "readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 24, "file": 13, "line": 92}, "message": "default parameter was declared here"}, {"location": {"col": 23, "file": 39, "line": 275}, "message": "calling a function that uses a default argument is disallowed"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/pdns/dynhandler.cc", "reportHash": "3dffea509b63b99d801442b9e26bdc94", "checkerName": "fuchsia-default-arguments", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 87, "file": 39, "line": 281}, "message": "do not access members of unions; use (boost::)variant instead"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/pdns/dynhandler.cc", "reportHash": "1d7634529437ce59489e367fa4d73ce9", "checkerName": "cppcoreguidelines-pro-type-union-access", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 72, "file": 39, "line": 284}, "message": "/*ppid*/ (fixit)"}, {"location": {"col": 71, "file": 39, "line": 284}, "message": "parameter 'ppid' is unused"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/pdns/dynhandler.cc", "reportHash": "de2e106e9fe33b081201e2e044011c5f", "checkerName": "misc-unused-parameters", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 28, "file": 39, "line": 240}, "message": "previously declared here"}, {"location": {"col": 28, "file": 39, "line": 286}, "message": "redundant 'Communicator' declaration"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/pdns/dynhandler.cc", "reportHash": "76d16504dfaa130ef0a9438407e0b4e3", "checkerName": "readability-redundant-declaration", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 27, "file": 27, "line": 560}, "message": "default parameter was declared here"}, {"location": {"col": 17, "file": 39, "line": 287}, "message": "calling a function that uses a default argument is disallowed"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/pdns/dynhandler.cc", "reportHash": "a2be9f5f13b8b774eb0866919076d7f3", "checkerName": "fuchsia-default-arguments", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 23, "file": 39, "line": 288}, "message": "{ (fixit)"}, {"location": {"col": 22, "file": 39, "line": 288}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/pdns/dynhandler.cc", "reportHash": "8716d4803dbd3a15c66283d5afc5bc3d", "checkerName": "hicpp-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 39, "file": 3, "line": 509}, "message": "default parameter was declared here"}, {"location": {"col": 12, "file": 39, "line": 289}, "message": "calling a function that uses a default argument is disallowed"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/pdns/dynhandler.cc", "reportHash": "f9b912772e79a8ab916ab25c2e893792", "checkerName": "fuchsia-default-arguments", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 39, "file": 3, "line": 509}, "message": "default parameter was declared here"}, {"location": {"col": 22, "file": 39, "line": 290}, "message": "calling a function that uses a default argument is disallowed"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/pdns/dynhandler.cc", "reportHash": "915a32b742e0db88feac3587aace4e2d", "checkerName": "fuchsia-default-arguments", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 39, "file": 3, "line": 509}, "message": "default parameter was declared here"}, {"location": {"col": 52, "file": 39, "line": 290}, "message": "calling a function that uses a default argument is disallowed"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/pdns/dynhandler.cc", "reportHash": "7743e59c38cd9bd98c32f354255973f8", "checkerName": "fuchsia-default-arguments", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 39, "file": 3, "line": 509}, "message": "default parameter was declared here"}, {"location": {"col": 79, "file": 39, "line": 290}, "message": "calling a function that uses a default argument is disallowed"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/pdns/dynhandler.cc", "reportHash": "0ba46176721c403a191237bf51969f4d", "checkerName": "fuchsia-default-arguments", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 99, "file": 39, "line": 290}, "message": "{ (fixit)"}, {"location": {"col": 98, "file": 39, "line": 290}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/pdns/dynhandler.cc", "reportHash": "f279658d1b83123ecc9844ccde6316e2", "checkerName": "google-readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 39, "file": 3, "line": 509}, "message": "default parameter was declared here"}, {"location": {"col": 14, "file": 39, "line": 291}, "message": "calling a function that uses a default argument is disallowed"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/pdns/dynhandler.cc", "reportHash": "c89ca4a4d17e2e05298a30a2d0922b8c", "checkerName": "fuchsia-default-arguments", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 39, "file": 3, "line": 509}, "message": "default parameter was declared here"}, {"location": {"col": 12, "file": 39, "line": 297}, "message": "calling a function that uses a default argument is disallowed"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/pdns/dynhandler.cc", "reportHash": "e25956039a032c42a4d9875ec94e720c", "checkerName": "fuchsia-default-arguments", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 44, "file": 20, "line": 211}, "message": "default parameter was declared here"}, {"location": {"col": 18, "file": 39, "line": 301}, "message": "calling a function that uses a default argument is disallowed"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/pdns/dynhandler.cc", "reportHash": "564a83f631926f01c9cdbacf4144f7df", "checkerName": "fuchsia-default-arguments", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 39, "file": 3, "line": 509}, "message": "default parameter was declared here"}, {"location": {"col": 10, "file": 39, "line": 309}, "message": "calling a function that uses a default argument is disallowed"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/pdns/dynhandler.cc", "reportHash": "d6b2127f7e2767bc443ea19af06b9536", "checkerName": "fuchsia-default-arguments", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 68, "file": 39, "line": 312}, "message": "/*ppid*/ (fixit)"}, {"location": {"col": 67, "file": 39, "line": 312}, "message": "parameter 'ppid' is unused"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/pdns/dynhandler.cc", "reportHash": "9db14df40eba6884dd7a43c121544c62", "checkerName": "misc-unused-parameters", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 28, "file": 39, "line": 286}, "message": "previously declared here"}, {"location": {"col": 28, "file": 39, "line": 314}, "message": "redundant 'Communicator' declaration"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/pdns/dynhandler.cc", "reportHash": "76d16504dfaa130ef0a9438407e0b4e3", "checkerName": "readability-redundant-declaration", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 16, "file": 21, "line": 46}, "message": "default parameter was declared here"}, {"location": {"col": 16, "file": 39, "line": 315}, "message": "calling a function that uses a default argument is disallowed"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/pdns/dynhandler.cc", "reportHash": "d94f2895a1ce83cbfc15154aea0be2c8", "checkerName": "fuchsia-default-arguments", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 23, "file": 39, "line": 316}, "message": "{ (fixit)"}, {"location": {"col": 22, "file": 39, "line": 316}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/pdns/dynhandler.cc", "reportHash": "1496d7349eb01aab500953964910a3e4", "checkerName": "readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 39, "file": 3, "line": 509}, "message": "default parameter was declared here"}, {"location": {"col": 12, "file": 39, "line": 317}, "message": "calling a function that uses a default argument is disallowed"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/pdns/dynhandler.cc", "reportHash": "46c16c9f0e1f447d89a4dcedd4cb3370", "checkerName": "fuchsia-default-arguments", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 39, "file": 3, "line": 509}, "message": "default parameter was declared here"}, {"location": {"col": 22, "file": 39, "line": 318}, "message": "calling a function that uses a default argument is disallowed"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/pdns/dynhandler.cc", "reportHash": "915a32b742e0db88feac3587aace4e2d", "checkerName": "fuchsia-default-arguments", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 39, "file": 3, "line": 509}, "message": "default parameter was declared here"}, {"location": {"col": 52, "file": 39, "line": 318}, "message": "calling a function that uses a default argument is disallowed"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/pdns/dynhandler.cc", "reportHash": "7743e59c38cd9bd98c32f354255973f8", "checkerName": "fuchsia-default-arguments", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 39, "file": 3, "line": 509}, "message": "default parameter was declared here"}, {"location": {"col": 79, "file": 39, "line": 318}, "message": "calling a function that uses a default argument is disallowed"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/pdns/dynhandler.cc", "reportHash": "0ba46176721c403a191237bf51969f4d", "checkerName": "fuchsia-default-arguments", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 99, "file": 39, "line": 318}, "message": "{ (fixit)"}, {"location": {"col": 98, "file": 39, "line": 318}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/pdns/dynhandler.cc", "reportHash": "f279658d1b83123ecc9844ccde6316e2", "checkerName": "google-readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 39, "file": 3, "line": 509}, "message": "default parameter was declared here"}, {"location": {"col": 14, "file": 39, "line": 319}, "message": "calling a function that uses a default argument is disallowed"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/pdns/dynhandler.cc", "reportHash": "c89ca4a4d17e2e05298a30a2d0922b8c", "checkerName": "fuchsia-default-arguments", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 51, "file": 21, "line": 104}, "message": "default parameter was declared here"}, {"location": {"col": 5, "file": 39, "line": 324}, "message": "calling a function that uses a default argument is disallowed"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/pdns/dynhandler.cc", "reportHash": "6849cf9d75a57adf2b1986e5cc147e35", "checkerName": "fuchsia-default-arguments", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 52, "file": 39, "line": 331}, "message": "{ (fixit)"}, {"location": {"col": 51, "file": 39, "line": 331}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/pdns/dynhandler.cc", "reportHash": "e48ae687d43e9c40825280e59a8fb16e", "checkerName": "readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 28, "file": 39, "line": 336}, "message": "{ (fixit)"}, {"location": {"col": 27, "file": 39, "line": 336}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/pdns/dynhandler.cc", "reportHash": "0ccb763e9dea0289b709782a590ceeac", "checkerName": "hicpp-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 5, "file": 39, "line": 339}, "message": "do not use 'else' after 'return'"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/pdns/dynhandler.cc", "reportHash": "159d0340d46958596459af91f5eb3d51", "checkerName": "readability-else-after-return", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 39, "file": 3, "line": 509}, "message": "default parameter was declared here"}, {"location": {"col": 14, "file": 39, "line": 344}, "message": "calling a function that uses a default argument is disallowed"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/pdns/dynhandler.cc", "reportHash": "996edfb03547f21c53533ac875648fad", "checkerName": "fuchsia-default-arguments", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 59, "file": 39, "line": 346}, "message": "{ (fixit)"}, {"location": {"col": 58, "file": 39, "line": 346}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/pdns/dynhandler.cc", "reportHash": "82f1f4cf771f8e07cb8f43ffad21f2b6", "checkerName": "readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 39, "file": 3, "line": 509}, "message": "default parameter was declared here"}, {"location": {"col": 14, "file": 39, "line": 347}, "message": "calling a function that uses a default argument is disallowed"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/pdns/dynhandler.cc", "reportHash": "56210d3caed8272a7574620d94584558", "checkerName": "fuchsia-default-arguments", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 39, "file": 3, "line": 509}, "message": "default parameter was declared here"}, {"location": {"col": 12, "file": 39, "line": 348}, "message": "calling a function that uses a default argument is disallowed"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/pdns/dynhandler.cc", "reportHash": "933dc2c495ace547b2c76bd730a19a62", "checkerName": "fuchsia-default-arguments", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 50, "file": 39, "line": 352}, "message": "/*parts*/ (fixit)"}, {"location": {"col": 49, "file": 39, "line": 352}, "message": "parameter 'parts' is unused"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/pdns/dynhandler.cc", "reportHash": "3f0489f45696f7e4d9263a10570105cb", "checkerName": "misc-unused-parameters", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 72, "file": 39, "line": 352}, "message": "/*ppid*/ (fixit)"}, {"location": {"col": 71, "file": 39, "line": 352}, "message": "parameter 'ppid' is unused"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/pdns/dynhandler.cc", "reportHash": "3e0981519a4eb77e0d9f5c468df4395a", "checkerName": "misc-unused-parameters", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 16, "file": 21, "line": 46}, "message": "default parameter was declared here"}, {"location": {"col": 16, "file": 39, "line": 354}, "message": "calling a function that uses a default argument is disallowed"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/pdns/dynhandler.cc", "reportHash": "d94f2895a1ce83cbfc15154aea0be2c8", "checkerName": "fuchsia-default-arguments", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 39, "file": 3, "line": 509}, "message": "default parameter was declared here"}, {"location": {"col": 19, "file": 39, "line": 357}, "message": "calling a function that uses a default argument is disallowed"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/pdns/dynhandler.cc", "reportHash": "799c5e18ff6a4dcfe3783d95b79f5232", "checkerName": "fuchsia-default-arguments", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 46, "file": 39, "line": 367}, "message": "/*parts*/ (fixit)"}, {"location": {"col": 45, "file": 39, "line": 367}, "message": "parameter 'parts' is unused"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/pdns/dynhandler.cc", "reportHash": "a95950eb6fb97a2098790c8f64742d06", "checkerName": "misc-unused-parameters", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 68, "file": 39, "line": 367}, "message": "/*ppid*/ (fixit)"}, {"location": {"col": 67, "file": 39, "line": 367}, "message": "parameter 'ppid' is unused"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/pdns/dynhandler.cc", "reportHash": "4d6c9459fbbb3d8badf35f7927466706", "checkerName": "misc-unused-parameters", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 16, "file": 21, "line": 46}, "message": "default parameter was declared here"}, {"location": {"col": 16, "file": 39, "line": 369}, "message": "calling a function that uses a default argument is disallowed"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/pdns/dynhandler.cc", "reportHash": "d94f2895a1ce83cbfc15154aea0be2c8", "checkerName": "fuchsia-default-arguments", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 39, "file": 3, "line": 509}, "message": "default parameter was declared here"}, {"location": {"col": 10, "file": 39, "line": 372}, "message": "calling a function that uses a default argument is disallowed"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/pdns/dynhandler.cc", "reportHash": "32a3b3fc50625a92aa1eb7596ff4cfe5", "checkerName": "fuchsia-default-arguments", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 64, "file": 39, "line": 376}, "message": "/*ppid*/ (fixit)"}, {"location": {"col": 63, "file": 39, "line": 376}, "message": "parameter 'ppid' is unused"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/pdns/dynhandler.cc", "reportHash": "34544922a1e680eb4df186083082f899", "checkerName": "misc-unused-parameters", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 16, "file": 21, "line": 46}, "message": "default parameter was declared here"}, {"location": {"col": 16, "file": 39, "line": 378}, "message": "calling a function that uses a default argument is disallowed"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/pdns/dynhandler.cc", "reportHash": "d94f2895a1ce83cbfc15154aea0be2c8", "checkerName": "fuchsia-default-arguments", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 51, "file": 21, "line": 104}, "message": "default parameter was declared here"}, {"location": {"col": 3, "file": 39, "line": 381}, "message": "calling a function that uses a default argument is disallowed"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/pdns/dynhandler.cc", "reportHash": "d8d75cf7b4d893564f78f64fea4dbb15", "checkerName": "fuchsia-default-arguments", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 27, "file": 27, "line": 560}, "message": "default parameter was declared here"}, {"location": {"col": 17, "file": 39, "line": 382}, "message": "calling a function that uses a default argument is disallowed"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/pdns/dynhandler.cc", "reportHash": "68ca9f3986d72919b18c46c48b6e0ae1", "checkerName": "fuchsia-default-arguments", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 40, "file": 39, "line": 385}, "message": "{ (fixit)"}, {"location": {"col": 39, "file": 39, "line": 385}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/pdns/dynhandler.cc", "reportHash": "30743f0122fd952b76fef59ac1a24e4e", "checkerName": "readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 44, "file": 39, "line": 387}, "message": "{ (fixit)"}, {"location": {"col": 43, "file": 39, "line": 387}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/pdns/dynhandler.cc", "reportHash": "92ef5b27c995a0bab0cf891abe292835", "checkerName": "hicpp-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 45, "file": 39, "line": 389}, "message": "{ (fixit)"}, {"location": {"col": 44, "file": 39, "line": 389}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/pdns/dynhandler.cc", "reportHash": "e52400cad93c7a4eac53164b0f998068", "checkerName": "readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 58, "file": 13, "line": 92}, "message": "default parameter was declared here"}, {"location": {"col": 12, "file": 39, "line": 397}, "message": "calling a function that uses a default argument is disallowed"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/pdns/dynhandler.cc", "reportHash": "778c79ceaf271fd331e1926a2218a5ed", "checkerName": "fuchsia-default-arguments", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 25, "file": 39, "line": 401}, "message": "{ (fixit)"}, {"location": {"col": 24, "file": 39, "line": 401}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/pdns/dynhandler.cc", "reportHash": "e5ba1e1d397c9fc0dcd5f917adc58cf0", "checkerName": "google-readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 8, "file": 39, "line": 403}, "message": "{ (fixit)"}, {"location": {"col": 7, "file": 39, "line": 403}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/pdns/dynhandler.cc", "reportHash": "e8e9654c73b6e296bff1c542a9c60f3d", "checkerName": "google-readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 43, "file": 39, "line": 413}, "message": "/*parts*/ (fixit)"}, {"location": {"col": 42, "file": 39, "line": 413}, "message": "parameter 'parts' is unused"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/pdns/dynhandler.cc", "reportHash": "c09bf11842724f3fb888349201375fb8", "checkerName": "misc-unused-parameters", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 65, "file": 39, "line": 413}, "message": "/*ppid*/ (fixit)"}, {"location": {"col": 64, "file": 39, "line": 413}, "message": "parameter 'ppid' is unused"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/pdns/dynhandler.cc", "reportHash": "570d5dff28e20948cd9b500ef9530ad9", "checkerName": "misc-unused-parameters", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 39, "file": 3, "line": 509}, "message": "default parameter was declared here"}, {"location": {"col": 10, "file": 39, "line": 416}, "message": "calling a function that uses a default argument is disallowed"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/pdns/dynhandler.cc", "reportHash": "aded945b3cf13032c779e8fcb02e9b98", "checkerName": "fuchsia-default-arguments", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 1, "file": 41, "line": 1}, "message": "header is missing header guard"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/pdns/dynhandler.hh", "reportHash": "482292ab19f17a1c754ad15059a18794", "checkerName": "llvm-header-guard", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 10, "file": 41, "line": 23}, "message": "<stdlib.h> (fixit)"}, {"location": {"col": 1, "file": 41, "line": 23}, "message": "#includes are not sorted properly"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/pdns/dynhandler.hh", "reportHash": "76a32473c63a349e7b2d3ce388b964fa", "checkerName": "llvm-include-order", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 1, "file": 41, "line": 25}, "message": "note: this fix will not be applied because it overlaps with another fix (fixit)"}, {"location": {"col": 10, "file": 41, "line": 25}, "message": "inclusion of deprecated C++ header 'stdlib.h'; consider using 'cstdlib' instead"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/pdns/dynhandler.hh", "reportHash": "3bf1d348d247ebe58c3d5f664e3e3560", "checkerName": "modernize-deprecated-headers", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 1, "file": 42, "line": 1}, "message": "header is missing header guard"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/pdns/dynlistener.hh", "reportHash": "d82405f7c9dc600d82e31b0abc46e0b6", "checkerName": "llvm-header-guard", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 10, "file": 42, "line": 23}, "message": "\"iputils.hh\" (fixit)"}, {"location": {"col": 1, "file": 42, "line": 23}, "message": "#includes are not sorted properly"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/pdns/dynlistener.hh", "reportHash": "7f4d8e1a51487c386275c594297c6ef8", "checkerName": "llvm-include-order", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 10, "file": 42, "line": 26}, "message": "<cerrno> (fixit)"}, {"location": {"col": 10, "file": 42, "line": 26}, "message": "inclusion of deprecated C++ header 'errno.h'; consider using 'cerrno' instead"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/pdns/dynlistener.hh", "reportHash": "ad0838545b9c7069250bb76d8ec10948", "checkerName": "hicpp-deprecated-headers", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 7, "file": 42, "line": 39}, "message": "class 'DynListener' defines a non-default destructor but does not define a copy constructor, a copy assignment operator, a move constructor or a move assignment operator"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/pdns/dynlistener.hh", "reportHash": "84515686c3f06f8f39b98c67a6054d1d", "checkerName": "cppcoreguidelines-special-member-functions", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 24, "file": 42, "line": 42}, "message": "declaring a parameter with a default argument is disallowed"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/pdns/dynlistener.hh", "reportHash": "0a6b630a033172173602939e0d97dff2", "checkerName": "fuchsia-default-arguments", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 39, "file": 3, "line": 509}, "message": "default parameter was declared here"}, {"location": {"col": 44, "file": 42, "line": 42}, "message": "calling a function that uses a default argument is disallowed"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/pdns/dynlistener.hh", "reportHash": "a7a0a95a62a08175df8ccd99759d065e", "checkerName": "fuchsia-default-arguments", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 3, "file": 42, "line": 48}, "message": "using g_funk_t = string (const vector<string> &, Utility::pid_t) (fixit)"}, {"location": {"col": 3, "file": 42, "line": 48}, "message": "use 'using' instead of 'typedef'"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/pdns/dynlistener.hh", "reportHash": "c33125254e07c7a4c8f1e0df59ce31b0", "checkerName": "modernize-use-using", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 3, "file": 42, "line": 49}, "message": "use 'using' instead of 'typedef'"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/pdns/dynlistener.hh", "reportHash": "cf2b7886f5a9b646a5790254ab11d8b0", "checkerName": "modernize-use-using", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 34, "file": 42, "line": 49}, "message": "{} (fixit)"}, {"location": {"col": 11, "file": 42, "line": 49}, "message": "constructor does not initialize these fields: func"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/pdns/dynlistener.hh", "reportHash": "35c3a61b10ebe624c86fee886bd5939b", "checkerName": "hicpp-member-init", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 3, "file": 42, "line": 50}, "message": "use 'using' instead of 'typedef'"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/pdns/dynlistener.hh", "reportHash": "1cc76e08684e3e0dc6eb27b07fe7f153", "checkerName": "modernize-use-using", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 62, "file": 42, "line": 52}, "message": "declaring a parameter with a default argument is disallowed"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/pdns/dynlistener.hh", "reportHash": "c5506ff8117ac02251438f80e0d0b2b1", "checkerName": "fuchsia-default-arguments", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 39, "file": 3, "line": 509}, "message": "default parameter was declared here"}, {"location": {"col": 82, "file": 42, "line": 52}, "message": "calling a function that uses a default argument is disallowed"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/pdns/dynlistener.hh", "reportHash": "5f4f17ea244fd730e435c96e371fb2d5", "checkerName": "fuchsia-default-arguments", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 86, "file": 42, "line": 52}, "message": "declaring a parameter with a default argument is disallowed"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/pdns/dynlistener.hh", "reportHash": "94f49d9794fc71072ccc31a39e54a14f", "checkerName": "fuchsia-default-arguments", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 39, "file": 3, "line": 509}, "message": "default parameter was declared here"}, {"location": {"col": 105, "file": 42, "line": 52}, "message": "calling a function that uses a default argument is disallowed"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/pdns/dynlistener.hh", "reportHash": "32ad249d83d323053e133bac520128b3", "checkerName": "fuchsia-default-arguments", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 1, "file": 43, "line": 1}, "message": "header is missing header guard"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/pdns/ednsoptions.hh", "reportHash": "084291827edcca4ddb4470eb9f7743e3", "checkerName": "llvm-header-guard", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 1, "file": 43, "line": 44}, "message": "use 'using' instead of 'typedef'"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/pdns/ednsoptions.hh", "reportHash": "3b3f6f192739d333de90219231b60592", "checkerName": "modernize-use-using", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 70, "file": 43, "line": 47}, "message": "non-const reference parameter 'options', make it const or use a pointer"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/pdns/ednsoptions.hh", "reportHash": "03c5ccb94742ba3031a655040e46bb97", "checkerName": "google-runtime-references", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 107, "file": 43, "line": 49}, "message": "non-const reference parameter 'options', make it const or use a pointer"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/pdns/ednsoptions.hh", "reportHash": "ef29b7af48514c3d0d1cb7ff0878d0c7", "checkerName": "google-runtime-references", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 87, "file": 43, "line": 51}, "message": "non-const reference parameter 'res', make it const or use a pointer"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/pdns/ednsoptions.hh", "reportHash": "ae23bf4e16f24498a8c78ec74e28a137", "checkerName": "google-runtime-references", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 1, "file": 44, "line": 1}, "message": "header is missing header guard"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/pdns/ednssubnet.hh", "reportHash": "f3304c17436399ff4c98c313a2a4b143", "checkerName": "llvm-header-guard", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 10, "file": 44, "line": 23}, "message": "\"dnsname.hh\" (fixit)"}, {"location": {"col": 1, "file": 44, "line": 23}, "message": "#includes are not sorted properly"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/pdns/ednssubnet.hh", "reportHash": "ec1c5d5443c2d1542031f1a3ee53bc3a", "checkerName": "llvm-include-order", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 1, "file": 45, "line": 1}, "message": "header is missing header guard"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/pdns/gss_context.hh", "reportHash": "88fe29af5612953487ad174e8a511c43", "checkerName": "llvm-header-guard", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 7, "file": 45, "line": 52}, "message": "class 'GssName' defines a non-default destructor but does not define a copy constructor, a copy assignment operator, a move constructor or a move assignment operator"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/pdns/gss_context.hh", "reportHash": "81d5c3a6bf5d27edd97dea9a29e9f0bb", "checkerName": "hicpp-special-member-functions", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 39, "file": 3, "line": 509}, "message": "default parameter was declared here"}, {"location": {"col": 13, "file": 45, "line": 56}, "message": "calling a function that uses a default argument is disallowed"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/pdns/gss_context.hh", "reportHash": "c7c065ee90499c4948a815e40595bff6", "checkerName": "fuchsia-default-arguments", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 3, "file": 45, "line": 60}, "message": "explicit (fixit)"}, {"location": {"col": 3, "file": 45, "line": 60}, "message": "single-argument constructors must be marked explicit to avoid unintentional implicit conversions"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/pdns/gss_context.hh", "reportHash": "54cbc13ca9108ddee47bc50f9c9950dc", "checkerName": "hicpp-explicit-conversions", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 36, "file": 45, "line": 65}, "message": "/*name*/ (fixit)"}, {"location": {"col": 35, "file": 45, "line": 65}, "message": "parameter 'name' is unused"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/pdns/gss_context.hh", "reportHash": "11afdfe314681a93914e5d6123bce54e", "checkerName": "misc-unused-parameters", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 3, "file": 45, "line": 82}, "message": "use '= default' to define a trivial destructor"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/pdns/gss_context.hh", "reportHash": "5d1785dce33ba6d60c855749be0a848f", "checkerName": "modernize-use-equals-default", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 3, "file": 45, "line": 91}, "message": "cannot overload 'operator=='"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/pdns/gss_context.hh", "reportHash": "fdb601a720203ac4d05c59f165db2b76", "checkerName": "fuchsia-overloaded-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 35, "file": 45, "line": 91}, "message": "/*rhs*/ (fixit)"}, {"location": {"col": 34, "file": 45, "line": 91}, "message": "parameter 'rhs' is unused"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/pdns/gss_context.hh", "reportHash": "edfd8ed8e9601745718542f3523ab944", "checkerName": "misc-unused-parameters", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 34, "file": 45, "line": 103}, "message": "/*name*/ (fixit)"}, {"location": {"col": 33, "file": 45, "line": 103}, "message": "parameter 'name' is unused"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/pdns/gss_context.hh", "reportHash": "6d98dd061d3899251f858383479fd49d", "checkerName": "misc-unused-parameters", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 3, "file": 45, "line": 142}, "message": "explicit (fixit)"}, {"location": {"col": 3, "file": 45, "line": 142}, "message": "single-argument constructors must be marked explicit to avoid unintentional implicit conversions"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/pdns/gss_context.hh", "reportHash": "337c3403e8ead6e1faeb43601ed77321", "checkerName": "hicpp-explicit-conversions", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 39, "file": 45, "line": 145}, "message": "non-const reference parameter 'name', make it const or use a pointer"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/pdns/gss_context.hh", "reportHash": "1e7b20f3f56efe31a33eeed37645e032", "checkerName": "google-runtime-references", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 38, "file": 45, "line": 147}, "message": "non-const reference parameter 'name', make it const or use a pointer"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/pdns/gss_context.hh", "reportHash": "b58c3f3acf8a0ff6f7cf9a13d42f3648", "checkerName": "google-runtime-references", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 52, "file": 45, "line": 153}, "message": "non-const reference parameter 'output', make it const or use a pointer"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/pdns/gss_context.hh", "reportHash": "b0957a87aa25e7b71304db0d339fcda9", "checkerName": "google-runtime-references", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 54, "file": 45, "line": 154}, "message": "non-const reference parameter 'output', make it const or use a pointer"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/pdns/gss_context.hh", "reportHash": "51ae9051d56fe9d76b6003069d61fd90", "checkerName": "google-runtime-references", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 52, "file": 45, "line": 159}, "message": "non-const reference parameter 'output', make it const or use a pointer"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/pdns/gss_context.hh", "reportHash": "396a5659fa431fd299b3387d3c6ac865", "checkerName": "google-runtime-references", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 89, "file": 45, "line": 179}, "message": "non-const reference parameter 'mac', make it const or use a pointer"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/pdns/gss_context.hh", "reportHash": "d58dc191c90b118077e3787d13391c1a", "checkerName": "google-runtime-references", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 36, "file": 20, "line": 97}, "message": "{ (fixit)"}, {"location": {"col": 35, "file": 20, "line": 97}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/pdns/iputils.hh", "reportHash": "4caa1191b9f313d77f1b5c37078c62d2", "checkerName": "hicpp-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 105, "file": 20, "line": 113}, "message": "{ (fixit)"}, {"location": {"col": 104, "file": 20, "line": 113}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/pdns/iputils.hh", "reportHash": "f9a5558d7bb403a95b062c6fbfd71e27", "checkerName": "readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 36, "file": 20, "line": 118}, "message": "{ (fixit)"}, {"location": {"col": 35, "file": 20, "line": 118}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/pdns/iputils.hh", "reportHash": "41d9a84c7b4d3bf1b280ae04572a9705", "checkerName": "readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 49, "file": 20, "line": 151}, "message": "{ (fixit)"}, {"location": {"col": 48, "file": 20, "line": 151}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/pdns/iputils.hh", "reportHash": "4588de9351eb2d88a5815af0ce64d584", "checkerName": "google-readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 40, "file": 20, "line": 155}, "message": "{ (fixit)"}, {"location": {"col": 39, "file": 20, "line": 155}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/pdns/iputils.hh", "reportHash": "1a3081b0dbe0f1858efa38032b6ff807", "checkerName": "google-readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 12, "file": 20, "line": 157}, "message": "{ (fixit)"}, {"location": {"col": 11, "file": 20, "line": 157}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/pdns/iputils.hh", "reportHash": "ce7ee69836df61d6faaf56ad7a7de759", "checkerName": "hicpp-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 40, "file": 20, "line": 168}, "message": "{ (fixit)"}, {"location": {"col": 39, "file": 20, "line": 168}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/pdns/iputils.hh", "reportHash": "2cc4cebaa9d7b0fa933fbda0364cd1ae", "checkerName": "readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 36, "file": 20, "line": 178}, "message": "{ (fixit)"}, {"location": {"col": 35, "file": 20, "line": 178}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/pdns/iputils.hh", "reportHash": "f6479da5a482283907f08cb9df60aeb7", "checkerName": "google-readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 10, "file": 20, "line": 180}, "message": "{ (fixit)"}, {"location": {"col": 9, "file": 20, "line": 180}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/pdns/iputils.hh", "reportHash": "0cf5aa750122c695f19ca1782c59181e", "checkerName": "readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 3, "file": 20, "line": 201}, "message": "explicit (fixit)"}, {"location": {"col": 3, "file": 20, "line": 201}, "message": "single-argument constructors must be marked explicit to avoid unintentional implicit conversions"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/pdns/iputils.hh", "reportHash": "d664423ef8920f90e542443696a6f76c", "checkerName": "google-explicit-constructor", "reviewStatus": null, "severity": "MEDIUM"}, {"events": [{"location": {"col": 3, "file": 20, "line": 201}, "message": "union constructor should initialize one of these fields: sin4, sin6"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/pdns/iputils.hh", "reportHash": "518b542c84ced529563de39a16b1249a", "checkerName": "cppcoreguidelines-pro-type-member-init", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 24, "file": 20, "line": 222}, "message": "{ (fixit)"}, {"location": {"col": 23, "file": 20, "line": 222}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/pdns/iputils.hh", "reportHash": "53d96e6c39b5a2eb710edf05c37f4808", "checkerName": "readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 21, "file": 29, "line": 404}, "message": "expanded from macro 'htons'"}, {"location": {"col": 11, "file": 33, "line": 29}, "message": "expanded from macro '__bswap_16'"}, {"location": {"col": 52, "file": 30, "line": 32}, "message": "expanded from macro '__bswap_constant_16'"}, {"location": {"col": 21, "file": 20, "line": 223}, "message": "use of a signed integer operand with a binary bitwise operator"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/pdns/iputils.hh", "reportHash": "92e298975f99b10514bb65ced7f76a7b", "checkerName": "hicpp-signed-bitwise", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 35, "file": 20, "line": 237}, "message": "{ (fixit)"}, {"location": {"col": 34, "file": 20, "line": 237}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/pdns/iputils.hh", "reportHash": "9d53d91aaf7ec18fc006ddb03d6389f0", "checkerName": "readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 27, "file": 20, "line": 242}, "message": "{ (fixit)"}, {"location": {"col": 26, "file": 20, "line": 242}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/pdns/iputils.hh", "reportHash": "b217a055459836eea5cb098274b10538", "checkerName": "google-readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 24, "file": 20, "line": 246}, "message": "{ (fixit)"}, {"location": {"col": 23, "file": 20, "line": 246}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/pdns/iputils.hh", "reportHash": "294469a62a9f9bc954bcd481b3d60e26", "checkerName": "readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 24, "file": 20, "line": 247}, "message": "{ (fixit)"}, {"location": {"col": 23, "file": 20, "line": 247}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/pdns/iputils.hh", "reportHash": "17f4993e2d3cec2108fe625363f43a9b", "checkerName": "hicpp-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 108, "file": 20, "line": 271}, "message": "nullptr (fixit)"}, {"location": {"col": 108, "file": 20, "line": 271}, "message": "use nullptr"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/pdns/iputils.hh", "reportHash": "b268b0052c7466ca72a1026ab8c05b74", "checkerName": "modernize-use-nullptr", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 132, "file": 20, "line": 271}, "message": "{ (fixit)"}, {"location": {"col": 131, "file": 20, "line": 271}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/pdns/iputils.hh", "reportHash": "eb58b609303c6927fe093b344754b202", "checkerName": "readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 21, "file": 20, "line": 272}, "message": "do not implicitly decay an array into a pointer; consider using gsl::array_view or an explicit cast instead"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/pdns/iputils.hh", "reportHash": "5961937784d459bb4a91f3b9e47c5f8b", "checkerName": "hicpp-no-array-decay", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 10, "file": 20, "line": 273}, "message": "{ (fixit)"}, {"location": {"col": 9, "file": 20, "line": 273}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/pdns/iputils.hh", "reportHash": "0a6e3dfbdcd46ca28d5e27915e1788bd", "checkerName": "hicpp-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 34, "file": 20, "line": 279}, "message": "{ (fixit)"}, {"location": {"col": 33, "file": 20, "line": 279}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/pdns/iputils.hh", "reportHash": "8fc29b3ab20a9aff1973d5ba046d8691", "checkerName": "google-readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 21, "file": 29, "line": 402}, "message": "expanded from macro 'ntohs'"}, {"location": {"col": 11, "file": 33, "line": 29}, "message": "expanded from macro '__bswap_16'"}, {"location": {"col": 31, "file": 30, "line": 32}, "message": "expanded from macro '__bswap_constant_16'"}, {"location": {"col": 48, "file": 20, "line": 280}, "message": "use of a signed integer operand with a binary bitwise operator"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/pdns/iputils.hh", "reportHash": "8652d4e1366d18096e0abe17b821a2ec", "checkerName": "hicpp-signed-bitwise", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 21, "file": 29, "line": 402}, "message": "expanded from macro 'ntohs'"}, {"location": {"col": 11, "file": 33, "line": 29}, "message": "expanded from macro '__bswap_16'"}, {"location": {"col": 53, "file": 30, "line": 32}, "message": "expanded from macro '__bswap_constant_16'"}, {"location": {"col": 53, "file": 20, "line": 282}, "message": "use of a signed integer operand with a binary bitwise operator"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/pdns/iputils.hh", "reportHash": "4cfc72e9c8b59923765b87aa8602b50d", "checkerName": "hicpp-signed-bitwise", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 21, "file": 29, "line": 402}, "message": "expanded from macro 'ntohs'"}, {"location": {"col": 7, "file": 33, "line": 28}, "message": "expanded from macro '__bswap_16'"}, {"location": {"col": 8, "file": 20, "line": 287}, "message": "do not call c-style vararg functions"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/pdns/iputils.hh", "reportHash": "8d8a4916d56267b5f6b44d74334f2b73", "checkerName": "hicpp-vararg", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 21, "file": 29, "line": 402}, "message": "expanded from macro 'ntohs'"}, {"location": {"col": 11, "file": 33, "line": 29}, "message": "expanded from macro '__bswap_16'"}, {"location": {"col": 31, "file": 30, "line": 32}, "message": "expanded from macro '__bswap_constant_16'"}, {"location": {"col": 8, "file": 20, "line": 287}, "message": "use of a signed integer operand with a binary bitwise operator"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/pdns/iputils.hh", "reportHash": "e58893451d590736578c3cd9caa0a0bb", "checkerName": "hicpp-signed-bitwise", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 38, "file": 20, "line": 287}, "message": "{ (fixit)"}, {"location": {"col": 37, "file": 20, "line": 287}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/pdns/iputils.hh", "reportHash": "94dfc222d106b26bc9074922e94f1738", "checkerName": "hicpp-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 21, "file": 29, "line": 402}, "message": "expanded from macro 'ntohs'"}, {"location": {"col": 11, "file": 33, "line": 29}, "message": "expanded from macro '__bswap_16'"}, {"location": {"col": 52, "file": 30, "line": 32}, "message": "expanded from macro '__bswap_constant_16'"}, {"location": {"col": 48, "file": 20, "line": 290}, "message": "use of a signed integer operand with a binary bitwise operator"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/pdns/iputils.hh", "reportHash": "8652d4e1366d18096e0abe17b821a2ec", "checkerName": "hicpp-signed-bitwise", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 10, "file": 20, "line": 291}, "message": "{ (fixit)"}, {"location": {"col": 9, "file": 20, "line": 291}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/pdns/iputils.hh", "reportHash": "0cf5aa750122c695f19ca1782c59181e", "checkerName": "readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 21, "file": 29, "line": 402}, "message": "expanded from macro 'ntohs'"}, {"location": {"col": 11, "file": 33, "line": 29}, "message": "expanded from macro '__bswap_16'"}, {"location": {"col": 30, "file": 30, "line": 32}, "message": "expanded from macro '__bswap_constant_16'"}, {"location": {"col": 53, "file": 20, "line": 292}, "message": "use of a signed integer operand with a binary bitwise operator"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/pdns/iputils.hh", "reportHash": "4cfc72e9c8b59923765b87aa8602b50d", "checkerName": "hicpp-signed-bitwise", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 21, "file": 29, "line": 402}, "message": "expanded from macro 'ntohs'"}, {"location": {"col": 11, "file": 33, "line": 29}, "message": "expanded from macro '__bswap_16'"}, {"location": {"col": 30, "file": 30, "line": 32}, "message": "expanded from macro '__bswap_constant_16'"}, {"location": {"col": 12, "file": 20, "line": 304}, "message": "use of a signed integer operand with a binary bitwise operator"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/pdns/iputils.hh", "reportHash": "561514192cd8837deaa8deee1cfcc10f", "checkerName": "hicpp-signed-bitwise", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 21, "file": 29, "line": 404}, "message": "expanded from macro 'htons'"}, {"location": {"col": 11, "file": 33, "line": 29}, "message": "expanded from macro '__bswap_16'"}, {"location": {"col": 29, "file": 30, "line": 32}, "message": "expanded from macro '__bswap_constant_16'"}, {"location": {"col": 21, "file": 20, "line": 309}, "message": "use of a signed integer operand with a binary bitwise operator"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/pdns/iputils.hh", "reportHash": "905f5461f07638b5133bb662025af143", "checkerName": "hicpp-signed-bitwise", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 19, "file": 20, "line": 323}, "message": "{ (fixit)"}, {"location": {"col": 18, "file": 20, "line": 323}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/pdns/iputils.hh", "reportHash": "f533f2edcd763e68c76bad6d1ec42cf8", "checkerName": "hicpp-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 21, "file": 29, "line": 401}, "message": "expanded from macro 'ntohl'"}, {"location": {"col": 12, "file": 30, "line": 62}, "message": "expanded from macro '__bswap_32'"}, {"location": {"col": 8, "file": 30, "line": 39}, "message": "expanded from macro '__bswap_constant_32'"}, {"location": {"col": 26, "file": 20, "line": 342}, "message": "use of a signed integer operand with a binary bitwise operator"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/pdns/iputils.hh", "reportHash": "a03d57461ebe13b9f04fc1e2144531bf", "checkerName": "hicpp-signed-bitwise", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 3, "file": 20, "line": 369}, "message": "explicit (fixit)"}, {"location": {"col": 3, "file": 20, "line": 369}, "message": "single-argument constructors must be marked explicit to avoid unintentional implicit conversions"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/pdns/iputils.hh", "reportHash": "2150bdfd04bbbc0524e35f3358295e10", "checkerName": "hicpp-explicit-conversions", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 3, "file": 20, "line": 421}, "message": "explicit (fixit)"}, {"location": {"col": 3, "file": 20, "line": 421}, "message": "constructors that are callable with a single argument must be marked explicit to avoid unintentional implicit conversions"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/pdns/iputils.hh", "reportHash": "213076e7c37fdf61c27ed67e78ccdb35", "checkerName": "hicpp-explicit-conversions", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 21, "file": 29, "line": 403}, "message": "expanded from macro 'htonl'"}, {"location": {"col": 12, "file": 30, "line": 62}, "message": "expanded from macro '__bswap_32'"}, {"location": {"col": 38, "file": 30, "line": 40}, "message": "expanded from macro '__bswap_constant_32'"}, {"location": {"col": 40, "file": 20, "line": 440}, "message": "use of a signed integer operand with a binary bitwise operator"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/pdns/iputils.hh", "reportHash": "106d968c18ecc77539b793799a1bf6c6", "checkerName": "hicpp-signed-bitwise", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 21, "file": 29, "line": 401}, "message": "expanded from macro 'ntohl'"}, {"location": {"col": 12, "file": 30, "line": 62}, "message": "expanded from macro '__bswap_32'"}, {"location": {"col": 38, "file": 30, "line": 40}, "message": "expanded from macro '__bswap_constant_32'"}, {"location": {"col": 33, "file": 29, "line": 403}, "message": "expanded from macro 'htonl'"}, {"location": {"col": 36, "file": 30, "line": 60}, "message": "expanded from macro '__bswap_32'"}, {"location": {"col": 46, "file": 20, "line": 440}, "message": "use of a signed integer operand with a binary bitwise operator"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/pdns/iputils.hh", "reportHash": "dea81e1b83cd9fc8841ffdb9f39ea26c", "checkerName": "hicpp-signed-bitwise", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 3, "file": 20, "line": 459}, "message": "constructor does not initialize these fields: d_mask, d_bits"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/pdns/iputils.hh", "reportHash": "ffb823db925ec5d5f64955899e336888", "checkerName": "cppcoreguidelines-pro-type-member-init", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 3, "file": 20, "line": 459}, "message": "explicit (fixit)"}, {"location": {"col": 3, "file": 20, "line": 459}, "message": "single-argument constructors must be marked explicit to avoid unintentional implicit conversions"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/pdns/iputils.hh", "reportHash": "fa0ed7ed656c55f9a4a2c008fc0ccdbd", "checkerName": "google-explicit-constructor", "reviewStatus": null, "severity": "MEDIUM"}, {"events": [{"location": {"col": 21, "file": 29, "line": 403}, "message": "expanded from macro 'htonl'"}, {"location": {"col": 8, "file": 30, "line": 61}, "message": "expanded from macro '__bswap_32'"}, {"location": {"col": 21, "file": 20, "line": 487}, "message": "do not call c-style vararg functions"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/pdns/iputils.hh", "reportHash": "6df132608115e96db9eae2e036472c09", "checkerName": "cppcoreguidelines-pro-type-vararg", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 21, "file": 29, "line": 403}, "message": "expanded from macro 'htonl'"}, {"location": {"col": 12, "file": 30, "line": 62}, "message": "expanded from macro '__bswap_32'"}, {"location": {"col": 8, "file": 30, "line": 40}, "message": "expanded from macro '__bswap_constant_32'"}, {"location": {"col": 21, "file": 20, "line": 487}, "message": "use of a signed integer operand with a binary bitwise operator"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/pdns/iputils.hh", "reportHash": "6a8d2dcc3f845ce96c3091cd8d565b42", "checkerName": "hicpp-signed-bitwise", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 7, "file": 20, "line": 501}, "message": "auto (fixit)"}, {"location": {"col": 7, "file": 20, "line": 501}, "message": "use auto when initializing with a cast to avoid duplicating the type name"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/pdns/iputils.hh", "reportHash": "e686076b462be4b4aa6fd8ca33b42b41", "checkerName": "modernize-use-auto", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 21, "file": 29, "line": 401}, "message": "expanded from macro 'ntohl'"}, {"location": {"col": 8, "file": 30, "line": 61}, "message": "expanded from macro '__bswap_32'"}, {"location": {"col": 30, "file": 20, "line": 518}, "message": "do not call c-style vararg functions"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/pdns/iputils.hh", "reportHash": "23c96b28191b84e025faa7488e48c79f", "checkerName": "cppcoreguidelines-pro-type-vararg", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 21, "file": 29, "line": 401}, "message": "expanded from macro 'ntohl'"}, {"location": {"col": 12, "file": 30, "line": 62}, "message": "expanded from macro '__bswap_32'"}, {"location": {"col": 38, "file": 30, "line": 40}, "message": "expanded from macro '__bswap_constant_32'"}, {"location": {"col": 30, "file": 20, "line": 518}, "message": "use of a signed integer operand with a binary bitwise operator"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/pdns/iputils.hh", "reportHash": "e3bffa34f4ec681a34652ea620445072", "checkerName": "hicpp-signed-bitwise", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 30, "file": 20, "line": 566}, "message": "{ (fixit)"}, {"location": {"col": 29, "file": 20, "line": 566}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/pdns/iputils.hh", "reportHash": "cebbd9966c7c0244062a8375b66d4969", "checkerName": "readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 7, "file": 20, "line": 651}, "message": "class 'NetmaskTree' defines a copy constructor and a copy assignment operator but does not define a destructor, a move constructor or a move assignment operator"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/pdns/iputils.hh", "reportHash": "083f8e7cd6e4211cb09a9985fb98c23a", "checkerName": "hicpp-special-member-functions", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 7, "file": 20, "line": 707}, "message": "auto (fixit)"}, {"location": {"col": 7, "file": 20, "line": 707}, "message": "use auto when initializing with new to avoid duplicating the type name"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/pdns/iputils.hh", "reportHash": "4e6a22f7f4c67b22e90a45198e7f7083", "checkerName": "modernize-use-auto", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 7, "file": 20, "line": 753}, "message": "auto (fixit)"}, {"location": {"col": 7, "file": 20, "line": 753}, "message": "use auto when initializing with new to avoid duplicating the type name"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/pdns/iputils.hh", "reportHash": "4e6a22f7f4c67b22e90a45198e7f7083", "checkerName": "modernize-use-auto", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 27, "file": 20, "line": 776}, "message": "{ (fixit)"}, {"location": {"col": 26, "file": 20, "line": 776}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/pdns/iputils.hh", "reportHash": "585691a7386445e7070601f311c75573", "checkerName": "google-readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 61, "file": 20, "line": 800}, "message": "{ (fixit)"}, {"location": {"col": 60, "file": 20, "line": 800}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/pdns/iputils.hh", "reportHash": "caff18634c2f4d710cab084d3c809ca2", "checkerName": "readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 10, "file": 20, "line": 821}, "message": "use default member initializer for 'assigned'"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/pdns/iputils.hh", "reportHash": "4ffa5f1aecc8e885e8bba5374dfa7b55", "checkerName": "modernize-use-default-member-init", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 9, "file": 20, "line": 823}, "message": "use default member initializer for 'd_bits'"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/pdns/iputils.hh", "reportHash": "7de56574dece340697cbac792fab6364", "checkerName": "modernize-use-default-member-init", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 42, "file": 20, "line": 834}, "message": "{ (fixit)"}, {"location": {"col": 41, "file": 20, "line": 834}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/pdns/iputils.hh", "reportHash": "09daad98afc65745e994e5683ecab17d", "checkerName": "hicpp-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 14, "file": 20, "line": 836}, "message": "{ (fixit)"}, {"location": {"col": 13, "file": 20, "line": 836}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/pdns/iputils.hh", "reportHash": "34de0fe5f332f6c0d780f4b8ca79b218", "checkerName": "readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 26, "file": 20, "line": 849}, "message": "{ (fixit)"}, {"location": {"col": 25, "file": 20, "line": 849}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/pdns/iputils.hh", "reportHash": "624f2d35856c38f9b89f97c305caaa96", "checkerName": "readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 27, "file": 20, "line": 852}, "message": "{ (fixit)"}, {"location": {"col": 26, "file": 20, "line": 852}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/pdns/iputils.hh", "reportHash": "2676c648c80d894ee2d9af2925939abd", "checkerName": "google-readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 25, "file": 20, "line": 985}, "message": "{ (fixit)"}, {"location": {"col": 24, "file": 20, "line": 985}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/pdns/iputils.hh", "reportHash": "50cb187096c2253c06b58ff2cb005400", "checkerName": "readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 12, "file": 20, "line": 987}, "message": "{ (fixit)"}, {"location": {"col": 11, "file": 20, "line": 987}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/pdns/iputils.hh", "reportHash": "845fa35c3651196ac9370e074ca07ae5", "checkerName": "google-readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 45, "file": 20, "line": 998}, "message": "{ (fixit)"}, {"location": {"col": 44, "file": 20, "line": 998}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/pdns/iputils.hh", "reportHash": "0edca7ebada7ec7229061c1d02ce1ca9", "checkerName": "readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 19, "file": 20, "line": 1030}, "message": "{ (fixit)"}, {"location": {"col": 18, "file": 20, "line": 1030}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/pdns/iputils.hh", "reportHash": "4a0c528d740bb9a235fcaa66ec004539", "checkerName": "hicpp-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 21, "file": 20, "line": 1045}, "message": "{ (fixit)"}, {"location": {"col": 20, "file": 20, "line": 1045}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/pdns/iputils.hh", "reportHash": "9539d8ff94b1a65d0c872e20b9465c0a", "checkerName": "hicpp-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 20, "file": 20, "line": 1054}, "message": "{ (fixit)"}, {"location": {"col": 19, "file": 20, "line": 1054}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/pdns/iputils.hh", "reportHash": "e7a40226d8535c51df82a0f08fe40614", "checkerName": "readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 25, "file": 20, "line": 1096}, "message": "{ (fixit)"}, {"location": {"col": 24, "file": 20, "line": 1096}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/pdns/iputils.hh", "reportHash": "8dddc531a561511119b9db095cb3132f", "checkerName": "hicpp-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 30, "file": 20, "line": 1098}, "message": "{ (fixit)"}, {"location": {"col": 29, "file": 20, "line": 1098}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/pdns/iputils.hh", "reportHash": "bc875b4053eaa5a5442f15eace3a72ac", "checkerName": "google-readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 10, "file": 20, "line": 1100}, "message": "{ (fixit)"}, {"location": {"col": 9, "file": 20, "line": 1100}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/pdns/iputils.hh", "reportHash": "0cf5aa750122c695f19ca1782c59181e", "checkerName": "readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 26, "file": 20, "line": 1102}, "message": "{ (fixit)"}, {"location": {"col": 25, "file": 20, "line": 1102}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/pdns/iputils.hh", "reportHash": "9a032a2b79022b3241aace8dc94f9363", "checkerName": "readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 67, "file": 20, "line": 1112}, "message": "{ (fixit)"}, {"location": {"col": 66, "file": 20, "line": 1112}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/pdns/iputils.hh", "reportHash": "576e745bd276c347751a90d54c1b64de", "checkerName": "readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 29, "file": 20, "line": 1115}, "message": "{ (fixit)"}, {"location": {"col": 28, "file": 20, "line": 1115}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/pdns/iputils.hh", "reportHash": "e325f9955e87d8dce0be88952c175d36", "checkerName": "readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 28, "file": 20, "line": 1119}, "message": "{ (fixit)"}, {"location": {"col": 27, "file": 20, "line": 1119}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/pdns/iputils.hh", "reportHash": "0b5c7ccb3f00acdb165b5c5f3aa036d0", "checkerName": "google-readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 63, "file": 20, "line": 1137}, "message": "{ (fixit)"}, {"location": {"col": 62, "file": 20, "line": 1137}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/pdns/iputils.hh", "reportHash": "a64effd6679352683128449fe5f1965e", "checkerName": "google-readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 28, "file": 20, "line": 1150}, "message": "{ (fixit)"}, {"location": {"col": 27, "file": 20, "line": 1150}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/pdns/iputils.hh", "reportHash": "7f7aba5fbe123615f99b22946c21bffd", "checkerName": "readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 26, "file": 20, "line": 1155}, "message": "{ (fixit)"}, {"location": {"col": 25, "file": 20, "line": 1155}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/pdns/iputils.hh", "reportHash": "6ce9b113a22040bf0b4dd3ad56667abf", "checkerName": "readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 58, "file": 20, "line": 1171}, "message": "{ (fixit)"}, {"location": {"col": 57, "file": 20, "line": 1171}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/pdns/iputils.hh", "reportHash": "3355a47a7b5bb39544bf47c9a23d6539", "checkerName": "google-readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 27, "file": 20, "line": 1192}, "message": "{ (fixit)"}, {"location": {"col": 26, "file": 20, "line": 1192}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/pdns/iputils.hh", "reportHash": "37a5da0288afb37017b0c5bfcee44485", "checkerName": "readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 27, "file": 20, "line": 1248}, "message": "= default; (fixit)"}, {"location": {"col": 3, "file": 20, "line": 1248}, "message": "use '= default' to define a trivial default constructor"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/pdns/iputils.hh", "reportHash": "89ed85bbac4a68e5e314c69dea23e1bc", "checkerName": "modernize-use-equals-default", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 27, "file": 20, "line": 1269}, "message": "{ (fixit)"}, {"location": {"col": 26, "file": 20, "line": 1269}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/pdns/iputils.hh", "reportHash": "6fa9746c3a452c8094fc17c396c3d6c2", "checkerName": "google-readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 22, "file": 20, "line": 1306}, "message": "{ (fixit)"}, {"location": {"col": 21, "file": 20, "line": 1306}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/pdns/iputils.hh", "reportHash": "4d2057891f94343f6e4fb561121a9d75", "checkerName": "hicpp-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 32, "file": 20, "line": 1329}, "message": "{ (fixit)"}, {"location": {"col": 31, "file": 20, "line": 1329}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/pdns/iputils.hh", "reportHash": "d28d3b8d9c9da0918675febf407bf7d5", "checkerName": "google-readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 3, "file": 20, "line": 1360}, "message": "explicit (fixit)"}, {"location": {"col": 3, "file": 20, "line": 1360}, "message": "single-argument constructors must be marked explicit to avoid unintentional implicit conversions"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/pdns/iputils.hh", "reportHash": "1aee41c1a0decc512731dc28379eecd1", "checkerName": "google-explicit-constructor", "reviewStatus": null, "severity": "MEDIUM"}, {"events": [{"location": {"col": 23, "file": 20, "line": 1411}, "message": "class 'NetmaskTree' defines a copy constructor and a copy assignment operator but does not define a destructor, a move constructor or a move assignment operator"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/pdns/iputils.hh", "reportHash": "5b47bbf9ca76457635080d82b4f1cd96", "checkerName": "hicpp-special-member-functions", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 1, "file": 47, "line": 24}, "message": "note: this fix will not be applied because it overlaps with another fix (fixit)"}, {"location": {"col": 10, "file": 47, "line": 24}, "message": "inclusion of deprecated C++ header 'errno.h'; consider using 'cerrno' instead"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/pdns/lock.hh", "reportHash": "d210d24d68807b350f6db0292ca7a1b5", "checkerName": "modernize-deprecated-headers", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 3, "file": 47, "line": 31}, "message": "constructor does not initialize these fields: d_lock"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/pdns/lock.hh", "reportHash": "f9a3b5bb4d2627a3363c86825ff2aa41", "checkerName": "cppcoreguidelines-pro-type-member-init", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 7, "file": 47, "line": 130}, "message": "class 'TryReadLock' defines a non-default destructor, a copy constructor, a copy assignment operator and a move constructor but does not define a move assignment operator"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/pdns/lock.hh", "reportHash": "567b081777263d42b7945f33fc94b22d", "checkerName": "hicpp-special-member-functions", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 30, "file": 47, "line": 151}, "message": "{ (fixit)"}, {"location": {"col": 29, "file": 47, "line": 151}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/pdns/lock.hh", "reportHash": "91a525234a73c3442e5d3aafb8c4b322", "checkerName": "google-readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 3, "file": 47, "line": 164}, "message": "explicit (fixit)"}, {"location": {"col": 3, "file": 47, "line": 164}, "message": "single-argument constructors must be marked explicit to avoid unintentional implicit conversions"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/pdns/lock.hh", "reportHash": "67a6eb4cdbb16027ef795dd09a88bdc7", "checkerName": "hicpp-explicit-conversions", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 3, "file": 48, "line": 38}, "message": "explicit (fixit)"}, {"location": {"col": 3, "file": 48, "line": 38}, "message": "constructors that are callable with a single argument must be marked explicit to avoid unintentional implicit conversions"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/pdns/logger.hh", "reportHash": "9839c661fbb34654f9be720da08bc129", "checkerName": "hicpp-explicit-conversions", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 24, "file": 48, "line": 88}, "message": "cannot overload 'operator<<<ComboAddress>'"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/pdns/logger.hh", "reportHash": "c0a792044b88d72b00dd3c95b50e2deb", "checkerName": "fuchsia-overloaded-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 24, "file": 48, "line": 88}, "message": "cannot overload 'operator<<<DNSName>'"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/pdns/logger.hh", "reportHash": "c566e33d4973fbb3691bddcf7224dc51", "checkerName": "fuchsia-overloaded-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 24, "file": 48, "line": 88}, "message": "cannot overload 'operator<<<char [13]>'"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/pdns/logger.hh", "reportHash": "5148a65554e5541f0a213ac46a43d2a4", "checkerName": "fuchsia-overloaded-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 24, "file": 48, "line": 88}, "message": "cannot overload 'operator<<<char [14]>'"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/pdns/logger.hh", "reportHash": "ef1a30f2ecf0624c8a7f910500b2c6d7", "checkerName": "fuchsia-overloaded-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 24, "file": 48, "line": 88}, "message": "cannot overload 'operator<<<char [16]>'"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/pdns/logger.hh", "reportHash": "acef3d4cb8091abf666e67509da3a910", "checkerName": "fuchsia-overloaded-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 24, "file": 48, "line": 88}, "message": "cannot overload 'operator<<<char [17]>'"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/pdns/logger.hh", "reportHash": "bb85189a32d6c5dc6f201cbeb9dc433d", "checkerName": "fuchsia-overloaded-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 24, "file": 48, "line": 88}, "message": "cannot overload 'operator<<<char [21]>'"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/pdns/logger.hh", "reportHash": "4cb8d4618fc2246cbdf94f985ae10892", "checkerName": "fuchsia-overloaded-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 24, "file": 48, "line": 88}, "message": "cannot overload 'operator<<<char [25]>'"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/pdns/logger.hh", "reportHash": "e66b344dadc079b2be6f2d9a62d1d5af", "checkerName": "fuchsia-overloaded-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 24, "file": 48, "line": 88}, "message": "cannot overload 'operator<<<char [26]>'"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/pdns/logger.hh", "reportHash": "7c1a129767a5b2cd13834682efc395d2", "checkerName": "fuchsia-overloaded-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 24, "file": 48, "line": 88}, "message": "cannot overload 'operator<<<char [29]>'"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/pdns/logger.hh", "reportHash": "de7f85b39c7a16a95aa4001403002380", "checkerName": "fuchsia-overloaded-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 24, "file": 48, "line": 88}, "message": "cannot overload 'operator<<<char [30]>'"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/pdns/logger.hh", "reportHash": "6a71ae91f570ce125dcf59b0221ee481", "checkerName": "fuchsia-overloaded-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 24, "file": 48, "line": 88}, "message": "cannot overload 'operator<<<char [31]>'"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/pdns/logger.hh", "reportHash": "8eabbd6268d87a797771cabb0bf2a9cd", "checkerName": "fuchsia-overloaded-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 24, "file": 48, "line": 88}, "message": "cannot overload 'operator<<<char [32]>'"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/pdns/logger.hh", "reportHash": "4cf3e5eb8de4bd084221a2311bd2bd6b", "checkerName": "fuchsia-overloaded-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 24, "file": 48, "line": 88}, "message": "cannot overload 'operator<<<char [34]>'"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/pdns/logger.hh", "reportHash": "b17fa74c35a876a9107a9fe295477631", "checkerName": "fuchsia-overloaded-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 24, "file": 48, "line": 88}, "message": "cannot overload 'operator<<<char [43]>'"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/pdns/logger.hh", "reportHash": "ca27570c823f3b04cea4454e152f3110", "checkerName": "fuchsia-overloaded-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 24, "file": 48, "line": 88}, "message": "cannot overload 'operator<<<char [46]>'"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/pdns/logger.hh", "reportHash": "015bc7ac60622a1bbefda4bfd3776ee1", "checkerName": "fuchsia-overloaded-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 24, "file": 48, "line": 88}, "message": "cannot overload 'operator<<<char [48]>'"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/pdns/logger.hh", "reportHash": "753e1366658f007bd08e7a421a87cb4f", "checkerName": "fuchsia-overloaded-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 24, "file": 48, "line": 88}, "message": "cannot overload 'operator<<<char [54]>'"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/pdns/logger.hh", "reportHash": "2097e3d672c98424b56d3c16bad49124", "checkerName": "fuchsia-overloaded-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 24, "file": 48, "line": 88}, "message": "cannot overload 'operator<<<char [55]>'"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/pdns/logger.hh", "reportHash": "14205538c3475f1df4622f5623982913", "checkerName": "fuchsia-overloaded-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 24, "file": 48, "line": 88}, "message": "cannot overload 'operator<<<char [60]>'"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/pdns/logger.hh", "reportHash": "1395d412a7fbaf23a50eba29ce3d3375", "checkerName": "fuchsia-overloaded-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 24, "file": 48, "line": 88}, "message": "cannot overload 'operator<<<const char *>'"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/pdns/logger.hh", "reportHash": "cf4d4eb39ee44a2f0efd6a117db4bcb7", "checkerName": "fuchsia-overloaded-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 24, "file": 48, "line": 88}, "message": "cannot overload 'operator<<<int>'"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/pdns/logger.hh", "reportHash": "48e4400b5c2adda6ced505981f97b5e5", "checkerName": "fuchsia-overloaded-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 24, "file": 48, "line": 88}, "message": "cannot overload 'operator<<<long>'"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/pdns/logger.hh", "reportHash": "e5f968bbbf5a73570a6bd59e047e9c89", "checkerName": "fuchsia-overloaded-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 24, "file": 48, "line": 88}, "message": "cannot overload 'operator<<<unsigned long>'"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/pdns/logger.hh", "reportHash": "e8c667682353d783c1cb251e923348ec", "checkerName": "fuchsia-overloaded-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 1, "file": 50, "line": 1}, "message": "header is missing header guard"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/pdns/lua-auth4.hh", "reportHash": "8441e075556c0143a8ca0f5a5f8eab55", "checkerName": "llvm-header-guard", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 10, "file": 50, "line": 2}, "message": "\"dnsname.hh\" (fixit)"}, {"location": {"col": 1, "file": 50, "line": 2}, "message": "#includes are not sorted properly"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/pdns/lua-auth4.hh", "reportHash": "a8e8d8e98d6527170c1de92fdc1096de", "checkerName": "llvm-include-order", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 7, "file": 50, "line": 12}, "message": "class 'AuthLua4' defines a non-default destructor but does not define a copy constructor, a copy assignment operator, a move constructor or a move assignment operator"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/pdns/lua-auth4.hh", "reportHash": "a026014dddb4162d8469d51c0ab95e1a", "checkerName": "cppcoreguidelines-special-member-functions", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 113, "file": 50, "line": 17}, "message": "non-const reference parameter at index 3, make it const or use a pointer"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/pdns/lua-auth4.hh", "reportHash": "921c8995cb99960596a5eea8eaa568b8", "checkerName": "google-runtime-references", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 15, "file": 50, "line": 22}, "message": "override (fixit)"}, {"location": {"col": 3, "file": 50, "line": 22}, "message": "annotate this function with 'override' or (rarely) 'final'"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/pdns/lua-auth4.hh", "reportHash": "3ee0cd8bdf549f0f68fcad6fcb01686f", "checkerName": "modernize-use-override", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 16, "file": 50, "line": 24}, "message": "'virtual' is redundant since the function is already declared 'override'"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/pdns/lua-auth4.hh", "reportHash": "1130eeb11733e332ab4c1a7e7efbd741", "checkerName": "modernize-use-override", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 16, "file": 50, "line": 25}, "message": "'virtual' is redundant since the function is already declared 'override'"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/pdns/lua-auth4.hh", "reportHash": "07fc7a69ca64a673c46eba2772061a64", "checkerName": "modernize-use-override", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 3, "file": 50, "line": 37}, "message": "using luacall_update_policy_t = std::function<bool (const UpdatePolicyQuery &)> (fixit)"}, {"location": {"col": 3, "file": 50, "line": 37}, "message": "use 'using' instead of 'typedef'"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/pdns/lua-auth4.hh", "reportHash": "2520e1afb3582f1203f76f0b21cb7e9d", "checkerName": "modernize-use-using", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 3, "file": 50, "line": 38}, "message": "use 'using' instead of 'typedef'"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/pdns/lua-auth4.hh", "reportHash": "48edaf446980a829d8c0b8fa132efc67", "checkerName": "modernize-use-using", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 3, "file": 50, "line": 39}, "message": "using luacall_prequery_t = std::function<bool (DNSPacket *)> (fixit)"}, {"location": {"col": 3, "file": 50, "line": 39}, "message": "use 'using' instead of 'typedef'"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/pdns/lua-auth4.hh", "reportHash": "d9bafbb167467d6c691ca5f7fb6778a8", "checkerName": "modernize-use-using", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 1, "file": 51, "line": 1}, "message": "header is missing header guard"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/pdns/lua-base4.hh", "reportHash": "8bc8ee25f3b2184bf6ba89cc68fee073", "checkerName": "llvm-header-guard", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 7, "file": 51, "line": 9}, "message": "class 'BaseLua4' defines a non-default destructor but does not define a copy constructor, a copy assignment operator, a move constructor or a move assignment operator"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/pdns/lua-base4.hh", "reportHash": "c52016e411eb18235208b6a48424c731", "checkerName": "hicpp-special-member-functions", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 3, "file": 51, "line": 24}, "message": "use 'using' instead of 'typedef'"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/pdns/lua-base4.hh", "reportHash": "60b1a26752adc008d43ae4f5f1a60462", "checkerName": "modernize-use-using", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 3, "file": 51, "line": 26}, "message": "use 'using' instead of 'typedef'"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/pdns/lua-base4.hh", "reportHash": "a03aebae697be182b72d02255abf2a7f", "checkerName": "modernize-use-using", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 37, "file": 51, "line": 27}, "message": "non-const reference parameter at index 0, make it const or use a pointer"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/pdns/lua-base4.hh", "reportHash": "b29a5c43a03a06df0ffc9ce62d39b85a", "checkerName": "google-runtime-references", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 1, "file": 32, "line": 27}, "message": "note: this fix will not be applied because it overlaps with another fix (fixit)"}, {"location": {"col": 10, "file": 32, "line": 27}, "message": "inclusion of deprecated C++ header 'limits.h'; consider using 'climits' instead"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/pdns/misc.hh", "reportHash": "22154dada1fccb8aa4144cc853535a52", "checkerName": "hicpp-deprecated-headers", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 1, "file": 32, "line": 43}, "message": "note: this fix will not be applied because it overlaps with another fix (fixit)"}, {"location": {"col": 10, "file": 32, "line": 43}, "message": "inclusion of deprecated C++ header 'time.h'; consider using 'ctime' instead"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/pdns/misc.hh", "reportHash": "c58292cfcfb3435057b3fdc1cdab9c40", "checkerName": "hicpp-deprecated-headers", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 8, "file": 32, "line": 76}, "message": "constructor does not initialize these fields: port"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/pdns/misc.hh", "reportHash": "3155986e4968f36b0d9e0b2295718614", "checkerName": "hicpp-member-init", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 12, "file": 32, "line": 104}, "message": "{ (fixit)"}, {"location": {"col": 11, "file": 32, "line": 104}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/pdns/misc.hh", "reportHash": "583cfa48abc654bc381b0037c16845ac", "checkerName": "hicpp-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 28, "file": 32, "line": 131}, "message": "{ (fixit)"}, {"location": {"col": 27, "file": 32, "line": 131}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/pdns/misc.hh", "reportHash": "7293be3fdd91b10e6410e8d2f4bf6a99", "checkerName": "google-readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 23, "file": 32, "line": 215}, "message": "nullptr (fixit)"}, {"location": {"col": 23, "file": 32, "line": 215}, "message": "use nullptr"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/pdns/misc.hh", "reportHash": "8aa347901f6175a847827e7b8d5b7a07", "checkerName": "hicpp-use-nullptr", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 21, "file": 32, "line": 229}, "message": "nullptr (fixit)"}, {"location": {"col": 21, "file": 32, "line": 229}, "message": "use nullptr"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/pdns/misc.hh", "reportHash": "67faba07bfaf2f1a9ea0bf606dcfd4da", "checkerName": "modernize-use-nullptr", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 25, "file": 32, "line": 263}, "message": "{ (fixit)"}, {"location": {"col": 24, "file": 32, "line": 263}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/pdns/misc.hh", "reportHash": "2d91d3e0d5ce3d8734d1f3477a904390", "checkerName": "google-readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 72, "file": 32, "line": 325}, "message": "{ (fixit)"}, {"location": {"col": 71, "file": 32, "line": 325}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/pdns/misc.hh", "reportHash": "43b9da6104f926caa4fdd1cae7f6103e", "checkerName": "google-readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 72, "file": 32, "line": 344}, "message": "{ (fixit)"}, {"location": {"col": 71, "file": 32, "line": 344}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/pdns/misc.hh", "reportHash": "8f4231ce6753e7db941ca32e746113d9", "checkerName": "hicpp-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 74, "file": 32, "line": 382}, "message": "{ (fixit)"}, {"location": {"col": 73, "file": 32, "line": 382}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/pdns/misc.hh", "reportHash": "49a262c899c1d0c8bd911b06614b6795", "checkerName": "readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 57, "file": 32, "line": 394}, "message": "{ (fixit)"}, {"location": {"col": 56, "file": 32, "line": 394}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/pdns/misc.hh", "reportHash": "9c55a5058c1104193cae371a5bc06060", "checkerName": "readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 57, "file": 32, "line": 396}, "message": "{ (fixit)"}, {"location": {"col": 56, "file": 32, "line": 396}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/pdns/misc.hh", "reportHash": "d4d19118dc82e8b667f6d3fc309cc79b", "checkerName": "readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 21, "file": 32, "line": 418}, "message": "{ (fixit)"}, {"location": {"col": 20, "file": 32, "line": 418}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/pdns/misc.hh", "reportHash": "2a5f20adcb76d645b004bf4ff384aa45", "checkerName": "readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 40, "file": 32, "line": 425}, "message": "{ (fixit)"}, {"location": {"col": 39, "file": 32, "line": 425}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/pdns/misc.hh", "reportHash": "42feae2e92a68e6a3d28dc0b1ac5042a", "checkerName": "readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 26, "file": 32, "line": 427}, "message": "{ (fixit)"}, {"location": {"col": 25, "file": 32, "line": 427}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/pdns/misc.hh", "reportHash": "2fa1447fae0390db41b77160416d5b64", "checkerName": "hicpp-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 19, "file": 32, "line": 444}, "message": "{ (fixit)"}, {"location": {"col": 18, "file": 32, "line": 444}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/pdns/misc.hh", "reportHash": "01369105ad60eae3e1a043d22e3f61da", "checkerName": "readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 43, "file": 32, "line": 462}, "message": "nullptr (fixit)"}, {"location": {"col": 43, "file": 32, "line": 462}, "message": "use nullptr"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/pdns/misc.hh", "reportHash": "1e6389733e2ec3fb721e5625eb755cb1", "checkerName": "hicpp-use-nullptr", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 25, "file": 32, "line": 486}, "message": "{ (fixit)"}, {"location": {"col": 24, "file": 32, "line": 486}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/pdns/misc.hh", "reportHash": "969f420ea4d1c17c9100b04b80cd9640", "checkerName": "hicpp-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 33, "file": 32, "line": 490}, "message": "{ (fixit)"}, {"location": {"col": 32, "file": 32, "line": 490}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/pdns/misc.hh", "reportHash": "43349df34af03bb6a1c2c82c1d728148", "checkerName": "readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 39, "file": 32, "line": 492}, "message": "{ (fixit)"}, {"location": {"col": 38, "file": 32, "line": 492}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/pdns/misc.hh", "reportHash": "b15dcec5a0a02b96d6b6e35c2d9e7dd1", "checkerName": "readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 41, "file": 32, "line": 498}, "message": "{ (fixit)"}, {"location": {"col": 40, "file": 32, "line": 498}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/pdns/misc.hh", "reportHash": "e90c4f3655f28566adf58b061c64f92a", "checkerName": "readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 53, "file": 32, "line": 500}, "message": "{ (fixit)"}, {"location": {"col": 52, "file": 32, "line": 500}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/pdns/misc.hh", "reportHash": "8ed1005b84a33334e1fc333079588bf7", "checkerName": "readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 23, "file": 32, "line": 584}, "message": "{ (fixit)"}, {"location": {"col": 22, "file": 32, "line": 584}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/pdns/misc.hh", "reportHash": "c3bb5697bba5e6e24b8becf8e2a98818", "checkerName": "readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 8, "file": 32, "line": 586}, "message": "{ (fixit)"}, {"location": {"col": 7, "file": 32, "line": 586}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/pdns/misc.hh", "reportHash": "00d5e4f24d7cb51d8c8f49e2cef38735", "checkerName": "readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 22, "file": 32, "line": 599}, "message": "{ (fixit)"}, {"location": {"col": 21, "file": 32, "line": 599}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/pdns/misc.hh", "reportHash": "e9fb19c23d273e99c6df306335a50b69", "checkerName": "readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 1, "file": 32, "line": 609}, "message": "note: this fix will not be applied because it overlaps with another fix (fixit)"}, {"location": {"col": 63, "file": 32, "line": 609}, "message": "use nullptr"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/pdns/misc.hh", "reportHash": "c87be1e32a06ff1c27808c60a238312f", "checkerName": "modernize-use-nullptr", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 1, "file": 40, "line": 1}, "message": "header is missing header guard"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/pdns/nameserver.hh", "reportHash": "f506b196630d61e4fc8fd7a63801b72c", "checkerName": "llvm-header-guard", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 10, "file": 40, "line": 23}, "message": "<arpa/inet.h> (fixit)"}, {"location": {"col": 1, "file": 40, "line": 23}, "message": "#includes are not sorted properly"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/pdns/nameserver.hh", "reportHash": "e410b936bbdd8b9d6aee08ecb97e2ad5", "checkerName": "llvm-include-order", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 10, "file": 40, "line": 33}, "message": "\"dnspacket.hh\" (fixit)"}, {"location": {"col": 1, "file": 40, "line": 33}, "message": "#includes are not sorted properly"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/pdns/nameserver.hh", "reportHash": "7f965136bb42da6cfad785f0157eefbc", "checkerName": "llvm-include-order", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 3, "file": 40, "line": 81}, "message": "explicit (fixit)"}, {"location": {"col": 3, "file": 40, "line": 81}, "message": "single-argument constructors must be marked explicit to avoid unintentional implicit conversions"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/pdns/nameserver.hh", "reportHash": "00174cd2427e38684dc45f2b77032e47", "checkerName": "hicpp-explicit-conversions", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 18, "file": 40, "line": 81}, "message": "declaring a parameter with a default argument is disallowed"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/pdns/nameserver.hh", "reportHash": "7484a3a2302ff520850786013479d2db", "checkerName": "fuchsia-default-arguments", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 27, "file": 40, "line": 82}, "message": "non-const reference parameter 'packet', make it const or use a pointer"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/pdns/nameserver.hh", "reportHash": "735c688da56323c58c42342846d9345e", "checkerName": "google-runtime-references", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 48, "file": 40, "line": 82}, "message": "non-const reference parameter 'buffer', make it const or use a pointer"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/pdns/nameserver.hh", "reportHash": "678a79cc1d30123cdd3e3efeaf87d3fa", "checkerName": "google-runtime-references", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 23, "file": 40, "line": 83}, "message": "non-const reference parameter at index 0, make it const or use a pointer"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/pdns/nameserver.hh", "reportHash": "1060173732d30ca402a1bd7ab13b2e6f", "checkerName": "google-runtime-references", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 22, "file": 52, "line": 46}, "message": "previously declared here"}, {"location": {"col": 22, "file": 40, "line": 98}, "message": "redundant 'g_rs' declaration"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/pdns/nameserver.hh", "reportHash": "068ba2822a65220340d22e0f3395df51", "checkerName": "readability-redundant-declaration", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 1, "file": 54, "line": 1}, "message": "header is missing header guard"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/pdns/packetcache.hh", "reportHash": "701cccebd2961d00aaeb734aaa0245a7", "checkerName": "llvm-header-guard", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 10, "file": 54, "line": 24}, "message": "\"iputils.hh\" (fixit)"}, {"location": {"col": 1, "file": 54, "line": 24}, "message": "#includes are not sorted properly"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/pdns/packetcache.hh", "reportHash": "1581a3536d2032a20c31f057e8cd7b30", "checkerName": "llvm-include-order", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 18, "file": 54, "line": 33}, "message": "do not use reinterpret_cast"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/pdns/packetcache.hh", "reportHash": "e3696aa49e16bee043fb246a03eb0593", "checkerName": "cppcoreguidelines-pro-type-reinterpret-cast", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 73, "file": 54, "line": 33}, "message": "do not use pointer arithmetic"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/pdns/packetcache.hh", "reportHash": "025be61f882d986263be9a77ff0b9288", "checkerName": "cppcoreguidelines-pro-bounds-pointer-arithmetic", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 38, "file": 54, "line": 36}, "message": "do not use pointer arithmetic"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/pdns/packetcache.hh", "reportHash": "6eec2c024d1ce4b1cfc5dc473b352bae", "checkerName": "cppcoreguidelines-pro-bounds-pointer-arithmetic", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 36, "file": 54, "line": 37}, "message": "do not use pointer arithmetic"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/pdns/packetcache.hh", "reportHash": "db070acc9dc8276694b1d2844c8e0dac", "checkerName": "cppcoreguidelines-pro-bounds-pointer-arithmetic", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 22, "file": 54, "line": 39}, "message": "(  != 0) (fixit)"}, {"location": {"col": 22, "file": 54, "line": 39}, "message": "implicit conversion 'char' -> bool"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/pdns/packetcache.hh", "reportHash": "b3a9777cbe36f9c0d3f04c025a3da026", "checkerName": "readability-implicit-bool-conversion", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 26, "file": 54, "line": 39}, "message": "do not use pointer arithmetic"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/pdns/packetcache.hh", "reportHash": "c6a1cc3e516cee3c454dd56538e796f0", "checkerName": "cppcoreguidelines-pro-bounds-pointer-arithmetic", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 11, "file": 54, "line": 44}, "message": "auto (fixit)"}, {"location": {"col": 11, "file": 54, "line": 44}, "message": "use auto when initializing with a cast to avoid duplicating the type name"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/pdns/packetcache.hh", "reportHash": "e0b923c615411eeb6c8095b6ea66512a", "checkerName": "modernize-use-auto", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 34, "file": 54, "line": 44}, "message": "do not use reinterpret_cast"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/pdns/packetcache.hh", "reportHash": "ecfc83390bd50bd39310d5350bc75d4e", "checkerName": "cppcoreguidelines-pro-type-reinterpret-cast", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 21, "file": 29, "line": 402}, "message": "expanded from macro 'ntohs'"}, {"location": {"col": 7, "file": 33, "line": 28}, "message": "expanded from macro '__bswap_16'"}, {"location": {"col": 8, "file": 54, "line": 56}, "message": "do not call c-style vararg functions"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/pdns/packetcache.hh", "reportHash": "090bcf24f2a8e2c5389d6f065b6d2151", "checkerName": "cppcoreguidelines-pro-type-vararg", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 21, "file": 29, "line": 402}, "message": "expanded from macro 'ntohs'"}, {"location": {"col": 5, "file": 33, "line": 31}, "message": "expanded from macro '__bswap_16'"}, {"location": {"col": 8, "file": 54, "line": 56}, "message": "do not use inline assembler in safety-critical code"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/pdns/packetcache.hh", "reportHash": "b06ae3c7cef5731d6c8ad821302856f6", "checkerName": "hicpp-no-assembler", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 21, "file": 29, "line": 402}, "message": "expanded from macro 'ntohs'"}, {"location": {"col": 11, "file": 33, "line": 29}, "message": "expanded from macro '__bswap_16'"}, {"location": {"col": 29, "file": 30, "line": 32}, "message": "expanded from macro '__bswap_constant_16'"}, {"location": {"col": 8, "file": 54, "line": 56}, "message": "use of a signed integer operand with a binary bitwise operator"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/pdns/packetcache.hh", "reportHash": "4252ad94f69d5ed4f46917aed3f8c81a", "checkerName": "hicpp-signed-bitwise", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 31, "file": 54, "line": 61}, "message": "do not use const_cast"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/pdns/packetcache.hh", "reportHash": "3df4bde9dc2558ae8157ffd44fc42a14", "checkerName": "cppcoreguidelines-pro-type-const-cast", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 49, "file": 54, "line": 61}, "message": "do not use reinterpret_cast"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/pdns/packetcache.hh", "reportHash": "fca2a1cde7125c882d6d642f3c557c1f", "checkerName": "cppcoreguidelines-pro-type-reinterpret-cast", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 83, "file": 54, "line": 61}, "message": "do not use pointer arithmetic"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/pdns/packetcache.hh", "reportHash": "e6d84728e8cc19384b97d960d513ed24", "checkerName": "cppcoreguidelines-pro-bounds-pointer-arithmetic", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 98, "file": 54, "line": 61}, "message": "do not use pointer arithmetic"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/pdns/packetcache.hh", "reportHash": "aa5387254091120bda78fc5e963d9430", "checkerName": "cppcoreguidelines-pro-bounds-pointer-arithmetic", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 31, "file": 54, "line": 64}, "message": "do not use pointer arithmetic"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/pdns/packetcache.hh", "reportHash": "e64c4d3787262676ff70ab63bae5485e", "checkerName": "cppcoreguidelines-pro-bounds-pointer-arithmetic", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 20, "file": 54, "line": 72}, "message": "do not use reinterpret_cast"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/pdns/packetcache.hh", "reportHash": "6ccbb379aafc1552b4809bad15f29a94", "checkerName": "cppcoreguidelines-pro-type-reinterpret-cast", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 20, "file": 54, "line": 75}, "message": "do not use reinterpret_cast"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/pdns/packetcache.hh", "reportHash": "4d4327cc8129752e28ae043a6a98028d", "checkerName": "cppcoreguidelines-pro-type-reinterpret-cast", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 18, "file": 54, "line": 84}, "message": "do not use reinterpret_cast"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/pdns/packetcache.hh", "reportHash": "e3696aa49e16bee043fb246a03eb0593", "checkerName": "cppcoreguidelines-pro-type-reinterpret-cast", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 73, "file": 54, "line": 84}, "message": "do not use pointer arithmetic"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/pdns/packetcache.hh", "reportHash": "025be61f882d986263be9a77ff0b9288", "checkerName": "cppcoreguidelines-pro-bounds-pointer-arithmetic", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 38, "file": 54, "line": 87}, "message": "do not use pointer arithmetic"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/pdns/packetcache.hh", "reportHash": "6eec2c024d1ce4b1cfc5dc473b352bae", "checkerName": "cppcoreguidelines-pro-bounds-pointer-arithmetic", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 36, "file": 54, "line": 88}, "message": "do not use pointer arithmetic"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/pdns/packetcache.hh", "reportHash": "db070acc9dc8276694b1d2844c8e0dac", "checkerName": "cppcoreguidelines-pro-bounds-pointer-arithmetic", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 22, "file": 54, "line": 90}, "message": "(  != 0) (fixit)"}, {"location": {"col": 22, "file": 54, "line": 90}, "message": "implicit conversion 'char' -> bool"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/pdns/packetcache.hh", "reportHash": "9720642e6550fce87604ecade4c1eaa5", "checkerName": "readability-implicit-bool-conversion", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 26, "file": 54, "line": 90}, "message": "do not use pointer arithmetic"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/pdns/packetcache.hh", "reportHash": "8b283fbb5f3986d06f2031682a6d6fce", "checkerName": "cppcoreguidelines-pro-bounds-pointer-arithmetic", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 20, "file": 54, "line": 96}, "message": "do not use reinterpret_cast"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/pdns/packetcache.hh", "reportHash": "d2e54554982245de549ce06603f452b8", "checkerName": "cppcoreguidelines-pro-type-reinterpret-cast", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 1, "file": 55, "line": 1}, "message": "header is missing header guard"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/pdns/packethandler.hh", "reportHash": "5078f12d9362e0a4066839f355644278", "checkerName": "llvm-header-guard", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 10, "file": 55, "line": 23}, "message": "\"dnspacket.hh\" (fixit)"}, {"location": {"col": 1, "file": 55, "line": 23}, "message": "#includes are not sorted properly"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/pdns/packethandler.hh", "reportHash": "d3388a6f3754cc4e3466b710413de884", "checkerName": "llvm-include-order", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 7, "file": 55, "line": 53}, "message": "class 'PacketHandler' defines a non-default destructor but does not define a copy constructor, a copy assignment operator, a move constructor or a move assignment operator"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/pdns/packethandler.hh", "reportHash": "ba2037e1820367172500085f50431683", "checkerName": "cppcoreguidelines-special-member-functions", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 51, "file": 55, "line": 56}, "message": "non-const reference parameter at index 0, make it const or use a pointer"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/pdns/packethandler.hh", "reportHash": "91709810a8e7fca07936be3d056ef837", "checkerName": "google-runtime-references", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 49, "file": 55, "line": 57}, "message": "non-const reference parameter at index 0, make it const or use a pointer"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/pdns/packethandler.hh", "reportHash": "2e2e0cc8f95af604590ae7a90d001796", "checkerName": "google-runtime-references", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 35, "file": 55, "line": 71}, "message": "non-const reference parameter 'r', make it const or use a pointer"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/pdns/packethandler.hh", "reportHash": "8f94b08ca77363ff42848d0703d588c1", "checkerName": "google-runtime-references", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 70, "file": 55, "line": 72}, "message": "non-const reference parameter 'r', make it const or use a pointer"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/pdns/packethandler.hh", "reportHash": "a91a3f9d2c154859e862759eaf2610c6", "checkerName": "google-runtime-references", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 82, "file": 55, "line": 72}, "message": "non-const reference parameter 'target', make it const or use a pointer"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/pdns/packethandler.hh", "reportHash": "b8bef7c560dfe66998d5e7bc818f2bcb", "checkerName": "google-runtime-references", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 29, "file": 55, "line": 73}, "message": "non-const reference parameter 'p', make it const or use a pointer"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/pdns/packethandler.hh", "reportHash": "0b9b9e8ceb02aac7097252ca989ab894", "checkerName": "google-runtime-references", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 60, "file": 55, "line": 73}, "message": "non-const reference parameter 'r', make it const or use a pointer"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/pdns/packethandler.hh", "reportHash": "2e17da673753f481ea82c8ff9c19664f", "checkerName": "google-runtime-references", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 30, "file": 55, "line": 74}, "message": "non-const reference parameter 'p', make it const or use a pointer"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/pdns/packethandler.hh", "reportHash": "e6313434113bf38e48257e0ff32491af", "checkerName": "google-runtime-references", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 61, "file": 55, "line": 74}, "message": "non-const reference parameter 'r', make it const or use a pointer"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/pdns/packethandler.hh", "reportHash": "bdcdbe71036d459e0aa82ce1e6e8fa15", "checkerName": "google-runtime-references", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 26, "file": 55, "line": 75}, "message": "non-const reference parameter 'p', make it const or use a pointer"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/pdns/packethandler.hh", "reportHash": "605e3ef065876389fe356aea8dfcc535", "checkerName": "google-runtime-references", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 57, "file": 55, "line": 75}, "message": "non-const reference parameter 'r', make it const or use a pointer"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/pdns/packethandler.hh", "reportHash": "d0102fc424683e3d6598d608e3a27d07", "checkerName": "google-runtime-references", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 70, "file": 55, "line": 76}, "message": "non-const reference parameter 'r', make it const or use a pointer"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/pdns/packethandler.hh", "reportHash": "9d6978dfa4f85ed157960875c1b93f92", "checkerName": "google-runtime-references", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 50, "file": 55, "line": 77}, "message": "non-const reference parameter 'p', make it const or use a pointer"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/pdns/packethandler.hh", "reportHash": "f276fc2f987686a7e672070bfe19ebb0", "checkerName": "google-runtime-references", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 81, "file": 55, "line": 77}, "message": "non-const reference parameter 'r', make it const or use a pointer"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/pdns/packethandler.hh", "reportHash": "19f137077e3eb2dc8065b32d29689f48", "checkerName": "google-runtime-references", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 28, "file": 55, "line": 78}, "message": "non-const reference parameter 'p', make it const or use a pointer"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/pdns/packethandler.hh", "reportHash": "88333615599a55ad04d1df61fff67316", "checkerName": "google-runtime-references", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 59, "file": 55, "line": 78}, "message": "non-const reference parameter 'r', make it const or use a pointer"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/pdns/packethandler.hh", "reportHash": "864948fd7e20dbdd0fd2d9d4e4265ee7", "checkerName": "google-runtime-references", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 27, "file": 55, "line": 79}, "message": "non-const reference parameter 'p', make it const or use a pointer"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/pdns/packethandler.hh", "reportHash": "fcd3178e0d848829c2bb1468e0b84734", "checkerName": "google-runtime-references", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 58, "file": 55, "line": 79}, "message": "non-const reference parameter 'r', make it const or use a pointer"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/pdns/packethandler.hh", "reportHash": "50743f6e2f893dbaf530e1077d10d820", "checkerName": "google-runtime-references", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 28, "file": 55, "line": 80}, "message": "non-const reference parameter 'p', make it const or use a pointer"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/pdns/packethandler.hh", "reportHash": "2f141bece74658930273d8caca7af179", "checkerName": "google-runtime-references", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 59, "file": 55, "line": 80}, "message": "non-const reference parameter 'r', make it const or use a pointer"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/pdns/packethandler.hh", "reportHash": "0bd6e1ccfec4f887313abcf460bc7a1a", "checkerName": "google-runtime-references", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 45, "file": 55, "line": 81}, "message": "non-const reference parameter 'r', make it const or use a pointer"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/pdns/packethandler.hh", "reportHash": "f376c0a059bb7d2100e7ed116a96c58b", "checkerName": "google-runtime-references", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 46, "file": 55, "line": 82}, "message": "non-const reference parameter 'r', make it const or use a pointer"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/pdns/packethandler.hh", "reportHash": "6ff8de3e302a9d1d53201abcbfdb8efd", "checkerName": "google-runtime-references", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 32, "file": 55, "line": 83}, "message": "non-const reference parameter 'p', make it const or use a pointer"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/pdns/packethandler.hh", "reportHash": "8594ea8a317c89cb91ba749eb4c71284", "checkerName": "google-runtime-references", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 32, "file": 55, "line": 90}, "message": "non-const reference parameter 'p', make it const or use a pointer"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/pdns/packethandler.hh", "reportHash": "c86b47ecf2a617289b9b95369db0c4b4", "checkerName": "google-runtime-references", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 63, "file": 55, "line": 90}, "message": "non-const reference parameter 'r', make it const or use a pointer"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/pdns/packethandler.hh", "reportHash": "b0aa8613fb3862d9c819bca6c54420a8", "checkerName": "google-runtime-references", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 31, "file": 55, "line": 91}, "message": "non-const reference parameter 'p', make it const or use a pointer"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/pdns/packethandler.hh", "reportHash": "4c8c3e12bf4cdbf8bab3909f0bcfcefc", "checkerName": "google-runtime-references", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 62, "file": 55, "line": 91}, "message": "non-const reference parameter 'r', make it const or use a pointer"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/pdns/packethandler.hh", "reportHash": "74cb1c1d3d464f50f7b334ef24fbeadf", "checkerName": "google-runtime-references", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 54, "file": 55, "line": 92}, "message": "non-const reference parameter 'p', make it const or use a pointer"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/pdns/packethandler.hh", "reportHash": "95fd2da066e9e1ee237e3bf79a9b7d42", "checkerName": "google-runtime-references", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 54, "file": 55, "line": 93}, "message": "non-const reference parameter 'p', make it const or use a pointer"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/pdns/packethandler.hh", "reportHash": "349080b9a65d2bc55c3395a8fde999b3", "checkerName": "google-runtime-references", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 85, "file": 55, "line": 93}, "message": "non-const reference parameter 'target', make it const or use a pointer"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/pdns/packethandler.hh", "reportHash": "f788e674657125650ffbc754ab55f44e", "checkerName": "google-runtime-references", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 28, "file": 55, "line": 94}, "message": "non-const reference parameter 'p', make it const or use a pointer"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/pdns/packethandler.hh", "reportHash": "96497a2311c83d1a122afff1a2f5f1ea", "checkerName": "google-runtime-references", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 59, "file": 55, "line": 94}, "message": "non-const reference parameter 'r', make it const or use a pointer"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/pdns/packethandler.hh", "reportHash": "391315715034be0258f7ace693a5b700", "checkerName": "google-runtime-references", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 90, "file": 55, "line": 94}, "message": "non-const reference parameter 'target', make it const or use a pointer"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/pdns/packethandler.hh", "reportHash": "455be3a2dd149218eb3ba241bad3f7c7", "checkerName": "google-runtime-references", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 31, "file": 55, "line": 95}, "message": "non-const reference parameter 'p', make it const or use a pointer"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/pdns/packethandler.hh", "reportHash": "23d87a7f9586c7e8296a3f2ea308f6cf", "checkerName": "google-runtime-references", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 62, "file": 55, "line": 95}, "message": "non-const reference parameter 'r', make it const or use a pointer"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/pdns/packethandler.hh", "reportHash": "6ffa2de36bafe1709a7dec184f4121be", "checkerName": "google-runtime-references", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 35, "file": 55, "line": 97}, "message": "non-const reference parameter 'p', make it const or use a pointer"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/pdns/packethandler.hh", "reportHash": "6802ff924a932b1d8f112f356d7148a7", "checkerName": "google-runtime-references", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 89, "file": 55, "line": 97}, "message": "non-const reference parameter 'wildcard', make it const or use a pointer"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/pdns/packethandler.hh", "reportHash": "df5ff0ffda9a7d018aa3d68fb6a1acd2", "checkerName": "google-runtime-references", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 31, "file": 55, "line": 98}, "message": "non-const reference parameter 'p', make it const or use a pointer"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/pdns/packethandler.hh", "reportHash": "a6531e9f26be174b4291f528d4ac8e44", "checkerName": "google-runtime-references", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 62, "file": 55, "line": 98}, "message": "non-const reference parameter 'r', make it const or use a pointer"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/pdns/packethandler.hh", "reportHash": "091f5cb5de8d450ff4200ab5b7b14486", "checkerName": "google-runtime-references", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 93, "file": 55, "line": 98}, "message": "non-const reference parameter 'target', make it const or use a pointer"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/pdns/packethandler.hh", "reportHash": "ecbe41b20509c0178babe8a89d3a5285", "checkerName": "google-runtime-references", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 110, "file": 55, "line": 98}, "message": "non-const reference parameter 'wildcard', make it const or use a pointer"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/pdns/packethandler.hh", "reportHash": "db673161b5b7b74fc02649a4277d6fc2", "checkerName": "google-runtime-references", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 126, "file": 55, "line": 98}, "message": "non-const reference parameter 'retargeted', make it const or use a pointer"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/pdns/packethandler.hh", "reportHash": "80ec605849177f0e8e1ea49bc76c1d8f", "checkerName": "google-runtime-references", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 144, "file": 55, "line": 98}, "message": "non-const reference parameter 'nodata', make it const or use a pointer"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/pdns/packethandler.hh", "reportHash": "1a9967ff235f1ce40a55dcf9bba7bc12", "checkerName": "google-runtime-references", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 30, "file": 55, "line": 99}, "message": "non-const reference parameter 'p', make it const or use a pointer"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/pdns/packethandler.hh", "reportHash": "a50835384e3c74da16dbf6a5845503e7", "checkerName": "google-runtime-references", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 61, "file": 55, "line": 99}, "message": "non-const reference parameter 'r', make it const or use a pointer"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/pdns/packethandler.hh", "reportHash": "0640d2c4b28fb2cdfa2f22fd00d35d5b", "checkerName": "google-runtime-references", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 38, "file": 55, "line": 100}, "message": "non-const reference parameter 'p', make it const or use a pointer"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/pdns/packethandler.hh", "reportHash": "e4a414dc3420ede09a02e39727794ce8", "checkerName": "google-runtime-references", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 69, "file": 55, "line": 100}, "message": "non-const reference parameter 'r', make it const or use a pointer"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/pdns/packethandler.hh", "reportHash": "6a9d4116d2372f2a725eaf709970cc81", "checkerName": "google-runtime-references", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 68, "file": 55, "line": 102}, "message": "non-const reference parameter 'r', make it const or use a pointer"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/pdns/packethandler.hh", "reportHash": "0111a494508de4e738418e3f980e6d63", "checkerName": "google-runtime-references", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 3, "file": 46, "line": 41}, "message": "explicit (fixit)"}, {"location": {"col": 3, "file": 46, "line": 41}, "message": "single-argument constructors must be marked explicit to avoid unintentional implicit conversions"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/pdns/pdnsexception.hh", "reportHash": "d67491a13985f9a8d0cac6492fc664a4", "checkerName": "hicpp-explicit-conversions", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 7, "file": 56, "line": 43}, "message": "class 'QType' defines a copy constructor and a copy assignment operator but does not define a destructor, a move constructor or a move assignment operator"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/pdns/qtype.hh", "reportHash": "9d754230dd9ebae6616eea3f2de146bc", "checkerName": "cppcoreguidelines-special-member-functions", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 3, "file": 56, "line": 132}, "message": "explicit (fixit)"}, {"location": {"col": 3, "file": 56, "line": 132}, "message": "single-argument constructors must be marked explicit to avoid unintentional implicit conversions"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/pdns/qtype.hh", "reportHash": "0df226d0889e815e196499e1f1dadcfe", "checkerName": "hicpp-explicit-conversions", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 10, "file": 57, "line": 23}, "message": "<cinttypes> (fixit)"}, {"location": {"col": 10, "file": 57, "line": 23}, "message": "inclusion of deprecated C++ header 'inttypes.h'; consider using 'cinttypes' instead"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/pdns/rcpgenerator.hh", "reportHash": "9906fe77ed3ede8d6adbc72d72e4be71", "checkerName": "modernize-deprecated-headers", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 3, "file": 57, "line": 34}, "message": "explicit (fixit)"}, {"location": {"col": 3, "file": 57, "line": 34}, "message": "single-argument constructors must be marked explicit to avoid unintentional implicit conversions"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/pdns/rcpgenerator.hh", "reportHash": "2324f406f5fa14fe9ca8d829c9dba3b5", "checkerName": "google-explicit-constructor", "reviewStatus": null, "severity": "MEDIUM"}, {"events": [{"location": {"col": 3, "file": 57, "line": 41}, "message": "explicit (fixit)"}, {"location": {"col": 3, "file": 57, "line": 41}, "message": "constructors that are callable with a single argument must be marked explicit to avoid unintentional implicit conversions"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/pdns/rcpgenerator.hh", "reportHash": "c114fb985acc5ae291c06e7c87f2f764", "checkerName": "hicpp-explicit-conversions", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 1, "file": 52, "line": 1}, "message": "header is missing header guard"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/pdns/responsestats.hh", "reportHash": "e630c933751db3c27ac072d1e7fe7685", "checkerName": "llvm-header-guard", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 10, "file": 52, "line": 23}, "message": "\"dnspacket.hh\" (fixit)"}, {"location": {"col": 1, "file": 52, "line": 23}, "message": "#includes are not sorted properly"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/pdns/responsestats.hh", "reportHash": "8b407b8def4f5c4916573384acb89a6a", "checkerName": "llvm-include-order", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 34, "file": 52, "line": 31}, "message": "non-const reference parameter 'p', make it const or use a pointer"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/pdns/responsestats.hh", "reportHash": "b66beac27d422c2d1949ec19be9bae36", "checkerName": "google-runtime-references", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 35, "file": 52, "line": 40}, "message": "consider replacing 'unsigned long' with 'uint64'"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/pdns/responsestats.hh", "reportHash": "cbb8718540650fb9a7ce253f648815e7", "checkerName": "google-runtime-int", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 35, "file": 52, "line": 41}, "message": "consider replacing 'unsigned long' with 'uint64'"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/pdns/responsestats.hh", "reportHash": "0e8ca779c33da9b47a8e9ebd6fdeeb44", "checkerName": "google-runtime-int", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 3, "file": 52, "line": 42}, "message": "use 'using' instead of 'typedef'"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/pdns/responsestats.hh", "reportHash": "0e2f9e9e0eee4aeea0120ac189932994", "checkerName": "modernize-use-using", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 7, "file": 58, "line": 36}, "message": "class 'StatRing' defines a copy constructor and a copy assignment operator but does not define a destructor, a move constructor or a move assignment operator"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/pdns/statbag.hh", "reportHash": "43a3d6ecec0e24994a8a181fd965102c", "checkerName": "cppcoreguidelines-special-member-functions", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 37, "file": 58, "line": 111}, "message": "{ (fixit)"}, {"location": {"col": 36, "file": 58, "line": 111}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/pdns/statbag.hh", "reportHash": "68764ab36b517a65385cd2d6df4a89e1", "checkerName": "hicpp-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 44, "file": 58, "line": 119}, "message": "{ (fixit)"}, {"location": {"col": 43, "file": 58, "line": 119}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/pdns/statbag.hh", "reportHash": "48c9d17af8696e1f00fda00490806be5", "checkerName": "hicpp-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 1, "file": 59, "line": 1}, "message": "header is missing header guard"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/pdns/tcpreceiver.hh", "reportHash": "f589570a144b288f9e40daa1f333af6e", "checkerName": "llvm-header-guard", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 10, "file": 59, "line": 24}, "message": "\"dnsbackend.hh\" (fixit)"}, {"location": {"col": 1, "file": 59, "line": 24}, "message": "#includes are not sorted properly"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/pdns/tcpreceiver.hh", "reportHash": "c9908827379c0a3330fb3b9b3d27e6bf", "checkerName": "llvm-include-order", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 7, "file": 59, "line": 42}, "message": "class 'TCPNameserver' defines a non-default destructor but does not define a copy constructor, a copy assignment operator, a move constructor or a move assignment operator"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/pdns/tcpreceiver.hh", "reportHash": "51770a2c8b7abb2000b7ca24ab2f0445", "checkerName": "hicpp-special-member-functions", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 54, "file": 59, "line": 51}, "message": "non-const reference parameter 'p', make it const or use a pointer"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/pdns/tcpreceiver.hh", "reportHash": "bda84d692957a52bbe8bb453a58c3b3f", "checkerName": "google-runtime-references", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 72, "file": 59, "line": 54}, "message": "non-const reference parameter 'q', make it const or use a pointer"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/pdns/tcpreceiver.hh", "reportHash": "4469ddf06c95580c03f5abe410298fdb", "checkerName": "google-runtime-references", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 49, "file": 59, "line": 55}, "message": "non-const reference parameter 'q', make it const or use a pointer"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/pdns/tcpreceiver.hh", "reportHash": "8bbf6a03e6f5f86906cb56e6dc3db4d3", "checkerName": "google-runtime-references", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 53, "file": 59, "line": 56}, "message": "non-const reference parameter 'q', make it const or use a pointer"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/pdns/tcpreceiver.hh", "reportHash": "72a94f9b4514d8a643ddf536f95bdaff", "checkerName": "google-runtime-references", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 15, "file": 59, "line": 59}, "message": "redundant void argument list in function declaration"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/pdns/tcpreceiver.hh", "reportHash": "883e66c3ed69091146898e487401c104", "checkerName": "modernize-redundant-void-arg", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 1, "file": 60, "line": 1}, "message": "header is missing header guard"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/pdns/threadname.hh", "reportHash": "61ccbef1fad5ac3eb0b3cb0041fae57c", "checkerName": "llvm-header-guard", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 1, "file": 21, "line": 1}, "message": "header is missing header guard"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/pdns/ueberbackend.hh", "reportHash": "4f91bce41f253e7c2ee2e66def24fe40", "checkerName": "llvm-header-guard", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 10, "file": 21, "line": 23}, "message": "<algorithm> (fixit)"}, {"location": {"col": 1, "file": 21, "line": 23}, "message": "#includes are not sorted properly"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/pdns/ueberbackend.hh", "reportHash": "d9b9847c772d9ed2aab8df1814d7f189", "checkerName": "llvm-include-order", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 10, "file": 21, "line": 32}, "message": "\"dnsbackend.hh\" (fixit)"}, {"location": {"col": 1, "file": 21, "line": 32}, "message": "#includes are not sorted properly"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/pdns/ueberbackend.hh", "reportHash": "99e0521e213ed0ca2f57792ed39b6b0a", "checkerName": "llvm-include-order", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 7, "file": 21, "line": 43}, "message": "class 'UeberBackend' defines a non-default destructor but does not define a copy constructor, a copy assignment operator, a move constructor or a move assignment operator"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/pdns/ueberbackend.hh", "reportHash": "d93cf2c468a3b6c2a37c130b64699639", "checkerName": "cppcoreguidelines-special-member-functions", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 3, "file": 21, "line": 46}, "message": "explicit (fixit)"}, {"location": {"col": 3, "file": 21, "line": 46}, "message": "single-argument constructors must be marked explicit to avoid unintentional implicit conversions"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/pdns/ueberbackend.hh", "reportHash": "9f76695d4f3077b41d9570ef8265b4d1", "checkerName": "google-explicit-constructor", "reviewStatus": null, "severity": "MEDIUM"}, {"events": [{"location": {"col": 16, "file": 21, "line": 46}, "message": "declaring a parameter with a default argument is disallowed"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/pdns/ueberbackend.hh", "reportHash": "4e3e69af8d79db4c7fd84b646949c03a", "checkerName": "fuchsia-default-arguments", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 39, "file": 3, "line": 509}, "message": "default parameter was declared here"}, {"location": {"col": 36, "file": 21, "line": 46}, "message": "calling a function that uses a default argument is disallowed"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/pdns/ueberbackend.hh", "reportHash": "316791578fe2a0f6aaa1d98851cae9dc", "checkerName": "fuchsia-default-arguments", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 18, "file": 21, "line": 62}, "message": "redundant void argument list in function declaration"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/pdns/ueberbackend.hh", "reportHash": "9f2704f29110b4539a598079cdc78603", "checkerName": "modernize-redundant-void-arg", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 9, "file": 21, "line": 71}, "message": "class 'handle' defines a non-default destructor but does not define a copy constructor, a copy assignment operator, a move constructor or a move assignment operator"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/pdns/ueberbackend.hh", "reportHash": "5dd5bb945c772d99f7a3a1f0e2149633", "checkerName": "cppcoreguidelines-special-member-functions", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 29, "file": 21, "line": 74}, "message": "non-const reference parameter 'dr', make it const or use a pointer"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/pdns/ueberbackend.hh", "reportHash": "f98835e17ffb87fd122969ed6e18a01a", "checkerName": "google-runtime-references", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 66, "file": 21, "line": 96}, "message": "declaring a parameter with a default argument is disallowed"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/pdns/ueberbackend.hh", "reportHash": "c87429ff6ea9165f604f5dc9947d87bb", "checkerName": "fuchsia-default-arguments", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 72, "file": 21, "line": 99}, "message": "declaring a parameter with a default argument is disallowed"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/pdns/ueberbackend.hh", "reportHash": "7459835f17e86bf1d7937780baacc266", "checkerName": "fuchsia-default-arguments", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 47, "file": 21, "line": 100}, "message": "non-const reference parameter 'sd', make it const or use a pointer"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/pdns/ueberbackend.hh", "reportHash": "aebe039c45185892cc918341e262febe", "checkerName": "google-runtime-references", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 55, "file": 21, "line": 102}, "message": "non-const reference parameter 'sd', make it const or use a pointer"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/pdns/ueberbackend.hh", "reportHash": "03d30c18e253a0d76d4eeae1c7375370", "checkerName": "google-runtime-references", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 27, "file": 21, "line": 103}, "message": "non-const reference parameter 'r', make it const or use a pointer"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/pdns/ueberbackend.hh", "reportHash": "bdeb31a98b2c0cd0e4c959f38d213089", "checkerName": "google-runtime-references", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 51, "file": 21, "line": 104}, "message": "declaring a parameter with a default argument is disallowed"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/pdns/ueberbackend.hh", "reportHash": "6c4374f9989e865b546ec592729c278f", "checkerName": "fuchsia-default-arguments", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 57, "file": 21, "line": 108}, "message": "non-const reference parameter 'di', make it const or use a pointer"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/pdns/ueberbackend.hh", "reportHash": "483fdd02218992b9adf3347018a1b21a", "checkerName": "google-runtime-references", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 61, "file": 21, "line": 108}, "message": "declaring a parameter with a default argument is disallowed"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/pdns/ueberbackend.hh", "reportHash": "1df642b5b1ce9180024022e87a94d248", "checkerName": "fuchsia-default-arguments", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 44, "file": 21, "line": 109}, "message": "parameter 'kind' is const-qualified in the function declaration; const-qualification of parameters only has an effect in function definitions"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/pdns/ueberbackend.hh", "reportHash": "0755a14d9597bc825a4790ec25e23925", "checkerName": "readability-avoid-const-params-in-decls", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 83, "file": 21, "line": 112}, "message": "non-const reference parameter 'id', make it const or use a pointer"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/pdns/ueberbackend.hh", "reportHash": "296575ad62e8ebba2afb40293236e99a", "checkerName": "google-runtime-references", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 77, "file": 21, "line": 113}, "message": "non-const reference parameter 'keys', make it const or use a pointer"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/pdns/ueberbackend.hh", "reportHash": "c1910dc22ad5829d91c107bdc019a474", "checkerName": "google-runtime-references", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 100, "file": 21, "line": 114}, "message": "non-const reference parameter 'meta', make it const or use a pointer"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/pdns/ueberbackend.hh", "reportHash": "7bd2528715b9377a5ae0950ac22d4bec", "checkerName": "google-runtime-references", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 98, "file": 21, "line": 115}, "message": "non-const reference parameter 'meta', make it const or use a pointer"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/pdns/ueberbackend.hh", "reportHash": "e2a7e270bb99a35b23d0a7df0f08a9d8", "checkerName": "google-runtime-references", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 51, "file": 21, "line": 127}, "message": "non-const reference parameter 'keys', make it const or use a pointer"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/pdns/ueberbackend.hh", "reportHash": "4eb698e49020cb2c9dd0e4e5f3ec2331", "checkerName": "google-runtime-references", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 19, "file": 21, "line": 130}, "message": "declaring a parameter with a default argument is disallowed"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/pdns/ueberbackend.hh", "reportHash": "93c1ba9db8b7963e9c311d369c802879", "checkerName": "fuchsia-default-arguments", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 1, "file": 21, "line": 130}, "message": "note: this fix will not be applied because it overlaps with another fix (fixit)"}, {"location": {"col": 34, "file": 21, "line": 130}, "message": "use nullptr"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/pdns/ueberbackend.hh", "reportHash": "61b0c56081d1c4fb8a549c1e4cb264fe", "checkerName": "hicpp-use-nullptr", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 88, "file": 21, "line": 132}, "message": "non-const reference parameter 'result', make it const or use a pointer"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/pdns/ueberbackend.hh", "reportHash": "7ad45251a4e1e06f0a54488a8cf5a1e5", "checkerName": "google-runtime-references", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 79, "file": 21, "line": 133}, "message": "non-const reference parameter 'result', make it const or use a pointer"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/pdns/ueberbackend.hh", "reportHash": "88727e058d7c7bf679d02e6fbbee08ab", "checkerName": "google-runtime-references", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 58, "file": 21, "line": 158}, "message": "non-const reference parameter 'rrs', make it const or use a pointer"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/pdns/ueberbackend.hh", "reportHash": "7fcdbc1e2f7b1559e9ab6027fe30946c", "checkerName": "google-runtime-references", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 1, "file": 61, "line": 1}, "message": "header is missing header guard"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/pdns/utility.hh", "reportHash": "d1f8615a99e1acde0bad4ce92cc6276e", "checkerName": "llvm-header-guard", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 10, "file": 61, "line": 33}, "message": "<errno.h> (fixit)"}, {"location": {"col": 1, "file": 61, "line": 33}, "message": "#includes are not sorted properly"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/pdns/utility.hh", "reportHash": "03caba85299905e51b5711c5a759bbce", "checkerName": "llvm-include-order", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 10, "file": 61, "line": 37}, "message": "<csignal> (fixit)"}, {"location": {"col": 10, "file": 61, "line": 37}, "message": "inclusion of deprecated C++ header 'signal.h'; consider using 'csignal' instead"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/pdns/utility.hh", "reportHash": "0f21a35b1238f0196493bd09867f7c1c", "checkerName": "hicpp-deprecated-headers", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 1, "file": 61, "line": 40}, "message": "note: this fix will not be applied because it overlaps with another fix (fixit)"}, {"location": {"col": 10, "file": 61, "line": 40}, "message": "inclusion of deprecated C++ header 'signal.h'; consider using 'csignal' instead"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/pdns/utility.hh", "reportHash": "7940a10a7dd44f7dd7a182a0409dd589", "checkerName": "modernize-deprecated-headers", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 1, "file": 61, "line": 41}, "message": "note: this fix will not be applied because it overlaps with another fix (fixit)"}, {"location": {"col": 10, "file": 61, "line": 41}, "message": "inclusion of deprecated C++ header 'errno.h'; consider using 'cerrno' instead"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/pdns/utility.hh", "reportHash": "0e9a178099faffe0681f7830e5e33de1", "checkerName": "modernize-deprecated-headers", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 7, "file": 61, "line": 48}, "message": "class 'Semaphore' defines a non-default destructor, a copy constructor and a copy assignment operator but does not define a move constructor or a move assignment operator"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/pdns/utility.hh", "reportHash": "1fdbeb668192c299698417560ad1f9d9", "checkerName": "cppcoreguidelines-special-member-functions", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 3, "file": 61, "line": 51}, "message": "using sem_value_t = int (fixit)"}, {"location": {"col": 3, "file": 61, "line": 51}, "message": "use 'using' instead of 'typedef'"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/pdns/utility.hh", "reportHash": "599e3ec833d91816c035d85cc1dff530", "checkerName": "modernize-use-using", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 3, "file": 61, "line": 68}, "message": "explicit (fixit)"}, {"location": {"col": 3, "file": 61, "line": 68}, "message": "single-argument constructors must be marked explicit to avoid unintentional implicit conversions"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/pdns/utility.hh", "reportHash": "c6c3082e526132374d163163ce826caa", "checkerName": "google-explicit-constructor", "reviewStatus": null, "severity": "MEDIUM"}, {"events": [{"location": {"col": 14, "file": 61, "line": 68}, "message": "declaring a parameter with a default argument is disallowed"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/pdns/utility.hh", "reportHash": "d550a6525e1c9b66fb08771147c1ab33", "checkerName": "fuchsia-default-arguments", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 15, "file": 61, "line": 71}, "message": "redundant void argument list in function declaration"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/pdns/utility.hh", "reportHash": "1a565c87d0b37abfa2fe574f5063b6b5", "checkerName": "modernize-redundant-void-arg", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 13, "file": 61, "line": 74}, "message": "redundant void argument list in function declaration"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/pdns/utility.hh", "reportHash": "52b36165cc9e4a7c31f7df04b2afa467", "checkerName": "modernize-redundant-void-arg", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 13, "file": 61, "line": 77}, "message": "redundant void argument list in function declaration"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/pdns/utility.hh", "reportHash": "0278f20694aeb04b6efcc35618385e61", "checkerName": "modernize-redundant-void-arg", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 16, "file": 61, "line": 80}, "message": "redundant void argument list in function declaration"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/pdns/utility.hh", "reportHash": "723448fde000e49900a0fcaa83e6b36b", "checkerName": "modernize-redundant-void-arg", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 3, "file": 61, "line": 90}, "message": "using iovec = ::iovec (fixit)"}, {"location": {"col": 3, "file": 61, "line": 90}, "message": "use 'using' instead of 'typedef'"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/pdns/utility.hh", "reportHash": "2ddf995a8e53a1633c882699c3533e37", "checkerName": "modernize-use-using", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 3, "file": 61, "line": 91}, "message": "using pid_t = ::pid_t (fixit)"}, {"location": {"col": 3, "file": 61, "line": 91}, "message": "use 'using' instead of 'typedef'"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/pdns/utility.hh", "reportHash": "84965b8b92f057c24876b1c30da95cec", "checkerName": "modernize-use-using", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 3, "file": 61, "line": 92}, "message": "using sock_t = int (fixit)"}, {"location": {"col": 3, "file": 61, "line": 92}, "message": "use 'using' instead of 'typedef'"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/pdns/utility.hh", "reportHash": "5a3becda912093942daa6ce1ce09a37c", "checkerName": "modernize-use-using", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 3, "file": 61, "line": 93}, "message": "using socklen_t = ::socklen_t (fixit)"}, {"location": {"col": 3, "file": 61, "line": 93}, "message": "use 'using' instead of 'typedef'"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/pdns/utility.hh", "reportHash": "702dc3a12abc8e383a8e8c1e7cfcf71d", "checkerName": "modernize-use-using", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 24, "file": 61, "line": 107}, "message": "redundant void argument list in function declaration"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/pdns/utility.hh", "reportHash": "03e09648253646fd1df14b394fa9703d", "checkerName": "modernize-redundant-void-arg", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 48, "file": 61, "line": 110}, "message": "declaring a parameter with a default argument is disallowed"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/pdns/utility.hh", "reportHash": "89ca9c486f267b1aa176ec2173ddea56", "checkerName": "fuchsia-default-arguments", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 59, "file": 61, "line": 110}, "message": "nullptr (fixit)"}, {"location": {"col": 59, "file": 61, "line": 110}, "message": "use nullptr"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/pdns/utility.hh", "reportHash": "4ed25890599b7b593f58bde76918b2c4", "checkerName": "modernize-use-nullptr", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 23, "file": 61, "line": 125}, "message": "redundant void argument list in function declaration"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/pdns/utility.hh", "reportHash": "36fd63c97f26724e719250ed14502fe4", "checkerName": "modernize-redundant-void-arg", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 23, "file": 61, "line": 140}, "message": "consider replacing 'unsigned long' with 'uint64'"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/pdns/utility.hh", "reportHash": "01d4344d94e0dd722cedfa8bac01834c", "checkerName": "google-runtime-int", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 9, "file": 63, "line": 8}, "message": "LUAJIT_2_1_LAUXLIB_H (fixit)"}, {"location": {"col": 9, "file": 63, "line": 8}, "message": "header guard does not follow preferred style"}], "macros": [], "notes": [], "path": "/usr/include/luajit-2.1/lauxlib.h", "reportHash": "c815140baa5502bc135263c4b163d8fe", "checkerName": "llvm-header-guard", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 10, "file": 63, "line": 12}, "message": "<cstddef> (fixit)"}, {"location": {"col": 10, "file": 63, "line": 12}, "message": "inclusion of deprecated C++ header 'stddef.h'; consider using 'cstddef' instead"}], "macros": [], "notes": [], "path": "/usr/include/luajit-2.1/lauxlib.h", "reportHash": "5144f8b04310124716ac48966fc334a8", "checkerName": "modernize-deprecated-headers", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 10, "file": 63, "line": 13}, "message": "<cstdio> (fixit)"}, {"location": {"col": 10, "file": 63, "line": 13}, "message": "inclusion of deprecated C++ header 'stdio.h'; consider using 'cstdio' instead"}], "macros": [], "notes": [], "path": "/usr/include/luajit-2.1/lauxlib.h", "reportHash": "5841359f11f0e37013b5292a9dcc851e", "checkerName": "hicpp-deprecated-headers", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 1, "file": 63, "line": 21}, "message": "use 'using' instead of 'typedef'"}], "macros": [], "notes": [], "path": "/usr/include/luajit-2.1/lauxlib.h", "reportHash": "fa7ae24870443c1e18394a8ac74a817e", "checkerName": "modernize-use-using", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 1, "file": 63, "line": 135}, "message": "use 'using' instead of 'typedef'"}], "macros": [], "notes": [], "path": "/usr/include/luajit-2.1/lauxlib.h", "reportHash": "7f36327b0eec9268a32ca4f93917886c", "checkerName": "modernize-use-using", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 9, "file": 2, "line": 9}, "message": "LUAJIT_2_1_LUA_H (fixit)"}, {"location": {"col": 9, "file": 2, "line": 9}, "message": "header guard does not follow preferred style"}], "macros": [], "notes": [], "path": "/usr/include/luajit-2.1/lua.h", "reportHash": "86c413522c85a60653f6e20b585d923f", "checkerName": "llvm-header-guard", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 10, "file": 2, "line": 12}, "message": "<cstdarg> (fixit)"}, {"location": {"col": 10, "file": 2, "line": 12}, "message": "inclusion of deprecated C++ header 'stdarg.h'; consider using 'cstdarg' instead"}], "macros": [], "notes": [], "path": "/usr/include/luajit-2.1/lua.h", "reportHash": "2de818c831da02347b339d1a7c3c2bec", "checkerName": "modernize-deprecated-headers", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 10, "file": 2, "line": 13}, "message": "<cstddef> (fixit)"}, {"location": {"col": 10, "file": 2, "line": 13}, "message": "inclusion of deprecated C++ header 'stddef.h'; consider using 'cstddef' instead"}], "macros": [], "notes": [], "path": "/usr/include/luajit-2.1/lua.h", "reportHash": "50ee2f2e6994d91c47c76ece70762941", "checkerName": "modernize-deprecated-headers", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 1, "file": 2, "line": 51}, "message": "using lua_State = struct lua_State (fixit)"}, {"location": {"col": 1, "file": 2, "line": 51}, "message": "use 'using' instead of 'typedef'"}], "macros": [], "notes": [], "path": "/usr/include/luajit-2.1/lua.h", "reportHash": "b329721c1238739b23b74ee8dd80f240", "checkerName": "modernize-use-using", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 1, "file": 2, "line": 53}, "message": "using lua_CFunction = int (*)(lua_State *) (fixit)"}, {"location": {"col": 1, "file": 2, "line": 53}, "message": "use 'using' instead of 'typedef'"}], "macros": [], "notes": [], "path": "/usr/include/luajit-2.1/lua.h", "reportHash": "5d3dbcee268ef49a760a3da1dc0ab3e3", "checkerName": "modernize-use-using", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 1, "file": 2, "line": 59}, "message": "using lua_Reader = const char *(*)(lua_State *, void *, size_t *) (fixit)"}, {"location": {"col": 1, "file": 2, "line": 59}, "message": "use 'using' instead of 'typedef'"}], "macros": [], "notes": [], "path": "/usr/include/luajit-2.1/lua.h", "reportHash": "4bfb2657f44a3cae48a48bad2e48102c", "checkerName": "modernize-use-using", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 1, "file": 2, "line": 61}, "message": "using lua_Writer = int (*)(lua_State *, const void *, size_t, void *) (fixit)"}, {"location": {"col": 1, "file": 2, "line": 61}, "message": "use 'using' instead of 'typedef'"}], "macros": [], "notes": [], "path": "/usr/include/luajit-2.1/lua.h", "reportHash": "617263f74eb5066a1db274b125ad1f2f", "checkerName": "modernize-use-using", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 1, "file": 2, "line": 67}, "message": "using lua_Alloc = void *(*)(void *, void *, size_t, size_t) (fixit)"}, {"location": {"col": 1, "file": 2, "line": 67}, "message": "use 'using' instead of 'typedef'"}], "macros": [], "notes": [], "path": "/usr/include/luajit-2.1/lua.h", "reportHash": "c6abacb77d31d25fc195e2f9b993f7ec", "checkerName": "modernize-use-using", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 1, "file": 2, "line": 100}, "message": "using lua_Number = double (fixit)"}, {"location": {"col": 1, "file": 2, "line": 100}, "message": "use 'using' instead of 'typedef'"}], "macros": [], "notes": [], "path": "/usr/include/luajit-2.1/lua.h", "reportHash": "2f7e03fabc43c738105543402053e158", "checkerName": "modernize-use-using", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 1, "file": 2, "line": 104}, "message": "using lua_Integer = ptrdiff_t (fixit)"}, {"location": {"col": 1, "file": 2, "line": 104}, "message": "use 'using' instead of 'typedef'"}], "macros": [], "notes": [], "path": "/usr/include/luajit-2.1/lua.h", "reportHash": "ea59851c5994595fcc487da878f5e0c5", "checkerName": "modernize-use-using", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 1, "file": 2, "line": 328}, "message": "using lua_Debug = struct lua_Debug (fixit)"}, {"location": {"col": 1, "file": 2, "line": 328}, "message": "use 'using' instead of 'typedef'"}], "macros": [], "notes": [], "path": "/usr/include/luajit-2.1/lua.h", "reportHash": "005a1c827a7a97aaabad3819e826dc50", "checkerName": "modernize-use-using", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 1, "file": 2, "line": 332}, "message": "using lua_Hook = void (*)(lua_State *, lua_Debug *) (fixit)"}, {"location": {"col": 1, "file": 2, "line": 332}, "message": "use 'using' instead of 'typedef'"}], "macros": [], "notes": [], "path": "/usr/include/luajit-2.1/lua.h", "reportHash": "20bb6788745db993efd7ddd3ca0f8508", "checkerName": "modernize-use-using", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 1, "file": 64, "line": 1}, "message": "header is missing header guard"}], "macros": [], "notes": [], "path": "/usr/include/luajit-2.1/lua.hpp", "reportHash": "2fba9902d5a93c21335fdc6bd38ac110", "checkerName": "llvm-header-guard", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 10, "file": 64, "line": 4}, "message": "\"lauxlib.h\" (fixit)"}, {"location": {"col": 1, "file": 64, "line": 4}, "message": "#includes are not sorted properly"}], "macros": [], "notes": [], "path": "/usr/include/luajit-2.1/lua.hpp", "reportHash": "07ac2ff97eaef5f48f1807b8062b47ba", "checkerName": "llvm-include-order", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 9, "file": 65, "line": 6}, "message": "LUAJIT_2_1_LUACONF_H (fixit)"}, {"location": {"col": 9, "file": 65, "line": 6}, "message": "header guard does not follow preferred style"}], "macros": [], "notes": [], "path": "/usr/include/luajit-2.1/luaconf.h", "reportHash": "4db02f7c72d7330f1c5cec25f5b07910", "checkerName": "llvm-header-guard", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 10, "file": 65, "line": 12}, "message": "<climits> (fixit)"}, {"location": {"col": 10, "file": 65, "line": 12}, "message": "inclusion of deprecated C++ header 'limits.h'; consider using 'climits' instead"}], "macros": [], "notes": [], "path": "/usr/include/luajit-2.1/luaconf.h", "reportHash": "70dd5e8028815794b9572330da2fb2c0", "checkerName": "hicpp-deprecated-headers", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 10, "file": 65, "line": 13}, "message": "<cstddef> (fixit)"}, {"location": {"col": 10, "file": 65, "line": 13}, "message": "inclusion of deprecated C++ header 'stddef.h'; consider using 'cstddef' instead"}], "macros": [], "notes": [], "path": "/usr/include/luajit-2.1/luaconf.h", "reportHash": "6f11a3d8b24ad6ac9de23412edc3d15d", "checkerName": "hicpp-deprecated-headers", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 41, "file": 65, "line": 149}, "message": "() (fixit)"}, {"location": {"col": 37, "file": 65, "line": 149}, "message": "macro argument should be enclosed in parentheses"}], "macros": [], "notes": [], "path": "/usr/include/luajit-2.1/luaconf.h", "reportHash": "d5d57ff4fabb6a6afde20b425691262e", "checkerName": "misc-macro-parentheses", "reviewStatus": null, "severity": "MEDIUM"}, {"events": [{"location": {"col": 9, "file": 66, "line": 28}, "message": "LUAJIT_2_1_LUAJIT_H (fixit)"}, {"location": {"col": 9, "file": 66, "line": 28}, "message": "header guard does not follow preferred style"}], "macros": [], "notes": [], "path": "/usr/include/luajit-2.1/luajit.h", "reportHash": "5645c46ddc11183ef9df3c787bb7092d", "checkerName": "llvm-header-guard", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 1, "file": 66, "line": 68}, "message": "using luaJIT_profile_callback = void (*)(void *, lua_State *, int, int) (fixit)"}, {"location": {"col": 1, "file": 66, "line": 68}, "message": "use 'using' instead of 'typedef'"}], "macros": [], "notes": [], "path": "/usr/include/luajit-2.1/luajit.h", "reportHash": "4790b876b153f6857ae5b9e826cbb13f", "checkerName": "modernize-use-using", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 9, "file": 67, "line": 6}, "message": "LUAJIT_2_1_LUALIB_H (fixit)"}, {"location": {"col": 9, "file": 67, "line": 6}, "message": "header guard does not follow preferred style"}], "macros": [], "notes": [], "path": "/usr/include/luajit-2.1/lualib.h", "reportHash": "8cc60395e994f400404bef4e8def5db6", "checkerName": "llvm-header-guard", "reviewStatus": null, "severity": "LOW"}]};
      window.onload = function() {
        if (!browserCompatible) {
          setNonCompatibleBrowserMessage();
        } else {
          BugViewer.init(data.files, data.reports);
          BugViewer.create();
          BugViewer.initByUrl();
        }
      };
    </script>
  </head>
  <body>
  <div class="container">
    <div id="content">
      <div id="side-bar">
        <div class="header">
          <a href="index.html" class="button">&#8249; Return to List</a>
        </div>
        <div id="report-nav">
          <div class="header">Reports</div>
        </div>
      </div>
      <div id="editor-wrapper">
        <div class="header">
          <div id="file">
            <span class="label">File:</span>
            <span id="file-path"></span>
          </div>
          <div id="checker">
            <span class="label">Checker name:</span>
            <span id="checker-name"></span>
          </div>
          <div id="review-status-wrapper">
            <span class="label">Review status:</span>
            <span id="review-status"></span>
          </div>
        </div>
        <div id="editor"></div>
      </div>
    </div>
  </div>
  </body>
</html>
