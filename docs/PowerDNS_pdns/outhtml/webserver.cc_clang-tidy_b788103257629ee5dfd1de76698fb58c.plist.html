<!DOCTYPE html>
<html>
  <head>
    <title>Plist HTML Viewer</title>

    <meta charset="UTF-8">

    <style type="text/css">
      .CodeMirror{font-family:monospace;height:300px;color:#000;direction:ltr}.CodeMirror-lines{padding:4px 0}.CodeMirror pre{padding:0 4px}.CodeMirror-gutter-filler,.CodeMirror-scrollbar-filler{background-color:#fff}.CodeMirror-gutters{border-right:1px solid #ddd;background-color:#f7f7f7;white-space:nowrap}.CodeMirror-linenumber{padding:0 3px 0 5px;min-width:20px;text-align:right;color:#999;white-space:nowrap}.CodeMirror-guttermarker{color:#000}.CodeMirror-guttermarker-subtle{color:#999}.CodeMirror-cursor{border-left:1px solid #000;border-right:none;width:0}.CodeMirror div.CodeMirror-secondarycursor{border-left:1px solid silver}.cm-fat-cursor .CodeMirror-cursor{width:auto;border:0!important;background:#7e7}.cm-fat-cursor div.CodeMirror-cursors{z-index:1}.cm-animate-fat-cursor{width:auto;border:0;-webkit-animation:blink 1.06s steps(1) infinite;-moz-animation:blink 1.06s steps(1) infinite;animation:blink 1.06s steps(1) infinite;background-color:#7e7}@-moz-keyframes blink{50%{background-color:transparent}}@-webkit-keyframes blink{50%{background-color:transparent}}@keyframes blink{50%{background-color:transparent}}.cm-tab{display:inline-block;text-decoration:inherit}.CodeMirror-rulers{position:absolute;left:0;right:0;top:-50px;bottom:-20px;overflow:hidden}.CodeMirror-ruler{border-left:1px solid #ccc;top:0;bottom:0;position:absolute}.cm-s-default .cm-header{color:#00f}.cm-s-default .cm-quote{color:#090}.cm-negative{color:#d44}.cm-positive{color:#292}.cm-header,.cm-strong{font-weight:700}.cm-em{font-style:italic}.cm-link{text-decoration:underline}.cm-strikethrough{text-decoration:line-through}.cm-s-default .cm-keyword{color:#708}.cm-s-default .cm-atom{color:#219}.cm-s-default .cm-number{color:#164}.cm-s-default .cm-def{color:#00f}.cm-s-default .cm-variable-2{color:#05a}.cm-s-default .cm-type,.cm-s-default .cm-variable-3{color:#085}.cm-s-default .cm-comment{color:#a50}.cm-s-default .cm-string{color:#a11}.cm-s-default .cm-string-2{color:#f50}.cm-s-default .cm-meta{color:#555}.cm-s-default .cm-qualifier{color:#555}.cm-s-default .cm-builtin{color:#30a}.cm-s-default .cm-bracket{color:#997}.cm-s-default .cm-tag{color:#170}.cm-s-default .cm-attribute{color:#00c}.cm-s-default .cm-hr{color:#999}.cm-s-default .cm-link{color:#00c}.cm-s-default .cm-error{color:red}.cm-invalidchar{color:red}.CodeMirror-composing{border-bottom:2px solid}div.CodeMirror span.CodeMirror-matchingbracket{color:#0f0}div.CodeMirror span.CodeMirror-nonmatchingbracket{color:#f22}.CodeMirror-matchingtag{background:rgba(255,150,0,.3)}.CodeMirror-activeline-background{background:#e8f2ff}.CodeMirror{position:relative;overflow:hidden;background:#fff}.CodeMirror-scroll{overflow:scroll!important;margin-bottom:-30px;margin-right:-30px;padding-bottom:30px;height:100%;outline:0;position:relative}.CodeMirror-sizer{position:relative;border-right:30px solid transparent}.CodeMirror-gutter-filler,.CodeMirror-hscrollbar,.CodeMirror-scrollbar-filler,.CodeMirror-vscrollbar{position:absolute;z-index:6;display:none}.CodeMirror-vscrollbar{right:0;top:0;overflow-x:hidden;overflow-y:scroll}.CodeMirror-hscrollbar{bottom:0;left:0;overflow-y:hidden;overflow-x:scroll}.CodeMirror-scrollbar-filler{right:0;bottom:0}.CodeMirror-gutter-filler{left:0;bottom:0}.CodeMirror-gutters{position:absolute;left:0;top:0;min-height:100%;z-index:3}.CodeMirror-gutter{white-space:normal;height:100%;display:inline-block;vertical-align:top;margin-bottom:-30px}.CodeMirror-gutter-wrapper{position:absolute;z-index:4;background:0 0!important;border:none!important}.CodeMirror-gutter-background{position:absolute;top:0;bottom:0;z-index:4}.CodeMirror-gutter-elt{position:absolute;cursor:default;z-index:4}.CodeMirror-gutter-wrapper ::selection{background-color:transparent}.CodeMirror-gutter-wrapper ::-moz-selection{background-color:transparent}.CodeMirror-lines{cursor:text;min-height:1px}.CodeMirror pre{-moz-border-radius:0;-webkit-border-radius:0;border-radius:0;border-width:0;background:0 0;font-family:inherit;font-size:inherit;margin:0;white-space:pre;word-wrap:normal;line-height:inherit;color:inherit;z-index:2;position:relative;overflow:visible;-webkit-tap-highlight-color:transparent;-webkit-font-variant-ligatures:contextual;font-variant-ligatures:contextual}.CodeMirror-wrap pre{word-wrap:break-word;white-space:pre-wrap;word-break:normal}.CodeMirror-linebackground{position:absolute;left:0;right:0;top:0;bottom:0;z-index:0}.CodeMirror-linewidget{position:relative;z-index:2;overflow:auto}.CodeMirror-rtl pre{direction:rtl}.CodeMirror-code{outline:0}.CodeMirror-gutter,.CodeMirror-gutters,.CodeMirror-linenumber,.CodeMirror-scroll,.CodeMirror-sizer{-moz-box-sizing:content-box;box-sizing:content-box}.CodeMirror-measure{position:absolute;width:100%;height:0;overflow:hidden;visibility:hidden}.CodeMirror-cursor{position:absolute;pointer-events:none}.CodeMirror-measure pre{position:static}div.CodeMirror-cursors{visibility:hidden;position:relative;z-index:3}div.CodeMirror-dragcursors{visibility:visible}.CodeMirror-focused div.CodeMirror-cursors{visibility:visible}.CodeMirror-selected{background:#d9d9d9}.CodeMirror-focused .CodeMirror-selected{background:#d7d4f0}.CodeMirror-crosshair{cursor:crosshair}.CodeMirror-line::selection,.CodeMirror-line>span::selection,.CodeMirror-line>span>span::selection{background:#d7d4f0}.CodeMirror-line::-moz-selection,.CodeMirror-line>span::-moz-selection,.CodeMirror-line>span>span::-moz-selection{background:#d7d4f0}.cm-searching{background-color:#ffa;background-color:rgba(255,255,0,.4)}.cm-force-border{padding-right:.1px}@media print{.CodeMirror div.CodeMirror-cursors{visibility:hidden}}.cm-tab-wrap-hack:after{content:''}span.CodeMirror-selectedtext{background:0 0}
/*# sourceMappingURL=codemirror.min.css.map */

      .severity-low {
  background-color: #669603;
}

.severity-low:after {
  content : 'L';
}

.severity-unspecified {
  background-color: #666666;
}

.severity-unspecified:after {
  content : 'U';
}

.severity-style {
  background-color: #9932cc;
}

.severity-style:after {
  content : 'S';
}

.severity-medium {
  background-color: #a9d323;
  color: black;
}

.severity-medium:after {
  content : 'M';
}

.severity-high {
  background-color: #ffa800;
}

.severity-high:after {
  content : 'H';
}

.severity-critical {
  background-color: #e92625;
}

.severity-critical:after {
  content : 'C';
}

i[class*="severity-"] {
  line-height: normal;
  text-transform: capitalize;
  font-size: 0.8em;
  font-weight: bold;
  color: white;
  display: inline-block;
  width: 16px;
  height: 16px;
  text-align: center;
  font-family: sans-serif;
}

      html, body {
  width: 100%;
  height: 100%;
  padding: 0px;
  margin: 0px;
}

div.container {
  padding: 10px;
}

#content {
  height: 100%;
  display: block;
  overflow: hidden;
}

#content > div {
  margin: 10px;
  overflow: hidden;
  border: 1px solid #ddd;
  border-radius: 3px;
  overflow: hidden;
  height: 97%;
}

.button {
  background-color: #f1f1f1;
  text-decoration: none;
  display: inline-block;
  padding: 8px 16px;
  color: black;
  cursor: pointer;
}

.button:hover {
  background-color: #ddd;
  color: black;
}

.review-status {
  color: white;
  text-align: center;
}

.review-status-confirmed {
  background-color: #e92625;
}

.review-status-false-positive {
  background-color: grey;
}

.review-status-intentional {
  background-color: #669603;
}

      div.container {
  width: 100%;
  height: 100%;
  padding: 0px;
}

#editor-wrapper {
  margin: 10px;
}

#side-bar {
  float: left;
  width: 260px;
  margin: 0px;
}

#report-nav ul {
  list-style-type: none;
  padding: 0;
  margin: 0;
  overflow-y: auto;
  height: 100%;
}

#report-nav ul > li {
  padding: .4em;
  background-color: #fff;
  border-bottom: 1px solid rgba(0,0,0,.125);
  text-align: left;
  overflow: hidden;
  white-space: nowrap;
  text-overflow: ellipsis;
}

#report-nav ul > li.active {
  background-color: #427ea9;
  color: white;
}

#report-nav ul > li:hover {
  background-color: #427ea9;
  color: white;
  cursor: pointer;
}

#report-nav ul a {
  text-decoration: none;
}

#report-nav i[class*="severity-"] {
  margin-right: 5px;
}

.header {
  border-bottom: 1px solid lightgrey;
  font-family: monospace;
  padding: 10px;
  background-color: #fafbfc;
  border-bottom: 1px solid #e1e4e8;
  border-top-left-radius: 2px;
  border-top-right-radius: 2px;
}

#report-nav .header {
  font-weight: bold;
}

#editor-wrapper .header > div {
  padding-top: 2px;
}

#file-path,
#checker-name {
  color: #195ea2;
}

#review-status {
  padding: 0px 5px;
}

#file-path {
  font-family: monospace;
}

.check-msg {
  display: inline-block;
  padding: 3px 6px;
  margin: 1px;
  -webkit-border-radius: 5px;
  -moz-border-radius: 5px;
  border-radius: 5px;
}

.check-msg.info {
  color: #00546f;
  background-color: #bfdfe9;
  border: 1px solid #87a8b3;
}

.check-msg.error {
  background-color: #f2dede;
  color: #a94442;
  border: 1px solid #ebcccc;
}

.check-msg.macro {
  background-color: #d7dac2;
  color: #4f5c6d;
  border: 1px solid #d7dac2;
}

.check-msg.note {
  background-color: #d7d7d7;
  color: #4f5c6d;
  border: 1px solid #bfbfbf;
}

.check-msg.current {
  border: 2px dashed #3692ff;
}

.check-msg .tag {
  padding: 1px 5px;
  text-align: center;
  border-radius: 2px;
  margin-right: 5px;
  text-decoration: inherit;
}

.check-msg .tag.macro {
  background-color: #83876a;
  color: white;
  text-transform: capitalize;
}

.check-msg .tag.note {
  background-color: #9299a1;
  color: white;
  text-transform: capitalize;
}

.checker-enum {
  color: white;
  padding: 1px 5px;
  text-align: center;
  border-radius: 25px;
  margin-right: 5px;
  text-decoration: inherit;
}

.checker-enum.info {
  background-color: #427ea9;
}

.checker-enum.error {
  background-color: #a94442;
}

.arrow {
  border: solid black;
  border-width: 0 3px 3px 0;
  display: inline-block;
  padding: 3px;
  cursor: pointer;
  margin: 0px 5px;
}

.arrow:hover {
  border: solid #437ea8;
  border-width: 0 3px 3px 0;
}

.left-arrow {
  transform: rotate(135deg);
  -webkit-transform: rotate(135deg);
}

.right-arrow {
  transform: rotate(-45deg);
  -webkit-transform: rotate(-45deg);
}

    </style>

    <script type="text/javascript">
      function setNonCompatibleBrowserMessage() {
  document.body.innerHTML =
    '<h2 style="margin-left: 20px;">Your browser is not compatible with CodeChecker Viewer!</h2> \
     <p style="margin-left: 20px;">The version required for the following browsers are:</p> \
     <ul style="margin-left: 20px;"> \
     <li>Internet Explorer: version 9 or newer</li> \
     <li>Firefox: version 22.0 or newer</li> \
     </ul>';
}

// http://stackoverflow.com/questions/5916900/how-can-you-detect-the-version-of-a-browser
var browserVersion = (function(){
  var ua = navigator.userAgent, tem,
    M = ua.match(/(opera|chrome|safari|firefox|msie|trident(?=\/))\/?\s*(\d+)/i) || [];

  if (/trident/i.test(M[1])) {
    tem = /\brv[ :]+(\d+)/g.exec(ua) || [];
    return 'IE ' + (tem[1] || '');
  }

  if (M[1] === 'Chrome') {
    tem = ua.match(/\b(OPR|Edge)\/(\d+)/);
    if (tem != null) return tem.slice(1).join(' ').replace('OPR', 'Opera');
  }

  M = M[2] ? [M[1], M[2]] : [navigator.appName, navigator.appVersion, '-?'];
  if ((tem = ua.match(/version\/(\d+)/i)) != null) M.splice(1, 1, tem[1]);
    return M.join(' ');
})();

var pos = browserVersion.indexOf(' ');
var browser = browserVersion.substr(0, pos);
var version = parseInt(browserVersion.substr(pos + 1));

var browserCompatible
  = browser === 'Firefox'
  ? version >= 22
  : browser === 'IE'
  ? version >= 9
  : true;


      /* MIT License

Copyright (C) 2017 by Marijn Haverbeke <marijnh@gmail.com> and others

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
THE SOFTWARE.
 */
      !function(e,t){"object"==typeof exports&&"undefined"!=typeof module?module.exports=t():"function"==typeof define&&define.amd?define(t):e.CodeMirror=t()}(this,function(){"use strict";function e(e){return new RegExp("(^|\\s)"+e+"(?:$|\\s)\\s*")}function t(e){for(var t=e.childNodes.length;t>0;--t)e.removeChild(e.firstChild);return e}function r(e,r){return t(e).appendChild(r)}function n(e,t,r,n){var i=document.createElement(e);if(r&&(i.className=r),n&&(i.style.cssText=n),"string"==typeof t)i.appendChild(document.createTextNode(t));else if(t)for(var o=0;o<t.length;++o)i.appendChild(t[o]);return i}function i(e,t,r,i){var o=n(e,t,r,i);return o.setAttribute("role","presentation"),o}function o(e,t){if(3==t.nodeType&&(t=t.parentNode),e.contains)return e.contains(t);do{if(11==t.nodeType&&(t=t.host),t==e)return!0}while(t=t.parentNode)}function l(){var e;try{e=document.activeElement}catch(t){e=document.body||null}for(;e&&e.shadowRoot&&e.shadowRoot.activeElement;)e=e.shadowRoot.activeElement;return e}function s(t,r){var n=t.className;e(r).test(n)||(t.className+=(n?" ":"")+r)}function a(t,r){for(var n=t.split(" "),i=0;i<n.length;i++)n[i]&&!e(n[i]).test(r)&&(r+=" "+n[i]);return r}function u(e){var t=Array.prototype.slice.call(arguments,1);return function(){return e.apply(null,t)}}function c(e,t,r){t||(t={});for(var n in e)!e.hasOwnProperty(n)||!1===r&&t.hasOwnProperty(n)||(t[n]=e[n]);return t}function f(e,t,r,n,i){null==t&&-1==(t=e.search(/[^\s\u00a0]/))&&(t=e.length);for(var o=n||0,l=i||0;;){var s=e.indexOf("\t",o);if(s<0||s>=t)return l+(t-o);l+=s-o,l+=r-l%r,o=s+1}}function h(e,t){for(var r=0;r<e.length;++r)if(e[r]==t)return r;return-1}function d(e,t,r){for(var n=0,i=0;;){var o=e.indexOf("\t",n);-1==o&&(o=e.length);var l=o-n;if(o==e.length||i+l>=t)return n+Math.min(l,t-i);if(i+=o-n,i+=r-i%r,n=o+1,i>=t)return n}}function p(e){for(;Kl.length<=e;)Kl.push(g(Kl)+" ");return Kl[e]}function g(e){return e[e.length-1]}function v(e,t){for(var r=[],n=0;n<e.length;n++)r[n]=t(e[n],n);return r}function m(e,t,r){for(var n=0,i=r(t);n<e.length&&r(e[n])<=i;)n++;e.splice(n,0,t)}function y(){}function b(e,t){var r;return Object.create?r=Object.create(e):(y.prototype=e,r=new y),t&&c(t,r),r}function w(e){return/\w/.test(e)||e>""&&(e.toUpperCase()!=e.toLowerCase()||jl.test(e))}function x(e,t){return t?!!(t.source.indexOf("\\w")>-1&&w(e))||t.test(e):w(e)}function C(e){for(var t in e)if(e.hasOwnProperty(t)&&e[t])return!1;return!0}function S(e){return e.charCodeAt(0)>=768&&Xl.test(e)}function L(e,t,r){for(;(r<0?t>0:t<e.length)&&S(e.charAt(t));)t+=r;return t}function k(e,t,r){for(var n=t>r?-1:1;;){if(t==r)return t;var i=(t+r)/2,o=n<0?Math.ceil(i):Math.floor(i);if(o==t)return e(o)?t:r;e(o)?r=o:t=o+n}}function T(e,t,r){var o=this;this.input=r,o.scrollbarFiller=n("div",null,"CodeMirror-scrollbar-filler"),o.scrollbarFiller.setAttribute("cm-not-content","true"),o.gutterFiller=n("div",null,"CodeMirror-gutter-filler"),o.gutterFiller.setAttribute("cm-not-content","true"),o.lineDiv=i("div",null,"CodeMirror-code"),o.selectionDiv=n("div",null,null,"position: relative; z-index: 1"),o.cursorDiv=n("div",null,"CodeMirror-cursors"),o.measure=n("div",null,"CodeMirror-measure"),o.lineMeasure=n("div",null,"CodeMirror-measure"),o.lineSpace=i("div",[o.measure,o.lineMeasure,o.selectionDiv,o.cursorDiv,o.lineDiv],null,"position: relative; outline: none");var l=i("div",[o.lineSpace],"CodeMirror-lines");o.mover=n("div",[l],null,"position: relative"),o.sizer=n("div",[o.mover],"CodeMirror-sizer"),o.sizerWidth=null,o.heightForcer=n("div",null,null,"position: absolute; height: "+Rl+"px; width: 1px;"),o.gutters=n("div",null,"CodeMirror-gutters"),o.lineGutter=null,o.scroller=n("div",[o.sizer,o.heightForcer,o.gutters],"CodeMirror-scroll"),o.scroller.setAttribute("tabIndex","-1"),o.wrapper=n("div",[o.scrollbarFiller,o.gutterFiller,o.scroller],"CodeMirror"),gl&&vl<8&&(o.gutters.style.zIndex=-1,o.scroller.style.paddingRight=0),ml||fl&&Tl||(o.scroller.draggable=!0),e&&(e.appendChild?e.appendChild(o.wrapper):e(o.wrapper)),o.viewFrom=o.viewTo=t.first,o.reportedViewFrom=o.reportedViewTo=t.first,o.view=[],o.renderedView=null,o.externalMeasured=null,o.viewOffset=0,o.lastWrapHeight=o.lastWrapWidth=0,o.updateLineNumbers=null,o.nativeBarWidth=o.barHeight=o.barWidth=0,o.scrollbarsClipped=!1,o.lineNumWidth=o.lineNumInnerWidth=o.lineNumChars=null,o.alignWidgets=!1,o.cachedCharWidth=o.cachedTextHeight=o.cachedPaddingH=null,o.maxLine=null,o.maxLineLength=0,o.maxLineChanged=!1,o.wheelDX=o.wheelDY=o.wheelStartX=o.wheelStartY=null,o.shift=!1,o.selForContextMenu=null,o.activeTouch=null,r.init(o)}function M(e,t){if((t-=e.first)<0||t>=e.size)throw new Error("There is no line "+(t+e.first)+" in the document.");for(var r=e;!r.lines;)for(var n=0;;++n){var i=r.children[n],o=i.chunkSize();if(t<o){r=i;break}t-=o}return r.lines[t]}function N(e,t,r){var n=[],i=t.line;return e.iter(t.line,r.line+1,function(e){var o=e.text;i==r.line&&(o=o.slice(0,r.ch)),i==t.line&&(o=o.slice(t.ch)),n.push(o),++i}),n}function O(e,t,r){var n=[];return e.iter(t,r,function(e){n.push(e.text)}),n}function A(e,t){var r=t-e.height;if(r)for(var n=e;n;n=n.parent)n.height+=r}function W(e){if(null==e.parent)return null;for(var t=e.parent,r=h(t.lines,e),n=t.parent;n;t=n,n=n.parent)for(var i=0;n.children[i]!=t;++i)r+=n.children[i].chunkSize();return r+t.first}function D(e,t){var r=e.first;e:do{for(var n=0;n<e.children.length;++n){var i=e.children[n],o=i.height;if(t<o){e=i;continue e}t-=o,r+=i.chunkSize()}return r}while(!e.lines);for(var l=0;l<e.lines.length;++l){var s=e.lines[l].height;if(t<s)break;t-=s}return r+l}function H(e,t){return t>=e.first&&t<e.first+e.size}function F(e,t){return String(e.lineNumberFormatter(t+e.firstLineNumber))}function E(e,t,r){if(void 0===r&&(r=null),!(this instanceof E))return new E(e,t,r);this.line=e,this.ch=t,this.sticky=r}function P(e,t){return e.line-t.line||e.ch-t.ch}function I(e,t){return e.sticky==t.sticky&&0==P(e,t)}function z(e){return E(e.line,e.ch)}function R(e,t){return P(e,t)<0?t:e}function B(e,t){return P(e,t)<0?e:t}function G(e,t){return Math.max(e.first,Math.min(t,e.first+e.size-1))}function U(e,t){if(t.line<e.first)return E(e.first,0);var r=e.first+e.size-1;return t.line>r?E(r,M(e,r).text.length):V(t,M(e,t.line).text.length)}function V(e,t){var r=e.ch;return null==r||r>t?E(e.line,t):r<0?E(e.line,0):e}function K(e,t){for(var r=[],n=0;n<t.length;n++)r[n]=U(e,t[n]);return r}function j(){Yl=!0}function X(){_l=!0}function Y(e,t,r){this.marker=e,this.from=t,this.to=r}function _(e,t){if(e)for(var r=0;r<e.length;++r){var n=e[r];if(n.marker==t)return n}}function $(e,t){for(var r,n=0;n<e.length;++n)e[n]!=t&&(r||(r=[])).push(e[n]);return r}function q(e,t){e.markedSpans=e.markedSpans?e.markedSpans.concat([t]):[t],t.marker.attachLine(e)}function Z(e,t,r){var n;if(e)for(var i=0;i<e.length;++i){var o=e[i],l=o.marker;if(null==o.from||(l.inclusiveLeft?o.from<=t:o.from<t)||o.from==t&&"bookmark"==l.type&&(!r||!o.marker.insertLeft)){var s=null==o.to||(l.inclusiveRight?o.to>=t:o.to>t);(n||(n=[])).push(new Y(l,o.from,s?null:o.to))}}return n}function Q(e,t,r){var n;if(e)for(var i=0;i<e.length;++i){var o=e[i],l=o.marker;if(null==o.to||(l.inclusiveRight?o.to>=t:o.to>t)||o.from==t&&"bookmark"==l.type&&(!r||o.marker.insertLeft)){var s=null==o.from||(l.inclusiveLeft?o.from<=t:o.from<t);(n||(n=[])).push(new Y(l,s?null:o.from-t,null==o.to?null:o.to-t))}}return n}function J(e,t){if(t.full)return null;var r=H(e,t.from.line)&&M(e,t.from.line).markedSpans,n=H(e,t.to.line)&&M(e,t.to.line).markedSpans;if(!r&&!n)return null;var i=t.from.ch,o=t.to.ch,l=0==P(t.from,t.to),s=Z(r,i,l),a=Q(n,o,l),u=1==t.text.length,c=g(t.text).length+(u?i:0);if(s)for(var f=0;f<s.length;++f){var h=s[f];if(null==h.to){var d=_(a,h.marker);d?u&&(h.to=null==d.to?null:d.to+c):h.to=i}}if(a)for(var p=0;p<a.length;++p){var v=a[p];null!=v.to&&(v.to+=c),null==v.from?_(s,v.marker)||(v.from=c,u&&(s||(s=[])).push(v)):(v.from+=c,u&&(s||(s=[])).push(v))}s&&(s=ee(s)),a&&a!=s&&(a=ee(a));var m=[s];if(!u){var y,b=t.text.length-2;if(b>0&&s)for(var w=0;w<s.length;++w)null==s[w].to&&(y||(y=[])).push(new Y(s[w].marker,null,null));for(var x=0;x<b;++x)m.push(y);m.push(a)}return m}function ee(e){for(var t=0;t<e.length;++t){var r=e[t];null!=r.from&&r.from==r.to&&!1!==r.marker.clearWhenEmpty&&e.splice(t--,1)}return e.length?e:null}function te(e,t,r){var n=null;if(e.iter(t.line,r.line+1,function(e){if(e.markedSpans)for(var t=0;t<e.markedSpans.length;++t){var r=e.markedSpans[t].marker;!r.readOnly||n&&-1!=h(n,r)||(n||(n=[])).push(r)}}),!n)return null;for(var i=[{from:t,to:r}],o=0;o<n.length;++o)for(var l=n[o],s=l.find(0),a=0;a<i.length;++a){var u=i[a];if(!(P(u.to,s.from)<0||P(u.from,s.to)>0)){var c=[a,1],f=P(u.from,s.from),d=P(u.to,s.to);(f<0||!l.inclusiveLeft&&!f)&&c.push({from:u.from,to:s.from}),(d>0||!l.inclusiveRight&&!d)&&c.push({from:s.to,to:u.to}),i.splice.apply(i,c),a+=c.length-3}}return i}function re(e){var t=e.markedSpans;if(t){for(var r=0;r<t.length;++r)t[r].marker.detachLine(e);e.markedSpans=null}}function ne(e,t){if(t){for(var r=0;r<t.length;++r)t[r].marker.attachLine(e);e.markedSpans=t}}function ie(e){return e.inclusiveLeft?-1:0}function oe(e){return e.inclusiveRight?1:0}function le(e,t){var r=e.lines.length-t.lines.length;if(0!=r)return r;var n=e.find(),i=t.find(),o=P(n.from,i.from)||ie(e)-ie(t);if(o)return-o;var l=P(n.to,i.to)||oe(e)-oe(t);return l||t.id-e.id}function se(e,t){var r,n=_l&&e.markedSpans;if(n)for(var i=void 0,o=0;o<n.length;++o)(i=n[o]).marker.collapsed&&null==(t?i.from:i.to)&&(!r||le(r,i.marker)<0)&&(r=i.marker);return r}function ae(e){return se(e,!0)}function ue(e){return se(e,!1)}function ce(e,t,r,n,i){var o=M(e,t),l=_l&&o.markedSpans;if(l)for(var s=0;s<l.length;++s){var a=l[s];if(a.marker.collapsed){var u=a.marker.find(0),c=P(u.from,r)||ie(a.marker)-ie(i),f=P(u.to,n)||oe(a.marker)-oe(i);if(!(c>=0&&f<=0||c<=0&&f>=0)&&(c<=0&&(a.marker.inclusiveRight&&i.inclusiveLeft?P(u.to,r)>=0:P(u.to,r)>0)||c>=0&&(a.marker.inclusiveRight&&i.inclusiveLeft?P(u.from,n)<=0:P(u.from,n)<0)))return!0}}}function fe(e){for(var t;t=ae(e);)e=t.find(-1,!0).line;return e}function he(e){for(var t;t=ue(e);)e=t.find(1,!0).line;return e}function de(e){for(var t,r;t=ue(e);)e=t.find(1,!0).line,(r||(r=[])).push(e);return r}function pe(e,t){var r=M(e,t),n=fe(r);return r==n?t:W(n)}function ge(e,t){if(t>e.lastLine())return t;var r,n=M(e,t);if(!ve(e,n))return t;for(;r=ue(n);)n=r.find(1,!0).line;return W(n)+1}function ve(e,t){var r=_l&&t.markedSpans;if(r)for(var n=void 0,i=0;i<r.length;++i)if((n=r[i]).marker.collapsed){if(null==n.from)return!0;if(!n.marker.widgetNode&&0==n.from&&n.marker.inclusiveLeft&&me(e,t,n))return!0}}function me(e,t,r){if(null==r.to){var n=r.marker.find(1,!0);return me(e,n.line,_(n.line.markedSpans,r.marker))}if(r.marker.inclusiveRight&&r.to==t.text.length)return!0;for(var i=void 0,o=0;o<t.markedSpans.length;++o)if((i=t.markedSpans[o]).marker.collapsed&&!i.marker.widgetNode&&i.from==r.to&&(null==i.to||i.to!=r.from)&&(i.marker.inclusiveLeft||r.marker.inclusiveRight)&&me(e,t,i))return!0}function ye(e){for(var t=0,r=(e=fe(e)).parent,n=0;n<r.lines.length;++n){var i=r.lines[n];if(i==e)break;t+=i.height}for(var o=r.parent;o;r=o,o=r.parent)for(var l=0;l<o.children.length;++l){var s=o.children[l];if(s==r)break;t+=s.height}return t}function be(e){if(0==e.height)return 0;for(var t,r=e.text.length,n=e;t=ae(n);){var i=t.find(0,!0);n=i.from.line,r+=i.from.ch-i.to.ch}for(n=e;t=ue(n);){var o=t.find(0,!0);r-=n.text.length-o.from.ch,r+=(n=o.to.line).text.length-o.to.ch}return r}function we(e){var t=e.display,r=e.doc;t.maxLine=M(r,r.first),t.maxLineLength=be(t.maxLine),t.maxLineChanged=!0,r.iter(function(e){var r=be(e);r>t.maxLineLength&&(t.maxLineLength=r,t.maxLine=e)})}function xe(e,t,r,n){if(!e)return n(t,r,"ltr",0);for(var i=!1,o=0;o<e.length;++o){var l=e[o];(l.from<r&&l.to>t||t==r&&l.to==t)&&(n(Math.max(l.from,t),Math.min(l.to,r),1==l.level?"rtl":"ltr",o),i=!0)}i||n(t,r,"ltr")}function Ce(e,t,r){var n;$l=null;for(var i=0;i<e.length;++i){var o=e[i];if(o.from<t&&o.to>t)return i;o.to==t&&(o.from!=o.to&&"before"==r?n=i:$l=i),o.from==t&&(o.from!=o.to&&"before"!=r?n=i:$l=i)}return null!=n?n:$l}function Se(e,t){var r=e.order;return null==r&&(r=e.order=ql(e.text,t)),r}function Le(e,t){return e._handlers&&e._handlers[t]||Zl}function ke(e,t,r){if(e.removeEventListener)e.removeEventListener(t,r,!1);else if(e.detachEvent)e.detachEvent("on"+t,r);else{var n=e._handlers,i=n&&n[t];if(i){var o=h(i,r);o>-1&&(n[t]=i.slice(0,o).concat(i.slice(o+1)))}}}function Te(e,t){var r=Le(e,t);if(r.length)for(var n=Array.prototype.slice.call(arguments,2),i=0;i<r.length;++i)r[i].apply(null,n)}function Me(e,t,r){return"string"==typeof t&&(t={type:t,preventDefault:function(){this.defaultPrevented=!0}}),Te(e,r||t.type,e,t),He(t)||t.codemirrorIgnore}function Ne(e){var t=e._handlers&&e._handlers.cursorActivity;if(t)for(var r=e.curOp.cursorActivityHandlers||(e.curOp.cursorActivityHandlers=[]),n=0;n<t.length;++n)-1==h(r,t[n])&&r.push(t[n])}function Oe(e,t){return Le(e,t).length>0}function Ae(e){e.prototype.on=function(e,t){Ql(this,e,t)},e.prototype.off=function(e,t){ke(this,e,t)}}function We(e){e.preventDefault?e.preventDefault():e.returnValue=!1}function De(e){e.stopPropagation?e.stopPropagation():e.cancelBubble=!0}function He(e){return null!=e.defaultPrevented?e.defaultPrevented:0==e.returnValue}function Fe(e){We(e),De(e)}function Ee(e){return e.target||e.srcElement}function Pe(e){var t=e.which;return null==t&&(1&e.button?t=1:2&e.button?t=3:4&e.button&&(t=2)),Ml&&e.ctrlKey&&1==t&&(t=3),t}function Ie(e){if(null==Il){var t=n("span","​");r(e,n("span",[t,document.createTextNode("x")])),0!=e.firstChild.offsetHeight&&(Il=t.offsetWidth<=1&&t.offsetHeight>2&&!(gl&&vl<8))}var i=Il?n("span","​"):n("span"," ",null,"display: inline-block; width: 1px; margin-right: -1px");return i.setAttribute("cm-text",""),i}function ze(e){if(null!=zl)return zl;var n=r(e,document.createTextNode("AخA")),i=Wl(n,0,1).getBoundingClientRect(),o=Wl(n,1,2).getBoundingClientRect();return t(e),!(!i||i.left==i.right)&&(zl=o.right-i.right<3)}function Re(e){if(null!=ns)return ns;var t=r(e,n("span","x")),i=t.getBoundingClientRect(),o=Wl(t,0,1).getBoundingClientRect();return ns=Math.abs(i.left-o.left)>1}function Be(e,t){arguments.length>2&&(t.dependencies=Array.prototype.slice.call(arguments,2)),is[e]=t}function Ge(e){if("string"==typeof e&&os.hasOwnProperty(e))e=os[e];else if(e&&"string"==typeof e.name&&os.hasOwnProperty(e.name)){var t=os[e.name];"string"==typeof t&&(t={name:t}),(e=b(t,e)).name=t.name}else{if("string"==typeof e&&/^[\w\-]+\/[\w\-]+\+xml$/.test(e))return Ge("application/xml");if("string"==typeof e&&/^[\w\-]+\/[\w\-]+\+json$/.test(e))return Ge("application/json")}return"string"==typeof e?{name:e}:e||{name:"null"}}function Ue(e,t){t=Ge(t);var r=is[t.name];if(!r)return Ue(e,"text/plain");var n=r(e,t);if(ls.hasOwnProperty(t.name)){var i=ls[t.name];for(var o in i)i.hasOwnProperty(o)&&(n.hasOwnProperty(o)&&(n["_"+o]=n[o]),n[o]=i[o])}if(n.name=t.name,t.helperType&&(n.helperType=t.helperType),t.modeProps)for(var l in t.modeProps)n[l]=t.modeProps[l];return n}function Ve(e,t){c(t,ls.hasOwnProperty(e)?ls[e]:ls[e]={})}function Ke(e,t){if(!0===t)return t;if(e.copyState)return e.copyState(t);var r={};for(var n in t){var i=t[n];i instanceof Array&&(i=i.concat([])),r[n]=i}return r}function je(e,t){for(var r;e.innerMode&&(r=e.innerMode(t))&&r.mode!=e;)t=r.state,e=r.mode;return r||{mode:e,state:t}}function Xe(e,t,r){return!e.startState||e.startState(t,r)}function Ye(e,t,r,n){var i=[e.state.modeGen],o={};tt(e,t.text,e.doc.mode,r,function(e,t){return i.push(e,t)},o,n);for(var l=r.state,s=0;s<e.state.overlays.length;++s)!function(n){var l=e.state.overlays[n],s=1,a=0;r.state=!0,tt(e,t.text,l.mode,r,function(e,t){for(var r=s;a<e;){var n=i[s];n>e&&i.splice(s,1,e,i[s+1],n),s+=2,a=Math.min(e,n)}if(t)if(l.opaque)i.splice(r,s-r,e,"overlay "+t),s=r+2;else for(;r<s;r+=2){var o=i[r+1];i[r+1]=(o?o+" ":"")+"overlay "+t}},o)}(s);return r.state=l,{styles:i,classes:o.bgClass||o.textClass?o:null}}function _e(e,t,r){if(!t.styles||t.styles[0]!=e.state.modeGen){var n=$e(e,W(t)),i=t.text.length>e.options.maxHighlightLength&&Ke(e.doc.mode,n.state),o=Ye(e,t,n);i&&(n.state=i),t.stateAfter=n.save(!i),t.styles=o.styles,o.classes?t.styleClasses=o.classes:t.styleClasses&&(t.styleClasses=null),r===e.doc.highlightFrontier&&(e.doc.modeFrontier=Math.max(e.doc.modeFrontier,++e.doc.highlightFrontier))}return t.styles}function $e(e,t,r){var n=e.doc,i=e.display;if(!n.mode.startState)return new us(n,!0,t);var o=rt(e,t,r),l=o>n.first&&M(n,o-1).stateAfter,s=l?us.fromSaved(n,l,o):new us(n,Xe(n.mode),o);return n.iter(o,t,function(r){qe(e,r.text,s);var n=s.line;r.stateAfter=n==t-1||n%5==0||n>=i.viewFrom&&n<i.viewTo?s.save():null,s.nextLine()}),r&&(n.modeFrontier=s.line),s}function qe(e,t,r,n){var i=e.doc.mode,o=new ss(t,e.options.tabSize,r);for(o.start=o.pos=n||0,""==t&&Ze(i,r.state);!o.eol();)Qe(i,o,r.state),o.start=o.pos}function Ze(e,t){if(e.blankLine)return e.blankLine(t);if(e.innerMode){var r=je(e,t);return r.mode.blankLine?r.mode.blankLine(r.state):void 0}}function Qe(e,t,r,n){for(var i=0;i<10;i++){n&&(n[0]=je(e,r).mode);var o=e.token(t,r);if(t.pos>t.start)return o}throw new Error("Mode "+e.name+" failed to advance stream.")}function Je(e,t,r,n){var i,o,l=e.doc,s=l.mode,a=M(l,(t=U(l,t)).line),u=$e(e,t.line,r),c=new ss(a.text,e.options.tabSize,u);for(n&&(o=[]);(n||c.pos<t.ch)&&!c.eol();)c.start=c.pos,i=Qe(s,c,u.state),n&&o.push(new cs(c,i,Ke(l.mode,u.state)));return n?o:new cs(c,i,u.state)}function et(e,t){if(e)for(;;){var r=e.match(/(?:^|\s+)line-(background-)?(\S+)/);if(!r)break;e=e.slice(0,r.index)+e.slice(r.index+r[0].length);var n=r[1]?"bgClass":"textClass";null==t[n]?t[n]=r[2]:new RegExp("(?:^|s)"+r[2]+"(?:$|s)").test(t[n])||(t[n]+=" "+r[2])}return e}function tt(e,t,r,n,i,o,l){var s=r.flattenSpans;null==s&&(s=e.options.flattenSpans);var a,u=0,c=null,f=new ss(t,e.options.tabSize,n),h=e.options.addModeClass&&[null];for(""==t&&et(Ze(r,n.state),o);!f.eol();){if(f.pos>e.options.maxHighlightLength?(s=!1,l&&qe(e,t,n,f.pos),f.pos=t.length,a=null):a=et(Qe(r,f,n.state,h),o),h){var d=h[0].name;d&&(a="m-"+(a?d+" "+a:d))}if(!s||c!=a){for(;u<f.start;)i(u=Math.min(f.start,u+5e3),c);c=a}f.start=f.pos}for(;u<f.pos;){var p=Math.min(f.pos,u+5e3);i(p,c),u=p}}function rt(e,t,r){for(var n,i,o=e.doc,l=r?-1:t-(e.doc.mode.innerMode?1e3:100),s=t;s>l;--s){if(s<=o.first)return o.first;var a=M(o,s-1),u=a.stateAfter;if(u&&(!r||s+(u instanceof as?u.lookAhead:0)<=o.modeFrontier))return s;var c=f(a.text,null,e.options.tabSize);(null==i||n>c)&&(i=s-1,n=c)}return i}function nt(e,t){if(e.modeFrontier=Math.min(e.modeFrontier,t),!(e.highlightFrontier<t-10)){for(var r=e.first,n=t-1;n>r;n--){var i=M(e,n).stateAfter;if(i&&(!(i instanceof as)||n+i.lookAhead<t)){r=n+1;break}}e.highlightFrontier=Math.min(e.highlightFrontier,r)}}function it(e,t,r,n){e.text=t,e.stateAfter&&(e.stateAfter=null),e.styles&&(e.styles=null),null!=e.order&&(e.order=null),re(e),ne(e,r);var i=n?n(e):1;i!=e.height&&A(e,i)}function ot(e){e.parent=null,re(e)}function lt(e,t){if(!e||/^\s*$/.test(e))return null;var r=t.addModeClass?ps:ds;return r[e]||(r[e]=e.replace(/\S+/g,"cm-$&"))}function st(e,t){var r=i("span",null,null,ml?"padding-right: .1px":null),n={pre:i("pre",[r],"CodeMirror-line"),content:r,col:0,pos:0,cm:e,trailingSpace:!1,splitSpaces:(gl||ml)&&e.getOption("lineWrapping")};t.measure={};for(var o=0;o<=(t.rest?t.rest.length:0);o++){var l=o?t.rest[o-1]:t.line,s=void 0;n.pos=0,n.addToken=ut,ze(e.display.measure)&&(s=Se(l,e.doc.direction))&&(n.addToken=ft(n.addToken,s)),n.map=[],dt(l,n,_e(e,l,t!=e.display.externalMeasured&&W(l))),l.styleClasses&&(l.styleClasses.bgClass&&(n.bgClass=a(l.styleClasses.bgClass,n.bgClass||"")),l.styleClasses.textClass&&(n.textClass=a(l.styleClasses.textClass,n.textClass||""))),0==n.map.length&&n.map.push(0,0,n.content.appendChild(Ie(e.display.measure))),0==o?(t.measure.map=n.map,t.measure.cache={}):((t.measure.maps||(t.measure.maps=[])).push(n.map),(t.measure.caches||(t.measure.caches=[])).push({}))}if(ml){var u=n.content.lastChild;(/\bcm-tab\b/.test(u.className)||u.querySelector&&u.querySelector(".cm-tab"))&&(n.content.className="cm-tab-wrap-hack")}return Te(e,"renderLine",e,t.line,n.pre),n.pre.className&&(n.textClass=a(n.pre.className,n.textClass||"")),n}function at(e){var t=n("span","•","cm-invalidchar");return t.title="\\u"+e.charCodeAt(0).toString(16),t.setAttribute("aria-label",t.title),t}function ut(e,t,r,i,o,l,s){if(t){var a,u=e.splitSpaces?ct(t,e.trailingSpace):t,c=e.cm.state.specialChars,f=!1;if(c.test(t)){a=document.createDocumentFragment();for(var h=0;;){c.lastIndex=h;var d=c.exec(t),g=d?d.index-h:t.length-h;if(g){var v=document.createTextNode(u.slice(h,h+g));gl&&vl<9?a.appendChild(n("span",[v])):a.appendChild(v),e.map.push(e.pos,e.pos+g,v),e.col+=g,e.pos+=g}if(!d)break;h+=g+1;var m=void 0;if("\t"==d[0]){var y=e.cm.options.tabSize,b=y-e.col%y;(m=a.appendChild(n("span",p(b),"cm-tab"))).setAttribute("role","presentation"),m.setAttribute("cm-text","\t"),e.col+=b}else"\r"==d[0]||"\n"==d[0]?((m=a.appendChild(n("span","\r"==d[0]?"␍":"␤","cm-invalidchar"))).setAttribute("cm-text",d[0]),e.col+=1):((m=e.cm.options.specialCharPlaceholder(d[0])).setAttribute("cm-text",d[0]),gl&&vl<9?a.appendChild(n("span",[m])):a.appendChild(m),e.col+=1);e.map.push(e.pos,e.pos+1,m),e.pos++}}else e.col+=t.length,a=document.createTextNode(u),e.map.push(e.pos,e.pos+t.length,a),gl&&vl<9&&(f=!0),e.pos+=t.length;if(e.trailingSpace=32==u.charCodeAt(t.length-1),r||i||o||f||s){var w=r||"";i&&(w+=i),o&&(w+=o);var x=n("span",[a],w,s);return l&&(x.title=l),e.content.appendChild(x)}e.content.appendChild(a)}}function ct(e,t){if(e.length>1&&!/  /.test(e))return e;for(var r=t,n="",i=0;i<e.length;i++){var o=e.charAt(i);" "!=o||!r||i!=e.length-1&&32!=e.charCodeAt(i+1)||(o=" "),n+=o,r=" "==o}return n}function ft(e,t){return function(r,n,i,o,l,s,a){i=i?i+" cm-force-border":"cm-force-border";for(var u=r.pos,c=u+n.length;;){for(var f=void 0,h=0;h<t.length&&!((f=t[h]).to>u&&f.from<=u);h++);if(f.to>=c)return e(r,n,i,o,l,s,a);e(r,n.slice(0,f.to-u),i,o,null,s,a),o=null,n=n.slice(f.to-u),u=f.to}}}function ht(e,t,r,n){var i=!n&&r.widgetNode;i&&e.map.push(e.pos,e.pos+t,i),!n&&e.cm.display.input.needsContentAttribute&&(i||(i=e.content.appendChild(document.createElement("span"))),i.setAttribute("cm-marker",r.id)),i&&(e.cm.display.input.setUneditable(i),e.content.appendChild(i)),e.pos+=t,e.trailingSpace=!1}function dt(e,t,r){var n=e.markedSpans,i=e.text,o=0;if(n)for(var l,s,a,u,c,f,h,d=i.length,p=0,g=1,v="",m=0;;){if(m==p){a=u=c=f=s="",h=null,m=1/0;for(var y=[],b=void 0,w=0;w<n.length;++w){var x=n[w],C=x.marker;"bookmark"==C.type&&x.from==p&&C.widgetNode?y.push(C):x.from<=p&&(null==x.to||x.to>p||C.collapsed&&x.to==p&&x.from==p)?(null!=x.to&&x.to!=p&&m>x.to&&(m=x.to,u=""),C.className&&(a+=" "+C.className),C.css&&(s=(s?s+";":"")+C.css),C.startStyle&&x.from==p&&(c+=" "+C.startStyle),C.endStyle&&x.to==m&&(b||(b=[])).push(C.endStyle,x.to),C.title&&!f&&(f=C.title),C.collapsed&&(!h||le(h.marker,C)<0)&&(h=x)):x.from>p&&m>x.from&&(m=x.from)}if(b)for(var S=0;S<b.length;S+=2)b[S+1]==m&&(u+=" "+b[S]);if(!h||h.from==p)for(var L=0;L<y.length;++L)ht(t,0,y[L]);if(h&&(h.from||0)==p){if(ht(t,(null==h.to?d+1:h.to)-p,h.marker,null==h.from),null==h.to)return;h.to==p&&(h=!1)}}if(p>=d)break;for(var k=Math.min(d,m);;){if(v){var T=p+v.length;if(!h){var M=T>k?v.slice(0,k-p):v;t.addToken(t,M,l?l+a:a,c,p+M.length==m?u:"",f,s)}if(T>=k){v=v.slice(k-p),p=k;break}p=T,c=""}v=i.slice(o,o=r[g++]),l=lt(r[g++],t.cm.options)}}else for(var N=1;N<r.length;N+=2)t.addToken(t,i.slice(o,o=r[N]),lt(r[N+1],t.cm.options))}function pt(e,t,r){this.line=t,this.rest=de(t),this.size=this.rest?W(g(this.rest))-r+1:1,this.node=this.text=null,this.hidden=ve(e,t)}function gt(e,t,r){for(var n,i=[],o=t;o<r;o=n){var l=new pt(e.doc,M(e.doc,o),o);n=o+l.size,i.push(l)}return i}function vt(e){gs?gs.ops.push(e):e.ownsGroup=gs={ops:[e],delayedCallbacks:[]}}function mt(e){var t=e.delayedCallbacks,r=0;do{for(;r<t.length;r++)t[r].call(null);for(var n=0;n<e.ops.length;n++){var i=e.ops[n];if(i.cursorActivityHandlers)for(;i.cursorActivityCalled<i.cursorActivityHandlers.length;)i.cursorActivityHandlers[i.cursorActivityCalled++].call(null,i.cm)}}while(r<t.length)}function yt(e,t){var r=e.ownsGroup;if(r)try{mt(r)}finally{gs=null,t(r)}}function bt(e,t){var r=Le(e,t);if(r.length){var n,i=Array.prototype.slice.call(arguments,2);gs?n=gs.delayedCallbacks:vs?n=vs:(n=vs=[],setTimeout(wt,0));for(var o=0;o<r.length;++o)!function(e){n.push(function(){return r[e].apply(null,i)})}(o)}}function wt(){var e=vs;vs=null;for(var t=0;t<e.length;++t)e[t]()}function xt(e,t,r,n){for(var i=0;i<t.changes.length;i++){var o=t.changes[i];"text"==o?kt(e,t):"gutter"==o?Mt(e,t,r,n):"class"==o?Tt(e,t):"widget"==o&&Nt(e,t,n)}t.changes=null}function Ct(e){return e.node==e.text&&(e.node=n("div",null,null,"position: relative"),e.text.parentNode&&e.text.parentNode.replaceChild(e.node,e.text),e.node.appendChild(e.text),gl&&vl<8&&(e.node.style.zIndex=2)),e.node}function St(e,t){var r=t.bgClass?t.bgClass+" "+(t.line.bgClass||""):t.line.bgClass;if(r&&(r+=" CodeMirror-linebackground"),t.background)r?t.background.className=r:(t.background.parentNode.removeChild(t.background),t.background=null);else if(r){var i=Ct(t);t.background=i.insertBefore(n("div",null,r),i.firstChild),e.display.input.setUneditable(t.background)}}function Lt(e,t){var r=e.display.externalMeasured;return r&&r.line==t.line?(e.display.externalMeasured=null,t.measure=r.measure,r.built):st(e,t)}function kt(e,t){var r=t.text.className,n=Lt(e,t);t.text==t.node&&(t.node=n.pre),t.text.parentNode.replaceChild(n.pre,t.text),t.text=n.pre,n.bgClass!=t.bgClass||n.textClass!=t.textClass?(t.bgClass=n.bgClass,t.textClass=n.textClass,Tt(e,t)):r&&(t.text.className=r)}function Tt(e,t){St(e,t),t.line.wrapClass?Ct(t).className=t.line.wrapClass:t.node!=t.text&&(t.node.className="");var r=t.textClass?t.textClass+" "+(t.line.textClass||""):t.line.textClass;t.text.className=r||""}function Mt(e,t,r,i){if(t.gutter&&(t.node.removeChild(t.gutter),t.gutter=null),t.gutterBackground&&(t.node.removeChild(t.gutterBackground),t.gutterBackground=null),t.line.gutterClass){var o=Ct(t);t.gutterBackground=n("div",null,"CodeMirror-gutter-background "+t.line.gutterClass,"left: "+(e.options.fixedGutter?i.fixedPos:-i.gutterTotalWidth)+"px; width: "+i.gutterTotalWidth+"px"),e.display.input.setUneditable(t.gutterBackground),o.insertBefore(t.gutterBackground,t.text)}var l=t.line.gutterMarkers;if(e.options.lineNumbers||l){var s=Ct(t),a=t.gutter=n("div",null,"CodeMirror-gutter-wrapper","left: "+(e.options.fixedGutter?i.fixedPos:-i.gutterTotalWidth)+"px");if(e.display.input.setUneditable(a),s.insertBefore(a,t.text),t.line.gutterClass&&(a.className+=" "+t.line.gutterClass),!e.options.lineNumbers||l&&l["CodeMirror-linenumbers"]||(t.lineNumber=a.appendChild(n("div",F(e.options,r),"CodeMirror-linenumber CodeMirror-gutter-elt","left: "+i.gutterLeft["CodeMirror-linenumbers"]+"px; width: "+e.display.lineNumInnerWidth+"px"))),l)for(var u=0;u<e.options.gutters.length;++u){var c=e.options.gutters[u],f=l.hasOwnProperty(c)&&l[c];f&&a.appendChild(n("div",[f],"CodeMirror-gutter-elt","left: "+i.gutterLeft[c]+"px; width: "+i.gutterWidth[c]+"px"))}}}function Nt(e,t,r){t.alignable&&(t.alignable=null);for(var n=t.node.firstChild,i=void 0;n;n=i)i=n.nextSibling,"CodeMirror-linewidget"==n.className&&t.node.removeChild(n);At(e,t,r)}function Ot(e,t,r,n){var i=Lt(e,t);return t.text=t.node=i.pre,i.bgClass&&(t.bgClass=i.bgClass),i.textClass&&(t.textClass=i.textClass),Tt(e,t),Mt(e,t,r,n),At(e,t,n),t.node}function At(e,t,r){if(Wt(e,t.line,t,r,!0),t.rest)for(var n=0;n<t.rest.length;n++)Wt(e,t.rest[n],t,r,!1)}function Wt(e,t,r,i,o){if(t.widgets)for(var l=Ct(r),s=0,a=t.widgets;s<a.length;++s){var u=a[s],c=n("div",[u.node],"CodeMirror-linewidget");u.handleMouseEvents||c.setAttribute("cm-ignore-events","true"),Dt(u,c,r,i),e.display.input.setUneditable(c),o&&u.above?l.insertBefore(c,r.gutter||r.text):l.appendChild(c),bt(u,"redraw")}}function Dt(e,t,r,n){if(e.noHScroll){(r.alignable||(r.alignable=[])).push(t);var i=n.wrapperWidth;t.style.left=n.fixedPos+"px",e.coverGutter||(i-=n.gutterTotalWidth,t.style.paddingLeft=n.gutterTotalWidth+"px"),t.style.width=i+"px"}e.coverGutter&&(t.style.zIndex=5,t.style.position="relative",e.noHScroll||(t.style.marginLeft=-n.gutterTotalWidth+"px"))}function Ht(e){if(null!=e.height)return e.height;var t=e.doc.cm;if(!t)return 0;if(!o(document.body,e.node)){var i="position: relative;";e.coverGutter&&(i+="margin-left: -"+t.display.gutters.offsetWidth+"px;"),e.noHScroll&&(i+="width: "+t.display.wrapper.clientWidth+"px;"),r(t.display.measure,n("div",[e.node],null,i))}return e.height=e.node.parentNode.offsetHeight}function Ft(e,t){for(var r=Ee(t);r!=e.wrapper;r=r.parentNode)if(!r||1==r.nodeType&&"true"==r.getAttribute("cm-ignore-events")||r.parentNode==e.sizer&&r!=e.mover)return!0}function Et(e){return e.lineSpace.offsetTop}function Pt(e){return e.mover.offsetHeight-e.lineSpace.offsetHeight}function It(e){if(e.cachedPaddingH)return e.cachedPaddingH;var t=r(e.measure,n("pre","x")),i=window.getComputedStyle?window.getComputedStyle(t):t.currentStyle,o={left:parseInt(i.paddingLeft),right:parseInt(i.paddingRight)};return isNaN(o.left)||isNaN(o.right)||(e.cachedPaddingH=o),o}function zt(e){return Rl-e.display.nativeBarWidth}function Rt(e){return e.display.scroller.clientWidth-zt(e)-e.display.barWidth}function Bt(e){return e.display.scroller.clientHeight-zt(e)-e.display.barHeight}function Gt(e,t,r){var n=e.options.lineWrapping,i=n&&Rt(e);if(!t.measure.heights||n&&t.measure.width!=i){var o=t.measure.heights=[];if(n){t.measure.width=i;for(var l=t.text.firstChild.getClientRects(),s=0;s<l.length-1;s++){var a=l[s],u=l[s+1];Math.abs(a.bottom-u.bottom)>2&&o.push((a.bottom+u.top)/2-r.top)}}o.push(r.bottom-r.top)}}function Ut(e,t,r){if(e.line==t)return{map:e.measure.map,cache:e.measure.cache};for(var n=0;n<e.rest.length;n++)if(e.rest[n]==t)return{map:e.measure.maps[n],cache:e.measure.caches[n]};for(var i=0;i<e.rest.length;i++)if(W(e.rest[i])>r)return{map:e.measure.maps[i],cache:e.measure.caches[i],before:!0}}function Vt(e,t){var n=W(t=fe(t)),i=e.display.externalMeasured=new pt(e.doc,t,n);i.lineN=n;var o=i.built=st(e,i);return i.text=o.pre,r(e.display.lineMeasure,o.pre),i}function Kt(e,t,r,n){return Yt(e,Xt(e,t),r,n)}function jt(e,t){if(t>=e.display.viewFrom&&t<e.display.viewTo)return e.display.view[Lr(e,t)];var r=e.display.externalMeasured;return r&&t>=r.lineN&&t<r.lineN+r.size?r:void 0}function Xt(e,t){var r=W(t),n=jt(e,r);n&&!n.text?n=null:n&&n.changes&&(xt(e,n,r,br(e)),e.curOp.forceUpdate=!0),n||(n=Vt(e,t));var i=Ut(n,t,r);return{line:t,view:n,rect:null,map:i.map,cache:i.cache,before:i.before,hasHeights:!1}}function Yt(e,t,r,n,i){t.before&&(r=-1);var o,l=r+(n||"");return t.cache.hasOwnProperty(l)?o=t.cache[l]:(t.rect||(t.rect=t.view.text.getBoundingClientRect()),t.hasHeights||(Gt(e,t.view,t.rect),t.hasHeights=!0),(o=qt(e,t,r,n)).bogus||(t.cache[l]=o)),{left:o.left,right:o.right,top:i?o.rtop:o.top,bottom:i?o.rbottom:o.bottom}}function _t(e,t,r){for(var n,i,o,l,s,a,u=0;u<e.length;u+=3)if(s=e[u],a=e[u+1],t<s?(i=0,o=1,l="left"):t<a?o=(i=t-s)+1:(u==e.length-3||t==a&&e[u+3]>t)&&(i=(o=a-s)-1,t>=a&&(l="right")),null!=i){if(n=e[u+2],s==a&&r==(n.insertLeft?"left":"right")&&(l=r),"left"==r&&0==i)for(;u&&e[u-2]==e[u-3]&&e[u-1].insertLeft;)n=e[2+(u-=3)],l="left";if("right"==r&&i==a-s)for(;u<e.length-3&&e[u+3]==e[u+4]&&!e[u+5].insertLeft;)n=e[(u+=3)+2],l="right";break}return{node:n,start:i,end:o,collapse:l,coverStart:s,coverEnd:a}}function $t(e,t){var r=ms;if("left"==t)for(var n=0;n<e.length&&(r=e[n]).left==r.right;n++);else for(var i=e.length-1;i>=0&&(r=e[i]).left==r.right;i--);return r}function qt(e,t,r,n){var i,o=_t(t.map,r,n),l=o.node,s=o.start,a=o.end,u=o.collapse;if(3==l.nodeType){for(var c=0;c<4;c++){for(;s&&S(t.line.text.charAt(o.coverStart+s));)--s;for(;o.coverStart+a<o.coverEnd&&S(t.line.text.charAt(o.coverStart+a));)++a;if((i=gl&&vl<9&&0==s&&a==o.coverEnd-o.coverStart?l.parentNode.getBoundingClientRect():$t(Wl(l,s,a).getClientRects(),n)).left||i.right||0==s)break;a=s,s-=1,u="right"}gl&&vl<11&&(i=Zt(e.display.measure,i))}else{s>0&&(u=n="right");var f;i=e.options.lineWrapping&&(f=l.getClientRects()).length>1?f["right"==n?f.length-1:0]:l.getBoundingClientRect()}if(gl&&vl<9&&!s&&(!i||!i.left&&!i.right)){var h=l.parentNode.getClientRects()[0];i=h?{left:h.left,right:h.left+yr(e.display),top:h.top,bottom:h.bottom}:ms}for(var d=i.top-t.rect.top,p=i.bottom-t.rect.top,g=(d+p)/2,v=t.view.measure.heights,m=0;m<v.length-1&&!(g<v[m]);m++);var y=m?v[m-1]:0,b=v[m],w={left:("right"==u?i.right:i.left)-t.rect.left,right:("left"==u?i.left:i.right)-t.rect.left,top:y,bottom:b};return i.left||i.right||(w.bogus=!0),e.options.singleCursorHeightPerLine||(w.rtop=d,w.rbottom=p),w}function Zt(e,t){if(!window.screen||null==screen.logicalXDPI||screen.logicalXDPI==screen.deviceXDPI||!Re(e))return t;var r=screen.logicalXDPI/screen.deviceXDPI,n=screen.logicalYDPI/screen.deviceYDPI;return{left:t.left*r,right:t.right*r,top:t.top*n,bottom:t.bottom*n}}function Qt(e){if(e.measure&&(e.measure.cache={},e.measure.heights=null,e.rest))for(var t=0;t<e.rest.length;t++)e.measure.caches[t]={}}function Jt(e){e.display.externalMeasure=null,t(e.display.lineMeasure);for(var r=0;r<e.display.view.length;r++)Qt(e.display.view[r])}function er(e){Jt(e),e.display.cachedCharWidth=e.display.cachedTextHeight=e.display.cachedPaddingH=null,e.options.lineWrapping||(e.display.maxLineChanged=!0),e.display.lineNumChars=null}function tr(){return bl&&kl?-(document.body.getBoundingClientRect().left-parseInt(getComputedStyle(document.body).marginLeft)):window.pageXOffset||(document.documentElement||document.body).scrollLeft}function rr(){return bl&&kl?-(document.body.getBoundingClientRect().top-parseInt(getComputedStyle(document.body).marginTop)):window.pageYOffset||(document.documentElement||document.body).scrollTop}function nr(e){var t=0;if(e.widgets)for(var r=0;r<e.widgets.length;++r)e.widgets[r].above&&(t+=Ht(e.widgets[r]));return t}function ir(e,t,r,n,i){if(!i){var o=nr(t);r.top+=o,r.bottom+=o}if("line"==n)return r;n||(n="local");var l=ye(t);if("local"==n?l+=Et(e.display):l-=e.display.viewOffset,"page"==n||"window"==n){var s=e.display.lineSpace.getBoundingClientRect();l+=s.top+("window"==n?0:rr());var a=s.left+("window"==n?0:tr());r.left+=a,r.right+=a}return r.top+=l,r.bottom+=l,r}function or(e,t,r){if("div"==r)return t;var n=t.left,i=t.top;if("page"==r)n-=tr(),i-=rr();else if("local"==r||!r){var o=e.display.sizer.getBoundingClientRect();n+=o.left,i+=o.top}var l=e.display.lineSpace.getBoundingClientRect();return{left:n-l.left,top:i-l.top}}function lr(e,t,r,n,i){return n||(n=M(e.doc,t.line)),ir(e,n,Kt(e,n,t.ch,i),r)}function sr(e,t,r,n,i,o){function l(t,l){var s=Yt(e,i,t,l?"right":"left",o);return l?s.left=s.right:s.right=s.left,ir(e,n,s,r)}function s(e,t,r){var n=1==a[t].level;return l(r?e-1:e,n!=r)}n=n||M(e.doc,t.line),i||(i=Xt(e,n));var a=Se(n,e.doc.direction),u=t.ch,c=t.sticky;if(u>=n.text.length?(u=n.text.length,c="before"):u<=0&&(u=0,c="after"),!a)return l("before"==c?u-1:u,"before"==c);var f=Ce(a,u,c),h=$l,d=s(u,f,"before"==c);return null!=h&&(d.other=s(u,h,"before"!=c)),d}function ar(e,t){var r=0;t=U(e.doc,t),e.options.lineWrapping||(r=yr(e.display)*t.ch);var n=M(e.doc,t.line),i=ye(n)+Et(e.display);return{left:r,right:r,top:i,bottom:i+n.height}}function ur(e,t,r,n,i){var o=E(e,t,r);return o.xRel=i,n&&(o.outside=!0),o}function cr(e,t,r){var n=e.doc;if((r+=e.display.viewOffset)<0)return ur(n.first,0,null,!0,-1);var i=D(n,r),o=n.first+n.size-1;if(i>o)return ur(n.first+n.size-1,M(n,o).text.length,null,!0,1);t<0&&(t=0);for(var l=M(n,i);;){var s=pr(e,l,i,t,r),a=ue(l),u=a&&a.find(0,!0);if(!a||!(s.ch>u.from.ch||s.ch==u.from.ch&&s.xRel>0))return s;i=W(l=u.to.line)}}function fr(e,t,r,n){n-=nr(t);var i=t.text.length,o=k(function(t){return Yt(e,r,t-1).bottom<=n},i,0);return i=k(function(t){return Yt(e,r,t).top>n},o,i),{begin:o,end:i}}function hr(e,t,r,n){return r||(r=Xt(e,t)),fr(e,t,r,ir(e,t,Yt(e,r,n),"line").top)}function dr(e,t,r,n){return!(e.bottom<=r)&&(e.top>r||(n?e.left:e.right)>t)}function pr(e,t,r,n,i){i-=ye(t);var o=Xt(e,t),l=nr(t),s=0,a=t.text.length,u=!0,c=Se(t,e.doc.direction);if(c){var f=(e.options.lineWrapping?vr:gr)(e,t,r,o,c,n,i);s=(u=1!=f.level)?f.from:f.to-1,a=u?f.to:f.from-1}var h,d,p=null,g=null,v=k(function(t){var r=Yt(e,o,t);return r.top+=l,r.bottom+=l,!!dr(r,n,i,!1)&&(r.top<=i&&r.left<=n&&(p=t,g=r),!0)},s,a),m=!1;if(g){var y=n-g.left<g.right-n,b=y==u;v=p+(b?0:1),d=b?"after":"before",h=y?g.left:g.right}else{u||v!=a&&v!=s||v++,d=0==v?"after":v==t.text.length?"before":Yt(e,o,v-(u?1:0)).bottom+l<=i==u?"after":"before";var w=sr(e,E(r,v,d),"line",t,o);h=w.left,m=i<w.top||i>=w.bottom}return v=L(t.text,v,1),ur(r,v,d,m,n-h)}function gr(e,t,r,n,i,o,l){var s=k(function(s){var a=i[s],u=1!=a.level;return dr(sr(e,E(r,u?a.to:a.from,u?"before":"after"),"line",t,n),o,l,!0)},0,i.length-1),a=i[s];if(s>0){var u=1!=a.level,c=sr(e,E(r,u?a.from:a.to,u?"after":"before"),"line",t,n);dr(c,o,l,!0)&&c.top>l&&(a=i[s-1])}return a}function vr(e,t,r,n,i,o,l){for(var s=fr(e,t,n,l),a=s.begin,u=s.end,c=null,f=null,h=0;h<i.length;h++){var d=i[h];if(!(d.from>=u||d.to<=a)){var p=Yt(e,n,1!=d.level?Math.min(u,d.to)-1:Math.max(a,d.from)).right,g=p<o?o-p+1e9:p-o;(!c||f>g)&&(c=d,f=g)}}return c||(c=i[i.length-1]),c.from<a&&(c={from:a,to:c.to,level:c.level}),c.to>u&&(c={from:c.from,to:u,level:c.level}),c}function mr(e){if(null!=e.cachedTextHeight)return e.cachedTextHeight;if(null==hs){hs=n("pre");for(var i=0;i<49;++i)hs.appendChild(document.createTextNode("x")),hs.appendChild(n("br"));hs.appendChild(document.createTextNode("x"))}r(e.measure,hs);var o=hs.offsetHeight/50;return o>3&&(e.cachedTextHeight=o),t(e.measure),o||1}function yr(e){if(null!=e.cachedCharWidth)return e.cachedCharWidth;var t=n("span","xxxxxxxxxx"),i=n("pre",[t]);r(e.measure,i);var o=t.getBoundingClientRect(),l=(o.right-o.left)/10;return l>2&&(e.cachedCharWidth=l),l||10}function br(e){for(var t=e.display,r={},n={},i=t.gutters.clientLeft,o=t.gutters.firstChild,l=0;o;o=o.nextSibling,++l)r[e.options.gutters[l]]=o.offsetLeft+o.clientLeft+i,n[e.options.gutters[l]]=o.clientWidth;return{fixedPos:wr(t),gutterTotalWidth:t.gutters.offsetWidth,gutterLeft:r,gutterWidth:n,wrapperWidth:t.wrapper.clientWidth}}function wr(e){return e.scroller.getBoundingClientRect().left-e.sizer.getBoundingClientRect().left}function xr(e){var t=mr(e.display),r=e.options.lineWrapping,n=r&&Math.max(5,e.display.scroller.clientWidth/yr(e.display)-3);return function(i){if(ve(e.doc,i))return 0;var o=0;if(i.widgets)for(var l=0;l<i.widgets.length;l++)i.widgets[l].height&&(o+=i.widgets[l].height);return r?o+(Math.ceil(i.text.length/n)||1)*t:o+t}}function Cr(e){var t=e.doc,r=xr(e);t.iter(function(e){var t=r(e);t!=e.height&&A(e,t)})}function Sr(e,t,r,n){var i=e.display;if(!r&&"true"==Ee(t).getAttribute("cm-not-content"))return null;var o,l,s=i.lineSpace.getBoundingClientRect();try{o=t.clientX-s.left,l=t.clientY-s.top}catch(t){return null}var a,u=cr(e,o,l);if(n&&1==u.xRel&&(a=M(e.doc,u.line).text).length==u.ch){var c=f(a,a.length,e.options.tabSize)-a.length;u=E(u.line,Math.max(0,Math.round((o-It(e.display).left)/yr(e.display))-c))}return u}function Lr(e,t){if(t>=e.display.viewTo)return null;if((t-=e.display.viewFrom)<0)return null;for(var r=e.display.view,n=0;n<r.length;n++)if((t-=r[n].size)<0)return n}function kr(e){e.display.input.showSelection(e.display.input.prepareSelection())}function Tr(e,t){void 0===t&&(t=!0);for(var r=e.doc,n={},i=n.cursors=document.createDocumentFragment(),o=n.selection=document.createDocumentFragment(),l=0;l<r.sel.ranges.length;l++)if(t||l!=r.sel.primIndex){var s=r.sel.ranges[l];if(!(s.from().line>=e.display.viewTo||s.to().line<e.display.viewFrom)){var a=s.empty();(a||e.options.showCursorWhenSelecting)&&Mr(e,s.head,i),a||Or(e,s,o)}}return n}function Mr(e,t,r){var i=sr(e,t,"div",null,null,!e.options.singleCursorHeightPerLine),o=r.appendChild(n("div"," ","CodeMirror-cursor"));if(o.style.left=i.left+"px",o.style.top=i.top+"px",o.style.height=Math.max(0,i.bottom-i.top)*e.options.cursorHeight+"px",i.other){var l=r.appendChild(n("div"," ","CodeMirror-cursor CodeMirror-secondarycursor"));l.style.display="",l.style.left=i.other.left+"px",l.style.top=i.other.top+"px",l.style.height=.85*(i.other.bottom-i.other.top)+"px"}}function Nr(e,t){return e.top-t.top||e.left-t.left}function Or(e,t,r){function i(e,t,r,i){t<0&&(t=0),t=Math.round(t),i=Math.round(i),a.appendChild(n("div",null,"CodeMirror-selected","position: absolute; left: "+e+"px;\n                             top: "+t+"px; width: "+(null==r?f-e:r)+"px;\n                             height: "+(i-t)+"px"))}function o(t,r,n){function o(r,n){return lr(e,E(t,r),"div",u,n)}var l,a,u=M(s,t),h=u.text.length,d=Se(u,s.direction);return xe(d,r||0,null==n?h:n,function(t,s,p,g){var v=o(t,"ltr"==p?"left":"right"),m=o(s-1,"ltr"==p?"right":"left");if("ltr"==p){var y=null==r&&0==t?c:v.left,b=null==n&&s==h?f:m.right;m.top-v.top<=3?i(y,m.top,b-y,m.bottom):(i(y,v.top,null,v.bottom),v.bottom<m.top&&i(c,v.bottom,null,m.top),i(c,m.top,m.right,m.bottom))}else if(t<s){var w=null==r&&0==t?f:v.right,x=null==n&&s==h?c:m.left;if(m.top-v.top<=3)i(x,m.top,w-x,m.bottom);else{var C=c;if(g){var S=hr(e,u,null,t).end;C=o(S-(/\s/.test(u.text.charAt(S-1))?2:1),"left").left}i(C,v.top,w-C,v.bottom),v.bottom<m.top&&i(c,v.bottom,null,m.top);var L=null;d.length,L=o(hr(e,u,null,s).begin,"right").right-x,i(x,m.top,L,m.bottom)}}(!l||Nr(v,l)<0)&&(l=v),Nr(m,l)<0&&(l=m),(!a||Nr(v,a)<0)&&(a=v),Nr(m,a)<0&&(a=m)}),{start:l,end:a}}var l=e.display,s=e.doc,a=document.createDocumentFragment(),u=It(e.display),c=u.left,f=Math.max(l.sizerWidth,Rt(e)-l.sizer.offsetLeft)-u.right,h=t.from(),d=t.to();if(h.line==d.line)o(h.line,h.ch,d.ch);else{var p=M(s,h.line),g=M(s,d.line),v=fe(p)==fe(g),m=o(h.line,h.ch,v?p.text.length+1:null).end,y=o(d.line,v?0:null,d.ch).start;v&&(m.top<y.top-2?(i(m.right,m.top,null,m.bottom),i(c,y.top,y.left,y.bottom)):i(m.right,m.top,y.left-m.right,m.bottom)),m.bottom<y.top&&i(c,m.bottom,null,y.top)}r.appendChild(a)}function Ar(e){if(e.state.focused){var t=e.display;clearInterval(t.blinker);var r=!0;t.cursorDiv.style.visibility="",e.options.cursorBlinkRate>0?t.blinker=setInterval(function(){return t.cursorDiv.style.visibility=(r=!r)?"":"hidden"},e.options.cursorBlinkRate):e.options.cursorBlinkRate<0&&(t.cursorDiv.style.visibility="hidden")}}function Wr(e){e.state.focused||(e.display.input.focus(),Hr(e))}function Dr(e){e.state.delayingBlurEvent=!0,setTimeout(function(){e.state.delayingBlurEvent&&(e.state.delayingBlurEvent=!1,Fr(e))},100)}function Hr(e,t){e.state.delayingBlurEvent&&(e.state.delayingBlurEvent=!1),"nocursor"!=e.options.readOnly&&(e.state.focused||(Te(e,"focus",e,t),e.state.focused=!0,s(e.display.wrapper,"CodeMirror-focused"),e.curOp||e.display.selForContextMenu==e.doc.sel||(e.display.input.reset(),ml&&setTimeout(function(){return e.display.input.reset(!0)},20)),e.display.input.receivedFocus()),Ar(e))}function Fr(e,t){e.state.delayingBlurEvent||(e.state.focused&&(Te(e,"blur",e,t),e.state.focused=!1,Fl(e.display.wrapper,"CodeMirror-focused")),clearInterval(e.display.blinker),setTimeout(function(){e.state.focused||(e.display.shift=!1)},150))}function Er(e){for(var t=e.display,r=t.lineDiv.offsetTop,n=0;n<t.view.length;n++){var i=t.view[n],o=void 0;if(!i.hidden){if(gl&&vl<8){var l=i.node.offsetTop+i.node.offsetHeight;o=l-r,r=l}else{var s=i.node.getBoundingClientRect();o=s.bottom-s.top}var a=i.line.height-o;if(o<2&&(o=mr(t)),(a>.005||a<-.005)&&(A(i.line,o),Pr(i.line),i.rest))for(var u=0;u<i.rest.length;u++)Pr(i.rest[u])}}}function Pr(e){if(e.widgets)for(var t=0;t<e.widgets.length;++t)e.widgets[t].height=e.widgets[t].node.parentNode.offsetHeight}function Ir(e,t,r){var n=r&&null!=r.top?Math.max(0,r.top):e.scroller.scrollTop;n=Math.floor(n-Et(e));var i=r&&null!=r.bottom?r.bottom:n+e.wrapper.clientHeight,o=D(t,n),l=D(t,i);if(r&&r.ensure){var s=r.ensure.from.line,a=r.ensure.to.line;s<o?(o=s,l=D(t,ye(M(t,s))+e.wrapper.clientHeight)):Math.min(a,t.lastLine())>=l&&(o=D(t,ye(M(t,a))-e.wrapper.clientHeight),l=a)}return{from:o,to:Math.max(l,o+1)}}function zr(e){var t=e.display,r=t.view;if(t.alignWidgets||t.gutters.firstChild&&e.options.fixedGutter){for(var n=wr(t)-t.scroller.scrollLeft+e.doc.scrollLeft,i=t.gutters.offsetWidth,o=n+"px",l=0;l<r.length;l++)if(!r[l].hidden){e.options.fixedGutter&&(r[l].gutter&&(r[l].gutter.style.left=o),r[l].gutterBackground&&(r[l].gutterBackground.style.left=o));var s=r[l].alignable;if(s)for(var a=0;a<s.length;a++)s[a].style.left=o}e.options.fixedGutter&&(t.gutters.style.left=n+i+"px")}}function Rr(e){if(!e.options.lineNumbers)return!1;var t=e.doc,r=F(e.options,t.first+t.size-1),i=e.display;if(r.length!=i.lineNumChars){var o=i.measure.appendChild(n("div",[n("div",r)],"CodeMirror-linenumber CodeMirror-gutter-elt")),l=o.firstChild.offsetWidth,s=o.offsetWidth-l;return i.lineGutter.style.width="",i.lineNumInnerWidth=Math.max(l,i.lineGutter.offsetWidth-s)+1,i.lineNumWidth=i.lineNumInnerWidth+s,i.lineNumChars=i.lineNumInnerWidth?r.length:-1,i.lineGutter.style.width=i.lineNumWidth+"px",Wn(e),!0}return!1}function Br(e,t){if(!Me(e,"scrollCursorIntoView")){var r=e.display,i=r.sizer.getBoundingClientRect(),o=null;if(t.top+i.top<0?o=!0:t.bottom+i.top>(window.innerHeight||document.documentElement.clientHeight)&&(o=!1),null!=o&&!Sl){var l=n("div","​",null,"position: absolute;\n                         top: "+(t.top-r.viewOffset-Et(e.display))+"px;\n                         height: "+(t.bottom-t.top+zt(e)+r.barHeight)+"px;\n                         left: "+t.left+"px; width: "+Math.max(2,t.right-t.left)+"px;");e.display.lineSpace.appendChild(l),l.scrollIntoView(o),e.display.lineSpace.removeChild(l)}}}function Gr(e,t,r,n){null==n&&(n=0);var i;e.options.lineWrapping||t!=r||(r="before"==(t=t.ch?E(t.line,"before"==t.sticky?t.ch-1:t.ch,"after"):t).sticky?E(t.line,t.ch+1,"before"):t);for(var o=0;o<5;o++){var l=!1,s=sr(e,t),a=r&&r!=t?sr(e,r):s,u=Vr(e,i={left:Math.min(s.left,a.left),top:Math.min(s.top,a.top)-n,right:Math.max(s.left,a.left),bottom:Math.max(s.bottom,a.bottom)+n}),c=e.doc.scrollTop,f=e.doc.scrollLeft;if(null!=u.scrollTop&&(qr(e,u.scrollTop),Math.abs(e.doc.scrollTop-c)>1&&(l=!0)),null!=u.scrollLeft&&(Qr(e,u.scrollLeft),Math.abs(e.doc.scrollLeft-f)>1&&(l=!0)),!l)break}return i}function Ur(e,t){var r=Vr(e,t);null!=r.scrollTop&&qr(e,r.scrollTop),null!=r.scrollLeft&&Qr(e,r.scrollLeft)}function Vr(e,t){var r=e.display,n=mr(e.display);t.top<0&&(t.top=0);var i=e.curOp&&null!=e.curOp.scrollTop?e.curOp.scrollTop:r.scroller.scrollTop,o=Bt(e),l={};t.bottom-t.top>o&&(t.bottom=t.top+o);var s=e.doc.height+Pt(r),a=t.top<n,u=t.bottom>s-n;if(t.top<i)l.scrollTop=a?0:t.top;else if(t.bottom>i+o){var c=Math.min(t.top,(u?s:t.bottom)-o);c!=i&&(l.scrollTop=c)}var f=e.curOp&&null!=e.curOp.scrollLeft?e.curOp.scrollLeft:r.scroller.scrollLeft,h=Rt(e)-(e.options.fixedGutter?r.gutters.offsetWidth:0),d=t.right-t.left>h;return d&&(t.right=t.left+h),t.left<10?l.scrollLeft=0:t.left<f?l.scrollLeft=Math.max(0,t.left-(d?0:10)):t.right>h+f-3&&(l.scrollLeft=t.right+(d?0:10)-h),l}function Kr(e,t){null!=t&&(_r(e),e.curOp.scrollTop=(null==e.curOp.scrollTop?e.doc.scrollTop:e.curOp.scrollTop)+t)}function jr(e){_r(e);var t=e.getCursor();e.curOp.scrollToPos={from:t,to:t,margin:e.options.cursorScrollMargin}}function Xr(e,t,r){null==t&&null==r||_r(e),null!=t&&(e.curOp.scrollLeft=t),null!=r&&(e.curOp.scrollTop=r)}function Yr(e,t){_r(e),e.curOp.scrollToPos=t}function _r(e){var t=e.curOp.scrollToPos;t&&(e.curOp.scrollToPos=null,$r(e,ar(e,t.from),ar(e,t.to),t.margin))}function $r(e,t,r,n){var i=Vr(e,{left:Math.min(t.left,r.left),top:Math.min(t.top,r.top)-n,right:Math.max(t.right,r.right),bottom:Math.max(t.bottom,r.bottom)+n});Xr(e,i.scrollLeft,i.scrollTop)}function qr(e,t){Math.abs(e.doc.scrollTop-t)<2||(fl||On(e,{top:t}),Zr(e,t,!0),fl&&On(e),Cn(e,100))}function Zr(e,t,r){t=Math.min(e.display.scroller.scrollHeight-e.display.scroller.clientHeight,t),(e.display.scroller.scrollTop!=t||r)&&(e.doc.scrollTop=t,e.display.scrollbars.setScrollTop(t),e.display.scroller.scrollTop!=t&&(e.display.scroller.scrollTop=t))}function Qr(e,t,r,n){t=Math.min(t,e.display.scroller.scrollWidth-e.display.scroller.clientWidth),(r?t==e.doc.scrollLeft:Math.abs(e.doc.scrollLeft-t)<2)&&!n||(e.doc.scrollLeft=t,zr(e),e.display.scroller.scrollLeft!=t&&(e.display.scroller.scrollLeft=t),e.display.scrollbars.setScrollLeft(t))}function Jr(e){var t=e.display,r=t.gutters.offsetWidth,n=Math.round(e.doc.height+Pt(e.display));return{clientHeight:t.scroller.clientHeight,viewHeight:t.wrapper.clientHeight,scrollWidth:t.scroller.scrollWidth,clientWidth:t.scroller.clientWidth,viewWidth:t.wrapper.clientWidth,barLeft:e.options.fixedGutter?r:0,docHeight:n,scrollHeight:n+zt(e)+t.barHeight,nativeBarWidth:t.nativeBarWidth,gutterWidth:r}}function en(e,t){t||(t=Jr(e));var r=e.display.barWidth,n=e.display.barHeight;tn(e,t);for(var i=0;i<4&&r!=e.display.barWidth||n!=e.display.barHeight;i++)r!=e.display.barWidth&&e.options.lineWrapping&&Er(e),tn(e,Jr(e)),r=e.display.barWidth,n=e.display.barHeight}function tn(e,t){var r=e.display,n=r.scrollbars.update(t);r.sizer.style.paddingRight=(r.barWidth=n.right)+"px",r.sizer.style.paddingBottom=(r.barHeight=n.bottom)+"px",r.heightForcer.style.borderBottom=n.bottom+"px solid transparent",n.right&&n.bottom?(r.scrollbarFiller.style.display="block",r.scrollbarFiller.style.height=n.bottom+"px",r.scrollbarFiller.style.width=n.right+"px"):r.scrollbarFiller.style.display="",n.bottom&&e.options.coverGutterNextToScrollbar&&e.options.fixedGutter?(r.gutterFiller.style.display="block",r.gutterFiller.style.height=n.bottom+"px",r.gutterFiller.style.width=t.gutterWidth+"px"):r.gutterFiller.style.display=""}function rn(e){e.display.scrollbars&&(e.display.scrollbars.clear(),e.display.scrollbars.addClass&&Fl(e.display.wrapper,e.display.scrollbars.addClass)),e.display.scrollbars=new ws[e.options.scrollbarStyle](function(t){e.display.wrapper.insertBefore(t,e.display.scrollbarFiller),Ql(t,"mousedown",function(){e.state.focused&&setTimeout(function(){return e.display.input.focus()},0)}),t.setAttribute("cm-not-content","true")},function(t,r){"horizontal"==r?Qr(e,t):qr(e,t)},e),e.display.scrollbars.addClass&&s(e.display.wrapper,e.display.scrollbars.addClass)}function nn(e){e.curOp={cm:e,viewChanged:!1,startHeight:e.doc.height,forceUpdate:!1,updateInput:null,typing:!1,changeObjs:null,cursorActivityHandlers:null,cursorActivityCalled:0,selectionChanged:!1,updateMaxLine:!1,scrollLeft:null,scrollTop:null,scrollToPos:null,focus:!1,id:++xs},vt(e.curOp)}function on(e){yt(e.curOp,function(e){for(var t=0;t<e.ops.length;t++)e.ops[t].cm.curOp=null;ln(e)})}function ln(e){for(var t=e.ops,r=0;r<t.length;r++)sn(t[r]);for(var n=0;n<t.length;n++)an(t[n]);for(var i=0;i<t.length;i++)un(t[i]);for(var o=0;o<t.length;o++)cn(t[o]);for(var l=0;l<t.length;l++)fn(t[l])}function sn(e){var t=e.cm,r=t.display;Ln(t),e.updateMaxLine&&we(t),e.mustUpdate=e.viewChanged||e.forceUpdate||null!=e.scrollTop||e.scrollToPos&&(e.scrollToPos.from.line<r.viewFrom||e.scrollToPos.to.line>=r.viewTo)||r.maxLineChanged&&t.options.lineWrapping,e.update=e.mustUpdate&&new Cs(t,e.mustUpdate&&{top:e.scrollTop,ensure:e.scrollToPos},e.forceUpdate)}function an(e){e.updatedDisplay=e.mustUpdate&&Mn(e.cm,e.update)}function un(e){var t=e.cm,r=t.display;e.updatedDisplay&&Er(t),e.barMeasure=Jr(t),r.maxLineChanged&&!t.options.lineWrapping&&(e.adjustWidthTo=Kt(t,r.maxLine,r.maxLine.text.length).left+3,t.display.sizerWidth=e.adjustWidthTo,e.barMeasure.scrollWidth=Math.max(r.scroller.clientWidth,r.sizer.offsetLeft+e.adjustWidthTo+zt(t)+t.display.barWidth),e.maxScrollLeft=Math.max(0,r.sizer.offsetLeft+e.adjustWidthTo-Rt(t))),(e.updatedDisplay||e.selectionChanged)&&(e.preparedSelection=r.input.prepareSelection())}function cn(e){var t=e.cm;null!=e.adjustWidthTo&&(t.display.sizer.style.minWidth=e.adjustWidthTo+"px",e.maxScrollLeft<t.doc.scrollLeft&&Qr(t,Math.min(t.display.scroller.scrollLeft,e.maxScrollLeft),!0),t.display.maxLineChanged=!1);var r=e.focus&&e.focus==l();e.preparedSelection&&t.display.input.showSelection(e.preparedSelection,r),(e.updatedDisplay||e.startHeight!=t.doc.height)&&en(t,e.barMeasure),e.updatedDisplay&&Dn(t,e.barMeasure),e.selectionChanged&&Ar(t),t.state.focused&&e.updateInput&&t.display.input.reset(e.typing),r&&Wr(e.cm)}function fn(e){var t=e.cm,r=t.display,n=t.doc;e.updatedDisplay&&Nn(t,e.update),null==r.wheelStartX||null==e.scrollTop&&null==e.scrollLeft&&!e.scrollToPos||(r.wheelStartX=r.wheelStartY=null),null!=e.scrollTop&&Zr(t,e.scrollTop,e.forceScroll),null!=e.scrollLeft&&Qr(t,e.scrollLeft,!0,!0),e.scrollToPos&&Br(t,Gr(t,U(n,e.scrollToPos.from),U(n,e.scrollToPos.to),e.scrollToPos.margin));var i=e.maybeHiddenMarkers,o=e.maybeUnhiddenMarkers;if(i)for(var l=0;l<i.length;++l)i[l].lines.length||Te(i[l],"hide");if(o)for(var s=0;s<o.length;++s)o[s].lines.length&&Te(o[s],"unhide");r.wrapper.offsetHeight&&(n.scrollTop=t.display.scroller.scrollTop),e.changeObjs&&Te(t,"changes",t,e.changeObjs),e.update&&e.update.finish()}function hn(e,t){if(e.curOp)return t();nn(e);try{return t()}finally{on(e)}}function dn(e,t){return function(){if(e.curOp)return t.apply(e,arguments);nn(e);try{return t.apply(e,arguments)}finally{on(e)}}}function pn(e){return function(){if(this.curOp)return e.apply(this,arguments);nn(this);try{return e.apply(this,arguments)}finally{on(this)}}}function gn(e){return function(){var t=this.cm;if(!t||t.curOp)return e.apply(this,arguments);nn(t);try{return e.apply(this,arguments)}finally{on(t)}}}function vn(e,t,r,n){null==t&&(t=e.doc.first),null==r&&(r=e.doc.first+e.doc.size),n||(n=0);var i=e.display;if(n&&r<i.viewTo&&(null==i.updateLineNumbers||i.updateLineNumbers>t)&&(i.updateLineNumbers=t),e.curOp.viewChanged=!0,t>=i.viewTo)_l&&pe(e.doc,t)<i.viewTo&&yn(e);else if(r<=i.viewFrom)_l&&ge(e.doc,r+n)>i.viewFrom?yn(e):(i.viewFrom+=n,i.viewTo+=n);else if(t<=i.viewFrom&&r>=i.viewTo)yn(e);else if(t<=i.viewFrom){var o=bn(e,r,r+n,1);o?(i.view=i.view.slice(o.index),i.viewFrom=o.lineN,i.viewTo+=n):yn(e)}else if(r>=i.viewTo){var l=bn(e,t,t,-1);l?(i.view=i.view.slice(0,l.index),i.viewTo=l.lineN):yn(e)}else{var s=bn(e,t,t,-1),a=bn(e,r,r+n,1);s&&a?(i.view=i.view.slice(0,s.index).concat(gt(e,s.lineN,a.lineN)).concat(i.view.slice(a.index)),i.viewTo+=n):yn(e)}var u=i.externalMeasured;u&&(r<u.lineN?u.lineN+=n:t<u.lineN+u.size&&(i.externalMeasured=null))}function mn(e,t,r){e.curOp.viewChanged=!0;var n=e.display,i=e.display.externalMeasured;if(i&&t>=i.lineN&&t<i.lineN+i.size&&(n.externalMeasured=null),!(t<n.viewFrom||t>=n.viewTo)){var o=n.view[Lr(e,t)];if(null!=o.node){var l=o.changes||(o.changes=[]);-1==h(l,r)&&l.push(r)}}}function yn(e){e.display.viewFrom=e.display.viewTo=e.doc.first,e.display.view=[],e.display.viewOffset=0}function bn(e,t,r,n){var i,o=Lr(e,t),l=e.display.view;if(!_l||r==e.doc.first+e.doc.size)return{index:o,lineN:r};for(var s=e.display.viewFrom,a=0;a<o;a++)s+=l[a].size;if(s!=t){if(n>0){if(o==l.length-1)return null;i=s+l[o].size-t,o++}else i=s-t;t+=i,r+=i}for(;pe(e.doc,r)!=r;){if(o==(n<0?0:l.length-1))return null;r+=n*l[o-(n<0?1:0)].size,o+=n}return{index:o,lineN:r}}function wn(e,t,r){var n=e.display;0==n.view.length||t>=n.viewTo||r<=n.viewFrom?(n.view=gt(e,t,r),n.viewFrom=t):(n.viewFrom>t?n.view=gt(e,t,n.viewFrom).concat(n.view):n.viewFrom<t&&(n.view=n.view.slice(Lr(e,t))),n.viewFrom=t,n.viewTo<r?n.view=n.view.concat(gt(e,n.viewTo,r)):n.viewTo>r&&(n.view=n.view.slice(0,Lr(e,r)))),n.viewTo=r}function xn(e){for(var t=e.display.view,r=0,n=0;n<t.length;n++){var i=t[n];i.hidden||i.node&&!i.changes||++r}return r}function Cn(e,t){e.doc.highlightFrontier<e.display.viewTo&&e.state.highlight.set(t,u(Sn,e))}function Sn(e){var t=e.doc;if(!(t.highlightFrontier>=e.display.viewTo)){var r=+new Date+e.options.workTime,n=$e(e,t.highlightFrontier),i=[];t.iter(n.line,Math.min(t.first+t.size,e.display.viewTo+500),function(o){if(n.line>=e.display.viewFrom){var l=o.styles,s=o.text.length>e.options.maxHighlightLength?Ke(t.mode,n.state):null,a=Ye(e,o,n,!0);s&&(n.state=s),o.styles=a.styles;var u=o.styleClasses,c=a.classes;c?o.styleClasses=c:u&&(o.styleClasses=null);for(var f=!l||l.length!=o.styles.length||u!=c&&(!u||!c||u.bgClass!=c.bgClass||u.textClass!=c.textClass),h=0;!f&&h<l.length;++h)f=l[h]!=o.styles[h];f&&i.push(n.line),o.stateAfter=n.save(),n.nextLine()}else o.text.length<=e.options.maxHighlightLength&&qe(e,o.text,n),o.stateAfter=n.line%5==0?n.save():null,n.nextLine();if(+new Date>r)return Cn(e,e.options.workDelay),!0}),t.highlightFrontier=n.line,t.modeFrontier=Math.max(t.modeFrontier,n.line),i.length&&hn(e,function(){for(var t=0;t<i.length;t++)mn(e,i[t],"text")})}}function Ln(e){var t=e.display;!t.scrollbarsClipped&&t.scroller.offsetWidth&&(t.nativeBarWidth=t.scroller.offsetWidth-t.scroller.clientWidth,t.heightForcer.style.height=zt(e)+"px",t.sizer.style.marginBottom=-t.nativeBarWidth+"px",t.sizer.style.borderRightWidth=zt(e)+"px",t.scrollbarsClipped=!0)}function kn(e){if(e.hasFocus())return null;var t=l();if(!t||!o(e.display.lineDiv,t))return null;var r={activeElt:t};if(window.getSelection){var n=window.getSelection();n.anchorNode&&n.extend&&o(e.display.lineDiv,n.anchorNode)&&(r.anchorNode=n.anchorNode,r.anchorOffset=n.anchorOffset,r.focusNode=n.focusNode,r.focusOffset=n.focusOffset)}return r}function Tn(e){if(e&&e.activeElt&&e.activeElt!=l()&&(e.activeElt.focus(),e.anchorNode&&o(document.body,e.anchorNode)&&o(document.body,e.focusNode))){var t=window.getSelection(),r=document.createRange();r.setEnd(e.anchorNode,e.anchorOffset),r.collapse(!1),t.removeAllRanges(),t.addRange(r),t.extend(e.focusNode,e.focusOffset)}}function Mn(e,r){var n=e.display,i=e.doc;if(r.editorIsHidden)return yn(e),!1;if(!r.force&&r.visible.from>=n.viewFrom&&r.visible.to<=n.viewTo&&(null==n.updateLineNumbers||n.updateLineNumbers>=n.viewTo)&&n.renderedView==n.view&&0==xn(e))return!1;Rr(e)&&(yn(e),r.dims=br(e));var o=i.first+i.size,l=Math.max(r.visible.from-e.options.viewportMargin,i.first),s=Math.min(o,r.visible.to+e.options.viewportMargin);n.viewFrom<l&&l-n.viewFrom<20&&(l=Math.max(i.first,n.viewFrom)),n.viewTo>s&&n.viewTo-s<20&&(s=Math.min(o,n.viewTo)),_l&&(l=pe(e.doc,l),s=ge(e.doc,s));var a=l!=n.viewFrom||s!=n.viewTo||n.lastWrapHeight!=r.wrapperHeight||n.lastWrapWidth!=r.wrapperWidth;wn(e,l,s),n.viewOffset=ye(M(e.doc,n.viewFrom)),e.display.mover.style.top=n.viewOffset+"px";var u=xn(e);if(!a&&0==u&&!r.force&&n.renderedView==n.view&&(null==n.updateLineNumbers||n.updateLineNumbers>=n.viewTo))return!1;var c=kn(e);return u>4&&(n.lineDiv.style.display="none"),An(e,n.updateLineNumbers,r.dims),u>4&&(n.lineDiv.style.display=""),n.renderedView=n.view,Tn(c),t(n.cursorDiv),t(n.selectionDiv),n.gutters.style.height=n.sizer.style.minHeight=0,a&&(n.lastWrapHeight=r.wrapperHeight,n.lastWrapWidth=r.wrapperWidth,Cn(e,400)),n.updateLineNumbers=null,!0}function Nn(e,t){for(var r=t.viewport,n=!0;(n&&e.options.lineWrapping&&t.oldDisplayWidth!=Rt(e)||(r&&null!=r.top&&(r={top:Math.min(e.doc.height+Pt(e.display)-Bt(e),r.top)}),t.visible=Ir(e.display,e.doc,r),!(t.visible.from>=e.display.viewFrom&&t.visible.to<=e.display.viewTo)))&&Mn(e,t);n=!1){Er(e);var i=Jr(e);kr(e),en(e,i),Dn(e,i),t.force=!1}t.signal(e,"update",e),e.display.viewFrom==e.display.reportedViewFrom&&e.display.viewTo==e.display.reportedViewTo||(t.signal(e,"viewportChange",e,e.display.viewFrom,e.display.viewTo),e.display.reportedViewFrom=e.display.viewFrom,e.display.reportedViewTo=e.display.viewTo)}function On(e,t){var r=new Cs(e,t);if(Mn(e,r)){Er(e),Nn(e,r);var n=Jr(e);kr(e),en(e,n),Dn(e,n),r.finish()}}function An(e,r,n){function i(t){var r=t.nextSibling;return ml&&Ml&&e.display.currentWheelTarget==t?t.style.display="none":t.parentNode.removeChild(t),r}for(var o=e.display,l=e.options.lineNumbers,s=o.lineDiv,a=s.firstChild,u=o.view,c=o.viewFrom,f=0;f<u.length;f++){var d=u[f];if(d.hidden);else if(d.node&&d.node.parentNode==s){for(;a!=d.node;)a=i(a);var p=l&&null!=r&&r<=c&&d.lineNumber;d.changes&&(h(d.changes,"gutter")>-1&&(p=!1),xt(e,d,c,n)),p&&(t(d.lineNumber),d.lineNumber.appendChild(document.createTextNode(F(e.options,c)))),a=d.node.nextSibling}else{var g=Ot(e,d,c,n);s.insertBefore(g,a)}c+=d.size}for(;a;)a=i(a)}function Wn(e){var t=e.display.gutters.offsetWidth;e.display.sizer.style.marginLeft=t+"px"}function Dn(e,t){e.display.sizer.style.minHeight=t.docHeight+"px",e.display.heightForcer.style.top=t.docHeight+"px",e.display.gutters.style.height=t.docHeight+e.display.barHeight+zt(e)+"px"}function Hn(e){var r=e.display.gutters,i=e.options.gutters;t(r);for(var o=0;o<i.length;++o){var l=i[o],s=r.appendChild(n("div",null,"CodeMirror-gutter "+l));"CodeMirror-linenumbers"==l&&(e.display.lineGutter=s,s.style.width=(e.display.lineNumWidth||1)+"px")}r.style.display=o?"":"none",Wn(e)}function Fn(e){var t=h(e.gutters,"CodeMirror-linenumbers");-1==t&&e.lineNumbers?e.gutters=e.gutters.concat(["CodeMirror-linenumbers"]):t>-1&&!e.lineNumbers&&(e.gutters=e.gutters.slice(0),e.gutters.splice(t,1))}function En(e){var t=e.wheelDeltaX,r=e.wheelDeltaY;return null==t&&e.detail&&e.axis==e.HORIZONTAL_AXIS&&(t=e.detail),null==r&&e.detail&&e.axis==e.VERTICAL_AXIS?r=e.detail:null==r&&(r=e.wheelDelta),{x:t,y:r}}function Pn(e){var t=En(e);return t.x*=Ls,t.y*=Ls,t}function In(e,t){var r=En(t),n=r.x,i=r.y,o=e.display,l=o.scroller,s=l.scrollWidth>l.clientWidth,a=l.scrollHeight>l.clientHeight;if(n&&s||i&&a){if(i&&Ml&&ml)e:for(var u=t.target,c=o.view;u!=l;u=u.parentNode)for(var f=0;f<c.length;f++)if(c[f].node==u){e.display.currentWheelTarget=u;break e}if(n&&!fl&&!wl&&null!=Ls)return i&&a&&qr(e,Math.max(0,l.scrollTop+i*Ls)),Qr(e,Math.max(0,l.scrollLeft+n*Ls)),(!i||i&&a)&&We(t),void(o.wheelStartX=null);if(i&&null!=Ls){var h=i*Ls,d=e.doc.scrollTop,p=d+o.wrapper.clientHeight;h<0?d=Math.max(0,d+h-50):p=Math.min(e.doc.height,p+h+50),On(e,{top:d,bottom:p})}Ss<20&&(null==o.wheelStartX?(o.wheelStartX=l.scrollLeft,o.wheelStartY=l.scrollTop,o.wheelDX=n,o.wheelDY=i,setTimeout(function(){if(null!=o.wheelStartX){var e=l.scrollLeft-o.wheelStartX,t=l.scrollTop-o.wheelStartY,r=t&&o.wheelDY&&t/o.wheelDY||e&&o.wheelDX&&e/o.wheelDX;o.wheelStartX=o.wheelStartY=null,r&&(Ls=(Ls*Ss+r)/(Ss+1),++Ss)}},200)):(o.wheelDX+=n,o.wheelDY+=i))}}function zn(e,t){var r=e[t];e.sort(function(e,t){return P(e.from(),t.from())}),t=h(e,r);for(var n=1;n<e.length;n++){var i=e[n],o=e[n-1];if(P(o.to(),i.from())>=0){var l=B(o.from(),i.from()),s=R(o.to(),i.to()),a=o.empty()?i.from()==i.head:o.from()==o.head;n<=t&&--t,e.splice(--n,2,new Ts(a?s:l,a?l:s))}}return new ks(e,t)}function Rn(e,t){return new ks([new Ts(e,t||e)],0)}function Bn(e){return e.text?E(e.from.line+e.text.length-1,g(e.text).length+(1==e.text.length?e.from.ch:0)):e.to}function Gn(e,t){if(P(e,t.from)<0)return e;if(P(e,t.to)<=0)return Bn(t);var r=e.line+t.text.length-(t.to.line-t.from.line)-1,n=e.ch;return e.line==t.to.line&&(n+=Bn(t).ch-t.to.ch),E(r,n)}function Un(e,t){for(var r=[],n=0;n<e.sel.ranges.length;n++){var i=e.sel.ranges[n];r.push(new Ts(Gn(i.anchor,t),Gn(i.head,t)))}return zn(r,e.sel.primIndex)}function Vn(e,t,r){return e.line==t.line?E(r.line,e.ch-t.ch+r.ch):E(r.line+(e.line-t.line),e.ch)}function Kn(e,t,r){for(var n=[],i=E(e.first,0),o=i,l=0;l<t.length;l++){var s=t[l],a=Vn(s.from,i,o),u=Vn(Bn(s),i,o);if(i=s.to,o=u,"around"==r){var c=e.sel.ranges[l],f=P(c.head,c.anchor)<0;n[l]=new Ts(f?u:a,f?a:u)}else n[l]=new Ts(a,a)}return new ks(n,e.sel.primIndex)}function jn(e){e.doc.mode=Ue(e.options,e.doc.modeOption),Xn(e)}function Xn(e){e.doc.iter(function(e){e.stateAfter&&(e.stateAfter=null),e.styles&&(e.styles=null)}),e.doc.modeFrontier=e.doc.highlightFrontier=e.doc.first,Cn(e,100),e.state.modeGen++,e.curOp&&vn(e)}function Yn(e,t){return 0==t.from.ch&&0==t.to.ch&&""==g(t.text)&&(!e.cm||e.cm.options.wholeLineUpdateBefore)}function _n(e,t,r,n){function i(e){return r?r[e]:null}function o(e,r,i){it(e,r,i,n),bt(e,"change",e,t)}function l(e,t){for(var r=[],o=e;o<t;++o)r.push(new fs(u[o],i(o),n));return r}var s=t.from,a=t.to,u=t.text,c=M(e,s.line),f=M(e,a.line),h=g(u),d=i(u.length-1),p=a.line-s.line;if(t.full)e.insert(0,l(0,u.length)),e.remove(u.length,e.size-u.length);else if(Yn(e,t)){var v=l(0,u.length-1);o(f,f.text,d),p&&e.remove(s.line,p),v.length&&e.insert(s.line,v)}else if(c==f)if(1==u.length)o(c,c.text.slice(0,s.ch)+h+c.text.slice(a.ch),d);else{var m=l(1,u.length-1);m.push(new fs(h+c.text.slice(a.ch),d,n)),o(c,c.text.slice(0,s.ch)+u[0],i(0)),e.insert(s.line+1,m)}else if(1==u.length)o(c,c.text.slice(0,s.ch)+u[0]+f.text.slice(a.ch),i(0)),e.remove(s.line+1,p);else{o(c,c.text.slice(0,s.ch)+u[0],i(0)),o(f,h+f.text.slice(a.ch),d);var y=l(1,u.length-1);p>1&&e.remove(s.line+1,p-1),e.insert(s.line+1,y)}bt(e,"change",e,t)}function $n(e,t,r){function n(e,i,o){if(e.linked)for(var l=0;l<e.linked.length;++l){var s=e.linked[l];if(s.doc!=i){var a=o&&s.sharedHist;r&&!a||(t(s.doc,a),n(s.doc,e,a))}}}n(e,null,!0)}function qn(e,t){if(t.cm)throw new Error("This document is already in use.");e.doc=t,t.cm=e,Cr(e),jn(e),Zn(e),e.options.lineWrapping||we(e),e.options.mode=t.modeOption,vn(e)}function Zn(e){("rtl"==e.doc.direction?s:Fl)(e.display.lineDiv,"CodeMirror-rtl")}function Qn(e){hn(e,function(){Zn(e),vn(e)})}function Jn(e){this.done=[],this.undone=[],this.undoDepth=1/0,this.lastModTime=this.lastSelTime=0,this.lastOp=this.lastSelOp=null,this.lastOrigin=this.lastSelOrigin=null,this.generation=this.maxGeneration=e||1}function ei(e,t){var r={from:z(t.from),to:Bn(t),text:N(e,t.from,t.to)};return si(e,r,t.from.line,t.to.line+1),$n(e,function(e){return si(e,r,t.from.line,t.to.line+1)},!0),r}function ti(e){for(;e.length&&g(e).ranges;)e.pop()}function ri(e,t){return t?(ti(e.done),g(e.done)):e.done.length&&!g(e.done).ranges?g(e.done):e.done.length>1&&!e.done[e.done.length-2].ranges?(e.done.pop(),g(e.done)):void 0}function ni(e,t,r,n){var i=e.history;i.undone.length=0;var o,l,s=+new Date;if((i.lastOp==n||i.lastOrigin==t.origin&&t.origin&&("+"==t.origin.charAt(0)&&e.cm&&i.lastModTime>s-e.cm.options.historyEventDelay||"*"==t.origin.charAt(0)))&&(o=ri(i,i.lastOp==n)))l=g(o.changes),0==P(t.from,t.to)&&0==P(t.from,l.to)?l.to=Bn(t):o.changes.push(ei(e,t));else{var a=g(i.done);for(a&&a.ranges||li(e.sel,i.done),o={changes:[ei(e,t)],generation:i.generation},i.done.push(o);i.done.length>i.undoDepth;)i.done.shift(),i.done[0].ranges||i.done.shift()}i.done.push(r),i.generation=++i.maxGeneration,i.lastModTime=i.lastSelTime=s,i.lastOp=i.lastSelOp=n,i.lastOrigin=i.lastSelOrigin=t.origin,l||Te(e,"historyAdded")}function ii(e,t,r,n){var i=t.charAt(0);return"*"==i||"+"==i&&r.ranges.length==n.ranges.length&&r.somethingSelected()==n.somethingSelected()&&new Date-e.history.lastSelTime<=(e.cm?e.cm.options.historyEventDelay:500)}function oi(e,t,r,n){var i=e.history,o=n&&n.origin;r==i.lastSelOp||o&&i.lastSelOrigin==o&&(i.lastModTime==i.lastSelTime&&i.lastOrigin==o||ii(e,o,g(i.done),t))?i.done[i.done.length-1]=t:li(t,i.done),i.lastSelTime=+new Date,i.lastSelOrigin=o,i.lastSelOp=r,n&&!1!==n.clearRedo&&ti(i.undone)}function li(e,t){var r=g(t);r&&r.ranges&&r.equals(e)||t.push(e)}function si(e,t,r,n){var i=t["spans_"+e.id],o=0;e.iter(Math.max(e.first,r),Math.min(e.first+e.size,n),function(r){r.markedSpans&&((i||(i=t["spans_"+e.id]={}))[o]=r.markedSpans),++o})}function ai(e){if(!e)return null;for(var t,r=0;r<e.length;++r)e[r].marker.explicitlyCleared?t||(t=e.slice(0,r)):t&&t.push(e[r]);return t?t.length?t:null:e}function ui(e,t){var r=t["spans_"+e.id];if(!r)return null;for(var n=[],i=0;i<t.text.length;++i)n.push(ai(r[i]));return n}function ci(e,t){var r=ui(e,t),n=J(e,t);if(!r)return n;if(!n)return r;for(var i=0;i<r.length;++i){var o=r[i],l=n[i];if(o&&l)e:for(var s=0;s<l.length;++s){for(var a=l[s],u=0;u<o.length;++u)if(o[u].marker==a.marker)continue e;o.push(a)}else l&&(r[i]=l)}return r}function fi(e,t,r){for(var n=[],i=0;i<e.length;++i){var o=e[i];if(o.ranges)n.push(r?ks.prototype.deepCopy.call(o):o);else{var l=o.changes,s=[];n.push({changes:s});for(var a=0;a<l.length;++a){var u=l[a],c=void 0;if(s.push({from:u.from,to:u.to,text:u.text}),t)for(var f in u)(c=f.match(/^spans_(\d+)$/))&&h(t,Number(c[1]))>-1&&(g(s)[f]=u[f],delete u[f])}}}return n}function hi(e,t,r,n){if(n){var i=e.anchor;if(r){var o=P(t,i)<0;o!=P(r,i)<0?(i=t,t=r):o!=P(t,r)<0&&(t=r)}return new Ts(i,t)}return new Ts(r||t,t)}function di(e,t,r,n,i){null==i&&(i=e.cm&&(e.cm.display.shift||e.extend)),bi(e,new ks([hi(e.sel.primary(),t,r,i)],0),n)}function pi(e,t,r){for(var n=[],i=e.cm&&(e.cm.display.shift||e.extend),o=0;o<e.sel.ranges.length;o++)n[o]=hi(e.sel.ranges[o],t[o],null,i);bi(e,zn(n,e.sel.primIndex),r)}function gi(e,t,r,n){var i=e.sel.ranges.slice(0);i[t]=r,bi(e,zn(i,e.sel.primIndex),n)}function vi(e,t,r,n){bi(e,Rn(t,r),n)}function mi(e,t,r){var n={ranges:t.ranges,update:function(t){var r=this;this.ranges=[];for(var n=0;n<t.length;n++)r.ranges[n]=new Ts(U(e,t[n].anchor),U(e,t[n].head))},origin:r&&r.origin};return Te(e,"beforeSelectionChange",e,n),e.cm&&Te(e.cm,"beforeSelectionChange",e.cm,n),n.ranges!=t.ranges?zn(n.ranges,n.ranges.length-1):t}function yi(e,t,r){var n=e.history.done,i=g(n);i&&i.ranges?(n[n.length-1]=t,wi(e,t,r)):bi(e,t,r)}function bi(e,t,r){wi(e,t,r),oi(e,e.sel,e.cm?e.cm.curOp.id:NaN,r)}function wi(e,t,r){(Oe(e,"beforeSelectionChange")||e.cm&&Oe(e.cm,"beforeSelectionChange"))&&(t=mi(e,t,r)),xi(e,Si(e,t,r&&r.bias||(P(t.primary().head,e.sel.primary().head)<0?-1:1),!0)),r&&!1===r.scroll||!e.cm||jr(e.cm)}function xi(e,t){t.equals(e.sel)||(e.sel=t,e.cm&&(e.cm.curOp.updateInput=e.cm.curOp.selectionChanged=!0,Ne(e.cm)),bt(e,"cursorActivity",e))}function Ci(e){xi(e,Si(e,e.sel,null,!1))}function Si(e,t,r,n){for(var i,o=0;o<t.ranges.length;o++){var l=t.ranges[o],s=t.ranges.length==e.sel.ranges.length&&e.sel.ranges[o],a=ki(e,l.anchor,s&&s.anchor,r,n),u=ki(e,l.head,s&&s.head,r,n);(i||a!=l.anchor||u!=l.head)&&(i||(i=t.ranges.slice(0,o)),i[o]=new Ts(a,u))}return i?zn(i,t.primIndex):t}function Li(e,t,r,n,i){var o=M(e,t.line);if(o.markedSpans)for(var l=0;l<o.markedSpans.length;++l){var s=o.markedSpans[l],a=s.marker;if((null==s.from||(a.inclusiveLeft?s.from<=t.ch:s.from<t.ch))&&(null==s.to||(a.inclusiveRight?s.to>=t.ch:s.to>t.ch))){if(i&&(Te(a,"beforeCursorEnter"),a.explicitlyCleared)){if(o.markedSpans){--l;continue}break}if(!a.atomic)continue;if(r){var u=a.find(n<0?1:-1),c=void 0;if((n<0?a.inclusiveRight:a.inclusiveLeft)&&(u=Ti(e,u,-n,u&&u.line==t.line?o:null)),u&&u.line==t.line&&(c=P(u,r))&&(n<0?c<0:c>0))return Li(e,u,t,n,i)}var f=a.find(n<0?-1:1);return(n<0?a.inclusiveLeft:a.inclusiveRight)&&(f=Ti(e,f,n,f.line==t.line?o:null)),f?Li(e,f,t,n,i):null}}return t}function ki(e,t,r,n,i){var o=n||1,l=Li(e,t,r,o,i)||!i&&Li(e,t,r,o,!0)||Li(e,t,r,-o,i)||!i&&Li(e,t,r,-o,!0);return l||(e.cantEdit=!0,E(e.first,0))}function Ti(e,t,r,n){return r<0&&0==t.ch?t.line>e.first?U(e,E(t.line-1)):null:r>0&&t.ch==(n||M(e,t.line)).text.length?t.line<e.first+e.size-1?E(t.line+1,0):null:new E(t.line,t.ch+r)}function Mi(e){e.setSelection(E(e.firstLine(),0),E(e.lastLine()),Gl)}function Ni(e,t,r){var n={canceled:!1,from:t.from,to:t.to,text:t.text,origin:t.origin,cancel:function(){return n.canceled=!0}};return r&&(n.update=function(t,r,i,o){t&&(n.from=U(e,t)),r&&(n.to=U(e,r)),i&&(n.text=i),void 0!==o&&(n.origin=o)}),Te(e,"beforeChange",e,n),e.cm&&Te(e.cm,"beforeChange",e.cm,n),n.canceled?null:{from:n.from,to:n.to,text:n.text,origin:n.origin}}function Oi(e,t,r){if(e.cm){if(!e.cm.curOp)return dn(e.cm,Oi)(e,t,r);if(e.cm.state.suppressEdits)return}if(!(Oe(e,"beforeChange")||e.cm&&Oe(e.cm,"beforeChange"))||(t=Ni(e,t,!0))){var n=Yl&&!r&&te(e,t.from,t.to);if(n)for(var i=n.length-1;i>=0;--i)Ai(e,{from:n[i].from,to:n[i].to,text:i?[""]:t.text,origin:t.origin});else Ai(e,t)}}function Ai(e,t){if(1!=t.text.length||""!=t.text[0]||0!=P(t.from,t.to)){var r=Un(e,t);ni(e,t,r,e.cm?e.cm.curOp.id:NaN),Hi(e,t,r,J(e,t));var n=[];$n(e,function(e,r){r||-1!=h(n,e.history)||(zi(e.history,t),n.push(e.history)),Hi(e,t,null,J(e,t))})}}function Wi(e,t,r){if(!e.cm||!e.cm.state.suppressEdits||r){for(var n,i=e.history,o=e.sel,l="undo"==t?i.done:i.undone,s="undo"==t?i.undone:i.done,a=0;a<l.length&&(n=l[a],r?!n.ranges||n.equals(e.sel):n.ranges);a++);if(a!=l.length){for(i.lastOrigin=i.lastSelOrigin=null;(n=l.pop()).ranges;){if(li(n,s),r&&!n.equals(e.sel))return void bi(e,n,{clearRedo:!1});o=n}var u=[];li(o,s),s.push({changes:u,generation:i.generation}),i.generation=n.generation||++i.maxGeneration;for(var c=Oe(e,"beforeChange")||e.cm&&Oe(e.cm,"beforeChange"),f=n.changes.length-1;f>=0;--f){var d=function(r){var i=n.changes[r];if(i.origin=t,c&&!Ni(e,i,!1))return l.length=0,{};u.push(ei(e,i));var o=r?Un(e,i):g(l);Hi(e,i,o,ci(e,i)),!r&&e.cm&&e.cm.scrollIntoView({from:i.from,to:Bn(i)});var s=[];$n(e,function(e,t){t||-1!=h(s,e.history)||(zi(e.history,i),s.push(e.history)),Hi(e,i,null,ci(e,i))})}(f);if(d)return d.v}}}}function Di(e,t){if(0!=t&&(e.first+=t,e.sel=new ks(v(e.sel.ranges,function(e){return new Ts(E(e.anchor.line+t,e.anchor.ch),E(e.head.line+t,e.head.ch))}),e.sel.primIndex),e.cm)){vn(e.cm,e.first,e.first-t,t);for(var r=e.cm.display,n=r.viewFrom;n<r.viewTo;n++)mn(e.cm,n,"gutter")}}function Hi(e,t,r,n){if(e.cm&&!e.cm.curOp)return dn(e.cm,Hi)(e,t,r,n);if(t.to.line<e.first)Di(e,t.text.length-1-(t.to.line-t.from.line));else if(!(t.from.line>e.lastLine())){if(t.from.line<e.first){var i=t.text.length-1-(e.first-t.from.line);Di(e,i),t={from:E(e.first,0),to:E(t.to.line+i,t.to.ch),text:[g(t.text)],origin:t.origin}}var o=e.lastLine();t.to.line>o&&(t={from:t.from,to:E(o,M(e,o).text.length),text:[t.text[0]],origin:t.origin}),t.removed=N(e,t.from,t.to),r||(r=Un(e,t)),e.cm?Fi(e.cm,t,n):_n(e,t,n),wi(e,r,Gl)}}function Fi(e,t,r){var n=e.doc,i=e.display,o=t.from,l=t.to,s=!1,a=o.line;e.options.lineWrapping||(a=W(fe(M(n,o.line))),n.iter(a,l.line+1,function(e){if(e==i.maxLine)return s=!0,!0})),n.sel.contains(t.from,t.to)>-1&&Ne(e),_n(n,t,r,xr(e)),e.options.lineWrapping||(n.iter(a,o.line+t.text.length,function(e){var t=be(e);t>i.maxLineLength&&(i.maxLine=e,i.maxLineLength=t,i.maxLineChanged=!0,s=!1)}),s&&(e.curOp.updateMaxLine=!0)),nt(n,o.line),Cn(e,400);var u=t.text.length-(l.line-o.line)-1;t.full?vn(e):o.line!=l.line||1!=t.text.length||Yn(e.doc,t)?vn(e,o.line,l.line+1,u):mn(e,o.line,"text");var c=Oe(e,"changes"),f=Oe(e,"change");if(f||c){var h={from:o,to:l,text:t.text,removed:t.removed,origin:t.origin};f&&bt(e,"change",e,h),c&&(e.curOp.changeObjs||(e.curOp.changeObjs=[])).push(h)}e.display.selForContextMenu=null}function Ei(e,t,r,n,i){if(n||(n=r),P(n,r)<0){var o;r=(o=[n,r])[0],n=o[1]}"string"==typeof t&&(t=e.splitLines(t)),Oi(e,{from:r,to:n,text:t,origin:i})}function Pi(e,t,r,n){r<e.line?e.line+=n:t<e.line&&(e.line=t,e.ch=0)}function Ii(e,t,r,n){for(var i=0;i<e.length;++i){var o=e[i],l=!0;if(o.ranges){o.copied||((o=e[i]=o.deepCopy()).copied=!0);for(var s=0;s<o.ranges.length;s++)Pi(o.ranges[s].anchor,t,r,n),Pi(o.ranges[s].head,t,r,n)}else{for(var a=0;a<o.changes.length;++a){var u=o.changes[a];if(r<u.from.line)u.from=E(u.from.line+n,u.from.ch),u.to=E(u.to.line+n,u.to.ch);else if(t<=u.to.line){l=!1;break}}l||(e.splice(0,i+1),i=0)}}}function zi(e,t){var r=t.from.line,n=t.to.line,i=t.text.length-(n-r)-1;Ii(e.done,r,n,i),Ii(e.undone,r,n,i)}function Ri(e,t,r,n){var i=t,o=t;return"number"==typeof t?o=M(e,G(e,t)):i=W(t),null==i?null:(n(o,i)&&e.cm&&mn(e.cm,i,r),o)}function Bi(e){var t=this;this.lines=e,this.parent=null;for(var r=0,n=0;n<e.length;++n)e[n].parent=t,r+=e[n].height;this.height=r}function Gi(e){var t=this;this.children=e;for(var r=0,n=0,i=0;i<e.length;++i){var o=e[i];r+=o.chunkSize(),n+=o.height,o.parent=t}this.size=r,this.height=n,this.parent=null}function Ui(e,t,r){ye(t)<(e.curOp&&e.curOp.scrollTop||e.doc.scrollTop)&&Kr(e,r)}function Vi(e,t,r,n){var i=new Ms(e,r,n),o=e.cm;return o&&i.noHScroll&&(o.display.alignWidgets=!0),Ri(e,t,"widget",function(t){var r=t.widgets||(t.widgets=[]);if(null==i.insertAt?r.push(i):r.splice(Math.min(r.length-1,Math.max(0,i.insertAt)),0,i),i.line=t,o&&!ve(e,t)){var n=ye(t)<e.scrollTop;A(t,t.height+Ht(i)),n&&Kr(o,i.height),o.curOp.forceUpdate=!0}return!0}),bt(o,"lineWidgetAdded",o,i,"number"==typeof t?t:W(t)),i}function Ki(e,t,r,n,o){if(n&&n.shared)return ji(e,t,r,n,o);if(e.cm&&!e.cm.curOp)return dn(e.cm,Ki)(e,t,r,n,o);var l=new Os(e,o),s=P(t,r);if(n&&c(n,l,!1),s>0||0==s&&!1!==l.clearWhenEmpty)return l;if(l.replacedWith&&(l.collapsed=!0,l.widgetNode=i("span",[l.replacedWith],"CodeMirror-widget"),n.handleMouseEvents||l.widgetNode.setAttribute("cm-ignore-events","true"),n.insertLeft&&(l.widgetNode.insertLeft=!0)),l.collapsed){if(ce(e,t.line,t,r,l)||t.line!=r.line&&ce(e,r.line,t,r,l))throw new Error("Inserting collapsed marker partially overlapping an existing one");X()}l.addToHistory&&ni(e,{from:t,to:r,origin:"markText"},e.sel,NaN);var a,u=t.line,f=e.cm;if(e.iter(u,r.line+1,function(e){f&&l.collapsed&&!f.options.lineWrapping&&fe(e)==f.display.maxLine&&(a=!0),l.collapsed&&u!=t.line&&A(e,0),q(e,new Y(l,u==t.line?t.ch:null,u==r.line?r.ch:null)),++u}),l.collapsed&&e.iter(t.line,r.line+1,function(t){ve(e,t)&&A(t,0)}),l.clearOnEnter&&Ql(l,"beforeCursorEnter",function(){return l.clear()}),l.readOnly&&(j(),(e.history.done.length||e.history.undone.length)&&e.clearHistory()),l.collapsed&&(l.id=++Ns,l.atomic=!0),f){if(a&&(f.curOp.updateMaxLine=!0),l.collapsed)vn(f,t.line,r.line+1);else if(l.className||l.title||l.startStyle||l.endStyle||l.css)for(var h=t.line;h<=r.line;h++)mn(f,h,"text");l.atomic&&Ci(f.doc),bt(f,"markerAdded",f,l)}return l}function ji(e,t,r,n,i){(n=c(n)).shared=!1;var o=[Ki(e,t,r,n,i)],l=o[0],s=n.widgetNode;return $n(e,function(e){s&&(n.widgetNode=s.cloneNode(!0)),o.push(Ki(e,U(e,t),U(e,r),n,i));for(var a=0;a<e.linked.length;++a)if(e.linked[a].isParent)return;l=g(o)}),new As(o,l)}function Xi(e){return e.findMarks(E(e.first,0),e.clipPos(E(e.lastLine())),function(e){return e.parent})}function Yi(e,t){for(var r=0;r<t.length;r++){var n=t[r],i=n.find(),o=e.clipPos(i.from),l=e.clipPos(i.to);if(P(o,l)){var s=Ki(e,o,l,n.primary,n.primary.type);n.markers.push(s),s.parent=n}}}function _i(e){for(var t=0;t<e.length;t++)!function(t){var r=e[t],n=[r.primary.doc];$n(r.primary.doc,function(e){return n.push(e)});for(var i=0;i<r.markers.length;i++){var o=r.markers[i];-1==h(n,o.doc)&&(o.parent=null,r.markers.splice(i--,1))}}(t)}function $i(e){var t=this;if(Qi(t),!Me(t,e)&&!Ft(t.display,e)){We(e),gl&&(Hs=+new Date);var r=Sr(t,e,!0),n=e.dataTransfer.files;if(r&&!t.isReadOnly())if(n&&n.length&&window.FileReader&&window.File)for(var i=n.length,o=Array(i),l=0,s=0;s<i;++s)!function(e,n){if(!t.options.allowDropFileTypes||-1!=h(t.options.allowDropFileTypes,e.type)){var s=new FileReader;s.onload=dn(t,function(){var e=s.result;if(/[\x00-\x08\x0e-\x1f]{2}/.test(e)&&(e=""),o[n]=e,++l==i){var a={from:r=U(t.doc,r),to:r,text:t.doc.splitLines(o.join(t.doc.lineSeparator())),origin:"paste"};Oi(t.doc,a),yi(t.doc,Rn(r,Bn(a)))}}),s.readAsText(e)}}(n[s],s);else{if(t.state.draggingText&&t.doc.sel.contains(r)>-1)return t.state.draggingText(e),void setTimeout(function(){return t.display.input.focus()},20);try{var a=e.dataTransfer.getData("Text");if(a){var u;if(t.state.draggingText&&!t.state.draggingText.copy&&(u=t.listSelections()),wi(t.doc,Rn(r,r)),u)for(var c=0;c<u.length;++c)Ei(t.doc,"",u[c].anchor,u[c].head,"drag");t.replaceSelection(a,"around","paste"),t.display.input.focus()}}catch(e){}}}}function qi(e,t){if(gl&&(!e.state.draggingText||+new Date-Hs<100))Fe(t);else if(!Me(e,t)&&!Ft(e.display,t)&&(t.dataTransfer.setData("Text",e.getSelection()),t.dataTransfer.effectAllowed="copyMove",t.dataTransfer.setDragImage&&!xl)){var r=n("img",null,null,"position: fixed; left: 0; top: 0;");r.src="data:image/gif;base64,R0lGODlhAQABAAAAACH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==",wl&&(r.width=r.height=1,e.display.wrapper.appendChild(r),r._top=r.offsetTop),t.dataTransfer.setDragImage(r,0,0),wl&&r.parentNode.removeChild(r)}}function Zi(e,t){var i=Sr(e,t);if(i){var o=document.createDocumentFragment();Mr(e,i,o),e.display.dragCursor||(e.display.dragCursor=n("div",null,"CodeMirror-cursors CodeMirror-dragcursors"),e.display.lineSpace.insertBefore(e.display.dragCursor,e.display.cursorDiv)),r(e.display.dragCursor,o)}}function Qi(e){e.display.dragCursor&&(e.display.lineSpace.removeChild(e.display.dragCursor),e.display.dragCursor=null)}function Ji(e){if(document.getElementsByClassName)for(var t=document.getElementsByClassName("CodeMirror"),r=0;r<t.length;r++){var n=t[r].CodeMirror;n&&e(n)}}function eo(){Fs||(to(),Fs=!0)}function to(){var e;Ql(window,"resize",function(){null==e&&(e=setTimeout(function(){e=null,Ji(ro)},100))}),Ql(window,"blur",function(){return Ji(Fr)})}function ro(e){var t=e.display;t.lastWrapHeight==t.wrapper.clientHeight&&t.lastWrapWidth==t.wrapper.clientWidth||(t.cachedCharWidth=t.cachedTextHeight=t.cachedPaddingH=null,t.scrollbarsClipped=!1,e.setSize())}function no(e){var t=e.split(/-(?!$)/);e=t[t.length-1];for(var r,n,i,o,l=0;l<t.length-1;l++){var s=t[l];if(/^(cmd|meta|m)$/i.test(s))o=!0;else if(/^a(lt)?$/i.test(s))r=!0;else if(/^(c|ctrl|control)$/i.test(s))n=!0;else{if(!/^s(hift)?$/i.test(s))throw new Error("Unrecognized modifier name: "+s);i=!0}}return r&&(e="Alt-"+e),n&&(e="Ctrl-"+e),o&&(e="Cmd-"+e),i&&(e="Shift-"+e),e}function io(e){var t={};for(var r in e)if(e.hasOwnProperty(r)){var n=e[r];if(/^(name|fallthrough|(de|at)tach)$/.test(r))continue;if("..."==n){delete e[r];continue}for(var i=v(r.split(" "),no),o=0;o<i.length;o++){var l=void 0,s=void 0;o==i.length-1?(s=i.join(" "),l=n):(s=i.slice(0,o+1).join(" "),l="...");var a=t[s];if(a){if(a!=l)throw new Error("Inconsistent bindings for "+s)}else t[s]=l}delete e[r]}for(var u in t)e[u]=t[u];return e}function oo(e,t,r,n){var i=(t=uo(t)).call?t.call(e,n):t[e];if(!1===i)return"nothing";if("..."===i)return"multi";if(null!=i&&r(i))return"handled";if(t.fallthrough){if("[object Array]"!=Object.prototype.toString.call(t.fallthrough))return oo(e,t.fallthrough,r,n);for(var o=0;o<t.fallthrough.length;o++){var l=oo(e,t.fallthrough[o],r,n);if(l)return l}}}function lo(e){var t="string"==typeof e?e:Es[e.keyCode];return"Ctrl"==t||"Alt"==t||"Shift"==t||"Mod"==t}function so(e,t,r){var n=e;return t.altKey&&"Alt"!=n&&(e="Alt-"+e),(Dl?t.metaKey:t.ctrlKey)&&"Ctrl"!=n&&(e="Ctrl-"+e),(Dl?t.ctrlKey:t.metaKey)&&"Cmd"!=n&&(e="Cmd-"+e),!r&&t.shiftKey&&"Shift"!=n&&(e="Shift-"+e),e}function ao(e,t){if(wl&&34==e.keyCode&&e.char)return!1;var r=Es[e.keyCode];return null!=r&&!e.altGraphKey&&so(r,e,t)}function uo(e){return"string"==typeof e?Rs[e]:e}function co(e,t){for(var r=e.doc.sel.ranges,n=[],i=0;i<r.length;i++){for(var o=t(r[i]);n.length&&P(o.from,g(n).to)<=0;){var l=n.pop();if(P(l.from,o.from)<0){o.from=l.from;break}}n.push(o)}hn(e,function(){for(var t=n.length-1;t>=0;t--)Ei(e.doc,"",n[t].from,n[t].to,"+delete");jr(e)})}function fo(e,t,r){var n=L(e.text,t+r,r);return n<0||n>e.text.length?null:n}function ho(e,t,r){var n=fo(e,t.ch,r);return null==n?null:new E(t.line,n,r<0?"after":"before")}function po(e,t,r,n,i){if(e){var o=Se(r,t.doc.direction);if(o){var l,s=i<0?g(o):o[0],a=i<0==(1==s.level)?"after":"before";if(s.level>0){var u=Xt(t,r);l=i<0?r.text.length-1:0;var c=Yt(t,u,l).top;l=k(function(e){return Yt(t,u,e).top==c},i<0==(1==s.level)?s.from:s.to-1,l),"before"==a&&(l=fo(r,l,1))}else l=i<0?s.to:s.from;return new E(n,l,a)}}return new E(n,i<0?r.text.length:0,i<0?"before":"after")}function go(e,t,r,n){var i=Se(t,e.doc.direction);if(!i)return ho(t,r,n);r.ch>=t.text.length?(r.ch=t.text.length,r.sticky="before"):r.ch<=0&&(r.ch=0,r.sticky="after");var o=Ce(i,r.ch,r.sticky),l=i[o];if("ltr"==e.doc.direction&&l.level%2==0&&(n>0?l.to>r.ch:l.from<r.ch))return ho(t,r,n);var s,a=function(e,r){return fo(t,e instanceof E?e.ch:e,r)},u=function(r){return e.options.lineWrapping?(s=s||Xt(e,t),hr(e,t,s,r)):{begin:0,end:t.text.length}},c=u("before"==r.sticky?a(r,-1):r.ch);if("rtl"==e.doc.direction||1==l.level){var f=1==l.level==n<0,h=a(r,f?1:-1);if(null!=h&&(f?h<=l.to&&h<=c.end:h>=l.from&&h>=c.begin)){var d=f?"before":"after";return new E(r.line,h,d)}}var p=function(e,t,n){for(var o=function(e,t){return t?new E(r.line,a(e,1),"before"):new E(r.line,e,"after")};e>=0&&e<i.length;e+=t){var l=i[e],s=t>0==(1!=l.level),u=s?n.begin:a(n.end,-1);if(l.from<=u&&u<l.to)return o(u,s);if(u=s?l.from:a(l.to,-1),n.begin<=u&&u<n.end)return o(u,s)}},g=p(o+n,n,c);if(g)return g;var v=n>0?c.end:a(c.begin,-1);return null==v||n>0&&v==t.text.length||!(g=p(n>0?0:i.length-1,n,u(v)))?null:g}function vo(e,t){var r=M(e.doc,t),n=fe(r);return n!=r&&(t=W(n)),po(!0,e,n,t,1)}function mo(e,t){var r=M(e.doc,t),n=he(r);return n!=r&&(t=W(n)),po(!0,e,r,t,-1)}function yo(e,t){var r=vo(e,t.line),n=M(e.doc,r.line),i=Se(n,e.doc.direction);if(!i||0==i[0].level){var o=Math.max(0,n.text.search(/\S/)),l=t.line==r.line&&t.ch<=o&&t.ch;return E(r.line,l?0:o,r.sticky)}return r}function bo(e,t,r){if("string"==typeof t&&!(t=Bs[t]))return!1;e.display.input.ensurePolled();var n=e.display.shift,i=!1;try{e.isReadOnly()&&(e.state.suppressEdits=!0),r&&(e.display.shift=!1),i=t(e)!=Bl}finally{e.display.shift=n,e.state.suppressEdits=!1}return i}function wo(e,t,r){for(var n=0;n<e.state.keyMaps.length;n++){var i=oo(t,e.state.keyMaps[n],r,e);if(i)return i}return e.options.extraKeys&&oo(t,e.options.extraKeys,r,e)||oo(t,e.options.keyMap,r,e)}function xo(e,t,r,n){var i=e.state.keySeq;if(i){if(lo(t))return"handled";Gs.set(50,function(){e.state.keySeq==i&&(e.state.keySeq=null,e.display.input.reset())}),t=i+" "+t}var o=wo(e,t,n);return"multi"==o&&(e.state.keySeq=t),"handled"==o&&bt(e,"keyHandled",e,t,r),"handled"!=o&&"multi"!=o||(We(r),Ar(e)),i&&!o&&/\'$/.test(t)?(We(r),!0):!!o}function Co(e,t){var r=ao(t,!0);return!!r&&(t.shiftKey&&!e.state.keySeq?xo(e,"Shift-"+r,t,function(t){return bo(e,t,!0)})||xo(e,r,t,function(t){if("string"==typeof t?/^go[A-Z]/.test(t):t.motion)return bo(e,t)}):xo(e,r,t,function(t){return bo(e,t)}))}function So(e,t,r){return xo(e,"'"+r+"'",t,function(t){return bo(e,t,!0)})}function Lo(e){var t=this;if(t.curOp.focus=l(),!Me(t,e)){gl&&vl<11&&27==e.keyCode&&(e.returnValue=!1);var r=e.keyCode;t.display.shift=16==r||e.shiftKey;var n=Co(t,e);wl&&(Us=n?r:null,!n&&88==r&&!rs&&(Ml?e.metaKey:e.ctrlKey)&&t.replaceSelection("",null,"cut")),18!=r||/\bCodeMirror-crosshair\b/.test(t.display.lineDiv.className)||ko(t)}}function ko(e){function t(e){18!=e.keyCode&&e.altKey||(Fl(r,"CodeMirror-crosshair"),ke(document,"keyup",t),ke(document,"mouseover",t))}var r=e.display.lineDiv;s(r,"CodeMirror-crosshair"),Ql(document,"keyup",t),Ql(document,"mouseover",t)}function To(e){16==e.keyCode&&(this.doc.sel.shift=!1),Me(this,e)}function Mo(e){var t=this;if(!(Ft(t.display,e)||Me(t,e)||e.ctrlKey&&!e.altKey||Ml&&e.metaKey)){var r=e.keyCode,n=e.charCode;if(wl&&r==Us)return Us=null,void We(e);if(!wl||e.which&&!(e.which<10)||!Co(t,e)){var i=String.fromCharCode(null==n?r:n);"\b"!=i&&(So(t,e,i)||t.display.input.onKeyPress(e))}}}function No(e,t){var r=+new Date;return js&&js.compare(r,e,t)?(Ks=js=null,"triple"):Ks&&Ks.compare(r,e,t)?(js=new Vs(r,e,t),Ks=null,"double"):(Ks=new Vs(r,e,t),js=null,"single")}function Oo(e){var t=this,r=t.display;if(!(Me(t,e)||r.activeTouch&&r.input.supportsTouch()))if(r.input.ensurePolled(),r.shift=e.shiftKey,Ft(r,e))ml||(r.scroller.draggable=!1,setTimeout(function(){return r.scroller.draggable=!0},100));else if(!zo(t,e)){var n=Sr(t,e),i=Pe(e),o=n?No(n,i):"single";window.focus(),1==i&&t.state.selectingText&&t.state.selectingText(e),n&&Ao(t,i,n,o,e)||(1==i?n?Do(t,n,o,e):Ee(e)==r.scroller&&We(e):2==i?(n&&di(t.doc,n),setTimeout(function(){return r.input.focus()},20)):3==i&&(Hl?Ro(t,e):Dr(t)))}}function Ao(e,t,r,n,i){var o="Click";return"double"==n?o="Double"+o:"triple"==n&&(o="Triple"+o),o=(1==t?"Left":2==t?"Middle":"Right")+o,xo(e,so(o,i),i,function(t){if("string"==typeof t&&(t=Bs[t]),!t)return!1;var n=!1;try{e.isReadOnly()&&(e.state.suppressEdits=!0),n=t(e,r)!=Bl}finally{e.state.suppressEdits=!1}return n})}function Wo(e,t,r){var n=e.getOption("configureMouse"),i=n?n(e,t,r):{};if(null==i.unit){var o=Nl?r.shiftKey&&r.metaKey:r.altKey;i.unit=o?"rectangle":"single"==t?"char":"double"==t?"word":"line"}return(null==i.extend||e.doc.extend)&&(i.extend=e.doc.extend||r.shiftKey),null==i.addNew&&(i.addNew=Ml?r.metaKey:r.ctrlKey),null==i.moveOnDrag&&(i.moveOnDrag=!(Ml?r.altKey:r.ctrlKey)),i}function Do(e,t,r,n){gl?setTimeout(u(Wr,e),0):e.curOp.focus=l();var i,o=Wo(e,r,n),s=e.doc.sel;e.options.dragDrop&&Jl&&!e.isReadOnly()&&"single"==r&&(i=s.contains(t))>-1&&(P((i=s.ranges[i]).from(),t)<0||t.xRel>0)&&(P(i.to(),t)>0||t.xRel<0)?Ho(e,n,t,o):Eo(e,n,t,o)}function Ho(e,t,r,n){var i=e.display,o=!1,l=dn(e,function(t){ml&&(i.scroller.draggable=!1),e.state.draggingText=!1,ke(document,"mouseup",l),ke(document,"mousemove",s),ke(i.scroller,"dragstart",a),ke(i.scroller,"drop",l),o||(We(t),n.addNew||di(e.doc,r,null,null,n.extend),ml||gl&&9==vl?setTimeout(function(){document.body.focus(),i.input.focus()},20):i.input.focus())}),s=function(e){o=o||Math.abs(t.clientX-e.clientX)+Math.abs(t.clientY-e.clientY)>=10},a=function(){return o=!0};ml&&(i.scroller.draggable=!0),e.state.draggingText=l,l.copy=!n.moveOnDrag,i.scroller.dragDrop&&i.scroller.dragDrop(),Ql(document,"mouseup",l),Ql(document,"mousemove",s),Ql(i.scroller,"dragstart",a),Ql(i.scroller,"drop",l),Dr(e),setTimeout(function(){return i.input.focus()},20)}function Fo(e,t,r){if("char"==r)return new Ts(t,t);if("word"==r)return e.findWordAt(t);if("line"==r)return new Ts(E(t.line,0),U(e.doc,E(t.line+1,0)));var n=r(e,t);return new Ts(n.from,n.to)}function Eo(e,t,r,n){function i(t){if(0!=P(m,t))if(m=t,"rectangle"==n.unit){for(var i=[],o=e.options.tabSize,l=f(M(u,r.line).text,r.ch,o),s=f(M(u,t.line).text,t.ch,o),a=Math.min(l,s),g=Math.max(l,s),v=Math.min(r.line,t.line),y=Math.min(e.lastLine(),Math.max(r.line,t.line));v<=y;v++){var b=M(u,v).text,w=d(b,a,o);a==g?i.push(new Ts(E(v,w),E(v,w))):b.length>w&&i.push(new Ts(E(v,w),E(v,d(b,g,o))))}i.length||i.push(new Ts(r,r)),bi(u,zn(p.ranges.slice(0,h).concat(i),h),{origin:"*mouse",scroll:!1}),e.scrollIntoView(t)}else{var x,C=c,S=Fo(e,t,n.unit),L=C.anchor;P(S.anchor,L)>0?(x=S.head,L=B(C.from(),S.anchor)):(x=S.anchor,L=R(C.to(),S.head));var k=p.ranges.slice(0);k[h]=Po(e,new Ts(U(u,L),x)),bi(u,zn(k,h),Ul)}}function o(t){var r=++b,s=Sr(e,t,!0,"rectangle"==n.unit);if(s)if(0!=P(s,m)){e.curOp.focus=l(),i(s);var c=Ir(a,u);(s.line>=c.to||s.line<c.from)&&setTimeout(dn(e,function(){b==r&&o(t)}),150)}else{var f=t.clientY<y.top?-20:t.clientY>y.bottom?20:0;f&&setTimeout(dn(e,function(){b==r&&(a.scroller.scrollTop+=f,o(t))}),50)}}function s(t){e.state.selectingText=!1,b=1/0,We(t),a.input.focus(),ke(document,"mousemove",w),ke(document,"mouseup",x),u.history.lastSelOrigin=null}var a=e.display,u=e.doc;We(t);var c,h,p=u.sel,g=p.ranges;if(n.addNew&&!n.extend?(h=u.sel.contains(r),c=h>-1?g[h]:new Ts(r,r)):(c=u.sel.primary(),h=u.sel.primIndex),"rectangle"==n.unit)n.addNew||(c=new Ts(r,r)),r=Sr(e,t,!0,!0),h=-1;else{var v=Fo(e,r,n.unit);c=n.extend?hi(c,v.anchor,v.head,n.extend):v}n.addNew?-1==h?(h=g.length,bi(u,zn(g.concat([c]),h),{scroll:!1,origin:"*mouse"})):g.length>1&&g[h].empty()&&"char"==n.unit&&!n.extend?(bi(u,zn(g.slice(0,h).concat(g.slice(h+1)),0),{scroll:!1,origin:"*mouse"}),p=u.sel):gi(u,h,c,Ul):(h=0,bi(u,new ks([c],0),Ul),p=u.sel);var m=r,y=a.wrapper.getBoundingClientRect(),b=0,w=dn(e,function(e){Pe(e)?o(e):s(e)}),x=dn(e,s);e.state.selectingText=x,Ql(document,"mousemove",w),Ql(document,"mouseup",x)}function Po(e,t){var r=t.anchor,n=t.head,i=M(e.doc,r.line);if(0==P(r,n)&&r.sticky==n.sticky)return t;var o=Se(i);if(!o)return t;var l=Ce(o,r.ch,r.sticky),s=o[l];if(s.from!=r.ch&&s.to!=r.ch)return t;var a=l+(s.from==r.ch==(1!=s.level)?0:1);if(0==a||a==o.length)return t;var u;if(n.line!=r.line)u=(n.line-r.line)*("ltr"==e.doc.direction?1:-1)>0;else{var c=Ce(o,n.ch,n.sticky),f=c-l||(n.ch-r.ch)*(1==s.level?-1:1);u=c==a-1||c==a?f<0:f>0}var h=o[a+(u?-1:0)],d=u==(1==h.level),p=d?h.from:h.to,g=d?"after":"before";return r.ch==p&&r.sticky==g?t:new Ts(new E(r.line,p,g),n)}function Io(e,t,r,n){var i,o;if(t.touches)i=t.touches[0].clientX,o=t.touches[0].clientY;else try{i=t.clientX,o=t.clientY}catch(t){return!1}if(i>=Math.floor(e.display.gutters.getBoundingClientRect().right))return!1;n&&We(t);var l=e.display,s=l.lineDiv.getBoundingClientRect();if(o>s.bottom||!Oe(e,r))return He(t);o-=s.top-l.viewOffset;for(var a=0;a<e.options.gutters.length;++a){var u=l.gutters.childNodes[a];if(u&&u.getBoundingClientRect().right>=i)return Te(e,r,e,D(e.doc,o),e.options.gutters[a],t),He(t)}}function zo(e,t){return Io(e,t,"gutterClick",!0)}function Ro(e,t){Ft(e.display,t)||Bo(e,t)||Me(e,t,"contextmenu")||e.display.input.onContextMenu(t)}function Bo(e,t){return!!Oe(e,"gutterContextMenu")&&Io(e,t,"gutterContextMenu",!1)}function Go(e){e.display.wrapper.className=e.display.wrapper.className.replace(/\s*cm-s-\S+/g,"")+e.options.theme.replace(/(^|\s)\s*/g," cm-s-"),er(e)}function Uo(e){Hn(e),vn(e),zr(e)}function Vo(e,t,r){if(!t!=!(r&&r!=Xs)){var n=e.display.dragFunctions,i=t?Ql:ke;i(e.display.scroller,"dragstart",n.start),i(e.display.scroller,"dragenter",n.enter),i(e.display.scroller,"dragover",n.over),i(e.display.scroller,"dragleave",n.leave),i(e.display.scroller,"drop",n.drop)}}function Ko(e){e.options.lineWrapping?(s(e.display.wrapper,"CodeMirror-wrap"),e.display.sizer.style.minWidth="",e.display.sizerWidth=null):(Fl(e.display.wrapper,"CodeMirror-wrap"),we(e)),Cr(e),vn(e),er(e),setTimeout(function(){return en(e)},100)}function jo(e,t){var r=this;if(!(this instanceof jo))return new jo(e,t);this.options=t=t?c(t):{},c(Ys,t,!1),Fn(t);var n=t.value;"string"==typeof n&&(n=new Ds(n,t.mode,null,t.lineSeparator,t.direction)),this.doc=n;var i=new jo.inputStyles[t.inputStyle](this),o=this.display=new T(e,n,i);o.wrapper.CodeMirror=this,Hn(this),Go(this),t.lineWrapping&&(this.display.wrapper.className+=" CodeMirror-wrap"),rn(this),this.state={keyMaps:[],overlays:[],modeGen:0,overwrite:!1,delayingBlurEvent:!1,focused:!1,suppressEdits:!1,pasteIncoming:!1,cutIncoming:!1,selectingText:!1,draggingText:!1,highlight:new Pl,keySeq:null,specialChars:null},t.autofocus&&!Tl&&o.input.focus(),gl&&vl<11&&setTimeout(function(){return r.display.input.reset(!0)},20),Xo(this),eo(),nn(this),this.curOp.forceUpdate=!0,qn(this,n),t.autofocus&&!Tl||this.hasFocus()?setTimeout(u(Hr,this),20):Fr(this);for(var l in _s)_s.hasOwnProperty(l)&&_s[l](r,t[l],Xs);Rr(this),t.finishInit&&t.finishInit(this);for(var s=0;s<$s.length;++s)$s[s](r);on(this),ml&&t.lineWrapping&&"optimizelegibility"==getComputedStyle(o.lineDiv).textRendering&&(o.lineDiv.style.textRendering="auto")}function Xo(e){function t(){i.activeTouch&&(o=setTimeout(function(){return i.activeTouch=null},1e3),(l=i.activeTouch).end=+new Date)}function r(e){if(1!=e.touches.length)return!1;var t=e.touches[0];return t.radiusX<=1&&t.radiusY<=1}function n(e,t){if(null==t.left)return!0;var r=t.left-e.left,n=t.top-e.top;return r*r+n*n>400}var i=e.display;Ql(i.scroller,"mousedown",dn(e,Oo)),gl&&vl<11?Ql(i.scroller,"dblclick",dn(e,function(t){if(!Me(e,t)){var r=Sr(e,t);if(r&&!zo(e,t)&&!Ft(e.display,t)){We(t);var n=e.findWordAt(r);di(e.doc,n.anchor,n.head)}}})):Ql(i.scroller,"dblclick",function(t){return Me(e,t)||We(t)}),Hl||Ql(i.scroller,"contextmenu",function(t){return Ro(e,t)});var o,l={end:0};Ql(i.scroller,"touchstart",function(t){if(!Me(e,t)&&!r(t)&&!zo(e,t)){i.input.ensurePolled(),clearTimeout(o);var n=+new Date;i.activeTouch={start:n,moved:!1,prev:n-l.end<=300?l:null},1==t.touches.length&&(i.activeTouch.left=t.touches[0].pageX,i.activeTouch.top=t.touches[0].pageY)}}),Ql(i.scroller,"touchmove",function(){i.activeTouch&&(i.activeTouch.moved=!0)}),Ql(i.scroller,"touchend",function(r){var o=i.activeTouch;if(o&&!Ft(i,r)&&null!=o.left&&!o.moved&&new Date-o.start<300){var l,s=e.coordsChar(i.activeTouch,"page");l=!o.prev||n(o,o.prev)?new Ts(s,s):!o.prev.prev||n(o,o.prev.prev)?e.findWordAt(s):new Ts(E(s.line,0),U(e.doc,E(s.line+1,0))),e.setSelection(l.anchor,l.head),e.focus(),We(r)}t()}),Ql(i.scroller,"touchcancel",t),Ql(i.scroller,"scroll",function(){i.scroller.clientHeight&&(qr(e,i.scroller.scrollTop),Qr(e,i.scroller.scrollLeft,!0),Te(e,"scroll",e))}),Ql(i.scroller,"mousewheel",function(t){return In(e,t)}),Ql(i.scroller,"DOMMouseScroll",function(t){return In(e,t)}),Ql(i.wrapper,"scroll",function(){return i.wrapper.scrollTop=i.wrapper.scrollLeft=0}),i.dragFunctions={enter:function(t){Me(e,t)||Fe(t)},over:function(t){Me(e,t)||(Zi(e,t),Fe(t))},start:function(t){return qi(e,t)},drop:dn(e,$i),leave:function(t){Me(e,t)||Qi(e)}};var s=i.input.getField();Ql(s,"keyup",function(t){return To.call(e,t)}),Ql(s,"keydown",dn(e,Lo)),Ql(s,"keypress",dn(e,Mo)),Ql(s,"focus",function(t){return Hr(e,t)}),Ql(s,"blur",function(t){return Fr(e,t)})}function Yo(e,t,r,n){var i,o=e.doc;null==r&&(r="add"),"smart"==r&&(o.mode.indent?i=$e(e,t).state:r="prev");var l=e.options.tabSize,s=M(o,t),a=f(s.text,null,l);s.stateAfter&&(s.stateAfter=null);var u,c=s.text.match(/^\s*/)[0];if(n||/\S/.test(s.text)){if("smart"==r&&((u=o.mode.indent(i,s.text.slice(c.length),s.text))==Bl||u>150)){if(!n)return;r="prev"}}else u=0,r="not";"prev"==r?u=t>o.first?f(M(o,t-1).text,null,l):0:"add"==r?u=a+e.options.indentUnit:"subtract"==r?u=a-e.options.indentUnit:"number"==typeof r&&(u=a+r),u=Math.max(0,u);var h="",d=0;if(e.options.indentWithTabs)for(var g=Math.floor(u/l);g;--g)d+=l,h+="\t";if(d<u&&(h+=p(u-d)),h!=c)return Ei(o,h,E(t,0),E(t,c.length),"+input"),s.stateAfter=null,!0;for(var v=0;v<o.sel.ranges.length;v++){var m=o.sel.ranges[v];if(m.head.line==t&&m.head.ch<c.length){var y=E(t,c.length);gi(o,v,new Ts(y,y));break}}}function _o(e){qs=e}function $o(e,t,r,n,i){var o=e.doc;e.display.shift=!1,n||(n=o.sel);var l=e.state.pasteIncoming||"paste"==i,s=es(t),a=null;if(l&&n.ranges.length>1)if(qs&&qs.text.join("\n")==t){if(n.ranges.length%qs.text.length==0){a=[];for(var u=0;u<qs.text.length;u++)a.push(o.splitLines(qs.text[u]))}}else s.length==n.ranges.length&&e.options.pasteLinesPerSelection&&(a=v(s,function(e){return[e]}));for(var c,f=n.ranges.length-1;f>=0;f--){var h=n.ranges[f],d=h.from(),p=h.to();h.empty()&&(r&&r>0?d=E(d.line,d.ch-r):e.state.overwrite&&!l?p=E(p.line,Math.min(M(o,p.line).text.length,p.ch+g(s).length)):qs&&qs.lineWise&&qs.text.join("\n")==t&&(d=p=E(d.line,0))),c=e.curOp.updateInput;var m={from:d,to:p,text:a?a[f%a.length]:s,origin:i||(l?"paste":e.state.cutIncoming?"cut":"+input")};Oi(e.doc,m),bt(e,"inputRead",e,m)}t&&!l&&Zo(e,t),jr(e),e.curOp.updateInput=c,e.curOp.typing=!0,e.state.pasteIncoming=e.state.cutIncoming=!1}function qo(e,t){var r=e.clipboardData&&e.clipboardData.getData("Text");if(r)return e.preventDefault(),t.isReadOnly()||t.options.disableInput||hn(t,function(){return $o(t,r,0,null,"paste")}),!0}function Zo(e,t){if(e.options.electricChars&&e.options.smartIndent)for(var r=e.doc.sel,n=r.ranges.length-1;n>=0;n--){var i=r.ranges[n];if(!(i.head.ch>100||n&&r.ranges[n-1].head.line==i.head.line)){var o=e.getModeAt(i.head),l=!1;if(o.electricChars){for(var s=0;s<o.electricChars.length;s++)if(t.indexOf(o.electricChars.charAt(s))>-1){l=Yo(e,i.head.line,"smart");break}}else o.electricInput&&o.electricInput.test(M(e.doc,i.head.line).text.slice(0,i.head.ch))&&(l=Yo(e,i.head.line,"smart"));l&&bt(e,"electricInput",e,i.head.line)}}}function Qo(e){for(var t=[],r=[],n=0;n<e.doc.sel.ranges.length;n++){var i=e.doc.sel.ranges[n].head.line,o={anchor:E(i,0),head:E(i+1,0)};r.push(o),t.push(e.getRange(o.anchor,o.head))}return{text:t,ranges:r}}function Jo(e,t){e.setAttribute("autocorrect","off"),e.setAttribute("autocapitalize","off"),e.setAttribute("spellcheck",!!t)}function el(){var e=n("textarea",null,null,"position: absolute; bottom: -1em; padding: 0; width: 1px; height: 1em; outline: none"),t=n("div",[e],null,"overflow: hidden; position: relative; width: 3px; height: 0px;");return ml?e.style.width="1000px":e.setAttribute("wrap","off"),Ll&&(e.style.border="1px solid black"),Jo(e),t}function tl(e,t,r,n,i){function o(){var n=t.line+r;return!(n<e.first||n>=e.first+e.size)&&(t=new E(n,t.ch,t.sticky),u=M(e,n))}function l(n){var l;if(null==(l=i?go(e.cm,u,t,r):ho(u,t,r))){if(n||!o())return!1;t=po(i,e.cm,u,t.line,r)}else t=l;return!0}var s=t,a=r,u=M(e,t.line);if("char"==n)l();else if("column"==n)l(!0);else if("word"==n||"group"==n)for(var c=null,f="group"==n,h=e.cm&&e.cm.getHelper(t,"wordChars"),d=!0;!(r<0)||l(!d);d=!1){var p=u.text.charAt(t.ch)||"\n",g=x(p,h)?"w":f&&"\n"==p?"n":!f||/\s/.test(p)?null:"p";if(!f||d||g||(g="s"),c&&c!=g){r<0&&(r=1,l(),t.sticky="after");break}if(g&&(c=g),r>0&&!l(!d))break}var v=ki(e,t,s,a,!0);return I(s,v)&&(v.hitSide=!0),v}function rl(e,t,r,n){var i,o=e.doc,l=t.left;if("page"==n){var s=Math.min(e.display.wrapper.clientHeight,window.innerHeight||document.documentElement.clientHeight),a=Math.max(s-.5*mr(e.display),3);i=(r>0?t.bottom:t.top)+r*a}else"line"==n&&(i=r>0?t.bottom+3:t.top-3);for(var u;(u=cr(e,l,i)).outside;){if(r<0?i<=0:i>=o.height){u.hitSide=!0;break}i+=5*r}return u}function nl(e,t){var r=jt(e,t.line);if(!r||r.hidden)return null;var n=M(e.doc,t.line),i=Ut(r,n,t.line),o=Se(n,e.doc.direction),l="left";o&&(l=Ce(o,t.ch)%2?"right":"left");var s=_t(i.map,t.ch,l);return s.offset="right"==s.collapse?s.end:s.start,s}function il(e){for(var t=e;t;t=t.parentNode)if(/CodeMirror-gutter-wrapper/.test(t.className))return!0;return!1}function ol(e,t){return t&&(e.bad=!0),e}function ll(e,t,r,n,i){function o(e){return function(t){return t.id==e}}function l(){c&&(u+=f,c=!1)}function s(e){e&&(l(),u+=e)}function a(t){if(1==t.nodeType){var r=t.getAttribute("cm-text");if(null!=r)return void s(r||t.textContent.replace(/\u200b/g,""));var u,h=t.getAttribute("cm-marker");if(h){var d=e.findMarks(E(n,0),E(i+1,0),o(+h));return void(d.length&&(u=d[0].find(0))&&s(N(e.doc,u.from,u.to).join(f)))}if("false"==t.getAttribute("contenteditable"))return;var p=/^(pre|div|p)$/i.test(t.nodeName);p&&l();for(var g=0;g<t.childNodes.length;g++)a(t.childNodes[g]);p&&(c=!0)}else 3==t.nodeType&&s(t.nodeValue)}for(var u="",c=!1,f=e.doc.lineSeparator();a(t),t!=r;)t=t.nextSibling;return u}function sl(e,t,r){var n;if(t==e.display.lineDiv){if(!(n=e.display.lineDiv.childNodes[r]))return ol(e.clipPos(E(e.display.viewTo-1)),!0);t=null,r=0}else for(n=t;;n=n.parentNode){if(!n||n==e.display.lineDiv)return null;if(n.parentNode&&n.parentNode==e.display.lineDiv)break}for(var i=0;i<e.display.view.length;i++){var o=e.display.view[i];if(o.node==n)return al(o,t,r)}}function al(e,t,r){function n(t,r,n){for(var i=-1;i<(f?f.length:0);i++)for(var o=i<0?c.map:f[i],l=0;l<o.length;l+=3){var s=o[l+2];if(s==t||s==r){var a=W(i<0?e.line:e.rest[i]),u=o[l]+n;return(n<0||s!=t)&&(u=o[l+(n?1:0)]),E(a,u)}}}var i=e.text.firstChild,l=!1;if(!t||!o(i,t))return ol(E(W(e.line),0),!0);if(t==i&&(l=!0,t=i.childNodes[r],r=0,!t)){var s=e.rest?g(e.rest):e.line;return ol(E(W(s),s.text.length),l)}var a=3==t.nodeType?t:null,u=t;for(a||1!=t.childNodes.length||3!=t.firstChild.nodeType||(a=t.firstChild,r&&(r=a.nodeValue.length));u.parentNode!=i;)u=u.parentNode;var c=e.measure,f=c.maps,h=n(a,u,r);if(h)return ol(h,l);for(var d=u.nextSibling,p=a?a.nodeValue.length-r:0;d;d=d.nextSibling){if(h=n(d,d.firstChild,0))return ol(E(h.line,h.ch-p),l);p+=d.textContent.length}for(var v=u.previousSibling,m=r;v;v=v.previousSibling){if(h=n(v,v.firstChild,-1))return ol(E(h.line,h.ch+m),l);m+=v.textContent.length}}var ul=navigator.userAgent,cl=navigator.platform,fl=/gecko\/\d/i.test(ul),hl=/MSIE \d/.test(ul),dl=/Trident\/(?:[7-9]|\d{2,})\..*rv:(\d+)/.exec(ul),pl=/Edge\/(\d+)/.exec(ul),gl=hl||dl||pl,vl=gl&&(hl?document.documentMode||6:+(pl||dl)[1]),ml=!pl&&/WebKit\//.test(ul),yl=ml&&/Qt\/\d+\.\d+/.test(ul),bl=!pl&&/Chrome\//.test(ul),wl=/Opera\//.test(ul),xl=/Apple Computer/.test(navigator.vendor),Cl=/Mac OS X 1\d\D([8-9]|\d\d)\D/.test(ul),Sl=/PhantomJS/.test(ul),Ll=!pl&&/AppleWebKit/.test(ul)&&/Mobile\/\w+/.test(ul),kl=/Android/.test(ul),Tl=Ll||kl||/webOS|BlackBerry|Opera Mini|Opera Mobi|IEMobile/i.test(ul),Ml=Ll||/Mac/.test(cl),Nl=/\bCrOS\b/.test(ul),Ol=/win/i.test(cl),Al=wl&&ul.match(/Version\/(\d*\.\d*)/);Al&&(Al=Number(Al[1])),Al&&Al>=15&&(wl=!1,ml=!0);var Wl,Dl=Ml&&(yl||wl&&(null==Al||Al<12.11)),Hl=fl||gl&&vl>=9,Fl=function(t,r){var n=t.className,i=e(r).exec(n);if(i){var o=n.slice(i.index+i[0].length);t.className=n.slice(0,i.index)+(o?i[1]+o:"")}};Wl=document.createRange?function(e,t,r,n){var i=document.createRange();return i.setEnd(n||e,r),i.setStart(e,t),i}:function(e,t,r){var n=document.body.createTextRange();try{n.moveToElementText(e.parentNode)}catch(e){return n}return n.collapse(!0),n.moveEnd("character",r),n.moveStart("character",t),n};var El=function(e){e.select()};Ll?El=function(e){e.selectionStart=0,e.selectionEnd=e.value.length}:gl&&(El=function(e){try{e.select()}catch(e){}});var Pl=function(){this.id=null};Pl.prototype.set=function(e,t){clearTimeout(this.id),this.id=setTimeout(t,e)};var Il,zl,Rl=30,Bl={toString:function(){return"CodeMirror.Pass"}},Gl={scroll:!1},Ul={origin:"*mouse"},Vl={origin:"+move"},Kl=[""],jl=/[\u00df\u0587\u0590-\u05f4\u0600-\u06ff\u3040-\u309f\u30a0-\u30ff\u3400-\u4db5\u4e00-\u9fcc\uac00-\ud7af]/,Xl=/[\u0300-\u036f\u0483-\u0489\u0591-\u05bd\u05bf\u05c1\u05c2\u05c4\u05c5\u05c7\u0610-\u061a\u064b-\u065e\u0670\u06d6-\u06dc\u06de-\u06e4\u06e7\u06e8\u06ea-\u06ed\u0711\u0730-\u074a\u07a6-\u07b0\u07eb-\u07f3\u0816-\u0819\u081b-\u0823\u0825-\u0827\u0829-\u082d\u0900-\u0902\u093c\u0941-\u0948\u094d\u0951-\u0955\u0962\u0963\u0981\u09bc\u09be\u09c1-\u09c4\u09cd\u09d7\u09e2\u09e3\u0a01\u0a02\u0a3c\u0a41\u0a42\u0a47\u0a48\u0a4b-\u0a4d\u0a51\u0a70\u0a71\u0a75\u0a81\u0a82\u0abc\u0ac1-\u0ac5\u0ac7\u0ac8\u0acd\u0ae2\u0ae3\u0b01\u0b3c\u0b3e\u0b3f\u0b41-\u0b44\u0b4d\u0b56\u0b57\u0b62\u0b63\u0b82\u0bbe\u0bc0\u0bcd\u0bd7\u0c3e-\u0c40\u0c46-\u0c48\u0c4a-\u0c4d\u0c55\u0c56\u0c62\u0c63\u0cbc\u0cbf\u0cc2\u0cc6\u0ccc\u0ccd\u0cd5\u0cd6\u0ce2\u0ce3\u0d3e\u0d41-\u0d44\u0d4d\u0d57\u0d62\u0d63\u0dca\u0dcf\u0dd2-\u0dd4\u0dd6\u0ddf\u0e31\u0e34-\u0e3a\u0e47-\u0e4e\u0eb1\u0eb4-\u0eb9\u0ebb\u0ebc\u0ec8-\u0ecd\u0f18\u0f19\u0f35\u0f37\u0f39\u0f71-\u0f7e\u0f80-\u0f84\u0f86\u0f87\u0f90-\u0f97\u0f99-\u0fbc\u0fc6\u102d-\u1030\u1032-\u1037\u1039\u103a\u103d\u103e\u1058\u1059\u105e-\u1060\u1071-\u1074\u1082\u1085\u1086\u108d\u109d\u135f\u1712-\u1714\u1732-\u1734\u1752\u1753\u1772\u1773\u17b7-\u17bd\u17c6\u17c9-\u17d3\u17dd\u180b-\u180d\u18a9\u1920-\u1922\u1927\u1928\u1932\u1939-\u193b\u1a17\u1a18\u1a56\u1a58-\u1a5e\u1a60\u1a62\u1a65-\u1a6c\u1a73-\u1a7c\u1a7f\u1b00-\u1b03\u1b34\u1b36-\u1b3a\u1b3c\u1b42\u1b6b-\u1b73\u1b80\u1b81\u1ba2-\u1ba5\u1ba8\u1ba9\u1c2c-\u1c33\u1c36\u1c37\u1cd0-\u1cd2\u1cd4-\u1ce0\u1ce2-\u1ce8\u1ced\u1dc0-\u1de6\u1dfd-\u1dff\u200c\u200d\u20d0-\u20f0\u2cef-\u2cf1\u2de0-\u2dff\u302a-\u302f\u3099\u309a\ua66f-\ua672\ua67c\ua67d\ua6f0\ua6f1\ua802\ua806\ua80b\ua825\ua826\ua8c4\ua8e0-\ua8f1\ua926-\ua92d\ua947-\ua951\ua980-\ua982\ua9b3\ua9b6-\ua9b9\ua9bc\uaa29-\uaa2e\uaa31\uaa32\uaa35\uaa36\uaa43\uaa4c\uaab0\uaab2-\uaab4\uaab7\uaab8\uaabe\uaabf\uaac1\uabe5\uabe8\uabed\udc00-\udfff\ufb1e\ufe00-\ufe0f\ufe20-\ufe26\uff9e\uff9f]/,Yl=!1,_l=!1,$l=null,ql=function(){function e(e){return e<=247?r.charAt(e):1424<=e&&e<=1524?"R":1536<=e&&e<=1785?n.charAt(e-1536):1774<=e&&e<=2220?"r":8192<=e&&e<=8203?"w":8204==e?"b":"L"}function t(e,t,r){this.level=e,this.from=t,this.to=r}var r="bbbbbbbbbtstwsbbbbbbbbbbbbbbssstwNN%%%NNNNNN,N,N1111111111NNNNNNNLLLLLLLLLLLLLLLLLLLLLLLLLLNNNNNNLLLLLLLLLLLLLLLLLLLLLLLLLLNNNNbbbbbbsbbbbbbbbbbbbbbbbbbbbbbbbbb,N%%%%NNNNLNNNNN%%11NLNNN1LNNNNNLLLLLLLLLLLLLLLLLLLLLLLNLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLN",n="nnnnnnNNr%%r,rNNmmmmmmmmmmmrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrmmmmmmmmmmmmmmmmmmmmmnnnnnnnnnn%nnrrrmrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrmmmmmmmnNmmmmmmrrmmNmmmmrr1111111111",i=/[\u0590-\u05f4\u0600-\u06ff\u0700-\u08ac]/,o=/[stwN]/,l=/[LRr]/,s=/[Lb1n]/,a=/[1n]/;return function(r,n){var u="ltr"==n?"L":"R";if(0==r.length||"ltr"==n&&!i.test(r))return!1;for(var c=r.length,f=[],h=0;h<c;++h)f.push(e(r.charCodeAt(h)));for(var d=0,p=u;d<c;++d){var v=f[d];"m"==v?f[d]=p:p=v}for(var m=0,y=u;m<c;++m){var b=f[m];"1"==b&&"r"==y?f[m]="n":l.test(b)&&(y=b,"r"==b&&(f[m]="R"))}for(var w=1,x=f[0];w<c-1;++w){var C=f[w];"+"==C&&"1"==x&&"1"==f[w+1]?f[w]="1":","!=C||x!=f[w+1]||"1"!=x&&"n"!=x||(f[w]=x),x=C}for(var S=0;S<c;++S){var L=f[S];if(","==L)f[S]="N";else if("%"==L){var k=void 0;for(k=S+1;k<c&&"%"==f[k];++k);for(var T=S&&"!"==f[S-1]||k<c&&"1"==f[k]?"1":"N",M=S;M<k;++M)f[M]=T;S=k-1}}for(var N=0,O=u;N<c;++N){var A=f[N];"L"==O&&"1"==A?f[N]="L":l.test(A)&&(O=A)}for(var W=0;W<c;++W)if(o.test(f[W])){var D=void 0;for(D=W+1;D<c&&o.test(f[D]);++D);for(var H="L"==(W?f[W-1]:u),F=H==("L"==(D<c?f[D]:u))?H?"L":"R":u,E=W;E<D;++E)f[E]=F;W=D-1}for(var P,I=[],z=0;z<c;)if(s.test(f[z])){var R=z;for(++z;z<c&&s.test(f[z]);++z);I.push(new t(0,R,z))}else{var B=z,G=I.length;for(++z;z<c&&"L"!=f[z];++z);for(var U=B;U<z;)if(a.test(f[U])){B<U&&I.splice(G,0,new t(1,B,U));var V=U;for(++U;U<z&&a.test(f[U]);++U);I.splice(G,0,new t(2,V,U)),B=U}else++U;B<z&&I.splice(G,0,new t(1,B,z))}return 1==I[0].level&&(P=r.match(/^\s+/))&&(I[0].from=P[0].length,I.unshift(new t(0,0,P[0].length))),1==g(I).level&&(P=r.match(/\s+$/))&&(g(I).to-=P[0].length,I.push(new t(0,c-P[0].length,c))),"rtl"==n?I.reverse():I}}(),Zl=[],Ql=function(e,t,r){if(e.addEventListener)e.addEventListener(t,r,!1);else if(e.attachEvent)e.attachEvent("on"+t,r);else{var n=e._handlers||(e._handlers={});n[t]=(n[t]||Zl).concat(r)}},Jl=function(){if(gl&&vl<9)return!1;var e=n("div");return"draggable"in e||"dragDrop"in e}(),es=3!="\n\nb".split(/\n/).length?function(e){for(var t=0,r=[],n=e.length;t<=n;){var i=e.indexOf("\n",t);-1==i&&(i=e.length);var o=e.slice(t,"\r"==e.charAt(i-1)?i-1:i),l=o.indexOf("\r");-1!=l?(r.push(o.slice(0,l)),t+=l+1):(r.push(o),t=i+1)}return r}:function(e){return e.split(/\r\n?|\n/)},ts=window.getSelection?function(e){try{return e.selectionStart!=e.selectionEnd}catch(e){return!1}}:function(e){var t;try{t=e.ownerDocument.selection.createRange()}catch(e){}return!(!t||t.parentElement()!=e)&&0!=t.compareEndPoints("StartToEnd",t)},rs=function(){var e=n("div");return"oncopy"in e||(e.setAttribute("oncopy","return;"),"function"==typeof e.oncopy)}(),ns=null,is={},os={},ls={},ss=function(e,t,r){this.pos=this.start=0,this.string=e,this.tabSize=t||8,this.lastColumnPos=this.lastColumnValue=0,this.lineStart=0,this.lineOracle=r};ss.prototype.eol=function(){return this.pos>=this.string.length},ss.prototype.sol=function(){return this.pos==this.lineStart},ss.prototype.peek=function(){return this.string.charAt(this.pos)||void 0},ss.prototype.next=function(){if(this.pos<this.string.length)return this.string.charAt(this.pos++)},ss.prototype.eat=function(e){var t=this.string.charAt(this.pos);if("string"==typeof e?t==e:t&&(e.test?e.test(t):e(t)))return++this.pos,t},ss.prototype.eatWhile=function(e){for(var t=this.pos;this.eat(e););return this.pos>t},ss.prototype.eatSpace=function(){for(var e=this,t=this.pos;/[\s\u00a0]/.test(this.string.charAt(this.pos));)++e.pos;return this.pos>t},ss.prototype.skipToEnd=function(){this.pos=this.string.length},ss.prototype.skipTo=function(e){var t=this.string.indexOf(e,this.pos);if(t>-1)return this.pos=t,!0},ss.prototype.backUp=function(e){this.pos-=e},ss.prototype.column=function(){return this.lastColumnPos<this.start&&(this.lastColumnValue=f(this.string,this.start,this.tabSize,this.lastColumnPos,this.lastColumnValue),this.lastColumnPos=this.start),this.lastColumnValue-(this.lineStart?f(this.string,this.lineStart,this.tabSize):0)},ss.prototype.indentation=function(){return f(this.string,null,this.tabSize)-(this.lineStart?f(this.string,this.lineStart,this.tabSize):0)},ss.prototype.match=function(e,t,r){if("string"!=typeof e){var n=this.string.slice(this.pos).match(e);return n&&n.index>0?null:(n&&!1!==t&&(this.pos+=n[0].length),n)}var i=function(e){return r?e.toLowerCase():e};if(i(this.string.substr(this.pos,e.length))==i(e))return!1!==t&&(this.pos+=e.length),!0},ss.prototype.current=function(){return this.string.slice(this.start,this.pos)},ss.prototype.hideFirstChars=function(e,t){this.lineStart+=e;try{return t()}finally{this.lineStart-=e}},ss.prototype.lookAhead=function(e){var t=this.lineOracle;return t&&t.lookAhead(e)};var as=function(e,t){this.state=e,this.lookAhead=t},us=function(e,t,r,n){this.state=t,this.doc=e,this.line=r,this.maxLookAhead=n||0};us.prototype.lookAhead=function(e){var t=this.doc.getLine(this.line+e);return null!=t&&e>this.maxLookAhead&&(this.maxLookAhead=e),t},us.prototype.nextLine=function(){this.line++,this.maxLookAhead>0&&this.maxLookAhead--},us.fromSaved=function(e,t,r){return t instanceof as?new us(e,Ke(e.mode,t.state),r,t.lookAhead):new us(e,Ke(e.mode,t),r)},us.prototype.save=function(e){var t=!1!==e?Ke(this.doc.mode,this.state):this.state;return this.maxLookAhead>0?new as(t,this.maxLookAhead):t};var cs=function(e,t,r){this.start=e.start,this.end=e.pos,this.string=e.current(),this.type=t||null,this.state=r},fs=function(e,t,r){this.text=e,ne(this,t),this.height=r?r(this):1};fs.prototype.lineNo=function(){return W(this)},Ae(fs);var hs,ds={},ps={},gs=null,vs=null,ms={left:0,right:0,top:0,bottom:0},ys=function(e,t,r){this.cm=r;var i=this.vert=n("div",[n("div",null,null,"min-width: 1px")],"CodeMirror-vscrollbar"),o=this.horiz=n("div",[n("div",null,null,"height: 100%; min-height: 1px")],"CodeMirror-hscrollbar");e(i),e(o),Ql(i,"scroll",function(){i.clientHeight&&t(i.scrollTop,"vertical")}),Ql(o,"scroll",function(){o.clientWidth&&t(o.scrollLeft,"horizontal")}),this.checkedZeroWidth=!1,gl&&vl<8&&(this.horiz.style.minHeight=this.vert.style.minWidth="18px")};ys.prototype.update=function(e){var t=e.scrollWidth>e.clientWidth+1,r=e.scrollHeight>e.clientHeight+1,n=e.nativeBarWidth;if(r){this.vert.style.display="block",this.vert.style.bottom=t?n+"px":"0";var i=e.viewHeight-(t?n:0);this.vert.firstChild.style.height=Math.max(0,e.scrollHeight-e.clientHeight+i)+"px"}else this.vert.style.display="",this.vert.firstChild.style.height="0";if(t){this.horiz.style.display="block",this.horiz.style.right=r?n+"px":"0",this.horiz.style.left=e.barLeft+"px";var o=e.viewWidth-e.barLeft-(r?n:0);this.horiz.firstChild.style.width=Math.max(0,e.scrollWidth-e.clientWidth+o)+"px"}else this.horiz.style.display="",this.horiz.firstChild.style.width="0";return!this.checkedZeroWidth&&e.clientHeight>0&&(0==n&&this.zeroWidthHack(),this.checkedZeroWidth=!0),{right:r?n:0,bottom:t?n:0}},ys.prototype.setScrollLeft=function(e){this.horiz.scrollLeft!=e&&(this.horiz.scrollLeft=e),this.disableHoriz&&this.enableZeroWidthBar(this.horiz,this.disableHoriz,"horiz")},ys.prototype.setScrollTop=function(e){this.vert.scrollTop!=e&&(this.vert.scrollTop=e),this.disableVert&&this.enableZeroWidthBar(this.vert,this.disableVert,"vert")},ys.prototype.zeroWidthHack=function(){var e=Ml&&!Cl?"12px":"18px";this.horiz.style.height=this.vert.style.width=e,this.horiz.style.pointerEvents=this.vert.style.pointerEvents="none",this.disableHoriz=new Pl,this.disableVert=new Pl},ys.prototype.enableZeroWidthBar=function(e,t,r){function n(){var i=e.getBoundingClientRect();("vert"==r?document.elementFromPoint(i.right-1,(i.top+i.bottom)/2):document.elementFromPoint((i.right+i.left)/2,i.bottom-1))!=e?e.style.pointerEvents="none":t.set(1e3,n)}e.style.pointerEvents="auto",t.set(1e3,n)},ys.prototype.clear=function(){var e=this.horiz.parentNode;e.removeChild(this.horiz),e.removeChild(this.vert)};var bs=function(){};bs.prototype.update=function(){return{bottom:0,right:0}},bs.prototype.setScrollLeft=function(){},bs.prototype.setScrollTop=function(){},bs.prototype.clear=function(){};var ws={native:ys,null:bs},xs=0,Cs=function(e,t,r){var n=e.display;this.viewport=t,this.visible=Ir(n,e.doc,t),this.editorIsHidden=!n.wrapper.offsetWidth,this.wrapperHeight=n.wrapper.clientHeight,this.wrapperWidth=n.wrapper.clientWidth,this.oldDisplayWidth=Rt(e),this.force=r,this.dims=br(e),this.events=[]};Cs.prototype.signal=function(e,t){Oe(e,t)&&this.events.push(arguments)},Cs.prototype.finish=function(){for(var e=this,t=0;t<this.events.length;t++)Te.apply(null,e.events[t])};var Ss=0,Ls=null;gl?Ls=-.53:fl?Ls=15:bl?Ls=-.7:xl&&(Ls=-1/3);var ks=function(e,t){this.ranges=e,this.primIndex=t};ks.prototype.primary=function(){return this.ranges[this.primIndex]},ks.prototype.equals=function(e){var t=this;if(e==this)return!0;if(e.primIndex!=this.primIndex||e.ranges.length!=this.ranges.length)return!1;for(var r=0;r<this.ranges.length;r++){var n=t.ranges[r],i=e.ranges[r];if(!I(n.anchor,i.anchor)||!I(n.head,i.head))return!1}return!0},ks.prototype.deepCopy=function(){for(var e=this,t=[],r=0;r<this.ranges.length;r++)t[r]=new Ts(z(e.ranges[r].anchor),z(e.ranges[r].head));return new ks(t,this.primIndex)},ks.prototype.somethingSelected=function(){for(var e=this,t=0;t<this.ranges.length;t++)if(!e.ranges[t].empty())return!0;return!1},ks.prototype.contains=function(e,t){var r=this;t||(t=e);for(var n=0;n<this.ranges.length;n++){var i=r.ranges[n];if(P(t,i.from())>=0&&P(e,i.to())<=0)return n}return-1};var Ts=function(e,t){this.anchor=e,this.head=t};Ts.prototype.from=function(){return B(this.anchor,this.head)},Ts.prototype.to=function(){return R(this.anchor,this.head)},Ts.prototype.empty=function(){return this.head.line==this.anchor.line&&this.head.ch==this.anchor.ch},Bi.prototype={chunkSize:function(){return this.lines.length},removeInner:function(e,t){for(var r=this,n=e,i=e+t;n<i;++n){var o=r.lines[n];r.height-=o.height,ot(o),bt(o,"delete")}this.lines.splice(e,t)},collapse:function(e){e.push.apply(e,this.lines)},insertInner:function(e,t,r){var n=this;this.height+=r,this.lines=this.lines.slice(0,e).concat(t).concat(this.lines.slice(e));for(var i=0;i<t.length;++i)t[i].parent=n},iterN:function(e,t,r){for(var n=this,i=e+t;e<i;++e)if(r(n.lines[e]))return!0}},Gi.prototype={chunkSize:function(){return this.size},removeInner:function(e,t){var r=this;this.size-=t;for(var n=0;n<this.children.length;++n){var i=r.children[n],o=i.chunkSize();if(e<o){var l=Math.min(t,o-e),s=i.height;if(i.removeInner(e,l),r.height-=s-i.height,o==l&&(r.children.splice(n--,1),i.parent=null),0==(t-=l))break;e=0}else e-=o}if(this.size-t<25&&(this.children.length>1||!(this.children[0]instanceof Bi))){var a=[];this.collapse(a),this.children=[new Bi(a)],this.children[0].parent=this}},collapse:function(e){for(var t=this,r=0;r<this.children.length;++r)t.children[r].collapse(e)},insertInner:function(e,t,r){var n=this;this.size+=t.length,this.height+=r;for(var i=0;i<this.children.length;++i){var o=n.children[i],l=o.chunkSize();if(e<=l){if(o.insertInner(e,t,r),o.lines&&o.lines.length>50){for(var s=o.lines.length%25+25,a=s;a<o.lines.length;){var u=new Bi(o.lines.slice(a,a+=25));o.height-=u.height,n.children.splice(++i,0,u),u.parent=n}o.lines=o.lines.slice(0,s),n.maybeSpill()}break}e-=l}},maybeSpill:function(){if(!(this.children.length<=10)){var e=this;do{var t=new Gi(e.children.splice(e.children.length-5,5));if(e.parent){e.size-=t.size,e.height-=t.height;var r=h(e.parent.children,e);e.parent.children.splice(r+1,0,t)}else{var n=new Gi(e.children);n.parent=e,e.children=[n,t],e=n}t.parent=e.parent}while(e.children.length>10);e.parent.maybeSpill()}},iterN:function(e,t,r){for(var n=this,i=0;i<this.children.length;++i){var o=n.children[i],l=o.chunkSize();if(e<l){var s=Math.min(t,l-e);if(o.iterN(e,s,r))return!0;if(0==(t-=s))break;e=0}else e-=l}}};var Ms=function(e,t,r){var n=this;if(r)for(var i in r)r.hasOwnProperty(i)&&(n[i]=r[i]);this.doc=e,this.node=t};Ms.prototype.clear=function(){var e=this,t=this.doc.cm,r=this.line.widgets,n=this.line,i=W(n);if(null!=i&&r){for(var o=0;o<r.length;++o)r[o]==e&&r.splice(o--,1);r.length||(n.widgets=null);var l=Ht(this);A(n,Math.max(0,n.height-l)),t&&(hn(t,function(){Ui(t,n,-l),mn(t,i,"widget")}),bt(t,"lineWidgetCleared",t,this,i))}},Ms.prototype.changed=function(){var e=this,t=this.height,r=this.doc.cm,n=this.line;this.height=null;var i=Ht(this)-t;i&&(A(n,n.height+i),r&&hn(r,function(){r.curOp.forceUpdate=!0,Ui(r,n,i),bt(r,"lineWidgetChanged",r,e,W(n))}))},Ae(Ms);var Ns=0,Os=function(e,t){this.lines=[],this.type=t,this.doc=e,this.id=++Ns};Os.prototype.clear=function(){var e=this;if(!this.explicitlyCleared){var t=this.doc.cm,r=t&&!t.curOp;if(r&&nn(t),Oe(this,"clear")){var n=this.find();n&&bt(this,"clear",n.from,n.to)}for(var i=null,o=null,l=0;l<this.lines.length;++l){var s=e.lines[l],a=_(s.markedSpans,e);t&&!e.collapsed?mn(t,W(s),"text"):t&&(null!=a.to&&(o=W(s)),null!=a.from&&(i=W(s))),s.markedSpans=$(s.markedSpans,a),null==a.from&&e.collapsed&&!ve(e.doc,s)&&t&&A(s,mr(t.display))}if(t&&this.collapsed&&!t.options.lineWrapping)for(var u=0;u<this.lines.length;++u){var c=fe(e.lines[u]),f=be(c);f>t.display.maxLineLength&&(t.display.maxLine=c,t.display.maxLineLength=f,t.display.maxLineChanged=!0)}null!=i&&t&&this.collapsed&&vn(t,i,o+1),this.lines.length=0,this.explicitlyCleared=!0,this.atomic&&this.doc.cantEdit&&(this.doc.cantEdit=!1,t&&Ci(t.doc)),t&&bt(t,"markerCleared",t,this,i,o),r&&on(t),this.parent&&this.parent.clear()}},Os.prototype.find=function(e,t){var r=this;null==e&&"bookmark"==this.type&&(e=1);for(var n,i,o=0;o<this.lines.length;++o){var l=r.lines[o],s=_(l.markedSpans,r);if(null!=s.from&&(n=E(t?l:W(l),s.from),-1==e))return n;if(null!=s.to&&(i=E(t?l:W(l),s.to),1==e))return i}return n&&{from:n,to:i}},Os.prototype.changed=function(){var e=this,t=this.find(-1,!0),r=this,n=this.doc.cm;t&&n&&hn(n,function(){var i=t.line,o=W(t.line),l=jt(n,o);if(l&&(Qt(l),n.curOp.selectionChanged=n.curOp.forceUpdate=!0),n.curOp.updateMaxLine=!0,!ve(r.doc,i)&&null!=r.height){var s=r.height;r.height=null;var a=Ht(r)-s;a&&A(i,i.height+a)}bt(n,"markerChanged",n,e)})},Os.prototype.attachLine=function(e){if(!this.lines.length&&this.doc.cm){var t=this.doc.cm.curOp;t.maybeHiddenMarkers&&-1!=h(t.maybeHiddenMarkers,this)||(t.maybeUnhiddenMarkers||(t.maybeUnhiddenMarkers=[])).push(this)}this.lines.push(e)},Os.prototype.detachLine=function(e){if(this.lines.splice(h(this.lines,e),1),!this.lines.length&&this.doc.cm){var t=this.doc.cm.curOp;(t.maybeHiddenMarkers||(t.maybeHiddenMarkers=[])).push(this)}},Ae(Os);var As=function(e,t){var r=this;this.markers=e,this.primary=t;for(var n=0;n<e.length;++n)e[n].parent=r};As.prototype.clear=function(){var e=this;if(!this.explicitlyCleared){this.explicitlyCleared=!0;for(var t=0;t<this.markers.length;++t)e.markers[t].clear();bt(this,"clear")}},As.prototype.find=function(e,t){return this.primary.find(e,t)},Ae(As);var Ws=0,Ds=function(e,t,r,n,i){if(!(this instanceof Ds))return new Ds(e,t,r,n,i);null==r&&(r=0),Gi.call(this,[new Bi([new fs("",null)])]),this.first=r,this.scrollTop=this.scrollLeft=0,this.cantEdit=!1,this.cleanGeneration=1,this.modeFrontier=this.highlightFrontier=r;var o=E(r,0);this.sel=Rn(o),this.history=new Jn(null),this.id=++Ws,this.modeOption=t,this.lineSep=n,this.direction="rtl"==i?"rtl":"ltr",this.extend=!1,"string"==typeof e&&(e=this.splitLines(e)),_n(this,{from:o,to:o,text:e}),bi(this,Rn(o),Gl)};Ds.prototype=b(Gi.prototype,{constructor:Ds,iter:function(e,t,r){r?this.iterN(e-this.first,t-e,r):this.iterN(this.first,this.first+this.size,e)},insert:function(e,t){for(var r=0,n=0;n<t.length;++n)r+=t[n].height;this.insertInner(e-this.first,t,r)},remove:function(e,t){this.removeInner(e-this.first,t)},getValue:function(e){var t=O(this,this.first,this.first+this.size);return!1===e?t:t.join(e||this.lineSeparator())},setValue:gn(function(e){var t=E(this.first,0),r=this.first+this.size-1;Oi(this,{from:t,to:E(r,M(this,r).text.length),text:this.splitLines(e),origin:"setValue",full:!0},!0),this.cm&&Xr(this.cm,0,0),bi(this,Rn(t),Gl)}),replaceRange:function(e,t,r,n){Ei(this,e,t=U(this,t),r=r?U(this,r):t,n)},getRange:function(e,t,r){var n=N(this,U(this,e),U(this,t));return!1===r?n:n.join(r||this.lineSeparator())},getLine:function(e){var t=this.getLineHandle(e);return t&&t.text},getLineHandle:function(e){if(H(this,e))return M(this,e)},getLineNumber:function(e){return W(e)},getLineHandleVisualStart:function(e){return"number"==typeof e&&(e=M(this,e)),fe(e)},lineCount:function(){return this.size},firstLine:function(){return this.first},lastLine:function(){return this.first+this.size-1},clipPos:function(e){return U(this,e)},getCursor:function(e){var t=this.sel.primary();return null==e||"head"==e?t.head:"anchor"==e?t.anchor:"end"==e||"to"==e||!1===e?t.to():t.from()},listSelections:function(){return this.sel.ranges},somethingSelected:function(){return this.sel.somethingSelected()},setCursor:gn(function(e,t,r){vi(this,U(this,"number"==typeof e?E(e,t||0):e),null,r)}),setSelection:gn(function(e,t,r){vi(this,U(this,e),U(this,t||e),r)}),extendSelection:gn(function(e,t,r){di(this,U(this,e),t&&U(this,t),r)}),extendSelections:gn(function(e,t){pi(this,K(this,e),t)}),extendSelectionsBy:gn(function(e,t){pi(this,K(this,v(this.sel.ranges,e)),t)}),setSelections:gn(function(e,t,r){var n=this;if(e.length){for(var i=[],o=0;o<e.length;o++)i[o]=new Ts(U(n,e[o].anchor),U(n,e[o].head));null==t&&(t=Math.min(e.length-1,this.sel.primIndex)),bi(this,zn(i,t),r)}}),addSelection:gn(function(e,t,r){var n=this.sel.ranges.slice(0);n.push(new Ts(U(this,e),U(this,t||e))),bi(this,zn(n,n.length-1),r)}),getSelection:function(e){for(var t,r=this,n=this.sel.ranges,i=0;i<n.length;i++){var o=N(r,n[i].from(),n[i].to());t=t?t.concat(o):o}return!1===e?t:t.join(e||this.lineSeparator())},getSelections:function(e){for(var t=this,r=[],n=this.sel.ranges,i=0;i<n.length;i++){var o=N(t,n[i].from(),n[i].to());!1!==e&&(o=o.join(e||t.lineSeparator())),r[i]=o}return r},replaceSelection:function(e,t,r){for(var n=[],i=0;i<this.sel.ranges.length;i++)n[i]=e;this.replaceSelections(n,t,r||"+input")},replaceSelections:gn(function(e,t,r){for(var n=this,i=[],o=this.sel,l=0;l<o.ranges.length;l++){var s=o.ranges[l];i[l]={from:s.from(),to:s.to(),text:n.splitLines(e[l]),origin:r}}for(var a=t&&"end"!=t&&Kn(this,i,t),u=i.length-1;u>=0;u--)Oi(n,i[u]);a?yi(this,a):this.cm&&jr(this.cm)}),undo:gn(function(){Wi(this,"undo")}),redo:gn(function(){Wi(this,"redo")}),undoSelection:gn(function(){Wi(this,"undo",!0)}),redoSelection:gn(function(){Wi(this,"redo",!0)}),setExtending:function(e){this.extend=e},getExtending:function(){return this.extend},historySize:function(){for(var e=this.history,t=0,r=0,n=0;n<e.done.length;n++)e.done[n].ranges||++t;for(var i=0;i<e.undone.length;i++)e.undone[i].ranges||++r;return{undo:t,redo:r}},clearHistory:function(){this.history=new Jn(this.history.maxGeneration)},markClean:function(){this.cleanGeneration=this.changeGeneration(!0)},changeGeneration:function(e){return e&&(this.history.lastOp=this.history.lastSelOp=this.history.lastOrigin=null),this.history.generation},isClean:function(e){return this.history.generation==(e||this.cleanGeneration)},getHistory:function(){return{done:fi(this.history.done),undone:fi(this.history.undone)}},setHistory:function(e){var t=this.history=new Jn(this.history.maxGeneration);t.done=fi(e.done.slice(0),null,!0),t.undone=fi(e.undone.slice(0),null,!0)},setGutterMarker:gn(function(e,t,r){return Ri(this,e,"gutter",function(e){var n=e.gutterMarkers||(e.gutterMarkers={});return n[t]=r,!r&&C(n)&&(e.gutterMarkers=null),!0})}),clearGutter:gn(function(e){var t=this;this.iter(function(r){r.gutterMarkers&&r.gutterMarkers[e]&&Ri(t,r,"gutter",function(){return r.gutterMarkers[e]=null,C(r.gutterMarkers)&&(r.gutterMarkers=null),!0})})}),lineInfo:function(e){var t;if("number"==typeof e){if(!H(this,e))return null;if(t=e,!(e=M(this,e)))return null}else if(null==(t=W(e)))return null;return{line:t,handle:e,text:e.text,gutterMarkers:e.gutterMarkers,textClass:e.textClass,bgClass:e.bgClass,wrapClass:e.wrapClass,widgets:e.widgets}},addLineClass:gn(function(t,r,n){return Ri(this,t,"gutter"==r?"gutter":"class",function(t){var i="text"==r?"textClass":"background"==r?"bgClass":"gutter"==r?"gutterClass":"wrapClass";if(t[i]){if(e(n).test(t[i]))return!1;t[i]+=" "+n}else t[i]=n;return!0})}),removeLineClass:gn(function(t,r,n){return Ri(this,t,"gutter"==r?"gutter":"class",function(t){var i="text"==r?"textClass":"background"==r?"bgClass":"gutter"==r?"gutterClass":"wrapClass",o=t[i];if(!o)return!1;if(null==n)t[i]=null;else{var l=o.match(e(n));if(!l)return!1;var s=l.index+l[0].length;t[i]=o.slice(0,l.index)+(l.index&&s!=o.length?" ":"")+o.slice(s)||null}return!0})}),addLineWidget:gn(function(e,t,r){return Vi(this,e,t,r)}),removeLineWidget:function(e){e.clear()},markText:function(e,t,r){return Ki(this,U(this,e),U(this,t),r,r&&r.type||"range")},setBookmark:function(e,t){var r={replacedWith:t&&(null==t.nodeType?t.widget:t),insertLeft:t&&t.insertLeft,clearWhenEmpty:!1,shared:t&&t.shared,handleMouseEvents:t&&t.handleMouseEvents};return e=U(this,e),Ki(this,e,e,r,"bookmark")},findMarksAt:function(e){var t=[],r=M(this,(e=U(this,e)).line).markedSpans;if(r)for(var n=0;n<r.length;++n){var i=r[n];(null==i.from||i.from<=e.ch)&&(null==i.to||i.to>=e.ch)&&t.push(i.marker.parent||i.marker)}return t},findMarks:function(e,t,r){e=U(this,e),t=U(this,t);var n=[],i=e.line;return this.iter(e.line,t.line+1,function(o){var l=o.markedSpans;if(l)for(var s=0;s<l.length;s++){var a=l[s];null!=a.to&&i==e.line&&e.ch>=a.to||null==a.from&&i!=e.line||null!=a.from&&i==t.line&&a.from>=t.ch||r&&!r(a.marker)||n.push(a.marker.parent||a.marker)}++i}),n},getAllMarks:function(){var e=[];return this.iter(function(t){var r=t.markedSpans;if(r)for(var n=0;n<r.length;++n)null!=r[n].from&&e.push(r[n].marker)}),e},posFromIndex:function(e){var t,r=this.first,n=this.lineSeparator().length;return this.iter(function(i){var o=i.text.length+n;if(o>e)return t=e,!0;e-=o,++r}),U(this,E(r,t))},indexFromPos:function(e){var t=(e=U(this,e)).ch;if(e.line<this.first||e.ch<0)return 0;var r=this.lineSeparator().length;return this.iter(this.first,e.line,function(e){t+=e.text.length+r}),t},copy:function(e){var t=new Ds(O(this,this.first,this.first+this.size),this.modeOption,this.first,this.lineSep,this.direction);return t.scrollTop=this.scrollTop,t.scrollLeft=this.scrollLeft,t.sel=this.sel,t.extend=!1,e&&(t.history.undoDepth=this.history.undoDepth,t.setHistory(this.getHistory())),t},linkedDoc:function(e){e||(e={});var t=this.first,r=this.first+this.size;null!=e.from&&e.from>t&&(t=e.from),null!=e.to&&e.to<r&&(r=e.to);var n=new Ds(O(this,t,r),e.mode||this.modeOption,t,this.lineSep,this.direction);return e.sharedHist&&(n.history=this.history),(this.linked||(this.linked=[])).push({doc:n,sharedHist:e.sharedHist}),n.linked=[{doc:this,isParent:!0,sharedHist:e.sharedHist}],Yi(n,Xi(this)),n},unlinkDoc:function(e){var t=this;if(e instanceof jo&&(e=e.doc),this.linked)for(var r=0;r<this.linked.length;++r)if(t.linked[r].doc==e){t.linked.splice(r,1),e.unlinkDoc(t),_i(Xi(t));break}if(e.history==this.history){var n=[e.id];$n(e,function(e){return n.push(e.id)},!0),e.history=new Jn(null),e.history.done=fi(this.history.done,n),e.history.undone=fi(this.history.undone,n)}},iterLinkedDocs:function(e){$n(this,e)},getMode:function(){return this.mode},getEditor:function(){return this.cm},splitLines:function(e){return this.lineSep?e.split(this.lineSep):es(e)},lineSeparator:function(){return this.lineSep||"\n"},setDirection:gn(function(e){"rtl"!=e&&(e="ltr"),e!=this.direction&&(this.direction=e,this.iter(function(e){return e.order=null}),this.cm&&Qn(this.cm))})}),Ds.prototype.eachLine=Ds.prototype.iter;for(var Hs=0,Fs=!1,Es={3:"Enter",8:"Backspace",9:"Tab",13:"Enter",16:"Shift",17:"Ctrl",18:"Alt",19:"Pause",20:"CapsLock",27:"Esc",32:"Space",33:"PageUp",34:"PageDown",35:"End",36:"Home",37:"Left",38:"Up",39:"Right",40:"Down",44:"PrintScrn",45:"Insert",46:"Delete",59:";",61:"=",91:"Mod",92:"Mod",93:"Mod",106:"*",107:"=",109:"-",110:".",111:"/",127:"Delete",173:"-",186:";",187:"=",188:",",189:"-",190:".",191:"/",192:"`",219:"[",220:"\\",221:"]",222:"'",63232:"Up",63233:"Down",63234:"Left",63235:"Right",63272:"Delete",63273:"Home",63275:"End",63276:"PageUp",63277:"PageDown",63302:"Insert"},Ps=0;Ps<10;Ps++)Es[Ps+48]=Es[Ps+96]=String(Ps);for(var Is=65;Is<=90;Is++)Es[Is]=String.fromCharCode(Is);for(var zs=1;zs<=12;zs++)Es[zs+111]=Es[zs+63235]="F"+zs;var Rs={};Rs.basic={Left:"goCharLeft",Right:"goCharRight",Up:"goLineUp",Down:"goLineDown",End:"goLineEnd",Home:"goLineStartSmart",PageUp:"goPageUp",PageDown:"goPageDown",Delete:"delCharAfter",Backspace:"delCharBefore","Shift-Backspace":"delCharBefore",Tab:"defaultTab","Shift-Tab":"indentAuto",Enter:"newlineAndIndent",Insert:"toggleOverwrite",Esc:"singleSelection"},Rs.pcDefault={"Ctrl-A":"selectAll","Ctrl-D":"deleteLine","Ctrl-Z":"undo","Shift-Ctrl-Z":"redo","Ctrl-Y":"redo","Ctrl-Home":"goDocStart","Ctrl-End":"goDocEnd","Ctrl-Up":"goLineUp","Ctrl-Down":"goLineDown","Ctrl-Left":"goGroupLeft","Ctrl-Right":"goGroupRight","Alt-Left":"goLineStart","Alt-Right":"goLineEnd","Ctrl-Backspace":"delGroupBefore","Ctrl-Delete":"delGroupAfter","Ctrl-S":"save","Ctrl-F":"find","Ctrl-G":"findNext","Shift-Ctrl-G":"findPrev","Shift-Ctrl-F":"replace","Shift-Ctrl-R":"replaceAll","Ctrl-[":"indentLess","Ctrl-]":"indentMore","Ctrl-U":"undoSelection","Shift-Ctrl-U":"redoSelection","Alt-U":"redoSelection",fallthrough:"basic"},Rs.emacsy={"Ctrl-F":"goCharRight","Ctrl-B":"goCharLeft","Ctrl-P":"goLineUp","Ctrl-N":"goLineDown","Alt-F":"goWordRight","Alt-B":"goWordLeft","Ctrl-A":"goLineStart","Ctrl-E":"goLineEnd","Ctrl-V":"goPageDown","Shift-Ctrl-V":"goPageUp","Ctrl-D":"delCharAfter","Ctrl-H":"delCharBefore","Alt-D":"delWordAfter","Alt-Backspace":"delWordBefore","Ctrl-K":"killLine","Ctrl-T":"transposeChars","Ctrl-O":"openLine"},Rs.macDefault={"Cmd-A":"selectAll","Cmd-D":"deleteLine","Cmd-Z":"undo","Shift-Cmd-Z":"redo","Cmd-Y":"redo","Cmd-Home":"goDocStart","Cmd-Up":"goDocStart","Cmd-End":"goDocEnd","Cmd-Down":"goDocEnd","Alt-Left":"goGroupLeft","Alt-Right":"goGroupRight","Cmd-Left":"goLineLeft","Cmd-Right":"goLineRight","Alt-Backspace":"delGroupBefore","Ctrl-Alt-Backspace":"delGroupAfter","Alt-Delete":"delGroupAfter","Cmd-S":"save","Cmd-F":"find","Cmd-G":"findNext","Shift-Cmd-G":"findPrev","Cmd-Alt-F":"replace","Shift-Cmd-Alt-F":"replaceAll","Cmd-[":"indentLess","Cmd-]":"indentMore","Cmd-Backspace":"delWrappedLineLeft","Cmd-Delete":"delWrappedLineRight","Cmd-U":"undoSelection","Shift-Cmd-U":"redoSelection","Ctrl-Up":"goDocStart","Ctrl-Down":"goDocEnd",fallthrough:["basic","emacsy"]},Rs.default=Ml?Rs.macDefault:Rs.pcDefault;var Bs={selectAll:Mi,singleSelection:function(e){return e.setSelection(e.getCursor("anchor"),e.getCursor("head"),Gl)},killLine:function(e){return co(e,function(t){if(t.empty()){var r=M(e.doc,t.head.line).text.length;return t.head.ch==r&&t.head.line<e.lastLine()?{from:t.head,to:E(t.head.line+1,0)}:{from:t.head,to:E(t.head.line,r)}}return{from:t.from(),to:t.to()}})},deleteLine:function(e){return co(e,function(t){return{from:E(t.from().line,0),to:U(e.doc,E(t.to().line+1,0))}})},delLineLeft:function(e){return co(e,function(e){return{from:E(e.from().line,0),to:e.from()}})},delWrappedLineLeft:function(e){return co(e,function(t){var r=e.charCoords(t.head,"div").top+5;return{from:e.coordsChar({left:0,top:r},"div"),to:t.from()}})},delWrappedLineRight:function(e){return co(e,function(t){var r=e.charCoords(t.head,"div").top+5,n=e.coordsChar({left:e.display.lineDiv.offsetWidth+100,top:r},"div");return{from:t.from(),to:n}})},undo:function(e){return e.undo()},redo:function(e){return e.redo()},undoSelection:function(e){return e.undoSelection()},redoSelection:function(e){return e.redoSelection()},goDocStart:function(e){return e.extendSelection(E(e.firstLine(),0))},goDocEnd:function(e){return e.extendSelection(E(e.lastLine()))},goLineStart:function(e){return e.extendSelectionsBy(function(t){return vo(e,t.head.line)},{origin:"+move",bias:1})},goLineStartSmart:function(e){return e.extendSelectionsBy(function(t){return yo(e,t.head)},{origin:"+move",bias:1})},goLineEnd:function(e){return e.extendSelectionsBy(function(t){return mo(e,t.head.line)},{origin:"+move",bias:-1})},goLineRight:function(e){return e.extendSelectionsBy(function(t){var r=e.cursorCoords(t.head,"div").top+5;return e.coordsChar({left:e.display.lineDiv.offsetWidth+100,top:r},"div")},Vl)},goLineLeft:function(e){return e.extendSelectionsBy(function(t){var r=e.cursorCoords(t.head,"div").top+5;return e.coordsChar({left:0,top:r},"div")},Vl)},goLineLeftSmart:function(e){return e.extendSelectionsBy(function(t){var r=e.cursorCoords(t.head,"div").top+5,n=e.coordsChar({left:0,top:r},"div");return n.ch<e.getLine(n.line).search(/\S/)?yo(e,t.head):n},Vl)},goLineUp:function(e){return e.moveV(-1,"line")},goLineDown:function(e){return e.moveV(1,"line")},goPageUp:function(e){return e.moveV(-1,"page")},goPageDown:function(e){return e.moveV(1,"page")},goCharLeft:function(e){return e.moveH(-1,"char")},goCharRight:function(e){return e.moveH(1,"char")},goColumnLeft:function(e){return e.moveH(-1,"column")},goColumnRight:function(e){return e.moveH(1,"column")},goWordLeft:function(e){return e.moveH(-1,"word")},goGroupRight:function(e){return e.moveH(1,"group")},goGroupLeft:function(e){return e.moveH(-1,"group")},goWordRight:function(e){return e.moveH(1,"word")},delCharBefore:function(e){return e.deleteH(-1,"char")},delCharAfter:function(e){return e.deleteH(1,"char")},delWordBefore:function(e){return e.deleteH(-1,"word")},delWordAfter:function(e){return e.deleteH(1,"word")},delGroupBefore:function(e){return e.deleteH(-1,"group")},delGroupAfter:function(e){return e.deleteH(1,"group")},indentAuto:function(e){return e.indentSelection("smart")},indentMore:function(e){return e.indentSelection("add")},indentLess:function(e){return e.indentSelection("subtract")},insertTab:function(e){return e.replaceSelection("\t")},insertSoftTab:function(e){for(var t=[],r=e.listSelections(),n=e.options.tabSize,i=0;i<r.length;i++){var o=r[i].from(),l=f(e.getLine(o.line),o.ch,n);t.push(p(n-l%n))}e.replaceSelections(t)},defaultTab:function(e){e.somethingSelected()?e.indentSelection("add"):e.execCommand("insertTab")},transposeChars:function(e){return hn(e,function(){for(var t=e.listSelections(),r=[],n=0;n<t.length;n++)if(t[n].empty()){var i=t[n].head,o=M(e.doc,i.line).text;if(o)if(i.ch==o.length&&(i=new E(i.line,i.ch-1)),i.ch>0)i=new E(i.line,i.ch+1),e.replaceRange(o.charAt(i.ch-1)+o.charAt(i.ch-2),E(i.line,i.ch-2),i,"+transpose");else if(i.line>e.doc.first){var l=M(e.doc,i.line-1).text;l&&(i=new E(i.line,1),e.replaceRange(o.charAt(0)+e.doc.lineSeparator()+l.charAt(l.length-1),E(i.line-1,l.length-1),i,"+transpose"))}r.push(new Ts(i,i))}e.setSelections(r)})},newlineAndIndent:function(e){return hn(e,function(){for(var t=e.listSelections(),r=t.length-1;r>=0;r--)e.replaceRange(e.doc.lineSeparator(),t[r].anchor,t[r].head,"+input");t=e.listSelections();for(var n=0;n<t.length;n++)e.indentLine(t[n].from().line,null,!0);jr(e)})},openLine:function(e){return e.replaceSelection("\n","start")},toggleOverwrite:function(e){return e.toggleOverwrite()}},Gs=new Pl,Us=null,Vs=function(e,t,r){this.time=e,this.pos=t,this.button=r};Vs.prototype.compare=function(e,t,r){return this.time+400>e&&0==P(t,this.pos)&&r==this.button};var Ks,js,Xs={toString:function(){return"CodeMirror.Init"}},Ys={},_s={};jo.defaults=Ys,jo.optionHandlers=_s;var $s=[];jo.defineInitHook=function(e){return $s.push(e)};var qs=null,Zs=function(e){this.cm=e,this.lastAnchorNode=this.lastAnchorOffset=this.lastFocusNode=this.lastFocusOffset=null,this.polling=new Pl,this.composing=null,this.gracePeriod=!1,this.readDOMTimeout=null};Zs.prototype.init=function(e){function t(e){if(!Me(i,e)){if(i.somethingSelected())_o({lineWise:!1,text:i.getSelections()}),"cut"==e.type&&i.replaceSelection("",null,"cut");else{if(!i.options.lineWiseCopyCut)return;var t=Qo(i);_o({lineWise:!0,text:t.text}),"cut"==e.type&&i.operation(function(){i.setSelections(t.ranges,0,Gl),i.replaceSelection("",null,"cut")})}if(e.clipboardData){e.clipboardData.clearData();var r=qs.text.join("\n");if(e.clipboardData.setData("Text",r),e.clipboardData.getData("Text")==r)return void e.preventDefault()}var l=el(),s=l.firstChild;i.display.lineSpace.insertBefore(l,i.display.lineSpace.firstChild),s.value=qs.text.join("\n");var a=document.activeElement;El(s),setTimeout(function(){i.display.lineSpace.removeChild(l),a.focus(),a==o&&n.showPrimarySelection()},50)}}var r=this,n=this,i=n.cm,o=n.div=e.lineDiv;Jo(o,i.options.spellcheck),Ql(o,"paste",function(e){Me(i,e)||qo(e,i)||vl<=11&&setTimeout(dn(i,function(){return r.updateFromDOM()}),20)}),Ql(o,"compositionstart",function(e){r.composing={data:e.data,done:!1}}),Ql(o,"compositionupdate",function(e){r.composing||(r.composing={data:e.data,done:!1})}),Ql(o,"compositionend",function(e){r.composing&&(e.data!=r.composing.data&&r.readFromDOMSoon(),r.composing.done=!0)}),Ql(o,"touchstart",function(){return n.forceCompositionEnd()}),Ql(o,"input",function(){r.composing||r.readFromDOMSoon()}),Ql(o,"copy",t),Ql(o,"cut",t)},Zs.prototype.prepareSelection=function(){var e=Tr(this.cm,!1);return e.focus=this.cm.state.focused,e},Zs.prototype.showSelection=function(e,t){e&&this.cm.display.view.length&&((e.focus||t)&&this.showPrimarySelection(),this.showMultipleSelections(e))},Zs.prototype.showPrimarySelection=function(){var e=window.getSelection(),t=this.cm,r=t.doc.sel.primary(),n=r.from(),i=r.to();if(t.display.viewTo==t.display.viewFrom||n.line>=t.display.viewTo||i.line<t.display.viewFrom)e.removeAllRanges();else{var o=sl(t,e.anchorNode,e.anchorOffset),l=sl(t,e.focusNode,e.focusOffset);if(!o||o.bad||!l||l.bad||0!=P(B(o,l),n)||0!=P(R(o,l),i)){var s=t.display.view,a=n.line>=t.display.viewFrom&&nl(t,n)||{node:s[0].measure.map[2],offset:0},u=i.line<t.display.viewTo&&nl(t,i);if(!u){var c=s[s.length-1].measure,f=c.maps?c.maps[c.maps.length-1]:c.map;u={node:f[f.length-1],offset:f[f.length-2]-f[f.length-3]}}if(a&&u){var h,d=e.rangeCount&&e.getRangeAt(0);try{h=Wl(a.node,a.offset,u.offset,u.node)}catch(e){}h&&(!fl&&t.state.focused?(e.collapse(a.node,a.offset),h.collapsed||(e.removeAllRanges(),e.addRange(h))):(e.removeAllRanges(),e.addRange(h)),d&&null==e.anchorNode?e.addRange(d):fl&&this.startGracePeriod()),this.rememberSelection()}else e.removeAllRanges()}}},Zs.prototype.startGracePeriod=function(){var e=this;clearTimeout(this.gracePeriod),this.gracePeriod=setTimeout(function(){e.gracePeriod=!1,e.selectionChanged()&&e.cm.operation(function(){return e.cm.curOp.selectionChanged=!0})},20)},Zs.prototype.showMultipleSelections=function(e){r(this.cm.display.cursorDiv,e.cursors),r(this.cm.display.selectionDiv,e.selection)},Zs.prototype.rememberSelection=function(){var e=window.getSelection();this.lastAnchorNode=e.anchorNode,this.lastAnchorOffset=e.anchorOffset,this.lastFocusNode=e.focusNode,this.lastFocusOffset=e.focusOffset},Zs.prototype.selectionInEditor=function(){var e=window.getSelection();if(!e.rangeCount)return!1;var t=e.getRangeAt(0).commonAncestorContainer;return o(this.div,t)},Zs.prototype.focus=function(){"nocursor"!=this.cm.options.readOnly&&(this.selectionInEditor()||this.showSelection(this.prepareSelection(),!0),this.div.focus())},Zs.prototype.blur=function(){this.div.blur()},Zs.prototype.getField=function(){return this.div},Zs.prototype.supportsTouch=function(){return!0},Zs.prototype.receivedFocus=function(){function e(){t.cm.state.focused&&(t.pollSelection(),t.polling.set(t.cm.options.pollInterval,e))}var t=this;this.selectionInEditor()?this.pollSelection():hn(this.cm,function(){return t.cm.curOp.selectionChanged=!0}),this.polling.set(this.cm.options.pollInterval,e)},Zs.prototype.selectionChanged=function(){var e=window.getSelection();return e.anchorNode!=this.lastAnchorNode||e.anchorOffset!=this.lastAnchorOffset||e.focusNode!=this.lastFocusNode||e.focusOffset!=this.lastFocusOffset},Zs.prototype.pollSelection=function(){if(null==this.readDOMTimeout&&!this.gracePeriod&&this.selectionChanged()){var e=window.getSelection(),t=this.cm;if(kl&&bl&&this.cm.options.gutters.length&&il(e.anchorNode))return this.cm.triggerOnKeyDown({type:"keydown",keyCode:8,preventDefault:Math.abs}),this.blur(),void this.focus();if(!this.composing){this.rememberSelection();var r=sl(t,e.anchorNode,e.anchorOffset),n=sl(t,e.focusNode,e.focusOffset);r&&n&&hn(t,function(){bi(t.doc,Rn(r,n),Gl),(r.bad||n.bad)&&(t.curOp.selectionChanged=!0)})}}},Zs.prototype.pollContent=function(){null!=this.readDOMTimeout&&(clearTimeout(this.readDOMTimeout),this.readDOMTimeout=null);var e=this.cm,t=e.display,r=e.doc.sel.primary(),n=r.from(),i=r.to();if(0==n.ch&&n.line>e.firstLine()&&(n=E(n.line-1,M(e.doc,n.line-1).length)),i.ch==M(e.doc,i.line).text.length&&i.line<e.lastLine()&&(i=E(i.line+1,0)),n.line<t.viewFrom||i.line>t.viewTo-1)return!1;var o,l,s;n.line==t.viewFrom||0==(o=Lr(e,n.line))?(l=W(t.view[0].line),s=t.view[0].node):(l=W(t.view[o].line),s=t.view[o-1].node.nextSibling);var a,u,c=Lr(e,i.line);if(c==t.view.length-1?(a=t.viewTo-1,u=t.lineDiv.lastChild):(a=W(t.view[c+1].line)-1,u=t.view[c+1].node.previousSibling),!s)return!1;for(var f=e.doc.splitLines(ll(e,s,u,l,a)),h=N(e.doc,E(l,0),E(a,M(e.doc,a).text.length));f.length>1&&h.length>1;)if(g(f)==g(h))f.pop(),h.pop(),a--;else{if(f[0]!=h[0])break;f.shift(),h.shift(),l++}for(var d=0,p=0,v=f[0],m=h[0],y=Math.min(v.length,m.length);d<y&&v.charCodeAt(d)==m.charCodeAt(d);)++d;for(var b=g(f),w=g(h),x=Math.min(b.length-(1==f.length?d:0),w.length-(1==h.length?d:0));p<x&&b.charCodeAt(b.length-p-1)==w.charCodeAt(w.length-p-1);)++p;if(1==f.length&&1==h.length&&l==n.line)for(;d&&d>n.ch&&b.charCodeAt(b.length-p-1)==w.charCodeAt(w.length-p-1);)d--,p++;f[f.length-1]=b.slice(0,b.length-p).replace(/^\u200b+/,""),f[0]=f[0].slice(d).replace(/\u200b+$/,"");var C=E(l,d),S=E(a,h.length?g(h).length-p:0);return f.length>1||f[0]||P(C,S)?(Ei(e.doc,f,C,S,"+input"),!0):void 0},Zs.prototype.ensurePolled=function(){this.forceCompositionEnd()},Zs.prototype.reset=function(){this.forceCompositionEnd()},Zs.prototype.forceCompositionEnd=function(){this.composing&&(clearTimeout(this.readDOMTimeout),this.composing=null,this.updateFromDOM(),this.div.blur(),this.div.focus())},Zs.prototype.readFromDOMSoon=function(){var e=this;null==this.readDOMTimeout&&(this.readDOMTimeout=setTimeout(function(){if(e.readDOMTimeout=null,e.composing){if(!e.composing.done)return;e.composing=null}e.updateFromDOM()},80))},Zs.prototype.updateFromDOM=function(){var e=this;!this.cm.isReadOnly()&&this.pollContent()||hn(this.cm,function(){return vn(e.cm)})},Zs.prototype.setUneditable=function(e){e.contentEditable="false"},Zs.prototype.onKeyPress=function(e){0!=e.charCode&&(e.preventDefault(),this.cm.isReadOnly()||dn(this.cm,$o)(this.cm,String.fromCharCode(null==e.charCode?e.keyCode:e.charCode),0))},Zs.prototype.readOnlyChanged=function(e){this.div.contentEditable=String("nocursor"!=e)},Zs.prototype.onContextMenu=function(){},Zs.prototype.resetPosition=function(){},Zs.prototype.needsContentAttribute=!0;var Qs=function(e){this.cm=e,this.prevInput="",this.pollingFast=!1,this.polling=new Pl,this.hasSelection=!1,this.composing=null};Qs.prototype.init=function(e){function t(e){if(!Me(i,e)){if(i.somethingSelected())_o({lineWise:!1,text:i.getSelections()});else{if(!i.options.lineWiseCopyCut)return;var t=Qo(i);_o({lineWise:!0,text:t.text}),"cut"==e.type?i.setSelections(t.ranges,null,Gl):(n.prevInput="",l.value=t.text.join("\n"),El(l))}"cut"==e.type&&(i.state.cutIncoming=!0)}}var r=this,n=this,i=this.cm,o=this.wrapper=el(),l=this.textarea=o.firstChild;e.wrapper.insertBefore(o,e.wrapper.firstChild),Ll&&(l.style.width="0px"),Ql(l,"input",function(){gl&&vl>=9&&r.hasSelection&&(r.hasSelection=null),n.poll()}),Ql(l,"paste",function(e){Me(i,e)||qo(e,i)||(i.state.pasteIncoming=!0,n.fastPoll())}),Ql(l,"cut",t),Ql(l,"copy",t),Ql(e.scroller,"paste",function(t){Ft(e,t)||Me(i,t)||(i.state.pasteIncoming=!0,n.focus())}),Ql(e.lineSpace,"selectstart",function(t){Ft(e,t)||We(t)}),Ql(l,"compositionstart",function(){var e=i.getCursor("from");n.composing&&n.composing.range.clear(),n.composing={start:e,range:i.markText(e,i.getCursor("to"),{className:"CodeMirror-composing"})}}),Ql(l,"compositionend",function(){n.composing&&(n.poll(),n.composing.range.clear(),n.composing=null)})},Qs.prototype.prepareSelection=function(){var e=this.cm,t=e.display,r=e.doc,n=Tr(e);if(e.options.moveInputWithCursor){var i=sr(e,r.sel.primary().head,"div"),o=t.wrapper.getBoundingClientRect(),l=t.lineDiv.getBoundingClientRect();n.teTop=Math.max(0,Math.min(t.wrapper.clientHeight-10,i.top+l.top-o.top)),n.teLeft=Math.max(0,Math.min(t.wrapper.clientWidth-10,i.left+l.left-o.left))}return n},Qs.prototype.showSelection=function(e){var t=this.cm.display;r(t.cursorDiv,e.cursors),r(t.selectionDiv,e.selection),null!=e.teTop&&(this.wrapper.style.top=e.teTop+"px",this.wrapper.style.left=e.teLeft+"px")},Qs.prototype.reset=function(e){if(!this.contextMenuPending&&!this.composing){var t=this.cm;if(t.somethingSelected()){this.prevInput="";var r=t.getSelection();this.textarea.value=r,t.state.focused&&El(this.textarea),gl&&vl>=9&&(this.hasSelection=r)}else e||(this.prevInput=this.textarea.value="",gl&&vl>=9&&(this.hasSelection=null))}},Qs.prototype.getField=function(){return this.textarea},Qs.prototype.supportsTouch=function(){return!1},Qs.prototype.focus=function(){if("nocursor"!=this.cm.options.readOnly&&(!Tl||l()!=this.textarea))try{this.textarea.focus()}catch(e){}},Qs.prototype.blur=function(){this.textarea.blur()},Qs.prototype.resetPosition=function(){this.wrapper.style.top=this.wrapper.style.left=0},Qs.prototype.receivedFocus=function(){this.slowPoll()},Qs.prototype.slowPoll=function(){var e=this;this.pollingFast||this.polling.set(this.cm.options.pollInterval,function(){e.poll(),e.cm.state.focused&&e.slowPoll()})},Qs.prototype.fastPoll=function(){function e(){r.poll()||t?(r.pollingFast=!1,r.slowPoll()):(t=!0,r.polling.set(60,e))}var t=!1,r=this;r.pollingFast=!0,r.polling.set(20,e)},Qs.prototype.poll=function(){var e=this,t=this.cm,r=this.textarea,n=this.prevInput;if(this.contextMenuPending||!t.state.focused||ts(r)&&!n&&!this.composing||t.isReadOnly()||t.options.disableInput||t.state.keySeq)return!1;var i=r.value;if(i==n&&!t.somethingSelected())return!1;if(gl&&vl>=9&&this.hasSelection===i||Ml&&/[\uf700-\uf7ff]/.test(i))return t.display.input.reset(),!1;if(t.doc.sel==t.display.selForContextMenu){var o=i.charCodeAt(0);if(8203!=o||n||(n="​"),8666==o)return this.reset(),this.cm.execCommand("undo")}for(var l=0,s=Math.min(n.length,i.length);l<s&&n.charCodeAt(l)==i.charCodeAt(l);)++l;return hn(t,function(){$o(t,i.slice(l),n.length-l,null,e.composing?"*compose":null),i.length>1e3||i.indexOf("\n")>-1?r.value=e.prevInput="":e.prevInput=i,e.composing&&(e.composing.range.clear(),e.composing.range=t.markText(e.composing.start,t.getCursor("to"),{className:"CodeMirror-composing"}))}),!0},Qs.prototype.ensurePolled=function(){this.pollingFast&&this.poll()&&(this.pollingFast=!1)},Qs.prototype.onKeyPress=function(){gl&&vl>=9&&(this.hasSelection=null),this.fastPoll()},Qs.prototype.onContextMenu=function(e){function t(){if(null!=l.selectionStart){var e=i.somethingSelected(),t="​"+(e?l.value:"");l.value="⇚",l.value=t,n.prevInput=e?"":"​",l.selectionStart=1,l.selectionEnd=t.length,o.selForContextMenu=i.doc.sel}}function r(){if(n.contextMenuPending=!1,n.wrapper.style.cssText=c,l.style.cssText=u,gl&&vl<9&&o.scrollbars.setScrollTop(o.scroller.scrollTop=a),null!=l.selectionStart){(!gl||gl&&vl<9)&&t();var e=0,r=function(){o.selForContextMenu==i.doc.sel&&0==l.selectionStart&&l.selectionEnd>0&&"​"==n.prevInput?dn(i,Mi)(i):e++<10?o.detectingSelectAll=setTimeout(r,500):(o.selForContextMenu=null,o.input.reset())};o.detectingSelectAll=setTimeout(r,200)}}var n=this,i=n.cm,o=i.display,l=n.textarea,s=Sr(i,e),a=o.scroller.scrollTop;if(s&&!wl){i.options.resetSelectionOnContextMenu&&-1==i.doc.sel.contains(s)&&dn(i,bi)(i.doc,Rn(s),Gl);var u=l.style.cssText,c=n.wrapper.style.cssText;n.wrapper.style.cssText="position: absolute";var f=n.wrapper.getBoundingClientRect();l.style.cssText="position: absolute; width: 30px; height: 30px;\n      top: "+(e.clientY-f.top-5)+"px; left: "+(e.clientX-f.left-5)+"px;\n      z-index: 1000; background: "+(gl?"rgba(255, 255, 255, .05)":"transparent")+";\n      outline: none; border-width: 0; outline: none; overflow: hidden; opacity: .05; filter: alpha(opacity=5);";var h;if(ml&&(h=window.scrollY),o.input.focus(),ml&&window.scrollTo(null,h),o.input.reset(),i.somethingSelected()||(l.value=n.prevInput=" "),n.contextMenuPending=!0,o.selForContextMenu=i.doc.sel,clearTimeout(o.detectingSelectAll),gl&&vl>=9&&t(),Hl){Fe(e);var d=function(){ke(window,"mouseup",d),setTimeout(r,20)};Ql(window,"mouseup",d)}else setTimeout(r,50)}},Qs.prototype.readOnlyChanged=function(e){e||this.reset(),this.textarea.disabled="nocursor"==e},Qs.prototype.setUneditable=function(){},Qs.prototype.needsContentAttribute=!1,function(e){function t(t,n,i,o){e.defaults[t]=n,i&&(r[t]=o?function(e,t,r){r!=Xs&&i(e,t,r)}:i)}var r=e.optionHandlers;e.defineOption=t,e.Init=Xs,t("value","",function(e,t){return e.setValue(t)},!0),t("mode",null,function(e,t){e.doc.modeOption=t,jn(e)},!0),t("indentUnit",2,jn,!0),t("indentWithTabs",!1),t("smartIndent",!0),t("tabSize",4,function(e){Xn(e),er(e),vn(e)},!0),t("lineSeparator",null,function(e,t){if(e.doc.lineSep=t,t){var r=[],n=e.doc.first;e.doc.iter(function(e){for(var i=0;;){var o=e.text.indexOf(t,i);if(-1==o)break;i=o+t.length,r.push(E(n,o))}n++});for(var i=r.length-1;i>=0;i--)Ei(e.doc,t,r[i],E(r[i].line,r[i].ch+t.length))}}),t("specialChars",/[\u0000-\u001f\u007f-\u009f\u00ad\u061c\u200b-\u200f\u2028\u2029\ufeff]/g,function(e,t,r){e.state.specialChars=new RegExp(t.source+(t.test("\t")?"":"|\t"),"g"),r!=Xs&&e.refresh()}),t("specialCharPlaceholder",at,function(e){return e.refresh()},!0),t("electricChars",!0),t("inputStyle",Tl?"contenteditable":"textarea",function(){throw new Error("inputStyle can not (yet) be changed in a running editor")},!0),t("spellcheck",!1,function(e,t){return e.getInputField().spellcheck=t},!0),t("rtlMoveVisually",!Ol),t("wholeLineUpdateBefore",!0),t("theme","default",function(e){Go(e),Uo(e)},!0),t("keyMap","default",function(e,t,r){var n=uo(t),i=r!=Xs&&uo(r);i&&i.detach&&i.detach(e,n),n.attach&&n.attach(e,i||null)}),t("extraKeys",null),t("configureMouse",null),t("lineWrapping",!1,Ko,!0),t("gutters",[],function(e){Fn(e.options),Uo(e)},!0),t("fixedGutter",!0,function(e,t){e.display.gutters.style.left=t?wr(e.display)+"px":"0",e.refresh()},!0),t("coverGutterNextToScrollbar",!1,function(e){return en(e)},!0),t("scrollbarStyle","native",function(e){rn(e),en(e),e.display.scrollbars.setScrollTop(e.doc.scrollTop),e.display.scrollbars.setScrollLeft(e.doc.scrollLeft)},!0),t("lineNumbers",!1,function(e){Fn(e.options),Uo(e)},!0),t("firstLineNumber",1,Uo,!0),t("lineNumberFormatter",function(e){return e},Uo,!0),t("showCursorWhenSelecting",!1,kr,!0),t("resetSelectionOnContextMenu",!0),t("lineWiseCopyCut",!0),t("pasteLinesPerSelection",!0),t("readOnly",!1,function(e,t){"nocursor"==t&&(Fr(e),e.display.input.blur()),e.display.input.readOnlyChanged(t)}),t("disableInput",!1,function(e,t){t||e.display.input.reset()},!0),t("dragDrop",!0,Vo),t("allowDropFileTypes",null),t("cursorBlinkRate",530),t("cursorScrollMargin",0),t("cursorHeight",1,kr,!0),t("singleCursorHeightPerLine",!0,kr,!0),t("workTime",100),t("workDelay",100),t("flattenSpans",!0,Xn,!0),t("addModeClass",!1,Xn,!0),t("pollInterval",100),t("undoDepth",200,function(e,t){return e.doc.history.undoDepth=t}),t("historyEventDelay",1250),t("viewportMargin",10,function(e){return e.refresh()},!0),t("maxHighlightLength",1e4,Xn,!0),t("moveInputWithCursor",!0,function(e,t){t||e.display.input.resetPosition()}),t("tabindex",null,function(e,t){return e.display.input.getField().tabIndex=t||""}),t("autofocus",null),t("direction","ltr",function(e,t){return e.doc.setDirection(t)},!0)}(jo),function(e){var t=e.optionHandlers,r=e.helpers={};e.prototype={constructor:e,focus:function(){window.focus(),this.display.input.focus()},setOption:function(e,r){var n=this.options,i=n[e];n[e]==r&&"mode"!=e||(n[e]=r,t.hasOwnProperty(e)&&dn(this,t[e])(this,r,i),Te(this,"optionChange",this,e))},getOption:function(e){return this.options[e]},getDoc:function(){return this.doc},addKeyMap:function(e,t){this.state.keyMaps[t?"push":"unshift"](uo(e))},removeKeyMap:function(e){for(var t=this.state.keyMaps,r=0;r<t.length;++r)if(t[r]==e||t[r].name==e)return t.splice(r,1),!0},addOverlay:pn(function(t,r){var n=t.token?t:e.getMode(this.options,t);if(n.startState)throw new Error("Overlays may not be stateful.");m(this.state.overlays,{mode:n,modeSpec:t,opaque:r&&r.opaque,priority:r&&r.priority||0},function(e){return e.priority}),this.state.modeGen++,vn(this)}),removeOverlay:pn(function(e){for(var t=this,r=this.state.overlays,n=0;n<r.length;++n){var i=r[n].modeSpec;if(i==e||"string"==typeof e&&i.name==e)return r.splice(n,1),t.state.modeGen++,void vn(t)}}),indentLine:pn(function(e,t,r){"string"!=typeof t&&"number"!=typeof t&&(t=null==t?this.options.smartIndent?"smart":"prev":t?"add":"subtract"),H(this.doc,e)&&Yo(this,e,t,r)}),indentSelection:pn(function(e){for(var t=this,r=this.doc.sel.ranges,n=-1,i=0;i<r.length;i++){var o=r[i];if(o.empty())o.head.line>n&&(Yo(t,o.head.line,e,!0),n=o.head.line,i==t.doc.sel.primIndex&&jr(t));else{var l=o.from(),s=o.to(),a=Math.max(n,l.line);n=Math.min(t.lastLine(),s.line-(s.ch?0:1))+1;for(var u=a;u<n;++u)Yo(t,u,e);var c=t.doc.sel.ranges;0==l.ch&&r.length==c.length&&c[i].from().ch>0&&gi(t.doc,i,new Ts(l,c[i].to()),Gl)}}}),getTokenAt:function(e,t){return Je(this,e,t)},getLineTokens:function(e,t){return Je(this,E(e),t,!0)},getTokenTypeAt:function(e){e=U(this.doc,e);var t,r=_e(this,M(this.doc,e.line)),n=0,i=(r.length-1)/2,o=e.ch;if(0==o)t=r[2];else for(;;){var l=n+i>>1;if((l?r[2*l-1]:0)>=o)i=l;else{if(!(r[2*l+1]<o)){t=r[2*l+2];break}n=l+1}}var s=t?t.indexOf("overlay "):-1;return s<0?t:0==s?null:t.slice(0,s-1)},getModeAt:function(t){var r=this.doc.mode;return r.innerMode?e.innerMode(r,this.getTokenAt(t).state).mode:r},getHelper:function(e,t){return this.getHelpers(e,t)[0]},getHelpers:function(e,t){var n=this,i=[];if(!r.hasOwnProperty(t))return i;var o=r[t],l=this.getModeAt(e);if("string"==typeof l[t])o[l[t]]&&i.push(o[l[t]]);else if(l[t])for(var s=0;s<l[t].length;s++){var a=o[l[t][s]];a&&i.push(a)}else l.helperType&&o[l.helperType]?i.push(o[l.helperType]):o[l.name]&&i.push(o[l.name]);for(var u=0;u<o._global.length;u++){var c=o._global[u];c.pred(l,n)&&-1==h(i,c.val)&&i.push(c.val)}return i},getStateAfter:function(e,t){var r=this.doc;return e=G(r,null==e?r.first+r.size-1:e),$e(this,e+1,t).state},cursorCoords:function(e,t){var r,n=this.doc.sel.primary();return r=null==e?n.head:"object"==typeof e?U(this.doc,e):e?n.from():n.to(),sr(this,r,t||"page")},charCoords:function(e,t){return lr(this,U(this.doc,e),t||"page")},coordsChar:function(e,t){return e=or(this,e,t||"page"),cr(this,e.left,e.top)},lineAtHeight:function(e,t){return e=or(this,{top:e,left:0},t||"page").top,D(this.doc,e+this.display.viewOffset)},heightAtLine:function(e,t,r){var n,i=!1;if("number"==typeof e){var o=this.doc.first+this.doc.size-1;e<this.doc.first?e=this.doc.first:e>o&&(e=o,i=!0),n=M(this.doc,e)}else n=e;return ir(this,n,{top:0,left:0},t||"page",r||i).top+(i?this.doc.height-ye(n):0)},defaultTextHeight:function(){return mr(this.display)},defaultCharWidth:function(){return yr(this.display)},getViewport:function(){return{from:this.display.viewFrom,to:this.display.viewTo}},addWidget:function(e,t,r,n,i){var o=this.display,l=(e=sr(this,U(this.doc,e))).bottom,s=e.left;if(t.style.position="absolute",t.setAttribute("cm-ignore-events","true"),this.display.input.setUneditable(t),o.sizer.appendChild(t),"over"==n)l=e.top;else if("above"==n||"near"==n){var a=Math.max(o.wrapper.clientHeight,this.doc.height),u=Math.max(o.sizer.clientWidth,o.lineSpace.clientWidth);("above"==n||e.bottom+t.offsetHeight>a)&&e.top>t.offsetHeight?l=e.top-t.offsetHeight:e.bottom+t.offsetHeight<=a&&(l=e.bottom),s+t.offsetWidth>u&&(s=u-t.offsetWidth)}t.style.top=l+"px",t.style.left=t.style.right="","right"==i?(s=o.sizer.clientWidth-t.offsetWidth,t.style.right="0px"):("left"==i?s=0:"middle"==i&&(s=(o.sizer.clientWidth-t.offsetWidth)/2),t.style.left=s+"px"),r&&Ur(this,{left:s,top:l,right:s+t.offsetWidth,bottom:l+t.offsetHeight})},triggerOnKeyDown:pn(Lo),triggerOnKeyPress:pn(Mo),triggerOnKeyUp:To,triggerOnMouseDown:pn(Oo),execCommand:function(e){if(Bs.hasOwnProperty(e))return Bs[e].call(null,this)},triggerElectric:pn(function(e){Zo(this,e)}),findPosH:function(e,t,r,n){var i=this,o=1;t<0&&(o=-1,t=-t);for(var l=U(this.doc,e),s=0;s<t&&!(l=tl(i.doc,l,o,r,n)).hitSide;++s);return l},moveH:pn(function(e,t){var r=this;this.extendSelectionsBy(function(n){return r.display.shift||r.doc.extend||n.empty()?tl(r.doc,n.head,e,t,r.options.rtlMoveVisually):e<0?n.from():n.to()},Vl)}),deleteH:pn(function(e,t){var r=this.doc.sel,n=this.doc;r.somethingSelected()?n.replaceSelection("",null,"+delete"):co(this,function(r){var i=tl(n,r.head,e,t,!1);return e<0?{from:i,to:r.head}:{from:r.head,to:i}})}),findPosV:function(e,t,r,n){var i=this,o=1,l=n;t<0&&(o=-1,t=-t);for(var s=U(this.doc,e),a=0;a<t;++a){var u=sr(i,s,"div");if(null==l?l=u.left:u.left=l,(s=rl(i,u,o,r)).hitSide)break}return s},moveV:pn(function(e,t){var r=this,n=this.doc,i=[],o=!this.display.shift&&!n.extend&&n.sel.somethingSelected();if(n.extendSelectionsBy(function(l){if(o)return e<0?l.from():l.to();var s=sr(r,l.head,"div");null!=l.goalColumn&&(s.left=l.goalColumn),i.push(s.left);var a=rl(r,s,e,t);return"page"==t&&l==n.sel.primary()&&Kr(r,lr(r,a,"div").top-s.top),a},Vl),i.length)for(var l=0;l<n.sel.ranges.length;l++)n.sel.ranges[l].goalColumn=i[l]}),findWordAt:function(e){var t=M(this.doc,e.line).text,r=e.ch,n=e.ch;if(t){var i=this.getHelper(e,"wordChars");"before"!=e.sticky&&n!=t.length||!r?++n:--r;for(var o=t.charAt(r),l=x(o,i)?function(e){return x(e,i)}:/\s/.test(o)?function(e){return/\s/.test(e)}:function(e){return!/\s/.test(e)&&!x(e)};r>0&&l(t.charAt(r-1));)--r;for(;n<t.length&&l(t.charAt(n));)++n}return new Ts(E(e.line,r),E(e.line,n))},toggleOverwrite:function(e){null!=e&&e==this.state.overwrite||((this.state.overwrite=!this.state.overwrite)?s(this.display.cursorDiv,"CodeMirror-overwrite"):Fl(this.display.cursorDiv,"CodeMirror-overwrite"),Te(this,"overwriteToggle",this,this.state.overwrite))},hasFocus:function(){return this.display.input.getField()==l()},isReadOnly:function(){return!(!this.options.readOnly&&!this.doc.cantEdit)},scrollTo:pn(function(e,t){Xr(this,e,t)}),getScrollInfo:function(){var e=this.display.scroller;return{left:e.scrollLeft,top:e.scrollTop,height:e.scrollHeight-zt(this)-this.display.barHeight,width:e.scrollWidth-zt(this)-this.display.barWidth,clientHeight:Bt(this),clientWidth:Rt(this)}},scrollIntoView:pn(function(e,t){null==e?(e={from:this.doc.sel.primary().head,to:null},null==t&&(t=this.options.cursorScrollMargin)):"number"==typeof e?e={from:E(e,0),to:null}:null==e.from&&(e={from:e,to:null}),e.to||(e.to=e.from),e.margin=t||0,null!=e.from.line?Yr(this,e):$r(this,e.from,e.to,e.margin)}),setSize:pn(function(e,t){var r=this,n=function(e){return"number"==typeof e||/^\d+$/.test(String(e))?e+"px":e};null!=e&&(this.display.wrapper.style.width=n(e)),null!=t&&(this.display.wrapper.style.height=n(t)),this.options.lineWrapping&&Jt(this);var i=this.display.viewFrom;this.doc.iter(i,this.display.viewTo,function(e){if(e.widgets)for(var t=0;t<e.widgets.length;t++)if(e.widgets[t].noHScroll){mn(r,i,"widget");break}++i}),this.curOp.forceUpdate=!0,Te(this,"refresh",this)}),operation:function(e){return hn(this,e)},startOperation:function(){return nn(this)},endOperation:function(){return on(this)},refresh:pn(function(){var e=this.display.cachedTextHeight;vn(this),this.curOp.forceUpdate=!0,er(this),Xr(this,this.doc.scrollLeft,this.doc.scrollTop),Wn(this),(null==e||Math.abs(e-mr(this.display))>.5)&&Cr(this),Te(this,"refresh",this)}),swapDoc:pn(function(e){var t=this.doc;return t.cm=null,qn(this,e),er(this),this.display.input.reset(),Xr(this,e.scrollLeft,e.scrollTop),this.curOp.forceScroll=!0,bt(this,"swapDoc",this,t),t}),getInputField:function(){return this.display.input.getField()},getWrapperElement:function(){return this.display.wrapper},getScrollerElement:function(){return this.display.scroller},getGutterElement:function(){return this.display.gutters}},Ae(e),e.registerHelper=function(t,n,i){r.hasOwnProperty(t)||(r[t]=e[t]={_global:[]}),r[t][n]=i},e.registerGlobalHelper=function(t,n,i,o){e.registerHelper(t,n,o),r[t]._global.push({pred:i,val:o})}}(jo);var Js="iter insert remove copy getEditor constructor".split(" ");for(var ea in Ds.prototype)Ds.prototype.hasOwnProperty(ea)&&h(Js,ea)<0&&(jo.prototype[ea]=function(e){return function(){return e.apply(this.doc,arguments)}}(Ds.prototype[ea]));return Ae(Ds),jo.inputStyles={textarea:Qs,contenteditable:Zs},jo.defineMode=function(e){jo.defaults.mode||"null"==e||(jo.defaults.mode=e),Be.apply(this,arguments)},jo.defineMIME=function(e,t){os[e]=t},jo.defineMode("null",function(){return{token:function(e){return e.skipToEnd()}}}),jo.defineMIME("text/plain","null"),jo.defineExtension=function(e,t){jo.prototype[e]=t},jo.defineDocExtension=function(e,t){Ds.prototype[e]=t},jo.fromTextArea=function(e,t){function r(){e.value=a.getValue()}if(t=t?c(t):{},t.value=e.value,!t.tabindex&&e.tabIndex&&(t.tabindex=e.tabIndex),!t.placeholder&&e.placeholder&&(t.placeholder=e.placeholder),null==t.autofocus){var n=l();t.autofocus=n==e||null!=e.getAttribute("autofocus")&&n==document.body}var i;if(e.form&&(Ql(e.form,"submit",r),!t.leaveSubmitMethodAlone)){var o=e.form;i=o.submit;try{var s=o.submit=function(){r(),o.submit=i,o.submit(),o.submit=s}}catch(e){}}t.finishInit=function(t){t.save=r,t.getTextArea=function(){return e},t.toTextArea=function(){t.toTextArea=isNaN,r(),e.parentNode.removeChild(t.getWrapperElement()),e.style.display="",e.form&&(ke(e.form,"submit",r),"function"==typeof e.form.submit&&(e.form.submit=i))}},e.style.display="none";var a=jo(function(t){return e.parentNode.insertBefore(t,e.nextSibling)},t);return a},function(e){e.off=ke,e.on=Ql,e.wheelEventPixels=Pn,e.Doc=Ds,e.splitLines=es,e.countColumn=f,e.findColumn=d,e.isWordChar=w,e.Pass=Bl,e.signal=Te,e.Line=fs,e.changeEnd=Bn,e.scrollbarModel=ws,e.Pos=E,e.cmpPos=P,e.modes=is,e.mimeModes=os,e.resolveMode=Ge,e.getMode=Ue,e.modeExtensions=ls,e.extendMode=Ve,e.copyState=Ke,e.startState=Xe,e.innerMode=je,e.commands=Bs,e.keyMap=Rs,e.keyName=ao,e.isModifierKey=lo,e.lookupKey=oo,e.normalizeKeyMap=io,e.StringStream=ss,e.SharedTextMarker=As,e.TextMarker=Os,e.LineWidget=Ms,e.e_preventDefault=We,e.e_stopPropagation=De,e.e_stop=Fe,e.addClass=s,e.contains=o,e.rmClass=Fl,e.keyNames=Es}(jo),jo.version="5.30.0",jo});
      !function(e){"object"==typeof exports&&"object"==typeof module?e(require("../../lib/codemirror")):"function"==typeof define&&define.amd?define(["../../lib/codemirror"],e):e(CodeMirror)}(function(e){"use strict";function t(e,t,n,r,o,a){this.indented=e,this.column=t,this.type=n,this.info=r,this.align=o,this.prev=a}function n(e,n,r,o){var a=e.indented;return e.context&&"statement"==e.context.type&&"statement"!=r&&(a=e.context.indented),e.context=new t(a,n,r,o,null,e.context)}function r(e){var t=e.context.type;return")"!=t&&"]"!=t&&"}"!=t||(e.indented=e.context.indented),e.context=e.context.prev}function o(e,t,n){return"variable"==t.prevToken||"type"==t.prevToken||(!!/\S(?:[^- ]>|[*\]])\s*$|\*$/.test(e.string.slice(0,n))||(!(!t.typeAtEndOfLine||e.column()!=e.indentation())||void 0))}function a(e){for(;;){if(!e||"top"==e.type)return!0;if("}"==e.type&&"namespace"!=e.prev.info)return!1;e=e.prev}}function i(e){for(var t={},n=e.split(" "),r=0;r<n.length;++r)t[n[r]]=!0;return t}function l(e,t){return"function"==typeof e?e(t):e.propertyIsEnumerable(t)}function s(e,t){if(!t.startOfLine)return!1;for(var n,r=null;n=e.peek();){if("\\"==n&&e.match(/^.$/)){r=s;break}if("/"==n&&e.match(/^\/[\/\*]/,!1))break;e.next()}return t.tokenize=r,"meta"}function c(e,t){return"type"==t.prevToken&&"type"}function u(e){return e.eatWhile(/[\w\.']/),"number"}function d(e,t){if(e.backUp(1),e.match(/(R|u8R|uR|UR|LR)/)){var n=e.match(/"([^\s\\()]{0,16})\(/);return!!n&&(t.cpp11RawStringDelim=n[1],t.tokenize=m,m(e,t))}return e.match(/(u8|u|U|L)/)?!!e.match(/["']/,!1)&&"string":(e.next(),!1)}function f(e){var t=/(\w+)::~?(\w+)$/.exec(e);return t&&t[1]==t[2]}function p(e,t){for(var n;null!=(n=e.next());)if('"'==n&&!e.eat('"')){t.tokenize=null;break}return"string"}function m(e,t){var n=t.cpp11RawStringDelim.replace(/[^\w\s]/g,"\\$&");return e.match(new RegExp(".*?\\)"+n+'"'))?t.tokenize=null:e.skipToEnd(),"string"}function h(t,n){function r(e){if(e)for(var t in e)e.hasOwnProperty(t)&&o.push(t)}"string"==typeof t&&(t=[t]);var o=[];r(n.keywords),r(n.types),r(n.builtin),r(n.atoms),o.length&&(n.helperType=t[0],e.registerHelper("hintWords",t[0],o));for(var a=0;a<t.length;++a)e.defineMIME(t[a],n)}function g(e,t){for(var n=!1;!e.eol();){if(!n&&e.match('"""')){t.tokenize=null;break}n="\\"==e.next()&&!n}return"string"}function y(e){return function(t,n){for(var r,o=!1,a=!1;!t.eol();){if(!e&&!o&&t.match('"')){a=!0;break}if(e&&t.match('"""')){a=!0;break}r=t.next(),!o&&"$"==r&&t.match("{")&&t.skipTo("}"),o=!o&&"\\"==r&&!e}return!a&&e||(n.tokenize=null),"string"}}function x(e){return function(t,n){for(var r,o=!1,a=!1;!t.eol();){if(!o&&t.match('"')&&("single"==e||t.match('""'))){a=!0;break}if(!o&&t.match("``")){w=x(e),a=!0;break}r=t.next(),o="single"==e&&!o&&"\\"==r}return a&&(n.tokenize=null),"string"}}e.defineMode("clike",function(i,s){function c(e,t){var n=e.next();if(S[n]){var r=S[n](e,t);if(!1!==r)return r}if('"'==n||"'"==n)return t.tokenize=u(n),t.tokenize(e,t);if(D.test(n))return p=n,null;if(L.test(n)){if(e.backUp(1),e.match(I))return"number";e.next()}if("/"==n){if(e.eat("*"))return t.tokenize=d,d(e,t);if(e.eat("/"))return e.skipToEnd(),"comment"}if(F.test(n)){for(;!e.match(/^\/[\/*]/,!1)&&e.eat(F););return"operator"}if(e.eatWhile(z),P)for(;e.match(P);)e.eatWhile(z);var o=e.current();return l(x,o)?(l(w,o)&&(p="newstatement"),l(v,o)&&(m=!0),"keyword"):l(b,o)?"type":l(k,o)?(l(w,o)&&(p="newstatement"),"builtin"):l(_,o)?"atom":"variable"}function u(e){return function(t,n){for(var r,o=!1,a=!1;null!=(r=t.next());){if(r==e&&!o){a=!0;break}o=!o&&"\\"==r}return(a||!o&&!C)&&(n.tokenize=null),"string"}}function d(e,t){for(var n,r=!1;n=e.next();){if("/"==n&&r){t.tokenize=null;break}r="*"==n}return"comment"}function f(e,t){s.typeFirstDefinitions&&e.eol()&&a(t.context)&&(t.typeAtEndOfLine=o(e,t,e.pos))}var p,m,h=i.indentUnit,g=s.statementIndentUnit||h,y=s.dontAlignCalls,x=s.keywords||{},b=s.types||{},k=s.builtin||{},w=s.blockKeywords||{},v=s.defKeywords||{},_=s.atoms||{},S=s.hooks||{},C=s.multiLineStrings,T=!1!==s.indentStatements,M=!1!==s.indentSwitch,P=s.namespaceSeparator,D=s.isPunctuationChar||/[\[\]{}\(\),;\:\.]/,L=s.numberStart||/[\d\.]/,I=s.number||/^(?:0x[a-f\d]+|0b[01]+|(?:\d+\.?\d*|\.\d+)(?:e[-+]?\d+)?)(u|ll?|l|f)?/i,F=s.isOperatorChar||/[+\-*&%=<>!?|\/]/,z=s.isIdentifierChar||/[\w\$_\xa1-\uffff]/;return{startState:function(e){return{tokenize:null,context:new t((e||0)-h,0,"top",null,!1),indented:0,startOfLine:!0,prevToken:null}},token:function(e,t){var i=t.context;if(e.sol()&&(null==i.align&&(i.align=!1),t.indented=e.indentation(),t.startOfLine=!0),e.eatSpace())return f(e,t),null;p=m=null;var l=(t.tokenize||c)(e,t);if("comment"==l||"meta"==l)return l;if(null==i.align&&(i.align=!0),";"==p||":"==p||","==p&&e.match(/^\s*(?:\/\/.*)?$/,!1))for(;"statement"==t.context.type;)r(t);else if("{"==p)n(t,e.column(),"}");else if("["==p)n(t,e.column(),"]");else if("("==p)n(t,e.column(),")");else if("}"==p){for(;"statement"==i.type;)i=r(t);for("}"==i.type&&(i=r(t));"statement"==i.type;)i=r(t)}else p==i.type?r(t):T&&(("}"==i.type||"top"==i.type)&&";"!=p||"statement"==i.type&&"newstatement"==p)&&n(t,e.column(),"statement",e.current());if("variable"==l&&("def"==t.prevToken||s.typeFirstDefinitions&&o(e,t,e.start)&&a(t.context)&&e.match(/^\s*\(/,!1))&&(l="def"),S.token){var u=S.token(e,t,l);void 0!==u&&(l=u)}return"def"==l&&!1===s.styleDefs&&(l="variable"),t.startOfLine=!1,t.prevToken=m?"def":l||p,f(e,t),l},indent:function(t,n){if(t.tokenize!=c&&null!=t.tokenize||t.typeAtEndOfLine)return e.Pass;var r=t.context,o=n&&n.charAt(0);if("statement"==r.type&&"}"==o&&(r=r.prev),s.dontIndentStatements)for(;"statement"==r.type&&s.dontIndentStatements.test(r.info);)r=r.prev;if(S.indent){var a=S.indent(t,r,n);if("number"==typeof a)return a}var i=o==r.type,l=r.prev&&"switch"==r.prev.info;if(s.allmanIndentation&&/[{(]/.test(o)){for(;"top"!=r.type&&"}"!=r.type;)r=r.prev;return r.indented}return"statement"==r.type?r.indented+("{"==o?0:g):!r.align||y&&")"==r.type?")"!=r.type||i?r.indented+(i?0:h)+(i||!l||/^(?:case|default)\b/.test(n)?0:h):r.indented+g:r.column+(i?0:1)},electricInput:M?/^\s*(?:case .*?:|default:|\{\}?|\})$/:/^\s*[{}]$/,blockCommentStart:"/*",blockCommentEnd:"*/",lineComment:"//",fold:"brace"}});var b="auto if break case register continue return default do sizeof static else struct switch extern typedef union for goto while enum const volatile",k="int long char short double float unsigned signed void size_t ptrdiff_t";h(["text/x-csrc","text/x-c","text/x-chdr"],{name:"clike",keywords:i(b),types:i(k+" bool _Complex _Bool float_t double_t intptr_t intmax_t int8_t int16_t int32_t int64_t uintptr_t uintmax_t uint8_t uint16_t uint32_t uint64_t"),blockKeywords:i("case do else for if switch while struct"),defKeywords:i("struct"),typeFirstDefinitions:!0,atoms:i("null true false"),hooks:{"#":s,"*":c},modeProps:{fold:["brace","include"]}}),h(["text/x-c++src","text/x-c++hdr"],{name:"clike",keywords:i(b+" asm dynamic_cast namespace reinterpret_cast try explicit new static_cast typeid catch operator template typename class friend private this using const_cast inline public throw virtual delete mutable protected alignas alignof constexpr decltype nullptr noexcept thread_local final static_assert override"),types:i(k+" bool wchar_t"),blockKeywords:i("catch class do else finally for if struct switch try while"),defKeywords:i("class namespace struct enum union"),typeFirstDefinitions:!0,atoms:i("true false null"),dontIndentStatements:/^template$/,isIdentifierChar:/[\w\$_~\xa1-\uffff]/,hooks:{"#":s,"*":c,u:d,U:d,L:d,R:d,0:u,1:u,2:u,3:u,4:u,5:u,6:u,7:u,8:u,9:u,token:function(e,t,n){if("variable"==n&&"("==e.peek()&&(";"==t.prevToken||null==t.prevToken||"}"==t.prevToken)&&f(e.current()))return"def"}},namespaceSeparator:"::",modeProps:{fold:["brace","include"]}}),h("text/x-java",{name:"clike",keywords:i("abstract assert break case catch class const continue default do else enum extends final finally float for goto if implements import instanceof interface native new package private protected public return static strictfp super switch synchronized this throw throws transient try volatile while @interface"),types:i("byte short int long float double boolean char void Boolean Byte Character Double Float Integer Long Number Object Short String StringBuffer StringBuilder Void"),blockKeywords:i("catch class do else finally for if switch try while"),defKeywords:i("class interface package enum @interface"),typeFirstDefinitions:!0,atoms:i("true false null"),number:/^(?:0x[a-f\d_]+|0b[01_]+|(?:[\d_]+\.?\d*|\.\d+)(?:e[-+]?[\d_]+)?)(u|ll?|l|f)?/i,hooks:{"@":function(e){return!e.match("interface",!1)&&(e.eatWhile(/[\w\$_]/),"meta")}},modeProps:{fold:["brace","import"]}}),h("text/x-csharp",{name:"clike",keywords:i("abstract as async await base break case catch checked class const continue default delegate do else enum event explicit extern finally fixed for foreach goto if implicit in interface internal is lock namespace new operator out override params private protected public readonly ref return sealed sizeof stackalloc static struct switch this throw try typeof unchecked unsafe using virtual void volatile while add alias ascending descending dynamic from get global group into join let orderby partial remove select set value var yield"),types:i("Action Boolean Byte Char DateTime DateTimeOffset Decimal Double Func Guid Int16 Int32 Int64 Object SByte Single String Task TimeSpan UInt16 UInt32 UInt64 bool byte char decimal double short int long object sbyte float string ushort uint ulong"),blockKeywords:i("catch class do else finally for foreach if struct switch try while"),defKeywords:i("class interface namespace struct var"),typeFirstDefinitions:!0,atoms:i("true false null"),hooks:{"@":function(e,t){return e.eat('"')?(t.tokenize=p,p(e,t)):(e.eatWhile(/[\w\$_]/),"meta")}}}),h("text/x-scala",{name:"clike",keywords:i("abstract case catch class def do else extends final finally for forSome if implicit import lazy match new null object override package private protected return sealed super this throw trait try type val var while with yield _ assert assume require print println printf readLine readBoolean readByte readShort readChar readInt readLong readFloat readDouble"),types:i("AnyVal App Application Array BufferedIterator BigDecimal BigInt Char Console Either Enumeration Equiv Error Exception Fractional Function IndexedSeq Int Integral Iterable Iterator List Map Numeric Nil NotNull Option Ordered Ordering PartialFunction PartialOrdering Product Proxy Range Responder Seq Serializable Set Specializable Stream StringBuilder StringContext Symbol Throwable Traversable TraversableOnce Tuple Unit Vector Boolean Byte Character CharSequence Class ClassLoader Cloneable Comparable Compiler Double Exception Float Integer Long Math Number Object Package Pair Process Runtime Runnable SecurityManager Short StackTraceElement StrictMath String StringBuffer System Thread ThreadGroup ThreadLocal Throwable Triple Void"),multiLineStrings:!0,blockKeywords:i("catch class enum do else finally for forSome if match switch try while"),defKeywords:i("class enum def object package trait type val var"),atoms:i("true false null"),indentStatements:!1,indentSwitch:!1,isOperatorChar:/[+\-*&%=<>!?|\/#:@]/,hooks:{"@":function(e){return e.eatWhile(/[\w\$_]/),"meta"},'"':function(e,t){return!!e.match('""')&&(t.tokenize=g,t.tokenize(e,t))},"'":function(e){return e.eatWhile(/[\w\$_\xa1-\uffff]/),"atom"},"=":function(e,n){var r=n.context;return!("}"!=r.type||!r.align||!e.eat(">"))&&(n.context=new t(r.indented,r.column,r.type,r.info,null,r.prev),"operator")}},modeProps:{closeBrackets:{triples:'"'}}}),h("text/x-kotlin",{name:"clike",keywords:i("package as typealias class interface this super val var fun for is in This throw return break continue object if else while do try when !in !is as? file import where by get set abstract enum open inner override private public internal protected catch finally out final vararg reified dynamic companion constructor init sealed field property receiver param sparam lateinit data inline noinline tailrec external annotation crossinline const operator infix suspend"),types:i("Boolean Byte Character CharSequence Class ClassLoader Cloneable Comparable Compiler Double Exception Float Integer Long Math Number Object Package Pair Process Runtime Runnable SecurityManager Short StackTraceElement StrictMath String StringBuffer System Thread ThreadGroup ThreadLocal Throwable Triple Void"),intendSwitch:!1,indentStatements:!1,multiLineStrings:!0,number:/^(?:0x[a-f\d_]+|0b[01_]+|(?:[\d_]+\.?\d*|\.\d+)(?:e[-+]?[\d_]+)?)(u|ll?|l|f)?/i,blockKeywords:i("catch class do else finally for if where try while enum"),defKeywords:i("class val var object package interface fun"),atoms:i("true false null this"),hooks:{'"':function(e,t){return t.tokenize=y(e.match('""')),t.tokenize(e,t)}},modeProps:{closeBrackets:{triples:'"'}}}),h(["x-shader/x-vertex","x-shader/x-fragment"],{name:"clike",keywords:i("sampler1D sampler2D sampler3D samplerCube sampler1DShadow sampler2DShadow const attribute uniform varying break continue discard return for while do if else struct in out inout"),types:i("float int bool void vec2 vec3 vec4 ivec2 ivec3 ivec4 bvec2 bvec3 bvec4 mat2 mat3 mat4"),blockKeywords:i("for while do if else struct"),builtin:i("radians degrees sin cos tan asin acos atan pow exp log exp2 sqrt inversesqrt abs sign floor ceil fract mod min max clamp mix step smoothstep length distance dot cross normalize ftransform faceforward reflect refract matrixCompMult lessThan lessThanEqual greaterThan greaterThanEqual equal notEqual any all not texture1D texture1DProj texture1DLod texture1DProjLod texture2D texture2DProj texture2DLod texture2DProjLod texture3D texture3DProj texture3DLod texture3DProjLod textureCube textureCubeLod shadow1D shadow2D shadow1DProj shadow2DProj shadow1DLod shadow2DLod shadow1DProjLod shadow2DProjLod dFdx dFdy fwidth noise1 noise2 noise3 noise4"),atoms:i("true false gl_FragColor gl_SecondaryColor gl_Normal gl_Vertex gl_MultiTexCoord0 gl_MultiTexCoord1 gl_MultiTexCoord2 gl_MultiTexCoord3 gl_MultiTexCoord4 gl_MultiTexCoord5 gl_MultiTexCoord6 gl_MultiTexCoord7 gl_FogCoord gl_PointCoord gl_Position gl_PointSize gl_ClipVertex gl_FrontColor gl_BackColor gl_FrontSecondaryColor gl_BackSecondaryColor gl_TexCoord gl_FogFragCoord gl_FragCoord gl_FrontFacing gl_FragData gl_FragDepth gl_ModelViewMatrix gl_ProjectionMatrix gl_ModelViewProjectionMatrix gl_TextureMatrix gl_NormalMatrix gl_ModelViewMatrixInverse gl_ProjectionMatrixInverse gl_ModelViewProjectionMatrixInverse gl_TexureMatrixTranspose gl_ModelViewMatrixInverseTranspose gl_ProjectionMatrixInverseTranspose gl_ModelViewProjectionMatrixInverseTranspose gl_TextureMatrixInverseTranspose gl_NormalScale gl_DepthRange gl_ClipPlane gl_Point gl_FrontMaterial gl_BackMaterial gl_LightSource gl_LightModel gl_FrontLightModelProduct gl_BackLightModelProduct gl_TextureColor gl_EyePlaneS gl_EyePlaneT gl_EyePlaneR gl_EyePlaneQ gl_FogParameters gl_MaxLights gl_MaxClipPlanes gl_MaxTextureUnits gl_MaxTextureCoords gl_MaxVertexAttribs gl_MaxVertexUniformComponents gl_MaxVaryingFloats gl_MaxVertexTextureImageUnits gl_MaxTextureImageUnits gl_MaxFragmentUniformComponents gl_MaxCombineTextureImageUnits gl_MaxDrawBuffers"),indentSwitch:!1,hooks:{"#":s},modeProps:{fold:["brace","include"]}}),h("text/x-nesc",{name:"clike",keywords:i(b+"as atomic async call command component components configuration event generic implementation includes interface module new norace nx_struct nx_union post provides signal task uses abstract extends"),types:i(k),blockKeywords:i("case do else for if switch while struct"),atoms:i("null true false"),hooks:{"#":s},modeProps:{fold:["brace","include"]}}),h("text/x-objectivec",{name:"clike",keywords:i(b+"inline restrict _Bool _Complex _Imaginary BOOL Class bycopy byref id IMP in inout nil oneway out Protocol SEL self super atomic nonatomic retain copy readwrite readonly"),types:i(k),atoms:i("YES NO NULL NILL ON OFF true false"),hooks:{"@":function(e){return e.eatWhile(/[\w\$]/),"keyword"},"#":s,indent:function(e,t,n){if("statement"==t.type&&/^@\w/.test(n))return t.indented}},modeProps:{fold:"brace"}}),h("text/x-squirrel",{name:"clike",keywords:i("base break clone continue const default delete enum extends function in class foreach local resume return this throw typeof yield constructor instanceof static"),types:i(k),blockKeywords:i("case catch class else for foreach if switch try while"),defKeywords:i("function local class"),typeFirstDefinitions:!0,atoms:i("true false null"),hooks:{"#":s},modeProps:{fold:["brace","include"]}});var w=null;h("text/x-ceylon",{name:"clike",keywords:i("abstracts alias assembly assert assign break case catch class continue dynamic else exists extends finally for function given if import in interface is let module new nonempty object of out outer package return satisfies super switch then this throw try value void while"),types:function(e){var t=e.charAt(0);return t===t.toUpperCase()&&t!==t.toLowerCase()},blockKeywords:i("case catch class dynamic else finally for function if interface module new object switch try while"),defKeywords:i("class dynamic function interface module object package value"),builtin:i("abstract actual aliased annotation by default deprecated doc final formal late license native optional sealed see serializable shared suppressWarnings tagged throws variable"),isPunctuationChar:/[\[\]{}\(\),;\:\.`]/,isOperatorChar:/[+\-*&%=<>!?|^~:\/]/,numberStart:/[\d#$]/,number:/^(?:#[\da-fA-F_]+|\$[01_]+|[\d_]+[kMGTPmunpf]?|[\d_]+\.[\d_]+(?:[eE][-+]?\d+|[kMGTPmunpf]|)|)/i,multiLineStrings:!0,typeFirstDefinitions:!0,atoms:i("true false null larger smaller equal empty finished"),indentSwitch:!1,styleDefs:!1,hooks:{"@":function(e){return e.eatWhile(/[\w\$_]/),"meta"},'"':function(e,t){return t.tokenize=x(e.match('""')?"triple":"single"),t.tokenize(e,t)},"`":function(e,t){return!(!w||!e.match("`"))&&(t.tokenize=w,w=null,t.tokenize(e,t))},"'":function(e){return e.eatWhile(/[\w\$_\xa1-\uffff]/),"atom"},token:function(e,t,n){if(("variable"==n||"type"==n)&&"."==t.prevToken)return"variable-2"}},modeProps:{fold:["brace","import"],closeBrackets:{triples:'"'}}})});
      // -------------------------------------------------------------------------
//  Part of the CodeChecker project, under the Apache License v2.0 with
//  LLVM Exceptions. See LICENSE for license information.
//  SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
// -------------------------------------------------------------------------

var BugViewer = {
  _files : [],
  _reports : [],
  _lineWidgets : [],
  _navigationMenuItems : [],
  _sourceFileData : null,
  _currentReport : null,
  _lastBugEvent  : null,

  init : function (files, reports) {
    this._files = files;
    this._reports = reports;

    this.initEscapeChars();
  },

  initEscapeChars : function () {
    this.escapeChars = {
      ' ' : 'nbsp',
      '<' : 'lt',
      '>' : 'gt',
      '"' : 'quot',
      '&' : 'amp'
    };

    var regexString = '[';
    for (var key in this.escapeChars) {
      regexString += key;
    }
    regexString += ']';

    this.escapeRegExp = new RegExp( regexString, 'g');
  },

  escapeHTML : function (str) {
    var that = this;

    return str.replace(this.escapeRegExp, function (m) {
      return '&' + that.escapeChars[m] + ';';
    });
  },

  initByUrl : function () {
    if (!this._reports) return;

    var state = {};
    window.location.hash.substr(1).split('&').forEach(function (s) {
      var parts = s.split('=');
      state[parts[0]] = parts[1];
    });

    for (var key in this._reports) {
      var report = this._reports[key];
      if (report.reportHash === state['reportHash']) {
        this.navigate(report);
        return;
      }
    }

    this.navigate(this._reports[0]);
  },

  create : function () {
    this._content = document.getElementById('editor-wrapper');
    this._filepath = document.getElementById('file-path');
    this._checkerName = document.getElementById('checker-name');
    this._reviewStatusWrapper =
      document.getElementById('review-status-wrapper');
    this._reviewStatus = document.getElementById('review-status');
    this._editor = document.getElementById('editor');

    this._codeMirror = CodeMirror(this._editor, {
      mode: 'text/x-c++src',
      matchBrackets : true,
      lineNumbers : true,
      readOnly : true,
      foldGutter : true,
      extraKeys : {},
      viewportMargin : 100
    });

    this._createNavigationMenu();
  },

  navigate : function (report, item) {
    if (!item) {
      var items = this._navigationMenuItems.filter(function (navItem) {
        return navItem.report.reportHash === report.reportHash;
      });

      if (!items.length) return;

      item = items[0].widget;
    }

    this._selectedReport.classList.remove('active');
    this._selectedReport = item;
    this._selectedReport.classList.add('active');
    this.setReport(report);
  },

  _createNavigationMenu : function () {
    var that = this;

    var nav = document.getElementById('report-nav');
    var list = document.createElement('ul');
    this._reports.forEach(function (report) {
      var events = report['events'];
      var lastBugEvent = events[events.length - 1];
      var item = document.createElement('li');

      var severity = document.createElement('i');
      severity.className = 'severity-' + report.severity.toLowerCase();

      item.appendChild(severity);
      item.appendChild(document.createTextNode(lastBugEvent.message));

      item.addEventListener('click', function () {
        that.navigate(report, item);
      })
      list.appendChild(item);
      that._navigationMenuItems.push({ report : report, widget : item });
    });

    if (!this._selectedReport && list.childNodes.length) {
      this._selectedReport = list.childNodes[0];
      this._selectedReport.classList.add('active');
    }

    nav.appendChild(list);
  },

  setReport : function (report) {
    this._currentReport = report;
    var events = report['events'];
    var lastBugEvent = events[events.length - 1];
    this.setCurrentBugEvent(lastBugEvent, events.length - 1);
    this.setCheckerName(report.checkerName);
    this.setReviewStatus(report.reviewStatus);

    window.location.hash = '#reportHash=' + report.reportHash;
  },

  setCurrentBugEvent : function (event, idx) {
    this._currentBugEvent = event;
    this.setSourceFileData(this._files[event.location.file]);
    this.drawBugPath();

    this.jumpTo(event.location.line, 0);
    this.highlightBugEvent(event, idx);
  },

  highlightBugEvent : function (event, idx) {
    this._lineWidgets.forEach(function (widget) {
      var lineIdx = widget.node.getAttribute('idx');
      if (parseInt(lineIdx) === idx) {
        widget.node.classList.add('current');
      }
    });
  },

  setCheckerName : function (checkerName) {
    this._checkerName.innerHTML = checkerName;
  },

  setReviewStatus : function (status) {
    if (status) {
      var className =
        'review-status-' + status.toLowerCase().split(' ').join('-');
      this._reviewStatus.className = "review-status " + className;

      this._reviewStatus.innerHTML = status;
      this._reviewStatusWrapper.style.display = 'block';
    } else {
      this._reviewStatusWrapper.style.display = 'none';
    }
  },

  setSourceFileData : function (file) {
    if (this._sourceFileData && file.id === this._sourceFileData.id) {
      return;
    }

    this._sourceFileData = file;
    this._filepath.innerHTML = file.path;
    this._codeMirror.doc.setValue(file.content);
    this._refresh();
  },

  _refresh : function () {
    var that = this;
    setTimeout(function () {
      var fullHeight = parseInt(that._content.clientHeight);
      var headerHeight = that._filepath.clientHeight;

      that._codeMirror.setSize('auto', fullHeight - headerHeight);
      that._codeMirror.refresh();
    }, 200);
  },

  clearBubbles : function () {
    this._lineWidgets.forEach(function (widget) { widget.clear(); });
    this._lineWidgets = [];
  },

  getMessage : function (event, kind) {
    if (kind === 'macro') {
      var name = 'macro expansion' + (event.name ? ': ' + event.name : '');

      return '<span class="tag macro">' + name + '</span>'
        + this.escapeHTML(event.expansion).replace(/(?:\r\n|\r|\n)/g, '<br>');
    } else if (kind === 'note') {
      return '<span class="tag note">note</span>'
        +  this.escapeHTML(event.message).replace(/(?:\r\n|\r|\n)/g, '<br>');
    }
  },

  addExtraPathEvents : function (events, kind) {
    var that = this;

    if (!events) {
      return;
    }

    events.forEach(function (event) {
      if (event.location.file !== that._currentBugEvent.location.file) {
        return;
      }

      var left =
        that._codeMirror.defaultCharWidth() * event.location.col + 'px';

      var element = document.createElement('div');
      element.setAttribute('style', 'margin-left: ' + left);
      element.setAttribute('class', 'check-msg ' + kind);

      var msg = document.createElement('span');
      msg.innerHTML = that.getMessage(event, kind);
      element.appendChild(msg);

      that._lineWidgets.push(that._codeMirror.addLineWidget(
        event.location.line - 1, element));
    });
  },

  drawBugPath : function () {
    var that = this;

    this.clearBubbles();

    this.addExtraPathEvents(this._currentReport.macros, 'macro');
    this.addExtraPathEvents(this._currentReport.notes, 'note');

    // Processing bug path events.
    var currentEvents = this._currentReport.events;
    currentEvents.forEach(function (event, step) {
      if (event.location.file !== that._currentBugEvent.location.file)
        return;

      var left =
        that._codeMirror.defaultCharWidth() * event.location.col + 'px';
      var type = step === currentEvents.length - 1 ? 'error' : 'info';

      var element = document.createElement('div');
      element.setAttribute('style', 'margin-left: ' + left);
      element.setAttribute('class', 'check-msg ' + type);
      element.setAttribute('idx', step);

      var enumeration = document.createElement('span');
      enumeration.setAttribute('class', 'checker-enum ' + type);
      enumeration.innerHTML = step + 1;

      if (currentEvents.length > 1)
        element.appendChild(enumeration);

      var prevBugEvent = step - 1;
      if (step > 0) {
        var prevBug = document.createElement('span');
        prevBug.setAttribute('class', 'arrow left-arrow');
        prevBug.addEventListener('click', function () {
          var event = currentEvents[prevBugEvent];
          that.setCurrentBugEvent(event, prevBugEvent);
        });
        element.appendChild(prevBug);
      }

      var msg = document.createElement('span');
      msg.innerHTML = that.escapeHTML(event.message)
        .replace(/(?:\r\n|\r|\n)/g, '<br>');

      element.appendChild(msg);

      var nextBugEvent = step + 1;
      if (nextBugEvent < currentEvents.length) {
        var nextBug = document.createElement('span');
        nextBug.setAttribute('class', 'arrow right-arrow');
        nextBug.addEventListener('click', function () {
          var event = currentEvents[nextBugEvent];
          that.setCurrentBugEvent(event, nextBugEvent);
        });
        element.appendChild(nextBug);
      }


      that._lineWidgets.push(that._codeMirror.addLineWidget(
        event.location.line - 1, element));
    });
  },

  jumpTo : function (line, column) {
    var that = this;

    setTimeout(function () {
      var selPosPixel
        = that._codeMirror.charCoords({ line : line, ch : column }, 'local');
      var editorSize = {
        width  : that._editor.clientWidth,
        height : that._editor.clientHeight
      };

      that._codeMirror.scrollIntoView({
        top    : selPosPixel.top - 100,
        bottom : selPosPixel.top + editorSize.height - 150,
        left   : selPosPixel.left < editorSize.width - 100
               ? 0
               : selPosPixel.left - 50,
        right  : selPosPixel.left < editorSize.width - 100
               ? 10
               : selPosPixel.left + editorSize.width - 100
      });
    }, 0);
  }
}


      var data = {"files": {"1": {"id": 1, "path": "/home/runner/work/testcc/testcc/retdec/ext/json11/json11.hpp", "content": "/* json11\n *\n * json11 is a tiny JSON library for C++11, providing JSON parsing and serialization.\n *\n * The core object provided by the library is json11::Json. A Json object represents any JSON\n * value: null, bool, number (int or double), string (std::string), array (std::vector), or\n * object (std::map).\n *\n * Json objects act like values: they can be assigned, copied, moved, compared for equality or\n * order, etc. There are also helper methods Json::dump, to serialize a Json to a string, and\n * Json::parse (static) to parse a std::string as a Json object.\n *\n * Internally, the various types of Json object are represented by the JsonValue class\n * hierarchy.\n *\n * A note on numbers - JSON specifies the syntax of number formatting but not its semantics,\n * so some JSON implementations distinguish between integers and floating-point numbers, while\n * some don't. In json11, we choose the latter. Because some JSON implementations (namely\n * JavaScript itself) treat all numbers as the same type, distinguishing the two leads\n * to JSON that will be *silently* changed by a round-trip through those implementations.\n * Dangerous! To avoid that risk, json11 stores all numbers as double internally, but also\n * provides integer helpers.\n *\n * Fortunately, double-precision IEEE754 ('double') can precisely store any integer in the\n * range +/-2^53, which includes every 'int' on most systems. (Timestamps often use int64\n * or long long to avoid the Y2038K problem; a double storing microseconds since some epoch\n * will be exact for +/- 275 years.)\n */\n\n/* Copyright (c) 2013 Dropbox, Inc.\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n * THE SOFTWARE.\n */\n\n#pragma once\n\n#include <string>\n#include <vector>\n#include <map>\n#include <memory>\n#include <initializer_list>\n\n#ifdef _MSC_VER\n    #if _MSC_VER <= 1800 // VS 2013\n        #ifndef noexcept\n            #define noexcept throw()\n        #endif\n\n        #ifndef snprintf\n            #define snprintf _snprintf_s\n        #endif\n    #endif\n#endif\n\nnamespace json11 {\n\nenum JsonParse {\n    STANDARD, COMMENTS\n};\n\nclass JsonValue;\n\nclass Json final {\npublic:\n    // Types\n    enum Type {\n        NUL, NUMBER, BOOL, STRING, ARRAY, OBJECT\n    };\n\n    // Array and object typedefs\n    typedef std::vector<Json> array;\n    typedef std::map<std::string, Json> object;\n\n    // Constructors for the various types of JSON value.\n    Json() noexcept;                // NUL\n    Json(std::nullptr_t) noexcept;  // NUL\n    Json(double value);             // NUMBER\n    Json(int value);                // NUMBER\n    Json(bool value);               // BOOL\n    Json(const std::string &value); // STRING\n    Json(std::string &&value);      // STRING\n    Json(const char * value);       // STRING\n    Json(const array &values);      // ARRAY\n    Json(array &&values);           // ARRAY\n    Json(const object &values);     // OBJECT\n    Json(object &&values);          // OBJECT\n\n    // Implicit constructor: anything with a to_json() function.\n    template <class T, class = decltype(&T::to_json)>\n    Json(const T & t) : Json(t.to_json()) {}\n\n    // Implicit constructor: map-like objects (std::map, std::unordered_map, etc)\n    template <class M, typename std::enable_if<\n        std::is_constructible<std::string, typename M::key_type>::value\n        && std::is_constructible<Json, typename M::mapped_type>::value,\n            int>::type = 0>\n    Json(const M & m) : Json(object(m.begin(), m.end())) {}\n\n    // Implicit constructor: vector-like objects (std::list, std::vector, std::set, etc)\n    template <class V, typename std::enable_if<\n        std::is_constructible<Json, typename V::value_type>::value,\n            int>::type = 0>\n    Json(const V & v) : Json(array(v.begin(), v.end())) {}\n\n    // This prevents Json(some_pointer) from accidentally producing a bool. Use\n    // Json(bool(some_pointer)) if that behavior is desired.\n    Json(void *) = delete;\n\n    // Accessors\n    Type type() const;\n\n    bool is_null()   const { return type() == NUL; }\n    bool is_number() const { return type() == NUMBER; }\n    bool is_bool()   const { return type() == BOOL; }\n    bool is_string() const { return type() == STRING; }\n    bool is_array()  const { return type() == ARRAY; }\n    bool is_object() const { return type() == OBJECT; }\n\n    // Return the enclosed value if this is a number, 0 otherwise. Note that json11 does not\n    // distinguish between integer and non-integer numbers - number_value() and int_value()\n    // can both be applied to a NUMBER-typed object.\n    double number_value() const;\n    int int_value() const;\n\n    // Return the enclosed value if this is a boolean, false otherwise.\n    bool bool_value() const;\n    // Return the enclosed string if this is a string, \"\" otherwise.\n    const std::string &string_value() const;\n    // Return the enclosed std::vector if this is an array, or an empty vector otherwise.\n    const array &array_items() const;\n    // Return the enclosed std::map if this is an object, or an empty map otherwise.\n    const object &object_items() const;\n\n    // Return a reference to arr[i] if this is an array, Json() otherwise.\n    const Json & operator[](size_t i) const;\n    // Return a reference to obj[key] if this is an object, Json() otherwise.\n    const Json & operator[](const std::string &key) const;\n\n    // Serialize.\n    void dump(std::string &out) const;\n    std::string dump() const {\n        std::string out;\n        dump(out);\n        return out;\n    }\n\n    // Parse. If parse fails, return Json() and assign an error message to err.\n    static Json parse(const std::string & in,\n                      std::string & err,\n                      JsonParse strategy = JsonParse::STANDARD);\n    static Json parse(const char * in,\n                      std::string & err,\n                      JsonParse strategy = JsonParse::STANDARD) {\n        if (in) {\n            return parse(std::string(in), err, strategy);\n        } else {\n            err = \"null input\";\n            return nullptr;\n        }\n    }\n    // Parse multiple objects, concatenated or separated by whitespace\n    static std::vector<Json> parse_multi(\n        const std::string & in,\n        std::string::size_type & parser_stop_pos,\n        std::string & err,\n        JsonParse strategy = JsonParse::STANDARD);\n\n    static inline std::vector<Json> parse_multi(\n        const std::string & in,\n        std::string & err,\n        JsonParse strategy = JsonParse::STANDARD) {\n        std::string::size_type parser_stop_pos;\n        return parse_multi(in, parser_stop_pos, err, strategy);\n    }\n\n    bool operator== (const Json &rhs) const;\n    bool operator<  (const Json &rhs) const;\n    bool operator!= (const Json &rhs) const { return !(*this == rhs); }\n    bool operator<= (const Json &rhs) const { return !(rhs < *this); }\n    bool operator>  (const Json &rhs) const { return  (rhs < *this); }\n    bool operator>= (const Json &rhs) const { return !(*this < rhs); }\n\n    /* has_shape(types, err)\n     *\n     * Return true if this is a JSON object and, for each item in types, has a field of\n     * the given type. If not, return false and set err to a descriptive message.\n     */\n    typedef std::initializer_list<std::pair<std::string, Type>> shape;\n    bool has_shape(const shape & types, std::string & err) const;\n\nprivate:\n    std::shared_ptr<JsonValue> m_ptr;\n};\n\n// Internal class hierarchy - JsonValue objects are not exposed to users of this API.\nclass JsonValue {\nprotected:\n    friend class Json;\n    friend class JsonInt;\n    friend class JsonDouble;\n    virtual Json::Type type() const = 0;\n    virtual bool equals(const JsonValue * other) const = 0;\n    virtual bool less(const JsonValue * other) const = 0;\n    virtual void dump(std::string &out) const = 0;\n    virtual double number_value() const;\n    virtual int int_value() const;\n    virtual bool bool_value() const;\n    virtual const std::string &string_value() const;\n    virtual const Json::array &array_items() const;\n    virtual const Json &operator[](size_t i) const;\n    virtual const Json::object &object_items() const;\n    virtual const Json &operator[](const std::string &key) const;\n    virtual ~JsonValue() {}\n};\n\n} // namespace json11\n"}, "3": {"id": 3, "path": "/home/runner/work/testcc/testcc/retdec/ext/yahttp/yahttp/cookie.hpp", "content": "namespace YaHTTP {\n  /*! Implements a single cookie */\n  class Cookie {\n  public:\n     Cookie() {\n       secure = false;\n       httponly = false;\n       name = value = \"\";\n       expires = DateTime();\n     }; //!< Set the cookie to empty value\n\n     Cookie(const Cookie &rhs) {\n       name = rhs.name;\n       value = rhs.value;\n       domain = rhs.domain;\n       path = rhs.path;\n       secure = rhs.secure;\n       httponly = rhs.httponly;\n       expires = rhs.expires;\n     }; //<! Copy cookie values\n\n     Cookie& operator=(const Cookie &rhs) {\n       name = rhs.name;\n       value = rhs.value;\n       domain = rhs.domain;\n       path = rhs.path;\n       secure = rhs.secure;\n       httponly = rhs.httponly;\n       expires = rhs.expires;\n       return *this;\n     }\n\n     DateTime expires; /*!< Expiration date */\n     std::string domain; /*!< Domain where cookie is valid */\n     std::string path; /*!< Path where the cookie is valid */\n     bool httponly; /*!< Whether the cookie is for server use only */\n     bool secure; /*!< Whether the cookie is for HTTPS only */\n \n     std::string name; /*!< Cookie name */\n     std::string value; /*!< Cookie value */\n\n     std::string str() const {\n       std::ostringstream oss;\n       oss << YaHTTP::Utility::encodeURL(name) << \"=\" << YaHTTP::Utility::encodeURL(value);\n\n       if (expires.isSet) \n         oss << \"; expires=\" << expires.cookie_str();\n       if (domain.size()>0)\n         oss << \"; domain=\" << domain;\n       if (path.size()>0)\n         oss << \"; path=\" << path;\n       if (secure)\n         oss << \"; secure\";\n       if (httponly)\n         oss << \"; httpOnly\";\n       return oss.str();\n     }; //!< Stringify the cookie\n  };\n\n  /*! Implements a Cookie jar for storing multiple cookies */\n  class CookieJar {\n    public:\n    std::map<std::string, Cookie, ASCIICINullSafeComparator> cookies;  //<! cookie container\n  \n    CookieJar() {}; //<! constructs empty cookie jar\n    CookieJar(const CookieJar & rhs) {\n      this->cookies = rhs.cookies;\n    } //<! copy cookies from another cookie jar\n    CookieJar& operator=(const CookieJar & rhs) = default;\n  \n    void clear() {\n      this->cookies.clear();\n    }\n\n    void keyValuePair(const std::string &keyvalue, std::string &key, std::string &value) {\n      size_t pos;\n      pos = keyvalue.find(\"=\");\n      if (pos == std::string::npos) throw \"Not a Key-Value pair (cookie)\";\n      key = std::string(keyvalue.begin(), keyvalue.begin()+pos);\n      value = std::string(keyvalue.begin()+pos+1, keyvalue.end());\n    } //<! key value pair parser\n  \n    void parseCookieHeader(const std::string &cookiestr) {\n      size_t pos, npos;\n      std::list<Cookie> lcookies;\n      Cookie c;\n      pos = 0;\n      while(pos < cookiestr.size()) {\n        if ((npos = cookiestr.find(\"; \", pos)) == std::string::npos)\n          npos = cookiestr.size();\n        keyValuePair(cookiestr.substr(pos, npos-pos), c.name, c.value);\n        c.name = YaHTTP::Utility::decodeURL(c.name);\n        c.value = YaHTTP::Utility::decodeURL(c.value);\n        lcookies.push_back(c);\n        pos = npos+2;\n      }\n      for(std::list<Cookie>::iterator i = lcookies.begin(); i != lcookies.end(); i++) {\n        this->cookies[i->name] = *i;\n      }\n    }\n\n    void parseSetCookieHeader(const std::string &cookiestr) {\n      Cookie c;\n      size_t pos,npos;\n      std::string k, v;\n\n      if ((pos = cookiestr.find(\"; \", 0)) == std::string::npos)\n        pos = cookiestr.size();\n      keyValuePair(cookiestr.substr(0, pos), c.name, c.value);\n      c.name = YaHTTP::Utility::decodeURL(c.name);\n      c.value = YaHTTP::Utility::decodeURL(c.value);\n      if (pos < cookiestr.size()) pos+=2;\n\n      while(pos < cookiestr.size()) {\n        if ((npos = cookiestr.find(\"; \", pos)) == std::string::npos)\n          npos = cookiestr.size();\n        std::string s = cookiestr.substr(pos, npos-pos);\n        if (s.find(\"=\") != std::string::npos)\n          keyValuePair(s, k, v);\n        else\n          k = s;\n        if (k == \"expires\") {\n          DateTime dt;\n          dt.parseCookie(v);\n          c.expires = dt;\n        } else if (k == \"domain\") {\n          c.domain = v;\n        } else if (k == \"path\") {\n          c.path = v;\n        } else if (k == \"httpOnly\") {\n          c.httponly = true;\n        } else if (k == \"secure\") {\n          c.secure = true;\n        } else {\n          // ignore crap\n          break;\n        }\n        pos = npos+2;\n      }\n  \n      this->cookies[c.name] = c;\n    }; //<! Parse multiple cookies from header \n  };\n};\n"}, "6": {"id": 6, "path": "/home/runner/work/testcc/testcc/retdec/ext/yahttp/yahttp/exception.hpp", "content": "#pragma once\n#include <exception>\n\nnamespace YaHTTP {\n  /*! Generic error class */\n  class Error: public std::exception {\n  public:\n    Error() {};\n    Error(const std::string& reason_): reason(reason_) {};\n    virtual ~Error() throw() {};\n\n    virtual const char* what() const throw()\n    {\n      return reason.c_str();\n    }\n    const std::string reason; //<! Cause of the error\n  };\n  /*! Parse error class */\n  class ParseError: public YaHTTP::Error {\n  public:\n    ParseError() {};\n    ParseError(const std::string& reason_): Error(reason_) {};\n  };\n};\n"}, "7": {"id": 7, "path": "/home/runner/work/testcc/testcc/retdec/ext/yahttp/yahttp/reqresp.hpp", "content": "#ifdef HAVE_CXX11\n#include <functional>\n#define HAVE_CPP_FUNC_PTR\nnamespace funcptr = std;\n#else\n#ifdef HAVE_BOOST\n#include <boost/function.hpp>\nnamespace funcptr = boost;\n#define HAVE_CPP_FUNC_PTR\n#endif\n#endif\n\n#include <fstream>\n#include <cctype>\n\n#ifndef WIN32\n#include <cstdio>\n#include <unistd.h>\n#endif\n\n#include <algorithm>\n\n#ifndef YAHTTP_MAX_REQUEST_SIZE\n#define YAHTTP_MAX_REQUEST_SIZE 2097152\n#endif\n\n#ifndef YAHTTP_MAX_RESPONSE_SIZE\n#define YAHTTP_MAX_RESPONSE_SIZE 2097152\n#endif\n\n#define YAHTTP_TYPE_REQUEST 1\n#define YAHTTP_TYPE_RESPONSE 2\n\nnamespace YaHTTP {\n  typedef std::map<std::string,Cookie,ASCIICINullSafeComparator> strcookie_map_t; //<! String to Cookie map\n\n  typedef enum {\n    urlencoded,\n    multipart\n  } postformat_t; //<! Enumeration of possible post encodings, url encoding or multipart\n\n  /*! Base class for request and response */\n  class HTTPBase {\n  public:\n    /*! Default renderer for request/response, simply copies body to response */\n    class SendBodyRender {\n    public:\n      SendBodyRender() {};\n\n      size_t operator()(const HTTPBase *doc, std::ostream& os, bool chunked) const {\n        if (chunked) {\n          std::string::size_type i,cl;\n          for(i=0;i<doc->body.length();i+=1024) {\n            cl = std::min(static_cast<std::string::size_type>(1024), doc->body.length()-i); // for less than 1k blocks\n            os << std::hex << cl << std::dec << \"\\r\\n\";\n            os << doc->body.substr(i, cl) << \"\\r\\n\";\n          }\n          os << 0 << \"\\r\\n\\r\\n\"; // last chunk\n        } else {\n          os << doc->body;\n        }\n        return doc->body.length();\n      }; //<! writes body to ostream and returns length \n    };\n    /* Simple sendfile renderer which streams file to ostream */\n    class SendFileRender {\n    public:\n      SendFileRender(const std::string& path_) {\n        this->path = path_;\n      };\n  \n      size_t operator()(const HTTPBase *doc __attribute__((unused)), std::ostream& os, bool chunked) const {\n        char buf[4096];\n        size_t n,k;\n#ifdef HAVE_CXX11\n        std::ifstream ifs(path, std::ifstream::binary);\n#else\n        std::ifstream ifs(path.c_str(), std::ifstream::binary);\n#endif\n        n = 0;\n\n        while(ifs.good()) {\n          ifs.read(buf, sizeof buf);\n          n += (k = ifs.gcount());\n          if (k > 0) {\n            if (chunked) os << std::hex << k << std::dec << \"\\r\\n\";\n            os.write(buf, k);\n            if (chunked) os << \"\\r\\n\"; \n          }\n        }\n        if (chunked) os << 0 << \"\\r\\n\\r\\n\";\n        return n;\n      }; //<! writes file to ostream and returns length\n\n      std::string path; //<! File to send\n    };\n\n    HTTPBase() {\n      initialize();\n    };\n\n    virtual void initialize() {\n      kind = 0;\n      status = 0;\n#ifdef HAVE_CPP_FUNC_PTR\n      renderer = SendBodyRender();\n#endif\n      max_request_size = YAHTTP_MAX_REQUEST_SIZE;\n      max_response_size = YAHTTP_MAX_RESPONSE_SIZE;\n      url = \"\";\n      method = \"\";\n      statusText = \"\";\n      jar.clear();\n      headers.clear();\n      parameters.clear();\n      getvars.clear();\n      postvars.clear();\n      body = \"\";\n      routeName = \"\";\n      version = 11; // default to version 1.1\n      is_multipart = false;\n    }\nprotected:\n    HTTPBase(const HTTPBase& rhs) {\n      this->url = rhs.url; this->kind = rhs.kind;\n      this->status = rhs.status; this->statusText = rhs.statusText;\n      this->method = rhs.method; this->headers = rhs.headers;\n      this->jar = rhs.jar; this->postvars = rhs.postvars;\n      this->parameters = rhs.parameters; this->getvars = rhs.getvars;\n      this->body = rhs.body; this->max_request_size = rhs.max_request_size;\n      this->max_response_size = rhs.max_response_size; this->version = rhs.version;\n#ifdef HAVE_CPP_FUNC_PTR\n      this->renderer = rhs.renderer;\n#endif\n      this->is_multipart = rhs.is_multipart;\n    };\n    HTTPBase& operator=(const HTTPBase& rhs) {\n      this->url = rhs.url; this->kind = rhs.kind;\n      this->status = rhs.status; this->statusText = rhs.statusText;\n      this->method = rhs.method; this->headers = rhs.headers;\n      this->jar = rhs.jar; this->postvars = rhs.postvars;\n      this->parameters = rhs.parameters; this->getvars = rhs.getvars;\n      this->body = rhs.body; this->max_request_size = rhs.max_request_size;\n      this->max_response_size = rhs.max_response_size; this->version = rhs.version;\n#ifdef HAVE_CPP_FUNC_PTR\n      this->renderer = rhs.renderer;\n#endif\n      this->is_multipart = rhs.is_multipart;\n      return *this;\n    };\npublic:\n    URL url; //<! URL of this request/response\n    int kind; //<! Type of object (1 = request, 2 = response)\n    int status; //<! status code \n    int version; //<! http version 9 = 0.9, 10 = 1.0, 11 = 1.1\n    std::string statusText; //<! textual representation of status code\n    std::string method; //<! http verb\n    strstr_map_t headers; //<! map of header(s)\n    CookieJar jar; //<! cookies \n    strstr_map_t postvars; //<! map of POST variables (from POST body)\n    strstr_map_t getvars; //<! map of GET variables (from URL)\n// these two are for Router\n    strstr_map_t parameters; //<! map of route parameters (only if you use YaHTTP::Router)\n    std::string routeName; //<! name of the current route (only if you use YaHTTP::Router)\n\n    std::string body; //<! the actual content\n\n    ssize_t max_request_size; //<! maximum size of request\n    ssize_t max_response_size;  //<! maximum size of response\n    bool is_multipart; //<! if the request is multipart, prevents Content-Length header\n#ifdef HAVE_CPP_FUNC_PTR\n    funcptr::function<size_t(const HTTPBase*,std::ostream&,bool)> renderer; //<! rendering function\n#endif\n    void write(std::ostream& os) const; //<! writes request to the given output stream\n\n    strstr_map_t& GET() { return getvars; }; //<! acccessor for getvars\n    strstr_map_t& POST() { return postvars; }; //<! accessor for postvars\n    strcookie_map_t& COOKIES() { return jar.cookies; }; //<! accessor for cookies\n\n    std::string versionStr(int version_) const {\n      switch(version_) {\n      case  9: return \"0.9\";\n      case 10: return \"1.0\";\n      case 11: return \"1.1\";\n      default: throw YaHTTP::Error(\"Unsupported version\");\n      }\n    };\n\n    std::string str() const {\n       std::ostringstream oss;\n       write(oss);\n       return oss.str();\n    }; //<! return string representation of this object\n  };\n\n  /*! Response class, represents a HTTP Response document */\n  class Response: public HTTPBase { \n  public:\n    Response() { initialize(); };\n    Response(const HTTPBase& rhs): HTTPBase(rhs) {\n      this->kind = YAHTTP_TYPE_RESPONSE;\n    };\n    Response& operator=(const HTTPBase& rhs) {\n      HTTPBase::operator=(rhs);\n      this->kind = YAHTTP_TYPE_RESPONSE;\n      return *this;\n    };\n    void initialize() {\n      HTTPBase::initialize();\n      this->kind = YAHTTP_TYPE_RESPONSE;\n    }\n    void initialize(const HTTPBase& rhs) {\n      HTTPBase::initialize();\n      this->kind = YAHTTP_TYPE_RESPONSE;\n      // copy SOME attributes\n      this->url = rhs.url;\n      this->method = rhs.method;\n      this->jar = rhs.jar;\n      this->version = rhs.version;\n    }\n    friend std::ostream& operator<<(std::ostream& os, const Response &resp);\n    friend std::istream& operator>>(std::istream& is, Response &resp);\n  };\n\n  /* Request class, represents a HTTP Request document */\n  class Request: public HTTPBase {\n  public:\n    Request() { initialize(); };\n    Request(const HTTPBase& rhs): HTTPBase(rhs) {\n      this->kind = YAHTTP_TYPE_REQUEST;\n    };\n    Request& operator=(const HTTPBase& rhs) {\n      HTTPBase::operator=(rhs);\n      this->kind = YAHTTP_TYPE_REQUEST;\n      return *this;\n    };\n    void initialize() {\n      HTTPBase::initialize();\n      this->kind = YAHTTP_TYPE_REQUEST;\n    }\n    void initialize(const HTTPBase& rhs) {\n      HTTPBase::initialize();\n      this->kind = YAHTTP_TYPE_REQUEST;\n      // copy SOME attributes\n      this->url = rhs.url;\n      this->method = rhs.method;\n      this->jar = rhs.jar;\n      this->version = rhs.version;\n    }\n    void setup(const std::string& method_, const std::string& url_) {\n      this->url.parse(url_);\n      this->headers[\"host\"] = this->url.host.find(\":\") == std::string::npos ? this->url.host : \"[\" + this->url.host + \"]\";\n      this->method = method_;\n      std::transform(this->method.begin(), this->method.end(), this->method.begin(), ::toupper);\n      this->headers[\"user-agent\"] = \"YaHTTP v1.0\";\n    }; //<! Set some initial things for a request\n\n    void preparePost(postformat_t format = urlencoded) {\n      std::ostringstream postbuf;\n      if (format == urlencoded) {\n        for(strstr_map_t::const_iterator i = POST().begin(); i != POST().end(); i++) {\n          postbuf << Utility::encodeURL(i->first, false) << \"=\" << Utility::encodeURL(i->second, false) << \"&\";\n        }\n        // remove last bit\n        if (postbuf.str().length()>0) \n          body = postbuf.str().substr(0, postbuf.str().length()-1);\n        else\n          body = \"\";\n        headers[\"content-type\"] = \"application/x-www-form-urlencoded; charset=utf-8\";\n      } else if (format == multipart) {\n        headers[\"content-type\"] = \"multipart/form-data; boundary=YaHTTP-12ca543\";\n        this->is_multipart = true;\n        for(strstr_map_t::const_iterator i = POST().begin(); i != POST().end(); i++) {\n          postbuf << \"--YaHTTP-12ca543\\r\\nContent-Disposition: form-data; name=\\\"\" << Utility::encodeURL(i->first, false) << \"\\\"; charset=UTF-8\\r\\nContent-Length: \" << i->second.size() << \"\\r\\n\\r\\n\"\n            << Utility::encodeURL(i->second, false) << \"\\r\\n\";\n        }\n        postbuf << \"--\";\n        body = postbuf.str();\n      }\n\n      postbuf.str(\"\");\n      postbuf << body.length();\n      // set method and change headers\n      method = \"POST\";\n      if (!this->is_multipart)\n        headers[\"content-length\"] = postbuf.str();\n    }; //<! convert all postvars into string and stuff it into body\n\n    friend std::ostream& operator<<(std::ostream& os, const Request &resp);\n    friend std::istream& operator>>(std::istream& is, Request &resp);\n  };\n\n  /*! Asynchronous HTTP document loader */\n  template <class T>\n  class AsyncLoader {\n  public:\n    T* target; //<! target to populate\n    int state; //<! reader state\n    size_t pos; //<! reader position\n    \n    std::string buffer; //<! read buffer \n    bool chunked; //<! whether we are parsing chunked data\n    int chunk_size; //<! expected size of next chunk\n    std::ostringstream bodybuf; //<! buffer for body\n    size_t maxbody; //<! maximum size of body\n    size_t minbody; //<! minimum size of body\n    bool hasBody; //<! are we expecting body\n\n    void keyValuePair(const std::string &keyvalue, std::string &key, std::string &value); //<! key value pair parser helper\n\n    void initialize(T* target_) {\n      chunked = false; chunk_size = 0;\n      bodybuf.str(\"\"); minbody = 0; maxbody = 0;\n      pos = 0; state = 0; this->target = target_;\n      hasBody = false;\n      buffer = \"\";\n      this->target->initialize();\n    }; //<! Initialize the parser for target and clear state\n    bool feed(const std::string& somedata); //<! Feed data to the parser\n    bool ready() {\n     return (chunked == true && state == 3) || // if it's chunked we get end of data indication\n             (chunked == false && state > 1 &&  \n               (!hasBody || \n                 (bodybuf.str().size() <= maxbody && \n                  bodybuf.str().size() >= minbody)\n               )\n             ); \n    }; //<! whether we have received enough data\n    void finalize() {\n      bodybuf.flush();\n      if (ready()) {\n        strstr_map_t::iterator cpos = target->headers.find(\"content-type\");\n        if (cpos != target->headers.end() && Utility::iequals(cpos->second, \"application/x-www-form-urlencoded\", 32)) {\n          target->postvars = Utility::parseUrlParameters(bodybuf.str());\n        }\n        target->body = bodybuf.str();\n      }\n      bodybuf.str(\"\");\n      this->target = NULL;\n    }; //<! finalize and release target\n  };\n\n  /*! Asynchronous HTTP response loader */\n  class AsyncResponseLoader: public AsyncLoader<Response> {\n  };\n\n  /*! Asynchronous HTTP request loader */\n  class AsyncRequestLoader: public AsyncLoader<Request> {\n  };\n\n};\n"}, "8": {"id": 8, "path": "/home/runner/work/testcc/testcc/retdec/ext/yahttp/yahttp/router.hpp", "content": "#pragma once\n/* @file \n * @brief Defines router class and support structures\n */\n#ifdef HAVE_CXX11\n#include <functional>\n#include <tuple>\n#define HAVE_CPP_FUNC_PTR\n#define IGNORE std::ignore\nnamespace funcptr = std;\n#else\n#ifdef HAVE_BOOST\n#include <boost/function.hpp>\n#include <boost/tuple/tuple.hpp>\n#define IGNORE boost::tuples::ignore\nnamespace funcptr = boost;\n#define HAVE_CPP_FUNC_PTR\n#else\n#warning \"You need to configure with boost or have C++11 capable compiler for router\"\n#endif\n#endif\n\n#ifdef HAVE_CPP_FUNC_PTR\n#include <vector>\n#include <utility>\n\nnamespace YaHTTP {\n  typedef funcptr::function <void(Request* req, Response* resp)> THandlerFunction; //!< Handler function pointer \n  typedef funcptr::tuple<std::string, std::string, THandlerFunction, std::string> TRoute; //!< Route tuple (method, urlmask, handler, name)\n  typedef std::vector<TRoute> TRouteList; //!< List of routes in order of evaluation\n\n  /*! Implements simple router.\n\nThis class implements a router for masked urls. The URL mask syntax is as of follows\n\n/&lt;masked&gt;/url&lt;number&gt;/&lt;hi&gt;.&lt;format&gt;\n\nYou can use &lt;*param&gt; to denote that everything will be matched and consumed into the parameter, including slash (/). Use &lt;*&gt; to denote that URL \nis consumed but not stored. Note that only path is matched, scheme, host and url parameters are ignored. \n   */\n  class Router {\n  private:\n    Router() {}; \n    static Router router; //<! Singleton instance of Router\n  public:\n    void map(const std::string& method, const std::string& url, THandlerFunction handler, const std::string& name); //<! Instance method for mapping urls\n    bool route(Request *req, THandlerFunction& handler); //<! Instance method for performing routing\n    void printRoutes(std::ostream &os); //<! Instance method for printing routes\n    std::pair<std::string, std::string> urlFor(const std::string &name, const strstr_map_t& arguments); //<! Instance method for generating paths\n\n/*! Map an URL.\nIf method is left empty, it will match any method. Name is also optional, but needed if you want to find it for making URLs \n*/\n    static void Map(const std::string& method, const std::string& url, THandlerFunction handler, const std::string& name = \"\") { router.map(method, url, handler, name); }; \n    static void Get(const std::string& url, THandlerFunction handler, const std::string& name = \"\") { router.map(\"GET\", url, handler, name); }; //<! Helper for mapping GET\n    static void Post(const std::string& url, THandlerFunction handler, const std::string& name = \"\") { router.map(\"POST\", url, handler, name); }; //<! Helper for mapping POST\n    static void Put(const std::string& url, THandlerFunction handler, const std::string& name = \"\") { router.map(\"PUT\", url, handler, name); }; //<! Helper for mapping PUT\n    static void Patch(const std::string& url, THandlerFunction handler, const std::string& name = \"\") { router.map(\"PATCH\", url, handler, name); }; //<! Helper for mapping PATCH\n    static void Delete(const std::string& url, THandlerFunction handler, const std::string& name = \"\") { router.map(\"DELETE\", url, handler, name); }; //<! Helper for mapping DELETE\n    static void Any(const std::string& url, THandlerFunction handler, const std::string& name = \"\") { router.map(\"\", url, handler, name); }; //<! Helper for mapping any method\n\n    static bool Route(Request *req, THandlerFunction& handler) { return router.route(req, handler); }; //<! Performs routing based on req->url.path \n    static void PrintRoutes(std::ostream &os) { router.printRoutes(os); }; //<! Prints all known routes to given output stream\n\n    static std::pair<std::string, std::string> URLFor(const std::string &name, const strstr_map_t& arguments) { return router.urlFor(name,arguments); }; //<! Generates url from named route and arguments. Missing arguments are assumed empty\n    static const TRouteList& GetRoutes() { return router.routes; } //<! Reference to route list \n    static void Clear() { router.routes.clear(); } //<! Clear all routes\n\n    TRouteList routes; //<! Instance variable for routes\n  };\n};\n#endif\n"}, "2": {"id": 2, "path": "/usr/include/c++/7/bits/basic_string.h", "content": "// Components for manipulating sequences of characters -*- C++ -*-\n\n// Copyright (C) 1997-2017 Free Software Foundation, Inc.\n//\n// This file is part of the GNU ISO C++ Library.  This library is free\n// software; you can redistribute it and/or modify it under the\n// terms of the GNU General Public License as published by the\n// Free Software Foundation; either version 3, or (at your option)\n// any later version.\n\n// This library is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n\n// Under Section 7 of GPL version 3, you are granted additional\n// permissions described in the GCC Runtime Library Exception, version\n// 3.1, as published by the Free Software Foundation.\n\n// You should have received a copy of the GNU General Public License and\n// a copy of the GCC Runtime Library Exception along with this program;\n// see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n// <http://www.gnu.org/licenses/>.\n\n/** @file bits/basic_string.h\n *  This is an internal header file, included by other library headers.\n *  Do not attempt to use it directly. @headername{string}\n */\n\n//\n// ISO C++ 14882: 21 Strings library\n//\n\n#ifndef _BASIC_STRING_H\n#define _BASIC_STRING_H 1\n\n#pragma GCC system_header\n\n#include <ext/atomicity.h>\n#include <ext/alloc_traits.h>\n#include <debug/debug.h>\n\n#if __cplusplus >= 201103L\n#include <initializer_list>\n#endif\n\n#if __cplusplus > 201402L\n# include <string_view>\n#endif\n\n\nnamespace std _GLIBCXX_VISIBILITY(default)\n{\n_GLIBCXX_BEGIN_NAMESPACE_VERSION\n\n#if _GLIBCXX_USE_CXX11_ABI\n_GLIBCXX_BEGIN_NAMESPACE_CXX11\n  /**\n   *  @class basic_string basic_string.h <string>\n   *  @brief  Managing sequences of characters and character-like objects.\n   *\n   *  @ingroup strings\n   *  @ingroup sequences\n   *\n   *  @tparam _CharT  Type of character\n   *  @tparam _Traits  Traits for character type, defaults to\n   *                   char_traits<_CharT>.\n   *  @tparam _Alloc  Allocator type, defaults to allocator<_CharT>.\n   *\n   *  Meets the requirements of a <a href=\"tables.html#65\">container</a>, a\n   *  <a href=\"tables.html#66\">reversible container</a>, and a\n   *  <a href=\"tables.html#67\">sequence</a>.  Of the\n   *  <a href=\"tables.html#68\">optional sequence requirements</a>, only\n   *  @c push_back, @c at, and @c %array access are supported.\n   */\n  template<typename _CharT, typename _Traits, typename _Alloc>\n    class basic_string\n    {\n      typedef typename __gnu_cxx::__alloc_traits<_Alloc>::template\n\trebind<_CharT>::other _Char_alloc_type;\n      typedef __gnu_cxx::__alloc_traits<_Char_alloc_type> _Alloc_traits;\n\n      // Types:\n    public:\n      typedef _Traits\t\t\t\t\ttraits_type;\n      typedef typename _Traits::char_type\t\tvalue_type;\n      typedef _Char_alloc_type\t\t\t\tallocator_type;\n      typedef typename _Alloc_traits::size_type\t\tsize_type;\n      typedef typename _Alloc_traits::difference_type\tdifference_type;\n      typedef typename _Alloc_traits::reference\t\treference;\n      typedef typename _Alloc_traits::const_reference\tconst_reference;\n      typedef typename _Alloc_traits::pointer\t\tpointer;\n      typedef typename _Alloc_traits::const_pointer\tconst_pointer;\n      typedef __gnu_cxx::__normal_iterator<pointer, basic_string>  iterator;\n      typedef __gnu_cxx::__normal_iterator<const_pointer, basic_string>\n\t\t\t\t\t\t\tconst_iterator;\n      typedef std::reverse_iterator<const_iterator>\tconst_reverse_iterator;\n      typedef std::reverse_iterator<iterator>\t\treverse_iterator;\n\n      ///  Value returned by various member functions when they fail.\n      static const size_type\tnpos = static_cast<size_type>(-1);\n\n    private:\n      // type used for positions in insert, erase etc.\n#if __cplusplus < 201103L\n      typedef iterator __const_iterator;\n#else\n      typedef const_iterator __const_iterator;\n#endif\n\n#if __cplusplus > 201402L\n      // A helper type for avoiding boiler-plate.\n      typedef basic_string_view<_CharT, _Traits> __sv_type;\n\n      template<typename _Tp, typename _Res>\n\tusing _If_sv = enable_if_t<\n\t  __and_<is_convertible<const _Tp&, __sv_type>,\n\t\t __not_<is_convertible<const _Tp*, const basic_string*>>,\n\t\t __not_<is_convertible<const _Tp&, const _CharT*>>>::value,\n\t  _Res>;\n\n      // Allows an implicit conversion to __sv_type.\n      static __sv_type\n      _S_to_string_view(__sv_type __svt) noexcept\n      { return __svt; }\n\n      // Wraps a string_view by explicit conversion and thus\n      // allows to add an internal constructor that does not\n      // participate in overload resolution when a string_view\n      // is provided.\n      struct __sv_wrapper\n      {\n\texplicit __sv_wrapper(__sv_type __sv) noexcept : _M_sv(__sv) { }\n\t__sv_type _M_sv;\n      };\n#endif\n\n      // Use empty-base optimization: http://www.cantrip.org/emptyopt.html\n      struct _Alloc_hider : allocator_type // TODO check __is_final\n      {\n#if __cplusplus < 201103L\n\t_Alloc_hider(pointer __dat, const _Alloc& __a = _Alloc())\n\t: allocator_type(__a), _M_p(__dat) { }\n#else\n\t_Alloc_hider(pointer __dat, const _Alloc& __a)\n\t: allocator_type(__a), _M_p(__dat) { }\n\n\t_Alloc_hider(pointer __dat, _Alloc&& __a = _Alloc())\n\t: allocator_type(std::move(__a)), _M_p(__dat) { }\n#endif\n\n\tpointer _M_p; // The actual data.\n      };\n\n      _Alloc_hider\t_M_dataplus;\n      size_type\t\t_M_string_length;\n\n      enum { _S_local_capacity = 15 / sizeof(_CharT) };\n\n      union\n      {\n\t_CharT           _M_local_buf[_S_local_capacity + 1];\n\tsize_type        _M_allocated_capacity;\n      };\n\n      void\n      _M_data(pointer __p)\n      { _M_dataplus._M_p = __p; }\n\n      void\n      _M_length(size_type __length)\n      { _M_string_length = __length; }\n\n      pointer\n      _M_data() const\n      { return _M_dataplus._M_p; }\n\n      pointer\n      _M_local_data()\n      {\n#if __cplusplus >= 201103L\n\treturn std::pointer_traits<pointer>::pointer_to(*_M_local_buf);\n#else\n\treturn pointer(_M_local_buf);\n#endif\n      }\n\n      const_pointer\n      _M_local_data() const\n      {\n#if __cplusplus >= 201103L\n\treturn std::pointer_traits<const_pointer>::pointer_to(*_M_local_buf);\n#else\n\treturn const_pointer(_M_local_buf);\n#endif\n      }\n\n      void\n      _M_capacity(size_type __capacity)\n      { _M_allocated_capacity = __capacity; }\n\n      void\n      _M_set_length(size_type __n)\n      {\n\t_M_length(__n);\n\ttraits_type::assign(_M_data()[__n], _CharT());\n      }\n\n      bool\n      _M_is_local() const\n      { return _M_data() == _M_local_data(); }\n\n      // Create & Destroy\n      pointer\n      _M_create(size_type&, size_type);\n\n      void\n      _M_dispose()\n      {\n\tif (!_M_is_local())\n\t  _M_destroy(_M_allocated_capacity);\n      }\n\n      void\n      _M_destroy(size_type __size) throw()\n      { _Alloc_traits::deallocate(_M_get_allocator(), _M_data(), __size + 1); }\n\n      // _M_construct_aux is used to implement the 21.3.1 para 15 which\n      // requires special behaviour if _InIterator is an integral type\n      template<typename _InIterator>\n        void\n        _M_construct_aux(_InIterator __beg, _InIterator __end,\n\t\t\t std::__false_type)\n\t{\n          typedef typename iterator_traits<_InIterator>::iterator_category _Tag;\n          _M_construct(__beg, __end, _Tag());\n\t}\n\n      // _GLIBCXX_RESOLVE_LIB_DEFECTS\n      // 438. Ambiguity in the \"do the right thing\" clause\n      template<typename _Integer>\n        void\n        _M_construct_aux(_Integer __beg, _Integer __end, std::__true_type)\n\t{ _M_construct_aux_2(static_cast<size_type>(__beg), __end); }\n\n      void\n      _M_construct_aux_2(size_type __req, _CharT __c)\n      { _M_construct(__req, __c); }\n\n      template<typename _InIterator>\n        void\n        _M_construct(_InIterator __beg, _InIterator __end)\n\t{\n\t  typedef typename std::__is_integer<_InIterator>::__type _Integral;\n\t  _M_construct_aux(__beg, __end, _Integral());\n        }\n\n      // For Input Iterators, used in istreambuf_iterators, etc.\n      template<typename _InIterator>\n        void\n        _M_construct(_InIterator __beg, _InIterator __end,\n\t\t     std::input_iterator_tag);\n\n      // For forward_iterators up to random_access_iterators, used for\n      // string::iterator, _CharT*, etc.\n      template<typename _FwdIterator>\n        void\n        _M_construct(_FwdIterator __beg, _FwdIterator __end,\n\t\t     std::forward_iterator_tag);\n\n      void\n      _M_construct(size_type __req, _CharT __c);\n\n      allocator_type&\n      _M_get_allocator()\n      { return _M_dataplus; }\n\n      const allocator_type&\n      _M_get_allocator() const\n      { return _M_dataplus; }\n\n    private:\n\n#ifdef _GLIBCXX_DISAMBIGUATE_REPLACE_INST\n      // The explicit instantiations in misc-inst.cc require this due to\n      // https://gcc.gnu.org/bugzilla/show_bug.cgi?id=64063\n      template<typename _Tp, bool _Requires =\n\t       !__are_same<_Tp, _CharT*>::__value\n\t       && !__are_same<_Tp, const _CharT*>::__value\n\t       && !__are_same<_Tp, iterator>::__value\n\t       && !__are_same<_Tp, const_iterator>::__value>\n\tstruct __enable_if_not_native_iterator\n\t{ typedef basic_string& __type; };\n      template<typename _Tp>\n\tstruct __enable_if_not_native_iterator<_Tp, false> { };\n#endif\n\n      size_type\n      _M_check(size_type __pos, const char* __s) const\n      {\n\tif (__pos > this->size())\n\t  __throw_out_of_range_fmt(__N(\"%s: __pos (which is %zu) > \"\n\t\t\t\t       \"this->size() (which is %zu)\"),\n\t\t\t\t   __s, __pos, this->size());\n\treturn __pos;\n      }\n\n      void\n      _M_check_length(size_type __n1, size_type __n2, const char* __s) const\n      {\n\tif (this->max_size() - (this->size() - __n1) < __n2)\n\t  __throw_length_error(__N(__s));\n      }\n\n\n      // NB: _M_limit doesn't check for a bad __pos value.\n      size_type\n      _M_limit(size_type __pos, size_type __off) const _GLIBCXX_NOEXCEPT\n      {\n\tconst bool __testoff =  __off < this->size() - __pos;\n\treturn __testoff ? __off : this->size() - __pos;\n      }\n\n      // True if _Rep and source do not overlap.\n      bool\n      _M_disjunct(const _CharT* __s) const _GLIBCXX_NOEXCEPT\n      {\n\treturn (less<const _CharT*>()(__s, _M_data())\n\t\t|| less<const _CharT*>()(_M_data() + this->size(), __s));\n      }\n\n      // When __n = 1 way faster than the general multichar\n      // traits_type::copy/move/assign.\n      static void\n      _S_copy(_CharT* __d, const _CharT* __s, size_type __n)\n      {\n\tif (__n == 1)\n\t  traits_type::assign(*__d, *__s);\n\telse\n\t  traits_type::copy(__d, __s, __n);\n      }\n\n      static void\n      _S_move(_CharT* __d, const _CharT* __s, size_type __n)\n      {\n\tif (__n == 1)\n\t  traits_type::assign(*__d, *__s);\n\telse\n\t  traits_type::move(__d, __s, __n);\n      }\n\n      static void\n      _S_assign(_CharT* __d, size_type __n, _CharT __c)\n      {\n\tif (__n == 1)\n\t  traits_type::assign(*__d, __c);\n\telse\n\t  traits_type::assign(__d, __n, __c);\n      }\n\n      // _S_copy_chars is a separate template to permit specialization\n      // to optimize for the common case of pointers as iterators.\n      template<class _Iterator>\n        static void\n        _S_copy_chars(_CharT* __p, _Iterator __k1, _Iterator __k2)\n        {\n\t  for (; __k1 != __k2; ++__k1, (void)++__p)\n\t    traits_type::assign(*__p, *__k1); // These types are off.\n\t}\n\n      static void\n      _S_copy_chars(_CharT* __p, iterator __k1, iterator __k2) _GLIBCXX_NOEXCEPT\n      { _S_copy_chars(__p, __k1.base(), __k2.base()); }\n\n      static void\n      _S_copy_chars(_CharT* __p, const_iterator __k1, const_iterator __k2)\n      _GLIBCXX_NOEXCEPT\n      { _S_copy_chars(__p, __k1.base(), __k2.base()); }\n\n      static void\n      _S_copy_chars(_CharT* __p, _CharT* __k1, _CharT* __k2) _GLIBCXX_NOEXCEPT\n      { _S_copy(__p, __k1, __k2 - __k1); }\n\n      static void\n      _S_copy_chars(_CharT* __p, const _CharT* __k1, const _CharT* __k2)\n      _GLIBCXX_NOEXCEPT\n      { _S_copy(__p, __k1, __k2 - __k1); }\n\n      static int\n      _S_compare(size_type __n1, size_type __n2) _GLIBCXX_NOEXCEPT\n      {\n\tconst difference_type __d = difference_type(__n1 - __n2);\n\n\tif (__d > __gnu_cxx::__numeric_traits<int>::__max)\n\t  return __gnu_cxx::__numeric_traits<int>::__max;\n\telse if (__d < __gnu_cxx::__numeric_traits<int>::__min)\n\t  return __gnu_cxx::__numeric_traits<int>::__min;\n\telse\n\t  return int(__d);\n      }\n\n      void\n      _M_assign(const basic_string&);\n\n      void\n      _M_mutate(size_type __pos, size_type __len1, const _CharT* __s,\n\t\tsize_type __len2);\n\n      void\n      _M_erase(size_type __pos, size_type __n);\n\n    public:\n      // Construct/copy/destroy:\n      // NB: We overload ctors in some cases instead of using default\n      // arguments, per 17.4.4.4 para. 2 item 2.\n\n      /**\n       *  @brief  Default constructor creates an empty string.\n       */\n      basic_string()\n      _GLIBCXX_NOEXCEPT_IF(is_nothrow_default_constructible<_Alloc>::value)\n      : _M_dataplus(_M_local_data())\n      { _M_set_length(0); }\n\n      /**\n       *  @brief  Construct an empty string using allocator @a a.\n       */\n      explicit\n      basic_string(const _Alloc& __a) _GLIBCXX_NOEXCEPT\n      : _M_dataplus(_M_local_data(), __a)\n      { _M_set_length(0); }\n\n      /**\n       *  @brief  Construct string with copy of value of @a __str.\n       *  @param  __str  Source string.\n       */\n      basic_string(const basic_string& __str)\n      : _M_dataplus(_M_local_data(),\n\t\t    _Alloc_traits::_S_select_on_copy(__str._M_get_allocator()))\n      { _M_construct(__str._M_data(), __str._M_data() + __str.length()); }\n\n      // _GLIBCXX_RESOLVE_LIB_DEFECTS\n      // 2583. no way to supply an allocator for basic_string(str, pos)\n      /**\n       *  @brief  Construct string as copy of a substring.\n       *  @param  __str  Source string.\n       *  @param  __pos  Index of first character to copy from.\n       *  @param  __a  Allocator to use.\n       */\n      basic_string(const basic_string& __str, size_type __pos,\n\t\t   const _Alloc& __a = _Alloc())\n      : _M_dataplus(_M_local_data(), __a)\n      {\n\tconst _CharT* __start = __str._M_data()\n\t  + __str._M_check(__pos, \"basic_string::basic_string\");\n\t_M_construct(__start, __start + __str._M_limit(__pos, npos));\n      }\n\n      /**\n       *  @brief  Construct string as copy of a substring.\n       *  @param  __str  Source string.\n       *  @param  __pos  Index of first character to copy from.\n       *  @param  __n  Number of characters to copy.\n       */\n      basic_string(const basic_string& __str, size_type __pos,\n\t\t   size_type __n)\n      : _M_dataplus(_M_local_data())\n      {\n\tconst _CharT* __start = __str._M_data()\n\t  + __str._M_check(__pos, \"basic_string::basic_string\");\n\t_M_construct(__start, __start + __str._M_limit(__pos, __n));\n      }\n\n      /**\n       *  @brief  Construct string as copy of a substring.\n       *  @param  __str  Source string.\n       *  @param  __pos  Index of first character to copy from.\n       *  @param  __n  Number of characters to copy.\n       *  @param  __a  Allocator to use.\n       */\n      basic_string(const basic_string& __str, size_type __pos,\n\t\t   size_type __n, const _Alloc& __a)\n      : _M_dataplus(_M_local_data(), __a)\n      {\n\tconst _CharT* __start\n\t  = __str._M_data() + __str._M_check(__pos, \"string::string\");\n\t_M_construct(__start, __start + __str._M_limit(__pos, __n));\n      }\n\n      /**\n       *  @brief  Construct string initialized by a character %array.\n       *  @param  __s  Source character %array.\n       *  @param  __n  Number of characters to copy.\n       *  @param  __a  Allocator to use (default is default allocator).\n       *\n       *  NB: @a __s must have at least @a __n characters, &apos;\\\\0&apos;\n       *  has no special meaning.\n       */\n      basic_string(const _CharT* __s, size_type __n,\n\t\t   const _Alloc& __a = _Alloc())\n      : _M_dataplus(_M_local_data(), __a)\n      { _M_construct(__s, __s + __n); }\n\n      /**\n       *  @brief  Construct string as copy of a C string.\n       *  @param  __s  Source C string.\n       *  @param  __a  Allocator to use (default is default allocator).\n       */\n      basic_string(const _CharT* __s, const _Alloc& __a = _Alloc())\n      : _M_dataplus(_M_local_data(), __a)\n      { _M_construct(__s, __s ? __s + traits_type::length(__s) : __s+npos); }\n\n      /**\n       *  @brief  Construct string as multiple characters.\n       *  @param  __n  Number of characters.\n       *  @param  __c  Character to use.\n       *  @param  __a  Allocator to use (default is default allocator).\n       */\n      basic_string(size_type __n, _CharT __c, const _Alloc& __a = _Alloc())\n      : _M_dataplus(_M_local_data(), __a)\n      { _M_construct(__n, __c); }\n\n#if __cplusplus >= 201103L\n      /**\n       *  @brief  Move construct string.\n       *  @param  __str  Source string.\n       *\n       *  The newly-created string contains the exact contents of @a __str.\n       *  @a __str is a valid, but unspecified string.\n       **/\n      basic_string(basic_string&& __str) noexcept\n      : _M_dataplus(_M_local_data(), std::move(__str._M_get_allocator()))\n      {\n\tif (__str._M_is_local())\n\t  {\n\t    traits_type::copy(_M_local_buf, __str._M_local_buf,\n\t\t\t      _S_local_capacity + 1);\n\t  }\n\telse\n\t  {\n\t    _M_data(__str._M_data());\n\t    _M_capacity(__str._M_allocated_capacity);\n\t  }\n\n\t// Must use _M_length() here not _M_set_length() because\n\t// basic_stringbuf relies on writing into unallocated capacity so\n\t// we mess up the contents if we put a '\\0' in the string.\n\t_M_length(__str.length());\n\t__str._M_data(__str._M_local_data());\n\t__str._M_set_length(0);\n      }\n\n      /**\n       *  @brief  Construct string from an initializer %list.\n       *  @param  __l  std::initializer_list of characters.\n       *  @param  __a  Allocator to use (default is default allocator).\n       */\n      basic_string(initializer_list<_CharT> __l, const _Alloc& __a = _Alloc())\n      : _M_dataplus(_M_local_data(), __a)\n      { _M_construct(__l.begin(), __l.end()); }\n\n      basic_string(const basic_string& __str, const _Alloc& __a)\n      : _M_dataplus(_M_local_data(), __a)\n      { _M_construct(__str.begin(), __str.end()); }\n\n      basic_string(basic_string&& __str, const _Alloc& __a)\n      noexcept(_Alloc_traits::_S_always_equal())\n      : _M_dataplus(_M_local_data(), __a)\n      {\n\tif (__str._M_is_local())\n\t  {\n\t    traits_type::copy(_M_local_buf, __str._M_local_buf,\n\t\t\t      _S_local_capacity + 1);\n\t    _M_length(__str.length());\n\t    __str._M_set_length(0);\n\t  }\n\telse if (_Alloc_traits::_S_always_equal()\n\t    || __str.get_allocator() == __a)\n\t  {\n\t    _M_data(__str._M_data());\n\t    _M_length(__str.length());\n\t    _M_capacity(__str._M_allocated_capacity);\n\t    __str._M_data(__str._M_local_buf);\n\t    __str._M_set_length(0);\n\t  }\n\telse\n\t  _M_construct(__str.begin(), __str.end());\n      }\n\n#endif // C++11\n\n      /**\n       *  @brief  Construct string as copy of a range.\n       *  @param  __beg  Start of range.\n       *  @param  __end  End of range.\n       *  @param  __a  Allocator to use (default is default allocator).\n       */\n#if __cplusplus >= 201103L\n      template<typename _InputIterator,\n\t       typename = std::_RequireInputIter<_InputIterator>>\n#else\n      template<typename _InputIterator>\n#endif\n        basic_string(_InputIterator __beg, _InputIterator __end,\n\t\t     const _Alloc& __a = _Alloc())\n\t: _M_dataplus(_M_local_data(), __a)\n\t{ _M_construct(__beg, __end); }\n\n#if __cplusplus > 201402L\n      /**\n       *  @brief  Construct string from a substring of a string_view.\n       *  @param  __t   Source object convertible to string view.\n       *  @param  __pos The index of the first character to copy from __t.\n       *  @param  __n   The number of characters to copy from __t.\n       *  @param  __a   Allocator to use.\n       */\n      template<typename _Tp, typename = _If_sv<_Tp, void>>\n\tbasic_string(const _Tp& __t, size_type __pos, size_type __n,\n\t\t     const _Alloc& __a = _Alloc())\n\t: basic_string(_S_to_string_view(__t).substr(__pos, __n), __a) { }\n\n      /**\n       *  @brief  Construct string from a string_view.\n       *  @param  __t  Source object convertible to string view.\n       *  @param  __a  Allocator to use (default is default allocator).\n       */\n      template<typename _Tp, typename = _If_sv<_Tp, void>>\n\texplicit\n\tbasic_string(const _Tp& __t, const _Alloc& __a = _Alloc())\n\t: basic_string(__sv_wrapper(_S_to_string_view(__t)), __a) { }\n\n      /**\n       *  @brief  Only internally used: Construct string from a string view\n       *          wrapper.\n       *  @param  __svw  string view wrapper.\n       *  @param  __a  Allocator to use.\n       */\n      explicit\n      basic_string(__sv_wrapper __svw, const _Alloc& __a)\n      : basic_string(__svw._M_sv.data(), __svw._M_sv.size(), __a) { }\n#endif // C++17\n\n      /**\n       *  @brief  Destroy the string instance.\n       */\n      ~basic_string()\n      { _M_dispose(); }\n\n      /**\n       *  @brief  Assign the value of @a str to this string.\n       *  @param  __str  Source string.\n       */\n      basic_string&\n      operator=(const basic_string& __str)\n      {\n#if __cplusplus >= 201103L\n\tif (_Alloc_traits::_S_propagate_on_copy_assign())\n\t  {\n\t    if (!_Alloc_traits::_S_always_equal() && !_M_is_local()\n\t\t&& _M_get_allocator() != __str._M_get_allocator())\n\t      {\n\t\t// Propagating allocator cannot free existing storage so must\n\t\t// deallocate it before replacing current allocator.\n\t\tif (__str.size() <= _S_local_capacity)\n\t\t  {\n\t\t    _M_destroy(_M_allocated_capacity);\n\t\t    _M_data(_M_local_data());\n\t\t    _M_set_length(0);\n\t\t  }\n\t\telse\n\t\t  {\n\t\t    const auto __len = __str.size();\n\t\t    auto __alloc = __str._M_get_allocator();\n\t\t    // If this allocation throws there are no effects:\n\t\t    auto __ptr = _Alloc_traits::allocate(__alloc, __len + 1);\n\t\t    _M_destroy(_M_allocated_capacity);\n\t\t    _M_data(__ptr);\n\t\t    _M_capacity(__len);\n\t\t    _M_set_length(__len);\n\t\t  }\n\t      }\n\t    std::__alloc_on_copy(_M_get_allocator(), __str._M_get_allocator());\n\t  }\n#endif\n\treturn this->assign(__str);\n      }\n\n      /**\n       *  @brief  Copy contents of @a s into this string.\n       *  @param  __s  Source null-terminated string.\n       */\n      basic_string&\n      operator=(const _CharT* __s)\n      { return this->assign(__s); }\n\n      /**\n       *  @brief  Set value to string of length 1.\n       *  @param  __c  Source character.\n       *\n       *  Assigning to a character makes this string length 1 and\n       *  (*this)[0] == @a c.\n       */\n      basic_string&\n      operator=(_CharT __c)\n      {\n\tthis->assign(1, __c);\n\treturn *this;\n      }\n\n#if __cplusplus >= 201103L\n      /**\n       *  @brief  Move assign the value of @a str to this string.\n       *  @param  __str  Source string.\n       *\n       *  The contents of @a str are moved into this string (without copying).\n       *  @a str is a valid, but unspecified string.\n       **/\n      // PR 58265, this should be noexcept.\n      // _GLIBCXX_RESOLVE_LIB_DEFECTS\n      // 2063. Contradictory requirements for string move assignment\n      basic_string&\n      operator=(basic_string&& __str)\n      noexcept(_Alloc_traits::_S_nothrow_move())\n      {\n\tif (!_M_is_local() && _Alloc_traits::_S_propagate_on_move_assign()\n\t    && !_Alloc_traits::_S_always_equal()\n\t    && _M_get_allocator() != __str._M_get_allocator())\n\t  {\n\t    // Destroy existing storage before replacing allocator.\n\t    _M_destroy(_M_allocated_capacity);\n\t    _M_data(_M_local_data());\n\t    _M_set_length(0);\n\t  }\n\t// Replace allocator if POCMA is true.\n\tstd::__alloc_on_move(_M_get_allocator(), __str._M_get_allocator());\n\n\tif (__str._M_is_local())\n\t  {\n\t    // We've always got room for a short string, just copy it.\n\t    if (__str.size())\n\t      this->_S_copy(_M_data(), __str._M_data(), __str.size());\n\t    _M_set_length(__str.size());\n\t  }\n\telse if (_Alloc_traits::_S_propagate_on_move_assign()\n\t    || _Alloc_traits::_S_always_equal()\n\t    || _M_get_allocator() == __str._M_get_allocator())\n\t  {\n\t    // Just move the allocated pointer, our allocator can free it.\n\t    pointer __data = nullptr;\n\t    size_type __capacity;\n\t    if (!_M_is_local())\n\t      {\n\t\tif (_Alloc_traits::_S_always_equal())\n\t\t  {\n\t\t    // __str can reuse our existing storage.\n\t\t    __data = _M_data();\n\t\t    __capacity = _M_allocated_capacity;\n\t\t  }\n\t\telse // __str can't use it, so free it.\n\t\t  _M_destroy(_M_allocated_capacity);\n\t      }\n\n\t    _M_data(__str._M_data());\n\t    _M_length(__str.length());\n\t    _M_capacity(__str._M_allocated_capacity);\n\t    if (__data)\n\t      {\n\t\t__str._M_data(__data);\n\t\t__str._M_capacity(__capacity);\n\t      }\n\t    else\n\t      __str._M_data(__str._M_local_buf);\n\t  }\n\telse // Need to do a deep copy\n\t  assign(__str);\n\t__str.clear();\n\treturn *this;\n      }\n\n      /**\n       *  @brief  Set value to string constructed from initializer %list.\n       *  @param  __l  std::initializer_list.\n       */\n      basic_string&\n      operator=(initializer_list<_CharT> __l)\n      {\n\tthis->assign(__l.begin(), __l.size());\n\treturn *this;\n      }\n#endif // C++11\n\n#if __cplusplus > 201402L\n      /**\n       *  @brief  Set value to string constructed from a string_view.\n       *  @param  __svt  An object convertible to string_view.\n       */\n     template<typename _Tp>\n       _If_sv<_Tp, basic_string&>\n       operator=(const _Tp& __svt)\n       { return this->assign(__svt); }\n\n      /**\n       *  @brief  Convert to a string_view.\n       *  @return A string_view.\n       */\n      operator __sv_type() const noexcept\n      { return __sv_type(data(), size()); }\n#endif // C++17\n\n      // Iterators:\n      /**\n       *  Returns a read/write iterator that points to the first character in\n       *  the %string.\n       */\n      iterator\n      begin() _GLIBCXX_NOEXCEPT\n      { return iterator(_M_data()); }\n\n      /**\n       *  Returns a read-only (constant) iterator that points to the first\n       *  character in the %string.\n       */\n      const_iterator\n      begin() const _GLIBCXX_NOEXCEPT\n      { return const_iterator(_M_data()); }\n\n      /**\n       *  Returns a read/write iterator that points one past the last\n       *  character in the %string.\n       */\n      iterator\n      end() _GLIBCXX_NOEXCEPT\n      { return iterator(_M_data() + this->size()); }\n\n      /**\n       *  Returns a read-only (constant) iterator that points one past the\n       *  last character in the %string.\n       */\n      const_iterator\n      end() const _GLIBCXX_NOEXCEPT\n      { return const_iterator(_M_data() + this->size()); }\n\n      /**\n       *  Returns a read/write reverse iterator that points to the last\n       *  character in the %string.  Iteration is done in reverse element\n       *  order.\n       */\n      reverse_iterator\n      rbegin() _GLIBCXX_NOEXCEPT\n      { return reverse_iterator(this->end()); }\n\n      /**\n       *  Returns a read-only (constant) reverse iterator that points\n       *  to the last character in the %string.  Iteration is done in\n       *  reverse element order.\n       */\n      const_reverse_iterator\n      rbegin() const _GLIBCXX_NOEXCEPT\n      { return const_reverse_iterator(this->end()); }\n\n      /**\n       *  Returns a read/write reverse iterator that points to one before the\n       *  first character in the %string.  Iteration is done in reverse\n       *  element order.\n       */\n      reverse_iterator\n      rend() _GLIBCXX_NOEXCEPT\n      { return reverse_iterator(this->begin()); }\n\n      /**\n       *  Returns a read-only (constant) reverse iterator that points\n       *  to one before the first character in the %string.  Iteration\n       *  is done in reverse element order.\n       */\n      const_reverse_iterator\n      rend() const _GLIBCXX_NOEXCEPT\n      { return const_reverse_iterator(this->begin()); }\n\n#if __cplusplus >= 201103L\n      /**\n       *  Returns a read-only (constant) iterator that points to the first\n       *  character in the %string.\n       */\n      const_iterator\n      cbegin() const noexcept\n      { return const_iterator(this->_M_data()); }\n\n      /**\n       *  Returns a read-only (constant) iterator that points one past the\n       *  last character in the %string.\n       */\n      const_iterator\n      cend() const noexcept\n      { return const_iterator(this->_M_data() + this->size()); }\n\n      /**\n       *  Returns a read-only (constant) reverse iterator that points\n       *  to the last character in the %string.  Iteration is done in\n       *  reverse element order.\n       */\n      const_reverse_iterator\n      crbegin() const noexcept\n      { return const_reverse_iterator(this->end()); }\n\n      /**\n       *  Returns a read-only (constant) reverse iterator that points\n       *  to one before the first character in the %string.  Iteration\n       *  is done in reverse element order.\n       */\n      const_reverse_iterator\n      crend() const noexcept\n      { return const_reverse_iterator(this->begin()); }\n#endif\n\n    public:\n      // Capacity:\n      ///  Returns the number of characters in the string, not including any\n      ///  null-termination.\n      size_type\n      size() const _GLIBCXX_NOEXCEPT\n      { return _M_string_length; }\n\n      ///  Returns the number of characters in the string, not including any\n      ///  null-termination.\n      size_type\n      length() const _GLIBCXX_NOEXCEPT\n      { return _M_string_length; }\n\n      ///  Returns the size() of the largest possible %string.\n      size_type\n      max_size() const _GLIBCXX_NOEXCEPT\n      { return (_Alloc_traits::max_size(_M_get_allocator()) - 1) / 2; }\n\n      /**\n       *  @brief  Resizes the %string to the specified number of characters.\n       *  @param  __n  Number of characters the %string should contain.\n       *  @param  __c  Character to fill any new elements.\n       *\n       *  This function will %resize the %string to the specified\n       *  number of characters.  If the number is smaller than the\n       *  %string's current size the %string is truncated, otherwise\n       *  the %string is extended and new elements are %set to @a __c.\n       */\n      void\n      resize(size_type __n, _CharT __c);\n\n      /**\n       *  @brief  Resizes the %string to the specified number of characters.\n       *  @param  __n  Number of characters the %string should contain.\n       *\n       *  This function will resize the %string to the specified length.  If\n       *  the new size is smaller than the %string's current size the %string\n       *  is truncated, otherwise the %string is extended and new characters\n       *  are default-constructed.  For basic types such as char, this means\n       *  setting them to 0.\n       */\n      void\n      resize(size_type __n)\n      { this->resize(__n, _CharT()); }\n\n#if __cplusplus >= 201103L\n      ///  A non-binding request to reduce capacity() to size().\n      void\n      shrink_to_fit() noexcept\n      {\n#if __cpp_exceptions\n\tif (capacity() > size())\n\t  {\n\t    try\n\t      { reserve(0); }\n\t    catch(...)\n\t      { }\n\t  }\n#endif\n      }\n#endif\n\n      /**\n       *  Returns the total number of characters that the %string can hold\n       *  before needing to allocate more memory.\n       */\n      size_type\n      capacity() const _GLIBCXX_NOEXCEPT\n      {\n\treturn _M_is_local() ? size_type(_S_local_capacity)\n\t                     : _M_allocated_capacity;\n      }\n\n      /**\n       *  @brief  Attempt to preallocate enough memory for specified number of\n       *          characters.\n       *  @param  __res_arg  Number of characters required.\n       *  @throw  std::length_error  If @a __res_arg exceeds @c max_size().\n       *\n       *  This function attempts to reserve enough memory for the\n       *  %string to hold the specified number of characters.  If the\n       *  number requested is more than max_size(), length_error is\n       *  thrown.\n       *\n       *  The advantage of this function is that if optimal code is a\n       *  necessity and the user can determine the string length that will be\n       *  required, the user can reserve the memory in %advance, and thus\n       *  prevent a possible reallocation of memory and copying of %string\n       *  data.\n       */\n      void\n      reserve(size_type __res_arg = 0);\n\n      /**\n       *  Erases the string, making it empty.\n       */\n      void\n      clear() _GLIBCXX_NOEXCEPT\n      { _M_set_length(0); }\n\n      /**\n       *  Returns true if the %string is empty.  Equivalent to \n       *  <code>*this == \"\"</code>.\n       */\n      bool\n      empty() const _GLIBCXX_NOEXCEPT\n      { return this->size() == 0; }\n\n      // Element access:\n      /**\n       *  @brief  Subscript access to the data contained in the %string.\n       *  @param  __pos  The index of the character to access.\n       *  @return  Read-only (constant) reference to the character.\n       *\n       *  This operator allows for easy, array-style, data access.\n       *  Note that data access with this operator is unchecked and\n       *  out_of_range lookups are not defined. (For checked lookups\n       *  see at().)\n       */\n      const_reference\n      operator[] (size_type __pos) const _GLIBCXX_NOEXCEPT\n      {\n\t__glibcxx_assert(__pos <= size());\n\treturn _M_data()[__pos];\n      }\n\n      /**\n       *  @brief  Subscript access to the data contained in the %string.\n       *  @param  __pos  The index of the character to access.\n       *  @return  Read/write reference to the character.\n       *\n       *  This operator allows for easy, array-style, data access.\n       *  Note that data access with this operator is unchecked and\n       *  out_of_range lookups are not defined. (For checked lookups\n       *  see at().)\n       */\n      reference\n      operator[](size_type __pos)\n      {\n        // Allow pos == size() both in C++98 mode, as v3 extension,\n\t// and in C++11 mode.\n\t__glibcxx_assert(__pos <= size());\n        // In pedantic mode be strict in C++98 mode.\n\t_GLIBCXX_DEBUG_PEDASSERT(__cplusplus >= 201103L || __pos < size());\n\treturn _M_data()[__pos];\n      }\n\n      /**\n       *  @brief  Provides access to the data contained in the %string.\n       *  @param __n The index of the character to access.\n       *  @return  Read-only (const) reference to the character.\n       *  @throw  std::out_of_range  If @a n is an invalid index.\n       *\n       *  This function provides for safer data access.  The parameter is\n       *  first checked that it is in the range of the string.  The function\n       *  throws out_of_range if the check fails.\n       */\n      const_reference\n      at(size_type __n) const\n      {\n\tif (__n >= this->size())\n\t  __throw_out_of_range_fmt(__N(\"basic_string::at: __n \"\n\t\t\t\t       \"(which is %zu) >= this->size() \"\n\t\t\t\t       \"(which is %zu)\"),\n\t\t\t\t   __n, this->size());\n\treturn _M_data()[__n];\n      }\n\n      /**\n       *  @brief  Provides access to the data contained in the %string.\n       *  @param __n The index of the character to access.\n       *  @return  Read/write reference to the character.\n       *  @throw  std::out_of_range  If @a n is an invalid index.\n       *\n       *  This function provides for safer data access.  The parameter is\n       *  first checked that it is in the range of the string.  The function\n       *  throws out_of_range if the check fails.\n       */\n      reference\n      at(size_type __n)\n      {\n\tif (__n >= size())\n\t  __throw_out_of_range_fmt(__N(\"basic_string::at: __n \"\n\t\t\t\t       \"(which is %zu) >= this->size() \"\n\t\t\t\t       \"(which is %zu)\"),\n\t\t\t\t   __n, this->size());\n\treturn _M_data()[__n];\n      }\n\n#if __cplusplus >= 201103L\n      /**\n       *  Returns a read/write reference to the data at the first\n       *  element of the %string.\n       */\n      reference\n      front() noexcept\n      {\n\t__glibcxx_assert(!empty());\n\treturn operator[](0);\n      }\n\n      /**\n       *  Returns a read-only (constant) reference to the data at the first\n       *  element of the %string.\n       */\n      const_reference\n      front() const noexcept\n      {\n\t__glibcxx_assert(!empty());\n\treturn operator[](0);\n      }\n\n      /**\n       *  Returns a read/write reference to the data at the last\n       *  element of the %string.\n       */\n      reference\n      back() noexcept\n      {\n\t__glibcxx_assert(!empty());\n\treturn operator[](this->size() - 1);\n      }\n\n      /**\n       *  Returns a read-only (constant) reference to the data at the\n       *  last element of the %string.\n       */\n      const_reference\n      back() const noexcept\n      {\n\t__glibcxx_assert(!empty());\n\treturn operator[](this->size() - 1);\n      }\n#endif\n\n      // Modifiers:\n      /**\n       *  @brief  Append a string to this string.\n       *  @param __str  The string to append.\n       *  @return  Reference to this string.\n       */\n      basic_string&\n      operator+=(const basic_string& __str)\n      { return this->append(__str); }\n\n      /**\n       *  @brief  Append a C string.\n       *  @param __s  The C string to append.\n       *  @return  Reference to this string.\n       */\n      basic_string&\n      operator+=(const _CharT* __s)\n      { return this->append(__s); }\n\n      /**\n       *  @brief  Append a character.\n       *  @param __c  The character to append.\n       *  @return  Reference to this string.\n       */\n      basic_string&\n      operator+=(_CharT __c)\n      {\n\tthis->push_back(__c);\n\treturn *this;\n      }\n\n#if __cplusplus >= 201103L\n      /**\n       *  @brief  Append an initializer_list of characters.\n       *  @param __l  The initializer_list of characters to be appended.\n       *  @return  Reference to this string.\n       */\n      basic_string&\n      operator+=(initializer_list<_CharT> __l)\n      { return this->append(__l.begin(), __l.size()); }\n#endif // C++11\n\n#if __cplusplus > 201402L\n      /**\n       *  @brief  Append a string_view.\n       *  @param __svt  An object convertible to string_view to be appended.\n       *  @return  Reference to this string.\n       */\n      template<typename _Tp>\n\t_If_sv<_Tp, basic_string&>\n\toperator+=(const _Tp& __svt)\n\t{ return this->append(__svt); }\n#endif // C++17\n\n      /**\n       *  @brief  Append a string to this string.\n       *  @param __str  The string to append.\n       *  @return  Reference to this string.\n       */\n      basic_string&\n      append(const basic_string& __str)\n      { return _M_append(__str._M_data(), __str.size()); }\n\n      /**\n       *  @brief  Append a substring.\n       *  @param __str  The string to append.\n       *  @param __pos  Index of the first character of str to append.\n       *  @param __n  The number of characters to append.\n       *  @return  Reference to this string.\n       *  @throw  std::out_of_range if @a __pos is not a valid index.\n       *\n       *  This function appends @a __n characters from @a __str\n       *  starting at @a __pos to this string.  If @a __n is is larger\n       *  than the number of available characters in @a __str, the\n       *  remainder of @a __str is appended.\n       */\n      basic_string&\n      append(const basic_string& __str, size_type __pos, size_type __n = npos)\n      { return _M_append(__str._M_data()\n\t\t\t + __str._M_check(__pos, \"basic_string::append\"),\n\t\t\t __str._M_limit(__pos, __n)); }\n\n      /**\n       *  @brief  Append a C substring.\n       *  @param __s  The C string to append.\n       *  @param __n  The number of characters to append.\n       *  @return  Reference to this string.\n       */\n      basic_string&\n      append(const _CharT* __s, size_type __n)\n      {\n\t__glibcxx_requires_string_len(__s, __n);\n\t_M_check_length(size_type(0), __n, \"basic_string::append\");\n\treturn _M_append(__s, __n);\n      }\n\n      /**\n       *  @brief  Append a C string.\n       *  @param __s  The C string to append.\n       *  @return  Reference to this string.\n       */\n      basic_string&\n      append(const _CharT* __s)\n      {\n\t__glibcxx_requires_string(__s);\n\tconst size_type __n = traits_type::length(__s);\n\t_M_check_length(size_type(0), __n, \"basic_string::append\");\n\treturn _M_append(__s, __n);\n      }\n\n      /**\n       *  @brief  Append multiple characters.\n       *  @param __n  The number of characters to append.\n       *  @param __c  The character to use.\n       *  @return  Reference to this string.\n       *\n       *  Appends __n copies of __c to this string.\n       */\n      basic_string&\n      append(size_type __n, _CharT __c)\n      { return _M_replace_aux(this->size(), size_type(0), __n, __c); }\n\n#if __cplusplus >= 201103L\n      /**\n       *  @brief  Append an initializer_list of characters.\n       *  @param __l  The initializer_list of characters to append.\n       *  @return  Reference to this string.\n       */\n      basic_string&\n      append(initializer_list<_CharT> __l)\n      { return this->append(__l.begin(), __l.size()); }\n#endif // C++11\n\n      /**\n       *  @brief  Append a range of characters.\n       *  @param __first  Iterator referencing the first character to append.\n       *  @param __last  Iterator marking the end of the range.\n       *  @return  Reference to this string.\n       *\n       *  Appends characters in the range [__first,__last) to this string.\n       */\n#if __cplusplus >= 201103L\n      template<class _InputIterator,\n\t       typename = std::_RequireInputIter<_InputIterator>>\n#else\n      template<class _InputIterator>\n#endif\n        basic_string&\n        append(_InputIterator __first, _InputIterator __last)\n        { return this->replace(end(), end(), __first, __last); }\n\n#if __cplusplus > 201402L\n      /**\n       *  @brief  Append a string_view.\n       *  @param __svt  An object convertible to string_view to be appended.\n       *  @return  Reference to this string.\n       */\n      template<typename _Tp>\n        _If_sv<_Tp, basic_string&>\n        append(const _Tp& __svt)\n        {\n          __sv_type __sv = __svt;\n          return this->append(__sv.data(), __sv.size());\n        }\n\n      /**\n       *  @brief  Append a range of characters from a string_view.\n       *  @param __svt  An object convertible to string_view to be appended from.\n       *  @param __pos The position in the string_view to append from.\n       *  @param __n   The number of characters to append from the string_view.\n       *  @return  Reference to this string.\n       */\n      template<typename _Tp>\n        _If_sv<_Tp, basic_string&>\n\tappend(const _Tp& __svt, size_type __pos, size_type __n = npos)\n\t{\n\t  __sv_type __sv = __svt;\n\t  return _M_append(__sv.data()\n\t\t\t   + __sv._M_check(__pos, \"basic_string::append\"),\n\t\t\t   __sv._M_limit(__pos, __n));\n\t}\n#endif // C++17\n\n      /**\n       *  @brief  Append a single character.\n       *  @param __c  Character to append.\n       */\n      void\n      push_back(_CharT __c)\n      {\n\tconst size_type __size = this->size();\n\tif (__size + 1 > this->capacity())\n\t  this->_M_mutate(__size, size_type(0), 0, size_type(1));\n\ttraits_type::assign(this->_M_data()[__size], __c);\n\tthis->_M_set_length(__size + 1);\n      }\n\n      /**\n       *  @brief  Set value to contents of another string.\n       *  @param  __str  Source string to use.\n       *  @return  Reference to this string.\n       */\n      basic_string&\n      assign(const basic_string& __str)\n      {\n\tthis->_M_assign(__str);\n\treturn *this;\n      }\n\n#if __cplusplus >= 201103L\n      /**\n       *  @brief  Set value to contents of another string.\n       *  @param  __str  Source string to use.\n       *  @return  Reference to this string.\n       *\n       *  This function sets this string to the exact contents of @a __str.\n       *  @a __str is a valid, but unspecified string.\n       */\n      basic_string&\n      assign(basic_string&& __str)\n      noexcept(_Alloc_traits::_S_nothrow_move())\n      {\n\t// _GLIBCXX_RESOLVE_LIB_DEFECTS\n\t// 2063. Contradictory requirements for string move assignment\n\treturn *this = std::move(__str);\n      }\n#endif // C++11\n\n      /**\n       *  @brief  Set value to a substring of a string.\n       *  @param __str  The string to use.\n       *  @param __pos  Index of the first character of str.\n       *  @param __n  Number of characters to use.\n       *  @return  Reference to this string.\n       *  @throw  std::out_of_range if @a pos is not a valid index.\n       *\n       *  This function sets this string to the substring of @a __str\n       *  consisting of @a __n characters at @a __pos.  If @a __n is\n       *  is larger than the number of available characters in @a\n       *  __str, the remainder of @a __str is used.\n       */\n      basic_string&\n      assign(const basic_string& __str, size_type __pos, size_type __n = npos)\n      { return _M_replace(size_type(0), this->size(), __str._M_data()\n\t\t\t  + __str._M_check(__pos, \"basic_string::assign\"),\n\t\t\t  __str._M_limit(__pos, __n)); }\n\n      /**\n       *  @brief  Set value to a C substring.\n       *  @param __s  The C string to use.\n       *  @param __n  Number of characters to use.\n       *  @return  Reference to this string.\n       *\n       *  This function sets the value of this string to the first @a __n\n       *  characters of @a __s.  If @a __n is is larger than the number of\n       *  available characters in @a __s, the remainder of @a __s is used.\n       */\n      basic_string&\n      assign(const _CharT* __s, size_type __n)\n      {\n\t__glibcxx_requires_string_len(__s, __n);\n\treturn _M_replace(size_type(0), this->size(), __s, __n);\n      }\n\n      /**\n       *  @brief  Set value to contents of a C string.\n       *  @param __s  The C string to use.\n       *  @return  Reference to this string.\n       *\n       *  This function sets the value of this string to the value of @a __s.\n       *  The data is copied, so there is no dependence on @a __s once the\n       *  function returns.\n       */\n      basic_string&\n      assign(const _CharT* __s)\n      {\n\t__glibcxx_requires_string(__s);\n\treturn _M_replace(size_type(0), this->size(), __s,\n\t\t\t  traits_type::length(__s));\n      }\n\n      /**\n       *  @brief  Set value to multiple characters.\n       *  @param __n  Length of the resulting string.\n       *  @param __c  The character to use.\n       *  @return  Reference to this string.\n       *\n       *  This function sets the value of this string to @a __n copies of\n       *  character @a __c.\n       */\n      basic_string&\n      assign(size_type __n, _CharT __c)\n      { return _M_replace_aux(size_type(0), this->size(), __n, __c); }\n\n      /**\n       *  @brief  Set value to a range of characters.\n       *  @param __first  Iterator referencing the first character to append.\n       *  @param __last  Iterator marking the end of the range.\n       *  @return  Reference to this string.\n       *\n       *  Sets value of string to characters in the range [__first,__last).\n      */\n#if __cplusplus >= 201103L\n      template<class _InputIterator,\n\t       typename = std::_RequireInputIter<_InputIterator>>\n#else\n      template<class _InputIterator>\n#endif\n        basic_string&\n        assign(_InputIterator __first, _InputIterator __last)\n        { return this->replace(begin(), end(), __first, __last); }\n\n#if __cplusplus >= 201103L\n      /**\n       *  @brief  Set value to an initializer_list of characters.\n       *  @param __l  The initializer_list of characters to assign.\n       *  @return  Reference to this string.\n       */\n      basic_string&\n      assign(initializer_list<_CharT> __l)\n      { return this->assign(__l.begin(), __l.size()); }\n#endif // C++11\n\n#if __cplusplus > 201402L\n      /**\n       *  @brief  Set value from a string_view.\n       *  @param __svt  The source object convertible to string_view.\n       *  @return  Reference to this string.\n       */\n      template<typename _Tp>\n\t_If_sv<_Tp, basic_string&>\n\tassign(const _Tp& __svt)\n\t{\n\t  __sv_type __sv = __svt;\n\t  return this->assign(__sv.data(), __sv.size());\n\t}\n\n      /**\n       *  @brief  Set value from a range of characters in a string_view.\n       *  @param __svt  The source object convertible to string_view.\n       *  @param __pos  The position in the string_view to assign from.\n       *  @param __n  The number of characters to assign.\n       *  @return  Reference to this string.\n       */\n      template<typename _Tp>\n\t_If_sv<_Tp, basic_string&>\n\tassign(const _Tp& __svt, size_type __pos, size_type __n = npos)\n\t{\n\t  __sv_type __sv = __svt;\n\t  return _M_replace(size_type(0), this->size(), __sv.data()\n\t\t\t    + __sv._M_check(__pos, \"basic_string::assign\"),\n\t\t\t    __sv._M_limit(__pos, __n));\n\t}\n#endif // C++17\n\n#if __cplusplus >= 201103L\n      /**\n       *  @brief  Insert multiple characters.\n       *  @param __p  Const_iterator referencing location in string to\n       *              insert at.\n       *  @param __n  Number of characters to insert\n       *  @param __c  The character to insert.\n       *  @return  Iterator referencing the first inserted char.\n       *  @throw  std::length_error  If new length exceeds @c max_size().\n       *\n       *  Inserts @a __n copies of character @a __c starting at the\n       *  position referenced by iterator @a __p.  If adding\n       *  characters causes the length to exceed max_size(),\n       *  length_error is thrown.  The value of the string doesn't\n       *  change if an error is thrown.\n      */\n      iterator\n      insert(const_iterator __p, size_type __n, _CharT __c)\n      {\n\t_GLIBCXX_DEBUG_PEDASSERT(__p >= begin() && __p <= end());\n\tconst size_type __pos = __p - begin();\n\tthis->replace(__p, __p, __n, __c);\n\treturn iterator(this->_M_data() + __pos);\n      }\n#else\n      /**\n       *  @brief  Insert multiple characters.\n       *  @param __p  Iterator referencing location in string to insert at.\n       *  @param __n  Number of characters to insert\n       *  @param __c  The character to insert.\n       *  @throw  std::length_error  If new length exceeds @c max_size().\n       *\n       *  Inserts @a __n copies of character @a __c starting at the\n       *  position referenced by iterator @a __p.  If adding\n       *  characters causes the length to exceed max_size(),\n       *  length_error is thrown.  The value of the string doesn't\n       *  change if an error is thrown.\n      */\n      void\n      insert(iterator __p, size_type __n, _CharT __c)\n      {\tthis->replace(__p, __p, __n, __c);  }\n#endif\n\n#if __cplusplus >= 201103L\n      /**\n       *  @brief  Insert a range of characters.\n       *  @param __p  Const_iterator referencing location in string to\n       *              insert at.\n       *  @param __beg  Start of range.\n       *  @param __end  End of range.\n       *  @return  Iterator referencing the first inserted char.\n       *  @throw  std::length_error  If new length exceeds @c max_size().\n       *\n       *  Inserts characters in range [beg,end).  If adding characters\n       *  causes the length to exceed max_size(), length_error is\n       *  thrown.  The value of the string doesn't change if an error\n       *  is thrown.\n      */\n      template<class _InputIterator,\n\t       typename = std::_RequireInputIter<_InputIterator>>\n\titerator\n        insert(const_iterator __p, _InputIterator __beg, _InputIterator __end)\n        {\n\t  _GLIBCXX_DEBUG_PEDASSERT(__p >= begin() && __p <= end());\n\t  const size_type __pos = __p - begin();\n\t  this->replace(__p, __p, __beg, __end);\n\t  return iterator(this->_M_data() + __pos);\n\t}\n#else\n      /**\n       *  @brief  Insert a range of characters.\n       *  @param __p  Iterator referencing location in string to insert at.\n       *  @param __beg  Start of range.\n       *  @param __end  End of range.\n       *  @throw  std::length_error  If new length exceeds @c max_size().\n       *\n       *  Inserts characters in range [__beg,__end).  If adding\n       *  characters causes the length to exceed max_size(),\n       *  length_error is thrown.  The value of the string doesn't\n       *  change if an error is thrown.\n      */\n      template<class _InputIterator>\n        void\n        insert(iterator __p, _InputIterator __beg, _InputIterator __end)\n        { this->replace(__p, __p, __beg, __end); }\n#endif\n\n#if __cplusplus >= 201103L\n      /**\n       *  @brief  Insert an initializer_list of characters.\n       *  @param __p  Iterator referencing location in string to insert at.\n       *  @param __l  The initializer_list of characters to insert.\n       *  @throw  std::length_error  If new length exceeds @c max_size().\n       */\n      void\n      insert(iterator __p, initializer_list<_CharT> __l)\n      {\n\t_GLIBCXX_DEBUG_PEDASSERT(__p >= begin() && __p <= end());\n\tthis->insert(__p - begin(), __l.begin(), __l.size());\n      }\n#endif // C++11\n\n      /**\n       *  @brief  Insert value of a string.\n       *  @param __pos1  Iterator referencing location in string to insert at.\n       *  @param __str  The string to insert.\n       *  @return  Reference to this string.\n       *  @throw  std::length_error  If new length exceeds @c max_size().\n       *\n       *  Inserts value of @a __str starting at @a __pos1.  If adding\n       *  characters causes the length to exceed max_size(),\n       *  length_error is thrown.  The value of the string doesn't\n       *  change if an error is thrown.\n      */\n      basic_string&\n      insert(size_type __pos1, const basic_string& __str)\n      { return this->replace(__pos1, size_type(0),\n\t\t\t     __str._M_data(), __str.size()); }\n\n      /**\n       *  @brief  Insert a substring.\n       *  @param __pos1  Iterator referencing location in string to insert at.\n       *  @param __str  The string to insert.\n       *  @param __pos2  Start of characters in str to insert.\n       *  @param __n  Number of characters to insert.\n       *  @return  Reference to this string.\n       *  @throw  std::length_error  If new length exceeds @c max_size().\n       *  @throw  std::out_of_range  If @a pos1 > size() or\n       *  @a __pos2 > @a str.size().\n       *\n       *  Starting at @a pos1, insert @a __n character of @a __str\n       *  beginning with @a __pos2.  If adding characters causes the\n       *  length to exceed max_size(), length_error is thrown.  If @a\n       *  __pos1 is beyond the end of this string or @a __pos2 is\n       *  beyond the end of @a __str, out_of_range is thrown.  The\n       *  value of the string doesn't change if an error is thrown.\n      */\n      basic_string&\n      insert(size_type __pos1, const basic_string& __str,\n\t     size_type __pos2, size_type __n = npos)\n      { return this->replace(__pos1, size_type(0), __str._M_data()\n\t\t\t     + __str._M_check(__pos2, \"basic_string::insert\"),\n\t\t\t     __str._M_limit(__pos2, __n)); }\n\n      /**\n       *  @brief  Insert a C substring.\n       *  @param __pos  Iterator referencing location in string to insert at.\n       *  @param __s  The C string to insert.\n       *  @param __n  The number of characters to insert.\n       *  @return  Reference to this string.\n       *  @throw  std::length_error  If new length exceeds @c max_size().\n       *  @throw  std::out_of_range  If @a __pos is beyond the end of this\n       *  string.\n       *\n       *  Inserts the first @a __n characters of @a __s starting at @a\n       *  __pos.  If adding characters causes the length to exceed\n       *  max_size(), length_error is thrown.  If @a __pos is beyond\n       *  end(), out_of_range is thrown.  The value of the string\n       *  doesn't change if an error is thrown.\n      */\n      basic_string&\n      insert(size_type __pos, const _CharT* __s, size_type __n)\n      { return this->replace(__pos, size_type(0), __s, __n); }\n\n      /**\n       *  @brief  Insert a C string.\n       *  @param __pos  Iterator referencing location in string to insert at.\n       *  @param __s  The C string to insert.\n       *  @return  Reference to this string.\n       *  @throw  std::length_error  If new length exceeds @c max_size().\n       *  @throw  std::out_of_range  If @a pos is beyond the end of this\n       *  string.\n       *\n       *  Inserts the first @a n characters of @a __s starting at @a __pos.  If\n       *  adding characters causes the length to exceed max_size(),\n       *  length_error is thrown.  If @a __pos is beyond end(), out_of_range is\n       *  thrown.  The value of the string doesn't change if an error is\n       *  thrown.\n      */\n      basic_string&\n      insert(size_type __pos, const _CharT* __s)\n      {\n\t__glibcxx_requires_string(__s);\n\treturn this->replace(__pos, size_type(0), __s,\n\t\t\t     traits_type::length(__s));\n      }\n\n      /**\n       *  @brief  Insert multiple characters.\n       *  @param __pos  Index in string to insert at.\n       *  @param __n  Number of characters to insert\n       *  @param __c  The character to insert.\n       *  @return  Reference to this string.\n       *  @throw  std::length_error  If new length exceeds @c max_size().\n       *  @throw  std::out_of_range  If @a __pos is beyond the end of this\n       *  string.\n       *\n       *  Inserts @a __n copies of character @a __c starting at index\n       *  @a __pos.  If adding characters causes the length to exceed\n       *  max_size(), length_error is thrown.  If @a __pos > length(),\n       *  out_of_range is thrown.  The value of the string doesn't\n       *  change if an error is thrown.\n      */\n      basic_string&\n      insert(size_type __pos, size_type __n, _CharT __c)\n      { return _M_replace_aux(_M_check(__pos, \"basic_string::insert\"),\n\t\t\t      size_type(0), __n, __c); }\n\n      /**\n       *  @brief  Insert one character.\n       *  @param __p  Iterator referencing position in string to insert at.\n       *  @param __c  The character to insert.\n       *  @return  Iterator referencing newly inserted char.\n       *  @throw  std::length_error  If new length exceeds @c max_size().\n       *\n       *  Inserts character @a __c at position referenced by @a __p.\n       *  If adding character causes the length to exceed max_size(),\n       *  length_error is thrown.  If @a __p is beyond end of string,\n       *  out_of_range is thrown.  The value of the string doesn't\n       *  change if an error is thrown.\n      */\n      iterator\n      insert(__const_iterator __p, _CharT __c)\n      {\n\t_GLIBCXX_DEBUG_PEDASSERT(__p >= begin() && __p <= end());\n\tconst size_type __pos = __p - begin();\n\t_M_replace_aux(__pos, size_type(0), size_type(1), __c);\n\treturn iterator(_M_data() + __pos);\n      }\n\n#if __cplusplus > 201402L\n      /**\n       *  @brief  Insert a string_view.\n       *  @param __pos  Iterator referencing position in string to insert at.\n       *  @param __svt  The object convertible to string_view to insert.\n       *  @return  Reference to this string.\n      */\n      template<typename _Tp>\n\t_If_sv<_Tp, basic_string&>\n\tinsert(size_type __pos, const _Tp& __svt)\n\t{\n\t  __sv_type __sv = __svt;\n\t  return this->insert(__pos, __sv.data(), __sv.size());\n\t}\n\n      /**\n       *  @brief  Insert a string_view.\n       *  @param __pos  Iterator referencing position in string to insert at.\n       *  @param __svt  The object convertible to string_view to insert from.\n       *  @param __pos  Iterator referencing position in string_view to insert\n       *  from.\n       *  @param __n    The number of characters to insert.\n       *  @return  Reference to this string.\n      */\n      template<typename _Tp>\n\t_If_sv<_Tp, basic_string&>\n\tinsert(size_type __pos1, const _Tp& __svt,\n\t       size_type __pos2, size_type __n = npos)\n\t{\n\t  __sv_type __sv = __svt;\n\t  return this->replace(__pos1, size_type(0), __sv.data()\n\t\t\t       + __sv._M_check(__pos2, \"basic_string::insert\"),\n\t\t\t       __sv._M_limit(__pos2, __n));\n\t}\n#endif // C++17\n\n      /**\n       *  @brief  Remove characters.\n       *  @param __pos  Index of first character to remove (default 0).\n       *  @param __n  Number of characters to remove (default remainder).\n       *  @return  Reference to this string.\n       *  @throw  std::out_of_range  If @a pos is beyond the end of this\n       *  string.\n       *\n       *  Removes @a __n characters from this string starting at @a\n       *  __pos.  The length of the string is reduced by @a __n.  If\n       *  there are < @a __n characters to remove, the remainder of\n       *  the string is truncated.  If @a __p is beyond end of string,\n       *  out_of_range is thrown.  The value of the string doesn't\n       *  change if an error is thrown.\n      */\n      basic_string&\n      erase(size_type __pos = 0, size_type __n = npos)\n      {\n\t_M_check(__pos, \"basic_string::erase\");\n\tif (__n == npos)\n\t  this->_M_set_length(__pos);\n\telse if (__n != 0)\n\t  this->_M_erase(__pos, _M_limit(__pos, __n));\n\treturn *this;\n      }\n\n      /**\n       *  @brief  Remove one character.\n       *  @param __position  Iterator referencing the character to remove.\n       *  @return  iterator referencing same location after removal.\n       *\n       *  Removes the character at @a __position from this string. The value\n       *  of the string doesn't change if an error is thrown.\n      */\n      iterator\n      erase(__const_iterator __position)\n      {\n\t_GLIBCXX_DEBUG_PEDASSERT(__position >= begin()\n\t\t\t\t && __position < end());\n\tconst size_type __pos = __position - begin();\n\tthis->_M_erase(__pos, size_type(1));\n\treturn iterator(_M_data() + __pos);\n      }\n\n      /**\n       *  @brief  Remove a range of characters.\n       *  @param __first  Iterator referencing the first character to remove.\n       *  @param __last  Iterator referencing the end of the range.\n       *  @return  Iterator referencing location of first after removal.\n       *\n       *  Removes the characters in the range [first,last) from this string.\n       *  The value of the string doesn't change if an error is thrown.\n      */\n      iterator\n      erase(__const_iterator __first, __const_iterator __last)\n      {\n\t_GLIBCXX_DEBUG_PEDASSERT(__first >= begin() && __first <= __last\n\t\t\t\t && __last <= end());\n        const size_type __pos = __first - begin();\n\tif (__last == end())\n\t  this->_M_set_length(__pos);\n\telse\n\t  this->_M_erase(__pos, __last - __first);\n\treturn iterator(this->_M_data() + __pos);\n      }\n\n#if __cplusplus >= 201103L\n      /**\n       *  @brief  Remove the last character.\n       *\n       *  The string must be non-empty.\n       */\n      void\n      pop_back() noexcept\n      {\n\t__glibcxx_assert(!empty());\n\t_M_erase(size() - 1, 1);\n      }\n#endif // C++11\n\n      /**\n       *  @brief  Replace characters with value from another string.\n       *  @param __pos  Index of first character to replace.\n       *  @param __n  Number of characters to be replaced.\n       *  @param __str  String to insert.\n       *  @return  Reference to this string.\n       *  @throw  std::out_of_range  If @a pos is beyond the end of this\n       *  string.\n       *  @throw  std::length_error  If new length exceeds @c max_size().\n       *\n       *  Removes the characters in the range [__pos,__pos+__n) from\n       *  this string.  In place, the value of @a __str is inserted.\n       *  If @a __pos is beyond end of string, out_of_range is thrown.\n       *  If the length of the result exceeds max_size(), length_error\n       *  is thrown.  The value of the string doesn't change if an\n       *  error is thrown.\n      */\n      basic_string&\n      replace(size_type __pos, size_type __n, const basic_string& __str)\n      { return this->replace(__pos, __n, __str._M_data(), __str.size()); }\n\n      /**\n       *  @brief  Replace characters with value from another string.\n       *  @param __pos1  Index of first character to replace.\n       *  @param __n1  Number of characters to be replaced.\n       *  @param __str  String to insert.\n       *  @param __pos2  Index of first character of str to use.\n       *  @param __n2  Number of characters from str to use.\n       *  @return  Reference to this string.\n       *  @throw  std::out_of_range  If @a __pos1 > size() or @a __pos2 >\n       *  __str.size().\n       *  @throw  std::length_error  If new length exceeds @c max_size().\n       *\n       *  Removes the characters in the range [__pos1,__pos1 + n) from this\n       *  string.  In place, the value of @a __str is inserted.  If @a __pos is\n       *  beyond end of string, out_of_range is thrown.  If the length of the\n       *  result exceeds max_size(), length_error is thrown.  The value of the\n       *  string doesn't change if an error is thrown.\n      */\n      basic_string&\n      replace(size_type __pos1, size_type __n1, const basic_string& __str,\n\t      size_type __pos2, size_type __n2 = npos)\n      { return this->replace(__pos1, __n1, __str._M_data()\n\t\t\t     + __str._M_check(__pos2, \"basic_string::replace\"),\n\t\t\t     __str._M_limit(__pos2, __n2)); }\n\n      /**\n       *  @brief  Replace characters with value of a C substring.\n       *  @param __pos  Index of first character to replace.\n       *  @param __n1  Number of characters to be replaced.\n       *  @param __s  C string to insert.\n       *  @param __n2  Number of characters from @a s to use.\n       *  @return  Reference to this string.\n       *  @throw  std::out_of_range  If @a pos1 > size().\n       *  @throw  std::length_error  If new length exceeds @c max_size().\n       *\n       *  Removes the characters in the range [__pos,__pos + __n1)\n       *  from this string.  In place, the first @a __n2 characters of\n       *  @a __s are inserted, or all of @a __s if @a __n2 is too large.  If\n       *  @a __pos is beyond end of string, out_of_range is thrown.  If\n       *  the length of result exceeds max_size(), length_error is\n       *  thrown.  The value of the string doesn't change if an error\n       *  is thrown.\n      */\n      basic_string&\n      replace(size_type __pos, size_type __n1, const _CharT* __s,\n\t      size_type __n2)\n      {\n\t__glibcxx_requires_string_len(__s, __n2);\n\treturn _M_replace(_M_check(__pos, \"basic_string::replace\"),\n\t\t\t  _M_limit(__pos, __n1), __s, __n2);\n      }\n\n      /**\n       *  @brief  Replace characters with value of a C string.\n       *  @param __pos  Index of first character to replace.\n       *  @param __n1  Number of characters to be replaced.\n       *  @param __s  C string to insert.\n       *  @return  Reference to this string.\n       *  @throw  std::out_of_range  If @a pos > size().\n       *  @throw  std::length_error  If new length exceeds @c max_size().\n       *\n       *  Removes the characters in the range [__pos,__pos + __n1)\n       *  from this string.  In place, the characters of @a __s are\n       *  inserted.  If @a __pos is beyond end of string, out_of_range\n       *  is thrown.  If the length of result exceeds max_size(),\n       *  length_error is thrown.  The value of the string doesn't\n       *  change if an error is thrown.\n      */\n      basic_string&\n      replace(size_type __pos, size_type __n1, const _CharT* __s)\n      {\n\t__glibcxx_requires_string(__s);\n\treturn this->replace(__pos, __n1, __s, traits_type::length(__s));\n      }\n\n      /**\n       *  @brief  Replace characters with multiple characters.\n       *  @param __pos  Index of first character to replace.\n       *  @param __n1  Number of characters to be replaced.\n       *  @param __n2  Number of characters to insert.\n       *  @param __c  Character to insert.\n       *  @return  Reference to this string.\n       *  @throw  std::out_of_range  If @a __pos > size().\n       *  @throw  std::length_error  If new length exceeds @c max_size().\n       *\n       *  Removes the characters in the range [pos,pos + n1) from this\n       *  string.  In place, @a __n2 copies of @a __c are inserted.\n       *  If @a __pos is beyond end of string, out_of_range is thrown.\n       *  If the length of result exceeds max_size(), length_error is\n       *  thrown.  The value of the string doesn't change if an error\n       *  is thrown.\n      */\n      basic_string&\n      replace(size_type __pos, size_type __n1, size_type __n2, _CharT __c)\n      { return _M_replace_aux(_M_check(__pos, \"basic_string::replace\"),\n\t\t\t      _M_limit(__pos, __n1), __n2, __c); }\n\n      /**\n       *  @brief  Replace range of characters with string.\n       *  @param __i1  Iterator referencing start of range to replace.\n       *  @param __i2  Iterator referencing end of range to replace.\n       *  @param __str  String value to insert.\n       *  @return  Reference to this string.\n       *  @throw  std::length_error  If new length exceeds @c max_size().\n       *\n       *  Removes the characters in the range [__i1,__i2).  In place,\n       *  the value of @a __str is inserted.  If the length of result\n       *  exceeds max_size(), length_error is thrown.  The value of\n       *  the string doesn't change if an error is thrown.\n      */\n      basic_string&\n      replace(__const_iterator __i1, __const_iterator __i2,\n\t      const basic_string& __str)\n      { return this->replace(__i1, __i2, __str._M_data(), __str.size()); }\n\n      /**\n       *  @brief  Replace range of characters with C substring.\n       *  @param __i1  Iterator referencing start of range to replace.\n       *  @param __i2  Iterator referencing end of range to replace.\n       *  @param __s  C string value to insert.\n       *  @param __n  Number of characters from s to insert.\n       *  @return  Reference to this string.\n       *  @throw  std::length_error  If new length exceeds @c max_size().\n       *\n       *  Removes the characters in the range [__i1,__i2).  In place,\n       *  the first @a __n characters of @a __s are inserted.  If the\n       *  length of result exceeds max_size(), length_error is thrown.\n       *  The value of the string doesn't change if an error is\n       *  thrown.\n      */\n      basic_string&\n      replace(__const_iterator __i1, __const_iterator __i2,\n\t      const _CharT* __s, size_type __n)\n      {\n\t_GLIBCXX_DEBUG_PEDASSERT(begin() <= __i1 && __i1 <= __i2\n\t\t\t\t && __i2 <= end());\n\treturn this->replace(__i1 - begin(), __i2 - __i1, __s, __n);\n      }\n\n      /**\n       *  @brief  Replace range of characters with C string.\n       *  @param __i1  Iterator referencing start of range to replace.\n       *  @param __i2  Iterator referencing end of range to replace.\n       *  @param __s  C string value to insert.\n       *  @return  Reference to this string.\n       *  @throw  std::length_error  If new length exceeds @c max_size().\n       *\n       *  Removes the characters in the range [__i1,__i2).  In place,\n       *  the characters of @a __s are inserted.  If the length of\n       *  result exceeds max_size(), length_error is thrown.  The\n       *  value of the string doesn't change if an error is thrown.\n      */\n      basic_string&\n      replace(__const_iterator __i1, __const_iterator __i2, const _CharT* __s)\n      {\n\t__glibcxx_requires_string(__s);\n\treturn this->replace(__i1, __i2, __s, traits_type::length(__s));\n      }\n\n      /**\n       *  @brief  Replace range of characters with multiple characters\n       *  @param __i1  Iterator referencing start of range to replace.\n       *  @param __i2  Iterator referencing end of range to replace.\n       *  @param __n  Number of characters to insert.\n       *  @param __c  Character to insert.\n       *  @return  Reference to this string.\n       *  @throw  std::length_error  If new length exceeds @c max_size().\n       *\n       *  Removes the characters in the range [__i1,__i2).  In place,\n       *  @a __n copies of @a __c are inserted.  If the length of\n       *  result exceeds max_size(), length_error is thrown.  The\n       *  value of the string doesn't change if an error is thrown.\n      */\n      basic_string&\n      replace(__const_iterator __i1, __const_iterator __i2, size_type __n,\n\t      _CharT __c)\n      {\n\t_GLIBCXX_DEBUG_PEDASSERT(begin() <= __i1 && __i1 <= __i2\n\t\t\t\t && __i2 <= end());\n\treturn _M_replace_aux(__i1 - begin(), __i2 - __i1, __n, __c);\n      }\n\n      /**\n       *  @brief  Replace range of characters with range.\n       *  @param __i1  Iterator referencing start of range to replace.\n       *  @param __i2  Iterator referencing end of range to replace.\n       *  @param __k1  Iterator referencing start of range to insert.\n       *  @param __k2  Iterator referencing end of range to insert.\n       *  @return  Reference to this string.\n       *  @throw  std::length_error  If new length exceeds @c max_size().\n       *\n       *  Removes the characters in the range [__i1,__i2).  In place,\n       *  characters in the range [__k1,__k2) are inserted.  If the\n       *  length of result exceeds max_size(), length_error is thrown.\n       *  The value of the string doesn't change if an error is\n       *  thrown.\n      */\n#if __cplusplus >= 201103L\n      template<class _InputIterator,\n\t       typename = std::_RequireInputIter<_InputIterator>>\n        basic_string&\n        replace(const_iterator __i1, const_iterator __i2,\n\t\t_InputIterator __k1, _InputIterator __k2)\n        {\n\t  _GLIBCXX_DEBUG_PEDASSERT(begin() <= __i1 && __i1 <= __i2\n\t\t\t\t   && __i2 <= end());\n\t  __glibcxx_requires_valid_range(__k1, __k2);\n\t  return this->_M_replace_dispatch(__i1, __i2, __k1, __k2,\n\t\t\t\t\t   std::__false_type());\n\t}\n#else\n      template<class _InputIterator>\n#ifdef _GLIBCXX_DISAMBIGUATE_REPLACE_INST\n        typename __enable_if_not_native_iterator<_InputIterator>::__type\n#else\n        basic_string&\n#endif\n        replace(iterator __i1, iterator __i2,\n\t\t_InputIterator __k1, _InputIterator __k2)\n        {\n\t  _GLIBCXX_DEBUG_PEDASSERT(begin() <= __i1 && __i1 <= __i2\n\t\t\t\t   && __i2 <= end());\n\t  __glibcxx_requires_valid_range(__k1, __k2);\n\t  typedef typename std::__is_integer<_InputIterator>::__type _Integral;\n\t  return _M_replace_dispatch(__i1, __i2, __k1, __k2, _Integral());\n\t}\n#endif\n\n      // Specializations for the common case of pointer and iterator:\n      // useful to avoid the overhead of temporary buffering in _M_replace.\n      basic_string&\n      replace(__const_iterator __i1, __const_iterator __i2,\n\t      _CharT* __k1, _CharT* __k2)\n      {\n\t_GLIBCXX_DEBUG_PEDASSERT(begin() <= __i1 && __i1 <= __i2\n\t\t\t\t && __i2 <= end());\n\t__glibcxx_requires_valid_range(__k1, __k2);\n\treturn this->replace(__i1 - begin(), __i2 - __i1,\n\t\t\t     __k1, __k2 - __k1);\n      }\n\n      basic_string&\n      replace(__const_iterator __i1, __const_iterator __i2,\n\t      const _CharT* __k1, const _CharT* __k2)\n      {\n\t_GLIBCXX_DEBUG_PEDASSERT(begin() <= __i1 && __i1 <= __i2\n\t\t\t\t && __i2 <= end());\n\t__glibcxx_requires_valid_range(__k1, __k2);\n\treturn this->replace(__i1 - begin(), __i2 - __i1,\n\t\t\t     __k1, __k2 - __k1);\n      }\n\n      basic_string&\n      replace(__const_iterator __i1, __const_iterator __i2,\n\t      iterator __k1, iterator __k2)\n      {\n\t_GLIBCXX_DEBUG_PEDASSERT(begin() <= __i1 && __i1 <= __i2\n\t\t\t\t && __i2 <= end());\n\t__glibcxx_requires_valid_range(__k1, __k2);\n\treturn this->replace(__i1 - begin(), __i2 - __i1,\n\t\t\t     __k1.base(), __k2 - __k1);\n      }\n\n      basic_string&\n      replace(__const_iterator __i1, __const_iterator __i2,\n\t      const_iterator __k1, const_iterator __k2)\n      {\n\t_GLIBCXX_DEBUG_PEDASSERT(begin() <= __i1 && __i1 <= __i2\n\t\t\t\t && __i2 <= end());\n\t__glibcxx_requires_valid_range(__k1, __k2);\n\treturn this->replace(__i1 - begin(), __i2 - __i1,\n\t\t\t     __k1.base(), __k2 - __k1);\n      }\n\n#if __cplusplus >= 201103L\n      /**\n       *  @brief  Replace range of characters with initializer_list.\n       *  @param __i1  Iterator referencing start of range to replace.\n       *  @param __i2  Iterator referencing end of range to replace.\n       *  @param __l  The initializer_list of characters to insert.\n       *  @return  Reference to this string.\n       *  @throw  std::length_error  If new length exceeds @c max_size().\n       *\n       *  Removes the characters in the range [__i1,__i2).  In place,\n       *  characters in the range [__k1,__k2) are inserted.  If the\n       *  length of result exceeds max_size(), length_error is thrown.\n       *  The value of the string doesn't change if an error is\n       *  thrown.\n      */\n      basic_string& replace(const_iterator __i1, const_iterator __i2,\n\t\t\t    initializer_list<_CharT> __l)\n      { return this->replace(__i1, __i2, __l.begin(), __l.size()); }\n#endif // C++11\n\n#if __cplusplus > 201402L\n      /**\n       *  @brief  Replace range of characters with string_view.\n       *  @param __pos  The position to replace at.\n       *  @param __n    The number of characters to replace.\n       *  @param __svt  The object convertible to string_view to insert.\n       *  @return  Reference to this string.\n      */\n      template<typename _Tp>\n\t_If_sv<_Tp, basic_string&>\n\treplace(size_type __pos, size_type __n, const _Tp& __svt)\n\t{\n\t  __sv_type __sv = __svt;\n\t  return this->replace(__pos, __n, __sv.data(), __sv.size());\n\t}\n\n      /**\n       *  @brief  Replace range of characters with string_view.\n       *  @param __pos1  The position to replace at.\n       *  @param __n1    The number of characters to replace.\n       *  @param __svt   The object convertible to string_view to insert from.\n       *  @param __pos2  The position in the string_view to insert from.\n       *  @param __n2    The number of characters to insert.\n       *  @return  Reference to this string.\n      */\n      template<typename _Tp>\n\t_If_sv<_Tp, basic_string&>\n\treplace(size_type __pos1, size_type __n1, const _Tp& __svt,\n\t\tsize_type __pos2, size_type __n2 = npos)\n\t{\n\t  __sv_type __sv = __svt;\n\t  return this->replace(__pos1, __n1, __sv.data()\n\t\t\t       + __sv._M_check(__pos2, \"basic_string::replace\"),\n\t\t\t       __sv._M_limit(__pos2, __n2));\n\t}\n\n      /**\n       *  @brief  Replace range of characters with string_view.\n       *  @param __i1    An iterator referencing the start position\n          to replace at.\n       *  @param __i2    An iterator referencing the end position\n          for the replace.\n       *  @param __svt   The object convertible to string_view to insert from.\n       *  @return  Reference to this string.\n      */\n      template<typename _Tp>\n\t_If_sv<_Tp, basic_string&>\n\treplace(const_iterator __i1, const_iterator __i2, const _Tp& __svt)\n\t{\n\t  __sv_type __sv = __svt;\n\t  return this->replace(__i1 - begin(), __i2 - __i1, __sv);\n\t}\n#endif // C++17\n\n    private:\n      template<class _Integer>\n\tbasic_string&\n\t_M_replace_dispatch(const_iterator __i1, const_iterator __i2,\n\t\t\t    _Integer __n, _Integer __val, __true_type)\n        { return _M_replace_aux(__i1 - begin(), __i2 - __i1, __n, __val); }\n\n      template<class _InputIterator>\n\tbasic_string&\n\t_M_replace_dispatch(const_iterator __i1, const_iterator __i2,\n\t\t\t    _InputIterator __k1, _InputIterator __k2,\n\t\t\t    __false_type);\n\n      basic_string&\n      _M_replace_aux(size_type __pos1, size_type __n1, size_type __n2,\n\t\t     _CharT __c);\n\n      basic_string&\n      _M_replace(size_type __pos, size_type __len1, const _CharT* __s,\n\t\t const size_type __len2);\n\n      basic_string&\n      _M_append(const _CharT* __s, size_type __n);\n\n    public:\n\n      /**\n       *  @brief  Copy substring into C string.\n       *  @param __s  C string to copy value into.\n       *  @param __n  Number of characters to copy.\n       *  @param __pos  Index of first character to copy.\n       *  @return  Number of characters actually copied\n       *  @throw  std::out_of_range  If __pos > size().\n       *\n       *  Copies up to @a __n characters starting at @a __pos into the\n       *  C string @a __s.  If @a __pos is %greater than size(),\n       *  out_of_range is thrown.\n      */\n      size_type\n      copy(_CharT* __s, size_type __n, size_type __pos = 0) const;\n\n      /**\n       *  @brief  Swap contents with another string.\n       *  @param __s  String to swap with.\n       *\n       *  Exchanges the contents of this string with that of @a __s in constant\n       *  time.\n      */\n      void\n      swap(basic_string& __s) _GLIBCXX_NOEXCEPT;\n\n      // String operations:\n      /**\n       *  @brief  Return const pointer to null-terminated contents.\n       *\n       *  This is a handle to internal data.  Do not modify or dire things may\n       *  happen.\n      */\n      const _CharT*\n      c_str() const _GLIBCXX_NOEXCEPT\n      { return _M_data(); }\n\n      /**\n       *  @brief  Return const pointer to contents.\n       *\n       *  This is a pointer to internal data.  It is undefined to modify\n       *  the contents through the returned pointer. To get a pointer that\n       *  allows modifying the contents use @c &str[0] instead,\n       *  (or in C++17 the non-const @c str.data() overload).\n      */\n      const _CharT*\n      data() const _GLIBCXX_NOEXCEPT\n      { return _M_data(); }\n\n#if __cplusplus > 201402L\n      /**\n       *  @brief  Return non-const pointer to contents.\n       *\n       *  This is a pointer to the character sequence held by the string.\n       *  Modifying the characters in the sequence is allowed.\n      */\n      _CharT*\n      data() noexcept\n      { return _M_data(); }\n#endif\n\n      /**\n       *  @brief  Return copy of allocator used to construct this string.\n      */\n      allocator_type\n      get_allocator() const _GLIBCXX_NOEXCEPT\n      { return _M_get_allocator(); }\n\n      /**\n       *  @brief  Find position of a C substring.\n       *  @param __s  C string to locate.\n       *  @param __pos  Index of character to search from.\n       *  @param __n  Number of characters from @a s to search for.\n       *  @return  Index of start of first occurrence.\n       *\n       *  Starting from @a __pos, searches forward for the first @a\n       *  __n characters in @a __s within this string.  If found,\n       *  returns the index where it begins.  If not found, returns\n       *  npos.\n      */\n      size_type\n      find(const _CharT* __s, size_type __pos, size_type __n) const\n      _GLIBCXX_NOEXCEPT;\n\n      /**\n       *  @brief  Find position of a string.\n       *  @param __str  String to locate.\n       *  @param __pos  Index of character to search from (default 0).\n       *  @return  Index of start of first occurrence.\n       *\n       *  Starting from @a __pos, searches forward for value of @a __str within\n       *  this string.  If found, returns the index where it begins.  If not\n       *  found, returns npos.\n      */\n      size_type\n      find(const basic_string& __str, size_type __pos = 0) const\n      _GLIBCXX_NOEXCEPT\n      { return this->find(__str.data(), __pos, __str.size()); }\n\n#if __cplusplus > 201402L\n      /**\n       *  @brief  Find position of a string_view.\n       *  @param __svt  The object convertible to string_view to locate.\n       *  @param __pos  Index of character to search from (default 0).\n       *  @return  Index of start of first occurrence.\n      */\n      template<typename _Tp>\n\t_If_sv<_Tp, size_type>\n\tfind(const _Tp& __svt, size_type __pos = 0) const\n\tnoexcept(is_same<_Tp, __sv_type>::value)\n\t{\n\t  __sv_type __sv = __svt;\n\t  return this->find(__sv.data(), __pos, __sv.size());\n\t}\n#endif // C++17\n\n      /**\n       *  @brief  Find position of a C string.\n       *  @param __s  C string to locate.\n       *  @param __pos  Index of character to search from (default 0).\n       *  @return  Index of start of first occurrence.\n       *\n       *  Starting from @a __pos, searches forward for the value of @a\n       *  __s within this string.  If found, returns the index where\n       *  it begins.  If not found, returns npos.\n      */\n      size_type\n      find(const _CharT* __s, size_type __pos = 0) const _GLIBCXX_NOEXCEPT\n      {\n\t__glibcxx_requires_string(__s);\n\treturn this->find(__s, __pos, traits_type::length(__s));\n      }\n\n      /**\n       *  @brief  Find position of a character.\n       *  @param __c  Character to locate.\n       *  @param __pos  Index of character to search from (default 0).\n       *  @return  Index of first occurrence.\n       *\n       *  Starting from @a __pos, searches forward for @a __c within\n       *  this string.  If found, returns the index where it was\n       *  found.  If not found, returns npos.\n      */\n      size_type\n      find(_CharT __c, size_type __pos = 0) const _GLIBCXX_NOEXCEPT;\n\n      /**\n       *  @brief  Find last position of a string.\n       *  @param __str  String to locate.\n       *  @param __pos  Index of character to search back from (default end).\n       *  @return  Index of start of last occurrence.\n       *\n       *  Starting from @a __pos, searches backward for value of @a\n       *  __str within this string.  If found, returns the index where\n       *  it begins.  If not found, returns npos.\n      */\n      size_type\n      rfind(const basic_string& __str, size_type __pos = npos) const\n      _GLIBCXX_NOEXCEPT\n      { return this->rfind(__str.data(), __pos, __str.size()); }\n\n#if __cplusplus > 201402L\n      /**\n       *  @brief  Find last position of a string_view.\n       *  @param __svt  The object convertible to string_view to locate.\n       *  @param __pos  Index of character to search back from (default end).\n       *  @return  Index of start of last occurrence.\n      */\n      template<typename _Tp>\n\t_If_sv<_Tp, size_type>\n\trfind(const _Tp& __svt, size_type __pos = npos) const\n\tnoexcept(is_same<_Tp, __sv_type>::value)\n\t{\n\t  __sv_type __sv = __svt;\n\t  return this->rfind(__sv.data(), __pos, __sv.size());\n\t}\n#endif // C++17\n\n      /**\n       *  @brief  Find last position of a C substring.\n       *  @param __s  C string to locate.\n       *  @param __pos  Index of character to search back from.\n       *  @param __n  Number of characters from s to search for.\n       *  @return  Index of start of last occurrence.\n       *\n       *  Starting from @a __pos, searches backward for the first @a\n       *  __n characters in @a __s within this string.  If found,\n       *  returns the index where it begins.  If not found, returns\n       *  npos.\n      */\n      size_type\n      rfind(const _CharT* __s, size_type __pos, size_type __n) const\n      _GLIBCXX_NOEXCEPT;\n\n      /**\n       *  @brief  Find last position of a C string.\n       *  @param __s  C string to locate.\n       *  @param __pos  Index of character to start search at (default end).\n       *  @return  Index of start of  last occurrence.\n       *\n       *  Starting from @a __pos, searches backward for the value of\n       *  @a __s within this string.  If found, returns the index\n       *  where it begins.  If not found, returns npos.\n      */\n      size_type\n      rfind(const _CharT* __s, size_type __pos = npos) const\n      {\n\t__glibcxx_requires_string(__s);\n\treturn this->rfind(__s, __pos, traits_type::length(__s));\n      }\n\n      /**\n       *  @brief  Find last position of a character.\n       *  @param __c  Character to locate.\n       *  @param __pos  Index of character to search back from (default end).\n       *  @return  Index of last occurrence.\n       *\n       *  Starting from @a __pos, searches backward for @a __c within\n       *  this string.  If found, returns the index where it was\n       *  found.  If not found, returns npos.\n      */\n      size_type\n      rfind(_CharT __c, size_type __pos = npos) const _GLIBCXX_NOEXCEPT;\n\n      /**\n       *  @brief  Find position of a character of string.\n       *  @param __str  String containing characters to locate.\n       *  @param __pos  Index of character to search from (default 0).\n       *  @return  Index of first occurrence.\n       *\n       *  Starting from @a __pos, searches forward for one of the\n       *  characters of @a __str within this string.  If found,\n       *  returns the index where it was found.  If not found, returns\n       *  npos.\n      */\n      size_type\n      find_first_of(const basic_string& __str, size_type __pos = 0) const\n      _GLIBCXX_NOEXCEPT\n      { return this->find_first_of(__str.data(), __pos, __str.size()); }\n\n#if __cplusplus > 201402L\n      /**\n       *  @brief  Find position of a character of a string_view.\n       *  @param __svt  An object convertible to string_view containing\n       *                characters to locate.\n       *  @param __pos  Index of character to search from (default 0).\n       *  @return  Index of first occurrence.\n      */\n      template<typename _Tp>\n\t_If_sv<_Tp, size_type>\n\tfind_first_of(const _Tp& __svt, size_type __pos = 0) const\n\tnoexcept(is_same<_Tp, __sv_type>::value)\n\t{\n\t  __sv_type __sv = __svt;\n\t  return this->find_first_of(__sv.data(), __pos, __sv.size());\n\t}\n#endif // C++17\n\n      /**\n       *  @brief  Find position of a character of C substring.\n       *  @param __s  String containing characters to locate.\n       *  @param __pos  Index of character to search from.\n       *  @param __n  Number of characters from s to search for.\n       *  @return  Index of first occurrence.\n       *\n       *  Starting from @a __pos, searches forward for one of the\n       *  first @a __n characters of @a __s within this string.  If\n       *  found, returns the index where it was found.  If not found,\n       *  returns npos.\n      */\n      size_type\n      find_first_of(const _CharT* __s, size_type __pos, size_type __n) const\n      _GLIBCXX_NOEXCEPT;\n\n      /**\n       *  @brief  Find position of a character of C string.\n       *  @param __s  String containing characters to locate.\n       *  @param __pos  Index of character to search from (default 0).\n       *  @return  Index of first occurrence.\n       *\n       *  Starting from @a __pos, searches forward for one of the\n       *  characters of @a __s within this string.  If found, returns\n       *  the index where it was found.  If not found, returns npos.\n      */\n      size_type\n      find_first_of(const _CharT* __s, size_type __pos = 0) const\n      _GLIBCXX_NOEXCEPT\n      {\n\t__glibcxx_requires_string(__s);\n\treturn this->find_first_of(__s, __pos, traits_type::length(__s));\n      }\n\n      /**\n       *  @brief  Find position of a character.\n       *  @param __c  Character to locate.\n       *  @param __pos  Index of character to search from (default 0).\n       *  @return  Index of first occurrence.\n       *\n       *  Starting from @a __pos, searches forward for the character\n       *  @a __c within this string.  If found, returns the index\n       *  where it was found.  If not found, returns npos.\n       *\n       *  Note: equivalent to find(__c, __pos).\n      */\n      size_type\n      find_first_of(_CharT __c, size_type __pos = 0) const _GLIBCXX_NOEXCEPT\n      { return this->find(__c, __pos); }\n\n      /**\n       *  @brief  Find last position of a character of string.\n       *  @param __str  String containing characters to locate.\n       *  @param __pos  Index of character to search back from (default end).\n       *  @return  Index of last occurrence.\n       *\n       *  Starting from @a __pos, searches backward for one of the\n       *  characters of @a __str within this string.  If found,\n       *  returns the index where it was found.  If not found, returns\n       *  npos.\n      */\n      size_type\n      find_last_of(const basic_string& __str, size_type __pos = npos) const\n      _GLIBCXX_NOEXCEPT\n      { return this->find_last_of(__str.data(), __pos, __str.size()); }\n\n#if __cplusplus > 201402L\n      /**\n       *  @brief  Find last position of a character of string.\n       *  @param __svt  An object convertible to string_view containing\n       *                characters to locate.\n       *  @param __pos  Index of character to search back from (default end).\n       *  @return  Index of last occurrence.\n      */\n      template<typename _Tp>\n\t_If_sv<_Tp, size_type>\n\tfind_last_of(const _Tp& __svt, size_type __pos = npos) const\n\tnoexcept(is_same<_Tp, __sv_type>::value)\n\t{\n\t  __sv_type __sv = __svt;\n\t  return this->find_last_of(__sv.data(), __pos, __sv.size());\n\t}\n#endif // C++17\n\n      /**\n       *  @brief  Find last position of a character of C substring.\n       *  @param __s  C string containing characters to locate.\n       *  @param __pos  Index of character to search back from.\n       *  @param __n  Number of characters from s to search for.\n       *  @return  Index of last occurrence.\n       *\n       *  Starting from @a __pos, searches backward for one of the\n       *  first @a __n characters of @a __s within this string.  If\n       *  found, returns the index where it was found.  If not found,\n       *  returns npos.\n      */\n      size_type\n      find_last_of(const _CharT* __s, size_type __pos, size_type __n) const\n      _GLIBCXX_NOEXCEPT;\n\n      /**\n       *  @brief  Find last position of a character of C string.\n       *  @param __s  C string containing characters to locate.\n       *  @param __pos  Index of character to search back from (default end).\n       *  @return  Index of last occurrence.\n       *\n       *  Starting from @a __pos, searches backward for one of the\n       *  characters of @a __s within this string.  If found, returns\n       *  the index where it was found.  If not found, returns npos.\n      */\n      size_type\n      find_last_of(const _CharT* __s, size_type __pos = npos) const\n      _GLIBCXX_NOEXCEPT\n      {\n\t__glibcxx_requires_string(__s);\n\treturn this->find_last_of(__s, __pos, traits_type::length(__s));\n      }\n\n      /**\n       *  @brief  Find last position of a character.\n       *  @param __c  Character to locate.\n       *  @param __pos  Index of character to search back from (default end).\n       *  @return  Index of last occurrence.\n       *\n       *  Starting from @a __pos, searches backward for @a __c within\n       *  this string.  If found, returns the index where it was\n       *  found.  If not found, returns npos.\n       *\n       *  Note: equivalent to rfind(__c, __pos).\n      */\n      size_type\n      find_last_of(_CharT __c, size_type __pos = npos) const _GLIBCXX_NOEXCEPT\n      { return this->rfind(__c, __pos); }\n\n      /**\n       *  @brief  Find position of a character not in string.\n       *  @param __str  String containing characters to avoid.\n       *  @param __pos  Index of character to search from (default 0).\n       *  @return  Index of first occurrence.\n       *\n       *  Starting from @a __pos, searches forward for a character not contained\n       *  in @a __str within this string.  If found, returns the index where it\n       *  was found.  If not found, returns npos.\n      */\n      size_type\n      find_first_not_of(const basic_string& __str, size_type __pos = 0) const\n      _GLIBCXX_NOEXCEPT\n      { return this->find_first_not_of(__str.data(), __pos, __str.size()); }\n\n#if __cplusplus > 201402L\n      /**\n       *  @brief  Find position of a character not in a string_view.\n       *  @param __svt  A object convertible to string_view containing\n       *                characters to avoid.\n       *  @param __pos  Index of character to search from (default 0).\n       *  @return  Index of first occurrence.\n       */\n      template<typename _Tp>\n\t_If_sv<_Tp, size_type>\n\tfind_first_not_of(const _Tp& __svt, size_type __pos = 0) const\n\tnoexcept(is_same<_Tp, __sv_type>::value)\n\t{\n\t  __sv_type __sv = __svt;\n\t  return this->find_first_not_of(__sv.data(), __pos, __sv.size());\n\t}\n#endif // C++17\n\n      /**\n       *  @brief  Find position of a character not in C substring.\n       *  @param __s  C string containing characters to avoid.\n       *  @param __pos  Index of character to search from.\n       *  @param __n  Number of characters from __s to consider.\n       *  @return  Index of first occurrence.\n       *\n       *  Starting from @a __pos, searches forward for a character not\n       *  contained in the first @a __n characters of @a __s within\n       *  this string.  If found, returns the index where it was\n       *  found.  If not found, returns npos.\n      */\n      size_type\n      find_first_not_of(const _CharT* __s, size_type __pos,\n\t\t\tsize_type __n) const _GLIBCXX_NOEXCEPT;\n\n      /**\n       *  @brief  Find position of a character not in C string.\n       *  @param __s  C string containing characters to avoid.\n       *  @param __pos  Index of character to search from (default 0).\n       *  @return  Index of first occurrence.\n       *\n       *  Starting from @a __pos, searches forward for a character not\n       *  contained in @a __s within this string.  If found, returns\n       *  the index where it was found.  If not found, returns npos.\n      */\n      size_type\n      find_first_not_of(const _CharT* __s, size_type __pos = 0) const\n      _GLIBCXX_NOEXCEPT\n      {\n\t__glibcxx_requires_string(__s);\n\treturn this->find_first_not_of(__s, __pos, traits_type::length(__s));\n      }\n\n      /**\n       *  @brief  Find position of a different character.\n       *  @param __c  Character to avoid.\n       *  @param __pos  Index of character to search from (default 0).\n       *  @return  Index of first occurrence.\n       *\n       *  Starting from @a __pos, searches forward for a character\n       *  other than @a __c within this string.  If found, returns the\n       *  index where it was found.  If not found, returns npos.\n      */\n      size_type\n      find_first_not_of(_CharT __c, size_type __pos = 0) const\n      _GLIBCXX_NOEXCEPT;\n\n      /**\n       *  @brief  Find last position of a character not in string.\n       *  @param __str  String containing characters to avoid.\n       *  @param __pos  Index of character to search back from (default end).\n       *  @return  Index of last occurrence.\n       *\n       *  Starting from @a __pos, searches backward for a character\n       *  not contained in @a __str within this string.  If found,\n       *  returns the index where it was found.  If not found, returns\n       *  npos.\n      */\n      size_type\n      find_last_not_of(const basic_string& __str, size_type __pos = npos) const\n      _GLIBCXX_NOEXCEPT\n      { return this->find_last_not_of(__str.data(), __pos, __str.size()); }\n\n#if __cplusplus > 201402L\n      /**\n       *  @brief  Find last position of a character not in a string_view.\n       *  @param __svt  An object convertible to string_view containing\n       *                characters to avoid.\n       *  @param __pos  Index of character to search back from (default end).\n       *  @return  Index of last occurrence.\n       */\n      template<typename _Tp>\n\t_If_sv<_Tp, size_type>\n\tfind_last_not_of(const _Tp& __svt, size_type __pos = npos) const\n\tnoexcept(is_same<_Tp, __sv_type>::value)\n\t{\n\t  __sv_type __sv = __svt;\n\t  return this->find_last_not_of(__sv.data(), __pos, __sv.size());\n\t}\n#endif // C++17\n\n      /**\n       *  @brief  Find last position of a character not in C substring.\n       *  @param __s  C string containing characters to avoid.\n       *  @param __pos  Index of character to search back from.\n       *  @param __n  Number of characters from s to consider.\n       *  @return  Index of last occurrence.\n       *\n       *  Starting from @a __pos, searches backward for a character not\n       *  contained in the first @a __n characters of @a __s within this string.\n       *  If found, returns the index where it was found.  If not found,\n       *  returns npos.\n      */\n      size_type\n      find_last_not_of(const _CharT* __s, size_type __pos,\n\t\t       size_type __n) const _GLIBCXX_NOEXCEPT;\n      /**\n       *  @brief  Find last position of a character not in C string.\n       *  @param __s  C string containing characters to avoid.\n       *  @param __pos  Index of character to search back from (default end).\n       *  @return  Index of last occurrence.\n       *\n       *  Starting from @a __pos, searches backward for a character\n       *  not contained in @a __s within this string.  If found,\n       *  returns the index where it was found.  If not found, returns\n       *  npos.\n      */\n      size_type\n      find_last_not_of(const _CharT* __s, size_type __pos = npos) const\n      _GLIBCXX_NOEXCEPT\n      {\n\t__glibcxx_requires_string(__s);\n\treturn this->find_last_not_of(__s, __pos, traits_type::length(__s));\n      }\n\n      /**\n       *  @brief  Find last position of a different character.\n       *  @param __c  Character to avoid.\n       *  @param __pos  Index of character to search back from (default end).\n       *  @return  Index of last occurrence.\n       *\n       *  Starting from @a __pos, searches backward for a character other than\n       *  @a __c within this string.  If found, returns the index where it was\n       *  found.  If not found, returns npos.\n      */\n      size_type\n      find_last_not_of(_CharT __c, size_type __pos = npos) const\n      _GLIBCXX_NOEXCEPT;\n\n      /**\n       *  @brief  Get a substring.\n       *  @param __pos  Index of first character (default 0).\n       *  @param __n  Number of characters in substring (default remainder).\n       *  @return  The new string.\n       *  @throw  std::out_of_range  If __pos > size().\n       *\n       *  Construct and return a new string using the @a __n\n       *  characters starting at @a __pos.  If the string is too\n       *  short, use the remainder of the characters.  If @a __pos is\n       *  beyond the end of the string, out_of_range is thrown.\n      */\n      basic_string\n      substr(size_type __pos = 0, size_type __n = npos) const\n      { return basic_string(*this,\n\t\t\t    _M_check(__pos, \"basic_string::substr\"), __n); }\n\n      /**\n       *  @brief  Compare to a string.\n       *  @param __str  String to compare against.\n       *  @return  Integer < 0, 0, or > 0.\n       *\n       *  Returns an integer < 0 if this string is ordered before @a\n       *  __str, 0 if their values are equivalent, or > 0 if this\n       *  string is ordered after @a __str.  Determines the effective\n       *  length rlen of the strings to compare as the smallest of\n       *  size() and str.size().  The function then compares the two\n       *  strings by calling traits::compare(data(), str.data(),rlen).\n       *  If the result of the comparison is nonzero returns it,\n       *  otherwise the shorter one is ordered first.\n      */\n      int\n      compare(const basic_string& __str) const\n      {\n\tconst size_type __size = this->size();\n\tconst size_type __osize = __str.size();\n\tconst size_type __len = std::min(__size, __osize);\n\n\tint __r = traits_type::compare(_M_data(), __str.data(), __len);\n\tif (!__r)\n\t  __r = _S_compare(__size, __osize);\n\treturn __r;\n      }\n\n#if __cplusplus > 201402L\n      /**\n       *  @brief  Compare to a string_view.\n       *  @param __svt An object convertible to string_view to compare against.\n       *  @return  Integer < 0, 0, or > 0.\n       */\n      template<typename _Tp>\n\t_If_sv<_Tp, int>\n\tcompare(const _Tp& __svt) const\n\tnoexcept(is_same<_Tp, __sv_type>::value)\n\t{\n\t  __sv_type __sv = __svt;\n\t  const size_type __size = this->size();\n\t  const size_type __osize = __sv.size();\n\t  const size_type __len = std::min(__size, __osize);\n\n\t  int __r = traits_type::compare(_M_data(), __sv.data(), __len);\n\t  if (!__r)\n\t    __r = _S_compare(__size, __osize);\n\t  return __r;\n\t}\n\n      /**\n       *  @brief  Compare to a string_view.\n       *  @param __pos  A position in the string to start comparing from.\n       *  @param __n  The number of characters to compare.\n       *  @param __svt  An object convertible to string_view to compare\n       *                against.\n       *  @return  Integer < 0, 0, or > 0.\n       */\n      template<typename _Tp>\n\t_If_sv<_Tp, int>\n\tcompare(size_type __pos, size_type __n, const _Tp& __svt) const\n\tnoexcept(is_same<_Tp, __sv_type>::value)\n\t{\n\t  __sv_type __sv = __svt;\n\t  return __sv_type(*this).substr(__pos, __n).compare(__sv);\n\t}\n\n      /**\n       *  @brief  Compare to a string_view.\n       *  @param __pos1  A position in the string to start comparing from.\n       *  @param __n1  The number of characters to compare.\n       *  @param __svt  An object convertible to string_view to compare\n       *                against.\n       *  @param __pos2  A position in the string_view to start comparing from.\n       *  @param __n2  The number of characters to compare.\n       *  @return  Integer < 0, 0, or > 0.\n       */\n      template<typename _Tp>\n\t_If_sv<_Tp, int>\n\tcompare(size_type __pos1, size_type __n1, const _Tp& __svt,\n\t\tsize_type __pos2, size_type __n2 = npos) const\n\tnoexcept(is_same<_Tp, __sv_type>::value)\n\t{\n\t  __sv_type __sv = __svt;\n\t  return __sv_type(*this)\n\t    .substr(__pos1, __n1).compare(__sv.substr(__pos2, __n2));\n\t}\n#endif // C++17\n\n      /**\n       *  @brief  Compare substring to a string.\n       *  @param __pos  Index of first character of substring.\n       *  @param __n  Number of characters in substring.\n       *  @param __str  String to compare against.\n       *  @return  Integer < 0, 0, or > 0.\n       *\n       *  Form the substring of this string from the @a __n characters\n       *  starting at @a __pos.  Returns an integer < 0 if the\n       *  substring is ordered before @a __str, 0 if their values are\n       *  equivalent, or > 0 if the substring is ordered after @a\n       *  __str.  Determines the effective length rlen of the strings\n       *  to compare as the smallest of the length of the substring\n       *  and @a __str.size().  The function then compares the two\n       *  strings by calling\n       *  traits::compare(substring.data(),str.data(),rlen).  If the\n       *  result of the comparison is nonzero returns it, otherwise\n       *  the shorter one is ordered first.\n      */\n      int\n      compare(size_type __pos, size_type __n, const basic_string& __str) const;\n\n      /**\n       *  @brief  Compare substring to a substring.\n       *  @param __pos1  Index of first character of substring.\n       *  @param __n1  Number of characters in substring.\n       *  @param __str  String to compare against.\n       *  @param __pos2  Index of first character of substring of str.\n       *  @param __n2  Number of characters in substring of str.\n       *  @return  Integer < 0, 0, or > 0.\n       *\n       *  Form the substring of this string from the @a __n1\n       *  characters starting at @a __pos1.  Form the substring of @a\n       *  __str from the @a __n2 characters starting at @a __pos2.\n       *  Returns an integer < 0 if this substring is ordered before\n       *  the substring of @a __str, 0 if their values are equivalent,\n       *  or > 0 if this substring is ordered after the substring of\n       *  @a __str.  Determines the effective length rlen of the\n       *  strings to compare as the smallest of the lengths of the\n       *  substrings.  The function then compares the two strings by\n       *  calling\n       *  traits::compare(substring.data(),str.substr(pos2,n2).data(),rlen).\n       *  If the result of the comparison is nonzero returns it,\n       *  otherwise the shorter one is ordered first.\n      */\n      int\n      compare(size_type __pos1, size_type __n1, const basic_string& __str,\n\t      size_type __pos2, size_type __n2 = npos) const;\n\n      /**\n       *  @brief  Compare to a C string.\n       *  @param __s  C string to compare against.\n       *  @return  Integer < 0, 0, or > 0.\n       *\n       *  Returns an integer < 0 if this string is ordered before @a __s, 0 if\n       *  their values are equivalent, or > 0 if this string is ordered after\n       *  @a __s.  Determines the effective length rlen of the strings to\n       *  compare as the smallest of size() and the length of a string\n       *  constructed from @a __s.  The function then compares the two strings\n       *  by calling traits::compare(data(),s,rlen).  If the result of the\n       *  comparison is nonzero returns it, otherwise the shorter one is\n       *  ordered first.\n      */\n      int\n      compare(const _CharT* __s) const _GLIBCXX_NOEXCEPT;\n\n      // _GLIBCXX_RESOLVE_LIB_DEFECTS\n      // 5 String::compare specification questionable\n      /**\n       *  @brief  Compare substring to a C string.\n       *  @param __pos  Index of first character of substring.\n       *  @param __n1  Number of characters in substring.\n       *  @param __s  C string to compare against.\n       *  @return  Integer < 0, 0, or > 0.\n       *\n       *  Form the substring of this string from the @a __n1\n       *  characters starting at @a pos.  Returns an integer < 0 if\n       *  the substring is ordered before @a __s, 0 if their values\n       *  are equivalent, or > 0 if the substring is ordered after @a\n       *  __s.  Determines the effective length rlen of the strings to\n       *  compare as the smallest of the length of the substring and\n       *  the length of a string constructed from @a __s.  The\n       *  function then compares the two string by calling\n       *  traits::compare(substring.data(),__s,rlen).  If the result of\n       *  the comparison is nonzero returns it, otherwise the shorter\n       *  one is ordered first.\n      */\n      int\n      compare(size_type __pos, size_type __n1, const _CharT* __s) const;\n\n      /**\n       *  @brief  Compare substring against a character %array.\n       *  @param __pos  Index of first character of substring.\n       *  @param __n1  Number of characters in substring.\n       *  @param __s  character %array to compare against.\n       *  @param __n2  Number of characters of s.\n       *  @return  Integer < 0, 0, or > 0.\n       *\n       *  Form the substring of this string from the @a __n1\n       *  characters starting at @a __pos.  Form a string from the\n       *  first @a __n2 characters of @a __s.  Returns an integer < 0\n       *  if this substring is ordered before the string from @a __s,\n       *  0 if their values are equivalent, or > 0 if this substring\n       *  is ordered after the string from @a __s.  Determines the\n       *  effective length rlen of the strings to compare as the\n       *  smallest of the length of the substring and @a __n2.  The\n       *  function then compares the two strings by calling\n       *  traits::compare(substring.data(),s,rlen).  If the result of\n       *  the comparison is nonzero returns it, otherwise the shorter\n       *  one is ordered first.\n       *\n       *  NB: s must have at least n2 characters, &apos;\\\\0&apos; has\n       *  no special meaning.\n      */\n      int\n      compare(size_type __pos, size_type __n1, const _CharT* __s,\n\t      size_type __n2) const;\n\n      // Allow basic_stringbuf::__xfer_bufptrs to call _M_length:\n      template<typename, typename, typename> friend class basic_stringbuf;\n    };\n_GLIBCXX_END_NAMESPACE_CXX11\n#else  // !_GLIBCXX_USE_CXX11_ABI\n  // Reference-counted COW string implentation\n\n  /**\n   *  @class basic_string basic_string.h <string>\n   *  @brief  Managing sequences of characters and character-like objects.\n   *\n   *  @ingroup strings\n   *  @ingroup sequences\n   *\n   *  @tparam _CharT  Type of character\n   *  @tparam _Traits  Traits for character type, defaults to\n   *                   char_traits<_CharT>.\n   *  @tparam _Alloc  Allocator type, defaults to allocator<_CharT>.\n   *\n   *  Meets the requirements of a <a href=\"tables.html#65\">container</a>, a\n   *  <a href=\"tables.html#66\">reversible container</a>, and a\n   *  <a href=\"tables.html#67\">sequence</a>.  Of the\n   *  <a href=\"tables.html#68\">optional sequence requirements</a>, only\n   *  @c push_back, @c at, and @c %array access are supported.\n   *\n   *  @doctodo\n   *\n   *\n   *  Documentation?  What's that?\n   *  Nathan Myers <ncm@cantrip.org>.\n   *\n   *  A string looks like this:\n   *\n   *  @code\n   *                                        [_Rep]\n   *                                        _M_length\n   *   [basic_string<char_type>]            _M_capacity\n   *   _M_dataplus                          _M_refcount\n   *   _M_p ---------------->               unnamed array of char_type\n   *  @endcode\n   *\n   *  Where the _M_p points to the first character in the string, and\n   *  you cast it to a pointer-to-_Rep and subtract 1 to get a\n   *  pointer to the header.\n   *\n   *  This approach has the enormous advantage that a string object\n   *  requires only one allocation.  All the ugliness is confined\n   *  within a single %pair of inline functions, which each compile to\n   *  a single @a add instruction: _Rep::_M_data(), and\n   *  string::_M_rep(); and the allocation function which gets a\n   *  block of raw bytes and with room enough and constructs a _Rep\n   *  object at the front.\n   *\n   *  The reason you want _M_data pointing to the character %array and\n   *  not the _Rep is so that the debugger can see the string\n   *  contents. (Probably we should add a non-inline member to get\n   *  the _Rep for the debugger to use, so users can check the actual\n   *  string length.)\n   *\n   *  Note that the _Rep object is a POD so that you can have a\n   *  static <em>empty string</em> _Rep object already @a constructed before\n   *  static constructors have run.  The reference-count encoding is\n   *  chosen so that a 0 indicates one reference, so you never try to\n   *  destroy the empty-string _Rep object.\n   *\n   *  All but the last paragraph is considered pretty conventional\n   *  for a C++ string implementation.\n  */\n  // 21.3  Template class basic_string\n  template<typename _CharT, typename _Traits, typename _Alloc>\n    class basic_string\n    {\n      typedef typename _Alloc::template rebind<_CharT>::other _CharT_alloc_type;\n\n      // Types:\n    public:\n      typedef _Traits\t\t\t\t\t    traits_type;\n      typedef typename _Traits::char_type\t\t    value_type;\n      typedef _Alloc\t\t\t\t\t    allocator_type;\n      typedef typename _CharT_alloc_type::size_type\t    size_type;\n      typedef typename _CharT_alloc_type::difference_type   difference_type;\n      typedef typename _CharT_alloc_type::reference\t    reference;\n      typedef typename _CharT_alloc_type::const_reference   const_reference;\n      typedef typename _CharT_alloc_type::pointer\t    pointer;\n      typedef typename _CharT_alloc_type::const_pointer\t    const_pointer;\n      typedef __gnu_cxx::__normal_iterator<pointer, basic_string>  iterator;\n      typedef __gnu_cxx::__normal_iterator<const_pointer, basic_string>\n                                                            const_iterator;\n      typedef std::reverse_iterator<const_iterator>\tconst_reverse_iterator;\n      typedef std::reverse_iterator<iterator>\t\t    reverse_iterator;\n\n    private:\n      // _Rep: string representation\n      //   Invariants:\n      //   1. String really contains _M_length + 1 characters: due to 21.3.4\n      //      must be kept null-terminated.\n      //   2. _M_capacity >= _M_length\n      //      Allocated memory is always (_M_capacity + 1) * sizeof(_CharT).\n      //   3. _M_refcount has three states:\n      //      -1: leaked, one reference, no ref-copies allowed, non-const.\n      //       0: one reference, non-const.\n      //     n>0: n + 1 references, operations require a lock, const.\n      //   4. All fields==0 is an empty string, given the extra storage\n      //      beyond-the-end for a null terminator; thus, the shared\n      //      empty string representation needs no constructor.\n\n      struct _Rep_base\n      {\n\tsize_type\t\t_M_length;\n\tsize_type\t\t_M_capacity;\n\t_Atomic_word\t\t_M_refcount;\n      };\n\n      struct _Rep : _Rep_base\n      {\n\t// Types:\n\ttypedef typename _Alloc::template rebind<char>::other _Raw_bytes_alloc;\n\n\t// (Public) Data members:\n\n\t// The maximum number of individual char_type elements of an\n\t// individual string is determined by _S_max_size. This is the\n\t// value that will be returned by max_size().  (Whereas npos\n\t// is the maximum number of bytes the allocator can allocate.)\n\t// If one was to divvy up the theoretical largest size string,\n\t// with a terminating character and m _CharT elements, it'd\n\t// look like this:\n\t// npos = sizeof(_Rep) + (m * sizeof(_CharT)) + sizeof(_CharT)\n\t// Solving for m:\n\t// m = ((npos - sizeof(_Rep))/sizeof(CharT)) - 1\n\t// In addition, this implementation quarters this amount.\n\tstatic const size_type\t_S_max_size;\n\tstatic const _CharT\t_S_terminal;\n\n\t// The following storage is init'd to 0 by the linker, resulting\n        // (carefully) in an empty string with one reference.\n        static size_type _S_empty_rep_storage[];\n\n        static _Rep&\n        _S_empty_rep() _GLIBCXX_NOEXCEPT\n        { \n\t  // NB: Mild hack to avoid strict-aliasing warnings.  Note that\n\t  // _S_empty_rep_storage is never modified and the punning should\n\t  // be reasonably safe in this case.\n\t  void* __p = reinterpret_cast<void*>(&_S_empty_rep_storage);\n\t  return *reinterpret_cast<_Rep*>(__p);\n\t}\n\n        bool\n\t_M_is_leaked() const _GLIBCXX_NOEXCEPT\n        {\n#if defined(__GTHREADS)\n          // _M_refcount is mutated concurrently by _M_refcopy/_M_dispose,\n          // so we need to use an atomic load. However, _M_is_leaked\n          // predicate does not change concurrently (i.e. the string is either\n          // leaked or not), so a relaxed load is enough.\n          return __atomic_load_n(&this->_M_refcount, __ATOMIC_RELAXED) < 0;\n#else\n          return this->_M_refcount < 0;\n#endif\n        }\n\n        bool\n\t_M_is_shared() const _GLIBCXX_NOEXCEPT\n\t{\n#if defined(__GTHREADS)\n          // _M_refcount is mutated concurrently by _M_refcopy/_M_dispose,\n          // so we need to use an atomic load. Another thread can drop last\n          // but one reference concurrently with this check, so we need this\n          // load to be acquire to synchronize with release fetch_and_add in\n          // _M_dispose.\n          return __atomic_load_n(&this->_M_refcount, __ATOMIC_ACQUIRE) > 0;\n#else\n          return this->_M_refcount > 0;\n#endif\n        }\n\n        void\n\t_M_set_leaked() _GLIBCXX_NOEXCEPT\n        { this->_M_refcount = -1; }\n\n        void\n\t_M_set_sharable() _GLIBCXX_NOEXCEPT\n        { this->_M_refcount = 0; }\n\n\tvoid\n\t_M_set_length_and_sharable(size_type __n) _GLIBCXX_NOEXCEPT\n\t{\n#if _GLIBCXX_FULLY_DYNAMIC_STRING == 0\n\t  if (__builtin_expect(this != &_S_empty_rep(), false))\n#endif\n\t    {\n\t      this->_M_set_sharable();  // One reference.\n\t      this->_M_length = __n;\n\t      traits_type::assign(this->_M_refdata()[__n], _S_terminal);\n\t      // grrr. (per 21.3.4)\n\t      // You cannot leave those LWG people alone for a second.\n\t    }\n\t}\n\n\t_CharT*\n\t_M_refdata() throw()\n\t{ return reinterpret_cast<_CharT*>(this + 1); }\n\n\t_CharT*\n\t_M_grab(const _Alloc& __alloc1, const _Alloc& __alloc2)\n\t{\n\t  return (!_M_is_leaked() && __alloc1 == __alloc2)\n\t          ? _M_refcopy() : _M_clone(__alloc1);\n\t}\n\n\t// Create & Destroy\n\tstatic _Rep*\n\t_S_create(size_type, size_type, const _Alloc&);\n\n\tvoid\n\t_M_dispose(const _Alloc& __a) _GLIBCXX_NOEXCEPT\n\t{\n#if _GLIBCXX_FULLY_DYNAMIC_STRING == 0\n\t  if (__builtin_expect(this != &_S_empty_rep(), false))\n#endif\n\t    {\n\t      // Be race-detector-friendly.  For more info see bits/c++config.\n\t      _GLIBCXX_SYNCHRONIZATION_HAPPENS_BEFORE(&this->_M_refcount);\n              // Decrement of _M_refcount is acq_rel, because:\n              // - all but last decrements need to release to synchronize with\n              //   the last decrement that will delete the object.\n              // - the last decrement needs to acquire to synchronize with\n              //   all the previous decrements.\n              // - last but one decrement needs to release to synchronize with\n              //   the acquire load in _M_is_shared that will conclude that\n              //   the object is not shared anymore.\n\t      if (__gnu_cxx::__exchange_and_add_dispatch(&this->_M_refcount,\n\t\t\t\t\t\t\t -1) <= 0)\n\t\t{\n\t\t  _GLIBCXX_SYNCHRONIZATION_HAPPENS_AFTER(&this->_M_refcount);\n\t\t  _M_destroy(__a);\n\t\t}\n\t    }\n\t}  // XXX MT\n\n\tvoid\n\t_M_destroy(const _Alloc&) throw();\n\n\t_CharT*\n\t_M_refcopy() throw()\n\t{\n#if _GLIBCXX_FULLY_DYNAMIC_STRING == 0\n\t  if (__builtin_expect(this != &_S_empty_rep(), false))\n#endif\n            __gnu_cxx::__atomic_add_dispatch(&this->_M_refcount, 1);\n\t  return _M_refdata();\n\t}  // XXX MT\n\n\t_CharT*\n\t_M_clone(const _Alloc&, size_type __res = 0);\n      };\n\n      // Use empty-base optimization: http://www.cantrip.org/emptyopt.html\n      struct _Alloc_hider : _Alloc\n      {\n\t_Alloc_hider(_CharT* __dat, const _Alloc& __a) _GLIBCXX_NOEXCEPT\n\t: _Alloc(__a), _M_p(__dat) { }\n\n\t_CharT* _M_p; // The actual data.\n      };\n\n    public:\n      // Data Members (public):\n      // NB: This is an unsigned type, and thus represents the maximum\n      // size that the allocator can hold.\n      ///  Value returned by various member functions when they fail.\n      static const size_type\tnpos = static_cast<size_type>(-1);\n\n    private:\n      // Data Members (private):\n      mutable _Alloc_hider\t_M_dataplus;\n\n      _CharT*\n      _M_data() const _GLIBCXX_NOEXCEPT\n      { return  _M_dataplus._M_p; }\n\n      _CharT*\n      _M_data(_CharT* __p) _GLIBCXX_NOEXCEPT\n      { return (_M_dataplus._M_p = __p); }\n\n      _Rep*\n      _M_rep() const _GLIBCXX_NOEXCEPT\n      { return &((reinterpret_cast<_Rep*> (_M_data()))[-1]); }\n\n      // For the internal use we have functions similar to `begin'/`end'\n      // but they do not call _M_leak.\n      iterator\n      _M_ibegin() const _GLIBCXX_NOEXCEPT\n      { return iterator(_M_data()); }\n\n      iterator\n      _M_iend() const _GLIBCXX_NOEXCEPT\n      { return iterator(_M_data() + this->size()); }\n\n      void\n      _M_leak()    // for use in begin() & non-const op[]\n      {\n\tif (!_M_rep()->_M_is_leaked())\n\t  _M_leak_hard();\n      }\n\n      size_type\n      _M_check(size_type __pos, const char* __s) const\n      {\n\tif (__pos > this->size())\n\t  __throw_out_of_range_fmt(__N(\"%s: __pos (which is %zu) > \"\n\t\t\t\t       \"this->size() (which is %zu)\"),\n\t\t\t\t   __s, __pos, this->size());\n\treturn __pos;\n      }\n\n      void\n      _M_check_length(size_type __n1, size_type __n2, const char* __s) const\n      {\n\tif (this->max_size() - (this->size() - __n1) < __n2)\n\t  __throw_length_error(__N(__s));\n      }\n\n      // NB: _M_limit doesn't check for a bad __pos value.\n      size_type\n      _M_limit(size_type __pos, size_type __off) const _GLIBCXX_NOEXCEPT\n      {\n\tconst bool __testoff =  __off < this->size() - __pos;\n\treturn __testoff ? __off : this->size() - __pos;\n      }\n\n      // True if _Rep and source do not overlap.\n      bool\n      _M_disjunct(const _CharT* __s) const _GLIBCXX_NOEXCEPT\n      {\n\treturn (less<const _CharT*>()(__s, _M_data())\n\t\t|| less<const _CharT*>()(_M_data() + this->size(), __s));\n      }\n\n      // When __n = 1 way faster than the general multichar\n      // traits_type::copy/move/assign.\n      static void\n      _M_copy(_CharT* __d, const _CharT* __s, size_type __n) _GLIBCXX_NOEXCEPT\n      {\n\tif (__n == 1)\n\t  traits_type::assign(*__d, *__s);\n\telse\n\t  traits_type::copy(__d, __s, __n);\n      }\n\n      static void\n      _M_move(_CharT* __d, const _CharT* __s, size_type __n) _GLIBCXX_NOEXCEPT\n      {\n\tif (__n == 1)\n\t  traits_type::assign(*__d, *__s);\n\telse\n\t  traits_type::move(__d, __s, __n);\t  \n      }\n\n      static void\n      _M_assign(_CharT* __d, size_type __n, _CharT __c) _GLIBCXX_NOEXCEPT\n      {\n\tif (__n == 1)\n\t  traits_type::assign(*__d, __c);\n\telse\n\t  traits_type::assign(__d, __n, __c);\t  \n      }\n\n      // _S_copy_chars is a separate template to permit specialization\n      // to optimize for the common case of pointers as iterators.\n      template<class _Iterator>\n        static void\n        _S_copy_chars(_CharT* __p, _Iterator __k1, _Iterator __k2)\n        {\n\t  for (; __k1 != __k2; ++__k1, (void)++__p)\n\t    traits_type::assign(*__p, *__k1); // These types are off.\n\t}\n\n      static void\n      _S_copy_chars(_CharT* __p, iterator __k1, iterator __k2) _GLIBCXX_NOEXCEPT\n      { _S_copy_chars(__p, __k1.base(), __k2.base()); }\n\n      static void\n      _S_copy_chars(_CharT* __p, const_iterator __k1, const_iterator __k2)\n      _GLIBCXX_NOEXCEPT\n      { _S_copy_chars(__p, __k1.base(), __k2.base()); }\n\n      static void\n      _S_copy_chars(_CharT* __p, _CharT* __k1, _CharT* __k2) _GLIBCXX_NOEXCEPT\n      { _M_copy(__p, __k1, __k2 - __k1); }\n\n      static void\n      _S_copy_chars(_CharT* __p, const _CharT* __k1, const _CharT* __k2)\n      _GLIBCXX_NOEXCEPT\n      { _M_copy(__p, __k1, __k2 - __k1); }\n\n      static int\n      _S_compare(size_type __n1, size_type __n2) _GLIBCXX_NOEXCEPT\n      {\n\tconst difference_type __d = difference_type(__n1 - __n2);\n\n\tif (__d > __gnu_cxx::__numeric_traits<int>::__max)\n\t  return __gnu_cxx::__numeric_traits<int>::__max;\n\telse if (__d < __gnu_cxx::__numeric_traits<int>::__min)\n\t  return __gnu_cxx::__numeric_traits<int>::__min;\n\telse\n\t  return int(__d);\n      }\n\n      void\n      _M_mutate(size_type __pos, size_type __len1, size_type __len2);\n\n      void\n      _M_leak_hard();\n\n      static _Rep&\n      _S_empty_rep() _GLIBCXX_NOEXCEPT\n      { return _Rep::_S_empty_rep(); }\n\n#if __cplusplus > 201402L\n      // A helper type for avoiding boiler-plate.\n      typedef basic_string_view<_CharT, _Traits> __sv_type;\n\n      template<typename _Tp, typename _Res>\n\tusing _If_sv = enable_if_t<\n\t  __and_<is_convertible<const _Tp&, __sv_type>,\n\t\t __not_<is_convertible<const _Tp*, const basic_string*>>,\n\t\t __not_<is_convertible<const _Tp&, const _CharT*>>>::value,\n\t  _Res>;\n\n      // Allows an implicit conversion to __sv_type.\n      static __sv_type\n      _S_to_string_view(__sv_type __svt) noexcept\n      { return __svt; }\n\n      // Wraps a string_view by explicit conversion and thus\n      // allows to add an internal constructor that does not\n      // participate in overload resolution when a string_view\n      // is provided.\n      struct __sv_wrapper\n      {\n\texplicit __sv_wrapper(__sv_type __sv) noexcept : _M_sv(__sv) { }\n\t__sv_type _M_sv;\n      };\n#endif\n\n    public:\n      // Construct/copy/destroy:\n      // NB: We overload ctors in some cases instead of using default\n      // arguments, per 17.4.4.4 para. 2 item 2.\n\n      /**\n       *  @brief  Default constructor creates an empty string.\n       */\n      basic_string()\n#if _GLIBCXX_FULLY_DYNAMIC_STRING == 0\n      : _M_dataplus(_S_empty_rep()._M_refdata(), _Alloc()) { }\n#else\n      : _M_dataplus(_S_construct(size_type(), _CharT(), _Alloc()), _Alloc()){ }\n#endif\n\n      /**\n       *  @brief  Construct an empty string using allocator @a a.\n       */\n      explicit\n      basic_string(const _Alloc& __a);\n\n      // NB: per LWG issue 42, semantics different from IS:\n      /**\n       *  @brief  Construct string with copy of value of @a str.\n       *  @param  __str  Source string.\n       */\n      basic_string(const basic_string& __str);\n\n      // _GLIBCXX_RESOLVE_LIB_DEFECTS\n      // 2583. no way to supply an allocator for basic_string(str, pos)\n      /**\n       *  @brief  Construct string as copy of a substring.\n       *  @param  __str  Source string.\n       *  @param  __pos  Index of first character to copy from.\n       *  @param  __a  Allocator to use.\n       */\n      basic_string(const basic_string& __str, size_type __pos,\n\t\t   const _Alloc& __a = _Alloc());\n\n      /**\n       *  @brief  Construct string as copy of a substring.\n       *  @param  __str  Source string.\n       *  @param  __pos  Index of first character to copy from.\n       *  @param  __n  Number of characters to copy.\n       */\n      basic_string(const basic_string& __str, size_type __pos,\n\t\t   size_type __n);\n      /**\n       *  @brief  Construct string as copy of a substring.\n       *  @param  __str  Source string.\n       *  @param  __pos  Index of first character to copy from.\n       *  @param  __n  Number of characters to copy.\n       *  @param  __a  Allocator to use.\n       */\n      basic_string(const basic_string& __str, size_type __pos,\n\t\t   size_type __n, const _Alloc& __a);\n\n      /**\n       *  @brief  Construct string initialized by a character %array.\n       *  @param  __s  Source character %array.\n       *  @param  __n  Number of characters to copy.\n       *  @param  __a  Allocator to use (default is default allocator).\n       *\n       *  NB: @a __s must have at least @a __n characters, &apos;\\\\0&apos;\n       *  has no special meaning.\n       */\n      basic_string(const _CharT* __s, size_type __n,\n\t\t   const _Alloc& __a = _Alloc());\n      /**\n       *  @brief  Construct string as copy of a C string.\n       *  @param  __s  Source C string.\n       *  @param  __a  Allocator to use (default is default allocator).\n       */\n      basic_string(const _CharT* __s, const _Alloc& __a = _Alloc());\n      /**\n       *  @brief  Construct string as multiple characters.\n       *  @param  __n  Number of characters.\n       *  @param  __c  Character to use.\n       *  @param  __a  Allocator to use (default is default allocator).\n       */\n      basic_string(size_type __n, _CharT __c, const _Alloc& __a = _Alloc());\n\n#if __cplusplus >= 201103L\n      /**\n       *  @brief  Move construct string.\n       *  @param  __str  Source string.\n       *\n       *  The newly-created string contains the exact contents of @a __str.\n       *  @a __str is a valid, but unspecified string.\n       **/\n      basic_string(basic_string&& __str)\n#if _GLIBCXX_FULLY_DYNAMIC_STRING == 0\n      noexcept // FIXME C++11: should always be noexcept.\n#endif\n      : _M_dataplus(__str._M_dataplus)\n      {\n#if _GLIBCXX_FULLY_DYNAMIC_STRING == 0\n\t__str._M_data(_S_empty_rep()._M_refdata());\n#else\n\t__str._M_data(_S_construct(size_type(), _CharT(), get_allocator()));\n#endif\n      }\n\n      /**\n       *  @brief  Construct string from an initializer %list.\n       *  @param  __l  std::initializer_list of characters.\n       *  @param  __a  Allocator to use (default is default allocator).\n       */\n      basic_string(initializer_list<_CharT> __l, const _Alloc& __a = _Alloc());\n#endif // C++11\n\n      /**\n       *  @brief  Construct string as copy of a range.\n       *  @param  __beg  Start of range.\n       *  @param  __end  End of range.\n       *  @param  __a  Allocator to use (default is default allocator).\n       */\n      template<class _InputIterator>\n        basic_string(_InputIterator __beg, _InputIterator __end,\n\t\t     const _Alloc& __a = _Alloc());\n\n#if __cplusplus > 201402L\n      /**\n       *  @brief  Construct string from a substring of a string_view.\n       *  @param  __t   Source object convertible to string view.\n       *  @param  __pos The index of the first character to copy from __t.\n       *  @param  __n   The number of characters to copy from __t.\n       *  @param  __a   Allocator to use.\n       */\n      template<typename _Tp, typename = _If_sv<_Tp, void>>\n\tbasic_string(const _Tp& __t, size_type __pos, size_type __n,\n\t\t     const _Alloc& __a = _Alloc())\n\t: basic_string(_S_to_string_view(__t).substr(__pos, __n), __a) { }\n\n      /**\n       *  @brief  Construct string from a string_view.\n       *  @param  __t  Source object convertible to string view.\n       *  @param  __a  Allocator to use (default is default allocator).\n       */\n      template<typename _Tp, typename = _If_sv<_Tp, void>>\n\texplicit\n\tbasic_string(const _Tp& __t, const _Alloc& __a = _Alloc())\n\t: basic_string(__sv_wrapper(_S_to_string_view(__t)), __a) { }\n\n      /**\n       *  @brief  Only internally used: Construct string from a string view\n       *          wrapper.\n       *  @param  __svw  string view wrapper.\n       *  @param  __a  Allocator to use.\n       */\n      explicit\n      basic_string(__sv_wrapper __svw, const _Alloc& __a)\n      : basic_string(__svw._M_sv.data(), __svw._M_sv.size(), __a) { }\n#endif // C++17\n\n      /**\n       *  @brief  Destroy the string instance.\n       */\n      ~basic_string() _GLIBCXX_NOEXCEPT\n      { _M_rep()->_M_dispose(this->get_allocator()); }\n\n      /**\n       *  @brief  Assign the value of @a str to this string.\n       *  @param  __str  Source string.\n       */\n      basic_string&\n      operator=(const basic_string& __str) \n      { return this->assign(__str); }\n\n      /**\n       *  @brief  Copy contents of @a s into this string.\n       *  @param  __s  Source null-terminated string.\n       */\n      basic_string&\n      operator=(const _CharT* __s) \n      { return this->assign(__s); }\n\n      /**\n       *  @brief  Set value to string of length 1.\n       *  @param  __c  Source character.\n       *\n       *  Assigning to a character makes this string length 1 and\n       *  (*this)[0] == @a c.\n       */\n      basic_string&\n      operator=(_CharT __c) \n      { \n\tthis->assign(1, __c); \n\treturn *this;\n      }\n\n#if __cplusplus >= 201103L\n      /**\n       *  @brief  Move assign the value of @a str to this string.\n       *  @param  __str  Source string.\n       *\n       *  The contents of @a str are moved into this string (without copying).\n       *  @a str is a valid, but unspecified string.\n       **/\n      // PR 58265, this should be noexcept.\n      basic_string&\n      operator=(basic_string&& __str)\n      {\n\t// NB: DR 1204.\n\tthis->swap(__str);\n\treturn *this;\n      }\n\n      /**\n       *  @brief  Set value to string constructed from initializer %list.\n       *  @param  __l  std::initializer_list.\n       */\n      basic_string&\n      operator=(initializer_list<_CharT> __l)\n      {\n\tthis->assign(__l.begin(), __l.size());\n\treturn *this;\n      }\n#endif // C++11\n\n#if __cplusplus > 201402L\n      /**\n       *  @brief  Set value to string constructed from a string_view.\n       *  @param  __svt An object convertible to  string_view.\n       */\n      template<typename _Tp>\n\t_If_sv<_Tp, basic_string&>\n\toperator=(const _Tp& __svt)\n\t{ return this->assign(__svt); }\n\n      /**\n       *  @brief  Convert to a string_view.\n       *  @return A string_view.\n       */\n      operator __sv_type() const noexcept\n      { return __sv_type(data(), size()); }\n#endif // C++17\n\n      // Iterators:\n      /**\n       *  Returns a read/write iterator that points to the first character in\n       *  the %string.  Unshares the string.\n       */\n      iterator\n      begin() // FIXME C++11: should be noexcept.\n      {\n\t_M_leak();\n\treturn iterator(_M_data());\n      }\n\n      /**\n       *  Returns a read-only (constant) iterator that points to the first\n       *  character in the %string.\n       */\n      const_iterator\n      begin() const _GLIBCXX_NOEXCEPT\n      { return const_iterator(_M_data()); }\n\n      /**\n       *  Returns a read/write iterator that points one past the last\n       *  character in the %string.  Unshares the string.\n       */\n      iterator\n      end() // FIXME C++11: should be noexcept.\n      {\n\t_M_leak();\n\treturn iterator(_M_data() + this->size());\n      }\n\n      /**\n       *  Returns a read-only (constant) iterator that points one past the\n       *  last character in the %string.\n       */\n      const_iterator\n      end() const _GLIBCXX_NOEXCEPT\n      { return const_iterator(_M_data() + this->size()); }\n\n      /**\n       *  Returns a read/write reverse iterator that points to the last\n       *  character in the %string.  Iteration is done in reverse element\n       *  order.  Unshares the string.\n       */\n      reverse_iterator\n      rbegin() // FIXME C++11: should be noexcept.\n      { return reverse_iterator(this->end()); }\n\n      /**\n       *  Returns a read-only (constant) reverse iterator that points\n       *  to the last character in the %string.  Iteration is done in\n       *  reverse element order.\n       */\n      const_reverse_iterator\n      rbegin() const _GLIBCXX_NOEXCEPT\n      { return const_reverse_iterator(this->end()); }\n\n      /**\n       *  Returns a read/write reverse iterator that points to one before the\n       *  first character in the %string.  Iteration is done in reverse\n       *  element order.  Unshares the string.\n       */\n      reverse_iterator\n      rend() // FIXME C++11: should be noexcept.\n      { return reverse_iterator(this->begin()); }\n\n      /**\n       *  Returns a read-only (constant) reverse iterator that points\n       *  to one before the first character in the %string.  Iteration\n       *  is done in reverse element order.\n       */\n      const_reverse_iterator\n      rend() const _GLIBCXX_NOEXCEPT\n      { return const_reverse_iterator(this->begin()); }\n\n#if __cplusplus >= 201103L\n      /**\n       *  Returns a read-only (constant) iterator that points to the first\n       *  character in the %string.\n       */\n      const_iterator\n      cbegin() const noexcept\n      { return const_iterator(this->_M_data()); }\n\n      /**\n       *  Returns a read-only (constant) iterator that points one past the\n       *  last character in the %string.\n       */\n      const_iterator\n      cend() const noexcept\n      { return const_iterator(this->_M_data() + this->size()); }\n\n      /**\n       *  Returns a read-only (constant) reverse iterator that points\n       *  to the last character in the %string.  Iteration is done in\n       *  reverse element order.\n       */\n      const_reverse_iterator\n      crbegin() const noexcept\n      { return const_reverse_iterator(this->end()); }\n\n      /**\n       *  Returns a read-only (constant) reverse iterator that points\n       *  to one before the first character in the %string.  Iteration\n       *  is done in reverse element order.\n       */\n      const_reverse_iterator\n      crend() const noexcept\n      { return const_reverse_iterator(this->begin()); }\n#endif\n\n    public:\n      // Capacity:\n      ///  Returns the number of characters in the string, not including any\n      ///  null-termination.\n      size_type\n      size() const _GLIBCXX_NOEXCEPT\n      { return _M_rep()->_M_length; }\n\n      ///  Returns the number of characters in the string, not including any\n      ///  null-termination.\n      size_type\n      length() const _GLIBCXX_NOEXCEPT\n      { return _M_rep()->_M_length; }\n\n      ///  Returns the size() of the largest possible %string.\n      size_type\n      max_size() const _GLIBCXX_NOEXCEPT\n      { return _Rep::_S_max_size; }\n\n      /**\n       *  @brief  Resizes the %string to the specified number of characters.\n       *  @param  __n  Number of characters the %string should contain.\n       *  @param  __c  Character to fill any new elements.\n       *\n       *  This function will %resize the %string to the specified\n       *  number of characters.  If the number is smaller than the\n       *  %string's current size the %string is truncated, otherwise\n       *  the %string is extended and new elements are %set to @a __c.\n       */\n      void\n      resize(size_type __n, _CharT __c);\n\n      /**\n       *  @brief  Resizes the %string to the specified number of characters.\n       *  @param  __n  Number of characters the %string should contain.\n       *\n       *  This function will resize the %string to the specified length.  If\n       *  the new size is smaller than the %string's current size the %string\n       *  is truncated, otherwise the %string is extended and new characters\n       *  are default-constructed.  For basic types such as char, this means\n       *  setting them to 0.\n       */\n      void\n      resize(size_type __n)\n      { this->resize(__n, _CharT()); }\n\n#if __cplusplus >= 201103L\n      ///  A non-binding request to reduce capacity() to size().\n      void\n      shrink_to_fit() _GLIBCXX_NOEXCEPT\n      {\n#if __cpp_exceptions\n\tif (capacity() > size())\n\t  {\n\t    try\n\t      { reserve(0); }\n\t    catch(...)\n\t      { }\n\t  }\n#endif\n      }\n#endif\n\n      /**\n       *  Returns the total number of characters that the %string can hold\n       *  before needing to allocate more memory.\n       */\n      size_type\n      capacity() const _GLIBCXX_NOEXCEPT\n      { return _M_rep()->_M_capacity; }\n\n      /**\n       *  @brief  Attempt to preallocate enough memory for specified number of\n       *          characters.\n       *  @param  __res_arg  Number of characters required.\n       *  @throw  std::length_error  If @a __res_arg exceeds @c max_size().\n       *\n       *  This function attempts to reserve enough memory for the\n       *  %string to hold the specified number of characters.  If the\n       *  number requested is more than max_size(), length_error is\n       *  thrown.\n       *\n       *  The advantage of this function is that if optimal code is a\n       *  necessity and the user can determine the string length that will be\n       *  required, the user can reserve the memory in %advance, and thus\n       *  prevent a possible reallocation of memory and copying of %string\n       *  data.\n       */\n      void\n      reserve(size_type __res_arg = 0);\n\n      /**\n       *  Erases the string, making it empty.\n       */\n#if _GLIBCXX_FULLY_DYNAMIC_STRING == 0\n      void\n      clear() _GLIBCXX_NOEXCEPT\n      {\n\tif (_M_rep()->_M_is_shared())\n\t  {\n\t    _M_rep()->_M_dispose(this->get_allocator());\n\t    _M_data(_S_empty_rep()._M_refdata());\n\t  }\n\telse\n\t  _M_rep()->_M_set_length_and_sharable(0);\n      }\n#else\n      // PR 56166: this should not throw.\n      void\n      clear()\n      { _M_mutate(0, this->size(), 0); }\n#endif\n\n      /**\n       *  Returns true if the %string is empty.  Equivalent to \n       *  <code>*this == \"\"</code>.\n       */\n      bool\n      empty() const _GLIBCXX_NOEXCEPT\n      { return this->size() == 0; }\n\n      // Element access:\n      /**\n       *  @brief  Subscript access to the data contained in the %string.\n       *  @param  __pos  The index of the character to access.\n       *  @return  Read-only (constant) reference to the character.\n       *\n       *  This operator allows for easy, array-style, data access.\n       *  Note that data access with this operator is unchecked and\n       *  out_of_range lookups are not defined. (For checked lookups\n       *  see at().)\n       */\n      const_reference\n      operator[] (size_type __pos) const _GLIBCXX_NOEXCEPT\n      {\n\t__glibcxx_assert(__pos <= size());\n\treturn _M_data()[__pos];\n      }\n\n      /**\n       *  @brief  Subscript access to the data contained in the %string.\n       *  @param  __pos  The index of the character to access.\n       *  @return  Read/write reference to the character.\n       *\n       *  This operator allows for easy, array-style, data access.\n       *  Note that data access with this operator is unchecked and\n       *  out_of_range lookups are not defined. (For checked lookups\n       *  see at().)  Unshares the string.\n       */\n      reference\n      operator[](size_type __pos)\n      {\n        // Allow pos == size() both in C++98 mode, as v3 extension,\n\t// and in C++11 mode.\n\t__glibcxx_assert(__pos <= size());\n        // In pedantic mode be strict in C++98 mode.\n\t_GLIBCXX_DEBUG_PEDASSERT(__cplusplus >= 201103L || __pos < size());\n\t_M_leak();\n\treturn _M_data()[__pos];\n      }\n\n      /**\n       *  @brief  Provides access to the data contained in the %string.\n       *  @param __n The index of the character to access.\n       *  @return  Read-only (const) reference to the character.\n       *  @throw  std::out_of_range  If @a n is an invalid index.\n       *\n       *  This function provides for safer data access.  The parameter is\n       *  first checked that it is in the range of the string.  The function\n       *  throws out_of_range if the check fails.\n       */\n      const_reference\n      at(size_type __n) const\n      {\n\tif (__n >= this->size())\n\t  __throw_out_of_range_fmt(__N(\"basic_string::at: __n \"\n\t\t\t\t       \"(which is %zu) >= this->size() \"\n\t\t\t\t       \"(which is %zu)\"),\n\t\t\t\t   __n, this->size());\n\treturn _M_data()[__n];\n      }\n\n      /**\n       *  @brief  Provides access to the data contained in the %string.\n       *  @param __n The index of the character to access.\n       *  @return  Read/write reference to the character.\n       *  @throw  std::out_of_range  If @a n is an invalid index.\n       *\n       *  This function provides for safer data access.  The parameter is\n       *  first checked that it is in the range of the string.  The function\n       *  throws out_of_range if the check fails.  Success results in\n       *  unsharing the string.\n       */\n      reference\n      at(size_type __n)\n      {\n\tif (__n >= size())\n\t  __throw_out_of_range_fmt(__N(\"basic_string::at: __n \"\n\t\t\t\t       \"(which is %zu) >= this->size() \"\n\t\t\t\t       \"(which is %zu)\"),\n\t\t\t\t   __n, this->size());\n\t_M_leak();\n\treturn _M_data()[__n];\n      }\n\n#if __cplusplus >= 201103L\n      /**\n       *  Returns a read/write reference to the data at the first\n       *  element of the %string.\n       */\n      reference\n      front()\n      {\n\t__glibcxx_assert(!empty());\n\treturn operator[](0);\n      }\n\n      /**\n       *  Returns a read-only (constant) reference to the data at the first\n       *  element of the %string.\n       */\n      const_reference\n      front() const noexcept\n      {\n\t__glibcxx_assert(!empty());\n\treturn operator[](0);\n      }\n\n      /**\n       *  Returns a read/write reference to the data at the last\n       *  element of the %string.\n       */\n      reference\n      back()\n      {\n\t__glibcxx_assert(!empty());\n\treturn operator[](this->size() - 1);\n      }\n\n      /**\n       *  Returns a read-only (constant) reference to the data at the\n       *  last element of the %string.\n       */\n      const_reference\n      back() const noexcept\n      {\n\t__glibcxx_assert(!empty());\n\treturn operator[](this->size() - 1);\n      }\n#endif\n\n      // Modifiers:\n      /**\n       *  @brief  Append a string to this string.\n       *  @param __str  The string to append.\n       *  @return  Reference to this string.\n       */\n      basic_string&\n      operator+=(const basic_string& __str)\n      { return this->append(__str); }\n\n      /**\n       *  @brief  Append a C string.\n       *  @param __s  The C string to append.\n       *  @return  Reference to this string.\n       */\n      basic_string&\n      operator+=(const _CharT* __s)\n      { return this->append(__s); }\n\n      /**\n       *  @brief  Append a character.\n       *  @param __c  The character to append.\n       *  @return  Reference to this string.\n       */\n      basic_string&\n      operator+=(_CharT __c)\n      { \n\tthis->push_back(__c);\n\treturn *this;\n      }\n\n#if __cplusplus >= 201103L\n      /**\n       *  @brief  Append an initializer_list of characters.\n       *  @param __l  The initializer_list of characters to be appended.\n       *  @return  Reference to this string.\n       */\n      basic_string&\n      operator+=(initializer_list<_CharT> __l)\n      { return this->append(__l.begin(), __l.size()); }\n#endif // C++11\n\n#if __cplusplus > 201402L\n      /**\n       *  @brief  Append a string_view.\n       *  @param __svt The object convertible to string_view to be appended.\n       *  @return  Reference to this string.\n       */\n      template<typename _Tp>\n\t_If_sv<_Tp, basic_string&>\n\toperator+=(const _Tp& __svt)\n\t{ return this->append(__svt); }\n#endif // C++17\n\n      /**\n       *  @brief  Append a string to this string.\n       *  @param __str  The string to append.\n       *  @return  Reference to this string.\n       */\n      basic_string&\n      append(const basic_string& __str);\n\n      /**\n       *  @brief  Append a substring.\n       *  @param __str  The string to append.\n       *  @param __pos  Index of the first character of str to append.\n       *  @param __n  The number of characters to append.\n       *  @return  Reference to this string.\n       *  @throw  std::out_of_range if @a __pos is not a valid index.\n       *\n       *  This function appends @a __n characters from @a __str\n       *  starting at @a __pos to this string.  If @a __n is is larger\n       *  than the number of available characters in @a __str, the\n       *  remainder of @a __str is appended.\n       */\n      basic_string&\n      append(const basic_string& __str, size_type __pos, size_type __n = npos);\n\n      /**\n       *  @brief  Append a C substring.\n       *  @param __s  The C string to append.\n       *  @param __n  The number of characters to append.\n       *  @return  Reference to this string.\n       */\n      basic_string&\n      append(const _CharT* __s, size_type __n);\n\n      /**\n       *  @brief  Append a C string.\n       *  @param __s  The C string to append.\n       *  @return  Reference to this string.\n       */\n      basic_string&\n      append(const _CharT* __s)\n      {\n\t__glibcxx_requires_string(__s);\n\treturn this->append(__s, traits_type::length(__s));\n      }\n\n      /**\n       *  @brief  Append multiple characters.\n       *  @param __n  The number of characters to append.\n       *  @param __c  The character to use.\n       *  @return  Reference to this string.\n       *\n       *  Appends __n copies of __c to this string.\n       */\n      basic_string&\n      append(size_type __n, _CharT __c);\n\n#if __cplusplus >= 201103L\n      /**\n       *  @brief  Append an initializer_list of characters.\n       *  @param __l  The initializer_list of characters to append.\n       *  @return  Reference to this string.\n       */\n      basic_string&\n      append(initializer_list<_CharT> __l)\n      { return this->append(__l.begin(), __l.size()); }\n#endif // C++11\n\n      /**\n       *  @brief  Append a range of characters.\n       *  @param __first  Iterator referencing the first character to append.\n       *  @param __last  Iterator marking the end of the range.\n       *  @return  Reference to this string.\n       *\n       *  Appends characters in the range [__first,__last) to this string.\n       */\n      template<class _InputIterator>\n        basic_string&\n        append(_InputIterator __first, _InputIterator __last)\n        { return this->replace(_M_iend(), _M_iend(), __first, __last); }\n\n#if __cplusplus > 201402L\n      /**\n       *  @brief  Append a string_view.\n       *  @param __svt The object convertible to string_view to be appended.\n       *  @return  Reference to this string.\n       */\n      template<typename _Tp>\n\t_If_sv<_Tp, basic_string&>\n\tappend(const _Tp& __svt)\n\t{\n\t  __sv_type __sv = __svt;\n\t  return this->append(__sv.data(), __sv.size());\n\t}\n\n      /**\n       *  @brief  Append a range of characters from a string_view.\n       *  @param __svt The object convertible to string_view to be appended\n       *               from.\n       *  @param __pos The position in the string_view to append from.\n       *  @param __n   The number of characters to append from the string_view.\n       *  @return  Reference to this string.\n       */\n      template<typename _Tp>\n        _If_sv<_Tp, basic_string&>\n\tappend(const _Tp& __svt, size_type __pos, size_type __n = npos)\n\t{\n\t  __sv_type __sv = __svt;\n\t  return append(__sv.data()\n\t\t\t+ __sv._M_check(__pos, \"basic_string::append\"),\n\t\t\t__sv._M_limit(__pos, __n));\n\t}\n#endif // C++17\n\n      /**\n       *  @brief  Append a single character.\n       *  @param __c  Character to append.\n       */\n      void\n      push_back(_CharT __c)\n      { \n\tconst size_type __len = 1 + this->size();\n\tif (__len > this->capacity() || _M_rep()->_M_is_shared())\n\t  this->reserve(__len);\n\ttraits_type::assign(_M_data()[this->size()], __c);\n\t_M_rep()->_M_set_length_and_sharable(__len);\n      }\n\n      /**\n       *  @brief  Set value to contents of another string.\n       *  @param  __str  Source string to use.\n       *  @return  Reference to this string.\n       */\n      basic_string&\n      assign(const basic_string& __str);\n\n#if __cplusplus >= 201103L\n      /**\n       *  @brief  Set value to contents of another string.\n       *  @param  __str  Source string to use.\n       *  @return  Reference to this string.\n       *\n       *  This function sets this string to the exact contents of @a __str.\n       *  @a __str is a valid, but unspecified string.\n       */\n      // PR 58265, this should be noexcept.\n      basic_string&\n      assign(basic_string&& __str)\n      {\n\tthis->swap(__str);\n\treturn *this;\n      }\n#endif // C++11\n\n      /**\n       *  @brief  Set value to a substring of a string.\n       *  @param __str  The string to use.\n       *  @param __pos  Index of the first character of str.\n       *  @param __n  Number of characters to use.\n       *  @return  Reference to this string.\n       *  @throw  std::out_of_range if @a pos is not a valid index.\n       *\n       *  This function sets this string to the substring of @a __str\n       *  consisting of @a __n characters at @a __pos.  If @a __n is\n       *  is larger than the number of available characters in @a\n       *  __str, the remainder of @a __str is used.\n       */\n      basic_string&\n      assign(const basic_string& __str, size_type __pos, size_type __n = npos)\n      { return this->assign(__str._M_data()\n\t\t\t    + __str._M_check(__pos, \"basic_string::assign\"),\n\t\t\t    __str._M_limit(__pos, __n)); }\n\n      /**\n       *  @brief  Set value to a C substring.\n       *  @param __s  The C string to use.\n       *  @param __n  Number of characters to use.\n       *  @return  Reference to this string.\n       *\n       *  This function sets the value of this string to the first @a __n\n       *  characters of @a __s.  If @a __n is is larger than the number of\n       *  available characters in @a __s, the remainder of @a __s is used.\n       */\n      basic_string&\n      assign(const _CharT* __s, size_type __n);\n\n      /**\n       *  @brief  Set value to contents of a C string.\n       *  @param __s  The C string to use.\n       *  @return  Reference to this string.\n       *\n       *  This function sets the value of this string to the value of @a __s.\n       *  The data is copied, so there is no dependence on @a __s once the\n       *  function returns.\n       */\n      basic_string&\n      assign(const _CharT* __s)\n      {\n\t__glibcxx_requires_string(__s);\n\treturn this->assign(__s, traits_type::length(__s));\n      }\n\n      /**\n       *  @brief  Set value to multiple characters.\n       *  @param __n  Length of the resulting string.\n       *  @param __c  The character to use.\n       *  @return  Reference to this string.\n       *\n       *  This function sets the value of this string to @a __n copies of\n       *  character @a __c.\n       */\n      basic_string&\n      assign(size_type __n, _CharT __c)\n      { return _M_replace_aux(size_type(0), this->size(), __n, __c); }\n\n      /**\n       *  @brief  Set value to a range of characters.\n       *  @param __first  Iterator referencing the first character to append.\n       *  @param __last  Iterator marking the end of the range.\n       *  @return  Reference to this string.\n       *\n       *  Sets value of string to characters in the range [__first,__last).\n      */\n      template<class _InputIterator>\n        basic_string&\n        assign(_InputIterator __first, _InputIterator __last)\n        { return this->replace(_M_ibegin(), _M_iend(), __first, __last); }\n\n#if __cplusplus >= 201103L\n      /**\n       *  @brief  Set value to an initializer_list of characters.\n       *  @param __l  The initializer_list of characters to assign.\n       *  @return  Reference to this string.\n       */\n      basic_string&\n      assign(initializer_list<_CharT> __l)\n      { return this->assign(__l.begin(), __l.size()); }\n#endif // C++11\n\n#if __cplusplus > 201402L\n      /**\n       *  @brief  Set value from a string_view.\n       *  @param __svt The source object convertible to string_view.\n       *  @return  Reference to this string.\n       */\n      template<typename _Tp>\n\t_If_sv<_Tp, basic_string&>\n\tassign(const _Tp& __svt)\n\t{\n\t  __sv_type __sv = __svt;\n\t  return this->assign(__sv.data(), __sv.size());\n\t}\n\n      /**\n       *  @brief  Set value from a range of characters in a string_view.\n       *  @param __svt  The source object convertible to string_view.\n       *  @param __pos  The position in the string_view to assign from.\n       *  @param __n  The number of characters to assign.\n       *  @return  Reference to this string.\n       */\n      template<typename _Tp>\n        _If_sv<_Tp, basic_string&>\n        assign(const _Tp& __svt, size_type __pos, size_type __n = npos)\n\t{\n\t  __sv_type __sv = __svt;\n\t  return assign(__sv.data()\n\t\t\t+ __sv._M_check(__pos, \"basic_string::assign\"),\n\t\t\t__sv._M_limit(__pos, __n));\n\t}\n#endif // C++17\n\n      /**\n       *  @brief  Insert multiple characters.\n       *  @param __p  Iterator referencing location in string to insert at.\n       *  @param __n  Number of characters to insert\n       *  @param __c  The character to insert.\n       *  @throw  std::length_error  If new length exceeds @c max_size().\n       *\n       *  Inserts @a __n copies of character @a __c starting at the\n       *  position referenced by iterator @a __p.  If adding\n       *  characters causes the length to exceed max_size(),\n       *  length_error is thrown.  The value of the string doesn't\n       *  change if an error is thrown.\n      */\n      void\n      insert(iterator __p, size_type __n, _CharT __c)\n      {\tthis->replace(__p, __p, __n, __c);  }\n\n      /**\n       *  @brief  Insert a range of characters.\n       *  @param __p  Iterator referencing location in string to insert at.\n       *  @param __beg  Start of range.\n       *  @param __end  End of range.\n       *  @throw  std::length_error  If new length exceeds @c max_size().\n       *\n       *  Inserts characters in range [__beg,__end).  If adding\n       *  characters causes the length to exceed max_size(),\n       *  length_error is thrown.  The value of the string doesn't\n       *  change if an error is thrown.\n      */\n      template<class _InputIterator>\n        void\n        insert(iterator __p, _InputIterator __beg, _InputIterator __end)\n        { this->replace(__p, __p, __beg, __end); }\n\n#if __cplusplus >= 201103L\n      /**\n       *  @brief  Insert an initializer_list of characters.\n       *  @param __p  Iterator referencing location in string to insert at.\n       *  @param __l  The initializer_list of characters to insert.\n       *  @throw  std::length_error  If new length exceeds @c max_size().\n       */\n      void\n      insert(iterator __p, initializer_list<_CharT> __l)\n      {\n\t_GLIBCXX_DEBUG_PEDASSERT(__p >= _M_ibegin() && __p <= _M_iend());\n\tthis->insert(__p - _M_ibegin(), __l.begin(), __l.size());\n      }\n#endif // C++11\n\n      /**\n       *  @brief  Insert value of a string.\n       *  @param __pos1  Iterator referencing location in string to insert at.\n       *  @param __str  The string to insert.\n       *  @return  Reference to this string.\n       *  @throw  std::length_error  If new length exceeds @c max_size().\n       *\n       *  Inserts value of @a __str starting at @a __pos1.  If adding\n       *  characters causes the length to exceed max_size(),\n       *  length_error is thrown.  The value of the string doesn't\n       *  change if an error is thrown.\n      */\n      basic_string&\n      insert(size_type __pos1, const basic_string& __str)\n      { return this->insert(__pos1, __str, size_type(0), __str.size()); }\n\n      /**\n       *  @brief  Insert a substring.\n       *  @param __pos1  Iterator referencing location in string to insert at.\n       *  @param __str  The string to insert.\n       *  @param __pos2  Start of characters in str to insert.\n       *  @param __n  Number of characters to insert.\n       *  @return  Reference to this string.\n       *  @throw  std::length_error  If new length exceeds @c max_size().\n       *  @throw  std::out_of_range  If @a pos1 > size() or\n       *  @a __pos2 > @a str.size().\n       *\n       *  Starting at @a pos1, insert @a __n character of @a __str\n       *  beginning with @a __pos2.  If adding characters causes the\n       *  length to exceed max_size(), length_error is thrown.  If @a\n       *  __pos1 is beyond the end of this string or @a __pos2 is\n       *  beyond the end of @a __str, out_of_range is thrown.  The\n       *  value of the string doesn't change if an error is thrown.\n      */\n      basic_string&\n      insert(size_type __pos1, const basic_string& __str,\n\t     size_type __pos2, size_type __n = npos)\n      { return this->insert(__pos1, __str._M_data()\n\t\t\t    + __str._M_check(__pos2, \"basic_string::insert\"),\n\t\t\t    __str._M_limit(__pos2, __n)); }\n\n      /**\n       *  @brief  Insert a C substring.\n       *  @param __pos  Iterator referencing location in string to insert at.\n       *  @param __s  The C string to insert.\n       *  @param __n  The number of characters to insert.\n       *  @return  Reference to this string.\n       *  @throw  std::length_error  If new length exceeds @c max_size().\n       *  @throw  std::out_of_range  If @a __pos is beyond the end of this\n       *  string.\n       *\n       *  Inserts the first @a __n characters of @a __s starting at @a\n       *  __pos.  If adding characters causes the length to exceed\n       *  max_size(), length_error is thrown.  If @a __pos is beyond\n       *  end(), out_of_range is thrown.  The value of the string\n       *  doesn't change if an error is thrown.\n      */\n      basic_string&\n      insert(size_type __pos, const _CharT* __s, size_type __n);\n\n      /**\n       *  @brief  Insert a C string.\n       *  @param __pos  Iterator referencing location in string to insert at.\n       *  @param __s  The C string to insert.\n       *  @return  Reference to this string.\n       *  @throw  std::length_error  If new length exceeds @c max_size().\n       *  @throw  std::out_of_range  If @a pos is beyond the end of this\n       *  string.\n       *\n       *  Inserts the first @a n characters of @a __s starting at @a __pos.  If\n       *  adding characters causes the length to exceed max_size(),\n       *  length_error is thrown.  If @a __pos is beyond end(), out_of_range is\n       *  thrown.  The value of the string doesn't change if an error is\n       *  thrown.\n      */\n      basic_string&\n      insert(size_type __pos, const _CharT* __s)\n      {\n\t__glibcxx_requires_string(__s);\n\treturn this->insert(__pos, __s, traits_type::length(__s));\n      }\n\n      /**\n       *  @brief  Insert multiple characters.\n       *  @param __pos  Index in string to insert at.\n       *  @param __n  Number of characters to insert\n       *  @param __c  The character to insert.\n       *  @return  Reference to this string.\n       *  @throw  std::length_error  If new length exceeds @c max_size().\n       *  @throw  std::out_of_range  If @a __pos is beyond the end of this\n       *  string.\n       *\n       *  Inserts @a __n copies of character @a __c starting at index\n       *  @a __pos.  If adding characters causes the length to exceed\n       *  max_size(), length_error is thrown.  If @a __pos > length(),\n       *  out_of_range is thrown.  The value of the string doesn't\n       *  change if an error is thrown.\n      */\n      basic_string&\n      insert(size_type __pos, size_type __n, _CharT __c)\n      { return _M_replace_aux(_M_check(__pos, \"basic_string::insert\"),\n\t\t\t      size_type(0), __n, __c); }\n\n      /**\n       *  @brief  Insert one character.\n       *  @param __p  Iterator referencing position in string to insert at.\n       *  @param __c  The character to insert.\n       *  @return  Iterator referencing newly inserted char.\n       *  @throw  std::length_error  If new length exceeds @c max_size().\n       *\n       *  Inserts character @a __c at position referenced by @a __p.\n       *  If adding character causes the length to exceed max_size(),\n       *  length_error is thrown.  If @a __p is beyond end of string,\n       *  out_of_range is thrown.  The value of the string doesn't\n       *  change if an error is thrown.\n      */\n      iterator\n      insert(iterator __p, _CharT __c)\n      {\n\t_GLIBCXX_DEBUG_PEDASSERT(__p >= _M_ibegin() && __p <= _M_iend());\n\tconst size_type __pos = __p - _M_ibegin();\n\t_M_replace_aux(__pos, size_type(0), size_type(1), __c);\n\t_M_rep()->_M_set_leaked();\n\treturn iterator(_M_data() + __pos);\n      }\n\n#if __cplusplus > 201402L\n      /**\n       *  @brief  Insert a string_view.\n       *  @param __pos  Iterator referencing position in string to insert at.\n       *  @param __svt  The object convertible to string_view to insert.\n       *  @return  Reference to this string.\n      */\n      template<typename _Tp>\n\t_If_sv<_Tp, basic_string&>\n\tinsert(size_type __pos, const _Tp& __svt)\n\t{\n\t  __sv_type __sv = __svt;\n\t  return this->insert(__pos, __sv.data(), __sv.size());\n\t}\n\n      /**\n       *  @brief  Insert a string_view.\n       *  @param __pos  Iterator referencing position in string to insert at.\n       *  @param __svt  The object convertible to string_view to insert from.\n       *  @param __pos  Iterator referencing position in string_view to insert\n       *  from.\n       *  @param __n    The number of characters to insert.\n       *  @return  Reference to this string.\n      */\n      template<typename _Tp>\n        _If_sv<_Tp, basic_string&>\n        insert(size_type __pos1, const _Tp& __svt,\n\t       size_type __pos2, size_type __n = npos)\n\t{\n\t  __sv_type __sv = __svt;\n\t  return this->replace(__pos1, size_type(0), __sv.data()\n\t\t\t       + __sv._M_check(__pos2, \"basic_string::insert\"),\n\t\t\t       __sv._M_limit(__pos2, __n));\n\t}\n#endif // C++17\n\n      /**\n       *  @brief  Remove characters.\n       *  @param __pos  Index of first character to remove (default 0).\n       *  @param __n  Number of characters to remove (default remainder).\n       *  @return  Reference to this string.\n       *  @throw  std::out_of_range  If @a pos is beyond the end of this\n       *  string.\n       *\n       *  Removes @a __n characters from this string starting at @a\n       *  __pos.  The length of the string is reduced by @a __n.  If\n       *  there are < @a __n characters to remove, the remainder of\n       *  the string is truncated.  If @a __p is beyond end of string,\n       *  out_of_range is thrown.  The value of the string doesn't\n       *  change if an error is thrown.\n      */\n      basic_string&\n      erase(size_type __pos = 0, size_type __n = npos)\n      { \n\t_M_mutate(_M_check(__pos, \"basic_string::erase\"),\n\t\t  _M_limit(__pos, __n), size_type(0));\n\treturn *this;\n      }\n\n      /**\n       *  @brief  Remove one character.\n       *  @param __position  Iterator referencing the character to remove.\n       *  @return  iterator referencing same location after removal.\n       *\n       *  Removes the character at @a __position from this string. The value\n       *  of the string doesn't change if an error is thrown.\n      */\n      iterator\n      erase(iterator __position)\n      {\n\t_GLIBCXX_DEBUG_PEDASSERT(__position >= _M_ibegin()\n\t\t\t\t && __position < _M_iend());\n\tconst size_type __pos = __position - _M_ibegin();\n\t_M_mutate(__pos, size_type(1), size_type(0));\n\t_M_rep()->_M_set_leaked();\n\treturn iterator(_M_data() + __pos);\n      }\n\n      /**\n       *  @brief  Remove a range of characters.\n       *  @param __first  Iterator referencing the first character to remove.\n       *  @param __last  Iterator referencing the end of the range.\n       *  @return  Iterator referencing location of first after removal.\n       *\n       *  Removes the characters in the range [first,last) from this string.\n       *  The value of the string doesn't change if an error is thrown.\n      */\n      iterator\n      erase(iterator __first, iterator __last);\n \n#if __cplusplus >= 201103L\n      /**\n       *  @brief  Remove the last character.\n       *\n       *  The string must be non-empty.\n       */\n      void\n      pop_back() // FIXME C++11: should be noexcept.\n      {\n\t__glibcxx_assert(!empty());\n\terase(size() - 1, 1);\n      }\n#endif // C++11\n\n      /**\n       *  @brief  Replace characters with value from another string.\n       *  @param __pos  Index of first character to replace.\n       *  @param __n  Number of characters to be replaced.\n       *  @param __str  String to insert.\n       *  @return  Reference to this string.\n       *  @throw  std::out_of_range  If @a pos is beyond the end of this\n       *  string.\n       *  @throw  std::length_error  If new length exceeds @c max_size().\n       *\n       *  Removes the characters in the range [__pos,__pos+__n) from\n       *  this string.  In place, the value of @a __str is inserted.\n       *  If @a __pos is beyond end of string, out_of_range is thrown.\n       *  If the length of the result exceeds max_size(), length_error\n       *  is thrown.  The value of the string doesn't change if an\n       *  error is thrown.\n      */\n      basic_string&\n      replace(size_type __pos, size_type __n, const basic_string& __str)\n      { return this->replace(__pos, __n, __str._M_data(), __str.size()); }\n\n      /**\n       *  @brief  Replace characters with value from another string.\n       *  @param __pos1  Index of first character to replace.\n       *  @param __n1  Number of characters to be replaced.\n       *  @param __str  String to insert.\n       *  @param __pos2  Index of first character of str to use.\n       *  @param __n2  Number of characters from str to use.\n       *  @return  Reference to this string.\n       *  @throw  std::out_of_range  If @a __pos1 > size() or @a __pos2 >\n       *  __str.size().\n       *  @throw  std::length_error  If new length exceeds @c max_size().\n       *\n       *  Removes the characters in the range [__pos1,__pos1 + n) from this\n       *  string.  In place, the value of @a __str is inserted.  If @a __pos is\n       *  beyond end of string, out_of_range is thrown.  If the length of the\n       *  result exceeds max_size(), length_error is thrown.  The value of the\n       *  string doesn't change if an error is thrown.\n      */\n      basic_string&\n      replace(size_type __pos1, size_type __n1, const basic_string& __str,\n\t      size_type __pos2, size_type __n2 = npos)\n      { return this->replace(__pos1, __n1, __str._M_data()\n\t\t\t     + __str._M_check(__pos2, \"basic_string::replace\"),\n\t\t\t     __str._M_limit(__pos2, __n2)); }\n\n      /**\n       *  @brief  Replace characters with value of a C substring.\n       *  @param __pos  Index of first character to replace.\n       *  @param __n1  Number of characters to be replaced.\n       *  @param __s  C string to insert.\n       *  @param __n2  Number of characters from @a s to use.\n       *  @return  Reference to this string.\n       *  @throw  std::out_of_range  If @a pos1 > size().\n       *  @throw  std::length_error  If new length exceeds @c max_size().\n       *\n       *  Removes the characters in the range [__pos,__pos + __n1)\n       *  from this string.  In place, the first @a __n2 characters of\n       *  @a __s are inserted, or all of @a __s if @a __n2 is too large.  If\n       *  @a __pos is beyond end of string, out_of_range is thrown.  If\n       *  the length of result exceeds max_size(), length_error is\n       *  thrown.  The value of the string doesn't change if an error\n       *  is thrown.\n      */\n      basic_string&\n      replace(size_type __pos, size_type __n1, const _CharT* __s,\n\t      size_type __n2);\n\n      /**\n       *  @brief  Replace characters with value of a C string.\n       *  @param __pos  Index of first character to replace.\n       *  @param __n1  Number of characters to be replaced.\n       *  @param __s  C string to insert.\n       *  @return  Reference to this string.\n       *  @throw  std::out_of_range  If @a pos > size().\n       *  @throw  std::length_error  If new length exceeds @c max_size().\n       *\n       *  Removes the characters in the range [__pos,__pos + __n1)\n       *  from this string.  In place, the characters of @a __s are\n       *  inserted.  If @a __pos is beyond end of string, out_of_range\n       *  is thrown.  If the length of result exceeds max_size(),\n       *  length_error is thrown.  The value of the string doesn't\n       *  change if an error is thrown.\n      */\n      basic_string&\n      replace(size_type __pos, size_type __n1, const _CharT* __s)\n      {\n\t__glibcxx_requires_string(__s);\n\treturn this->replace(__pos, __n1, __s, traits_type::length(__s));\n      }\n\n      /**\n       *  @brief  Replace characters with multiple characters.\n       *  @param __pos  Index of first character to replace.\n       *  @param __n1  Number of characters to be replaced.\n       *  @param __n2  Number of characters to insert.\n       *  @param __c  Character to insert.\n       *  @return  Reference to this string.\n       *  @throw  std::out_of_range  If @a __pos > size().\n       *  @throw  std::length_error  If new length exceeds @c max_size().\n       *\n       *  Removes the characters in the range [pos,pos + n1) from this\n       *  string.  In place, @a __n2 copies of @a __c are inserted.\n       *  If @a __pos is beyond end of string, out_of_range is thrown.\n       *  If the length of result exceeds max_size(), length_error is\n       *  thrown.  The value of the string doesn't change if an error\n       *  is thrown.\n      */\n      basic_string&\n      replace(size_type __pos, size_type __n1, size_type __n2, _CharT __c)\n      { return _M_replace_aux(_M_check(__pos, \"basic_string::replace\"),\n\t\t\t      _M_limit(__pos, __n1), __n2, __c); }\n\n      /**\n       *  @brief  Replace range of characters with string.\n       *  @param __i1  Iterator referencing start of range to replace.\n       *  @param __i2  Iterator referencing end of range to replace.\n       *  @param __str  String value to insert.\n       *  @return  Reference to this string.\n       *  @throw  std::length_error  If new length exceeds @c max_size().\n       *\n       *  Removes the characters in the range [__i1,__i2).  In place,\n       *  the value of @a __str is inserted.  If the length of result\n       *  exceeds max_size(), length_error is thrown.  The value of\n       *  the string doesn't change if an error is thrown.\n      */\n      basic_string&\n      replace(iterator __i1, iterator __i2, const basic_string& __str)\n      { return this->replace(__i1, __i2, __str._M_data(), __str.size()); }\n\n      /**\n       *  @brief  Replace range of characters with C substring.\n       *  @param __i1  Iterator referencing start of range to replace.\n       *  @param __i2  Iterator referencing end of range to replace.\n       *  @param __s  C string value to insert.\n       *  @param __n  Number of characters from s to insert.\n       *  @return  Reference to this string.\n       *  @throw  std::length_error  If new length exceeds @c max_size().\n       *\n       *  Removes the characters in the range [__i1,__i2).  In place,\n       *  the first @a __n characters of @a __s are inserted.  If the\n       *  length of result exceeds max_size(), length_error is thrown.\n       *  The value of the string doesn't change if an error is\n       *  thrown.\n      */\n      basic_string&\n      replace(iterator __i1, iterator __i2, const _CharT* __s, size_type __n)\n      {\n\t_GLIBCXX_DEBUG_PEDASSERT(_M_ibegin() <= __i1 && __i1 <= __i2\n\t\t\t\t && __i2 <= _M_iend());\n\treturn this->replace(__i1 - _M_ibegin(), __i2 - __i1, __s, __n);\n      }\n\n      /**\n       *  @brief  Replace range of characters with C string.\n       *  @param __i1  Iterator referencing start of range to replace.\n       *  @param __i2  Iterator referencing end of range to replace.\n       *  @param __s  C string value to insert.\n       *  @return  Reference to this string.\n       *  @throw  std::length_error  If new length exceeds @c max_size().\n       *\n       *  Removes the characters in the range [__i1,__i2).  In place,\n       *  the characters of @a __s are inserted.  If the length of\n       *  result exceeds max_size(), length_error is thrown.  The\n       *  value of the string doesn't change if an error is thrown.\n      */\n      basic_string&\n      replace(iterator __i1, iterator __i2, const _CharT* __s)\n      {\n\t__glibcxx_requires_string(__s);\n\treturn this->replace(__i1, __i2, __s, traits_type::length(__s));\n      }\n\n      /**\n       *  @brief  Replace range of characters with multiple characters\n       *  @param __i1  Iterator referencing start of range to replace.\n       *  @param __i2  Iterator referencing end of range to replace.\n       *  @param __n  Number of characters to insert.\n       *  @param __c  Character to insert.\n       *  @return  Reference to this string.\n       *  @throw  std::length_error  If new length exceeds @c max_size().\n       *\n       *  Removes the characters in the range [__i1,__i2).  In place,\n       *  @a __n copies of @a __c are inserted.  If the length of\n       *  result exceeds max_size(), length_error is thrown.  The\n       *  value of the string doesn't change if an error is thrown.\n      */\n      basic_string&\n      replace(iterator __i1, iterator __i2, size_type __n, _CharT __c)\n      {\n\t_GLIBCXX_DEBUG_PEDASSERT(_M_ibegin() <= __i1 && __i1 <= __i2\n\t\t\t\t && __i2 <= _M_iend());\n\treturn _M_replace_aux(__i1 - _M_ibegin(), __i2 - __i1, __n, __c);\n      }\n\n      /**\n       *  @brief  Replace range of characters with range.\n       *  @param __i1  Iterator referencing start of range to replace.\n       *  @param __i2  Iterator referencing end of range to replace.\n       *  @param __k1  Iterator referencing start of range to insert.\n       *  @param __k2  Iterator referencing end of range to insert.\n       *  @return  Reference to this string.\n       *  @throw  std::length_error  If new length exceeds @c max_size().\n       *\n       *  Removes the characters in the range [__i1,__i2).  In place,\n       *  characters in the range [__k1,__k2) are inserted.  If the\n       *  length of result exceeds max_size(), length_error is thrown.\n       *  The value of the string doesn't change if an error is\n       *  thrown.\n      */\n      template<class _InputIterator>\n        basic_string&\n        replace(iterator __i1, iterator __i2,\n\t\t_InputIterator __k1, _InputIterator __k2)\n        {\n\t  _GLIBCXX_DEBUG_PEDASSERT(_M_ibegin() <= __i1 && __i1 <= __i2\n\t\t\t\t   && __i2 <= _M_iend());\n\t  __glibcxx_requires_valid_range(__k1, __k2);\n\t  typedef typename std::__is_integer<_InputIterator>::__type _Integral;\n\t  return _M_replace_dispatch(__i1, __i2, __k1, __k2, _Integral());\n\t}\n\n      // Specializations for the common case of pointer and iterator:\n      // useful to avoid the overhead of temporary buffering in _M_replace.\n      basic_string&\n      replace(iterator __i1, iterator __i2, _CharT* __k1, _CharT* __k2)\n      {\n\t_GLIBCXX_DEBUG_PEDASSERT(_M_ibegin() <= __i1 && __i1 <= __i2\n\t\t\t\t && __i2 <= _M_iend());\n\t__glibcxx_requires_valid_range(__k1, __k2);\n\treturn this->replace(__i1 - _M_ibegin(), __i2 - __i1,\n\t\t\t     __k1, __k2 - __k1);\n      }\n\n      basic_string&\n      replace(iterator __i1, iterator __i2,\n\t      const _CharT* __k1, const _CharT* __k2)\n      {\n\t_GLIBCXX_DEBUG_PEDASSERT(_M_ibegin() <= __i1 && __i1 <= __i2\n\t\t\t\t && __i2 <= _M_iend());\n\t__glibcxx_requires_valid_range(__k1, __k2);\n\treturn this->replace(__i1 - _M_ibegin(), __i2 - __i1,\n\t\t\t     __k1, __k2 - __k1);\n      }\n\n      basic_string&\n      replace(iterator __i1, iterator __i2, iterator __k1, iterator __k2)\n      {\n\t_GLIBCXX_DEBUG_PEDASSERT(_M_ibegin() <= __i1 && __i1 <= __i2\n\t\t\t\t && __i2 <= _M_iend());\n\t__glibcxx_requires_valid_range(__k1, __k2);\n\treturn this->replace(__i1 - _M_ibegin(), __i2 - __i1,\n\t\t\t     __k1.base(), __k2 - __k1);\n      }\n\n      basic_string&\n      replace(iterator __i1, iterator __i2,\n\t      const_iterator __k1, const_iterator __k2)\n      {\n\t_GLIBCXX_DEBUG_PEDASSERT(_M_ibegin() <= __i1 && __i1 <= __i2\n\t\t\t\t && __i2 <= _M_iend());\n\t__glibcxx_requires_valid_range(__k1, __k2);\n\treturn this->replace(__i1 - _M_ibegin(), __i2 - __i1,\n\t\t\t     __k1.base(), __k2 - __k1);\n      }\n\n#if __cplusplus >= 201103L\n      /**\n       *  @brief  Replace range of characters with initializer_list.\n       *  @param __i1  Iterator referencing start of range to replace.\n       *  @param __i2  Iterator referencing end of range to replace.\n       *  @param __l  The initializer_list of characters to insert.\n       *  @return  Reference to this string.\n       *  @throw  std::length_error  If new length exceeds @c max_size().\n       *\n       *  Removes the characters in the range [__i1,__i2).  In place,\n       *  characters in the range [__k1,__k2) are inserted.  If the\n       *  length of result exceeds max_size(), length_error is thrown.\n       *  The value of the string doesn't change if an error is\n       *  thrown.\n      */\n      basic_string& replace(iterator __i1, iterator __i2,\n\t\t\t    initializer_list<_CharT> __l)\n      { return this->replace(__i1, __i2, __l.begin(), __l.end()); }\n#endif // C++11\n\n#if __cplusplus > 201402L\n      /**\n       *  @brief  Replace range of characters with string_view.\n       *  @param __pos  The position to replace at.\n       *  @param __n    The number of characters to replace.\n       *  @param __svt  The object convertible to string_view to insert.\n       *  @return  Reference to this string.\n      */\n      template<typename _Tp>\n\t_If_sv<_Tp, basic_string&>\n\treplace(size_type __pos, size_type __n, const _Tp& __svt)\n\t{\n\t  __sv_type __sv = __svt;\n\t  return this->replace(__pos, __n, __sv.data(), __sv.size());\n\t}\n\n      /**\n       *  @brief  Replace range of characters with string_view.\n       *  @param __pos1  The position to replace at.\n       *  @param __n1    The number of characters to replace.\n       *  @param __svt   The object convertible to string_view to insert from.\n       *  @param __pos2  The position in the string_view to insert from.\n       *  @param __n2    The number of characters to insert.\n       *  @return  Reference to this string.\n      */\n      template<typename _Tp>\n        _If_sv<_Tp, basic_string&>\n        replace(size_type __pos1, size_type __n1, const _Tp& __svt,\n\t\tsize_type __pos2, size_type __n2 = npos)\n\t{\n\t  __sv_type __sv = __svt;\n\t  return this->replace(__pos1, __n1,\n\t      __sv.data() + __sv._M_check(__pos2, \"basic_string::replace\"),\n\t      __sv._M_limit(__pos2, __n2));\n\t}\n\n      /**\n       *  @brief  Replace range of characters with string_view.\n       *  @param __i1    An iterator referencing the start position\n          to replace at.\n       *  @param __i2    An iterator referencing the end position\n          for the replace.\n       *  @param __svt   The object convertible to string_view to insert from.\n       *  @return  Reference to this string.\n      */\n      template<typename _Tp>\n\t_If_sv<_Tp, basic_string&>\n\treplace(const_iterator __i1, const_iterator __i2, const _Tp& __svt)\n\t{\n\t  __sv_type __sv = __svt;\n\t  return this->replace(__i1 - begin(), __i2 - __i1, __sv);\n\t}\n#endif // C++17\n\n    private:\n      template<class _Integer>\n\tbasic_string&\n\t_M_replace_dispatch(iterator __i1, iterator __i2, _Integer __n,\n\t\t\t    _Integer __val, __true_type)\n        { return _M_replace_aux(__i1 - _M_ibegin(), __i2 - __i1, __n, __val); }\n\n      template<class _InputIterator>\n\tbasic_string&\n\t_M_replace_dispatch(iterator __i1, iterator __i2, _InputIterator __k1,\n\t\t\t    _InputIterator __k2, __false_type);\n\n      basic_string&\n      _M_replace_aux(size_type __pos1, size_type __n1, size_type __n2,\n\t\t     _CharT __c);\n\n      basic_string&\n      _M_replace_safe(size_type __pos1, size_type __n1, const _CharT* __s,\n\t\t      size_type __n2);\n\n      // _S_construct_aux is used to implement the 21.3.1 para 15 which\n      // requires special behaviour if _InIter is an integral type\n      template<class _InIterator>\n        static _CharT*\n        _S_construct_aux(_InIterator __beg, _InIterator __end,\n\t\t\t const _Alloc& __a, __false_type)\n\t{\n          typedef typename iterator_traits<_InIterator>::iterator_category _Tag;\n          return _S_construct(__beg, __end, __a, _Tag());\n\t}\n\n      // _GLIBCXX_RESOLVE_LIB_DEFECTS\n      // 438. Ambiguity in the \"do the right thing\" clause\n      template<class _Integer>\n        static _CharT*\n        _S_construct_aux(_Integer __beg, _Integer __end,\n\t\t\t const _Alloc& __a, __true_type)\n        { return _S_construct_aux_2(static_cast<size_type>(__beg),\n\t\t\t\t    __end, __a); }\n\n      static _CharT*\n      _S_construct_aux_2(size_type __req, _CharT __c, const _Alloc& __a)\n      { return _S_construct(__req, __c, __a); }\n\n      template<class _InIterator>\n        static _CharT*\n        _S_construct(_InIterator __beg, _InIterator __end, const _Alloc& __a)\n\t{\n\t  typedef typename std::__is_integer<_InIterator>::__type _Integral;\n\t  return _S_construct_aux(__beg, __end, __a, _Integral());\n        }\n\n      // For Input Iterators, used in istreambuf_iterators, etc.\n      template<class _InIterator>\n        static _CharT*\n         _S_construct(_InIterator __beg, _InIterator __end, const _Alloc& __a,\n\t\t      input_iterator_tag);\n\n      // For forward_iterators up to random_access_iterators, used for\n      // string::iterator, _CharT*, etc.\n      template<class _FwdIterator>\n        static _CharT*\n        _S_construct(_FwdIterator __beg, _FwdIterator __end, const _Alloc& __a,\n\t\t     forward_iterator_tag);\n\n      static _CharT*\n      _S_construct(size_type __req, _CharT __c, const _Alloc& __a);\n\n    public:\n\n      /**\n       *  @brief  Copy substring into C string.\n       *  @param __s  C string to copy value into.\n       *  @param __n  Number of characters to copy.\n       *  @param __pos  Index of first character to copy.\n       *  @return  Number of characters actually copied\n       *  @throw  std::out_of_range  If __pos > size().\n       *\n       *  Copies up to @a __n characters starting at @a __pos into the\n       *  C string @a __s.  If @a __pos is %greater than size(),\n       *  out_of_range is thrown.\n      */\n      size_type\n      copy(_CharT* __s, size_type __n, size_type __pos = 0) const;\n\n      /**\n       *  @brief  Swap contents with another string.\n       *  @param __s  String to swap with.\n       *\n       *  Exchanges the contents of this string with that of @a __s in constant\n       *  time.\n      */\n      // PR 58265, this should be noexcept.\n      void\n      swap(basic_string& __s);\n\n      // String operations:\n      /**\n       *  @brief  Return const pointer to null-terminated contents.\n       *\n       *  This is a handle to internal data.  Do not modify or dire things may\n       *  happen.\n      */\n      const _CharT*\n      c_str() const _GLIBCXX_NOEXCEPT\n      { return _M_data(); }\n\n      /**\n       *  @brief  Return const pointer to contents.\n       *\n       *  This is a pointer to internal data.  It is undefined to modify\n       *  the contents through the returned pointer. To get a pointer that\n       *  allows modifying the contents use @c &str[0] instead,\n       *  (or in C++17 the non-const @c str.data() overload).\n      */\n      const _CharT*\n      data() const _GLIBCXX_NOEXCEPT\n      { return _M_data(); }\n\n#if __cplusplus > 201402L\n      /**\n       *  @brief  Return non-const pointer to contents.\n       *\n       *  This is a pointer to the character sequence held by the string.\n       *  Modifying the characters in the sequence is allowed.\n      */\n      _CharT*\n      data() noexcept\n      {\n\t_M_leak();\n\treturn _M_data();\n      }\n#endif\n\n      /**\n       *  @brief  Return copy of allocator used to construct this string.\n      */\n      allocator_type\n      get_allocator() const _GLIBCXX_NOEXCEPT\n      { return _M_dataplus; }\n\n      /**\n       *  @brief  Find position of a C substring.\n       *  @param __s  C string to locate.\n       *  @param __pos  Index of character to search from.\n       *  @param __n  Number of characters from @a s to search for.\n       *  @return  Index of start of first occurrence.\n       *\n       *  Starting from @a __pos, searches forward for the first @a\n       *  __n characters in @a __s within this string.  If found,\n       *  returns the index where it begins.  If not found, returns\n       *  npos.\n      */\n      size_type\n      find(const _CharT* __s, size_type __pos, size_type __n) const\n      _GLIBCXX_NOEXCEPT;\n\n      /**\n       *  @brief  Find position of a string.\n       *  @param __str  String to locate.\n       *  @param __pos  Index of character to search from (default 0).\n       *  @return  Index of start of first occurrence.\n       *\n       *  Starting from @a __pos, searches forward for value of @a __str within\n       *  this string.  If found, returns the index where it begins.  If not\n       *  found, returns npos.\n      */\n      size_type\n      find(const basic_string& __str, size_type __pos = 0) const\n      _GLIBCXX_NOEXCEPT\n      { return this->find(__str.data(), __pos, __str.size()); }\n\n      /**\n       *  @brief  Find position of a C string.\n       *  @param __s  C string to locate.\n       *  @param __pos  Index of character to search from (default 0).\n       *  @return  Index of start of first occurrence.\n       *\n       *  Starting from @a __pos, searches forward for the value of @a\n       *  __s within this string.  If found, returns the index where\n       *  it begins.  If not found, returns npos.\n      */\n      size_type\n      find(const _CharT* __s, size_type __pos = 0) const _GLIBCXX_NOEXCEPT\n      {\n\t__glibcxx_requires_string(__s);\n\treturn this->find(__s, __pos, traits_type::length(__s));\n      }\n\n      /**\n       *  @brief  Find position of a character.\n       *  @param __c  Character to locate.\n       *  @param __pos  Index of character to search from (default 0).\n       *  @return  Index of first occurrence.\n       *\n       *  Starting from @a __pos, searches forward for @a __c within\n       *  this string.  If found, returns the index where it was\n       *  found.  If not found, returns npos.\n      */\n      size_type\n      find(_CharT __c, size_type __pos = 0) const _GLIBCXX_NOEXCEPT;\n\n#if __cplusplus > 201402L\n      /**\n       *  @brief  Find position of a string_view.\n       *  @param __svt  The object convertible to string_view to locate.\n       *  @param __pos  Index of character to search from (default 0).\n       *  @return  Index of start of first occurrence.\n      */\n      template<typename _Tp>\n\t_If_sv<_Tp, size_type>\n\tfind(const _Tp& __svt, size_type __pos = 0) const\n\tnoexcept(is_same<_Tp, __sv_type>::value)\n\t{\n\t  __sv_type __sv = __svt;\n\t  return this->find(__sv.data(), __pos, __sv.size());\n\t}\n#endif // C++17\n\n      /**\n       *  @brief  Find last position of a string.\n       *  @param __str  String to locate.\n       *  @param __pos  Index of character to search back from (default end).\n       *  @return  Index of start of last occurrence.\n       *\n       *  Starting from @a __pos, searches backward for value of @a\n       *  __str within this string.  If found, returns the index where\n       *  it begins.  If not found, returns npos.\n      */\n      size_type\n      rfind(const basic_string& __str, size_type __pos = npos) const\n      _GLIBCXX_NOEXCEPT\n      { return this->rfind(__str.data(), __pos, __str.size()); }\n\n      /**\n       *  @brief  Find last position of a C substring.\n       *  @param __s  C string to locate.\n       *  @param __pos  Index of character to search back from.\n       *  @param __n  Number of characters from s to search for.\n       *  @return  Index of start of last occurrence.\n       *\n       *  Starting from @a __pos, searches backward for the first @a\n       *  __n characters in @a __s within this string.  If found,\n       *  returns the index where it begins.  If not found, returns\n       *  npos.\n      */\n      size_type\n      rfind(const _CharT* __s, size_type __pos, size_type __n) const\n      _GLIBCXX_NOEXCEPT;\n\n      /**\n       *  @brief  Find last position of a C string.\n       *  @param __s  C string to locate.\n       *  @param __pos  Index of character to start search at (default end).\n       *  @return  Index of start of  last occurrence.\n       *\n       *  Starting from @a __pos, searches backward for the value of\n       *  @a __s within this string.  If found, returns the index\n       *  where it begins.  If not found, returns npos.\n      */\n      size_type\n      rfind(const _CharT* __s, size_type __pos = npos) const _GLIBCXX_NOEXCEPT\n      {\n\t__glibcxx_requires_string(__s);\n\treturn this->rfind(__s, __pos, traits_type::length(__s));\n      }\n\n      /**\n       *  @brief  Find last position of a character.\n       *  @param __c  Character to locate.\n       *  @param __pos  Index of character to search back from (default end).\n       *  @return  Index of last occurrence.\n       *\n       *  Starting from @a __pos, searches backward for @a __c within\n       *  this string.  If found, returns the index where it was\n       *  found.  If not found, returns npos.\n      */\n      size_type\n      rfind(_CharT __c, size_type __pos = npos) const _GLIBCXX_NOEXCEPT;\n\n#if __cplusplus > 201402L\n      /**\n       *  @brief  Find last position of a string_view.\n       *  @param __svt  The object convertible to string_view to locate.\n       *  @param __pos  Index of character to search back from (default end).\n       *  @return  Index of start of last occurrence.\n      */\n      template<typename _Tp>\n\t_If_sv<_Tp, size_type>\n\trfind(const _Tp& __svt, size_type __pos = npos) const\n\tnoexcept(is_same<_Tp, __sv_type>::value)\n\t{\n\t  __sv_type __sv = __svt;\n\t  return this->rfind(__sv.data(), __pos, __sv.size());\n\t}\n#endif // C++17\n\n      /**\n       *  @brief  Find position of a character of string.\n       *  @param __str  String containing characters to locate.\n       *  @param __pos  Index of character to search from (default 0).\n       *  @return  Index of first occurrence.\n       *\n       *  Starting from @a __pos, searches forward for one of the\n       *  characters of @a __str within this string.  If found,\n       *  returns the index where it was found.  If not found, returns\n       *  npos.\n      */\n      size_type\n      find_first_of(const basic_string& __str, size_type __pos = 0) const\n      _GLIBCXX_NOEXCEPT\n      { return this->find_first_of(__str.data(), __pos, __str.size()); }\n\n      /**\n       *  @brief  Find position of a character of C substring.\n       *  @param __s  String containing characters to locate.\n       *  @param __pos  Index of character to search from.\n       *  @param __n  Number of characters from s to search for.\n       *  @return  Index of first occurrence.\n       *\n       *  Starting from @a __pos, searches forward for one of the\n       *  first @a __n characters of @a __s within this string.  If\n       *  found, returns the index where it was found.  If not found,\n       *  returns npos.\n      */\n      size_type\n      find_first_of(const _CharT* __s, size_type __pos, size_type __n) const\n      _GLIBCXX_NOEXCEPT;\n\n      /**\n       *  @brief  Find position of a character of C string.\n       *  @param __s  String containing characters to locate.\n       *  @param __pos  Index of character to search from (default 0).\n       *  @return  Index of first occurrence.\n       *\n       *  Starting from @a __pos, searches forward for one of the\n       *  characters of @a __s within this string.  If found, returns\n       *  the index where it was found.  If not found, returns npos.\n      */\n      size_type\n      find_first_of(const _CharT* __s, size_type __pos = 0) const\n      _GLIBCXX_NOEXCEPT\n      {\n\t__glibcxx_requires_string(__s);\n\treturn this->find_first_of(__s, __pos, traits_type::length(__s));\n      }\n\n      /**\n       *  @brief  Find position of a character.\n       *  @param __c  Character to locate.\n       *  @param __pos  Index of character to search from (default 0).\n       *  @return  Index of first occurrence.\n       *\n       *  Starting from @a __pos, searches forward for the character\n       *  @a __c within this string.  If found, returns the index\n       *  where it was found.  If not found, returns npos.\n       *\n       *  Note: equivalent to find(__c, __pos).\n      */\n      size_type\n      find_first_of(_CharT __c, size_type __pos = 0) const _GLIBCXX_NOEXCEPT\n      { return this->find(__c, __pos); }\n\n#if __cplusplus > 201402L\n      /**\n       *  @brief  Find position of a character of a string_view.\n       *  @param __svt  An object convertible to string_view containing\n       *                characters to locate.\n       *  @param __pos  Index of character to search from (default 0).\n       *  @return  Index of first occurrence.\n      */\n      template<typename _Tp>\n\t_If_sv<_Tp, size_type>\n\tfind_first_of(const _Tp& __svt, size_type __pos = 0) const\n\tnoexcept(is_same<_Tp, __sv_type>::value)\n\t{\n\t  __sv_type __sv = __svt;\n\t  return this->find_first_of(__sv.data(), __pos, __sv.size());\n\t}\n#endif // C++17\n\n      /**\n       *  @brief  Find last position of a character of string.\n       *  @param __str  String containing characters to locate.\n       *  @param __pos  Index of character to search back from (default end).\n       *  @return  Index of last occurrence.\n       *\n       *  Starting from @a __pos, searches backward for one of the\n       *  characters of @a __str within this string.  If found,\n       *  returns the index where it was found.  If not found, returns\n       *  npos.\n      */\n      size_type\n      find_last_of(const basic_string& __str, size_type __pos = npos) const\n      _GLIBCXX_NOEXCEPT\n      { return this->find_last_of(__str.data(), __pos, __str.size()); }\n\n      /**\n       *  @brief  Find last position of a character of C substring.\n       *  @param __s  C string containing characters to locate.\n       *  @param __pos  Index of character to search back from.\n       *  @param __n  Number of characters from s to search for.\n       *  @return  Index of last occurrence.\n       *\n       *  Starting from @a __pos, searches backward for one of the\n       *  first @a __n characters of @a __s within this string.  If\n       *  found, returns the index where it was found.  If not found,\n       *  returns npos.\n      */\n      size_type\n      find_last_of(const _CharT* __s, size_type __pos, size_type __n) const\n      _GLIBCXX_NOEXCEPT;\n\n      /**\n       *  @brief  Find last position of a character of C string.\n       *  @param __s  C string containing characters to locate.\n       *  @param __pos  Index of character to search back from (default end).\n       *  @return  Index of last occurrence.\n       *\n       *  Starting from @a __pos, searches backward for one of the\n       *  characters of @a __s within this string.  If found, returns\n       *  the index where it was found.  If not found, returns npos.\n      */\n      size_type\n      find_last_of(const _CharT* __s, size_type __pos = npos) const\n      _GLIBCXX_NOEXCEPT\n      {\n\t__glibcxx_requires_string(__s);\n\treturn this->find_last_of(__s, __pos, traits_type::length(__s));\n      }\n\n      /**\n       *  @brief  Find last position of a character.\n       *  @param __c  Character to locate.\n       *  @param __pos  Index of character to search back from (default end).\n       *  @return  Index of last occurrence.\n       *\n       *  Starting from @a __pos, searches backward for @a __c within\n       *  this string.  If found, returns the index where it was\n       *  found.  If not found, returns npos.\n       *\n       *  Note: equivalent to rfind(__c, __pos).\n      */\n      size_type\n      find_last_of(_CharT __c, size_type __pos = npos) const _GLIBCXX_NOEXCEPT\n      { return this->rfind(__c, __pos); }\n\n#if __cplusplus > 201402L\n      /**\n       *  @brief  Find last position of a character of string.\n       *  @param __svt  An object convertible to string_view containing\n       *                characters to locate.\n       *  @param __pos  Index of character to search back from (default end).\n       *  @return  Index of last occurrence.\n      */\n      template<typename _Tp>\n\t_If_sv<_Tp, size_type>\n\tfind_last_of(const _Tp& __svt, size_type __pos = npos) const\n\tnoexcept(is_same<_Tp, __sv_type>::value)\n\t{\n\t  __sv_type __sv = __svt;\n\t  return this->find_last_of(__sv.data(), __pos, __sv.size());\n\t}\n#endif // C++17\n\n      /**\n       *  @brief  Find position of a character not in string.\n       *  @param __str  String containing characters to avoid.\n       *  @param __pos  Index of character to search from (default 0).\n       *  @return  Index of first occurrence.\n       *\n       *  Starting from @a __pos, searches forward for a character not contained\n       *  in @a __str within this string.  If found, returns the index where it\n       *  was found.  If not found, returns npos.\n      */\n      size_type\n      find_first_not_of(const basic_string& __str, size_type __pos = 0) const\n      _GLIBCXX_NOEXCEPT\n      { return this->find_first_not_of(__str.data(), __pos, __str.size()); }\n\n      /**\n       *  @brief  Find position of a character not in C substring.\n       *  @param __s  C string containing characters to avoid.\n       *  @param __pos  Index of character to search from.\n       *  @param __n  Number of characters from __s to consider.\n       *  @return  Index of first occurrence.\n       *\n       *  Starting from @a __pos, searches forward for a character not\n       *  contained in the first @a __n characters of @a __s within\n       *  this string.  If found, returns the index where it was\n       *  found.  If not found, returns npos.\n      */\n      size_type\n      find_first_not_of(const _CharT* __s, size_type __pos,\n\t\t\tsize_type __n) const _GLIBCXX_NOEXCEPT;\n\n      /**\n       *  @brief  Find position of a character not in C string.\n       *  @param __s  C string containing characters to avoid.\n       *  @param __pos  Index of character to search from (default 0).\n       *  @return  Index of first occurrence.\n       *\n       *  Starting from @a __pos, searches forward for a character not\n       *  contained in @a __s within this string.  If found, returns\n       *  the index where it was found.  If not found, returns npos.\n      */\n      size_type\n      find_first_not_of(const _CharT* __s, size_type __pos = 0) const\n      _GLIBCXX_NOEXCEPT\n      {\n\t__glibcxx_requires_string(__s);\n\treturn this->find_first_not_of(__s, __pos, traits_type::length(__s));\n      }\n\n      /**\n       *  @brief  Find position of a different character.\n       *  @param __c  Character to avoid.\n       *  @param __pos  Index of character to search from (default 0).\n       *  @return  Index of first occurrence.\n       *\n       *  Starting from @a __pos, searches forward for a character\n       *  other than @a __c within this string.  If found, returns the\n       *  index where it was found.  If not found, returns npos.\n      */\n      size_type\n      find_first_not_of(_CharT __c, size_type __pos = 0) const\n      _GLIBCXX_NOEXCEPT;\n\n#if __cplusplus > 201402L\n      /**\n       *  @brief  Find position of a character not in a string_view.\n       *  @param __svt  An object convertible to string_view containing\n       *                characters to avoid.\n       *  @param __pos  Index of character to search from (default 0).\n       *  @return  Index of first occurrence.\n       */\n      template<typename _Tp>\n\t_If_sv<_Tp, size_type>\n\tfind_first_not_of(const _Tp& __svt, size_type __pos = 0) const\n\tnoexcept(is_same<_Tp, __sv_type>::value)\n\t{\n\t  __sv_type __sv = __svt;\n\t  return this->find_first_not_of(__sv.data(), __pos, __sv.size());\n\t}\n#endif // C++17\n\n      /**\n       *  @brief  Find last position of a character not in string.\n       *  @param __str  String containing characters to avoid.\n       *  @param __pos  Index of character to search back from (default end).\n       *  @return  Index of last occurrence.\n       *\n       *  Starting from @a __pos, searches backward for a character\n       *  not contained in @a __str within this string.  If found,\n       *  returns the index where it was found.  If not found, returns\n       *  npos.\n      */\n      size_type\n      find_last_not_of(const basic_string& __str, size_type __pos = npos) const\n      _GLIBCXX_NOEXCEPT\n      { return this->find_last_not_of(__str.data(), __pos, __str.size()); }\n\n      /**\n       *  @brief  Find last position of a character not in C substring.\n       *  @param __s  C string containing characters to avoid.\n       *  @param __pos  Index of character to search back from.\n       *  @param __n  Number of characters from s to consider.\n       *  @return  Index of last occurrence.\n       *\n       *  Starting from @a __pos, searches backward for a character not\n       *  contained in the first @a __n characters of @a __s within this string.\n       *  If found, returns the index where it was found.  If not found,\n       *  returns npos.\n      */\n      size_type\n      find_last_not_of(const _CharT* __s, size_type __pos,\n\t\t       size_type __n) const _GLIBCXX_NOEXCEPT;\n      /**\n       *  @brief  Find last position of a character not in C string.\n       *  @param __s  C string containing characters to avoid.\n       *  @param __pos  Index of character to search back from (default end).\n       *  @return  Index of last occurrence.\n       *\n       *  Starting from @a __pos, searches backward for a character\n       *  not contained in @a __s within this string.  If found,\n       *  returns the index where it was found.  If not found, returns\n       *  npos.\n      */\n      size_type\n      find_last_not_of(const _CharT* __s, size_type __pos = npos) const\n      _GLIBCXX_NOEXCEPT\n      {\n\t__glibcxx_requires_string(__s);\n\treturn this->find_last_not_of(__s, __pos, traits_type::length(__s));\n      }\n\n      /**\n       *  @brief  Find last position of a different character.\n       *  @param __c  Character to avoid.\n       *  @param __pos  Index of character to search back from (default end).\n       *  @return  Index of last occurrence.\n       *\n       *  Starting from @a __pos, searches backward for a character other than\n       *  @a __c within this string.  If found, returns the index where it was\n       *  found.  If not found, returns npos.\n      */\n      size_type\n      find_last_not_of(_CharT __c, size_type __pos = npos) const\n      _GLIBCXX_NOEXCEPT;\n\n#if __cplusplus > 201402L\n      /**\n       *  @brief  Find last position of a character not in a string_view.\n       *  @param __svt  An object convertible to string_view containing\n       *                characters to avoid.\n       *  @param __pos  Index of character to search back from (default end).\n       *  @return  Index of last occurrence.\n       */\n      template<typename _Tp>\n\t_If_sv<_Tp, size_type>\n\tfind_last_not_of(const _Tp& __svt, size_type __pos = npos) const\n\tnoexcept(is_same<_Tp, __sv_type>::value)\n\t{\n\t  __sv_type __sv = __svt;\n\t  return this->find_last_not_of(__sv.data(), __pos, __sv.size());\n\t}\n#endif // C++17\n\n      /**\n       *  @brief  Get a substring.\n       *  @param __pos  Index of first character (default 0).\n       *  @param __n  Number of characters in substring (default remainder).\n       *  @return  The new string.\n       *  @throw  std::out_of_range  If __pos > size().\n       *\n       *  Construct and return a new string using the @a __n\n       *  characters starting at @a __pos.  If the string is too\n       *  short, use the remainder of the characters.  If @a __pos is\n       *  beyond the end of the string, out_of_range is thrown.\n      */\n      basic_string\n      substr(size_type __pos = 0, size_type __n = npos) const\n      { return basic_string(*this,\n\t\t\t    _M_check(__pos, \"basic_string::substr\"), __n); }\n\n      /**\n       *  @brief  Compare to a string.\n       *  @param __str  String to compare against.\n       *  @return  Integer < 0, 0, or > 0.\n       *\n       *  Returns an integer < 0 if this string is ordered before @a\n       *  __str, 0 if their values are equivalent, or > 0 if this\n       *  string is ordered after @a __str.  Determines the effective\n       *  length rlen of the strings to compare as the smallest of\n       *  size() and str.size().  The function then compares the two\n       *  strings by calling traits::compare(data(), str.data(),rlen).\n       *  If the result of the comparison is nonzero returns it,\n       *  otherwise the shorter one is ordered first.\n      */\n      int\n      compare(const basic_string& __str) const\n      {\n\tconst size_type __size = this->size();\n\tconst size_type __osize = __str.size();\n\tconst size_type __len = std::min(__size, __osize);\n\n\tint __r = traits_type::compare(_M_data(), __str.data(), __len);\n\tif (!__r)\n\t  __r = _S_compare(__size, __osize);\n\treturn __r;\n      }\n\n#if __cplusplus > 201402L\n      /**\n       *  @brief  Compare to a string_view.\n       *  @param __svt An object convertible to string_view to compare against.\n       *  @return  Integer < 0, 0, or > 0.\n       */\n      template<typename _Tp>\n\t_If_sv<_Tp, int>\n\tcompare(const _Tp& __svt) const\n\tnoexcept(is_same<_Tp, __sv_type>::value)\n\t{\n\t   __sv_type __sv = __svt;\n\t  const size_type __size = this->size();\n\t  const size_type __osize = __sv.size();\n\t  const size_type __len = std::min(__size, __osize);\n\n\t  int __r = traits_type::compare(_M_data(), __sv.data(), __len);\n\t  if (!__r)\n\t    __r = _S_compare(__size, __osize);\n\t  return __r;\n\t}\n\n      /**\n       *  @brief  Compare to a string_view.\n       *  @param __pos  A position in the string to start comparing from.\n       *  @param __n  The number of characters to compare.\n       *  @param __svt  An object convertible to string_view to compare\n       *                against.\n       *  @return  Integer < 0, 0, or > 0.\n       */\n      template<typename _Tp>\n\t_If_sv<_Tp, int>\n\tcompare(size_type __pos, size_type __n, const _Tp& __svt) const\n\tnoexcept(is_same<_Tp, __sv_type>::value)\n\t{\n\t  __sv_type __sv = __svt;\n\t  return __sv_type(*this).substr(__pos, __n).compare(__sv);\n\t}\n\n      /**\n       *  @brief  Compare to a string_view.\n       *  @param __pos1  A position in the string to start comparing from.\n       *  @param __n1  The number of characters to compare.\n       *  @param __svt   An object convertible to string_view to compare\n       *                 against.\n       *  @param __pos2  A position in the string_view to start comparing from.\n       *  @param __n2  The number of characters to compare.\n       *  @return  Integer < 0, 0, or > 0.\n       */\n      template<typename _Tp>\n\t_If_sv<_Tp, int>\n\tcompare(size_type __pos1, size_type __n1, const _Tp& __svt,\n\t\tsize_type __pos2, size_type __n2 = npos) const\n\tnoexcept(is_same<_Tp, __sv_type>::value)\n\t{\n\t  __sv_type __sv = __svt;\n\t  return __sv_type(*this)\n\t    .substr(__pos1, __n1).compare(__sv.substr(__pos2, __n2));\n\t}\n#endif // C++17\n\n      /**\n       *  @brief  Compare substring to a string.\n       *  @param __pos  Index of first character of substring.\n       *  @param __n  Number of characters in substring.\n       *  @param __str  String to compare against.\n       *  @return  Integer < 0, 0, or > 0.\n       *\n       *  Form the substring of this string from the @a __n characters\n       *  starting at @a __pos.  Returns an integer < 0 if the\n       *  substring is ordered before @a __str, 0 if their values are\n       *  equivalent, or > 0 if the substring is ordered after @a\n       *  __str.  Determines the effective length rlen of the strings\n       *  to compare as the smallest of the length of the substring\n       *  and @a __str.size().  The function then compares the two\n       *  strings by calling\n       *  traits::compare(substring.data(),str.data(),rlen).  If the\n       *  result of the comparison is nonzero returns it, otherwise\n       *  the shorter one is ordered first.\n      */\n      int\n      compare(size_type __pos, size_type __n, const basic_string& __str) const;\n\n      /**\n       *  @brief  Compare substring to a substring.\n       *  @param __pos1  Index of first character of substring.\n       *  @param __n1  Number of characters in substring.\n       *  @param __str  String to compare against.\n       *  @param __pos2  Index of first character of substring of str.\n       *  @param __n2  Number of characters in substring of str.\n       *  @return  Integer < 0, 0, or > 0.\n       *\n       *  Form the substring of this string from the @a __n1\n       *  characters starting at @a __pos1.  Form the substring of @a\n       *  __str from the @a __n2 characters starting at @a __pos2.\n       *  Returns an integer < 0 if this substring is ordered before\n       *  the substring of @a __str, 0 if their values are equivalent,\n       *  or > 0 if this substring is ordered after the substring of\n       *  @a __str.  Determines the effective length rlen of the\n       *  strings to compare as the smallest of the lengths of the\n       *  substrings.  The function then compares the two strings by\n       *  calling\n       *  traits::compare(substring.data(),str.substr(pos2,n2).data(),rlen).\n       *  If the result of the comparison is nonzero returns it,\n       *  otherwise the shorter one is ordered first.\n      */\n      int\n      compare(size_type __pos1, size_type __n1, const basic_string& __str,\n\t      size_type __pos2, size_type __n2 = npos) const;\n\n      /**\n       *  @brief  Compare to a C string.\n       *  @param __s  C string to compare against.\n       *  @return  Integer < 0, 0, or > 0.\n       *\n       *  Returns an integer < 0 if this string is ordered before @a __s, 0 if\n       *  their values are equivalent, or > 0 if this string is ordered after\n       *  @a __s.  Determines the effective length rlen of the strings to\n       *  compare as the smallest of size() and the length of a string\n       *  constructed from @a __s.  The function then compares the two strings\n       *  by calling traits::compare(data(),s,rlen).  If the result of the\n       *  comparison is nonzero returns it, otherwise the shorter one is\n       *  ordered first.\n      */\n      int\n      compare(const _CharT* __s) const _GLIBCXX_NOEXCEPT;\n\n      // _GLIBCXX_RESOLVE_LIB_DEFECTS\n      // 5 String::compare specification questionable\n      /**\n       *  @brief  Compare substring to a C string.\n       *  @param __pos  Index of first character of substring.\n       *  @param __n1  Number of characters in substring.\n       *  @param __s  C string to compare against.\n       *  @return  Integer < 0, 0, or > 0.\n       *\n       *  Form the substring of this string from the @a __n1\n       *  characters starting at @a pos.  Returns an integer < 0 if\n       *  the substring is ordered before @a __s, 0 if their values\n       *  are equivalent, or > 0 if the substring is ordered after @a\n       *  __s.  Determines the effective length rlen of the strings to\n       *  compare as the smallest of the length of the substring and\n       *  the length of a string constructed from @a __s.  The\n       *  function then compares the two string by calling\n       *  traits::compare(substring.data(),__s,rlen).  If the result of\n       *  the comparison is nonzero returns it, otherwise the shorter\n       *  one is ordered first.\n      */\n      int\n      compare(size_type __pos, size_type __n1, const _CharT* __s) const;\n\n      /**\n       *  @brief  Compare substring against a character %array.\n       *  @param __pos  Index of first character of substring.\n       *  @param __n1  Number of characters in substring.\n       *  @param __s  character %array to compare against.\n       *  @param __n2  Number of characters of s.\n       *  @return  Integer < 0, 0, or > 0.\n       *\n       *  Form the substring of this string from the @a __n1\n       *  characters starting at @a __pos.  Form a string from the\n       *  first @a __n2 characters of @a __s.  Returns an integer < 0\n       *  if this substring is ordered before the string from @a __s,\n       *  0 if their values are equivalent, or > 0 if this substring\n       *  is ordered after the string from @a __s.  Determines the\n       *  effective length rlen of the strings to compare as the\n       *  smallest of the length of the substring and @a __n2.  The\n       *  function then compares the two strings by calling\n       *  traits::compare(substring.data(),s,rlen).  If the result of\n       *  the comparison is nonzero returns it, otherwise the shorter\n       *  one is ordered first.\n       *\n       *  NB: s must have at least n2 characters, &apos;\\\\0&apos; has\n       *  no special meaning.\n      */\n      int\n      compare(size_type __pos, size_type __n1, const _CharT* __s,\n\t      size_type __n2) const;\n\n# ifdef _GLIBCXX_TM_TS_INTERNAL\n      friend void\n      ::_txnal_cow_string_C1_for_exceptions(void* that, const char* s,\n\t\t\t\t\t    void* exc);\n      friend const char*\n      ::_txnal_cow_string_c_str(const void *that);\n      friend void\n      ::_txnal_cow_string_D1(void *that);\n      friend void\n      ::_txnal_cow_string_D1_commit(void *that);\n# endif\n  };\n#endif  // !_GLIBCXX_USE_CXX11_ABI\n\n  // operator+\n  /**\n   *  @brief  Concatenate two strings.\n   *  @param __lhs  First string.\n   *  @param __rhs  Last string.\n   *  @return  New string with value of @a __lhs followed by @a __rhs.\n   */\n  template<typename _CharT, typename _Traits, typename _Alloc>\n    basic_string<_CharT, _Traits, _Alloc>\n    operator+(const basic_string<_CharT, _Traits, _Alloc>& __lhs,\n\t      const basic_string<_CharT, _Traits, _Alloc>& __rhs)\n    {\n      basic_string<_CharT, _Traits, _Alloc> __str(__lhs);\n      __str.append(__rhs);\n      return __str;\n    }\n\n  /**\n   *  @brief  Concatenate C string and string.\n   *  @param __lhs  First string.\n   *  @param __rhs  Last string.\n   *  @return  New string with value of @a __lhs followed by @a __rhs.\n   */\n  template<typename _CharT, typename _Traits, typename _Alloc>\n    basic_string<_CharT,_Traits,_Alloc>\n    operator+(const _CharT* __lhs,\n\t      const basic_string<_CharT,_Traits,_Alloc>& __rhs);\n\n  /**\n   *  @brief  Concatenate character and string.\n   *  @param __lhs  First string.\n   *  @param __rhs  Last string.\n   *  @return  New string with @a __lhs followed by @a __rhs.\n   */\n  template<typename _CharT, typename _Traits, typename _Alloc>\n    basic_string<_CharT,_Traits,_Alloc>\n    operator+(_CharT __lhs, const basic_string<_CharT,_Traits,_Alloc>& __rhs);\n\n  /**\n   *  @brief  Concatenate string and C string.\n   *  @param __lhs  First string.\n   *  @param __rhs  Last string.\n   *  @return  New string with @a __lhs followed by @a __rhs.\n   */\n  template<typename _CharT, typename _Traits, typename _Alloc>\n    inline basic_string<_CharT, _Traits, _Alloc>\n    operator+(const basic_string<_CharT, _Traits, _Alloc>& __lhs,\n\t      const _CharT* __rhs)\n    {\n      basic_string<_CharT, _Traits, _Alloc> __str(__lhs);\n      __str.append(__rhs);\n      return __str;\n    }\n\n  /**\n   *  @brief  Concatenate string and character.\n   *  @param __lhs  First string.\n   *  @param __rhs  Last string.\n   *  @return  New string with @a __lhs followed by @a __rhs.\n   */\n  template<typename _CharT, typename _Traits, typename _Alloc>\n    inline basic_string<_CharT, _Traits, _Alloc>\n    operator+(const basic_string<_CharT, _Traits, _Alloc>& __lhs, _CharT __rhs)\n    {\n      typedef basic_string<_CharT, _Traits, _Alloc>\t__string_type;\n      typedef typename __string_type::size_type\t\t__size_type;\n      __string_type __str(__lhs);\n      __str.append(__size_type(1), __rhs);\n      return __str;\n    }\n\n#if __cplusplus >= 201103L\n  template<typename _CharT, typename _Traits, typename _Alloc>\n    inline basic_string<_CharT, _Traits, _Alloc>\n    operator+(basic_string<_CharT, _Traits, _Alloc>&& __lhs,\n\t      const basic_string<_CharT, _Traits, _Alloc>& __rhs)\n    { return std::move(__lhs.append(__rhs)); }\n\n  template<typename _CharT, typename _Traits, typename _Alloc>\n    inline basic_string<_CharT, _Traits, _Alloc>\n    operator+(const basic_string<_CharT, _Traits, _Alloc>& __lhs,\n\t      basic_string<_CharT, _Traits, _Alloc>&& __rhs)\n    { return std::move(__rhs.insert(0, __lhs)); }\n\n  template<typename _CharT, typename _Traits, typename _Alloc>\n    inline basic_string<_CharT, _Traits, _Alloc>\n    operator+(basic_string<_CharT, _Traits, _Alloc>&& __lhs,\n\t      basic_string<_CharT, _Traits, _Alloc>&& __rhs)\n    {\n      const auto __size = __lhs.size() + __rhs.size();\n      const bool __cond = (__size > __lhs.capacity()\n\t\t\t   && __size <= __rhs.capacity());\n      return __cond ? std::move(__rhs.insert(0, __lhs))\n\t            : std::move(__lhs.append(__rhs));\n    }\n\n  template<typename _CharT, typename _Traits, typename _Alloc>\n    inline basic_string<_CharT, _Traits, _Alloc>\n    operator+(const _CharT* __lhs,\n\t      basic_string<_CharT, _Traits, _Alloc>&& __rhs)\n    { return std::move(__rhs.insert(0, __lhs)); }\n\n  template<typename _CharT, typename _Traits, typename _Alloc>\n    inline basic_string<_CharT, _Traits, _Alloc>\n    operator+(_CharT __lhs,\n\t      basic_string<_CharT, _Traits, _Alloc>&& __rhs)\n    { return std::move(__rhs.insert(0, 1, __lhs)); }\n\n  template<typename _CharT, typename _Traits, typename _Alloc>\n    inline basic_string<_CharT, _Traits, _Alloc>\n    operator+(basic_string<_CharT, _Traits, _Alloc>&& __lhs,\n\t      const _CharT* __rhs)\n    { return std::move(__lhs.append(__rhs)); }\n\n  template<typename _CharT, typename _Traits, typename _Alloc>\n    inline basic_string<_CharT, _Traits, _Alloc>\n    operator+(basic_string<_CharT, _Traits, _Alloc>&& __lhs,\n\t      _CharT __rhs)\n    { return std::move(__lhs.append(1, __rhs)); }\n#endif\n\n  // operator ==\n  /**\n   *  @brief  Test equivalence of two strings.\n   *  @param __lhs  First string.\n   *  @param __rhs  Second string.\n   *  @return  True if @a __lhs.compare(@a __rhs) == 0.  False otherwise.\n   */\n  template<typename _CharT, typename _Traits, typename _Alloc>\n    inline bool\n    operator==(const basic_string<_CharT, _Traits, _Alloc>& __lhs,\n\t       const basic_string<_CharT, _Traits, _Alloc>& __rhs)\n    _GLIBCXX_NOEXCEPT\n    { return __lhs.compare(__rhs) == 0; }\n\n  template<typename _CharT>\n    inline\n    typename __gnu_cxx::__enable_if<__is_char<_CharT>::__value, bool>::__type\n    operator==(const basic_string<_CharT>& __lhs,\n\t       const basic_string<_CharT>& __rhs) _GLIBCXX_NOEXCEPT\n    { return (__lhs.size() == __rhs.size()\n\t      && !std::char_traits<_CharT>::compare(__lhs.data(), __rhs.data(),\n\t\t\t\t\t\t    __lhs.size())); }\n\n  /**\n   *  @brief  Test equivalence of C string and string.\n   *  @param __lhs  C string.\n   *  @param __rhs  String.\n   *  @return  True if @a __rhs.compare(@a __lhs) == 0.  False otherwise.\n   */\n  template<typename _CharT, typename _Traits, typename _Alloc>\n    inline bool\n    operator==(const _CharT* __lhs,\n\t       const basic_string<_CharT, _Traits, _Alloc>& __rhs)\n    { return __rhs.compare(__lhs) == 0; }\n\n  /**\n   *  @brief  Test equivalence of string and C string.\n   *  @param __lhs  String.\n   *  @param __rhs  C string.\n   *  @return  True if @a __lhs.compare(@a __rhs) == 0.  False otherwise.\n   */\n  template<typename _CharT, typename _Traits, typename _Alloc>\n    inline bool\n    operator==(const basic_string<_CharT, _Traits, _Alloc>& __lhs,\n\t       const _CharT* __rhs)\n    { return __lhs.compare(__rhs) == 0; }\n\n  // operator !=\n  /**\n   *  @brief  Test difference of two strings.\n   *  @param __lhs  First string.\n   *  @param __rhs  Second string.\n   *  @return  True if @a __lhs.compare(@a __rhs) != 0.  False otherwise.\n   */\n  template<typename _CharT, typename _Traits, typename _Alloc>\n    inline bool\n    operator!=(const basic_string<_CharT, _Traits, _Alloc>& __lhs,\n\t       const basic_string<_CharT, _Traits, _Alloc>& __rhs)\n    _GLIBCXX_NOEXCEPT\n    { return !(__lhs == __rhs); }\n\n  /**\n   *  @brief  Test difference of C string and string.\n   *  @param __lhs  C string.\n   *  @param __rhs  String.\n   *  @return  True if @a __rhs.compare(@a __lhs) != 0.  False otherwise.\n   */\n  template<typename _CharT, typename _Traits, typename _Alloc>\n    inline bool\n    operator!=(const _CharT* __lhs,\n\t       const basic_string<_CharT, _Traits, _Alloc>& __rhs)\n    { return !(__lhs == __rhs); }\n\n  /**\n   *  @brief  Test difference of string and C string.\n   *  @param __lhs  String.\n   *  @param __rhs  C string.\n   *  @return  True if @a __lhs.compare(@a __rhs) != 0.  False otherwise.\n   */\n  template<typename _CharT, typename _Traits, typename _Alloc>\n    inline bool\n    operator!=(const basic_string<_CharT, _Traits, _Alloc>& __lhs,\n\t       const _CharT* __rhs)\n    { return !(__lhs == __rhs); }\n\n  // operator <\n  /**\n   *  @brief  Test if string precedes string.\n   *  @param __lhs  First string.\n   *  @param __rhs  Second string.\n   *  @return  True if @a __lhs precedes @a __rhs.  False otherwise.\n   */\n  template<typename _CharT, typename _Traits, typename _Alloc>\n    inline bool\n    operator<(const basic_string<_CharT, _Traits, _Alloc>& __lhs,\n\t      const basic_string<_CharT, _Traits, _Alloc>& __rhs)\n    _GLIBCXX_NOEXCEPT\n    { return __lhs.compare(__rhs) < 0; }\n\n  /**\n   *  @brief  Test if string precedes C string.\n   *  @param __lhs  String.\n   *  @param __rhs  C string.\n   *  @return  True if @a __lhs precedes @a __rhs.  False otherwise.\n   */\n  template<typename _CharT, typename _Traits, typename _Alloc>\n    inline bool\n    operator<(const basic_string<_CharT, _Traits, _Alloc>& __lhs,\n\t      const _CharT* __rhs)\n    { return __lhs.compare(__rhs) < 0; }\n\n  /**\n   *  @brief  Test if C string precedes string.\n   *  @param __lhs  C string.\n   *  @param __rhs  String.\n   *  @return  True if @a __lhs precedes @a __rhs.  False otherwise.\n   */\n  template<typename _CharT, typename _Traits, typename _Alloc>\n    inline bool\n    operator<(const _CharT* __lhs,\n\t      const basic_string<_CharT, _Traits, _Alloc>& __rhs)\n    { return __rhs.compare(__lhs) > 0; }\n\n  // operator >\n  /**\n   *  @brief  Test if string follows string.\n   *  @param __lhs  First string.\n   *  @param __rhs  Second string.\n   *  @return  True if @a __lhs follows @a __rhs.  False otherwise.\n   */\n  template<typename _CharT, typename _Traits, typename _Alloc>\n    inline bool\n    operator>(const basic_string<_CharT, _Traits, _Alloc>& __lhs,\n\t      const basic_string<_CharT, _Traits, _Alloc>& __rhs)\n    _GLIBCXX_NOEXCEPT\n    { return __lhs.compare(__rhs) > 0; }\n\n  /**\n   *  @brief  Test if string follows C string.\n   *  @param __lhs  String.\n   *  @param __rhs  C string.\n   *  @return  True if @a __lhs follows @a __rhs.  False otherwise.\n   */\n  template<typename _CharT, typename _Traits, typename _Alloc>\n    inline bool\n    operator>(const basic_string<_CharT, _Traits, _Alloc>& __lhs,\n\t      const _CharT* __rhs)\n    { return __lhs.compare(__rhs) > 0; }\n\n  /**\n   *  @brief  Test if C string follows string.\n   *  @param __lhs  C string.\n   *  @param __rhs  String.\n   *  @return  True if @a __lhs follows @a __rhs.  False otherwise.\n   */\n  template<typename _CharT, typename _Traits, typename _Alloc>\n    inline bool\n    operator>(const _CharT* __lhs,\n\t      const basic_string<_CharT, _Traits, _Alloc>& __rhs)\n    { return __rhs.compare(__lhs) < 0; }\n\n  // operator <=\n  /**\n   *  @brief  Test if string doesn't follow string.\n   *  @param __lhs  First string.\n   *  @param __rhs  Second string.\n   *  @return  True if @a __lhs doesn't follow @a __rhs.  False otherwise.\n   */\n  template<typename _CharT, typename _Traits, typename _Alloc>\n    inline bool\n    operator<=(const basic_string<_CharT, _Traits, _Alloc>& __lhs,\n\t       const basic_string<_CharT, _Traits, _Alloc>& __rhs)\n    _GLIBCXX_NOEXCEPT\n    { return __lhs.compare(__rhs) <= 0; }\n\n  /**\n   *  @brief  Test if string doesn't follow C string.\n   *  @param __lhs  String.\n   *  @param __rhs  C string.\n   *  @return  True if @a __lhs doesn't follow @a __rhs.  False otherwise.\n   */\n  template<typename _CharT, typename _Traits, typename _Alloc>\n    inline bool\n    operator<=(const basic_string<_CharT, _Traits, _Alloc>& __lhs,\n\t       const _CharT* __rhs)\n    { return __lhs.compare(__rhs) <= 0; }\n\n  /**\n   *  @brief  Test if C string doesn't follow string.\n   *  @param __lhs  C string.\n   *  @param __rhs  String.\n   *  @return  True if @a __lhs doesn't follow @a __rhs.  False otherwise.\n   */\n  template<typename _CharT, typename _Traits, typename _Alloc>\n    inline bool\n    operator<=(const _CharT* __lhs,\n\t       const basic_string<_CharT, _Traits, _Alloc>& __rhs)\n    { return __rhs.compare(__lhs) >= 0; }\n\n  // operator >=\n  /**\n   *  @brief  Test if string doesn't precede string.\n   *  @param __lhs  First string.\n   *  @param __rhs  Second string.\n   *  @return  True if @a __lhs doesn't precede @a __rhs.  False otherwise.\n   */\n  template<typename _CharT, typename _Traits, typename _Alloc>\n    inline bool\n    operator>=(const basic_string<_CharT, _Traits, _Alloc>& __lhs,\n\t       const basic_string<_CharT, _Traits, _Alloc>& __rhs)\n    _GLIBCXX_NOEXCEPT\n    { return __lhs.compare(__rhs) >= 0; }\n\n  /**\n   *  @brief  Test if string doesn't precede C string.\n   *  @param __lhs  String.\n   *  @param __rhs  C string.\n   *  @return  True if @a __lhs doesn't precede @a __rhs.  False otherwise.\n   */\n  template<typename _CharT, typename _Traits, typename _Alloc>\n    inline bool\n    operator>=(const basic_string<_CharT, _Traits, _Alloc>& __lhs,\n\t       const _CharT* __rhs)\n    { return __lhs.compare(__rhs) >= 0; }\n\n  /**\n   *  @brief  Test if C string doesn't precede string.\n   *  @param __lhs  C string.\n   *  @param __rhs  String.\n   *  @return  True if @a __lhs doesn't precede @a __rhs.  False otherwise.\n   */\n  template<typename _CharT, typename _Traits, typename _Alloc>\n    inline bool\n    operator>=(const _CharT* __lhs,\n\t     const basic_string<_CharT, _Traits, _Alloc>& __rhs)\n    { return __rhs.compare(__lhs) <= 0; }\n\n  /**\n   *  @brief  Swap contents of two strings.\n   *  @param __lhs  First string.\n   *  @param __rhs  Second string.\n   *\n   *  Exchanges the contents of @a __lhs and @a __rhs in constant time.\n   */\n  template<typename _CharT, typename _Traits, typename _Alloc>\n    inline void\n    swap(basic_string<_CharT, _Traits, _Alloc>& __lhs,\n\t basic_string<_CharT, _Traits, _Alloc>& __rhs)\n    _GLIBCXX_NOEXCEPT_IF(noexcept(__lhs.swap(__rhs)))\n    { __lhs.swap(__rhs); }\n\n\n  /**\n   *  @brief  Read stream into a string.\n   *  @param __is  Input stream.\n   *  @param __str  Buffer to store into.\n   *  @return  Reference to the input stream.\n   *\n   *  Stores characters from @a __is into @a __str until whitespace is\n   *  found, the end of the stream is encountered, or str.max_size()\n   *  is reached.  If is.width() is non-zero, that is the limit on the\n   *  number of characters stored into @a __str.  Any previous\n   *  contents of @a __str are erased.\n   */\n  template<typename _CharT, typename _Traits, typename _Alloc>\n    basic_istream<_CharT, _Traits>&\n    operator>>(basic_istream<_CharT, _Traits>& __is,\n\t       basic_string<_CharT, _Traits, _Alloc>& __str);\n\n  template<>\n    basic_istream<char>&\n    operator>>(basic_istream<char>& __is, basic_string<char>& __str);\n\n  /**\n   *  @brief  Write string to a stream.\n   *  @param __os  Output stream.\n   *  @param __str  String to write out.\n   *  @return  Reference to the output stream.\n   *\n   *  Output characters of @a __str into os following the same rules as for\n   *  writing a C string.\n   */\n  template<typename _CharT, typename _Traits, typename _Alloc>\n    inline basic_ostream<_CharT, _Traits>&\n    operator<<(basic_ostream<_CharT, _Traits>& __os,\n\t       const basic_string<_CharT, _Traits, _Alloc>& __str)\n    {\n      // _GLIBCXX_RESOLVE_LIB_DEFECTS\n      // 586. string inserter not a formatted function\n      return __ostream_insert(__os, __str.data(), __str.size());\n    }\n\n  /**\n   *  @brief  Read a line from stream into a string.\n   *  @param __is  Input stream.\n   *  @param __str  Buffer to store into.\n   *  @param __delim  Character marking end of line.\n   *  @return  Reference to the input stream.\n   *\n   *  Stores characters from @a __is into @a __str until @a __delim is\n   *  found, the end of the stream is encountered, or str.max_size()\n   *  is reached.  Any previous contents of @a __str are erased.  If\n   *  @a __delim is encountered, it is extracted but not stored into\n   *  @a __str.\n   */\n  template<typename _CharT, typename _Traits, typename _Alloc>\n    basic_istream<_CharT, _Traits>&\n    getline(basic_istream<_CharT, _Traits>& __is,\n\t    basic_string<_CharT, _Traits, _Alloc>& __str, _CharT __delim);\n\n  /**\n   *  @brief  Read a line from stream into a string.\n   *  @param __is  Input stream.\n   *  @param __str  Buffer to store into.\n   *  @return  Reference to the input stream.\n   *\n   *  Stores characters from is into @a __str until &apos;\\n&apos; is\n   *  found, the end of the stream is encountered, or str.max_size()\n   *  is reached.  Any previous contents of @a __str are erased.  If\n   *  end of line is encountered, it is extracted but not stored into\n   *  @a __str.\n   */\n  template<typename _CharT, typename _Traits, typename _Alloc>\n    inline basic_istream<_CharT, _Traits>&\n    getline(basic_istream<_CharT, _Traits>& __is,\n\t    basic_string<_CharT, _Traits, _Alloc>& __str)\n    { return std::getline(__is, __str, __is.widen('\\n')); }\n\n#if __cplusplus >= 201103L\n  /// Read a line from an rvalue stream into a string.\n  template<typename _CharT, typename _Traits, typename _Alloc>\n    inline basic_istream<_CharT, _Traits>&\n    getline(basic_istream<_CharT, _Traits>&& __is,\n\t    basic_string<_CharT, _Traits, _Alloc>& __str, _CharT __delim)\n    { return std::getline(__is, __str, __delim); }\n\n  /// Read a line from an rvalue stream into a string.\n  template<typename _CharT, typename _Traits, typename _Alloc>\n    inline basic_istream<_CharT, _Traits>&\n    getline(basic_istream<_CharT, _Traits>&& __is,\n\t    basic_string<_CharT, _Traits, _Alloc>& __str)\n    { return std::getline(__is, __str); }\n#endif\n\n  template<>\n    basic_istream<char>&\n    getline(basic_istream<char>& __in, basic_string<char>& __str,\n\t    char __delim);\n\n#ifdef _GLIBCXX_USE_WCHAR_T\n  template<>\n    basic_istream<wchar_t>&\n    getline(basic_istream<wchar_t>& __in, basic_string<wchar_t>& __str,\n\t    wchar_t __delim);\n#endif  \n\n_GLIBCXX_END_NAMESPACE_VERSION\n} // namespace\n\n#if __cplusplus >= 201103L\n\n#include <ext/string_conversions.h>\n\nnamespace std _GLIBCXX_VISIBILITY(default)\n{\n_GLIBCXX_BEGIN_NAMESPACE_VERSION\n_GLIBCXX_BEGIN_NAMESPACE_CXX11\n\n#if _GLIBCXX_USE_C99_STDLIB\n  // 21.4 Numeric Conversions [string.conversions].\n  inline int\n  stoi(const string& __str, size_t* __idx = 0, int __base = 10)\n  { return __gnu_cxx::__stoa<long, int>(&std::strtol, \"stoi\", __str.c_str(),\n\t\t\t\t\t__idx, __base); }\n\n  inline long\n  stol(const string& __str, size_t* __idx = 0, int __base = 10)\n  { return __gnu_cxx::__stoa(&std::strtol, \"stol\", __str.c_str(),\n\t\t\t     __idx, __base); }\n\n  inline unsigned long\n  stoul(const string& __str, size_t* __idx = 0, int __base = 10)\n  { return __gnu_cxx::__stoa(&std::strtoul, \"stoul\", __str.c_str(),\n\t\t\t     __idx, __base); }\n\n  inline long long\n  stoll(const string& __str, size_t* __idx = 0, int __base = 10)\n  { return __gnu_cxx::__stoa(&std::strtoll, \"stoll\", __str.c_str(),\n\t\t\t     __idx, __base); }\n\n  inline unsigned long long\n  stoull(const string& __str, size_t* __idx = 0, int __base = 10)\n  { return __gnu_cxx::__stoa(&std::strtoull, \"stoull\", __str.c_str(),\n\t\t\t     __idx, __base); }\n\n  // NB: strtof vs strtod.\n  inline float\n  stof(const string& __str, size_t* __idx = 0)\n  { return __gnu_cxx::__stoa(&std::strtof, \"stof\", __str.c_str(), __idx); }\n\n  inline double\n  stod(const string& __str, size_t* __idx = 0)\n  { return __gnu_cxx::__stoa(&std::strtod, \"stod\", __str.c_str(), __idx); }\n\n  inline long double\n  stold(const string& __str, size_t* __idx = 0)\n  { return __gnu_cxx::__stoa(&std::strtold, \"stold\", __str.c_str(), __idx); }\n#endif // _GLIBCXX_USE_C99_STDLIB\n\n#if _GLIBCXX_USE_C99_STDIO\n  // NB: (v)snprintf vs sprintf.\n\n  // DR 1261.\n  inline string\n  to_string(int __val)\n  { return __gnu_cxx::__to_xstring<string>(&std::vsnprintf, 4 * sizeof(int),\n\t\t\t\t\t   \"%d\", __val); }\n\n  inline string\n  to_string(unsigned __val)\n  { return __gnu_cxx::__to_xstring<string>(&std::vsnprintf,\n\t\t\t\t\t   4 * sizeof(unsigned),\n\t\t\t\t\t   \"%u\", __val); }\n\n  inline string\n  to_string(long __val)\n  { return __gnu_cxx::__to_xstring<string>(&std::vsnprintf, 4 * sizeof(long),\n\t\t\t\t\t   \"%ld\", __val); }\n\n  inline string\n  to_string(unsigned long __val)\n  { return __gnu_cxx::__to_xstring<string>(&std::vsnprintf,\n\t\t\t\t\t   4 * sizeof(unsigned long),\n\t\t\t\t\t   \"%lu\", __val); }\n\n  inline string\n  to_string(long long __val)\n  { return __gnu_cxx::__to_xstring<string>(&std::vsnprintf,\n\t\t\t\t\t   4 * sizeof(long long),\n\t\t\t\t\t   \"%lld\", __val); }\n\n  inline string\n  to_string(unsigned long long __val)\n  { return __gnu_cxx::__to_xstring<string>(&std::vsnprintf,\n\t\t\t\t\t   4 * sizeof(unsigned long long),\n\t\t\t\t\t   \"%llu\", __val); }\n\n  inline string\n  to_string(float __val)\n  {\n    const int __n = \n      __gnu_cxx::__numeric_traits<float>::__max_exponent10 + 20;\n    return __gnu_cxx::__to_xstring<string>(&std::vsnprintf, __n,\n\t\t\t\t\t   \"%f\", __val);\n  }\n\n  inline string\n  to_string(double __val)\n  {\n    const int __n = \n      __gnu_cxx::__numeric_traits<double>::__max_exponent10 + 20;\n    return __gnu_cxx::__to_xstring<string>(&std::vsnprintf, __n,\n\t\t\t\t\t   \"%f\", __val);\n  }\n\n  inline string\n  to_string(long double __val)\n  {\n    const int __n = \n      __gnu_cxx::__numeric_traits<long double>::__max_exponent10 + 20;\n    return __gnu_cxx::__to_xstring<string>(&std::vsnprintf, __n,\n\t\t\t\t\t   \"%Lf\", __val);\n  }\n#endif // _GLIBCXX_USE_C99_STDIO\n\n#if defined(_GLIBCXX_USE_WCHAR_T) && _GLIBCXX_USE_C99_WCHAR\n  inline int \n  stoi(const wstring& __str, size_t* __idx = 0, int __base = 10)\n  { return __gnu_cxx::__stoa<long, int>(&std::wcstol, \"stoi\", __str.c_str(),\n\t\t\t\t\t__idx, __base); }\n\n  inline long \n  stol(const wstring& __str, size_t* __idx = 0, int __base = 10)\n  { return __gnu_cxx::__stoa(&std::wcstol, \"stol\", __str.c_str(),\n\t\t\t     __idx, __base); }\n\n  inline unsigned long\n  stoul(const wstring& __str, size_t* __idx = 0, int __base = 10)\n  { return __gnu_cxx::__stoa(&std::wcstoul, \"stoul\", __str.c_str(),\n\t\t\t     __idx, __base); }\n\n  inline long long\n  stoll(const wstring& __str, size_t* __idx = 0, int __base = 10)\n  { return __gnu_cxx::__stoa(&std::wcstoll, \"stoll\", __str.c_str(),\n\t\t\t     __idx, __base); }\n\n  inline unsigned long long\n  stoull(const wstring& __str, size_t* __idx = 0, int __base = 10)\n  { return __gnu_cxx::__stoa(&std::wcstoull, \"stoull\", __str.c_str(),\n\t\t\t     __idx, __base); }\n\n  // NB: wcstof vs wcstod.\n  inline float\n  stof(const wstring& __str, size_t* __idx = 0)\n  { return __gnu_cxx::__stoa(&std::wcstof, \"stof\", __str.c_str(), __idx); }\n\n  inline double\n  stod(const wstring& __str, size_t* __idx = 0)\n  { return __gnu_cxx::__stoa(&std::wcstod, \"stod\", __str.c_str(), __idx); }\n\n  inline long double\n  stold(const wstring& __str, size_t* __idx = 0)\n  { return __gnu_cxx::__stoa(&std::wcstold, \"stold\", __str.c_str(), __idx); }\n\n#ifndef _GLIBCXX_HAVE_BROKEN_VSWPRINTF\n  // DR 1261.\n  inline wstring\n  to_wstring(int __val)\n  { return __gnu_cxx::__to_xstring<wstring>(&std::vswprintf, 4 * sizeof(int),\n\t\t\t\t\t    L\"%d\", __val); }\n\n  inline wstring\n  to_wstring(unsigned __val)\n  { return __gnu_cxx::__to_xstring<wstring>(&std::vswprintf,\n\t\t\t\t\t    4 * sizeof(unsigned),\n\t\t\t\t\t    L\"%u\", __val); }\n\n  inline wstring\n  to_wstring(long __val)\n  { return __gnu_cxx::__to_xstring<wstring>(&std::vswprintf, 4 * sizeof(long),\n\t\t\t\t\t    L\"%ld\", __val); }\n\n  inline wstring\n  to_wstring(unsigned long __val)\n  { return __gnu_cxx::__to_xstring<wstring>(&std::vswprintf,\n\t\t\t\t\t    4 * sizeof(unsigned long),\n\t\t\t\t\t    L\"%lu\", __val); }\n\n  inline wstring\n  to_wstring(long long __val)\n  { return __gnu_cxx::__to_xstring<wstring>(&std::vswprintf,\n\t\t\t\t\t    4 * sizeof(long long),\n\t\t\t\t\t    L\"%lld\", __val); }\n\n  inline wstring\n  to_wstring(unsigned long long __val)\n  { return __gnu_cxx::__to_xstring<wstring>(&std::vswprintf,\n\t\t\t\t\t    4 * sizeof(unsigned long long),\n\t\t\t\t\t    L\"%llu\", __val); }\n\n  inline wstring\n  to_wstring(float __val)\n  {\n    const int __n =\n      __gnu_cxx::__numeric_traits<float>::__max_exponent10 + 20;\n    return __gnu_cxx::__to_xstring<wstring>(&std::vswprintf, __n,\n\t\t\t\t\t    L\"%f\", __val);\n  }\n\n  inline wstring\n  to_wstring(double __val)\n  {\n    const int __n =\n      __gnu_cxx::__numeric_traits<double>::__max_exponent10 + 20;\n    return __gnu_cxx::__to_xstring<wstring>(&std::vswprintf, __n,\n\t\t\t\t\t    L\"%f\", __val);\n  }\n\n  inline wstring\n  to_wstring(long double __val)\n  {\n    const int __n =\n      __gnu_cxx::__numeric_traits<long double>::__max_exponent10 + 20;\n    return __gnu_cxx::__to_xstring<wstring>(&std::vswprintf, __n,\n\t\t\t\t\t    L\"%Lf\", __val);\n  }\n#endif // _GLIBCXX_HAVE_BROKEN_VSWPRINTF\n#endif // _GLIBCXX_USE_WCHAR_T && _GLIBCXX_USE_C99_WCHAR\n\n_GLIBCXX_END_NAMESPACE_CXX11\n_GLIBCXX_END_NAMESPACE_VERSION\n} // namespace\n\n#endif /* C++11 */\n\n#if __cplusplus >= 201103L\n\n#include <bits/functional_hash.h>\n\nnamespace std _GLIBCXX_VISIBILITY(default)\n{\n_GLIBCXX_BEGIN_NAMESPACE_VERSION\n\n  // DR 1182.\n\n#ifndef _GLIBCXX_COMPATIBILITY_CXX0X\n  /// std::hash specialization for string.\n  template<>\n    struct hash<string>\n    : public __hash_base<size_t, string>\n    {\n      size_t\n      operator()(const string& __s) const noexcept\n      { return std::_Hash_impl::hash(__s.data(), __s.length()); }\n    };\n\n  template<>\n    struct __is_fast_hash<hash<string>> : std::false_type\n    { };\n\n#ifdef _GLIBCXX_USE_WCHAR_T\n  /// std::hash specialization for wstring.\n  template<>\n    struct hash<wstring>\n    : public __hash_base<size_t, wstring>\n    {\n      size_t\n      operator()(const wstring& __s) const noexcept\n      { return std::_Hash_impl::hash(__s.data(),\n                                     __s.length() * sizeof(wchar_t)); }\n    };\n\n  template<>\n    struct __is_fast_hash<hash<wstring>> : std::false_type\n    { };\n#endif\n#endif /* _GLIBCXX_COMPATIBILITY_CXX0X */\n\n#ifdef _GLIBCXX_USE_C99_STDINT_TR1\n  /// std::hash specialization for u16string.\n  template<>\n    struct hash<u16string>\n    : public __hash_base<size_t, u16string>\n    {\n      size_t\n      operator()(const u16string& __s) const noexcept\n      { return std::_Hash_impl::hash(__s.data(),\n                                     __s.length() * sizeof(char16_t)); }\n    };\n\n  template<>\n    struct __is_fast_hash<hash<u16string>> : std::false_type\n    { };\n\n  /// std::hash specialization for u32string.\n  template<>\n    struct hash<u32string>\n    : public __hash_base<size_t, u32string>\n    {\n      size_t\n      operator()(const u32string& __s) const noexcept\n      { return std::_Hash_impl::hash(__s.data(),\n                                     __s.length() * sizeof(char32_t)); }\n    };\n\n  template<>\n    struct __is_fast_hash<hash<u32string>> : std::false_type\n    { };\n#endif\n\n_GLIBCXX_END_NAMESPACE_VERSION\n\n#if __cplusplus > 201103L\n\n#define __cpp_lib_string_udls 201304\n\n  inline namespace literals\n  {\n  inline namespace string_literals\n  {\n_GLIBCXX_BEGIN_NAMESPACE_VERSION\n\n    _GLIBCXX_DEFAULT_ABI_TAG\n    inline basic_string<char>\n    operator\"\"s(const char* __str, size_t __len)\n    { return basic_string<char>{__str, __len}; }\n\n#ifdef _GLIBCXX_USE_WCHAR_T\n    _GLIBCXX_DEFAULT_ABI_TAG\n    inline basic_string<wchar_t>\n    operator\"\"s(const wchar_t* __str, size_t __len)\n    { return basic_string<wchar_t>{__str, __len}; }\n#endif\n\n#ifdef _GLIBCXX_USE_C99_STDINT_TR1\n    _GLIBCXX_DEFAULT_ABI_TAG\n    inline basic_string<char16_t>\n    operator\"\"s(const char16_t* __str, size_t __len)\n    { return basic_string<char16_t>{__str, __len}; }\n\n    _GLIBCXX_DEFAULT_ABI_TAG\n    inline basic_string<char32_t>\n    operator\"\"s(const char32_t* __str, size_t __len)\n    { return basic_string<char32_t>{__str, __len}; }\n#endif\n\n_GLIBCXX_END_NAMESPACE_VERSION\n  } // inline namespace string_literals\n  } // inline namespace literals\n\n#endif // __cplusplus > 201103L\n\n} // namespace std\n\n#endif // C++11\n\n#endif /* _BASIC_STRING_H */\n"}, "9": {"id": 9, "path": "/home/runner/work/testcc/testcc/retdec/ext/yahttp/yahttp/url.hpp", "content": "#pragma once\n#include <sstream>\n#include <string>\n\n#include \"utility.hpp\"\n\n#ifndef YAHTTP_MAX_URL_LENGTH\n#define YAHTTP_MAX_URL_LENGTH 2048\n#endif \n\nnamespace YaHTTP {\n  /*! URL parser and container */\n  class URL {\n   private: \n      bool parseSchema(const std::string& url, size_t &pos) {\n          size_t pos1;\n          if (pos >= url.size()) return false; // no data\n          if ( (pos1 = url.find_first_of(\":\",pos)) == std::string::npos ) return false; // schema is mandatory\n          protocol = url.substr(pos, pos1-pos);\n          if (protocol == \"http\") port = 80;\n          if (protocol == \"https\") port = 443;\n          pos = pos1+1; // after :\n          if (url.compare(pos, 2, \"//\") == 0) {\n             pathless = false; // if this is true we put rest into parameters\n             pos += 2;\n          }\n          return true;\n      }; //<! parse schema/protocol part \n\n      bool parseHost(const std::string& url, size_t &pos) {\n          size_t pos1;\n          if (pos >= url.size()) return true; // no data\n          if ( (pos1 = url.find_first_of(\"/\", pos)) == std::string::npos ) {\n             host = url.substr(pos);\n             path = \"/\";\n             pos = url.size();\n          } else {\n             host = url.substr(pos, pos1-pos);\n             pos = pos1;\n          }\n          if (host.at(0) == '[') { // IPv6\n            if ((pos1 = host.find_first_of(\"]\")) == std::string::npos) {\n              // incomplete address\n              return false;\n            }\n            size_t pos2;\n            if ((pos2 = host.find_first_of(\":\", pos1)) != std::string::npos) {\n              std::istringstream tmp(host.substr(pos2 + 1));\n              tmp >> port;\n            }\n            host = host.substr(1, pos1 - 1);\n          } else if ( (pos1 = host.find_first_of(\":\")) != std::string::npos ) {\n             std::istringstream tmp(host.substr(pos1+1));\n             tmp >> port;\n             host = host.substr(0, pos1);\n          }\n          return true;\n      }; //<! parse host and port\n\n      bool parseUserPass(const std::string& url, size_t &pos) {\n          size_t pos1,pos2;\n          if (pos >= url.size()) return true; // no data\n\n          if ( (pos1 = url.find_first_of(\"@\",pos)) == std::string::npos ) return true; // no userinfo\n          pos2 = url.find_first_of(\":\",pos);\n\n          if (pos2 != std::string::npos) { // comes with password\n             username = url.substr(pos, pos2 - pos);\n             password = url.substr(pos2+1, pos1 - pos2 - 1);\n             password = Utility::decodeURL(password);\n          } else {\n             username = url.substr(pos, pos1 - pos);\n          }\n          pos = pos1+1;\n          username = Utility::decodeURL(username);\n          return true;\n      }; //<! parse possible username and password\n\n      bool parsePath(const std::string& url, size_t &pos) {\n          size_t pos1;\n          if (pos >= url.size()) return true; // no data\n          if (url[pos] != '/') return false; // not an url\n          if ( (pos1 = url.find_first_of(\"?\", pos)) == std::string::npos ) {\n             path = url.substr(pos);\n             pos = url.size();\n          } else {\n             path = url.substr(pos, pos1-pos);\n             pos = pos1;\n          }\n          return true;\n      }; //<! parse path component\n\n      bool parseParameters(const std::string& url, size_t &pos) {\n          size_t pos1;\n          if (pos >= url.size()) return true; // no data\n          if (url[pos] == '#') return true; // anchor starts here\n          if (url[pos] != '?') return false; // not a parameter\n          if ( (pos1 = url.find_first_of(\"#\", pos)) == std::string::npos ) {\n             parameters = url.substr(pos+1);;\n             pos = url.size();\n          } else {\n             parameters = url.substr(pos+1, pos1-pos-1);\n             pos = pos1;\n          }\n          if (parameters.size()>0 && *(parameters.end()-1) == '&') parameters.resize(parameters.size()-1);\n          return true;\n      }; //<! parse url parameters\n\n      bool parseAnchor(const std::string& url, size_t &pos) {\n          if (pos >= url.size()) return true; // no data\n          if (url[pos] != '#') return false; // not anchor\n          anchor = url.substr(pos+1);\n          return true;\n      }; //<! parse anchor\n\n      void initialize() {\n        protocol = \"\"; host = \"\"; port = 0; username = \"\"; password = \"\"; path = \"\"; parameters = \"\"; anchor =\"\"; pathless = true;\n      }; //<! initialize to empty URL\n\n  public:\n      std::string to_string() const {\n          std::string tmp;\n          std::ostringstream oss;\n            \n          if (protocol.empty() == false) {\n             oss << protocol << \":\";\n             if (host.empty() == false) {\n               oss << \"//\";\n             }\n          }\n\n          if (username.empty() == false) {\n           if (password.empty() == false)\n             oss << Utility::encodeURL(username) << \":\" << Utility::encodeURL(password) << \"@\";\n           else\n             oss << Utility::encodeURL(username) << \"@\";\n          }\n          if (host.empty() == false)\n             oss << host;\n          if (!(protocol == \"http\" && port == 80) &&\n              !(protocol == \"https\" && port == 443) &&\n              port > 0) \n            oss << \":\" << port;\n\n          oss << path;\n          if (parameters.empty() == false) {\n             if (!pathless) \n                oss << \"?\";\n             oss << parameters;\n          }\n          if (anchor.empty() == false)\n             oss << \"#\" << anchor;\n          return oss.str();\n      }; //<! convert this URL to string\n\n      std::string protocol; //<! schema/protocol \n      std::string host; //<! host\n      int port; //<! port\n      std::string username; //<! username\n      std::string password; //<! password\n      std::string path; //<! path \n      std::string parameters; //<! url parameters\n      std::string anchor; //<! anchor\n      bool pathless; //<! whether this url has no path\n\n      URL() { initialize(); }; //<! construct empty url\n      URL(const std::string& url) {\n        parse(url);\n      }; //<! calls parse with url \n\n      URL(const char *url) {\n        parse(std::string(url));\n      }; //<! calls parse with url\n\n      bool parse(const std::string& url) {\n        // setup\n        initialize();\n\n        if (url.size() > YAHTTP_MAX_URL_LENGTH) return false;\n        size_t pos = 0;\n        if (*(url.begin()) != '/') { // full url?\n          if (parseSchema(url, pos) == false) return false;\n          if (pathless) {\n            parameters = url.substr(pos);\n            return true;\n          }\n          if (parseUserPass(url, pos) == false) return false;\n          if (parseHost(url, pos) == false) return false;\n        }\n        if (parsePath(url, pos) == false) return false;\n        if (parseParameters(url, pos) == false) return false;\n        return parseAnchor(url, pos);\n    }; //<! parse various formats of urls ranging from http://example.com/foo?bar=baz into data:base64:d089swt64wt... \n\n    friend std::ostream & operator<<(std::ostream& os, const URL& url) {\n      os<<url.to_string();\n      return os;\n    };\n  };\n};\n"}, "5": {"id": 5, "path": "/home/runner/work/testcc/testcc/retdec/ext/yahttp/yahttp/utility.hpp", "content": "#pragma once\nnamespace YaHTTP {\n  static const char *MONTHS[] = {0,\"Jan\",\"Feb\",\"Mar\",\"Apr\",\"May\",\"Jun\",\"Jul\",\"Aug\",\"Sep\",\"Oct\",\"Nov\",\"Dec\",0}; //<! List of months \n  static const char *DAYS[] = {\"Sun\",\"Mon\",\"Tue\",\"Wed\",\"Thu\",\"Fri\",\"Sat\",0}; //<! List of days\n\n  bool isspace(char c);\n  bool isspace(char c, const std::locale& loc);\n  bool isxdigit(char c);\n  bool isxdigit(char c, const std::locale& loc);\n  bool isdigit(char c);\n  bool isdigit(char c, const std::locale& loc);\n  bool isalnum(char c);\n  bool isalnum(char c, const std::locale& loc);\n\n  /*! Case-Insensitive NULL safe comparator for string maps */\n  struct ASCIICINullSafeComparator {\n    bool operator() (const std::string& lhs, const std::string& rhs) const {\n      int v;\n      std::string::const_iterator lhi = lhs.begin();\n      std::string::const_iterator rhi = rhs.begin();\n      for(;lhi != lhs.end() && rhi != rhs.end(); lhi++, rhi++)\n        if ((v = ::tolower(*lhi) - ::tolower(*rhi)) != 0) return v<0; \n      if (lhi == lhs.end() && rhi != rhs.end()) return true;\n      if (lhi != lhs.end() && rhi == rhs.end()) return false;\n      return false; // they are equal\n    }\n  };\n\n  typedef std::map<std::string,std::string,ASCIICINullSafeComparator> strstr_map_t; //<! String to String map\n\n  /*! Represents a date/time with utc offset */\n  class DateTime {\n  public:\n     bool isSet; //<! if this is initialized yet\n\n     int year; //<! year, 0 is year 0, not 1900\n\n     int month; //<! month, range 1-12\n     int day; //<! day, range 1-31\n     int wday; //<! week day, range 1-7\n\n     int hours; //<! hours, range 0-23\n     int minutes; //<! minutes, range 0-59\n     int seconds; //<! seconds, range 0-60\n\n     int utc_offset; //<! UTC offset with minutes (hhmm)\n\n     DateTime() { \n       initialize();\n     }; //<! Construct and initialize\n\n     void initialize() {\n       isSet = false; \n       year = month = day = wday = hours = minutes = seconds = utc_offset = 0;\n       month = 1; // it's invalid otherwise\n     }; //<! Creates year 0 date\n\n     void setLocal() {\n       fromLocaltime(time((time_t*)NULL)); \n     }; //<! sets current local time\n\n     void setGm() {\n       fromGmtime(time((time_t*)NULL));\n     }; //<! sets current gmtime (almost UTC)\n\n     void fromLocaltime(time_t t) {\n#ifdef HAVE_LOCALTIME_R\n       struct tm tm;\n       localtime_r(&t, &tm);\n       fromTm(&tm);\n#else\n       struct tm *tm;\n       #error define HAVE_LOCALTIME_R\n       tm = localtime(&t); // lgtm [cpp/potentially-dangerous-function]\n       fromTm(tm);\n#endif\n#ifndef HAVE_TM_GMTOFF\n       time_t t2;\n# ifdef HAVE_LOCALTIME_R\n       gmtime_r(&t, &tm);\n       t2 = mktime(&tm);\n# else\n       #error define HAVE_LOCALTIME_R\n       tm = gmtime(&t); // lgtm [cpp/potentially-dangerous-function]\n       t2 = mktime(tm);\n# endif\n       this->utc_offset = ((t2-t)/10)*10; // removes any possible differences. \n#endif\n     }; //<! uses localtime for time\n\n     void fromGmtime(time_t t) {\n#ifdef HAVE_GMTIME_R\n       struct tm tm;\n       gmtime_r(&t, &tm);\n       fromTm(&tm);\n#else\n       struct tm *tm;\n       #error define HAVE_GMTIME_R\n       tm = gmtime(&t);// lgtm [cpp/potentially-dangerous-function]\n       fromTm(tm);\n#endif\n#ifndef HAVE_TM_GMTOFF\n       this->utc_offset = 0;\n#endif\n     }; //<! uses gmtime for time\n\n     void fromTm(const struct tm *tm) {\n       year = tm->tm_year + 1900;\n       month = tm->tm_mon + 1;\n       day = tm->tm_mday;\n       hours = tm->tm_hour;\n       minutes = tm->tm_min;\n       seconds = tm->tm_sec;\n       wday = tm->tm_wday;\n#ifdef HAVE_TM_GMTOFF\n       utc_offset = tm->tm_gmtoff;\n#endif\n       isSet = true;\n     }; //<! parses date from struct tm \n\n     void validate() const {\n       if (wday < 0 || wday > 6) throw std::range_error(\"Invalid date\");\n       if (month < 1 || month > 12) throw std::range_error(\"Invalid date\");\n       if (year < 0) throw std::range_error(\"Invalid date\");\n       if (hours < 0 || hours > 23 ||\n           minutes < 0 || minutes > 59 ||\n           seconds < 0 || seconds > 60) throw std::range_error(\"Invalid date\");\n     }; //<! make sure we are within ranges (not a *REAL* validation, just range check)\n\n     std::string rfc_str() const {\n       std::ostringstream oss;\n       validate();\n       oss << DAYS[wday] << \", \" << std::setfill('0') << std::setw(2) << day << \" \" << MONTHS[month] << \" \" <<\n          std::setfill('0') << std::setw(2) <<  year << \" \" << \n          std::setfill('0') << std::setw(2) << hours << \":\" << \n          std::setfill('0') << std::setw(2) << minutes << \":\" << \n          std::setfill('0') << std::setw(2) << seconds << \" \";\n       if (utc_offset>=0) oss << \"+\";\n       else oss << \"-\";\n       int tmp_off = ( utc_offset < 0 ? utc_offset*-1 : utc_offset ); \n       oss << std::setfill('0') << std::setw(2) << (tmp_off/3600);\n       oss << std::setfill('0') << std::setw(2) << (tmp_off%3600)/60;\n\n       return oss.str(); \n     }; //<! converts this date into a RFC-822 format\n \n     std::string cookie_str() const {\n       std::ostringstream oss;\n       validate();\n       oss << std::setfill('0') << std::setw(2) << day << \"-\" << MONTHS[month] << \"-\" << year << \" \" <<\n         std::setfill('0') << std::setw(2) << hours << \":\" << \n         std::setfill('0') << std::setw(2) << minutes << \":\" << \n         std::setfill('0') << std::setw(2) << seconds << \" GMT\";\n       return oss.str();\n     }; //<! converts this date into a HTTP Cookie date\n \n     void parse822(const std::string &rfc822_date) {\n       struct tm tm;\n       const char *ptr;\n#ifdef HAVE_TM_GMTOFF\n       if ( (ptr = strptime(rfc822_date.c_str(), \"%a, %d %b %Y %T %z\", &tm)) != NULL) {\n#else\n\tif ( (ptr = strptime(rfc822_date.c_str(), \"%a, %d %b %Y %T\", &tm)) != NULL) {\n          int sign;\n  \t  // parse the timezone parameter\n          while(*ptr && YaHTTP::isspace(*ptr)) ptr++;\n          if (*ptr == '+') sign = 0;\n          else if (*ptr == '-') sign = -1;\n          else throw YaHTTP::ParseError(\"Unparseable date\");\n          ptr++;\n          utc_offset = ::atoi(ptr) * sign;\n          while(*ptr != '\\0' && YaHTTP::isdigit(*ptr)) ptr++;\n#endif\n          while(*ptr != '\\0' && YaHTTP::isspace(*ptr)) ptr++;\n          if (*ptr != '\\0') throw YaHTTP::ParseError(\"Unparseable date\"); // must be final.\n          fromTm(&tm);\n       } else {\n          throw YaHTTP::ParseError(\"Unparseable date\");\n       }\n     }; //<! parses RFC-822 date\n\n     void parseCookie(const std::string &cookie_date) {\n       struct tm tm;\n       const char *ptr;\n       if ( (ptr = strptime(cookie_date.c_str(), \"%d-%b-%Y %T\", &tm)) != NULL\n#ifdef HAVE_TM_GMTOFF\n          || (ptr = strptime(cookie_date.c_str(), \"%d-%b-%Y %T %z\", &tm)) != NULL\n          || (ptr = strptime(cookie_date.c_str(), \"%a, %d-%b-%Y %T %Z\", &tm)) != NULL\n#endif\n          ) {\n          while(*ptr != '\\0' && ( YaHTTP::isspace(*ptr) || YaHTTP::isalnum(*ptr) )) ptr++;\n          if (*ptr != '\\0') throw YaHTTP::ParseError(\"Unparseable date (non-final)\"); // must be final.\n          fromTm(&tm);\n          this->utc_offset = 0;\n       } else {\n          std::cout << cookie_date << std::endl;\n          throw YaHTTP::ParseError(\"Unparseable date (did not match pattern cookie)\");\n       }\n     }; //<! parses HTTP Cookie date\n\n     time_t unixtime() const {\n       struct tm tm;\n       tm.tm_year = year-1900;\n       tm.tm_mon = month-1;\n       tm.tm_mday = day;\n       tm.tm_hour = hours;\n       tm.tm_min = minutes;\n       tm.tm_sec = seconds;\n       tm.tm_isdst = 0;\n#ifdef HAVE_TM_GMTOFF\n       tm.tm_gmtoff = utc_offset;\n#endif\n       return mktime(&tm);\n     }; //<! returns this datetime as unixtime. will not work for dates before 1970/1/1 00:00:00 GMT\n  };\n\n  /*! Various helpers needed in the code */ \n  class Utility {\n  public:\n    static std::string decodeURL(const std::string& component) {\n        std::string result = component;\n        size_t pos1,pos2;\n        pos2 = 0;\n        while((pos1 = result.find_first_of(\"%\", pos2))!=std::string::npos) {\n           std::string code;\n           char a,b,c;\n           if (pos1 + 2 > result.length()) return result; // end of result\n           code = result.substr(pos1+1, 2);\n           a = std::tolower(code[0]); b = std::tolower(code[1]);\n\n           if ((( '0' > a || a > '9') && ('a' > a || a > 'f')) ||\n              (( '0' > b || b > '9') && ('a' > b || b > 'f'))) {\n              pos2 = pos1+3;\n              continue;\n           }\n\n           if ('0' <= a && a <= '9') a = a - '0';\n           if ('a' <= a && a <= 'f') a = a - 'a' + 0x0a;\n           if ('0' <= b && b <= '9') b = b - '0';\n           if ('a' <= b && b <= 'f') b = b - 'a' + 0x0a;\n\n           c = (a<<4)+b;\n           result = result.replace(pos1,3,1,c);\n           pos2=pos1;\n        }\n        return result;\n    }; //<! Decodes %xx from string into bytes\n    \n    static std::string encodeURL(const std::string& component, bool asUrl = true) {\n      std::string result = component;\n      std::string skip = \"+-.:,&;_#%[]?/@(){}=\";\n      char repl[3];\n      size_t pos;\n      for(std::string::iterator iter = result.begin(); iter != result.end(); iter++) {\n        if (!YaHTTP::isalnum(*iter) && (!asUrl || skip.find(*iter) == std::string::npos)) {\n          // replace with different thing\n          pos = std::distance(result.begin(), iter);\n          ::snprintf(repl,3,\"%02x\", static_cast<unsigned char>(*iter));\n          result = result.replace(pos, 1, \"%\", 1).insert(pos+1, repl, 2);\n          iter = result.begin() + pos + 2;\n        }\n      }\n      return result;\n    }; //<! Escapes any characters into %xx representation when necessary, set asUrl to false to fully encode the url\n\n    static std::string encodeURL(const std::wstring& component, bool asUrl = true) {\n      unsigned char const *p = reinterpret_cast<unsigned char const*>(&component[0]);\n      std::size_t s = component.size() * sizeof((*component.begin()));\n      std::vector<unsigned char> vec(p, p+s);\n\n      std::ostringstream result;\n      std::string skip = \"+-.,&;_#%[]?/@(){}=\";\n      for(std::vector<unsigned char>::iterator iter = vec.begin(); iter != vec.end(); iter++) {\n        if (!YaHTTP::isalnum((char)*iter) && (!asUrl || skip.find((char)*iter) == std::string::npos)) {\n          // bit more complex replace\n          result << \"%\" << std::hex << std::setw(2) << std::setfill('0') << static_cast<unsigned int>(*iter);\n        } else result << (char)*iter;\n      }\n      return result.str();\n    }; //<! Escapes any characters into %xx representation when necessary, set asUrl to false to fully encode the url, for wide strings, returns ordinary string\n\n    static std::string status2text(int status) {\n       switch(status) {\n       case 200:\n           return \"OK\";\n       case 201:\n           return \"Created\";\n       case 202:\n           return \"Accepted\";\n       case 203:\n           return \"Non-Authoritative Information\";\n       case 204:\n           return \"No Content\";\n       case 205:\n           return \"Reset Content\";\n       case 206:\n           return \"Partial Content\";\n       case 300:\n           return \"Multiple Choices\";\n       case 301:\n           return \"Moved Permanently\";\n       case 302:\n           return \"Found\";\n       case 303:\n           return \"See Other\";\n       case 304:\n           return \"Not Modified\";\n       case 305:\n           return \"Use Proxy\";\n       case 307:\n           return \"Temporary Redirect\";\n       case 400:\n           return \"Bad Request\";\n       case 401:\n           return \"Unauthorized\";\n       case 402:\n           return \"Payment Required\";\n       case 403: \n           return \"Forbidden\";\n       case 404:\n           return \"Not Found\";\n       case 405:\n           return \"Method Not Allowed\";\n       case 406:\n           return \"Not Acceptable\";\n       case 407:\n           return \"Proxy Authentication Required\";\n       case 408:\n           return \"Request Time-out\";\n       case 409:\n           return \"Conflict\";\n       case 410:\n           return \"Gone\";\n       case 411:\n           return \"Length Required\";\n       case 412:\n           return \"Precondition Failed\";\n       case 413:\n           return \"Request Entity Too Large\";\n       case 414:\n           return \"Request-URI Too Large\";\n       case 415:\n           return \"Unsupported Media Type\";\n       case 416:\n           return \"Requested range not satisfiable\";\n       case 417:\n           return \"Expectation Failed\";\n       case 422:\n           return \"Unprocessable Entity\";\n       case 500:\n           return \"Internal Server Error\";\n       case 501:\n           return \"Not Implemented\";\n       case 502:\n           return \"Bad Gateway\";\n       case 503:\n           return \"Service Unavailable\";\n       case 504:\n           return \"Gateway Time-out\";\n       case 505:\n           return \"HTTP Version not supported\";\n       default:\n           return \"Unknown Status\";\n       }\n    }; //<! static HTTP codes to text mappings\n\n    static strstr_map_t parseUrlParameters(std::string parameters) {\n      std::string::size_type pos = 0;\n      strstr_map_t parameter_map;\n      while (pos != std::string::npos) {\n        // find next parameter start\n        std::string::size_type nextpos = parameters.find(\"&\", pos);\n        std::string::size_type delim = parameters.find(\"=\", pos);\n        if (delim > nextpos) {\n          delim = nextpos;\n        }\n        std::string key;\n        std::string value;\n        if (delim == std::string::npos) {\n          key = parameters.substr(pos);\n        } else {\n          key = parameters.substr(pos, delim-pos);\n          if (nextpos == std::string::npos) {\n            value = parameters.substr(delim+1);\n          } else {\n            value = parameters.substr(delim+1, nextpos-delim-1);\n          }\n        }\n        if (key.empty()) {\n          // no parameters at all\n          break;\n        }\n        key = decodeURL(key);\n        value = decodeURL(value);\n        parameter_map[key] = value;\n        if (nextpos == std::string::npos) {\n          // no more parameters left\n          break;\n        }\n\n        pos = nextpos+1;\n      }\n      return parameter_map;\n    }; //<! parses URL parameters into string map \n\n    static bool iequals(const std::string& a, const std::string& b, size_t length) {\n      std::string::const_iterator ai, bi;\n      size_t i;\n      for(ai = a.begin(), bi = b.begin(), i = 0; ai != a.end() && bi != b.end() && i < length; ai++,bi++,i++) {\n        if (::toupper(*ai) != ::toupper(*bi)) return false;\n      }\n\n      if (ai == a.end() && bi == b.end()) return true;\n      if ((ai == a.end() && bi != b.end()) ||\n          (ai != a.end() && bi == b.end())) return false;\n      \n      return ::toupper(*ai) == ::toupper(*bi);\n    }; //<! case-insensitive comparison with length\n\n    static bool iequals(const std::string& a, const std::string& b) {\n      if (a.size() != b.size()) return false;\n      return iequals(a,b,a.size());\n    }; //<! case-insensitive comparison\n\n    static void trimLeft(std::string &str) {\n       const std::locale &loc = std::locale::classic();\n       std::string::iterator iter = str.begin();\n       while(iter != str.end() && YaHTTP::isspace(*iter, loc)) iter++;\n       str.erase(str.begin(), iter);\n    }; //<! removes whitespace from left\n\n    static void trimRight(std::string &str) {\n       const std::locale &loc = std::locale::classic();\n       std::string::reverse_iterator iter = str.rbegin();\n       while(iter != str.rend() && YaHTTP::isspace(*iter, loc)) iter++;\n       str.erase(iter.base(), str.end());\n    }; //<! removes whitespace from right\n\n    static void trim(std::string &str) {\n       trimLeft(str);\n       trimRight(str);\n    }; //<! removes whitespace from left and right\n\n    static std::string camelizeHeader(const std::string &str) {\n       std::string::const_iterator iter = str.begin();\n       std::string result;\n       const std::locale &loc = std::locale::classic();\n\n       bool doNext = true;\n\n       while(iter != str.end()) {\n         if (doNext) \n            result.insert(result.end(), std::toupper(*iter, loc));\n         else \n            result.insert(result.end(), std::tolower(*iter, loc)); \n         doNext = (*(iter++) == '-');\n       }\n\n       return result;\n   }; //<! camelizes headers, such as, content-type => Content-Type\n  };\n};\n"}, "24": {"id": 24, "path": "/home/runner/work/testcc/testcc/retdec/pdns/json.hh", "content": "/*\n * This file is part of PowerDNS or dnsdist.\n * Copyright -- PowerDNS.COM B.V. and its contributors\n *\n * This program is free software; you can redistribute it and/or modify\n * it under the terms of version 2 of the GNU General Public License as\n * published by the Free Software Foundation.\n *\n * In addition, for the avoidance of any doubt, permission is granted to\n * link this program with OpenSSL and to (re)distribute the binaries\n * produced as the result of such linking.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with this program; if not, write to the Free Software\n * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.\n */\n#pragma once // it is 2012, deal with it\n\n#include <string>\n#include <stdexcept>\n#include \"json11.hpp\"\n\nint intFromJson(const json11::Json container, const std::string& key);\nint intFromJson(const json11::Json container, const std::string& key, const int default_value);\ndouble doubleFromJson(const json11::Json container, const std::string& key);\ndouble doubleFromJson(const json11::Json container, const std::string& key, const double default_value);\nstd::string stringFromJson(const json11::Json container, const std::string &key);\nbool boolFromJson(const json11::Json container, const std::string& key);\nbool boolFromJson(const json11::Json container, const std::string& key, const bool default_value);\n\nclass JsonException : public std::runtime_error\n{\npublic:\n  JsonException(const std::string& what_arg) : std::runtime_error(what_arg) {\n  }\n};\n"}, "25": {"id": 25, "path": "/home/runner/work/testcc/testcc/retdec/pdns/logger.hh", "content": "/*\n * This file is part of PowerDNS or dnsdist.\n * Copyright -- PowerDNS.COM B.V. and its contributors\n *\n * This program is free software; you can redistribute it and/or modify\n * it under the terms of version 2 of the GNU General Public License as\n * published by the Free Software Foundation.\n *\n * In addition, for the avoidance of any doubt, permission is granted to\n * link this program with OpenSSL and to (re)distribute the binaries\n * produced as the result of such linking.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with this program; if not, write to the Free Software\n * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.\n */\n#pragma once\n\n#include <string>\n#include <ctime>\n#include <iostream>\n#include <sstream>\n#include <syslog.h>\n\n#include \"namespaces.hh\"\n#include \"dnsname.hh\"\n#include \"iputils.hh\"\n\n//! The Logger class can be used to log messages in various ways.\nclass Logger\n{\npublic:\n  Logger(const string &, int facility=LOG_DAEMON); //!< pass the identification you wish to appear in the log\n\n  //! The urgency of a log message\n  enum Urgency {All=32767,Alert=LOG_ALERT, Critical=LOG_CRIT, Error=LOG_ERR, Warning=LOG_WARNING,\n                Notice=LOG_NOTICE,Info=LOG_INFO, Debug=LOG_DEBUG, None=-1};\n\n  /** Log a message.\n      \\param msg Message you wish to log\n      \\param u Urgency of the message you wish to log\n  */\n  void log(const string &msg, Urgency u=Notice) noexcept;\n\n  void setFacility(int f){d_facility=f;open();} //!< Choose logging facility\n  void setFlag(int f){flags|=f;open();} //!< set a syslog flag\n  void setName(const string &);\n\n  //! set lower limit of urgency needed for console display. Messages of this urgency, and higher, will be displayed\n  void toConsole(Urgency);\n  void setLoglevel( Urgency );\n\n  void disableSyslog(bool d) {\n    d_disableSyslog = d;\n  }\n\n  void setTimestamps(bool t) {\n    d_timestamps = t;\n  }\n\n  void setPrefixed(bool p) {\n    d_prefixed = p;\n  }\n\n  //! Log to a file.\n  void toFile( const string & filename );\n  \n  void resetFlags(){flags=0;open();} //!< zero the flags\n  /** Use this to stream to your log, like this:\n      \\code\n      g_log<<\"This is an informational message\"<<endl; // logged at default loglevel (Info)\n      g_log<<Logger::Warning<<\"Out of diskspace\"<<endl; // Logged as a warning \n      g_log<<\"This is an informational message\"<<endl; // logged AGAIN at default loglevel (Info)\n      \\endcode\n  */\n  Logger& operator<<(const char *s);\n  Logger& operator<<(const string &s);   //!< log a string\n  Logger& operator<<(const DNSName&); \n  Logger& operator<<(const ComboAddress&); //!< log an address\n  Logger& operator<<(Urgency);    //!< set the urgency, << style\n\n  // Using const & since otherwise SyncRes:: values induce (illegal) copies\n  template<typename T> Logger & operator<<(const T & i) {\n\tostringstream tmp;\n\ttmp<<i;\n\t*this<<tmp.str();\n\treturn *this;\n  }\n\n  Logger& operator<<(std::ostream & (&)(std::ostream &)); //!< this is to recognise the endl, and to commit the log\n\nprivate:\n  struct PerThread\n  {\n    PerThread() : d_urgency(Info)\n    {}\n    string d_output;\n    Urgency d_urgency;\n  };\n  PerThread& getPerThread();\n  void open();\n\n  static thread_local PerThread t_perThread;\n  string name;\n  int flags;\n  int d_facility;\n  Urgency d_loglevel;\n  Urgency consoleUrgency;\n  bool opened;\n  bool d_disableSyslog;\n  bool d_timestamps{true};\n  bool d_prefixed{false};\n};\n\nLogger& getLogger();\n\n#define g_log getLogger()\n\n#ifdef VERBOSELOG\n#define DLOG(x) x\n#else\n#define DLOG(x) ((void)0)\n#endif\n"}, "29": {"id": 29, "path": "/home/runner/work/testcc/testcc/retdec/pdns/sstuff.hh", "content": "/*\n * This file is part of PowerDNS or dnsdist.\n * Copyright -- PowerDNS.COM B.V. and its contributors\n *\n * This program is free software; you can redistribute it and/or modify\n * it under the terms of version 2 of the GNU General Public License as\n * published by the Free Software Foundation.\n *\n * In addition, for the avoidance of any doubt, permission is granted to\n * link this program with OpenSSL and to (re)distribute the binaries\n * produced as the result of such linking.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with this program; if not, write to the Free Software\n * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.\n */\n#pragma once\n#include <string>\n#include <sstream>\n#include <iostream>\n#include \"iputils.hh\"\n#include <errno.h>\n#include <sys/types.h>\n#include <unistd.h>\n#include <sys/socket.h>\n#include <netinet/in.h>\n#include <arpa/inet.h>\n#include <sys/select.h>\n#include <fcntl.h>\n#include <stdexcept>\n\n#include <boost/utility.hpp>\n#include <csignal>\n#include \"namespaces.hh\"\n#include \"namespaces.hh\"\n\n\ntypedef int ProtocolType; //!< Supported protocol types\n\n//! Representation of a Socket and many of the Berkeley functions available\nclass Socket : public boost::noncopyable\n{\n  Socket(int fd): d_socket(fd)\n  {\n  }\n\npublic:\n  //! Construct a socket of specified address family and socket type.\n  Socket(int af, int st, ProtocolType pt=0)\n  {\n    if((d_socket=socket(af, st, pt))<0)\n      throw NetworkError(stringerror());\n    setCloseOnExec(d_socket);\n  }\n\n  Socket(Socket&& rhs): d_buffer(std::move(rhs.d_buffer)), d_socket(rhs.d_socket)\n  {\n    rhs.d_socket = -1;\n  }\n\n  ~Socket()\n  {\n    try {\n      if (d_socket != -1) {\n        closesocket(d_socket);\n      }\n    }\n    catch(const PDNSException& e) {\n    }\n  }\n\n  //! If the socket is capable of doing so, this function will wait for a connection\n  std::unique_ptr<Socket> accept()\n  {\n    struct sockaddr_in remote;\n    socklen_t remlen=sizeof(remote);\n    memset(&remote, 0, sizeof(remote));\n    int s=::accept(d_socket, reinterpret_cast<sockaddr *>(&remote), &remlen);\n    if(s<0) {\n      if(errno==EAGAIN)\n        return nullptr;\n\n      throw NetworkError(\"Accepting a connection: \"+stringerror());\n    }\n\n    return std::unique_ptr<Socket>(new Socket(s));\n  }\n\n  //! Get remote address\n  bool getRemote(ComboAddress &remote) {\n    socklen_t remotelen=sizeof(remote);\n    return (getpeername(d_socket, reinterpret_cast<struct sockaddr *>(&remote), &remotelen) >= 0);\n  }\n\n  //! Check remote address against netmaskgroup ng\n  bool acl(const NetmaskGroup &ng)\n  {\n    ComboAddress remote;\n    if (getRemote(remote))\n      return ng.match(remote);\n\n    return false;\n  }\n\n  //! Set the socket to non-blocking\n  void setNonBlocking()\n  {\n    ::setNonBlocking(d_socket);\n  }\n\n  //! Set the socket to blocking\n  void setBlocking()\n  {\n    ::setBlocking(d_socket);\n  }\n\n  void setReuseAddr()\n  {\n    try {\n      ::setReuseAddr(d_socket);\n    } catch (const PDNSException &e) {\n      throw NetworkError(e.reason);\n    }\n  }\n\n  //! Bind the socket to a specified endpoint\n  void bind(const ComboAddress &local, bool reuseaddr=true)\n  {\n    int tmp=1;\n    if(reuseaddr && setsockopt(d_socket, SOL_SOCKET, SO_REUSEADDR, reinterpret_cast<char*>(&tmp), sizeof tmp)<0)\n      throw NetworkError(\"Setsockopt failed: \"+stringerror());\n\n    if(::bind(d_socket, reinterpret_cast<const struct sockaddr *>(&local), local.getSocklen())<0)\n      throw NetworkError(\"While binding: \"+stringerror());\n  }\n\n  //! Connect the socket to a specified endpoint\n  void connect(const ComboAddress &ep, int timeout=0)\n  {\n    SConnectWithTimeout(d_socket, ep, timeout);\n  }\n\n\n  //! For datagram sockets, receive a datagram and learn where it came from\n  /** For datagram sockets, receive a datagram and learn where it came from\n      \\param dgram Will be filled with the datagram\n      \\param ep Will be filled with the origin of the datagram */\n  void recvFrom(string &dgram, ComboAddress &ep)\n  {\n    socklen_t remlen = sizeof(ep);\n    ssize_t bytes;\n    d_buffer.resize(s_buflen);\n    if((bytes=recvfrom(d_socket, &d_buffer[0], s_buflen, 0, reinterpret_cast<sockaddr *>(&ep) , &remlen)) <0)\n      throw NetworkError(\"After recvfrom: \"+stringerror());\n    \n    dgram.assign(d_buffer, 0, static_cast<size_t>(bytes));\n  }\n\n  bool recvFromAsync(string &dgram, ComboAddress &ep)\n  {\n    struct sockaddr_in remote;\n    socklen_t remlen = sizeof(remote);\n    ssize_t bytes;\n    d_buffer.resize(s_buflen);\n    if((bytes=recvfrom(d_socket, &d_buffer[0], s_buflen, 0, reinterpret_cast<sockaddr *>(&remote), &remlen))<0) {\n      if(errno!=EAGAIN) {\n        throw NetworkError(\"After async recvfrom: \"+stringerror());\n      }\n      else {\n        return false;\n      }\n    }\n    dgram.assign(d_buffer, 0, static_cast<size_t>(bytes));\n    return true;\n  }\n\n\n  //! For datagram sockets, send a datagram to a destination\n  void sendTo(const char* msg, size_t len, const ComboAddress &ep)\n  {\n    if(sendto(d_socket, msg, len, 0, reinterpret_cast<const sockaddr *>(&ep), ep.getSocklen())<0)\n      throw NetworkError(\"After sendto: \"+stringerror());\n  }\n\n  //! For connected datagram sockets, send a datagram\n  void send(const std::string& msg)\n  {\n    if(::send(d_socket, msg.c_str(), msg.size(), 0)<0)\n      throw NetworkError(\"After send: \"+stringerror());\n  }\n\n  \n  /** For datagram sockets, send a datagram to a destination\n      \\param dgram The datagram\n      \\param ep The intended destination of the datagram */\n  void sendTo(const string &dgram, const ComboAddress &ep)\n  {\n    sendTo(dgram.c_str(), dgram.length(), ep);\n  }\n\n\n  //! Write this data to the socket, taking care that all bytes are written out \n  void writen(const string &data)\n  {\n    if(data.empty())\n      return;\n\n    size_t toWrite=data.length();\n    ssize_t res;\n    const char *ptr=data.c_str();\n\n    do {\n      res=::send(d_socket, ptr, toWrite, 0);\n      if(res<0) \n        throw NetworkError(\"Writing to a socket: \"+stringerror());\n      if(!res)\n        throw NetworkError(\"EOF on socket\");\n      toWrite -= static_cast<size_t>(res);\n      ptr += static_cast<size_t>(res);\n    } while(toWrite);\n\n  }\n\n  //! tries to write toWrite bytes from ptr to the socket\n  /** tries to write toWrite bytes from ptr to the socket, but does not make sure they al get written out\n      \\param ptr Location to write from\n      \\param toWrite number of bytes to try\n  */\n  size_t tryWrite(const char *ptr, size_t toWrite)\n  {\n    ssize_t res;\n    res=::send(d_socket,ptr,toWrite,0);\n    if(res==0)\n      throw NetworkError(\"EOF on writing to a socket\");\n\n    if(res>0)\n      return res;\n\n    if(errno==EAGAIN)\n      return 0;\n    \n    throw NetworkError(\"Writing to a socket: \"+stringerror());\n  }\n\n  //! Writes toWrite bytes from ptr to the socket\n  /** Writes toWrite bytes from ptr to the socket. Returns how many bytes were written */\n  size_t write(const char *ptr, size_t toWrite)\n  {\n    ssize_t res;\n    res=::send(d_socket,ptr,toWrite,0);\n    if(res<0) {\n      throw NetworkError(\"Writing to a socket: \"+stringerror());\n    }\n    return res;\n  }\n\n  void writenWithTimeout(const void *buffer, size_t n, int timeout)\n  {\n    size_t bytes=n;\n    const char *ptr = reinterpret_cast<const char*>(buffer);\n    ssize_t ret;\n    while(bytes) {\n      ret=::write(d_socket, ptr, bytes);\n      if(ret < 0) {\n        if(errno==EAGAIN) {\n          ret=waitForRWData(d_socket, false, timeout, 0);\n          if(ret < 0)\n            throw NetworkError(\"Waiting for data write\");\n          if(!ret)\n            throw NetworkError(\"Timeout writing data\");\n          continue;\n        }\n        else\n          throw NetworkError(\"Writing data: \"+stringerror());\n      }\n      if(!ret) {\n        throw NetworkError(\"Did not fulfill TCP write due to EOF\");\n      }\n\n      ptr += static_cast<size_t>(ret);\n      bytes -= static_cast<size_t>(ret);\n    }\n  }\n\n  //! reads one character from the socket \n  int getChar()\n  {\n    char c;\n\n    ssize_t res=::recv(d_socket,&c,1,0);\n    if(res)\n      return c;\n    return -1;\n  }\n\n  void getline(string &data)\n  {\n    data=\"\";\n    int c;\n    while((c=getChar())!=-1) {\n      data+=(char)c;\n      if(c=='\\n')\n        break;\n    }\n  }\n\n  //! Reads a block of data from the socket to a string\n  void read(string &data)\n  {\n    d_buffer.resize(s_buflen);\n    ssize_t res=::recv(d_socket, &d_buffer[0], s_buflen, 0);\n    if(res<0) \n      throw NetworkError(\"Reading from a socket: \"+stringerror());\n    data.assign(d_buffer, 0, static_cast<size_t>(res));\n  }\n\n  //! Reads a block of data from the socket to a block of memory\n  size_t read(char *buffer, size_t bytes)\n  {\n    ssize_t res=::recv(d_socket, buffer, bytes, 0);\n    if(res<0) \n      throw NetworkError(\"Reading from a socket: \"+stringerror());\n    return static_cast<size_t>(res);\n  }\n\n  ssize_t readWithTimeout(char* buffer, size_t n, int timeout)\n  {\n    int err = waitForRWData(d_socket, true, timeout, 0);\n\n    if(err == 0)\n      throw NetworkError(\"timeout reading\");\n    if(err < 0)\n      throw NetworkError(\"nonblocking read failed: \"+stringerror());\n\n    return read(buffer, n);\n  }\n\n  //! Sets the socket to listen with a default listen backlog of 10 pending connections \n  void listen(unsigned int length=10)\n  {\n    if(::listen(d_socket,length)<0)\n      throw NetworkError(\"Setting socket to listen: \"+stringerror());\n  }\n\n  //! Returns the internal file descriptor of the socket\n  int getHandle() const\n  {\n    return d_socket;\n  }\n  \nprivate:\n  static const size_t s_buflen{4096};\n  std::string d_buffer;\n  int d_socket;\n};\n"}, "33": {"id": 33, "path": "/home/runner/work/testcc/testcc/retdec/pdns/webserver.cc", "content": "/*\n * This file is part of PowerDNS or dnsdist.\n * Copyright -- PowerDNS.COM B.V. and its contributors\n *\n * This program is free software; you can redistribute it and/or modify\n * it under the terms of version 2 of the GNU General Public License as\n * published by the Free Software Foundation.\n *\n * In addition, for the avoidance of any doubt, permission is granted to\n * link this program with OpenSSL and to (re)distribute the binaries\n * produced as the result of such linking.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with this program; if not, write to the Free Software\n * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.\n */\n#ifdef HAVE_CONFIG_H\n#include \"config.h\"\n#endif\n#include \"utility.hh\"\n#include \"webserver.hh\"\n#include \"misc.hh\"\n#include <thread>\n#include \"threadname.hh\"\n#include <vector>\n#include \"logger.hh\"\n#include <stdio.h>\n#include \"dns.hh\"\n#include \"base64.hh\"\n#include \"json.hh\"\n#include \"uuid-utils.hh\"\n#include <yahttp/router.hpp>\n\njson11::Json HttpRequest::json()\n{\n  string err;\n  if(this->body.empty()) {\n    g_log<<Logger::Debug<<logprefix<<\"JSON document expected in request body, but body was empty\" << endl;\n    throw HttpBadRequestException();\n  }\n  json11::Json doc = json11::Json::parse(this->body, err);\n  if (doc.is_null()) {\n    g_log<<Logger::Debug<<logprefix<<\"parsing of JSON document failed:\" << err << endl;\n    throw HttpBadRequestException();\n  }\n  return doc;\n}\n\nbool HttpRequest::compareAuthorization(const string &expected_password)\n{\n  // validate password\n  YaHTTP::strstr_map_t::iterator header = headers.find(\"authorization\");\n  bool auth_ok = false;\n  if (header != headers.end() && toLower(header->second).find(\"basic \") == 0) {\n    string cookie = header->second.substr(6);\n\n    string plain;\n    B64Decode(cookie, plain);\n\n    vector<string> cparts;\n    stringtok(cparts, plain, \":\");\n\n    // this gets rid of terminating zeros\n    auth_ok = (cparts.size()==2 && (0==strcmp(cparts[1].c_str(), expected_password.c_str())));\n  }\n  return auth_ok;\n}\n\nbool HttpRequest::compareHeader(const string &header_name, const string &expected_value)\n{\n  YaHTTP::strstr_map_t::iterator header = headers.find(header_name);\n  if (header == headers.end())\n    return false;\n\n  // this gets rid of terminating zeros\n  return (0==strcmp(header->second.c_str(), expected_value.c_str()));\n}\n\n\nvoid HttpResponse::setBody(const json11::Json& document)\n{\n  document.dump(this->body);\n}\n\nvoid HttpResponse::setErrorResult(const std::string& message, const int status_)\n{\n  setBody(json11::Json::object { { \"error\", message } });\n  this->status = status_;\n}\n\nvoid HttpResponse::setSuccessResult(const std::string& message, const int status_)\n{\n  setBody(json11::Json::object { { \"result\", message } });\n  this->status = status_;\n}\n\nstatic void bareHandlerWrapper(WebServer::HandlerFunction handler, YaHTTP::Request* req, YaHTTP::Response* resp)\n{\n  // wrapper to convert from YaHTTP::* to our subclasses\n  handler(static_cast<HttpRequest*>(req), static_cast<HttpResponse*>(resp));\n}\n\nvoid WebServer::registerBareHandler(const string& url, HandlerFunction handler)\n{\n  YaHTTP::THandlerFunction f = [=](YaHTTP::Request* req, YaHTTP::Response* resp){return bareHandlerWrapper(handler, req, resp);};\n  YaHTTP::Router::Any(url, f);\n}\n\nstatic bool optionsHandler(HttpRequest* req, HttpResponse* resp) {\n  if (req->method == \"OPTIONS\") {\n    resp->headers[\"access-control-allow-origin\"] = \"*\";\n    resp->headers[\"access-control-allow-headers\"] = \"Content-Type, X-API-Key\";\n    resp->headers[\"access-control-allow-methods\"] = \"GET, POST, PUT, PATCH, DELETE, OPTIONS\";\n    resp->headers[\"access-control-max-age\"] = \"3600\";\n    resp->status = 200;\n    resp->headers[\"content-type\"]= \"text/plain\";\n    resp->body = \"\";\n    return true;\n  }\n  return false;\n}\n\nvoid WebServer::apiWrapper(WebServer::HandlerFunction handler, HttpRequest* req, HttpResponse* resp, bool allowPassword) {\n  if (optionsHandler(req, resp)) return;\n\n  resp->headers[\"access-control-allow-origin\"] = \"*\";\n\n  if (d_apikey.empty()) {\n    g_log<<Logger::Error<<req->logprefix<<\"HTTP API Request \\\"\" << req->url.path << \"\\\": Authentication failed, API Key missing in config\" << endl;\n    throw HttpUnauthorizedException(\"X-API-Key\");\n  }\n\n  bool auth_ok = req->compareHeader(\"x-api-key\", d_apikey) || req->getvars[\"api-key\"] == d_apikey;\n\n  if (!auth_ok && allowPassword) {\n    if (!d_webserverPassword.empty()) {\n      auth_ok = req->compareAuthorization(d_webserverPassword);\n    } else {\n      auth_ok = true;\n    }\n  }\n\n  if (!auth_ok) {\n    g_log<<Logger::Error<<req->logprefix<<\"HTTP Request \\\"\" << req->url.path << \"\\\": Authentication by API Key failed\" << endl;\n    throw HttpUnauthorizedException(\"X-API-Key\");\n  }\n\n  resp->headers[\"Content-Type\"] = \"application/json\";\n\n  // security headers\n  resp->headers[\"X-Content-Type-Options\"] = \"nosniff\";\n  resp->headers[\"X-Frame-Options\"] = \"deny\";\n  resp->headers[\"X-Permitted-Cross-Domain-Policies\"] = \"none\";\n  resp->headers[\"X-XSS-Protection\"] = \"1; mode=block\";\n  resp->headers[\"Content-Security-Policy\"] = \"default-src 'self'; style-src 'self' 'unsafe-inline'\";\n\n  req->getvars.erase(\"_\"); // jQuery cache buster\n\n  try {\n    resp->status = 200;\n    handler(req, resp);\n  } catch (ApiException &e) {\n    resp->setErrorResult(e.what(), 422);\n    return;\n  } catch (JsonException &e) {\n    resp->setErrorResult(e.what(), 422);\n    return;\n  }\n\n  if (resp->status == 204) {\n    // No Content -> no Content-Type.\n    resp->headers.erase(\"Content-Type\");\n  }\n}\n\nvoid WebServer::registerApiHandler(const string& url, HandlerFunction handler, bool allowPassword) {\n  HandlerFunction f = std::bind(&WebServer::apiWrapper, this, handler, std::placeholders::_1, std::placeholders::_2, allowPassword);\n  registerBareHandler(url, f);\n}\n\nvoid WebServer::webWrapper(WebServer::HandlerFunction handler, HttpRequest* req, HttpResponse* resp) {\n  if (!d_webserverPassword.empty()) {\n    bool auth_ok = req->compareAuthorization(d_webserverPassword);\n    if (!auth_ok) {\n      g_log<<Logger::Debug<<req->logprefix<<\"HTTP Request \\\"\" << req->url.path << \"\\\": Web Authentication failed\" << endl;\n      throw HttpUnauthorizedException(\"Basic\");\n    }\n  }\n\n  handler(req, resp);\n}\n\nvoid WebServer::registerWebHandler(const string& url, HandlerFunction handler) {\n  HandlerFunction f = std::bind(&WebServer::webWrapper, this, handler, std::placeholders::_1, std::placeholders::_2);\n  registerBareHandler(url, f);\n}\n\nstatic void *WebServerConnectionThreadStart(const WebServer* webServer, std::shared_ptr<Socket> client) {\n  setThreadName(\"pdns-r/webhndlr\");\n  try {\n    webServer->serveConnection(client);\n  }\n  catch(PDNSException &e) {\n    g_log<<Logger::Error<<\"PDNSException while serving a connection in main webserver thread: \"<<e.reason<<endl;\n  }\n  catch(std::exception &e) {\n    g_log<<Logger::Error<<\"STL Exception while serving a connection in main webserver thread: \"<<e.what()<<endl;\n  }\n  catch(...) {\n    g_log<<Logger::Error<<\"Unknown exception while serving a connection in main webserver thread\"<<endl;\n  }\n  return nullptr;\n}\n\nvoid WebServer::handleRequest(HttpRequest& req, HttpResponse& resp) const\n{\n  // set default headers\n  resp.headers[\"Content-Type\"] = \"text/html; charset=utf-8\";\n\n  try {\n    if (!req.complete) {\n      g_log<<Logger::Debug<<req.logprefix<<\"Incomplete request\" << endl;\n      throw HttpBadRequestException();\n    }\n\n    g_log<<Logger::Debug<<req.logprefix<<\"Handling request \\\"\" << req.url.path << \"\\\"\" << endl;\n\n    YaHTTP::strstr_map_t::iterator header;\n\n    if ((header = req.headers.find(\"accept\")) != req.headers.end()) {\n      // json wins over html\n      if (header->second.find(\"application/json\") != std::string::npos) {\n        req.accept_json = true;\n      } else if (header->second.find(\"text/html\") != std::string::npos) {\n        req.accept_html = true;\n      }\n    }\n\n    YaHTTP::THandlerFunction handler;\n    if (!YaHTTP::Router::Route(&req, handler)) {\n      g_log<<Logger::Debug<<req.logprefix<<\"No route found for \\\"\" << req.url.path << \"\\\"\" << endl;\n      throw HttpNotFoundException();\n    }\n\n    try {\n      handler(&req, &resp);\n      g_log<<Logger::Debug<<req.logprefix<<\"Result for \\\"\" << req.url.path << \"\\\": \" << resp.status << \", body length: \" << resp.body.size() << endl;\n    }\n    catch(HttpException&) {\n      throw;\n    }\n    catch(PDNSException &e) {\n      g_log<<Logger::Error<<req.logprefix<<\"HTTP ISE for \\\"\"<< req.url.path << \"\\\": Exception: \" << e.reason << endl;\n      throw HttpInternalServerErrorException();\n    }\n    catch(std::exception &e) {\n      g_log<<Logger::Error<<req.logprefix<<\"HTTP ISE for \\\"\"<< req.url.path << \"\\\": STL Exception: \" << e.what() << endl;\n      throw HttpInternalServerErrorException();\n    }\n    catch(...) {\n      g_log<<Logger::Error<<req.logprefix<<\"HTTP ISE for \\\"\"<< req.url.path << \"\\\": Unknown Exception\" << endl;\n      throw HttpInternalServerErrorException();\n    }\n  }\n  catch(HttpException &e) {\n    resp = e.response();\n    // TODO rm this logline?\n    g_log<<Logger::Debug<<req.logprefix<<\"Error result for \\\"\" << req.url.path << \"\\\": \" << resp.status << endl;\n    string what = YaHTTP::Utility::status2text(resp.status);\n    if(req.accept_html) {\n      resp.headers[\"Content-Type\"] = \"text/html; charset=utf-8\";\n      resp.body = \"<!html><title>\" + what + \"</title><h1>\" + what + \"</h1>\";\n    } else if (req.accept_json) {\n      resp.headers[\"Content-Type\"] = \"application/json\";\n      if (resp.body.empty()) {\n        resp.setErrorResult(what, resp.status);\n      }\n    } else {\n      resp.headers[\"Content-Type\"] = \"text/plain; charset=utf-8\";\n      resp.body = what;\n    }\n  }\n\n  // always set these headers\n  resp.headers[\"Server\"] = \"PowerDNS/\" VERSION;\n  resp.headers[\"Connection\"] = \"close\";\n\n  if (req.method == \"HEAD\") {\n    resp.body = \"\";\n  } else {\n    resp.headers[\"Content-Length\"] = std::to_string(resp.body.size());\n  }\n}\n\nvoid WebServer::logRequest(const HttpRequest& req, const ComboAddress& remote) const {\n  if (d_loglevel >= WebServer::LogLevel::Detailed) {\n    auto logprefix = req.logprefix;\n    g_log<<Logger::Notice<<logprefix<<\"Request details:\"<<endl;\n\n    bool first = true;\n    for (const auto& r : req.getvars) {\n      if (first) {\n        first = false;\n        g_log<<Logger::Notice<<logprefix<<\" GET params:\"<<endl;\n      }\n      g_log<<Logger::Notice<<logprefix<<\"  \"<<r.first<<\": \"<<r.second<<endl;\n    }\n\n    first = true;\n    for (const auto& r : req.postvars) {\n      if (first) {\n        first = false;\n        g_log<<Logger::Notice<<logprefix<<\" POST params:\"<<endl;\n      }\n      g_log<<Logger::Notice<<logprefix<<\"  \"<<r.first<<\": \"<<r.second<<endl;\n    }\n\n    first = true;\n    for (const auto& h : req.headers) {\n      if (first) {\n        first = false;\n        g_log<<Logger::Notice<<logprefix<<\" Headers:\"<<endl;\n      }\n      g_log<<Logger::Notice<<logprefix<<\"  \"<<h.first<<\": \"<<h.second<<endl;\n    }\n\n    if (req.body.empty()) {\n      g_log<<Logger::Notice<<logprefix<<\" No body\"<<endl;\n    } else {\n      g_log<<Logger::Notice<<logprefix<<\" Full body: \"<<endl;\n      g_log<<Logger::Notice<<logprefix<<\"  \"<<req.body<<endl;\n    }\n  }\n}\n\nvoid WebServer::logResponse(const HttpResponse& resp, const ComboAddress& remote, const string& logprefix) const {\n  if (d_loglevel >= WebServer::LogLevel::Detailed) {\n    g_log<<Logger::Notice<<logprefix<<\"Response details:\"<<endl;\n    bool first = true;\n    for (const auto& h : resp.headers) {\n      if (first) {\n        first = false;\n        g_log<<Logger::Notice<<logprefix<<\" Headers:\"<<endl;\n      }\n      g_log<<Logger::Notice<<logprefix<<\"  \"<<h.first<<\": \"<<h.second<<endl;\n    }\n    if (resp.body.empty()) {\n      g_log<<Logger::Notice<<logprefix<<\" No body\"<<endl;\n    } else {\n      g_log<<Logger::Notice<<logprefix<<\" Full body: \"<<endl;\n      g_log<<Logger::Notice<<logprefix<<\"  \"<<resp.body<<endl;\n    }\n  }\n}\n\nvoid WebServer::serveConnection(std::shared_ptr<Socket> client) const {\n  const string logprefix = d_logprefix + to_string(getUniqueID()) + \" \";\n\n  HttpRequest req(logprefix);\n  HttpResponse resp;\n  resp.max_response_size=d_maxbodysize;\n  ComboAddress remote;\n  string reply;\n\n  try {\n    YaHTTP::AsyncRequestLoader yarl;\n    yarl.initialize(&req);\n    req.max_request_size=d_maxbodysize;\n    int timeout = 5;\n    client->setNonBlocking();\n\n    try {\n      while(!req.complete) {\n        int bytes;\n        char buf[16000];\n        bytes = client->readWithTimeout(buf, sizeof(buf), timeout);\n        if (bytes > 0) {\n          string data = string(buf, bytes);\n          req.complete = yarl.feed(data);\n        } else {\n          // read error OR EOF\n          break;\n        }\n      }\n      yarl.finalize();\n    } catch (YaHTTP::ParseError &e) {\n      // request stays incomplete\n      g_log<<Logger::Warning<<logprefix<<\"Unable to parse request: \"<<e.what()<<endl;\n    }\n\n    if (d_loglevel >= WebServer::LogLevel::None) {\n      client->getRemote(remote);\n    }\n\n    logRequest(req, remote);\n\n    WebServer::handleRequest(req, resp);\n    ostringstream ss;\n    resp.write(ss);\n    reply = ss.str();\n\n    logResponse(resp, remote, logprefix);\n\n    client->writenWithTimeout(reply.c_str(), reply.size(), timeout);\n  }\n  catch(PDNSException &e) {\n    g_log<<Logger::Error<<logprefix<<\"HTTP Exception: \"<<e.reason<<endl;\n  }\n  catch(std::exception &e) {\n    if(strstr(e.what(), \"timeout\")==0)\n      g_log<<Logger::Error<<logprefix<<\"HTTP STL Exception: \"<<e.what()<<endl;\n  }\n  catch(...) {\n    g_log<<Logger::Error<<logprefix<<\"Unknown exception\"<<endl;\n  }\n\n  if (d_loglevel >= WebServer::LogLevel::Normal) {\n    g_log<<Logger::Notice<<logprefix<<remote<<\" \\\"\"<<req.method<<\" \"<<req.url.path<<\" HTTP/\"<<req.versionStr(req.version)<<\"\\\" \"<<resp.status<<\" \"<<reply.size()<<endl;\n  }\n}\n\nWebServer::WebServer(const string &listenaddress, int port) :\n  d_listenaddress(listenaddress),\n  d_port(port),\n  d_server(nullptr),\n  d_maxbodysize(2*1024*1024)\n{\n}\n\nvoid WebServer::bind()\n{\n  try {\n    d_server = createServer();\n    g_log<<Logger::Warning<<d_logprefix<<\"Listening for HTTP requests on \"<<d_server->d_local.toStringWithPort()<<endl;\n  }\n  catch(NetworkError &e) {\n    g_log<<Logger::Error<<d_logprefix<<\"Listening on HTTP socket failed: \"<<e.what()<<endl;\n    d_server = nullptr;\n  }\n}\n\nvoid WebServer::go()\n{\n  if(!d_server)\n    return;\n  try {\n    while(true) {\n      try {\n        auto client = d_server->accept();\n        if (!client) {\n          continue;\n        }\n        if (client->acl(d_acl)) {\n          std::thread webHandler(WebServerConnectionThreadStart, this, client);\n          webHandler.detach();\n        } else {\n          ComboAddress remote;\n          if (client->getRemote(remote))\n            g_log<<Logger::Error<<d_logprefix<<\"Webserver closing socket: remote (\"<< remote.toString() <<\") does not match the set ACL(\"<<d_acl.toString()<<\")\"<<endl;\n        }\n      }\n      catch(PDNSException &e) {\n        g_log<<Logger::Error<<d_logprefix<<\"PDNSException while accepting a connection in main webserver thread: \"<<e.reason<<endl;\n      }\n      catch(std::exception &e) {\n        g_log<<Logger::Error<<d_logprefix<<\"STL Exception while accepting a connection in main webserver thread: \"<<e.what()<<endl;\n      }\n      catch(...) {\n        g_log<<Logger::Error<<d_logprefix<<\"Unknown exception while accepting a connection in main webserver thread\"<<endl;\n      }\n    }\n  }\n  catch(PDNSException &e) {\n    g_log<<Logger::Error<<d_logprefix<<\"PDNSException in main webserver thread: \"<<e.reason<<endl;\n  }\n  catch(std::exception &e) {\n    g_log<<Logger::Error<<d_logprefix<<\"STL Exception in main webserver thread: \"<<e.what()<<endl;\n  }\n  catch(...) {\n    g_log<<Logger::Error<<d_logprefix<<\"Unknown exception in main webserver thread\"<<endl;\n  }\n  _exit(1);\n}\n"}, "34": {"id": 34, "path": "/home/runner/work/testcc/testcc/retdec/pdns/webserver.hh", "content": "/*\n * This file is part of PowerDNS or dnsdist.\n * Copyright -- PowerDNS.COM B.V. and its contributors\n *\n * This program is free software; you can redistribute it and/or modify\n * it under the terms of version 2 of the GNU General Public License as\n * published by the Free Software Foundation.\n *\n * In addition, for the avoidance of any doubt, permission is granted to\n * link this program with OpenSSL and to (re)distribute the binaries\n * produced as the result of such linking.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with this program; if not, write to the Free Software\n * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.\n */\n#pragma once\n#include <map>\n#include <string>\n#include <list>\n#include <boost/utility.hpp>\n#include <yahttp/yahttp.hpp>\n#include \"json11.hpp\"\n#include \"namespaces.hh\"\n#include \"sstuff.hh\"\n\nclass HttpRequest : public YaHTTP::Request {\npublic:\n  HttpRequest(const string& logprefix_=\"\") : YaHTTP::Request(), accept_json(false), accept_html(false), complete(false), logprefix(logprefix_) { };\n\n  bool accept_json;\n  bool accept_html;\n  bool complete;\n  string logprefix;\n  json11::Json json();\n\n  // checks password _only_.\n  bool compareAuthorization(const string &expected_password);\n  bool compareHeader(const string &header_name, const string &expected_value);\n};\n\nclass HttpResponse: public YaHTTP::Response {\npublic:\n  HttpResponse() : YaHTTP::Response() { };\n  HttpResponse(const YaHTTP::Response &resp) : YaHTTP::Response(resp) { };\n\n  void setBody(const json11::Json& document);\n  void setErrorResult(const std::string& message, const int status);\n  void setSuccessResult(const std::string& message, const int status = 200);\n};\n\n\nclass HttpException\n{\npublic:\n  HttpException(int status) : d_response()\n  {\n    d_response.status = status;\n  };\n\n  HttpException(int status, const string& msg) : d_response()\n  {\n    d_response.setErrorResult(msg, status);\n  };\n\n  HttpResponse response()\n  {\n    return d_response;\n  }\n\nprotected:\n  HttpResponse d_response;\n};\n\nclass HttpBadRequestException : public HttpException {\npublic:\n  HttpBadRequestException() : HttpException(400) { };\n  HttpBadRequestException(const string& msg) : HttpException(400, msg) { };\n};\n\nclass HttpUnauthorizedException : public HttpException {\npublic:\n  HttpUnauthorizedException(string const &scheme) : HttpException(401)\n  {\n    d_response.headers[\"WWW-Authenticate\"] = scheme + \" realm=\\\"PowerDNS\\\"\";\n  }\n};\n\nclass HttpForbiddenException : public HttpException {\npublic:\n  HttpForbiddenException() : HttpException(403) { };\n  HttpForbiddenException(const string& msg) : HttpException(403, msg) { };\n};\n\nclass HttpNotFoundException : public HttpException {\npublic:\n  HttpNotFoundException() : HttpException(404) { };\n  HttpNotFoundException(const string& msg) : HttpException(404, msg) { };\n};\n\nclass HttpMethodNotAllowedException : public HttpException {\npublic:\n  HttpMethodNotAllowedException() : HttpException(405) { };\n  HttpMethodNotAllowedException(const string& msg) : HttpException(405, msg) { };\n};\n\nclass HttpConflictException : public HttpException {\npublic:\n  HttpConflictException() : HttpException(409) { };\n  HttpConflictException(const string& msg) : HttpException(409, msg) { };\n};\n\nclass HttpInternalServerErrorException : public HttpException {\npublic:\n  HttpInternalServerErrorException() : HttpException(500) { };\n  HttpInternalServerErrorException(const string& msg) : HttpException(500, msg) { };\n};\n\nclass ApiException : public runtime_error\n{\npublic:\n  ApiException(const string& what_arg) : runtime_error(what_arg) {\n  }\n};\n\nclass Server\n{\npublic:\n  Server(const string &localaddress, int port) : d_local(localaddress.empty() ? \"0.0.0.0\" : localaddress, port), d_server_socket(d_local.sin4.sin_family, SOCK_STREAM, 0) {\n    d_server_socket.setReuseAddr();\n    d_server_socket.bind(d_local);\n    d_server_socket.listen();\n  }\n  virtual ~Server() { };\n\n  ComboAddress d_local;\n\n  std::shared_ptr<Socket> accept() {\n    return std::shared_ptr<Socket>(d_server_socket.accept());\n  }\n\nprotected:\n  Socket d_server_socket;\n};\n\nclass WebServer : public boost::noncopyable\n{\npublic:\n  WebServer(const string &listenaddress, int port);\n  virtual ~WebServer() { };\n\n  void setApiKey(const string &apikey) {\n    d_apikey = apikey;\n  }\n\n  void setPassword(const string &password) {\n    d_webserverPassword = password;\n  }\n\n  void setMaxBodySize(ssize_t s) { // in megabytes\n    d_maxbodysize = s * 1024 * 1024;\n  }\n\n  void setACL(const NetmaskGroup &nmg) {\n    d_acl = nmg;\n  }\n\n  void bind();\n  void go();\n\n  void serveConnection(std::shared_ptr<Socket> client) const;\n  void handleRequest(HttpRequest& request, HttpResponse& resp) const;\n\n  typedef boost::function<void(HttpRequest* req, HttpResponse* resp)> HandlerFunction;\n  void registerApiHandler(const string& url, HandlerFunction handler, bool allowPassword=false);\n  void registerWebHandler(const string& url, HandlerFunction handler);\n\n  enum class LogLevel : uint8_t {\n    None = 0,                // No logs from requests at all\n    Normal = 10,             // A \"common log format\"-like line e.g. '127.0.0.1 \"GET /apache_pb.gif HTTP/1.0\" 200 2326'\n    Detailed = 20,           // The full request headers and body, and the full response headers and body\n  };\n\n  void setLogLevel(const string& level) {\n    if (level == \"none\") {\n      d_loglevel = LogLevel::None;\n      return;\n    }\n\n    if (level == \"normal\") {\n      d_loglevel = LogLevel::Normal;\n      return;\n    }\n\n    if (level == \"detailed\") {\n      d_loglevel = LogLevel::Detailed;\n      return;\n    }\n\n    throw PDNSException(\"Unknown webserver log level: \" + level);\n  }\n\n  void setLogLevel(const LogLevel level) {\n    d_loglevel = level;\n  };\n\n  LogLevel getLogLevel() {\n    return d_loglevel;\n  };\n\nprotected:\n  void registerBareHandler(const string& url, HandlerFunction handler);\n  void logRequest(const HttpRequest& req, const ComboAddress& remote) const;\n  void logResponse(const HttpResponse& resp, const ComboAddress& remote, const string& logprefix) const;\n\n  virtual std::shared_ptr<Server> createServer() {\n    return std::make_shared<Server>(d_listenaddress, d_port);\n  }\n\n  string d_listenaddress;\n  int d_port;\n  string d_password;\n  std::shared_ptr<Server> d_server;\n\n  std::string d_apikey;\n  void apiWrapper(WebServer::HandlerFunction handler, HttpRequest* req, HttpResponse* resp, bool allowPassword);\n  std::string d_webserverPassword;\n  void webWrapper(WebServer::HandlerFunction handler, HttpRequest* req, HttpResponse* resp);\n\n  ssize_t d_maxbodysize; // in bytes\n\n  NetmaskGroup d_acl;\n\n  const string d_logprefix = \"[webserver] \";\n\n  // Describes the amount of logging the webserver does\n  WebServer::LogLevel d_loglevel{WebServer::LogLevel::Detailed};\n};\n"}, "35": {"id": 35, "path": "/usr/include/c++/7/bits/stl_map.h", "content": "// Map implementation -*- C++ -*-\n\n// Copyright (C) 2001-2017 Free Software Foundation, Inc.\n//\n// This file is part of the GNU ISO C++ Library.  This library is free\n// software; you can redistribute it and/or modify it under the\n// terms of the GNU General Public License as published by the\n// Free Software Foundation; either version 3, or (at your option)\n// any later version.\n\n// This library is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n\n// Under Section 7 of GPL version 3, you are granted additional\n// permissions described in the GCC Runtime Library Exception, version\n// 3.1, as published by the Free Software Foundation.\n\n// You should have received a copy of the GNU General Public License and\n// a copy of the GCC Runtime Library Exception along with this program;\n// see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n// <http://www.gnu.org/licenses/>.\n\n/*\n *\n * Copyright (c) 1994\n * Hewlett-Packard Company\n *\n * Permission to use, copy, modify, distribute and sell this software\n * and its documentation for any purpose is hereby granted without fee,\n * provided that the above copyright notice appear in all copies and\n * that both that copyright notice and this permission notice appear\n * in supporting documentation.  Hewlett-Packard Company makes no\n * representations about the suitability of this software for any\n * purpose.  It is provided \"as is\" without express or implied warranty.\n *\n *\n * Copyright (c) 1996,1997\n * Silicon Graphics Computer Systems, Inc.\n *\n * Permission to use, copy, modify, distribute and sell this software\n * and its documentation for any purpose is hereby granted without fee,\n * provided that the above copyright notice appear in all copies and\n * that both that copyright notice and this permission notice appear\n * in supporting documentation.  Silicon Graphics makes no\n * representations about the suitability of this software for any\n * purpose.  It is provided \"as is\" without express or implied warranty.\n */\n\n/** @file bits/stl_map.h\n *  This is an internal header file, included by other library headers.\n *  Do not attempt to use it directly. @headername{map}\n */\n\n#ifndef _STL_MAP_H\n#define _STL_MAP_H 1\n\n#include <bits/functexcept.h>\n#include <bits/concept_check.h>\n#if __cplusplus >= 201103L\n#include <initializer_list>\n#include <tuple>\n#endif\n\nnamespace std _GLIBCXX_VISIBILITY(default)\n{\n_GLIBCXX_BEGIN_NAMESPACE_CONTAINER\n\n  template <typename _Key, typename _Tp, typename _Compare, typename _Alloc>\n    class multimap;\n\n  /**\n   *  @brief A standard container made up of (key,value) pairs, which can be\n   *  retrieved based on a key, in logarithmic time.\n   *\n   *  @ingroup associative_containers\n   *\n   *  @tparam _Key  Type of key objects.\n   *  @tparam  _Tp  Type of mapped objects.\n   *  @tparam _Compare  Comparison function object type, defaults to less<_Key>.\n   *  @tparam _Alloc  Allocator type, defaults to\n   *                  allocator<pair<const _Key, _Tp>.\n   *\n   *  Meets the requirements of a <a href=\"tables.html#65\">container</a>, a\n   *  <a href=\"tables.html#66\">reversible container</a>, and an\n   *  <a href=\"tables.html#69\">associative container</a> (using unique keys).\n   *  For a @c map<Key,T> the key_type is Key, the mapped_type is T, and the\n   *  value_type is std::pair<const Key,T>.\n   *\n   *  Maps support bidirectional iterators.\n   *\n   *  The private tree data is declared exactly the same way for map and\n   *  multimap; the distinction is made entirely in how the tree functions are\n   *  called (*_unique versus *_equal, same as the standard).\n  */\n  template <typename _Key, typename _Tp, typename _Compare = std::less<_Key>,\n\t    typename _Alloc = std::allocator<std::pair<const _Key, _Tp> > >\n    class map\n    {\n    public:\n      typedef _Key\t\t\t\t\tkey_type;\n      typedef _Tp\t\t\t\t\tmapped_type;\n      typedef std::pair<const _Key, _Tp>\t\tvalue_type;\n      typedef _Compare\t\t\t\t\tkey_compare;\n      typedef _Alloc\t\t\t\t\tallocator_type;\n\n    private:\n#ifdef _GLIBCXX_CONCEPT_CHECKS\n      // concept requirements\n      typedef typename _Alloc::value_type\t\t_Alloc_value_type;\n# if __cplusplus < 201103L\n      __glibcxx_class_requires(_Tp, _SGIAssignableConcept)\n# endif\n      __glibcxx_class_requires4(_Compare, bool, _Key, _Key,\n\t\t\t\t_BinaryFunctionConcept)\n      __glibcxx_class_requires2(value_type, _Alloc_value_type, _SameTypeConcept)\n#endif\n\n    public:\n      class value_compare\n      : public std::binary_function<value_type, value_type, bool>\n      {\n\tfriend class map<_Key, _Tp, _Compare, _Alloc>;\n      protected:\n\t_Compare comp;\n\n\tvalue_compare(_Compare __c)\n\t: comp(__c) { }\n\n      public:\n\tbool operator()(const value_type& __x, const value_type& __y) const\n\t{ return comp(__x.first, __y.first); }\n      };\n\n    private:\n      /// This turns a red-black tree into a [multi]map.\n      typedef typename __gnu_cxx::__alloc_traits<_Alloc>::template\n\trebind<value_type>::other _Pair_alloc_type;\n\n      typedef _Rb_tree<key_type, value_type, _Select1st<value_type>,\n\t\t       key_compare, _Pair_alloc_type> _Rep_type;\n\n      /// The actual tree structure.\n      _Rep_type _M_t;\n\n      typedef __gnu_cxx::__alloc_traits<_Pair_alloc_type> _Alloc_traits;\n\n    public:\n      // many of these are specified differently in ISO, but the following are\n      // \"functionally equivalent\"\n      typedef typename _Alloc_traits::pointer\t\t pointer;\n      typedef typename _Alloc_traits::const_pointer\t const_pointer;\n      typedef typename _Alloc_traits::reference\t\t reference;\n      typedef typename _Alloc_traits::const_reference\t const_reference;\n      typedef typename _Rep_type::iterator\t\t iterator;\n      typedef typename _Rep_type::const_iterator\t const_iterator;\n      typedef typename _Rep_type::size_type\t\t size_type;\n      typedef typename _Rep_type::difference_type\t difference_type;\n      typedef typename _Rep_type::reverse_iterator\t reverse_iterator;\n      typedef typename _Rep_type::const_reverse_iterator const_reverse_iterator;\n\n#if __cplusplus > 201402L\n      using node_type = typename _Rep_type::node_type;\n      using insert_return_type = typename _Rep_type::insert_return_type;\n#endif\n\n      // [23.3.1.1] construct/copy/destroy\n      // (get_allocator() is also listed in this section)\n\n      /**\n       *  @brief  Default constructor creates no elements.\n       */\n#if __cplusplus < 201103L\n      map() : _M_t() { }\n#else\n      map() = default;\n#endif\n\n      /**\n       *  @brief  Creates a %map with no elements.\n       *  @param  __comp  A comparison object.\n       *  @param  __a  An allocator object.\n       */\n      explicit\n      map(const _Compare& __comp,\n\t  const allocator_type& __a = allocator_type())\n      : _M_t(__comp, _Pair_alloc_type(__a)) { }\n\n      /**\n       *  @brief  %Map copy constructor.\n       *\n       *  Whether the allocator is copied depends on the allocator traits.\n       */\n#if __cplusplus < 201103L\n      map(const map& __x)\n      : _M_t(__x._M_t) { }\n#else\n      map(const map&) = default;\n\n      /**\n       *  @brief  %Map move constructor.\n       *\n       *  The newly-created %map contains the exact contents of the moved\n       *  instance. The moved instance is a valid, but unspecified, %map.\n       */\n      map(map&&) = default;\n\n      /**\n       *  @brief  Builds a %map from an initializer_list.\n       *  @param  __l  An initializer_list.\n       *  @param  __comp  A comparison object.\n       *  @param  __a  An allocator object.\n       *\n       *  Create a %map consisting of copies of the elements in the\n       *  initializer_list @a __l.\n       *  This is linear in N if the range is already sorted, and NlogN\n       *  otherwise (where N is @a __l.size()).\n       */\n      map(initializer_list<value_type> __l,\n\t  const _Compare& __comp = _Compare(),\n\t  const allocator_type& __a = allocator_type())\n      : _M_t(__comp, _Pair_alloc_type(__a))\n      { _M_t._M_insert_unique(__l.begin(), __l.end()); }\n\n      /// Allocator-extended default constructor.\n      explicit\n      map(const allocator_type& __a)\n      : _M_t(_Compare(), _Pair_alloc_type(__a)) { }\n\n      /// Allocator-extended copy constructor.\n      map(const map& __m, const allocator_type& __a)\n      : _M_t(__m._M_t, _Pair_alloc_type(__a)) { }\n\n      /// Allocator-extended move constructor.\n      map(map&& __m, const allocator_type& __a)\n      noexcept(is_nothrow_copy_constructible<_Compare>::value\n\t       && _Alloc_traits::_S_always_equal())\n      : _M_t(std::move(__m._M_t), _Pair_alloc_type(__a)) { }\n\n      /// Allocator-extended initialier-list constructor.\n      map(initializer_list<value_type> __l, const allocator_type& __a)\n      : _M_t(_Compare(), _Pair_alloc_type(__a))\n      { _M_t._M_insert_unique(__l.begin(), __l.end()); }\n\n      /// Allocator-extended range constructor.\n      template<typename _InputIterator>\n\tmap(_InputIterator __first, _InputIterator __last,\n\t    const allocator_type& __a)\n\t: _M_t(_Compare(), _Pair_alloc_type(__a))\n\t{ _M_t._M_insert_unique(__first, __last); }\n#endif\n\n      /**\n       *  @brief  Builds a %map from a range.\n       *  @param  __first  An input iterator.\n       *  @param  __last  An input iterator.\n       *\n       *  Create a %map consisting of copies of the elements from\n       *  [__first,__last).  This is linear in N if the range is\n       *  already sorted, and NlogN otherwise (where N is\n       *  distance(__first,__last)).\n       */\n      template<typename _InputIterator>\n\tmap(_InputIterator __first, _InputIterator __last)\n\t: _M_t()\n\t{ _M_t._M_insert_unique(__first, __last); }\n\n      /**\n       *  @brief  Builds a %map from a range.\n       *  @param  __first  An input iterator.\n       *  @param  __last  An input iterator.\n       *  @param  __comp  A comparison functor.\n       *  @param  __a  An allocator object.\n       *\n       *  Create a %map consisting of copies of the elements from\n       *  [__first,__last).  This is linear in N if the range is\n       *  already sorted, and NlogN otherwise (where N is\n       *  distance(__first,__last)).\n       */\n      template<typename _InputIterator>\n\tmap(_InputIterator __first, _InputIterator __last,\n\t    const _Compare& __comp,\n\t    const allocator_type& __a = allocator_type())\n\t: _M_t(__comp, _Pair_alloc_type(__a))\n\t{ _M_t._M_insert_unique(__first, __last); }\n\n#if __cplusplus >= 201103L\n      /**\n       *  The dtor only erases the elements, and note that if the elements\n       *  themselves are pointers, the pointed-to memory is not touched in any\n       *  way.  Managing the pointer is the user's responsibility.\n       */\n      ~map() = default;\n#endif\n\n      /**\n       *  @brief  %Map assignment operator.\n       *\n       *  Whether the allocator is copied depends on the allocator traits.\n       */\n#if __cplusplus < 201103L\n      map&\n      operator=(const map& __x)\n      {\n\t_M_t = __x._M_t;\n\treturn *this;\n      }\n#else\n      map&\n      operator=(const map&) = default;\n\n      /// Move assignment operator.\n      map&\n      operator=(map&&) = default;\n\n      /**\n       *  @brief  %Map list assignment operator.\n       *  @param  __l  An initializer_list.\n       *\n       *  This function fills a %map with copies of the elements in the\n       *  initializer list @a __l.\n       *\n       *  Note that the assignment completely changes the %map and\n       *  that the resulting %map's size is the same as the number\n       *  of elements assigned.\n       */\n      map&\n      operator=(initializer_list<value_type> __l)\n      {\n\t_M_t._M_assign_unique(__l.begin(), __l.end());\n\treturn *this;\n      }\n#endif\n\n      /// Get a copy of the memory allocation object.\n      allocator_type\n      get_allocator() const _GLIBCXX_NOEXCEPT\n      { return allocator_type(_M_t.get_allocator()); }\n\n      // iterators\n      /**\n       *  Returns a read/write iterator that points to the first pair in the\n       *  %map.\n       *  Iteration is done in ascending order according to the keys.\n       */\n      iterator\n      begin() _GLIBCXX_NOEXCEPT\n      { return _M_t.begin(); }\n\n      /**\n       *  Returns a read-only (constant) iterator that points to the first pair\n       *  in the %map.  Iteration is done in ascending order according to the\n       *  keys.\n       */\n      const_iterator\n      begin() const _GLIBCXX_NOEXCEPT\n      { return _M_t.begin(); }\n\n      /**\n       *  Returns a read/write iterator that points one past the last\n       *  pair in the %map.  Iteration is done in ascending order\n       *  according to the keys.\n       */\n      iterator\n      end() _GLIBCXX_NOEXCEPT\n      { return _M_t.end(); }\n\n      /**\n       *  Returns a read-only (constant) iterator that points one past the last\n       *  pair in the %map.  Iteration is done in ascending order according to\n       *  the keys.\n       */\n      const_iterator\n      end() const _GLIBCXX_NOEXCEPT\n      { return _M_t.end(); }\n\n      /**\n       *  Returns a read/write reverse iterator that points to the last pair in\n       *  the %map.  Iteration is done in descending order according to the\n       *  keys.\n       */\n      reverse_iterator\n      rbegin() _GLIBCXX_NOEXCEPT\n      { return _M_t.rbegin(); }\n\n      /**\n       *  Returns a read-only (constant) reverse iterator that points to the\n       *  last pair in the %map.  Iteration is done in descending order\n       *  according to the keys.\n       */\n      const_reverse_iterator\n      rbegin() const _GLIBCXX_NOEXCEPT\n      { return _M_t.rbegin(); }\n\n      /**\n       *  Returns a read/write reverse iterator that points to one before the\n       *  first pair in the %map.  Iteration is done in descending order\n       *  according to the keys.\n       */\n      reverse_iterator\n      rend() _GLIBCXX_NOEXCEPT\n      { return _M_t.rend(); }\n\n      /**\n       *  Returns a read-only (constant) reverse iterator that points to one\n       *  before the first pair in the %map.  Iteration is done in descending\n       *  order according to the keys.\n       */\n      const_reverse_iterator\n      rend() const _GLIBCXX_NOEXCEPT\n      { return _M_t.rend(); }\n\n#if __cplusplus >= 201103L\n      /**\n       *  Returns a read-only (constant) iterator that points to the first pair\n       *  in the %map.  Iteration is done in ascending order according to the\n       *  keys.\n       */\n      const_iterator\n      cbegin() const noexcept\n      { return _M_t.begin(); }\n\n      /**\n       *  Returns a read-only (constant) iterator that points one past the last\n       *  pair in the %map.  Iteration is done in ascending order according to\n       *  the keys.\n       */\n      const_iterator\n      cend() const noexcept\n      { return _M_t.end(); }\n\n      /**\n       *  Returns a read-only (constant) reverse iterator that points to the\n       *  last pair in the %map.  Iteration is done in descending order\n       *  according to the keys.\n       */\n      const_reverse_iterator\n      crbegin() const noexcept\n      { return _M_t.rbegin(); }\n\n      /**\n       *  Returns a read-only (constant) reverse iterator that points to one\n       *  before the first pair in the %map.  Iteration is done in descending\n       *  order according to the keys.\n       */\n      const_reverse_iterator\n      crend() const noexcept\n      { return _M_t.rend(); }\n#endif\n\n      // capacity\n      /** Returns true if the %map is empty.  (Thus begin() would equal\n       *  end().)\n      */\n      bool\n      empty() const _GLIBCXX_NOEXCEPT\n      { return _M_t.empty(); }\n\n      /** Returns the size of the %map.  */\n      size_type\n      size() const _GLIBCXX_NOEXCEPT\n      { return _M_t.size(); }\n\n      /** Returns the maximum size of the %map.  */\n      size_type\n      max_size() const _GLIBCXX_NOEXCEPT\n      { return _M_t.max_size(); }\n\n      // [23.3.1.2] element access\n      /**\n       *  @brief  Subscript ( @c [] ) access to %map data.\n       *  @param  __k  The key for which data should be retrieved.\n       *  @return  A reference to the data of the (key,data) %pair.\n       *\n       *  Allows for easy lookup with the subscript ( @c [] )\n       *  operator.  Returns data associated with the key specified in\n       *  subscript.  If the key does not exist, a pair with that key\n       *  is created using default values, which is then returned.\n       *\n       *  Lookup requires logarithmic time.\n       */\n      mapped_type&\n      operator[](const key_type& __k)\n      {\n\t// concept requirements\n\t__glibcxx_function_requires(_DefaultConstructibleConcept<mapped_type>)\n\n\titerator __i = lower_bound(__k);\n\t// __i->first is greater than or equivalent to __k.\n\tif (__i == end() || key_comp()(__k, (*__i).first))\n#if __cplusplus >= 201103L\n\t  __i = _M_t._M_emplace_hint_unique(__i, std::piecewise_construct,\n\t\t\t\t\t    std::tuple<const key_type&>(__k),\n\t\t\t\t\t    std::tuple<>());\n#else\n\t  __i = insert(__i, value_type(__k, mapped_type()));\n#endif\n\treturn (*__i).second;\n      }\n\n#if __cplusplus >= 201103L\n      mapped_type&\n      operator[](key_type&& __k)\n      {\n\t// concept requirements\n\t__glibcxx_function_requires(_DefaultConstructibleConcept<mapped_type>)\n\n\titerator __i = lower_bound(__k);\n\t// __i->first is greater than or equivalent to __k.\n\tif (__i == end() || key_comp()(__k, (*__i).first))\n\t  __i = _M_t._M_emplace_hint_unique(__i, std::piecewise_construct,\n\t\t\t\t\tstd::forward_as_tuple(std::move(__k)),\n\t\t\t\t\tstd::tuple<>());\n\treturn (*__i).second;\n      }\n#endif\n\n      // _GLIBCXX_RESOLVE_LIB_DEFECTS\n      // DR 464. Suggestion for new member functions in standard containers.\n      /**\n       *  @brief  Access to %map data.\n       *  @param  __k  The key for which data should be retrieved.\n       *  @return  A reference to the data whose key is equivalent to @a __k, if\n       *           such a data is present in the %map.\n       *  @throw  std::out_of_range  If no such data is present.\n       */\n      mapped_type&\n      at(const key_type& __k)\n      {\n\titerator __i = lower_bound(__k);\n\tif (__i == end() || key_comp()(__k, (*__i).first))\n\t  __throw_out_of_range(__N(\"map::at\"));\n\treturn (*__i).second;\n      }\n\n      const mapped_type&\n      at(const key_type& __k) const\n      {\n\tconst_iterator __i = lower_bound(__k);\n\tif (__i == end() || key_comp()(__k, (*__i).first))\n\t  __throw_out_of_range(__N(\"map::at\"));\n\treturn (*__i).second;\n      }\n\n      // modifiers\n#if __cplusplus >= 201103L\n      /**\n       *  @brief Attempts to build and insert a std::pair into the %map.\n       *\n       *  @param __args  Arguments used to generate a new pair instance (see\n       *\t        std::piecewise_contruct for passing arguments to each\n       *\t        part of the pair constructor).\n       *\n       *  @return  A pair, of which the first element is an iterator that points\n       *           to the possibly inserted pair, and the second is a bool that\n       *           is true if the pair was actually inserted.\n       *\n       *  This function attempts to build and insert a (key, value) %pair into\n       *  the %map.\n       *  A %map relies on unique keys and thus a %pair is only inserted if its\n       *  first element (the key) is not already present in the %map.\n       *\n       *  Insertion requires logarithmic time.\n       */\n      template<typename... _Args>\n\tstd::pair<iterator, bool>\n\templace(_Args&&... __args)\n\t{ return _M_t._M_emplace_unique(std::forward<_Args>(__args)...); }\n\n      /**\n       *  @brief Attempts to build and insert a std::pair into the %map.\n       *\n       *  @param  __pos  An iterator that serves as a hint as to where the pair\n       *                should be inserted.\n       *  @param  __args  Arguments used to generate a new pair instance (see\n       *\t         std::piecewise_contruct for passing arguments to each\n       *\t         part of the pair constructor).\n       *  @return An iterator that points to the element with key of the\n       *          std::pair built from @a __args (may or may not be that\n       *          std::pair).\n       *\n       *  This function is not concerned about whether the insertion took place,\n       *  and thus does not return a boolean like the single-argument emplace()\n       *  does.\n       *  Note that the first parameter is only a hint and can potentially\n       *  improve the performance of the insertion process. A bad hint would\n       *  cause no gains in efficiency.\n       *\n       *  See\n       *  https://gcc.gnu.org/onlinedocs/libstdc++/manual/associative.html#containers.associative.insert_hints\n       *  for more on @a hinting.\n       *\n       *  Insertion requires logarithmic time (if the hint is not taken).\n       */\n      template<typename... _Args>\n\titerator\n\templace_hint(const_iterator __pos, _Args&&... __args)\n\t{\n\t  return _M_t._M_emplace_hint_unique(__pos,\n\t\t\t\t\t     std::forward<_Args>(__args)...);\n\t}\n#endif\n\n#if __cplusplus > 201402L\n      /// Extract a node.\n      node_type\n      extract(const_iterator __pos)\n      {\n\t__glibcxx_assert(__pos != end());\n\treturn _M_t.extract(__pos);\n      }\n\n      /// Extract a node.\n      node_type\n      extract(const key_type& __x)\n      { return _M_t.extract(__x); }\n\n      /// Re-insert an extracted node.\n      insert_return_type\n      insert(node_type&& __nh)\n      { return _M_t._M_reinsert_node_unique(std::move(__nh)); }\n\n      /// Re-insert an extracted node.\n      iterator\n      insert(const_iterator __hint, node_type&& __nh)\n      { return _M_t._M_reinsert_node_hint_unique(__hint, std::move(__nh)); }\n\n      template<typename, typename>\n\tfriend class _Rb_tree_merge_helper;\n\n      template<typename _C2>\n\tvoid\n\tmerge(map<_Key, _Tp, _C2, _Alloc>& __source)\n\t{\n\t  using _Merge_helper = _Rb_tree_merge_helper<map, _C2>;\n\t  _M_t._M_merge_unique(_Merge_helper::_S_get_tree(__source));\n\t}\n\n      template<typename _C2>\n\tvoid\n\tmerge(map<_Key, _Tp, _C2, _Alloc>&& __source)\n\t{ merge(__source); }\n\n      template<typename _C2>\n\tvoid\n\tmerge(multimap<_Key, _Tp, _C2, _Alloc>& __source)\n\t{\n\t  using _Merge_helper = _Rb_tree_merge_helper<map, _C2>;\n\t  _M_t._M_merge_unique(_Merge_helper::_S_get_tree(__source));\n\t}\n\n      template<typename _C2>\n\tvoid\n\tmerge(multimap<_Key, _Tp, _C2, _Alloc>&& __source)\n\t{ merge(__source); }\n#endif // C++17\n\n#if __cplusplus > 201402L\n#define __cpp_lib_map_try_emplace 201411\n      /**\n       *  @brief Attempts to build and insert a std::pair into the %map.\n       *\n       *  @param __k    Key to use for finding a possibly existing pair in\n       *                the map.\n       *  @param __args  Arguments used to generate the .second for a new pair\n       *                instance.\n       *\n       *  @return  A pair, of which the first element is an iterator that points\n       *           to the possibly inserted pair, and the second is a bool that\n       *           is true if the pair was actually inserted.\n       *\n       *  This function attempts to build and insert a (key, value) %pair into\n       *  the %map.\n       *  A %map relies on unique keys and thus a %pair is only inserted if its\n       *  first element (the key) is not already present in the %map.\n       *  If a %pair is not inserted, this function has no effect.\n       *\n       *  Insertion requires logarithmic time.\n       */\n      template <typename... _Args>\n\tpair<iterator, bool>\n\ttry_emplace(const key_type& __k, _Args&&... __args)\n\t{\n\t  iterator __i = lower_bound(__k);\n\t  if (__i == end() || key_comp()(__k, (*__i).first))\n\t    {\n\t      __i = emplace_hint(__i, std::piecewise_construct,\n\t\t\t\t std::forward_as_tuple(__k),\n\t\t\t\t std::forward_as_tuple(\n\t\t\t\t   std::forward<_Args>(__args)...));\n\t      return {__i, true};\n\t    }\n\t  return {__i, false};\n\t}\n\n      // move-capable overload\n      template <typename... _Args>\n\tpair<iterator, bool>\n\ttry_emplace(key_type&& __k, _Args&&... __args)\n\t{\n\t  iterator __i = lower_bound(__k);\n\t  if (__i == end() || key_comp()(__k, (*__i).first))\n\t    {\n\t      __i = emplace_hint(__i, std::piecewise_construct,\n\t\t\t\t std::forward_as_tuple(std::move(__k)),\n\t\t\t\t std::forward_as_tuple(\n\t\t\t\t   std::forward<_Args>(__args)...));\n\t      return {__i, true};\n\t    }\n\t  return {__i, false};\n\t}\n\n      /**\n       *  @brief Attempts to build and insert a std::pair into the %map.\n       *\n       *  @param  __hint  An iterator that serves as a hint as to where the\n       *                  pair should be inserted.\n       *  @param __k    Key to use for finding a possibly existing pair in\n       *                the map.\n       *  @param __args  Arguments used to generate the .second for a new pair\n       *                instance.\n       *  @return An iterator that points to the element with key of the\n       *          std::pair built from @a __args (may or may not be that\n       *          std::pair).\n       *\n       *  This function is not concerned about whether the insertion took place,\n       *  and thus does not return a boolean like the single-argument\n       *  try_emplace() does. However, if insertion did not take place,\n       *  this function has no effect.\n       *  Note that the first parameter is only a hint and can potentially\n       *  improve the performance of the insertion process. A bad hint would\n       *  cause no gains in efficiency.\n       *\n       *  See\n       *  https://gcc.gnu.org/onlinedocs/libstdc++/manual/associative.html#containers.associative.insert_hints\n       *  for more on @a hinting.\n       *\n       *  Insertion requires logarithmic time (if the hint is not taken).\n       */\n      template <typename... _Args>\n\titerator\n\ttry_emplace(const_iterator __hint, const key_type& __k,\n\t\t    _Args&&... __args)\n\t{\n\t  iterator __i;\n\t  auto __true_hint = _M_t._M_get_insert_hint_unique_pos(__hint, __k);\n\t  if (__true_hint.second)\n\t    __i = emplace_hint(iterator(__true_hint.second),\n\t\t\t       std::piecewise_construct,\n\t\t\t       std::forward_as_tuple(__k),\n\t\t\t       std::forward_as_tuple(\n\t\t\t\t std::forward<_Args>(__args)...));\n\t  else\n\t    __i = iterator(__true_hint.first);\n\t  return __i;\n\t}\n\n      // move-capable overload\n      template <typename... _Args>\n\titerator\n\ttry_emplace(const_iterator __hint, key_type&& __k, _Args&&... __args)\n\t{\n\t  iterator __i;\n\t  auto __true_hint = _M_t._M_get_insert_hint_unique_pos(__hint, __k);\n\t  if (__true_hint.second)\n\t    __i = emplace_hint(iterator(__true_hint.second),\n\t\t\t       std::piecewise_construct,\n\t\t\t       std::forward_as_tuple(std::move(__k)),\n\t\t\t       std::forward_as_tuple(\n\t\t\t\t std::forward<_Args>(__args)...));\n\t  else\n\t    __i = iterator(__true_hint.first);\n\t  return __i;\n\t}\n#endif\n\n      /**\n       *  @brief Attempts to insert a std::pair into the %map.\n       *  @param __x Pair to be inserted (see std::make_pair for easy\n       *\t     creation of pairs).\n       *\n       *  @return  A pair, of which the first element is an iterator that\n       *           points to the possibly inserted pair, and the second is\n       *           a bool that is true if the pair was actually inserted.\n       *\n       *  This function attempts to insert a (key, value) %pair into the %map.\n       *  A %map relies on unique keys and thus a %pair is only inserted if its\n       *  first element (the key) is not already present in the %map.\n       *\n       *  Insertion requires logarithmic time.\n       *  @{\n       */\n      std::pair<iterator, bool>\n      insert(const value_type& __x)\n      { return _M_t._M_insert_unique(__x); }\n\n#if __cplusplus >= 201103L\n      // _GLIBCXX_RESOLVE_LIB_DEFECTS\n      // 2354. Unnecessary copying when inserting into maps with braced-init\n      std::pair<iterator, bool>\n      insert(value_type&& __x)\n      { return _M_t._M_insert_unique(std::move(__x)); }\n\n      template<typename _Pair>\n\t__enable_if_t<is_constructible<value_type, _Pair>::value,\n\t\t      pair<iterator, bool>>\n\tinsert(_Pair&& __x)\n\t{ return _M_t._M_emplace_unique(std::forward<_Pair>(__x)); }\n#endif\n      // @}\n\n#if __cplusplus >= 201103L\n      /**\n       *  @brief Attempts to insert a list of std::pairs into the %map.\n       *  @param  __list  A std::initializer_list<value_type> of pairs to be\n       *                  inserted.\n       *\n       *  Complexity similar to that of the range constructor.\n       */\n      void\n      insert(std::initializer_list<value_type> __list)\n      { insert(__list.begin(), __list.end()); }\n#endif\n\n      /**\n       *  @brief Attempts to insert a std::pair into the %map.\n       *  @param  __position  An iterator that serves as a hint as to where the\n       *                    pair should be inserted.\n       *  @param  __x  Pair to be inserted (see std::make_pair for easy creation\n       *               of pairs).\n       *  @return An iterator that points to the element with key of\n       *           @a __x (may or may not be the %pair passed in).\n       *\n\n       *  This function is not concerned about whether the insertion\n       *  took place, and thus does not return a boolean like the\n       *  single-argument insert() does.  Note that the first\n       *  parameter is only a hint and can potentially improve the\n       *  performance of the insertion process.  A bad hint would\n       *  cause no gains in efficiency.\n       *\n       *  See\n       *  https://gcc.gnu.org/onlinedocs/libstdc++/manual/associative.html#containers.associative.insert_hints\n       *  for more on @a hinting.\n       *\n       *  Insertion requires logarithmic time (if the hint is not taken).\n       *  @{\n       */\n      iterator\n#if __cplusplus >= 201103L\n      insert(const_iterator __position, const value_type& __x)\n#else\n      insert(iterator __position, const value_type& __x)\n#endif\n      { return _M_t._M_insert_unique_(__position, __x); }\n\n#if __cplusplus >= 201103L\n      // _GLIBCXX_RESOLVE_LIB_DEFECTS\n      // 2354. Unnecessary copying when inserting into maps with braced-init\n      iterator\n      insert(const_iterator __position, value_type&& __x)\n      { return _M_t._M_insert_unique_(__position, std::move(__x)); }\n\n      template<typename _Pair>\n\t__enable_if_t<is_constructible<value_type, _Pair>::value, iterator>\n\tinsert(const_iterator __position, _Pair&& __x)\n\t{\n\t  return _M_t._M_emplace_hint_unique(__position,\n\t\t\t\t\t     std::forward<_Pair>(__x));\n\t}\n#endif\n      // @}\n\n      /**\n       *  @brief Template function that attempts to insert a range of elements.\n       *  @param  __first  Iterator pointing to the start of the range to be\n       *                   inserted.\n       *  @param  __last  Iterator pointing to the end of the range.\n       *\n       *  Complexity similar to that of the range constructor.\n       */\n      template<typename _InputIterator>\n\tvoid\n\tinsert(_InputIterator __first, _InputIterator __last)\n\t{ _M_t._M_insert_unique(__first, __last); }\n\n#if __cplusplus > 201402L\n#define __cpp_lib_map_insertion 201411\n      /**\n       *  @brief Attempts to insert or assign a std::pair into the %map.\n       *  @param __k    Key to use for finding a possibly existing pair in\n       *                the map.\n       *  @param __obj  Argument used to generate the .second for a pair\n       *                instance.\n       *\n       *  @return  A pair, of which the first element is an iterator that\n       *           points to the possibly inserted pair, and the second is\n       *           a bool that is true if the pair was actually inserted.\n       *\n       *  This function attempts to insert a (key, value) %pair into the %map.\n       *  A %map relies on unique keys and thus a %pair is only inserted if its\n       *  first element (the key) is not already present in the %map.\n       *  If the %pair was already in the %map, the .second of the %pair\n       *  is assigned from __obj.\n       *\n       *  Insertion requires logarithmic time.\n       */\n      template <typename _Obj>\n\tpair<iterator, bool>\n\tinsert_or_assign(const key_type& __k, _Obj&& __obj)\n\t{\n\t  iterator __i = lower_bound(__k);\n\t  if (__i == end() || key_comp()(__k, (*__i).first))\n\t    {\n\t      __i = emplace_hint(__i, std::piecewise_construct,\n\t\t\t\t std::forward_as_tuple(__k),\n\t\t\t\t std::forward_as_tuple(\n\t\t\t\t   std::forward<_Obj>(__obj)));\n\t      return {__i, true};\n\t    }\n\t  (*__i).second = std::forward<_Obj>(__obj);\n\t  return {__i, false};\n\t}\n\n      // move-capable overload\n      template <typename _Obj>\n\tpair<iterator, bool>\n\tinsert_or_assign(key_type&& __k, _Obj&& __obj)\n\t{\n\t  iterator __i = lower_bound(__k);\n\t  if (__i == end() || key_comp()(__k, (*__i).first))\n\t    {\n\t      __i = emplace_hint(__i, std::piecewise_construct,\n\t\t\t\t std::forward_as_tuple(std::move(__k)),\n\t\t\t\t std::forward_as_tuple(\n\t\t\t\t   std::forward<_Obj>(__obj)));\n\t      return {__i, true};\n\t    }\n\t  (*__i).second = std::forward<_Obj>(__obj);\n\t  return {__i, false};\n\t}\n\n      /**\n       *  @brief Attempts to insert or assign a std::pair into the %map.\n       *  @param  __hint  An iterator that serves as a hint as to where the\n       *                  pair should be inserted.\n       *  @param __k    Key to use for finding a possibly existing pair in\n       *                the map.\n       *  @param __obj  Argument used to generate the .second for a pair\n       *                instance.\n       *\n       *  @return An iterator that points to the element with key of\n       *           @a __x (may or may not be the %pair passed in).\n       *\n       *  This function attempts to insert a (key, value) %pair into the %map.\n       *  A %map relies on unique keys and thus a %pair is only inserted if its\n       *  first element (the key) is not already present in the %map.\n       *  If the %pair was already in the %map, the .second of the %pair\n       *  is assigned from __obj.\n       *\n       *  Insertion requires logarithmic time.\n       */\n      template <typename _Obj>\n\titerator\n\tinsert_or_assign(const_iterator __hint,\n\t\t\t const key_type& __k, _Obj&& __obj)\n\t{\n\t  iterator __i;\n\t  auto __true_hint = _M_t._M_get_insert_hint_unique_pos(__hint, __k);\n\t  if (__true_hint.second)\n\t    {\n\t      return emplace_hint(iterator(__true_hint.second),\n\t\t\t\t  std::piecewise_construct,\n\t\t\t\t  std::forward_as_tuple(__k),\n\t\t\t\t  std::forward_as_tuple(\n\t\t\t\t    std::forward<_Obj>(__obj)));\n\t    }\n\t  __i = iterator(__true_hint.first);\n\t  (*__i).second = std::forward<_Obj>(__obj);\n\t  return __i;\n\t}\n\n      // move-capable overload\n      template <typename _Obj>\n\titerator\n\tinsert_or_assign(const_iterator __hint, key_type&& __k, _Obj&& __obj)\n\t{\n\t  iterator __i;\n\t  auto __true_hint = _M_t._M_get_insert_hint_unique_pos(__hint, __k);\n\t  if (__true_hint.second)\n\t    {\n\t      return emplace_hint(iterator(__true_hint.second),\n\t\t\t\t  std::piecewise_construct,\n\t\t\t\t  std::forward_as_tuple(std::move(__k)),\n\t\t\t\t  std::forward_as_tuple(\n\t\t\t\t    std::forward<_Obj>(__obj)));\n\t    }\n\t  __i = iterator(__true_hint.first);\n\t  (*__i).second = std::forward<_Obj>(__obj);\n\t  return __i;\n\t}\n#endif\n\n#if __cplusplus >= 201103L\n      // _GLIBCXX_RESOLVE_LIB_DEFECTS\n      // DR 130. Associative erase should return an iterator.\n      /**\n       *  @brief Erases an element from a %map.\n       *  @param  __position  An iterator pointing to the element to be erased.\n       *  @return An iterator pointing to the element immediately following\n       *          @a position prior to the element being erased. If no such\n       *          element exists, end() is returned.\n       *\n       *  This function erases an element, pointed to by the given\n       *  iterator, from a %map.  Note that this function only erases\n       *  the element, and that if the element is itself a pointer,\n       *  the pointed-to memory is not touched in any way.  Managing\n       *  the pointer is the user's responsibility.\n       *\n       *  @{\n       */\n      iterator\n      erase(const_iterator __position)\n      { return _M_t.erase(__position); }\n\n      // LWG 2059\n      _GLIBCXX_ABI_TAG_CXX11\n      iterator\n      erase(iterator __position)\n      { return _M_t.erase(__position); }\n      // @}\n#else\n      /**\n       *  @brief Erases an element from a %map.\n       *  @param  __position  An iterator pointing to the element to be erased.\n       *\n       *  This function erases an element, pointed to by the given\n       *  iterator, from a %map.  Note that this function only erases\n       *  the element, and that if the element is itself a pointer,\n       *  the pointed-to memory is not touched in any way.  Managing\n       *  the pointer is the user's responsibility.\n       */\n      void\n      erase(iterator __position)\n      { _M_t.erase(__position); }\n#endif\n\n      /**\n       *  @brief Erases elements according to the provided key.\n       *  @param  __x  Key of element to be erased.\n       *  @return  The number of elements erased.\n       *\n       *  This function erases all the elements located by the given key from\n       *  a %map.\n       *  Note that this function only erases the element, and that if\n       *  the element is itself a pointer, the pointed-to memory is not touched\n       *  in any way.  Managing the pointer is the user's responsibility.\n       */\n      size_type\n      erase(const key_type& __x)\n      { return _M_t.erase(__x); }\n\n#if __cplusplus >= 201103L\n      // _GLIBCXX_RESOLVE_LIB_DEFECTS\n      // DR 130. Associative erase should return an iterator.\n      /**\n       *  @brief Erases a [first,last) range of elements from a %map.\n       *  @param  __first  Iterator pointing to the start of the range to be\n       *                   erased.\n       *  @param __last Iterator pointing to the end of the range to\n       *                be erased.\n       *  @return The iterator @a __last.\n       *\n       *  This function erases a sequence of elements from a %map.\n       *  Note that this function only erases the element, and that if\n       *  the element is itself a pointer, the pointed-to memory is not touched\n       *  in any way.  Managing the pointer is the user's responsibility.\n       */\n      iterator\n      erase(const_iterator __first, const_iterator __last)\n      { return _M_t.erase(__first, __last); }\n#else\n      /**\n       *  @brief Erases a [__first,__last) range of elements from a %map.\n       *  @param  __first  Iterator pointing to the start of the range to be\n       *                   erased.\n       *  @param __last Iterator pointing to the end of the range to\n       *                be erased.\n       *\n       *  This function erases a sequence of elements from a %map.\n       *  Note that this function only erases the element, and that if\n       *  the element is itself a pointer, the pointed-to memory is not touched\n       *  in any way.  Managing the pointer is the user's responsibility.\n       */\n      void\n      erase(iterator __first, iterator __last)\n      { _M_t.erase(__first, __last); }\n#endif\n\n      /**\n       *  @brief  Swaps data with another %map.\n       *  @param  __x  A %map of the same element and allocator types.\n       *\n       *  This exchanges the elements between two maps in constant\n       *  time.  (It is only swapping a pointer, an integer, and an\n       *  instance of the @c Compare type (which itself is often\n       *  stateless and empty), so it should be quite fast.)  Note\n       *  that the global std::swap() function is specialized such\n       *  that std::swap(m1,m2) will feed to this function.\n       *\n       *  Whether the allocators are swapped depends on the allocator traits.\n       */\n      void\n      swap(map& __x)\n      _GLIBCXX_NOEXCEPT_IF(__is_nothrow_swappable<_Compare>::value)\n      { _M_t.swap(__x._M_t); }\n\n      /**\n       *  Erases all elements in a %map.  Note that this function only\n       *  erases the elements, and that if the elements themselves are\n       *  pointers, the pointed-to memory is not touched in any way.\n       *  Managing the pointer is the user's responsibility.\n       */\n      void\n      clear() _GLIBCXX_NOEXCEPT\n      { _M_t.clear(); }\n\n      // observers\n      /**\n       *  Returns the key comparison object out of which the %map was\n       *  constructed.\n       */\n      key_compare\n      key_comp() const\n      { return _M_t.key_comp(); }\n\n      /**\n       *  Returns a value comparison object, built from the key comparison\n       *  object out of which the %map was constructed.\n       */\n      value_compare\n      value_comp() const\n      { return value_compare(_M_t.key_comp()); }\n\n      // [23.3.1.3] map operations\n\n      //@{\n      /**\n       *  @brief Tries to locate an element in a %map.\n       *  @param  __x  Key of (key, value) %pair to be located.\n       *  @return  Iterator pointing to sought-after element, or end() if not\n       *           found.\n       *\n       *  This function takes a key and tries to locate the element with which\n       *  the key matches.  If successful the function returns an iterator\n       *  pointing to the sought after %pair.  If unsuccessful it returns the\n       *  past-the-end ( @c end() ) iterator.\n       */\n\n      iterator\n      find(const key_type& __x)\n      { return _M_t.find(__x); }\n\n#if __cplusplus > 201103L\n      template<typename _Kt>\n\tauto\n\tfind(const _Kt& __x) -> decltype(_M_t._M_find_tr(__x))\n\t{ return _M_t._M_find_tr(__x); }\n#endif\n      //@}\n\n      //@{\n      /**\n       *  @brief Tries to locate an element in a %map.\n       *  @param  __x  Key of (key, value) %pair to be located.\n       *  @return  Read-only (constant) iterator pointing to sought-after\n       *           element, or end() if not found.\n       *\n       *  This function takes a key and tries to locate the element with which\n       *  the key matches.  If successful the function returns a constant\n       *  iterator pointing to the sought after %pair. If unsuccessful it\n       *  returns the past-the-end ( @c end() ) iterator.\n       */\n\n      const_iterator\n      find(const key_type& __x) const\n      { return _M_t.find(__x); }\n\n#if __cplusplus > 201103L\n      template<typename _Kt>\n\tauto\n\tfind(const _Kt& __x) const -> decltype(_M_t._M_find_tr(__x))\n\t{ return _M_t._M_find_tr(__x); }\n#endif\n      //@}\n\n      //@{\n      /**\n       *  @brief  Finds the number of elements with given key.\n       *  @param  __x  Key of (key, value) pairs to be located.\n       *  @return  Number of elements with specified key.\n       *\n       *  This function only makes sense for multimaps; for map the result will\n       *  either be 0 (not present) or 1 (present).\n       */\n      size_type\n      count(const key_type& __x) const\n      { return _M_t.find(__x) == _M_t.end() ? 0 : 1; }\n\n#if __cplusplus > 201103L\n      template<typename _Kt>\n\tauto\n\tcount(const _Kt& __x) const -> decltype(_M_t._M_count_tr(__x))\n\t{ return _M_t._M_count_tr(__x); }\n#endif\n      //@}\n\n      //@{\n      /**\n       *  @brief Finds the beginning of a subsequence matching given key.\n       *  @param  __x  Key of (key, value) pair to be located.\n       *  @return  Iterator pointing to first element equal to or greater\n       *           than key, or end().\n       *\n       *  This function returns the first element of a subsequence of elements\n       *  that matches the given key.  If unsuccessful it returns an iterator\n       *  pointing to the first element that has a greater value than given key\n       *  or end() if no such element exists.\n       */\n      iterator\n      lower_bound(const key_type& __x)\n      { return _M_t.lower_bound(__x); }\n\n#if __cplusplus > 201103L\n      template<typename _Kt>\n\tauto\n\tlower_bound(const _Kt& __x)\n\t-> decltype(iterator(_M_t._M_lower_bound_tr(__x)))\n\t{ return iterator(_M_t._M_lower_bound_tr(__x)); }\n#endif\n      //@}\n\n      //@{\n      /**\n       *  @brief Finds the beginning of a subsequence matching given key.\n       *  @param  __x  Key of (key, value) pair to be located.\n       *  @return  Read-only (constant) iterator pointing to first element\n       *           equal to or greater than key, or end().\n       *\n       *  This function returns the first element of a subsequence of elements\n       *  that matches the given key.  If unsuccessful it returns an iterator\n       *  pointing to the first element that has a greater value than given key\n       *  or end() if no such element exists.\n       */\n      const_iterator\n      lower_bound(const key_type& __x) const\n      { return _M_t.lower_bound(__x); }\n\n#if __cplusplus > 201103L\n      template<typename _Kt>\n\tauto\n\tlower_bound(const _Kt& __x) const\n\t-> decltype(const_iterator(_M_t._M_lower_bound_tr(__x)))\n\t{ return const_iterator(_M_t._M_lower_bound_tr(__x)); }\n#endif\n      //@}\n\n      //@{\n      /**\n       *  @brief Finds the end of a subsequence matching given key.\n       *  @param  __x  Key of (key, value) pair to be located.\n       *  @return Iterator pointing to the first element\n       *          greater than key, or end().\n       */\n      iterator\n      upper_bound(const key_type& __x)\n      { return _M_t.upper_bound(__x); }\n\n#if __cplusplus > 201103L\n      template<typename _Kt>\n\tauto\n\tupper_bound(const _Kt& __x)\n\t-> decltype(iterator(_M_t._M_upper_bound_tr(__x)))\n\t{ return iterator(_M_t._M_upper_bound_tr(__x)); }\n#endif\n      //@}\n\n      //@{\n      /**\n       *  @brief Finds the end of a subsequence matching given key.\n       *  @param  __x  Key of (key, value) pair to be located.\n       *  @return  Read-only (constant) iterator pointing to first iterator\n       *           greater than key, or end().\n       */\n      const_iterator\n      upper_bound(const key_type& __x) const\n      { return _M_t.upper_bound(__x); }\n\n#if __cplusplus > 201103L\n      template<typename _Kt>\n\tauto\n\tupper_bound(const _Kt& __x) const\n\t-> decltype(const_iterator(_M_t._M_upper_bound_tr(__x)))\n\t{ return const_iterator(_M_t._M_upper_bound_tr(__x)); }\n#endif\n      //@}\n\n      //@{\n      /**\n       *  @brief Finds a subsequence matching given key.\n       *  @param  __x  Key of (key, value) pairs to be located.\n       *  @return  Pair of iterators that possibly points to the subsequence\n       *           matching given key.\n       *\n       *  This function is equivalent to\n       *  @code\n       *    std::make_pair(c.lower_bound(val),\n       *                   c.upper_bound(val))\n       *  @endcode\n       *  (but is faster than making the calls separately).\n       *\n       *  This function probably only makes sense for multimaps.\n       */\n      std::pair<iterator, iterator>\n      equal_range(const key_type& __x)\n      { return _M_t.equal_range(__x); }\n\n#if __cplusplus > 201103L\n      template<typename _Kt>\n\tauto\n\tequal_range(const _Kt& __x)\n\t-> decltype(pair<iterator, iterator>(_M_t._M_equal_range_tr(__x)))\n\t{ return pair<iterator, iterator>(_M_t._M_equal_range_tr(__x)); }\n#endif\n      //@}\n\n      //@{\n      /**\n       *  @brief Finds a subsequence matching given key.\n       *  @param  __x  Key of (key, value) pairs to be located.\n       *  @return  Pair of read-only (constant) iterators that possibly points\n       *           to the subsequence matching given key.\n       *\n       *  This function is equivalent to\n       *  @code\n       *    std::make_pair(c.lower_bound(val),\n       *                   c.upper_bound(val))\n       *  @endcode\n       *  (but is faster than making the calls separately).\n       *\n       *  This function probably only makes sense for multimaps.\n       */\n      std::pair<const_iterator, const_iterator>\n      equal_range(const key_type& __x) const\n      { return _M_t.equal_range(__x); }\n\n#if __cplusplus > 201103L\n      template<typename _Kt>\n\tauto\n\tequal_range(const _Kt& __x) const\n\t-> decltype(pair<const_iterator, const_iterator>(\n\t      _M_t._M_equal_range_tr(__x)))\n\t{\n\t  return pair<const_iterator, const_iterator>(\n\t      _M_t._M_equal_range_tr(__x));\n\t}\n#endif\n      //@}\n\n      template<typename _K1, typename _T1, typename _C1, typename _A1>\n\tfriend bool\n\toperator==(const map<_K1, _T1, _C1, _A1>&,\n\t\t   const map<_K1, _T1, _C1, _A1>&);\n\n      template<typename _K1, typename _T1, typename _C1, typename _A1>\n\tfriend bool\n\toperator<(const map<_K1, _T1, _C1, _A1>&,\n\t\t  const map<_K1, _T1, _C1, _A1>&);\n    };\n\n  /**\n   *  @brief  Map equality comparison.\n   *  @param  __x  A %map.\n   *  @param  __y  A %map of the same type as @a x.\n   *  @return  True iff the size and elements of the maps are equal.\n   *\n   *  This is an equivalence relation.  It is linear in the size of the\n   *  maps.  Maps are considered equivalent if their sizes are equal,\n   *  and if corresponding elements compare equal.\n  */\n  template<typename _Key, typename _Tp, typename _Compare, typename _Alloc>\n    inline bool\n    operator==(const map<_Key, _Tp, _Compare, _Alloc>& __x,\n\t       const map<_Key, _Tp, _Compare, _Alloc>& __y)\n    { return __x._M_t == __y._M_t; }\n\n  /**\n   *  @brief  Map ordering relation.\n   *  @param  __x  A %map.\n   *  @param  __y  A %map of the same type as @a x.\n   *  @return  True iff @a x is lexicographically less than @a y.\n   *\n   *  This is a total ordering relation.  It is linear in the size of the\n   *  maps.  The elements must be comparable with @c <.\n   *\n   *  See std::lexicographical_compare() for how the determination is made.\n  */\n  template<typename _Key, typename _Tp, typename _Compare, typename _Alloc>\n    inline bool\n    operator<(const map<_Key, _Tp, _Compare, _Alloc>& __x,\n\t      const map<_Key, _Tp, _Compare, _Alloc>& __y)\n    { return __x._M_t < __y._M_t; }\n\n  /// Based on operator==\n  template<typename _Key, typename _Tp, typename _Compare, typename _Alloc>\n    inline bool\n    operator!=(const map<_Key, _Tp, _Compare, _Alloc>& __x,\n\t       const map<_Key, _Tp, _Compare, _Alloc>& __y)\n    { return !(__x == __y); }\n\n  /// Based on operator<\n  template<typename _Key, typename _Tp, typename _Compare, typename _Alloc>\n    inline bool\n    operator>(const map<_Key, _Tp, _Compare, _Alloc>& __x,\n\t      const map<_Key, _Tp, _Compare, _Alloc>& __y)\n    { return __y < __x; }\n\n  /// Based on operator<\n  template<typename _Key, typename _Tp, typename _Compare, typename _Alloc>\n    inline bool\n    operator<=(const map<_Key, _Tp, _Compare, _Alloc>& __x,\n\t       const map<_Key, _Tp, _Compare, _Alloc>& __y)\n    { return !(__y < __x); }\n\n  /// Based on operator<\n  template<typename _Key, typename _Tp, typename _Compare, typename _Alloc>\n    inline bool\n    operator>=(const map<_Key, _Tp, _Compare, _Alloc>& __x,\n\t       const map<_Key, _Tp, _Compare, _Alloc>& __y)\n    { return !(__x < __y); }\n\n  /// See std::map::swap().\n  template<typename _Key, typename _Tp, typename _Compare, typename _Alloc>\n    inline void\n    swap(map<_Key, _Tp, _Compare, _Alloc>& __x,\n\t map<_Key, _Tp, _Compare, _Alloc>& __y)\n    _GLIBCXX_NOEXCEPT_IF(noexcept(__x.swap(__y)))\n    { __x.swap(__y); }\n\n_GLIBCXX_END_NAMESPACE_CONTAINER\n\n#if __cplusplus > 201402L\n_GLIBCXX_BEGIN_NAMESPACE_VERSION\n  // Allow std::map access to internals of compatible maps.\n  template<typename _Key, typename _Val, typename _Cmp1, typename _Alloc,\n\t   typename _Cmp2>\n    struct\n    _Rb_tree_merge_helper<_GLIBCXX_STD_C::map<_Key, _Val, _Cmp1, _Alloc>,\n\t\t\t  _Cmp2>\n    {\n    private:\n      friend class _GLIBCXX_STD_C::map<_Key, _Val, _Cmp1, _Alloc>;\n\n      static auto&\n      _S_get_tree(_GLIBCXX_STD_C::map<_Key, _Val, _Cmp2, _Alloc>& __map)\n      { return __map._M_t; }\n\n      static auto&\n      _S_get_tree(_GLIBCXX_STD_C::multimap<_Key, _Val, _Cmp2, _Alloc>& __map)\n      { return __map._M_t; }\n    };\n_GLIBCXX_END_NAMESPACE_VERSION\n#endif // C++17\n\n} // namespace std\n\n#endif /* _STL_MAP_H */\n"}, "36": {"id": 36, "path": "/usr/include/boost/function/function_template.hpp", "content": "// Boost.Function library\n\n//  Copyright Douglas Gregor 2001-2006\n//  Copyright Emil Dotchevski 2007\n//  Use, modification and distribution is subject to the Boost Software License, Version 1.0.\n//  (See accompanying file LICENSE_1_0.txt or copy at\n//  http://www.boost.org/LICENSE_1_0.txt)\n\n// For more information, see http://www.boost.org\n\n// Note: this header is a header template and must NOT have multiple-inclusion\n// protection.\n#include <boost/function/detail/prologue.hpp>\n#include <boost/detail/no_exceptions_support.hpp>\n\n#if defined(BOOST_MSVC)\n#   pragma warning( push )\n#   pragma warning( disable : 4127 ) // \"conditional expression is constant\"\n#endif\n\n#define BOOST_FUNCTION_TEMPLATE_PARMS BOOST_PP_ENUM_PARAMS(BOOST_FUNCTION_NUM_ARGS, typename T)\n\n#define BOOST_FUNCTION_TEMPLATE_ARGS BOOST_PP_ENUM_PARAMS(BOOST_FUNCTION_NUM_ARGS, T)\n\n#define BOOST_FUNCTION_PARM(J,I,D) BOOST_PP_CAT(T,I) BOOST_PP_CAT(a,I)\n\n#define BOOST_FUNCTION_PARMS BOOST_PP_ENUM(BOOST_FUNCTION_NUM_ARGS,BOOST_FUNCTION_PARM,BOOST_PP_EMPTY)\n\n#ifdef BOOST_NO_CXX11_RVALUE_REFERENCES\n#   define BOOST_FUNCTION_ARGS BOOST_PP_ENUM_PARAMS(BOOST_FUNCTION_NUM_ARGS, a)\n#else\n#   include <boost/move/utility_core.hpp>\n#   define BOOST_FUNCTION_ARG(J,I,D) ::boost::forward< BOOST_PP_CAT(T,I) >(BOOST_PP_CAT(a,I))\n#   define BOOST_FUNCTION_ARGS BOOST_PP_ENUM(BOOST_FUNCTION_NUM_ARGS,BOOST_FUNCTION_ARG,BOOST_PP_EMPTY)\n#endif\n\n#define BOOST_FUNCTION_ARG_TYPE(J,I,D) \\\n  typedef BOOST_PP_CAT(T,I) BOOST_PP_CAT(BOOST_PP_CAT(arg, BOOST_PP_INC(I)),_type);\n\n#define BOOST_FUNCTION_ARG_TYPES BOOST_PP_REPEAT(BOOST_FUNCTION_NUM_ARGS,BOOST_FUNCTION_ARG_TYPE,BOOST_PP_EMPTY)\n\n// Comma if nonzero number of arguments\n#if BOOST_FUNCTION_NUM_ARGS == 0\n#  define BOOST_FUNCTION_COMMA\n#else\n#  define BOOST_FUNCTION_COMMA ,\n#endif // BOOST_FUNCTION_NUM_ARGS > 0\n\n// Class names used in this version of the code\n#define BOOST_FUNCTION_FUNCTION BOOST_JOIN(function,BOOST_FUNCTION_NUM_ARGS)\n#define BOOST_FUNCTION_FUNCTION_INVOKER \\\n  BOOST_JOIN(function_invoker,BOOST_FUNCTION_NUM_ARGS)\n#define BOOST_FUNCTION_VOID_FUNCTION_INVOKER \\\n  BOOST_JOIN(void_function_invoker,BOOST_FUNCTION_NUM_ARGS)\n#define BOOST_FUNCTION_FUNCTION_OBJ_INVOKER \\\n  BOOST_JOIN(function_obj_invoker,BOOST_FUNCTION_NUM_ARGS)\n#define BOOST_FUNCTION_VOID_FUNCTION_OBJ_INVOKER \\\n  BOOST_JOIN(void_function_obj_invoker,BOOST_FUNCTION_NUM_ARGS)\n#define BOOST_FUNCTION_FUNCTION_REF_INVOKER \\\n  BOOST_JOIN(function_ref_invoker,BOOST_FUNCTION_NUM_ARGS)\n#define BOOST_FUNCTION_VOID_FUNCTION_REF_INVOKER \\\n  BOOST_JOIN(void_function_ref_invoker,BOOST_FUNCTION_NUM_ARGS)\n#define BOOST_FUNCTION_MEMBER_INVOKER \\\n  BOOST_JOIN(function_mem_invoker,BOOST_FUNCTION_NUM_ARGS)\n#define BOOST_FUNCTION_VOID_MEMBER_INVOKER \\\n  BOOST_JOIN(function_void_mem_invoker,BOOST_FUNCTION_NUM_ARGS)\n#define BOOST_FUNCTION_GET_FUNCTION_INVOKER \\\n  BOOST_JOIN(get_function_invoker,BOOST_FUNCTION_NUM_ARGS)\n#define BOOST_FUNCTION_GET_FUNCTION_OBJ_INVOKER \\\n  BOOST_JOIN(get_function_obj_invoker,BOOST_FUNCTION_NUM_ARGS)\n#define BOOST_FUNCTION_GET_FUNCTION_REF_INVOKER \\\n  BOOST_JOIN(get_function_ref_invoker,BOOST_FUNCTION_NUM_ARGS)\n#define BOOST_FUNCTION_GET_MEMBER_INVOKER \\\n  BOOST_JOIN(get_member_invoker,BOOST_FUNCTION_NUM_ARGS)\n#define BOOST_FUNCTION_GET_INVOKER \\\n  BOOST_JOIN(get_invoker,BOOST_FUNCTION_NUM_ARGS)\n#define BOOST_FUNCTION_VTABLE BOOST_JOIN(basic_vtable,BOOST_FUNCTION_NUM_ARGS)\n\n#ifndef BOOST_NO_VOID_RETURNS\n#  define BOOST_FUNCTION_VOID_RETURN_TYPE void\n#  define BOOST_FUNCTION_RETURN(X) X\n#else\n#  define BOOST_FUNCTION_VOID_RETURN_TYPE boost::detail::function::unusable\n#  define BOOST_FUNCTION_RETURN(X) X; return BOOST_FUNCTION_VOID_RETURN_TYPE ()\n#endif\n\nnamespace boost {\n  namespace detail {\n    namespace function {\n      template<\n        typename FunctionPtr,\n        typename R BOOST_FUNCTION_COMMA\n        BOOST_FUNCTION_TEMPLATE_PARMS\n        >\n      struct BOOST_FUNCTION_FUNCTION_INVOKER\n      {\n        static R invoke(function_buffer& function_ptr BOOST_FUNCTION_COMMA\n                        BOOST_FUNCTION_PARMS)\n        {\n          FunctionPtr f = reinterpret_cast<FunctionPtr>(function_ptr.members.func_ptr);\n          return f(BOOST_FUNCTION_ARGS);\n        }\n      };\n\n      template<\n        typename FunctionPtr,\n        typename R BOOST_FUNCTION_COMMA\n        BOOST_FUNCTION_TEMPLATE_PARMS\n        >\n      struct BOOST_FUNCTION_VOID_FUNCTION_INVOKER\n      {\n        static BOOST_FUNCTION_VOID_RETURN_TYPE\n        invoke(function_buffer& function_ptr BOOST_FUNCTION_COMMA\n               BOOST_FUNCTION_PARMS)\n\n        {\n          FunctionPtr f = reinterpret_cast<FunctionPtr>(function_ptr.members.func_ptr);\n          BOOST_FUNCTION_RETURN(f(BOOST_FUNCTION_ARGS));\n        }\n      };\n\n      template<\n        typename FunctionObj,\n        typename R BOOST_FUNCTION_COMMA\n        BOOST_FUNCTION_TEMPLATE_PARMS\n      >\n      struct BOOST_FUNCTION_FUNCTION_OBJ_INVOKER\n      {\n        static R invoke(function_buffer& function_obj_ptr BOOST_FUNCTION_COMMA\n                        BOOST_FUNCTION_PARMS)\n\n        {\n          FunctionObj* f;\n          if (function_allows_small_object_optimization<FunctionObj>::value)\n            f = reinterpret_cast<FunctionObj*>(function_obj_ptr.data);\n          else\n            f = reinterpret_cast<FunctionObj*>(function_obj_ptr.members.obj_ptr);\n          return (*f)(BOOST_FUNCTION_ARGS);\n        }\n      };\n\n      template<\n        typename FunctionObj,\n        typename R BOOST_FUNCTION_COMMA\n        BOOST_FUNCTION_TEMPLATE_PARMS\n      >\n      struct BOOST_FUNCTION_VOID_FUNCTION_OBJ_INVOKER\n      {\n        static BOOST_FUNCTION_VOID_RETURN_TYPE\n        invoke(function_buffer& function_obj_ptr BOOST_FUNCTION_COMMA\n               BOOST_FUNCTION_PARMS)\n\n        {\n          FunctionObj* f;\n          if (function_allows_small_object_optimization<FunctionObj>::value)\n            f = reinterpret_cast<FunctionObj*>(function_obj_ptr.data);\n          else\n            f = reinterpret_cast<FunctionObj*>(function_obj_ptr.members.obj_ptr);\n          BOOST_FUNCTION_RETURN((*f)(BOOST_FUNCTION_ARGS));\n        }\n      };\n\n      template<\n        typename FunctionObj,\n        typename R BOOST_FUNCTION_COMMA\n        BOOST_FUNCTION_TEMPLATE_PARMS\n      >\n      struct BOOST_FUNCTION_FUNCTION_REF_INVOKER\n      {\n        static R invoke(function_buffer& function_obj_ptr BOOST_FUNCTION_COMMA\n                        BOOST_FUNCTION_PARMS)\n\n        {\n          FunctionObj* f =\n            reinterpret_cast<FunctionObj*>(function_obj_ptr.members.obj_ptr);\n          return (*f)(BOOST_FUNCTION_ARGS);\n        }\n      };\n\n      template<\n        typename FunctionObj,\n        typename R BOOST_FUNCTION_COMMA\n        BOOST_FUNCTION_TEMPLATE_PARMS\n      >\n      struct BOOST_FUNCTION_VOID_FUNCTION_REF_INVOKER\n      {\n        static BOOST_FUNCTION_VOID_RETURN_TYPE\n        invoke(function_buffer& function_obj_ptr BOOST_FUNCTION_COMMA\n               BOOST_FUNCTION_PARMS)\n\n        {\n          FunctionObj* f =\n            reinterpret_cast<FunctionObj*>(function_obj_ptr.members.obj_ptr);\n          BOOST_FUNCTION_RETURN((*f)(BOOST_FUNCTION_ARGS));\n        }\n      };\n\n#if BOOST_FUNCTION_NUM_ARGS > 0\n      /* Handle invocation of member pointers. */\n      template<\n        typename MemberPtr,\n        typename R BOOST_FUNCTION_COMMA\n        BOOST_FUNCTION_TEMPLATE_PARMS\n      >\n      struct BOOST_FUNCTION_MEMBER_INVOKER\n      {\n        static R invoke(function_buffer& function_obj_ptr BOOST_FUNCTION_COMMA\n                        BOOST_FUNCTION_PARMS)\n\n        {\n          MemberPtr* f =\n            reinterpret_cast<MemberPtr*>(function_obj_ptr.data);\n          return boost::mem_fn(*f)(BOOST_FUNCTION_ARGS);\n        }\n      };\n\n      template<\n        typename MemberPtr,\n        typename R BOOST_FUNCTION_COMMA\n        BOOST_FUNCTION_TEMPLATE_PARMS\n      >\n      struct BOOST_FUNCTION_VOID_MEMBER_INVOKER\n      {\n        static BOOST_FUNCTION_VOID_RETURN_TYPE\n        invoke(function_buffer& function_obj_ptr BOOST_FUNCTION_COMMA\n               BOOST_FUNCTION_PARMS)\n\n        {\n          MemberPtr* f =\n            reinterpret_cast<MemberPtr*>(function_obj_ptr.data);\n          BOOST_FUNCTION_RETURN(boost::mem_fn(*f)(BOOST_FUNCTION_ARGS));\n        }\n      };\n#endif\n\n      template<\n        typename FunctionPtr,\n        typename R BOOST_FUNCTION_COMMA\n        BOOST_FUNCTION_TEMPLATE_PARMS\n      >\n      struct BOOST_FUNCTION_GET_FUNCTION_INVOKER\n      {\n        typedef typename mpl::if_c<(is_void<R>::value),\n                            BOOST_FUNCTION_VOID_FUNCTION_INVOKER<\n                            FunctionPtr,\n                            R BOOST_FUNCTION_COMMA\n                            BOOST_FUNCTION_TEMPLATE_ARGS\n                          >,\n                          BOOST_FUNCTION_FUNCTION_INVOKER<\n                            FunctionPtr,\n                            R BOOST_FUNCTION_COMMA\n                            BOOST_FUNCTION_TEMPLATE_ARGS\n                          >\n                       >::type type;\n      };\n\n      template<\n        typename FunctionObj,\n        typename R BOOST_FUNCTION_COMMA\n        BOOST_FUNCTION_TEMPLATE_PARMS\n       >\n      struct BOOST_FUNCTION_GET_FUNCTION_OBJ_INVOKER\n      {\n        typedef typename mpl::if_c<(is_void<R>::value),\n                            BOOST_FUNCTION_VOID_FUNCTION_OBJ_INVOKER<\n                            FunctionObj,\n                            R BOOST_FUNCTION_COMMA\n                            BOOST_FUNCTION_TEMPLATE_ARGS\n                          >,\n                          BOOST_FUNCTION_FUNCTION_OBJ_INVOKER<\n                            FunctionObj,\n                            R BOOST_FUNCTION_COMMA\n                            BOOST_FUNCTION_TEMPLATE_ARGS\n                          >\n                       >::type type;\n      };\n\n      template<\n        typename FunctionObj,\n        typename R BOOST_FUNCTION_COMMA\n        BOOST_FUNCTION_TEMPLATE_PARMS\n       >\n      struct BOOST_FUNCTION_GET_FUNCTION_REF_INVOKER\n      {\n        typedef typename mpl::if_c<(is_void<R>::value),\n                            BOOST_FUNCTION_VOID_FUNCTION_REF_INVOKER<\n                            FunctionObj,\n                            R BOOST_FUNCTION_COMMA\n                            BOOST_FUNCTION_TEMPLATE_ARGS\n                          >,\n                          BOOST_FUNCTION_FUNCTION_REF_INVOKER<\n                            FunctionObj,\n                            R BOOST_FUNCTION_COMMA\n                            BOOST_FUNCTION_TEMPLATE_ARGS\n                          >\n                       >::type type;\n      };\n\n#if BOOST_FUNCTION_NUM_ARGS > 0\n      /* Retrieve the appropriate invoker for a member pointer.  */\n      template<\n        typename MemberPtr,\n        typename R BOOST_FUNCTION_COMMA\n        BOOST_FUNCTION_TEMPLATE_PARMS\n       >\n      struct BOOST_FUNCTION_GET_MEMBER_INVOKER\n      {\n        typedef typename mpl::if_c<(is_void<R>::value),\n                            BOOST_FUNCTION_VOID_MEMBER_INVOKER<\n                            MemberPtr,\n                            R BOOST_FUNCTION_COMMA\n                            BOOST_FUNCTION_TEMPLATE_ARGS\n                          >,\n                          BOOST_FUNCTION_MEMBER_INVOKER<\n                            MemberPtr,\n                            R BOOST_FUNCTION_COMMA\n                            BOOST_FUNCTION_TEMPLATE_ARGS\n                          >\n                       >::type type;\n      };\n#endif\n\n      /* Given the tag returned by get_function_tag, retrieve the\n         actual invoker that will be used for the given function\n         object.\n\n         Each specialization contains an \"apply\" nested class template\n         that accepts the function object, return type, function\n         argument types, and allocator. The resulting \"apply\" class\n         contains two typedefs, \"invoker_type\" and \"manager_type\",\n         which correspond to the invoker and manager types. */\n      template<typename Tag>\n      struct BOOST_FUNCTION_GET_INVOKER { };\n\n      /* Retrieve the invoker for a function pointer. */\n      template<>\n      struct BOOST_FUNCTION_GET_INVOKER<function_ptr_tag>\n      {\n        template<typename FunctionPtr,\n                 typename R BOOST_FUNCTION_COMMA BOOST_FUNCTION_TEMPLATE_PARMS>\n        struct apply\n        {\n          typedef typename BOOST_FUNCTION_GET_FUNCTION_INVOKER<\n                             FunctionPtr,\n                             R BOOST_FUNCTION_COMMA\n                             BOOST_FUNCTION_TEMPLATE_ARGS\n                           >::type\n            invoker_type;\n\n          typedef functor_manager<FunctionPtr> manager_type;\n        };\n\n        template<typename FunctionPtr,\n                 typename R BOOST_FUNCTION_COMMA BOOST_FUNCTION_TEMPLATE_PARMS,\n                 typename Allocator>\n        struct apply_a\n        {\n          typedef typename BOOST_FUNCTION_GET_FUNCTION_INVOKER<\n                             FunctionPtr,\n                             R BOOST_FUNCTION_COMMA\n                             BOOST_FUNCTION_TEMPLATE_ARGS\n                           >::type\n            invoker_type;\n\n          typedef functor_manager<FunctionPtr> manager_type;\n        };\n      };\n\n#if BOOST_FUNCTION_NUM_ARGS > 0\n      /* Retrieve the invoker for a member pointer. */\n      template<>\n      struct BOOST_FUNCTION_GET_INVOKER<member_ptr_tag>\n      {\n        template<typename MemberPtr,\n                 typename R BOOST_FUNCTION_COMMA BOOST_FUNCTION_TEMPLATE_PARMS>\n        struct apply\n        {\n          typedef typename BOOST_FUNCTION_GET_MEMBER_INVOKER<\n                             MemberPtr,\n                             R BOOST_FUNCTION_COMMA\n                             BOOST_FUNCTION_TEMPLATE_ARGS\n                           >::type\n            invoker_type;\n\n          typedef functor_manager<MemberPtr> manager_type;\n        };\n\n        template<typename MemberPtr,\n                 typename R BOOST_FUNCTION_COMMA BOOST_FUNCTION_TEMPLATE_PARMS,\n                 typename Allocator>\n        struct apply_a\n        {\n          typedef typename BOOST_FUNCTION_GET_MEMBER_INVOKER<\n                             MemberPtr,\n                             R BOOST_FUNCTION_COMMA\n                             BOOST_FUNCTION_TEMPLATE_ARGS\n                           >::type\n            invoker_type;\n\n          typedef functor_manager<MemberPtr> manager_type;\n        };\n      };\n#endif\n\n      /* Retrieve the invoker for a function object. */\n      template<>\n      struct BOOST_FUNCTION_GET_INVOKER<function_obj_tag>\n      {\n        template<typename FunctionObj,\n                 typename R BOOST_FUNCTION_COMMA BOOST_FUNCTION_TEMPLATE_PARMS>\n        struct apply\n        {\n          typedef typename BOOST_FUNCTION_GET_FUNCTION_OBJ_INVOKER<\n                             FunctionObj,\n                             R BOOST_FUNCTION_COMMA\n                             BOOST_FUNCTION_TEMPLATE_ARGS\n                           >::type\n            invoker_type;\n\n          typedef functor_manager<FunctionObj> manager_type;\n        };\n\n        template<typename FunctionObj,\n                 typename R BOOST_FUNCTION_COMMA BOOST_FUNCTION_TEMPLATE_PARMS,\n                 typename Allocator>\n        struct apply_a\n        {\n          typedef typename BOOST_FUNCTION_GET_FUNCTION_OBJ_INVOKER<\n                             FunctionObj,\n                             R BOOST_FUNCTION_COMMA\n                             BOOST_FUNCTION_TEMPLATE_ARGS\n                           >::type\n            invoker_type;\n\n          typedef functor_manager_a<FunctionObj, Allocator> manager_type;\n        };\n      };\n\n      /* Retrieve the invoker for a reference to a function object. */\n      template<>\n      struct BOOST_FUNCTION_GET_INVOKER<function_obj_ref_tag>\n      {\n        template<typename RefWrapper,\n                 typename R BOOST_FUNCTION_COMMA BOOST_FUNCTION_TEMPLATE_PARMS>\n        struct apply\n        {\n          typedef typename BOOST_FUNCTION_GET_FUNCTION_REF_INVOKER<\n                             typename RefWrapper::type,\n                             R BOOST_FUNCTION_COMMA\n                             BOOST_FUNCTION_TEMPLATE_ARGS\n                           >::type\n            invoker_type;\n\n          typedef reference_manager<typename RefWrapper::type> manager_type;\n        };\n\n        template<typename RefWrapper,\n                 typename R BOOST_FUNCTION_COMMA BOOST_FUNCTION_TEMPLATE_PARMS,\n                 typename Allocator>\n        struct apply_a\n        {\n          typedef typename BOOST_FUNCTION_GET_FUNCTION_REF_INVOKER<\n                             typename RefWrapper::type,\n                             R BOOST_FUNCTION_COMMA\n                             BOOST_FUNCTION_TEMPLATE_ARGS\n                           >::type\n            invoker_type;\n\n          typedef reference_manager<typename RefWrapper::type> manager_type;\n        };\n      };\n\n\n      /**\n       * vtable for a specific boost::function instance. This\n       * structure must be an aggregate so that we can use static\n       * initialization in boost::function's assign_to and assign_to_a\n       * members. It therefore cannot have any constructors,\n       * destructors, base classes, etc.\n       */\n      template<typename R BOOST_FUNCTION_COMMA BOOST_FUNCTION_TEMPLATE_PARMS>\n      struct BOOST_FUNCTION_VTABLE\n      {\n#ifndef BOOST_NO_VOID_RETURNS\n        typedef R         result_type;\n#else\n        typedef typename function_return_type<R>::type result_type;\n#endif // BOOST_NO_VOID_RETURNS\n\n        typedef result_type (*invoker_type)(function_buffer&\n                                            BOOST_FUNCTION_COMMA\n                                            BOOST_FUNCTION_TEMPLATE_ARGS);\n\n        template<typename F>\n        bool assign_to(F f, function_buffer& functor) const\n        {\n          typedef typename get_function_tag<F>::type tag;\n          return assign_to(f, functor, tag());\n        }\n        template<typename F,typename Allocator>\n        bool assign_to_a(F f, function_buffer& functor, Allocator a) const\n        {\n          typedef typename get_function_tag<F>::type tag;\n          return assign_to_a(f, functor, a, tag());\n        }\n\n        void clear(function_buffer& functor) const\n        {\n          if (base.manager)\n            base.manager(functor, functor, destroy_functor_tag);\n        }\n\n      private:\n        // Function pointers\n        template<typename FunctionPtr>\n        bool\n        assign_to(FunctionPtr f, function_buffer& functor, function_ptr_tag) const\n        {\n          this->clear(functor);\n          if (f) {\n            // should be a reinterpret cast, but some compilers insist\n            // on giving cv-qualifiers to free functions\n            functor.members.func_ptr = reinterpret_cast<void (*)()>(f);\n            return true;\n          } else {\n            return false;\n          }\n        }\n        template<typename FunctionPtr,typename Allocator>\n        bool\n        assign_to_a(FunctionPtr f, function_buffer& functor, Allocator, function_ptr_tag) const\n        {\n          return assign_to(f,functor,function_ptr_tag());\n        }\n\n        // Member pointers\n#if BOOST_FUNCTION_NUM_ARGS > 0\n        template<typename MemberPtr>\n        bool assign_to(MemberPtr f, function_buffer& functor, member_ptr_tag) const\n        {\n          // DPG TBD: Add explicit support for member function\n          // objects, so we invoke through mem_fn() but we retain the\n          // right target_type() values.\n          if (f) {\n            this->assign_to(boost::mem_fn(f), functor);\n            return true;\n          } else {\n            return false;\n          }\n        }\n        template<typename MemberPtr,typename Allocator>\n        bool assign_to_a(MemberPtr f, function_buffer& functor, Allocator a, member_ptr_tag) const\n        {\n          // DPG TBD: Add explicit support for member function\n          // objects, so we invoke through mem_fn() but we retain the\n          // right target_type() values.\n          if (f) {\n            this->assign_to_a(boost::mem_fn(f), functor, a);\n            return true;\n          } else {\n            return false;\n          }\n        }\n#endif // BOOST_FUNCTION_NUM_ARGS > 0\n\n        // Function objects\n        // Assign to a function object using the small object optimization\n        template<typename FunctionObj>\n        void\n        assign_functor(FunctionObj f, function_buffer& functor, mpl::true_) const\n        {\n          new (reinterpret_cast<void*>(functor.data)) FunctionObj(f);\n        }\n        template<typename FunctionObj,typename Allocator>\n        void\n        assign_functor_a(FunctionObj f, function_buffer& functor, Allocator, mpl::true_) const\n        {\n          assign_functor(f,functor,mpl::true_());\n        }\n\n        // Assign to a function object allocated on the heap.\n        template<typename FunctionObj>\n        void\n        assign_functor(FunctionObj f, function_buffer& functor, mpl::false_) const\n        {\n          functor.members.obj_ptr = new FunctionObj(f);\n        }\n        template<typename FunctionObj,typename Allocator>\n        void\n        assign_functor_a(FunctionObj f, function_buffer& functor, Allocator a, mpl::false_) const\n        {\n          typedef functor_wrapper<FunctionObj,Allocator> functor_wrapper_type;\n          typedef typename Allocator::template rebind<functor_wrapper_type>::other\n            wrapper_allocator_type;\n          typedef typename wrapper_allocator_type::pointer wrapper_allocator_pointer_type;\n          wrapper_allocator_type wrapper_allocator(a);\n          wrapper_allocator_pointer_type copy = wrapper_allocator.allocate(1);\n          wrapper_allocator.construct(copy, functor_wrapper_type(f,a));\n          functor_wrapper_type* new_f = static_cast<functor_wrapper_type*>(copy);\n          functor.members.obj_ptr = new_f;\n        }\n\n        template<typename FunctionObj>\n        bool\n        assign_to(FunctionObj f, function_buffer& functor, function_obj_tag) const\n        {\n          if (!boost::detail::function::has_empty_target(boost::addressof(f))) {\n            assign_functor(f, functor,\n                           mpl::bool_<(function_allows_small_object_optimization<FunctionObj>::value)>());\n            return true;\n          } else {\n            return false;\n          }\n        }\n        template<typename FunctionObj,typename Allocator>\n        bool\n        assign_to_a(FunctionObj f, function_buffer& functor, Allocator a, function_obj_tag) const\n        {\n          if (!boost::detail::function::has_empty_target(boost::addressof(f))) {\n            assign_functor_a(f, functor, a,\n                           mpl::bool_<(function_allows_small_object_optimization<FunctionObj>::value)>());\n            return true;\n          } else {\n            return false;\n          }\n        }\n\n        // Reference to a function object\n        template<typename FunctionObj>\n        bool\n        assign_to(const reference_wrapper<FunctionObj>& f,\n                  function_buffer& functor, function_obj_ref_tag) const\n        {\n          functor.members.obj_ref.obj_ptr = (void *)(f.get_pointer());\n          functor.members.obj_ref.is_const_qualified = is_const<FunctionObj>::value;\n          functor.members.obj_ref.is_volatile_qualified = is_volatile<FunctionObj>::value;\n          return true;\n        }\n        template<typename FunctionObj,typename Allocator>\n        bool\n        assign_to_a(const reference_wrapper<FunctionObj>& f,\n                  function_buffer& functor, Allocator, function_obj_ref_tag) const\n        {\n          return assign_to(f,functor,function_obj_ref_tag());\n        }\n\n      public:\n        vtable_base base;\n        invoker_type invoker;\n      };\n    } // end namespace function\n  } // end namespace detail\n\n  template<\n    typename R BOOST_FUNCTION_COMMA\n    BOOST_FUNCTION_TEMPLATE_PARMS\n  >\n  class BOOST_FUNCTION_FUNCTION : public function_base\n  {\n  public:\n#ifndef BOOST_NO_VOID_RETURNS\n    typedef R         result_type;\n#else\n    typedef  typename boost::detail::function::function_return_type<R>::type\n      result_type;\n#endif // BOOST_NO_VOID_RETURNS\n\n  private:\n    typedef boost::detail::function::BOOST_FUNCTION_VTABLE<\n              R BOOST_FUNCTION_COMMA BOOST_FUNCTION_TEMPLATE_ARGS>\n      vtable_type;\n\n    vtable_type* get_vtable() const {\n      return reinterpret_cast<vtable_type*>(\n               reinterpret_cast<std::size_t>(vtable) & ~static_cast<std::size_t>(0x01));\n    }\n\n    struct clear_type {};\n\n  public:\n    BOOST_STATIC_CONSTANT(int, args = BOOST_FUNCTION_NUM_ARGS);\n\n    // add signature for boost::lambda\n    template<typename Args>\n    struct sig\n    {\n      typedef result_type type;\n    };\n\n#if BOOST_FUNCTION_NUM_ARGS == 1\n    typedef T0 argument_type;\n#elif BOOST_FUNCTION_NUM_ARGS == 2\n    typedef T0 first_argument_type;\n    typedef T1 second_argument_type;\n#endif\n\n    BOOST_STATIC_CONSTANT(int, arity = BOOST_FUNCTION_NUM_ARGS);\n    BOOST_FUNCTION_ARG_TYPES\n\n    typedef BOOST_FUNCTION_FUNCTION self_type;\n\n    BOOST_FUNCTION_FUNCTION() : function_base() { }\n\n    // MSVC chokes if the following two constructors are collapsed into\n    // one with a default parameter.\n    template<typename Functor>\n    BOOST_FUNCTION_FUNCTION(Functor BOOST_FUNCTION_TARGET_FIX(const &) f\n#ifndef BOOST_NO_SFINAE\n                            ,typename boost::enable_if_c<\n                             !(is_integral<Functor>::value),\n                                        int>::type = 0\n#endif // BOOST_NO_SFINAE\n                            ) :\n      function_base()\n    {\n      this->assign_to(f);\n    }\n    template<typename Functor,typename Allocator>\n    BOOST_FUNCTION_FUNCTION(Functor BOOST_FUNCTION_TARGET_FIX(const &) f, Allocator a\n#ifndef BOOST_NO_SFINAE\n                            ,typename boost::enable_if_c<\n                              !(is_integral<Functor>::value),\n                                        int>::type = 0\n#endif // BOOST_NO_SFINAE\n                            ) :\n      function_base()\n    {\n      this->assign_to_a(f,a);\n    }\n\n#ifndef BOOST_NO_SFINAE\n    BOOST_FUNCTION_FUNCTION(clear_type*) : function_base() { }\n#else\n    BOOST_FUNCTION_FUNCTION(int zero) : function_base()\n    {\n      BOOST_ASSERT(zero == 0);\n    }\n#endif\n\n    BOOST_FUNCTION_FUNCTION(const BOOST_FUNCTION_FUNCTION& f) : function_base()\n    {\n      this->assign_to_own(f);\n    }\n\n#ifndef BOOST_NO_CXX11_RVALUE_REFERENCES\n    BOOST_FUNCTION_FUNCTION(BOOST_FUNCTION_FUNCTION&& f) : function_base()\n    {\n      this->move_assign(f);\n    }\n#endif\n\n    ~BOOST_FUNCTION_FUNCTION() { clear(); }\n\n    result_type operator()(BOOST_FUNCTION_PARMS) const\n    {\n      if (this->empty())\n        boost::throw_exception(bad_function_call());\n\n      return get_vtable()->invoker\n               (this->functor BOOST_FUNCTION_COMMA BOOST_FUNCTION_ARGS);\n    }\n\n    // The distinction between when to use BOOST_FUNCTION_FUNCTION and\n    // when to use self_type is obnoxious. MSVC cannot handle self_type as\n    // the return type of these assignment operators, but Borland C++ cannot\n    // handle BOOST_FUNCTION_FUNCTION as the type of the temporary to\n    // construct.\n    template<typename Functor>\n#ifndef BOOST_NO_SFINAE\n    typename boost::enable_if_c<\n                  !(is_integral<Functor>::value),\n               BOOST_FUNCTION_FUNCTION&>::type\n#else\n    BOOST_FUNCTION_FUNCTION&\n#endif\n    operator=(Functor BOOST_FUNCTION_TARGET_FIX(const &) f)\n    {\n      this->clear();\n      BOOST_TRY  {\n        this->assign_to(f);\n      } BOOST_CATCH (...) {\n        vtable = 0;\n        BOOST_RETHROW;\n      }\n      BOOST_CATCH_END\n      return *this;\n    }\n    template<typename Functor,typename Allocator>\n    void assign(Functor BOOST_FUNCTION_TARGET_FIX(const &) f, Allocator a)\n    {\n      this->clear();\n      BOOST_TRY{\n        this->assign_to_a(f,a);\n      } BOOST_CATCH (...) {\n        vtable = 0;\n        BOOST_RETHROW;\n      }\n      BOOST_CATCH_END\n    }\n\n#ifndef BOOST_NO_SFINAE\n    BOOST_FUNCTION_FUNCTION& operator=(clear_type*)\n    {\n      this->clear();\n      return *this;\n    }\n#else\n    BOOST_FUNCTION_FUNCTION& operator=(int zero)\n    {\n      BOOST_ASSERT(zero == 0);\n      this->clear();\n      return *this;\n    }\n#endif\n\n    // Assignment from another BOOST_FUNCTION_FUNCTION\n    BOOST_FUNCTION_FUNCTION& operator=(const BOOST_FUNCTION_FUNCTION& f)\n    {\n      if (&f == this)\n        return *this;\n\n      this->clear();\n      BOOST_TRY {\n        this->assign_to_own(f);\n      } BOOST_CATCH (...) {\n        vtable = 0;\n        BOOST_RETHROW;\n      }\n      BOOST_CATCH_END\n      return *this;\n    }\n\n#ifndef BOOST_NO_CXX11_RVALUE_REFERENCES\n    // Move assignment from another BOOST_FUNCTION_FUNCTION\n    BOOST_FUNCTION_FUNCTION& operator=(BOOST_FUNCTION_FUNCTION&& f)\n    {\n      if (&f == this)\n        return *this;\n\n      this->clear();\n      BOOST_TRY {\n        this->move_assign(f);\n      } BOOST_CATCH (...) {\n        vtable = 0;\n        BOOST_RETHROW;\n      }\n      BOOST_CATCH_END\n      return *this;\n    }\n#endif\n\n    void swap(BOOST_FUNCTION_FUNCTION& other)\n    {\n      if (&other == this)\n        return;\n\n      BOOST_FUNCTION_FUNCTION tmp;\n      tmp.move_assign(*this);\n      this->move_assign(other);\n      other.move_assign(tmp);\n    }\n\n    // Clear out a target, if there is one\n    void clear()\n    {\n      if (vtable) {\n        if (!this->has_trivial_copy_and_destroy())\n          get_vtable()->clear(this->functor);\n        vtable = 0;\n      }\n    }\n\n#if (defined __SUNPRO_CC) && (__SUNPRO_CC <= 0x530) && !(defined BOOST_NO_COMPILER_CONFIG)\n    // Sun C++ 5.3 can't handle the safe_bool idiom, so don't use it\n    operator bool () const { return !this->empty(); }\n#else\n  private:\n    struct dummy {\n      void nonnull() {}\n    };\n\n    typedef void (dummy::*safe_bool)();\n\n  public:\n    operator safe_bool () const\n      { return (this->empty())? 0 : &dummy::nonnull; }\n\n    bool operator!() const\n      { return this->empty(); }\n#endif\n\n  private:\n    void assign_to_own(const BOOST_FUNCTION_FUNCTION& f)\n    {\n      if (!f.empty()) {\n        this->vtable = f.vtable;\n        if (this->has_trivial_copy_and_destroy())\n          this->functor = f.functor;\n        else\n          get_vtable()->base.manager(f.functor, this->functor,\n                                     boost::detail::function::clone_functor_tag);\n      }\n    }\n\n    template<typename Functor>\n    void assign_to(Functor f)\n    {\n      using boost::detail::function::vtable_base;\n\n      typedef typename boost::detail::function::get_function_tag<Functor>::type tag;\n      typedef boost::detail::function::BOOST_FUNCTION_GET_INVOKER<tag> get_invoker;\n      typedef typename get_invoker::\n                         template apply<Functor, R BOOST_FUNCTION_COMMA\n                        BOOST_FUNCTION_TEMPLATE_ARGS>\n        handler_type;\n\n      typedef typename handler_type::invoker_type invoker_type;\n      typedef typename handler_type::manager_type manager_type;\n\n      // Note: it is extremely important that this initialization use\n      // static initialization. Otherwise, we will have a race\n      // condition here in multi-threaded code. See\n      // http://thread.gmane.org/gmane.comp.lib.boost.devel/164902/.\n      static const vtable_type stored_vtable =\n        { { &manager_type::manage }, &invoker_type::invoke };\n\n      if (stored_vtable.assign_to(f, functor)) {\n        std::size_t value = reinterpret_cast<std::size_t>(&stored_vtable.base);\n        // coverity[pointless_expression]: suppress coverity warnings on apparant if(const).\n        if (boost::has_trivial_copy_constructor<Functor>::value &&\n            boost::has_trivial_destructor<Functor>::value &&\n            boost::detail::function::function_allows_small_object_optimization<Functor>::value)\n          value |= static_cast<std::size_t>(0x01);\n        vtable = reinterpret_cast<boost::detail::function::vtable_base *>(value);\n      } else\n        vtable = 0;\n    }\n\n    template<typename Functor,typename Allocator>\n    void assign_to_a(Functor f,Allocator a)\n    {\n      using boost::detail::function::vtable_base;\n\n      typedef typename boost::detail::function::get_function_tag<Functor>::type tag;\n      typedef boost::detail::function::BOOST_FUNCTION_GET_INVOKER<tag> get_invoker;\n      typedef typename get_invoker::\n                         template apply_a<Functor, R BOOST_FUNCTION_COMMA\n                         BOOST_FUNCTION_TEMPLATE_ARGS,\n                         Allocator>\n        handler_type;\n\n      typedef typename handler_type::invoker_type invoker_type;\n      typedef typename handler_type::manager_type manager_type;\n\n      // Note: it is extremely important that this initialization use\n      // static initialization. Otherwise, we will have a race\n      // condition here in multi-threaded code. See\n      // http://thread.gmane.org/gmane.comp.lib.boost.devel/164902/.\n      static const vtable_type stored_vtable =\n        { { &manager_type::manage }, &invoker_type::invoke };\n\n      if (stored_vtable.assign_to_a(f, functor, a)) {\n        std::size_t value = reinterpret_cast<std::size_t>(&stored_vtable.base);\n        // coverity[pointless_expression]: suppress coverity warnings on apparant if(const).\n        if (boost::has_trivial_copy_constructor<Functor>::value &&\n            boost::has_trivial_destructor<Functor>::value &&\n            boost::detail::function::function_allows_small_object_optimization<Functor>::value)\n          value |= static_cast<std::size_t>(0x01);\n        vtable = reinterpret_cast<boost::detail::function::vtable_base *>(value);\n      } else\n        vtable = 0;\n    }\n\n    // Moves the value from the specified argument to *this. If the argument\n    // has its function object allocated on the heap, move_assign will pass\n    // its buffer to *this, and set the argument's buffer pointer to NULL.\n    void move_assign(BOOST_FUNCTION_FUNCTION& f)\n    {\n      if (&f == this)\n        return;\n\n      BOOST_TRY {\n        if (!f.empty()) {\n          this->vtable = f.vtable;\n          if (this->has_trivial_copy_and_destroy())\n            this->functor = f.functor;\n          else\n            get_vtable()->base.manager(f.functor, this->functor,\n                                     boost::detail::function::move_functor_tag);\n          f.vtable = 0;\n        } else {\n          clear();\n        }\n      } BOOST_CATCH (...) {\n        vtable = 0;\n        BOOST_RETHROW;\n      }\n      BOOST_CATCH_END\n    }\n  };\n\n  template<typename R BOOST_FUNCTION_COMMA BOOST_FUNCTION_TEMPLATE_PARMS>\n  inline void swap(BOOST_FUNCTION_FUNCTION<\n                     R BOOST_FUNCTION_COMMA\n                     BOOST_FUNCTION_TEMPLATE_ARGS\n                   >& f1,\n                   BOOST_FUNCTION_FUNCTION<\n                     R BOOST_FUNCTION_COMMA\n                     BOOST_FUNCTION_TEMPLATE_ARGS\n                   >& f2)\n  {\n    f1.swap(f2);\n  }\n\n// Poison comparisons between boost::function objects of the same type.\ntemplate<typename R BOOST_FUNCTION_COMMA BOOST_FUNCTION_TEMPLATE_PARMS>\n  void operator==(const BOOST_FUNCTION_FUNCTION<\n                          R BOOST_FUNCTION_COMMA\n                          BOOST_FUNCTION_TEMPLATE_ARGS>&,\n                  const BOOST_FUNCTION_FUNCTION<\n                          R BOOST_FUNCTION_COMMA\n                          BOOST_FUNCTION_TEMPLATE_ARGS>&);\ntemplate<typename R BOOST_FUNCTION_COMMA BOOST_FUNCTION_TEMPLATE_PARMS>\n  void operator!=(const BOOST_FUNCTION_FUNCTION<\n                          R BOOST_FUNCTION_COMMA\n                          BOOST_FUNCTION_TEMPLATE_ARGS>&,\n                  const BOOST_FUNCTION_FUNCTION<\n                          R BOOST_FUNCTION_COMMA\n                          BOOST_FUNCTION_TEMPLATE_ARGS>& );\n\n#if !defined(BOOST_FUNCTION_NO_FUNCTION_TYPE_SYNTAX)\n\n#if BOOST_FUNCTION_NUM_ARGS == 0\n#define BOOST_FUNCTION_PARTIAL_SPEC R (void)\n#else\n#define BOOST_FUNCTION_PARTIAL_SPEC R (BOOST_PP_ENUM_PARAMS(BOOST_FUNCTION_NUM_ARGS,T))\n#endif\n\ntemplate<typename R BOOST_FUNCTION_COMMA\n         BOOST_FUNCTION_TEMPLATE_PARMS>\nclass function<BOOST_FUNCTION_PARTIAL_SPEC>\n  : public BOOST_FUNCTION_FUNCTION<R BOOST_FUNCTION_COMMA BOOST_FUNCTION_TEMPLATE_ARGS>\n{\n  typedef BOOST_FUNCTION_FUNCTION<R BOOST_FUNCTION_COMMA BOOST_FUNCTION_TEMPLATE_ARGS> base_type;\n  typedef function self_type;\n\n  struct clear_type {};\n\npublic:\n\n  function() : base_type() {}\n\n  template<typename Functor>\n  function(Functor f\n#ifndef BOOST_NO_SFINAE\n           ,typename boost::enable_if_c<\n                          !(is_integral<Functor>::value),\n                       int>::type = 0\n#endif\n           ) :\n    base_type(f)\n  {\n  }\n  template<typename Functor,typename Allocator>\n  function(Functor f, Allocator a\n#ifndef BOOST_NO_SFINAE\n           ,typename boost::enable_if_c<\n                           !(is_integral<Functor>::value),\n                       int>::type = 0\n#endif\n           ) :\n    base_type(f,a)\n  {\n  }\n\n#ifndef BOOST_NO_SFINAE\n  function(clear_type*) : base_type() {}\n#endif\n\n  function(const self_type& f) : base_type(static_cast<const base_type&>(f)){}\n\n  function(const base_type& f) : base_type(static_cast<const base_type&>(f)){}\n\n#ifndef BOOST_NO_CXX11_RVALUE_REFERENCES\n  // Move constructors\n  function(self_type&& f): base_type(static_cast<base_type&&>(f)){}\n  function(base_type&& f): base_type(static_cast<base_type&&>(f)){}\n#endif\n\n  self_type& operator=(const self_type& f)\n  {\n    self_type(f).swap(*this);\n    return *this;\n  }\n\n#ifndef BOOST_NO_CXX11_RVALUE_REFERENCES\n  self_type& operator=(self_type&& f)\n  {\n    self_type(static_cast<self_type&&>(f)).swap(*this);\n    return *this;\n  }\n#endif\n\n  template<typename Functor>\n#ifndef BOOST_NO_SFINAE\n  typename boost::enable_if_c<\n                         !(is_integral<Functor>::value),\n                      self_type&>::type\n#else\n  self_type&\n#endif\n  operator=(Functor f)\n  {\n    self_type(f).swap(*this);\n    return *this;\n  }\n\n#ifndef BOOST_NO_SFINAE\n  self_type& operator=(clear_type*)\n  {\n    this->clear();\n    return *this;\n  }\n#endif\n\n  self_type& operator=(const base_type& f)\n  {\n    self_type(f).swap(*this);\n    return *this;\n  }\n\n#ifndef BOOST_NO_CXX11_RVALUE_REFERENCES\n  self_type& operator=(base_type&& f)\n  {\n    self_type(static_cast<base_type&&>(f)).swap(*this);\n    return *this;\n  }\n#endif\n};\n\n#undef BOOST_FUNCTION_PARTIAL_SPEC\n#endif // have partial specialization\n\n} // end namespace boost\n\n// Cleanup after ourselves...\n#undef BOOST_FUNCTION_VTABLE\n#undef BOOST_FUNCTION_COMMA\n#undef BOOST_FUNCTION_FUNCTION\n#undef BOOST_FUNCTION_FUNCTION_INVOKER\n#undef BOOST_FUNCTION_VOID_FUNCTION_INVOKER\n#undef BOOST_FUNCTION_FUNCTION_OBJ_INVOKER\n#undef BOOST_FUNCTION_VOID_FUNCTION_OBJ_INVOKER\n#undef BOOST_FUNCTION_FUNCTION_REF_INVOKER\n#undef BOOST_FUNCTION_VOID_FUNCTION_REF_INVOKER\n#undef BOOST_FUNCTION_MEMBER_INVOKER\n#undef BOOST_FUNCTION_VOID_MEMBER_INVOKER\n#undef BOOST_FUNCTION_GET_FUNCTION_INVOKER\n#undef BOOST_FUNCTION_GET_FUNCTION_OBJ_INVOKER\n#undef BOOST_FUNCTION_GET_FUNCTION_REF_INVOKER\n#undef BOOST_FUNCTION_GET_MEM_FUNCTION_INVOKER\n#undef BOOST_FUNCTION_GET_INVOKER\n#undef BOOST_FUNCTION_TEMPLATE_PARMS\n#undef BOOST_FUNCTION_TEMPLATE_ARGS\n#undef BOOST_FUNCTION_PARMS\n#undef BOOST_FUNCTION_PARM\n#ifdef BOOST_FUNCTION_ARG\n#   undef BOOST_FUNCTION_ARG\n#endif\n#undef BOOST_FUNCTION_ARGS\n#undef BOOST_FUNCTION_ARG_TYPE\n#undef BOOST_FUNCTION_ARG_TYPES\n#undef BOOST_FUNCTION_VOID_RETURN_TYPE\n#undef BOOST_FUNCTION_RETURN\n\n#if defined(BOOST_MSVC)\n#   pragma warning( pop )\n#endif\n"}, "4": {"id": 4, "path": "/usr/include/c++/7/sstream", "content": "// String based streams -*- C++ -*-\n\n// Copyright (C) 1997-2017 Free Software Foundation, Inc.\n//\n// This file is part of the GNU ISO C++ Library.  This library is free\n// software; you can redistribute it and/or modify it under the\n// terms of the GNU General Public License as published by the\n// Free Software Foundation; either version 3, or (at your option)\n// any later version.\n\n// This library is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n\n// Under Section 7 of GPL version 3, you are granted additional\n// permissions described in the GCC Runtime Library Exception, version\n// 3.1, as published by the Free Software Foundation.\n\n// You should have received a copy of the GNU General Public License and\n// a copy of the GCC Runtime Library Exception along with this program;\n// see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n// <http://www.gnu.org/licenses/>.\n\n/** @file include/sstream\n *  This is a Standard C++ Library header.\n */\n\n//\n// ISO C++ 14882: 27.7  String-based streams\n//\n\n#ifndef _GLIBCXX_SSTREAM\n#define _GLIBCXX_SSTREAM 1\n\n#pragma GCC system_header\n\n#include <istream>\n#include <ostream>\n\nnamespace std _GLIBCXX_VISIBILITY(default)\n{\n_GLIBCXX_BEGIN_NAMESPACE_VERSION\n_GLIBCXX_BEGIN_NAMESPACE_CXX11\n\n  // [27.7.1] template class basic_stringbuf\n  /**\n   *  @brief  The actual work of input and output (for std::string).\n   *  @ingroup io\n   *\n   *  @tparam _CharT  Type of character stream.\n   *  @tparam _Traits  Traits for character type, defaults to\n   *                   char_traits<_CharT>.\n   *  @tparam _Alloc  Allocator type, defaults to allocator<_CharT>.\n   *\n   *  This class associates either or both of its input and output sequences\n   *  with a sequence of characters, which can be initialized from, or made\n   *  available as, a @c std::basic_string.  (Paraphrased from [27.7.1]/1.)\n   *\n   *  For this class, open modes (of type @c ios_base::openmode) have\n   *  @c in set if the input sequence can be read, and @c out set if the\n   *  output sequence can be written.\n  */\n  template<typename _CharT, typename _Traits, typename _Alloc>\n    class basic_stringbuf : public basic_streambuf<_CharT, _Traits>\n    {\n      struct __xfer_bufptrs;\n    public:\n      // Types:\n      typedef _CharT \t\t\t\t\tchar_type;\n      typedef _Traits \t\t\t\t\ttraits_type;\n      // _GLIBCXX_RESOLVE_LIB_DEFECTS\n      // 251. basic_stringbuf missing allocator_type\n      typedef _Alloc\t\t\t\t       \tallocator_type;\n      typedef typename traits_type::int_type \t\tint_type;\n      typedef typename traits_type::pos_type \t\tpos_type;\n      typedef typename traits_type::off_type \t\toff_type;\n\n      typedef basic_streambuf<char_type, traits_type>  \t__streambuf_type;\n      typedef basic_string<char_type, _Traits, _Alloc> \t__string_type;\n      typedef typename __string_type::size_type\t\t__size_type;\n\n    protected:\n      /// Place to stash in || out || in | out settings for current stringbuf.\n      ios_base::openmode \t_M_mode;\n\n      // Data Members:\n      __string_type \t\t_M_string;\n\n    public:\n      // Constructors:\n      /**\n       *  @brief  Starts with an empty string buffer.\n       *  @param  __mode  Whether the buffer can read, or write, or both.\n       *\n       *  The default constructor initializes the parent class using its\n       *  own default ctor.\n      */\n      explicit\n      basic_stringbuf(ios_base::openmode __mode = ios_base::in | ios_base::out)\n      : __streambuf_type(), _M_mode(__mode), _M_string()\n      { }\n\n      /**\n       *  @brief  Starts with an existing string buffer.\n       *  @param  __str  A string to copy as a starting buffer.\n       *  @param  __mode  Whether the buffer can read, or write, or both.\n       *\n       *  This constructor initializes the parent class using its\n       *  own default ctor.\n      */\n      explicit\n      basic_stringbuf(const __string_type& __str,\n\t\t      ios_base::openmode __mode = ios_base::in | ios_base::out)\n      : __streambuf_type(), _M_mode(), _M_string(__str.data(), __str.size())\n      { _M_stringbuf_init(__mode); }\n\n#if __cplusplus >= 201103L\n      basic_stringbuf(const basic_stringbuf&) = delete;\n\n      basic_stringbuf(basic_stringbuf&& __rhs)\n      : basic_stringbuf(std::move(__rhs), __xfer_bufptrs(__rhs, this))\n      { __rhs._M_sync(const_cast<char_type*>(__rhs._M_string.data()), 0, 0); }\n\n      // 27.8.2.2 Assign and swap:\n\n      basic_stringbuf&\n      operator=(const basic_stringbuf&) = delete;\n\n      basic_stringbuf&\n      operator=(basic_stringbuf&& __rhs)\n      {\n\t__xfer_bufptrs __st{__rhs, this};\n\tconst __streambuf_type& __base = __rhs;\n\t__streambuf_type::operator=(__base);\n\tthis->pubimbue(__rhs.getloc());\n\t_M_mode = __rhs._M_mode;\n\t_M_string = std::move(__rhs._M_string);\n\t__rhs._M_sync(const_cast<char_type*>(__rhs._M_string.data()), 0, 0);\n\treturn *this;\n      }\n\n      void\n      swap(basic_stringbuf& __rhs)\n      {\n\t__xfer_bufptrs __l_st{*this, std::__addressof(__rhs)};\n\t__xfer_bufptrs __r_st{__rhs, this};\n\t__streambuf_type& __base = __rhs;\n\t__streambuf_type::swap(__base);\n\t__rhs.pubimbue(this->pubimbue(__rhs.getloc()));\n\tstd::swap(_M_mode, __rhs._M_mode);\n\tstd::swap(_M_string, __rhs._M_string);\n      }\n#endif\n\n      // Get and set:\n      /**\n       *  @brief  Copying out the string buffer.\n       *  @return  A copy of one of the underlying sequences.\n       *\n       *  <em>If the buffer is only created in input mode, the underlying\n       *  character sequence is equal to the input sequence; otherwise, it\n       *  is equal to the output sequence.</em> [27.7.1.2]/1\n      */\n      __string_type\n      str() const\n      {\n\t__string_type __ret;\n\tif (this->pptr())\n\t  {\n\t    // The current egptr() may not be the actual string end.\n\t    if (this->pptr() > this->egptr())\n\t      __ret = __string_type(this->pbase(), this->pptr());\n\t    else\n \t      __ret = __string_type(this->pbase(), this->egptr());\n\t  }\n\telse\n\t  __ret = _M_string;\n\treturn __ret;\n      }\n\n      /**\n       *  @brief  Setting a new buffer.\n       *  @param  __s  The string to use as a new sequence.\n       *\n       *  Deallocates any previous stored sequence, then copies @a s to\n       *  use as a new one.\n      */\n      void\n      str(const __string_type& __s)\n      {\n\t// Cannot use _M_string = __s, since v3 strings are COW\n\t// (not always true now but assign() always works).\n\t_M_string.assign(__s.data(), __s.size());\n\t_M_stringbuf_init(_M_mode);\n      }\n\n    protected:\n      // Common initialization code goes here.\n      void\n      _M_stringbuf_init(ios_base::openmode __mode)\n      {\n\t_M_mode = __mode;\n\t__size_type __len = 0;\n\tif (_M_mode & (ios_base::ate | ios_base::app))\n\t  __len = _M_string.size();\n\t_M_sync(const_cast<char_type*>(_M_string.data()), 0, __len);\n      }\n\n      virtual streamsize\n      showmanyc()\n      {\n\tstreamsize __ret = -1;\n\tif (_M_mode & ios_base::in)\n\t  {\n\t    _M_update_egptr();\n\t    __ret = this->egptr() - this->gptr();\n\t  }\n\treturn __ret;\n      }\n\n      virtual int_type\n      underflow();\n\n      virtual int_type\n      pbackfail(int_type __c = traits_type::eof());\n\n      virtual int_type\n      overflow(int_type __c = traits_type::eof());\n\n      /**\n       *  @brief  Manipulates the buffer.\n       *  @param  __s  Pointer to a buffer area.\n       *  @param  __n  Size of @a __s.\n       *  @return  @c this\n       *\n       *  If no buffer has already been created, and both @a __s and @a __n are\n       *  non-zero, then @c __s is used as a buffer; see\n       *  https://gcc.gnu.org/onlinedocs/libstdc++/manual/streambufs.html#io.streambuf.buffering\n       *  for more.\n      */\n      virtual __streambuf_type*\n      setbuf(char_type* __s, streamsize __n)\n      {\n\tif (__s && __n >= 0)\n\t  {\n\t    // This is implementation-defined behavior, and assumes\n\t    // that an external char_type array of length __n exists\n\t    // and has been pre-allocated. If this is not the case,\n\t    // things will quickly blow up.\n\n\t    // Step 1: Destroy the current internal array.\n\t    _M_string.clear();\n\n\t    // Step 2: Use the external array.\n\t    _M_sync(__s, __n, 0);\n\t  }\n\treturn this;\n      }\n\n      virtual pos_type\n      seekoff(off_type __off, ios_base::seekdir __way,\n\t      ios_base::openmode __mode = ios_base::in | ios_base::out);\n\n      virtual pos_type\n      seekpos(pos_type __sp,\n\t      ios_base::openmode __mode = ios_base::in | ios_base::out);\n\n      // Internal function for correctly updating the internal buffer\n      // for a particular _M_string, due to initialization or re-sizing\n      // of an existing _M_string.\n      void\n      _M_sync(char_type* __base, __size_type __i, __size_type __o);\n\n      // Internal function for correctly updating egptr() to the actual\n      // string end.\n      void\n      _M_update_egptr()\n      {\n\tconst bool __testin = _M_mode & ios_base::in;\n\tif (this->pptr() && this->pptr() > this->egptr())\n\t  {\n\t    if (__testin)\n\t      this->setg(this->eback(), this->gptr(), this->pptr());\n\t    else\n\t      this->setg(this->pptr(), this->pptr(), this->pptr());\n\t  }\n      }\n\n      // Works around the issue with pbump, part of the protected\n      // interface of basic_streambuf, taking just an int.\n      void\n      _M_pbump(char_type* __pbeg, char_type* __pend, off_type __off);\n\n    private:\n#if __cplusplus >= 201103L\n#if _GLIBCXX_USE_CXX11_ABI\n      // This type captures the state of the gptr / pptr pointers as offsets\n      // so they can be restored in another object after moving the string.\n      struct __xfer_bufptrs\n      {\n\t__xfer_bufptrs(const basic_stringbuf& __from, basic_stringbuf* __to)\n\t: _M_to{__to}, _M_goff{-1, -1, -1}, _M_poff{-1, -1, -1}\n\t{\n\t  const _CharT* const __str = __from._M_string.data();\n\t  const _CharT* __end = nullptr;\n\t  if (__from.eback())\n\t    {\n\t      _M_goff[0] = __from.eback() - __str;\n\t      _M_goff[1] = __from.gptr() - __str;\n\t      _M_goff[2] = __from.egptr() - __str;\n\t      __end = __from.egptr();\n\t    }\n\t  if (__from.pbase())\n\t    {\n\t      _M_poff[0] = __from.pbase() - __str;\n\t      _M_poff[1] = __from.pptr() - __from.pbase();\n\t      _M_poff[2] = __from.epptr() - __str;\n\t      if (__from.pptr() > __end)\n\t\t__end = __from.pptr();\n\t    }\n\n\t  // Set _M_string length to the greater of the get and put areas.\n\t  if (__end)\n\t    {\n\t      // The const_cast avoids changing this constructor's signature,\n\t      // because it is exported from the dynamic library.\n\t      auto& __mut_from = const_cast<basic_stringbuf&>(__from);\n\t      __mut_from._M_string._M_length(__end - __str);\n\t    }\n\t}\n\n\t~__xfer_bufptrs()\n\t{\n\t  char_type* __str = const_cast<char_type*>(_M_to->_M_string.data());\n\t  if (_M_goff[0] != -1)\n\t    _M_to->setg(__str+_M_goff[0], __str+_M_goff[1], __str+_M_goff[2]);\n\t  if (_M_poff[0] != -1)\n\t    _M_to->_M_pbump(__str+_M_poff[0], __str+_M_poff[2], _M_poff[1]);\n\t}\n\n\tbasic_stringbuf* _M_to;\n\toff_type _M_goff[3];\n\toff_type _M_poff[3];\n      };\n#else\n      // This type does nothing when using Copy-On-Write strings.\n      struct __xfer_bufptrs\n      {\n\t__xfer_bufptrs(const basic_stringbuf&, basic_stringbuf*) { }\n      };\n#endif\n\n      // The move constructor initializes an __xfer_bufptrs temporary then\n      // delegates to this constructor to performs moves during its lifetime.\n      basic_stringbuf(basic_stringbuf&& __rhs, __xfer_bufptrs&&)\n      : __streambuf_type(static_cast<const __streambuf_type&>(__rhs)),\n      _M_mode(__rhs._M_mode), _M_string(std::move(__rhs._M_string))\n      { }\n#endif\n    };\n\n\n  // [27.7.2] Template class basic_istringstream\n  /**\n   *  @brief  Controlling input for std::string.\n   *  @ingroup io\n   *\n   *  @tparam _CharT  Type of character stream.\n   *  @tparam _Traits  Traits for character type, defaults to\n   *                   char_traits<_CharT>.\n   *  @tparam _Alloc  Allocator type, defaults to allocator<_CharT>.\n   *\n   *  This class supports reading from objects of type std::basic_string,\n   *  using the inherited functions from std::basic_istream.  To control\n   *  the associated sequence, an instance of std::basic_stringbuf is used,\n   *  which this page refers to as @c sb.\n  */\n  template<typename _CharT, typename _Traits, typename _Alloc>\n    class basic_istringstream : public basic_istream<_CharT, _Traits>\n    {\n    public:\n      // Types:\n      typedef _CharT \t\t\t\t\tchar_type;\n      typedef _Traits \t\t\t\t\ttraits_type;\n      // _GLIBCXX_RESOLVE_LIB_DEFECTS\n      // 251. basic_stringbuf missing allocator_type\n      typedef _Alloc\t\t\t\t       \tallocator_type;\n      typedef typename traits_type::int_type \t\tint_type;\n      typedef typename traits_type::pos_type \t\tpos_type;\n      typedef typename traits_type::off_type \t\toff_type;\n\n      // Non-standard types:\n      typedef basic_string<_CharT, _Traits, _Alloc> \t__string_type;\n      typedef basic_stringbuf<_CharT, _Traits, _Alloc> \t__stringbuf_type;\n      typedef basic_istream<char_type, traits_type>\t__istream_type;\n\n    private:\n      __stringbuf_type\t_M_stringbuf;\n\n    public:\n      // Constructors:\n      /**\n       *  @brief  Default constructor starts with an empty string buffer.\n       *  @param  __mode  Whether the buffer can read, or write, or both.\n       *\n       *  @c ios_base::in is automatically included in @a __mode.\n       *\n       *  Initializes @c sb using @c __mode|in, and passes @c &sb to the base\n       *  class initializer.  Does not allocate any buffer.\n       *\n       *  That's a lie.  We initialize the base class with NULL, because the\n       *  string class does its own memory management.\n      */\n      explicit\n      basic_istringstream(ios_base::openmode __mode = ios_base::in)\n      : __istream_type(), _M_stringbuf(__mode | ios_base::in)\n      { this->init(&_M_stringbuf); }\n\n      /**\n       *  @brief  Starts with an existing string buffer.\n       *  @param  __str  A string to copy as a starting buffer.\n       *  @param  __mode  Whether the buffer can read, or write, or both.\n       *\n       *  @c ios_base::in is automatically included in @a mode.\n       *\n       *  Initializes @c sb using @a str and @c mode|in, and passes @c &sb\n       *  to the base class initializer.\n       *\n       *  That's a lie.  We initialize the base class with NULL, because the\n       *  string class does its own memory management.\n      */\n      explicit\n      basic_istringstream(const __string_type& __str,\n\t\t\t  ios_base::openmode __mode = ios_base::in)\n      : __istream_type(), _M_stringbuf(__str, __mode | ios_base::in)\n      { this->init(&_M_stringbuf); }\n\n      /**\n       *  @brief  The destructor does nothing.\n       *\n       *  The buffer is deallocated by the stringbuf object, not the\n       *  formatting stream.\n      */\n      ~basic_istringstream()\n      { }\n\n#if __cplusplus >= 201103L\n      basic_istringstream(const basic_istringstream&) = delete;\n\n      basic_istringstream(basic_istringstream&& __rhs)\n      : __istream_type(std::move(__rhs)),\n      _M_stringbuf(std::move(__rhs._M_stringbuf))\n      { __istream_type::set_rdbuf(&_M_stringbuf); }\n\n      // 27.8.3.2 Assign and swap:\n\n      basic_istringstream&\n      operator=(const basic_istringstream&) = delete;\n\n      basic_istringstream&\n      operator=(basic_istringstream&& __rhs)\n      {\n\t__istream_type::operator=(std::move(__rhs));\n\t_M_stringbuf = std::move(__rhs._M_stringbuf);\n\treturn *this;\n      }\n\n      void\n      swap(basic_istringstream& __rhs)\n      {\n\t__istream_type::swap(__rhs);\n\t_M_stringbuf.swap(__rhs._M_stringbuf);\n      }\n#endif\n\n      // Members:\n      /**\n       *  @brief  Accessing the underlying buffer.\n       *  @return  The current basic_stringbuf buffer.\n       *\n       *  This hides both signatures of std::basic_ios::rdbuf().\n      */\n      __stringbuf_type*\n      rdbuf() const\n      { return const_cast<__stringbuf_type*>(&_M_stringbuf); }\n\n      /**\n       *  @brief  Copying out the string buffer.\n       *  @return  @c rdbuf()->str()\n      */\n      __string_type\n      str() const\n      { return _M_stringbuf.str(); }\n\n      /**\n       *  @brief  Setting a new buffer.\n       *  @param  __s  The string to use as a new sequence.\n       *\n       *  Calls @c rdbuf()->str(s).\n      */\n      void\n      str(const __string_type& __s)\n      { _M_stringbuf.str(__s); }\n    };\n\n\n  // [27.7.3] Template class basic_ostringstream\n  /**\n   *  @brief  Controlling output for std::string.\n   *  @ingroup io\n   *\n   *  @tparam _CharT  Type of character stream.\n   *  @tparam _Traits  Traits for character type, defaults to\n   *                   char_traits<_CharT>.\n   *  @tparam _Alloc  Allocator type, defaults to allocator<_CharT>.\n   *\n   *  This class supports writing to objects of type std::basic_string,\n   *  using the inherited functions from std::basic_ostream.  To control\n   *  the associated sequence, an instance of std::basic_stringbuf is used,\n   *  which this page refers to as @c sb.\n  */\n  template <typename _CharT, typename _Traits, typename _Alloc>\n    class basic_ostringstream : public basic_ostream<_CharT, _Traits>\n    {\n    public:\n      // Types:\n      typedef _CharT \t\t\t\t\tchar_type;\n      typedef _Traits \t\t\t\t\ttraits_type;\n      // _GLIBCXX_RESOLVE_LIB_DEFECTS\n      // 251. basic_stringbuf missing allocator_type\n      typedef _Alloc\t\t\t\t       \tallocator_type;\n      typedef typename traits_type::int_type \t\tint_type;\n      typedef typename traits_type::pos_type \t\tpos_type;\n      typedef typename traits_type::off_type \t\toff_type;\n\n      // Non-standard types:\n      typedef basic_string<_CharT, _Traits, _Alloc> \t__string_type;\n      typedef basic_stringbuf<_CharT, _Traits, _Alloc> \t__stringbuf_type;\n      typedef basic_ostream<char_type, traits_type>\t__ostream_type;\n\n    private:\n      __stringbuf_type\t_M_stringbuf;\n\n    public:\n      // Constructors/destructor:\n      /**\n       *  @brief  Default constructor starts with an empty string buffer.\n       *  @param  __mode  Whether the buffer can read, or write, or both.\n       *\n       *  @c ios_base::out is automatically included in @a mode.\n       *\n       *  Initializes @c sb using @c mode|out, and passes @c &sb to the base\n       *  class initializer.  Does not allocate any buffer.\n       *\n       *  That's a lie.  We initialize the base class with NULL, because the\n       *  string class does its own memory management.\n      */\n      explicit\n      basic_ostringstream(ios_base::openmode __mode = ios_base::out)\n      : __ostream_type(), _M_stringbuf(__mode | ios_base::out)\n      { this->init(&_M_stringbuf); }\n\n      /**\n       *  @brief  Starts with an existing string buffer.\n       *  @param  __str  A string to copy as a starting buffer.\n       *  @param  __mode  Whether the buffer can read, or write, or both.\n       *\n       *  @c ios_base::out is automatically included in @a mode.\n       *\n       *  Initializes @c sb using @a str and @c mode|out, and passes @c &sb\n       *  to the base class initializer.\n       *\n       *  That's a lie.  We initialize the base class with NULL, because the\n       *  string class does its own memory management.\n      */\n      explicit\n      basic_ostringstream(const __string_type& __str,\n\t\t\t  ios_base::openmode __mode = ios_base::out)\n      : __ostream_type(), _M_stringbuf(__str, __mode | ios_base::out)\n      { this->init(&_M_stringbuf); }\n\n      /**\n       *  @brief  The destructor does nothing.\n       *\n       *  The buffer is deallocated by the stringbuf object, not the\n       *  formatting stream.\n      */\n      ~basic_ostringstream()\n      { }\n\n#if __cplusplus >= 201103L\n      basic_ostringstream(const basic_ostringstream&) = delete;\n\n      basic_ostringstream(basic_ostringstream&& __rhs)\n      : __ostream_type(std::move(__rhs)),\n      _M_stringbuf(std::move(__rhs._M_stringbuf))\n      { __ostream_type::set_rdbuf(&_M_stringbuf); }\n\n      // 27.8.3.2 Assign and swap:\n\n      basic_ostringstream&\n      operator=(const basic_ostringstream&) = delete;\n\n      basic_ostringstream&\n      operator=(basic_ostringstream&& __rhs)\n      {\n\t__ostream_type::operator=(std::move(__rhs));\n\t_M_stringbuf = std::move(__rhs._M_stringbuf);\n\treturn *this;\n      }\n\n      void\n      swap(basic_ostringstream& __rhs)\n      {\n\t__ostream_type::swap(__rhs);\n\t_M_stringbuf.swap(__rhs._M_stringbuf);\n      }\n#endif\n\n      // Members:\n      /**\n       *  @brief  Accessing the underlying buffer.\n       *  @return  The current basic_stringbuf buffer.\n       *\n       *  This hides both signatures of std::basic_ios::rdbuf().\n      */\n      __stringbuf_type*\n      rdbuf() const\n      { return const_cast<__stringbuf_type*>(&_M_stringbuf); }\n\n      /**\n       *  @brief  Copying out the string buffer.\n       *  @return  @c rdbuf()->str()\n      */\n      __string_type\n      str() const\n      { return _M_stringbuf.str(); }\n\n      /**\n       *  @brief  Setting a new buffer.\n       *  @param  __s  The string to use as a new sequence.\n       *\n       *  Calls @c rdbuf()->str(s).\n      */\n      void\n      str(const __string_type& __s)\n      { _M_stringbuf.str(__s); }\n    };\n\n\n  // [27.7.4] Template class basic_stringstream\n  /**\n   *  @brief  Controlling input and output for std::string.\n   *  @ingroup io\n   *\n   *  @tparam _CharT  Type of character stream.\n   *  @tparam _Traits  Traits for character type, defaults to\n   *                   char_traits<_CharT>.\n   *  @tparam _Alloc  Allocator type, defaults to allocator<_CharT>.\n   *\n   *  This class supports reading from and writing to objects of type\n   *  std::basic_string, using the inherited functions from\n   *  std::basic_iostream.  To control the associated sequence, an instance\n   *  of std::basic_stringbuf is used, which this page refers to as @c sb.\n  */\n  template <typename _CharT, typename _Traits, typename _Alloc>\n    class basic_stringstream : public basic_iostream<_CharT, _Traits>\n    {\n    public:\n      // Types:\n      typedef _CharT \t\t\t\t\tchar_type;\n      typedef _Traits \t\t\t\t\ttraits_type;\n      // _GLIBCXX_RESOLVE_LIB_DEFECTS\n      // 251. basic_stringbuf missing allocator_type\n      typedef _Alloc\t\t\t\t       \tallocator_type;\n      typedef typename traits_type::int_type \t\tint_type;\n      typedef typename traits_type::pos_type \t\tpos_type;\n      typedef typename traits_type::off_type \t\toff_type;\n\n      // Non-standard Types:\n      typedef basic_string<_CharT, _Traits, _Alloc> \t__string_type;\n      typedef basic_stringbuf<_CharT, _Traits, _Alloc> \t__stringbuf_type;\n      typedef basic_iostream<char_type, traits_type>\t__iostream_type;\n\n    private:\n      __stringbuf_type\t_M_stringbuf;\n\n    public:\n      // Constructors/destructors\n      /**\n       *  @brief  Default constructor starts with an empty string buffer.\n       *  @param  __m  Whether the buffer can read, or write, or both.\n       *\n       *  Initializes @c sb using the mode from @c __m, and passes @c\n       *  &sb to the base class initializer.  Does not allocate any\n       *  buffer.\n       *\n       *  That's a lie.  We initialize the base class with NULL, because the\n       *  string class does its own memory management.\n      */\n      explicit\n      basic_stringstream(ios_base::openmode __m = ios_base::out | ios_base::in)\n      : __iostream_type(), _M_stringbuf(__m)\n      { this->init(&_M_stringbuf); }\n\n      /**\n       *  @brief  Starts with an existing string buffer.\n       *  @param  __str  A string to copy as a starting buffer.\n       *  @param  __m  Whether the buffer can read, or write, or both.\n       *\n       *  Initializes @c sb using @a __str and @c __m, and passes @c &sb\n       *  to the base class initializer.\n       *\n       *  That's a lie.  We initialize the base class with NULL, because the\n       *  string class does its own memory management.\n      */\n      explicit\n      basic_stringstream(const __string_type& __str,\n\t\t\t ios_base::openmode __m = ios_base::out | ios_base::in)\n      : __iostream_type(), _M_stringbuf(__str, __m)\n      { this->init(&_M_stringbuf); }\n\n      /**\n       *  @brief  The destructor does nothing.\n       *\n       *  The buffer is deallocated by the stringbuf object, not the\n       *  formatting stream.\n      */\n      ~basic_stringstream()\n      { }\n\n#if __cplusplus >= 201103L\n      basic_stringstream(const basic_stringstream&) = delete;\n\n      basic_stringstream(basic_stringstream&& __rhs)\n      : __iostream_type(std::move(__rhs)),\n      _M_stringbuf(std::move(__rhs._M_stringbuf))\n      { __iostream_type::set_rdbuf(&_M_stringbuf); }\n\n      // 27.8.3.2 Assign and swap:\n\n      basic_stringstream&\n      operator=(const basic_stringstream&) = delete;\n\n      basic_stringstream&\n      operator=(basic_stringstream&& __rhs)\n      {\n\t__iostream_type::operator=(std::move(__rhs));\n\t_M_stringbuf = std::move(__rhs._M_stringbuf);\n\treturn *this;\n      }\n\n      void\n      swap(basic_stringstream& __rhs)\n      {\n\t__iostream_type::swap(__rhs);\n\t_M_stringbuf.swap(__rhs._M_stringbuf);\n      }\n#endif\n\n      // Members:\n      /**\n       *  @brief  Accessing the underlying buffer.\n       *  @return  The current basic_stringbuf buffer.\n       *\n       *  This hides both signatures of std::basic_ios::rdbuf().\n      */\n      __stringbuf_type*\n      rdbuf() const\n      { return const_cast<__stringbuf_type*>(&_M_stringbuf); }\n\n      /**\n       *  @brief  Copying out the string buffer.\n       *  @return  @c rdbuf()->str()\n      */\n      __string_type\n      str() const\n      { return _M_stringbuf.str(); }\n\n      /**\n       *  @brief  Setting a new buffer.\n       *  @param  __s  The string to use as a new sequence.\n       *\n       *  Calls @c rdbuf()->str(s).\n      */\n      void\n      str(const __string_type& __s)\n      { _M_stringbuf.str(__s); }\n    };\n\n#if __cplusplus >= 201103L\n  /// Swap specialization for stringbufs.\n  template <class _CharT, class _Traits, class _Allocator>\n    inline void\n    swap(basic_stringbuf<_CharT, _Traits, _Allocator>& __x,\n\t basic_stringbuf<_CharT, _Traits, _Allocator>& __y)\n    { __x.swap(__y); }\n\n  /// Swap specialization for istringstreams.\n  template <class _CharT, class _Traits, class _Allocator>\n    inline void\n    swap(basic_istringstream<_CharT, _Traits, _Allocator>& __x,\n\t basic_istringstream<_CharT, _Traits, _Allocator>& __y)\n    { __x.swap(__y); }\n\n  /// Swap specialization for ostringstreams.\n  template <class _CharT, class _Traits, class _Allocator>\n    inline void\n    swap(basic_ostringstream<_CharT, _Traits, _Allocator>& __x,\n\t basic_ostringstream<_CharT, _Traits, _Allocator>& __y)\n    { __x.swap(__y); }\n\n  /// Swap specialization for stringstreams.\n  template <class _CharT, class _Traits, class _Allocator>\n    inline void\n    swap(basic_stringstream<_CharT, _Traits, _Allocator>& __x,\n\t basic_stringstream<_CharT, _Traits, _Allocator>& __y)\n    { __x.swap(__y); }\n#endif\n\n_GLIBCXX_END_NAMESPACE_CXX11\n_GLIBCXX_END_NAMESPACE_VERSION\n} // namespace\n\n#include <bits/sstream.tcc>\n\n#endif /* _GLIBCXX_SSTREAM */\n"}}, "reports": [{"events": [{"location": {"col": 5, "file": 1, "line": 96}, "message": "explicit (fixit)"}, {"location": {"col": 5, "file": 1, "line": 96}, "message": "single-argument constructors must be marked explicit to avoid unintentional implicit conversions"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/ext/json11/json11.hpp", "reportHash": "d68c8909f40797846b625d7b19ba4b0c", "checkerName": "hicpp-explicit-conversions", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 5, "file": 1, "line": 97}, "message": "explicit (fixit)"}, {"location": {"col": 5, "file": 1, "line": 97}, "message": "single-argument constructors must be marked explicit to avoid unintentional implicit conversions"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/ext/json11/json11.hpp", "reportHash": "3e36e2fb653a7860677398e78ff09eb2", "checkerName": "google-explicit-constructor", "reviewStatus": null, "severity": "MEDIUM"}, {"events": [{"location": {"col": 5, "file": 1, "line": 106}, "message": "explicit (fixit)"}, {"location": {"col": 5, "file": 1, "line": 106}, "message": "single-argument constructors must be marked explicit to avoid unintentional implicit conversions"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/ext/json11/json11.hpp", "reportHash": "c11bab789ec454b6e1e1599ab31fd1c7", "checkerName": "hicpp-explicit-conversions", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 5, "file": 1, "line": 113}, "message": "explicit (fixit)"}, {"location": {"col": 5, "file": 1, "line": 113}, "message": "single-argument constructors must be marked explicit to avoid unintentional implicit conversions"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/ext/json11/json11.hpp", "reportHash": "84d0b4af4ad7b69cb8d4c4ea31da4fb1", "checkerName": "hicpp-explicit-conversions", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 27, "file": 3, "line": 46}, "message": "{ (fixit)"}, {"location": {"col": 26, "file": 3, "line": 46}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/ext/yahttp/yahttp/cookie.hpp", "reportHash": "5b6831e9ad3fb62baafdb7334dfd1102", "checkerName": "readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 20, "file": 3, "line": 52}, "message": "{ (fixit)"}, {"location": {"col": 19, "file": 3, "line": 52}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/ext/yahttp/yahttp/cookie.hpp", "reportHash": "18a5e8d88c6c0d05deeac3facb76f7a9", "checkerName": "readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 17, "file": 3, "line": 65}, "message": "= default; (fixit)"}, {"location": {"col": 5, "file": 3, "line": 65}, "message": "use '= default' to define a trivial default constructor"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/ext/yahttp/yahttp/cookie.hpp", "reportHash": "8964228e87bec0e87175131c06283f29", "checkerName": "modernize-use-equals-default", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 1, "file": 3, "line": 97}, "message": "note: this fix will not be applied because it overlaps with another fix (fixit)"}, {"location": {"col": 11, "file": 3, "line": 97}, "message": "use auto when declaring iterators"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/ext/yahttp/yahttp/cookie.hpp", "reportHash": "dee83042a72717c03a3290f56cc9ff3e", "checkerName": "modernize-use-auto", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 65, "file": 3, "line": 107}, "message": "{ (fixit)"}, {"location": {"col": 64, "file": 3, "line": 107}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/ext/yahttp/yahttp/cookie.hpp", "reportHash": "02c21c6489da93ac33fc7e5c3e5c5d68", "checkerName": "hicpp-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 14, "file": 3, "line": 120}, "message": "{ (fixit)"}, {"location": {"col": 13, "file": 3, "line": 120}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/ext/yahttp/yahttp/cookie.hpp", "reportHash": "5e255532c55b3fa99a7eff4e932e95c2", "checkerName": "readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 5, "file": 6, "line": 9}, "message": "explicit (fixit)"}, {"location": {"col": 5, "file": 6, "line": 9}, "message": "single-argument constructors must be marked explicit to avoid unintentional implicit conversions"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/ext/yahttp/yahttp/exception.hpp", "reportHash": "158e86a385e7a9e92ac73b50240c5442", "checkerName": "hicpp-explicit-conversions", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 9, "file": 7, "line": 43}, "message": "class 'HTTPBase' defines a copy constructor and a copy assignment operator but does not define a destructor, a move constructor or a move assignment operator"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/ext/yahttp/yahttp/reqresp.hpp", "reportHash": "c661fa963555da09ab349e9c65192c2e", "checkerName": "hicpp-special-member-functions", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 24, "file": 7, "line": 48}, "message": "= default; (fixit)"}, {"location": {"col": 7, "file": 7, "line": 48}, "message": "use '= default' to define a trivial default constructor"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/ext/yahttp/yahttp/reqresp.hpp", "reportHash": "297323728a484d3961fd9cb9f6b6d5c7", "checkerName": "hicpp-use-equals-default", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 5, "file": 7, "line": 200}, "message": "explicit (fixit)"}, {"location": {"col": 5, "file": 7, "line": 200}, "message": "single-argument constructors must be marked explicit to avoid unintentional implicit conversions"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/ext/yahttp/yahttp/reqresp.hpp", "reportHash": "b511abae88e059b63bb4d1dabebb7212", "checkerName": "hicpp-explicit-conversions", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 23, "file": 7, "line": 208}, "message": "override (fixit)"}, {"location": {"col": 10, "file": 7, "line": 208}, "message": "annotate this function with 'override' or (rarely) 'final'"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/ext/yahttp/yahttp/reqresp.hpp", "reportHash": "d20822ec41f3b923c5b260c8eac5e4da", "checkerName": "modernize-use-override", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 5, "file": 7, "line": 229}, "message": "explicit (fixit)"}, {"location": {"col": 5, "file": 7, "line": 229}, "message": "single-argument constructors must be marked explicit to avoid unintentional implicit conversions"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/ext/yahttp/yahttp/reqresp.hpp", "reportHash": "41f5c1364f68975c86773420f571e3b7", "checkerName": "hicpp-explicit-conversions", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 14, "file": 7, "line": 267}, "message": "{ (fixit)"}, {"location": {"col": 13, "file": 7, "line": 267}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/ext/yahttp/yahttp/reqresp.hpp", "reportHash": "f5452923c5a47f3345f2b31bb9ab80bc", "checkerName": "google-readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 32, "file": 7, "line": 285}, "message": "{ (fixit)"}, {"location": {"col": 31, "file": 7, "line": 285}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/ext/yahttp/yahttp/reqresp.hpp", "reportHash": "4da53f69b99a173732429664e13a3c9c", "checkerName": "google-readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 1, "file": 8, "line": 1}, "message": "header is missing header guard"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/ext/yahttp/yahttp/router.hpp", "reportHash": "1af68993104309e514f7700f506403af", "checkerName": "llvm-header-guard", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 10, "file": 8, "line": 24}, "message": "<utility> (fixit)"}, {"location": {"col": 1, "file": 8, "line": 24}, "message": "#includes are not sorted properly"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/ext/yahttp/yahttp/router.hpp", "reportHash": "47d3357b1a5e45cdf228814dfd11eea7", "checkerName": "llvm-include-order", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 3, "file": 8, "line": 28}, "message": "using THandlerFunction = funcptr::function<void (Request *, Response *)> (fixit)"}, {"location": {"col": 3, "file": 8, "line": 28}, "message": "use 'using' instead of 'typedef'"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/ext/yahttp/yahttp/router.hpp", "reportHash": "71e76210e2dc1dbf4f0ade9eedd2f646", "checkerName": "modernize-use-using", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 3, "file": 8, "line": 29}, "message": "use 'using' instead of 'typedef'"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/ext/yahttp/yahttp/router.hpp", "reportHash": "b9002137993a62989240057465e0a755", "checkerName": "modernize-use-using", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 3, "file": 8, "line": 30}, "message": "using TRouteList = std::vector<TRoute> (fixit)"}, {"location": {"col": 3, "file": 8, "line": 30}, "message": "use 'using' instead of 'typedef'"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/ext/yahttp/yahttp/router.hpp", "reportHash": "eb1d70cb5a2d66dc87476c7ecb8901d4", "checkerName": "modernize-use-using", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 14, "file": 8, "line": 43}, "message": "= default; (fixit)"}, {"location": {"col": 5, "file": 8, "line": 43}, "message": "use '= default' to define a trivial default constructor"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/ext/yahttp/yahttp/router.hpp", "reportHash": "d12b1a63c4f6b1709222f5af8a23cf7a", "checkerName": "hicpp-use-equals-default", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 48, "file": 8, "line": 47}, "message": "non-const reference parameter 'handler', make it const or use a pointer"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/ext/yahttp/yahttp/router.hpp", "reportHash": "1d63d08b4f298b58ff9d02330244b9e8", "checkerName": "google-runtime-references", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 98, "file": 8, "line": 54}, "message": "declaring a parameter with a default argument is disallowed"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/ext/yahttp/yahttp/router.hpp", "reportHash": "7704b9e20bdc7afeb6588c45def9f04e", "checkerName": "fuchsia-default-arguments", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 39, "file": 2, "line": 509}, "message": "default parameter was declared here"}, {"location": {"col": 124, "file": 8, "line": 54}, "message": "calling a function that uses a default argument is disallowed"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/ext/yahttp/yahttp/router.hpp", "reportHash": "84c3a4c17421d86b67d41e64d95c2c20", "checkerName": "fuchsia-default-arguments", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 154, "file": 8, "line": 54}, "message": "std::move() (fixit)"}, {"location": {"col": 154, "file": 8, "line": 54}, "message": "parameter 'handler' is passed by value and only copied once; consider moving it to avoid unnecessary copies"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/ext/yahttp/yahttp/router.hpp", "reportHash": "6d990e05ab236b0f8bcc0c2a4171fdc2", "checkerName": "performance-unnecessary-value-param", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 71, "file": 8, "line": 55}, "message": "declaring a parameter with a default argument is disallowed"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/ext/yahttp/yahttp/router.hpp", "reportHash": "59f0af82e0c036610e7ee773dcddeb5b", "checkerName": "fuchsia-default-arguments", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 39, "file": 2, "line": 509}, "message": "default parameter was declared here"}, {"location": {"col": 97, "file": 8, "line": 55}, "message": "calling a function that uses a default argument is disallowed"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/ext/yahttp/yahttp/router.hpp", "reportHash": "7a912b77a13de0e61ca69bd9cdff4bcb", "checkerName": "fuchsia-default-arguments", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 39, "file": 2, "line": 509}, "message": "default parameter was declared here"}, {"location": {"col": 114, "file": 8, "line": 55}, "message": "calling a function that uses a default argument is disallowed"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/ext/yahttp/yahttp/router.hpp", "reportHash": "b01c8ce44c957555044c32939ed659f8", "checkerName": "fuchsia-default-arguments", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 126, "file": 8, "line": 55}, "message": "std::move() (fixit)"}, {"location": {"col": 126, "file": 8, "line": 55}, "message": "parameter 'handler' is passed by value and only copied once; consider moving it to avoid unnecessary copies"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/ext/yahttp/yahttp/router.hpp", "reportHash": "d74cc935638b0f4ff56f106cb2203666", "checkerName": "performance-unnecessary-value-param", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 72, "file": 8, "line": 56}, "message": "declaring a parameter with a default argument is disallowed"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/ext/yahttp/yahttp/router.hpp", "reportHash": "644f4413bf94f45bc253b137ccc6af15", "checkerName": "fuchsia-default-arguments", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 39, "file": 2, "line": 509}, "message": "default parameter was declared here"}, {"location": {"col": 98, "file": 8, "line": 56}, "message": "calling a function that uses a default argument is disallowed"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/ext/yahttp/yahttp/router.hpp", "reportHash": "826e5e1d0c5626cd45594bc258b41b98", "checkerName": "fuchsia-default-arguments", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 39, "file": 2, "line": 509}, "message": "default parameter was declared here"}, {"location": {"col": 115, "file": 8, "line": 56}, "message": "calling a function that uses a default argument is disallowed"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/ext/yahttp/yahttp/router.hpp", "reportHash": "9b2c28dad3d0aa83c2a7d3524d5952fc", "checkerName": "fuchsia-default-arguments", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 128, "file": 8, "line": 56}, "message": "std::move() (fixit)"}, {"location": {"col": 128, "file": 8, "line": 56}, "message": "parameter 'handler' is passed by value and only copied once; consider moving it to avoid unnecessary copies"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/ext/yahttp/yahttp/router.hpp", "reportHash": "9b20fa7483be1f74ab1ba30774c2882c", "checkerName": "performance-unnecessary-value-param", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 71, "file": 8, "line": 57}, "message": "declaring a parameter with a default argument is disallowed"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/ext/yahttp/yahttp/router.hpp", "reportHash": "b9472344ada400cdc7e03bc4a575d613", "checkerName": "fuchsia-default-arguments", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 39, "file": 2, "line": 509}, "message": "default parameter was declared here"}, {"location": {"col": 97, "file": 8, "line": 57}, "message": "calling a function that uses a default argument is disallowed"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/ext/yahttp/yahttp/router.hpp", "reportHash": "de222c85887ff13496786f82dee82861", "checkerName": "fuchsia-default-arguments", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 39, "file": 2, "line": 509}, "message": "default parameter was declared here"}, {"location": {"col": 114, "file": 8, "line": 57}, "message": "calling a function that uses a default argument is disallowed"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/ext/yahttp/yahttp/router.hpp", "reportHash": "c4c8ef1a8445c6b0d9da9eab3f7bc9d6", "checkerName": "fuchsia-default-arguments", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 126, "file": 8, "line": 57}, "message": "std::move() (fixit)"}, {"location": {"col": 126, "file": 8, "line": 57}, "message": "parameter 'handler' is passed by value and only copied once; consider moving it to avoid unnecessary copies"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/ext/yahttp/yahttp/router.hpp", "reportHash": "73d51414f744215ec33db937dce25d87", "checkerName": "performance-unnecessary-value-param", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 73, "file": 8, "line": 58}, "message": "declaring a parameter with a default argument is disallowed"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/ext/yahttp/yahttp/router.hpp", "reportHash": "9b24f454746eb457726295ba36e917a5", "checkerName": "fuchsia-default-arguments", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 39, "file": 2, "line": 509}, "message": "default parameter was declared here"}, {"location": {"col": 99, "file": 8, "line": 58}, "message": "calling a function that uses a default argument is disallowed"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/ext/yahttp/yahttp/router.hpp", "reportHash": "a9f6562b13d1b52471221d2988f136b7", "checkerName": "fuchsia-default-arguments", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 39, "file": 2, "line": 509}, "message": "default parameter was declared here"}, {"location": {"col": 116, "file": 8, "line": 58}, "message": "calling a function that uses a default argument is disallowed"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/ext/yahttp/yahttp/router.hpp", "reportHash": "6ee03abcb981a72f77e811dd9bb88847", "checkerName": "fuchsia-default-arguments", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 130, "file": 8, "line": 58}, "message": "std::move() (fixit)"}, {"location": {"col": 130, "file": 8, "line": 58}, "message": "parameter 'handler' is passed by value and only copied once; consider moving it to avoid unnecessary copies"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/ext/yahttp/yahttp/router.hpp", "reportHash": "5814bd451b40b152f00b5aa7f36e8407", "checkerName": "performance-unnecessary-value-param", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 74, "file": 8, "line": 59}, "message": "declaring a parameter with a default argument is disallowed"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/ext/yahttp/yahttp/router.hpp", "reportHash": "721e5bcd10b18195a12a201a48e65d1c", "checkerName": "fuchsia-default-arguments", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 39, "file": 2, "line": 509}, "message": "default parameter was declared here"}, {"location": {"col": 100, "file": 8, "line": 59}, "message": "calling a function that uses a default argument is disallowed"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/ext/yahttp/yahttp/router.hpp", "reportHash": "80765d9a3ce40b9dff06267533946af6", "checkerName": "fuchsia-default-arguments", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 39, "file": 2, "line": 509}, "message": "default parameter was declared here"}, {"location": {"col": 117, "file": 8, "line": 59}, "message": "calling a function that uses a default argument is disallowed"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/ext/yahttp/yahttp/router.hpp", "reportHash": "5ec04142cf4bba3967705393b26e3904", "checkerName": "fuchsia-default-arguments", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 132, "file": 8, "line": 59}, "message": "std::move() (fixit)"}, {"location": {"col": 132, "file": 8, "line": 59}, "message": "parameter 'handler' is passed by value and only copied once; consider moving it to avoid unnecessary copies"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/ext/yahttp/yahttp/router.hpp", "reportHash": "dd3773f8162f1b7faaca0617f1d3288f", "checkerName": "performance-unnecessary-value-param", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 71, "file": 8, "line": 60}, "message": "declaring a parameter with a default argument is disallowed"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/ext/yahttp/yahttp/router.hpp", "reportHash": "4f7cb1c6455ebb6a318ae3cc2f60eb79", "checkerName": "fuchsia-default-arguments", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 39, "file": 2, "line": 509}, "message": "default parameter was declared here"}, {"location": {"col": 97, "file": 8, "line": 60}, "message": "calling a function that uses a default argument is disallowed"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/ext/yahttp/yahttp/router.hpp", "reportHash": "dfd950e1df7e25f39c01fa57e24eb182", "checkerName": "fuchsia-default-arguments", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 39, "file": 2, "line": 509}, "message": "default parameter was declared here"}, {"location": {"col": 114, "file": 8, "line": 60}, "message": "calling a function that uses a default argument is disallowed"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/ext/yahttp/yahttp/router.hpp", "reportHash": "ee6bbc985411b7c605ddfffa49525bdd", "checkerName": "fuchsia-default-arguments", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 123, "file": 8, "line": 60}, "message": "std::move() (fixit)"}, {"location": {"col": 123, "file": 8, "line": 60}, "message": "parameter 'handler' is passed by value and only copied once; consider moving it to avoid unnecessary copies"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/ext/yahttp/yahttp/router.hpp", "reportHash": "59ec51d7912785a7abbdd96cf874dab8", "checkerName": "performance-unnecessary-value-param", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 55, "file": 8, "line": 62}, "message": "non-const reference parameter 'handler', make it const or use a pointer"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/ext/yahttp/yahttp/router.hpp", "reportHash": "72afc88254d6b361145cd863d0df06cb", "checkerName": "google-runtime-references", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 4, "file": 8, "line": 71}, "message": "// namespace YaHTTP (fixit)"}, {"location": {"col": 11, "file": 8, "line": 27}, "message": "namespace 'YaHTTP' starts here"}, {"location": {"col": 2, "file": 8, "line": 71}, "message": "namespace 'YaHTTP' not terminated with a closing comment"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/ext/yahttp/yahttp/router.hpp", "reportHash": "c544baf338e07a658b9b89b9f3c2f54d", "checkerName": "google-readability-namespace-comments", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 75, "file": 9, "line": 18}, "message": "{ (fixit)"}, {"location": {"col": 74, "file": 9, "line": 18}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/ext/yahttp/yahttp/url.hpp", "reportHash": "46f74a9145cffdf4cd03bf6d43a36660", "checkerName": "readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 34, "file": 9, "line": 32}, "message": "{ (fixit)"}, {"location": {"col": 33, "file": 9, "line": 32}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/ext/yahttp/yahttp/url.hpp", "reportHash": "c10423edd8e10e2f03f6eaab6816ff96", "checkerName": "readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 34, "file": 9, "line": 62}, "message": "{ (fixit)"}, {"location": {"col": 33, "file": 9, "line": 62}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/ext/yahttp/yahttp/url.hpp", "reportHash": "c10423edd8e10e2f03f6eaab6816ff96", "checkerName": "readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 75, "file": 9, "line": 64}, "message": "{ (fixit)"}, {"location": {"col": 74, "file": 9, "line": 64}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/ext/yahttp/yahttp/url.hpp", "reportHash": "91bf1e563d6f9d4df97e54dbafe52441", "checkerName": "readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 68, "file": 9, "line": 105}, "message": "{ (fixit)"}, {"location": {"col": 67, "file": 9, "line": 105}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/ext/yahttp/yahttp/url.hpp", "reportHash": "96a1b876bf6592887647d9f9e5af4f0c", "checkerName": "readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 43, "file": 9, "line": 133}, "message": "{ (fixit)"}, {"location": {"col": 42, "file": 9, "line": 133}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/ext/yahttp/yahttp/url.hpp", "reportHash": "f078d7e40f098d2d30d2a6a7a38e5d02", "checkerName": "readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 40, "file": 9, "line": 151}, "message": "{ (fixit)"}, {"location": {"col": 39, "file": 9, "line": 151}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/ext/yahttp/yahttp/url.hpp", "reportHash": "b007913a75853bf13280ec1016a2de68", "checkerName": "google-readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 43, "file": 9, "line": 190}, "message": "{ (fixit)"}, {"location": {"col": 42, "file": 9, "line": 190}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/ext/yahttp/yahttp/url.hpp", "reportHash": "5bcd828c4509e8aee9695dbbbd42c6fe", "checkerName": "hicpp-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 20, "file": 5, "line": 68}, "message": "{} (fixit)"}, {"location": {"col": 8, "file": 5, "line": 68}, "message": "uninitialized record type: 'tm'"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/ext/yahttp/yahttp/utility.hpp", "reportHash": "2a01109063b3f7d52b6f8fc415dd7158", "checkerName": "cppcoreguidelines-pro-type-member-init", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 34, "file": 5, "line": 122}, "message": "{ (fixit)"}, {"location": {"col": 33, "file": 5, "line": 122}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/ext/yahttp/yahttp/utility.hpp", "reportHash": "6a96a55e8dcd686058e8351e0e17347b", "checkerName": "hicpp-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 41, "file": 5, "line": 127}, "message": "{ (fixit)"}, {"location": {"col": 40, "file": 5, "line": 127}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/ext/yahttp/yahttp/utility.hpp", "reportHash": "b0a6c4771b47e8ab2508f871ac5cea36", "checkerName": "hicpp-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 27, "file": 5, "line": 138}, "message": "{ (fixit)"}, {"location": {"col": 26, "file": 5, "line": 138}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/ext/yahttp/yahttp/utility.hpp", "reportHash": "f22baa30c167c7e87c2f8a01d557640b", "checkerName": "google-readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 20, "file": 5, "line": 158}, "message": "{} (fixit)"}, {"location": {"col": 8, "file": 5, "line": 158}, "message": "uninitialized record type: 'tm'"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/ext/yahttp/yahttp/utility.hpp", "reportHash": "2a01109063b3f7d52b6f8fc415dd7158", "checkerName": "cppcoreguidelines-pro-type-member-init", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 11, "file": 5, "line": 258}, "message": "do not call c-style vararg functions"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/ext/yahttp/yahttp/utility.hpp", "reportHash": "ec0aaca1d0b9a749d21af3fe55a1e458", "checkerName": "cppcoreguidelines-pro-type-vararg", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 65, "file": 5, "line": 259}, "message": "do not implicitly decay an array into a pointer; consider using gsl::array_view or an explicit cast instead"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/ext/yahttp/yahttp/utility.hpp", "reportHash": "10a07f07b7d2dd96faa63c80d585fc4f", "checkerName": "cppcoreguidelines-pro-bounds-array-to-pointer-decay", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 16, "file": 5, "line": 277}, "message": "{ (fixit)"}, {"location": {"col": 15, "file": 5, "line": 277}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/ext/yahttp/yahttp/utility.hpp", "reportHash": "563cbe74e7e7c98ec7008eb3ac7f4ff6", "checkerName": "hicpp-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 3, "file": 24, "line": 39}, "message": "explicit (fixit)"}, {"location": {"col": 3, "file": 24, "line": 39}, "message": "single-argument constructors must be marked explicit to avoid unintentional implicit conversions"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/pdns/json.hh", "reportHash": "9d20847e02ecfbbb37b00abdbf26dddd", "checkerName": "hicpp-explicit-conversions", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 24, "file": 25, "line": 88}, "message": "cannot overload 'operator<<<char [52]>'"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/pdns/logger.hh", "reportHash": "a9bcb9d2684900733cf301961dd86758", "checkerName": "fuchsia-overloaded-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 24, "file": 25, "line": 88}, "message": "cannot overload 'operator<<<char [68]>'"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/pdns/logger.hh", "reportHash": "b02e2e7e28c1179a6e9ef18e26f2d1b2", "checkerName": "fuchsia-overloaded-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 24, "file": 25, "line": 88}, "message": "cannot overload 'operator<<<char [70]>'"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/pdns/logger.hh", "reportHash": "c03d4449941c537650cd831d164a871c", "checkerName": "fuchsia-overloaded-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 56, "file": 29, "line": 193}, "message": "{ (fixit)"}, {"location": {"col": 55, "file": 29, "line": 193}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/pdns/sstuff.hh", "reportHash": "a424a1b1132ae7d004112f83dca8d232", "checkerName": "hicpp-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 19, "file": 29, "line": 307}, "message": "{ (fixit)"}, {"location": {"col": 18, "file": 29, "line": 307}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/pdns/sstuff.hh", "reportHash": "7000eab48d8c1008edbb7bfc667e7b3f", "checkerName": "hicpp-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 10, "file": 33, "line": 25}, "message": "\"base64.hh\" (fixit)"}, {"location": {"col": 1, "file": 33, "line": 25}, "message": "#includes are not sorted properly"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/pdns/webserver.cc", "reportHash": "5195978ff8b5eb627d19ff4745fb4cdc", "checkerName": "llvm-include-order", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 1, "file": 33, "line": 32}, "message": "note: this fix will not be applied because it overlaps with another fix (fixit)"}, {"location": {"col": 10, "file": 33, "line": 32}, "message": "inclusion of deprecated C++ header 'stdio.h'; consider using 'cstdio' instead"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/pdns/webserver.cc", "reportHash": "e3fb15e5f6d7c508315554c95b911c46", "checkerName": "hicpp-deprecated-headers", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 1, "file": 34, "line": 80}, "message": "type defined here"}, {"location": {"col": 11, "file": 33, "line": 44}, "message": "throwing an exception whose type 'HttpBadRequestException' is not derived from 'std::exception'"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/pdns/webserver.cc", "reportHash": "08ceaf9d7f26d1445c2df20b35522d7b", "checkerName": "hicpp-exception-baseclass", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 23, "file": 1, "line": 166}, "message": "default parameter was declared here"}, {"location": {"col": 22, "file": 33, "line": 46}, "message": "calling a function that uses a default argument is disallowed"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/pdns/webserver.cc", "reportHash": "45953ade17fa7b036b247c53fd1acd87", "checkerName": "fuchsia-default-arguments", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 1, "file": 34, "line": 80}, "message": "type defined here"}, {"location": {"col": 11, "file": 33, "line": 49}, "message": "throwing an exception whose type 'HttpBadRequestException' is not derived from 'std::exception'"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/pdns/webserver.cc", "reportHash": "08ceaf9d7f26d1445c2df20b35522d7b", "checkerName": "hicpp-exception-baseclass", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 3, "file": 33, "line": 57}, "message": "auto (fixit)"}, {"location": {"col": 3, "file": 33, "line": 57}, "message": "use auto when declaring iterators"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/pdns/webserver.cc", "reportHash": "7a65bd919265016c2b93baabf2f63b19", "checkerName": "hicpp-use-auto", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 39, "file": 2, "line": 509}, "message": "default parameter was declared here"}, {"location": {"col": 56, "file": 33, "line": 57}, "message": "calling a function that uses a default argument is disallowed"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/pdns/webserver.cc", "reportHash": "474f1b6a7fdf8fc750418ec98b5db84d", "checkerName": "fuchsia-default-arguments", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 31, "file": 2, "line": 2373}, "message": "default parameter was declared here"}, {"location": {"col": 34, "file": 33, "line": 59}, "message": "calling a function that uses a default argument is disallowed"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/pdns/webserver.cc", "reportHash": "6eb8efc54f4666f6014a3b13ae771e22", "checkerName": "fuchsia-default-arguments", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 35, "file": 2, "line": 2814}, "message": "default parameter was declared here"}, {"location": {"col": 21, "file": 33, "line": 60}, "message": "calling a function that uses a default argument is disallowed"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/pdns/webserver.cc", "reportHash": "6bae9aa329e7554ed07c80826f5a6e77", "checkerName": "fuchsia-default-arguments", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 3, "file": 33, "line": 76}, "message": "auto (fixit)"}, {"location": {"col": 3, "file": 33, "line": 76}, "message": "use auto when declaring iterators"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/pdns/webserver.cc", "reportHash": "dcbdc562a919a7cceab33b1209431563", "checkerName": "hicpp-use-auto", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 32, "file": 33, "line": 77}, "message": "{ (fixit)"}, {"location": {"col": 31, "file": 33, "line": 77}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/pdns/webserver.cc", "reportHash": "210c297d927ac893dddb88e7b8970768", "checkerName": "google-readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 4, "file": 35, "line": 221}, "message": "default parameter was declared here"}, {"location": {"col": 11, "file": 33, "line": 92}, "message": "calling a function that uses a default argument is disallowed"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/pdns/webserver.cc", "reportHash": "f3b121cc7684d75c29b4138c9eed1c01", "checkerName": "fuchsia-default-arguments", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 4, "file": 35, "line": 221}, "message": "default parameter was declared here"}, {"location": {"col": 11, "file": 33, "line": 98}, "message": "calling a function that uses a default argument is disallowed"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/pdns/webserver.cc", "reportHash": "d85bd1b8542635bcb1e9932067c0940d", "checkerName": "fuchsia-default-arguments", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 32, "file": 33, "line": 102}, "message": "const                     & (fixit)"}, {"location": {"col": 59, "file": 33, "line": 102}, "message": "the parameter 'handler' is copied for each invocation but only used as a const reference; consider making it a const reference"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/pdns/webserver.cc", "reportHash": "0770d894c12ff78f17bbf677a8bba83d", "checkerName": "performance-unnecessary-value-param", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 11, "file": 33, "line": 105}, "message": "dynamic_cast (fixit)"}, {"location": {"col": 11, "file": 33, "line": 105}, "message": "do not use static_cast to downcast from a base to a derived class; use dynamic_cast instead"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/pdns/webserver.cc", "reportHash": "8f6efee14fc09802e5f2eeae4110eb23", "checkerName": "cppcoreguidelines-pro-type-static-cast-downcast", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 43, "file": 33, "line": 105}, "message": "dynamic_cast (fixit)"}, {"location": {"col": 43, "file": 33, "line": 105}, "message": "do not use static_cast to downcast from a base to a derived class; use dynamic_cast instead"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/pdns/webserver.cc", "reportHash": "55a9cc39bfe6cd67f0f8c62a7a035283", "checkerName": "cppcoreguidelines-pro-type-static-cast-downcast", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 56, "file": 33, "line": 108}, "message": "const & (fixit)"}, {"location": {"col": 72, "file": 33, "line": 108}, "message": "the parameter 'handler' is copied for each invocation but only used as a const reference; consider making it a const reference"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/pdns/webserver.cc", "reportHash": "f3c38debf9ff2862c9043a40c04ff8ea", "checkerName": "performance-unnecessary-value-param", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 13, "file": 36, "line": 1056}, "message": "default parameter was declared here"}, {"location": {"col": 32, "file": 33, "line": 110}, "message": "calling a function that uses a default argument is disallowed"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/pdns/webserver.cc", "reportHash": "53d4c7d76dbdb08490835c2b380334a8", "checkerName": "fuchsia-default-arguments", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 71, "file": 8, "line": 60}, "message": "default parameter was declared here"}, {"location": {"col": 3, "file": 33, "line": 111}, "message": "calling a function that uses a default argument is disallowed"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/pdns/webserver.cc", "reportHash": "7401eb7c0c8f9fb162b6485e9ff5320c", "checkerName": "fuchsia-default-arguments", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 39, "file": 2, "line": 509}, "message": "default parameter was declared here"}, {"location": {"col": 19, "file": 33, "line": 116}, "message": "calling a function that uses a default argument is disallowed"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/pdns/webserver.cc", "reportHash": "18de68d47cf54d45dc06c79489836348", "checkerName": "fuchsia-default-arguments", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 39, "file": 2, "line": 509}, "message": "default parameter was declared here"}, {"location": {"col": 19, "file": 33, "line": 117}, "message": "calling a function that uses a default argument is disallowed"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/pdns/webserver.cc", "reportHash": "b13bb54bcd57fbd226cbee1f5a066f0d", "checkerName": "fuchsia-default-arguments", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 39, "file": 2, "line": 509}, "message": "default parameter was declared here"}, {"location": {"col": 19, "file": 33, "line": 118}, "message": "calling a function that uses a default argument is disallowed"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/pdns/webserver.cc", "reportHash": "03ad938addf681e44f1c632b2caeb6be", "checkerName": "fuchsia-default-arguments", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 39, "file": 2, "line": 509}, "message": "default parameter was declared here"}, {"location": {"col": 19, "file": 33, "line": 119}, "message": "calling a function that uses a default argument is disallowed"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/pdns/webserver.cc", "reportHash": "36eaea6c330ae2fd443b9670a6f7307b", "checkerName": "fuchsia-default-arguments", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 39, "file": 2, "line": 509}, "message": "default parameter was declared here"}, {"location": {"col": 19, "file": 33, "line": 121}, "message": "calling a function that uses a default argument is disallowed"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/pdns/webserver.cc", "reportHash": "f9ab40169e63e734987d3faec662448d", "checkerName": "fuchsia-default-arguments", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 28, "file": 33, "line": 128}, "message": "const                     & (fixit)"}, {"location": {"col": 55, "file": 33, "line": 128}, "message": "the parameter 'handler' is copied for each invocation but only used as a const reference; consider making it a const reference"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/pdns/webserver.cc", "reportHash": "64049d9595921c7b5fdd4bbc6ee71bd1", "checkerName": "performance-unnecessary-value-param", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 34, "file": 33, "line": 129}, "message": "{ (fixit)"}, {"location": {"col": 33, "file": 33, "line": 129}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/pdns/webserver.cc", "reportHash": "b4a55767c40d6e2cc8c3b1a09c1f5d3b", "checkerName": "hicpp-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 39, "file": 2, "line": 509}, "message": "default parameter was declared here"}, {"location": {"col": 17, "file": 33, "line": 131}, "message": "calling a function that uses a default argument is disallowed"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/pdns/webserver.cc", "reportHash": "9943bc5c51d00d1605f3eea567589ed2", "checkerName": "fuchsia-default-arguments", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 1, "file": 34, "line": 86}, "message": "type defined here"}, {"location": {"col": 11, "file": 33, "line": 135}, "message": "throwing an exception whose type 'HttpUnauthorizedException' is not derived from 'std::exception'"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/pdns/webserver.cc", "reportHash": "a0acf9ab4124d6c5ef95319b460313a2", "checkerName": "hicpp-exception-baseclass", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 39, "file": 2, "line": 509}, "message": "default parameter was declared here"}, {"location": {"col": 37, "file": 33, "line": 135}, "message": "calling a function that uses a default argument is disallowed"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/pdns/webserver.cc", "reportHash": "6a96ebee7a6a410f09a346a3253e8482", "checkerName": "fuchsia-default-arguments", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 39, "file": 2, "line": 509}, "message": "default parameter was declared here"}, {"location": {"col": 37, "file": 33, "line": 138}, "message": "calling a function that uses a default argument is disallowed"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/pdns/webserver.cc", "reportHash": "0812900a3b11d03fd7de9b20931030aa", "checkerName": "fuchsia-default-arguments", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 39, "file": 2, "line": 509}, "message": "default parameter was declared here"}, {"location": {"col": 76, "file": 33, "line": 138}, "message": "calling a function that uses a default argument is disallowed"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/pdns/webserver.cc", "reportHash": "cc3c6acff6696ffcb8b3e3749b24fa90", "checkerName": "fuchsia-default-arguments", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 1, "file": 34, "line": 86}, "message": "type defined here"}, {"location": {"col": 11, "file": 33, "line": 150}, "message": "throwing an exception whose type 'HttpUnauthorizedException' is not derived from 'std::exception'"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/pdns/webserver.cc", "reportHash": "a0acf9ab4124d6c5ef95319b460313a2", "checkerName": "hicpp-exception-baseclass", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 39, "file": 2, "line": 509}, "message": "default parameter was declared here"}, {"location": {"col": 37, "file": 33, "line": 150}, "message": "calling a function that uses a default argument is disallowed"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/pdns/webserver.cc", "reportHash": "6a96ebee7a6a410f09a346a3253e8482", "checkerName": "fuchsia-default-arguments", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 39, "file": 2, "line": 509}, "message": "default parameter was declared here"}, {"location": {"col": 17, "file": 33, "line": 153}, "message": "calling a function that uses a default argument is disallowed"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/pdns/webserver.cc", "reportHash": "70be79cd780e706c29b22e9ae6df6f51", "checkerName": "fuchsia-default-arguments", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 39, "file": 2, "line": 509}, "message": "default parameter was declared here"}, {"location": {"col": 17, "file": 33, "line": 156}, "message": "calling a function that uses a default argument is disallowed"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/pdns/webserver.cc", "reportHash": "1c030124273277d514604fcbdfe1effe", "checkerName": "fuchsia-default-arguments", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 39, "file": 2, "line": 509}, "message": "default parameter was declared here"}, {"location": {"col": 17, "file": 33, "line": 157}, "message": "calling a function that uses a default argument is disallowed"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/pdns/webserver.cc", "reportHash": "299c27fcc09b4b5bbd22cf70ab76e1e2", "checkerName": "fuchsia-default-arguments", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 39, "file": 2, "line": 509}, "message": "default parameter was declared here"}, {"location": {"col": 17, "file": 33, "line": 158}, "message": "calling a function that uses a default argument is disallowed"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/pdns/webserver.cc", "reportHash": "ffead77f62df5b6c41e8e53496f1742d", "checkerName": "fuchsia-default-arguments", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 39, "file": 2, "line": 509}, "message": "default parameter was declared here"}, {"location": {"col": 17, "file": 33, "line": 159}, "message": "calling a function that uses a default argument is disallowed"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/pdns/webserver.cc", "reportHash": "13000e5e700aac4aca876e68c2a42ceb", "checkerName": "fuchsia-default-arguments", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 39, "file": 2, "line": 509}, "message": "default parameter was declared here"}, {"location": {"col": 17, "file": 33, "line": 160}, "message": "calling a function that uses a default argument is disallowed"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/pdns/webserver.cc", "reportHash": "a8beeca0a91ccaa97b876cde607ad2d4", "checkerName": "fuchsia-default-arguments", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 39, "file": 2, "line": 509}, "message": "default parameter was declared here"}, {"location": {"col": 22, "file": 33, "line": 162}, "message": "calling a function that uses a default argument is disallowed"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/pdns/webserver.cc", "reportHash": "58a58c5f345856e5870b921a214ff205", "checkerName": "fuchsia-default-arguments", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 39, "file": 2, "line": 509}, "message": "default parameter was declared here"}, {"location": {"col": 26, "file": 33, "line": 168}, "message": "calling a function that uses a default argument is disallowed"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/pdns/webserver.cc", "reportHash": "23e8de01024866f7a8172c7dd763b24d", "checkerName": "fuchsia-default-arguments", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 39, "file": 2, "line": 509}, "message": "default parameter was declared here"}, {"location": {"col": 26, "file": 33, "line": 171}, "message": "calling a function that uses a default argument is disallowed"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/pdns/webserver.cc", "reportHash": "23e8de01024866f7a8172c7dd763b24d", "checkerName": "fuchsia-default-arguments", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 39, "file": 2, "line": 509}, "message": "default parameter was declared here"}, {"location": {"col": 25, "file": 33, "line": 177}, "message": "calling a function that uses a default argument is disallowed"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/pdns/webserver.cc", "reportHash": "b50c5efd806d211e055237ea90ba3711", "checkerName": "fuchsia-default-arguments", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 13, "file": 36, "line": 1056}, "message": "default parameter was declared here"}, {"location": {"col": 23, "file": 33, "line": 182}, "message": "calling a function that uses a default argument is disallowed"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/pdns/webserver.cc", "reportHash": "c273a3787e7438734cde062e54772b85", "checkerName": "fuchsia-default-arguments", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 28, "file": 33, "line": 186}, "message": "const                     & (fixit)"}, {"location": {"col": 55, "file": 33, "line": 186}, "message": "the parameter 'handler' is copied for each invocation but only used as a const reference; consider making it a const reference"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/pdns/webserver.cc", "reportHash": "9eec72b06a5b38a398a1d3eb3ac1efe1", "checkerName": "performance-unnecessary-value-param", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 1, "file": 34, "line": 86}, "message": "type defined here"}, {"location": {"col": 13, "file": 33, "line": 191}, "message": "throwing an exception whose type 'HttpUnauthorizedException' is not derived from 'std::exception'"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/pdns/webserver.cc", "reportHash": "06816f667d60a70f1b811f1faa23bc66", "checkerName": "hicpp-exception-baseclass", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 39, "file": 2, "line": 509}, "message": "default parameter was declared here"}, {"location": {"col": 39, "file": 33, "line": 191}, "message": "calling a function that uses a default argument is disallowed"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/pdns/webserver.cc", "reportHash": "89d9a40c1c29f092d30c00e162edd42b", "checkerName": "fuchsia-default-arguments", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 13, "file": 36, "line": 1056}, "message": "default parameter was declared here"}, {"location": {"col": 23, "file": 33, "line": 199}, "message": "calling a function that uses a default argument is disallowed"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/pdns/webserver.cc", "reportHash": "c32f22b2c998e8d730d2a228bbae3d86", "checkerName": "fuchsia-default-arguments", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 39, "file": 2, "line": 509}, "message": "default parameter was declared here"}, {"location": {"col": 17, "file": 33, "line": 204}, "message": "calling a function that uses a default argument is disallowed"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/pdns/webserver.cc", "reportHash": "c1368332d9466bff6b609b3aa94359f5", "checkerName": "fuchsia-default-arguments", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 32, "file": 33, "line": 206}, "message": "std::move() (fixit)"}, {"location": {"col": 32, "file": 33, "line": 206}, "message": "parameter 'client' is passed by value and only copied once; consider moving it to avoid unnecessary copies"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/pdns/webserver.cc", "reportHash": "adf8205e903eb6d14b6cf0acfc921f3d", "checkerName": "performance-unnecessary-value-param", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 39, "file": 2, "line": 509}, "message": "default parameter was declared here"}, {"location": {"col": 16, "file": 33, "line": 223}, "message": "calling a function that uses a default argument is disallowed"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/pdns/webserver.cc", "reportHash": "20f483f18f323b82309978d2914b82bd", "checkerName": "fuchsia-default-arguments", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 1, "file": 34, "line": 80}, "message": "type defined here"}, {"location": {"col": 13, "file": 33, "line": 228}, "message": "throwing an exception whose type 'HttpBadRequestException' is not derived from 'std::exception'"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/pdns/webserver.cc", "reportHash": "76368034300fea2435da7dedbd0db1f9", "checkerName": "hicpp-exception-baseclass", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 39, "file": 2, "line": 509}, "message": "default parameter was declared here"}, {"location": {"col": 36, "file": 33, "line": 235}, "message": "calling a function that uses a default argument is disallowed"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/pdns/webserver.cc", "reportHash": "11929181813675a1c841cf123ae2d84e", "checkerName": "fuchsia-default-arguments", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 31, "file": 2, "line": 2373}, "message": "default parameter was declared here"}, {"location": {"col": 11, "file": 33, "line": 237}, "message": "calling a function that uses a default argument is disallowed"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/pdns/webserver.cc", "reportHash": "7ac1ab2d3839bb359d266c971a7bc24d", "checkerName": "fuchsia-default-arguments", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 31, "file": 2, "line": 2373}, "message": "default parameter was declared here"}, {"location": {"col": 18, "file": 33, "line": 239}, "message": "calling a function that uses a default argument is disallowed"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/pdns/webserver.cc", "reportHash": "285df9cc1d00bc8c3c0d5e76ea91fdcd", "checkerName": "fuchsia-default-arguments", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 1, "file": 34, "line": 100}, "message": "type defined here"}, {"location": {"col": 13, "file": 33, "line": 247}, "message": "throwing an exception whose type 'HttpNotFoundException' is not derived from 'std::exception'"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/pdns/webserver.cc", "reportHash": "587f98227b4809b6b626bc6a088058bb", "checkerName": "hicpp-exception-baseclass", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 1, "file": 34, "line": 118}, "message": "type defined here"}, {"location": {"col": 13, "file": 33, "line": 259}, "message": "throwing an exception whose type 'HttpInternalServerErrorException' is not derived from 'std::exception'"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/pdns/webserver.cc", "reportHash": "c3107269dc968d4c90874a216e354dbf", "checkerName": "hicpp-exception-baseclass", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 1, "file": 34, "line": 118}, "message": "type defined here"}, {"location": {"col": 13, "file": 33, "line": 263}, "message": "throwing an exception whose type 'HttpInternalServerErrorException' is not derived from 'std::exception'"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/pdns/webserver.cc", "reportHash": "c3107269dc968d4c90874a216e354dbf", "checkerName": "hicpp-exception-baseclass", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 1, "file": 34, "line": 118}, "message": "type defined here"}, {"location": {"col": 13, "file": 33, "line": 267}, "message": "throwing an exception whose type 'HttpInternalServerErrorException' is not derived from 'std::exception'"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/pdns/webserver.cc", "reportHash": "c3107269dc968d4c90874a216e354dbf", "checkerName": "hicpp-exception-baseclass", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 5, "file": 33, "line": 272}, "message": "// TODO(root): rm this logline? (fixit)"}, {"location": {"col": 5, "file": 33, "line": 272}, "message": "missing username/bug in TODO"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/pdns/webserver.cc", "reportHash": "3a46b8e487024e2e8a26b503767d6ed1", "checkerName": "google-readability-todo", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 39, "file": 2, "line": 509}, "message": "default parameter was declared here"}, {"location": {"col": 20, "file": 33, "line": 276}, "message": "calling a function that uses a default argument is disallowed"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/pdns/webserver.cc", "reportHash": "8408fc146e216328ccdb809e5c821bf9", "checkerName": "fuchsia-default-arguments", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 39, "file": 2, "line": 509}, "message": "default parameter was declared here"}, {"location": {"col": 20, "file": 33, "line": 279}, "message": "calling a function that uses a default argument is disallowed"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/pdns/webserver.cc", "reportHash": "14734317eba10b4601cd3563e0fb7021", "checkerName": "fuchsia-default-arguments", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 39, "file": 2, "line": 509}, "message": "default parameter was declared here"}, {"location": {"col": 20, "file": 33, "line": 284}, "message": "calling a function that uses a default argument is disallowed"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/pdns/webserver.cc", "reportHash": "f7005f637a6c40e94d368cd84ecf217a", "checkerName": "fuchsia-default-arguments", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 39, "file": 2, "line": 509}, "message": "default parameter was declared here"}, {"location": {"col": 16, "file": 33, "line": 290}, "message": "calling a function that uses a default argument is disallowed"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/pdns/webserver.cc", "reportHash": "d646b3b17eef183a3778e16c527e4d3a", "checkerName": "fuchsia-default-arguments", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 39, "file": 2, "line": 509}, "message": "default parameter was declared here"}, {"location": {"col": 16, "file": 33, "line": 291}, "message": "calling a function that uses a default argument is disallowed"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/pdns/webserver.cc", "reportHash": "1e9c6c110fd60e5e17e40ca6985a0e4c", "checkerName": "fuchsia-default-arguments", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 39, "file": 2, "line": 509}, "message": "default parameter was declared here"}, {"location": {"col": 18, "file": 33, "line": 296}, "message": "calling a function that uses a default argument is disallowed"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/pdns/webserver.cc", "reportHash": "7d1a8550b6d9b41c812c2948aa9694ca", "checkerName": "fuchsia-default-arguments", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 73, "file": 33, "line": 300}, "message": "/*remote*/ (fixit)"}, {"location": {"col": 72, "file": 33, "line": 300}, "message": "parameter 'remote' is unused"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/pdns/webserver.cc", "reportHash": "8e4dcb7a919c3653cf56cfa41faaccd4", "checkerName": "misc-unused-parameters", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 76, "file": 33, "line": 341}, "message": "/*remote*/ (fixit)"}, {"location": {"col": 75, "file": 33, "line": 341}, "message": "parameter 'remote' is unused"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/pdns/webserver.cc", "reportHash": "e2ec008eb6f0657fe7adc53e3166e997", "checkerName": "misc-unused-parameters", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 33, "file": 33, "line": 361}, "message": "const                  & (fixit)"}, {"location": {"col": 57, "file": 33, "line": 361}, "message": "the parameter 'client' is copied for each invocation but only used as a const reference; consider making it a const reference"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/pdns/webserver.cc", "reportHash": "cdd9f3bceb9cf8c077b803209ddb1702", "checkerName": "performance-unnecessary-value-param", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 41, "file": 33, "line": 381}, "message": "do not implicitly decay an array into a pointer; consider using gsl::array_view or an explicit cast instead"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/pdns/webserver.cc", "reportHash": "353a32471fbdb5d045a68d21ac0806a7", "checkerName": "hicpp-no-array-decay", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 6, "file": 2, "line": 500}, "message": "default parameter was declared here"}, {"location": {"col": 25, "file": 33, "line": 383}, "message": "calling a function that uses a default argument is disallowed"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/pdns/webserver.cc", "reportHash": "3a0f374896ab8578b54364ab420fdf2d", "checkerName": "fuchsia-default-arguments", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 32, "file": 33, "line": 383}, "message": "do not implicitly decay an array into a pointer; consider using gsl::array_view or an explicit cast instead"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/pdns/webserver.cc", "reportHash": "166e6b6ebbd036ae36b587c0f5abc3e1", "checkerName": "hicpp-no-array-decay", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 27, "file": 4, "line": 560}, "message": "default parameter was declared here"}, {"location": {"col": 19, "file": 33, "line": 403}, "message": "calling a function that uses a default argument is disallowed"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/pdns/webserver.cc", "reportHash": "09d8305284038f30d165693217ffaad2", "checkerName": "fuchsia-default-arguments", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 37, "file": 33, "line": 415}, "message": "nullptr (fixit)"}, {"location": {"col": 37, "file": 33, "line": 415}, "message": "use nullptr"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/pdns/webserver.cc", "reportHash": "baa2959490cc52f158cc51c4fc93abb4", "checkerName": "hicpp-use-nullptr", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 40, "file": 33, "line": 415}, "message": "{ (fixit)"}, {"location": {"col": 39, "file": 33, "line": 415}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/pdns/webserver.cc", "reportHash": "ffe3ab971722ee13ef7be827f6d7690b", "checkerName": "google-readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 22, "file": 33, "line": 427}, "message": "string (fixit)"}, {"location": {"col": 22, "file": 33, "line": 427}, "message": "pass by value and use std::move"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/pdns/webserver.cc", "reportHash": "1dbe64b0832cc3a213a6dce2168974c9", "checkerName": "modernize-pass-by-value", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 95, "file": 33, "line": 439}, "message": "do not access members of unions; use (boost::)variant instead"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/pdns/webserver.cc", "reportHash": "a5dce560b15becd8bb4231bed244ea1f", "checkerName": "cppcoreguidelines-pro-type-union-access", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 17, "file": 33, "line": 449}, "message": "{ (fixit)"}, {"location": {"col": 16, "file": 33, "line": 449}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/pdns/webserver.cc", "reportHash": "4d063456428661b050dd19d1f2595921", "checkerName": "readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 42, "file": 33, "line": 463}, "message": "{ (fixit)"}, {"location": {"col": 41, "file": 33, "line": 463}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/pdns/webserver.cc", "reportHash": "a0e9b81e19c5766e155e431c9449a0eb", "checkerName": "hicpp-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 94, "file": 33, "line": 464}, "message": "do not access members of unions; use (boost::)variant instead"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/pdns/webserver.cc", "reportHash": "0ec3e3ec62176ac4bdf6eebe30b4354d", "checkerName": "cppcoreguidelines-pro-type-union-access", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 3, "file": 34, "line": 34}, "message": "explicit (fixit)"}, {"location": {"col": 3, "file": 34, "line": 34}, "message": "single-argument constructors must be marked explicit to avoid unintentional implicit conversions"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/pdns/webserver.hh", "reportHash": "28686b50ed561c0b3ca1de9b7fd59f7c", "checkerName": "hicpp-explicit-conversions", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 3, "file": 34, "line": 50}, "message": "explicit (fixit)"}, {"location": {"col": 3, "file": 34, "line": 50}, "message": "single-argument constructors must be marked explicit to avoid unintentional implicit conversions"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/pdns/webserver.hh", "reportHash": "2b841c23d5a471b7c05af0001aa8bc1a", "checkerName": "hicpp-explicit-conversions", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 61, "file": 34, "line": 53}, "message": "status_ (fixit)"}, {"location": {"col": 20, "file": 33, "line": 90}, "message": "the definition seen here"}, {"location": {"col": 8, "file": 34, "line": 53}, "message": "differing parameters are named here: ('status'), in definition: ('status_')"}, {"location": {"col": 8, "file": 34, "line": 53}, "message": "function 'HttpResponse::setErrorResult' has a definition with different parameter names"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/pdns/webserver.hh", "reportHash": "d4f95b9daa9bfe9110600ad7eac93824", "checkerName": "readability-inconsistent-declaration-parameter-name", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 63, "file": 34, "line": 54}, "message": "status_ (fixit)"}, {"location": {"col": 20, "file": 33, "line": 96}, "message": "the definition seen here"}, {"location": {"col": 8, "file": 34, "line": 54}, "message": "differing parameters are named here: ('status'), in definition: ('status_')"}, {"location": {"col": 8, "file": 34, "line": 54}, "message": "function 'HttpResponse::setSuccessResult' has a definition with different parameter names"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/pdns/webserver.hh", "reportHash": "ff78743c0270d164564903930e361293", "checkerName": "readability-inconsistent-declaration-parameter-name", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 3, "file": 34, "line": 97}, "message": "explicit (fixit)"}, {"location": {"col": 3, "file": 34, "line": 97}, "message": "single-argument constructors must be marked explicit to avoid unintentional implicit conversions"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/pdns/webserver.hh", "reportHash": "cd34cea82df3f729fe8e4df9352ed978", "checkerName": "hicpp-explicit-conversions", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 3, "file": 34, "line": 103}, "message": "explicit (fixit)"}, {"location": {"col": 3, "file": 34, "line": 103}, "message": "single-argument constructors must be marked explicit to avoid unintentional implicit conversions"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/pdns/webserver.hh", "reportHash": "eb835534c22d87b8d844a0f0fb202888", "checkerName": "hicpp-explicit-conversions", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 3, "file": 34, "line": 109}, "message": "explicit (fixit)"}, {"location": {"col": 3, "file": 34, "line": 109}, "message": "single-argument constructors must be marked explicit to avoid unintentional implicit conversions"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/pdns/webserver.hh", "reportHash": "9b861924354948eef18ae0c78fe66f9b", "checkerName": "hicpp-explicit-conversions", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 3, "file": 34, "line": 127}, "message": "explicit (fixit)"}, {"location": {"col": 3, "file": 34, "line": 127}, "message": "single-argument constructors must be marked explicit to avoid unintentional implicit conversions"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/pdns/webserver.hh", "reportHash": "6241f358a6da6cbc8cc5a883dbabf307", "checkerName": "hicpp-explicit-conversions", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 7, "file": 34, "line": 131}, "message": "class 'Server' defines a non-default destructor but does not define a copy constructor, a copy assignment operator, a move constructor or a move assignment operator"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/pdns/webserver.hh", "reportHash": "9770fc4ad8292cd6ba6801c4693bb0c6", "checkerName": "hicpp-special-member-functions", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 21, "file": 34, "line": 139}, "message": "= default; (fixit)"}, {"location": {"col": 11, "file": 34, "line": 139}, "message": "use '= default' to define a trivial destructor"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/pdns/webserver.hh", "reportHash": "1611cdec60b77c6af55c2ccac317c245", "checkerName": "hicpp-use-equals-default", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 24, "file": 34, "line": 155}, "message": "= default; (fixit)"}, {"location": {"col": 11, "file": 34, "line": 155}, "message": "use '= default' to define a trivial destructor"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/pdns/webserver.hh", "reportHash": "cc3529d5dcb1ee7f6058966e849640ef", "checkerName": "modernize-use-equals-default", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 35, "file": 34, "line": 177}, "message": "req (fixit)"}, {"location": {"col": 17, "file": 33, "line": 220}, "message": "the definition seen here"}, {"location": {"col": 8, "file": 34, "line": 177}, "message": "differing parameters are named here: ('request'), in definition: ('req')"}, {"location": {"col": 8, "file": 34, "line": 177}, "message": "function 'WebServer::handleRequest' has a definition with different parameter names"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/pdns/webserver.hh", "reportHash": "2ba08cd52ebdc8e03897837113bdc7e8", "checkerName": "readability-inconsistent-declaration-parameter-name", "reviewStatus": null, "severity": "STYLE"}]};
      window.onload = function() {
        if (!browserCompatible) {
          setNonCompatibleBrowserMessage();
        } else {
          BugViewer.init(data.files, data.reports);
          BugViewer.create();
          BugViewer.initByUrl();
        }
      };
    </script>
  </head>
  <body>
  <div class="container">
    <div id="content">
      <div id="side-bar">
        <div class="header">
          <a href="index.html" class="button">&#8249; Return to List</a>
        </div>
        <div id="report-nav">
          <div class="header">Reports</div>
        </div>
      </div>
      <div id="editor-wrapper">
        <div class="header">
          <div id="file">
            <span class="label">File:</span>
            <span id="file-path"></span>
          </div>
          <div id="checker">
            <span class="label">Checker name:</span>
            <span id="checker-name"></span>
          </div>
          <div id="review-status-wrapper">
            <span class="label">Review status:</span>
            <span id="review-status"></span>
          </div>
        </div>
        <div id="editor"></div>
      </div>
    </div>
  </div>
  </body>
</html>
