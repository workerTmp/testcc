<!DOCTYPE html>
<html>
  <head>
    <title>Plist HTML Viewer</title>

    <meta charset="UTF-8">

    <style type="text/css">
      .CodeMirror{font-family:monospace;height:300px;color:#000;direction:ltr}.CodeMirror-lines{padding:4px 0}.CodeMirror pre{padding:0 4px}.CodeMirror-gutter-filler,.CodeMirror-scrollbar-filler{background-color:#fff}.CodeMirror-gutters{border-right:1px solid #ddd;background-color:#f7f7f7;white-space:nowrap}.CodeMirror-linenumber{padding:0 3px 0 5px;min-width:20px;text-align:right;color:#999;white-space:nowrap}.CodeMirror-guttermarker{color:#000}.CodeMirror-guttermarker-subtle{color:#999}.CodeMirror-cursor{border-left:1px solid #000;border-right:none;width:0}.CodeMirror div.CodeMirror-secondarycursor{border-left:1px solid silver}.cm-fat-cursor .CodeMirror-cursor{width:auto;border:0!important;background:#7e7}.cm-fat-cursor div.CodeMirror-cursors{z-index:1}.cm-animate-fat-cursor{width:auto;border:0;-webkit-animation:blink 1.06s steps(1) infinite;-moz-animation:blink 1.06s steps(1) infinite;animation:blink 1.06s steps(1) infinite;background-color:#7e7}@-moz-keyframes blink{50%{background-color:transparent}}@-webkit-keyframes blink{50%{background-color:transparent}}@keyframes blink{50%{background-color:transparent}}.cm-tab{display:inline-block;text-decoration:inherit}.CodeMirror-rulers{position:absolute;left:0;right:0;top:-50px;bottom:-20px;overflow:hidden}.CodeMirror-ruler{border-left:1px solid #ccc;top:0;bottom:0;position:absolute}.cm-s-default .cm-header{color:#00f}.cm-s-default .cm-quote{color:#090}.cm-negative{color:#d44}.cm-positive{color:#292}.cm-header,.cm-strong{font-weight:700}.cm-em{font-style:italic}.cm-link{text-decoration:underline}.cm-strikethrough{text-decoration:line-through}.cm-s-default .cm-keyword{color:#708}.cm-s-default .cm-atom{color:#219}.cm-s-default .cm-number{color:#164}.cm-s-default .cm-def{color:#00f}.cm-s-default .cm-variable-2{color:#05a}.cm-s-default .cm-type,.cm-s-default .cm-variable-3{color:#085}.cm-s-default .cm-comment{color:#a50}.cm-s-default .cm-string{color:#a11}.cm-s-default .cm-string-2{color:#f50}.cm-s-default .cm-meta{color:#555}.cm-s-default .cm-qualifier{color:#555}.cm-s-default .cm-builtin{color:#30a}.cm-s-default .cm-bracket{color:#997}.cm-s-default .cm-tag{color:#170}.cm-s-default .cm-attribute{color:#00c}.cm-s-default .cm-hr{color:#999}.cm-s-default .cm-link{color:#00c}.cm-s-default .cm-error{color:red}.cm-invalidchar{color:red}.CodeMirror-composing{border-bottom:2px solid}div.CodeMirror span.CodeMirror-matchingbracket{color:#0f0}div.CodeMirror span.CodeMirror-nonmatchingbracket{color:#f22}.CodeMirror-matchingtag{background:rgba(255,150,0,.3)}.CodeMirror-activeline-background{background:#e8f2ff}.CodeMirror{position:relative;overflow:hidden;background:#fff}.CodeMirror-scroll{overflow:scroll!important;margin-bottom:-30px;margin-right:-30px;padding-bottom:30px;height:100%;outline:0;position:relative}.CodeMirror-sizer{position:relative;border-right:30px solid transparent}.CodeMirror-gutter-filler,.CodeMirror-hscrollbar,.CodeMirror-scrollbar-filler,.CodeMirror-vscrollbar{position:absolute;z-index:6;display:none}.CodeMirror-vscrollbar{right:0;top:0;overflow-x:hidden;overflow-y:scroll}.CodeMirror-hscrollbar{bottom:0;left:0;overflow-y:hidden;overflow-x:scroll}.CodeMirror-scrollbar-filler{right:0;bottom:0}.CodeMirror-gutter-filler{left:0;bottom:0}.CodeMirror-gutters{position:absolute;left:0;top:0;min-height:100%;z-index:3}.CodeMirror-gutter{white-space:normal;height:100%;display:inline-block;vertical-align:top;margin-bottom:-30px}.CodeMirror-gutter-wrapper{position:absolute;z-index:4;background:0 0!important;border:none!important}.CodeMirror-gutter-background{position:absolute;top:0;bottom:0;z-index:4}.CodeMirror-gutter-elt{position:absolute;cursor:default;z-index:4}.CodeMirror-gutter-wrapper ::selection{background-color:transparent}.CodeMirror-gutter-wrapper ::-moz-selection{background-color:transparent}.CodeMirror-lines{cursor:text;min-height:1px}.CodeMirror pre{-moz-border-radius:0;-webkit-border-radius:0;border-radius:0;border-width:0;background:0 0;font-family:inherit;font-size:inherit;margin:0;white-space:pre;word-wrap:normal;line-height:inherit;color:inherit;z-index:2;position:relative;overflow:visible;-webkit-tap-highlight-color:transparent;-webkit-font-variant-ligatures:contextual;font-variant-ligatures:contextual}.CodeMirror-wrap pre{word-wrap:break-word;white-space:pre-wrap;word-break:normal}.CodeMirror-linebackground{position:absolute;left:0;right:0;top:0;bottom:0;z-index:0}.CodeMirror-linewidget{position:relative;z-index:2;overflow:auto}.CodeMirror-rtl pre{direction:rtl}.CodeMirror-code{outline:0}.CodeMirror-gutter,.CodeMirror-gutters,.CodeMirror-linenumber,.CodeMirror-scroll,.CodeMirror-sizer{-moz-box-sizing:content-box;box-sizing:content-box}.CodeMirror-measure{position:absolute;width:100%;height:0;overflow:hidden;visibility:hidden}.CodeMirror-cursor{position:absolute;pointer-events:none}.CodeMirror-measure pre{position:static}div.CodeMirror-cursors{visibility:hidden;position:relative;z-index:3}div.CodeMirror-dragcursors{visibility:visible}.CodeMirror-focused div.CodeMirror-cursors{visibility:visible}.CodeMirror-selected{background:#d9d9d9}.CodeMirror-focused .CodeMirror-selected{background:#d7d4f0}.CodeMirror-crosshair{cursor:crosshair}.CodeMirror-line::selection,.CodeMirror-line>span::selection,.CodeMirror-line>span>span::selection{background:#d7d4f0}.CodeMirror-line::-moz-selection,.CodeMirror-line>span::-moz-selection,.CodeMirror-line>span>span::-moz-selection{background:#d7d4f0}.cm-searching{background-color:#ffa;background-color:rgba(255,255,0,.4)}.cm-force-border{padding-right:.1px}@media print{.CodeMirror div.CodeMirror-cursors{visibility:hidden}}.cm-tab-wrap-hack:after{content:''}span.CodeMirror-selectedtext{background:0 0}
/*# sourceMappingURL=codemirror.min.css.map */

      .severity-low {
  background-color: #669603;
}

.severity-low:after {
  content : 'L';
}

.severity-unspecified {
  background-color: #666666;
}

.severity-unspecified:after {
  content : 'U';
}

.severity-style {
  background-color: #9932cc;
}

.severity-style:after {
  content : 'S';
}

.severity-medium {
  background-color: #a9d323;
  color: black;
}

.severity-medium:after {
  content : 'M';
}

.severity-high {
  background-color: #ffa800;
}

.severity-high:after {
  content : 'H';
}

.severity-critical {
  background-color: #e92625;
}

.severity-critical:after {
  content : 'C';
}

i[class*="severity-"] {
  line-height: normal;
  text-transform: capitalize;
  font-size: 0.8em;
  font-weight: bold;
  color: white;
  display: inline-block;
  width: 16px;
  height: 16px;
  text-align: center;
  font-family: sans-serif;
}

      html, body {
  width: 100%;
  height: 100%;
  padding: 0px;
  margin: 0px;
}

div.container {
  padding: 10px;
}

#content {
  height: 100%;
  display: block;
  overflow: hidden;
}

#content > div {
  margin: 10px;
  overflow: hidden;
  border: 1px solid #ddd;
  border-radius: 3px;
  overflow: hidden;
  height: 97%;
}

.button {
  background-color: #f1f1f1;
  text-decoration: none;
  display: inline-block;
  padding: 8px 16px;
  color: black;
  cursor: pointer;
}

.button:hover {
  background-color: #ddd;
  color: black;
}

.review-status {
  color: white;
  text-align: center;
}

.review-status-confirmed {
  background-color: #e92625;
}

.review-status-false-positive {
  background-color: grey;
}

.review-status-intentional {
  background-color: #669603;
}

      div.container {
  width: 100%;
  height: 100%;
  padding: 0px;
}

#editor-wrapper {
  margin: 10px;
}

#side-bar {
  float: left;
  width: 260px;
  margin: 0px;
}

#report-nav ul {
  list-style-type: none;
  padding: 0;
  margin: 0;
  overflow-y: auto;
  height: 100%;
}

#report-nav ul > li {
  padding: .4em;
  background-color: #fff;
  border-bottom: 1px solid rgba(0,0,0,.125);
  text-align: left;
  overflow: hidden;
  white-space: nowrap;
  text-overflow: ellipsis;
}

#report-nav ul > li.active {
  background-color: #427ea9;
  color: white;
}

#report-nav ul > li:hover {
  background-color: #427ea9;
  color: white;
  cursor: pointer;
}

#report-nav ul a {
  text-decoration: none;
}

#report-nav i[class*="severity-"] {
  margin-right: 5px;
}

.header {
  border-bottom: 1px solid lightgrey;
  font-family: monospace;
  padding: 10px;
  background-color: #fafbfc;
  border-bottom: 1px solid #e1e4e8;
  border-top-left-radius: 2px;
  border-top-right-radius: 2px;
}

#report-nav .header {
  font-weight: bold;
}

#editor-wrapper .header > div {
  padding-top: 2px;
}

#file-path,
#checker-name {
  color: #195ea2;
}

#review-status {
  padding: 0px 5px;
}

#file-path {
  font-family: monospace;
}

.check-msg {
  display: inline-block;
  padding: 3px 6px;
  margin: 1px;
  -webkit-border-radius: 5px;
  -moz-border-radius: 5px;
  border-radius: 5px;
}

.check-msg.info {
  color: #00546f;
  background-color: #bfdfe9;
  border: 1px solid #87a8b3;
}

.check-msg.error {
  background-color: #f2dede;
  color: #a94442;
  border: 1px solid #ebcccc;
}

.check-msg.macro {
  background-color: #d7dac2;
  color: #4f5c6d;
  border: 1px solid #d7dac2;
}

.check-msg.note {
  background-color: #d7d7d7;
  color: #4f5c6d;
  border: 1px solid #bfbfbf;
}

.check-msg.current {
  border: 2px dashed #3692ff;
}

.check-msg .tag {
  padding: 1px 5px;
  text-align: center;
  border-radius: 2px;
  margin-right: 5px;
  text-decoration: inherit;
}

.check-msg .tag.macro {
  background-color: #83876a;
  color: white;
  text-transform: capitalize;
}

.check-msg .tag.note {
  background-color: #9299a1;
  color: white;
  text-transform: capitalize;
}

.checker-enum {
  color: white;
  padding: 1px 5px;
  text-align: center;
  border-radius: 25px;
  margin-right: 5px;
  text-decoration: inherit;
}

.checker-enum.info {
  background-color: #427ea9;
}

.checker-enum.error {
  background-color: #a94442;
}

.arrow {
  border: solid black;
  border-width: 0 3px 3px 0;
  display: inline-block;
  padding: 3px;
  cursor: pointer;
  margin: 0px 5px;
}

.arrow:hover {
  border: solid #437ea8;
  border-width: 0 3px 3px 0;
}

.left-arrow {
  transform: rotate(135deg);
  -webkit-transform: rotate(135deg);
}

.right-arrow {
  transform: rotate(-45deg);
  -webkit-transform: rotate(-45deg);
}

    </style>

    <script type="text/javascript">
      function setNonCompatibleBrowserMessage() {
  document.body.innerHTML =
    '<h2 style="margin-left: 20px;">Your browser is not compatible with CodeChecker Viewer!</h2> \
     <p style="margin-left: 20px;">The version required for the following browsers are:</p> \
     <ul style="margin-left: 20px;"> \
     <li>Internet Explorer: version 9 or newer</li> \
     <li>Firefox: version 22.0 or newer</li> \
     </ul>';
}

// http://stackoverflow.com/questions/5916900/how-can-you-detect-the-version-of-a-browser
var browserVersion = (function(){
  var ua = navigator.userAgent, tem,
    M = ua.match(/(opera|chrome|safari|firefox|msie|trident(?=\/))\/?\s*(\d+)/i) || [];

  if (/trident/i.test(M[1])) {
    tem = /\brv[ :]+(\d+)/g.exec(ua) || [];
    return 'IE ' + (tem[1] || '');
  }

  if (M[1] === 'Chrome') {
    tem = ua.match(/\b(OPR|Edge)\/(\d+)/);
    if (tem != null) return tem.slice(1).join(' ').replace('OPR', 'Opera');
  }

  M = M[2] ? [M[1], M[2]] : [navigator.appName, navigator.appVersion, '-?'];
  if ((tem = ua.match(/version\/(\d+)/i)) != null) M.splice(1, 1, tem[1]);
    return M.join(' ');
})();

var pos = browserVersion.indexOf(' ');
var browser = browserVersion.substr(0, pos);
var version = parseInt(browserVersion.substr(pos + 1));

var browserCompatible
  = browser === 'Firefox'
  ? version >= 22
  : browser === 'IE'
  ? version >= 9
  : true;


      /* MIT License

Copyright (C) 2017 by Marijn Haverbeke <marijnh@gmail.com> and others

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
THE SOFTWARE.
 */
      !function(e,t){"object"==typeof exports&&"undefined"!=typeof module?module.exports=t():"function"==typeof define&&define.amd?define(t):e.CodeMirror=t()}(this,function(){"use strict";function e(e){return new RegExp("(^|\\s)"+e+"(?:$|\\s)\\s*")}function t(e){for(var t=e.childNodes.length;t>0;--t)e.removeChild(e.firstChild);return e}function r(e,r){return t(e).appendChild(r)}function n(e,t,r,n){var i=document.createElement(e);if(r&&(i.className=r),n&&(i.style.cssText=n),"string"==typeof t)i.appendChild(document.createTextNode(t));else if(t)for(var o=0;o<t.length;++o)i.appendChild(t[o]);return i}function i(e,t,r,i){var o=n(e,t,r,i);return o.setAttribute("role","presentation"),o}function o(e,t){if(3==t.nodeType&&(t=t.parentNode),e.contains)return e.contains(t);do{if(11==t.nodeType&&(t=t.host),t==e)return!0}while(t=t.parentNode)}function l(){var e;try{e=document.activeElement}catch(t){e=document.body||null}for(;e&&e.shadowRoot&&e.shadowRoot.activeElement;)e=e.shadowRoot.activeElement;return e}function s(t,r){var n=t.className;e(r).test(n)||(t.className+=(n?" ":"")+r)}function a(t,r){for(var n=t.split(" "),i=0;i<n.length;i++)n[i]&&!e(n[i]).test(r)&&(r+=" "+n[i]);return r}function u(e){var t=Array.prototype.slice.call(arguments,1);return function(){return e.apply(null,t)}}function c(e,t,r){t||(t={});for(var n in e)!e.hasOwnProperty(n)||!1===r&&t.hasOwnProperty(n)||(t[n]=e[n]);return t}function f(e,t,r,n,i){null==t&&-1==(t=e.search(/[^\s\u00a0]/))&&(t=e.length);for(var o=n||0,l=i||0;;){var s=e.indexOf("\t",o);if(s<0||s>=t)return l+(t-o);l+=s-o,l+=r-l%r,o=s+1}}function h(e,t){for(var r=0;r<e.length;++r)if(e[r]==t)return r;return-1}function d(e,t,r){for(var n=0,i=0;;){var o=e.indexOf("\t",n);-1==o&&(o=e.length);var l=o-n;if(o==e.length||i+l>=t)return n+Math.min(l,t-i);if(i+=o-n,i+=r-i%r,n=o+1,i>=t)return n}}function p(e){for(;Kl.length<=e;)Kl.push(g(Kl)+" ");return Kl[e]}function g(e){return e[e.length-1]}function v(e,t){for(var r=[],n=0;n<e.length;n++)r[n]=t(e[n],n);return r}function m(e,t,r){for(var n=0,i=r(t);n<e.length&&r(e[n])<=i;)n++;e.splice(n,0,t)}function y(){}function b(e,t){var r;return Object.create?r=Object.create(e):(y.prototype=e,r=new y),t&&c(t,r),r}function w(e){return/\w/.test(e)||e>""&&(e.toUpperCase()!=e.toLowerCase()||jl.test(e))}function x(e,t){return t?!!(t.source.indexOf("\\w")>-1&&w(e))||t.test(e):w(e)}function C(e){for(var t in e)if(e.hasOwnProperty(t)&&e[t])return!1;return!0}function S(e){return e.charCodeAt(0)>=768&&Xl.test(e)}function L(e,t,r){for(;(r<0?t>0:t<e.length)&&S(e.charAt(t));)t+=r;return t}function k(e,t,r){for(var n=t>r?-1:1;;){if(t==r)return t;var i=(t+r)/2,o=n<0?Math.ceil(i):Math.floor(i);if(o==t)return e(o)?t:r;e(o)?r=o:t=o+n}}function T(e,t,r){var o=this;this.input=r,o.scrollbarFiller=n("div",null,"CodeMirror-scrollbar-filler"),o.scrollbarFiller.setAttribute("cm-not-content","true"),o.gutterFiller=n("div",null,"CodeMirror-gutter-filler"),o.gutterFiller.setAttribute("cm-not-content","true"),o.lineDiv=i("div",null,"CodeMirror-code"),o.selectionDiv=n("div",null,null,"position: relative; z-index: 1"),o.cursorDiv=n("div",null,"CodeMirror-cursors"),o.measure=n("div",null,"CodeMirror-measure"),o.lineMeasure=n("div",null,"CodeMirror-measure"),o.lineSpace=i("div",[o.measure,o.lineMeasure,o.selectionDiv,o.cursorDiv,o.lineDiv],null,"position: relative; outline: none");var l=i("div",[o.lineSpace],"CodeMirror-lines");o.mover=n("div",[l],null,"position: relative"),o.sizer=n("div",[o.mover],"CodeMirror-sizer"),o.sizerWidth=null,o.heightForcer=n("div",null,null,"position: absolute; height: "+Rl+"px; width: 1px;"),o.gutters=n("div",null,"CodeMirror-gutters"),o.lineGutter=null,o.scroller=n("div",[o.sizer,o.heightForcer,o.gutters],"CodeMirror-scroll"),o.scroller.setAttribute("tabIndex","-1"),o.wrapper=n("div",[o.scrollbarFiller,o.gutterFiller,o.scroller],"CodeMirror"),gl&&vl<8&&(o.gutters.style.zIndex=-1,o.scroller.style.paddingRight=0),ml||fl&&Tl||(o.scroller.draggable=!0),e&&(e.appendChild?e.appendChild(o.wrapper):e(o.wrapper)),o.viewFrom=o.viewTo=t.first,o.reportedViewFrom=o.reportedViewTo=t.first,o.view=[],o.renderedView=null,o.externalMeasured=null,o.viewOffset=0,o.lastWrapHeight=o.lastWrapWidth=0,o.updateLineNumbers=null,o.nativeBarWidth=o.barHeight=o.barWidth=0,o.scrollbarsClipped=!1,o.lineNumWidth=o.lineNumInnerWidth=o.lineNumChars=null,o.alignWidgets=!1,o.cachedCharWidth=o.cachedTextHeight=o.cachedPaddingH=null,o.maxLine=null,o.maxLineLength=0,o.maxLineChanged=!1,o.wheelDX=o.wheelDY=o.wheelStartX=o.wheelStartY=null,o.shift=!1,o.selForContextMenu=null,o.activeTouch=null,r.init(o)}function M(e,t){if((t-=e.first)<0||t>=e.size)throw new Error("There is no line "+(t+e.first)+" in the document.");for(var r=e;!r.lines;)for(var n=0;;++n){var i=r.children[n],o=i.chunkSize();if(t<o){r=i;break}t-=o}return r.lines[t]}function N(e,t,r){var n=[],i=t.line;return e.iter(t.line,r.line+1,function(e){var o=e.text;i==r.line&&(o=o.slice(0,r.ch)),i==t.line&&(o=o.slice(t.ch)),n.push(o),++i}),n}function O(e,t,r){var n=[];return e.iter(t,r,function(e){n.push(e.text)}),n}function A(e,t){var r=t-e.height;if(r)for(var n=e;n;n=n.parent)n.height+=r}function W(e){if(null==e.parent)return null;for(var t=e.parent,r=h(t.lines,e),n=t.parent;n;t=n,n=n.parent)for(var i=0;n.children[i]!=t;++i)r+=n.children[i].chunkSize();return r+t.first}function D(e,t){var r=e.first;e:do{for(var n=0;n<e.children.length;++n){var i=e.children[n],o=i.height;if(t<o){e=i;continue e}t-=o,r+=i.chunkSize()}return r}while(!e.lines);for(var l=0;l<e.lines.length;++l){var s=e.lines[l].height;if(t<s)break;t-=s}return r+l}function H(e,t){return t>=e.first&&t<e.first+e.size}function F(e,t){return String(e.lineNumberFormatter(t+e.firstLineNumber))}function E(e,t,r){if(void 0===r&&(r=null),!(this instanceof E))return new E(e,t,r);this.line=e,this.ch=t,this.sticky=r}function P(e,t){return e.line-t.line||e.ch-t.ch}function I(e,t){return e.sticky==t.sticky&&0==P(e,t)}function z(e){return E(e.line,e.ch)}function R(e,t){return P(e,t)<0?t:e}function B(e,t){return P(e,t)<0?e:t}function G(e,t){return Math.max(e.first,Math.min(t,e.first+e.size-1))}function U(e,t){if(t.line<e.first)return E(e.first,0);var r=e.first+e.size-1;return t.line>r?E(r,M(e,r).text.length):V(t,M(e,t.line).text.length)}function V(e,t){var r=e.ch;return null==r||r>t?E(e.line,t):r<0?E(e.line,0):e}function K(e,t){for(var r=[],n=0;n<t.length;n++)r[n]=U(e,t[n]);return r}function j(){Yl=!0}function X(){_l=!0}function Y(e,t,r){this.marker=e,this.from=t,this.to=r}function _(e,t){if(e)for(var r=0;r<e.length;++r){var n=e[r];if(n.marker==t)return n}}function $(e,t){for(var r,n=0;n<e.length;++n)e[n]!=t&&(r||(r=[])).push(e[n]);return r}function q(e,t){e.markedSpans=e.markedSpans?e.markedSpans.concat([t]):[t],t.marker.attachLine(e)}function Z(e,t,r){var n;if(e)for(var i=0;i<e.length;++i){var o=e[i],l=o.marker;if(null==o.from||(l.inclusiveLeft?o.from<=t:o.from<t)||o.from==t&&"bookmark"==l.type&&(!r||!o.marker.insertLeft)){var s=null==o.to||(l.inclusiveRight?o.to>=t:o.to>t);(n||(n=[])).push(new Y(l,o.from,s?null:o.to))}}return n}function Q(e,t,r){var n;if(e)for(var i=0;i<e.length;++i){var o=e[i],l=o.marker;if(null==o.to||(l.inclusiveRight?o.to>=t:o.to>t)||o.from==t&&"bookmark"==l.type&&(!r||o.marker.insertLeft)){var s=null==o.from||(l.inclusiveLeft?o.from<=t:o.from<t);(n||(n=[])).push(new Y(l,s?null:o.from-t,null==o.to?null:o.to-t))}}return n}function J(e,t){if(t.full)return null;var r=H(e,t.from.line)&&M(e,t.from.line).markedSpans,n=H(e,t.to.line)&&M(e,t.to.line).markedSpans;if(!r&&!n)return null;var i=t.from.ch,o=t.to.ch,l=0==P(t.from,t.to),s=Z(r,i,l),a=Q(n,o,l),u=1==t.text.length,c=g(t.text).length+(u?i:0);if(s)for(var f=0;f<s.length;++f){var h=s[f];if(null==h.to){var d=_(a,h.marker);d?u&&(h.to=null==d.to?null:d.to+c):h.to=i}}if(a)for(var p=0;p<a.length;++p){var v=a[p];null!=v.to&&(v.to+=c),null==v.from?_(s,v.marker)||(v.from=c,u&&(s||(s=[])).push(v)):(v.from+=c,u&&(s||(s=[])).push(v))}s&&(s=ee(s)),a&&a!=s&&(a=ee(a));var m=[s];if(!u){var y,b=t.text.length-2;if(b>0&&s)for(var w=0;w<s.length;++w)null==s[w].to&&(y||(y=[])).push(new Y(s[w].marker,null,null));for(var x=0;x<b;++x)m.push(y);m.push(a)}return m}function ee(e){for(var t=0;t<e.length;++t){var r=e[t];null!=r.from&&r.from==r.to&&!1!==r.marker.clearWhenEmpty&&e.splice(t--,1)}return e.length?e:null}function te(e,t,r){var n=null;if(e.iter(t.line,r.line+1,function(e){if(e.markedSpans)for(var t=0;t<e.markedSpans.length;++t){var r=e.markedSpans[t].marker;!r.readOnly||n&&-1!=h(n,r)||(n||(n=[])).push(r)}}),!n)return null;for(var i=[{from:t,to:r}],o=0;o<n.length;++o)for(var l=n[o],s=l.find(0),a=0;a<i.length;++a){var u=i[a];if(!(P(u.to,s.from)<0||P(u.from,s.to)>0)){var c=[a,1],f=P(u.from,s.from),d=P(u.to,s.to);(f<0||!l.inclusiveLeft&&!f)&&c.push({from:u.from,to:s.from}),(d>0||!l.inclusiveRight&&!d)&&c.push({from:s.to,to:u.to}),i.splice.apply(i,c),a+=c.length-3}}return i}function re(e){var t=e.markedSpans;if(t){for(var r=0;r<t.length;++r)t[r].marker.detachLine(e);e.markedSpans=null}}function ne(e,t){if(t){for(var r=0;r<t.length;++r)t[r].marker.attachLine(e);e.markedSpans=t}}function ie(e){return e.inclusiveLeft?-1:0}function oe(e){return e.inclusiveRight?1:0}function le(e,t){var r=e.lines.length-t.lines.length;if(0!=r)return r;var n=e.find(),i=t.find(),o=P(n.from,i.from)||ie(e)-ie(t);if(o)return-o;var l=P(n.to,i.to)||oe(e)-oe(t);return l||t.id-e.id}function se(e,t){var r,n=_l&&e.markedSpans;if(n)for(var i=void 0,o=0;o<n.length;++o)(i=n[o]).marker.collapsed&&null==(t?i.from:i.to)&&(!r||le(r,i.marker)<0)&&(r=i.marker);return r}function ae(e){return se(e,!0)}function ue(e){return se(e,!1)}function ce(e,t,r,n,i){var o=M(e,t),l=_l&&o.markedSpans;if(l)for(var s=0;s<l.length;++s){var a=l[s];if(a.marker.collapsed){var u=a.marker.find(0),c=P(u.from,r)||ie(a.marker)-ie(i),f=P(u.to,n)||oe(a.marker)-oe(i);if(!(c>=0&&f<=0||c<=0&&f>=0)&&(c<=0&&(a.marker.inclusiveRight&&i.inclusiveLeft?P(u.to,r)>=0:P(u.to,r)>0)||c>=0&&(a.marker.inclusiveRight&&i.inclusiveLeft?P(u.from,n)<=0:P(u.from,n)<0)))return!0}}}function fe(e){for(var t;t=ae(e);)e=t.find(-1,!0).line;return e}function he(e){for(var t;t=ue(e);)e=t.find(1,!0).line;return e}function de(e){for(var t,r;t=ue(e);)e=t.find(1,!0).line,(r||(r=[])).push(e);return r}function pe(e,t){var r=M(e,t),n=fe(r);return r==n?t:W(n)}function ge(e,t){if(t>e.lastLine())return t;var r,n=M(e,t);if(!ve(e,n))return t;for(;r=ue(n);)n=r.find(1,!0).line;return W(n)+1}function ve(e,t){var r=_l&&t.markedSpans;if(r)for(var n=void 0,i=0;i<r.length;++i)if((n=r[i]).marker.collapsed){if(null==n.from)return!0;if(!n.marker.widgetNode&&0==n.from&&n.marker.inclusiveLeft&&me(e,t,n))return!0}}function me(e,t,r){if(null==r.to){var n=r.marker.find(1,!0);return me(e,n.line,_(n.line.markedSpans,r.marker))}if(r.marker.inclusiveRight&&r.to==t.text.length)return!0;for(var i=void 0,o=0;o<t.markedSpans.length;++o)if((i=t.markedSpans[o]).marker.collapsed&&!i.marker.widgetNode&&i.from==r.to&&(null==i.to||i.to!=r.from)&&(i.marker.inclusiveLeft||r.marker.inclusiveRight)&&me(e,t,i))return!0}function ye(e){for(var t=0,r=(e=fe(e)).parent,n=0;n<r.lines.length;++n){var i=r.lines[n];if(i==e)break;t+=i.height}for(var o=r.parent;o;r=o,o=r.parent)for(var l=0;l<o.children.length;++l){var s=o.children[l];if(s==r)break;t+=s.height}return t}function be(e){if(0==e.height)return 0;for(var t,r=e.text.length,n=e;t=ae(n);){var i=t.find(0,!0);n=i.from.line,r+=i.from.ch-i.to.ch}for(n=e;t=ue(n);){var o=t.find(0,!0);r-=n.text.length-o.from.ch,r+=(n=o.to.line).text.length-o.to.ch}return r}function we(e){var t=e.display,r=e.doc;t.maxLine=M(r,r.first),t.maxLineLength=be(t.maxLine),t.maxLineChanged=!0,r.iter(function(e){var r=be(e);r>t.maxLineLength&&(t.maxLineLength=r,t.maxLine=e)})}function xe(e,t,r,n){if(!e)return n(t,r,"ltr",0);for(var i=!1,o=0;o<e.length;++o){var l=e[o];(l.from<r&&l.to>t||t==r&&l.to==t)&&(n(Math.max(l.from,t),Math.min(l.to,r),1==l.level?"rtl":"ltr",o),i=!0)}i||n(t,r,"ltr")}function Ce(e,t,r){var n;$l=null;for(var i=0;i<e.length;++i){var o=e[i];if(o.from<t&&o.to>t)return i;o.to==t&&(o.from!=o.to&&"before"==r?n=i:$l=i),o.from==t&&(o.from!=o.to&&"before"!=r?n=i:$l=i)}return null!=n?n:$l}function Se(e,t){var r=e.order;return null==r&&(r=e.order=ql(e.text,t)),r}function Le(e,t){return e._handlers&&e._handlers[t]||Zl}function ke(e,t,r){if(e.removeEventListener)e.removeEventListener(t,r,!1);else if(e.detachEvent)e.detachEvent("on"+t,r);else{var n=e._handlers,i=n&&n[t];if(i){var o=h(i,r);o>-1&&(n[t]=i.slice(0,o).concat(i.slice(o+1)))}}}function Te(e,t){var r=Le(e,t);if(r.length)for(var n=Array.prototype.slice.call(arguments,2),i=0;i<r.length;++i)r[i].apply(null,n)}function Me(e,t,r){return"string"==typeof t&&(t={type:t,preventDefault:function(){this.defaultPrevented=!0}}),Te(e,r||t.type,e,t),He(t)||t.codemirrorIgnore}function Ne(e){var t=e._handlers&&e._handlers.cursorActivity;if(t)for(var r=e.curOp.cursorActivityHandlers||(e.curOp.cursorActivityHandlers=[]),n=0;n<t.length;++n)-1==h(r,t[n])&&r.push(t[n])}function Oe(e,t){return Le(e,t).length>0}function Ae(e){e.prototype.on=function(e,t){Ql(this,e,t)},e.prototype.off=function(e,t){ke(this,e,t)}}function We(e){e.preventDefault?e.preventDefault():e.returnValue=!1}function De(e){e.stopPropagation?e.stopPropagation():e.cancelBubble=!0}function He(e){return null!=e.defaultPrevented?e.defaultPrevented:0==e.returnValue}function Fe(e){We(e),De(e)}function Ee(e){return e.target||e.srcElement}function Pe(e){var t=e.which;return null==t&&(1&e.button?t=1:2&e.button?t=3:4&e.button&&(t=2)),Ml&&e.ctrlKey&&1==t&&(t=3),t}function Ie(e){if(null==Il){var t=n("span","​");r(e,n("span",[t,document.createTextNode("x")])),0!=e.firstChild.offsetHeight&&(Il=t.offsetWidth<=1&&t.offsetHeight>2&&!(gl&&vl<8))}var i=Il?n("span","​"):n("span"," ",null,"display: inline-block; width: 1px; margin-right: -1px");return i.setAttribute("cm-text",""),i}function ze(e){if(null!=zl)return zl;var n=r(e,document.createTextNode("AخA")),i=Wl(n,0,1).getBoundingClientRect(),o=Wl(n,1,2).getBoundingClientRect();return t(e),!(!i||i.left==i.right)&&(zl=o.right-i.right<3)}function Re(e){if(null!=ns)return ns;var t=r(e,n("span","x")),i=t.getBoundingClientRect(),o=Wl(t,0,1).getBoundingClientRect();return ns=Math.abs(i.left-o.left)>1}function Be(e,t){arguments.length>2&&(t.dependencies=Array.prototype.slice.call(arguments,2)),is[e]=t}function Ge(e){if("string"==typeof e&&os.hasOwnProperty(e))e=os[e];else if(e&&"string"==typeof e.name&&os.hasOwnProperty(e.name)){var t=os[e.name];"string"==typeof t&&(t={name:t}),(e=b(t,e)).name=t.name}else{if("string"==typeof e&&/^[\w\-]+\/[\w\-]+\+xml$/.test(e))return Ge("application/xml");if("string"==typeof e&&/^[\w\-]+\/[\w\-]+\+json$/.test(e))return Ge("application/json")}return"string"==typeof e?{name:e}:e||{name:"null"}}function Ue(e,t){t=Ge(t);var r=is[t.name];if(!r)return Ue(e,"text/plain");var n=r(e,t);if(ls.hasOwnProperty(t.name)){var i=ls[t.name];for(var o in i)i.hasOwnProperty(o)&&(n.hasOwnProperty(o)&&(n["_"+o]=n[o]),n[o]=i[o])}if(n.name=t.name,t.helperType&&(n.helperType=t.helperType),t.modeProps)for(var l in t.modeProps)n[l]=t.modeProps[l];return n}function Ve(e,t){c(t,ls.hasOwnProperty(e)?ls[e]:ls[e]={})}function Ke(e,t){if(!0===t)return t;if(e.copyState)return e.copyState(t);var r={};for(var n in t){var i=t[n];i instanceof Array&&(i=i.concat([])),r[n]=i}return r}function je(e,t){for(var r;e.innerMode&&(r=e.innerMode(t))&&r.mode!=e;)t=r.state,e=r.mode;return r||{mode:e,state:t}}function Xe(e,t,r){return!e.startState||e.startState(t,r)}function Ye(e,t,r,n){var i=[e.state.modeGen],o={};tt(e,t.text,e.doc.mode,r,function(e,t){return i.push(e,t)},o,n);for(var l=r.state,s=0;s<e.state.overlays.length;++s)!function(n){var l=e.state.overlays[n],s=1,a=0;r.state=!0,tt(e,t.text,l.mode,r,function(e,t){for(var r=s;a<e;){var n=i[s];n>e&&i.splice(s,1,e,i[s+1],n),s+=2,a=Math.min(e,n)}if(t)if(l.opaque)i.splice(r,s-r,e,"overlay "+t),s=r+2;else for(;r<s;r+=2){var o=i[r+1];i[r+1]=(o?o+" ":"")+"overlay "+t}},o)}(s);return r.state=l,{styles:i,classes:o.bgClass||o.textClass?o:null}}function _e(e,t,r){if(!t.styles||t.styles[0]!=e.state.modeGen){var n=$e(e,W(t)),i=t.text.length>e.options.maxHighlightLength&&Ke(e.doc.mode,n.state),o=Ye(e,t,n);i&&(n.state=i),t.stateAfter=n.save(!i),t.styles=o.styles,o.classes?t.styleClasses=o.classes:t.styleClasses&&(t.styleClasses=null),r===e.doc.highlightFrontier&&(e.doc.modeFrontier=Math.max(e.doc.modeFrontier,++e.doc.highlightFrontier))}return t.styles}function $e(e,t,r){var n=e.doc,i=e.display;if(!n.mode.startState)return new us(n,!0,t);var o=rt(e,t,r),l=o>n.first&&M(n,o-1).stateAfter,s=l?us.fromSaved(n,l,o):new us(n,Xe(n.mode),o);return n.iter(o,t,function(r){qe(e,r.text,s);var n=s.line;r.stateAfter=n==t-1||n%5==0||n>=i.viewFrom&&n<i.viewTo?s.save():null,s.nextLine()}),r&&(n.modeFrontier=s.line),s}function qe(e,t,r,n){var i=e.doc.mode,o=new ss(t,e.options.tabSize,r);for(o.start=o.pos=n||0,""==t&&Ze(i,r.state);!o.eol();)Qe(i,o,r.state),o.start=o.pos}function Ze(e,t){if(e.blankLine)return e.blankLine(t);if(e.innerMode){var r=je(e,t);return r.mode.blankLine?r.mode.blankLine(r.state):void 0}}function Qe(e,t,r,n){for(var i=0;i<10;i++){n&&(n[0]=je(e,r).mode);var o=e.token(t,r);if(t.pos>t.start)return o}throw new Error("Mode "+e.name+" failed to advance stream.")}function Je(e,t,r,n){var i,o,l=e.doc,s=l.mode,a=M(l,(t=U(l,t)).line),u=$e(e,t.line,r),c=new ss(a.text,e.options.tabSize,u);for(n&&(o=[]);(n||c.pos<t.ch)&&!c.eol();)c.start=c.pos,i=Qe(s,c,u.state),n&&o.push(new cs(c,i,Ke(l.mode,u.state)));return n?o:new cs(c,i,u.state)}function et(e,t){if(e)for(;;){var r=e.match(/(?:^|\s+)line-(background-)?(\S+)/);if(!r)break;e=e.slice(0,r.index)+e.slice(r.index+r[0].length);var n=r[1]?"bgClass":"textClass";null==t[n]?t[n]=r[2]:new RegExp("(?:^|s)"+r[2]+"(?:$|s)").test(t[n])||(t[n]+=" "+r[2])}return e}function tt(e,t,r,n,i,o,l){var s=r.flattenSpans;null==s&&(s=e.options.flattenSpans);var a,u=0,c=null,f=new ss(t,e.options.tabSize,n),h=e.options.addModeClass&&[null];for(""==t&&et(Ze(r,n.state),o);!f.eol();){if(f.pos>e.options.maxHighlightLength?(s=!1,l&&qe(e,t,n,f.pos),f.pos=t.length,a=null):a=et(Qe(r,f,n.state,h),o),h){var d=h[0].name;d&&(a="m-"+(a?d+" "+a:d))}if(!s||c!=a){for(;u<f.start;)i(u=Math.min(f.start,u+5e3),c);c=a}f.start=f.pos}for(;u<f.pos;){var p=Math.min(f.pos,u+5e3);i(p,c),u=p}}function rt(e,t,r){for(var n,i,o=e.doc,l=r?-1:t-(e.doc.mode.innerMode?1e3:100),s=t;s>l;--s){if(s<=o.first)return o.first;var a=M(o,s-1),u=a.stateAfter;if(u&&(!r||s+(u instanceof as?u.lookAhead:0)<=o.modeFrontier))return s;var c=f(a.text,null,e.options.tabSize);(null==i||n>c)&&(i=s-1,n=c)}return i}function nt(e,t){if(e.modeFrontier=Math.min(e.modeFrontier,t),!(e.highlightFrontier<t-10)){for(var r=e.first,n=t-1;n>r;n--){var i=M(e,n).stateAfter;if(i&&(!(i instanceof as)||n+i.lookAhead<t)){r=n+1;break}}e.highlightFrontier=Math.min(e.highlightFrontier,r)}}function it(e,t,r,n){e.text=t,e.stateAfter&&(e.stateAfter=null),e.styles&&(e.styles=null),null!=e.order&&(e.order=null),re(e),ne(e,r);var i=n?n(e):1;i!=e.height&&A(e,i)}function ot(e){e.parent=null,re(e)}function lt(e,t){if(!e||/^\s*$/.test(e))return null;var r=t.addModeClass?ps:ds;return r[e]||(r[e]=e.replace(/\S+/g,"cm-$&"))}function st(e,t){var r=i("span",null,null,ml?"padding-right: .1px":null),n={pre:i("pre",[r],"CodeMirror-line"),content:r,col:0,pos:0,cm:e,trailingSpace:!1,splitSpaces:(gl||ml)&&e.getOption("lineWrapping")};t.measure={};for(var o=0;o<=(t.rest?t.rest.length:0);o++){var l=o?t.rest[o-1]:t.line,s=void 0;n.pos=0,n.addToken=ut,ze(e.display.measure)&&(s=Se(l,e.doc.direction))&&(n.addToken=ft(n.addToken,s)),n.map=[],dt(l,n,_e(e,l,t!=e.display.externalMeasured&&W(l))),l.styleClasses&&(l.styleClasses.bgClass&&(n.bgClass=a(l.styleClasses.bgClass,n.bgClass||"")),l.styleClasses.textClass&&(n.textClass=a(l.styleClasses.textClass,n.textClass||""))),0==n.map.length&&n.map.push(0,0,n.content.appendChild(Ie(e.display.measure))),0==o?(t.measure.map=n.map,t.measure.cache={}):((t.measure.maps||(t.measure.maps=[])).push(n.map),(t.measure.caches||(t.measure.caches=[])).push({}))}if(ml){var u=n.content.lastChild;(/\bcm-tab\b/.test(u.className)||u.querySelector&&u.querySelector(".cm-tab"))&&(n.content.className="cm-tab-wrap-hack")}return Te(e,"renderLine",e,t.line,n.pre),n.pre.className&&(n.textClass=a(n.pre.className,n.textClass||"")),n}function at(e){var t=n("span","•","cm-invalidchar");return t.title="\\u"+e.charCodeAt(0).toString(16),t.setAttribute("aria-label",t.title),t}function ut(e,t,r,i,o,l,s){if(t){var a,u=e.splitSpaces?ct(t,e.trailingSpace):t,c=e.cm.state.specialChars,f=!1;if(c.test(t)){a=document.createDocumentFragment();for(var h=0;;){c.lastIndex=h;var d=c.exec(t),g=d?d.index-h:t.length-h;if(g){var v=document.createTextNode(u.slice(h,h+g));gl&&vl<9?a.appendChild(n("span",[v])):a.appendChild(v),e.map.push(e.pos,e.pos+g,v),e.col+=g,e.pos+=g}if(!d)break;h+=g+1;var m=void 0;if("\t"==d[0]){var y=e.cm.options.tabSize,b=y-e.col%y;(m=a.appendChild(n("span",p(b),"cm-tab"))).setAttribute("role","presentation"),m.setAttribute("cm-text","\t"),e.col+=b}else"\r"==d[0]||"\n"==d[0]?((m=a.appendChild(n("span","\r"==d[0]?"␍":"␤","cm-invalidchar"))).setAttribute("cm-text",d[0]),e.col+=1):((m=e.cm.options.specialCharPlaceholder(d[0])).setAttribute("cm-text",d[0]),gl&&vl<9?a.appendChild(n("span",[m])):a.appendChild(m),e.col+=1);e.map.push(e.pos,e.pos+1,m),e.pos++}}else e.col+=t.length,a=document.createTextNode(u),e.map.push(e.pos,e.pos+t.length,a),gl&&vl<9&&(f=!0),e.pos+=t.length;if(e.trailingSpace=32==u.charCodeAt(t.length-1),r||i||o||f||s){var w=r||"";i&&(w+=i),o&&(w+=o);var x=n("span",[a],w,s);return l&&(x.title=l),e.content.appendChild(x)}e.content.appendChild(a)}}function ct(e,t){if(e.length>1&&!/  /.test(e))return e;for(var r=t,n="",i=0;i<e.length;i++){var o=e.charAt(i);" "!=o||!r||i!=e.length-1&&32!=e.charCodeAt(i+1)||(o=" "),n+=o,r=" "==o}return n}function ft(e,t){return function(r,n,i,o,l,s,a){i=i?i+" cm-force-border":"cm-force-border";for(var u=r.pos,c=u+n.length;;){for(var f=void 0,h=0;h<t.length&&!((f=t[h]).to>u&&f.from<=u);h++);if(f.to>=c)return e(r,n,i,o,l,s,a);e(r,n.slice(0,f.to-u),i,o,null,s,a),o=null,n=n.slice(f.to-u),u=f.to}}}function ht(e,t,r,n){var i=!n&&r.widgetNode;i&&e.map.push(e.pos,e.pos+t,i),!n&&e.cm.display.input.needsContentAttribute&&(i||(i=e.content.appendChild(document.createElement("span"))),i.setAttribute("cm-marker",r.id)),i&&(e.cm.display.input.setUneditable(i),e.content.appendChild(i)),e.pos+=t,e.trailingSpace=!1}function dt(e,t,r){var n=e.markedSpans,i=e.text,o=0;if(n)for(var l,s,a,u,c,f,h,d=i.length,p=0,g=1,v="",m=0;;){if(m==p){a=u=c=f=s="",h=null,m=1/0;for(var y=[],b=void 0,w=0;w<n.length;++w){var x=n[w],C=x.marker;"bookmark"==C.type&&x.from==p&&C.widgetNode?y.push(C):x.from<=p&&(null==x.to||x.to>p||C.collapsed&&x.to==p&&x.from==p)?(null!=x.to&&x.to!=p&&m>x.to&&(m=x.to,u=""),C.className&&(a+=" "+C.className),C.css&&(s=(s?s+";":"")+C.css),C.startStyle&&x.from==p&&(c+=" "+C.startStyle),C.endStyle&&x.to==m&&(b||(b=[])).push(C.endStyle,x.to),C.title&&!f&&(f=C.title),C.collapsed&&(!h||le(h.marker,C)<0)&&(h=x)):x.from>p&&m>x.from&&(m=x.from)}if(b)for(var S=0;S<b.length;S+=2)b[S+1]==m&&(u+=" "+b[S]);if(!h||h.from==p)for(var L=0;L<y.length;++L)ht(t,0,y[L]);if(h&&(h.from||0)==p){if(ht(t,(null==h.to?d+1:h.to)-p,h.marker,null==h.from),null==h.to)return;h.to==p&&(h=!1)}}if(p>=d)break;for(var k=Math.min(d,m);;){if(v){var T=p+v.length;if(!h){var M=T>k?v.slice(0,k-p):v;t.addToken(t,M,l?l+a:a,c,p+M.length==m?u:"",f,s)}if(T>=k){v=v.slice(k-p),p=k;break}p=T,c=""}v=i.slice(o,o=r[g++]),l=lt(r[g++],t.cm.options)}}else for(var N=1;N<r.length;N+=2)t.addToken(t,i.slice(o,o=r[N]),lt(r[N+1],t.cm.options))}function pt(e,t,r){this.line=t,this.rest=de(t),this.size=this.rest?W(g(this.rest))-r+1:1,this.node=this.text=null,this.hidden=ve(e,t)}function gt(e,t,r){for(var n,i=[],o=t;o<r;o=n){var l=new pt(e.doc,M(e.doc,o),o);n=o+l.size,i.push(l)}return i}function vt(e){gs?gs.ops.push(e):e.ownsGroup=gs={ops:[e],delayedCallbacks:[]}}function mt(e){var t=e.delayedCallbacks,r=0;do{for(;r<t.length;r++)t[r].call(null);for(var n=0;n<e.ops.length;n++){var i=e.ops[n];if(i.cursorActivityHandlers)for(;i.cursorActivityCalled<i.cursorActivityHandlers.length;)i.cursorActivityHandlers[i.cursorActivityCalled++].call(null,i.cm)}}while(r<t.length)}function yt(e,t){var r=e.ownsGroup;if(r)try{mt(r)}finally{gs=null,t(r)}}function bt(e,t){var r=Le(e,t);if(r.length){var n,i=Array.prototype.slice.call(arguments,2);gs?n=gs.delayedCallbacks:vs?n=vs:(n=vs=[],setTimeout(wt,0));for(var o=0;o<r.length;++o)!function(e){n.push(function(){return r[e].apply(null,i)})}(o)}}function wt(){var e=vs;vs=null;for(var t=0;t<e.length;++t)e[t]()}function xt(e,t,r,n){for(var i=0;i<t.changes.length;i++){var o=t.changes[i];"text"==o?kt(e,t):"gutter"==o?Mt(e,t,r,n):"class"==o?Tt(e,t):"widget"==o&&Nt(e,t,n)}t.changes=null}function Ct(e){return e.node==e.text&&(e.node=n("div",null,null,"position: relative"),e.text.parentNode&&e.text.parentNode.replaceChild(e.node,e.text),e.node.appendChild(e.text),gl&&vl<8&&(e.node.style.zIndex=2)),e.node}function St(e,t){var r=t.bgClass?t.bgClass+" "+(t.line.bgClass||""):t.line.bgClass;if(r&&(r+=" CodeMirror-linebackground"),t.background)r?t.background.className=r:(t.background.parentNode.removeChild(t.background),t.background=null);else if(r){var i=Ct(t);t.background=i.insertBefore(n("div",null,r),i.firstChild),e.display.input.setUneditable(t.background)}}function Lt(e,t){var r=e.display.externalMeasured;return r&&r.line==t.line?(e.display.externalMeasured=null,t.measure=r.measure,r.built):st(e,t)}function kt(e,t){var r=t.text.className,n=Lt(e,t);t.text==t.node&&(t.node=n.pre),t.text.parentNode.replaceChild(n.pre,t.text),t.text=n.pre,n.bgClass!=t.bgClass||n.textClass!=t.textClass?(t.bgClass=n.bgClass,t.textClass=n.textClass,Tt(e,t)):r&&(t.text.className=r)}function Tt(e,t){St(e,t),t.line.wrapClass?Ct(t).className=t.line.wrapClass:t.node!=t.text&&(t.node.className="");var r=t.textClass?t.textClass+" "+(t.line.textClass||""):t.line.textClass;t.text.className=r||""}function Mt(e,t,r,i){if(t.gutter&&(t.node.removeChild(t.gutter),t.gutter=null),t.gutterBackground&&(t.node.removeChild(t.gutterBackground),t.gutterBackground=null),t.line.gutterClass){var o=Ct(t);t.gutterBackground=n("div",null,"CodeMirror-gutter-background "+t.line.gutterClass,"left: "+(e.options.fixedGutter?i.fixedPos:-i.gutterTotalWidth)+"px; width: "+i.gutterTotalWidth+"px"),e.display.input.setUneditable(t.gutterBackground),o.insertBefore(t.gutterBackground,t.text)}var l=t.line.gutterMarkers;if(e.options.lineNumbers||l){var s=Ct(t),a=t.gutter=n("div",null,"CodeMirror-gutter-wrapper","left: "+(e.options.fixedGutter?i.fixedPos:-i.gutterTotalWidth)+"px");if(e.display.input.setUneditable(a),s.insertBefore(a,t.text),t.line.gutterClass&&(a.className+=" "+t.line.gutterClass),!e.options.lineNumbers||l&&l["CodeMirror-linenumbers"]||(t.lineNumber=a.appendChild(n("div",F(e.options,r),"CodeMirror-linenumber CodeMirror-gutter-elt","left: "+i.gutterLeft["CodeMirror-linenumbers"]+"px; width: "+e.display.lineNumInnerWidth+"px"))),l)for(var u=0;u<e.options.gutters.length;++u){var c=e.options.gutters[u],f=l.hasOwnProperty(c)&&l[c];f&&a.appendChild(n("div",[f],"CodeMirror-gutter-elt","left: "+i.gutterLeft[c]+"px; width: "+i.gutterWidth[c]+"px"))}}}function Nt(e,t,r){t.alignable&&(t.alignable=null);for(var n=t.node.firstChild,i=void 0;n;n=i)i=n.nextSibling,"CodeMirror-linewidget"==n.className&&t.node.removeChild(n);At(e,t,r)}function Ot(e,t,r,n){var i=Lt(e,t);return t.text=t.node=i.pre,i.bgClass&&(t.bgClass=i.bgClass),i.textClass&&(t.textClass=i.textClass),Tt(e,t),Mt(e,t,r,n),At(e,t,n),t.node}function At(e,t,r){if(Wt(e,t.line,t,r,!0),t.rest)for(var n=0;n<t.rest.length;n++)Wt(e,t.rest[n],t,r,!1)}function Wt(e,t,r,i,o){if(t.widgets)for(var l=Ct(r),s=0,a=t.widgets;s<a.length;++s){var u=a[s],c=n("div",[u.node],"CodeMirror-linewidget");u.handleMouseEvents||c.setAttribute("cm-ignore-events","true"),Dt(u,c,r,i),e.display.input.setUneditable(c),o&&u.above?l.insertBefore(c,r.gutter||r.text):l.appendChild(c),bt(u,"redraw")}}function Dt(e,t,r,n){if(e.noHScroll){(r.alignable||(r.alignable=[])).push(t);var i=n.wrapperWidth;t.style.left=n.fixedPos+"px",e.coverGutter||(i-=n.gutterTotalWidth,t.style.paddingLeft=n.gutterTotalWidth+"px"),t.style.width=i+"px"}e.coverGutter&&(t.style.zIndex=5,t.style.position="relative",e.noHScroll||(t.style.marginLeft=-n.gutterTotalWidth+"px"))}function Ht(e){if(null!=e.height)return e.height;var t=e.doc.cm;if(!t)return 0;if(!o(document.body,e.node)){var i="position: relative;";e.coverGutter&&(i+="margin-left: -"+t.display.gutters.offsetWidth+"px;"),e.noHScroll&&(i+="width: "+t.display.wrapper.clientWidth+"px;"),r(t.display.measure,n("div",[e.node],null,i))}return e.height=e.node.parentNode.offsetHeight}function Ft(e,t){for(var r=Ee(t);r!=e.wrapper;r=r.parentNode)if(!r||1==r.nodeType&&"true"==r.getAttribute("cm-ignore-events")||r.parentNode==e.sizer&&r!=e.mover)return!0}function Et(e){return e.lineSpace.offsetTop}function Pt(e){return e.mover.offsetHeight-e.lineSpace.offsetHeight}function It(e){if(e.cachedPaddingH)return e.cachedPaddingH;var t=r(e.measure,n("pre","x")),i=window.getComputedStyle?window.getComputedStyle(t):t.currentStyle,o={left:parseInt(i.paddingLeft),right:parseInt(i.paddingRight)};return isNaN(o.left)||isNaN(o.right)||(e.cachedPaddingH=o),o}function zt(e){return Rl-e.display.nativeBarWidth}function Rt(e){return e.display.scroller.clientWidth-zt(e)-e.display.barWidth}function Bt(e){return e.display.scroller.clientHeight-zt(e)-e.display.barHeight}function Gt(e,t,r){var n=e.options.lineWrapping,i=n&&Rt(e);if(!t.measure.heights||n&&t.measure.width!=i){var o=t.measure.heights=[];if(n){t.measure.width=i;for(var l=t.text.firstChild.getClientRects(),s=0;s<l.length-1;s++){var a=l[s],u=l[s+1];Math.abs(a.bottom-u.bottom)>2&&o.push((a.bottom+u.top)/2-r.top)}}o.push(r.bottom-r.top)}}function Ut(e,t,r){if(e.line==t)return{map:e.measure.map,cache:e.measure.cache};for(var n=0;n<e.rest.length;n++)if(e.rest[n]==t)return{map:e.measure.maps[n],cache:e.measure.caches[n]};for(var i=0;i<e.rest.length;i++)if(W(e.rest[i])>r)return{map:e.measure.maps[i],cache:e.measure.caches[i],before:!0}}function Vt(e,t){var n=W(t=fe(t)),i=e.display.externalMeasured=new pt(e.doc,t,n);i.lineN=n;var o=i.built=st(e,i);return i.text=o.pre,r(e.display.lineMeasure,o.pre),i}function Kt(e,t,r,n){return Yt(e,Xt(e,t),r,n)}function jt(e,t){if(t>=e.display.viewFrom&&t<e.display.viewTo)return e.display.view[Lr(e,t)];var r=e.display.externalMeasured;return r&&t>=r.lineN&&t<r.lineN+r.size?r:void 0}function Xt(e,t){var r=W(t),n=jt(e,r);n&&!n.text?n=null:n&&n.changes&&(xt(e,n,r,br(e)),e.curOp.forceUpdate=!0),n||(n=Vt(e,t));var i=Ut(n,t,r);return{line:t,view:n,rect:null,map:i.map,cache:i.cache,before:i.before,hasHeights:!1}}function Yt(e,t,r,n,i){t.before&&(r=-1);var o,l=r+(n||"");return t.cache.hasOwnProperty(l)?o=t.cache[l]:(t.rect||(t.rect=t.view.text.getBoundingClientRect()),t.hasHeights||(Gt(e,t.view,t.rect),t.hasHeights=!0),(o=qt(e,t,r,n)).bogus||(t.cache[l]=o)),{left:o.left,right:o.right,top:i?o.rtop:o.top,bottom:i?o.rbottom:o.bottom}}function _t(e,t,r){for(var n,i,o,l,s,a,u=0;u<e.length;u+=3)if(s=e[u],a=e[u+1],t<s?(i=0,o=1,l="left"):t<a?o=(i=t-s)+1:(u==e.length-3||t==a&&e[u+3]>t)&&(i=(o=a-s)-1,t>=a&&(l="right")),null!=i){if(n=e[u+2],s==a&&r==(n.insertLeft?"left":"right")&&(l=r),"left"==r&&0==i)for(;u&&e[u-2]==e[u-3]&&e[u-1].insertLeft;)n=e[2+(u-=3)],l="left";if("right"==r&&i==a-s)for(;u<e.length-3&&e[u+3]==e[u+4]&&!e[u+5].insertLeft;)n=e[(u+=3)+2],l="right";break}return{node:n,start:i,end:o,collapse:l,coverStart:s,coverEnd:a}}function $t(e,t){var r=ms;if("left"==t)for(var n=0;n<e.length&&(r=e[n]).left==r.right;n++);else for(var i=e.length-1;i>=0&&(r=e[i]).left==r.right;i--);return r}function qt(e,t,r,n){var i,o=_t(t.map,r,n),l=o.node,s=o.start,a=o.end,u=o.collapse;if(3==l.nodeType){for(var c=0;c<4;c++){for(;s&&S(t.line.text.charAt(o.coverStart+s));)--s;for(;o.coverStart+a<o.coverEnd&&S(t.line.text.charAt(o.coverStart+a));)++a;if((i=gl&&vl<9&&0==s&&a==o.coverEnd-o.coverStart?l.parentNode.getBoundingClientRect():$t(Wl(l,s,a).getClientRects(),n)).left||i.right||0==s)break;a=s,s-=1,u="right"}gl&&vl<11&&(i=Zt(e.display.measure,i))}else{s>0&&(u=n="right");var f;i=e.options.lineWrapping&&(f=l.getClientRects()).length>1?f["right"==n?f.length-1:0]:l.getBoundingClientRect()}if(gl&&vl<9&&!s&&(!i||!i.left&&!i.right)){var h=l.parentNode.getClientRects()[0];i=h?{left:h.left,right:h.left+yr(e.display),top:h.top,bottom:h.bottom}:ms}for(var d=i.top-t.rect.top,p=i.bottom-t.rect.top,g=(d+p)/2,v=t.view.measure.heights,m=0;m<v.length-1&&!(g<v[m]);m++);var y=m?v[m-1]:0,b=v[m],w={left:("right"==u?i.right:i.left)-t.rect.left,right:("left"==u?i.left:i.right)-t.rect.left,top:y,bottom:b};return i.left||i.right||(w.bogus=!0),e.options.singleCursorHeightPerLine||(w.rtop=d,w.rbottom=p),w}function Zt(e,t){if(!window.screen||null==screen.logicalXDPI||screen.logicalXDPI==screen.deviceXDPI||!Re(e))return t;var r=screen.logicalXDPI/screen.deviceXDPI,n=screen.logicalYDPI/screen.deviceYDPI;return{left:t.left*r,right:t.right*r,top:t.top*n,bottom:t.bottom*n}}function Qt(e){if(e.measure&&(e.measure.cache={},e.measure.heights=null,e.rest))for(var t=0;t<e.rest.length;t++)e.measure.caches[t]={}}function Jt(e){e.display.externalMeasure=null,t(e.display.lineMeasure);for(var r=0;r<e.display.view.length;r++)Qt(e.display.view[r])}function er(e){Jt(e),e.display.cachedCharWidth=e.display.cachedTextHeight=e.display.cachedPaddingH=null,e.options.lineWrapping||(e.display.maxLineChanged=!0),e.display.lineNumChars=null}function tr(){return bl&&kl?-(document.body.getBoundingClientRect().left-parseInt(getComputedStyle(document.body).marginLeft)):window.pageXOffset||(document.documentElement||document.body).scrollLeft}function rr(){return bl&&kl?-(document.body.getBoundingClientRect().top-parseInt(getComputedStyle(document.body).marginTop)):window.pageYOffset||(document.documentElement||document.body).scrollTop}function nr(e){var t=0;if(e.widgets)for(var r=0;r<e.widgets.length;++r)e.widgets[r].above&&(t+=Ht(e.widgets[r]));return t}function ir(e,t,r,n,i){if(!i){var o=nr(t);r.top+=o,r.bottom+=o}if("line"==n)return r;n||(n="local");var l=ye(t);if("local"==n?l+=Et(e.display):l-=e.display.viewOffset,"page"==n||"window"==n){var s=e.display.lineSpace.getBoundingClientRect();l+=s.top+("window"==n?0:rr());var a=s.left+("window"==n?0:tr());r.left+=a,r.right+=a}return r.top+=l,r.bottom+=l,r}function or(e,t,r){if("div"==r)return t;var n=t.left,i=t.top;if("page"==r)n-=tr(),i-=rr();else if("local"==r||!r){var o=e.display.sizer.getBoundingClientRect();n+=o.left,i+=o.top}var l=e.display.lineSpace.getBoundingClientRect();return{left:n-l.left,top:i-l.top}}function lr(e,t,r,n,i){return n||(n=M(e.doc,t.line)),ir(e,n,Kt(e,n,t.ch,i),r)}function sr(e,t,r,n,i,o){function l(t,l){var s=Yt(e,i,t,l?"right":"left",o);return l?s.left=s.right:s.right=s.left,ir(e,n,s,r)}function s(e,t,r){var n=1==a[t].level;return l(r?e-1:e,n!=r)}n=n||M(e.doc,t.line),i||(i=Xt(e,n));var a=Se(n,e.doc.direction),u=t.ch,c=t.sticky;if(u>=n.text.length?(u=n.text.length,c="before"):u<=0&&(u=0,c="after"),!a)return l("before"==c?u-1:u,"before"==c);var f=Ce(a,u,c),h=$l,d=s(u,f,"before"==c);return null!=h&&(d.other=s(u,h,"before"!=c)),d}function ar(e,t){var r=0;t=U(e.doc,t),e.options.lineWrapping||(r=yr(e.display)*t.ch);var n=M(e.doc,t.line),i=ye(n)+Et(e.display);return{left:r,right:r,top:i,bottom:i+n.height}}function ur(e,t,r,n,i){var o=E(e,t,r);return o.xRel=i,n&&(o.outside=!0),o}function cr(e,t,r){var n=e.doc;if((r+=e.display.viewOffset)<0)return ur(n.first,0,null,!0,-1);var i=D(n,r),o=n.first+n.size-1;if(i>o)return ur(n.first+n.size-1,M(n,o).text.length,null,!0,1);t<0&&(t=0);for(var l=M(n,i);;){var s=pr(e,l,i,t,r),a=ue(l),u=a&&a.find(0,!0);if(!a||!(s.ch>u.from.ch||s.ch==u.from.ch&&s.xRel>0))return s;i=W(l=u.to.line)}}function fr(e,t,r,n){n-=nr(t);var i=t.text.length,o=k(function(t){return Yt(e,r,t-1).bottom<=n},i,0);return i=k(function(t){return Yt(e,r,t).top>n},o,i),{begin:o,end:i}}function hr(e,t,r,n){return r||(r=Xt(e,t)),fr(e,t,r,ir(e,t,Yt(e,r,n),"line").top)}function dr(e,t,r,n){return!(e.bottom<=r)&&(e.top>r||(n?e.left:e.right)>t)}function pr(e,t,r,n,i){i-=ye(t);var o=Xt(e,t),l=nr(t),s=0,a=t.text.length,u=!0,c=Se(t,e.doc.direction);if(c){var f=(e.options.lineWrapping?vr:gr)(e,t,r,o,c,n,i);s=(u=1!=f.level)?f.from:f.to-1,a=u?f.to:f.from-1}var h,d,p=null,g=null,v=k(function(t){var r=Yt(e,o,t);return r.top+=l,r.bottom+=l,!!dr(r,n,i,!1)&&(r.top<=i&&r.left<=n&&(p=t,g=r),!0)},s,a),m=!1;if(g){var y=n-g.left<g.right-n,b=y==u;v=p+(b?0:1),d=b?"after":"before",h=y?g.left:g.right}else{u||v!=a&&v!=s||v++,d=0==v?"after":v==t.text.length?"before":Yt(e,o,v-(u?1:0)).bottom+l<=i==u?"after":"before";var w=sr(e,E(r,v,d),"line",t,o);h=w.left,m=i<w.top||i>=w.bottom}return v=L(t.text,v,1),ur(r,v,d,m,n-h)}function gr(e,t,r,n,i,o,l){var s=k(function(s){var a=i[s],u=1!=a.level;return dr(sr(e,E(r,u?a.to:a.from,u?"before":"after"),"line",t,n),o,l,!0)},0,i.length-1),a=i[s];if(s>0){var u=1!=a.level,c=sr(e,E(r,u?a.from:a.to,u?"after":"before"),"line",t,n);dr(c,o,l,!0)&&c.top>l&&(a=i[s-1])}return a}function vr(e,t,r,n,i,o,l){for(var s=fr(e,t,n,l),a=s.begin,u=s.end,c=null,f=null,h=0;h<i.length;h++){var d=i[h];if(!(d.from>=u||d.to<=a)){var p=Yt(e,n,1!=d.level?Math.min(u,d.to)-1:Math.max(a,d.from)).right,g=p<o?o-p+1e9:p-o;(!c||f>g)&&(c=d,f=g)}}return c||(c=i[i.length-1]),c.from<a&&(c={from:a,to:c.to,level:c.level}),c.to>u&&(c={from:c.from,to:u,level:c.level}),c}function mr(e){if(null!=e.cachedTextHeight)return e.cachedTextHeight;if(null==hs){hs=n("pre");for(var i=0;i<49;++i)hs.appendChild(document.createTextNode("x")),hs.appendChild(n("br"));hs.appendChild(document.createTextNode("x"))}r(e.measure,hs);var o=hs.offsetHeight/50;return o>3&&(e.cachedTextHeight=o),t(e.measure),o||1}function yr(e){if(null!=e.cachedCharWidth)return e.cachedCharWidth;var t=n("span","xxxxxxxxxx"),i=n("pre",[t]);r(e.measure,i);var o=t.getBoundingClientRect(),l=(o.right-o.left)/10;return l>2&&(e.cachedCharWidth=l),l||10}function br(e){for(var t=e.display,r={},n={},i=t.gutters.clientLeft,o=t.gutters.firstChild,l=0;o;o=o.nextSibling,++l)r[e.options.gutters[l]]=o.offsetLeft+o.clientLeft+i,n[e.options.gutters[l]]=o.clientWidth;return{fixedPos:wr(t),gutterTotalWidth:t.gutters.offsetWidth,gutterLeft:r,gutterWidth:n,wrapperWidth:t.wrapper.clientWidth}}function wr(e){return e.scroller.getBoundingClientRect().left-e.sizer.getBoundingClientRect().left}function xr(e){var t=mr(e.display),r=e.options.lineWrapping,n=r&&Math.max(5,e.display.scroller.clientWidth/yr(e.display)-3);return function(i){if(ve(e.doc,i))return 0;var o=0;if(i.widgets)for(var l=0;l<i.widgets.length;l++)i.widgets[l].height&&(o+=i.widgets[l].height);return r?o+(Math.ceil(i.text.length/n)||1)*t:o+t}}function Cr(e){var t=e.doc,r=xr(e);t.iter(function(e){var t=r(e);t!=e.height&&A(e,t)})}function Sr(e,t,r,n){var i=e.display;if(!r&&"true"==Ee(t).getAttribute("cm-not-content"))return null;var o,l,s=i.lineSpace.getBoundingClientRect();try{o=t.clientX-s.left,l=t.clientY-s.top}catch(t){return null}var a,u=cr(e,o,l);if(n&&1==u.xRel&&(a=M(e.doc,u.line).text).length==u.ch){var c=f(a,a.length,e.options.tabSize)-a.length;u=E(u.line,Math.max(0,Math.round((o-It(e.display).left)/yr(e.display))-c))}return u}function Lr(e,t){if(t>=e.display.viewTo)return null;if((t-=e.display.viewFrom)<0)return null;for(var r=e.display.view,n=0;n<r.length;n++)if((t-=r[n].size)<0)return n}function kr(e){e.display.input.showSelection(e.display.input.prepareSelection())}function Tr(e,t){void 0===t&&(t=!0);for(var r=e.doc,n={},i=n.cursors=document.createDocumentFragment(),o=n.selection=document.createDocumentFragment(),l=0;l<r.sel.ranges.length;l++)if(t||l!=r.sel.primIndex){var s=r.sel.ranges[l];if(!(s.from().line>=e.display.viewTo||s.to().line<e.display.viewFrom)){var a=s.empty();(a||e.options.showCursorWhenSelecting)&&Mr(e,s.head,i),a||Or(e,s,o)}}return n}function Mr(e,t,r){var i=sr(e,t,"div",null,null,!e.options.singleCursorHeightPerLine),o=r.appendChild(n("div"," ","CodeMirror-cursor"));if(o.style.left=i.left+"px",o.style.top=i.top+"px",o.style.height=Math.max(0,i.bottom-i.top)*e.options.cursorHeight+"px",i.other){var l=r.appendChild(n("div"," ","CodeMirror-cursor CodeMirror-secondarycursor"));l.style.display="",l.style.left=i.other.left+"px",l.style.top=i.other.top+"px",l.style.height=.85*(i.other.bottom-i.other.top)+"px"}}function Nr(e,t){return e.top-t.top||e.left-t.left}function Or(e,t,r){function i(e,t,r,i){t<0&&(t=0),t=Math.round(t),i=Math.round(i),a.appendChild(n("div",null,"CodeMirror-selected","position: absolute; left: "+e+"px;\n                             top: "+t+"px; width: "+(null==r?f-e:r)+"px;\n                             height: "+(i-t)+"px"))}function o(t,r,n){function o(r,n){return lr(e,E(t,r),"div",u,n)}var l,a,u=M(s,t),h=u.text.length,d=Se(u,s.direction);return xe(d,r||0,null==n?h:n,function(t,s,p,g){var v=o(t,"ltr"==p?"left":"right"),m=o(s-1,"ltr"==p?"right":"left");if("ltr"==p){var y=null==r&&0==t?c:v.left,b=null==n&&s==h?f:m.right;m.top-v.top<=3?i(y,m.top,b-y,m.bottom):(i(y,v.top,null,v.bottom),v.bottom<m.top&&i(c,v.bottom,null,m.top),i(c,m.top,m.right,m.bottom))}else if(t<s){var w=null==r&&0==t?f:v.right,x=null==n&&s==h?c:m.left;if(m.top-v.top<=3)i(x,m.top,w-x,m.bottom);else{var C=c;if(g){var S=hr(e,u,null,t).end;C=o(S-(/\s/.test(u.text.charAt(S-1))?2:1),"left").left}i(C,v.top,w-C,v.bottom),v.bottom<m.top&&i(c,v.bottom,null,m.top);var L=null;d.length,L=o(hr(e,u,null,s).begin,"right").right-x,i(x,m.top,L,m.bottom)}}(!l||Nr(v,l)<0)&&(l=v),Nr(m,l)<0&&(l=m),(!a||Nr(v,a)<0)&&(a=v),Nr(m,a)<0&&(a=m)}),{start:l,end:a}}var l=e.display,s=e.doc,a=document.createDocumentFragment(),u=It(e.display),c=u.left,f=Math.max(l.sizerWidth,Rt(e)-l.sizer.offsetLeft)-u.right,h=t.from(),d=t.to();if(h.line==d.line)o(h.line,h.ch,d.ch);else{var p=M(s,h.line),g=M(s,d.line),v=fe(p)==fe(g),m=o(h.line,h.ch,v?p.text.length+1:null).end,y=o(d.line,v?0:null,d.ch).start;v&&(m.top<y.top-2?(i(m.right,m.top,null,m.bottom),i(c,y.top,y.left,y.bottom)):i(m.right,m.top,y.left-m.right,m.bottom)),m.bottom<y.top&&i(c,m.bottom,null,y.top)}r.appendChild(a)}function Ar(e){if(e.state.focused){var t=e.display;clearInterval(t.blinker);var r=!0;t.cursorDiv.style.visibility="",e.options.cursorBlinkRate>0?t.blinker=setInterval(function(){return t.cursorDiv.style.visibility=(r=!r)?"":"hidden"},e.options.cursorBlinkRate):e.options.cursorBlinkRate<0&&(t.cursorDiv.style.visibility="hidden")}}function Wr(e){e.state.focused||(e.display.input.focus(),Hr(e))}function Dr(e){e.state.delayingBlurEvent=!0,setTimeout(function(){e.state.delayingBlurEvent&&(e.state.delayingBlurEvent=!1,Fr(e))},100)}function Hr(e,t){e.state.delayingBlurEvent&&(e.state.delayingBlurEvent=!1),"nocursor"!=e.options.readOnly&&(e.state.focused||(Te(e,"focus",e,t),e.state.focused=!0,s(e.display.wrapper,"CodeMirror-focused"),e.curOp||e.display.selForContextMenu==e.doc.sel||(e.display.input.reset(),ml&&setTimeout(function(){return e.display.input.reset(!0)},20)),e.display.input.receivedFocus()),Ar(e))}function Fr(e,t){e.state.delayingBlurEvent||(e.state.focused&&(Te(e,"blur",e,t),e.state.focused=!1,Fl(e.display.wrapper,"CodeMirror-focused")),clearInterval(e.display.blinker),setTimeout(function(){e.state.focused||(e.display.shift=!1)},150))}function Er(e){for(var t=e.display,r=t.lineDiv.offsetTop,n=0;n<t.view.length;n++){var i=t.view[n],o=void 0;if(!i.hidden){if(gl&&vl<8){var l=i.node.offsetTop+i.node.offsetHeight;o=l-r,r=l}else{var s=i.node.getBoundingClientRect();o=s.bottom-s.top}var a=i.line.height-o;if(o<2&&(o=mr(t)),(a>.005||a<-.005)&&(A(i.line,o),Pr(i.line),i.rest))for(var u=0;u<i.rest.length;u++)Pr(i.rest[u])}}}function Pr(e){if(e.widgets)for(var t=0;t<e.widgets.length;++t)e.widgets[t].height=e.widgets[t].node.parentNode.offsetHeight}function Ir(e,t,r){var n=r&&null!=r.top?Math.max(0,r.top):e.scroller.scrollTop;n=Math.floor(n-Et(e));var i=r&&null!=r.bottom?r.bottom:n+e.wrapper.clientHeight,o=D(t,n),l=D(t,i);if(r&&r.ensure){var s=r.ensure.from.line,a=r.ensure.to.line;s<o?(o=s,l=D(t,ye(M(t,s))+e.wrapper.clientHeight)):Math.min(a,t.lastLine())>=l&&(o=D(t,ye(M(t,a))-e.wrapper.clientHeight),l=a)}return{from:o,to:Math.max(l,o+1)}}function zr(e){var t=e.display,r=t.view;if(t.alignWidgets||t.gutters.firstChild&&e.options.fixedGutter){for(var n=wr(t)-t.scroller.scrollLeft+e.doc.scrollLeft,i=t.gutters.offsetWidth,o=n+"px",l=0;l<r.length;l++)if(!r[l].hidden){e.options.fixedGutter&&(r[l].gutter&&(r[l].gutter.style.left=o),r[l].gutterBackground&&(r[l].gutterBackground.style.left=o));var s=r[l].alignable;if(s)for(var a=0;a<s.length;a++)s[a].style.left=o}e.options.fixedGutter&&(t.gutters.style.left=n+i+"px")}}function Rr(e){if(!e.options.lineNumbers)return!1;var t=e.doc,r=F(e.options,t.first+t.size-1),i=e.display;if(r.length!=i.lineNumChars){var o=i.measure.appendChild(n("div",[n("div",r)],"CodeMirror-linenumber CodeMirror-gutter-elt")),l=o.firstChild.offsetWidth,s=o.offsetWidth-l;return i.lineGutter.style.width="",i.lineNumInnerWidth=Math.max(l,i.lineGutter.offsetWidth-s)+1,i.lineNumWidth=i.lineNumInnerWidth+s,i.lineNumChars=i.lineNumInnerWidth?r.length:-1,i.lineGutter.style.width=i.lineNumWidth+"px",Wn(e),!0}return!1}function Br(e,t){if(!Me(e,"scrollCursorIntoView")){var r=e.display,i=r.sizer.getBoundingClientRect(),o=null;if(t.top+i.top<0?o=!0:t.bottom+i.top>(window.innerHeight||document.documentElement.clientHeight)&&(o=!1),null!=o&&!Sl){var l=n("div","​",null,"position: absolute;\n                         top: "+(t.top-r.viewOffset-Et(e.display))+"px;\n                         height: "+(t.bottom-t.top+zt(e)+r.barHeight)+"px;\n                         left: "+t.left+"px; width: "+Math.max(2,t.right-t.left)+"px;");e.display.lineSpace.appendChild(l),l.scrollIntoView(o),e.display.lineSpace.removeChild(l)}}}function Gr(e,t,r,n){null==n&&(n=0);var i;e.options.lineWrapping||t!=r||(r="before"==(t=t.ch?E(t.line,"before"==t.sticky?t.ch-1:t.ch,"after"):t).sticky?E(t.line,t.ch+1,"before"):t);for(var o=0;o<5;o++){var l=!1,s=sr(e,t),a=r&&r!=t?sr(e,r):s,u=Vr(e,i={left:Math.min(s.left,a.left),top:Math.min(s.top,a.top)-n,right:Math.max(s.left,a.left),bottom:Math.max(s.bottom,a.bottom)+n}),c=e.doc.scrollTop,f=e.doc.scrollLeft;if(null!=u.scrollTop&&(qr(e,u.scrollTop),Math.abs(e.doc.scrollTop-c)>1&&(l=!0)),null!=u.scrollLeft&&(Qr(e,u.scrollLeft),Math.abs(e.doc.scrollLeft-f)>1&&(l=!0)),!l)break}return i}function Ur(e,t){var r=Vr(e,t);null!=r.scrollTop&&qr(e,r.scrollTop),null!=r.scrollLeft&&Qr(e,r.scrollLeft)}function Vr(e,t){var r=e.display,n=mr(e.display);t.top<0&&(t.top=0);var i=e.curOp&&null!=e.curOp.scrollTop?e.curOp.scrollTop:r.scroller.scrollTop,o=Bt(e),l={};t.bottom-t.top>o&&(t.bottom=t.top+o);var s=e.doc.height+Pt(r),a=t.top<n,u=t.bottom>s-n;if(t.top<i)l.scrollTop=a?0:t.top;else if(t.bottom>i+o){var c=Math.min(t.top,(u?s:t.bottom)-o);c!=i&&(l.scrollTop=c)}var f=e.curOp&&null!=e.curOp.scrollLeft?e.curOp.scrollLeft:r.scroller.scrollLeft,h=Rt(e)-(e.options.fixedGutter?r.gutters.offsetWidth:0),d=t.right-t.left>h;return d&&(t.right=t.left+h),t.left<10?l.scrollLeft=0:t.left<f?l.scrollLeft=Math.max(0,t.left-(d?0:10)):t.right>h+f-3&&(l.scrollLeft=t.right+(d?0:10)-h),l}function Kr(e,t){null!=t&&(_r(e),e.curOp.scrollTop=(null==e.curOp.scrollTop?e.doc.scrollTop:e.curOp.scrollTop)+t)}function jr(e){_r(e);var t=e.getCursor();e.curOp.scrollToPos={from:t,to:t,margin:e.options.cursorScrollMargin}}function Xr(e,t,r){null==t&&null==r||_r(e),null!=t&&(e.curOp.scrollLeft=t),null!=r&&(e.curOp.scrollTop=r)}function Yr(e,t){_r(e),e.curOp.scrollToPos=t}function _r(e){var t=e.curOp.scrollToPos;t&&(e.curOp.scrollToPos=null,$r(e,ar(e,t.from),ar(e,t.to),t.margin))}function $r(e,t,r,n){var i=Vr(e,{left:Math.min(t.left,r.left),top:Math.min(t.top,r.top)-n,right:Math.max(t.right,r.right),bottom:Math.max(t.bottom,r.bottom)+n});Xr(e,i.scrollLeft,i.scrollTop)}function qr(e,t){Math.abs(e.doc.scrollTop-t)<2||(fl||On(e,{top:t}),Zr(e,t,!0),fl&&On(e),Cn(e,100))}function Zr(e,t,r){t=Math.min(e.display.scroller.scrollHeight-e.display.scroller.clientHeight,t),(e.display.scroller.scrollTop!=t||r)&&(e.doc.scrollTop=t,e.display.scrollbars.setScrollTop(t),e.display.scroller.scrollTop!=t&&(e.display.scroller.scrollTop=t))}function Qr(e,t,r,n){t=Math.min(t,e.display.scroller.scrollWidth-e.display.scroller.clientWidth),(r?t==e.doc.scrollLeft:Math.abs(e.doc.scrollLeft-t)<2)&&!n||(e.doc.scrollLeft=t,zr(e),e.display.scroller.scrollLeft!=t&&(e.display.scroller.scrollLeft=t),e.display.scrollbars.setScrollLeft(t))}function Jr(e){var t=e.display,r=t.gutters.offsetWidth,n=Math.round(e.doc.height+Pt(e.display));return{clientHeight:t.scroller.clientHeight,viewHeight:t.wrapper.clientHeight,scrollWidth:t.scroller.scrollWidth,clientWidth:t.scroller.clientWidth,viewWidth:t.wrapper.clientWidth,barLeft:e.options.fixedGutter?r:0,docHeight:n,scrollHeight:n+zt(e)+t.barHeight,nativeBarWidth:t.nativeBarWidth,gutterWidth:r}}function en(e,t){t||(t=Jr(e));var r=e.display.barWidth,n=e.display.barHeight;tn(e,t);for(var i=0;i<4&&r!=e.display.barWidth||n!=e.display.barHeight;i++)r!=e.display.barWidth&&e.options.lineWrapping&&Er(e),tn(e,Jr(e)),r=e.display.barWidth,n=e.display.barHeight}function tn(e,t){var r=e.display,n=r.scrollbars.update(t);r.sizer.style.paddingRight=(r.barWidth=n.right)+"px",r.sizer.style.paddingBottom=(r.barHeight=n.bottom)+"px",r.heightForcer.style.borderBottom=n.bottom+"px solid transparent",n.right&&n.bottom?(r.scrollbarFiller.style.display="block",r.scrollbarFiller.style.height=n.bottom+"px",r.scrollbarFiller.style.width=n.right+"px"):r.scrollbarFiller.style.display="",n.bottom&&e.options.coverGutterNextToScrollbar&&e.options.fixedGutter?(r.gutterFiller.style.display="block",r.gutterFiller.style.height=n.bottom+"px",r.gutterFiller.style.width=t.gutterWidth+"px"):r.gutterFiller.style.display=""}function rn(e){e.display.scrollbars&&(e.display.scrollbars.clear(),e.display.scrollbars.addClass&&Fl(e.display.wrapper,e.display.scrollbars.addClass)),e.display.scrollbars=new ws[e.options.scrollbarStyle](function(t){e.display.wrapper.insertBefore(t,e.display.scrollbarFiller),Ql(t,"mousedown",function(){e.state.focused&&setTimeout(function(){return e.display.input.focus()},0)}),t.setAttribute("cm-not-content","true")},function(t,r){"horizontal"==r?Qr(e,t):qr(e,t)},e),e.display.scrollbars.addClass&&s(e.display.wrapper,e.display.scrollbars.addClass)}function nn(e){e.curOp={cm:e,viewChanged:!1,startHeight:e.doc.height,forceUpdate:!1,updateInput:null,typing:!1,changeObjs:null,cursorActivityHandlers:null,cursorActivityCalled:0,selectionChanged:!1,updateMaxLine:!1,scrollLeft:null,scrollTop:null,scrollToPos:null,focus:!1,id:++xs},vt(e.curOp)}function on(e){yt(e.curOp,function(e){for(var t=0;t<e.ops.length;t++)e.ops[t].cm.curOp=null;ln(e)})}function ln(e){for(var t=e.ops,r=0;r<t.length;r++)sn(t[r]);for(var n=0;n<t.length;n++)an(t[n]);for(var i=0;i<t.length;i++)un(t[i]);for(var o=0;o<t.length;o++)cn(t[o]);for(var l=0;l<t.length;l++)fn(t[l])}function sn(e){var t=e.cm,r=t.display;Ln(t),e.updateMaxLine&&we(t),e.mustUpdate=e.viewChanged||e.forceUpdate||null!=e.scrollTop||e.scrollToPos&&(e.scrollToPos.from.line<r.viewFrom||e.scrollToPos.to.line>=r.viewTo)||r.maxLineChanged&&t.options.lineWrapping,e.update=e.mustUpdate&&new Cs(t,e.mustUpdate&&{top:e.scrollTop,ensure:e.scrollToPos},e.forceUpdate)}function an(e){e.updatedDisplay=e.mustUpdate&&Mn(e.cm,e.update)}function un(e){var t=e.cm,r=t.display;e.updatedDisplay&&Er(t),e.barMeasure=Jr(t),r.maxLineChanged&&!t.options.lineWrapping&&(e.adjustWidthTo=Kt(t,r.maxLine,r.maxLine.text.length).left+3,t.display.sizerWidth=e.adjustWidthTo,e.barMeasure.scrollWidth=Math.max(r.scroller.clientWidth,r.sizer.offsetLeft+e.adjustWidthTo+zt(t)+t.display.barWidth),e.maxScrollLeft=Math.max(0,r.sizer.offsetLeft+e.adjustWidthTo-Rt(t))),(e.updatedDisplay||e.selectionChanged)&&(e.preparedSelection=r.input.prepareSelection())}function cn(e){var t=e.cm;null!=e.adjustWidthTo&&(t.display.sizer.style.minWidth=e.adjustWidthTo+"px",e.maxScrollLeft<t.doc.scrollLeft&&Qr(t,Math.min(t.display.scroller.scrollLeft,e.maxScrollLeft),!0),t.display.maxLineChanged=!1);var r=e.focus&&e.focus==l();e.preparedSelection&&t.display.input.showSelection(e.preparedSelection,r),(e.updatedDisplay||e.startHeight!=t.doc.height)&&en(t,e.barMeasure),e.updatedDisplay&&Dn(t,e.barMeasure),e.selectionChanged&&Ar(t),t.state.focused&&e.updateInput&&t.display.input.reset(e.typing),r&&Wr(e.cm)}function fn(e){var t=e.cm,r=t.display,n=t.doc;e.updatedDisplay&&Nn(t,e.update),null==r.wheelStartX||null==e.scrollTop&&null==e.scrollLeft&&!e.scrollToPos||(r.wheelStartX=r.wheelStartY=null),null!=e.scrollTop&&Zr(t,e.scrollTop,e.forceScroll),null!=e.scrollLeft&&Qr(t,e.scrollLeft,!0,!0),e.scrollToPos&&Br(t,Gr(t,U(n,e.scrollToPos.from),U(n,e.scrollToPos.to),e.scrollToPos.margin));var i=e.maybeHiddenMarkers,o=e.maybeUnhiddenMarkers;if(i)for(var l=0;l<i.length;++l)i[l].lines.length||Te(i[l],"hide");if(o)for(var s=0;s<o.length;++s)o[s].lines.length&&Te(o[s],"unhide");r.wrapper.offsetHeight&&(n.scrollTop=t.display.scroller.scrollTop),e.changeObjs&&Te(t,"changes",t,e.changeObjs),e.update&&e.update.finish()}function hn(e,t){if(e.curOp)return t();nn(e);try{return t()}finally{on(e)}}function dn(e,t){return function(){if(e.curOp)return t.apply(e,arguments);nn(e);try{return t.apply(e,arguments)}finally{on(e)}}}function pn(e){return function(){if(this.curOp)return e.apply(this,arguments);nn(this);try{return e.apply(this,arguments)}finally{on(this)}}}function gn(e){return function(){var t=this.cm;if(!t||t.curOp)return e.apply(this,arguments);nn(t);try{return e.apply(this,arguments)}finally{on(t)}}}function vn(e,t,r,n){null==t&&(t=e.doc.first),null==r&&(r=e.doc.first+e.doc.size),n||(n=0);var i=e.display;if(n&&r<i.viewTo&&(null==i.updateLineNumbers||i.updateLineNumbers>t)&&(i.updateLineNumbers=t),e.curOp.viewChanged=!0,t>=i.viewTo)_l&&pe(e.doc,t)<i.viewTo&&yn(e);else if(r<=i.viewFrom)_l&&ge(e.doc,r+n)>i.viewFrom?yn(e):(i.viewFrom+=n,i.viewTo+=n);else if(t<=i.viewFrom&&r>=i.viewTo)yn(e);else if(t<=i.viewFrom){var o=bn(e,r,r+n,1);o?(i.view=i.view.slice(o.index),i.viewFrom=o.lineN,i.viewTo+=n):yn(e)}else if(r>=i.viewTo){var l=bn(e,t,t,-1);l?(i.view=i.view.slice(0,l.index),i.viewTo=l.lineN):yn(e)}else{var s=bn(e,t,t,-1),a=bn(e,r,r+n,1);s&&a?(i.view=i.view.slice(0,s.index).concat(gt(e,s.lineN,a.lineN)).concat(i.view.slice(a.index)),i.viewTo+=n):yn(e)}var u=i.externalMeasured;u&&(r<u.lineN?u.lineN+=n:t<u.lineN+u.size&&(i.externalMeasured=null))}function mn(e,t,r){e.curOp.viewChanged=!0;var n=e.display,i=e.display.externalMeasured;if(i&&t>=i.lineN&&t<i.lineN+i.size&&(n.externalMeasured=null),!(t<n.viewFrom||t>=n.viewTo)){var o=n.view[Lr(e,t)];if(null!=o.node){var l=o.changes||(o.changes=[]);-1==h(l,r)&&l.push(r)}}}function yn(e){e.display.viewFrom=e.display.viewTo=e.doc.first,e.display.view=[],e.display.viewOffset=0}function bn(e,t,r,n){var i,o=Lr(e,t),l=e.display.view;if(!_l||r==e.doc.first+e.doc.size)return{index:o,lineN:r};for(var s=e.display.viewFrom,a=0;a<o;a++)s+=l[a].size;if(s!=t){if(n>0){if(o==l.length-1)return null;i=s+l[o].size-t,o++}else i=s-t;t+=i,r+=i}for(;pe(e.doc,r)!=r;){if(o==(n<0?0:l.length-1))return null;r+=n*l[o-(n<0?1:0)].size,o+=n}return{index:o,lineN:r}}function wn(e,t,r){var n=e.display;0==n.view.length||t>=n.viewTo||r<=n.viewFrom?(n.view=gt(e,t,r),n.viewFrom=t):(n.viewFrom>t?n.view=gt(e,t,n.viewFrom).concat(n.view):n.viewFrom<t&&(n.view=n.view.slice(Lr(e,t))),n.viewFrom=t,n.viewTo<r?n.view=n.view.concat(gt(e,n.viewTo,r)):n.viewTo>r&&(n.view=n.view.slice(0,Lr(e,r)))),n.viewTo=r}function xn(e){for(var t=e.display.view,r=0,n=0;n<t.length;n++){var i=t[n];i.hidden||i.node&&!i.changes||++r}return r}function Cn(e,t){e.doc.highlightFrontier<e.display.viewTo&&e.state.highlight.set(t,u(Sn,e))}function Sn(e){var t=e.doc;if(!(t.highlightFrontier>=e.display.viewTo)){var r=+new Date+e.options.workTime,n=$e(e,t.highlightFrontier),i=[];t.iter(n.line,Math.min(t.first+t.size,e.display.viewTo+500),function(o){if(n.line>=e.display.viewFrom){var l=o.styles,s=o.text.length>e.options.maxHighlightLength?Ke(t.mode,n.state):null,a=Ye(e,o,n,!0);s&&(n.state=s),o.styles=a.styles;var u=o.styleClasses,c=a.classes;c?o.styleClasses=c:u&&(o.styleClasses=null);for(var f=!l||l.length!=o.styles.length||u!=c&&(!u||!c||u.bgClass!=c.bgClass||u.textClass!=c.textClass),h=0;!f&&h<l.length;++h)f=l[h]!=o.styles[h];f&&i.push(n.line),o.stateAfter=n.save(),n.nextLine()}else o.text.length<=e.options.maxHighlightLength&&qe(e,o.text,n),o.stateAfter=n.line%5==0?n.save():null,n.nextLine();if(+new Date>r)return Cn(e,e.options.workDelay),!0}),t.highlightFrontier=n.line,t.modeFrontier=Math.max(t.modeFrontier,n.line),i.length&&hn(e,function(){for(var t=0;t<i.length;t++)mn(e,i[t],"text")})}}function Ln(e){var t=e.display;!t.scrollbarsClipped&&t.scroller.offsetWidth&&(t.nativeBarWidth=t.scroller.offsetWidth-t.scroller.clientWidth,t.heightForcer.style.height=zt(e)+"px",t.sizer.style.marginBottom=-t.nativeBarWidth+"px",t.sizer.style.borderRightWidth=zt(e)+"px",t.scrollbarsClipped=!0)}function kn(e){if(e.hasFocus())return null;var t=l();if(!t||!o(e.display.lineDiv,t))return null;var r={activeElt:t};if(window.getSelection){var n=window.getSelection();n.anchorNode&&n.extend&&o(e.display.lineDiv,n.anchorNode)&&(r.anchorNode=n.anchorNode,r.anchorOffset=n.anchorOffset,r.focusNode=n.focusNode,r.focusOffset=n.focusOffset)}return r}function Tn(e){if(e&&e.activeElt&&e.activeElt!=l()&&(e.activeElt.focus(),e.anchorNode&&o(document.body,e.anchorNode)&&o(document.body,e.focusNode))){var t=window.getSelection(),r=document.createRange();r.setEnd(e.anchorNode,e.anchorOffset),r.collapse(!1),t.removeAllRanges(),t.addRange(r),t.extend(e.focusNode,e.focusOffset)}}function Mn(e,r){var n=e.display,i=e.doc;if(r.editorIsHidden)return yn(e),!1;if(!r.force&&r.visible.from>=n.viewFrom&&r.visible.to<=n.viewTo&&(null==n.updateLineNumbers||n.updateLineNumbers>=n.viewTo)&&n.renderedView==n.view&&0==xn(e))return!1;Rr(e)&&(yn(e),r.dims=br(e));var o=i.first+i.size,l=Math.max(r.visible.from-e.options.viewportMargin,i.first),s=Math.min(o,r.visible.to+e.options.viewportMargin);n.viewFrom<l&&l-n.viewFrom<20&&(l=Math.max(i.first,n.viewFrom)),n.viewTo>s&&n.viewTo-s<20&&(s=Math.min(o,n.viewTo)),_l&&(l=pe(e.doc,l),s=ge(e.doc,s));var a=l!=n.viewFrom||s!=n.viewTo||n.lastWrapHeight!=r.wrapperHeight||n.lastWrapWidth!=r.wrapperWidth;wn(e,l,s),n.viewOffset=ye(M(e.doc,n.viewFrom)),e.display.mover.style.top=n.viewOffset+"px";var u=xn(e);if(!a&&0==u&&!r.force&&n.renderedView==n.view&&(null==n.updateLineNumbers||n.updateLineNumbers>=n.viewTo))return!1;var c=kn(e);return u>4&&(n.lineDiv.style.display="none"),An(e,n.updateLineNumbers,r.dims),u>4&&(n.lineDiv.style.display=""),n.renderedView=n.view,Tn(c),t(n.cursorDiv),t(n.selectionDiv),n.gutters.style.height=n.sizer.style.minHeight=0,a&&(n.lastWrapHeight=r.wrapperHeight,n.lastWrapWidth=r.wrapperWidth,Cn(e,400)),n.updateLineNumbers=null,!0}function Nn(e,t){for(var r=t.viewport,n=!0;(n&&e.options.lineWrapping&&t.oldDisplayWidth!=Rt(e)||(r&&null!=r.top&&(r={top:Math.min(e.doc.height+Pt(e.display)-Bt(e),r.top)}),t.visible=Ir(e.display,e.doc,r),!(t.visible.from>=e.display.viewFrom&&t.visible.to<=e.display.viewTo)))&&Mn(e,t);n=!1){Er(e);var i=Jr(e);kr(e),en(e,i),Dn(e,i),t.force=!1}t.signal(e,"update",e),e.display.viewFrom==e.display.reportedViewFrom&&e.display.viewTo==e.display.reportedViewTo||(t.signal(e,"viewportChange",e,e.display.viewFrom,e.display.viewTo),e.display.reportedViewFrom=e.display.viewFrom,e.display.reportedViewTo=e.display.viewTo)}function On(e,t){var r=new Cs(e,t);if(Mn(e,r)){Er(e),Nn(e,r);var n=Jr(e);kr(e),en(e,n),Dn(e,n),r.finish()}}function An(e,r,n){function i(t){var r=t.nextSibling;return ml&&Ml&&e.display.currentWheelTarget==t?t.style.display="none":t.parentNode.removeChild(t),r}for(var o=e.display,l=e.options.lineNumbers,s=o.lineDiv,a=s.firstChild,u=o.view,c=o.viewFrom,f=0;f<u.length;f++){var d=u[f];if(d.hidden);else if(d.node&&d.node.parentNode==s){for(;a!=d.node;)a=i(a);var p=l&&null!=r&&r<=c&&d.lineNumber;d.changes&&(h(d.changes,"gutter")>-1&&(p=!1),xt(e,d,c,n)),p&&(t(d.lineNumber),d.lineNumber.appendChild(document.createTextNode(F(e.options,c)))),a=d.node.nextSibling}else{var g=Ot(e,d,c,n);s.insertBefore(g,a)}c+=d.size}for(;a;)a=i(a)}function Wn(e){var t=e.display.gutters.offsetWidth;e.display.sizer.style.marginLeft=t+"px"}function Dn(e,t){e.display.sizer.style.minHeight=t.docHeight+"px",e.display.heightForcer.style.top=t.docHeight+"px",e.display.gutters.style.height=t.docHeight+e.display.barHeight+zt(e)+"px"}function Hn(e){var r=e.display.gutters,i=e.options.gutters;t(r);for(var o=0;o<i.length;++o){var l=i[o],s=r.appendChild(n("div",null,"CodeMirror-gutter "+l));"CodeMirror-linenumbers"==l&&(e.display.lineGutter=s,s.style.width=(e.display.lineNumWidth||1)+"px")}r.style.display=o?"":"none",Wn(e)}function Fn(e){var t=h(e.gutters,"CodeMirror-linenumbers");-1==t&&e.lineNumbers?e.gutters=e.gutters.concat(["CodeMirror-linenumbers"]):t>-1&&!e.lineNumbers&&(e.gutters=e.gutters.slice(0),e.gutters.splice(t,1))}function En(e){var t=e.wheelDeltaX,r=e.wheelDeltaY;return null==t&&e.detail&&e.axis==e.HORIZONTAL_AXIS&&(t=e.detail),null==r&&e.detail&&e.axis==e.VERTICAL_AXIS?r=e.detail:null==r&&(r=e.wheelDelta),{x:t,y:r}}function Pn(e){var t=En(e);return t.x*=Ls,t.y*=Ls,t}function In(e,t){var r=En(t),n=r.x,i=r.y,o=e.display,l=o.scroller,s=l.scrollWidth>l.clientWidth,a=l.scrollHeight>l.clientHeight;if(n&&s||i&&a){if(i&&Ml&&ml)e:for(var u=t.target,c=o.view;u!=l;u=u.parentNode)for(var f=0;f<c.length;f++)if(c[f].node==u){e.display.currentWheelTarget=u;break e}if(n&&!fl&&!wl&&null!=Ls)return i&&a&&qr(e,Math.max(0,l.scrollTop+i*Ls)),Qr(e,Math.max(0,l.scrollLeft+n*Ls)),(!i||i&&a)&&We(t),void(o.wheelStartX=null);if(i&&null!=Ls){var h=i*Ls,d=e.doc.scrollTop,p=d+o.wrapper.clientHeight;h<0?d=Math.max(0,d+h-50):p=Math.min(e.doc.height,p+h+50),On(e,{top:d,bottom:p})}Ss<20&&(null==o.wheelStartX?(o.wheelStartX=l.scrollLeft,o.wheelStartY=l.scrollTop,o.wheelDX=n,o.wheelDY=i,setTimeout(function(){if(null!=o.wheelStartX){var e=l.scrollLeft-o.wheelStartX,t=l.scrollTop-o.wheelStartY,r=t&&o.wheelDY&&t/o.wheelDY||e&&o.wheelDX&&e/o.wheelDX;o.wheelStartX=o.wheelStartY=null,r&&(Ls=(Ls*Ss+r)/(Ss+1),++Ss)}},200)):(o.wheelDX+=n,o.wheelDY+=i))}}function zn(e,t){var r=e[t];e.sort(function(e,t){return P(e.from(),t.from())}),t=h(e,r);for(var n=1;n<e.length;n++){var i=e[n],o=e[n-1];if(P(o.to(),i.from())>=0){var l=B(o.from(),i.from()),s=R(o.to(),i.to()),a=o.empty()?i.from()==i.head:o.from()==o.head;n<=t&&--t,e.splice(--n,2,new Ts(a?s:l,a?l:s))}}return new ks(e,t)}function Rn(e,t){return new ks([new Ts(e,t||e)],0)}function Bn(e){return e.text?E(e.from.line+e.text.length-1,g(e.text).length+(1==e.text.length?e.from.ch:0)):e.to}function Gn(e,t){if(P(e,t.from)<0)return e;if(P(e,t.to)<=0)return Bn(t);var r=e.line+t.text.length-(t.to.line-t.from.line)-1,n=e.ch;return e.line==t.to.line&&(n+=Bn(t).ch-t.to.ch),E(r,n)}function Un(e,t){for(var r=[],n=0;n<e.sel.ranges.length;n++){var i=e.sel.ranges[n];r.push(new Ts(Gn(i.anchor,t),Gn(i.head,t)))}return zn(r,e.sel.primIndex)}function Vn(e,t,r){return e.line==t.line?E(r.line,e.ch-t.ch+r.ch):E(r.line+(e.line-t.line),e.ch)}function Kn(e,t,r){for(var n=[],i=E(e.first,0),o=i,l=0;l<t.length;l++){var s=t[l],a=Vn(s.from,i,o),u=Vn(Bn(s),i,o);if(i=s.to,o=u,"around"==r){var c=e.sel.ranges[l],f=P(c.head,c.anchor)<0;n[l]=new Ts(f?u:a,f?a:u)}else n[l]=new Ts(a,a)}return new ks(n,e.sel.primIndex)}function jn(e){e.doc.mode=Ue(e.options,e.doc.modeOption),Xn(e)}function Xn(e){e.doc.iter(function(e){e.stateAfter&&(e.stateAfter=null),e.styles&&(e.styles=null)}),e.doc.modeFrontier=e.doc.highlightFrontier=e.doc.first,Cn(e,100),e.state.modeGen++,e.curOp&&vn(e)}function Yn(e,t){return 0==t.from.ch&&0==t.to.ch&&""==g(t.text)&&(!e.cm||e.cm.options.wholeLineUpdateBefore)}function _n(e,t,r,n){function i(e){return r?r[e]:null}function o(e,r,i){it(e,r,i,n),bt(e,"change",e,t)}function l(e,t){for(var r=[],o=e;o<t;++o)r.push(new fs(u[o],i(o),n));return r}var s=t.from,a=t.to,u=t.text,c=M(e,s.line),f=M(e,a.line),h=g(u),d=i(u.length-1),p=a.line-s.line;if(t.full)e.insert(0,l(0,u.length)),e.remove(u.length,e.size-u.length);else if(Yn(e,t)){var v=l(0,u.length-1);o(f,f.text,d),p&&e.remove(s.line,p),v.length&&e.insert(s.line,v)}else if(c==f)if(1==u.length)o(c,c.text.slice(0,s.ch)+h+c.text.slice(a.ch),d);else{var m=l(1,u.length-1);m.push(new fs(h+c.text.slice(a.ch),d,n)),o(c,c.text.slice(0,s.ch)+u[0],i(0)),e.insert(s.line+1,m)}else if(1==u.length)o(c,c.text.slice(0,s.ch)+u[0]+f.text.slice(a.ch),i(0)),e.remove(s.line+1,p);else{o(c,c.text.slice(0,s.ch)+u[0],i(0)),o(f,h+f.text.slice(a.ch),d);var y=l(1,u.length-1);p>1&&e.remove(s.line+1,p-1),e.insert(s.line+1,y)}bt(e,"change",e,t)}function $n(e,t,r){function n(e,i,o){if(e.linked)for(var l=0;l<e.linked.length;++l){var s=e.linked[l];if(s.doc!=i){var a=o&&s.sharedHist;r&&!a||(t(s.doc,a),n(s.doc,e,a))}}}n(e,null,!0)}function qn(e,t){if(t.cm)throw new Error("This document is already in use.");e.doc=t,t.cm=e,Cr(e),jn(e),Zn(e),e.options.lineWrapping||we(e),e.options.mode=t.modeOption,vn(e)}function Zn(e){("rtl"==e.doc.direction?s:Fl)(e.display.lineDiv,"CodeMirror-rtl")}function Qn(e){hn(e,function(){Zn(e),vn(e)})}function Jn(e){this.done=[],this.undone=[],this.undoDepth=1/0,this.lastModTime=this.lastSelTime=0,this.lastOp=this.lastSelOp=null,this.lastOrigin=this.lastSelOrigin=null,this.generation=this.maxGeneration=e||1}function ei(e,t){var r={from:z(t.from),to:Bn(t),text:N(e,t.from,t.to)};return si(e,r,t.from.line,t.to.line+1),$n(e,function(e){return si(e,r,t.from.line,t.to.line+1)},!0),r}function ti(e){for(;e.length&&g(e).ranges;)e.pop()}function ri(e,t){return t?(ti(e.done),g(e.done)):e.done.length&&!g(e.done).ranges?g(e.done):e.done.length>1&&!e.done[e.done.length-2].ranges?(e.done.pop(),g(e.done)):void 0}function ni(e,t,r,n){var i=e.history;i.undone.length=0;var o,l,s=+new Date;if((i.lastOp==n||i.lastOrigin==t.origin&&t.origin&&("+"==t.origin.charAt(0)&&e.cm&&i.lastModTime>s-e.cm.options.historyEventDelay||"*"==t.origin.charAt(0)))&&(o=ri(i,i.lastOp==n)))l=g(o.changes),0==P(t.from,t.to)&&0==P(t.from,l.to)?l.to=Bn(t):o.changes.push(ei(e,t));else{var a=g(i.done);for(a&&a.ranges||li(e.sel,i.done),o={changes:[ei(e,t)],generation:i.generation},i.done.push(o);i.done.length>i.undoDepth;)i.done.shift(),i.done[0].ranges||i.done.shift()}i.done.push(r),i.generation=++i.maxGeneration,i.lastModTime=i.lastSelTime=s,i.lastOp=i.lastSelOp=n,i.lastOrigin=i.lastSelOrigin=t.origin,l||Te(e,"historyAdded")}function ii(e,t,r,n){var i=t.charAt(0);return"*"==i||"+"==i&&r.ranges.length==n.ranges.length&&r.somethingSelected()==n.somethingSelected()&&new Date-e.history.lastSelTime<=(e.cm?e.cm.options.historyEventDelay:500)}function oi(e,t,r,n){var i=e.history,o=n&&n.origin;r==i.lastSelOp||o&&i.lastSelOrigin==o&&(i.lastModTime==i.lastSelTime&&i.lastOrigin==o||ii(e,o,g(i.done),t))?i.done[i.done.length-1]=t:li(t,i.done),i.lastSelTime=+new Date,i.lastSelOrigin=o,i.lastSelOp=r,n&&!1!==n.clearRedo&&ti(i.undone)}function li(e,t){var r=g(t);r&&r.ranges&&r.equals(e)||t.push(e)}function si(e,t,r,n){var i=t["spans_"+e.id],o=0;e.iter(Math.max(e.first,r),Math.min(e.first+e.size,n),function(r){r.markedSpans&&((i||(i=t["spans_"+e.id]={}))[o]=r.markedSpans),++o})}function ai(e){if(!e)return null;for(var t,r=0;r<e.length;++r)e[r].marker.explicitlyCleared?t||(t=e.slice(0,r)):t&&t.push(e[r]);return t?t.length?t:null:e}function ui(e,t){var r=t["spans_"+e.id];if(!r)return null;for(var n=[],i=0;i<t.text.length;++i)n.push(ai(r[i]));return n}function ci(e,t){var r=ui(e,t),n=J(e,t);if(!r)return n;if(!n)return r;for(var i=0;i<r.length;++i){var o=r[i],l=n[i];if(o&&l)e:for(var s=0;s<l.length;++s){for(var a=l[s],u=0;u<o.length;++u)if(o[u].marker==a.marker)continue e;o.push(a)}else l&&(r[i]=l)}return r}function fi(e,t,r){for(var n=[],i=0;i<e.length;++i){var o=e[i];if(o.ranges)n.push(r?ks.prototype.deepCopy.call(o):o);else{var l=o.changes,s=[];n.push({changes:s});for(var a=0;a<l.length;++a){var u=l[a],c=void 0;if(s.push({from:u.from,to:u.to,text:u.text}),t)for(var f in u)(c=f.match(/^spans_(\d+)$/))&&h(t,Number(c[1]))>-1&&(g(s)[f]=u[f],delete u[f])}}}return n}function hi(e,t,r,n){if(n){var i=e.anchor;if(r){var o=P(t,i)<0;o!=P(r,i)<0?(i=t,t=r):o!=P(t,r)<0&&(t=r)}return new Ts(i,t)}return new Ts(r||t,t)}function di(e,t,r,n,i){null==i&&(i=e.cm&&(e.cm.display.shift||e.extend)),bi(e,new ks([hi(e.sel.primary(),t,r,i)],0),n)}function pi(e,t,r){for(var n=[],i=e.cm&&(e.cm.display.shift||e.extend),o=0;o<e.sel.ranges.length;o++)n[o]=hi(e.sel.ranges[o],t[o],null,i);bi(e,zn(n,e.sel.primIndex),r)}function gi(e,t,r,n){var i=e.sel.ranges.slice(0);i[t]=r,bi(e,zn(i,e.sel.primIndex),n)}function vi(e,t,r,n){bi(e,Rn(t,r),n)}function mi(e,t,r){var n={ranges:t.ranges,update:function(t){var r=this;this.ranges=[];for(var n=0;n<t.length;n++)r.ranges[n]=new Ts(U(e,t[n].anchor),U(e,t[n].head))},origin:r&&r.origin};return Te(e,"beforeSelectionChange",e,n),e.cm&&Te(e.cm,"beforeSelectionChange",e.cm,n),n.ranges!=t.ranges?zn(n.ranges,n.ranges.length-1):t}function yi(e,t,r){var n=e.history.done,i=g(n);i&&i.ranges?(n[n.length-1]=t,wi(e,t,r)):bi(e,t,r)}function bi(e,t,r){wi(e,t,r),oi(e,e.sel,e.cm?e.cm.curOp.id:NaN,r)}function wi(e,t,r){(Oe(e,"beforeSelectionChange")||e.cm&&Oe(e.cm,"beforeSelectionChange"))&&(t=mi(e,t,r)),xi(e,Si(e,t,r&&r.bias||(P(t.primary().head,e.sel.primary().head)<0?-1:1),!0)),r&&!1===r.scroll||!e.cm||jr(e.cm)}function xi(e,t){t.equals(e.sel)||(e.sel=t,e.cm&&(e.cm.curOp.updateInput=e.cm.curOp.selectionChanged=!0,Ne(e.cm)),bt(e,"cursorActivity",e))}function Ci(e){xi(e,Si(e,e.sel,null,!1))}function Si(e,t,r,n){for(var i,o=0;o<t.ranges.length;o++){var l=t.ranges[o],s=t.ranges.length==e.sel.ranges.length&&e.sel.ranges[o],a=ki(e,l.anchor,s&&s.anchor,r,n),u=ki(e,l.head,s&&s.head,r,n);(i||a!=l.anchor||u!=l.head)&&(i||(i=t.ranges.slice(0,o)),i[o]=new Ts(a,u))}return i?zn(i,t.primIndex):t}function Li(e,t,r,n,i){var o=M(e,t.line);if(o.markedSpans)for(var l=0;l<o.markedSpans.length;++l){var s=o.markedSpans[l],a=s.marker;if((null==s.from||(a.inclusiveLeft?s.from<=t.ch:s.from<t.ch))&&(null==s.to||(a.inclusiveRight?s.to>=t.ch:s.to>t.ch))){if(i&&(Te(a,"beforeCursorEnter"),a.explicitlyCleared)){if(o.markedSpans){--l;continue}break}if(!a.atomic)continue;if(r){var u=a.find(n<0?1:-1),c=void 0;if((n<0?a.inclusiveRight:a.inclusiveLeft)&&(u=Ti(e,u,-n,u&&u.line==t.line?o:null)),u&&u.line==t.line&&(c=P(u,r))&&(n<0?c<0:c>0))return Li(e,u,t,n,i)}var f=a.find(n<0?-1:1);return(n<0?a.inclusiveLeft:a.inclusiveRight)&&(f=Ti(e,f,n,f.line==t.line?o:null)),f?Li(e,f,t,n,i):null}}return t}function ki(e,t,r,n,i){var o=n||1,l=Li(e,t,r,o,i)||!i&&Li(e,t,r,o,!0)||Li(e,t,r,-o,i)||!i&&Li(e,t,r,-o,!0);return l||(e.cantEdit=!0,E(e.first,0))}function Ti(e,t,r,n){return r<0&&0==t.ch?t.line>e.first?U(e,E(t.line-1)):null:r>0&&t.ch==(n||M(e,t.line)).text.length?t.line<e.first+e.size-1?E(t.line+1,0):null:new E(t.line,t.ch+r)}function Mi(e){e.setSelection(E(e.firstLine(),0),E(e.lastLine()),Gl)}function Ni(e,t,r){var n={canceled:!1,from:t.from,to:t.to,text:t.text,origin:t.origin,cancel:function(){return n.canceled=!0}};return r&&(n.update=function(t,r,i,o){t&&(n.from=U(e,t)),r&&(n.to=U(e,r)),i&&(n.text=i),void 0!==o&&(n.origin=o)}),Te(e,"beforeChange",e,n),e.cm&&Te(e.cm,"beforeChange",e.cm,n),n.canceled?null:{from:n.from,to:n.to,text:n.text,origin:n.origin}}function Oi(e,t,r){if(e.cm){if(!e.cm.curOp)return dn(e.cm,Oi)(e,t,r);if(e.cm.state.suppressEdits)return}if(!(Oe(e,"beforeChange")||e.cm&&Oe(e.cm,"beforeChange"))||(t=Ni(e,t,!0))){var n=Yl&&!r&&te(e,t.from,t.to);if(n)for(var i=n.length-1;i>=0;--i)Ai(e,{from:n[i].from,to:n[i].to,text:i?[""]:t.text,origin:t.origin});else Ai(e,t)}}function Ai(e,t){if(1!=t.text.length||""!=t.text[0]||0!=P(t.from,t.to)){var r=Un(e,t);ni(e,t,r,e.cm?e.cm.curOp.id:NaN),Hi(e,t,r,J(e,t));var n=[];$n(e,function(e,r){r||-1!=h(n,e.history)||(zi(e.history,t),n.push(e.history)),Hi(e,t,null,J(e,t))})}}function Wi(e,t,r){if(!e.cm||!e.cm.state.suppressEdits||r){for(var n,i=e.history,o=e.sel,l="undo"==t?i.done:i.undone,s="undo"==t?i.undone:i.done,a=0;a<l.length&&(n=l[a],r?!n.ranges||n.equals(e.sel):n.ranges);a++);if(a!=l.length){for(i.lastOrigin=i.lastSelOrigin=null;(n=l.pop()).ranges;){if(li(n,s),r&&!n.equals(e.sel))return void bi(e,n,{clearRedo:!1});o=n}var u=[];li(o,s),s.push({changes:u,generation:i.generation}),i.generation=n.generation||++i.maxGeneration;for(var c=Oe(e,"beforeChange")||e.cm&&Oe(e.cm,"beforeChange"),f=n.changes.length-1;f>=0;--f){var d=function(r){var i=n.changes[r];if(i.origin=t,c&&!Ni(e,i,!1))return l.length=0,{};u.push(ei(e,i));var o=r?Un(e,i):g(l);Hi(e,i,o,ci(e,i)),!r&&e.cm&&e.cm.scrollIntoView({from:i.from,to:Bn(i)});var s=[];$n(e,function(e,t){t||-1!=h(s,e.history)||(zi(e.history,i),s.push(e.history)),Hi(e,i,null,ci(e,i))})}(f);if(d)return d.v}}}}function Di(e,t){if(0!=t&&(e.first+=t,e.sel=new ks(v(e.sel.ranges,function(e){return new Ts(E(e.anchor.line+t,e.anchor.ch),E(e.head.line+t,e.head.ch))}),e.sel.primIndex),e.cm)){vn(e.cm,e.first,e.first-t,t);for(var r=e.cm.display,n=r.viewFrom;n<r.viewTo;n++)mn(e.cm,n,"gutter")}}function Hi(e,t,r,n){if(e.cm&&!e.cm.curOp)return dn(e.cm,Hi)(e,t,r,n);if(t.to.line<e.first)Di(e,t.text.length-1-(t.to.line-t.from.line));else if(!(t.from.line>e.lastLine())){if(t.from.line<e.first){var i=t.text.length-1-(e.first-t.from.line);Di(e,i),t={from:E(e.first,0),to:E(t.to.line+i,t.to.ch),text:[g(t.text)],origin:t.origin}}var o=e.lastLine();t.to.line>o&&(t={from:t.from,to:E(o,M(e,o).text.length),text:[t.text[0]],origin:t.origin}),t.removed=N(e,t.from,t.to),r||(r=Un(e,t)),e.cm?Fi(e.cm,t,n):_n(e,t,n),wi(e,r,Gl)}}function Fi(e,t,r){var n=e.doc,i=e.display,o=t.from,l=t.to,s=!1,a=o.line;e.options.lineWrapping||(a=W(fe(M(n,o.line))),n.iter(a,l.line+1,function(e){if(e==i.maxLine)return s=!0,!0})),n.sel.contains(t.from,t.to)>-1&&Ne(e),_n(n,t,r,xr(e)),e.options.lineWrapping||(n.iter(a,o.line+t.text.length,function(e){var t=be(e);t>i.maxLineLength&&(i.maxLine=e,i.maxLineLength=t,i.maxLineChanged=!0,s=!1)}),s&&(e.curOp.updateMaxLine=!0)),nt(n,o.line),Cn(e,400);var u=t.text.length-(l.line-o.line)-1;t.full?vn(e):o.line!=l.line||1!=t.text.length||Yn(e.doc,t)?vn(e,o.line,l.line+1,u):mn(e,o.line,"text");var c=Oe(e,"changes"),f=Oe(e,"change");if(f||c){var h={from:o,to:l,text:t.text,removed:t.removed,origin:t.origin};f&&bt(e,"change",e,h),c&&(e.curOp.changeObjs||(e.curOp.changeObjs=[])).push(h)}e.display.selForContextMenu=null}function Ei(e,t,r,n,i){if(n||(n=r),P(n,r)<0){var o;r=(o=[n,r])[0],n=o[1]}"string"==typeof t&&(t=e.splitLines(t)),Oi(e,{from:r,to:n,text:t,origin:i})}function Pi(e,t,r,n){r<e.line?e.line+=n:t<e.line&&(e.line=t,e.ch=0)}function Ii(e,t,r,n){for(var i=0;i<e.length;++i){var o=e[i],l=!0;if(o.ranges){o.copied||((o=e[i]=o.deepCopy()).copied=!0);for(var s=0;s<o.ranges.length;s++)Pi(o.ranges[s].anchor,t,r,n),Pi(o.ranges[s].head,t,r,n)}else{for(var a=0;a<o.changes.length;++a){var u=o.changes[a];if(r<u.from.line)u.from=E(u.from.line+n,u.from.ch),u.to=E(u.to.line+n,u.to.ch);else if(t<=u.to.line){l=!1;break}}l||(e.splice(0,i+1),i=0)}}}function zi(e,t){var r=t.from.line,n=t.to.line,i=t.text.length-(n-r)-1;Ii(e.done,r,n,i),Ii(e.undone,r,n,i)}function Ri(e,t,r,n){var i=t,o=t;return"number"==typeof t?o=M(e,G(e,t)):i=W(t),null==i?null:(n(o,i)&&e.cm&&mn(e.cm,i,r),o)}function Bi(e){var t=this;this.lines=e,this.parent=null;for(var r=0,n=0;n<e.length;++n)e[n].parent=t,r+=e[n].height;this.height=r}function Gi(e){var t=this;this.children=e;for(var r=0,n=0,i=0;i<e.length;++i){var o=e[i];r+=o.chunkSize(),n+=o.height,o.parent=t}this.size=r,this.height=n,this.parent=null}function Ui(e,t,r){ye(t)<(e.curOp&&e.curOp.scrollTop||e.doc.scrollTop)&&Kr(e,r)}function Vi(e,t,r,n){var i=new Ms(e,r,n),o=e.cm;return o&&i.noHScroll&&(o.display.alignWidgets=!0),Ri(e,t,"widget",function(t){var r=t.widgets||(t.widgets=[]);if(null==i.insertAt?r.push(i):r.splice(Math.min(r.length-1,Math.max(0,i.insertAt)),0,i),i.line=t,o&&!ve(e,t)){var n=ye(t)<e.scrollTop;A(t,t.height+Ht(i)),n&&Kr(o,i.height),o.curOp.forceUpdate=!0}return!0}),bt(o,"lineWidgetAdded",o,i,"number"==typeof t?t:W(t)),i}function Ki(e,t,r,n,o){if(n&&n.shared)return ji(e,t,r,n,o);if(e.cm&&!e.cm.curOp)return dn(e.cm,Ki)(e,t,r,n,o);var l=new Os(e,o),s=P(t,r);if(n&&c(n,l,!1),s>0||0==s&&!1!==l.clearWhenEmpty)return l;if(l.replacedWith&&(l.collapsed=!0,l.widgetNode=i("span",[l.replacedWith],"CodeMirror-widget"),n.handleMouseEvents||l.widgetNode.setAttribute("cm-ignore-events","true"),n.insertLeft&&(l.widgetNode.insertLeft=!0)),l.collapsed){if(ce(e,t.line,t,r,l)||t.line!=r.line&&ce(e,r.line,t,r,l))throw new Error("Inserting collapsed marker partially overlapping an existing one");X()}l.addToHistory&&ni(e,{from:t,to:r,origin:"markText"},e.sel,NaN);var a,u=t.line,f=e.cm;if(e.iter(u,r.line+1,function(e){f&&l.collapsed&&!f.options.lineWrapping&&fe(e)==f.display.maxLine&&(a=!0),l.collapsed&&u!=t.line&&A(e,0),q(e,new Y(l,u==t.line?t.ch:null,u==r.line?r.ch:null)),++u}),l.collapsed&&e.iter(t.line,r.line+1,function(t){ve(e,t)&&A(t,0)}),l.clearOnEnter&&Ql(l,"beforeCursorEnter",function(){return l.clear()}),l.readOnly&&(j(),(e.history.done.length||e.history.undone.length)&&e.clearHistory()),l.collapsed&&(l.id=++Ns,l.atomic=!0),f){if(a&&(f.curOp.updateMaxLine=!0),l.collapsed)vn(f,t.line,r.line+1);else if(l.className||l.title||l.startStyle||l.endStyle||l.css)for(var h=t.line;h<=r.line;h++)mn(f,h,"text");l.atomic&&Ci(f.doc),bt(f,"markerAdded",f,l)}return l}function ji(e,t,r,n,i){(n=c(n)).shared=!1;var o=[Ki(e,t,r,n,i)],l=o[0],s=n.widgetNode;return $n(e,function(e){s&&(n.widgetNode=s.cloneNode(!0)),o.push(Ki(e,U(e,t),U(e,r),n,i));for(var a=0;a<e.linked.length;++a)if(e.linked[a].isParent)return;l=g(o)}),new As(o,l)}function Xi(e){return e.findMarks(E(e.first,0),e.clipPos(E(e.lastLine())),function(e){return e.parent})}function Yi(e,t){for(var r=0;r<t.length;r++){var n=t[r],i=n.find(),o=e.clipPos(i.from),l=e.clipPos(i.to);if(P(o,l)){var s=Ki(e,o,l,n.primary,n.primary.type);n.markers.push(s),s.parent=n}}}function _i(e){for(var t=0;t<e.length;t++)!function(t){var r=e[t],n=[r.primary.doc];$n(r.primary.doc,function(e){return n.push(e)});for(var i=0;i<r.markers.length;i++){var o=r.markers[i];-1==h(n,o.doc)&&(o.parent=null,r.markers.splice(i--,1))}}(t)}function $i(e){var t=this;if(Qi(t),!Me(t,e)&&!Ft(t.display,e)){We(e),gl&&(Hs=+new Date);var r=Sr(t,e,!0),n=e.dataTransfer.files;if(r&&!t.isReadOnly())if(n&&n.length&&window.FileReader&&window.File)for(var i=n.length,o=Array(i),l=0,s=0;s<i;++s)!function(e,n){if(!t.options.allowDropFileTypes||-1!=h(t.options.allowDropFileTypes,e.type)){var s=new FileReader;s.onload=dn(t,function(){var e=s.result;if(/[\x00-\x08\x0e-\x1f]{2}/.test(e)&&(e=""),o[n]=e,++l==i){var a={from:r=U(t.doc,r),to:r,text:t.doc.splitLines(o.join(t.doc.lineSeparator())),origin:"paste"};Oi(t.doc,a),yi(t.doc,Rn(r,Bn(a)))}}),s.readAsText(e)}}(n[s],s);else{if(t.state.draggingText&&t.doc.sel.contains(r)>-1)return t.state.draggingText(e),void setTimeout(function(){return t.display.input.focus()},20);try{var a=e.dataTransfer.getData("Text");if(a){var u;if(t.state.draggingText&&!t.state.draggingText.copy&&(u=t.listSelections()),wi(t.doc,Rn(r,r)),u)for(var c=0;c<u.length;++c)Ei(t.doc,"",u[c].anchor,u[c].head,"drag");t.replaceSelection(a,"around","paste"),t.display.input.focus()}}catch(e){}}}}function qi(e,t){if(gl&&(!e.state.draggingText||+new Date-Hs<100))Fe(t);else if(!Me(e,t)&&!Ft(e.display,t)&&(t.dataTransfer.setData("Text",e.getSelection()),t.dataTransfer.effectAllowed="copyMove",t.dataTransfer.setDragImage&&!xl)){var r=n("img",null,null,"position: fixed; left: 0; top: 0;");r.src="data:image/gif;base64,R0lGODlhAQABAAAAACH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==",wl&&(r.width=r.height=1,e.display.wrapper.appendChild(r),r._top=r.offsetTop),t.dataTransfer.setDragImage(r,0,0),wl&&r.parentNode.removeChild(r)}}function Zi(e,t){var i=Sr(e,t);if(i){var o=document.createDocumentFragment();Mr(e,i,o),e.display.dragCursor||(e.display.dragCursor=n("div",null,"CodeMirror-cursors CodeMirror-dragcursors"),e.display.lineSpace.insertBefore(e.display.dragCursor,e.display.cursorDiv)),r(e.display.dragCursor,o)}}function Qi(e){e.display.dragCursor&&(e.display.lineSpace.removeChild(e.display.dragCursor),e.display.dragCursor=null)}function Ji(e){if(document.getElementsByClassName)for(var t=document.getElementsByClassName("CodeMirror"),r=0;r<t.length;r++){var n=t[r].CodeMirror;n&&e(n)}}function eo(){Fs||(to(),Fs=!0)}function to(){var e;Ql(window,"resize",function(){null==e&&(e=setTimeout(function(){e=null,Ji(ro)},100))}),Ql(window,"blur",function(){return Ji(Fr)})}function ro(e){var t=e.display;t.lastWrapHeight==t.wrapper.clientHeight&&t.lastWrapWidth==t.wrapper.clientWidth||(t.cachedCharWidth=t.cachedTextHeight=t.cachedPaddingH=null,t.scrollbarsClipped=!1,e.setSize())}function no(e){var t=e.split(/-(?!$)/);e=t[t.length-1];for(var r,n,i,o,l=0;l<t.length-1;l++){var s=t[l];if(/^(cmd|meta|m)$/i.test(s))o=!0;else if(/^a(lt)?$/i.test(s))r=!0;else if(/^(c|ctrl|control)$/i.test(s))n=!0;else{if(!/^s(hift)?$/i.test(s))throw new Error("Unrecognized modifier name: "+s);i=!0}}return r&&(e="Alt-"+e),n&&(e="Ctrl-"+e),o&&(e="Cmd-"+e),i&&(e="Shift-"+e),e}function io(e){var t={};for(var r in e)if(e.hasOwnProperty(r)){var n=e[r];if(/^(name|fallthrough|(de|at)tach)$/.test(r))continue;if("..."==n){delete e[r];continue}for(var i=v(r.split(" "),no),o=0;o<i.length;o++){var l=void 0,s=void 0;o==i.length-1?(s=i.join(" "),l=n):(s=i.slice(0,o+1).join(" "),l="...");var a=t[s];if(a){if(a!=l)throw new Error("Inconsistent bindings for "+s)}else t[s]=l}delete e[r]}for(var u in t)e[u]=t[u];return e}function oo(e,t,r,n){var i=(t=uo(t)).call?t.call(e,n):t[e];if(!1===i)return"nothing";if("..."===i)return"multi";if(null!=i&&r(i))return"handled";if(t.fallthrough){if("[object Array]"!=Object.prototype.toString.call(t.fallthrough))return oo(e,t.fallthrough,r,n);for(var o=0;o<t.fallthrough.length;o++){var l=oo(e,t.fallthrough[o],r,n);if(l)return l}}}function lo(e){var t="string"==typeof e?e:Es[e.keyCode];return"Ctrl"==t||"Alt"==t||"Shift"==t||"Mod"==t}function so(e,t,r){var n=e;return t.altKey&&"Alt"!=n&&(e="Alt-"+e),(Dl?t.metaKey:t.ctrlKey)&&"Ctrl"!=n&&(e="Ctrl-"+e),(Dl?t.ctrlKey:t.metaKey)&&"Cmd"!=n&&(e="Cmd-"+e),!r&&t.shiftKey&&"Shift"!=n&&(e="Shift-"+e),e}function ao(e,t){if(wl&&34==e.keyCode&&e.char)return!1;var r=Es[e.keyCode];return null!=r&&!e.altGraphKey&&so(r,e,t)}function uo(e){return"string"==typeof e?Rs[e]:e}function co(e,t){for(var r=e.doc.sel.ranges,n=[],i=0;i<r.length;i++){for(var o=t(r[i]);n.length&&P(o.from,g(n).to)<=0;){var l=n.pop();if(P(l.from,o.from)<0){o.from=l.from;break}}n.push(o)}hn(e,function(){for(var t=n.length-1;t>=0;t--)Ei(e.doc,"",n[t].from,n[t].to,"+delete");jr(e)})}function fo(e,t,r){var n=L(e.text,t+r,r);return n<0||n>e.text.length?null:n}function ho(e,t,r){var n=fo(e,t.ch,r);return null==n?null:new E(t.line,n,r<0?"after":"before")}function po(e,t,r,n,i){if(e){var o=Se(r,t.doc.direction);if(o){var l,s=i<0?g(o):o[0],a=i<0==(1==s.level)?"after":"before";if(s.level>0){var u=Xt(t,r);l=i<0?r.text.length-1:0;var c=Yt(t,u,l).top;l=k(function(e){return Yt(t,u,e).top==c},i<0==(1==s.level)?s.from:s.to-1,l),"before"==a&&(l=fo(r,l,1))}else l=i<0?s.to:s.from;return new E(n,l,a)}}return new E(n,i<0?r.text.length:0,i<0?"before":"after")}function go(e,t,r,n){var i=Se(t,e.doc.direction);if(!i)return ho(t,r,n);r.ch>=t.text.length?(r.ch=t.text.length,r.sticky="before"):r.ch<=0&&(r.ch=0,r.sticky="after");var o=Ce(i,r.ch,r.sticky),l=i[o];if("ltr"==e.doc.direction&&l.level%2==0&&(n>0?l.to>r.ch:l.from<r.ch))return ho(t,r,n);var s,a=function(e,r){return fo(t,e instanceof E?e.ch:e,r)},u=function(r){return e.options.lineWrapping?(s=s||Xt(e,t),hr(e,t,s,r)):{begin:0,end:t.text.length}},c=u("before"==r.sticky?a(r,-1):r.ch);if("rtl"==e.doc.direction||1==l.level){var f=1==l.level==n<0,h=a(r,f?1:-1);if(null!=h&&(f?h<=l.to&&h<=c.end:h>=l.from&&h>=c.begin)){var d=f?"before":"after";return new E(r.line,h,d)}}var p=function(e,t,n){for(var o=function(e,t){return t?new E(r.line,a(e,1),"before"):new E(r.line,e,"after")};e>=0&&e<i.length;e+=t){var l=i[e],s=t>0==(1!=l.level),u=s?n.begin:a(n.end,-1);if(l.from<=u&&u<l.to)return o(u,s);if(u=s?l.from:a(l.to,-1),n.begin<=u&&u<n.end)return o(u,s)}},g=p(o+n,n,c);if(g)return g;var v=n>0?c.end:a(c.begin,-1);return null==v||n>0&&v==t.text.length||!(g=p(n>0?0:i.length-1,n,u(v)))?null:g}function vo(e,t){var r=M(e.doc,t),n=fe(r);return n!=r&&(t=W(n)),po(!0,e,n,t,1)}function mo(e,t){var r=M(e.doc,t),n=he(r);return n!=r&&(t=W(n)),po(!0,e,r,t,-1)}function yo(e,t){var r=vo(e,t.line),n=M(e.doc,r.line),i=Se(n,e.doc.direction);if(!i||0==i[0].level){var o=Math.max(0,n.text.search(/\S/)),l=t.line==r.line&&t.ch<=o&&t.ch;return E(r.line,l?0:o,r.sticky)}return r}function bo(e,t,r){if("string"==typeof t&&!(t=Bs[t]))return!1;e.display.input.ensurePolled();var n=e.display.shift,i=!1;try{e.isReadOnly()&&(e.state.suppressEdits=!0),r&&(e.display.shift=!1),i=t(e)!=Bl}finally{e.display.shift=n,e.state.suppressEdits=!1}return i}function wo(e,t,r){for(var n=0;n<e.state.keyMaps.length;n++){var i=oo(t,e.state.keyMaps[n],r,e);if(i)return i}return e.options.extraKeys&&oo(t,e.options.extraKeys,r,e)||oo(t,e.options.keyMap,r,e)}function xo(e,t,r,n){var i=e.state.keySeq;if(i){if(lo(t))return"handled";Gs.set(50,function(){e.state.keySeq==i&&(e.state.keySeq=null,e.display.input.reset())}),t=i+" "+t}var o=wo(e,t,n);return"multi"==o&&(e.state.keySeq=t),"handled"==o&&bt(e,"keyHandled",e,t,r),"handled"!=o&&"multi"!=o||(We(r),Ar(e)),i&&!o&&/\'$/.test(t)?(We(r),!0):!!o}function Co(e,t){var r=ao(t,!0);return!!r&&(t.shiftKey&&!e.state.keySeq?xo(e,"Shift-"+r,t,function(t){return bo(e,t,!0)})||xo(e,r,t,function(t){if("string"==typeof t?/^go[A-Z]/.test(t):t.motion)return bo(e,t)}):xo(e,r,t,function(t){return bo(e,t)}))}function So(e,t,r){return xo(e,"'"+r+"'",t,function(t){return bo(e,t,!0)})}function Lo(e){var t=this;if(t.curOp.focus=l(),!Me(t,e)){gl&&vl<11&&27==e.keyCode&&(e.returnValue=!1);var r=e.keyCode;t.display.shift=16==r||e.shiftKey;var n=Co(t,e);wl&&(Us=n?r:null,!n&&88==r&&!rs&&(Ml?e.metaKey:e.ctrlKey)&&t.replaceSelection("",null,"cut")),18!=r||/\bCodeMirror-crosshair\b/.test(t.display.lineDiv.className)||ko(t)}}function ko(e){function t(e){18!=e.keyCode&&e.altKey||(Fl(r,"CodeMirror-crosshair"),ke(document,"keyup",t),ke(document,"mouseover",t))}var r=e.display.lineDiv;s(r,"CodeMirror-crosshair"),Ql(document,"keyup",t),Ql(document,"mouseover",t)}function To(e){16==e.keyCode&&(this.doc.sel.shift=!1),Me(this,e)}function Mo(e){var t=this;if(!(Ft(t.display,e)||Me(t,e)||e.ctrlKey&&!e.altKey||Ml&&e.metaKey)){var r=e.keyCode,n=e.charCode;if(wl&&r==Us)return Us=null,void We(e);if(!wl||e.which&&!(e.which<10)||!Co(t,e)){var i=String.fromCharCode(null==n?r:n);"\b"!=i&&(So(t,e,i)||t.display.input.onKeyPress(e))}}}function No(e,t){var r=+new Date;return js&&js.compare(r,e,t)?(Ks=js=null,"triple"):Ks&&Ks.compare(r,e,t)?(js=new Vs(r,e,t),Ks=null,"double"):(Ks=new Vs(r,e,t),js=null,"single")}function Oo(e){var t=this,r=t.display;if(!(Me(t,e)||r.activeTouch&&r.input.supportsTouch()))if(r.input.ensurePolled(),r.shift=e.shiftKey,Ft(r,e))ml||(r.scroller.draggable=!1,setTimeout(function(){return r.scroller.draggable=!0},100));else if(!zo(t,e)){var n=Sr(t,e),i=Pe(e),o=n?No(n,i):"single";window.focus(),1==i&&t.state.selectingText&&t.state.selectingText(e),n&&Ao(t,i,n,o,e)||(1==i?n?Do(t,n,o,e):Ee(e)==r.scroller&&We(e):2==i?(n&&di(t.doc,n),setTimeout(function(){return r.input.focus()},20)):3==i&&(Hl?Ro(t,e):Dr(t)))}}function Ao(e,t,r,n,i){var o="Click";return"double"==n?o="Double"+o:"triple"==n&&(o="Triple"+o),o=(1==t?"Left":2==t?"Middle":"Right")+o,xo(e,so(o,i),i,function(t){if("string"==typeof t&&(t=Bs[t]),!t)return!1;var n=!1;try{e.isReadOnly()&&(e.state.suppressEdits=!0),n=t(e,r)!=Bl}finally{e.state.suppressEdits=!1}return n})}function Wo(e,t,r){var n=e.getOption("configureMouse"),i=n?n(e,t,r):{};if(null==i.unit){var o=Nl?r.shiftKey&&r.metaKey:r.altKey;i.unit=o?"rectangle":"single"==t?"char":"double"==t?"word":"line"}return(null==i.extend||e.doc.extend)&&(i.extend=e.doc.extend||r.shiftKey),null==i.addNew&&(i.addNew=Ml?r.metaKey:r.ctrlKey),null==i.moveOnDrag&&(i.moveOnDrag=!(Ml?r.altKey:r.ctrlKey)),i}function Do(e,t,r,n){gl?setTimeout(u(Wr,e),0):e.curOp.focus=l();var i,o=Wo(e,r,n),s=e.doc.sel;e.options.dragDrop&&Jl&&!e.isReadOnly()&&"single"==r&&(i=s.contains(t))>-1&&(P((i=s.ranges[i]).from(),t)<0||t.xRel>0)&&(P(i.to(),t)>0||t.xRel<0)?Ho(e,n,t,o):Eo(e,n,t,o)}function Ho(e,t,r,n){var i=e.display,o=!1,l=dn(e,function(t){ml&&(i.scroller.draggable=!1),e.state.draggingText=!1,ke(document,"mouseup",l),ke(document,"mousemove",s),ke(i.scroller,"dragstart",a),ke(i.scroller,"drop",l),o||(We(t),n.addNew||di(e.doc,r,null,null,n.extend),ml||gl&&9==vl?setTimeout(function(){document.body.focus(),i.input.focus()},20):i.input.focus())}),s=function(e){o=o||Math.abs(t.clientX-e.clientX)+Math.abs(t.clientY-e.clientY)>=10},a=function(){return o=!0};ml&&(i.scroller.draggable=!0),e.state.draggingText=l,l.copy=!n.moveOnDrag,i.scroller.dragDrop&&i.scroller.dragDrop(),Ql(document,"mouseup",l),Ql(document,"mousemove",s),Ql(i.scroller,"dragstart",a),Ql(i.scroller,"drop",l),Dr(e),setTimeout(function(){return i.input.focus()},20)}function Fo(e,t,r){if("char"==r)return new Ts(t,t);if("word"==r)return e.findWordAt(t);if("line"==r)return new Ts(E(t.line,0),U(e.doc,E(t.line+1,0)));var n=r(e,t);return new Ts(n.from,n.to)}function Eo(e,t,r,n){function i(t){if(0!=P(m,t))if(m=t,"rectangle"==n.unit){for(var i=[],o=e.options.tabSize,l=f(M(u,r.line).text,r.ch,o),s=f(M(u,t.line).text,t.ch,o),a=Math.min(l,s),g=Math.max(l,s),v=Math.min(r.line,t.line),y=Math.min(e.lastLine(),Math.max(r.line,t.line));v<=y;v++){var b=M(u,v).text,w=d(b,a,o);a==g?i.push(new Ts(E(v,w),E(v,w))):b.length>w&&i.push(new Ts(E(v,w),E(v,d(b,g,o))))}i.length||i.push(new Ts(r,r)),bi(u,zn(p.ranges.slice(0,h).concat(i),h),{origin:"*mouse",scroll:!1}),e.scrollIntoView(t)}else{var x,C=c,S=Fo(e,t,n.unit),L=C.anchor;P(S.anchor,L)>0?(x=S.head,L=B(C.from(),S.anchor)):(x=S.anchor,L=R(C.to(),S.head));var k=p.ranges.slice(0);k[h]=Po(e,new Ts(U(u,L),x)),bi(u,zn(k,h),Ul)}}function o(t){var r=++b,s=Sr(e,t,!0,"rectangle"==n.unit);if(s)if(0!=P(s,m)){e.curOp.focus=l(),i(s);var c=Ir(a,u);(s.line>=c.to||s.line<c.from)&&setTimeout(dn(e,function(){b==r&&o(t)}),150)}else{var f=t.clientY<y.top?-20:t.clientY>y.bottom?20:0;f&&setTimeout(dn(e,function(){b==r&&(a.scroller.scrollTop+=f,o(t))}),50)}}function s(t){e.state.selectingText=!1,b=1/0,We(t),a.input.focus(),ke(document,"mousemove",w),ke(document,"mouseup",x),u.history.lastSelOrigin=null}var a=e.display,u=e.doc;We(t);var c,h,p=u.sel,g=p.ranges;if(n.addNew&&!n.extend?(h=u.sel.contains(r),c=h>-1?g[h]:new Ts(r,r)):(c=u.sel.primary(),h=u.sel.primIndex),"rectangle"==n.unit)n.addNew||(c=new Ts(r,r)),r=Sr(e,t,!0,!0),h=-1;else{var v=Fo(e,r,n.unit);c=n.extend?hi(c,v.anchor,v.head,n.extend):v}n.addNew?-1==h?(h=g.length,bi(u,zn(g.concat([c]),h),{scroll:!1,origin:"*mouse"})):g.length>1&&g[h].empty()&&"char"==n.unit&&!n.extend?(bi(u,zn(g.slice(0,h).concat(g.slice(h+1)),0),{scroll:!1,origin:"*mouse"}),p=u.sel):gi(u,h,c,Ul):(h=0,bi(u,new ks([c],0),Ul),p=u.sel);var m=r,y=a.wrapper.getBoundingClientRect(),b=0,w=dn(e,function(e){Pe(e)?o(e):s(e)}),x=dn(e,s);e.state.selectingText=x,Ql(document,"mousemove",w),Ql(document,"mouseup",x)}function Po(e,t){var r=t.anchor,n=t.head,i=M(e.doc,r.line);if(0==P(r,n)&&r.sticky==n.sticky)return t;var o=Se(i);if(!o)return t;var l=Ce(o,r.ch,r.sticky),s=o[l];if(s.from!=r.ch&&s.to!=r.ch)return t;var a=l+(s.from==r.ch==(1!=s.level)?0:1);if(0==a||a==o.length)return t;var u;if(n.line!=r.line)u=(n.line-r.line)*("ltr"==e.doc.direction?1:-1)>0;else{var c=Ce(o,n.ch,n.sticky),f=c-l||(n.ch-r.ch)*(1==s.level?-1:1);u=c==a-1||c==a?f<0:f>0}var h=o[a+(u?-1:0)],d=u==(1==h.level),p=d?h.from:h.to,g=d?"after":"before";return r.ch==p&&r.sticky==g?t:new Ts(new E(r.line,p,g),n)}function Io(e,t,r,n){var i,o;if(t.touches)i=t.touches[0].clientX,o=t.touches[0].clientY;else try{i=t.clientX,o=t.clientY}catch(t){return!1}if(i>=Math.floor(e.display.gutters.getBoundingClientRect().right))return!1;n&&We(t);var l=e.display,s=l.lineDiv.getBoundingClientRect();if(o>s.bottom||!Oe(e,r))return He(t);o-=s.top-l.viewOffset;for(var a=0;a<e.options.gutters.length;++a){var u=l.gutters.childNodes[a];if(u&&u.getBoundingClientRect().right>=i)return Te(e,r,e,D(e.doc,o),e.options.gutters[a],t),He(t)}}function zo(e,t){return Io(e,t,"gutterClick",!0)}function Ro(e,t){Ft(e.display,t)||Bo(e,t)||Me(e,t,"contextmenu")||e.display.input.onContextMenu(t)}function Bo(e,t){return!!Oe(e,"gutterContextMenu")&&Io(e,t,"gutterContextMenu",!1)}function Go(e){e.display.wrapper.className=e.display.wrapper.className.replace(/\s*cm-s-\S+/g,"")+e.options.theme.replace(/(^|\s)\s*/g," cm-s-"),er(e)}function Uo(e){Hn(e),vn(e),zr(e)}function Vo(e,t,r){if(!t!=!(r&&r!=Xs)){var n=e.display.dragFunctions,i=t?Ql:ke;i(e.display.scroller,"dragstart",n.start),i(e.display.scroller,"dragenter",n.enter),i(e.display.scroller,"dragover",n.over),i(e.display.scroller,"dragleave",n.leave),i(e.display.scroller,"drop",n.drop)}}function Ko(e){e.options.lineWrapping?(s(e.display.wrapper,"CodeMirror-wrap"),e.display.sizer.style.minWidth="",e.display.sizerWidth=null):(Fl(e.display.wrapper,"CodeMirror-wrap"),we(e)),Cr(e),vn(e),er(e),setTimeout(function(){return en(e)},100)}function jo(e,t){var r=this;if(!(this instanceof jo))return new jo(e,t);this.options=t=t?c(t):{},c(Ys,t,!1),Fn(t);var n=t.value;"string"==typeof n&&(n=new Ds(n,t.mode,null,t.lineSeparator,t.direction)),this.doc=n;var i=new jo.inputStyles[t.inputStyle](this),o=this.display=new T(e,n,i);o.wrapper.CodeMirror=this,Hn(this),Go(this),t.lineWrapping&&(this.display.wrapper.className+=" CodeMirror-wrap"),rn(this),this.state={keyMaps:[],overlays:[],modeGen:0,overwrite:!1,delayingBlurEvent:!1,focused:!1,suppressEdits:!1,pasteIncoming:!1,cutIncoming:!1,selectingText:!1,draggingText:!1,highlight:new Pl,keySeq:null,specialChars:null},t.autofocus&&!Tl&&o.input.focus(),gl&&vl<11&&setTimeout(function(){return r.display.input.reset(!0)},20),Xo(this),eo(),nn(this),this.curOp.forceUpdate=!0,qn(this,n),t.autofocus&&!Tl||this.hasFocus()?setTimeout(u(Hr,this),20):Fr(this);for(var l in _s)_s.hasOwnProperty(l)&&_s[l](r,t[l],Xs);Rr(this),t.finishInit&&t.finishInit(this);for(var s=0;s<$s.length;++s)$s[s](r);on(this),ml&&t.lineWrapping&&"optimizelegibility"==getComputedStyle(o.lineDiv).textRendering&&(o.lineDiv.style.textRendering="auto")}function Xo(e){function t(){i.activeTouch&&(o=setTimeout(function(){return i.activeTouch=null},1e3),(l=i.activeTouch).end=+new Date)}function r(e){if(1!=e.touches.length)return!1;var t=e.touches[0];return t.radiusX<=1&&t.radiusY<=1}function n(e,t){if(null==t.left)return!0;var r=t.left-e.left,n=t.top-e.top;return r*r+n*n>400}var i=e.display;Ql(i.scroller,"mousedown",dn(e,Oo)),gl&&vl<11?Ql(i.scroller,"dblclick",dn(e,function(t){if(!Me(e,t)){var r=Sr(e,t);if(r&&!zo(e,t)&&!Ft(e.display,t)){We(t);var n=e.findWordAt(r);di(e.doc,n.anchor,n.head)}}})):Ql(i.scroller,"dblclick",function(t){return Me(e,t)||We(t)}),Hl||Ql(i.scroller,"contextmenu",function(t){return Ro(e,t)});var o,l={end:0};Ql(i.scroller,"touchstart",function(t){if(!Me(e,t)&&!r(t)&&!zo(e,t)){i.input.ensurePolled(),clearTimeout(o);var n=+new Date;i.activeTouch={start:n,moved:!1,prev:n-l.end<=300?l:null},1==t.touches.length&&(i.activeTouch.left=t.touches[0].pageX,i.activeTouch.top=t.touches[0].pageY)}}),Ql(i.scroller,"touchmove",function(){i.activeTouch&&(i.activeTouch.moved=!0)}),Ql(i.scroller,"touchend",function(r){var o=i.activeTouch;if(o&&!Ft(i,r)&&null!=o.left&&!o.moved&&new Date-o.start<300){var l,s=e.coordsChar(i.activeTouch,"page");l=!o.prev||n(o,o.prev)?new Ts(s,s):!o.prev.prev||n(o,o.prev.prev)?e.findWordAt(s):new Ts(E(s.line,0),U(e.doc,E(s.line+1,0))),e.setSelection(l.anchor,l.head),e.focus(),We(r)}t()}),Ql(i.scroller,"touchcancel",t),Ql(i.scroller,"scroll",function(){i.scroller.clientHeight&&(qr(e,i.scroller.scrollTop),Qr(e,i.scroller.scrollLeft,!0),Te(e,"scroll",e))}),Ql(i.scroller,"mousewheel",function(t){return In(e,t)}),Ql(i.scroller,"DOMMouseScroll",function(t){return In(e,t)}),Ql(i.wrapper,"scroll",function(){return i.wrapper.scrollTop=i.wrapper.scrollLeft=0}),i.dragFunctions={enter:function(t){Me(e,t)||Fe(t)},over:function(t){Me(e,t)||(Zi(e,t),Fe(t))},start:function(t){return qi(e,t)},drop:dn(e,$i),leave:function(t){Me(e,t)||Qi(e)}};var s=i.input.getField();Ql(s,"keyup",function(t){return To.call(e,t)}),Ql(s,"keydown",dn(e,Lo)),Ql(s,"keypress",dn(e,Mo)),Ql(s,"focus",function(t){return Hr(e,t)}),Ql(s,"blur",function(t){return Fr(e,t)})}function Yo(e,t,r,n){var i,o=e.doc;null==r&&(r="add"),"smart"==r&&(o.mode.indent?i=$e(e,t).state:r="prev");var l=e.options.tabSize,s=M(o,t),a=f(s.text,null,l);s.stateAfter&&(s.stateAfter=null);var u,c=s.text.match(/^\s*/)[0];if(n||/\S/.test(s.text)){if("smart"==r&&((u=o.mode.indent(i,s.text.slice(c.length),s.text))==Bl||u>150)){if(!n)return;r="prev"}}else u=0,r="not";"prev"==r?u=t>o.first?f(M(o,t-1).text,null,l):0:"add"==r?u=a+e.options.indentUnit:"subtract"==r?u=a-e.options.indentUnit:"number"==typeof r&&(u=a+r),u=Math.max(0,u);var h="",d=0;if(e.options.indentWithTabs)for(var g=Math.floor(u/l);g;--g)d+=l,h+="\t";if(d<u&&(h+=p(u-d)),h!=c)return Ei(o,h,E(t,0),E(t,c.length),"+input"),s.stateAfter=null,!0;for(var v=0;v<o.sel.ranges.length;v++){var m=o.sel.ranges[v];if(m.head.line==t&&m.head.ch<c.length){var y=E(t,c.length);gi(o,v,new Ts(y,y));break}}}function _o(e){qs=e}function $o(e,t,r,n,i){var o=e.doc;e.display.shift=!1,n||(n=o.sel);var l=e.state.pasteIncoming||"paste"==i,s=es(t),a=null;if(l&&n.ranges.length>1)if(qs&&qs.text.join("\n")==t){if(n.ranges.length%qs.text.length==0){a=[];for(var u=0;u<qs.text.length;u++)a.push(o.splitLines(qs.text[u]))}}else s.length==n.ranges.length&&e.options.pasteLinesPerSelection&&(a=v(s,function(e){return[e]}));for(var c,f=n.ranges.length-1;f>=0;f--){var h=n.ranges[f],d=h.from(),p=h.to();h.empty()&&(r&&r>0?d=E(d.line,d.ch-r):e.state.overwrite&&!l?p=E(p.line,Math.min(M(o,p.line).text.length,p.ch+g(s).length)):qs&&qs.lineWise&&qs.text.join("\n")==t&&(d=p=E(d.line,0))),c=e.curOp.updateInput;var m={from:d,to:p,text:a?a[f%a.length]:s,origin:i||(l?"paste":e.state.cutIncoming?"cut":"+input")};Oi(e.doc,m),bt(e,"inputRead",e,m)}t&&!l&&Zo(e,t),jr(e),e.curOp.updateInput=c,e.curOp.typing=!0,e.state.pasteIncoming=e.state.cutIncoming=!1}function qo(e,t){var r=e.clipboardData&&e.clipboardData.getData("Text");if(r)return e.preventDefault(),t.isReadOnly()||t.options.disableInput||hn(t,function(){return $o(t,r,0,null,"paste")}),!0}function Zo(e,t){if(e.options.electricChars&&e.options.smartIndent)for(var r=e.doc.sel,n=r.ranges.length-1;n>=0;n--){var i=r.ranges[n];if(!(i.head.ch>100||n&&r.ranges[n-1].head.line==i.head.line)){var o=e.getModeAt(i.head),l=!1;if(o.electricChars){for(var s=0;s<o.electricChars.length;s++)if(t.indexOf(o.electricChars.charAt(s))>-1){l=Yo(e,i.head.line,"smart");break}}else o.electricInput&&o.electricInput.test(M(e.doc,i.head.line).text.slice(0,i.head.ch))&&(l=Yo(e,i.head.line,"smart"));l&&bt(e,"electricInput",e,i.head.line)}}}function Qo(e){for(var t=[],r=[],n=0;n<e.doc.sel.ranges.length;n++){var i=e.doc.sel.ranges[n].head.line,o={anchor:E(i,0),head:E(i+1,0)};r.push(o),t.push(e.getRange(o.anchor,o.head))}return{text:t,ranges:r}}function Jo(e,t){e.setAttribute("autocorrect","off"),e.setAttribute("autocapitalize","off"),e.setAttribute("spellcheck",!!t)}function el(){var e=n("textarea",null,null,"position: absolute; bottom: -1em; padding: 0; width: 1px; height: 1em; outline: none"),t=n("div",[e],null,"overflow: hidden; position: relative; width: 3px; height: 0px;");return ml?e.style.width="1000px":e.setAttribute("wrap","off"),Ll&&(e.style.border="1px solid black"),Jo(e),t}function tl(e,t,r,n,i){function o(){var n=t.line+r;return!(n<e.first||n>=e.first+e.size)&&(t=new E(n,t.ch,t.sticky),u=M(e,n))}function l(n){var l;if(null==(l=i?go(e.cm,u,t,r):ho(u,t,r))){if(n||!o())return!1;t=po(i,e.cm,u,t.line,r)}else t=l;return!0}var s=t,a=r,u=M(e,t.line);if("char"==n)l();else if("column"==n)l(!0);else if("word"==n||"group"==n)for(var c=null,f="group"==n,h=e.cm&&e.cm.getHelper(t,"wordChars"),d=!0;!(r<0)||l(!d);d=!1){var p=u.text.charAt(t.ch)||"\n",g=x(p,h)?"w":f&&"\n"==p?"n":!f||/\s/.test(p)?null:"p";if(!f||d||g||(g="s"),c&&c!=g){r<0&&(r=1,l(),t.sticky="after");break}if(g&&(c=g),r>0&&!l(!d))break}var v=ki(e,t,s,a,!0);return I(s,v)&&(v.hitSide=!0),v}function rl(e,t,r,n){var i,o=e.doc,l=t.left;if("page"==n){var s=Math.min(e.display.wrapper.clientHeight,window.innerHeight||document.documentElement.clientHeight),a=Math.max(s-.5*mr(e.display),3);i=(r>0?t.bottom:t.top)+r*a}else"line"==n&&(i=r>0?t.bottom+3:t.top-3);for(var u;(u=cr(e,l,i)).outside;){if(r<0?i<=0:i>=o.height){u.hitSide=!0;break}i+=5*r}return u}function nl(e,t){var r=jt(e,t.line);if(!r||r.hidden)return null;var n=M(e.doc,t.line),i=Ut(r,n,t.line),o=Se(n,e.doc.direction),l="left";o&&(l=Ce(o,t.ch)%2?"right":"left");var s=_t(i.map,t.ch,l);return s.offset="right"==s.collapse?s.end:s.start,s}function il(e){for(var t=e;t;t=t.parentNode)if(/CodeMirror-gutter-wrapper/.test(t.className))return!0;return!1}function ol(e,t){return t&&(e.bad=!0),e}function ll(e,t,r,n,i){function o(e){return function(t){return t.id==e}}function l(){c&&(u+=f,c=!1)}function s(e){e&&(l(),u+=e)}function a(t){if(1==t.nodeType){var r=t.getAttribute("cm-text");if(null!=r)return void s(r||t.textContent.replace(/\u200b/g,""));var u,h=t.getAttribute("cm-marker");if(h){var d=e.findMarks(E(n,0),E(i+1,0),o(+h));return void(d.length&&(u=d[0].find(0))&&s(N(e.doc,u.from,u.to).join(f)))}if("false"==t.getAttribute("contenteditable"))return;var p=/^(pre|div|p)$/i.test(t.nodeName);p&&l();for(var g=0;g<t.childNodes.length;g++)a(t.childNodes[g]);p&&(c=!0)}else 3==t.nodeType&&s(t.nodeValue)}for(var u="",c=!1,f=e.doc.lineSeparator();a(t),t!=r;)t=t.nextSibling;return u}function sl(e,t,r){var n;if(t==e.display.lineDiv){if(!(n=e.display.lineDiv.childNodes[r]))return ol(e.clipPos(E(e.display.viewTo-1)),!0);t=null,r=0}else for(n=t;;n=n.parentNode){if(!n||n==e.display.lineDiv)return null;if(n.parentNode&&n.parentNode==e.display.lineDiv)break}for(var i=0;i<e.display.view.length;i++){var o=e.display.view[i];if(o.node==n)return al(o,t,r)}}function al(e,t,r){function n(t,r,n){for(var i=-1;i<(f?f.length:0);i++)for(var o=i<0?c.map:f[i],l=0;l<o.length;l+=3){var s=o[l+2];if(s==t||s==r){var a=W(i<0?e.line:e.rest[i]),u=o[l]+n;return(n<0||s!=t)&&(u=o[l+(n?1:0)]),E(a,u)}}}var i=e.text.firstChild,l=!1;if(!t||!o(i,t))return ol(E(W(e.line),0),!0);if(t==i&&(l=!0,t=i.childNodes[r],r=0,!t)){var s=e.rest?g(e.rest):e.line;return ol(E(W(s),s.text.length),l)}var a=3==t.nodeType?t:null,u=t;for(a||1!=t.childNodes.length||3!=t.firstChild.nodeType||(a=t.firstChild,r&&(r=a.nodeValue.length));u.parentNode!=i;)u=u.parentNode;var c=e.measure,f=c.maps,h=n(a,u,r);if(h)return ol(h,l);for(var d=u.nextSibling,p=a?a.nodeValue.length-r:0;d;d=d.nextSibling){if(h=n(d,d.firstChild,0))return ol(E(h.line,h.ch-p),l);p+=d.textContent.length}for(var v=u.previousSibling,m=r;v;v=v.previousSibling){if(h=n(v,v.firstChild,-1))return ol(E(h.line,h.ch+m),l);m+=v.textContent.length}}var ul=navigator.userAgent,cl=navigator.platform,fl=/gecko\/\d/i.test(ul),hl=/MSIE \d/.test(ul),dl=/Trident\/(?:[7-9]|\d{2,})\..*rv:(\d+)/.exec(ul),pl=/Edge\/(\d+)/.exec(ul),gl=hl||dl||pl,vl=gl&&(hl?document.documentMode||6:+(pl||dl)[1]),ml=!pl&&/WebKit\//.test(ul),yl=ml&&/Qt\/\d+\.\d+/.test(ul),bl=!pl&&/Chrome\//.test(ul),wl=/Opera\//.test(ul),xl=/Apple Computer/.test(navigator.vendor),Cl=/Mac OS X 1\d\D([8-9]|\d\d)\D/.test(ul),Sl=/PhantomJS/.test(ul),Ll=!pl&&/AppleWebKit/.test(ul)&&/Mobile\/\w+/.test(ul),kl=/Android/.test(ul),Tl=Ll||kl||/webOS|BlackBerry|Opera Mini|Opera Mobi|IEMobile/i.test(ul),Ml=Ll||/Mac/.test(cl),Nl=/\bCrOS\b/.test(ul),Ol=/win/i.test(cl),Al=wl&&ul.match(/Version\/(\d*\.\d*)/);Al&&(Al=Number(Al[1])),Al&&Al>=15&&(wl=!1,ml=!0);var Wl,Dl=Ml&&(yl||wl&&(null==Al||Al<12.11)),Hl=fl||gl&&vl>=9,Fl=function(t,r){var n=t.className,i=e(r).exec(n);if(i){var o=n.slice(i.index+i[0].length);t.className=n.slice(0,i.index)+(o?i[1]+o:"")}};Wl=document.createRange?function(e,t,r,n){var i=document.createRange();return i.setEnd(n||e,r),i.setStart(e,t),i}:function(e,t,r){var n=document.body.createTextRange();try{n.moveToElementText(e.parentNode)}catch(e){return n}return n.collapse(!0),n.moveEnd("character",r),n.moveStart("character",t),n};var El=function(e){e.select()};Ll?El=function(e){e.selectionStart=0,e.selectionEnd=e.value.length}:gl&&(El=function(e){try{e.select()}catch(e){}});var Pl=function(){this.id=null};Pl.prototype.set=function(e,t){clearTimeout(this.id),this.id=setTimeout(t,e)};var Il,zl,Rl=30,Bl={toString:function(){return"CodeMirror.Pass"}},Gl={scroll:!1},Ul={origin:"*mouse"},Vl={origin:"+move"},Kl=[""],jl=/[\u00df\u0587\u0590-\u05f4\u0600-\u06ff\u3040-\u309f\u30a0-\u30ff\u3400-\u4db5\u4e00-\u9fcc\uac00-\ud7af]/,Xl=/[\u0300-\u036f\u0483-\u0489\u0591-\u05bd\u05bf\u05c1\u05c2\u05c4\u05c5\u05c7\u0610-\u061a\u064b-\u065e\u0670\u06d6-\u06dc\u06de-\u06e4\u06e7\u06e8\u06ea-\u06ed\u0711\u0730-\u074a\u07a6-\u07b0\u07eb-\u07f3\u0816-\u0819\u081b-\u0823\u0825-\u0827\u0829-\u082d\u0900-\u0902\u093c\u0941-\u0948\u094d\u0951-\u0955\u0962\u0963\u0981\u09bc\u09be\u09c1-\u09c4\u09cd\u09d7\u09e2\u09e3\u0a01\u0a02\u0a3c\u0a41\u0a42\u0a47\u0a48\u0a4b-\u0a4d\u0a51\u0a70\u0a71\u0a75\u0a81\u0a82\u0abc\u0ac1-\u0ac5\u0ac7\u0ac8\u0acd\u0ae2\u0ae3\u0b01\u0b3c\u0b3e\u0b3f\u0b41-\u0b44\u0b4d\u0b56\u0b57\u0b62\u0b63\u0b82\u0bbe\u0bc0\u0bcd\u0bd7\u0c3e-\u0c40\u0c46-\u0c48\u0c4a-\u0c4d\u0c55\u0c56\u0c62\u0c63\u0cbc\u0cbf\u0cc2\u0cc6\u0ccc\u0ccd\u0cd5\u0cd6\u0ce2\u0ce3\u0d3e\u0d41-\u0d44\u0d4d\u0d57\u0d62\u0d63\u0dca\u0dcf\u0dd2-\u0dd4\u0dd6\u0ddf\u0e31\u0e34-\u0e3a\u0e47-\u0e4e\u0eb1\u0eb4-\u0eb9\u0ebb\u0ebc\u0ec8-\u0ecd\u0f18\u0f19\u0f35\u0f37\u0f39\u0f71-\u0f7e\u0f80-\u0f84\u0f86\u0f87\u0f90-\u0f97\u0f99-\u0fbc\u0fc6\u102d-\u1030\u1032-\u1037\u1039\u103a\u103d\u103e\u1058\u1059\u105e-\u1060\u1071-\u1074\u1082\u1085\u1086\u108d\u109d\u135f\u1712-\u1714\u1732-\u1734\u1752\u1753\u1772\u1773\u17b7-\u17bd\u17c6\u17c9-\u17d3\u17dd\u180b-\u180d\u18a9\u1920-\u1922\u1927\u1928\u1932\u1939-\u193b\u1a17\u1a18\u1a56\u1a58-\u1a5e\u1a60\u1a62\u1a65-\u1a6c\u1a73-\u1a7c\u1a7f\u1b00-\u1b03\u1b34\u1b36-\u1b3a\u1b3c\u1b42\u1b6b-\u1b73\u1b80\u1b81\u1ba2-\u1ba5\u1ba8\u1ba9\u1c2c-\u1c33\u1c36\u1c37\u1cd0-\u1cd2\u1cd4-\u1ce0\u1ce2-\u1ce8\u1ced\u1dc0-\u1de6\u1dfd-\u1dff\u200c\u200d\u20d0-\u20f0\u2cef-\u2cf1\u2de0-\u2dff\u302a-\u302f\u3099\u309a\ua66f-\ua672\ua67c\ua67d\ua6f0\ua6f1\ua802\ua806\ua80b\ua825\ua826\ua8c4\ua8e0-\ua8f1\ua926-\ua92d\ua947-\ua951\ua980-\ua982\ua9b3\ua9b6-\ua9b9\ua9bc\uaa29-\uaa2e\uaa31\uaa32\uaa35\uaa36\uaa43\uaa4c\uaab0\uaab2-\uaab4\uaab7\uaab8\uaabe\uaabf\uaac1\uabe5\uabe8\uabed\udc00-\udfff\ufb1e\ufe00-\ufe0f\ufe20-\ufe26\uff9e\uff9f]/,Yl=!1,_l=!1,$l=null,ql=function(){function e(e){return e<=247?r.charAt(e):1424<=e&&e<=1524?"R":1536<=e&&e<=1785?n.charAt(e-1536):1774<=e&&e<=2220?"r":8192<=e&&e<=8203?"w":8204==e?"b":"L"}function t(e,t,r){this.level=e,this.from=t,this.to=r}var r="bbbbbbbbbtstwsbbbbbbbbbbbbbbssstwNN%%%NNNNNN,N,N1111111111NNNNNNNLLLLLLLLLLLLLLLLLLLLLLLLLLNNNNNNLLLLLLLLLLLLLLLLLLLLLLLLLLNNNNbbbbbbsbbbbbbbbbbbbbbbbbbbbbbbbbb,N%%%%NNNNLNNNNN%%11NLNNN1LNNNNNLLLLLLLLLLLLLLLLLLLLLLLNLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLN",n="nnnnnnNNr%%r,rNNmmmmmmmmmmmrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrmmmmmmmmmmmmmmmmmmmmmnnnnnnnnnn%nnrrrmrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrmmmmmmmnNmmmmmmrrmmNmmmmrr1111111111",i=/[\u0590-\u05f4\u0600-\u06ff\u0700-\u08ac]/,o=/[stwN]/,l=/[LRr]/,s=/[Lb1n]/,a=/[1n]/;return function(r,n){var u="ltr"==n?"L":"R";if(0==r.length||"ltr"==n&&!i.test(r))return!1;for(var c=r.length,f=[],h=0;h<c;++h)f.push(e(r.charCodeAt(h)));for(var d=0,p=u;d<c;++d){var v=f[d];"m"==v?f[d]=p:p=v}for(var m=0,y=u;m<c;++m){var b=f[m];"1"==b&&"r"==y?f[m]="n":l.test(b)&&(y=b,"r"==b&&(f[m]="R"))}for(var w=1,x=f[0];w<c-1;++w){var C=f[w];"+"==C&&"1"==x&&"1"==f[w+1]?f[w]="1":","!=C||x!=f[w+1]||"1"!=x&&"n"!=x||(f[w]=x),x=C}for(var S=0;S<c;++S){var L=f[S];if(","==L)f[S]="N";else if("%"==L){var k=void 0;for(k=S+1;k<c&&"%"==f[k];++k);for(var T=S&&"!"==f[S-1]||k<c&&"1"==f[k]?"1":"N",M=S;M<k;++M)f[M]=T;S=k-1}}for(var N=0,O=u;N<c;++N){var A=f[N];"L"==O&&"1"==A?f[N]="L":l.test(A)&&(O=A)}for(var W=0;W<c;++W)if(o.test(f[W])){var D=void 0;for(D=W+1;D<c&&o.test(f[D]);++D);for(var H="L"==(W?f[W-1]:u),F=H==("L"==(D<c?f[D]:u))?H?"L":"R":u,E=W;E<D;++E)f[E]=F;W=D-1}for(var P,I=[],z=0;z<c;)if(s.test(f[z])){var R=z;for(++z;z<c&&s.test(f[z]);++z);I.push(new t(0,R,z))}else{var B=z,G=I.length;for(++z;z<c&&"L"!=f[z];++z);for(var U=B;U<z;)if(a.test(f[U])){B<U&&I.splice(G,0,new t(1,B,U));var V=U;for(++U;U<z&&a.test(f[U]);++U);I.splice(G,0,new t(2,V,U)),B=U}else++U;B<z&&I.splice(G,0,new t(1,B,z))}return 1==I[0].level&&(P=r.match(/^\s+/))&&(I[0].from=P[0].length,I.unshift(new t(0,0,P[0].length))),1==g(I).level&&(P=r.match(/\s+$/))&&(g(I).to-=P[0].length,I.push(new t(0,c-P[0].length,c))),"rtl"==n?I.reverse():I}}(),Zl=[],Ql=function(e,t,r){if(e.addEventListener)e.addEventListener(t,r,!1);else if(e.attachEvent)e.attachEvent("on"+t,r);else{var n=e._handlers||(e._handlers={});n[t]=(n[t]||Zl).concat(r)}},Jl=function(){if(gl&&vl<9)return!1;var e=n("div");return"draggable"in e||"dragDrop"in e}(),es=3!="\n\nb".split(/\n/).length?function(e){for(var t=0,r=[],n=e.length;t<=n;){var i=e.indexOf("\n",t);-1==i&&(i=e.length);var o=e.slice(t,"\r"==e.charAt(i-1)?i-1:i),l=o.indexOf("\r");-1!=l?(r.push(o.slice(0,l)),t+=l+1):(r.push(o),t=i+1)}return r}:function(e){return e.split(/\r\n?|\n/)},ts=window.getSelection?function(e){try{return e.selectionStart!=e.selectionEnd}catch(e){return!1}}:function(e){var t;try{t=e.ownerDocument.selection.createRange()}catch(e){}return!(!t||t.parentElement()!=e)&&0!=t.compareEndPoints("StartToEnd",t)},rs=function(){var e=n("div");return"oncopy"in e||(e.setAttribute("oncopy","return;"),"function"==typeof e.oncopy)}(),ns=null,is={},os={},ls={},ss=function(e,t,r){this.pos=this.start=0,this.string=e,this.tabSize=t||8,this.lastColumnPos=this.lastColumnValue=0,this.lineStart=0,this.lineOracle=r};ss.prototype.eol=function(){return this.pos>=this.string.length},ss.prototype.sol=function(){return this.pos==this.lineStart},ss.prototype.peek=function(){return this.string.charAt(this.pos)||void 0},ss.prototype.next=function(){if(this.pos<this.string.length)return this.string.charAt(this.pos++)},ss.prototype.eat=function(e){var t=this.string.charAt(this.pos);if("string"==typeof e?t==e:t&&(e.test?e.test(t):e(t)))return++this.pos,t},ss.prototype.eatWhile=function(e){for(var t=this.pos;this.eat(e););return this.pos>t},ss.prototype.eatSpace=function(){for(var e=this,t=this.pos;/[\s\u00a0]/.test(this.string.charAt(this.pos));)++e.pos;return this.pos>t},ss.prototype.skipToEnd=function(){this.pos=this.string.length},ss.prototype.skipTo=function(e){var t=this.string.indexOf(e,this.pos);if(t>-1)return this.pos=t,!0},ss.prototype.backUp=function(e){this.pos-=e},ss.prototype.column=function(){return this.lastColumnPos<this.start&&(this.lastColumnValue=f(this.string,this.start,this.tabSize,this.lastColumnPos,this.lastColumnValue),this.lastColumnPos=this.start),this.lastColumnValue-(this.lineStart?f(this.string,this.lineStart,this.tabSize):0)},ss.prototype.indentation=function(){return f(this.string,null,this.tabSize)-(this.lineStart?f(this.string,this.lineStart,this.tabSize):0)},ss.prototype.match=function(e,t,r){if("string"!=typeof e){var n=this.string.slice(this.pos).match(e);return n&&n.index>0?null:(n&&!1!==t&&(this.pos+=n[0].length),n)}var i=function(e){return r?e.toLowerCase():e};if(i(this.string.substr(this.pos,e.length))==i(e))return!1!==t&&(this.pos+=e.length),!0},ss.prototype.current=function(){return this.string.slice(this.start,this.pos)},ss.prototype.hideFirstChars=function(e,t){this.lineStart+=e;try{return t()}finally{this.lineStart-=e}},ss.prototype.lookAhead=function(e){var t=this.lineOracle;return t&&t.lookAhead(e)};var as=function(e,t){this.state=e,this.lookAhead=t},us=function(e,t,r,n){this.state=t,this.doc=e,this.line=r,this.maxLookAhead=n||0};us.prototype.lookAhead=function(e){var t=this.doc.getLine(this.line+e);return null!=t&&e>this.maxLookAhead&&(this.maxLookAhead=e),t},us.prototype.nextLine=function(){this.line++,this.maxLookAhead>0&&this.maxLookAhead--},us.fromSaved=function(e,t,r){return t instanceof as?new us(e,Ke(e.mode,t.state),r,t.lookAhead):new us(e,Ke(e.mode,t),r)},us.prototype.save=function(e){var t=!1!==e?Ke(this.doc.mode,this.state):this.state;return this.maxLookAhead>0?new as(t,this.maxLookAhead):t};var cs=function(e,t,r){this.start=e.start,this.end=e.pos,this.string=e.current(),this.type=t||null,this.state=r},fs=function(e,t,r){this.text=e,ne(this,t),this.height=r?r(this):1};fs.prototype.lineNo=function(){return W(this)},Ae(fs);var hs,ds={},ps={},gs=null,vs=null,ms={left:0,right:0,top:0,bottom:0},ys=function(e,t,r){this.cm=r;var i=this.vert=n("div",[n("div",null,null,"min-width: 1px")],"CodeMirror-vscrollbar"),o=this.horiz=n("div",[n("div",null,null,"height: 100%; min-height: 1px")],"CodeMirror-hscrollbar");e(i),e(o),Ql(i,"scroll",function(){i.clientHeight&&t(i.scrollTop,"vertical")}),Ql(o,"scroll",function(){o.clientWidth&&t(o.scrollLeft,"horizontal")}),this.checkedZeroWidth=!1,gl&&vl<8&&(this.horiz.style.minHeight=this.vert.style.minWidth="18px")};ys.prototype.update=function(e){var t=e.scrollWidth>e.clientWidth+1,r=e.scrollHeight>e.clientHeight+1,n=e.nativeBarWidth;if(r){this.vert.style.display="block",this.vert.style.bottom=t?n+"px":"0";var i=e.viewHeight-(t?n:0);this.vert.firstChild.style.height=Math.max(0,e.scrollHeight-e.clientHeight+i)+"px"}else this.vert.style.display="",this.vert.firstChild.style.height="0";if(t){this.horiz.style.display="block",this.horiz.style.right=r?n+"px":"0",this.horiz.style.left=e.barLeft+"px";var o=e.viewWidth-e.barLeft-(r?n:0);this.horiz.firstChild.style.width=Math.max(0,e.scrollWidth-e.clientWidth+o)+"px"}else this.horiz.style.display="",this.horiz.firstChild.style.width="0";return!this.checkedZeroWidth&&e.clientHeight>0&&(0==n&&this.zeroWidthHack(),this.checkedZeroWidth=!0),{right:r?n:0,bottom:t?n:0}},ys.prototype.setScrollLeft=function(e){this.horiz.scrollLeft!=e&&(this.horiz.scrollLeft=e),this.disableHoriz&&this.enableZeroWidthBar(this.horiz,this.disableHoriz,"horiz")},ys.prototype.setScrollTop=function(e){this.vert.scrollTop!=e&&(this.vert.scrollTop=e),this.disableVert&&this.enableZeroWidthBar(this.vert,this.disableVert,"vert")},ys.prototype.zeroWidthHack=function(){var e=Ml&&!Cl?"12px":"18px";this.horiz.style.height=this.vert.style.width=e,this.horiz.style.pointerEvents=this.vert.style.pointerEvents="none",this.disableHoriz=new Pl,this.disableVert=new Pl},ys.prototype.enableZeroWidthBar=function(e,t,r){function n(){var i=e.getBoundingClientRect();("vert"==r?document.elementFromPoint(i.right-1,(i.top+i.bottom)/2):document.elementFromPoint((i.right+i.left)/2,i.bottom-1))!=e?e.style.pointerEvents="none":t.set(1e3,n)}e.style.pointerEvents="auto",t.set(1e3,n)},ys.prototype.clear=function(){var e=this.horiz.parentNode;e.removeChild(this.horiz),e.removeChild(this.vert)};var bs=function(){};bs.prototype.update=function(){return{bottom:0,right:0}},bs.prototype.setScrollLeft=function(){},bs.prototype.setScrollTop=function(){},bs.prototype.clear=function(){};var ws={native:ys,null:bs},xs=0,Cs=function(e,t,r){var n=e.display;this.viewport=t,this.visible=Ir(n,e.doc,t),this.editorIsHidden=!n.wrapper.offsetWidth,this.wrapperHeight=n.wrapper.clientHeight,this.wrapperWidth=n.wrapper.clientWidth,this.oldDisplayWidth=Rt(e),this.force=r,this.dims=br(e),this.events=[]};Cs.prototype.signal=function(e,t){Oe(e,t)&&this.events.push(arguments)},Cs.prototype.finish=function(){for(var e=this,t=0;t<this.events.length;t++)Te.apply(null,e.events[t])};var Ss=0,Ls=null;gl?Ls=-.53:fl?Ls=15:bl?Ls=-.7:xl&&(Ls=-1/3);var ks=function(e,t){this.ranges=e,this.primIndex=t};ks.prototype.primary=function(){return this.ranges[this.primIndex]},ks.prototype.equals=function(e){var t=this;if(e==this)return!0;if(e.primIndex!=this.primIndex||e.ranges.length!=this.ranges.length)return!1;for(var r=0;r<this.ranges.length;r++){var n=t.ranges[r],i=e.ranges[r];if(!I(n.anchor,i.anchor)||!I(n.head,i.head))return!1}return!0},ks.prototype.deepCopy=function(){for(var e=this,t=[],r=0;r<this.ranges.length;r++)t[r]=new Ts(z(e.ranges[r].anchor),z(e.ranges[r].head));return new ks(t,this.primIndex)},ks.prototype.somethingSelected=function(){for(var e=this,t=0;t<this.ranges.length;t++)if(!e.ranges[t].empty())return!0;return!1},ks.prototype.contains=function(e,t){var r=this;t||(t=e);for(var n=0;n<this.ranges.length;n++){var i=r.ranges[n];if(P(t,i.from())>=0&&P(e,i.to())<=0)return n}return-1};var Ts=function(e,t){this.anchor=e,this.head=t};Ts.prototype.from=function(){return B(this.anchor,this.head)},Ts.prototype.to=function(){return R(this.anchor,this.head)},Ts.prototype.empty=function(){return this.head.line==this.anchor.line&&this.head.ch==this.anchor.ch},Bi.prototype={chunkSize:function(){return this.lines.length},removeInner:function(e,t){for(var r=this,n=e,i=e+t;n<i;++n){var o=r.lines[n];r.height-=o.height,ot(o),bt(o,"delete")}this.lines.splice(e,t)},collapse:function(e){e.push.apply(e,this.lines)},insertInner:function(e,t,r){var n=this;this.height+=r,this.lines=this.lines.slice(0,e).concat(t).concat(this.lines.slice(e));for(var i=0;i<t.length;++i)t[i].parent=n},iterN:function(e,t,r){for(var n=this,i=e+t;e<i;++e)if(r(n.lines[e]))return!0}},Gi.prototype={chunkSize:function(){return this.size},removeInner:function(e,t){var r=this;this.size-=t;for(var n=0;n<this.children.length;++n){var i=r.children[n],o=i.chunkSize();if(e<o){var l=Math.min(t,o-e),s=i.height;if(i.removeInner(e,l),r.height-=s-i.height,o==l&&(r.children.splice(n--,1),i.parent=null),0==(t-=l))break;e=0}else e-=o}if(this.size-t<25&&(this.children.length>1||!(this.children[0]instanceof Bi))){var a=[];this.collapse(a),this.children=[new Bi(a)],this.children[0].parent=this}},collapse:function(e){for(var t=this,r=0;r<this.children.length;++r)t.children[r].collapse(e)},insertInner:function(e,t,r){var n=this;this.size+=t.length,this.height+=r;for(var i=0;i<this.children.length;++i){var o=n.children[i],l=o.chunkSize();if(e<=l){if(o.insertInner(e,t,r),o.lines&&o.lines.length>50){for(var s=o.lines.length%25+25,a=s;a<o.lines.length;){var u=new Bi(o.lines.slice(a,a+=25));o.height-=u.height,n.children.splice(++i,0,u),u.parent=n}o.lines=o.lines.slice(0,s),n.maybeSpill()}break}e-=l}},maybeSpill:function(){if(!(this.children.length<=10)){var e=this;do{var t=new Gi(e.children.splice(e.children.length-5,5));if(e.parent){e.size-=t.size,e.height-=t.height;var r=h(e.parent.children,e);e.parent.children.splice(r+1,0,t)}else{var n=new Gi(e.children);n.parent=e,e.children=[n,t],e=n}t.parent=e.parent}while(e.children.length>10);e.parent.maybeSpill()}},iterN:function(e,t,r){for(var n=this,i=0;i<this.children.length;++i){var o=n.children[i],l=o.chunkSize();if(e<l){var s=Math.min(t,l-e);if(o.iterN(e,s,r))return!0;if(0==(t-=s))break;e=0}else e-=l}}};var Ms=function(e,t,r){var n=this;if(r)for(var i in r)r.hasOwnProperty(i)&&(n[i]=r[i]);this.doc=e,this.node=t};Ms.prototype.clear=function(){var e=this,t=this.doc.cm,r=this.line.widgets,n=this.line,i=W(n);if(null!=i&&r){for(var o=0;o<r.length;++o)r[o]==e&&r.splice(o--,1);r.length||(n.widgets=null);var l=Ht(this);A(n,Math.max(0,n.height-l)),t&&(hn(t,function(){Ui(t,n,-l),mn(t,i,"widget")}),bt(t,"lineWidgetCleared",t,this,i))}},Ms.prototype.changed=function(){var e=this,t=this.height,r=this.doc.cm,n=this.line;this.height=null;var i=Ht(this)-t;i&&(A(n,n.height+i),r&&hn(r,function(){r.curOp.forceUpdate=!0,Ui(r,n,i),bt(r,"lineWidgetChanged",r,e,W(n))}))},Ae(Ms);var Ns=0,Os=function(e,t){this.lines=[],this.type=t,this.doc=e,this.id=++Ns};Os.prototype.clear=function(){var e=this;if(!this.explicitlyCleared){var t=this.doc.cm,r=t&&!t.curOp;if(r&&nn(t),Oe(this,"clear")){var n=this.find();n&&bt(this,"clear",n.from,n.to)}for(var i=null,o=null,l=0;l<this.lines.length;++l){var s=e.lines[l],a=_(s.markedSpans,e);t&&!e.collapsed?mn(t,W(s),"text"):t&&(null!=a.to&&(o=W(s)),null!=a.from&&(i=W(s))),s.markedSpans=$(s.markedSpans,a),null==a.from&&e.collapsed&&!ve(e.doc,s)&&t&&A(s,mr(t.display))}if(t&&this.collapsed&&!t.options.lineWrapping)for(var u=0;u<this.lines.length;++u){var c=fe(e.lines[u]),f=be(c);f>t.display.maxLineLength&&(t.display.maxLine=c,t.display.maxLineLength=f,t.display.maxLineChanged=!0)}null!=i&&t&&this.collapsed&&vn(t,i,o+1),this.lines.length=0,this.explicitlyCleared=!0,this.atomic&&this.doc.cantEdit&&(this.doc.cantEdit=!1,t&&Ci(t.doc)),t&&bt(t,"markerCleared",t,this,i,o),r&&on(t),this.parent&&this.parent.clear()}},Os.prototype.find=function(e,t){var r=this;null==e&&"bookmark"==this.type&&(e=1);for(var n,i,o=0;o<this.lines.length;++o){var l=r.lines[o],s=_(l.markedSpans,r);if(null!=s.from&&(n=E(t?l:W(l),s.from),-1==e))return n;if(null!=s.to&&(i=E(t?l:W(l),s.to),1==e))return i}return n&&{from:n,to:i}},Os.prototype.changed=function(){var e=this,t=this.find(-1,!0),r=this,n=this.doc.cm;t&&n&&hn(n,function(){var i=t.line,o=W(t.line),l=jt(n,o);if(l&&(Qt(l),n.curOp.selectionChanged=n.curOp.forceUpdate=!0),n.curOp.updateMaxLine=!0,!ve(r.doc,i)&&null!=r.height){var s=r.height;r.height=null;var a=Ht(r)-s;a&&A(i,i.height+a)}bt(n,"markerChanged",n,e)})},Os.prototype.attachLine=function(e){if(!this.lines.length&&this.doc.cm){var t=this.doc.cm.curOp;t.maybeHiddenMarkers&&-1!=h(t.maybeHiddenMarkers,this)||(t.maybeUnhiddenMarkers||(t.maybeUnhiddenMarkers=[])).push(this)}this.lines.push(e)},Os.prototype.detachLine=function(e){if(this.lines.splice(h(this.lines,e),1),!this.lines.length&&this.doc.cm){var t=this.doc.cm.curOp;(t.maybeHiddenMarkers||(t.maybeHiddenMarkers=[])).push(this)}},Ae(Os);var As=function(e,t){var r=this;this.markers=e,this.primary=t;for(var n=0;n<e.length;++n)e[n].parent=r};As.prototype.clear=function(){var e=this;if(!this.explicitlyCleared){this.explicitlyCleared=!0;for(var t=0;t<this.markers.length;++t)e.markers[t].clear();bt(this,"clear")}},As.prototype.find=function(e,t){return this.primary.find(e,t)},Ae(As);var Ws=0,Ds=function(e,t,r,n,i){if(!(this instanceof Ds))return new Ds(e,t,r,n,i);null==r&&(r=0),Gi.call(this,[new Bi([new fs("",null)])]),this.first=r,this.scrollTop=this.scrollLeft=0,this.cantEdit=!1,this.cleanGeneration=1,this.modeFrontier=this.highlightFrontier=r;var o=E(r,0);this.sel=Rn(o),this.history=new Jn(null),this.id=++Ws,this.modeOption=t,this.lineSep=n,this.direction="rtl"==i?"rtl":"ltr",this.extend=!1,"string"==typeof e&&(e=this.splitLines(e)),_n(this,{from:o,to:o,text:e}),bi(this,Rn(o),Gl)};Ds.prototype=b(Gi.prototype,{constructor:Ds,iter:function(e,t,r){r?this.iterN(e-this.first,t-e,r):this.iterN(this.first,this.first+this.size,e)},insert:function(e,t){for(var r=0,n=0;n<t.length;++n)r+=t[n].height;this.insertInner(e-this.first,t,r)},remove:function(e,t){this.removeInner(e-this.first,t)},getValue:function(e){var t=O(this,this.first,this.first+this.size);return!1===e?t:t.join(e||this.lineSeparator())},setValue:gn(function(e){var t=E(this.first,0),r=this.first+this.size-1;Oi(this,{from:t,to:E(r,M(this,r).text.length),text:this.splitLines(e),origin:"setValue",full:!0},!0),this.cm&&Xr(this.cm,0,0),bi(this,Rn(t),Gl)}),replaceRange:function(e,t,r,n){Ei(this,e,t=U(this,t),r=r?U(this,r):t,n)},getRange:function(e,t,r){var n=N(this,U(this,e),U(this,t));return!1===r?n:n.join(r||this.lineSeparator())},getLine:function(e){var t=this.getLineHandle(e);return t&&t.text},getLineHandle:function(e){if(H(this,e))return M(this,e)},getLineNumber:function(e){return W(e)},getLineHandleVisualStart:function(e){return"number"==typeof e&&(e=M(this,e)),fe(e)},lineCount:function(){return this.size},firstLine:function(){return this.first},lastLine:function(){return this.first+this.size-1},clipPos:function(e){return U(this,e)},getCursor:function(e){var t=this.sel.primary();return null==e||"head"==e?t.head:"anchor"==e?t.anchor:"end"==e||"to"==e||!1===e?t.to():t.from()},listSelections:function(){return this.sel.ranges},somethingSelected:function(){return this.sel.somethingSelected()},setCursor:gn(function(e,t,r){vi(this,U(this,"number"==typeof e?E(e,t||0):e),null,r)}),setSelection:gn(function(e,t,r){vi(this,U(this,e),U(this,t||e),r)}),extendSelection:gn(function(e,t,r){di(this,U(this,e),t&&U(this,t),r)}),extendSelections:gn(function(e,t){pi(this,K(this,e),t)}),extendSelectionsBy:gn(function(e,t){pi(this,K(this,v(this.sel.ranges,e)),t)}),setSelections:gn(function(e,t,r){var n=this;if(e.length){for(var i=[],o=0;o<e.length;o++)i[o]=new Ts(U(n,e[o].anchor),U(n,e[o].head));null==t&&(t=Math.min(e.length-1,this.sel.primIndex)),bi(this,zn(i,t),r)}}),addSelection:gn(function(e,t,r){var n=this.sel.ranges.slice(0);n.push(new Ts(U(this,e),U(this,t||e))),bi(this,zn(n,n.length-1),r)}),getSelection:function(e){for(var t,r=this,n=this.sel.ranges,i=0;i<n.length;i++){var o=N(r,n[i].from(),n[i].to());t=t?t.concat(o):o}return!1===e?t:t.join(e||this.lineSeparator())},getSelections:function(e){for(var t=this,r=[],n=this.sel.ranges,i=0;i<n.length;i++){var o=N(t,n[i].from(),n[i].to());!1!==e&&(o=o.join(e||t.lineSeparator())),r[i]=o}return r},replaceSelection:function(e,t,r){for(var n=[],i=0;i<this.sel.ranges.length;i++)n[i]=e;this.replaceSelections(n,t,r||"+input")},replaceSelections:gn(function(e,t,r){for(var n=this,i=[],o=this.sel,l=0;l<o.ranges.length;l++){var s=o.ranges[l];i[l]={from:s.from(),to:s.to(),text:n.splitLines(e[l]),origin:r}}for(var a=t&&"end"!=t&&Kn(this,i,t),u=i.length-1;u>=0;u--)Oi(n,i[u]);a?yi(this,a):this.cm&&jr(this.cm)}),undo:gn(function(){Wi(this,"undo")}),redo:gn(function(){Wi(this,"redo")}),undoSelection:gn(function(){Wi(this,"undo",!0)}),redoSelection:gn(function(){Wi(this,"redo",!0)}),setExtending:function(e){this.extend=e},getExtending:function(){return this.extend},historySize:function(){for(var e=this.history,t=0,r=0,n=0;n<e.done.length;n++)e.done[n].ranges||++t;for(var i=0;i<e.undone.length;i++)e.undone[i].ranges||++r;return{undo:t,redo:r}},clearHistory:function(){this.history=new Jn(this.history.maxGeneration)},markClean:function(){this.cleanGeneration=this.changeGeneration(!0)},changeGeneration:function(e){return e&&(this.history.lastOp=this.history.lastSelOp=this.history.lastOrigin=null),this.history.generation},isClean:function(e){return this.history.generation==(e||this.cleanGeneration)},getHistory:function(){return{done:fi(this.history.done),undone:fi(this.history.undone)}},setHistory:function(e){var t=this.history=new Jn(this.history.maxGeneration);t.done=fi(e.done.slice(0),null,!0),t.undone=fi(e.undone.slice(0),null,!0)},setGutterMarker:gn(function(e,t,r){return Ri(this,e,"gutter",function(e){var n=e.gutterMarkers||(e.gutterMarkers={});return n[t]=r,!r&&C(n)&&(e.gutterMarkers=null),!0})}),clearGutter:gn(function(e){var t=this;this.iter(function(r){r.gutterMarkers&&r.gutterMarkers[e]&&Ri(t,r,"gutter",function(){return r.gutterMarkers[e]=null,C(r.gutterMarkers)&&(r.gutterMarkers=null),!0})})}),lineInfo:function(e){var t;if("number"==typeof e){if(!H(this,e))return null;if(t=e,!(e=M(this,e)))return null}else if(null==(t=W(e)))return null;return{line:t,handle:e,text:e.text,gutterMarkers:e.gutterMarkers,textClass:e.textClass,bgClass:e.bgClass,wrapClass:e.wrapClass,widgets:e.widgets}},addLineClass:gn(function(t,r,n){return Ri(this,t,"gutter"==r?"gutter":"class",function(t){var i="text"==r?"textClass":"background"==r?"bgClass":"gutter"==r?"gutterClass":"wrapClass";if(t[i]){if(e(n).test(t[i]))return!1;t[i]+=" "+n}else t[i]=n;return!0})}),removeLineClass:gn(function(t,r,n){return Ri(this,t,"gutter"==r?"gutter":"class",function(t){var i="text"==r?"textClass":"background"==r?"bgClass":"gutter"==r?"gutterClass":"wrapClass",o=t[i];if(!o)return!1;if(null==n)t[i]=null;else{var l=o.match(e(n));if(!l)return!1;var s=l.index+l[0].length;t[i]=o.slice(0,l.index)+(l.index&&s!=o.length?" ":"")+o.slice(s)||null}return!0})}),addLineWidget:gn(function(e,t,r){return Vi(this,e,t,r)}),removeLineWidget:function(e){e.clear()},markText:function(e,t,r){return Ki(this,U(this,e),U(this,t),r,r&&r.type||"range")},setBookmark:function(e,t){var r={replacedWith:t&&(null==t.nodeType?t.widget:t),insertLeft:t&&t.insertLeft,clearWhenEmpty:!1,shared:t&&t.shared,handleMouseEvents:t&&t.handleMouseEvents};return e=U(this,e),Ki(this,e,e,r,"bookmark")},findMarksAt:function(e){var t=[],r=M(this,(e=U(this,e)).line).markedSpans;if(r)for(var n=0;n<r.length;++n){var i=r[n];(null==i.from||i.from<=e.ch)&&(null==i.to||i.to>=e.ch)&&t.push(i.marker.parent||i.marker)}return t},findMarks:function(e,t,r){e=U(this,e),t=U(this,t);var n=[],i=e.line;return this.iter(e.line,t.line+1,function(o){var l=o.markedSpans;if(l)for(var s=0;s<l.length;s++){var a=l[s];null!=a.to&&i==e.line&&e.ch>=a.to||null==a.from&&i!=e.line||null!=a.from&&i==t.line&&a.from>=t.ch||r&&!r(a.marker)||n.push(a.marker.parent||a.marker)}++i}),n},getAllMarks:function(){var e=[];return this.iter(function(t){var r=t.markedSpans;if(r)for(var n=0;n<r.length;++n)null!=r[n].from&&e.push(r[n].marker)}),e},posFromIndex:function(e){var t,r=this.first,n=this.lineSeparator().length;return this.iter(function(i){var o=i.text.length+n;if(o>e)return t=e,!0;e-=o,++r}),U(this,E(r,t))},indexFromPos:function(e){var t=(e=U(this,e)).ch;if(e.line<this.first||e.ch<0)return 0;var r=this.lineSeparator().length;return this.iter(this.first,e.line,function(e){t+=e.text.length+r}),t},copy:function(e){var t=new Ds(O(this,this.first,this.first+this.size),this.modeOption,this.first,this.lineSep,this.direction);return t.scrollTop=this.scrollTop,t.scrollLeft=this.scrollLeft,t.sel=this.sel,t.extend=!1,e&&(t.history.undoDepth=this.history.undoDepth,t.setHistory(this.getHistory())),t},linkedDoc:function(e){e||(e={});var t=this.first,r=this.first+this.size;null!=e.from&&e.from>t&&(t=e.from),null!=e.to&&e.to<r&&(r=e.to);var n=new Ds(O(this,t,r),e.mode||this.modeOption,t,this.lineSep,this.direction);return e.sharedHist&&(n.history=this.history),(this.linked||(this.linked=[])).push({doc:n,sharedHist:e.sharedHist}),n.linked=[{doc:this,isParent:!0,sharedHist:e.sharedHist}],Yi(n,Xi(this)),n},unlinkDoc:function(e){var t=this;if(e instanceof jo&&(e=e.doc),this.linked)for(var r=0;r<this.linked.length;++r)if(t.linked[r].doc==e){t.linked.splice(r,1),e.unlinkDoc(t),_i(Xi(t));break}if(e.history==this.history){var n=[e.id];$n(e,function(e){return n.push(e.id)},!0),e.history=new Jn(null),e.history.done=fi(this.history.done,n),e.history.undone=fi(this.history.undone,n)}},iterLinkedDocs:function(e){$n(this,e)},getMode:function(){return this.mode},getEditor:function(){return this.cm},splitLines:function(e){return this.lineSep?e.split(this.lineSep):es(e)},lineSeparator:function(){return this.lineSep||"\n"},setDirection:gn(function(e){"rtl"!=e&&(e="ltr"),e!=this.direction&&(this.direction=e,this.iter(function(e){return e.order=null}),this.cm&&Qn(this.cm))})}),Ds.prototype.eachLine=Ds.prototype.iter;for(var Hs=0,Fs=!1,Es={3:"Enter",8:"Backspace",9:"Tab",13:"Enter",16:"Shift",17:"Ctrl",18:"Alt",19:"Pause",20:"CapsLock",27:"Esc",32:"Space",33:"PageUp",34:"PageDown",35:"End",36:"Home",37:"Left",38:"Up",39:"Right",40:"Down",44:"PrintScrn",45:"Insert",46:"Delete",59:";",61:"=",91:"Mod",92:"Mod",93:"Mod",106:"*",107:"=",109:"-",110:".",111:"/",127:"Delete",173:"-",186:";",187:"=",188:",",189:"-",190:".",191:"/",192:"`",219:"[",220:"\\",221:"]",222:"'",63232:"Up",63233:"Down",63234:"Left",63235:"Right",63272:"Delete",63273:"Home",63275:"End",63276:"PageUp",63277:"PageDown",63302:"Insert"},Ps=0;Ps<10;Ps++)Es[Ps+48]=Es[Ps+96]=String(Ps);for(var Is=65;Is<=90;Is++)Es[Is]=String.fromCharCode(Is);for(var zs=1;zs<=12;zs++)Es[zs+111]=Es[zs+63235]="F"+zs;var Rs={};Rs.basic={Left:"goCharLeft",Right:"goCharRight",Up:"goLineUp",Down:"goLineDown",End:"goLineEnd",Home:"goLineStartSmart",PageUp:"goPageUp",PageDown:"goPageDown",Delete:"delCharAfter",Backspace:"delCharBefore","Shift-Backspace":"delCharBefore",Tab:"defaultTab","Shift-Tab":"indentAuto",Enter:"newlineAndIndent",Insert:"toggleOverwrite",Esc:"singleSelection"},Rs.pcDefault={"Ctrl-A":"selectAll","Ctrl-D":"deleteLine","Ctrl-Z":"undo","Shift-Ctrl-Z":"redo","Ctrl-Y":"redo","Ctrl-Home":"goDocStart","Ctrl-End":"goDocEnd","Ctrl-Up":"goLineUp","Ctrl-Down":"goLineDown","Ctrl-Left":"goGroupLeft","Ctrl-Right":"goGroupRight","Alt-Left":"goLineStart","Alt-Right":"goLineEnd","Ctrl-Backspace":"delGroupBefore","Ctrl-Delete":"delGroupAfter","Ctrl-S":"save","Ctrl-F":"find","Ctrl-G":"findNext","Shift-Ctrl-G":"findPrev","Shift-Ctrl-F":"replace","Shift-Ctrl-R":"replaceAll","Ctrl-[":"indentLess","Ctrl-]":"indentMore","Ctrl-U":"undoSelection","Shift-Ctrl-U":"redoSelection","Alt-U":"redoSelection",fallthrough:"basic"},Rs.emacsy={"Ctrl-F":"goCharRight","Ctrl-B":"goCharLeft","Ctrl-P":"goLineUp","Ctrl-N":"goLineDown","Alt-F":"goWordRight","Alt-B":"goWordLeft","Ctrl-A":"goLineStart","Ctrl-E":"goLineEnd","Ctrl-V":"goPageDown","Shift-Ctrl-V":"goPageUp","Ctrl-D":"delCharAfter","Ctrl-H":"delCharBefore","Alt-D":"delWordAfter","Alt-Backspace":"delWordBefore","Ctrl-K":"killLine","Ctrl-T":"transposeChars","Ctrl-O":"openLine"},Rs.macDefault={"Cmd-A":"selectAll","Cmd-D":"deleteLine","Cmd-Z":"undo","Shift-Cmd-Z":"redo","Cmd-Y":"redo","Cmd-Home":"goDocStart","Cmd-Up":"goDocStart","Cmd-End":"goDocEnd","Cmd-Down":"goDocEnd","Alt-Left":"goGroupLeft","Alt-Right":"goGroupRight","Cmd-Left":"goLineLeft","Cmd-Right":"goLineRight","Alt-Backspace":"delGroupBefore","Ctrl-Alt-Backspace":"delGroupAfter","Alt-Delete":"delGroupAfter","Cmd-S":"save","Cmd-F":"find","Cmd-G":"findNext","Shift-Cmd-G":"findPrev","Cmd-Alt-F":"replace","Shift-Cmd-Alt-F":"replaceAll","Cmd-[":"indentLess","Cmd-]":"indentMore","Cmd-Backspace":"delWrappedLineLeft","Cmd-Delete":"delWrappedLineRight","Cmd-U":"undoSelection","Shift-Cmd-U":"redoSelection","Ctrl-Up":"goDocStart","Ctrl-Down":"goDocEnd",fallthrough:["basic","emacsy"]},Rs.default=Ml?Rs.macDefault:Rs.pcDefault;var Bs={selectAll:Mi,singleSelection:function(e){return e.setSelection(e.getCursor("anchor"),e.getCursor("head"),Gl)},killLine:function(e){return co(e,function(t){if(t.empty()){var r=M(e.doc,t.head.line).text.length;return t.head.ch==r&&t.head.line<e.lastLine()?{from:t.head,to:E(t.head.line+1,0)}:{from:t.head,to:E(t.head.line,r)}}return{from:t.from(),to:t.to()}})},deleteLine:function(e){return co(e,function(t){return{from:E(t.from().line,0),to:U(e.doc,E(t.to().line+1,0))}})},delLineLeft:function(e){return co(e,function(e){return{from:E(e.from().line,0),to:e.from()}})},delWrappedLineLeft:function(e){return co(e,function(t){var r=e.charCoords(t.head,"div").top+5;return{from:e.coordsChar({left:0,top:r},"div"),to:t.from()}})},delWrappedLineRight:function(e){return co(e,function(t){var r=e.charCoords(t.head,"div").top+5,n=e.coordsChar({left:e.display.lineDiv.offsetWidth+100,top:r},"div");return{from:t.from(),to:n}})},undo:function(e){return e.undo()},redo:function(e){return e.redo()},undoSelection:function(e){return e.undoSelection()},redoSelection:function(e){return e.redoSelection()},goDocStart:function(e){return e.extendSelection(E(e.firstLine(),0))},goDocEnd:function(e){return e.extendSelection(E(e.lastLine()))},goLineStart:function(e){return e.extendSelectionsBy(function(t){return vo(e,t.head.line)},{origin:"+move",bias:1})},goLineStartSmart:function(e){return e.extendSelectionsBy(function(t){return yo(e,t.head)},{origin:"+move",bias:1})},goLineEnd:function(e){return e.extendSelectionsBy(function(t){return mo(e,t.head.line)},{origin:"+move",bias:-1})},goLineRight:function(e){return e.extendSelectionsBy(function(t){var r=e.cursorCoords(t.head,"div").top+5;return e.coordsChar({left:e.display.lineDiv.offsetWidth+100,top:r},"div")},Vl)},goLineLeft:function(e){return e.extendSelectionsBy(function(t){var r=e.cursorCoords(t.head,"div").top+5;return e.coordsChar({left:0,top:r},"div")},Vl)},goLineLeftSmart:function(e){return e.extendSelectionsBy(function(t){var r=e.cursorCoords(t.head,"div").top+5,n=e.coordsChar({left:0,top:r},"div");return n.ch<e.getLine(n.line).search(/\S/)?yo(e,t.head):n},Vl)},goLineUp:function(e){return e.moveV(-1,"line")},goLineDown:function(e){return e.moveV(1,"line")},goPageUp:function(e){return e.moveV(-1,"page")},goPageDown:function(e){return e.moveV(1,"page")},goCharLeft:function(e){return e.moveH(-1,"char")},goCharRight:function(e){return e.moveH(1,"char")},goColumnLeft:function(e){return e.moveH(-1,"column")},goColumnRight:function(e){return e.moveH(1,"column")},goWordLeft:function(e){return e.moveH(-1,"word")},goGroupRight:function(e){return e.moveH(1,"group")},goGroupLeft:function(e){return e.moveH(-1,"group")},goWordRight:function(e){return e.moveH(1,"word")},delCharBefore:function(e){return e.deleteH(-1,"char")},delCharAfter:function(e){return e.deleteH(1,"char")},delWordBefore:function(e){return e.deleteH(-1,"word")},delWordAfter:function(e){return e.deleteH(1,"word")},delGroupBefore:function(e){return e.deleteH(-1,"group")},delGroupAfter:function(e){return e.deleteH(1,"group")},indentAuto:function(e){return e.indentSelection("smart")},indentMore:function(e){return e.indentSelection("add")},indentLess:function(e){return e.indentSelection("subtract")},insertTab:function(e){return e.replaceSelection("\t")},insertSoftTab:function(e){for(var t=[],r=e.listSelections(),n=e.options.tabSize,i=0;i<r.length;i++){var o=r[i].from(),l=f(e.getLine(o.line),o.ch,n);t.push(p(n-l%n))}e.replaceSelections(t)},defaultTab:function(e){e.somethingSelected()?e.indentSelection("add"):e.execCommand("insertTab")},transposeChars:function(e){return hn(e,function(){for(var t=e.listSelections(),r=[],n=0;n<t.length;n++)if(t[n].empty()){var i=t[n].head,o=M(e.doc,i.line).text;if(o)if(i.ch==o.length&&(i=new E(i.line,i.ch-1)),i.ch>0)i=new E(i.line,i.ch+1),e.replaceRange(o.charAt(i.ch-1)+o.charAt(i.ch-2),E(i.line,i.ch-2),i,"+transpose");else if(i.line>e.doc.first){var l=M(e.doc,i.line-1).text;l&&(i=new E(i.line,1),e.replaceRange(o.charAt(0)+e.doc.lineSeparator()+l.charAt(l.length-1),E(i.line-1,l.length-1),i,"+transpose"))}r.push(new Ts(i,i))}e.setSelections(r)})},newlineAndIndent:function(e){return hn(e,function(){for(var t=e.listSelections(),r=t.length-1;r>=0;r--)e.replaceRange(e.doc.lineSeparator(),t[r].anchor,t[r].head,"+input");t=e.listSelections();for(var n=0;n<t.length;n++)e.indentLine(t[n].from().line,null,!0);jr(e)})},openLine:function(e){return e.replaceSelection("\n","start")},toggleOverwrite:function(e){return e.toggleOverwrite()}},Gs=new Pl,Us=null,Vs=function(e,t,r){this.time=e,this.pos=t,this.button=r};Vs.prototype.compare=function(e,t,r){return this.time+400>e&&0==P(t,this.pos)&&r==this.button};var Ks,js,Xs={toString:function(){return"CodeMirror.Init"}},Ys={},_s={};jo.defaults=Ys,jo.optionHandlers=_s;var $s=[];jo.defineInitHook=function(e){return $s.push(e)};var qs=null,Zs=function(e){this.cm=e,this.lastAnchorNode=this.lastAnchorOffset=this.lastFocusNode=this.lastFocusOffset=null,this.polling=new Pl,this.composing=null,this.gracePeriod=!1,this.readDOMTimeout=null};Zs.prototype.init=function(e){function t(e){if(!Me(i,e)){if(i.somethingSelected())_o({lineWise:!1,text:i.getSelections()}),"cut"==e.type&&i.replaceSelection("",null,"cut");else{if(!i.options.lineWiseCopyCut)return;var t=Qo(i);_o({lineWise:!0,text:t.text}),"cut"==e.type&&i.operation(function(){i.setSelections(t.ranges,0,Gl),i.replaceSelection("",null,"cut")})}if(e.clipboardData){e.clipboardData.clearData();var r=qs.text.join("\n");if(e.clipboardData.setData("Text",r),e.clipboardData.getData("Text")==r)return void e.preventDefault()}var l=el(),s=l.firstChild;i.display.lineSpace.insertBefore(l,i.display.lineSpace.firstChild),s.value=qs.text.join("\n");var a=document.activeElement;El(s),setTimeout(function(){i.display.lineSpace.removeChild(l),a.focus(),a==o&&n.showPrimarySelection()},50)}}var r=this,n=this,i=n.cm,o=n.div=e.lineDiv;Jo(o,i.options.spellcheck),Ql(o,"paste",function(e){Me(i,e)||qo(e,i)||vl<=11&&setTimeout(dn(i,function(){return r.updateFromDOM()}),20)}),Ql(o,"compositionstart",function(e){r.composing={data:e.data,done:!1}}),Ql(o,"compositionupdate",function(e){r.composing||(r.composing={data:e.data,done:!1})}),Ql(o,"compositionend",function(e){r.composing&&(e.data!=r.composing.data&&r.readFromDOMSoon(),r.composing.done=!0)}),Ql(o,"touchstart",function(){return n.forceCompositionEnd()}),Ql(o,"input",function(){r.composing||r.readFromDOMSoon()}),Ql(o,"copy",t),Ql(o,"cut",t)},Zs.prototype.prepareSelection=function(){var e=Tr(this.cm,!1);return e.focus=this.cm.state.focused,e},Zs.prototype.showSelection=function(e,t){e&&this.cm.display.view.length&&((e.focus||t)&&this.showPrimarySelection(),this.showMultipleSelections(e))},Zs.prototype.showPrimarySelection=function(){var e=window.getSelection(),t=this.cm,r=t.doc.sel.primary(),n=r.from(),i=r.to();if(t.display.viewTo==t.display.viewFrom||n.line>=t.display.viewTo||i.line<t.display.viewFrom)e.removeAllRanges();else{var o=sl(t,e.anchorNode,e.anchorOffset),l=sl(t,e.focusNode,e.focusOffset);if(!o||o.bad||!l||l.bad||0!=P(B(o,l),n)||0!=P(R(o,l),i)){var s=t.display.view,a=n.line>=t.display.viewFrom&&nl(t,n)||{node:s[0].measure.map[2],offset:0},u=i.line<t.display.viewTo&&nl(t,i);if(!u){var c=s[s.length-1].measure,f=c.maps?c.maps[c.maps.length-1]:c.map;u={node:f[f.length-1],offset:f[f.length-2]-f[f.length-3]}}if(a&&u){var h,d=e.rangeCount&&e.getRangeAt(0);try{h=Wl(a.node,a.offset,u.offset,u.node)}catch(e){}h&&(!fl&&t.state.focused?(e.collapse(a.node,a.offset),h.collapsed||(e.removeAllRanges(),e.addRange(h))):(e.removeAllRanges(),e.addRange(h)),d&&null==e.anchorNode?e.addRange(d):fl&&this.startGracePeriod()),this.rememberSelection()}else e.removeAllRanges()}}},Zs.prototype.startGracePeriod=function(){var e=this;clearTimeout(this.gracePeriod),this.gracePeriod=setTimeout(function(){e.gracePeriod=!1,e.selectionChanged()&&e.cm.operation(function(){return e.cm.curOp.selectionChanged=!0})},20)},Zs.prototype.showMultipleSelections=function(e){r(this.cm.display.cursorDiv,e.cursors),r(this.cm.display.selectionDiv,e.selection)},Zs.prototype.rememberSelection=function(){var e=window.getSelection();this.lastAnchorNode=e.anchorNode,this.lastAnchorOffset=e.anchorOffset,this.lastFocusNode=e.focusNode,this.lastFocusOffset=e.focusOffset},Zs.prototype.selectionInEditor=function(){var e=window.getSelection();if(!e.rangeCount)return!1;var t=e.getRangeAt(0).commonAncestorContainer;return o(this.div,t)},Zs.prototype.focus=function(){"nocursor"!=this.cm.options.readOnly&&(this.selectionInEditor()||this.showSelection(this.prepareSelection(),!0),this.div.focus())},Zs.prototype.blur=function(){this.div.blur()},Zs.prototype.getField=function(){return this.div},Zs.prototype.supportsTouch=function(){return!0},Zs.prototype.receivedFocus=function(){function e(){t.cm.state.focused&&(t.pollSelection(),t.polling.set(t.cm.options.pollInterval,e))}var t=this;this.selectionInEditor()?this.pollSelection():hn(this.cm,function(){return t.cm.curOp.selectionChanged=!0}),this.polling.set(this.cm.options.pollInterval,e)},Zs.prototype.selectionChanged=function(){var e=window.getSelection();return e.anchorNode!=this.lastAnchorNode||e.anchorOffset!=this.lastAnchorOffset||e.focusNode!=this.lastFocusNode||e.focusOffset!=this.lastFocusOffset},Zs.prototype.pollSelection=function(){if(null==this.readDOMTimeout&&!this.gracePeriod&&this.selectionChanged()){var e=window.getSelection(),t=this.cm;if(kl&&bl&&this.cm.options.gutters.length&&il(e.anchorNode))return this.cm.triggerOnKeyDown({type:"keydown",keyCode:8,preventDefault:Math.abs}),this.blur(),void this.focus();if(!this.composing){this.rememberSelection();var r=sl(t,e.anchorNode,e.anchorOffset),n=sl(t,e.focusNode,e.focusOffset);r&&n&&hn(t,function(){bi(t.doc,Rn(r,n),Gl),(r.bad||n.bad)&&(t.curOp.selectionChanged=!0)})}}},Zs.prototype.pollContent=function(){null!=this.readDOMTimeout&&(clearTimeout(this.readDOMTimeout),this.readDOMTimeout=null);var e=this.cm,t=e.display,r=e.doc.sel.primary(),n=r.from(),i=r.to();if(0==n.ch&&n.line>e.firstLine()&&(n=E(n.line-1,M(e.doc,n.line-1).length)),i.ch==M(e.doc,i.line).text.length&&i.line<e.lastLine()&&(i=E(i.line+1,0)),n.line<t.viewFrom||i.line>t.viewTo-1)return!1;var o,l,s;n.line==t.viewFrom||0==(o=Lr(e,n.line))?(l=W(t.view[0].line),s=t.view[0].node):(l=W(t.view[o].line),s=t.view[o-1].node.nextSibling);var a,u,c=Lr(e,i.line);if(c==t.view.length-1?(a=t.viewTo-1,u=t.lineDiv.lastChild):(a=W(t.view[c+1].line)-1,u=t.view[c+1].node.previousSibling),!s)return!1;for(var f=e.doc.splitLines(ll(e,s,u,l,a)),h=N(e.doc,E(l,0),E(a,M(e.doc,a).text.length));f.length>1&&h.length>1;)if(g(f)==g(h))f.pop(),h.pop(),a--;else{if(f[0]!=h[0])break;f.shift(),h.shift(),l++}for(var d=0,p=0,v=f[0],m=h[0],y=Math.min(v.length,m.length);d<y&&v.charCodeAt(d)==m.charCodeAt(d);)++d;for(var b=g(f),w=g(h),x=Math.min(b.length-(1==f.length?d:0),w.length-(1==h.length?d:0));p<x&&b.charCodeAt(b.length-p-1)==w.charCodeAt(w.length-p-1);)++p;if(1==f.length&&1==h.length&&l==n.line)for(;d&&d>n.ch&&b.charCodeAt(b.length-p-1)==w.charCodeAt(w.length-p-1);)d--,p++;f[f.length-1]=b.slice(0,b.length-p).replace(/^\u200b+/,""),f[0]=f[0].slice(d).replace(/\u200b+$/,"");var C=E(l,d),S=E(a,h.length?g(h).length-p:0);return f.length>1||f[0]||P(C,S)?(Ei(e.doc,f,C,S,"+input"),!0):void 0},Zs.prototype.ensurePolled=function(){this.forceCompositionEnd()},Zs.prototype.reset=function(){this.forceCompositionEnd()},Zs.prototype.forceCompositionEnd=function(){this.composing&&(clearTimeout(this.readDOMTimeout),this.composing=null,this.updateFromDOM(),this.div.blur(),this.div.focus())},Zs.prototype.readFromDOMSoon=function(){var e=this;null==this.readDOMTimeout&&(this.readDOMTimeout=setTimeout(function(){if(e.readDOMTimeout=null,e.composing){if(!e.composing.done)return;e.composing=null}e.updateFromDOM()},80))},Zs.prototype.updateFromDOM=function(){var e=this;!this.cm.isReadOnly()&&this.pollContent()||hn(this.cm,function(){return vn(e.cm)})},Zs.prototype.setUneditable=function(e){e.contentEditable="false"},Zs.prototype.onKeyPress=function(e){0!=e.charCode&&(e.preventDefault(),this.cm.isReadOnly()||dn(this.cm,$o)(this.cm,String.fromCharCode(null==e.charCode?e.keyCode:e.charCode),0))},Zs.prototype.readOnlyChanged=function(e){this.div.contentEditable=String("nocursor"!=e)},Zs.prototype.onContextMenu=function(){},Zs.prototype.resetPosition=function(){},Zs.prototype.needsContentAttribute=!0;var Qs=function(e){this.cm=e,this.prevInput="",this.pollingFast=!1,this.polling=new Pl,this.hasSelection=!1,this.composing=null};Qs.prototype.init=function(e){function t(e){if(!Me(i,e)){if(i.somethingSelected())_o({lineWise:!1,text:i.getSelections()});else{if(!i.options.lineWiseCopyCut)return;var t=Qo(i);_o({lineWise:!0,text:t.text}),"cut"==e.type?i.setSelections(t.ranges,null,Gl):(n.prevInput="",l.value=t.text.join("\n"),El(l))}"cut"==e.type&&(i.state.cutIncoming=!0)}}var r=this,n=this,i=this.cm,o=this.wrapper=el(),l=this.textarea=o.firstChild;e.wrapper.insertBefore(o,e.wrapper.firstChild),Ll&&(l.style.width="0px"),Ql(l,"input",function(){gl&&vl>=9&&r.hasSelection&&(r.hasSelection=null),n.poll()}),Ql(l,"paste",function(e){Me(i,e)||qo(e,i)||(i.state.pasteIncoming=!0,n.fastPoll())}),Ql(l,"cut",t),Ql(l,"copy",t),Ql(e.scroller,"paste",function(t){Ft(e,t)||Me(i,t)||(i.state.pasteIncoming=!0,n.focus())}),Ql(e.lineSpace,"selectstart",function(t){Ft(e,t)||We(t)}),Ql(l,"compositionstart",function(){var e=i.getCursor("from");n.composing&&n.composing.range.clear(),n.composing={start:e,range:i.markText(e,i.getCursor("to"),{className:"CodeMirror-composing"})}}),Ql(l,"compositionend",function(){n.composing&&(n.poll(),n.composing.range.clear(),n.composing=null)})},Qs.prototype.prepareSelection=function(){var e=this.cm,t=e.display,r=e.doc,n=Tr(e);if(e.options.moveInputWithCursor){var i=sr(e,r.sel.primary().head,"div"),o=t.wrapper.getBoundingClientRect(),l=t.lineDiv.getBoundingClientRect();n.teTop=Math.max(0,Math.min(t.wrapper.clientHeight-10,i.top+l.top-o.top)),n.teLeft=Math.max(0,Math.min(t.wrapper.clientWidth-10,i.left+l.left-o.left))}return n},Qs.prototype.showSelection=function(e){var t=this.cm.display;r(t.cursorDiv,e.cursors),r(t.selectionDiv,e.selection),null!=e.teTop&&(this.wrapper.style.top=e.teTop+"px",this.wrapper.style.left=e.teLeft+"px")},Qs.prototype.reset=function(e){if(!this.contextMenuPending&&!this.composing){var t=this.cm;if(t.somethingSelected()){this.prevInput="";var r=t.getSelection();this.textarea.value=r,t.state.focused&&El(this.textarea),gl&&vl>=9&&(this.hasSelection=r)}else e||(this.prevInput=this.textarea.value="",gl&&vl>=9&&(this.hasSelection=null))}},Qs.prototype.getField=function(){return this.textarea},Qs.prototype.supportsTouch=function(){return!1},Qs.prototype.focus=function(){if("nocursor"!=this.cm.options.readOnly&&(!Tl||l()!=this.textarea))try{this.textarea.focus()}catch(e){}},Qs.prototype.blur=function(){this.textarea.blur()},Qs.prototype.resetPosition=function(){this.wrapper.style.top=this.wrapper.style.left=0},Qs.prototype.receivedFocus=function(){this.slowPoll()},Qs.prototype.slowPoll=function(){var e=this;this.pollingFast||this.polling.set(this.cm.options.pollInterval,function(){e.poll(),e.cm.state.focused&&e.slowPoll()})},Qs.prototype.fastPoll=function(){function e(){r.poll()||t?(r.pollingFast=!1,r.slowPoll()):(t=!0,r.polling.set(60,e))}var t=!1,r=this;r.pollingFast=!0,r.polling.set(20,e)},Qs.prototype.poll=function(){var e=this,t=this.cm,r=this.textarea,n=this.prevInput;if(this.contextMenuPending||!t.state.focused||ts(r)&&!n&&!this.composing||t.isReadOnly()||t.options.disableInput||t.state.keySeq)return!1;var i=r.value;if(i==n&&!t.somethingSelected())return!1;if(gl&&vl>=9&&this.hasSelection===i||Ml&&/[\uf700-\uf7ff]/.test(i))return t.display.input.reset(),!1;if(t.doc.sel==t.display.selForContextMenu){var o=i.charCodeAt(0);if(8203!=o||n||(n="​"),8666==o)return this.reset(),this.cm.execCommand("undo")}for(var l=0,s=Math.min(n.length,i.length);l<s&&n.charCodeAt(l)==i.charCodeAt(l);)++l;return hn(t,function(){$o(t,i.slice(l),n.length-l,null,e.composing?"*compose":null),i.length>1e3||i.indexOf("\n")>-1?r.value=e.prevInput="":e.prevInput=i,e.composing&&(e.composing.range.clear(),e.composing.range=t.markText(e.composing.start,t.getCursor("to"),{className:"CodeMirror-composing"}))}),!0},Qs.prototype.ensurePolled=function(){this.pollingFast&&this.poll()&&(this.pollingFast=!1)},Qs.prototype.onKeyPress=function(){gl&&vl>=9&&(this.hasSelection=null),this.fastPoll()},Qs.prototype.onContextMenu=function(e){function t(){if(null!=l.selectionStart){var e=i.somethingSelected(),t="​"+(e?l.value:"");l.value="⇚",l.value=t,n.prevInput=e?"":"​",l.selectionStart=1,l.selectionEnd=t.length,o.selForContextMenu=i.doc.sel}}function r(){if(n.contextMenuPending=!1,n.wrapper.style.cssText=c,l.style.cssText=u,gl&&vl<9&&o.scrollbars.setScrollTop(o.scroller.scrollTop=a),null!=l.selectionStart){(!gl||gl&&vl<9)&&t();var e=0,r=function(){o.selForContextMenu==i.doc.sel&&0==l.selectionStart&&l.selectionEnd>0&&"​"==n.prevInput?dn(i,Mi)(i):e++<10?o.detectingSelectAll=setTimeout(r,500):(o.selForContextMenu=null,o.input.reset())};o.detectingSelectAll=setTimeout(r,200)}}var n=this,i=n.cm,o=i.display,l=n.textarea,s=Sr(i,e),a=o.scroller.scrollTop;if(s&&!wl){i.options.resetSelectionOnContextMenu&&-1==i.doc.sel.contains(s)&&dn(i,bi)(i.doc,Rn(s),Gl);var u=l.style.cssText,c=n.wrapper.style.cssText;n.wrapper.style.cssText="position: absolute";var f=n.wrapper.getBoundingClientRect();l.style.cssText="position: absolute; width: 30px; height: 30px;\n      top: "+(e.clientY-f.top-5)+"px; left: "+(e.clientX-f.left-5)+"px;\n      z-index: 1000; background: "+(gl?"rgba(255, 255, 255, .05)":"transparent")+";\n      outline: none; border-width: 0; outline: none; overflow: hidden; opacity: .05; filter: alpha(opacity=5);";var h;if(ml&&(h=window.scrollY),o.input.focus(),ml&&window.scrollTo(null,h),o.input.reset(),i.somethingSelected()||(l.value=n.prevInput=" "),n.contextMenuPending=!0,o.selForContextMenu=i.doc.sel,clearTimeout(o.detectingSelectAll),gl&&vl>=9&&t(),Hl){Fe(e);var d=function(){ke(window,"mouseup",d),setTimeout(r,20)};Ql(window,"mouseup",d)}else setTimeout(r,50)}},Qs.prototype.readOnlyChanged=function(e){e||this.reset(),this.textarea.disabled="nocursor"==e},Qs.prototype.setUneditable=function(){},Qs.prototype.needsContentAttribute=!1,function(e){function t(t,n,i,o){e.defaults[t]=n,i&&(r[t]=o?function(e,t,r){r!=Xs&&i(e,t,r)}:i)}var r=e.optionHandlers;e.defineOption=t,e.Init=Xs,t("value","",function(e,t){return e.setValue(t)},!0),t("mode",null,function(e,t){e.doc.modeOption=t,jn(e)},!0),t("indentUnit",2,jn,!0),t("indentWithTabs",!1),t("smartIndent",!0),t("tabSize",4,function(e){Xn(e),er(e),vn(e)},!0),t("lineSeparator",null,function(e,t){if(e.doc.lineSep=t,t){var r=[],n=e.doc.first;e.doc.iter(function(e){for(var i=0;;){var o=e.text.indexOf(t,i);if(-1==o)break;i=o+t.length,r.push(E(n,o))}n++});for(var i=r.length-1;i>=0;i--)Ei(e.doc,t,r[i],E(r[i].line,r[i].ch+t.length))}}),t("specialChars",/[\u0000-\u001f\u007f-\u009f\u00ad\u061c\u200b-\u200f\u2028\u2029\ufeff]/g,function(e,t,r){e.state.specialChars=new RegExp(t.source+(t.test("\t")?"":"|\t"),"g"),r!=Xs&&e.refresh()}),t("specialCharPlaceholder",at,function(e){return e.refresh()},!0),t("electricChars",!0),t("inputStyle",Tl?"contenteditable":"textarea",function(){throw new Error("inputStyle can not (yet) be changed in a running editor")},!0),t("spellcheck",!1,function(e,t){return e.getInputField().spellcheck=t},!0),t("rtlMoveVisually",!Ol),t("wholeLineUpdateBefore",!0),t("theme","default",function(e){Go(e),Uo(e)},!0),t("keyMap","default",function(e,t,r){var n=uo(t),i=r!=Xs&&uo(r);i&&i.detach&&i.detach(e,n),n.attach&&n.attach(e,i||null)}),t("extraKeys",null),t("configureMouse",null),t("lineWrapping",!1,Ko,!0),t("gutters",[],function(e){Fn(e.options),Uo(e)},!0),t("fixedGutter",!0,function(e,t){e.display.gutters.style.left=t?wr(e.display)+"px":"0",e.refresh()},!0),t("coverGutterNextToScrollbar",!1,function(e){return en(e)},!0),t("scrollbarStyle","native",function(e){rn(e),en(e),e.display.scrollbars.setScrollTop(e.doc.scrollTop),e.display.scrollbars.setScrollLeft(e.doc.scrollLeft)},!0),t("lineNumbers",!1,function(e){Fn(e.options),Uo(e)},!0),t("firstLineNumber",1,Uo,!0),t("lineNumberFormatter",function(e){return e},Uo,!0),t("showCursorWhenSelecting",!1,kr,!0),t("resetSelectionOnContextMenu",!0),t("lineWiseCopyCut",!0),t("pasteLinesPerSelection",!0),t("readOnly",!1,function(e,t){"nocursor"==t&&(Fr(e),e.display.input.blur()),e.display.input.readOnlyChanged(t)}),t("disableInput",!1,function(e,t){t||e.display.input.reset()},!0),t("dragDrop",!0,Vo),t("allowDropFileTypes",null),t("cursorBlinkRate",530),t("cursorScrollMargin",0),t("cursorHeight",1,kr,!0),t("singleCursorHeightPerLine",!0,kr,!0),t("workTime",100),t("workDelay",100),t("flattenSpans",!0,Xn,!0),t("addModeClass",!1,Xn,!0),t("pollInterval",100),t("undoDepth",200,function(e,t){return e.doc.history.undoDepth=t}),t("historyEventDelay",1250),t("viewportMargin",10,function(e){return e.refresh()},!0),t("maxHighlightLength",1e4,Xn,!0),t("moveInputWithCursor",!0,function(e,t){t||e.display.input.resetPosition()}),t("tabindex",null,function(e,t){return e.display.input.getField().tabIndex=t||""}),t("autofocus",null),t("direction","ltr",function(e,t){return e.doc.setDirection(t)},!0)}(jo),function(e){var t=e.optionHandlers,r=e.helpers={};e.prototype={constructor:e,focus:function(){window.focus(),this.display.input.focus()},setOption:function(e,r){var n=this.options,i=n[e];n[e]==r&&"mode"!=e||(n[e]=r,t.hasOwnProperty(e)&&dn(this,t[e])(this,r,i),Te(this,"optionChange",this,e))},getOption:function(e){return this.options[e]},getDoc:function(){return this.doc},addKeyMap:function(e,t){this.state.keyMaps[t?"push":"unshift"](uo(e))},removeKeyMap:function(e){for(var t=this.state.keyMaps,r=0;r<t.length;++r)if(t[r]==e||t[r].name==e)return t.splice(r,1),!0},addOverlay:pn(function(t,r){var n=t.token?t:e.getMode(this.options,t);if(n.startState)throw new Error("Overlays may not be stateful.");m(this.state.overlays,{mode:n,modeSpec:t,opaque:r&&r.opaque,priority:r&&r.priority||0},function(e){return e.priority}),this.state.modeGen++,vn(this)}),removeOverlay:pn(function(e){for(var t=this,r=this.state.overlays,n=0;n<r.length;++n){var i=r[n].modeSpec;if(i==e||"string"==typeof e&&i.name==e)return r.splice(n,1),t.state.modeGen++,void vn(t)}}),indentLine:pn(function(e,t,r){"string"!=typeof t&&"number"!=typeof t&&(t=null==t?this.options.smartIndent?"smart":"prev":t?"add":"subtract"),H(this.doc,e)&&Yo(this,e,t,r)}),indentSelection:pn(function(e){for(var t=this,r=this.doc.sel.ranges,n=-1,i=0;i<r.length;i++){var o=r[i];if(o.empty())o.head.line>n&&(Yo(t,o.head.line,e,!0),n=o.head.line,i==t.doc.sel.primIndex&&jr(t));else{var l=o.from(),s=o.to(),a=Math.max(n,l.line);n=Math.min(t.lastLine(),s.line-(s.ch?0:1))+1;for(var u=a;u<n;++u)Yo(t,u,e);var c=t.doc.sel.ranges;0==l.ch&&r.length==c.length&&c[i].from().ch>0&&gi(t.doc,i,new Ts(l,c[i].to()),Gl)}}}),getTokenAt:function(e,t){return Je(this,e,t)},getLineTokens:function(e,t){return Je(this,E(e),t,!0)},getTokenTypeAt:function(e){e=U(this.doc,e);var t,r=_e(this,M(this.doc,e.line)),n=0,i=(r.length-1)/2,o=e.ch;if(0==o)t=r[2];else for(;;){var l=n+i>>1;if((l?r[2*l-1]:0)>=o)i=l;else{if(!(r[2*l+1]<o)){t=r[2*l+2];break}n=l+1}}var s=t?t.indexOf("overlay "):-1;return s<0?t:0==s?null:t.slice(0,s-1)},getModeAt:function(t){var r=this.doc.mode;return r.innerMode?e.innerMode(r,this.getTokenAt(t).state).mode:r},getHelper:function(e,t){return this.getHelpers(e,t)[0]},getHelpers:function(e,t){var n=this,i=[];if(!r.hasOwnProperty(t))return i;var o=r[t],l=this.getModeAt(e);if("string"==typeof l[t])o[l[t]]&&i.push(o[l[t]]);else if(l[t])for(var s=0;s<l[t].length;s++){var a=o[l[t][s]];a&&i.push(a)}else l.helperType&&o[l.helperType]?i.push(o[l.helperType]):o[l.name]&&i.push(o[l.name]);for(var u=0;u<o._global.length;u++){var c=o._global[u];c.pred(l,n)&&-1==h(i,c.val)&&i.push(c.val)}return i},getStateAfter:function(e,t){var r=this.doc;return e=G(r,null==e?r.first+r.size-1:e),$e(this,e+1,t).state},cursorCoords:function(e,t){var r,n=this.doc.sel.primary();return r=null==e?n.head:"object"==typeof e?U(this.doc,e):e?n.from():n.to(),sr(this,r,t||"page")},charCoords:function(e,t){return lr(this,U(this.doc,e),t||"page")},coordsChar:function(e,t){return e=or(this,e,t||"page"),cr(this,e.left,e.top)},lineAtHeight:function(e,t){return e=or(this,{top:e,left:0},t||"page").top,D(this.doc,e+this.display.viewOffset)},heightAtLine:function(e,t,r){var n,i=!1;if("number"==typeof e){var o=this.doc.first+this.doc.size-1;e<this.doc.first?e=this.doc.first:e>o&&(e=o,i=!0),n=M(this.doc,e)}else n=e;return ir(this,n,{top:0,left:0},t||"page",r||i).top+(i?this.doc.height-ye(n):0)},defaultTextHeight:function(){return mr(this.display)},defaultCharWidth:function(){return yr(this.display)},getViewport:function(){return{from:this.display.viewFrom,to:this.display.viewTo}},addWidget:function(e,t,r,n,i){var o=this.display,l=(e=sr(this,U(this.doc,e))).bottom,s=e.left;if(t.style.position="absolute",t.setAttribute("cm-ignore-events","true"),this.display.input.setUneditable(t),o.sizer.appendChild(t),"over"==n)l=e.top;else if("above"==n||"near"==n){var a=Math.max(o.wrapper.clientHeight,this.doc.height),u=Math.max(o.sizer.clientWidth,o.lineSpace.clientWidth);("above"==n||e.bottom+t.offsetHeight>a)&&e.top>t.offsetHeight?l=e.top-t.offsetHeight:e.bottom+t.offsetHeight<=a&&(l=e.bottom),s+t.offsetWidth>u&&(s=u-t.offsetWidth)}t.style.top=l+"px",t.style.left=t.style.right="","right"==i?(s=o.sizer.clientWidth-t.offsetWidth,t.style.right="0px"):("left"==i?s=0:"middle"==i&&(s=(o.sizer.clientWidth-t.offsetWidth)/2),t.style.left=s+"px"),r&&Ur(this,{left:s,top:l,right:s+t.offsetWidth,bottom:l+t.offsetHeight})},triggerOnKeyDown:pn(Lo),triggerOnKeyPress:pn(Mo),triggerOnKeyUp:To,triggerOnMouseDown:pn(Oo),execCommand:function(e){if(Bs.hasOwnProperty(e))return Bs[e].call(null,this)},triggerElectric:pn(function(e){Zo(this,e)}),findPosH:function(e,t,r,n){var i=this,o=1;t<0&&(o=-1,t=-t);for(var l=U(this.doc,e),s=0;s<t&&!(l=tl(i.doc,l,o,r,n)).hitSide;++s);return l},moveH:pn(function(e,t){var r=this;this.extendSelectionsBy(function(n){return r.display.shift||r.doc.extend||n.empty()?tl(r.doc,n.head,e,t,r.options.rtlMoveVisually):e<0?n.from():n.to()},Vl)}),deleteH:pn(function(e,t){var r=this.doc.sel,n=this.doc;r.somethingSelected()?n.replaceSelection("",null,"+delete"):co(this,function(r){var i=tl(n,r.head,e,t,!1);return e<0?{from:i,to:r.head}:{from:r.head,to:i}})}),findPosV:function(e,t,r,n){var i=this,o=1,l=n;t<0&&(o=-1,t=-t);for(var s=U(this.doc,e),a=0;a<t;++a){var u=sr(i,s,"div");if(null==l?l=u.left:u.left=l,(s=rl(i,u,o,r)).hitSide)break}return s},moveV:pn(function(e,t){var r=this,n=this.doc,i=[],o=!this.display.shift&&!n.extend&&n.sel.somethingSelected();if(n.extendSelectionsBy(function(l){if(o)return e<0?l.from():l.to();var s=sr(r,l.head,"div");null!=l.goalColumn&&(s.left=l.goalColumn),i.push(s.left);var a=rl(r,s,e,t);return"page"==t&&l==n.sel.primary()&&Kr(r,lr(r,a,"div").top-s.top),a},Vl),i.length)for(var l=0;l<n.sel.ranges.length;l++)n.sel.ranges[l].goalColumn=i[l]}),findWordAt:function(e){var t=M(this.doc,e.line).text,r=e.ch,n=e.ch;if(t){var i=this.getHelper(e,"wordChars");"before"!=e.sticky&&n!=t.length||!r?++n:--r;for(var o=t.charAt(r),l=x(o,i)?function(e){return x(e,i)}:/\s/.test(o)?function(e){return/\s/.test(e)}:function(e){return!/\s/.test(e)&&!x(e)};r>0&&l(t.charAt(r-1));)--r;for(;n<t.length&&l(t.charAt(n));)++n}return new Ts(E(e.line,r),E(e.line,n))},toggleOverwrite:function(e){null!=e&&e==this.state.overwrite||((this.state.overwrite=!this.state.overwrite)?s(this.display.cursorDiv,"CodeMirror-overwrite"):Fl(this.display.cursorDiv,"CodeMirror-overwrite"),Te(this,"overwriteToggle",this,this.state.overwrite))},hasFocus:function(){return this.display.input.getField()==l()},isReadOnly:function(){return!(!this.options.readOnly&&!this.doc.cantEdit)},scrollTo:pn(function(e,t){Xr(this,e,t)}),getScrollInfo:function(){var e=this.display.scroller;return{left:e.scrollLeft,top:e.scrollTop,height:e.scrollHeight-zt(this)-this.display.barHeight,width:e.scrollWidth-zt(this)-this.display.barWidth,clientHeight:Bt(this),clientWidth:Rt(this)}},scrollIntoView:pn(function(e,t){null==e?(e={from:this.doc.sel.primary().head,to:null},null==t&&(t=this.options.cursorScrollMargin)):"number"==typeof e?e={from:E(e,0),to:null}:null==e.from&&(e={from:e,to:null}),e.to||(e.to=e.from),e.margin=t||0,null!=e.from.line?Yr(this,e):$r(this,e.from,e.to,e.margin)}),setSize:pn(function(e,t){var r=this,n=function(e){return"number"==typeof e||/^\d+$/.test(String(e))?e+"px":e};null!=e&&(this.display.wrapper.style.width=n(e)),null!=t&&(this.display.wrapper.style.height=n(t)),this.options.lineWrapping&&Jt(this);var i=this.display.viewFrom;this.doc.iter(i,this.display.viewTo,function(e){if(e.widgets)for(var t=0;t<e.widgets.length;t++)if(e.widgets[t].noHScroll){mn(r,i,"widget");break}++i}),this.curOp.forceUpdate=!0,Te(this,"refresh",this)}),operation:function(e){return hn(this,e)},startOperation:function(){return nn(this)},endOperation:function(){return on(this)},refresh:pn(function(){var e=this.display.cachedTextHeight;vn(this),this.curOp.forceUpdate=!0,er(this),Xr(this,this.doc.scrollLeft,this.doc.scrollTop),Wn(this),(null==e||Math.abs(e-mr(this.display))>.5)&&Cr(this),Te(this,"refresh",this)}),swapDoc:pn(function(e){var t=this.doc;return t.cm=null,qn(this,e),er(this),this.display.input.reset(),Xr(this,e.scrollLeft,e.scrollTop),this.curOp.forceScroll=!0,bt(this,"swapDoc",this,t),t}),getInputField:function(){return this.display.input.getField()},getWrapperElement:function(){return this.display.wrapper},getScrollerElement:function(){return this.display.scroller},getGutterElement:function(){return this.display.gutters}},Ae(e),e.registerHelper=function(t,n,i){r.hasOwnProperty(t)||(r[t]=e[t]={_global:[]}),r[t][n]=i},e.registerGlobalHelper=function(t,n,i,o){e.registerHelper(t,n,o),r[t]._global.push({pred:i,val:o})}}(jo);var Js="iter insert remove copy getEditor constructor".split(" ");for(var ea in Ds.prototype)Ds.prototype.hasOwnProperty(ea)&&h(Js,ea)<0&&(jo.prototype[ea]=function(e){return function(){return e.apply(this.doc,arguments)}}(Ds.prototype[ea]));return Ae(Ds),jo.inputStyles={textarea:Qs,contenteditable:Zs},jo.defineMode=function(e){jo.defaults.mode||"null"==e||(jo.defaults.mode=e),Be.apply(this,arguments)},jo.defineMIME=function(e,t){os[e]=t},jo.defineMode("null",function(){return{token:function(e){return e.skipToEnd()}}}),jo.defineMIME("text/plain","null"),jo.defineExtension=function(e,t){jo.prototype[e]=t},jo.defineDocExtension=function(e,t){Ds.prototype[e]=t},jo.fromTextArea=function(e,t){function r(){e.value=a.getValue()}if(t=t?c(t):{},t.value=e.value,!t.tabindex&&e.tabIndex&&(t.tabindex=e.tabIndex),!t.placeholder&&e.placeholder&&(t.placeholder=e.placeholder),null==t.autofocus){var n=l();t.autofocus=n==e||null!=e.getAttribute("autofocus")&&n==document.body}var i;if(e.form&&(Ql(e.form,"submit",r),!t.leaveSubmitMethodAlone)){var o=e.form;i=o.submit;try{var s=o.submit=function(){r(),o.submit=i,o.submit(),o.submit=s}}catch(e){}}t.finishInit=function(t){t.save=r,t.getTextArea=function(){return e},t.toTextArea=function(){t.toTextArea=isNaN,r(),e.parentNode.removeChild(t.getWrapperElement()),e.style.display="",e.form&&(ke(e.form,"submit",r),"function"==typeof e.form.submit&&(e.form.submit=i))}},e.style.display="none";var a=jo(function(t){return e.parentNode.insertBefore(t,e.nextSibling)},t);return a},function(e){e.off=ke,e.on=Ql,e.wheelEventPixels=Pn,e.Doc=Ds,e.splitLines=es,e.countColumn=f,e.findColumn=d,e.isWordChar=w,e.Pass=Bl,e.signal=Te,e.Line=fs,e.changeEnd=Bn,e.scrollbarModel=ws,e.Pos=E,e.cmpPos=P,e.modes=is,e.mimeModes=os,e.resolveMode=Ge,e.getMode=Ue,e.modeExtensions=ls,e.extendMode=Ve,e.copyState=Ke,e.startState=Xe,e.innerMode=je,e.commands=Bs,e.keyMap=Rs,e.keyName=ao,e.isModifierKey=lo,e.lookupKey=oo,e.normalizeKeyMap=io,e.StringStream=ss,e.SharedTextMarker=As,e.TextMarker=Os,e.LineWidget=Ms,e.e_preventDefault=We,e.e_stopPropagation=De,e.e_stop=Fe,e.addClass=s,e.contains=o,e.rmClass=Fl,e.keyNames=Es}(jo),jo.version="5.30.0",jo});
      !function(e){"object"==typeof exports&&"object"==typeof module?e(require("../../lib/codemirror")):"function"==typeof define&&define.amd?define(["../../lib/codemirror"],e):e(CodeMirror)}(function(e){"use strict";function t(e,t,n,r,o,a){this.indented=e,this.column=t,this.type=n,this.info=r,this.align=o,this.prev=a}function n(e,n,r,o){var a=e.indented;return e.context&&"statement"==e.context.type&&"statement"!=r&&(a=e.context.indented),e.context=new t(a,n,r,o,null,e.context)}function r(e){var t=e.context.type;return")"!=t&&"]"!=t&&"}"!=t||(e.indented=e.context.indented),e.context=e.context.prev}function o(e,t,n){return"variable"==t.prevToken||"type"==t.prevToken||(!!/\S(?:[^- ]>|[*\]])\s*$|\*$/.test(e.string.slice(0,n))||(!(!t.typeAtEndOfLine||e.column()!=e.indentation())||void 0))}function a(e){for(;;){if(!e||"top"==e.type)return!0;if("}"==e.type&&"namespace"!=e.prev.info)return!1;e=e.prev}}function i(e){for(var t={},n=e.split(" "),r=0;r<n.length;++r)t[n[r]]=!0;return t}function l(e,t){return"function"==typeof e?e(t):e.propertyIsEnumerable(t)}function s(e,t){if(!t.startOfLine)return!1;for(var n,r=null;n=e.peek();){if("\\"==n&&e.match(/^.$/)){r=s;break}if("/"==n&&e.match(/^\/[\/\*]/,!1))break;e.next()}return t.tokenize=r,"meta"}function c(e,t){return"type"==t.prevToken&&"type"}function u(e){return e.eatWhile(/[\w\.']/),"number"}function d(e,t){if(e.backUp(1),e.match(/(R|u8R|uR|UR|LR)/)){var n=e.match(/"([^\s\\()]{0,16})\(/);return!!n&&(t.cpp11RawStringDelim=n[1],t.tokenize=m,m(e,t))}return e.match(/(u8|u|U|L)/)?!!e.match(/["']/,!1)&&"string":(e.next(),!1)}function f(e){var t=/(\w+)::~?(\w+)$/.exec(e);return t&&t[1]==t[2]}function p(e,t){for(var n;null!=(n=e.next());)if('"'==n&&!e.eat('"')){t.tokenize=null;break}return"string"}function m(e,t){var n=t.cpp11RawStringDelim.replace(/[^\w\s]/g,"\\$&");return e.match(new RegExp(".*?\\)"+n+'"'))?t.tokenize=null:e.skipToEnd(),"string"}function h(t,n){function r(e){if(e)for(var t in e)e.hasOwnProperty(t)&&o.push(t)}"string"==typeof t&&(t=[t]);var o=[];r(n.keywords),r(n.types),r(n.builtin),r(n.atoms),o.length&&(n.helperType=t[0],e.registerHelper("hintWords",t[0],o));for(var a=0;a<t.length;++a)e.defineMIME(t[a],n)}function g(e,t){for(var n=!1;!e.eol();){if(!n&&e.match('"""')){t.tokenize=null;break}n="\\"==e.next()&&!n}return"string"}function y(e){return function(t,n){for(var r,o=!1,a=!1;!t.eol();){if(!e&&!o&&t.match('"')){a=!0;break}if(e&&t.match('"""')){a=!0;break}r=t.next(),!o&&"$"==r&&t.match("{")&&t.skipTo("}"),o=!o&&"\\"==r&&!e}return!a&&e||(n.tokenize=null),"string"}}function x(e){return function(t,n){for(var r,o=!1,a=!1;!t.eol();){if(!o&&t.match('"')&&("single"==e||t.match('""'))){a=!0;break}if(!o&&t.match("``")){w=x(e),a=!0;break}r=t.next(),o="single"==e&&!o&&"\\"==r}return a&&(n.tokenize=null),"string"}}e.defineMode("clike",function(i,s){function c(e,t){var n=e.next();if(S[n]){var r=S[n](e,t);if(!1!==r)return r}if('"'==n||"'"==n)return t.tokenize=u(n),t.tokenize(e,t);if(D.test(n))return p=n,null;if(L.test(n)){if(e.backUp(1),e.match(I))return"number";e.next()}if("/"==n){if(e.eat("*"))return t.tokenize=d,d(e,t);if(e.eat("/"))return e.skipToEnd(),"comment"}if(F.test(n)){for(;!e.match(/^\/[\/*]/,!1)&&e.eat(F););return"operator"}if(e.eatWhile(z),P)for(;e.match(P);)e.eatWhile(z);var o=e.current();return l(x,o)?(l(w,o)&&(p="newstatement"),l(v,o)&&(m=!0),"keyword"):l(b,o)?"type":l(k,o)?(l(w,o)&&(p="newstatement"),"builtin"):l(_,o)?"atom":"variable"}function u(e){return function(t,n){for(var r,o=!1,a=!1;null!=(r=t.next());){if(r==e&&!o){a=!0;break}o=!o&&"\\"==r}return(a||!o&&!C)&&(n.tokenize=null),"string"}}function d(e,t){for(var n,r=!1;n=e.next();){if("/"==n&&r){t.tokenize=null;break}r="*"==n}return"comment"}function f(e,t){s.typeFirstDefinitions&&e.eol()&&a(t.context)&&(t.typeAtEndOfLine=o(e,t,e.pos))}var p,m,h=i.indentUnit,g=s.statementIndentUnit||h,y=s.dontAlignCalls,x=s.keywords||{},b=s.types||{},k=s.builtin||{},w=s.blockKeywords||{},v=s.defKeywords||{},_=s.atoms||{},S=s.hooks||{},C=s.multiLineStrings,T=!1!==s.indentStatements,M=!1!==s.indentSwitch,P=s.namespaceSeparator,D=s.isPunctuationChar||/[\[\]{}\(\),;\:\.]/,L=s.numberStart||/[\d\.]/,I=s.number||/^(?:0x[a-f\d]+|0b[01]+|(?:\d+\.?\d*|\.\d+)(?:e[-+]?\d+)?)(u|ll?|l|f)?/i,F=s.isOperatorChar||/[+\-*&%=<>!?|\/]/,z=s.isIdentifierChar||/[\w\$_\xa1-\uffff]/;return{startState:function(e){return{tokenize:null,context:new t((e||0)-h,0,"top",null,!1),indented:0,startOfLine:!0,prevToken:null}},token:function(e,t){var i=t.context;if(e.sol()&&(null==i.align&&(i.align=!1),t.indented=e.indentation(),t.startOfLine=!0),e.eatSpace())return f(e,t),null;p=m=null;var l=(t.tokenize||c)(e,t);if("comment"==l||"meta"==l)return l;if(null==i.align&&(i.align=!0),";"==p||":"==p||","==p&&e.match(/^\s*(?:\/\/.*)?$/,!1))for(;"statement"==t.context.type;)r(t);else if("{"==p)n(t,e.column(),"}");else if("["==p)n(t,e.column(),"]");else if("("==p)n(t,e.column(),")");else if("}"==p){for(;"statement"==i.type;)i=r(t);for("}"==i.type&&(i=r(t));"statement"==i.type;)i=r(t)}else p==i.type?r(t):T&&(("}"==i.type||"top"==i.type)&&";"!=p||"statement"==i.type&&"newstatement"==p)&&n(t,e.column(),"statement",e.current());if("variable"==l&&("def"==t.prevToken||s.typeFirstDefinitions&&o(e,t,e.start)&&a(t.context)&&e.match(/^\s*\(/,!1))&&(l="def"),S.token){var u=S.token(e,t,l);void 0!==u&&(l=u)}return"def"==l&&!1===s.styleDefs&&(l="variable"),t.startOfLine=!1,t.prevToken=m?"def":l||p,f(e,t),l},indent:function(t,n){if(t.tokenize!=c&&null!=t.tokenize||t.typeAtEndOfLine)return e.Pass;var r=t.context,o=n&&n.charAt(0);if("statement"==r.type&&"}"==o&&(r=r.prev),s.dontIndentStatements)for(;"statement"==r.type&&s.dontIndentStatements.test(r.info);)r=r.prev;if(S.indent){var a=S.indent(t,r,n);if("number"==typeof a)return a}var i=o==r.type,l=r.prev&&"switch"==r.prev.info;if(s.allmanIndentation&&/[{(]/.test(o)){for(;"top"!=r.type&&"}"!=r.type;)r=r.prev;return r.indented}return"statement"==r.type?r.indented+("{"==o?0:g):!r.align||y&&")"==r.type?")"!=r.type||i?r.indented+(i?0:h)+(i||!l||/^(?:case|default)\b/.test(n)?0:h):r.indented+g:r.column+(i?0:1)},electricInput:M?/^\s*(?:case .*?:|default:|\{\}?|\})$/:/^\s*[{}]$/,blockCommentStart:"/*",blockCommentEnd:"*/",lineComment:"//",fold:"brace"}});var b="auto if break case register continue return default do sizeof static else struct switch extern typedef union for goto while enum const volatile",k="int long char short double float unsigned signed void size_t ptrdiff_t";h(["text/x-csrc","text/x-c","text/x-chdr"],{name:"clike",keywords:i(b),types:i(k+" bool _Complex _Bool float_t double_t intptr_t intmax_t int8_t int16_t int32_t int64_t uintptr_t uintmax_t uint8_t uint16_t uint32_t uint64_t"),blockKeywords:i("case do else for if switch while struct"),defKeywords:i("struct"),typeFirstDefinitions:!0,atoms:i("null true false"),hooks:{"#":s,"*":c},modeProps:{fold:["brace","include"]}}),h(["text/x-c++src","text/x-c++hdr"],{name:"clike",keywords:i(b+" asm dynamic_cast namespace reinterpret_cast try explicit new static_cast typeid catch operator template typename class friend private this using const_cast inline public throw virtual delete mutable protected alignas alignof constexpr decltype nullptr noexcept thread_local final static_assert override"),types:i(k+" bool wchar_t"),blockKeywords:i("catch class do else finally for if struct switch try while"),defKeywords:i("class namespace struct enum union"),typeFirstDefinitions:!0,atoms:i("true false null"),dontIndentStatements:/^template$/,isIdentifierChar:/[\w\$_~\xa1-\uffff]/,hooks:{"#":s,"*":c,u:d,U:d,L:d,R:d,0:u,1:u,2:u,3:u,4:u,5:u,6:u,7:u,8:u,9:u,token:function(e,t,n){if("variable"==n&&"("==e.peek()&&(";"==t.prevToken||null==t.prevToken||"}"==t.prevToken)&&f(e.current()))return"def"}},namespaceSeparator:"::",modeProps:{fold:["brace","include"]}}),h("text/x-java",{name:"clike",keywords:i("abstract assert break case catch class const continue default do else enum extends final finally float for goto if implements import instanceof interface native new package private protected public return static strictfp super switch synchronized this throw throws transient try volatile while @interface"),types:i("byte short int long float double boolean char void Boolean Byte Character Double Float Integer Long Number Object Short String StringBuffer StringBuilder Void"),blockKeywords:i("catch class do else finally for if switch try while"),defKeywords:i("class interface package enum @interface"),typeFirstDefinitions:!0,atoms:i("true false null"),number:/^(?:0x[a-f\d_]+|0b[01_]+|(?:[\d_]+\.?\d*|\.\d+)(?:e[-+]?[\d_]+)?)(u|ll?|l|f)?/i,hooks:{"@":function(e){return!e.match("interface",!1)&&(e.eatWhile(/[\w\$_]/),"meta")}},modeProps:{fold:["brace","import"]}}),h("text/x-csharp",{name:"clike",keywords:i("abstract as async await base break case catch checked class const continue default delegate do else enum event explicit extern finally fixed for foreach goto if implicit in interface internal is lock namespace new operator out override params private protected public readonly ref return sealed sizeof stackalloc static struct switch this throw try typeof unchecked unsafe using virtual void volatile while add alias ascending descending dynamic from get global group into join let orderby partial remove select set value var yield"),types:i("Action Boolean Byte Char DateTime DateTimeOffset Decimal Double Func Guid Int16 Int32 Int64 Object SByte Single String Task TimeSpan UInt16 UInt32 UInt64 bool byte char decimal double short int long object sbyte float string ushort uint ulong"),blockKeywords:i("catch class do else finally for foreach if struct switch try while"),defKeywords:i("class interface namespace struct var"),typeFirstDefinitions:!0,atoms:i("true false null"),hooks:{"@":function(e,t){return e.eat('"')?(t.tokenize=p,p(e,t)):(e.eatWhile(/[\w\$_]/),"meta")}}}),h("text/x-scala",{name:"clike",keywords:i("abstract case catch class def do else extends final finally for forSome if implicit import lazy match new null object override package private protected return sealed super this throw trait try type val var while with yield _ assert assume require print println printf readLine readBoolean readByte readShort readChar readInt readLong readFloat readDouble"),types:i("AnyVal App Application Array BufferedIterator BigDecimal BigInt Char Console Either Enumeration Equiv Error Exception Fractional Function IndexedSeq Int Integral Iterable Iterator List Map Numeric Nil NotNull Option Ordered Ordering PartialFunction PartialOrdering Product Proxy Range Responder Seq Serializable Set Specializable Stream StringBuilder StringContext Symbol Throwable Traversable TraversableOnce Tuple Unit Vector Boolean Byte Character CharSequence Class ClassLoader Cloneable Comparable Compiler Double Exception Float Integer Long Math Number Object Package Pair Process Runtime Runnable SecurityManager Short StackTraceElement StrictMath String StringBuffer System Thread ThreadGroup ThreadLocal Throwable Triple Void"),multiLineStrings:!0,blockKeywords:i("catch class enum do else finally for forSome if match switch try while"),defKeywords:i("class enum def object package trait type val var"),atoms:i("true false null"),indentStatements:!1,indentSwitch:!1,isOperatorChar:/[+\-*&%=<>!?|\/#:@]/,hooks:{"@":function(e){return e.eatWhile(/[\w\$_]/),"meta"},'"':function(e,t){return!!e.match('""')&&(t.tokenize=g,t.tokenize(e,t))},"'":function(e){return e.eatWhile(/[\w\$_\xa1-\uffff]/),"atom"},"=":function(e,n){var r=n.context;return!("}"!=r.type||!r.align||!e.eat(">"))&&(n.context=new t(r.indented,r.column,r.type,r.info,null,r.prev),"operator")}},modeProps:{closeBrackets:{triples:'"'}}}),h("text/x-kotlin",{name:"clike",keywords:i("package as typealias class interface this super val var fun for is in This throw return break continue object if else while do try when !in !is as? file import where by get set abstract enum open inner override private public internal protected catch finally out final vararg reified dynamic companion constructor init sealed field property receiver param sparam lateinit data inline noinline tailrec external annotation crossinline const operator infix suspend"),types:i("Boolean Byte Character CharSequence Class ClassLoader Cloneable Comparable Compiler Double Exception Float Integer Long Math Number Object Package Pair Process Runtime Runnable SecurityManager Short StackTraceElement StrictMath String StringBuffer System Thread ThreadGroup ThreadLocal Throwable Triple Void"),intendSwitch:!1,indentStatements:!1,multiLineStrings:!0,number:/^(?:0x[a-f\d_]+|0b[01_]+|(?:[\d_]+\.?\d*|\.\d+)(?:e[-+]?[\d_]+)?)(u|ll?|l|f)?/i,blockKeywords:i("catch class do else finally for if where try while enum"),defKeywords:i("class val var object package interface fun"),atoms:i("true false null this"),hooks:{'"':function(e,t){return t.tokenize=y(e.match('""')),t.tokenize(e,t)}},modeProps:{closeBrackets:{triples:'"'}}}),h(["x-shader/x-vertex","x-shader/x-fragment"],{name:"clike",keywords:i("sampler1D sampler2D sampler3D samplerCube sampler1DShadow sampler2DShadow const attribute uniform varying break continue discard return for while do if else struct in out inout"),types:i("float int bool void vec2 vec3 vec4 ivec2 ivec3 ivec4 bvec2 bvec3 bvec4 mat2 mat3 mat4"),blockKeywords:i("for while do if else struct"),builtin:i("radians degrees sin cos tan asin acos atan pow exp log exp2 sqrt inversesqrt abs sign floor ceil fract mod min max clamp mix step smoothstep length distance dot cross normalize ftransform faceforward reflect refract matrixCompMult lessThan lessThanEqual greaterThan greaterThanEqual equal notEqual any all not texture1D texture1DProj texture1DLod texture1DProjLod texture2D texture2DProj texture2DLod texture2DProjLod texture3D texture3DProj texture3DLod texture3DProjLod textureCube textureCubeLod shadow1D shadow2D shadow1DProj shadow2DProj shadow1DLod shadow2DLod shadow1DProjLod shadow2DProjLod dFdx dFdy fwidth noise1 noise2 noise3 noise4"),atoms:i("true false gl_FragColor gl_SecondaryColor gl_Normal gl_Vertex gl_MultiTexCoord0 gl_MultiTexCoord1 gl_MultiTexCoord2 gl_MultiTexCoord3 gl_MultiTexCoord4 gl_MultiTexCoord5 gl_MultiTexCoord6 gl_MultiTexCoord7 gl_FogCoord gl_PointCoord gl_Position gl_PointSize gl_ClipVertex gl_FrontColor gl_BackColor gl_FrontSecondaryColor gl_BackSecondaryColor gl_TexCoord gl_FogFragCoord gl_FragCoord gl_FrontFacing gl_FragData gl_FragDepth gl_ModelViewMatrix gl_ProjectionMatrix gl_ModelViewProjectionMatrix gl_TextureMatrix gl_NormalMatrix gl_ModelViewMatrixInverse gl_ProjectionMatrixInverse gl_ModelViewProjectionMatrixInverse gl_TexureMatrixTranspose gl_ModelViewMatrixInverseTranspose gl_ProjectionMatrixInverseTranspose gl_ModelViewProjectionMatrixInverseTranspose gl_TextureMatrixInverseTranspose gl_NormalScale gl_DepthRange gl_ClipPlane gl_Point gl_FrontMaterial gl_BackMaterial gl_LightSource gl_LightModel gl_FrontLightModelProduct gl_BackLightModelProduct gl_TextureColor gl_EyePlaneS gl_EyePlaneT gl_EyePlaneR gl_EyePlaneQ gl_FogParameters gl_MaxLights gl_MaxClipPlanes gl_MaxTextureUnits gl_MaxTextureCoords gl_MaxVertexAttribs gl_MaxVertexUniformComponents gl_MaxVaryingFloats gl_MaxVertexTextureImageUnits gl_MaxTextureImageUnits gl_MaxFragmentUniformComponents gl_MaxCombineTextureImageUnits gl_MaxDrawBuffers"),indentSwitch:!1,hooks:{"#":s},modeProps:{fold:["brace","include"]}}),h("text/x-nesc",{name:"clike",keywords:i(b+"as atomic async call command component components configuration event generic implementation includes interface module new norace nx_struct nx_union post provides signal task uses abstract extends"),types:i(k),blockKeywords:i("case do else for if switch while struct"),atoms:i("null true false"),hooks:{"#":s},modeProps:{fold:["brace","include"]}}),h("text/x-objectivec",{name:"clike",keywords:i(b+"inline restrict _Bool _Complex _Imaginary BOOL Class bycopy byref id IMP in inout nil oneway out Protocol SEL self super atomic nonatomic retain copy readwrite readonly"),types:i(k),atoms:i("YES NO NULL NILL ON OFF true false"),hooks:{"@":function(e){return e.eatWhile(/[\w\$]/),"keyword"},"#":s,indent:function(e,t,n){if("statement"==t.type&&/^@\w/.test(n))return t.indented}},modeProps:{fold:"brace"}}),h("text/x-squirrel",{name:"clike",keywords:i("base break clone continue const default delete enum extends function in class foreach local resume return this throw typeof yield constructor instanceof static"),types:i(k),blockKeywords:i("case catch class else for foreach if switch try while"),defKeywords:i("function local class"),typeFirstDefinitions:!0,atoms:i("true false null"),hooks:{"#":s},modeProps:{fold:["brace","include"]}});var w=null;h("text/x-ceylon",{name:"clike",keywords:i("abstracts alias assembly assert assign break case catch class continue dynamic else exists extends finally for function given if import in interface is let module new nonempty object of out outer package return satisfies super switch then this throw try value void while"),types:function(e){var t=e.charAt(0);return t===t.toUpperCase()&&t!==t.toLowerCase()},blockKeywords:i("case catch class dynamic else finally for function if interface module new object switch try while"),defKeywords:i("class dynamic function interface module object package value"),builtin:i("abstract actual aliased annotation by default deprecated doc final formal late license native optional sealed see serializable shared suppressWarnings tagged throws variable"),isPunctuationChar:/[\[\]{}\(\),;\:\.`]/,isOperatorChar:/[+\-*&%=<>!?|^~:\/]/,numberStart:/[\d#$]/,number:/^(?:#[\da-fA-F_]+|\$[01_]+|[\d_]+[kMGTPmunpf]?|[\d_]+\.[\d_]+(?:[eE][-+]?\d+|[kMGTPmunpf]|)|)/i,multiLineStrings:!0,typeFirstDefinitions:!0,atoms:i("true false null larger smaller equal empty finished"),indentSwitch:!1,styleDefs:!1,hooks:{"@":function(e){return e.eatWhile(/[\w\$_]/),"meta"},'"':function(e,t){return t.tokenize=x(e.match('""')?"triple":"single"),t.tokenize(e,t)},"`":function(e,t){return!(!w||!e.match("`"))&&(t.tokenize=w,w=null,t.tokenize(e,t))},"'":function(e){return e.eatWhile(/[\w\$_\xa1-\uffff]/),"atom"},token:function(e,t,n){if(("variable"==n||"type"==n)&&"."==t.prevToken)return"variable-2"}},modeProps:{fold:["brace","import"],closeBrackets:{triples:'"'}}})});
      // -------------------------------------------------------------------------
//  Part of the CodeChecker project, under the Apache License v2.0 with
//  LLVM Exceptions. See LICENSE for license information.
//  SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
// -------------------------------------------------------------------------

var BugViewer = {
  _files : [],
  _reports : [],
  _lineWidgets : [],
  _navigationMenuItems : [],
  _sourceFileData : null,
  _currentReport : null,
  _lastBugEvent  : null,

  init : function (files, reports) {
    this._files = files;
    this._reports = reports;

    this.initEscapeChars();
  },

  initEscapeChars : function () {
    this.escapeChars = {
      ' ' : 'nbsp',
      '<' : 'lt',
      '>' : 'gt',
      '"' : 'quot',
      '&' : 'amp'
    };

    var regexString = '[';
    for (var key in this.escapeChars) {
      regexString += key;
    }
    regexString += ']';

    this.escapeRegExp = new RegExp( regexString, 'g');
  },

  escapeHTML : function (str) {
    var that = this;

    return str.replace(this.escapeRegExp, function (m) {
      return '&' + that.escapeChars[m] + ';';
    });
  },

  initByUrl : function () {
    if (!this._reports) return;

    var state = {};
    window.location.hash.substr(1).split('&').forEach(function (s) {
      var parts = s.split('=');
      state[parts[0]] = parts[1];
    });

    for (var key in this._reports) {
      var report = this._reports[key];
      if (report.reportHash === state['reportHash']) {
        this.navigate(report);
        return;
      }
    }

    this.navigate(this._reports[0]);
  },

  create : function () {
    this._content = document.getElementById('editor-wrapper');
    this._filepath = document.getElementById('file-path');
    this._checkerName = document.getElementById('checker-name');
    this._reviewStatusWrapper =
      document.getElementById('review-status-wrapper');
    this._reviewStatus = document.getElementById('review-status');
    this._editor = document.getElementById('editor');

    this._codeMirror = CodeMirror(this._editor, {
      mode: 'text/x-c++src',
      matchBrackets : true,
      lineNumbers : true,
      readOnly : true,
      foldGutter : true,
      extraKeys : {},
      viewportMargin : 100
    });

    this._createNavigationMenu();
  },

  navigate : function (report, item) {
    if (!item) {
      var items = this._navigationMenuItems.filter(function (navItem) {
        return navItem.report.reportHash === report.reportHash;
      });

      if (!items.length) return;

      item = items[0].widget;
    }

    this._selectedReport.classList.remove('active');
    this._selectedReport = item;
    this._selectedReport.classList.add('active');
    this.setReport(report);
  },

  _createNavigationMenu : function () {
    var that = this;

    var nav = document.getElementById('report-nav');
    var list = document.createElement('ul');
    this._reports.forEach(function (report) {
      var events = report['events'];
      var lastBugEvent = events[events.length - 1];
      var item = document.createElement('li');

      var severity = document.createElement('i');
      severity.className = 'severity-' + report.severity.toLowerCase();

      item.appendChild(severity);
      item.appendChild(document.createTextNode(lastBugEvent.message));

      item.addEventListener('click', function () {
        that.navigate(report, item);
      })
      list.appendChild(item);
      that._navigationMenuItems.push({ report : report, widget : item });
    });

    if (!this._selectedReport && list.childNodes.length) {
      this._selectedReport = list.childNodes[0];
      this._selectedReport.classList.add('active');
    }

    nav.appendChild(list);
  },

  setReport : function (report) {
    this._currentReport = report;
    var events = report['events'];
    var lastBugEvent = events[events.length - 1];
    this.setCurrentBugEvent(lastBugEvent, events.length - 1);
    this.setCheckerName(report.checkerName);
    this.setReviewStatus(report.reviewStatus);

    window.location.hash = '#reportHash=' + report.reportHash;
  },

  setCurrentBugEvent : function (event, idx) {
    this._currentBugEvent = event;
    this.setSourceFileData(this._files[event.location.file]);
    this.drawBugPath();

    this.jumpTo(event.location.line, 0);
    this.highlightBugEvent(event, idx);
  },

  highlightBugEvent : function (event, idx) {
    this._lineWidgets.forEach(function (widget) {
      var lineIdx = widget.node.getAttribute('idx');
      if (parseInt(lineIdx) === idx) {
        widget.node.classList.add('current');
      }
    });
  },

  setCheckerName : function (checkerName) {
    this._checkerName.innerHTML = checkerName;
  },

  setReviewStatus : function (status) {
    if (status) {
      var className =
        'review-status-' + status.toLowerCase().split(' ').join('-');
      this._reviewStatus.className = "review-status " + className;

      this._reviewStatus.innerHTML = status;
      this._reviewStatusWrapper.style.display = 'block';
    } else {
      this._reviewStatusWrapper.style.display = 'none';
    }
  },

  setSourceFileData : function (file) {
    if (this._sourceFileData && file.id === this._sourceFileData.id) {
      return;
    }

    this._sourceFileData = file;
    this._filepath.innerHTML = file.path;
    this._codeMirror.doc.setValue(file.content);
    this._refresh();
  },

  _refresh : function () {
    var that = this;
    setTimeout(function () {
      var fullHeight = parseInt(that._content.clientHeight);
      var headerHeight = that._filepath.clientHeight;

      that._codeMirror.setSize('auto', fullHeight - headerHeight);
      that._codeMirror.refresh();
    }, 200);
  },

  clearBubbles : function () {
    this._lineWidgets.forEach(function (widget) { widget.clear(); });
    this._lineWidgets = [];
  },

  getMessage : function (event, kind) {
    if (kind === 'macro') {
      var name = 'macro expansion' + (event.name ? ': ' + event.name : '');

      return '<span class="tag macro">' + name + '</span>'
        + this.escapeHTML(event.expansion).replace(/(?:\r\n|\r|\n)/g, '<br>');
    } else if (kind === 'note') {
      return '<span class="tag note">note</span>'
        +  this.escapeHTML(event.message).replace(/(?:\r\n|\r|\n)/g, '<br>');
    }
  },

  addExtraPathEvents : function (events, kind) {
    var that = this;

    if (!events) {
      return;
    }

    events.forEach(function (event) {
      if (event.location.file !== that._currentBugEvent.location.file) {
        return;
      }

      var left =
        that._codeMirror.defaultCharWidth() * event.location.col + 'px';

      var element = document.createElement('div');
      element.setAttribute('style', 'margin-left: ' + left);
      element.setAttribute('class', 'check-msg ' + kind);

      var msg = document.createElement('span');
      msg.innerHTML = that.getMessage(event, kind);
      element.appendChild(msg);

      that._lineWidgets.push(that._codeMirror.addLineWidget(
        event.location.line - 1, element));
    });
  },

  drawBugPath : function () {
    var that = this;

    this.clearBubbles();

    this.addExtraPathEvents(this._currentReport.macros, 'macro');
    this.addExtraPathEvents(this._currentReport.notes, 'note');

    // Processing bug path events.
    var currentEvents = this._currentReport.events;
    currentEvents.forEach(function (event, step) {
      if (event.location.file !== that._currentBugEvent.location.file)
        return;

      var left =
        that._codeMirror.defaultCharWidth() * event.location.col + 'px';
      var type = step === currentEvents.length - 1 ? 'error' : 'info';

      var element = document.createElement('div');
      element.setAttribute('style', 'margin-left: ' + left);
      element.setAttribute('class', 'check-msg ' + type);
      element.setAttribute('idx', step);

      var enumeration = document.createElement('span');
      enumeration.setAttribute('class', 'checker-enum ' + type);
      enumeration.innerHTML = step + 1;

      if (currentEvents.length > 1)
        element.appendChild(enumeration);

      var prevBugEvent = step - 1;
      if (step > 0) {
        var prevBug = document.createElement('span');
        prevBug.setAttribute('class', 'arrow left-arrow');
        prevBug.addEventListener('click', function () {
          var event = currentEvents[prevBugEvent];
          that.setCurrentBugEvent(event, prevBugEvent);
        });
        element.appendChild(prevBug);
      }

      var msg = document.createElement('span');
      msg.innerHTML = that.escapeHTML(event.message)
        .replace(/(?:\r\n|\r|\n)/g, '<br>');

      element.appendChild(msg);

      var nextBugEvent = step + 1;
      if (nextBugEvent < currentEvents.length) {
        var nextBug = document.createElement('span');
        nextBug.setAttribute('class', 'arrow right-arrow');
        nextBug.addEventListener('click', function () {
          var event = currentEvents[nextBugEvent];
          that.setCurrentBugEvent(event, nextBugEvent);
        });
        element.appendChild(nextBug);
      }


      that._lineWidgets.push(that._codeMirror.addLineWidget(
        event.location.line - 1, element));
    });
  },

  jumpTo : function (line, column) {
    var that = this;

    setTimeout(function () {
      var selPosPixel
        = that._codeMirror.charCoords({ line : line, ch : column }, 'local');
      var editorSize = {
        width  : that._editor.clientWidth,
        height : that._editor.clientHeight
      };

      that._codeMirror.scrollIntoView({
        top    : selPosPixel.top - 100,
        bottom : selPosPixel.top + editorSize.height - 150,
        left   : selPosPixel.left < editorSize.width - 100
               ? 0
               : selPosPixel.left - 50,
        right  : selPosPixel.left < editorSize.width - 100
               ? 10
               : selPosPixel.left + editorSize.width - 100
      });
    }, 0);
  }
}


      var data = {"files": {"0": {"id": 0, "path": "/home/runner/work/testcc/testcc/retdec/pigeonhole-config.h", "content": "/* pigeonhole-config.h.  Generated from pigeonhole-config.h.in by configure.  */\n\n/* Define to the full name of Pigeonhole for Dovecot. */\n#define PIGEONHOLE_NAME \"Pigeonhole\"\n\n/* Define to the version of Pigeonhole for Dovecot. */\n#define PIGEONHOLE_VERSION \"0.6.devel\"\n\n/* Pigeonhole ABI version */\n#define PIGEONHOLE_ABI_VERSION \"0.6.ABIv0(0.6.devel)\"\n\n/* Define to build unfinished features/extensions. */\n/* #undef HAVE_SIEVE_UNFINISHED */\n\n/* LDAP support is built in */\n/* #undef SIEVE_BUILTIN_LDAP */\n"}, "1": {"id": 1, "path": "/home/runner/work/testcc/testcc/retdec/pigeonhole-version.h", "content": "#ifndef PIGEONHOLE_VERSION_H\n#define PIGEONHOLE_VERSION_H\n\n#define PIGEONHOLE_VERSION_FULL PIGEONHOLE_VERSION\" (a1c1ca78)\"\n\n#endif /* PIGEONHOLE_VERSION_H */\n"}, "2": {"id": 2, "path": "/home/runner/work/testcc/testcc/retdec/src/lib-sieve/plugins/ihave/cmd-error.c", "content": "/* Copyright (c) 2002-2018 Pigeonhole authors, see the included COPYING file\n */\n\n#include \"lib.h\"\n#include \"str-sanitize.h\"\n\n#include \"sieve-extensions.h\"\n#include \"sieve-commands.h\"\n#include \"sieve-code.h\"\n\n#include \"sieve-validator.h\"\n#include \"sieve-generator.h\"\n#include \"sieve-binary.h\"\n#include \"sieve-interpreter.h\"\n#include \"sieve-dump.h\"\n\n#include \"ext-ihave-common.h\"\n\n/*\n * Error command\n *\n * Syntax\n *   error <message: string>\n */\n\nstatic bool cmd_error_validate\n\t(struct sieve_validator *valdtr, struct sieve_command *tst);\nstatic bool cmd_error_generate\n\t(const struct sieve_codegen_env *cgenv,\tstruct sieve_command *ctx);\n\nconst struct sieve_command_def error_command = {\n\t.identifier = \"error\",\n\t.type = SCT_COMMAND,\n\t.positional_args = 1,\n\t.subtests = 0,\n\t.block_allowed = FALSE,\n\t.block_required = FALSE,\n\t.validate = cmd_error_validate,\n\t.generate = cmd_error_generate\n};\n\n/*\n * Body operation\n */\n\nstatic bool cmd_error_operation_dump\n\t(const struct sieve_dumptime_env *denv, sieve_size_t *address);\nstatic int cmd_error_operation_execute\n\t(const struct sieve_runtime_env *renv, sieve_size_t *address);\n\nconst struct sieve_operation_def cmd_error_operation = {\n\t.mnemonic = \"ERROR\",\n\t.ext_def = &ihave_extension,\n\t.code = EXT_IHAVE_OPERATION_ERROR,\n\t.dump = cmd_error_operation_dump,\n\t.execute = cmd_error_operation_execute\n};\n\n/*\n * Validation\n */\n\nstatic bool cmd_error_validate\n(struct sieve_validator *valdtr, struct sieve_command *tst)\n{\n\tstruct sieve_ast_argument *arg = tst->first_positional;\n\n\tif ( !sieve_validate_positional_argument\n\t\t(valdtr, tst, arg, \"message\", 1, SAAT_STRING) ) {\n\t\treturn FALSE;\n\t}\n\n\treturn sieve_validator_argument_activate(valdtr, tst, arg, FALSE);\n}\n\n/*\n * Code generation\n */\n\nstatic bool cmd_error_generate\n(const struct sieve_codegen_env *cgenv, struct sieve_command *cmd)\n{\n\t(void)sieve_operation_emit(cgenv->sblock, cmd->ext, &cmd_error_operation);\n\n\t/* Generate arguments */\n\treturn sieve_generate_arguments(cgenv, cmd, NULL);\n}\n\n/*\n * Code dump\n */\n\nstatic bool cmd_error_operation_dump\n(const struct sieve_dumptime_env *denv, sieve_size_t *address)\n{\n\tsieve_code_dumpf(denv, \"ERROR\");\n\tsieve_code_descend(denv);\n\n\treturn sieve_opr_string_dump(denv, address, \"message\");\n}\n\n/*\n * Interpretation\n */\n\nstatic int cmd_error_operation_execute\n(const struct sieve_runtime_env *renv, sieve_size_t *address)\n{\n\tstring_t *message;\n\tint ret;\n\n\t/*\n\t * Read operands\n\t */\n\n\t/* Read message */\n\n\tif ( (ret=sieve_opr_string_read(renv, address, \"message\", &message)) <= 0 )\n\t\treturn ret;\n\n\t/*\n\t * Perform operation\n\t */\n\n\tsieve_runtime_trace(renv, SIEVE_TRLVL_COMMANDS, \"error \\\"%s\\\"\",\n\t\tstr_sanitize(str_c(message), 80));\n\n\tsieve_runtime_error(renv, NULL, \"%s\", str_c(message));\n\n\treturn SIEVE_EXEC_FAILURE;\n}\n"}, "3": {"id": 3, "path": "/home/runner/work/testcc/testcc/retdec/src/lib-sieve/plugins/ihave/ext-ihave-common.h", "content": "#ifndef EXT_IHAVE_COMMON_H\n#define EXT_IHAVE_COMMON_H\n\n#include \"sieve-common.h\"\n\n/*\n * Extensions\n */\n\nextern const struct sieve_extension_def ihave_extension;\n\n/*\n * Tests\n */\n\nextern const struct sieve_command_def ihave_test;\n\n/*\n * Commands\n */\n\nextern const struct sieve_command_def error_command;\n\n/*\n * Operations\n */\n\nenum ext_ihave_opcode {\n\tEXT_IHAVE_OPERATION_IHAVE,\n\tEXT_IHAVE_OPERATION_ERROR\n};\n\nextern const struct sieve_operation_def tst_ihave_operation;\nextern const struct sieve_operation_def cmd_error_operation;\n\n/*\n * AST context\n */\n\nstruct ext_ihave_ast_context {\n  ARRAY(const char *) missing_extensions;\n};\n\nstruct ext_ihave_ast_context *ext_ihave_get_ast_context\n\t(const struct sieve_extension *this_ext, struct sieve_ast *ast);\n\nvoid ext_ihave_ast_add_missing_extension\n\t(const struct sieve_extension *this_ext, struct sieve_ast *ast,\n\t\tconst char *ext_name);\n\n\n#endif\n"}, "4": {"id": 4, "path": "/home/runner/work/testcc/testcc/retdec/src/lib-sieve/sieve-address-source.h", "content": "#ifndef SIEVE_ADDRESS_SOURCE_H\n#define SIEVE_ADDRESS_SOURCE_H\n\n#include \"sieve-common.h\"\n\nenum sieve_address_source_type {\n\tSIEVE_ADDRESS_SOURCE_DEFAULT = 0,\n\tSIEVE_ADDRESS_SOURCE_SENDER,\n\tSIEVE_ADDRESS_SOURCE_RECIPIENT,\n\tSIEVE_ADDRESS_SOURCE_ORIG_RECIPIENT,\n\tSIEVE_ADDRESS_SOURCE_USER_EMAIL,\n\tSIEVE_ADDRESS_SOURCE_POSTMASTER,\n\tSIEVE_ADDRESS_SOURCE_EXPLICIT\n};\n\nstruct sieve_address_source {\n\tenum sieve_address_source_type type;\n\tconst struct smtp_address *address;\n};\n\nbool sieve_address_source_parse\n\t(pool_t pool, const char *value,\n\t\tstruct sieve_address_source *asrc);\nbool sieve_address_source_parse_from_setting\n\t(struct sieve_instance *svinst, pool_t pool,\n\t\tconst char *setting, struct sieve_address_source *asrc);\n\nint sieve_address_source_get_address\n\t(struct sieve_address_source *asrc,\n\t\tstruct sieve_instance *svinst,\n\t\tconst struct sieve_script_env *senv,\n\t\tstruct sieve_message_context *msgctx,\n\t\tenum sieve_execute_flags flags,\n\t\tconst struct smtp_address **addr_r);\n\n#endif\n"}, "5": {"id": 5, "path": "/home/runner/work/testcc/testcc/retdec/src/lib-sieve/sieve-ast.h", "content": "#ifndef SIEVE_AST_H\n#define SIEVE_AST_H\n\n#include \"lib.h\"\n#include \"str.h\"\n\n#include \"sieve-common.h\"\n#include \"sieve-error.h\"\n\n/*\n\tAbstract Syntax Tree (AST) structure:\n\n\tsieve_ast (root)\n\t[*command]\n\t |\n\t +-- command:\n\t |   ....\n\t +-- command:\n\t |\t [identifier *argument                      *test *command]\n\t |                +-- argument:                 |     \\--> as from root\n\t |                |   ....                      |\n \t |                +-- argument:                 V (continued below)\n\t |                |   [number | tag | *string]\n\t |                .\n\t .\n\n\t *test\n\t +-- test:\n\t |   ....\n\t +-- test:\n\t |   [identifier *argument                     *test]\n\t |               +-- argument:                 \\-->  as from the top\n\t .               |   ....                              of this tree\n\t                 +-- argument:\n\t                 |   [number | tag | *string]\n\t                 .\n\n\t Tests and commands are defined using the same structure: sieve_ast_node.\n\t However, arguments and string-lists are described using sieve_ast_argument.\n*/\n\n/* IMPORTANT NOTICE: Do not decorate the AST with objects other than those\n * allocated on the ast's pool or static const objects. Otherwise it is possible\n * that pointers in the tree become dangling which is highly undesirable.\n */\n\n/*\n * Forward declarations\n */\n\nstruct sieve_ast_list;\nstruct sieve_ast_arg_list;\n\n/*\n * Types\n */\n\nenum sieve_ast_argument_type {\n\tSAAT_NONE,\n\tSAAT_NUMBER,\n\tSAAT_STRING,\n\tSAAT_STRING_LIST,\n\tSAAT_TAG,\n};\n\nenum sieve_ast_type {\n\tSAT_NONE,\n\tSAT_ROOT,\n\tSAT_COMMAND,\n\tSAT_TEST,\n};\n\n/*\n * AST Nodes\n */\n\n/* Argument node */\n\nstruct sieve_ast_argument {\n\tenum sieve_ast_argument_type type;\n\n\t/* Back reference to the AST object */\n\tstruct sieve_ast *ast;\n\n\t/* List related */\n\tstruct sieve_ast_arg_list *list;\n\tstruct sieve_ast_argument *next;\n\tstruct sieve_ast_argument *prev;\n\n\t/* Parser-assigned data */\n\n\tunion {\n\t\tstring_t *str;\n\t\tstruct sieve_ast_arg_list *strlist;\n\t\tconst char *tag;\n\t\tunsigned int number;\n\t} _value;\n\n\tunsigned int source_line;\n\n\t/* Assigned during validation */\n\n\t/* Argument associated with this ast element  */\n\tstruct sieve_argument *argument;\n\n\t/* Parameters to this (tag) argument */\n\tstruct sieve_ast_argument *parameters;\n};\n\nstruct sieve_ast_node {\n\tenum sieve_ast_type type;\n\n\t/* Back reference to the AST object */\n\tstruct sieve_ast *ast;\n\n\t/* Back reference to this node's parent */\n\tstruct sieve_ast_node *parent;\n\n\t/* Linked list references */\n\tstruct sieve_ast_list *list;\n\tstruct sieve_ast_node *next;\n\tstruct sieve_ast_node *prev;\n\n\t/* Commands (NULL if not allocated) */\n\tbool block;\n\tstruct sieve_ast_list *commands;\n\n\t/* Tests (NULL if not allocated)*/\n\tbool test_list;\n\tstruct sieve_ast_list *tests;\n\n\t/* Arguments (NULL if not allocated) */\n\tstruct sieve_ast_arg_list *arguments;\n\n\t/* Identifier of command or test */\n\tconst char *identifier;\n\n\t/* The location in the file where this command was started */\n\tunsigned int source_line;\n\n\t/* Assigned during validation */\n\n\t/* Context */\n\tstruct sieve_command *command;\n};\n\n/*\n * AST node lists\n */\n\nstruct sieve_ast_list {\n\tstruct sieve_ast_node *head;\n\tstruct sieve_ast_node *tail;\n\tunsigned int len;\n};\n\nstruct sieve_ast_arg_list {\n\tstruct sieve_ast_argument *head;\n\tstruct sieve_ast_argument *tail;\n\tunsigned int len;\n};\n\n/*\n * AST object\n */\n\nstruct sieve_ast;\n\nstruct sieve_ast *sieve_ast_create(struct sieve_script *script);\nvoid sieve_ast_ref(struct sieve_ast *ast);\nvoid sieve_ast_unref(struct sieve_ast **ast);\n\nstruct sieve_ast_node *sieve_ast_root(struct sieve_ast *ast);\npool_t sieve_ast_pool(struct sieve_ast *ast);\nstruct sieve_script *sieve_ast_script(struct sieve_ast *ast);\n\n/* Extension support */\n\nstruct sieve_ast_extension {\n\tconst struct sieve_extension_def *ext;\n\n\tvoid (*free)(const struct sieve_extension *ext, struct sieve_ast *ast,\n\t\tvoid *context);\n};\n\nvoid sieve_ast_extension_link\n\t(struct sieve_ast *ast, const struct sieve_extension *ext,\n\t\tbool required);\nconst struct sieve_extension * const *sieve_ast_extensions_get\n\t(struct sieve_ast *ast, unsigned int *count_r);\n\nvoid sieve_ast_extension_register\n\t(struct sieve_ast *ast, const struct sieve_extension *ext,\n\t\tconst struct sieve_ast_extension *ast_ext, void *context);\nvoid sieve_ast_extension_set_context\n\t(struct sieve_ast *ast, const struct sieve_extension *ext, void *context);\nvoid *sieve_ast_extension_get_context\n\t(struct sieve_ast *ast, const struct sieve_extension *ext);\n\nbool sieve_ast_extension_is_required\n\t(struct sieve_ast *ast, const struct sieve_extension *ext);\n\n/*\n * AST node manipulation\n */\n\n/* Command nodes */\n\nstruct sieve_ast_node *sieve_ast_test_create\n\t(struct sieve_ast_node *parent, const char *identifier,\n\t\tunsigned int source_line);\nstruct sieve_ast_node *sieve_ast_command_create\n\t(struct sieve_ast_node *parent, const char *identifier,\n\t\tunsigned int source_line);\n\nstruct sieve_ast_node *sieve_ast_node_detach\n\t(struct sieve_ast_node *first);\n\nconst char *sieve_ast_type_name(enum sieve_ast_type ast_type);\n\n/* Argument nodes */\n\nstruct sieve_ast_argument *sieve_ast_argument_create\n\t(struct sieve_ast *ast, unsigned int source_line);\n\nstruct sieve_ast_arg_list *sieve_ast_arg_list_create(pool_t pool);\nbool sieve_ast_arg_list_add\n\t(struct sieve_ast_arg_list *list, struct sieve_ast_argument *argument);\nbool sieve_ast_arg_list_insert\n\t(struct sieve_ast_arg_list *list, struct sieve_ast_argument *before,\n\t\tstruct sieve_ast_argument *argument);\nvoid sieve_ast_arg_list_substitute\n\t(struct sieve_ast_arg_list *list, struct sieve_ast_argument *argument,\n\t\tstruct sieve_ast_argument *replacement);\n\nstruct sieve_ast_argument *sieve_ast_argument_string_create_raw\n\t(struct sieve_ast *ast, string_t *str, unsigned int source_line);\nstruct sieve_ast_argument *sieve_ast_argument_string_create\n\t(struct sieve_ast_node *node, const string_t *str, unsigned int source_line);\nstruct sieve_ast_argument *sieve_ast_argument_cstring_create\n\t(struct sieve_ast_node *node, const char *str, unsigned int source_line);\n\nstruct sieve_ast_argument *sieve_ast_argument_tag_create\n\t(struct sieve_ast_node *node, const char *tag, unsigned int source_line);\n\nstruct sieve_ast_argument *sieve_ast_argument_number_create\n\t(struct sieve_ast_node *node, unsigned int number, unsigned int source_line);\n\nvoid sieve_ast_argument_string_set\n\t(struct sieve_ast_argument *argument, string_t *newstr);\nvoid sieve_ast_argument_string_setc\n\t(struct sieve_ast_argument *argument, const char *newstr);\n\nvoid sieve_ast_argument_number_set\n\t(struct sieve_ast_argument *argument, unsigned int newnum);\nvoid sieve_ast_argument_number_substitute\n\t(struct sieve_ast_argument *argument, unsigned int number);\n\nstruct sieve_ast_argument *sieve_ast_argument_tag_insert\n(struct sieve_ast_argument *before, const char *tag, unsigned int source_line);\n\nstruct sieve_ast_argument *sieve_ast_argument_stringlist_create\n\t(struct sieve_ast_node *node, unsigned int source_line);\nstruct sieve_ast_argument *sieve_ast_argument_stringlist_substitute\n\t(struct sieve_ast_node *node, struct sieve_ast_argument *arg);\n\nstruct sieve_ast_argument *sieve_ast_arguments_detach\n\t(struct sieve_ast_argument *first, unsigned int count);\nbool sieve_ast_argument_attach\n\t(struct sieve_ast_node *node, struct sieve_ast_argument *argument);\n\nconst char *sieve_ast_argument_type_name(enum sieve_ast_argument_type arg_type);\n#define sieve_ast_argument_name(argument) \\\n\tsieve_ast_argument_type_name((argument)->type)\n\nbool sieve_ast_stringlist_add\n\t(struct sieve_ast_argument *list, const string_t *str,\n\t\tunsigned int source_line);\nbool sieve_ast_stringlist_add_strc\n\t(struct sieve_ast_argument *list, const char *str,\n\t\tunsigned int source_line);\n\n/*\n * Utility\n */\n\nint sieve_ast_stringlist_map\n\t(struct sieve_ast_argument **listitem, void *context,\n\t\tint (*map_function)(void *context, struct sieve_ast_argument *arg));\nstruct sieve_ast_argument *sieve_ast_stringlist_join\n\t(struct sieve_ast_argument *list, struct sieve_ast_argument *items);\n\n/*\n * AST access macros\n */\n\n/* Generic list access macros */\n#define __AST_LIST_FIRST(list) \\\n\t((list) == NULL ? NULL : (list)->head)\n#define __AST_LIST_LAST(list) \\\n\t((list) == NULL ? NULL : (list)->tail)\n#define __AST_LIST_COUNT(list) \\\n\t((list) == NULL || (list)->head == NULL ? 0 : (list)->len)\n#define __AST_LIST_NEXT(item) ((item)->next)\n#define __AST_LIST_PREV(item) ((item)->prev)\n\n#define __AST_NODE_LIST_FIRST(node, list) __AST_LIST_FIRST((node)->list)\n#define __AST_NODE_LIST_LAST(node, list) __AST_LIST_LAST((node)->list)\n#define __AST_NODE_LIST_COUNT(node, list) __AST_LIST_COUNT((node)->list)\n\n/* AST macros */\n\n/* AST node macros */\n#define sieve_ast_node_pool(node) (sieve_ast_pool((node)->ast))\n#define sieve_ast_node_parent(node) ((node)->parent)\n#define sieve_ast_node_prev(node) __AST_LIST_PREV(node)\n#define sieve_ast_node_next(node) __AST_LIST_NEXT(node)\n#define sieve_ast_node_type(node) ((node) == NULL ? SAT_NONE : (node)->type)\n#define sieve_ast_node_line(node) ((node) == NULL ? 0 : (node)->source_line)\n\n/* AST command node macros */\n#define sieve_ast_command_first(node) __AST_NODE_LIST_FIRST(node, commands)\n#define sieve_ast_command_count(node) __AST_NODE_LIST_COUNT(node, commands)\n#define sieve_ast_command_prev(command) __AST_LIST_PREV(command)\n#define sieve_ast_command_next(command) __AST_LIST_NEXT(command)\n\n/* Compare the identifier of the previous command */\n#define sieve_ast_prev_cmd_is(cmd, id) \\\n\t( (cmd)->prev == NULL ? FALSE : \\\n\t\tstrncasecmp((cmd)->prev->identifier, id, sizeof(id)-1) == 0 )\n\n/* AST test macros */\n#define sieve_ast_test_count(node) __AST_NODE_LIST_COUNT(node, tests)\n#define sieve_ast_test_first(node) __AST_NODE_LIST_FIRST(node, tests)\n#define sieve_ast_test_next(test) __AST_LIST_NEXT(test)\n\n/* AST argument macros */\n#define sieve_ast_argument_pool(node) (sieve_ast_pool((node)->ast))\n#define sieve_ast_argument_first(node) __AST_NODE_LIST_FIRST(node, arguments)\n#define sieve_ast_argument_last(node) __AST_NODE_LIST_LAST(node, arguments)\n#define sieve_ast_argument_count(node) __AST_NODE_LIST_COUNT(node, arguments)\n#define sieve_ast_argument_prev(argument) __AST_LIST_PREV(argument)\n#define sieve_ast_argument_next(argument) __AST_LIST_NEXT(argument)\n#define sieve_ast_argument_type(argument) (argument)->type\n#define sieve_ast_argument_line(argument) (argument)->source_line\n\n#define sieve_ast_argument_str(argument) ((argument)->_value.str)\n#define sieve_ast_argument_strc(argument) (str_c((argument)->_value.str))\n#define sieve_ast_argument_tag(argument) ((argument)->_value.tag)\n#define sieve_ast_argument_number(argument) ((argument)->_value.number)\n\n/* AST string list macros */\n// @UNSAFE: should check whether we are actually accessing a string list\n#define sieve_ast_strlist_first(list) \\\n\t__AST_NODE_LIST_FIRST(list, _value.strlist)\n#define sieve_ast_strlist_last(list) \\\n\t__AST_NODE_LIST_LAST(list, _value.strlist)\n#define sieve_ast_strlist_count(list) \\\n\t__AST_NODE_LIST_COUNT(list, _value.strlist)\n#define sieve_ast_strlist_next(str) __AST_LIST_NEXT(str)\n#define sieve_ast_strlist_prev(str) __AST_LIST_PREV(str)\n#define sieve_ast_strlist_str(str) sieve_ast_argument_str(str)\n#define sieve_ast_strlist_strc(str) sieve_ast_argument_strc(str)\n\n/*\n * Debug\n */\n\nvoid sieve_ast_unparse(struct sieve_ast *ast);\n\n#endif\n"}, "6": {"id": 6, "path": "/home/runner/work/testcc/testcc/retdec/src/lib-sieve/sieve-binary-dumper.h", "content": "#ifndef SIEVE_BINARY_DUMPER_H\n#define SIEVE_BINARY_DUMPER_H\n\n#include \"sieve-common.h\"\n\n/*\n * Binary dumper object\n */\n\nstruct sieve_binary_dumper;\n\nstruct sieve_binary_dumper *sieve_binary_dumper_create\n\t(struct sieve_binary *sbin);\nvoid sieve_binary_dumper_free\n\t(struct sieve_binary_dumper **dumper);\n\npool_t sieve_binary_dumper_pool\n\t(struct sieve_binary_dumper *dumper);\n\n/*\n * Formatted output\n */\n\nvoid sieve_binary_dumpf\n\t(const struct sieve_dumptime_env *denv, const char *fmt, ...)\n\t\tATTR_FORMAT(2, 3);\nvoid sieve_binary_dump_sectionf\n\t(const struct sieve_dumptime_env *denv, const char *fmt, ...)\n\t\tATTR_FORMAT(2, 3);\n\n/*\n * Dumping the binary\n */\n\nbool sieve_binary_dumper_run\n\t(struct sieve_binary_dumper *dumper, struct ostream *stream, bool verbose);\n\n/*\n * Hexdump production\n */\n\nvoid sieve_binary_dumper_hexdump\n(struct sieve_binary_dumper *dumper, struct ostream *stream);\n\n#endif\n"}, "7": {"id": 7, "path": "/home/runner/work/testcc/testcc/retdec/src/lib-sieve/sieve-binary.h", "content": "#ifndef SIEVE_BINARY_H\n#define SIEVE_BINARY_H\n\n#include \"lib.h\"\n\n#include \"sieve-common.h\"\n\n/*\n * Config\n */\n\n#define SIEVE_BINARY_VERSION_MAJOR     1\n#define SIEVE_BINARY_VERSION_MINOR     4\n\n/*\n * Binary object\n */\n\nstruct sieve_binary;\n\nstruct sieve_binary *sieve_binary_create_new(struct sieve_script *script);\nvoid sieve_binary_ref(struct sieve_binary *sbin);\nvoid sieve_binary_unref(struct sieve_binary **sbin);\n\n/*\n * Accessors\n */\n\npool_t sieve_binary_pool(struct sieve_binary *sbin);\nstruct sieve_instance *sieve_binary_svinst(struct sieve_binary *sbin);\nconst char *sieve_binary_path(struct sieve_binary *sbin);\nstruct sieve_script *sieve_binary_script(struct sieve_binary *sbin);\n\ntime_t sieve_binary_mtime(struct sieve_binary *sbin);\nconst struct stat *sieve_binary_stat(struct sieve_binary *sbin);\n\nconst char *sieve_binary_script_name(struct sieve_binary *sbin);\nconst char *sieve_binary_script_location(struct sieve_binary *sbin);\n\nconst char *sieve_binary_source(struct sieve_binary *sbin);\nbool sieve_binary_loaded(struct sieve_binary *sbin);\nbool sieve_binary_saved(struct sieve_binary *sbin);\n\n/*\n * Utility\n */\n\nconst char *sieve_binfile_from_name(const char *name);\n\n/*\n * Activation after code generation\n */\n\nvoid sieve_binary_activate(struct sieve_binary *sbin);\n\n/*\n * Saving the binary\n */\n\nint sieve_binary_save(struct sieve_binary *sbin, const char *path, bool update,\n\t\t      mode_t save_mode, enum sieve_error *error_r);\n\n/*\n * Loading the binary\n */\n\nstruct sieve_binary *\nsieve_binary_open(struct sieve_instance *svinst, const char *path,\n\t\t  struct sieve_script *script, enum sieve_error *error_r);\nbool sieve_binary_up_to_date(struct sieve_binary *sbin,\n\t\t\t     enum sieve_compile_flags cpflags);\n\n/*\n * Block management\n */\n\nenum sieve_binary_system_block {\n\tSBIN_SYSBLOCK_SCRIPT_DATA,\n\tSBIN_SYSBLOCK_EXTENSIONS,\n\tSBIN_SYSBLOCK_MAIN_PROGRAM,\n\tSBIN_SYSBLOCK_LAST\n};\n\nstruct sieve_binary_block *sieve_binary_block_create(struct sieve_binary *sbin);\n\nunsigned int sieve_binary_block_count(struct sieve_binary *sbin);\n\nstruct sieve_binary_block *\nsieve_binary_block_get(struct sieve_binary *sbin, unsigned int id);\n\nvoid sieve_binary_block_clear(struct sieve_binary_block *sblock);\n\nsize_t sieve_binary_block_get_size(const struct sieve_binary_block *sblock);\n\nstruct sieve_binary *\nsieve_binary_block_get_binary(const struct sieve_binary_block *sblock);\n\nunsigned int sieve_binary_block_get_id(const struct sieve_binary_block *sblock);\n\n/*\n * Extension support\n */\n\nstruct sieve_binary_extension {\n\tconst struct sieve_extension_def *extension;\n\n\tbool (*binary_pre_save)(const struct sieve_extension *ext,\n\t\t\t\tstruct sieve_binary *sbin, void *context,\n\t\t\t\tenum sieve_error *error_r);\n\tbool (*binary_post_save)(const struct sieve_extension *ext,\n\t\t\t\t struct sieve_binary *sbin, void *context,\n\t\t\t\t enum sieve_error *error_r);\n\tbool (*binary_open)(const struct sieve_extension *ext,\n\t\t\t    struct sieve_binary *sbin, void *context);\n\n\tvoid (*binary_free)(const struct sieve_extension *ext,\n\t\t\t    struct sieve_binary *sbin, void *context);\n\n\tbool (*binary_up_to_date)(const struct sieve_extension *ext,\n\t\t\t\t  struct sieve_binary *sbin, void *context,\n\t\t\t\t  enum sieve_compile_flags cpflags);\n};\n\nvoid sieve_binary_extension_set_context(struct sieve_binary *sbin,\n\t\t\t\t\tconst struct sieve_extension *ext,\n\t\t\t\t\tvoid *context);\nconst void *\nsieve_binary_extension_get_context(struct sieve_binary *sbin,\n\t\t\t\t   const struct sieve_extension *ext);\n\nvoid sieve_binary_extension_set(struct sieve_binary *sbin,\n\t\t\t\tconst struct sieve_extension *ext,\n\t\t\t\tconst struct sieve_binary_extension *bext,\n\t\t\t\tvoid *context);\n\nstruct sieve_binary_block *\nsieve_binary_extension_create_block(struct sieve_binary *sbin,\n\t\t\t\t    const struct sieve_extension *ext);\nstruct sieve_binary_block *\nsieve_binary_extension_get_block(struct sieve_binary *sbin,\n\t\t\t\t const struct sieve_extension *ext);\n\nint sieve_binary_extension_link(struct sieve_binary *sbin,\n\t\t\t\tconst struct sieve_extension *ext);\nconst struct sieve_extension *\nsieve_binary_extension_get_by_index(struct sieve_binary *sbin, int index);\nint sieve_binary_extension_get_index(struct sieve_binary *sbin,\n\t\t\t\t     const struct sieve_extension *ext);\nint sieve_binary_extensions_count(struct sieve_binary *sbin);\n\n/*\n * Code emission\n */\n\n/* Low-level emission functions */\n\nsieve_size_t sieve_binary_emit_data(struct sieve_binary_block *sblock,\n\t\t\t\t    const void *data, sieve_size_t size);\nsieve_size_t sieve_binary_emit_byte(struct sieve_binary_block *sblock,\n\t\t\t\t    uint8_t byte);\nvoid sieve_binary_update_data(struct sieve_binary_block *sblock,\n\t\t\t      sieve_size_t address, const void *data,\n\t\t\t      sieve_size_t size);\n\n/* Offset emission functions */\n\nsieve_size_t sieve_binary_emit_offset(struct sieve_binary_block *sblock,\n\t\t\t\t      sieve_offset_t offset);\nvoid sieve_binary_resolve_offset(struct sieve_binary_block *sblock,\n\t\t\t\t sieve_size_t address);\n\n/* Literal emission functions */\n\nsieve_size_t sieve_binary_emit_integer(struct sieve_binary_block *sblock,\n\t\t\t\t       sieve_number_t integer);\nsieve_size_t sieve_binary_emit_string(struct sieve_binary_block *sblock,\n\t\t\t\t      const string_t *str);\nsieve_size_t sieve_binary_emit_cstring(struct sieve_binary_block *sblock,\n\t\t\t\t       const char *str);\n\nstatic inline sieve_size_t\nsieve_binary_emit_unsigned(struct sieve_binary_block *sblock,\n\t\t\t   unsigned int count)\n{\n\treturn sieve_binary_emit_integer(sblock, count);\n}\n\n/* Extension emission functions */\n\nsieve_size_t sieve_binary_emit_extension(struct sieve_binary_block *sblock,\n\t\t\t\t\t const struct sieve_extension *ext,\n\t\t\t\t\t unsigned int offset);\nvoid sieve_binary_emit_extension_object(\n\tstruct sieve_binary_block *sblock,\n\tconst struct sieve_extension_objects *objs, unsigned int code);\n\n/*\n * Code retrieval\n */\n\n/* Literals */\n\nbool sieve_binary_read_byte(struct sieve_binary_block *sblock,\n\t\t\t    sieve_size_t *address, unsigned int *byte_r)\n\t\t\t    ATTR_NULL(3);\nbool sieve_binary_read_code(struct sieve_binary_block *sblock,\n\t\t\t    sieve_size_t *address, signed int *code_r)\n\t\t\t    ATTR_NULL(3);\nbool sieve_binary_read_offset(struct sieve_binary_block *sblock,\n\t\t\t      sieve_size_t *address, sieve_offset_t *offset_r)\n\t\t\t      ATTR_NULL(3);\nbool sieve_binary_read_integer(struct sieve_binary_block *sblock,\n\t\t\t       sieve_size_t *address, sieve_number_t *int_r)\n\t\t\t       ATTR_NULL(3);\nbool sieve_binary_read_string(struct sieve_binary_block *sblock,\n\t\t\t      sieve_size_t *address, string_t **str_r)\n\t\t\t      ATTR_NULL(3);\n\nstatic inline bool ATTR_NULL(3)\nsieve_binary_read_unsigned(struct sieve_binary_block *sblock,\n\t\t\t   sieve_size_t *address, unsigned int *count_r)\n{\n\tsieve_number_t integer = 0;\n\n\tif (!sieve_binary_read_integer(sblock, address, &integer))\n\t\treturn FALSE;\n\tif (count_r != NULL)\n\t\t*count_r = integer;\n\treturn TRUE;\n}\n\n/* Extensions */\n\nbool sieve_binary_read_extension(struct sieve_binary_block *sblock,\n\t\t\t\t sieve_size_t *address, unsigned int *offset_r,\n\t\t\t\t const struct sieve_extension **ext_r);\nconst void *\nsieve_binary_read_extension_object(struct sieve_binary_block *sblock,\n\t\t\t\t   sieve_size_t *address,\n\t\t\t\t   const struct sieve_extension_objects *objs);\n\n/*\n * Debug info\n */\n\n/* Writer */\n\nstruct sieve_binary_debug_writer;\n\nstruct sieve_binary_debug_writer *\nsieve_binary_debug_writer_init(struct sieve_binary_block *sblock);\nvoid sieve_binary_debug_writer_deinit(\n\tstruct sieve_binary_debug_writer **dwriter);\n\nvoid sieve_binary_debug_emit(struct sieve_binary_debug_writer *dwriter,\n\t\t\t     sieve_size_t code_address, unsigned int code_line,\n\t\t\t     unsigned int code_column);\n\n/* Reader */\n\nstruct sieve_binary_debug_reader *\nsieve_binary_debug_reader_init(struct sieve_binary_block *sblock);\nvoid sieve_binary_debug_reader_deinit(\n\tstruct sieve_binary_debug_reader **dreader);\n\nvoid sieve_binary_debug_reader_reset(struct sieve_binary_debug_reader *dreader);\n\nunsigned int\nsieve_binary_debug_read_line(struct sieve_binary_debug_reader *dreader,\n\t\t\t     sieve_size_t code_address);\n\n#endif\n"}, "8": {"id": 8, "path": "/home/runner/work/testcc/testcc/retdec/src/lib-sieve/sieve-code-dumper.h", "content": "#ifndef SIEVE_CODE_DUMPER_H\n#define SIEVE_CODE_DUMPER_H\n\n#include \"sieve-common.h\"\n\nstruct sieve_code_dumper;\n\nstruct sieve_code_dumper *sieve_code_dumper_create\n\t(struct sieve_dumptime_env *denv);\nvoid sieve_code_dumper_free\n\t(struct sieve_code_dumper **_dumper);\npool_t sieve_code_dumper_pool\n\t(struct sieve_code_dumper *dumper);\n\n/*\n * Extension support\n */\n\nstruct sieve_code_dumper_extension {\n\tconst struct sieve_extension_def *ext;\n\n\tvoid (*free)(struct sieve_code_dumper *dumper, void *context);\n};\n\nvoid sieve_dump_extension_register\n(struct sieve_code_dumper *dumper, const struct sieve_extension *ext,\n\tconst struct sieve_code_dumper_extension *dump_ext, void *context);\nvoid sieve_dump_extension_set_context\n\t(struct sieve_code_dumper *dumper, const struct sieve_extension *ext,\n\t\tvoid *context);\nvoid *sieve_dump_extension_get_context\n\t(struct sieve_code_dumper *dumper, const struct sieve_extension *ext);\n\n/* Dump functions */\n\nvoid sieve_code_dumpf\n\t(const struct sieve_dumptime_env *denv, const char *fmt, ...)\n\t\tATTR_FORMAT(2, 3);\n\nvoid sieve_code_mark(const struct sieve_dumptime_env *denv);\nvoid sieve_code_mark_specific\n\t(const struct sieve_dumptime_env *denv, sieve_size_t location);\nvoid sieve_code_descend(const struct sieve_dumptime_env *denv);\nvoid sieve_code_ascend(const struct sieve_dumptime_env *denv);\n\n/* Operations and operands */\n\nbool sieve_code_dumper_print_optional_operands\n\t(const struct sieve_dumptime_env *denv, sieve_size_t *address);\n\n/* Code dump (debugging purposes) */\n\nvoid sieve_code_dumper_run(struct sieve_code_dumper *dumper);\n\n#endif\n"}, "9": {"id": 9, "path": "/home/runner/work/testcc/testcc/retdec/src/lib-sieve/sieve-code.h", "content": "#ifndef SIEVE_CODE_H\n#define SIEVE_CODE_H\n\n#include \"lib.h\"\n#include \"buffer.h\"\n#include \"mempool.h\"\n#include \"array.h\"\n\n#include \"sieve-common.h\"\n#include \"sieve-runtime.h\"\n#include \"sieve-runtime-trace.h\"\n#include \"sieve-dump.h\"\n\n/*\n * Operand object\n */\n\nstruct sieve_operand_class {\n\tconst char *name;\n};\n\nstruct sieve_operand_def {\n\tconst char *name;\n\n\tconst struct sieve_extension_def *ext_def;\n\tunsigned int code;\n\n\tconst struct sieve_operand_class *class;\n\tconst void *interface;\n};\n\nstruct sieve_operand {\n\tconst struct sieve_operand_def *def;\n\tconst struct sieve_extension *ext;\n\tsieve_size_t address;\n\tconst char *field_name;\n};\n\n#define sieve_operand_name(opr) \\\n\t( (opr)->def == NULL ? \"(NULL)\" : (opr)->def->name )\n#define sieve_operand_is(opr, definition) \\\n\t( (opr)->def == &(definition) )\n\nsieve_size_t sieve_operand_emit\n\t(struct sieve_binary_block *sblock, const struct sieve_extension *ext,\n\t\tconst struct sieve_operand_def *oprnd);\nbool sieve_operand_read\n\t(struct sieve_binary_block *sblock, sieve_size_t *address,\n\t\tconst char *field_name, struct sieve_operand *oprnd);\n\nstatic inline int sieve_operand_runtime_read\n(const struct sieve_runtime_env *renv, sieve_size_t *address,\n\tconst char *field_name, struct sieve_operand *operand)\n{\n\tif ( !sieve_operand_read(renv->sblock, address, field_name, operand) ) {\n\t\tsieve_runtime_trace_operand_error(renv, operand, \"invalid operand\");\n\t\treturn SIEVE_EXEC_BIN_CORRUPT;\n\t}\n\n\treturn SIEVE_EXEC_OK;\n}\n\n/*\n * Optional operands\n */\n\nint sieve_opr_optional_next\n(struct sieve_binary_block *sblock, sieve_size_t *address,\n\tsigned int *opt_code);\n\nstatic inline int sieve_opr_optional_dump\n(const struct sieve_dumptime_env *denv, sieve_size_t *address,\n\tsigned int *opt_code)\n{\n\tsieve_size_t pc = *address;\n\tint ret;\n\n\tif ( (ret=sieve_opr_optional_next(denv->sblock, address, opt_code)) <= 0 )\n\t\treturn ret;\n\n\tsieve_code_mark_specific(denv, pc);\n\treturn ret;\n}\n\nstatic inline int sieve_opr_optional_read\n(const struct sieve_runtime_env *renv, sieve_size_t *address,\n\tsigned int *opt_code)\n{\n\tint ret;\n\n\tif ( (ret=sieve_opr_optional_next(renv->sblock, address, opt_code)) < 0 )\n\t\tsieve_runtime_trace_error(renv, \"invalid optional operand code\");\n\n\treturn ret;\n}\n\n/*\n * Core operands\n */\n\n/* Operand codes */\n\nenum sieve_core_operand {\n\tSIEVE_OPERAND_OPTIONAL = 0x00,\n\tSIEVE_OPERAND_NUMBER,\n\tSIEVE_OPERAND_STRING,\n\tSIEVE_OPERAND_STRING_LIST,\n\tSIEVE_OPERAND_COMPARATOR,\n\tSIEVE_OPERAND_MATCH_TYPE,\n\tSIEVE_OPERAND_ADDRESS_PART,\n\tSIEVE_OPERAND_CATENATED_STRING,\n\n\tSIEVE_OPERAND_CUSTOM\n};\n\n/* Operand classes */\n\nextern const struct sieve_operand_class number_class;\nextern const struct sieve_operand_class string_class;\nextern const struct sieve_operand_class stringlist_class;\n\n/* Operand objects */\n\nextern const struct sieve_operand_def omitted_operand;\nextern const struct sieve_operand_def number_operand;\nextern const struct sieve_operand_def string_operand;\nextern const struct sieve_operand_def stringlist_operand;\nextern const struct sieve_operand_def catenated_string_operand;\n\nextern const struct sieve_operand_def *sieve_operands[];\nextern const unsigned int sieve_operand_count;\n\n/* Operand object interfaces */\n\nstruct sieve_opr_number_interface {\n\tbool (*dump)\n\t\t(const struct sieve_dumptime_env *denv, const struct sieve_operand *oprnd,\n\t\t\tsieve_size_t *address);\n\tint (*read)\n\t  (const struct sieve_runtime_env *renv, const struct sieve_operand *oprnd,\n\t\t\tsieve_size_t *address, sieve_number_t *number_r);\n};\n\nstruct sieve_opr_string_interface {\n\tbool (*dump)\n\t\t(const struct sieve_dumptime_env *denv, const struct sieve_operand *oprnd,\n\t\t\tsieve_size_t *address);\n\tint (*read)\n\t\t(const struct sieve_runtime_env *renv, const struct sieve_operand *oprnd,\n\t\t \tsieve_size_t *address, string_t **str_r);\n};\n\nstruct sieve_opr_stringlist_interface {\n\tbool (*dump)\n\t\t(const struct sieve_dumptime_env *denv, const struct sieve_operand *oprnd,\n\t\t\tsieve_size_t *address);\n\tint (*read)\n\t\t(const struct sieve_runtime_env *renv, const struct sieve_operand *oprnd,\n\t\t\tsieve_size_t *address, struct sieve_stringlist **strlist_r);\n};\n\n/*\n * Core operand functions\n */\n\n/* Omitted */\n\nvoid sieve_opr_omitted_emit(struct sieve_binary_block *sblock);\n\nstatic inline bool sieve_operand_is_omitted\n(const struct sieve_operand *operand)\n{\n\treturn ( operand != NULL && operand->def != NULL &&\n\t\toperand->def == &omitted_operand );\n}\n\n/* Number */\n\nvoid sieve_opr_number_emit\n\t(struct sieve_binary_block *sblock, sieve_number_t number);\nbool sieve_opr_number_dump_data\n\t(const struct sieve_dumptime_env *denv, struct sieve_operand *operand,\n\t\tsieve_size_t *address, const char *field_name);\nbool sieve_opr_number_dump\n\t(const struct sieve_dumptime_env *denv, sieve_size_t *address,\n\t\tconst char *field_name);\nint sieve_opr_number_read_data\n\t(const struct sieve_runtime_env *renv, struct sieve_operand *operand,\n\t\tsieve_size_t *address, const char *field_name, sieve_number_t *number_r);\nint sieve_opr_number_read\n\t(const struct sieve_runtime_env *renv, sieve_size_t *address,\n\t\tconst char *field_name, sieve_number_t *number_r);\n\nstatic inline bool sieve_operand_is_number\n(const struct sieve_operand *operand)\n{\n\treturn ( operand != NULL && operand->def != NULL &&\n\t\toperand->def->class == &number_class );\n}\n\n/* String */\n\nvoid sieve_opr_string_emit\n\t(struct sieve_binary_block *sblock, string_t *str);\nbool sieve_opr_string_dump_data\n\t(const struct sieve_dumptime_env *denv, struct sieve_operand *operand,\n\t\tsieve_size_t *address, const char *field_name);\nbool sieve_opr_string_dump\n\t(const struct sieve_dumptime_env *denv, sieve_size_t *address,\n\t\tconst char *field_name);\nbool sieve_opr_string_dump_ex\n\t(const struct sieve_dumptime_env *denv, sieve_size_t *address,\n\t\tconst char *field_name, const char *omitted_value);\nint sieve_opr_string_read_data\n\t(const struct sieve_runtime_env *renv, struct sieve_operand *operand,\n\t\tsieve_size_t *address, const char *field_name, string_t **str_r);\nint sieve_opr_string_read\n\t(const struct sieve_runtime_env *renv, sieve_size_t *address,\n\t\tconst char *field_name, string_t **str_r);\nint sieve_opr_string_read_ex\n\t(const struct sieve_runtime_env *renv, sieve_size_t *address,\n\t\tconst char *field_name, bool optional, string_t **str_r, bool *literal_r);\n\nstatic inline bool sieve_operand_is_string\n(const struct sieve_operand *operand)\n{\n\treturn ( operand != NULL && operand->def != NULL &&\n\t\toperand->def->class == &string_class );\n}\n\nstatic inline bool sieve_operand_is_string_literal\n(const struct sieve_operand *operand)\n{\n\treturn ( operand != NULL && sieve_operand_is(operand, string_operand) );\n}\n\n/* String list */\n\nvoid sieve_opr_stringlist_emit_start\n\t(struct sieve_binary_block *sblock, unsigned int listlen, void **context);\nvoid sieve_opr_stringlist_emit_item\n\t(struct sieve_binary_block *sblock, void *context ATTR_UNUSED,\n\t\tstring_t *item);\nvoid sieve_opr_stringlist_emit_end\n\t(struct sieve_binary_block *sblock, void *context);\nbool sieve_opr_stringlist_dump_data\n\t(const struct sieve_dumptime_env *denv, struct sieve_operand *operand,\n\t\tsieve_size_t *address, const char *field_name);\nbool sieve_opr_stringlist_dump\n\t(const struct sieve_dumptime_env *denv, sieve_size_t *address,\n\t\tconst char *field_name);\nbool sieve_opr_stringlist_dump_ex\n\t(const struct sieve_dumptime_env *denv, sieve_size_t *address,\n\t\tconst char *field_name, const char *omitted_value);\nint sieve_opr_stringlist_read_data\n\t(const struct sieve_runtime_env *renv, struct sieve_operand *operand,\n\t\tsieve_size_t *address, const char *field_name,\n\t\tstruct sieve_stringlist **strlist_r);\nint sieve_opr_stringlist_read\n\t(const struct sieve_runtime_env *renv, sieve_size_t *address,\n\t\tconst char *field_name, struct sieve_stringlist **strlist_r);\nint sieve_opr_stringlist_read_ex\n\t(const struct sieve_runtime_env *renv, sieve_size_t *address,\n\t\tconst char *field_name, bool optional, struct sieve_stringlist **strlist_r);\n\nstatic inline bool sieve_operand_is_stringlist\n(const struct sieve_operand *operand)\n{\n\treturn ( operand != NULL && operand->def != NULL &&\n\t\t(operand->def->class == &stringlist_class ||\n\t\t\toperand->def->class == &string_class) );\n}\n\n/* Catenated string */\n\nvoid sieve_opr_catenated_string_emit\n\t(struct sieve_binary_block *sblock, unsigned int elements);\n\n/*\n * Operation object\n */\n\nstruct sieve_operation_def {\n\tconst char *mnemonic;\n\n\tconst struct sieve_extension_def *ext_def;\n\tunsigned int code;\n\n\tbool (*dump)\n\t\t(const struct sieve_dumptime_env *denv, sieve_size_t *address);\n\tint (*execute)\n\t\t(const struct sieve_runtime_env *renv, sieve_size_t *address);\n};\n\nstruct sieve_operation {\n\tconst struct sieve_operation_def *def;\n\tconst struct sieve_extension *ext;\n\n\tsieve_size_t address;\n};\n\n#define sieve_operation_is(oprtn, definition) \\\n\t( (oprtn)->def == &(definition) )\n#define sieve_operation_mnemonic(oprtn) \\\n\t( (oprtn)->def == NULL ? \"(NULL)\" : (oprtn)->def->mnemonic )\n\nsieve_size_t sieve_operation_emit\n\t(struct sieve_binary_block *sblock, const struct sieve_extension *ext,\n\t\tconst struct sieve_operation_def *op_def);\nbool sieve_operation_read\n\t(struct sieve_binary_block *sblock, sieve_size_t *address,\n\t\tstruct sieve_operation *oprtn);\nconst char *sieve_operation_read_string\n\t(struct sieve_binary_block *sblock, sieve_size_t *address);\n\n/*\n * Core operations\n */\n\n/* Opcodes */\n\nenum sieve_operation_code {\n\tSIEVE_OPERATION_INVALID,\n\tSIEVE_OPERATION_JMP,\n\tSIEVE_OPERATION_JMPTRUE,\n\tSIEVE_OPERATION_JMPFALSE,\n\n\tSIEVE_OPERATION_STOP,\n\tSIEVE_OPERATION_KEEP,\n\tSIEVE_OPERATION_DISCARD,\n\tSIEVE_OPERATION_REDIRECT,\n\n\tSIEVE_OPERATION_ADDRESS,\n\tSIEVE_OPERATION_HEADER,\n\tSIEVE_OPERATION_EXISTS,\n\tSIEVE_OPERATION_SIZE_OVER,\n\tSIEVE_OPERATION_SIZE_UNDER,\n\n\tSIEVE_OPERATION_CUSTOM\n};\n\n/* Operation objects */\n\nextern const struct sieve_operation_def sieve_jmp_operation;\nextern const struct sieve_operation_def sieve_jmptrue_operation;\nextern const struct sieve_operation_def sieve_jmpfalse_operation;\n\nextern const struct sieve_operation_def *sieve_operations[];\nextern const unsigned int sieve_operations_count;\n\n#endif\n"}, "10": {"id": 10, "path": "/home/runner/work/testcc/testcc/retdec/src/lib-sieve/sieve-commands.h", "content": "#ifndef SIEVE_COMMANDS_H\n#define SIEVE_COMMANDS_H\n\n#include \"lib.h\"\n\n#include \"sieve-common.h\"\n#include \"sieve-ast.h\"\n\n/*\n * Argument definition\n */\n\nenum sieve_argument_flag {\n\t/* More than one of this (type of) tagged argument is allowed */\n\tSIEVE_ARGUMENT_FLAG_MULTIPLE = (1 << 0)\n};\n\nstruct sieve_argument_def {\n\tconst char *identifier;\n\tenum sieve_argument_flag flags;\n\n\tbool (*is_instance_of)\n\t\t(struct sieve_validator *valdtr, struct sieve_command *cmd,\n\t\t\tconst struct sieve_extension *ext, const char *identifier, void **data);\n\n\tbool (*validate)\n\t\t(struct sieve_validator *valdtr, struct sieve_ast_argument **arg,\n\t\t\tstruct sieve_command *cmd);\n\tbool (*validate_context)\n\t\t(struct sieve_validator *valdtr, struct sieve_ast_argument *arg,\n\t\t\tstruct sieve_command *cmd);\n\tbool (*validate_persistent)\n\t\t(struct sieve_validator *valdtr, struct sieve_command *cmd,\n\t\t\tconst struct sieve_extension *ext);\n\n\tbool (*generate)\n\t\t(const struct sieve_codegen_env *cgenv, struct sieve_ast_argument *arg,\n\t\t\tstruct sieve_command *cmd);\n};\n\n/*\n * Argument instance\n */\n\nstruct sieve_argument {\n\tconst struct sieve_argument_def *def;\n\tconst struct sieve_extension *ext;\n\tint id_code;\n\n\t/* Context data */\n\tvoid *data;\n};\n\n#define sieve_argument_is(ast_arg, definition) \\\n\t( (ast_arg)->argument->def == &(definition) )\n#define sieve_argument_ext(ast_arg) \\\n\t( (ast_arg)->argument->ext )\n#define sieve_argument_identifier(ast_arg) \\\n\t( (ast_arg)->argument->def->identifier )\n\n/* Utility macros */\n\n#define sieve_argument_is_string_literal(arg) \\\n\t( (arg)->argument->def == &string_argument )\n\n/* Error handling */\n\n#define sieve_argument_validate_error(validator, arg_node, ...) \\\n\tsieve_validator_error(validator, \\\n\t\t((arg_node) == NULL ? 0 : (arg_node)->source_line), \\\n\t\t__VA_ARGS__)\n#define sieve_argument_validate_warning(validator, arg_node, ...) \\\n\tsieve_validator_warning(validator, \\\n\t\t((arg_node) == NULL ? 0 : (arg_node)->source_line), \\\n\t\t__VA_ARGS__)\n\n#define sieve_argument_generate_error(gentr, arg_node, ...) \\\n\tsieve_generator_error(gentr, \\\n\t\t((arg_node) == NULL ? 0 : (arg_node)->source_line), \\\n\t\t__VA_ARGS__)\n#define sieve_argument_generate_warning(gentr, arg_node, ...) \\\n\tsieve_generator_warning(gentr, \\\n\t\t((arg_node) == NULL ? 0 : (arg_node)->source_line), \\\n\t\t__VA_ARGS__)\n\n/* Argument API */\n\nstruct sieve_argument *sieve_argument_create\n\t(struct sieve_ast *ast, const struct sieve_argument_def *def,\n\t\tconst struct sieve_extension *ext, int id_code);\n\n/* Literal arguments */\n\nextern const struct sieve_argument_def number_argument;\nextern const struct sieve_argument_def string_argument;\nextern const struct sieve_argument_def string_list_argument;\n\n/* Catenated string argument */\n\nbool sieve_arg_catenated_string_generate\n\t(const struct sieve_codegen_env *cgenv, struct sieve_ast_argument *arg,\n\t\tstruct sieve_command *context);\n\nstruct sieve_arg_catenated_string;\n\nstruct sieve_arg_catenated_string *sieve_arg_catenated_string_create\n\t(struct sieve_ast_argument *orig_arg);\nvoid sieve_arg_catenated_string_add_element\n\t(struct sieve_arg_catenated_string *strdata,\n\t\tstruct sieve_ast_argument *element);\n\n/*\n * Command definition\n */\n\nenum sieve_command_type {\n\tSCT_NONE,\n\tSCT_COMMAND,\n\tSCT_TEST,\n\tSCT_HYBRID\n};\n\nstruct sieve_command_def {\n\tconst char *identifier;\n\tenum sieve_command_type type;\n\n\t/* High-level command syntax */\n\tint positional_args;\n\tint subtests;\n\tbool block_allowed;\n\tbool block_required;\n\n\tbool (*registered)\n\t\t(struct sieve_validator *valdtr, const struct sieve_extension *ext,\n\t\t\tstruct sieve_command_registration *cmd_reg);\n\tbool (*pre_validate)\n\t\t(struct sieve_validator *valdtr, struct sieve_command *cmd);\n\tbool (*validate)\n\t\t(struct sieve_validator *valdtr, struct sieve_command *cmd);\n\tbool (*validate_const)\n\t\t(struct sieve_validator *valdtr, struct sieve_command *cmd,\n\t\t\tint *const_current, int const_next);\n\tbool (*generate)\n\t\t(const struct sieve_codegen_env *cgenv, struct sieve_command *cmd);\n\tbool (*control_generate)\n\t\t(const struct sieve_codegen_env *cgenv, struct sieve_command *cmd,\n\t\tstruct sieve_jumplist *jumps, bool jump_true);\n};\n\n/*\n * Command instance\n */\n\nstruct sieve_command {\n\tconst struct sieve_command_def *def;\n\tconst struct sieve_extension *ext;\n\n\t/* The registration of this command in the validator (sieve-validator.h) */\n\tstruct sieve_command_registration *reg;\n\n\t/* The ast node of this command */\n\tstruct sieve_ast_node *ast_node;\n\n\t/* First positional argument, found during argument validation */\n\tstruct sieve_ast_argument *first_positional;\n\n\t/* The child ast node that unconditionally exits this command's block */\n\tstruct sieve_command *block_exit_command;\n\n\t/* Context data*/\n\tvoid *data;\n};\n\n#define sieve_command_is(cmd, definition) \\\n\t( (cmd)->def == &(definition) )\n#define sieve_command_identifier(cmd) \\\n\t( (cmd)->def->identifier )\n\n#define sieve_commands_equal(cmd1, cmd2) \\\n\t( (cmd1) != NULL && (cmd2) != NULL && (cmd1)->def == (cmd2)->def )\n\n/* Context API */\n\nstruct sieve_command *sieve_command_create\n\t(struct sieve_ast_node *cmd_node, const struct sieve_extension *ext,\n\t\tconst struct sieve_command_def *cmd_def,\n\t\tstruct sieve_command_registration *cmd_reg);\n\nconst char *sieve_command_def_type_name\n\t(const struct sieve_command_def *cmd_def);\nconst char *sieve_command_type_name\n\t(const struct sieve_command *cmd);\n\nstruct sieve_command *sieve_command_prev\n\t(struct sieve_command *cmd);\nstruct sieve_command *sieve_command_parent\n\t(struct sieve_command *cmd);\n\nstruct sieve_ast_argument *sieve_command_add_dynamic_tag\n\t(struct sieve_command *cmd, const struct sieve_extension *ext,\n\t\tconst struct sieve_argument_def *tag, int id_code);\nstruct sieve_ast_argument *sieve_command_find_argument\n\t(struct sieve_command *cmd, const struct sieve_argument_def *argument);\n\nvoid sieve_command_exit_block_unconditionally\n\t(struct sieve_command *cmd);\nbool sieve_command_block_exits_unconditionally\n\t(struct sieve_command *cmd);\n\n/* Error handling */\n\n#define sieve_command_validate_error(validator, context, ...) \\\n\tsieve_validator_error(validator, \\\n\t\t((context) == NULL ? 0 : (context)->ast_node->source_line), \\\n\t\t__VA_ARGS__)\n#define sieve_command_validate_warning(validator, context, ...) \\\n\tsieve_validator_warning(validator, \\\n\t\t((context) == NULL ? 0 : (context)->ast_node->source_line), \\\n\t\t__VA_ARGS__)\n\n#define sieve_command_generate_error(gentr, context, ...) \\\n\tsieve_generator_error(gentr, \\\n\t\t((context) == NULL ? 0 : (context)->ast_node->source_line), \\\n\t\t__VA_ARGS__)\n#define sieve_command_generate_warning(gentr, context, ...) \\\n\tsieve_generator_warning(gentr, \\\n\t\t((context) == NULL ? 0 : (context)->ast_node->source_line), \\\n\t\t__VA_ARGS__)\n\n/* Utility macros */\n\n#define sieve_command_pool(context) \\\n\tsieve_ast_node_pool((context)->ast_node)\n\n#define sieve_command_source_line(context) \\\n\t(context)->ast_node->source_line\n\n#define sieve_command_first_argument(context) \\\n\tsieve_ast_argument_first((context)->ast_node)\n\n#define sieve_command_is_toplevel(context) \\\n\t( sieve_ast_node_type(sieve_ast_node_parent((context)->ast_node)) == SAT_ROOT )\n#define sieve_command_is_first(context) \\\n\t( sieve_ast_node_prev((context)->ast_node) == NULL )\n\n/*\n * Core commands\n */\n\nextern const struct sieve_command_def cmd_require;\nextern const struct sieve_command_def cmd_stop;\nextern const struct sieve_command_def cmd_if;\nextern const struct sieve_command_def cmd_elsif;\nextern const struct sieve_command_def cmd_else;\nextern const struct sieve_command_def cmd_redirect;\nextern const struct sieve_command_def cmd_keep;\nextern const struct sieve_command_def cmd_discard;\n\nextern const struct sieve_command_def *sieve_core_commands[];\nextern const unsigned int sieve_core_commands_count;\n\n/*\n * Core tests\n */\n\nextern const struct sieve_command_def tst_true;\nextern const struct sieve_command_def tst_false;\nextern const struct sieve_command_def tst_not;\nextern const struct sieve_command_def tst_anyof;\nextern const struct sieve_command_def tst_allof;\nextern const struct sieve_command_def tst_address;\nextern const struct sieve_command_def tst_header;\nextern const struct sieve_command_def tst_exists;\nextern const struct sieve_command_def tst_size;\n\nextern const struct sieve_command_def *sieve_core_tests[];\nextern const unsigned int sieve_core_tests_count;\n\n/*\n * Command utility functions\n */\n\nbool sieve_command_verify_headers_argument\n(struct sieve_validator *valdtr, struct sieve_ast_argument *headers);\n\n#endif\n"}, "11": {"id": 11, "path": "/home/runner/work/testcc/testcc/retdec/src/lib-sieve/sieve-common.h", "content": "#ifndef SIEVE_COMMON_H\n#define SIEVE_COMMON_H\n\n#include \"lib.h\"\n\n#include \"sieve-config.h\"\n#include \"sieve-types.h\"\n\n#include <sys/types.h>\n\n/*\n * Types\n */\n\ntypedef size_t sieve_size_t;\ntypedef uint32_t sieve_offset_t;\ntypedef uint64_t sieve_number_t;\n\n#define SIEVE_MAX_NUMBER ((sieve_number_t)-1)\n\n/*\n * Forward declarations\n */\n\n/* sieve-error.h */\nstruct sieve_error_handler;\n\n/* sieve-ast.h */\nenum sieve_ast_argument_type;\n\nstruct sieve_ast;\nstruct sieve_ast_node;\nstruct sieve_ast_argument;\n\n/* sieve-commands.h */\nstruct sieve_argument;\nstruct sieve_argument_def;\nstruct sieve_command;\nstruct sieve_command_def;\nstruct sieve_command_context;\nstruct sieve_command_registration;\n\n/* sieve-stringlist.h */\nstruct sieve_stringlist;\n\n/* sieve-code.h */\nstruct sieve_operation_extension;\n\n/* sieve-lexer.h */\nstruct sieve_lexer;\n\n/* sieve-parser.h */\nstruct sieve_parser;\n\n/* sieve-validator.h */\nstruct sieve_validator;\n\n/* sieve-generator.h */\nstruct sieve_jumplist;\nstruct sieve_generator;\nstruct sieve_codegen_env;\n\n/* sieve-runtime.h */\nstruct sieve_runtime_env;\n\n/* sieve-interpreter.h */\nstruct sieve_interpreter;\n\n/* sieve-dump.h */\nstruct sieve_dumptime_env;\n\n/* sieve-binary-dumper.h */\nstruct sieve_binary_dumper;\n\n/* sieve-code-dumper.h */\nstruct sieve_code_dumper;\n\n/* sieve-extension.h */\nstruct sieve_extension;\nstruct sieve_extension_def;\nstruct sieve_extension_objects;\n\n/* sieve-code.h */\nstruct sieve_operand;\nstruct sieve_operand_def;\nstruct sieve_operand_class;\nstruct sieve_operation;\nstruct sieve_coded_stringlist;\n\n/* sieve-binary.h */\nstruct sieve_binary;\nstruct sieve_binary_block;\nstruct sieve_binary_debug_writer;\nstruct sieve_binary_debug_reader;\n\n/* sieve-execute.h */\nstruct sieve_execute;\n\n/* sieve-objects.h */\nstruct sieve_object_def;\nstruct sieve_object;\n\n/* sieve-comparator.h */\nstruct sieve_comparator;\n\n/* sieve-match-types.h */\nstruct sieve_match_type;\n\n/* sieve-match.h */\nstruct sieve_match_context;\n\n/* sieve-address.h */\nstruct sieve_address_list;\n\n/* sieve-address-parts.h */\nstruct sieve_address_part_def;\nstruct sieve_address_part;\n\n/* sieve-result.h */\nstruct sieve_result;\nstruct sieve_side_effects_list;\nstruct sieve_result_print_env;\n\n/* sieve-actions.h */\nstruct sieve_action_exec_env;\nstruct sieve_action;\nstruct sieve_action_def;\nstruct sieve_side_effect;\nstruct sieve_side_effect_def;\n\n/* sieve-script.h */\nstruct sieve_script;\nstruct sieve_script_sequence;\n\n/* sieve-storage.h */\nstruct sieve_storage_class_registry;\nstruct sieve_storage;\n\n/* sieve-message.h */\nstruct sieve_message_context;\nstruct sieve_message_override;\nstruct sieve_message_override_def;\n\n/* sieve-plugins.h */\nstruct sieve_plugin;\n\n/* sieve.c */\nstruct sieve_ast *sieve_parse\n\t(struct sieve_script *script, struct sieve_error_handler *ehandler,\n\t\tenum sieve_error *error_r);\nbool sieve_validate\n\t(struct sieve_ast *ast, struct sieve_error_handler *ehandler,\n\t\tenum sieve_compile_flags flags, enum sieve_error *error_r);\n\n/*\n * Parent category\n */\n\nextern struct event_category event_category_sieve;\n\n/*\n * Sieve engine instance\n */\n\n#include \"sieve-address-source.h\"\n\nstruct sieve_instance {\n\t/* Main engine pool */\n\tpool_t pool;\n\n\t/* System environment */\n\tconst char *hostname;\n\tconst char *domainname;\n\tconst char *base_dir;\n\tconst char *temp_dir;\n\n\t/* User environment */\n\tconst char *username;\n\tconst char *home_dir;\n\n\t/* Flags */\n\tenum sieve_flag flags;\n\n\t/* Callbacks */\n\tconst struct sieve_callbacks *callbacks;\n\tvoid *context;\n\n\t/* Logging, events, and debug */\n\tstruct event *event;\n\tbool debug;\n\n\t/* Extension registry */\n\tstruct sieve_extension_registry *ext_reg;\n\n\t/* Storage class registry */\n\tstruct sieve_storage_class_registry *storage_reg;\n\n\t/* Plugin modules */\n\tstruct sieve_plugin *plugins;\n\tenum sieve_env_location env_location;\n\tenum sieve_delivery_phase delivery_phase;\n\n\t/* Settings */\n\tsize_t max_script_size;\n\tunsigned int max_actions;\n\tunsigned int max_redirects;\n\tconst struct smtp_address *user_email, *user_email_implicit;\n\tstruct sieve_address_source redirect_from;\n\tunsigned int redirect_duplicate_period;\n};\n\n/*\n * Script trace log\n */\n\nvoid sieve_trace_log_write_line\n\t(struct sieve_trace_log *trace_log, const string_t *line)\n\tATTR_NULL(2);\n\n/*\n * User e-mail address\n */\n\nconst struct smtp_address *sieve_get_user_email\n\t(struct sieve_instance *svinst);\n\n/*\n * Postmaster address \n */\n\nconst struct message_address *\nsieve_get_postmaster(const struct sieve_script_env *senv);\nconst struct smtp_address *\nsieve_get_postmaster_smtp(const struct sieve_script_env *senv);\nconst char *\nsieve_get_postmaster_address(const struct sieve_script_env *senv);\n\n#endif\n"}, "12": {"id": 12, "path": "/home/runner/work/testcc/testcc/retdec/src/lib-sieve/sieve-config.h", "content": "#ifndef SIEVE_CONFIG_H\n#define SIEVE_CONFIG_H\n\n#include \"pigeonhole-config.h\"\n#include \"pigeonhole-version.h\"\n\n#define SIEVE_IMPLEMENTATION PIGEONHOLE_NAME \" Sieve \" PIGEONHOLE_VERSION_FULL\n\n#define SIEVE_SCRIPT_FILEEXT \"sieve\"\n#define SIEVE_BINARY_FILEEXT \"svbin\"\n\n#define DEFAULT_ENVELOPE_SENDER \"MAILER-DAEMON\"\n\n#define DEFAULT_REDIRECT_DUPLICATE_PERIOD (3600 * 12)\n\n#endif\n"}, "13": {"id": 13, "path": "/home/runner/work/testcc/testcc/retdec/src/lib-sieve/sieve-dump.h", "content": "#ifndef SIEVE_DUMP_H\n#define SIEVE_DUMP_H\n\n#include \"sieve-common.h\"\n#include \"sieve-code-dumper.h\"\n#include \"sieve-binary-dumper.h\"\n\n/*\n * Dumptime environment\n */\n\nstruct sieve_dumptime_env {\n\t/* Dumpers */\n\tstruct sieve_instance *svinst;\n\tstruct sieve_binary_dumper *dumper;\n\tstruct sieve_code_dumper *cdumper;\n\n\t/* Binary */\n\tstruct sieve_binary *sbin;\n\tstruct sieve_binary_block *sblock;\n\n\t/* Code position */\n\tconst struct sieve_operation *oprtn;\n\tsieve_size_t offset;\n\n\t/* Output stream */\n\tstruct ostream *stream;\n};\n\n#endif\n"}, "14": {"id": 14, "path": "/home/runner/work/testcc/testcc/retdec/src/lib-sieve/sieve-error.h", "content": "#ifndef SIEVE_ERROR_H\n#define SIEVE_ERROR_H\n\n#include \"lib.h\"\n#include \"compat.h\"\n\n#include <stdarg.h>\n\n/*\n * Forward declarations\n */\n\nstruct var_expand_table;\n\nstruct sieve_instance;\nstruct sieve_script;\nstruct sieve_error_handler;\n\n/*\n * Types\n */\n\nenum sieve_error_flags {\n\tSIEVE_ERROR_FLAG_GLOBAL = (1 << 0),\n\tSIEVE_ERROR_FLAG_GLOBAL_MAX_INFO = (1 << 1),\n};\n\nstruct sieve_error_params {\n\tenum log_type log_type;\n\tstruct event *event;\n\n\t/* Location log command in C source code */\n\tstruct {\n\t\tconst char *filename;\n\t\tunsigned int linenum;\n\t} csrc;\n\n\t/* Location in Sieve source script */\n\tconst char *location;\n};\n\n/*\n * Utility\n */\n\n/* Converts external messages to a style that better matches Sieve user errors\n */\nconst char *sieve_error_from_external(const char *msg);\n\n/*\n * Global (user+system) errors\n */\n\nvoid sieve_global_logv(struct sieve_instance *svinst,\n\t\t       struct sieve_error_handler *ehandler,\n\t\t       const struct sieve_error_params *params,\n\t\t       const char *fmt, va_list args) ATTR_FORMAT(4, 0);\nvoid sieve_global_info_logv(struct sieve_instance *svinst,\n\t\t\t    struct sieve_error_handler *ehandler,\n\t\t\t    const struct sieve_error_params *params,\n\t\t\t    const char *fmt, va_list args) ATTR_FORMAT(4, 0);\n\nvoid sieve_global_error(struct sieve_instance *svinst,\n\t\t\tstruct sieve_error_handler *ehandler,\n\t\t\tconst char *csrc_filename,\n\t\t\tunsigned int csrc_linenum,\n\t\t\tconst char *location, const char *fmt, ...)\n\t\t\tATTR_FORMAT(6, 7);\n#define sieve_global_error(svinst, ehandler, ...) \\\n\tsieve_global_error(svinst, ehandler, __FILE__, __LINE__, __VA_ARGS__)\nvoid sieve_global_warning(struct sieve_instance *svinst,\n\t\t\t  struct sieve_error_handler *ehandler,\n\t\t\t  const char *csrc_filename,\n\t\t\t  unsigned int csrc_linenum,\n\t\t\t  const char *location, const char *fmt, ...)\n\t\t\t  ATTR_FORMAT(6, 7);\n#define sieve_global_warning(svinst, ehandler, ...) \\\n\tsieve_global_warning(svinst, ehandler, __FILE__, __LINE__, __VA_ARGS__)\nvoid sieve_global_info(struct sieve_instance *svinst,\n\t\t       struct sieve_error_handler *ehandler,\n\t\t       const char *csrc_filename,\n\t\t       unsigned int csrc_linenum,\n\t\t       const char *location, const char *fmt, ...)\n\t\t       ATTR_FORMAT(6, 7);\n#define sieve_global_info(svinst, ehandler, ...) \\\n\tsieve_global_info(svinst, ehandler, __FILE__, __LINE__, __VA_ARGS__)\nvoid sieve_global_info_error(struct sieve_instance *svinst,\n\t\t\t     struct sieve_error_handler *ehandler,\n\t\t\t     const char *csrc_filename,\n\t\t\t     unsigned int csrc_linenum,\n\t\t\t     const char *location, const char *fmt, ...)\n\t\t\t     ATTR_FORMAT(6, 7);\n#define sieve_global_info_error(svinst, ehandler, ...) \\\n\tsieve_global_info_error(svinst, ehandler, __FILE__, __LINE__, \\\n\t\t\t\t__VA_ARGS__)\nvoid sieve_global_info_warning(struct sieve_instance *svinst,\n\t\t\t       struct sieve_error_handler *ehandler,\n\t\t\t       const char *csrc_filename,\n\t\t\t       unsigned int csrc_linenum,\n\t\t\t       const char *location, const char *fmt, ...)\n\t\t\t       ATTR_FORMAT(6, 7);\n#define sieve_global_info_warning(svinst, ehandler, ...) \\\n\tsieve_global_info_warning(svinst, ehandler, __FILE__, __LINE__, \\\n\t\t\t\t  __VA_ARGS__)\n\n/*\n * Main (user) error functions\n */\n\n/* For these functions it is the responsibility of the caller to\n * manage the datastack.\n */\n\nconst char *\nsieve_error_script_location(const struct sieve_script *script,\n\t\t\t    unsigned int source_line);\n\nvoid sieve_logv(struct sieve_error_handler *ehandler,\n\t\tconst struct sieve_error_params *params,\n\t\tconst char *fmt, va_list args) ATTR_FORMAT(3, 0);\n\nvoid sieve_event_logv(struct sieve_instance *svinst,\n\t\t      struct sieve_error_handler *ehandler,\n\t\t      struct event *event, enum log_type log_type,\n\t\t      const char *csrc_filename, unsigned int csrc_linenum,\n\t\t      const char *location, enum sieve_error_flags flags,\n\t\t      const char *fmt, va_list args) ATTR_FORMAT(9, 0);\nvoid sieve_event_log(struct sieve_instance *svinst,\n\t\t     struct sieve_error_handler *ehandler,\n\t\t     struct event *event, enum log_type log_type,\n\t\t     const char *csrc_filename, unsigned int csrc_linenum,\n\t\t     const char *location, enum sieve_error_flags flags,\n\t\t     const char *fmt, ...) ATTR_FORMAT(9, 10);\n#define sieve_event_log(svinst, ehandler, event, log_type, ...) \\\n\tsieve_event_log(svinst, ehandler, event, log_type, __FILE__, __LINE__, \\\n\t\t\t__VA_ARGS__)\n\nvoid sieve_criticalv(struct sieve_instance *svinst,\n\t\t     struct sieve_error_handler *ehandler,\n\t\t     const struct sieve_error_params *params,\n\t\t     const char *user_prefix, const char *fmt, va_list args)\n\t\t     ATTR_FORMAT(5, 0);\n\nvoid sieve_error(struct sieve_error_handler *ehandler,\n\t\t const char *csrc_filename, unsigned int csrc_linenum,\n\t\t const char *location, const char *fmt, ...) ATTR_FORMAT(5, 6);\n#define sieve_error(ehandler, ...) \\\n\tsieve_error(ehandler, __FILE__, __LINE__, __VA_ARGS__)\nvoid sieve_warning(struct sieve_error_handler *ehandler,\n\t\t   const char *csrc_filename, unsigned int csrc_linenum,\n\t\t   const char *location, const char *fmt, ...)\n\t\t   ATTR_FORMAT(5, 6);\n#define sieve_warning(ehandler, ...) \\\n\tsieve_warning(ehandler, __FILE__, __LINE__, __VA_ARGS__)\nvoid sieve_info(struct sieve_error_handler *ehandler,\n\t\tconst char *csrc_filename, unsigned int csrc_linenum,\n\t\tconst char *location, const char *fmt, ...) ATTR_FORMAT(5, 6);\n#define sieve_info(ehandler, ...) \\\n\tsieve_info(ehandler, __FILE__, __LINE__, __VA_ARGS__)\nvoid sieve_debug(struct sieve_error_handler *ehandler,\n\t\t const char *csrc_filename, unsigned int csrc_linenum,\n\t\t const char *location, const char *fmt, ...) ATTR_FORMAT(5, 6);\n#define sieve_debug(ehandler, ...) \\\n\tsieve_debug(ehandler, __FILE__, __LINE__, __VA_ARGS__)\nvoid sieve_critical(struct sieve_instance *svinst,\n\t\t    struct sieve_error_handler *ehandler,\n\t\t    const char *csrc_filename, unsigned int csrc_linenum,\n\t\t    const char *location, const char *user_prefix,\n\t\t    const char *fmt, ...) ATTR_FORMAT(7, 8);\n#define sieve_critical(svinst, ehandler, ...) \\\n\tsieve_critical(svinst, ehandler, __FILE__, __LINE__, __VA_ARGS__)\n\n\nvoid sieve_internal_error_params(struct sieve_error_handler *ehandler,\n\t\t\t\t const struct sieve_error_params *params,\n\t\t\t\t const char *user_prefix);\nvoid sieve_internal_error(struct sieve_error_handler *ehandler,\n\t\t\t  const char *csrc_filename, unsigned int csrc_linenum,\n\t\t\t  const char *location, const char *user_prefix)\n\t\t\t  ATTR_NULL(1, 4, 5);\n#define sieve_internal_error(ehandler, ...) \\\n\tsieve_internal_error(ehandler, __FILE__, __LINE__, __VA_ARGS__)\n\n/*\n * Error handler configuration\n */\n\nvoid sieve_error_handler_accept_infolog(struct sieve_error_handler *ehandler,\n\t\t\t\t\tbool enable);\nvoid sieve_error_handler_accept_debuglog(struct sieve_error_handler *ehandler,\n\t\t\t\t\t bool enable);\n\n/*\n * Error handler statistics\n */\n\nunsigned int sieve_get_errors(struct sieve_error_handler *ehandler);\nunsigned int sieve_get_warnings(struct sieve_error_handler *ehandler);\n\nbool sieve_errors_more_allowed(struct sieve_error_handler *ehandler);\n\n/*\n * Error handler object\n */\n\nvoid sieve_error_handler_ref(struct sieve_error_handler *ehandler);\nvoid sieve_error_handler_unref(struct sieve_error_handler **ehandler);\n\nvoid sieve_error_handler_reset(struct sieve_error_handler *ehandler);\n\n/*\n * Error handlers\n */\n\n/* Write errors to dovecot master log */\nstruct sieve_error_handler *\nsieve_master_ehandler_create(struct sieve_instance *svinst,\n\t\t\t     unsigned int max_errors);\n\n/* Write errors to stderr */\nstruct sieve_error_handler *\nsieve_stderr_ehandler_create(struct sieve_instance *svinst,\n\t\t\t     unsigned int max_errors);\n\n/* Write errors into a string buffer */\nstruct sieve_error_handler *\nsieve_strbuf_ehandler_create(struct sieve_instance *svinst, string_t *strbuf,\n\t\t\t     bool crlf, unsigned int max_errors);\n\n/* Write errors to a logfile */\nstruct sieve_error_handler *\nsieve_logfile_ehandler_create(struct sieve_instance *svinst,\n\t\t\t      const char *logfile, unsigned int max_errors);\n\n#endif\n"}, "15": {"id": 15, "path": "/home/runner/work/testcc/testcc/retdec/src/lib-sieve/sieve-execute.h", "content": "#ifndef SIEVE_EXECUTE_H\n#define SIEVE_EXECUTE_H\n\n#include \"sieve-common.h\"\n\nstruct sieve_execute_env {\n\tstruct sieve_instance *svinst;\n\tpool_t pool;\n\n\tenum sieve_execute_flags flags;\n\tstruct event *event;\n\n\tconst struct sieve_message_data *msgdata;\n\tconst struct sieve_script_env *scriptenv;\n\n\tstruct sieve_exec_status *exec_status;\n};\n\nvoid sieve_execute_init(struct sieve_execute_env *eenv,\n\t\t\tstruct sieve_instance *svinst, pool_t pool,\n\t\t\tconst struct sieve_message_data *msgdata,\n\t\t\tconst struct sieve_script_env *senv,\n\t\t\tenum sieve_execute_flags flags);\nvoid sieve_execute_deinit(struct sieve_execute_env *eenv);\n\n#endif\n"}, "16": {"id": 16, "path": "/home/runner/work/testcc/testcc/retdec/src/lib-sieve/sieve-extensions.h", "content": "#ifndef SIEVE_EXTENSIONS_H\n#define SIEVE_EXTENSIONS_H\n\n#include \"lib.h\"\n#include \"sieve-common.h\"\n\n/*\n * Per-extension object registry\n */\n\nstruct sieve_extension_objects {\n\tconst void *objects;\n\tunsigned int count;\n};\n\n/*\n * Extension definition\n */\n\nstruct sieve_extension_def {\n\tconst char *name;\n\n\t/* Version */\n\tunsigned int version;\n\n\t/* Registration */\n\tbool (*load)(const struct sieve_extension *ext, void **context);\n\tvoid (*unload)(const struct sieve_extension *ext);\n\n\t/* Compilation */\n\tbool (*validator_load)\n\t\t(const struct sieve_extension *ext, struct sieve_validator *validator);\n\tbool (*generator_load)\n\t\t(const struct sieve_extension *ext, const struct sieve_codegen_env *cgenv);\n\tbool (*interpreter_load)\n\t\t(const struct sieve_extension *ext, const struct sieve_runtime_env *renv,\n\t\t\tsieve_size_t *address);\n\tbool (*binary_load)\n\t\t(const struct sieve_extension *ext, struct sieve_binary *binary);\n\n\t/* Code dump */\n\tbool (*binary_dump)\n\t\t(const struct sieve_extension *ext, struct sieve_dumptime_env *denv);\n\tbool (*code_dump)\n\t\t(const struct sieve_extension *ext, const struct sieve_dumptime_env *denv,\n\t\t\tsieve_size_t *address);\n\n\t/* Objects */\n\tstruct sieve_extension_objects operations;\n\tstruct sieve_extension_objects operands;\n};\n\n/* Defining opcodes and operands */\n\n#define SIEVE_EXT_DEFINE_NO_OBJECTS \\\n\t{ NULL, 0 }\n#define SIEVE_EXT_DEFINE_OBJECT(OBJ) \\\n\t{ &OBJ, 1 }\n#define SIEVE_EXT_DEFINE_OBJECTS(OBJS) \\\n\t{ OBJS, N_ELEMENTS(OBJS) }\n\n#define SIEVE_EXT_GET_OBJECTS_COUNT(ext, field) \\\n\text->field->count;\n\n#define SIEVE_EXT_DEFINE_NO_OPERATIONS \\\n\t.operations = SIEVE_EXT_DEFINE_NO_OBJECTS\n#define SIEVE_EXT_DEFINE_OPERATION(OP) \\\n\t.operations = SIEVE_EXT_DEFINE_OBJECT(OP)\n#define SIEVE_EXT_DEFINE_OPERATIONS(OPS) \\\n\t.operations = SIEVE_EXT_DEFINE_OBJECTS(OPS)\n\n#define SIEVE_EXT_DEFINE_NO_OPERANDS \\\n\t.operands = SIEVE_EXT_DEFINE_NO_OBJECTS\n#define SIEVE_EXT_DEFINE_OPERAND(OP) \\\n\t.operands = SIEVE_EXT_DEFINE_OBJECT(OP)\n#define SIEVE_EXT_DEFINE_OPERANDS(OPS) \\\n\t.operands = SIEVE_EXT_DEFINE_OBJECTS(OPS)\n\n/*\n * Extension instance\n */\n\nstruct sieve_extension {\n\tconst struct sieve_extension_def *def;\n\tint id;\n\n\tstruct sieve_instance *svinst;\n\tvoid *context;\n\n\tbool required:1;\n\tbool loaded:1;\n\tbool enabled:1;\n\tbool dummy:1;\n\tbool global:1;\n\tbool implicit:1;\n\tbool overridden:1;\n};\n\n#define sieve_extension_is(ext, definition) \\\n\t( (ext)->def == &(definition) )\n#define sieve_extension_name(ext) \\\n\t((ext)->def->name)\n#define sieve_extension_name_is(ext, _name) \\\n\t( strcmp((ext)->def->name, (_name)) == 0 )\n#define sieve_extension_version(ext) \\\n\t((ext)->def->version)\n#define sieve_extension_version_is(ext, _version) \\\n\t((ext)->def->version == (_version))\n\n/*\n * Extensions init/deinit\n */\n\nbool sieve_extensions_init(struct sieve_instance *svinst);\nvoid sieve_extensions_configure(struct sieve_instance *svinst);\nvoid sieve_extensions_deinit(struct sieve_instance *svinst);\n\n/*\n * Pre-loaded extensions\n */\n\nconst struct sieve_extension *const *sieve_extensions_get_preloaded\n\t(struct sieve_instance *svinst, unsigned int *count_r);\n\n/*\n * Extension registry\n */\n\nconst struct sieve_extension *sieve_extension_register\n\t(struct sieve_instance *svinst, const struct sieve_extension_def *extension,\n\t\tbool load);\nconst struct sieve_extension *sieve_extension_require\n\t(struct sieve_instance *svinst, const struct sieve_extension_def *extension,\n\t\tbool load);\nbool sieve_extension_reload(const struct sieve_extension *ext);\n\nvoid sieve_extension_unregister(const struct sieve_extension *ext);\n\nconst struct sieve_extension *sieve_extension_replace\n\t(struct sieve_instance *svinst,\n\t\tconst struct sieve_extension_def *extdef,\n\t\tbool load);\nvoid sieve_extension_override\n\t(struct sieve_instance *svinst, const char *name,\n\t\tconst struct sieve_extension *ext);\n\nunsigned int sieve_extensions_get_count(struct sieve_instance *svinst);\nconst struct sieve_extension *const *\nsieve_extensions_get_all(struct sieve_instance *svinst,\n\tunsigned int *count_r);\n\nconst struct sieve_extension *sieve_extension_get_by_id\n\t(struct sieve_instance *svinst, unsigned int ext_id);\nconst struct sieve_extension *sieve_extension_get_by_name\n\t(struct sieve_instance *svinst, const char *name);\n\nconst char *sieve_extensions_get_string\n\t(struct sieve_instance *svinst);\nvoid sieve_extensions_set_string\n\t(struct sieve_instance *svinst, const char *ext_string,\n\t\tbool global, bool implicit);\n\nconst struct sieve_extension *sieve_get_match_type_extension\n\t(struct sieve_instance *svinst);\nconst struct sieve_extension *sieve_get_comparator_extension\n\t(struct sieve_instance *svinst);\nconst struct sieve_extension *sieve_get_address_part_extension\n\t(struct sieve_instance *svinst);\n\nvoid sieve_enable_debug_extension(struct sieve_instance *svinst);\n\n/*\n * Capability registries\n */\n\nstruct sieve_extension_capabilities {\n\tconst char *name;\n\n\tconst char *(*get_string)(const struct sieve_extension *ext);\n};\n\nvoid sieve_extension_capabilities_register\n\t(const struct sieve_extension *ext,\n\t\tconst struct sieve_extension_capabilities *cap);\nvoid sieve_extension_capabilities_unregister\n\t(const struct sieve_extension *ext);\n\nconst char *sieve_extension_capabilities_get_string\n\t(struct sieve_instance *svinst, const char *cap_name);\n\n#endif\n"}, "17": {"id": 17, "path": "/home/runner/work/testcc/testcc/retdec/src/lib-sieve/sieve-generator.h", "content": "#ifndef SIEVE_GENERATOR_H\n#define SIEVE_GENERATOR_H\n\n#include \"sieve-common.h\"\n\n/*\n * Code generator\n */\n\nstruct sieve_generator;\n\nstruct sieve_codegen_env {\n\tstruct sieve_generator *gentr;\n\n\tstruct sieve_instance *svinst;\n\tenum sieve_compile_flags flags;\n\n\tstruct sieve_script *script;\n\tstruct sieve_ast *ast;\n\n\tstruct sieve_binary *sbin;\n\tstruct sieve_binary_block *sblock;\n};\n\nstruct sieve_generator *\nsieve_generator_create(struct sieve_ast *ast,\n\t\t       struct sieve_error_handler *ehandler,\n\t\t       enum sieve_compile_flags flags);\nvoid sieve_generator_free(struct sieve_generator **generator);\n\n/*\n * Accessors\n */\n\nstruct sieve_error_handler *\nsieve_generator_error_handler(struct sieve_generator *gentr);\npool_t sieve_generator_pool(struct sieve_generator *gentr);\nstruct sieve_script *sieve_generator_script(struct sieve_generator *gentr);\nstruct sieve_binary *sieve_generator_get_binary(struct sieve_generator *gentr);\nstruct sieve_binary_block *\nsieve_generator_get_block(struct sieve_generator *gentr);\n\n/*\n * Extension support\n */\n\nvoid sieve_generator_extension_set_context(struct sieve_generator *gentr,\n\t\t\t\t\t   const struct sieve_extension *ext,\n\t\t\t\t\t   void *context);\nconst void *\nsieve_generator_extension_get_context(struct sieve_generator *gentr,\n\t\t\t\t      const struct sieve_extension *ext);\n\n/*\n * Jump list\n */\n\nstruct sieve_jumplist {\n\tpool_t pool;\n\tstruct sieve_binary_block *block;\n\tARRAY(sieve_size_t) jumps;\n};\n\nstruct sieve_jumplist *\nsieve_jumplist_create(pool_t pool, struct sieve_binary_block *sblock);\nvoid sieve_jumplist_init_temp(struct sieve_jumplist *jlist,\n\t\t\t      struct sieve_binary_block *sblock);\nvoid sieve_jumplist_reset(struct sieve_jumplist *jlist);\nvoid sieve_jumplist_add(struct sieve_jumplist *jlist, sieve_size_t jump);\nvoid sieve_jumplist_resolve(struct sieve_jumplist *jlist);\n\n/*\n * Code generation API\n */\n\nbool sieve_generate_argument(const struct sieve_codegen_env *cgenv,\n\t\t\t     struct sieve_ast_argument *arg,\n\t\t\t     struct sieve_command *cmd);\nbool sieve_generate_arguments(const struct sieve_codegen_env *cgenv,\n\t\t\t      struct sieve_command *cmd,\n\t\t\t      struct sieve_ast_argument **last_arg_r);\nbool sieve_generate_argument_parameters(const struct sieve_codegen_env *cgenv,\n\t\t\t\t\tstruct sieve_command *cmd,\n\t\t\t\t\tstruct sieve_ast_argument *arg);\n\nbool sieve_generate_block(const struct sieve_codegen_env *cgenv,\n\t\t\t  struct sieve_ast_node *block);\nbool sieve_generate_test(const struct sieve_codegen_env *cgenv,\n\t\t\t struct sieve_ast_node *tst_node,\n\t\t\t struct sieve_jumplist *jlist, bool jump_true);\nstruct sieve_binary *\nsieve_generator_run(struct sieve_generator *gentr,\n\t\t    struct sieve_binary_block **sblock_r);\n\n/*\n * Error handling\n */\n\nvoid sieve_generator_error(struct sieve_generator *gentr,\n\t\t\t   const char *csrc_filename, unsigned int csrc_linenum,\n\t\t\t   unsigned int source_line, const char *fmt, ...)\n\t\t\t   ATTR_FORMAT(5, 6);\n#define sieve_generator_error(gentr, ...) \\\n\tsieve_generator_error(gentr, __FILE__, __LINE__, __VA_ARGS__)\nvoid sieve_generator_warning(struct sieve_generator *gentr,\n\t\t\t     const char *csrc_filename,\n\t\t\t     unsigned int csrc_linenum,\n\t\t\t     unsigned int source_line, const char *fmt, ...)\n\t\t\t     ATTR_FORMAT(5, 6);\n#define sieve_generator_warning(gentr, ...) \\\n\tsieve_generator_warning(gentr, __FILE__, __LINE__, __VA_ARGS__)\nvoid sieve_generator_critical(struct sieve_generator *gentr,\n\t\t\t      const char *csrc_filename,\n\t\t\t      unsigned int csrc_linenum,\n\t\t\t      unsigned int source_line, const char *fmt, ...)\n\t\t\t      ATTR_FORMAT(5, 6);\n#define sieve_generator_critical(gentr, ...) \\\n\tsieve_generator_critical(gentr, __FILE__, __LINE__, __VA_ARGS__)\n\n#endif\n\n"}, "18": {"id": 18, "path": "/home/runner/work/testcc/testcc/retdec/src/lib-sieve/sieve-interpreter.h", "content": "#ifndef SIEVE_INTERPRETER_H\n#define SIEVE_INTERPRETER_H\n\n#include \"lib.h\"\n#include \"array.h\"\n#include \"buffer.h\"\n\n#include \"sieve-common.h\"\n#include \"sieve-runtime.h\"\n\n/*\n * Interpreter\n */\n\nstruct sieve_interpreter *\nsieve_interpreter_create(struct sieve_binary *sbin,\n\t\t\t struct sieve_interpreter *parent,\n\t\t\t const struct sieve_execute_env *eenv,\n\t\t\t struct sieve_error_handler *ehandler) ATTR_NULL(2);\nstruct sieve_interpreter *\nsieve_interpreter_create_for_block(struct sieve_binary_block *sblock,\n\t\t\t\t   struct sieve_script *script,\n\t\t\t\t   struct sieve_interpreter *parent,\n\t\t\t\t   const struct sieve_execute_env *eenv,\n\t\t\t\t   struct sieve_error_handler *ehandler)\n\t\t\t\t   ATTR_NULL(3);\nvoid sieve_interpreter_free(struct sieve_interpreter **_interp);\n\n/*\n * Accessors\n */\n\npool_t sieve_interpreter_pool(struct sieve_interpreter *interp);\nstruct sieve_interpreter *\nsieve_interpreter_get_parent(struct sieve_interpreter *interp);\nstruct sieve_script *sieve_interpreter_script(struct sieve_interpreter *interp);\nstruct sieve_error_handler *\nsieve_interpreter_get_error_handler(struct sieve_interpreter *interp);\nstruct sieve_instance *\nsieve_interpreter_svinst(struct sieve_interpreter *interp);\n\n/* Do not use this function for normal sieve extensions. This is intended for\n * the testsuite only.\n */\nvoid sieve_interpreter_set_result(struct sieve_interpreter *interp,\n\t\t\t\t  struct sieve_result *result);\n\n/*\n * Loop handling\n */\n\nstruct sieve_interpreter_loop;\n\nint sieve_interpreter_loop_start(struct sieve_interpreter *interp,\n\t\t\t\t sieve_size_t loop_end,\n\t\t\t\t const struct sieve_extension_def *ext_def,\n\t\t\t\t struct sieve_interpreter_loop **loop_r);\nstruct sieve_interpreter_loop *\nsieve_interpreter_loop_get(struct sieve_interpreter *interp,\n\t\t\t   sieve_size_t loop_end,\n\t\t\t   const struct sieve_extension_def *ext_def);\nint sieve_interpreter_loop_next(struct sieve_interpreter *interp,\n\t\t\t\tstruct sieve_interpreter_loop *loop,\n\t\t\t\tsieve_size_t loop_begin);\nint sieve_interpreter_loop_break(struct sieve_interpreter *interp,\n\t\t\t\t struct sieve_interpreter_loop *loop);\n\nstruct sieve_interpreter_loop *\nsieve_interpreter_loop_get_local(struct sieve_interpreter *interp,\n\t\t\t\t struct sieve_interpreter_loop *loop,\n\t\t\t\t const struct sieve_extension_def *ext_def)\n\t\t\t\t ATTR_NULL(2, 3);\nstruct sieve_interpreter_loop *\nsieve_interpreter_loop_get_global(struct sieve_interpreter *interp,\n\t\t\t\t  struct sieve_interpreter_loop *loop,\n\t\t\t\t  const struct sieve_extension_def *ext_def)\n\t\t\t\t  ATTR_NULL(2, 3);\n\npool_t sieve_interpreter_loop_get_pool(struct sieve_interpreter_loop *loop)\n\t\t\t\t       ATTR_PURE;\nvoid *sieve_interpreter_loop_get_context(struct sieve_interpreter_loop *loop)\n\t\t\t\t\t ATTR_PURE;\nvoid sieve_interpreter_loop_set_context(struct sieve_interpreter_loop *loop,\n\t\t\t\t\tvoid *context);\n\n/*\n * Program flow\n */\n\nvoid sieve_interpreter_reset(struct sieve_interpreter *interp);\nvoid sieve_interpreter_interrupt(struct sieve_interpreter *interp);\nsieve_size_t\nsieve_interpreter_program_counter(struct sieve_interpreter *interp);\n\nint sieve_interpreter_program_jump_to(struct sieve_interpreter *interp,\n\t\t\t\t      sieve_size_t jmp_target,\n\t\t\t\t      bool break_loops);\nint sieve_interpreter_program_jump(struct sieve_interpreter *interp, bool jump,\n\t\t\t\t   bool break_loops);\n\n/*\n * Test results\n */\n\nvoid sieve_interpreter_set_test_result(struct sieve_interpreter *interp,\n\t\t\t\t       bool result);\nbool sieve_interpreter_get_test_result(struct sieve_interpreter *interp);\n\n/*\n * Source location\n */\n\nunsigned int\nsieve_runtime_get_source_location(const struct sieve_runtime_env *renv,\n\t\t\t\t  sieve_size_t code_address);\n\nunsigned int\nsieve_runtime_get_command_location(const struct sieve_runtime_env *renv);\nconst char *\nsieve_runtime_get_full_command_location(const struct sieve_runtime_env *renv);\n\n/*\n * Extension support\n */\n\nstruct sieve_interpreter_extension {\n\tconst struct sieve_extension_def *ext_def;\n\n\tint (*run)(const struct sieve_extension *ext,\n\t\t   const struct sieve_runtime_env *renv,\n\t\t   void *context, bool deferred);\n\tvoid (*free)(const struct sieve_extension *ext,\n\t\t     struct sieve_interpreter *interp, void *context);\n};\n\nvoid sieve_interpreter_extension_register(\n\tstruct sieve_interpreter *interp, const struct sieve_extension *ext,\n\tconst struct sieve_interpreter_extension *intext, void *context);\nvoid sieve_interpreter_extension_set_context(\n\tstruct sieve_interpreter *interp, const struct sieve_extension *ext,\n\tvoid *context);\nvoid *sieve_interpreter_extension_get_context(\n\tstruct sieve_interpreter *interp, const struct sieve_extension *ext);\n\nint sieve_interpreter_extension_start(struct sieve_interpreter *interp,\n\t\t\t\t      const struct sieve_extension *ext);\n\n/*\n * Opcodes and operands\n */\n\nint sieve_interpreter_handle_optional_operands(\n\tconst struct sieve_runtime_env *renv, sieve_size_t *address,\n\tstruct sieve_side_effects_list **list);\n\n/*\n * Code execute\n */\n\nint sieve_interpreter_continue(struct sieve_interpreter *interp,\n\t\t\t       bool *interrupted);\nint sieve_interpreter_start(struct sieve_interpreter *interp,\n\t\t\t    struct sieve_result *result, bool *interrupted);\nint sieve_interpreter_run(struct sieve_interpreter *interp,\n\t\t\t  struct sieve_result *result);\n\n/*\n * Error handling\n */\n\nvoid sieve_runtime_error(const struct sieve_runtime_env *renv,\n\t\t\t const char *csrc_filename, unsigned int csrc_linenum,\n\t\t\t const char *location, const char *fmt, ...)\n\t\t\t ATTR_FORMAT(5, 6);\n#define sieve_runtime_error(renv, ...) \\\n\tsieve_runtime_error(renv, __FILE__, __LINE__, __VA_ARGS__)\nvoid sieve_runtime_warning(const struct sieve_runtime_env *renv,\n\t\t\t   const char *csrc_filename, unsigned int csrc_linenum,\n\t\t\t   const char *location, const char *fmt, ...)\n\t\t\t   ATTR_FORMAT(5, 6);\n#define sieve_runtime_warning(renv, ...) \\\n\tsieve_runtime_warning(renv, __FILE__, __LINE__, __VA_ARGS__)\nvoid sieve_runtime_log(const struct sieve_runtime_env *renv,\n\t\t       const char *csrc_filename, unsigned int csrc_linenum,\n\t\t       const char *location, const char *fmt, ...)\n\t\t       ATTR_FORMAT(5, 6);\n#define sieve_runtime_log(renv, ...) \\\n\tsieve_runtime_log(renv, __FILE__, __LINE__, __VA_ARGS__)\nvoid sieve_runtime_critical(const struct sieve_runtime_env *renv,\n\t\t\t    const char *csrc_filename,\n\t\t\t    unsigned int csrc_linenum,\n\t\t\t    const char *location, const char *user_prefix,\n\t\t\t    const char *fmt, ...) ATTR_FORMAT(6, 7);\n#define sieve_runtime_critical(renv, ...) \\\n\tsieve_runtime_critical(renv, __FILE__, __LINE__, __VA_ARGS__)\nint sieve_runtime_mail_error(const struct sieve_runtime_env *renv,\n\t\t\t     struct mail *mail, \n\t\t\t     const char *csrc_filename,\n\t\t\t     unsigned int csrc_linenum,\n\t\t\t     const char *fmt, ...) ATTR_FORMAT(5, 6);\n#define sieve_runtime_mail_error(renv, mail, ...) \\\n\tsieve_runtime_mail_error(renv, mail, __FILE__, __LINE__, __VA_ARGS__)\n\n#endif\n"}, "19": {"id": 19, "path": "/home/runner/work/testcc/testcc/retdec/src/lib-sieve/sieve-runtime-trace.h", "content": "#ifndef SIEVE_RUNTIME_TRACE_H\n#define SIEVE_RUNTIME_TRACE_H\n\n#include \"sieve-common.h\"\n#include \"sieve-runtime.h\"\n\n/*\n * Runtime trace\n */\n\nstruct sieve_runtime_trace {\n\tstruct sieve_trace_config config;\n\tstruct sieve_trace_log *log;\n\tunsigned int indent;\n};\n\n/* Trace configuration */\n\nstatic inline bool sieve_runtime_trace_active\n(const struct sieve_runtime_env *renv, sieve_trace_level_t trace_level)\n{\n\treturn ( renv->trace != NULL && trace_level <= renv->trace->config.level );\n}\n\nstatic inline bool sieve_runtime_trace_hasflag\n(const struct sieve_runtime_env *renv, unsigned int flag)\n{\n\treturn ( renv->trace != NULL && (renv->trace->config.flags & flag) != 0 );\n}\n\n/* Trace indent */\n\nstatic inline void sieve_runtime_trace_descend\n(const struct sieve_runtime_env *renv)\n{\n\tif ( renv->trace != NULL ) renv->trace->indent++;\n}\n\nstatic inline void sieve_runtime_trace_ascend\n(const struct sieve_runtime_env *renv)\n{\n\tif ( renv->trace != NULL ) renv->trace->indent--;\n}\n\nstatic inline void sieve_runtime_trace_toplevel\n(const struct sieve_runtime_env *renv)\n{\n\tif ( renv->trace != NULL ) renv->trace->indent = 0;\n}\n\n/* Trace errors */\n\nvoid _sieve_runtime_trace_error\n\t(const struct sieve_runtime_env *renv, const char *fmt, va_list args)\n\t\tATTR_FORMAT(2, 0);\n\nvoid _sieve_runtime_trace_operand_error\n\t(const struct sieve_runtime_env *renv, const struct sieve_operand *oprnd,\n\t\tconst char *fmt, va_list args) ATTR_FORMAT(3, 0);\n\nstatic inline void sieve_runtime_trace_error\n\t(const struct sieve_runtime_env *renv, const char *fmt, ...)\n\t\tATTR_FORMAT(2, 3);\n\nstatic inline void sieve_runtime_trace_operand_error\n\t(const struct sieve_runtime_env *renv, const struct sieve_operand *oprnd,\n\t\tconst char *fmt, ...) ATTR_FORMAT(3, 4);\n\nstatic inline void ATTR_FORMAT(2, 3) sieve_runtime_trace_error\n\t(const struct sieve_runtime_env *renv, const char *fmt, ...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tif ( renv->trace != NULL )\n\t\t_sieve_runtime_trace_error(renv, fmt, args);\n\tva_end(args);\n}\n\nstatic inline void ATTR_FORMAT(3, 4) sieve_runtime_trace_operand_error\n\t(const struct sieve_runtime_env *renv, const struct sieve_operand *oprnd,\n\t\tconst char *fmt, ...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tif ( renv->trace != NULL )\n\t\t_sieve_runtime_trace_operand_error(renv, oprnd, fmt, args);\n\tva_end(args);\n}\n\n/* Trace info */\n\nvoid _sieve_runtime_trace\n\t(const struct sieve_runtime_env *renv, const char *fmt, va_list args)\n\t\tATTR_FORMAT(2, 0);\n\nstatic inline void sieve_runtime_trace\n\t(const struct sieve_runtime_env *renv, sieve_trace_level_t trace_level,\n\t\tconst char *fmt, ...) ATTR_FORMAT(3, 4);\n\nstatic inline void ATTR_FORMAT(3, 4) sieve_runtime_trace\n(const struct sieve_runtime_env *renv, sieve_trace_level_t trace_level,\n\tconst char *fmt, ...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\n\tif ( renv->trace != NULL && trace_level <= renv->trace->config.level ) {\n\t\t_sieve_runtime_trace(renv, fmt, args);\n\t}\n\n\tva_end(args);\n}\n\nvoid _sieve_runtime_trace_address\n\t(const struct sieve_runtime_env *renv, sieve_size_t address,\n\t\tconst char *fmt, va_list args) ATTR_FORMAT(3, 0);\n\nstatic inline void sieve_runtime_trace_address\n\t(const struct sieve_runtime_env *renv, sieve_trace_level_t trace_level,\n\t\tsieve_size_t address, const char *fmt, ...) ATTR_FORMAT(4, 5);\n\nstatic inline void ATTR_FORMAT(4, 5) sieve_runtime_trace_address\n(const struct sieve_runtime_env *renv, sieve_trace_level_t trace_level,\n\tsieve_size_t address, const char *fmt, ...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\n\tif ( renv->trace != NULL && trace_level <= renv->trace->config.level ) {\n\t\t_sieve_runtime_trace_address(renv, address, fmt, args);\n\t}\n\n\tva_end(args);\n}\n\nstatic inline void ATTR_FORMAT(3, 4) sieve_runtime_trace_here\n(const struct sieve_runtime_env *renv, sieve_trace_level_t trace_level,\n\tconst char *fmt, ...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\n\tif ( renv->trace != NULL && trace_level <= renv->trace->config.level ) {\n\t\t_sieve_runtime_trace_address(renv, renv->pc, fmt, args);\n\t}\n\n\tva_end(args);\n}\n\n/* Trace boundaries */\n\nvoid _sieve_runtime_trace_begin(const struct sieve_runtime_env *renv);\nvoid _sieve_runtime_trace_end(const struct sieve_runtime_env *renv);\nvoid _sieve_runtime_trace_sep(const struct sieve_runtime_env *renv);\n\nstatic inline void sieve_runtime_trace_begin\n(const struct sieve_runtime_env *renv)\n{\n\tif ( renv->trace != NULL )\n\t\t_sieve_runtime_trace_begin(renv);\n}\n\nstatic inline void sieve_runtime_trace_end\n(const struct sieve_runtime_env *renv)\n{\n\tif ( renv->trace != NULL )\n\t\t_sieve_runtime_trace_end(renv);\n}\n\nstatic inline void sieve_runtime_trace_sep\n(const struct sieve_runtime_env *renv)\n{\n\tif ( renv->trace != NULL )\n\t\t_sieve_runtime_trace_sep(renv);\n}\n\n#endif\n"}, "20": {"id": 20, "path": "/home/runner/work/testcc/testcc/retdec/src/lib-sieve/sieve-runtime.h", "content": "#ifndef SIEVE_RUNTIME_H\n#define SIEVE_RUNTIME_H\n\n#include \"sieve-common.h\"\n#include \"sieve-execute.h\"\n\n/*\n * Runtime environment\n */\n\nstruct sieve_runtime_env {\n\tconst struct sieve_execute_env *exec_env;\n\tstruct event *event;\n\n\t/* Interpreter */\n\tstruct sieve_interpreter *interp;\n\tstruct sieve_error_handler *ehandler;\n\n\t/* Executing script */\n\tstruct sieve_script *script;\n\n\t/* Executing binary */\n\tstruct sieve_binary *sbin;\n\tstruct sieve_binary_block *sblock;\n\n\t/* Current code */\n\tsieve_size_t pc;\n\tconst struct sieve_operation *oprtn;\n\n\t/* Tested message */\n\tstruct sieve_message_context *msgctx;\n\n\t/* Filter result */\n\tstruct sieve_result *result;\n\n\t/* Runtime tracing */\n\tstruct sieve_runtime_trace *trace;\n};\n\n#endif\n"}, "21": {"id": 21, "path": "/home/runner/work/testcc/testcc/retdec/src/lib-sieve/sieve-types.h", "content": "#ifndef SIEVE_TYPES_H\n#define SIEVE_TYPES_H\n\n#include \"lib.h\"\n#include \"smtp-address.h\"\n\n#include <stdio.h>\n\n/*\n * Forward declarations\n */\n\nstruct smtp_params_mail;\nstruct smtp_params_rcpt;\n\nstruct sieve_instance;\nstruct sieve_callbacks;\n\nstruct sieve_script;\nstruct sieve_binary;\n\nstruct sieve_message_data;\nstruct sieve_script_env;\nstruct sieve_exec_status;\nstruct sieve_trace_log;\n\n/*\n * System environment\n */\n\nenum sieve_flag {\n\t/* Relative paths are resolved to HOME */\n\tSIEVE_FLAG_HOME_RELATIVE = (1 << 0)\n};\n\n/* Sieve evaluation can be performed at various different points as messages\n   are processed. */\nenum sieve_env_location {\n\t/* Unknown */\n\tSIEVE_ENV_LOCATION_UNKNOWN = 0,\n\t/* \"MDA\" - evaluation is being performed by a Mail Delivery Agent */\n\tSIEVE_ENV_LOCATION_MDA,\n\t/* \"MTA\" - the Sieve script is being evaluated by a Message Transfer Agent */\n\tSIEVE_ENV_LOCATION_MTA,\n\t/* \"MS\"  - evaluation is being performed by a Message Store */\n\tSIEVE_ENV_LOCATION_MS\n};\n\n/* The point relative to final delivery where the Sieve script is being\n   evaluated. */\nenum sieve_delivery_phase {\n\tSIEVE_DELIVERY_PHASE_UNKNOWN = 0,\n\tSIEVE_DELIVERY_PHASE_PRE,\n\tSIEVE_DELIVERY_PHASE_DURING,\n\tSIEVE_DELIVERY_PHASE_POST,\n};\n\nstruct sieve_environment {\n\tconst char *hostname;\n\tconst char *domainname;\n\n\tconst char *base_dir;\n\tconst char *username;\n\tconst char *home_dir;\n\tconst char *temp_dir;\n\n\tstruct event *event_parent;\n\n\tenum sieve_flag flags;\n\tenum sieve_env_location location;\n\tenum sieve_delivery_phase delivery_phase;\n};\n\n/*\n * Callbacks\n */\n\nstruct sieve_callbacks {\n\tconst char *(*get_homedir)(void *context);\n\tconst char *(*get_setting)(void *context, const char *identifier);\n};\n\n/*\n * Errors\n */\n\nenum sieve_error {\n\tSIEVE_ERROR_NONE = 0,\n\n\t/* Temporary internal error */\n\tSIEVE_ERROR_TEMP_FAILURE,\n\t/* It's not possible to do the wanted operation */\n\tSIEVE_ERROR_NOT_POSSIBLE,\n\t/* Invalid parameters (eg. script name not valid) */\n\tSIEVE_ERROR_BAD_PARAMS,\n\t/* No permission to do the request */\n\tSIEVE_ERROR_NO_PERMISSION,\n\t/* Out of disk space */\n\tSIEVE_ERROR_NO_QUOTA,\n\t/* Item (e.g. script or binary) cannot be found */\n\tSIEVE_ERROR_NOT_FOUND,\n\t/* Item (e.g. script or binary) already exists */\n\tSIEVE_ERROR_EXISTS,\n\t/* Referenced item (e.g. script or binary) is not valid or currupt */\n\tSIEVE_ERROR_NOT_VALID,\n\t/* Not allowed to perform the operation because the item is in active use */\n\tSIEVE_ERROR_ACTIVE\n};\n\n/*\n * Compile flags\n */\n\nenum sieve_compile_flags {\n\t/* No global extensions are allowed\n\t *  (as marked by sieve_global_extensions setting)\n\t */\n\tSIEVE_COMPILE_FLAG_NOGLOBAL = (1<<0),\n\t/* Script is being uploaded (usually through ManageSieve) */\n\tSIEVE_COMPILE_FLAG_UPLOADED = (1<<1),\n\t/* Script is being activated (usually through ManageSieve) */\n\tSIEVE_COMPILE_FLAG_ACTIVATED = (1<<2),\n\t/* Compiled for environment with no access to envelope */\n\tSIEVE_COMPILE_FLAG_NO_ENVELOPE = (1<<3)\n};\n\n/*\n * Message data\n *\n * - The mail message + envelope data\n */\n\nstruct sieve_message_data {\n\tstruct mail *mail;\n\n\tconst char *auth_user;\n\tconst char *id;\n\n\tstruct {\n\t\tconst struct smtp_address *mail_from;\n\t\tconst struct smtp_params_mail *mail_params;\n\n\t\tconst struct smtp_address *rcpt_to;\n\t\tconst struct smtp_params_rcpt *rcpt_params;\n\t} envelope;\n};\n\n/*\n * Runtime flags\n */\n\nenum sieve_execute_flags {\n\t/* No global extensions are allowed\n\t *  (as marked by sieve_global_extensions setting)\n\t */\n\tSIEVE_EXECUTE_FLAG_NOGLOBAL = (1<<0),\n\t/* Do not execute (implicit keep) at the end */\n\tSIEVE_EXECUTE_FLAG_DEFER_KEEP = (1<<1),\n\t/* There is no envelope */\n\tSIEVE_EXECUTE_FLAG_NO_ENVELOPE = (1<<2),\n\t/* Skip sending responses */\n\tSIEVE_EXECUTE_FLAG_SKIP_RESPONSES = (1<<3),\n\t/* Log result as info (when absent, only debug logging is performed) */\n\tSIEVE_EXECUTE_FLAG_LOG_RESULT = (1<<4),\n};\n\n/*\n * Runtime trace settings\n */\n\ntypedef enum {\n\tSIEVE_TRLVL_NONE = 0,\n\tSIEVE_TRLVL_ACTIONS,\n\tSIEVE_TRLVL_COMMANDS,\n\tSIEVE_TRLVL_TESTS,\n\tSIEVE_TRLVL_MATCHING\n} sieve_trace_level_t;\n\nenum {\n\tSIEVE_TRFLG_DEBUG = (1 << 0),\n\tSIEVE_TRFLG_ADDRESSES = (1 << 1)\n};\n\nstruct sieve_trace_config {\n\tsieve_trace_level_t level;\n\tunsigned int flags;\n};\n\n/*\n * Script environment\n *\n * - Environment for currently executing script\n */\n\nstruct sieve_script_env {\n\t/* Mail-related */\n\tstruct mail_user *user;\n\tconst struct message_address *postmaster_address;\n\tconst char *default_mailbox;\n\tbool mailbox_autocreate;\n\tbool mailbox_autosubscribe;\n\n\t/* External context data */\n\n\tvoid *script_context;\n\n\t/* Callbacks */\n\n\t/* Interface for sending mail */\n\tvoid *(*smtp_start)\n\t\t(const struct sieve_script_env *senv,\n\t\t\tconst struct smtp_address *mail_from);\n\t/* Add a new recipient */\n\tvoid (*smtp_add_rcpt)\t\n\t\t(const struct sieve_script_env *senv, void *handle,\n\t\t\tconst struct smtp_address *rcpt_to);\n\t/* Get an output stream where the message can be written to. The recipients\n\t   must already be added before calling this. */\n\tstruct ostream *(*smtp_send)\n\t\t(const struct sieve_script_env *senv, void *handle);\n\t/* Abort the SMTP transaction after smtp_send() is already issued */\n\tvoid (*smtp_abort)\n\t\t(const struct sieve_script_env *senv, void *handle);\n\t/* Returns 1 on success, 0 on permanent failure, -1 on temporary failure. */\n\tint (*smtp_finish)\n\t\t(const struct sieve_script_env *senv, void *handle,\n\t\t\tconst char **error_r);\n\n\t/* Interface for marking and checking duplicates */\n\tbool (*duplicate_check)\n\t\t(const struct sieve_script_env *senv, const void *id, size_t id_size);\n\tvoid (*duplicate_mark)\n\t\t(const struct sieve_script_env *senv, const void *id, size_t id_size,\n\t\t\ttime_t time);\n\tvoid (*duplicate_flush)\n\t\t(const struct sieve_script_env *senv);\n\n\t/* Interface for rejecting mail */\n\tint (*reject_mail)(const struct sieve_script_env *senv,\n\t\tconst struct smtp_address *recipient, const char *reason);\n\n\t/* Interface for amending result messages */\n\tconst char *\n\t(*result_amend_log_message)(const struct sieve_script_env *senv,\n\t\t\t\t    enum log_type log_type,\n\t\t\t\t    const char *message);\n\n\t/* Execution status record */\n\tstruct sieve_exec_status *exec_status;\n\n\t/* Runtime trace*/\n\tstruct sieve_trace_log *trace_log;\n\tstruct sieve_trace_config trace_config;\n};\n\n#define SIEVE_SCRIPT_DEFAULT_MAILBOX(senv) \\\n\t(senv->default_mailbox == NULL ? \"INBOX\" : senv->default_mailbox )\n\n/*\n * Script execution status\n */\n\nstruct sieve_exec_status {\n\tstruct mail_storage *last_storage;\n\n\tbool message_saved:1;\n\tbool message_forwarded:1;\n\tbool tried_default_save:1;\n\tbool keep_original:1;\n\tbool store_failed:1;\n\tbool significant_action_executed:1;\n};\n\n/*\n * Execution exit codes\n */\n\nenum sieve_execution_exitcode {\n\tSIEVE_EXEC_OK           = 1,\n\tSIEVE_EXEC_FAILURE      = 0,\n\tSIEVE_EXEC_TEMP_FAILURE = -1,\n\tSIEVE_EXEC_BIN_CORRUPT  = -2,\n\tSIEVE_EXEC_KEEP_FAILED  = -3\n};\n\n#endif\n"}, "22": {"id": 22, "path": "/home/runner/work/testcc/testcc/retdec/src/lib-sieve/sieve-validator.h", "content": "#ifndef SIEVE_VALIDATOR_H\n#define SIEVE_VALIDATOR_H\n\n#include \"lib.h\"\n\n#include \"sieve-common.h\"\n\n/*\n * Types\n */\n\nenum sieve_argument_type {\n\tSAT_NUMBER,\n\tSAT_CONST_STRING,\n\tSAT_VAR_STRING,\n\tSAT_STRING_LIST,\n\n\tSAT_COUNT\n};\n\nstruct sieve_command_registration;\n\n/*\n * Validator\n */\n\nstruct sieve_validator;\n\nstruct sieve_validator *\nsieve_validator_create(struct sieve_ast *ast,\n\t\t       struct sieve_error_handler *ehandler,\n\t\t       enum sieve_compile_flags flags);\nvoid sieve_validator_free(struct sieve_validator **valdtr);\npool_t sieve_validator_pool(struct sieve_validator *valdtr);\n\nbool sieve_validator_run(struct sieve_validator *valdtr);\n\n/*\n * Accessors\n */\n\nstruct sieve_error_handler *\nsieve_validator_error_handler(struct sieve_validator *valdtr);\nstruct sieve_ast *sieve_validator_ast(struct sieve_validator *valdtr);\nstruct sieve_script *sieve_validator_script(struct sieve_validator *valdtr);\nstruct sieve_instance *sieve_validator_svinst(struct sieve_validator *valdtr);\nenum sieve_compile_flags\nsieve_validator_compile_flags(struct sieve_validator *valdtr);\n\n/*\n * Command/Test registry\n */\n\nvoid sieve_validator_register_command(struct sieve_validator *valdtr,\n\t\t\t\t      const struct sieve_extension *ext,\n\t\t\t\t      const struct sieve_command_def *command);\n\n/*\n * Per-command tagged argument registry\n */\n\nvoid sieve_validator_register_tag(struct sieve_validator *valdtr,\n\t\t\t\t  struct sieve_command_registration *cmd_reg,\n\t\t\t\t  const struct sieve_extension *ext,\n\t\t\t\t  const struct sieve_argument_def *tag_def,\n\t\t\t\t  int id_code);\nvoid sieve_validator_register_external_tag(\n\tstruct sieve_validator *valdtr, const char *command,\n\tconst struct sieve_extension *ext,\n\tconst struct sieve_argument_def *tag_def, int id_code);\nvoid sieve_validator_register_persistent_tag(\n\tstruct sieve_validator *valdtr, const char *command,\n\tconst struct sieve_extension *ext,\n\tconst struct sieve_argument_def *tag_def);\n\n/*\n * Overriding the default literal arguments\n */\n\nvoid sieve_validator_argument_override(\n\tstruct sieve_validator *valdtr, enum sieve_argument_type type,\n\tconst struct sieve_extension *ext,\n\tconst struct sieve_argument_def *arg_def);\nbool sieve_validator_argument_activate_super(\n\tstruct sieve_validator *valdtr, struct sieve_command *cmd,\n\tstruct sieve_ast_argument *arg, bool constant);\n\n/*\n * Argument validation API\n */\n\nbool sieve_validate_positional_argument(struct sieve_validator *valdtr,\n\t\t\t\t\tstruct sieve_command *cmd,\n\t\t\t\t\tstruct sieve_ast_argument *arg,\n\t\t\t\t\tconst char *arg_name,\n\t\t\t\t\tunsigned int arg_pos,\n\t\t\t\t\tenum sieve_ast_argument_type req_type);\nbool sieve_validator_argument_activate(struct sieve_validator *valdtr,\n\t\t\t\t       struct sieve_command *cmd,\n\t\t\t\t       struct sieve_ast_argument *arg,\n\t\t\t\t       bool constant);\n\nbool sieve_validate_tag_parameter(struct sieve_validator *valdtr,\n\t\t\t\t  struct sieve_command *cmd,\n\t\t\t\t  struct sieve_ast_argument *tag,\n\t\t\t\t  struct sieve_ast_argument *param,\n\t\t\t\t  const char *arg_name, unsigned int arg_pos,\n\t\t\t\t  enum sieve_ast_argument_type req_type,\n\t\t\t\t  bool constant);\n\n/*\n * Extension support\n */\n\nstruct sieve_validator_extension {\n\tconst struct sieve_extension_def *ext;\n\n\tbool (*check_conflict)(const struct sieve_extension *ext,\n\t\t\t       struct sieve_validator *valdtr, void *context,\n\t\t\t       struct sieve_ast_argument *require_arg,\n\t\t\t       const struct sieve_extension *ext_other,\n\t\t\t       bool required);\n\tbool (*validate)(const struct sieve_extension *ext,\n\t\t\t struct sieve_validator *valdtr, void *context,\n\t\t\t struct sieve_ast_argument *require_arg, bool required);\n\n\tvoid (*free)(const struct sieve_extension *ext,\n\t\t     struct sieve_validator *valdtr, void *context);\n};\n\nbool sieve_validator_extension_load(struct sieve_validator *valdtr,\n\t\t\t\t    struct sieve_command *cmd,\n\t\t\t\t    struct sieve_ast_argument *ext_arg,\n\t\t\t\t    const struct sieve_extension *ext,\n\t\t\t\t    bool required) ATTR_NULL(2, 3);\nconst struct sieve_extension *\nsieve_validator_extension_load_by_name(struct sieve_validator *valdtr,\n\t\t\t\t       struct sieve_command *cmd,\n\t\t\t\t       struct sieve_ast_argument *ext_arg,\n\t\t\t\t       const char *ext_name);\nconst struct sieve_extension *\nsieve_validator_extension_load_implicit(struct sieve_validator *valdtr,\n\t\t\t\t\tconst char *ext_name);\n\nvoid sieve_validator_extension_register(\n\tstruct sieve_validator *valdtr, const struct sieve_extension *ext,\n\tconst struct sieve_validator_extension *valext, void *context);\nbool sieve_validator_extension_loaded(struct sieve_validator *valdtr,\n\t\t\t\t      const struct sieve_extension *ext);\n\nvoid sieve_validator_extension_set_context(struct sieve_validator *valdtr,\n\t\t\t\t\t   const struct sieve_extension *ext,\n\t\t\t\t\t   void *context);\nvoid *sieve_validator_extension_get_context(struct sieve_validator *valdtr,\n\t\t\t\t\t    const struct sieve_extension *ext);\n\n/*\n * Validator object registry\n */\n\nstruct sieve_validator_object_registry;\n\nstruct sieve_validator_object_registry *\nsieve_validator_object_registry_get(struct sieve_validator *valdtr,\n\t\t\t\t    const struct sieve_extension *ext);\nvoid sieve_validator_object_registry_add(\n\tstruct sieve_validator_object_registry *regs,\n\tconst struct sieve_extension *ext,\n\tconst struct sieve_object_def *obj_def);\nbool sieve_validator_object_registry_find(\n\tstruct sieve_validator_object_registry *regs, const char *identifier,\n\tstruct sieve_object *obj);\nstruct sieve_validator_object_registry *\nsieve_validator_object_registry_create(struct sieve_validator *valdtr);\nstruct sieve_validator_object_registry *\nsieve_validator_object_registry_init(struct sieve_validator *valdtr,\n\t\t\t\t     const struct sieve_extension *ext);\n\n/*\n * Error handling\n */\n\nvoid sieve_validator_error(struct sieve_validator *valdtr,\n\t\t\t   const char *csrc_filename, unsigned int csrc_linenum,\n\t\t\t   unsigned int source_line, const char *fmt, ...)\n\t\t\t   ATTR_FORMAT(5, 6);\n#define sieve_validator_error(valdtr, ...) \\\n\tsieve_validator_error(valdtr, __FILE__, __LINE__, __VA_ARGS__)\nvoid sieve_validator_warning(struct sieve_validator *valdtr,\n\t\t\t     const char *csrc_filename,\n\t\t\t     unsigned int csrc_linenum,\n\t\t\t     unsigned int source_line, const char *fmt, ...)\n\t\t\t     ATTR_FORMAT(5, 6);\n#define sieve_validator_warning(valdtr, ...) \\\n\tsieve_validator_warning(valdtr, __FILE__, __LINE__, __VA_ARGS__)\n\n#endif\n"}, "23": {"id": 23, "path": "/usr/local/include/dovecot/array-decl.h", "content": "#ifndef ARRAY_DECL_H\n#define ARRAY_DECL_H\n\n#define ARRAY(array_type) union { struct array arr; array_type const *const *v; array_type **v_modifiable; }\n#define ARRAY_INIT { { NULL, 0 } }\n\n#define ARRAY_DEFINE_TYPE(name, array_type) \\\n\tunion array ## __ ## name { struct array arr; array_type const *const *v; array_type **v_modifiable; }\n#define ARRAY_TYPE(name) \\\n\tunion array ## __ ## name\n\nstruct array {\n\tbuffer_t *buffer;\n\tsize_t element_size;\n};\n\nARRAY_DEFINE_TYPE(string, char *);\nARRAY_DEFINE_TYPE(const_string, const char *);\nARRAY_DEFINE_TYPE(uint8_t, uint8_t);\nARRAY_DEFINE_TYPE(uint16_t, uint16_t);\nARRAY_DEFINE_TYPE(uint32_t, uint32_t);\nARRAY_DEFINE_TYPE(uint64_t, uint64_t);\nARRAY_DEFINE_TYPE(uint, unsigned int);\nARRAY_DEFINE_TYPE(void_array, void *);\n\n#endif\n"}, "24": {"id": 24, "path": "/usr/local/include/dovecot/array.h", "content": "#ifndef ARRAY_H\n#define ARRAY_H\n\n/* Array is a buffer accessible using fixed size elements. As long as the\n   compiler provides a typeof() operator, the array provides type safety. If\n   a wrong type is tried to be added to the array, or if the array's contents\n   are tried to be used using a wrong type, the compiler will give a warning.\n\n   Example usage:\n\n   struct foo {\n\tARRAY(struct bar) bars;\n\t...\n   };\n\n   i_array_init(&foo->bars, 10);\n\n   struct bar *bar = array_idx(&foo->bars, 5);\n   struct baz *baz = array_idx(&foo->bars, 5); // compiler warning\n\n   If you want to pass an array as a parameter to a function, you'll need to\n   create a type for the array using ARRAY_DEFINE_TYPE() and use the type in\n   the parameter using ARRAY_TYPE(). Any arrays that you want to be passing\n   around, such as structure members as in the above example, must also be\n   defined using ARRAY_TYPE() too, rather than ARRAY().\n\n   Example:\n\n   ARRAY_DEFINE_TYPE(foo, struct foo);\n   void do_foo(ARRAY_TYPE(foo) *foos) {\n\tstruct foo *foo = array_idx(foos, 0);\n   }\n   struct foo_manager {\n        ARRAY_TYPE(foo) foos; // pedantically, ARRAY(struct foo) is a different type\n   };\n   // ...\n        do_foo(&my_foo_manager->foos); // No compiler warning about mismatched types\n\n*/\n#include \"array-decl.h\"\n#include \"buffer.h\"\n\n#define p_array_init(array, pool, init_count) \\\n\tarray_create(array, pool, sizeof(**(array)->v), init_count)\n#define i_array_init(array, init_count) \\\n\tp_array_init(array, default_pool, init_count)\n#define t_array_init(array, init_count) \\\n\tp_array_init(array, pool_datastack_create(), init_count)\n\n#ifdef HAVE_TYPEOF\n#  define ARRAY_TYPE_CAST_CONST(array) \\\n\t(typeof(*(array)->v))\n#  define ARRAY_TYPE_CAST_MODIFIABLE(array) \\\n\t(typeof(*(array)->v_modifiable))\n#  define ARRAY_TYPE_CHECK(array, data) \\\n\tCOMPILE_ERROR_IF_TYPES_NOT_COMPATIBLE( \\\n\t\t**(array)->v_modifiable, *(data))\n#  define ARRAY_TYPES_CHECK(array1, array2) \\\n\tCOMPILE_ERROR_IF_TYPES_NOT_COMPATIBLE( \\\n\t\t**(array1)->v_modifiable, **(array2)->v_modifiable)\n\n#else\n#  define ARRAY_TYPE_CAST_CONST(array)\n#  define ARRAY_TYPE_CAST_MODIFIABLE(array)\n#  define ARRAY_TYPE_CHECK(array, data) 0\n#  define ARRAY_TYPES_CHECK(array1, array2) 0\n#endif\n\n/* usage: struct foo *foo; array_foreach(foo_arr, foo) { .. } */\n#if (defined(__STDC__) && __STDC_VERSION__ >= 199901L)\n#  define array_foreach(array, elem) \\\n\tfor (const void *elem ## __foreach_end = \\\n\t\t(const char *)(elem = *(array)->v) + (array)->arr.buffer->used; \\\n\t     elem != elem ## __foreach_end; (elem)++)\n#  define array_foreach_modifiable(array, elem) \\\n\tfor (const void *elem ## _end = \\\n\t\t(const char *)(elem = ARRAY_TYPE_CAST_MODIFIABLE(array) \\\n\t\t\tbuffer_get_modifiable_data((array)->arr.buffer, NULL)) + \\\n\t\t\t(array)->arr.buffer->used; \\\n\t     elem != elem ## _end; (elem)++)\n/* Bikeshed: which is better\n   array_foreach_elem(array, myvar) { ... use myvar ... }  // not clear myvar is modified\n   array_foreach_elem(array, &myvar) { ... use myvar ... } // clearer, as more pass-by-referencey\n   Latter is impossible if we want to use the variable name as the base for the other variable names\n*/\n#  define array_foreach_elem(array, elem) \\\n\tfor (unsigned int _foreach_offset = ARRAY_TYPE_CHECK(array, &elem) + \\\n\t\t\t\tCOMPILE_ERROR_IF_TRUE(sizeof(elem) > 16)\\\n\t\t     ;\t\t\t\t\t\t\t\\\n\t     (_foreach_offset < (array)->arr.buffer->used) &&\t\t\\\n\t     (memcpy(&elem, CONST_PTR_OFFSET(*(array)->v, _foreach_offset), sizeof(elem)), TRUE) \\\n\t\t;\t\t\t\t\t\t\t\\\n\t     _foreach_offset += sizeof(elem)\t\t\t\t\\\n\t\t)\n\n#else\n#  define array_foreach(array, elem) \\\n\tfor (elem = *(array)->v; \\\n\t     elem != CONST_PTR_OFFSET(*(array)->v, (array)->arr.buffer->used); \\\n\t     (elem)++)\n#  define array_foreach_modifiable(array, elem) \\\n\tfor (elem = ARRAY_TYPE_CAST_MODIFIABLE(array) \\\n\t\t\tbuffer_get_modifiable_data((array)->arr.buffer, NULL); \\\n\t     elem != CONST_PTR_OFFSET(*(array)->v, (array)->arr.buffer->used); \\\n\t     (elem)++)\n#endif\n\n#define array_ptr_to_idx(array, elem) \\\n\t((elem) - (array)->v[0])\n#define array_foreach_idx(array, elem) \\\n\tarray_ptr_to_idx(array, elem)\n\nstatic inline void\narray_create_from_buffer_i(struct array *array, buffer_t *buffer,\n\t\t\t   size_t element_size)\n{\n\tarray->buffer = buffer;\n\tarray->element_size = element_size;\n}\n#define array_create_from_buffer(array, buffer, element_size) \\\n\tarray_create_from_buffer_i(&(array)->arr, buffer, element_size)\n\nstatic inline void\narray_create_i(struct array *array, pool_t pool,\n\t       size_t element_size, unsigned int init_count)\n{\n\tbuffer_t *buffer;\n\n        buffer = buffer_create_dynamic(pool, init_count * element_size);\n\tarray_create_from_buffer_i(array, buffer, element_size);\n}\n#define array_create(array, pool, element_size, init_count) \\\n\tarray_create_i(&(array)->arr, pool, element_size, init_count)\n\nstatic inline void\narray_free_i(struct array *array)\n{\n\tbuffer_free(&array->buffer);\n}\n#define array_free(array) \\\n\tarray_free_i(&(array)->arr)\n\nstatic inline void * ATTR_WARN_UNUSED_RESULT\narray_free_without_data_i(struct array *array)\n{\n\treturn buffer_free_without_data(&array->buffer);\n}\n#define array_free_without_data(array) \\\n\tARRAY_TYPE_CAST_MODIFIABLE(array)array_free_without_data_i(&(array)->arr)\n\nstatic inline bool\narray_is_created_i(const struct array *array)\n{\n\treturn array->buffer != NULL;\n}\n#define array_is_created(array) \\\n\tarray_is_created_i(&(array)->arr)\n\nstatic inline pool_t ATTR_PURE\narray_get_pool_i(struct array *array)\n{\n\treturn buffer_get_pool(array->buffer);\n}\n#define array_get_pool(array) \\\n\tarray_get_pool_i(&(array)->arr)\n\nstatic inline void\narray_clear_i(struct array *array)\n{\n\tbuffer_set_used_size(array->buffer, 0);\n}\n#define array_clear(array) \\\n\tarray_clear_i(&(array)->arr)\n\nstatic inline unsigned int ATTR_PURE\narray_count_i(const struct array *array)\n{\n\treturn array->buffer->used / array->element_size;\n}\n#define array_count(array) \\\n\tarray_count_i(&(array)->arr)\n/* No need for the real count if all we're doing is comparing against 0 */\n#define array_is_empty(array) \\\n\t((array)->arr.buffer->used == 0)\n#define array_not_empty(array) \\\n\t((array)->arr.buffer->used > 0)\n\nstatic inline void\narray_append_i(struct array *array, const void *data, unsigned int count)\n{\n\tbuffer_append(array->buffer, data, count * array->element_size);\n}\n\n#define array_append(array, data, count) \\\n\tarray_append_i(&(array)->arr + ARRAY_TYPE_CHECK(array, data), \\\n\t\tdata, count)\n\nstatic inline void\narray_append_array_i(struct array *dest_array, const struct array *src_array)\n{\n\ti_assert(dest_array->element_size == src_array->element_size);\n\tbuffer_append_buf(dest_array->buffer, src_array->buffer, 0, (size_t)-1);\n}\n#define array_append_array(dest_array, src_array) \\\n\tarray_append_array_i(&(dest_array)->arr + ARRAY_TYPES_CHECK(dest_array, src_array), \\\n\t\t\t     &(src_array)->arr)\n\nstatic inline void\narray_insert_i(struct array *array, unsigned int idx,\n\t       const void *data, unsigned int count)\n{\n\tbuffer_insert(array->buffer, idx * array->element_size,\n\t\t      data, count * array->element_size);\n}\n\n#define array_insert(array, idx, data, count) \\\n\tarray_insert_i(&(array)->arr + ARRAY_TYPE_CHECK(array, data), \\\n\t\tidx, data, count)\n\nstatic inline void\narray_delete_i(struct array *array, unsigned int idx, unsigned int count)\n{\n\tbuffer_delete(array->buffer, idx * array->element_size,\n\t\t      count * array->element_size);\n}\n#define array_delete(array, idx, count) \\\n\tarray_delete_i(&(array)->arr, idx, count)\n\nstatic inline const void *\narray_get_i(const struct array *array, unsigned int *count_r)\n{\n\t*count_r = array_count_i(array);\n\treturn array->buffer->data;\n}\n#define array_get(array, count) \\\n\tARRAY_TYPE_CAST_CONST(array)array_get_i(&(array)->arr, count)\n\n/* Re: i_assert() vs. pure: https://gcc.gnu.org/bugzilla/show_bug.cgi?id=51971#c1 */\nstatic inline const void * ATTR_PURE\narray_idx_i(const struct array *array, unsigned int idx)\n{\n\ti_assert(idx < array->buffer->used / array->element_size);\n\treturn CONST_PTR_OFFSET(array->buffer->data, idx * array->element_size);\n}\n\n#define array_front(array) array_idx(array, 0)\n#define array_front_modifiable(array) array_idx_modifiable(array, 0)\n#define array_back(array) array_idx(array, array_count(array)-1)\n#define array_back_modifiable(array) array_idx_modifiable(array, array_count(array)-1)\n#define array_pop_back(array) array_delete(array, array_count(array)-1, 1);\n#define array_push_back(array, item) array_append(array, (item), 1)\n#define array_pop_front(array) array_delete(array, 0, 1)\n#define array_push_front(array, item) array_insert(array, 0, (item), 1)\n\n#define array_idx(array, idx) \\\n\tARRAY_TYPE_CAST_CONST(array)array_idx_i(&(array)->arr, idx)\n\nstatic inline void *\narray_get_modifiable_i(struct array *array, unsigned int *count_r)\n{\n\t*count_r = array_count_i(array);\n\treturn buffer_get_modifiable_data(array->buffer, NULL);\n}\n#define array_get_modifiable(array, count) \\\n\tARRAY_TYPE_CAST_MODIFIABLE(array) \\\n\t\tarray_get_modifiable_i(&(array)->arr, count)\n\nvoid *\narray_idx_modifiable_i(const struct array *array, unsigned int idx) ATTR_PURE;\n#define array_idx_modifiable(array, idx) \\\n\tARRAY_TYPE_CAST_MODIFIABLE(array) \\\n\t\tarray_idx_modifiable_i(&(array)->arr, idx)\n\nvoid *array_idx_get_space_i(struct array *array, unsigned int idx);\n#define array_idx_get_space(array, idx) \\\n\tARRAY_TYPE_CAST_MODIFIABLE(array) \\\n\t\tarray_idx_get_space_i(&(array)->arr, idx)\n\nvoid array_idx_set_i(struct array *array, unsigned int idx, const void *data);\n#define array_idx_set(array, idx, data) \\\n\tarray_idx_set_i(&(array)->arr + ARRAY_TYPE_CHECK(array, data), \\\n\t\tidx, data)\n\nvoid array_idx_clear_i(struct array *array, unsigned int idx);\n#define array_idx_clear(array, idx) \\\n\tarray_idx_clear_i(&(array)->arr, idx)\n\nstatic inline void *\narray_append_space_i(struct array *array)\n{\n\tvoid *data;\n\n\tdata = buffer_append_space_unsafe(array->buffer, array->element_size);\n\tmemset(data, 0, array->element_size);\n\treturn data;\n}\n#define array_append_space(array) \\\n\tARRAY_TYPE_CAST_MODIFIABLE(array)array_append_space_i(&(array)->arr)\n#define array_append_zero(array) \\\n\t(void)array_append_space_i(&(array)->arr)\n\nvoid *array_insert_space_i(struct array *array, unsigned int idx);\n#define array_insert_space(array, idx) \\\n\tARRAY_TYPE_CAST_MODIFIABLE(array) \\\n\t\tarray_insert_space_i(&(array)->arr, idx)\n\nstatic inline void\narray_copy(struct array *dest, unsigned int dest_idx,\n\t   const struct array *src, unsigned int src_idx, unsigned int count)\n{\n\ti_assert(dest->element_size == src->element_size);\n\n\tbuffer_copy(dest->buffer, dest_idx * dest->element_size,\n\t\t    src->buffer, src_idx * src->element_size,\n\t\t    count * dest->element_size);\n}\n\n/* Exchange ownership of two arrays, which should have been allocated\n   from the same pool/context. Useful for updating an array with a\n   replacement. Can also do it with uninitialized arrays (which will\n   have .element_size == 0). */\nstatic inline void\narray_swap_i(struct array *array1, struct array *array2)\n{\n\tbuffer_t *buffer = array1->buffer;\n\tsize_t elsize = array1->element_size;\n\n\tarray1->buffer = array2->buffer;\n\tarray1->element_size = array2->element_size;\n\tarray2->buffer = buffer;\n\tarray2->element_size = elsize;\n}\n#define array_swap(array1, array2)\t\t\t\t\t\\\n\tarray_swap_i(&(array1)->arr + ARRAY_TYPES_CHECK(array1, array2), \\\n\t\t     &(array2)->arr)\n\nbool array_cmp_i(const struct array *array1,\n\t\t const struct array *array2) ATTR_PURE;\n#define array_cmp(array1, array2) \\\n\tarray_cmp_i(&(array1)->arr, &(array2)->arr)\n\n/* Test equality via a comparator */\nbool array_equal_fn_i(const struct array *array1,\n\t\t      const struct array *array2,\n\t\t      int (*cmp)(const void*, const void *)) ATTR_PURE;\n#define array_equal_fn(array1, array2, cmp)\t\t\t\t\\\n\tarray_equal_fn_i(&(array1)->arr -\t\t\t\t\t\\\n\t\t       ARRAY_TYPES_CHECK(array1, array2),\t\t\\\n\t\t       &(array2)->arr -\t\t\t\t\t\\\n\t\t       CALLBACK_TYPECHECK(cmp, int (*)(typeof(*(array1)->v), \\\n\t\t\t\t\t\t       typeof(*(array2)->v))), \\\n\t\t       (int (*)(const void *, const void *))cmp)\nbool array_equal_fn_ctx_i(const struct array *array1,\n\t\t\t  const struct array *array2,\n\t\t\t  int (*cmp)(const void*, const void *, const void *),\n\t\t\t  const void *context) ATTR_PURE;\n/* Same, but with a context pointer.\n   context can't be void* as ``const typeof(context)'' won't compile,\n   so ``const typeof(*context)*'' is required instead, and that requires a\n   complete type. */\n#define array_equal_fn_ctx(array1, array2, cmp, ctx)\t\t\t\\\n\tarray_equal_fn_ctx_i(&(array1)->arr -\t\t\t\t\\\n\t\t\t     ARRAY_TYPES_CHECK(array1, array2),\t\t\\\n\t\t\t     &(array2)->arr -\t\t\t\t\\\n\t\t\t     CALLBACK_TYPECHECK(cmp, int (*)(typeof(*(array1)->v), \\\n\t\t\t\t\t\t\t     typeof(*(array2)->v), \\\n\t\t\t\t\t\t\t     const typeof(*ctx)*)), \\\n\t\t\t     (int (*)(const void *, const void *, const void *))cmp, \\\n\t\t\t     ctx)\n\nvoid array_reverse_i(struct array *array);\n#define array_reverse(array) \\\n\tarray_reverse_i(&(array)->arr)\n\nvoid array_sort_i(struct array *array, int (*cmp)(const void *, const void *));\n#define array_sort(array, cmp) \\\n\tarray_sort_i(&(array)->arr - \\\n\t\tCALLBACK_TYPECHECK(cmp, int (*)(typeof(*(array)->v), \\\n\t\t\t\t\t\ttypeof(*(array)->v))), \\\n\t\t(int (*)(const void *, const void *))cmp)\n\nvoid *array_bsearch_i(struct array *array, const void *key,\n\t\t      int (*cmp)(const void *, const void *));\n#define array_bsearch(array, key, cmp) \\\n\tARRAY_TYPE_CAST_MODIFIABLE(array)array_bsearch_i(&(array)->arr - \\\n\t\tCALLBACK_TYPECHECK(cmp, int (*)(typeof(const typeof(*key) *), \\\n\t\t\t\t\t\ttypeof(*(array)->v))), \\\n\t\t(const void *)key, (int (*)(const void *, const void *))cmp)\n\n/* Returns pointer to first element for which cmp(key,elem)==0, or NULL */\nconst void *array_lsearch_i(const struct array *array, const void *key,\n\t\t\t    int (*cmp)(const void *, const void *));\nstatic inline void *array_lsearch_modifiable_i(struct array *array, const void *key,\n\t\t\t\t\t       int (*cmp)(const void *, const void *))\n{\n\treturn (void *)array_lsearch_i(array, key, cmp);\n}\n#define ARRAY_LSEARCH_CALL(modifiable, array, key, cmp)\t\t\t\\\n\tarray_lsearch##modifiable##i(\t\t\t\t\t\\\n\t\t&(array)->arr -\t\t\t\t\t\t\\\n\t\tCALLBACK_TYPECHECK(cmp, int (*)(typeof(const typeof(*key) *), \\\n\t\t\t\t\t\ttypeof(*(array)->v))),\t\\\n\t\t(const void *)key,\t\t\t\t\t\\\n\t\t(int (*)(const void *, const void *))cmp)\n#define array_lsearch(array, key, cmp)\t\t\t\t\t\\\n\tARRAY_TYPE_CAST_CONST(array)ARRAY_LSEARCH_CALL(_, array, key, cmp)\n#define array_lsearch_modifiable(array, key, cmp)\t\t\t\\\n\tARRAY_TYPE_CAST_MODIFIABLE(array)ARRAY_LSEARCH_CALL(_modifiable_, array, key, cmp)\n\n#endif\n"}, "25": {"id": 25, "path": "/usr/local/include/dovecot/bits.h", "content": "#ifndef BITS_H\n#define BITS_H\n\n#define UINT64_SUM_OVERFLOWS(a, b) \\\n\t(a > (uint64_t)-1 - b)\n\n#define BIT(n) (1u << (n))\n\n/* These expressions make it easy to ensure that bit test expressions\n   are boolean in order to satisfy the in-house -Wstrict-bool. */\n/* ((val & bits) == 0) is very common */\n#define HAS_NO_BITS(val,bits) (((val) & (bits)) == 0)\n/* ((val & bits) != 0) is even more common */\n/* Note - illogical behaviour if bits==0, fixing that requires potential\n   multiple evaluation, but it's a corner case that should never occur. */\n#define HAS_ANY_BITS(val,bits) (((val) & (bits)) != 0)\n/* ((val & bits) == bits) is uncommon */\n#define HAS_ALL_BITS(val,bits) ((~(val) & (bits)) == 0)\n\n/* Returns x, such that x is the smallest power of 2 >= num. */\nsize_t nearest_power(size_t num) ATTR_CONST;\n\n/* Returns TRUE if 2^x=num, i.e. if num has only a single bit set to 1. */\nstatic inline bool ATTR_CONST\nbits_is_power_of_two(uint64_t num)\n{\n\treturn num > 0 && (num & (num - 1)) == 0;\n}\n\n#if __GNUC__ > 3 || (__GNUC__ == 3 && __GNUC_MINOR__ >= 4)\nstatic inline unsigned int ATTR_CONST\nbits_required32(uint32_t num)\n{\n\treturn num == 0 ? 0 : 32 - __builtin_clz(num);\n}\nstatic inline unsigned int ATTR_CONST\nbits_required8(uint8_t num)   { return bits_required32(num); }\n\nstatic inline unsigned int ATTR_CONST\nbits_required16(uint16_t num) { return bits_required32(num); }\n\nstatic inline unsigned int ATTR_CONST\nbits_required64(uint64_t num)\n{\n\treturn num == 0 ? 0 : 64 - __builtin_clzll(num);\n}\n#else\nunsigned int bits_required8(uint8_t num) ATTR_CONST;\n\nstatic inline\nunsigned int bits_required16(uint16_t num)\n{\n\treturn (num <= 0xff) ? bits_required8(num)\n\t\t: 8 + bits_required8(num >> 8);\n}\nstatic inline\nunsigned int bits_required32(uint32_t num)\n{\n\treturn (num <= 0xffff) ? bits_required16(num)\n\t\t: 16 + bits_required16(num >> 16);\n}\nstatic inline\nunsigned int bits_required64(uint64_t num)\n{\n\treturn (num <= 0xffffffff) ? bits_required32(num)\n\t\t: 32 + bits_required32(num >> 32);\n}\n#endif\n\nstatic inline uint64_t\nbits_rotl64(uint64_t num, unsigned int count)\n{\n\tconst unsigned int mask = CHAR_BIT*sizeof(num) - 1;\n\tcount &= mask;\n\treturn (num << count) | (num >> (-count & mask));\n}\n\nstatic inline uint32_t\nbits_rotl32(uint32_t num, unsigned int count)\n{\n        const unsigned int mask = CHAR_BIT*sizeof(num) - 1;\n        count &= mask;\n        return (num << count) | (num >> (-count & mask));\n}\n\nstatic inline uint64_t\nbits_rotr64(uint64_t num, unsigned int count)\n{\n\tconst unsigned int mask = CHAR_BIT*sizeof(num) - 1;\n\tcount &= mask;\n\treturn (num >> count) | (num << (-count & mask));\n}\n\nstatic inline uint32_t\nbits_rotr32(uint32_t num, unsigned int count)\n{\n\tconst unsigned int mask = CHAR_BIT*sizeof(num) - 1;\n\tcount &= mask;\n\treturn (num >> count) | (num << (-count & mask));\n}\n\n/* These functions look too big to be inline, but in almost all expected\n   uses, 'fracbits' will be a compile-time constant, and most of the\n   expressions will simplify greatly.\n*/\n\n/* Perform a piecewise-linear approximation to a log2, with fracbits \"fractional\" bits.\n   Best explained with examples:\n   With 2 fractional bits splitting each power of 2 into 4 bands:\n     00,   01,   10,   11 ->   00,   01,   10,   11 (small corner cases)\n    100,  101,  110,  111 ->  100,  101,  110,  111 ([4-8) split into 4 bands)\n   1000, 1001, 1010, 1011 -> 1000, 1000, 1001, 1001 ([8-15) split ...\n   1100, 1101, 1110, 1111 -> 1010, 1010, 1011, 1011  ... into 4 bands)\n   [16..31) -> 11bb\n   [32..63) -> 100bb\n   [64..127) -> 101bb\n   [128..255) -> 110bb\n   e.g. 236 = 11101100 -> ((8-2)<<2 == 11000) + (111.....>> 5 == 111) - 100 == 11011\n */\nstatic inline unsigned int ATTR_CONST\nbits_fraclog(unsigned int val, unsigned int fracbits)\n{\n\tunsigned bits = bits_required32(val);\n\tif (bits <= fracbits + 1)\n\t\treturn val;\n\n\tunsigned int bandnum = bits - fracbits;\n\tunsigned int bandstart = bandnum << fracbits;\n\tunsigned int fracoffsbad = val >> (bandnum - 1); /* has leading 1 still */\n\tunsigned int bucket = bandstart + fracoffsbad - BIT(fracbits);\n\treturn bucket;\n}\nstatic inline unsigned int ATTR_CONST\nbits_fraclog_bucket_start(unsigned int bucket, unsigned int fracbits)\n{\n\tunsigned int bandnum = bucket >> fracbits;\n\tif (bandnum <= 1)\n\t\treturn bucket;\n\tif (fracbits == 0)\n\t\treturn BIT(bucket - 1);\n\tunsigned int fracoffs = bucket & (BIT(fracbits)-1);\n\tunsigned int fracoffs1 = BIT(fracbits) + fracoffs;\n\tunsigned int bandstart = fracoffs1 << (bandnum - 1);\n\treturn bandstart;\n}\nstatic inline unsigned int ATTR_CONST\nbits_fraclog_bucket_end(unsigned int bucket, unsigned int fracbits)\n{\n\tunsigned int bandnum = bucket >> fracbits;\n\tif (bandnum <= 1)\n\t\treturn bucket;\n\tif (fracbits == 0)\n\t\treturn BIT(bucket - 1) * 2 - 1;\n\tunsigned int fracoffs = bucket & (BIT(fracbits)-1);\n\tunsigned int nextfracoffs1 = 1 + BIT(fracbits) + fracoffs;\n\tunsigned int nextbandstart = nextfracoffs1 << (bandnum - 1);\n\treturn nextbandstart - 1;\n}\n/* UNSAFE: multiple use of parameter (but expecting a constant in reality).\n   But a macro as it's most likely to be used to declare an array size.\n*/\n#define BITS_FRACLOG_BUCKETS(bits) ((33u - (bits)) << (bits))\n\n#endif\n"}, "26": {"id": 26, "path": "/usr/local/include/dovecot/buffer.h", "content": "#ifndef BUFFER_H\n#define BUFFER_H\n\nstruct buffer {\n\tconst void *data;\n\tconst size_t used;\n\tvoid *priv[5];\n};\n\n/* WARNING: Be careful with functions that return pointers to data.\n   With dynamic buffers they are valid only as long as buffer is not\n   realloc()ed. You shouldn't rely on it being valid if you have modified\n   buffer in any way. */\n\n/* Create a modifiable buffer from given data. Writes past this size will\n   i_panic(). */\nvoid buffer_create_from_data(buffer_t *buffer, void *data, size_t size);\n/* Create a non-modifiable buffer from given data. */\nvoid buffer_create_from_const_data(buffer_t *buffer,\n\t\t\t\t   const void *data, size_t size);\n#if defined(__GNUC__) && (__GNUC__ * 100 + __GNUC_MINOR__) > 401\n#define buffer_create_from_data(b,d,s) ({\t\t\t\t           \\\n\t(void)COMPILE_ERROR_IF_TRUE(__builtin_object_size((d),1) < ((s)>0?(s):1)); \\\n\tbuffer_create_from_data((b), (d), (s)); })\n#define buffer_create_from_const_data(b,d,s) ({\t\t\t\t           \\\n\t(void)COMPILE_ERROR_IF_TRUE(__builtin_object_size((d),1) < ((s)>0?(s):1)); \\\n\tbuffer_create_from_const_data((b), (d), (s)); })\n#endif\n/* Creates a dynamically growing buffer. Whenever write would exceed the\n   current size it's grown. */\nbuffer_t *buffer_create_dynamic(pool_t pool, size_t init_size);\n\n#define t_buffer_create(init_size) \\\n\tbuffer_create_dynamic(pool_datastack_create(), (init_size))\n\n/* Free the memory used by buffer. Not needed if the memory is free'd\n   directly from the memory pool. */\nvoid buffer_free(buffer_t **buf);\n/* Free the memory used by buffer structure, but return the buffer data\n   unfree'd. */\nvoid *buffer_free_without_data(buffer_t **buf);\n\n/* Returns the pool buffer was created with. */\npool_t buffer_get_pool(const buffer_t *buf) ATTR_PURE;\n\n/* Write data to buffer at specified position. If pos is beyond the buffer's\n   current size, it is zero-filled up to that point (even if data_size==0). */\nvoid buffer_write(buffer_t *buf, size_t pos,\n\t\t  const void *data, size_t data_size);\n/* Append data to buffer. */\nvoid buffer_append(buffer_t *buf, const void *data, size_t data_size);\n/* Append character to buffer. */\nvoid buffer_append_c(buffer_t *buf, unsigned char chr);\n\n/* Insert the provided data into the buffer at position pos. If pos points past\n   the current buffer size, the gap is zero-filled. */\nvoid buffer_insert(buffer_t *buf, size_t pos,\n\t\t   const void *data, size_t data_size);\n/* Delete data with the indicated size from the buffer at position pos. The\n   deleted block may cross the current buffer size boundary, which is ignored.\n */\nvoid buffer_delete(buffer_t *buf, size_t pos, size_t size);\n/* Replace the data in the buffer with the indicated size at position pos with\n   the provided data. This is a more optimized version of\n   buffer_delete(buf, pos, size); buffer_insert(buf, pos, data, data_size); */\nvoid buffer_replace(buffer_t *buf, size_t pos, size_t size,\n\t\t    const void *data, size_t data_size);\n\n/* Fill buffer with zero bytes. */\nvoid buffer_write_zero(buffer_t *buf, size_t pos, size_t data_size);\nvoid buffer_append_zero(buffer_t *buf, size_t data_size);\nvoid buffer_insert_zero(buffer_t *buf, size_t pos, size_t data_size);\n\n/* Copy data from buffer to another. The buffers may be same in which case\n   it's internal copying, possibly with overlapping positions (ie. memmove()\n   like functionality). copy_size may be set to (size_t)-1 to copy the rest of\n   the used data in buffer. */\nvoid buffer_copy(buffer_t *dest, size_t dest_pos,\n\t\t const buffer_t *src, size_t src_pos, size_t copy_size);\n/* Append data to buffer from another. copy_size may be set to (size_t)-1 to\n   copy the rest of the used data in buffer. */\nvoid buffer_append_buf(buffer_t *dest, const buffer_t *src,\n\t\t       size_t src_pos, size_t copy_size);\n\n/* Returns pointer to specified position in buffer. WARNING: The returned\n   address may become invalid if you add more data to buffer. */\nvoid *buffer_get_space_unsafe(buffer_t *buf, size_t pos, size_t size);\n/* Increase the buffer usage by given size, and return a pointer to beginning\n   of it. */\nvoid *buffer_append_space_unsafe(buffer_t *buf, size_t size);\n\n/* Like buffer_get_data(), but don't return it as const. Returns NULL if the\n   buffer is non-modifiable. WARNING: The returned address may become invalid\n   if you add more data to buffer. */\nvoid *buffer_get_modifiable_data(const buffer_t *buf, size_t *used_size_r)\n\tATTR_NULL(2);\n\n/* Set the \"used size\" of buffer, ie. 0 would set the buffer empty.\n   Must not be used to grow buffer. The data after the buffer's new size will\n   be effectively lost, because e.g. buffer_get_space_unsafe() will zero out\n   the contents. */\nvoid buffer_set_used_size(buffer_t *buf, size_t used_size);\n\n/* Returns the current buffer size. */\nsize_t buffer_get_size(const buffer_t *buf) ATTR_PURE;\n/* Returns how many bytes we can write to buffer without increasing its size.\n   With dynamic buffers this is buffer_get_size()-1, because the extra 1 byte\n   is reserved for str_c()'s NUL. */\nsize_t buffer_get_writable_size(const buffer_t *buf) ATTR_PURE;\n/* Returns the maximum number of bytes we can append to the buffer. If the\n   buffer is dynamic, this is always near SIZE_MAX. */\nsize_t buffer_get_avail_size(const buffer_t *buf) ATTR_PURE;\n\n/* Returns TRUE if buffer contents are identical. */\nbool buffer_cmp(const buffer_t *buf1, const buffer_t *buf2);\n\n/* Returns pointer to beginning of buffer data. Current used size of buffer is\n   stored in used_size if it's non-NULL. */\nstatic inline const void * ATTR_NULL(2)\nbuffer_get_data(const buffer_t *buf, size_t *used_size_r)\n{\n\tif (used_size_r != NULL)\n\t\t*used_size_r = buf->used;\n\treturn buf->data;\n}\n\n/* Returns the current used buffer size. */\nstatic inline size_t ATTR_PURE\nbuffer_get_used_size(const buffer_t *buf)\n{\n\treturn buf->used;\n}\n\n/* Crash if buffer was allocated from data stack and stack frame has changed.\n   This can be used as an assert-like check to verify that it's valid to\n   increase the buffer size here, instead of crashing only randomly when the\n   buffer needs to be increased. */\nvoid buffer_verify_pool(buffer_t *buf);\n\n/* This will truncate your byte buffer to contain at most\n   given number of bits. \n\n 1 bits:    01 00000001\n 2 bits:    03 00000011\n 3 bits:    07 00000111\n 4 bits:    0f 00001111\n 5 bits:    1f 00011111\n 6 bits:    3f 00111111\n 7 bits:    7f 01111111\n 8 bits:    ff 11111111\n 9 bits:  01ff 0000000111111111\n10 bits:  03ff 0000001111111111\n11 bits:  07ff 0000011111111111\n12 bits:  0fff 0000111111111111\n13 bits:  1fff 0001111111111111\n14 bits:  3fff 0011111111111111\n15 bits:  7fff 0111111111111111\n16 bits:  ffff 1111111111111111\n\n and so forth\n\n*/\nvoid buffer_truncate_rshift_bits(buffer_t *buf, size_t bits);\n\n#endif\n"}, "27": {"id": 27, "path": "/usr/local/include/dovecot/byteorder.h", "content": "/*\n * Copyright (c) 2016-2017 Josef 'Jeff' Sipek <jeffpc@josefsipek.net>\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n * SOFTWARE.\n */\n\n#ifndef BYTEORDER_H\n#define BYTEORDER_H\n\n/*\n * These prototypes exist to catch bugs in the code generating macros below.\n */\n/* return byte swapped input */\nstatic inline uint64_t i_bswap_64(uint64_t in);\nstatic inline uint32_t i_bswap_32(uint32_t in);\nstatic inline uint16_t i_bswap_16(uint16_t in);\nstatic inline uint8_t i_bswap_8(uint8_t in);\n\n/* load an unaligned cpu native endian number from memory */\nstatic inline uint64_t cpu64_to_cpu_unaligned(const void *in);\nstatic inline uint32_t cpu32_to_cpu_unaligned(const void *in);\nstatic inline uint16_t cpu16_to_cpu_unaligned(const void *in);\nstatic inline uint8_t cpu8_to_cpu_unaligned(const void *in);\n\n/* load an unaligned big endian number from memory */\nstatic inline uint64_t be64_to_cpu_unaligned(const void *in);\nstatic inline uint32_t be32_to_cpu_unaligned(const void *in);\nstatic inline uint16_t be16_to_cpu_unaligned(const void *in);\nstatic inline uint8_t be8_to_cpu_unaligned(const void *in);\n\n/* load an unaligned little endian number from memory */\nstatic inline uint64_t le64_to_cpu_unaligned(const void *in);\nstatic inline uint32_t le32_to_cpu_unaligned(const void *in);\nstatic inline uint16_t le16_to_cpu_unaligned(const void *in);\nstatic inline uint8_t le8_to_cpu_unaligned(const void *in);\n\n/* store into memory a cpu native endian number as a big endian number */\nstatic inline void cpu64_to_be_unaligned(uint64_t in, void *out);\nstatic inline void cpu32_to_be_unaligned(uint32_t in, void *out);\nstatic inline void cpu16_to_be_unaligned(uint16_t in, void *out);\nstatic inline void cpu8_to_be_unaligned(uint8_t in, void *out);\n\n/* store into memory a cpu native endian number as a little endian number */\nstatic inline void cpu64_to_le_unaligned(uint64_t in, void *out);\nstatic inline void cpu32_to_le_unaligned(uint32_t in, void *out);\nstatic inline void cpu16_to_le_unaligned(uint16_t in, void *out);\nstatic inline void cpu8_to_le_unaligned(uint8_t in, void *out);\n\n/* convert a big endian input into cpu native endian */\nstatic inline uint64_t be64_to_cpu(uint64_t in);\nstatic inline uint32_t be32_to_cpu(uint32_t in);\nstatic inline uint16_t be16_to_cpu(uint16_t in);\nstatic inline uint8_t be8_to_cpu(uint8_t in);\n\n/* convert a cpu native endian input into big endian */\nstatic inline uint64_t cpu64_to_be(uint64_t in);\nstatic inline uint32_t cpu32_to_be(uint32_t in);\nstatic inline uint16_t cpu16_to_be(uint16_t in);\nstatic inline uint8_t cpu8_to_be(uint8_t in);\n\n/* convert a little endian input into cpu native endian */\nstatic inline uint64_t le64_to_cpu(uint64_t in);\nstatic inline uint32_t le32_to_cpu(uint32_t in);\nstatic inline uint16_t le16_to_cpu(uint16_t in);\nstatic inline uint8_t le8_to_cpu(uint8_t in);\n\n/* convert a cpu native endian input into little endian */\nstatic inline uint64_t cpu64_to_le(uint64_t in);\nstatic inline uint32_t cpu32_to_le(uint32_t in);\nstatic inline uint16_t cpu16_to_le(uint16_t in);\nstatic inline uint8_t cpu8_to_le(uint8_t in);\n\n/*\n * byte swapping\n */\nstatic inline uint64_t i_bswap_64(uint64_t in)\n{\n\treturn ((in & 0xff00000000000000ULL) >> 56) |\n\t       ((in & 0x00ff000000000000ULL) >> 40) |\n\t       ((in & 0x0000ff0000000000ULL) >> 24) |\n\t       ((in & 0x000000ff00000000ULL) >> 8) |\n\t       ((in & 0x00000000ff000000ULL) << 8) |\n\t       ((in & 0x0000000000ff0000ULL) << 24) |\n\t       ((in & 0x000000000000ff00ULL) << 40) |\n\t       ((in & 0x00000000000000ffULL) << 56);\n}\n\nstatic inline uint32_t i_bswap_32(uint32_t in)\n{\n\treturn ((in & 0xff000000) >> 24) |\n\t       ((in & 0x00ff0000) >> 8) |\n\t       ((in & 0x0000ff00) << 8) |\n\t       ((in & 0x000000ff) << 24);\n}\n\nstatic inline uint16_t i_bswap_16(uint16_t in)\n{\n\treturn ((in & 0xff00) >> 8) |\n\t       ((in & 0x00ff) << 8);\n}\n\nstatic inline uint8_t i_bswap_8(uint8_t in)\n{\n\treturn (in & 0xff);\n}\n\n/*\n * unaligned big-endian integer\n */\nstatic inline uint64_t be64_to_cpu_unaligned(const void *in)\n{\n\tconst uint8_t *p = (const uint8_t *) in;\n\n\treturn (((uint64_t) p[0] << 56) |\n\t\t((uint64_t) p[1] << 48) |\n\t\t((uint64_t) p[2] << 40) |\n\t\t((uint64_t) p[3] << 32) |\n\t\t((uint64_t) p[4] << 24) |\n\t\t((uint64_t) p[5] << 16) |\n\t\t((uint64_t) p[6] << 8) |\n\t\t((uint64_t) p[7]));\n}\n\nstatic inline void cpu64_to_be_unaligned(uint64_t in, void *out)\n{\n\tuint8_t *p = (uint8_t *) out;\n\n\tp[0] = (in >> 56) & 0xff;\n\tp[1] = (in >> 48) & 0xff;\n\tp[2] = (in >> 40) & 0xff;\n\tp[3] = (in >> 32) & 0xff;\n\tp[4] = (in >> 24) & 0xff;\n\tp[5] = (in >> 16) & 0xff;\n\tp[6] = (in >> 8) & 0xff;\n\tp[7] = in & 0xff;\n}\n\nstatic inline uint32_t be32_to_cpu_unaligned(const void *in)\n{\n\tconst uint8_t *p = (const uint8_t *) in;\n\n\treturn (((uint32_t) p[0] << 24) |\n\t\t((uint32_t) p[1] << 16) |\n\t\t((uint32_t) p[2] << 8) |\n\t\t((uint32_t) p[3]));\n}\n\nstatic inline void cpu32_to_be_unaligned(uint32_t in, void *out)\n{\n\tuint8_t *p = (uint8_t *) out;\n\n\tp[0] = (in >> 24) & 0xff;\n\tp[1] = (in >> 16) & 0xff;\n\tp[2] = (in >> 8) & 0xff;\n\tp[3] = in & 0xff;\n}\n\nstatic inline uint16_t be16_to_cpu_unaligned(const void *in)\n{\n\tconst uint8_t *p = (const uint8_t *) in;\n\n\treturn (((uint16_t) p[0] << 8) |\n\t\t((uint16_t) p[1]));\n}\n\nstatic inline void cpu16_to_be_unaligned(uint16_t in, void *out)\n{\n\tuint8_t *p = (uint8_t *) out;\n\n\tp[0] = (in >> 8) & 0xff;\n\tp[1] = in & 0xff;\n}\n\nstatic inline uint8_t be8_to_cpu_unaligned(const void *in)\n{\n\treturn *((const uint8_t *) in);\n}\n\nstatic inline void cpu8_to_be_unaligned(uint8_t in, void *out)\n{\n\tuint8_t *p = (uint8_t *) out;\n\n\t*p = in;\n}\n\n/*\n * unaligned little-endian & cpu-endian integers\n */\n#define __GEN(size, bswap)\t\t\t\t\t\t\\\nstatic inline uint##size##_t le##size##_to_cpu_unaligned(const void *in)\\\n{\t\t\t\t\t\t\t\t\t\\\n\tuint##size##_t x = be##size##_to_cpu_unaligned(in);\t\t\\\n\t/* we read a LE int as BE, so we always have to byte swap */\t\\\n\treturn i_bswap_##size(x);\t\t\t\t\t\t\\\n}\t\t\t\t\t\t\t\t\t\\\nstatic inline void cpu##size##_to_le_unaligned(uint##size##_t in,\t\\\n\t\t\t\t\t       void *out)\t\t\\\n{\t\t\t\t\t\t\t\t\t\\\n\t/* we'll be writing in BE, so we always have to byte swap */\t\\\n\tcpu##size##_to_be_unaligned(i_bswap_##size(in), out);\t\t\\\n}\t\t\t\t\t\t\t\t\t\\\nstatic inline uint##size##_t cpu##size##_to_cpu_unaligned(const void *in)\\\n{\t\t\t\t\t\t\t\t\t\\\n\tuint##size##_t x = be##size##_to_cpu_unaligned(in);\t\t\\\n\treturn bswap;\t\t\t\t\t\t\t\\\n}\n\n#ifdef WORDS_BIGENDIAN\n#define GEN(size)\t__GEN(size, x)\n#else\n#define GEN(size)\t__GEN(size, i_bswap_##size(x))\n#endif\n\nGEN(64)\nGEN(32)\nGEN(16)\nGEN(8)\n\n#undef __GEN\n#undef GEN\n\n/*\n * byte ordering\n */\n#define ___GEN(from, size, to, bswap)\t\t\t\t\t\\\nstatic inline uint##size##_t from##size##_to_##to(uint##size##_t x)\t\\\n{\t\t\t\t\t\t\t\t\t\\\n\treturn bswap;\t\t\t\t\t\t\t\\\n}\n\n#ifdef WORDS_BIGENDIAN\n#define __GEN(from, size, to, be, le) ___GEN(from, size, to, be)\n#else\n#define __GEN(from, size, to, be, le) ___GEN(from, size, to, le)\n#endif\n\n#define GEN(size)\t\t\t\t\t\t\t\\\n\t__GEN(be,  size, cpu, x, i_bswap_##size(x))\t\t\t\\\n\t__GEN(cpu, size, be,  x, i_bswap_##size(x))\t\t\t\\\n\t__GEN(le,  size, cpu, i_bswap_##size(x), x)\t\t\t\\\n\t__GEN(cpu, size, le,  i_bswap_##size(x), x)\n\nGEN(64)\nGEN(32)\nGEN(16)\nGEN(8)\n\n#undef ___GEN\n#undef __GEN\n#undef GEN\n\n#endif\n"}, "28": {"id": 28, "path": "/usr/local/include/dovecot/compat.h", "content": "#ifndef COMPAT_H\n#define COMPAT_H\n\n/* _ILP32 and _LP64 are common but not universal, make sure that exactly one\n   of them is defined. */\n#if !defined(_ILP32) && \\\n\t(SIZEOF_INT == 4) && (SIZEOF_LONG == 4) && (SIZEOF_VOID_P == 4)\n#  define _ILP32\n#endif\n#if !defined(_LP64) && \\\n\t(SIZEOF_INT == 4) && (SIZEOF_LONG == 8) && (SIZEOF_VOID_P == 8)\n#  define _LP64\n#endif\n#if defined(_ILP32) && defined(_LP64)\n#  error \"Cannot have both _ILP32 and _LP64 defined\"\n#elif !defined(_ILP32) && !defined(_LP64)\n#  error \"Must have one of _ILP32 and _LP64 defined\"\n#endif\n\n/* well, this is obviously wrong since it assumes it's 64bit, but older\n   GCCs don't define it and we really want it. */\n#ifndef LLONG_MAX\n#  define LLONG_MAX 9223372036854775807LL\n#endif\n\n#if ((__GNUC__ > 3 || (__GNUC__ == 3 && __GNUC_MINOR__ > 3)) && \\\n\tdefined(HAVE_TYPEOF)) && !defined(__cplusplus)\n#  define HAVE_TYPE_CHECKS\n#endif\n\n/* We really want NULL to be a pointer, since we have various type-checks\n   that may result in compiler warnings/errors if it's not. Do this only when\n   type checking is used - it's not otherwise needed and causes compiling\n   problems with e.g. Sun C compiler. */\n#ifdef HAVE_TYPE_CHECKS\n#  undef NULL\n#  define NULL ((void *)0)\n#endif\n\n#ifndef __has_extension\n  #define __has_extension(x) 0  // Compatibility with non-clang compilers.\n#endif\n\n#if (defined(__GNUC__) && __GNUC__ > 4 || (__GNUC__ == 4 && __GNUC_MINOR__ >= 5)) || \\\n    (defined(__clang__) && (__has_extension(attribute_deprecated_with_message)))\n#  define HAVE_ATTR_DEPRECATED\nint rand(void) __attribute__((deprecated(\"Do not use rand, use i_rand\")));\nint rand_r(unsigned int*) __attribute__((deprecated(\"Do not use rand_r, use i_rand\")));\n#endif\n\n#ifndef __cplusplus\n#ifdef HAVE__BOOL\ntypedef _Bool bool;\n#else\ntypedef int bool;\n#endif\n#endif\n\n#if defined (HAVE_UOFF_T)\n/* native support */\n#elif defined (UOFF_T_INT)\ntypedef unsigned int uoff_t;\n#elif defined (UOFF_T_LONG)\ntypedef unsigned long uoff_t;\n#elif defined (UOFF_T_LONG_LONG)\ntypedef unsigned long long uoff_t;\n#else\n#  error uoff_t size not set\n#endif\n\n#ifndef HAVE_UINTMAX_T\n#  if SIZEOF_LONG_LONG > 0\ntypedef unsigned long long uintmax_t;\n#  else\ntypedef unsigned long uintmax_t;\n#  endif\n#endif\n\n#ifndef HAVE_UINT_FAST32_T\n#  if SIZEOF_INT >= 4\ntypedef unsigned int uint_fast32_t;\n#  else\ntypedef unsigned long uint_fast32_t;\n#  endif\n#endif\n\n#ifndef HAVE_SOCKLEN_T\ntypedef int socklen_t;\n#endif\n\n/* WORDS_BIGENDIAN needs to be undefined if not enabled */\n#if defined(WORDS_BIGENDIAN) && WORDS_BIGENDIAN == 0\n#  undef WORDS_BIGENDIAN\n#endif\n\n#ifdef HAVE_SYS_SYSMACROS_H\n#  include <sys/sysmacros.h>\n#  ifdef HAVE_SYS_MKDEV_H\n#    include <sys/mkdev.h> /* UnixWare */\n#  endif\n#  define CMP_DEV_T(a, b) (major(a) == major(b) && minor(a) == minor(b))\n#elif !defined (DEV_T_STRUCT)\n#  define CMP_DEV_T(a, b) ((a) == (b))\n#else\n#  error I do not know how to compare dev_t\n#endif\n\n#ifdef HAVE_STAT_XTIM\n#  define HAVE_ST_NSECS\n#  define ST_ATIME_NSEC(st) ((unsigned long)(st).st_atim.tv_nsec)\n#  define ST_MTIME_NSEC(st) ((unsigned long)(st).st_mtim.tv_nsec)\n#  define ST_CTIME_NSEC(st) ((unsigned long)(st).st_ctim.tv_nsec)\n#elif defined (HAVE_STAT_XTIMESPEC)\n#  define HAVE_ST_NSECS\n#  define ST_ATIME_NSEC(st) ((unsigned long)(st).st_atimespec.tv_nsec)\n#  define ST_MTIME_NSEC(st) ((unsigned long)(st).st_mtimespec.tv_nsec)\n#  define ST_CTIME_NSEC(st) ((unsigned long)(st).st_ctimespec.tv_nsec)\n#else\n#  define ST_ATIME_NSEC(st) 0UL\n#  define ST_MTIME_NSEC(st) 0UL\n#  define ST_CTIME_NSEC(st) 0UL\n#endif\n\n#ifdef HAVE_ST_NSECS\n/* TRUE if a nanosecond timestamp from struct stat matches another nanosecond.\n   If nanoseconds aren't supported in struct stat, returns always TRUE (useful\n   with NFS if some hosts support nanoseconds and others don't). */\n#  define ST_NTIMES_EQUAL(ns1, ns2) ((ns1) == (ns2))\n#else\n#  define ST_NTIMES_EQUAL(ns1, ns2) TRUE\n#endif\n\n#define CMP_ST_MTIME(st1, st2) \\\n\t((st1)->st_mtime == (st2)->st_mtime && \\\n\t ST_NTIMES_EQUAL(ST_MTIME_NSEC(*(st1)), ST_MTIME_NSEC(*(st2))))\n#define CMP_ST_CTIME(st1, st2) \\\n\t((st1)->st_ctime == (st2)->st_ctime && \\\n\t ST_NTIMES_EQUAL(ST_CTIME_NSEC(*(st1)), ST_CTIME_NSEC(*(st2))))\n\n/* strcasecmp(), strncasecmp() */\n#ifndef HAVE_STRCASECMP\n#  ifdef HAVE_STRICMP\n#    define strcasecmp stricmp\n#    define strncasecmp strnicmp\n#  else\n#    define strcasecmp i_my_strcasecmp\n#    define strncasecmp i_my_strncasecmp\nint i_my_strcasecmp(const char *s1, const char *s2);\nint i_my_strncasecmp(const char *s1, const char *s2, size_t max_chars);\n#  endif\n#endif\n\n#ifndef HAVE_INET_ATON\n#  include <sys/socket.h>\n#  include <netinet/in.h>\n#  include <arpa/inet.h>\n#  define inet_aton i_my_inet_aton\nint i_my_inet_aton(const char *cp, struct in_addr *inp);\n#endif\n\n#ifndef HAVE_VSYSLOG\n#  define vsyslog i_my_vsyslog\nvoid i_my_vsyslog(int priority, const char *format, va_list args);\n#endif\n\n#ifndef HAVE_GETPAGESIZE\n#  define getpagesize i_my_getpagesize\nint i_my_getpagesize(void);\n#endif\n\n#ifndef HAVE_FDATASYNC\n#  define fdatasync fsync\n#endif\n\nstruct const_iovec {\n\tconst void *iov_base;\n\tsize_t iov_len;\n};\n\n#ifndef HAVE_STRUCT_IOVEC\nstruct iovec {\n\tvoid *iov_base;\n\tsize_t iov_len;\n};\n#endif\n\n/* IOV_MAX should be in limits.h nowadays. Linux still (2005) requires\n   defining _XOPEN_SOURCE to get that value. UIO_MAXIOV works with it though,\n   so use it instead. 16 is the lowest acceptable value for all OSes. */\n#ifndef IOV_MAX\n#  include <sys/uio.h>\n#  ifdef UIO_MAXIOV\n#    define IOV_MAX UIO_MAXIOV\n#  else\n#    define IOV_MAX 16\n#  endif\n#endif\n\n#ifndef HAVE_WRITEV\n#  define writev i_my_writev\nstruct iovec;\nssize_t i_my_writev(int fd, const struct iovec *iov, int iov_len);\n#endif\n\n#if !defined(HAVE_PREAD) || defined(PREAD_WRAPPERS) || defined(PREAD_BROKEN)\n#  ifndef IN_COMPAT_C\n#    define pread i_my_pread\n#    define pwrite i_my_pwrite\n#  endif\nssize_t i_my_pread(int fd, void *buf, size_t count, off_t offset);\nssize_t i_my_pwrite(int fd, const void *buf, size_t count, off_t offset);\n#endif\n\n#ifndef HAVE_SETEUID\n#  define seteuid i_my_seteuid\nint i_my_seteuid(uid_t euid);\n#endif\n\n#ifndef HAVE_SETEGID\n#  define setegid i_my_setegid\nint i_my_setegid(gid_t egid);\n#endif\n\n#ifndef HAVE_LIBGEN_H\n#  define basename i_my_basename\nchar *i_my_basename(char *path);\n#endif\n\n#ifdef HAVE_OLD_VSNPRINTF\n#  include <stdio.h>\n#  define vsnprintf i_my_vsnprintf\nint i_my_vsnprintf(char *str, size_t size, const char *format, va_list ap);\n#endif\n\n#ifndef HAVE_CLOCK_GETTIME\n#  include <time.h>\n#  undef CLOCK_REALTIME\n#  define CLOCK_REALTIME 1\n#  define clock_gettime i_my_clock_gettime\nint i_my_clock_gettime(int clk_id, struct timespec *tp);\n#endif\n\n/* ctype.h isn't safe with signed chars,\n   use our own instead if really needed */\n#define i_toupper(x) ((char) toupper((int) (unsigned char) (x)))\n#define i_tolower(x) ((char) tolower((int) (unsigned char) (x)))\n#define i_isalnum(x) (isalnum((int) (unsigned char) (x)) != 0)\n#define i_isalpha(x) (isalpha((int) (unsigned char) (x)) != 0)\n#define i_isascii(x) (isascii((int) (unsigned char) (x)) != 0)\n#define i_isblank(x) (isblank((int) (unsigned char) (x)) != 0)\n#define i_iscntrl(x) (iscntrl((int) (unsigned char) (x)) != 0)\n#define i_isdigit(x) (isdigit((int) (unsigned char) (x)) != 0)\n#define i_isgraph(x) (isgraph((int) (unsigned char) (x)) != 0)\n#define i_islower(x) (islower((int) (unsigned char) (x)) != 0)\n#define i_isprint(x) (isprint((int) (unsigned char) (x)) != 0)\n#define i_ispunct(x) (ispunct((int) (unsigned char) (x)) != 0)\n#define i_isspace(x) (isspace((int) (unsigned char) (x)) != 0)\n#define i_isupper(x) (isupper((int) (unsigned char) (x)) != 0)\n#define i_isxdigit(x) (isxdigit((int) (unsigned char) (x)) != 0)\n\n#ifndef EOVERFLOW\n#  define EOVERFLOW ERANGE\n#endif\n\n#ifdef EDQUOT\n#  define ENOSPACE(errno) ((errno) == ENOSPC || (errno) == EDQUOT)\n#  define ENOQUOTA(errno) ((errno) == EDQUOT)\n#else\n/* probably all modern OSes have EDQUOT, but just in case one doesn't assume\n   that ENOSPC is the same as \"over quota\". */\n#  define ENOSPACE(errno) ((errno) == ENOSPC)\n#  define ENOQUOTA(errno) ((errno) == ENOSPC)\n#endif\n\n/* EPERM is returned sometimes if device doesn't support such modification */\n#ifdef EROFS\n#  define ENOACCESS(errno) \\\n\t((errno) == EACCES || (errno) == EROFS || (errno) == EPERM)\n#else\n#  define ENOACCESS(errno) ((errno) == EACCES || (errno) == EPERM)\n#endif\n\n#define ENOTFOUND(errno) \\\n\t((errno) == ENOENT || (errno) == ENOTDIR || \\\n\t (errno) == ELOOP || (errno) == ENAMETOOLONG)\n\n#define ECANTLINK(errno) \\\n\t((errno) == EXDEV || (errno) == EMLINK || (errno) == EPERM)\n\n/* Returns TRUE if unlink() failed because it attempted to delete a directory */\n#define UNLINK_EISDIR(errno) \\\n\t((errno) == EPERM || /* POSIX */ \\\n\t (errno) == EISDIR) /* Linux */\n\n/* EBUSY is given by some NFS implementations */\n#define EDESTDIREXISTS(errno) \\\n\t((errno) == EEXIST || (errno) == ENOTEMPTY || (errno) == EBUSY)\n\n/* fstat() returns ENOENT instead of ESTALE with some Linux versions */\n#define ESTALE_FSTAT(errno) \\\n\t((errno) == ESTALE || (errno) == ENOENT)\n\n#if !defined(_POSIX_SYNCHRONIZED_IO) && \\\n    defined(__ENVIRONMENT_MAC_OS_X_VERSION_MIN_REQUIRED__) && \\\n    (__ENVIRONMENT_MAC_OS_X_VERSION_MIN_REQUIRED__ >= 1060)\n/* OS X Snow Leopard has fdatasync(), but no prototype for it. */\nint fdatasync(int);\n#endif\n\n/* Try to keep IO operations at least this size */\n#ifndef IO_BLOCK_SIZE\n#  define IO_BLOCK_SIZE 8192\n#endif\n/* Default size for data blocks transferred over the network */\n#ifndef NET_BLOCK_SIZE\n#  define NET_BLOCK_SIZE (128*1024)\n#endif\n\n#if !defined(PIPE_BUF) && defined(_POSIX_PIPE_BUF)\n#  define PIPE_BUF (8 * _POSIX_PIPE_BUF) /* for HURD */\n#endif\n\n#endif\n"}, "29": {"id": 29, "path": "/usr/include/stdlib.h", "content": "/* Copyright (C) 1991-2018 Free Software Foundation, Inc.\n   This file is part of the GNU C Library.\n\n   The GNU C Library is free software; you can redistribute it and/or\n   modify it under the terms of the GNU Lesser General Public\n   License as published by the Free Software Foundation; either\n   version 2.1 of the License, or (at your option) any later version.\n\n   The GNU C Library is distributed in the hope that it will be useful,\n   but WITHOUT ANY WARRANTY; without even the implied warranty of\n   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n   Lesser General Public License for more details.\n\n   You should have received a copy of the GNU Lesser General Public\n   License along with the GNU C Library; if not, see\n   <http://www.gnu.org/licenses/>.  */\n\n/*\n *\tISO C99 Standard: 7.20 General utilities\t<stdlib.h>\n */\n\n#ifndef\t_STDLIB_H\n\n#define __GLIBC_INTERNAL_STARTING_HEADER_IMPLEMENTATION\n#include <bits/libc-header-start.h>\n\n/* Get size_t, wchar_t and NULL from <stddef.h>.  */\n#define __need_size_t\n#define __need_wchar_t\n#define __need_NULL\n#include <stddef.h>\n\n__BEGIN_DECLS\n\n#define\t_STDLIB_H\t1\n\n#if (defined __USE_XOPEN || defined __USE_XOPEN2K8) && !defined _SYS_WAIT_H\n/* XPG requires a few symbols from <sys/wait.h> being defined.  */\n# include <bits/waitflags.h>\n# include <bits/waitstatus.h>\n\n/* Define the macros <sys/wait.h> also would define this way.  */\n# define WEXITSTATUS(status)\t__WEXITSTATUS (status)\n# define WTERMSIG(status)\t__WTERMSIG (status)\n# define WSTOPSIG(status)\t__WSTOPSIG (status)\n# define WIFEXITED(status)\t__WIFEXITED (status)\n# define WIFSIGNALED(status)\t__WIFSIGNALED (status)\n# define WIFSTOPPED(status)\t__WIFSTOPPED (status)\n# ifdef __WIFCONTINUED\n#  define WIFCONTINUED(status)\t__WIFCONTINUED (status)\n# endif\n#endif\t/* X/Open or XPG7 and <sys/wait.h> not included.  */\n\n/* _FloatN API tests for enablement.  */\n#include <bits/floatn.h>\n\n/* Returned by `div'.  */\ntypedef struct\n  {\n    int quot;\t\t\t/* Quotient.  */\n    int rem;\t\t\t/* Remainder.  */\n  } div_t;\n\n/* Returned by `ldiv'.  */\n#ifndef __ldiv_t_defined\ntypedef struct\n  {\n    long int quot;\t\t/* Quotient.  */\n    long int rem;\t\t/* Remainder.  */\n  } ldiv_t;\n# define __ldiv_t_defined\t1\n#endif\n\n#if defined __USE_ISOC99 && !defined __lldiv_t_defined\n/* Returned by `lldiv'.  */\n__extension__ typedef struct\n  {\n    long long int quot;\t\t/* Quotient.  */\n    long long int rem;\t\t/* Remainder.  */\n  } lldiv_t;\n# define __lldiv_t_defined\t1\n#endif\n\n\n/* The largest number rand will return (same as INT_MAX).  */\n#define\tRAND_MAX\t2147483647\n\n\n/* We define these the same for all machines.\n   Changes from this to the outside world should be done in `_exit'.  */\n#define\tEXIT_FAILURE\t1\t/* Failing exit status.  */\n#define\tEXIT_SUCCESS\t0\t/* Successful exit status.  */\n\n\n/* Maximum length of a multibyte character in the current locale.  */\n#define\tMB_CUR_MAX\t(__ctype_get_mb_cur_max ())\nextern size_t __ctype_get_mb_cur_max (void) __THROW __wur;\n\n\n/* Convert a string to a floating-point number.  */\nextern double atof (const char *__nptr)\n     __THROW __attribute_pure__ __nonnull ((1)) __wur;\n/* Convert a string to an integer.  */\nextern int atoi (const char *__nptr)\n     __THROW __attribute_pure__ __nonnull ((1)) __wur;\n/* Convert a string to a long integer.  */\nextern long int atol (const char *__nptr)\n     __THROW __attribute_pure__ __nonnull ((1)) __wur;\n\n#ifdef __USE_ISOC99\n/* Convert a string to a long long integer.  */\n__extension__ extern long long int atoll (const char *__nptr)\n     __THROW __attribute_pure__ __nonnull ((1)) __wur;\n#endif\n\n/* Convert a string to a floating-point number.  */\nextern double strtod (const char *__restrict __nptr,\n\t\t      char **__restrict __endptr)\n     __THROW __nonnull ((1));\n\n#ifdef\t__USE_ISOC99\n/* Likewise for `float' and `long double' sizes of floating-point numbers.  */\nextern float strtof (const char *__restrict __nptr,\n\t\t     char **__restrict __endptr) __THROW __nonnull ((1));\n\nextern long double strtold (const char *__restrict __nptr,\n\t\t\t    char **__restrict __endptr)\n     __THROW __nonnull ((1));\n#endif\n\n/* Likewise for '_FloatN' and '_FloatNx'.  */\n\n#if __HAVE_FLOAT16 && __GLIBC_USE (IEC_60559_TYPES_EXT)\nextern _Float16 strtof16 (const char *__restrict __nptr,\n\t\t\t  char **__restrict __endptr)\n     __THROW __nonnull ((1));\n#endif\n\n#if __HAVE_FLOAT32 && __GLIBC_USE (IEC_60559_TYPES_EXT)\nextern _Float32 strtof32 (const char *__restrict __nptr,\n\t\t\t  char **__restrict __endptr)\n     __THROW __nonnull ((1));\n#endif\n\n#if __HAVE_FLOAT64 && __GLIBC_USE (IEC_60559_TYPES_EXT)\nextern _Float64 strtof64 (const char *__restrict __nptr,\n\t\t\t  char **__restrict __endptr)\n     __THROW __nonnull ((1));\n#endif\n\n#if __HAVE_FLOAT128 && __GLIBC_USE (IEC_60559_TYPES_EXT)\nextern _Float128 strtof128 (const char *__restrict __nptr,\n\t\t\t    char **__restrict __endptr)\n     __THROW __nonnull ((1));\n#endif\n\n#if __HAVE_FLOAT32X && __GLIBC_USE (IEC_60559_TYPES_EXT)\nextern _Float32x strtof32x (const char *__restrict __nptr,\n\t\t\t    char **__restrict __endptr)\n     __THROW __nonnull ((1));\n#endif\n\n#if __HAVE_FLOAT64X && __GLIBC_USE (IEC_60559_TYPES_EXT)\nextern _Float64x strtof64x (const char *__restrict __nptr,\n\t\t\t    char **__restrict __endptr)\n     __THROW __nonnull ((1));\n#endif\n\n#if __HAVE_FLOAT128X && __GLIBC_USE (IEC_60559_TYPES_EXT)\nextern _Float128x strtof128x (const char *__restrict __nptr,\n\t\t\t      char **__restrict __endptr)\n     __THROW __nonnull ((1));\n#endif\n\n/* Convert a string to a long integer.  */\nextern long int strtol (const char *__restrict __nptr,\n\t\t\tchar **__restrict __endptr, int __base)\n     __THROW __nonnull ((1));\n/* Convert a string to an unsigned long integer.  */\nextern unsigned long int strtoul (const char *__restrict __nptr,\n\t\t\t\t  char **__restrict __endptr, int __base)\n     __THROW __nonnull ((1));\n\n#ifdef __USE_MISC\n/* Convert a string to a quadword integer.  */\n__extension__\nextern long long int strtoq (const char *__restrict __nptr,\n\t\t\t     char **__restrict __endptr, int __base)\n     __THROW __nonnull ((1));\n/* Convert a string to an unsigned quadword integer.  */\n__extension__\nextern unsigned long long int strtouq (const char *__restrict __nptr,\n\t\t\t\t       char **__restrict __endptr, int __base)\n     __THROW __nonnull ((1));\n#endif /* Use misc.  */\n\n#ifdef __USE_ISOC99\n/* Convert a string to a quadword integer.  */\n__extension__\nextern long long int strtoll (const char *__restrict __nptr,\n\t\t\t      char **__restrict __endptr, int __base)\n     __THROW __nonnull ((1));\n/* Convert a string to an unsigned quadword integer.  */\n__extension__\nextern unsigned long long int strtoull (const char *__restrict __nptr,\n\t\t\t\t\tchar **__restrict __endptr, int __base)\n     __THROW __nonnull ((1));\n#endif /* ISO C99 or use MISC.  */\n\n/* Convert a floating-point number to a string.  */\n#if __GLIBC_USE (IEC_60559_BFP_EXT)\nextern int strfromd (char *__dest, size_t __size, const char *__format,\n\t\t     double __f)\n     __THROW __nonnull ((3));\n\nextern int strfromf (char *__dest, size_t __size, const char *__format,\n\t\t     float __f)\n     __THROW __nonnull ((3));\n\nextern int strfroml (char *__dest, size_t __size, const char *__format,\n\t\t     long double __f)\n     __THROW __nonnull ((3));\n#endif\n\n#if __HAVE_FLOAT16 && __GLIBC_USE (IEC_60559_TYPES_EXT)\nextern int strfromf16 (char *__dest, size_t __size, const char * __format,\n\t\t       _Float16 __f)\n     __THROW __nonnull ((3));\n#endif\n\n#if __HAVE_FLOAT32 && __GLIBC_USE (IEC_60559_TYPES_EXT)\nextern int strfromf32 (char *__dest, size_t __size, const char * __format,\n\t\t       _Float32 __f)\n     __THROW __nonnull ((3));\n#endif\n\n#if __HAVE_FLOAT64 && __GLIBC_USE (IEC_60559_TYPES_EXT)\nextern int strfromf64 (char *__dest, size_t __size, const char * __format,\n\t\t       _Float64 __f)\n     __THROW __nonnull ((3));\n#endif\n\n#if __HAVE_FLOAT128 && __GLIBC_USE (IEC_60559_TYPES_EXT)\nextern int strfromf128 (char *__dest, size_t __size, const char * __format,\n\t\t\t_Float128 __f)\n     __THROW __nonnull ((3));\n#endif\n\n#if __HAVE_FLOAT32X && __GLIBC_USE (IEC_60559_TYPES_EXT)\nextern int strfromf32x (char *__dest, size_t __size, const char * __format,\n\t\t\t_Float32x __f)\n     __THROW __nonnull ((3));\n#endif\n\n#if __HAVE_FLOAT64X && __GLIBC_USE (IEC_60559_TYPES_EXT)\nextern int strfromf64x (char *__dest, size_t __size, const char * __format,\n\t\t\t_Float64x __f)\n     __THROW __nonnull ((3));\n#endif\n\n#if __HAVE_FLOAT128X && __GLIBC_USE (IEC_60559_TYPES_EXT)\nextern int strfromf128x (char *__dest, size_t __size, const char * __format,\n\t\t\t _Float128x __f)\n     __THROW __nonnull ((3));\n#endif\n\n\n#ifdef __USE_GNU\n/* Parallel versions of the functions above which take the locale to\n   use as an additional parameter.  These are GNU extensions inspired\n   by the POSIX.1-2008 extended locale API.  */\n# include <bits/types/locale_t.h>\n\nextern long int strtol_l (const char *__restrict __nptr,\n\t\t\t  char **__restrict __endptr, int __base,\n\t\t\t  locale_t __loc) __THROW __nonnull ((1, 4));\n\nextern unsigned long int strtoul_l (const char *__restrict __nptr,\n\t\t\t\t    char **__restrict __endptr,\n\t\t\t\t    int __base, locale_t __loc)\n     __THROW __nonnull ((1, 4));\n\n__extension__\nextern long long int strtoll_l (const char *__restrict __nptr,\n\t\t\t\tchar **__restrict __endptr, int __base,\n\t\t\t\tlocale_t __loc)\n     __THROW __nonnull ((1, 4));\n\n__extension__\nextern unsigned long long int strtoull_l (const char *__restrict __nptr,\n\t\t\t\t\t  char **__restrict __endptr,\n\t\t\t\t\t  int __base, locale_t __loc)\n     __THROW __nonnull ((1, 4));\n\nextern double strtod_l (const char *__restrict __nptr,\n\t\t\tchar **__restrict __endptr, locale_t __loc)\n     __THROW __nonnull ((1, 3));\n\nextern float strtof_l (const char *__restrict __nptr,\n\t\t       char **__restrict __endptr, locale_t __loc)\n     __THROW __nonnull ((1, 3));\n\nextern long double strtold_l (const char *__restrict __nptr,\n\t\t\t      char **__restrict __endptr,\n\t\t\t      locale_t __loc)\n     __THROW __nonnull ((1, 3));\n\n# if __HAVE_FLOAT16\nextern _Float16 strtof16_l (const char *__restrict __nptr,\n\t\t\t    char **__restrict __endptr,\n\t\t\t    locale_t __loc)\n     __THROW __nonnull ((1, 3));\n# endif\n\n# if __HAVE_FLOAT32\nextern _Float32 strtof32_l (const char *__restrict __nptr,\n\t\t\t    char **__restrict __endptr,\n\t\t\t    locale_t __loc)\n     __THROW __nonnull ((1, 3));\n# endif\n\n# if __HAVE_FLOAT64\nextern _Float64 strtof64_l (const char *__restrict __nptr,\n\t\t\t    char **__restrict __endptr,\n\t\t\t    locale_t __loc)\n     __THROW __nonnull ((1, 3));\n# endif\n\n# if __HAVE_FLOAT128\nextern _Float128 strtof128_l (const char *__restrict __nptr,\n\t\t\t      char **__restrict __endptr,\n\t\t\t      locale_t __loc)\n     __THROW __nonnull ((1, 3));\n# endif\n\n# if __HAVE_FLOAT32X\nextern _Float32x strtof32x_l (const char *__restrict __nptr,\n\t\t\t      char **__restrict __endptr,\n\t\t\t      locale_t __loc)\n     __THROW __nonnull ((1, 3));\n# endif\n\n# if __HAVE_FLOAT64X\nextern _Float64x strtof64x_l (const char *__restrict __nptr,\n\t\t\t      char **__restrict __endptr,\n\t\t\t      locale_t __loc)\n     __THROW __nonnull ((1, 3));\n# endif\n\n# if __HAVE_FLOAT128X\nextern _Float128x strtof128x_l (const char *__restrict __nptr,\n\t\t\t\tchar **__restrict __endptr,\n\t\t\t\tlocale_t __loc)\n     __THROW __nonnull ((1, 3));\n# endif\n#endif /* GNU */\n\n\n#ifdef __USE_EXTERN_INLINES\n__extern_inline int\n__NTH (atoi (const char *__nptr))\n{\n  return (int) strtol (__nptr, (char **) NULL, 10);\n}\n__extern_inline long int\n__NTH (atol (const char *__nptr))\n{\n  return strtol (__nptr, (char **) NULL, 10);\n}\n\n# ifdef __USE_ISOC99\n__extension__ __extern_inline long long int\n__NTH (atoll (const char *__nptr))\n{\n  return strtoll (__nptr, (char **) NULL, 10);\n}\n# endif\n#endif /* Optimizing and Inlining.  */\n\n\n#if defined __USE_MISC || defined __USE_XOPEN_EXTENDED\n/* Convert N to base 64 using the digits \"./0-9A-Za-z\", least-significant\n   digit first.  Returns a pointer to static storage overwritten by the\n   next call.  */\nextern char *l64a (long int __n) __THROW __wur;\n\n/* Read a number from a string S in base 64 as above.  */\nextern long int a64l (const char *__s)\n     __THROW __attribute_pure__ __nonnull ((1)) __wur;\n\n#endif\t/* Use misc || extended X/Open.  */\n\n#if defined __USE_MISC || defined __USE_XOPEN_EXTENDED\n# include <sys/types.h>\t/* we need int32_t... */\n\n/* These are the functions that actually do things.  The `random', `srandom',\n   `initstate' and `setstate' functions are those from BSD Unices.\n   The `rand' and `srand' functions are required by the ANSI standard.\n   We provide both interfaces to the same random number generator.  */\n/* Return a random long integer between 0 and RAND_MAX inclusive.  */\nextern long int random (void) __THROW;\n\n/* Seed the random number generator with the given number.  */\nextern void srandom (unsigned int __seed) __THROW;\n\n/* Initialize the random number generator to use state buffer STATEBUF,\n   of length STATELEN, and seed it with SEED.  Optimal lengths are 8, 16,\n   32, 64, 128 and 256, the bigger the better; values less than 8 will\n   cause an error and values greater than 256 will be rounded down.  */\nextern char *initstate (unsigned int __seed, char *__statebuf,\n\t\t\tsize_t __statelen) __THROW __nonnull ((2));\n\n/* Switch the random number generator to state buffer STATEBUF,\n   which should have been previously initialized by `initstate'.  */\nextern char *setstate (char *__statebuf) __THROW __nonnull ((1));\n\n\n# ifdef __USE_MISC\n/* Reentrant versions of the `random' family of functions.\n   These functions all use the following data structure to contain\n   state, rather than global state variables.  */\n\nstruct random_data\n  {\n    int32_t *fptr;\t\t/* Front pointer.  */\n    int32_t *rptr;\t\t/* Rear pointer.  */\n    int32_t *state;\t\t/* Array of state values.  */\n    int rand_type;\t\t/* Type of random number generator.  */\n    int rand_deg;\t\t/* Degree of random number generator.  */\n    int rand_sep;\t\t/* Distance between front and rear.  */\n    int32_t *end_ptr;\t\t/* Pointer behind state table.  */\n  };\n\nextern int random_r (struct random_data *__restrict __buf,\n\t\t     int32_t *__restrict __result) __THROW __nonnull ((1, 2));\n\nextern int srandom_r (unsigned int __seed, struct random_data *__buf)\n     __THROW __nonnull ((2));\n\nextern int initstate_r (unsigned int __seed, char *__restrict __statebuf,\n\t\t\tsize_t __statelen,\n\t\t\tstruct random_data *__restrict __buf)\n     __THROW __nonnull ((2, 4));\n\nextern int setstate_r (char *__restrict __statebuf,\n\t\t       struct random_data *__restrict __buf)\n     __THROW __nonnull ((1, 2));\n# endif\t/* Use misc.  */\n#endif\t/* Use extended X/Open || misc. */\n\n\n/* Return a random integer between 0 and RAND_MAX inclusive.  */\nextern int rand (void) __THROW;\n/* Seed the random number generator with the given number.  */\nextern void srand (unsigned int __seed) __THROW;\n\n#ifdef __USE_POSIX199506\n/* Reentrant interface according to POSIX.1.  */\nextern int rand_r (unsigned int *__seed) __THROW;\n#endif\n\n\n#if defined __USE_MISC || defined __USE_XOPEN\n/* System V style 48-bit random number generator functions.  */\n\n/* Return non-negative, double-precision floating-point value in [0.0,1.0).  */\nextern double drand48 (void) __THROW;\nextern double erand48 (unsigned short int __xsubi[3]) __THROW __nonnull ((1));\n\n/* Return non-negative, long integer in [0,2^31).  */\nextern long int lrand48 (void) __THROW;\nextern long int nrand48 (unsigned short int __xsubi[3])\n     __THROW __nonnull ((1));\n\n/* Return signed, long integers in [-2^31,2^31).  */\nextern long int mrand48 (void) __THROW;\nextern long int jrand48 (unsigned short int __xsubi[3])\n     __THROW __nonnull ((1));\n\n/* Seed random number generator.  */\nextern void srand48 (long int __seedval) __THROW;\nextern unsigned short int *seed48 (unsigned short int __seed16v[3])\n     __THROW __nonnull ((1));\nextern void lcong48 (unsigned short int __param[7]) __THROW __nonnull ((1));\n\n# ifdef __USE_MISC\n/* Data structure for communication with thread safe versions.  This\n   type is to be regarded as opaque.  It's only exported because users\n   have to allocate objects of this type.  */\nstruct drand48_data\n  {\n    unsigned short int __x[3];\t/* Current state.  */\n    unsigned short int __old_x[3]; /* Old state.  */\n    unsigned short int __c;\t/* Additive const. in congruential formula.  */\n    unsigned short int __init;\t/* Flag for initializing.  */\n    __extension__ unsigned long long int __a;\t/* Factor in congruential\n\t\t\t\t\t\t   formula.  */\n  };\n\n/* Return non-negative, double-precision floating-point value in [0.0,1.0).  */\nextern int drand48_r (struct drand48_data *__restrict __buffer,\n\t\t      double *__restrict __result) __THROW __nonnull ((1, 2));\nextern int erand48_r (unsigned short int __xsubi[3],\n\t\t      struct drand48_data *__restrict __buffer,\n\t\t      double *__restrict __result) __THROW __nonnull ((1, 2));\n\n/* Return non-negative, long integer in [0,2^31).  */\nextern int lrand48_r (struct drand48_data *__restrict __buffer,\n\t\t      long int *__restrict __result)\n     __THROW __nonnull ((1, 2));\nextern int nrand48_r (unsigned short int __xsubi[3],\n\t\t      struct drand48_data *__restrict __buffer,\n\t\t      long int *__restrict __result)\n     __THROW __nonnull ((1, 2));\n\n/* Return signed, long integers in [-2^31,2^31).  */\nextern int mrand48_r (struct drand48_data *__restrict __buffer,\n\t\t      long int *__restrict __result)\n     __THROW __nonnull ((1, 2));\nextern int jrand48_r (unsigned short int __xsubi[3],\n\t\t      struct drand48_data *__restrict __buffer,\n\t\t      long int *__restrict __result)\n     __THROW __nonnull ((1, 2));\n\n/* Seed random number generator.  */\nextern int srand48_r (long int __seedval, struct drand48_data *__buffer)\n     __THROW __nonnull ((2));\n\nextern int seed48_r (unsigned short int __seed16v[3],\n\t\t     struct drand48_data *__buffer) __THROW __nonnull ((1, 2));\n\nextern int lcong48_r (unsigned short int __param[7],\n\t\t      struct drand48_data *__buffer)\n     __THROW __nonnull ((1, 2));\n# endif\t/* Use misc.  */\n#endif\t/* Use misc or X/Open.  */\n\n/* Allocate SIZE bytes of memory.  */\nextern void *malloc (size_t __size) __THROW __attribute_malloc__ __wur;\n/* Allocate NMEMB elements of SIZE bytes each, all initialized to 0.  */\nextern void *calloc (size_t __nmemb, size_t __size)\n     __THROW __attribute_malloc__ __wur;\n\n/* Re-allocate the previously allocated block\n   in PTR, making the new block SIZE bytes long.  */\n/* __attribute_malloc__ is not used, because if realloc returns\n   the same pointer that was passed to it, aliasing needs to be allowed\n   between objects pointed by the old and new pointers.  */\nextern void *realloc (void *__ptr, size_t __size)\n     __THROW __attribute_warn_unused_result__;\n\n#ifdef __USE_GNU\n/* Re-allocate the previously allocated block in PTR, making the new\n   block large enough for NMEMB elements of SIZE bytes each.  */\n/* __attribute_malloc__ is not used, because if reallocarray returns\n   the same pointer that was passed to it, aliasing needs to be allowed\n   between objects pointed by the old and new pointers.  */\nextern void *reallocarray (void *__ptr, size_t __nmemb, size_t __size)\n     __THROW __attribute_warn_unused_result__;\n#endif\n\n/* Free a block allocated by `malloc', `realloc' or `calloc'.  */\nextern void free (void *__ptr) __THROW;\n\n#ifdef __USE_MISC\n# include <alloca.h>\n#endif /* Use misc.  */\n\n#if (defined __USE_XOPEN_EXTENDED && !defined __USE_XOPEN2K) \\\n    || defined __USE_MISC\n/* Allocate SIZE bytes on a page boundary.  The storage cannot be freed.  */\nextern void *valloc (size_t __size) __THROW __attribute_malloc__ __wur;\n#endif\n\n#ifdef __USE_XOPEN2K\n/* Allocate memory of SIZE bytes with an alignment of ALIGNMENT.  */\nextern int posix_memalign (void **__memptr, size_t __alignment, size_t __size)\n     __THROW __nonnull ((1)) __wur;\n#endif\n\n#ifdef __USE_ISOC11\n/* ISO C variant of aligned allocation.  */\nextern void *aligned_alloc (size_t __alignment, size_t __size)\n     __THROW __attribute_malloc__ __attribute_alloc_size__ ((2)) __wur;\n#endif\n\n/* Abort execution and generate a core-dump.  */\nextern void abort (void) __THROW __attribute__ ((__noreturn__));\n\n\n/* Register a function to be called when `exit' is called.  */\nextern int atexit (void (*__func) (void)) __THROW __nonnull ((1));\n\n#if defined __USE_ISOC11 || defined __USE_ISOCXX11\n/* Register a function to be called when `quick_exit' is called.  */\n# ifdef __cplusplus\nextern \"C++\" int at_quick_exit (void (*__func) (void))\n     __THROW __asm (\"at_quick_exit\") __nonnull ((1));\n# else\nextern int at_quick_exit (void (*__func) (void)) __THROW __nonnull ((1));\n# endif\n#endif\n\n#ifdef\t__USE_MISC\n/* Register a function to be called with the status\n   given to `exit' and the given argument.  */\nextern int on_exit (void (*__func) (int __status, void *__arg), void *__arg)\n     __THROW __nonnull ((1));\n#endif\n\n/* Call all functions registered with `atexit' and `on_exit',\n   in the reverse of the order in which they were registered,\n   perform stdio cleanup, and terminate program execution with STATUS.  */\nextern void exit (int __status) __THROW __attribute__ ((__noreturn__));\n\n#if defined __USE_ISOC11 || defined __USE_ISOCXX11\n/* Call all functions registered with `at_quick_exit' in the reverse\n   of the order in which they were registered and terminate program\n   execution with STATUS.  */\nextern void quick_exit (int __status) __THROW __attribute__ ((__noreturn__));\n#endif\n\n#ifdef __USE_ISOC99\n/* Terminate the program with STATUS without calling any of the\n   functions registered with `atexit' or `on_exit'.  */\nextern void _Exit (int __status) __THROW __attribute__ ((__noreturn__));\n#endif\n\n\n/* Return the value of envariable NAME, or NULL if it doesn't exist.  */\nextern char *getenv (const char *__name) __THROW __nonnull ((1)) __wur;\n\n#ifdef __USE_GNU\n/* This function is similar to the above but returns NULL if the\n   programs is running with SUID or SGID enabled.  */\nextern char *secure_getenv (const char *__name)\n     __THROW __nonnull ((1)) __wur;\n#endif\n\n#if defined __USE_MISC || defined __USE_XOPEN\n/* The SVID says this is in <stdio.h>, but this seems a better place.\t*/\n/* Put STRING, which is of the form \"NAME=VALUE\", in the environment.\n   If there is no `=', remove NAME from the environment.  */\nextern int putenv (char *__string) __THROW __nonnull ((1));\n#endif\n\n#ifdef __USE_XOPEN2K\n/* Set NAME to VALUE in the environment.\n   If REPLACE is nonzero, overwrite an existing value.  */\nextern int setenv (const char *__name, const char *__value, int __replace)\n     __THROW __nonnull ((2));\n\n/* Remove the variable NAME from the environment.  */\nextern int unsetenv (const char *__name) __THROW __nonnull ((1));\n#endif\n\n#ifdef\t__USE_MISC\n/* The `clearenv' was planned to be added to POSIX.1 but probably\n   never made it.  Nevertheless the POSIX.9 standard (POSIX bindings\n   for Fortran 77) requires this function.  */\nextern int clearenv (void) __THROW;\n#endif\n\n\n#if defined __USE_MISC \\\n    || (defined __USE_XOPEN_EXTENDED && !defined __USE_XOPEN2K8)\n/* Generate a unique temporary file name from TEMPLATE.\n   The last six characters of TEMPLATE must be \"XXXXXX\";\n   they are replaced with a string that makes the file name unique.\n   Always returns TEMPLATE, it's either a temporary file name or a null\n   string if it cannot get a unique file name.  */\nextern char *mktemp (char *__template) __THROW __nonnull ((1));\n#endif\n\n#if defined __USE_XOPEN_EXTENDED || defined __USE_XOPEN2K8\n/* Generate a unique temporary file name from TEMPLATE.\n   The last six characters of TEMPLATE must be \"XXXXXX\";\n   they are replaced with a string that makes the filename unique.\n   Returns a file descriptor open on the file for reading and writing,\n   or -1 if it cannot create a uniquely-named file.\n\n   This function is a possible cancellation point and therefore not\n   marked with __THROW.  */\n# ifndef __USE_FILE_OFFSET64\nextern int mkstemp (char *__template) __nonnull ((1)) __wur;\n# else\n#  ifdef __REDIRECT\nextern int __REDIRECT (mkstemp, (char *__template), mkstemp64)\n     __nonnull ((1)) __wur;\n#  else\n#   define mkstemp mkstemp64\n#  endif\n# endif\n# ifdef __USE_LARGEFILE64\nextern int mkstemp64 (char *__template) __nonnull ((1)) __wur;\n# endif\n#endif\n\n#ifdef __USE_MISC\n/* Similar to mkstemp, but the template can have a suffix after the\n   XXXXXX.  The length of the suffix is specified in the second\n   parameter.\n\n   This function is a possible cancellation point and therefore not\n   marked with __THROW.  */\n# ifndef __USE_FILE_OFFSET64\nextern int mkstemps (char *__template, int __suffixlen) __nonnull ((1)) __wur;\n# else\n#  ifdef __REDIRECT\nextern int __REDIRECT (mkstemps, (char *__template, int __suffixlen),\n\t\t       mkstemps64) __nonnull ((1)) __wur;\n#  else\n#   define mkstemps mkstemps64\n#  endif\n# endif\n# ifdef __USE_LARGEFILE64\nextern int mkstemps64 (char *__template, int __suffixlen)\n     __nonnull ((1)) __wur;\n# endif\n#endif\n\n#ifdef __USE_XOPEN2K8\n/* Create a unique temporary directory from TEMPLATE.\n   The last six characters of TEMPLATE must be \"XXXXXX\";\n   they are replaced with a string that makes the directory name unique.\n   Returns TEMPLATE, or a null pointer if it cannot get a unique name.\n   The directory is created mode 700.  */\nextern char *mkdtemp (char *__template) __THROW __nonnull ((1)) __wur;\n#endif\n\n#ifdef __USE_GNU\n/* Generate a unique temporary file name from TEMPLATE similar to\n   mkstemp.  But allow the caller to pass additional flags which are\n   used in the open call to create the file..\n\n   This function is a possible cancellation point and therefore not\n   marked with __THROW.  */\n# ifndef __USE_FILE_OFFSET64\nextern int mkostemp (char *__template, int __flags) __nonnull ((1)) __wur;\n# else\n#  ifdef __REDIRECT\nextern int __REDIRECT (mkostemp, (char *__template, int __flags), mkostemp64)\n     __nonnull ((1)) __wur;\n#  else\n#   define mkostemp mkostemp64\n#  endif\n# endif\n# ifdef __USE_LARGEFILE64\nextern int mkostemp64 (char *__template, int __flags) __nonnull ((1)) __wur;\n# endif\n\n/* Similar to mkostemp, but the template can have a suffix after the\n   XXXXXX.  The length of the suffix is specified in the second\n   parameter.\n\n   This function is a possible cancellation point and therefore not\n   marked with __THROW.  */\n# ifndef __USE_FILE_OFFSET64\nextern int mkostemps (char *__template, int __suffixlen, int __flags)\n     __nonnull ((1)) __wur;\n# else\n#  ifdef __REDIRECT\nextern int __REDIRECT (mkostemps, (char *__template, int __suffixlen,\n\t\t\t\t   int __flags), mkostemps64)\n     __nonnull ((1)) __wur;\n#  else\n#   define mkostemps mkostemps64\n#  endif\n# endif\n# ifdef __USE_LARGEFILE64\nextern int mkostemps64 (char *__template, int __suffixlen, int __flags)\n     __nonnull ((1)) __wur;\n# endif\n#endif\n\n\n/* Execute the given line as a shell command.\n\n   This function is a cancellation point and therefore not marked with\n   __THROW.  */\nextern int system (const char *__command) __wur;\n\n\n#ifdef\t__USE_GNU\n/* Return a malloc'd string containing the canonical absolute name of the\n   existing named file.  */\nextern char *canonicalize_file_name (const char *__name)\n     __THROW __nonnull ((1)) __wur;\n#endif\n\n#if defined __USE_MISC || defined __USE_XOPEN_EXTENDED\n/* Return the canonical absolute name of file NAME.  If RESOLVED is\n   null, the result is malloc'd; otherwise, if the canonical name is\n   PATH_MAX chars or more, returns null with `errno' set to\n   ENAMETOOLONG; if the name fits in fewer than PATH_MAX chars,\n   returns the name in RESOLVED.  */\nextern char *realpath (const char *__restrict __name,\n\t\t       char *__restrict __resolved) __THROW __wur;\n#endif\n\n\n/* Shorthand for type of comparison functions.  */\n#ifndef __COMPAR_FN_T\n# define __COMPAR_FN_T\ntypedef int (*__compar_fn_t) (const void *, const void *);\n\n# ifdef\t__USE_GNU\ntypedef __compar_fn_t comparison_fn_t;\n# endif\n#endif\n#ifdef __USE_GNU\ntypedef int (*__compar_d_fn_t) (const void *, const void *, void *);\n#endif\n\n/* Do a binary search for KEY in BASE, which consists of NMEMB elements\n   of SIZE bytes each, using COMPAR to perform the comparisons.  */\nextern void *bsearch (const void *__key, const void *__base,\n\t\t      size_t __nmemb, size_t __size, __compar_fn_t __compar)\n     __nonnull ((1, 2, 5)) __wur;\n\n#ifdef __USE_EXTERN_INLINES\n# include <bits/stdlib-bsearch.h>\n#endif\n\n/* Sort NMEMB elements of BASE, of SIZE bytes each,\n   using COMPAR to perform the comparisons.  */\nextern void qsort (void *__base, size_t __nmemb, size_t __size,\n\t\t   __compar_fn_t __compar) __nonnull ((1, 4));\n#ifdef __USE_GNU\nextern void qsort_r (void *__base, size_t __nmemb, size_t __size,\n\t\t     __compar_d_fn_t __compar, void *__arg)\n  __nonnull ((1, 4));\n#endif\n\n\n/* Return the absolute value of X.  */\nextern int abs (int __x) __THROW __attribute__ ((__const__)) __wur;\nextern long int labs (long int __x) __THROW __attribute__ ((__const__)) __wur;\n\n#ifdef __USE_ISOC99\n__extension__ extern long long int llabs (long long int __x)\n     __THROW __attribute__ ((__const__)) __wur;\n#endif\n\n\n/* Return the `div_t', `ldiv_t' or `lldiv_t' representation\n   of the value of NUMER over DENOM. */\n/* GCC may have built-ins for these someday.  */\nextern div_t div (int __numer, int __denom)\n     __THROW __attribute__ ((__const__)) __wur;\nextern ldiv_t ldiv (long int __numer, long int __denom)\n     __THROW __attribute__ ((__const__)) __wur;\n\n#ifdef __USE_ISOC99\n__extension__ extern lldiv_t lldiv (long long int __numer,\n\t\t\t\t    long long int __denom)\n     __THROW __attribute__ ((__const__)) __wur;\n#endif\n\n\n#if (defined __USE_XOPEN_EXTENDED && !defined __USE_XOPEN2K8) \\\n    || defined __USE_MISC\n/* Convert floating point numbers to strings.  The returned values are\n   valid only until another call to the same function.  */\n\n/* Convert VALUE to a string with NDIGIT digits and return a pointer to\n   this.  Set *DECPT with the position of the decimal character and *SIGN\n   with the sign of the number.  */\nextern char *ecvt (double __value, int __ndigit, int *__restrict __decpt,\n\t\t   int *__restrict __sign) __THROW __nonnull ((3, 4)) __wur;\n\n/* Convert VALUE to a string rounded to NDIGIT decimal digits.  Set *DECPT\n   with the position of the decimal character and *SIGN with the sign of\n   the number.  */\nextern char *fcvt (double __value, int __ndigit, int *__restrict __decpt,\n\t\t   int *__restrict __sign) __THROW __nonnull ((3, 4)) __wur;\n\n/* If possible convert VALUE to a string with NDIGIT significant digits.\n   Otherwise use exponential representation.  The resulting string will\n   be written to BUF.  */\nextern char *gcvt (double __value, int __ndigit, char *__buf)\n     __THROW __nonnull ((3)) __wur;\n#endif\n\n#ifdef __USE_MISC\n/* Long double versions of above functions.  */\nextern char *qecvt (long double __value, int __ndigit,\n\t\t    int *__restrict __decpt, int *__restrict __sign)\n     __THROW __nonnull ((3, 4)) __wur;\nextern char *qfcvt (long double __value, int __ndigit,\n\t\t    int *__restrict __decpt, int *__restrict __sign)\n     __THROW __nonnull ((3, 4)) __wur;\nextern char *qgcvt (long double __value, int __ndigit, char *__buf)\n     __THROW __nonnull ((3)) __wur;\n\n\n/* Reentrant version of the functions above which provide their own\n   buffers.  */\nextern int ecvt_r (double __value, int __ndigit, int *__restrict __decpt,\n\t\t   int *__restrict __sign, char *__restrict __buf,\n\t\t   size_t __len) __THROW __nonnull ((3, 4, 5));\nextern int fcvt_r (double __value, int __ndigit, int *__restrict __decpt,\n\t\t   int *__restrict __sign, char *__restrict __buf,\n\t\t   size_t __len) __THROW __nonnull ((3, 4, 5));\n\nextern int qecvt_r (long double __value, int __ndigit,\n\t\t    int *__restrict __decpt, int *__restrict __sign,\n\t\t    char *__restrict __buf, size_t __len)\n     __THROW __nonnull ((3, 4, 5));\nextern int qfcvt_r (long double __value, int __ndigit,\n\t\t    int *__restrict __decpt, int *__restrict __sign,\n\t\t    char *__restrict __buf, size_t __len)\n     __THROW __nonnull ((3, 4, 5));\n#endif\t/* misc */\n\n\n/* Return the length of the multibyte character\n   in S, which is no longer than N.  */\nextern int mblen (const char *__s, size_t __n) __THROW;\n/* Return the length of the given multibyte character,\n   putting its `wchar_t' representation in *PWC.  */\nextern int mbtowc (wchar_t *__restrict __pwc,\n\t\t   const char *__restrict __s, size_t __n) __THROW;\n/* Put the multibyte character represented\n   by WCHAR in S, returning its length.  */\nextern int wctomb (char *__s, wchar_t __wchar) __THROW;\n\n\n/* Convert a multibyte string to a wide char string.  */\nextern size_t mbstowcs (wchar_t *__restrict  __pwcs,\n\t\t\tconst char *__restrict __s, size_t __n) __THROW;\n/* Convert a wide char string to multibyte string.  */\nextern size_t wcstombs (char *__restrict __s,\n\t\t\tconst wchar_t *__restrict __pwcs, size_t __n)\n     __THROW;\n\n\n#ifdef __USE_MISC\n/* Determine whether the string value of RESPONSE matches the affirmation\n   or negative response expression as specified by the LC_MESSAGES category\n   in the program's current locale.  Returns 1 if affirmative, 0 if\n   negative, and -1 if not matching.  */\nextern int rpmatch (const char *__response) __THROW __nonnull ((1)) __wur;\n#endif\n\n\n#if defined __USE_XOPEN_EXTENDED || defined __USE_XOPEN2K8\n/* Parse comma separated suboption from *OPTIONP and match against\n   strings in TOKENS.  If found return index and set *VALUEP to\n   optional value introduced by an equal sign.  If the suboption is\n   not part of TOKENS return in *VALUEP beginning of unknown\n   suboption.  On exit *OPTIONP is set to the beginning of the next\n   token or at the terminating NUL character.  */\nextern int getsubopt (char **__restrict __optionp,\n\t\t      char *const *__restrict __tokens,\n\t\t      char **__restrict __valuep)\n     __THROW __nonnull ((1, 2, 3)) __wur;\n#endif\n\n\n#ifdef __USE_XOPEN\n/* Setup DES tables according KEY.  */\nextern void setkey (const char *__key) __THROW __nonnull ((1));\n#endif\n\n\n/* X/Open pseudo terminal handling.  */\n\n#ifdef __USE_XOPEN2KXSI\n/* Return a master pseudo-terminal handle.  */\nextern int posix_openpt (int __oflag) __wur;\n#endif\n\n#ifdef __USE_XOPEN_EXTENDED\n/* The next four functions all take a master pseudo-tty fd and\n   perform an operation on the associated slave:  */\n\n/* Chown the slave to the calling user.  */\nextern int grantpt (int __fd) __THROW;\n\n/* Release an internal lock so the slave can be opened.\n   Call after grantpt().  */\nextern int unlockpt (int __fd) __THROW;\n\n/* Return the pathname of the pseudo terminal slave associated with\n   the master FD is open on, or NULL on errors.\n   The returned storage is good until the next call to this function.  */\nextern char *ptsname (int __fd) __THROW __wur;\n#endif\n\n#ifdef __USE_GNU\n/* Store at most BUFLEN characters of the pathname of the slave pseudo\n   terminal associated with the master FD is open on in BUF.\n   Return 0 on success, otherwise an error number.  */\nextern int ptsname_r (int __fd, char *__buf, size_t __buflen)\n     __THROW __nonnull ((2));\n\n/* Open a master pseudo terminal and return its file descriptor.  */\nextern int getpt (void);\n#endif\n\n#ifdef __USE_MISC\n/* Put the 1 minute, 5 minute and 15 minute load averages into the first\n   NELEM elements of LOADAVG.  Return the number written (never more than\n   three, but may be less than NELEM), or -1 if an error occurred.  */\nextern int getloadavg (double __loadavg[], int __nelem)\n     __THROW __nonnull ((1));\n#endif\n\n#if defined __USE_XOPEN_EXTENDED && !defined __USE_XOPEN2K\n/* Return the index into the active-logins file (utmp) for\n   the controlling terminal.  */\nextern int ttyslot (void) __THROW;\n#endif\n\n#include <bits/stdlib-float.h>\n\n/* Define some macros helping to catch buffer overflows.  */\n#if __USE_FORTIFY_LEVEL > 0 && defined __fortify_function\n# include <bits/stdlib.h>\n#endif\n#ifdef __LDBL_COMPAT\n# include <bits/stdlib-ldbl.h>\n#endif\n\n__END_DECLS\n\n#endif /* stdlib.h  */\n"}, "30": {"id": 30, "path": "/usr/local/include/dovecot/config.h", "content": "/* config.h.  Generated from config.h.in by configure.  */\n/* config.h.in.  Generated from configure.ac by autoheader.  */\n\n/* Define if building universal (internal helper macro) */\n/* #undef AC_APPLE_UNIVERSAL_BUILD */\n\n/* Define if you have buggy CMSG macros */\n/* #undef BUGGY_CMSG_MACROS */\n\n/* Built-in Cassandra support */\n/* #undef BUILD_CASSANDRA */\n\n/* Build with CDB support */\n/* #undef BUILD_CDB */\n\n/* Build with Berkeley DB support */\n/* #undef BUILD_DB */\n\n/* Built-in MySQL support */\n/* #undef BUILD_MYSQL */\n\n/* Built-in PostgreSQL support */\n/* #undef BUILD_PGSQL */\n\n/* Built-in SQLite support */\n/* #undef BUILD_SQLITE */\n\n/* GSSAPI support is built in */\n/* #undef BUILTIN_GSSAPI */\n\n/* LDAP support is built in */\n/* #undef BUILTIN_LDAP */\n\n/* Lua support is builtin */\n/* #undef BUILTIN_LUA */\n\n/* IMAP capabilities advertised in banner */\n#define CAPABILITY_BANNER_STRING \"IMAP4rev1 SASL-IR LOGIN-REFERRALS ID ENABLE IDLE\"\n\n/* IMAP capabilities */\n#define CAPABILITY_STRING \"IMAP4rev1 SASL-IR LOGIN-REFERRALS ID ENABLE IDLE SORT SORT=DISPLAY THREAD=REFERENCES THREAD=REFS THREAD=ORDEREDSUBJECT MULTIAPPEND URL-PARTIAL CATENATE UNSELECT CHILDREN NAMESPACE UIDPLUS LIST-EXTENDED I18NLEVEL=1 CONDSTORE QRESYNC ESEARCH ESORT SEARCHRES WITHIN CONTEXT=SEARCH LIST-STATUS BINARY MOVE SNIPPET=FUZZY PREVIEW=FUZZY STATUS=SIZE SAVEDATE\"\n\n/* Define if _XPG6 macro is needed for crypt() */\n#define CRYPT_USE_XPG6 /**/\n\n/* Build with extra debugging checks */\n/* #undef DEBUG */\n\n/* Define if your dev_t is a structure instead of integer type */\n/* #undef DEV_T_STRUCT */\n\n/* Path to random source */\n#define DEV_URANDOM_PATH \"/dev/urandom\"\n\n/* Disable asserts */\n/* #undef DISABLE_ASSERTS */\n\n/* Dovecot ABI version */\n#define DOVECOT_ABI_VERSION \"2.4.ABIv0(2.4.devel)\"\n\n/* Dovecot name */\n#define DOVECOT_NAME \"Dovecot\"\n\n/* Dovecot string */\n#define DOVECOT_STRING \"Dovecot 2.4.devel\"\n\n/* Dovecot version */\n#define DOVECOT_VERSION \"2.4.devel\"\n\n/* Dovecot major version */\n#define DOVECOT_VERSION_MAJOR 2\n\n/* Dovecot minor version */\n#define DOVECOT_VERSION_MINOR 4\n\n/* How to define flexible array members in structs */\n#define FLEXIBLE_ARRAY_MEMBER \n\n/* Define this if you have arc4random_buf() */\n/* #undef HAVE_ARC4RANDOM */\n\n/* Build with ASN1_STRING_get0_data() support */\n#define HAVE_ASN1_STRING_GET0_DATA /**/\n\n/* Define to 1 if you have the `backtrace_symbols' function. */\n#define HAVE_BACKTRACE_SYMBOLS 1\n\n/* Build with BN_secure_new support */\n#define HAVE_BN_SECURE_NEW /**/\n\n/* Define if you have bzlib library */\n#define HAVE_BZLIB /**/\n\n/* Build with Cassandra support */\n/* #undef HAVE_CASSANDRA */\n\n/* Cassandra supports speculative execution policy */\n/* #undef HAVE_CASSANDRA_SPECULATIVE_POLICY */\n\n/* Define to 1 if you have the `clearenv' function. */\n#define HAVE_CLEARENV 1\n\n/* Define if you have the clock_gettime function */\n#define HAVE_CLOCK_GETTIME /**/\n\n/* Define to 1 if you have the <crypt.h> header file. */\n#define HAVE_CRYPT_H 1\n\n/* Define to 1 if you have the declaration of `getrandom', and to 0 if you\n   don't. */\n#define HAVE_DECL_GETRANDOM 1\n\n/* Define to 1 if you have the declaration of\n   `ZSTD_error_parameter_unsupported', and to 0 if you don't. */\n/* #undef HAVE_DECL_ZSTD_ERROR_PARAMETER_UNSUPPORTED */\n\n/* Define if you have struct dirent->d_type */\n#define HAVE_DIRENT_D_TYPE /**/\n\n/* Define to 1 if you have the <dirent.h> header file. */\n#define HAVE_DIRENT_H 1\n\n/* Define to 1 if you have the `dirfd' function. */\n#define HAVE_DIRFD 1\n\n/* Define to 1 if you have the <dlfcn.h> header file. */\n#define HAVE_DLFCN_H 1\n\n/* Build with ECDSA_SIG_get0 support */\n#define HAVE_ECDSA_SIG_GET0 /**/\n\n/* Build with ECDSA_SIG_set0 support */\n#define HAVE_ECDSA_SIG_SET0 /**/\n\n/* Build with EC_GROUP_order_bits support */\n#define HAVE_EC_GROUP_order_bits /**/\n\n/* Build with EVP_MD_CTX_new() support */\n#define HAVE_EVP_MD_CTX_NEW /**/\n\n/* Build with EVP_PKEY_get0_*() support */\n#define HAVE_EVP_PKEY_get0 /**/\n\n/* Define to 1 if you have the <execinfo.h> header file. */\n#define HAVE_EXECINFO_H 1\n\n/* Define to 1 if you have the `fallocate' function. */\n#define HAVE_FALLOCATE 1\n\n/* Define to 1 if you have the `fcntl' function. */\n#define HAVE_FCNTL 1\n\n/* Define if you have fdatasync() */\n#define HAVE_FDATASYNC /**/\n\n/* Define to 1 if you have the `flock' function. */\n#define HAVE_FLOCK 1\n\n/* Define if you have FreeBSD-compatible sendfile() */\n/* #undef HAVE_FREEBSD_SENDFILE */\n\n/* Define if you want exttextcat support for FTS */\n/* #undef HAVE_FTS_EXTTEXTCAT */\n\n/* Define if you want stemming support for FTS */\n/* #undef HAVE_FTS_STEMMER */\n\n/* Define if you want textcat support for FTS */\n/* #undef HAVE_FTS_TEXTCAT */\n\n/* Define to 1 if you have the `getmntent' function. */\n#define HAVE_GETMNTENT 1\n\n/* Define to 1 if you have the `getmntinfo' function. */\n/* #undef HAVE_GETMNTINFO */\n\n/* Define to 1 if you have the `getpagesize' function. */\n#define HAVE_GETPAGESIZE 1\n\n/* Define to 1 if you have the `getpeereid' function. */\n/* #undef HAVE_GETPEEREID */\n\n/* Define to 1 if you have the `getpeerucred' function. */\n/* #undef HAVE_GETPEERUCRED */\n\n/* Define to 1 if you have the `getrandom' function. */\n#define HAVE_GETRANDOM 1\n\n/* Define to 1 if you have the `glob' function. */\n#define HAVE_GLOB 1\n\n/* Define to 1 if you have the <glob.h> header file. */\n#define HAVE_GLOB_H 1\n\n/* Build with GNUTLS support */\n/* #undef HAVE_GNUTLS */\n\n/* Build with GSSAPI support */\n/* #undef HAVE_GSSAPI */\n\n/* Define to 1 if you have the <gssapi/gssapi_ext.h> header file. */\n/* #undef HAVE_GSSAPI_GSSAPI_EXT_H */\n\n/* GSSAPI headers in gssapi/gssapi.h */\n/* #undef HAVE_GSSAPI_GSSAPI_H */\n\n/* Define to 1 if you have the <gssapi/gssapi_krb5.h> header file. */\n/* #undef HAVE_GSSAPI_GSSAPI_KRB5_H */\n\n/* GSSAPI headers in gssapi.h */\n/* #undef HAVE_GSSAPI_H */\n\n/* Define to 1 if you have the <gssapi_krb5.h> header file. */\n/* #undef HAVE_GSSAPI_KRB5_H */\n\n/* GSSAPI supports SPNEGO */\n/* #undef HAVE_GSSAPI_SPNEGO */\n\n/* Define to 1 if you have the `gsskrb5_register_acceptor_identity' function.\n   */\n/* #undef HAVE_GSSKRB5_REGISTER_ACCEPTOR_IDENTITY */\n\n/* Build with HMAC_CTX_new() support */\n#define HAVE_HMAC_CTX_NEW /**/\n\n/* Define if you have the iconv() function and it works. */\n#define HAVE_ICONV 1\n\n/* Define to 1 if you have the `inet_aton' function. */\n#define HAVE_INET_ATON 1\n\n/* Define to 1 if you have the `inotify_init' function. */\n#define HAVE_INOTIFY_INIT 1\n\n/* Define to 1 if you have the <inttypes.h> header file. */\n#define HAVE_INTTYPES_H 1\n\n/* Build with IPv6 support */\n#define HAVE_IPV6 /**/\n\n/* Define to 1 if you have the <jfs/quota.h> header file. */\n/* #undef HAVE_JFS_QUOTA_H */\n\n/* Define to 1 if you have the `kevent' function. */\n/* #undef HAVE_KEVENT */\n\n/* Define to 1 if you have the `kqueue' function. */\n/* #undef HAVE_KQUEUE */\n\n/* Define to 1 if you have the `krb5_free_context' function. */\n/* #undef HAVE_KRB5_FREE_CONTEXT */\n\n/* Define to 1 if you have the `krb5_gss_register_acceptor_identity' function.\n   */\n/* #undef HAVE_KRB5_GSS_REGISTER_ACCEPTOR_IDENTITY */\n\n/* Define this if you have libbsd */\n/* #undef HAVE_LIBBSD */\n\n/* libcap is installed for cap_init() */\n/* #undef HAVE_LIBCAP */\n\n/* Define to 1 if you have the <libexttextcat/textcat.h> header file. */\n/* #undef HAVE_LIBEXTTEXTCAT_TEXTCAT_H */\n\n/* Define to 1 if you have the <libgen.h> header file. */\n#define HAVE_LIBGEN_H 1\n\n/* Define if you want ICU normalization support for FTS */\n#define HAVE_LIBICU /**/\n\n/* Define if you have libsodium */\n#define HAVE_LIBSODIUM 1\n\n/* Define to 1 if you have the <libtextcat/textcat.h> header file. */\n/* #undef HAVE_LIBTEXTCAT_TEXTCAT_H */\n\n/* Define this if you have libunwind */\n/* #undef HAVE_LIBUNWIND */\n\n/* Define if you have libwrap */\n/* #undef HAVE_LIBWRAP */\n\n/* Define to 1 if you have the <linux/dqblk_xfs.h> header file. */\n#define HAVE_LINUX_DQBLK_XFS_H 1\n\n/* Define to 1 if you have the <linux/falloc.h> header file. */\n#define HAVE_LINUX_FALLOC_H 1\n\n/* Define if you have Linux-compatible mremap() */\n#define HAVE_LINUX_MREMAP /**/\n\n/* Define if you have Linux-compatible sendfile() */\n#define HAVE_LINUX_SENDFILE /**/\n\n/* Define to 1 if you have the `lockf' function. */\n#define HAVE_LOCKF 1\n\n/* Define to 1 if you have lua */\n/* #undef HAVE_LUA */\n\n/* Define if you have lz4 library */\n/* #undef HAVE_LZ4 */\n\n/* Define if you have LZ4_compress_default */\n/* #undef HAVE_LZ4_COMPRESS_DEFAULT */\n\n/* Define if you have lzma library */\n#define HAVE_LZMA /**/\n\n/* Define to 1 if you have the `madvise' function. */\n#define HAVE_MADVISE 1\n\n/* Define to 1 if you have the <malloc.h> header file. */\n#define HAVE_MALLOC_H 1\n\n/* Define to 1 if you have the <malloc_np.h> header file. */\n/* #undef HAVE_MALLOC_NP_H */\n\n/* Define to 1 if you have the `malloc_usable_size' function. */\n#define HAVE_MALLOC_USABLE_SIZE 1\n\n/* Define to 1 if you have the <memory.h> header file. */\n#define HAVE_MEMORY_H 1\n\n/* Define to 1 if you have the <mntent.h> header file. */\n#define HAVE_MNTENT_H 1\n\n/* Define if you have dynamic module support */\n#define HAVE_MODULES /**/\n\n/* Build with MySQL support */\n/* #undef HAVE_MYSQL */\n\n/* Define if your MySQL library has SSL functions */\n/* #undef HAVE_MYSQL_SSL */\n\n/* Define if your MySQL library supports setting cipher */\n/* #undef HAVE_MYSQL_SSL_CIPHER */\n\n/* Defineif your MySQL library supports verifying the name in the SSL\n   certificate */\n/* #undef HAVE_MYSQL_SSL_VERIFY_SERVER_CERT */\n\n/* Build with OBJ_length() support */\n#define HAVE_OBJ_LENGTH /**/\n\n/* Define if you don't have C99 compatible vsnprintf() call */\n/* #undef HAVE_OLD_VSNPRINTF */\n\n/* Build with OpenSSL support */\n#define HAVE_OPENSSL /**/\n\n/* Define if OpenSSL performs thread cleanup automatically */\n#define HAVE_OPENSSL_AUTO_THREAD_DEINIT /**/\n\n/* OpenSSL supports OPENSSL_cleanup() */\n#define HAVE_OPENSSL_CLEANUP /**/\n\n/* Define to 1 if you have the <openssl/err.h> header file. */\n/* #undef HAVE_OPENSSL_ERR_H */\n\n/* Define if you have ERR_remove_thread_state */\n#define HAVE_OPENSSL_ERR_REMOVE_THREAD_STATE /**/\n\n/* Define if you have openssl/rand.h */\n/* #undef HAVE_OPENSSL_RAND_H */\n\n/* Define to 1 if you have the <openssl/ssl.h> header file. */\n/* #undef HAVE_OPENSSL_SSL_H */\n\n/* Define if you have pam/pam_appl.h */\n/* #undef HAVE_PAM_PAM_APPL_H */\n\n/* Define if you have pam_setcred() */\n/* #undef HAVE_PAM_SETCRED */\n\n/* Build with PostgreSQL support */\n/* #undef HAVE_PGSQL */\n\n/* Define to 1 if you have the `posix_fadvise' function. */\n#define HAVE_POSIX_FADVISE 1\n\n/* Define if you have a working posix_fallocate() */\n#define HAVE_POSIX_FALLOCATE /**/\n\n/* Define if libpq has PQescapeStringConn function */\n/* #undef HAVE_PQESCAPE_STRING_CONN */\n\n/* Define to 1 if you have the `pread' function. */\n#define HAVE_PREAD 1\n\n/* Define if you have prctl(PR_SET_DUMPABLE) */\n#define HAVE_PR_SET_DUMPABLE /**/\n\n/* Define to 1 if you have the `quotactl' function. */\n#define HAVE_QUOTACTL 1\n\n/* Define to 1 if you have the <quota.h> header file. */\n/* #undef HAVE_QUOTA_H */\n\n/* Define if you have quota_open() */\n/* #undef HAVE_QUOTA_OPEN */\n\n/* Define if Q_QUOTACTL exists */\n/* #undef HAVE_Q_QUOTACTL */\n\n/* Define if you have RLIMIT_AS for setrlimit() */\n#define HAVE_RLIMIT_AS /**/\n\n/* Define if you have RLIMIT_CORE for getrlimit() */\n#define HAVE_RLIMIT_CORE /**/\n\n/* Define if you have RLIMIT_NPROC for setrlimit() */\n#define HAVE_RLIMIT_NPROC /**/\n\n/* Define if you wish to retrieve quota of NFS mounted mailboxes */\n#define HAVE_RQUOTA /**/\n\n/* Build with RSA_generate_key_ex() support */\n#define HAVE_RSA_GENERATE_KEY_EX /**/\n\n/* Build with RSA_set0_crt_params support */\n#define HAVE_RSA_SET0_CRT_PARAMS /**/\n\n/* Build with RSA_set0_factors support */\n#define HAVE_RSA_SET0_FACTORS /**/\n\n/* Build with RSA_set0_key support */\n#define HAVE_RSA_SET0_KEY /**/\n\n/* Define to 1 if you have the <sasl.h> header file. */\n/* #undef HAVE_SASL_H */\n\n/* Define to 1 if you have the <sasl/sasl.h> header file. */\n/* #undef HAVE_SASL_SASL_H */\n\n/* Define if you have security/pam_appl.h */\n/* #undef HAVE_SECURITY_PAM_APPL_H */\n\n/* Define to 1 if you have the `setegid' function. */\n#define HAVE_SETEGID 1\n\n/* Define to 1 if you have the `seteuid' function. */\n#define HAVE_SETEUID 1\n\n/* Define to 1 if you have the `setpriority' function. */\n#define HAVE_SETPRIORITY 1\n\n/* Define to 1 if you have the `setproctitle' function. */\n/* #undef HAVE_SETPROCTITLE */\n\n/* Define to 1 if you have the `setresgid' function. */\n#define HAVE_SETRESGID 1\n\n/* Define to 1 if you have the `setreuid' function. */\n#define HAVE_SETREUID 1\n\n/* Define to 1 if you have the `setrlimit' function. */\n#define HAVE_SETRLIMIT 1\n\n/* Define to 1 if you have the `sigaction' function. */\n#define HAVE_SIGACTION 1\n\n/* Define to 'int' if you don't have socklen_t */\n#define HAVE_SOCKLEN_T /**/\n\n/* Define if you have Solaris-compatible sendfile() */\n/* #undef HAVE_SOLARIS_SENDFILE */\n\n/* Build with SQLite3 support */\n/* #undef HAVE_SQLITE */\n\n/* Build with SSL/TLS support */\n#define HAVE_SSL /**/\n\n/* Define if you have SSL_CIPHER_get_kx_nid */\n#define HAVE_SSL_CIPHER_get_kx_nid /**/\n\n/* Define if you have SSL_clear_options */\n#define HAVE_SSL_CLEAR_OPTIONS /**/\n\n/* Build with OpenSSL compression */\n#define HAVE_SSL_COMPRESSION /**/\n\n/* Build with SSL_COMP_free_compression_methods() support */\n/* #undef HAVE_SSL_COMP_FREE_COMPRESSION_METHODS */\n\n/* Define if you have SSL_CTX_add0_chain_cert */\n#define HAVE_SSL_CTX_ADD0_CHAIN_CERT /**/\n\n/* Define if you have SSL_CTX_set1_curves_list */\n#define HAVE_SSL_CTX_SET1_CURVES_LIST /**/\n\n/* Build with SSL_CTX_set_ciphersuites() support */\n#define HAVE_SSL_CTX_SET_CIPHERSUITES /**/\n\n/* Define if you have SSL_CTX_set_current_cert */\n#define HAVE_SSL_CTX_SET_CURRENT_CERT /**/\n\n/* Define if you have SSL_CTX_set_min_proto_version */\n#define HAVE_SSL_CTX_SET_MIN_PROTO_VERSION /**/\n\n/* Build with TLS hostname support */\n#define HAVE_SSL_GET_SERVERNAME /**/\n\n/* Define if CRYPTO_set_mem_functions has new style parameters */\n#define HAVE_SSL_NEW_MEM_FUNCS /**/\n\n/* Define if you have statfs.f_mntfromname */\n/* #undef HAVE_STATFS_MNTFROMNAME */\n\n/* Define if you have statvfs.f_mntfromname */\n/* #undef HAVE_STATVFS_MNTFROMNAME */\n\n/* Define if you have st_?tim timespec fields in struct stat */\n#define HAVE_STAT_XTIM /**/\n\n/* Define if you have st_?timespec fields in struct stat */\n/* #undef HAVE_STAT_XTIMESPEC */\n\n/* Define to 1 if you have the <stdint.h> header file. */\n#define HAVE_STDINT_H 1\n\n/* Define to 1 if you have the <stdlib.h> header file. */\n#define HAVE_STDLIB_H 1\n\n/* Define to 1 if you have the `strcasecmp' function. */\n#define HAVE_STRCASECMP 1\n\n/* Define to 1 if you have the `stricmp' function. */\n/* #undef HAVE_STRICMP */\n\n/* Define to 1 if you have the <strings.h> header file. */\n#define HAVE_STRINGS_H 1\n\n/* Define to 1 if you have the <string.h> header file. */\n#define HAVE_STRING_H 1\n\n/* Define if struct sqblk.dqb_curblocks exists */\n/* #undef HAVE_STRUCT_DQBLK_CURBLOCKS */\n\n/* Define if struct sqblk.dqb_curspace exists */\n#define HAVE_STRUCT_DQBLK_CURSPACE /**/\n\n/* Define if you have struct iovec */\n#define HAVE_STRUCT_IOVEC /**/\n\n/* Define to 1 if the system has the type `struct sockpeercred'. */\n/* #undef HAVE_STRUCT_SOCKPEERCRED */\n\n/* Define if you want to use systemd socket activation */\n/* #undef HAVE_SYSTEMD */\n\n/* Define to 1 if you have the <sys/event.h> header file. */\n/* #undef HAVE_SYS_EVENT_H */\n\n/* Define to 1 if you have the <sys/fs/quota_common.h> header file. */\n/* #undef HAVE_SYS_FS_QUOTA_COMMON_H */\n\n/* Define to 1 if you have the <sys/fs/ufs_quota.h> header file. */\n/* #undef HAVE_SYS_FS_UFS_QUOTA_H */\n\n/* Define to 1 if you have the <sys/mkdev.h> header file. */\n/* #undef HAVE_SYS_MKDEV_H */\n\n/* Define to 1 if you have the <sys/mnttab.h> header file. */\n/* #undef HAVE_SYS_MNTTAB_H */\n\n/* Define to 1 if you have the <sys/quota.h> header file. */\n#define HAVE_SYS_QUOTA_H 1\n\n/* Define to 1 if you have the <sys/resource.h> header file. */\n#define HAVE_SYS_RESOURCE_H 1\n\n/* Define to 1 if you have the <sys/select.h> header file. */\n#define HAVE_SYS_SELECT_H 1\n\n/* Define to 1 if you have the <sys/stat.h> header file. */\n#define HAVE_SYS_STAT_H 1\n\n/* Define to 1 if you have the <sys/sysmacros.h> header file. */\n#define HAVE_SYS_SYSMACROS_H 1\n\n/* Define to 1 if you have the <sys/time.h> header file. */\n#define HAVE_SYS_TIME_H 1\n\n/* Define to 1 if you have the <sys/types.h> header file. */\n#define HAVE_SYS_TYPES_H 1\n\n/* Define to 1 if you have the <sys/ucred.h> header file. */\n/* #undef HAVE_SYS_UCRED_H */\n\n/* Define to 1 if you have the <sys/uio.h> header file. */\n#define HAVE_SYS_UIO_H 1\n\n/* Define to 1 if you have the <sys/utsname.h> header file. */\n#define HAVE_SYS_UTSNAME_H 1\n\n/* Define to 1 if you have the <sys/vmount.h> header file. */\n/* #undef HAVE_SYS_VMOUNT_H */\n\n/* Define to 1 if you have the `timegm' function. */\n#define HAVE_TIMEGM 1\n\n/* Define if you have struct tm->tm_gmtoff */\n#define HAVE_TM_GMTOFF /**/\n\n/* Define if you have typeof() */\n#define HAVE_TYPEOF /**/\n\n/* Define to 1 if you have the <ucontext.h> header file. */\n#define HAVE_UCONTEXT_H 1\n\n/* Define to 1 if you have the <ucred.h> header file. */\n/* #undef HAVE_UCRED_H */\n\n/* Define to 1 if you have the <ufs/ufs/quota.h> header file. */\n/* #undef HAVE_UFS_UFS_QUOTA_H */\n\n/* Define if you have uintmax_t (C99 type) */\n#define HAVE_UINTMAX_T /**/\n\n/* Define if you have uint_fast32_t (C99 type) */\n#define HAVE_UINT_FAST32_T /**/\n\n/* Define to 1 if you have the `uname' function. */\n#define HAVE_UNAME 1\n\n/* Define to 1 if you have the <unistd.h> header file. */\n#define HAVE_UNISTD_H 1\n\n/* Define to 1 if you have the `unsetenv' function. */\n#define HAVE_UNSETENV 1\n\n/* Define if you have a native uoff_t type */\n/* #undef HAVE_UOFF_T */\n\n/* Define to 1 if you have the `vsyslog' function. */\n#define HAVE_VSYSLOG 1\n\n/* Define to 1 if you have the `walkcontext' function. */\n/* #undef HAVE_WALKCONTEXT */\n\n/* Define to 1 if you have the `writev' function. */\n#define HAVE_WRITEV 1\n\n/* Define to 1 if you have the <xfs/xqm.h> header file. */\n/* #undef HAVE_XFS_XQM_H */\n\n/* Define if you have zlib library */\n#define HAVE_ZLIB /**/\n\n/* Define if you have ZSTD library */\n/* #undef HAVE_ZSTD */\n\n/* Whether zstd has ZSTD_getErrorCode */\n/* #undef HAVE_ZSTD_GETERRORCODE */\n\n/* Define to 1 if the system has the type `_Bool'. */\n#define HAVE__BOOL 1\n\n/* Define if you have __gss_userok() */\n/* #undef HAVE___GSS_USEROK */\n\n/* Define as const if the declaration of iconv() needs const. */\n#define ICONV_CONST \n\n/* Implement I/O loop with Linux 2.6 epoll() */\n#define IOLOOP_EPOLL /**/\n\n/* Implement I/O loop with BSD kqueue() */\n/* #undef IOLOOP_KQUEUE */\n\n/* Use Linux inotify */\n#define IOLOOP_NOTIFY_INOTIFY /**/\n\n/* Use BSD kqueue directory changes notification */\n/* #undef IOLOOP_NOTIFY_KQUEUE */\n\n/* No special notify support */\n/* #undef IOLOOP_NOTIFY_NONE */\n\n/* Implement I/O loop with poll() */\n/* #undef IOLOOP_POLL */\n\n/* Implement I/O loop with select() */\n/* #undef IOLOOP_SELECT */\n\n/* Define if you have ldap_initialize */\n/* #undef LDAP_HAVE_INITIALIZE */\n\n/* Define if you have ldap_start_tls_s */\n/* #undef LDAP_HAVE_START_TLS_S */\n\n/* Define to the sub-directory where libtool stores uninstalled libraries. */\n#define LT_OBJDIR \".libs/\"\n\n/* Required memory alignment */\n#define MEM_ALIGN_SIZE 8\n\n/* Define if shared mmaps don't get updated by write()s */\n/* #undef MMAP_CONFLICTS_WRITE */\n\n/* Dynamic module suffix */\n#define MODULE_SUFFIX \".so\"\n\n/* Maximum value of off_t */\n#define OFF_T_MAX LONG_MAX\n\n/* Name of package */\n#define PACKAGE \"dovecot\"\n\n/* Define to the address where bug reports for this package should be sent. */\n#define PACKAGE_BUGREPORT \"dovecot@dovecot.org\"\n\n/* Define to the full name of this package. */\n#define PACKAGE_NAME \"Dovecot\"\n\n/* Define to the full name and version of this package. */\n#define PACKAGE_STRING \"Dovecot 2.4.devel\"\n\n/* Define to the one symbol short name of this package. */\n#define PACKAGE_TARNAME \"dovecot\"\n\n/* Define to the home page for this package. */\n#define PACKAGE_URL \"\"\n\n/* Define to the version of this package. */\n#define PACKAGE_VERSION \"2.4.devel\"\n\n/* Support URL */\n#define PACKAGE_WEBPAGE \"http://www.dovecot.org/\"\n\n/* Build with BSD authentication support */\n/* #undef PASSDB_BSDAUTH */\n\n/* Build with checkpassword passdb support */\n#define PASSDB_CHECKPASSWORD /**/\n\n/* Build with LDAP support */\n/* #undef PASSDB_LDAP */\n\n/* Build with PAM support */\n/* #undef PASSDB_PAM */\n\n/* Build with passwd support */\n#define PASSDB_PASSWD /**/\n\n/* Build with passwd-file support */\n#define PASSDB_PASSWD_FILE /**/\n\n/* Build with shadow support */\n#define PASSDB_SHADOW /**/\n\n/* Build with Tru64 SIA support */\n/* #undef PASSDB_SIA */\n\n/* Build with SQL support */\n/* #undef PASSDB_SQL */\n\n/* Build with vpopmail support */\n/* #undef PASSDB_VPOPMAIL */\n\n/* Define if pread/pwrite implementation is broken */\n/* #undef PREAD_BROKEN */\n\n/* Define if pread/pwrite needs _XOPEN_SOURCE 500 */\n#define PREAD_WRAPPERS /**/\n\n/* printf() fmt for dec time_t */\n#define PRIdTIME_T \"ld\"\n\n/* printf() format for uoff_t */\n#define PRIuUOFF_T \"lu\"\n\n/* printf() fmt for hex time_t */\n#define PRIxTIME_T \"lx\"\n\n/* Define if process title can be changed by modifying argv */\n#define PROCTITLE_HACK /**/\n\n/* The size of `int', as computed by sizeof. */\n#define SIZEOF_INT 4\n\n/* The size of `long', as computed by sizeof. */\n#define SIZEOF_LONG 8\n\n/* The size of `long long', as computed by sizeof. */\n#define SIZEOF_LONG_LONG 8\n\n/* The size of `void *', as computed by sizeof. */\n#define SIZEOF_VOID_P 8\n\n/* Build SQL drivers as plugins */\n/* #undef SQL_DRIVER_PLUGINS */\n\n/* Maximum value of ssize_t */\n#define SSIZE_T_MAX LONG_MAX\n\n/* C99 static array */\n#define STATIC_ARRAY static\n\n/* Building with static code analyzer */\n/* #undef STATIC_CHECKER */\n\n/* reasonable mntctl buffer size */\n/* #undef STATIC_MTAB_SIZE */\n\n/* Define to 1 if you have the ANSI C header files. */\n#define STDC_HEADERS 1\n\n/* Points to textcat pkgdatadir containing the language files */\n/* #undef TEXTCAT_DATADIR */\n\n/* max. time_t bits gmtime() can handle */\n#define TIME_T_MAX_BITS 40\n\n/* Define if your time_t is signed */\n#define TIME_T_SIGNED /**/\n\n/* Define if unsetenv() returns int */\n#define UNSETENV_RET_INT /**/\n\n/* Define if off_t is int */\n/* #undef UOFF_T_INT */\n\n/* Define if off_t is long */\n#define UOFF_T_LONG /**/\n\n/* Define if off_t is long long */\n/* #undef UOFF_T_LONG_LONG */\n\n/* Maximum value of uoff_t */\n#define UOFF_T_MAX ULONG_MAX\n\n/* Build with checkpassword userdb support */\n#define USERDB_CHECKPASSWORD /**/\n\n/* Build with LDAP support */\n/* #undef USERDB_LDAP */\n\n/* Build with passwd support */\n#define USERDB_PASSWD /**/\n\n/* Build with passwd-file support */\n#define USERDB_PASSWD_FILE /**/\n\n/* Build with prefetch userdb support */\n#define USERDB_PREFETCH /**/\n\n/* Build with SQL support */\n/* #undef USERDB_SQL */\n\n/* Build with vpopmail support */\n/* #undef USERDB_VPOPMAIL */\n\n/* A 'va_copy' style function */\n#define VA_COPY va_copy\n\n/* 'va_lists' cannot be copied as values */\n#define VA_COPY_AS_ARRAY 1\n\n/* Version number of package */\n#define VERSION \"2.4.devel\"\n\n/* Define WORDS_BIGENDIAN to 1 if your processor stores words with the most\n   significant byte first (like Motorola and SPARC, unlike Intel). */\n#if defined AC_APPLE_UNIVERSAL_BUILD\n# if defined __BIG_ENDIAN__\n#  define WORDS_BIGENDIAN 1\n# endif\n#else\n# ifndef WORDS_BIGENDIAN\n/* #  undef WORDS_BIGENDIAN */\n# endif\n#endif\n\n/* Enable large inode numbers on Mac OS X 10.5.  */\n#ifndef _DARWIN_USE_64_BIT_INODE\n# define _DARWIN_USE_64_BIT_INODE 1\n#endif\n\n/* Number of bits in a file offset, on hosts where this is settable. */\n/* #undef _FILE_OFFSET_BITS */\n\n/* Define for large files, on AIX-style hosts. */\n/* #undef _LARGE_FILES */\n\n/* Define to `__inline__' or `__inline' if that's what the C compiler\n   calls it, or to nothing if 'inline' is not supported under any name.  */\n#ifndef __cplusplus\n/* #undef inline */\n#endif\n\n/* Define to 'unsigned int' if you don't have it */\n/* #undef size_t */\n\n/* Define to 'int' if you don't have it */\n/* #undef ssize_t */\n"}, "31": {"id": 31, "path": "/usr/local/include/dovecot/data-stack.h", "content": "#ifndef DATA_STACK_H\n#define DATA_STACK_H\n\n/* Data stack makes it very easy to implement functions returning dynamic data\n   without having to worry much about memory management like freeing the\n   result or having large enough buffers for the result.\n\n   t_ prefix was chosen to describe functions allocating memory from data\n   stack. \"t\" meaning temporary.\n\n   Advantages over control stack and alloca():\n    - Functions can return a value allocated from data stack\n    - We can portably specify how much data we want to allocate at runtime\n\n   Advantages over malloc():\n    - FAST, most of the time allocating memory means only updating a couple of\n      pointers and integers. Freeing the memory all at once also is a fast\n      operation.\n    - No need to free() each allocation resulting in prettier code\n    - No memory leaks\n    - No memory fragmentation\n\n   Disadvantages:\n    - Allocating memory inside loops can accidentally allocate a lot of memory\n      if the loops are long and you forgot to place t_push() and t_pop() there.\n    - t_malloc()ed data could be accidentally stored into permanent location\n      and accessed after it's already been freed. const'ing the return values\n      helps for most uses though (see the t_malloc() description).\n    - Debugging invalid memory usage may be difficult using existing tools,\n      although compiling with DEBUG enabled helps finding simple buffer\n      overflows.\n*/\n\n#ifndef STATIC_CHECKER\ntypedef unsigned int data_stack_frame_t;\n#else\ntypedef struct data_stack_frame *data_stack_frame_t;\n#endif\n\nextern unsigned int data_stack_frame_id;\n\n/* All t_..() allocations between t_push*() and t_pop() are freed after t_pop()\n   is called. Returns the current stack frame number, which can be used\n   to detect missing t_pop() calls:\n\n   x = t_push(marker); .. if (!t_pop(x)) abort();\n\n   In DEBUG mode, t_push_named() makes a temporary allocation for the name,\n   but is safe to call in a loop as it performs the allocation within its own\n   frame. However, you should always prefer to use T_BEGIN { ... } T_END below.\n*/\ndata_stack_frame_t t_push(const char *marker) ATTR_HOT;\ndata_stack_frame_t t_push_named(const char *format, ...) ATTR_HOT ATTR_FORMAT(1, 2);\n/* Returns TRUE on success, FALSE if t_pop() call was leaked. The caller\n   should panic. */\nbool t_pop(data_stack_frame_t *id) ATTR_HOT;\n/* Pop the last data stack frame. This shouldn't be called outside test code. */\nvoid t_pop_last_unsafe(void);\n\n/* Usage: T_BEGIN { code } T_END */\n#define T_STRING(x)\t#x\n#define T_XSTRING(x)\tT_STRING(x)\t/* expand and then stringify */\n#define T_BEGIN \\\n\tSTMT_START { \\\n\t\tdata_stack_frame_t _data_stack_cur_id = t_push(__FILE__ \":\" T_XSTRING(__LINE__));\n#define T_END \\\n\tSTMT_START { \\\n\t\tif (unlikely(!t_pop(&_data_stack_cur_id))) \\\n\t\t\ti_panic(\"Leaked t_pop() call\"); \\\n\t} STMT_END; \\\n\t} STMT_END\n\n/* WARNING: Be careful when using these functions, it's too easy to\n   accidentally save the returned value somewhere permanently.\n\n   You probably should never use these functions directly, rather\n   create functions that return 'const xxx*' types and use t_malloc()\n   internally in them. This is a lot safer, since usually compiler\n   warns if you try to place them in xxx*. See strfuncs.c for examples.\n\n   t_malloc() calls never fail. If there's not enough memory left,\n   i_panic() will be called. */\nvoid *t_malloc_no0(size_t size) ATTR_MALLOC ATTR_RETURNS_NONNULL;\nvoid *t_malloc0(size_t size) ATTR_MALLOC ATTR_RETURNS_NONNULL;\n\n/* Try growing allocated memory. Returns TRUE if successful. Works only\n   for last allocated memory in current stack frame. */\nbool t_try_realloc(void *mem, size_t size);\n\n/* Returns the number of bytes available in data stack without allocating\n   more memory. */\nsize_t t_get_bytes_available(void) ATTR_PURE;\n\n#define t_new(type, count) \\\n\t((type *) t_malloc0(MALLOC_MULTIPLY((unsigned int)sizeof(type), (count))) + \\\n\t COMPILE_ERROR_IF_TRUE(sizeof(type) > UINT_MAX))\n\n/* Returns pointer to a temporary buffer you can use. The buffer will be\n   invalid as soon as next t_malloc() is called!\n\n   If you wish to grow the buffer, you must give the full wanted size\n   in the size parameter. If return value doesn't point to the same value\n   as last time, you need to memcpy() data from the old buffer to the\n   new one (or do some other trickery). See t_buffer_reget(). */\nvoid *t_buffer_get(size_t size) ATTR_RETURNS_NONNULL;\n\n/* Grow the buffer, memcpy()ing the memory to new location if needed. */\nvoid *t_buffer_reget(void *buffer, size_t size) ATTR_RETURNS_NONNULL;\n\n/* Make the last t_buffer_get()ed buffer permanent. Note that size MUST be\n   less or equal than the size you gave with last t_buffer_get() or the\n   result will be undefined. */\nvoid t_buffer_alloc(size_t size);\n/* Allocate the last t_buffer_get()ed data entirely. */\nvoid t_buffer_alloc_last_full(void);\n\n/* If enabled, all the used memory is cleared after t_pop(). */\nvoid data_stack_set_clean_after_pop(bool enable);\n\nvoid data_stack_init(void);\nvoid data_stack_deinit(void);\n\n#endif\n"}, "32": {"id": 32, "path": "/usr/local/include/dovecot/event-log.h", "content": "#ifndef EVENT_LOG_H\n#define EVENT_LOG_H\n\nstruct event_filter;\n\n#include \"lib-event.h\"\n\nstruct event_log_params {\n\tenum log_type log_type;\n\tconst char *source_filename;\n\tunsigned int source_linenum;\n\n\t/* Base event used as a reference for base_* parameters (see below) */\n\tstruct event *base_event;\n\n\t/* Append the event message to base_str_out in addition to emitting the\n\t   event as normal. The message appended to the string buffer includes\n\t   prefixes and message callback modifications by parent events up until\n\t   the base_event. The event is otherwise sent as normal with the full\n\t   prefixes and all modifications up to the root event (unless\n\t   no_send=TRUE). This is primarily useful to mimic (part of) event\n\t   logging in parallel logs that are visible to users. */\n\tstring_t *base_str_out;\n\n\t/* Prefix inserted at the base_event for the sent log message. */\n\tconst char *base_send_prefix;\n\t/* Prefix inserted at the base_event for the log message appended to the\n\t   string buffer. */\n\tconst char *base_str_prefix;\n\n\t/* Don't actually send the event; only append to the provided string\n\t   buffer (base_str_out must not be NULL). */\n\tbool no_send:1;\n};\n\nvoid e_error(struct event *event,\n\t     const char *source_filename, unsigned int source_linenum,\n\t     const char *fmt, ...) ATTR_FORMAT(4, 5);\n#define e_error(_event, ...) STMT_START { \\\n\tstruct event *_tmp_event = (_event); \\\n\tif (event_want_level(_tmp_event, LOG_TYPE_ERROR)) \\\n\t\te_error(_tmp_event, __FILE__, __LINE__, __VA_ARGS__); \\\n\telse \\\n\t\tevent_send_abort(_tmp_event); \\\n\t} STMT_END\nvoid e_warning(struct event *event,\n\t       const char *source_filename, unsigned int source_linenum,\n\t       const char *fmt, ...) ATTR_FORMAT(4, 5);\n#define e_warning(_event, ...) STMT_START { \\\n\tstruct event *_tmp_event = (_event); \\\n\t if (event_want_level(_tmp_event, LOG_TYPE_WARNING)) \\\n\t\te_warning(_tmp_event, __FILE__, __LINE__, __VA_ARGS__); \\\n\telse \\\n\t\tevent_send_abort(_tmp_event); \\\n\t} STMT_END\nvoid e_info(struct event *event,\n\t    const char *source_filename, unsigned int source_linenum,\n\t    const char *fmt, ...) ATTR_FORMAT(4, 5);\n#define e_info(_event, ...) STMT_START { \\\n\tstruct event *_tmp_event = (_event); \\\n\tif (event_want_level(_tmp_event, LOG_TYPE_INFO)) \\\n\t\te_info(_tmp_event, __FILE__, __LINE__, __VA_ARGS__); \\\n\telse \\\n\t\tevent_send_abort(_tmp_event); \\\n\t} STMT_END\nvoid e_debug(struct event *event,\n\t     const char *source_filename, unsigned int source_linenum,\n\t     const char *fmt, ...) ATTR_FORMAT(4, 5);\n#define e_debug(_event, ...) STMT_START { \\\n\tstruct event *_tmp_event = (_event); \\\n\tif (event_want_debug(_tmp_event)) \\\n\t\te_debug(_tmp_event, __FILE__, __LINE__, __VA_ARGS__); \\\n\telse \\\n\t\tevent_send_abort(_tmp_event); \\\n\t} STMT_END\n\nvoid e_log(struct event *event, enum log_type level,\n\t   const char *source_filename, unsigned int source_linenum,\n\t   const char *fmt, ...) ATTR_FORMAT(5, 6);\n#define e_log(_event, level, ...) STMT_START { \\\n\tstruct event *_tmp_event = (_event); \\\n\tif (event_want_level(_tmp_event, level)) \\\n\t\te_log(_tmp_event, level, __FILE__, __LINE__, __VA_ARGS__); \\\n\telse \\\n\t\tevent_send_abort(_tmp_event); \\\n\t} STMT_END\n\n/* Returns TRUE if debug event should be sent (either logged or sent to\n   stats). */\nbool event_want_log_level(struct event *event, enum log_type level,\n\t\t\t  const char *source_filename,\n\t\t\t  unsigned int source_linenum);\n#define event_want_log_level(_event, level) event_want_log_level((_event), (level), __FILE__, __LINE__)\n#define event_want_debug_log(_event) event_want_log_level((_event), LOG_TYPE_DEBUG)\n\nbool event_want_level(struct event *event, enum log_type level,\n\t\t      const char *source_filename,\n\t\t      unsigned int source_linenum);\n#define event_want_level(_event, level) event_want_level((_event), (level), __FILE__, __LINE__)\n#define event_want_debug(_event) event_want_level((_event), LOG_TYPE_DEBUG)\n\nvoid event_log(struct event *event, const struct event_log_params *params,\n\t       const char *fmt, ...)\n\tATTR_FORMAT(3, 4);\nvoid event_logv(struct event *event, const struct event_log_params *params,\n\t\tconst char *fmt, va_list args)\n\tATTR_FORMAT(3, 0);\n\n/* If debugging is forced, the global debug log filter is ignored. Changing\n   this applies only to this event and any child event that is created\n   afterwards. It doesn't apply to existing child events (mainly for\n   performance reasons).\n\n   Note that event_set_forced_debug(event, FALSE) is a no-op. To disable\n   forced-debug, use event_unset_forced_debug(event). */\nstruct event *event_set_forced_debug(struct event *event, bool force);\n/* Set the forced-debug to FALSE */\nstruct event *event_unset_forced_debug(struct event *event);\n/* Set the global filter to logging debug events. */\nvoid event_set_global_debug_log_filter(struct event_filter *filter);\n/* Return the current global debug log event filter. */\nstruct event_filter *event_get_global_debug_log_filter(void);\n/* Unset global debug log filter, if one exists. */\nvoid event_unset_global_debug_log_filter(void);\n\n/* Set the global filter to sending debug events. The debug events are also\n   sent if they match the global debug log filter. */\nvoid event_set_global_debug_send_filter(struct event_filter *filter);\n/* Return the current global debug send event filter. */\nstruct event_filter *event_get_global_debug_send_filter(void);\n/* Unset global debug send filter, if one exists. */\nvoid event_unset_global_debug_send_filter(void);\n\n/* Set/replace the global core filter, which abort()s on matching events. */\nvoid event_set_global_core_log_filter(struct event_filter *filter);\n/* Return the current global core filter. */\nstruct event_filter *event_get_global_core_log_filter(void);\n/* Unset the global core filter, if one exists. */\nvoid event_unset_global_core_log_filter(void);\n\n#endif\n"}, "33": {"id": 33, "path": "/usr/local/include/dovecot/failures.h", "content": "#ifndef FAILURES_H\n#define FAILURES_H\n\nstruct ip_addr;\n\n/* Default exit status codes that we could use. */\nenum fatal_exit_status {\n\tFATAL_LOGOPEN\t= 80, /* Can't open log file */\n\tFATAL_LOGWRITE  = 81, /* Can't write to log file */\n\tFATAL_LOGERROR  = 82, /* Internal logging error */\n\tFATAL_OUTOFMEM\t= 83, /* Out of memory */\n\tFATAL_EXEC\t= 84, /* exec() failed */\n\n\tFATAL_DEFAULT\t= 89\n};\n\nenum log_type {\n\tLOG_TYPE_DEBUG,\n\tLOG_TYPE_INFO,\n\tLOG_TYPE_WARNING,\n\tLOG_TYPE_ERROR,\n\tLOG_TYPE_FATAL,\n\tLOG_TYPE_PANIC,\n\n\tLOG_TYPE_COUNT,\n\t/* special case */\n\tLOG_TYPE_OPTION\n};\n\nstruct failure_line {\n\tpid_t pid;\n\tenum log_type log_type;\n\t/* If non-zero, the first log_prefix_len bytes in text indicate\n\t   the log prefix. This implies disable_log_prefix=TRUE. */\n\tunsigned int log_prefix_len;\n\t/* Disable the global log prefix. */\n\tbool disable_log_prefix;\n\tconst char *text;\n};\n\nstruct failure_context {\n\tenum log_type type;\n\tint exit_status; /* for LOG_TYPE_FATAL */\n\tconst struct tm *timestamp; /* NULL = use time() + localtime() */\n\tunsigned int timestamp_usecs;\n\tconst char *log_prefix; /* override the default log prefix */\n\t/* If non-0, insert the log type text (e.g. \"Info: \") at this position\n\t   in the log_prefix instead of appending it. */\n\tunsigned int log_prefix_type_pos;\n};\n\n#define DEFAULT_FAILURE_STAMP_FORMAT \"%b %d %H:%M:%S \"\n\ntypedef void failure_callback_t(const struct failure_context *ctx,\n\t\t\t\tconst char *format, va_list args);\n\nextern const char *failure_log_type_prefixes[];\nextern const char *failure_log_type_names[];\n\nvoid i_log_type(const struct failure_context *ctx, const char *format, ...)\n\tATTR_FORMAT(2, 3);\nvoid i_log_typev(const struct failure_context *ctx, const char *format,\n\t\t va_list args) ATTR_FORMAT(2, 0);\n\nvoid i_panic(const char *format, ...) ATTR_FORMAT(1, 2) ATTR_NORETURN ATTR_COLD;\nvoid i_fatal(const char *format, ...) ATTR_FORMAT(1, 2) ATTR_NORETURN ATTR_COLD;\nvoid i_error(const char *format, ...) ATTR_FORMAT(1, 2) ATTR_COLD;\nvoid i_warning(const char *format, ...) ATTR_FORMAT(1, 2);\nvoid i_info(const char *format, ...) ATTR_FORMAT(1, 2);\nvoid i_debug(const char *format, ...) ATTR_FORMAT(1, 2);\n\nvoid i_fatal_status(int status, const char *format, ...)\n\tATTR_FORMAT(2, 3) ATTR_NORETURN ATTR_COLD;\n\n/* Change failure handlers. */\n#ifndef __cplusplus\nvoid i_set_fatal_handler(failure_callback_t *callback ATTR_NORETURN);\n#else\n/* Older g++ doesn't like attributes in parameters */\nvoid i_set_fatal_handler(failure_callback_t *callback);\n#endif\nvoid i_set_error_handler(failure_callback_t *callback);\nvoid i_set_info_handler(failure_callback_t *callback);\nvoid i_set_debug_handler(failure_callback_t *callback);\nvoid i_get_failure_handlers(failure_callback_t **fatal_callback_r,\n\t\t\t    failure_callback_t **error_callback_r,\n\t\t\t    failure_callback_t **info_callback_r,\n\t\t\t    failure_callback_t **debug_callback_r);\n\n/* Send failures to file. */\nvoid default_fatal_handler(const struct failure_context *ctx,\n\t\t\t   const char *format, va_list args)\n\tATTR_NORETURN ATTR_FORMAT(2, 0);\nvoid default_error_handler(const struct failure_context *ctx,\n\t\t\t   const char *format, va_list args)\n\tATTR_FORMAT(2, 0);\n\n/* Send failures to syslog() */\nvoid i_syslog_fatal_handler(const struct failure_context *ctx,\n\t\t\t    const char *format, va_list args)\n\tATTR_NORETURN ATTR_FORMAT(2, 0);\nvoid i_syslog_error_handler(const struct failure_context *ctx,\n\t\t\t    const char *format, va_list args)\n\tATTR_FORMAT(2, 0);\n\n/* Open syslog and set failure/info/debug handlers to use it. */\nvoid i_set_failure_syslog(const char *ident, int options, int facility);\n\n/* Send failures to specified log file instead of stderr. */\nvoid i_set_failure_file(const char *path, const char *prefix);\n\n/* Send errors to stderr using internal error protocol. */\nvoid i_set_failure_internal(void);\n/* Returns TRUE if the given callback handler was set via\n   i_set_failure_internal(). */\nbool i_failure_handler_is_internal(failure_callback_t *const callback);\n/* If writing to log fails, ignore it instead of existing with\n   FATAL_LOGWRITE or FATAL_LOGERROR. */\nvoid i_set_failure_ignore_errors(bool ignore);\n\n/* Send informational messages to specified log file. i_set_failure_*()\n   functions modify the info file too, so call this function after them. */\nvoid i_set_info_file(const char *path);\n\n/* Send debug-level message to the given log file. The i_set_info_file() \n   function modifies also the debug log file, so call this function after it. */\nvoid i_set_debug_file(const char *path);\n\n/* Set the failure prefix. */\nvoid i_set_failure_prefix(const char *prefix_fmt, ...) ATTR_FORMAT(1, 2);\n/* Set prefix to \"\". */\nvoid i_unset_failure_prefix(void);\n/* Returns the current failure prefix (never NULL). */\nconst char *i_get_failure_prefix(void);\n/* Prefix failures with a timestamp. fmt is in strftime() format. */\nvoid i_set_failure_timestamp_format(const char *fmt);\n/* When logging with internal error protocol, update the process's current\n   IP address / log prefix by sending it to log process. This is mainly used to\n   improve the error message if the process crashes. */\nvoid i_set_failure_send_ip(const struct ip_addr *ip);\nvoid i_set_failure_send_prefix(const char *prefix);\n\n/* Call the callback before exit()ing. The callback may update the status. */\nvoid i_set_failure_exit_callback(void (*callback)(int *status));\n/* Call the exit callback and exit() */\nvoid failure_exit(int status) ATTR_NORETURN ATTR_COLD;\n\n/* Parse a line logged using internal failure handler */\nvoid i_failure_parse_line(const char *line, struct failure_line *failure);\n\nvoid failures_deinit(void);\n\n#endif\n"}, "34": {"id": 34, "path": "/usr/local/include/dovecot/fd-util.h", "content": "#ifndef FD_UTIL_H\n#define FD_UTIL_H\n\n/* Change close-on-exec flag of fd. */\nvoid fd_close_on_exec(int fd, bool set);\n\n/* Verify that fds in given range don't exist. */\nvoid fd_debug_verify_leaks(int first_fd, int last_fd);\n\n/* Set file descriptor to blocking/nonblocking state */\nvoid fd_set_nonblock(int fd, bool nonblock);\n\n/* Close fd_in and fd_out, unless they're already -1. They can point to the\n   same fd, in which case they're closed only once. If they point to stdin\n   or stdout, they're replaced with /dev/null. */\nvoid fd_close_maybe_stdio(int *fd_in, int *fd_out);\n\n/* Close the fd and set it to -1. This assert-crashes if fd == 0, and is a\n   no-op if fd == -1. Normally fd == 0 would happen only if an uninitialized\n   fd is attempted to be closed, which is a bug. */\nvoid i_close_fd_path(int *fd, const char *path, const char *arg,\n\t\t     const char *func, const char *file, int line);\n#define i_close_fd_path(fd, path) i_close_fd_path((fd), (path), #fd, __func__, __FILE__, __LINE__)\n#define i_close_fd(fd) i_close_fd_path((fd), NULL)\n\n#endif\n"}, "35": {"id": 35, "path": "/usr/local/include/dovecot/hash-decl.h", "content": "#ifndef HASH_DECL_H\n#define HASH_DECL_H\n\n#define HASH_TABLE_UNION(key_type, value_type) { \\\n\t\tstruct hash_table *_table; \\\n\t\tkey_type _key; \\\n\t\tkey_type *_keyp; \\\n\t\tconst key_type _const_key; \\\n\t\tvalue_type _value; \\\n\t\tvalue_type *_valuep; \\\n\t}\n\n#define HASH_TABLE_DEFINE_TYPE(name, key_type, value_type) \\\n\tunion hash ## __ ## name HASH_TABLE_UNION(key_type, value_type)\n#define HASH_TABLE(key_type, value_type) \\\n\tunion HASH_TABLE_UNION(key_type, value_type)\n#define HASH_TABLE_TYPE(name) \\\n\tunion hash ## __ ## name\n\n#endif\n"}, "36": {"id": 36, "path": "/usr/local/include/dovecot/imem.h", "content": "#ifndef IMEM_H\n#define IMEM_H\n\n/* For easy allocation of memory from default memory pool. */\n\nextern pool_t default_pool;\n\n#define i_new(type, count) p_new(default_pool, type, count)\n#define i_realloc_type(mem, type, old_count, new_count) \\\n\tp_realloc_type(default_pool, mem, type, old_count, new_count)\n\nvoid *i_malloc(size_t size) ATTR_MALLOC ATTR_RETURNS_NONNULL;\nvoid *i_realloc(void *mem, size_t old_size, size_t new_size)\n\tATTR_WARN_UNUSED_RESULT ATTR_RETURNS_NONNULL;\n\n/* i_free() and i_free_and_null() are now guaranteed to both set mem=NULL,\n   so either one of them can be used. */\n#ifndef STATIC_CHECKER\n#  define i_free(mem) p_free_and_null(default_pool, mem)\n#else\n#  define i_free(mem) \\\n\tSTMT_START { \\\n\t\tpool_system_free(default_pool, mem); \\\n\t\t(mem) = NULL; \\\n\t} STMT_END\n#endif\n#define i_free_and_null(mem) i_free(mem)\n\n/* string functions */\nchar *i_strdup(const char *str) ATTR_MALLOC;\nvoid *i_memdup(const void *data, size_t size) ATTR_MALLOC;\n/* like i_strdup(), but if str == \"\", return NULL */\nchar *i_strdup_empty(const char *str) ATTR_MALLOC;\n/* *end isn't included */\nchar *i_strdup_until(const void *str, const void *end)\n\tATTR_MALLOC ATTR_RETURNS_NONNULL;\nchar *i_strndup(const void *str, size_t max_chars) ATTR_MALLOC;\nchar *i_strdup_printf(const char *format, ...)\n\tATTR_FORMAT(1, 2) ATTR_MALLOC ATTR_RETURNS_NONNULL;\nchar *i_strdup_vprintf(const char *format, va_list args)\n\tATTR_FORMAT(1, 0) ATTR_MALLOC ATTR_RETURNS_NONNULL;\n\nchar *i_strconcat(const char *str1, ...)  ATTR_SENTINEL ATTR_MALLOC;\n\n#endif\n"}, "37": {"id": 37, "path": "/usr/local/include/dovecot/lib-event.h", "content": "#ifndef LIB_EVENT_H\n#define LIB_EVENT_H\n/* event.h name is probably a bit too generic, so lets avoid using it. */\n\n#include <sys/time.h>\n\nstruct event;\nstruct event_log_params;\n\n/* Hierarchical category of events. Each event can belong to multiple\n   categories. For example [ lib-storage/maildir, syscall/io ]. The categories\n   are expected to live as long as they're used in events. */\nstruct event_category {\n\tstruct event_category *parent;\n\tconst char *name;\n\n\t/* non-NULL if this category has been registered\n\n\t   Do NOT dereference outside of event code in src/lib.\n\n\t   At any point in time it is safe to (1) check the pointer for\n\t   NULL/non-NULL to determine if this particular category instance\n\t   has been registered, and (2) compare two categories' internal\n\t   pointers to determine if they represent the same category. */\n\tvoid *internal;\n};\n\nenum event_field_value_type {\n\tEVENT_FIELD_VALUE_TYPE_STR,\n\tEVENT_FIELD_VALUE_TYPE_INTMAX,\n\tEVENT_FIELD_VALUE_TYPE_TIMEVAL,\n};\n\nstruct event_field {\n\tconst char *key;\n\tenum event_field_value_type value_type;\n\tstruct {\n\t\tconst char *str;\n\t\tintmax_t intmax;\n\t\tstruct timeval timeval;\n\t} value;\n};\n\nstruct event_add_field {\n\tconst char *key;\n\t/* The first non-0/NULL value is used. */\n\tconst char *value;\n\tintmax_t value_intmax;\n\tstruct timeval value_timeval;\n};\n\nstruct event_passthrough {\n\t/* wrappers to event_set_*() and event_add_*() for passthrough events,\n\t   so these can be chained like:\n\t   event_create_passthrough(parent)->name(\"name\")->...->event() */\n\tstruct event_passthrough *\n\t\t(*append_log_prefix)(const char *prefix);\n\tstruct event_passthrough *\n\t\t(*replace_log_prefix)(const char *prefix);\n\tstruct event_passthrough *\n\t\t(*set_name)(const char *name);\n\tstruct event_passthrough *\n\t\t(*set_source)(const char *filename,\n\t\t\t      unsigned int linenum, bool literal_fname);\n\tstruct event_passthrough *\n\t\t(*set_always_log_source)(void);\n\n\tstruct event_passthrough *\n\t\t(*add_categories)(struct event_category *const *categories);\n\tstruct event_passthrough *\n\t\t(*add_category)(struct event_category *category);\n\tstruct event_passthrough *\n\t\t(*add_fields)(const struct event_add_field *fields);\n\n\tstruct event_passthrough *\n\t\t(*add_str)(const char *key, const char *value);\n\tstruct event_passthrough *\n\t\t(*add_int)(const char *key, intmax_t num);\n\tstruct event_passthrough *\n\t\t(*add_timeval)(const char *key, const struct timeval *tv);\n\n\tstruct event_passthrough *\n\t\t(*inc_int)(const char *key, intmax_t num);\n\n\tstruct event_passthrough *\n\t\t(*clear_field)(const char *key);\n\n\tstruct event *(*event)(void);\n};\n\ntypedef const char *\nevent_log_prefix_callback_t(void *context);\ntypedef const char *\nevent_log_message_callback_t(void *context, enum log_type log_type,\n\t\t\t     const char *message);\n\n/* Returns TRUE if the event has all the categories that the \"other\" event has (and maybe more). */\nbool event_has_all_categories(struct event *event, const struct event *other);\n/* Returns TRUE if the event has all the fields that the \"other\" event has (and maybe more).\n   Only the fields in the events themselves are checked. Parent events' fields are not checked. */\nbool event_has_all_fields(struct event *event, const struct event *other);\n\n/* Returns the source event duplicated into a new event. Event pointers are\n   dropped. */\nstruct event *event_dup(const struct event *source);\n/* Returns a flattened version of the source event.\n   Both categories and fields will be flattened.\n   A new reference to the source event is returned if no flattening was\n   needed. Event pointers are dropped if a new event was created. */\nstruct event *event_flatten(struct event *src);\n/* Returns a minimized version of the source event.\n   Remove parents with no fields or categories, attempt to flatten fields\n   and categories to avoid sending one-off parent events.  (There is a more\n   detailed description in a comment above the function implementation.)\n   A new reference to the source event is returned if no simplification\n   occured. Event pointers are dropped if a new event was created. */\nstruct event *event_minimize(struct event *src);\n/* Copy all categories from source to dest.\n   Only the categories in source event itself are copied.\n   Parent events' categories aren't copied. */\nvoid event_copy_categories(struct event *to, struct event *from);\n/* Copy all fields from source to dest.\n   Only the fields in source event itself are copied.\n   Parent events' fields aren't copied. */\nvoid event_copy_fields(struct event *to, struct event *from);\n\n/* Create a new empty event under the parent event, or NULL for root event. */\nstruct event *event_create(struct event *parent, const char *source_filename,\n\t\t\t   unsigned int source_linenum);\n#define event_create(parent) \\\n\tevent_create((parent), __FILE__, __LINE__)\n/* This is a temporary \"passthrough\" event. Its main purpose is to make it\n   easier to create temporary events as part of the event parameter in\n   e_error(), e_warning(), e_info() or e_debug(). These passthrough events are\n   automatically freed when the e_*() call is finished. Because this makes the\n   freeing less obvious, it should be avoided outside e_*()'s event parameter.\n\n   The passthrough events also change the API to be more convenient towards\n   being used in a parameter. Instead of having to use e.g.\n   event_add_str(event_set_name(event_create(parent), \"name\"), \"key\", \"value\")\n   the event_passthrough API can be a bit more readable as:\n   event_create_passthrough(parent)->set_name(\"name\")->\n   add_str(\"key\", \"value\")->event(). The passthrough event is converted to\n   a normal event at the end with the event() call. Note that this API works\n   by modifying the last created passthrough event, so it's not possible to\n   have multiple passthrough events created in parallel. */\nstruct event_passthrough *\nevent_create_passthrough(struct event *parent, const char *source_filename,\n\t\t\t unsigned int source_linenum);\n#define event_create_passthrough(parent) \\\n\tevent_create_passthrough((parent), __FILE__, __LINE__)\n\n/* Reference the event. Returns the event parameter. */\nstruct event *event_ref(struct event *event);\n/* Unreference the event. If the reference count drops to 0, the event is\n   freed. The current global event's refcount must not drop to 0. */\nvoid event_unref(struct event **event);\n\n/* Set the event to be the global default event used by i_error(), etc.\n   Returns the event parameter. The event must be explicitly popped before\n   it's freed.\n\n   The global event stack is also an alternative nonpermanent hierarchy for\n   events. For example the global event can be \"IMAP command SELECT\", which\n   can be used for filtering events that happen while the SELECT command is\n   being executed. However, for the created struct mailbox the parent event\n   should be the mail_user, not the SELECT command. Otherwise everything else\n   that happens afterwards to the selected mailbox would also count towards\n   SELECT. This means that events shouldn't be using the current global event\n   as their parent event. */\nstruct event *event_push_global(struct event *event);\n/* Pop the global event. Assert-crash if the current global event isn't the\n   given event parameter. Returns the new global event. */\nstruct event *event_pop_global(struct event *event);\n/* Returns the current global event. */\nstruct event *event_get_global(void);\n\n/* Set the appended log prefix string for this event. All the parent events'\n   log prefixes will be concatenated together when logging. The log type\n   text (e.g. \"Info: \") will be inserted before appended log prefixes (but\n   after replaced log prefix).\n\n   Clears log_prefix callback.\n */\nstruct event *\nevent_set_append_log_prefix(struct event *event, const char *prefix);\n/* Replace the full log prefix string for this event. The parent events' log\n   prefixes won't be used. Also, any parent event's message amendment callback\n   is not used.\n\n   Clears log_prefix callback.\n*/\nstruct event *event_replace_log_prefix(struct event *event, const char *prefix);\n\n/* Drop count prefixes from parents when this event is used for logging. This\n   does not affect the parent events. This only counts actual prefixes and not\n   parents. If the count is higher than the actual number of prefixes added by\n   parents, all will be dropped. */\nstruct event *\nevent_drop_parent_log_prefixes(struct event *event, unsigned int count);\n\n/* Sets event prefix callback, sets log_prefix empty */\nstruct event *event_set_log_prefix_callback(struct event *event,\n\t\t\t\t\t    bool replace,\n\t\t\t\t\t    event_log_prefix_callback_t *callback,\n\t\t\t\t\t    void *context);\n#define event_set_log_prefix_callback(event, replace, callback, context) \\\n\tevent_set_log_prefix_callback(event, replace, \\\n\t\t(event_log_prefix_callback_t*)callback, TRUE ? context : \\\n\t\tCALLBACK_TYPECHECK(callback, const char *(*)(typeof(context))))\n\n/* Sets event message amendment callback */\nstruct event *event_set_log_message_callback(struct event *event,\n\t\t\t\t\t     event_log_message_callback_t *callback,\n\t\t\t\t\t     void *context);\n#define event_set_log_message_callback(event, callback, context) \\\n\tevent_set_log_message_callback(event, \\\n\t\t(event_log_message_callback_t*)callback, TRUE ? context : \\\n\t\tCALLBACK_TYPECHECK(callback, \\\n\t\t\tconst char *(*)(typeof(context), enum log_type, \\\n\t\t\t\t\tconst char *)))\n\n/* Set the event's name. The name is specific to a single sending of an event,\n   and it'll be automatically cleared once the event is sent. This should\n   typically be used only in a parameter to e_debug(), etc. */\nstruct event *\nevent_set_name(struct event *event, const char *name);\n/* Set the source filename:linenum to the event. If literal_fname==TRUE,\n   it's assumed that __FILE__ has been used and the pointer is stored directly,\n   otherwise the filename is strdup()ed. */\nstruct event *\nevent_set_source(struct event *event, const char *filename,\n\t\t unsigned int linenum, bool literal_fname);\n/* Always include the source path:line in the log replies. This is\n   especially useful when logging about unexpected syscall failures, because\n   it allow quickly finding which of the otherwise identical syscalls in the\n   code generated the error. */\nstruct event *event_set_always_log_source(struct event *event);\n/* Set minimum log level for the event */\nstruct event *event_set_min_log_level(struct event *event, enum log_type level);\nenum log_type event_get_min_log_level(const struct event *event);\n\n/* Add an internal pointer to an event. It can be looked up only with\n   event_get_ptr(). The keys are in their own namespace and won't conflict\n   with event fields. The pointers are specific to this specific event only -\n   they will be dropped from any duplicated/flattened/minimized events. */\nstruct event *event_set_ptr(struct event *event, const char *key, void *value);\n/* Return a pointer set with event_set_ptr(), or NULL if it doesn't exist.\n   The pointer is looked up only from the event itself, not its parents. */\nvoid *event_get_ptr(const struct event *event, const char *key);\n\n/* Add NULL-terminated list of categories to the event. The categories pointer\n   doesn't need to stay valid afterwards, but the event_category structs\n   themselves must be. Returns the event parameter. */\nstruct event *\nevent_add_categories(struct event *event,\n\t\t     struct event_category *const *categories);\n/* Add a single category to the event. */\nstruct event *\nevent_add_category(struct event *event, struct event_category *category);\n\n/* Add key=value field to the event. If a key already exists, it's replaced.\n   Child events automatically inherit key=values from their parents at the\n   time the event is sent. So changing a key in parent will change the values\n   in the child events as well, unless the key has been overwritten in the\n   child event. Setting the value to \"\" is the same as event_field_clear().\n   Returns the event parameter. */\nstruct event *\nevent_add_str(struct event *event, const char *key, const char *value);\nstruct event *\nevent_add_int(struct event *event, const char *key, intmax_t num);\n/* Increase the key's value. If it's not set or isn't an integer type,\n   initialize the value to num. */\nstruct event *\nevent_inc_int(struct event *event, const char *key, intmax_t num);\nstruct event *\nevent_add_timeval(struct event *event, const char *key,\n\t\t  const struct timeval *tv);\n/* Same as event_add_str/int(), but do it via event_field struct. The fields\n   terminates with key=NULL. Returns the event parameter. */\nstruct event *\nevent_add_fields(struct event *event, const struct event_add_field *fields);\n/* Mark a field as nonexistent. If a parent event has the field set, this\n   allows removing it from the child event. Using an event filter with e.g.\n   \"key=*\" won't match this field anymore, although it's still visible in\n   event_find_field*() and event_get_fields(). This is the same as using\n   event_add_str() with value=\"\". */\nvoid event_field_clear(struct event *event, const char *key);\n\n/* Returns the parent event, or NULL if it doesn't exist. */\nstruct event *event_get_parent(const struct event *event);\n/* Get the event's creation time. */\nvoid event_get_create_time(const struct event *event, struct timeval *tv_r);\n/* Get the time when the event was last sent. Returns TRUE if time was\n   returned, FALSE if event has never been sent. */\nbool event_get_last_send_time(const struct event *event, struct timeval *tv_r);\n/* Get the event duration field, calculated after event has been sent. */\nvoid event_get_last_duration(const struct event *event,\n\t\t\t     intmax_t *duration_msec_r);\n/* Returns field for a given key, or NULL if it doesn't exist. If the key\n   isn't found from the event itself, find it from parent events. */\nconst struct event_field *\nevent_find_field(const struct event *event, const char *key);\n/* Returns the given key's value as string, or NULL if it doesn't exist.\n   If the field isn't stored as a string, the result is allocated from\n   data stack. */\nconst char *\nevent_find_field_str(const struct event *event, const char *key);\n/* Returns all key=value fields that the event has.\n   Parent events' fields aren't returned. */\nconst struct event_field *\nevent_get_fields(const struct event *event, unsigned int *count_r);\n/* Return all categories that the event has.\n   Parent events' categories aren't returned. */\nstruct event_category *const *\nevent_get_categories(const struct event *event, unsigned int *count_r);\n\n/* Export the event into a tabescaped string, so its fields are separated\n   with TABs and there are no NUL, CR or LF characters. */\nvoid event_export(const struct event *event, string_t *dest);\n/* Import event. The string is expected to be generated by event_export().\n   All the used categories must already be registered.\n   Returns TRUE on success, FALSE on invalid string. */\nbool event_import(struct event *event, const char *str, const char **error_r);\n/* Same as event_import(), but string is already split into an array\n   of strings via *_strsplit_tabescaped(). */\nbool event_import_unescaped(struct event *event, const char *const *args,\n\t\t\t    const char **error_r);\n\n/* The event wasn't sent after all - free everything related to it.\n   Most importantly this frees any passthrough events. Typically this shouldn't\n   need to be called. */\nvoid event_send_abort(struct event *event);\n\nvoid lib_event_init(void);\nvoid lib_event_deinit(void);\n\n#endif\n"}, "38": {"id": 38, "path": "/usr/local/include/dovecot/lib.h", "content": "#ifndef LIB_H\n#define LIB_H\n\n/* default lib includes */\n#ifdef HAVE_CONFIG_H\n#  include \"config.h\"\n#endif\n\n/* default system includes - keep these at minimum.. */\n#include <stddef.h> /* Solaris defines NULL wrong unless this is used */\n#include <stdlib.h>\n#include <string.h> /* strcmp() etc. */\n#ifdef HAVE_STRINGS_H\n#  include <strings.h> /* strcasecmp() etc. */\n#endif\n#include <stdarg.h> /* va_list is used everywhere */\n#include <limits.h> /* INT_MAX, etc. */\n#include <errno.h> /* error checking is good */\n#include <sys/types.h> /* many other includes want this */\n#include <inttypes.h> /* PRI* macros */\n\n#ifdef HAVE_STDINT_H\n#  include <stdint.h> /* C99 int types, we mostly need uintmax_t */\n#endif\n\n#include \"compat.h\"\n#include \"macros.h\"\n#include \"failures.h\"\n\n#include \"malloc-overflow.h\"\n#include \"data-stack.h\"\n#include \"mempool.h\"\n#include \"imem.h\"\n#include \"byteorder.h\"\n#include \"fd-util.h\"\n\ntypedef struct buffer buffer_t;\ntypedef struct buffer string_t;\n\nstruct istream;\nstruct ostream;\n\ntypedef void lib_atexit_callback_t(void);\n\n#include \"array-decl.h\" /* ARRAY*()s may exist in any header */\n#include \"bits.h\"\n#include \"hash-decl.h\" /* HASH_TABLE*()s may exist in any header */\n#include \"strfuncs.h\"\n#include \"strnum.h\"\n#include \"event-log.h\"\n\n#define LIB_ATEXIT_PRIORITY_HIGH -10\n#define LIB_ATEXIT_PRIORITY_DEFAULT 0\n#define LIB_ATEXIT_PRIORITY_LOW 10\n\n/* /dev/null opened as O_WRONLY. Opened at lib_init(), so it can be accessed\n   also inside chroots. */\nextern int dev_null_fd;\n\n/* Call unlink(). If it fails, log an error including the source filename\n   and line number. */\nint i_unlink(const char *path, const char *source_fname,\n\t     unsigned int source_linenum);\n#define i_unlink(path) i_unlink(path, __FILE__, __LINE__)\n/* Same as i_unlink(), but don't log an error if errno=ENOENT. Returns 1 on\n   unlink() success, 0 if errno=ENOENT, -1 on other errors. */\nint i_unlink_if_exists(const char *path, const char *source_fname,\n\t\t       unsigned int source_linenum);\n#define i_unlink_if_exists(path) i_unlink_if_exists(path, __FILE__, __LINE__)\n/* Reset getopt() so it can be used for the next args. */\nvoid i_getopt_reset(void);\n\n/* Call the given callback at the beginning of lib_deinit(). The main\n   difference to atexit() is that liblib's memory allocation and logging\n   functions are still available. Also if lib_atexit() is called multiple times\n   to the same callback, it's added only once. */\nvoid lib_atexit(lib_atexit_callback_t *callback);\n/* Specify the order in which the callback is called. Lowest numbered\n   priorities are called first. lib_atexit() is called with priority=0. */\nvoid lib_atexit_priority(lib_atexit_callback_t *callback, int priority);\n/* Manually run the atexit callbacks. lib_deinit() also does this if not\n   explicitly called. */\nvoid lib_atexit_run(void);\n\nvoid lib_init(void);\nbool lib_is_initialized(void);\nvoid lib_deinit(void);\n\nuint32_t i_rand(void);\n/* Returns a random integer < upper_bound. */\nuint32_t i_rand_limit(uint32_t upper_bound);\n\n/* Returns a random integer >= min_val, and <= max_val. */\nstatic inline uint32_t i_rand_minmax(uint32_t min_val, uint32_t max_val)\n{\n\ti_assert(min_val <= max_val);\n\treturn min_val + i_rand_limit(max_val - min_val + 1);\n}\n\n#endif\n"}, "39": {"id": 39, "path": "/usr/local/include/dovecot/macros.h", "content": "#ifndef MACROS_H\n#define MACROS_H\n\n/* several useful macros, mostly from glib.h */\n\n#ifndef NULL\n#  define NULL ((void *)0)\n#endif\n\n#ifndef FALSE\n#  define FALSE (!1)\n#endif\n\n#ifndef TRUE\n#  define TRUE (!FALSE)\n#endif\n\n#define N_ELEMENTS(arr) \\\n\t(sizeof(arr) / sizeof((arr)[0]))\n\n#define MEM_ALIGN(size) \\\n\t(((size) + MEM_ALIGN_SIZE-1) & ~((size_t) MEM_ALIGN_SIZE-1))\n\n#define PTR_OFFSET(ptr, offset) \\\n\t((void *) (((uintptr_t) (ptr)) + ((size_t) (offset))))\n#define CONST_PTR_OFFSET(ptr, offset) \\\n\t((const void *) (((uintptr_t) (ptr)) + ((size_t) (offset))))\n\n#define container_of(ptr, type, name) \\\n\t(type *)((uintptr_t)(ptr) - (uintptr_t)offsetof(type, name) + \\\n\t\t COMPILE_ERROR_IF_TYPES_NOT_COMPATIBLE(ptr, &((type *) 0)->name))\n\n/* Don't use simply MIN/MAX, as they're often defined elsewhere in include\n   files that are included after this file generating tons of warnings. */\n#define I_MIN(a, b)  (((a) < (b)) ? (a) : (b))\n#define I_MAX(a, b)  (((a) > (b)) ? (a) : (b))\n\n/* make it easier to cast from/to pointers. assumes that\n   sizeof(uintptr_t) == sizeof(void *) and they're both the largest datatypes\n   that are allowed to be used. so, long long isn't safe with these. */\n#define POINTER_CAST(i) \\\n\t((void *) (((uintptr_t)NULL) + (i)))\n#define POINTER_CAST_TO(p, type) \\\n\t((type) ((const char *) (p) - (const char *) NULL))\n\n/* Define VA_COPY() to do the right thing for copying va_list variables.\n   config.h may have already defined VA_COPY as va_copy or __va_copy. */\n#ifndef VA_COPY\n#  if defined (__GNUC__) && defined (__PPC__) && \\\n      (defined (_CALL_SYSV) || defined (_WIN32))\n#    define VA_COPY(ap1, ap2) (*(ap1) = *(ap2))\n#  elif defined (VA_COPY_AS_ARRAY)\n#    define VA_COPY(ap1, ap2) memmove ((ap1), (ap2), sizeof (va_list))\n#  else /* va_list is a pointer */\n#    define VA_COPY(ap1, ap2) ((ap1) = (ap2))\n#  endif /* va_list is a pointer */\n#endif\n\n/* Provide convenience macros for handling structure\n * fields through their offsets.\n */\n#define STRUCT_MEMBER_P(struct_p, struct_offset) \\\n\t((void *) ((char *) (struct_p) + (long) (struct_offset)))\n#define CONST_STRUCT_MEMBER_P(struct_p, struct_offset) \\\n\t((const void *) ((const char *) (struct_p) + (long) (struct_offset)))\n\n/* Provide simple macro statement wrappers (adapted from Perl):\n   STMT_START { statements; } STMT_END;\n   can be used as a single statement, as in\n   if (x) STMT_START { ... } STMT_END; else ...\n\n   For gcc we will wrap the statements within `({' and `})' braces.\n   For SunOS they will be wrapped within `if (1)' and `else (void) 0',\n   and otherwise within `do' and `while (0)'. */\n#if !(defined (STMT_START) && defined (STMT_END))\n#  if defined (__GNUC__) && !defined (__cplusplus) && \\\n\t!defined (__STRICT_ANSI__) && !defined (PEDANTIC)\n#    define STMT_START (void)(\n#    define STMT_END   )\n#  else\n#    if (defined (sun) || defined (__sun__))\n#      define STMT_START if (1)\n#      define STMT_END   else (void)0\n#    else\n#      define STMT_START do\n#      define STMT_END   while (0)\n#    endif\n#  endif\n#endif\n\n/* Provide macros to feature the GCC function attribute. */\n#if __GNUC__ > 2 || (__GNUC__ == 2 && __GNUC_MINOR__ > 4)\n#  define ATTRS_DEFINED\n#  define ATTR_FORMAT(format_idx, arg_idx) \\\n\t__attribute__((format (printf, format_idx, arg_idx)))\n#  define ATTR_FORMAT_ARG(arg_idx) \\\n\t__attribute__((format_arg (arg_idx)))\n#  define ATTR_SCANF(format_idx, arg_idx) \\\n\t__attribute__((format (scanf, format_idx, arg_idx)))\n#  define ATTR_STRFTIME(format_idx) \\\n\t__attribute__((format (strftime, format_idx, 0)))\n#  define ATTR_UNUSED __attribute__((unused))\n#  define ATTR_NORETURN __attribute__((noreturn))\n#  define ATTR_CONST __attribute__((const))\n#  define ATTR_PURE __attribute__((pure))\n#else\n#  define ATTR_FORMAT(format_idx, arg_idx)\n#  define ATTR_FORMAT_ARG(arg_idx)\n#  define ATTR_SCANF(format_idx, arg_idx)\n#  define ATTR_STRFTIME(format_idx)\n#  define ATTR_UNUSED\n#  define ATTR_NORETURN\n#  define ATTR_CONST\n#  define ATTR_PURE\n#endif\n#ifdef HAVE_ATTR_NULL\n#  define ATTR_NULL(...) __attribute__((null(__VA_ARGS__)))\n#else\n#  define ATTR_NULL(...)\n#endif\n#ifdef HAVE_ATTR_NOWARN_UNUSED_RESULT\n#  define ATTR_NOWARN_UNUSED_RESULT __attribute__((nowarn_unused_result))\n#else\n#  define ATTR_NOWARN_UNUSED_RESULT\n#endif\n#if __GNUC__ > 2\n#  define ATTR_MALLOC __attribute__((malloc))\n#else\n#  define ATTR_MALLOC\n#endif\n#if __GNUC__ > 3\n/* GCC 4.0 and later */\n#  define ATTR_WARN_UNUSED_RESULT __attribute__((warn_unused_result))\n#  define ATTR_SENTINEL __attribute__((sentinel))\n#else\n#  define ATTR_WARN_UNUSED_RESULT\n#  define ATTR_SENTINEL\n#endif\n#if __GNUC__ > 4 || (__GNUC__ == 4 && __GNUC_MINOR__ >= 3)\n/* GCC 4.3 and later */\n#  define ATTR_HOT __attribute__((hot))\n#  define ATTR_COLD __attribute__((cold))\n#else\n#  define ATTR_HOT\n#  define ATTR_COLD\n#endif\n#if __GNUC__ > 4 || (__GNUC__ == 4 && __GNUC_MINOR__ >= 9)\n/* GCC 4.9 and later */\n#  define ATTR_RETURNS_NONNULL __attribute__((returns_nonnull))\n#else\n#  define ATTR_RETURNS_NONNULL\n#endif\n#ifdef HAVE_ATTR_DEPRECATED\n#  define ATTR_DEPRECATED(str) __attribute__((deprecated(str)))\n#else\n#  define ATTR_DEPRECATED(str)\n#endif\n\n/* Macros to provide type safety for callback functions' context parameters */\n#ifdef HAVE_TYPE_CHECKS\n#  define CALLBACK_TYPECHECK(callback, type) \\\n\t(COMPILE_ERROR_IF_TRUE(!__builtin_types_compatible_p( \\\n\t\ttypeof(&callback), type)) ? 1 : 0)\n#else\n#  define CALLBACK_TYPECHECK(callback, type) 0\n#endif\n\n#if (__GNUC__ > 3 || (__GNUC__ == 3 && __GNUC_MINOR__ > 0)) && !defined(__cplusplus)\n#  define COMPILE_ERROR_IF_TRUE(condition) \\\n\t(sizeof(char[1 - 2 * ((condition) ? 1 : 0)]) - 1)\n#else\n#  define COMPILE_ERROR_IF_TRUE(condition) 0\n#endif\n\n#ifdef HAVE_TYPE_CHECKS\n#  define COMPILE_ERROR_IF_TYPES_NOT_COMPATIBLE(_a, _b) \\\n\tCOMPILE_ERROR_IF_TRUE( \\\n\t\t!__builtin_types_compatible_p(typeof(_a), typeof(_b)))\n#define COMPILE_ERROR_IF_TYPES2_NOT_COMPATIBLE(_a1, _a2, _b) \\\n\tCOMPILE_ERROR_IF_TRUE( \\\n\t\t!__builtin_types_compatible_p(typeof(_a1), typeof(_b)) && \\\n\t\t!__builtin_types_compatible_p(typeof(_a2), typeof(_b)))\n#else\n#  define COMPILE_ERROR_IF_TYPES_NOT_COMPATIBLE(_a, _b) 0\n#  define COMPILE_ERROR_IF_TYPES2_NOT_COMPATIBLE(_a1, _a2, _b) 0\n#endif\n\n#if __GNUC__ > 2\n#  define unlikely(expr) (__builtin_expect((expr) ? 1 : 0, 0) != 0)\n#  define likely(expr) (__builtin_expect((expr) ? 1 : 0, 1) != 0)\n#else\n#  define unlikely(expr) expr\n#  define likely(expr) expr\n#endif\n\n#if defined(__clang__) && ((__clang_major__ > 4) || (__clang_major__ == 3 && __clang_minor__ >= 9))\n#  define ATTR_UNSIGNED_WRAPS __attribute__((no_sanitize(\"integer\")))\n#else\n#  define ATTR_UNSIGNED_WRAPS\n#endif\n\n/* Provide macros for error handling. */\n#ifdef DISABLE_ASSERTS\n#  define i_assert(expr)\n#else\n\n#define i_assert(expr)\t\t\tSTMT_START{\t\t\t\\\n     if (unlikely(!(expr)))\t\t\t\t\t\t\\\n       i_panic(\"file %s: line %d (%s): assertion failed: (%s)\",\t\t\\\n\t\t__FILE__,\t\t\t\t\t\t\\\n\t\t__LINE__,\t\t\t\t\t\t\\\n\t\t__func__,\t\t\t\t\t\\\n\t\t#expr);\t\t\t}STMT_END\n\n#endif\n\n#ifndef STATIC_CHECKER\n#  define i_unreached() \\\n\ti_panic(\"file %s: line %d: unreached\", __FILE__, __LINE__)\n#else\n#  define i_unreached() __builtin_unreachable()\n#endif\n\n/* Convenience macros to test the versions of dovecot. */\n#if defined DOVECOT_VERSION_MAJOR && defined DOVECOT_VERSION_MINOR\n#  define DOVECOT_PREREQ(maj, min) \\\n          ((DOVECOT_VERSION_MAJOR << 16) + DOVECOT_VERSION_MINOR >= ((maj) << 16) + (min))\n#else\n#  define DOVECOT_PREREQ(maj, min) 0\n#endif\n\n#ifdef __cplusplus\n#  undef STATIC_ARRAY\n#  define STATIC_ARRAY\n#endif\n\n/* Convenience wrappers for initializing a struct with zeros, although it can\n   be used for replacing other memset()s also.\n\n   // NOTE: This is the correct way to zero the whole array\n   char arr[5]; i_zero(&arr);\n   // This will give compiler error (or zero only the first element):\n   char arr[5]; i_zero(arr);\n*/\n#define i_zero(p) \\\n\tmemset(p, 0 + COMPILE_ERROR_IF_TRUE(sizeof(p) > sizeof(void *)), sizeof(*(p)))\n#define i_zero_safe(p) \\\n\tsafe_memset(p, 0 + COMPILE_ERROR_IF_TRUE(sizeof(p) > sizeof(void *)), sizeof(*(p)))\n\n#define ST_CHANGED(st_a, st_b) \\\n\t((st_a).st_mtime != (st_b).st_mtime || \\\n\t ST_MTIME_NSEC(st_a) != ST_MTIME_NSEC(st_b) || \\\n\t (st_a).st_size != (st_b).st_size || \\\n\t (st_a).st_ino != (st_b).st_ino)\n\n#endif\n"}, "40": {"id": 40, "path": "/usr/local/include/dovecot/malloc-overflow.h", "content": "#ifndef MALLOC_OVERFLOW_H\n#define MALLOC_OVERFLOW_H\n\n/* MALLOC_*() can be used to calculate memory allocation sizes. If there's an\n   overflow, it'll cleanly panic instead of causing a potential buffer\n   overflow.\n\n   Note that *_malloc(size+1) doesn't need to use MALLOC_ADD(size, 1). It wraps\n   to size==0 and the *_malloc() calls already panic if size==0. */\nstatic inline size_t\nmalloc_multiply_check(size_t a, size_t b, size_t sizeof_a, size_t sizeof_b,\n\t\t      const char *fname, unsigned int linenum)\n{\n\t/* the first sizeof-checks are intended to optimize away this entire\n\t   if-check for types that are small enough to never wrap size_t. */\n\tif ((sizeof_a * 2 > sizeof(size_t) || sizeof_b * 2 > sizeof(size_t)) &&\n\t    b != 0 && (a > SIZE_MAX / b)) {\n\t\ti_panic(\"file %s: line %d: memory allocation overflow: %zu * %zu\",\n\t\t\tfname, linenum, a, b);\n\t}\n\treturn a * b;\n}\n#ifndef STATIC_CHECKER\n#  define MALLOC_MULTIPLY(a, b) \\\n\tmalloc_multiply_check(a, b, sizeof(a), sizeof(b), __FILE__, __LINE__)\n#else\n/* avoid warning every time about sizeof(b) when b contains any arithmetic */\n#  define MALLOC_MULTIPLY(a, b) \\\n\tmalloc_multiply_check(a, b, sizeof(a), sizeof(size_t), __FILE__, __LINE__)\n#endif\n\nstatic inline size_t\nmalloc_add_check(size_t a, size_t b, size_t sizeof_a, size_t sizeof_b,\n\t\t const char *fname, unsigned int linenum)\n{\n\t/* the first sizeof-checks are intended to optimize away this entire\n\t   if-check for types that are small enough to never wrap size_t. */\n\tif ((sizeof_a >= sizeof(size_t) || sizeof_b >= sizeof(size_t)) &&\n\t    SIZE_MAX - a < b) {\n\t\ti_panic(\"file %s: line %d: memory allocation overflow: %zu + %zu\",\n\t\t\tfname, linenum, a, b);\n\t}\n\treturn a + b;\n}\n#ifndef STATIC_CHECKER\n#  define MALLOC_ADD(a, b) \\\n\tmalloc_add_check(a, b, sizeof(a), sizeof(b), __FILE__, __LINE__)\n#else\n/* avoid warning every time about sizeof(b) when b contains any arithmetic */\n#  define MALLOC_ADD(a, b) \\\n\tmalloc_add_check(a, b, sizeof(a), sizeof(size_t), __FILE__, __LINE__)\n#endif\n\n#endif\n"}, "41": {"id": 41, "path": "/usr/local/include/dovecot/mempool.h", "content": "#ifndef MEMPOOL_H\n#define MEMPOOL_H\n\n#include \"macros.h\"\n\n/* When DEBUG is enabled, Dovecot warns whenever a memory pool is grown.\n   This is done so that the initial pool size could be set large enough so that\n   it wouldn't grow in normal use. For some memory pools it's too difficult\n   to calculate a good initial size, so this prefix should be used with those\n   pools to disable the warning. */\n#define MEMPOOL_GROWING \"GROWING-\"\n\n/* The maximum allocation size that's allowed.  Anything larger than that\n   will panic.  No pool ever should need more than 4kB of overhead per\n   allocation. */\n#define POOL_MAX_ALLOC_SIZE\t(SSIZE_T_MAX - 4096)\n\n/* Memory allocated and reallocated (the new data in it) in pools is always\n   zeroed, it will cost only a few CPU cycles and may well save some debug\n   time. */\n\ntypedef struct pool *pool_t;\n\nstruct pool_vfuncs {\n\tconst char *(*get_name)(pool_t pool);\n\n\tvoid (*ref)(pool_t pool);\n\tvoid (*unref)(pool_t *pool);\n\n\tvoid *(*malloc)(pool_t pool, size_t size) ATTR_RETURNS_NONNULL;\n\tvoid (*free)(pool_t pool, void *mem);\n\n\t/* memory in old_size..new_size will be zeroed */\n\tvoid *(*realloc)(pool_t pool, void *mem,\n\t\t\t size_t old_size, size_t new_size)\n\t\tATTR_WARN_UNUSED_RESULT ATTR_RETURNS_NONNULL;\n\n\t/* Frees all the memory in pool. NOTE: system_pool doesn't support\n\t   this and crashes if it's used */\n\tvoid (*clear)(pool_t pool);\n\n\t/* Returns the maximum amount of bytes that can be allocated with\n\t   minimal trouble. If there's no such concept, always returns 0. */\n\tsize_t (*get_max_easy_alloc_size)(pool_t pool);\n};\n\nstruct pool {\n\tconst struct pool_vfuncs *v;\n\n\tbool alloconly_pool:1;\n\tbool datastack_pool:1;\n};\n\n/* system_pool uses calloc() + realloc() + free() */\nextern pool_t system_pool;\nextern struct pool static_system_pool;\n\n/* memory allocated from data_stack is valid only until next t_pop() call.\n   No checks are performed. */\nextern pool_t unsafe_data_stack_pool;\n\n/* Create a new alloc-only pool. Note that `size' specifies the initial\n   malloc()ed block size, part of it is used internally. */\npool_t pool_alloconly_create(const char *name, size_t size);\n/* Like alloconly pool, but clear the memory before freeing it. The idea is\n   that you could allocate memory for storing sensitive information from this\n   pool, and be sure that it gets cleared from the memory when it's no longer\n   needed. */\npool_t pool_alloconly_create_clean(const char *name, size_t size);\n\n/* When allocating memory from returned pool, the data stack frame must be\n   the same as it was when calling this function. pool_unref() also checks\n   that the stack frame is the same. This should make it quite safe to use. */\npool_t pool_datastack_create(void);\n\n/* Create new alloc pool. This is very similar to system pool, but it\n   will deallocate all memory on deinit. */\npool_t pool_allocfree_create(const char *name);\n\n/* Like alloc pool, but all memory is cleaned before freeing.\n   See pool_alloconly_create_clean. */\npool_t pool_allocfree_create_clean(const char *name);\n\n/* Similar to nearest_power(), but try not to exceed buffer's easy\n   allocation size. If you don't have any explicit minimum size, use\n   old_size + 1. */\nsize_t pool_get_exp_grown_size(pool_t pool, size_t old_size, size_t min_size);\n\n/* We require sizeof(type) to be <= UINT_MAX. This allows compiler to optimize\n   away the entire MALLOC_MULTIPLY() call on 64bit systems. */\n#define p_new(pool, type, count) \\\n\t((type *) p_malloc(pool, MALLOC_MULTIPLY((unsigned int)sizeof(type), (count))) + \\\n\t COMPILE_ERROR_IF_TRUE(sizeof(type) > UINT_MAX))\n\n#define p_realloc_type(pool, mem, type, old_count, new_count) \\\n\t((type *) p_realloc(pool, mem, \\\n\t MALLOC_MULTIPLY((unsigned int)sizeof(type), (old_count)), \\\n\t MALLOC_MULTIPLY((unsigned int)sizeof(type), (new_count))) + \\\n\t\tCOMPILE_ERROR_IF_TRUE(sizeof(type) > UINT_MAX))\n\nstatic inline void * ATTR_MALLOC ATTR_RETURNS_NONNULL\np_malloc(pool_t pool, size_t size)\n{\n\tif (unlikely(size == 0 || size > POOL_MAX_ALLOC_SIZE))\n\t\ti_panic(\"Trying to allocate %zu bytes\", size);\n\n\treturn pool->v->malloc(pool, size);\n}\n\nstatic inline void * ATTR_WARN_UNUSED_RESULT ATTR_RETURNS_NONNULL\np_realloc(pool_t pool, void *mem, size_t old_size, size_t new_size)\n{\n\tif (unlikely(new_size == 0 || new_size > POOL_MAX_ALLOC_SIZE))\n\t\ti_panic(\"Trying to reallocate %zu -> %zu bytes\",\n\t\t\told_size, new_size);\n\n\tif (mem == NULL)\n\t\treturn pool->v->malloc(pool, new_size);\n\n\treturn pool->v->realloc(pool, mem, old_size, new_size);\n}\n\n/* Free the memory. p_free() and p_free_and_null() are now guaranteed to both\n   set mem=NULL, so either one of them can be used. */\n#define p_free(pool, mem) \\\n\tSTMT_START { \\\n\t\tp_free_internal(pool, mem);\t\\\n\t\t(mem) = NULL;\t\t\t\\\n\t} STMT_END\n#define p_free_and_null(pool, mem) p_free(pool, mem)\n\nstatic inline void p_free_internal(pool_t pool, void *mem)\n{\n\tif (mem != NULL)\n\t\tpool->v->free(pool, mem);\n}\n\nstatic inline void p_clear(pool_t pool)\n{\n\tpool->v->clear(pool);\n}\n\nstatic inline size_t p_get_max_easy_alloc_size(pool_t pool)\n{\n\treturn pool->v->get_max_easy_alloc_size(pool);\n}\n\nstatic inline const char *pool_get_name(pool_t pool)\n{\n\treturn pool->v->get_name(pool);\n}\n\nstatic inline void pool_ref(pool_t pool)\n{\n\tpool->v->ref(pool);\n}\n\nstatic inline void pool_unref(pool_t *pool)\n{\n\tif (*pool != NULL)\n\t\t(*pool)->v->unref(pool);\n}\n\n/* These functions are only for pools created with pool_alloconly_create(): */\n\n/* Returns how much memory has been allocated from this pool. */\nsize_t pool_alloconly_get_total_used_size(pool_t pool);\n/* Returns how much system memory has been allocated for this pool. */\nsize_t pool_alloconly_get_total_alloc_size(pool_t pool);\n\n/* Returns how much memory has been allocated from this pool. */\nsize_t pool_allocfree_get_total_used_size(pool_t pool);\n/* Returns how much system memory has been allocated for this pool. */\nsize_t pool_allocfree_get_total_alloc_size(pool_t pool);\n\n/* private: */\nvoid pool_system_free(pool_t pool, void *mem);\n\n#endif\n"}, "42": {"id": 42, "path": "/usr/local/include/dovecot/smtp-address.h", "content": "#ifndef SMTP_ADDRESS_H\n#define SMTP_ADDRESS_H\n\n#include \"array-decl.h\"\n\nstruct message_address;\n\nenum smtp_address_parse_flags {\n\t/* Strictly enforce the RFC 5321 syntax */\n\tSMTP_ADDRESS_PARSE_FLAG_STRICT              = BIT(0),\n\t/* Allow an empty/NULL address */\n\tSMTP_ADDRESS_PARSE_FLAG_ALLOW_EMPTY         = BIT(1),\n\t/* Allow an address without a domain part */\n\tSMTP_ADDRESS_PARSE_FLAG_ALLOW_LOCALPART     = BIT(2),\n\t/* Allow omission of the <...> brackets in a path. This flag is only\n\t   relevant for smtp_address_parse_path(). */\n\tSMTP_ADDRESS_PARSE_FLAG_BRACKETS_OPTIONAL   = BIT(3),\n\t/* Allow localpart to have all kinds of bad unquoted characters by\n\t   parsing the last '@' in the string directly as the localpart/domain\n\t   separator. Addresses starting with `<' or `\"' are parsed as normal.\n\t   The address is rejected when the resulting localpart and domain\n\t   cannot be used to construct a valid RFC 5321 address.\n\t */\n\tSMTP_ADDRESS_PARSE_FLAG_ALLOW_BAD_LOCALPART = BIT(4),\n\t/* Store an unparsed copy of the address in the `raw' field of struct\n\t   smtp_address. When combined with SMTP_ADDRESS_PARSE_FLAG_SKIP_BROKEN,\n\t   the broken address will be stored there. This flag is only relevant\n\t   for smtp_address_parse_path(). */\n\tSMTP_ADDRESS_PARSE_FLAG_PRESERVE_RAW        = BIT(5),\n\t/* Try to skip over a broken address to allow working around syntax\n\t   errors in e.g. the sender address for the MAIL command. This flag is\n\t   only relevant for smtp_address_parse_path*(). The parser will return\n\t   failure, but it will return a broken address which is be equivalent\n\t   to <>. The raw broken address string is available in the address->raw\n\t   field. When the broken address contains control characters or is\n\t   badly delimited, parsing will still fail completely. */\n\tSMTP_ADDRESS_PARSE_FLAG_IGNORE_BROKEN       = BIT(6),\n};\n\nstruct smtp_address {\n\t/* Localpart */\n\tconst char *localpart;\n\t/* Domain */\n\tconst char *domain;\n\t/* Raw, unparsed address. If localpart == NULL, the value of this field\n\t   is syntactically invalid and MUST NOT be used for any purposes that\n\t   may be visible to external systems. It can be e.g. used for logging.\n\t   This is always in mailbox format, meaning that there are no\n\t   surrounding '<' and '>'.\n\t */\n\tconst char *raw;\n};\n\nARRAY_DEFINE_TYPE(smtp_address, struct smtp_address *);\nARRAY_DEFINE_TYPE(smtp_address_const, const struct smtp_address *);\n\n/*\n * SMTP address parsing\n */\n\n\n/* Parse the RFC 5321 address from the provided mailbox string. Returns 0 when\n   the address was parsed successfully and -1 upon error. The address is\n   returned in address_r. When address_r is NULL, the provided string will be\n   verified for validity as a mailbox only. */\nint smtp_address_parse_mailbox(pool_t pool, const char *mailbox,\n\t\t\t       enum smtp_address_parse_flags flags,\n\t\t\t       struct smtp_address **address_r,\n\t\t\t       const char **error_r) ATTR_NULL(4, 5);\n/* Parse the RFC 5321 address from the provided path string. Returns 0 when\n   the address was parsed successfully and -1 upon error. The address is\n   returned in address_r. When address_r is NULL, the provided string will be\n   verified for validity as a path only. The endp_r parameter is used to\n   return a pointer to the end of the path string, so that the caller can\n   continue parsing from there. When the SMTP_ADDRESS_PARSE_FLAG_IGNORE_BROKEN\n   flag is set, a broken address will be returned, even when the return value\n   is -1 (see above). If it is totally broken, *endp_r will be then be NULL.\n */\nint smtp_address_parse_path_full(pool_t pool, const char *path,\n\t\t\t\t enum smtp_address_parse_flags flags,\n\t\t\t\t struct smtp_address **address_r,\n\t\t\t\t const char **error_r, const char **endp_r)\n\t\t\t\t ATTR_NULL(4, 5, 6);\n/* Parse the RFC 5321 address from the provided path string. Returns 0 when\n   the address was parsed successfully and -1 upon error. The address is\n   returned in address_r. When address_r is NULL, the provided string will be\n   verified for validity as a path only. When the\n   SMTP_ADDRESS_PARSE_FLAG_IGNORE_BROKEN flag is set, a broken address will be\n   returned, even when the return value is -1 (see above). */\nint smtp_address_parse_path(pool_t pool, const char *path,\n\t\t\t    enum smtp_address_parse_flags flags,\n\t\t\t    struct smtp_address **address_r,\n\t\t\t    const char **error_r) ATTR_NULL(4, 5);\n/* Parse the RFC 5321 address from the provided username string. A username\n   string is not strictly parsed as an RFC 5321 mailbox; it allows a more\n   lenient syntax. If the address obtained from splitting the string at the last\n   `@' can be encoded back into a valid RFC 5321 mailbox string, parsing the\n   username will succeeded. Returns 0 when the address was parsed successfully\n   and -1 upon error. The address is returned in address_r. When address_r is\n   NULL, the provided string will be verified for validity as a username only.\n */\nint smtp_address_parse_username(pool_t pool, const char *username,\n\t\t\t\tstruct smtp_address **address_r,\n\t\t\t\tconst char **error_r) ATTR_NULL(3, 4);\n\n/* Parse address+detail@domain into address@domain and detail\n   using given delimiters. Returns used delimiter. */\nvoid smtp_address_detail_parse(pool_t pool, const char *delimiters,\n\t\t\t       struct smtp_address *address,\n\t\t\t       const char **username_r, char *delim_r,\n\t\t\t       const char **detail_r);\nvoid smtp_address_detail_parse_temp(const char *delimiters,\n\t\t\t\t    struct smtp_address *address,\n\t\t\t\t    const char **username_r, char *delim_r,\n\t\t\t\t    const char **detail_r);\n\n/* Parse any (possibly broken) address on the input to the best of our ability\n   until end of input or unquoted ` '. Things that are truly evil (unending\n   quoted string, control characters and a path without a closing '>') will\n   still fail and return -1. If the parse was successful, it will return 0.\n   The parsed address string is returned in address_r. Any outer < and > are\n   omitted in the parsed address. The endp_r parameter is used to return a\n   pointer to the end of the path string, so that the caller can continue\n   parsing from there.*/\nint smtp_address_parse_any(const char *in, const char **address_r,\n\t\t\t   const char **endp_r) ATTR_NULL(2, 3);\n\n/*\n * SMTP address construction\n */\n\nvoid smtp_address_write(string_t *out, const struct smtp_address *address)\n\t\t\tATTR_NULL(2);\nvoid smtp_address_write_path(string_t *out, const struct smtp_address *address)\n\t\t\tATTR_NULL(2);\n\nconst char *smtp_address_encode(const struct smtp_address *address)\n\t\t\t\tATTR_NULL(1);\nconst char *smtp_address_encode_path(const struct smtp_address *address)\n\t\t\t\t     ATTR_NULL(1);\n\nconst char *\nsmtp_address_encode_raw(const struct smtp_address *address) ATTR_NULL(1);\nconst char *\nsmtp_address_encode_raw_path(const struct smtp_address *address) ATTR_NULL(1);\n\n/*\n * SMTP address manipulation\n */\n\nvoid smtp_address_init(struct smtp_address *address,\n\t\t       const char *localpart, const char *domain)\n\t\t       ATTR_NULL(2,3);\nint smtp_address_init_from_msg(struct smtp_address *address,\n\t\t\t       const struct message_address *msg_addr);\n\nstruct smtp_address *\nsmtp_address_clone(pool_t pool, const struct smtp_address *address)\n\t\t   ATTR_NULL(2);\nstruct smtp_address *\nsmtp_address_create(pool_t pool, const char *localpart, const char *domain)\n\t\t    ATTR_NULL(2, 3);\nint smtp_address_create_from_msg(pool_t pool,\n\t\t\t\t const struct message_address *msg_addr,\n\t\t\t\t struct smtp_address **address_r);\n\nstruct smtp_address *\nsmtp_address_clone_temp(const struct smtp_address *address) ATTR_NULL(1);\nstruct smtp_address *\nsmtp_address_create_temp(const char *localpart, const char *domain)\n\t\t\t ATTR_NULL(2, 3);\nint smtp_address_create_from_msg_temp(const struct message_address *msg_addr,\n\t\t\t\t      struct smtp_address **address_r);\n\nstruct smtp_address *\nsmtp_address_add_detail(pool_t pool, const struct smtp_address *address,\n\t\t\tconst char *detail, char delim_c);\nstruct smtp_address *\nsmtp_address_add_detail_temp(const struct smtp_address *address,\n\t\t\t     const char *detail, char delim_c);\n\nint smtp_address_cmp(const struct smtp_address *address1,\n\t\t     const struct smtp_address *address2) ATTR_NULL(1, 2);\nint smtp_address_cmp_icase(const struct smtp_address *address1,\n\t\t\t  const struct smtp_address *address2) ATTR_NULL(1, 2);\n\nstatic inline bool ATTR_NULL(1, 2)\nsmtp_address_equals(const struct smtp_address *address1,\n\t\t    const struct smtp_address *address2)\n{\n\treturn (smtp_address_cmp(address1, address2) == 0);\n}\nstatic inline bool ATTR_NULL(1, 2)\nsmtp_address_equals_icase(const struct smtp_address *address1,\n\t\t\t  const struct smtp_address *address2)\n{\n\treturn (smtp_address_cmp_icase(address1, address2) == 0);\n}\n\nstatic inline bool ATTR_NULL(1) ATTR_PURE\nsmtp_address_isnull(const struct smtp_address *address)\n{\n\treturn (address == NULL || address->localpart == NULL);\n}\n\nstatic inline bool ATTR_NULL(1) ATTR_PURE\nsmtp_address_is_broken(const struct smtp_address *address)\n{\n\treturn (address != NULL &&\n\t\tsmtp_address_isnull(address) &&\n\t\t(address->raw != NULL && *address->raw != '\\0'));\n}\n\n#endif\n"}, "43": {"id": 43, "path": "/usr/local/include/dovecot/str-sanitize.h", "content": "#ifndef STR_SANITIZE_H\n#define STR_SANITIZE_H\n\n/* All control characters in src will be appended as '?'. If src is longer\n   than max_bytes, it's truncated with \"...\" appended to the end. Note that\n   src is treated as UTF-8 input, but max_bytes is in bytes instead of\n   UTF-8 characters. */\nvoid str_sanitize_append(string_t *dest, const char *src, size_t max_bytes);\n/* All control characters in src will be appended as the unicode replacement\n   character (U+FFFD). If src has more than max_cps unicode code points, it's\n   truncated with a horizontal ellipsis character (U+2026) appended to the end.\n */\nvoid str_sanitize_append_utf8(string_t *dest, const char *src,\n\t\t\t      uintmax_t max_cps);\n/* Return src sanitized. If there are no changes, src pointer is returned.\n   If src is NULL, returns NULL. */\nconst char *str_sanitize(const char *src, size_t max_bytes);\n/* The unicode version of str_sanitize() using str_sanitize_append_utf8()\n   internally. */\nconst char *str_sanitize_utf8(const char *src, uintmax_t max_cps);\n\n#endif\n"}, "44": {"id": 44, "path": "/usr/local/include/dovecot/str.h", "content": "#ifndef STR_H\n#define STR_H\n\n#include \"buffer.h\"\n\nstring_t *str_new(pool_t pool, size_t initial_size);\nstring_t *t_str_new(size_t initial_size);\n/* Allocate a constant string using the given str as the input data.\n   str pointer is saved directly, so it must not be freed until the returned\n   string is no longer used. len must contain strlen(str). */\nstring_t *str_new_const(pool_t pool, const char *str, size_t len);\nstring_t *t_str_new_const(const char *str, size_t len);\nvoid str_free(string_t **str);\nchar *str_free_without_data(string_t **str);\n\nconst char *str_c(string_t *str);\nchar *str_c_modifiable(string_t *str);\nbool str_equals(const string_t *str1, const string_t *str2) ATTR_PURE;\n\nstatic inline const unsigned char *str_data(const string_t *str)\n{\n\treturn (const unsigned char*)str->data;\n}\nstatic inline size_t str_len(const string_t *str)\n{\n\treturn str->used;\n}\n\n/* Append NUL-terminated string. If the trailing NUL isn't found earlier,\n   append a maximum of max_len characters. */\nvoid str_append_max(string_t *str, const char *cstr, size_t max_len);\n\nstatic inline void str_append(string_t *str, const char *cstr)\n{\n\tbuffer_append(str, cstr, strlen(cstr));\n}\nstatic inline void str_append_data(string_t *str, const void *data, size_t len)\n{\n\tbuffer_append(str, data, len);\n}\n\nstatic inline void str_append_c(string_t *str, unsigned char chr)\n{\n\tbuffer_append_c(str, chr);\n}\n\nstatic inline void str_append_str(string_t *dest, const string_t *src)\n{\n\tbuffer_append(dest, src->data, src->used);\n}\n\n/* Append printf()-like data */\nvoid str_printfa(string_t *str, const char *fmt, ...)\n\tATTR_FORMAT(2, 3);\nvoid str_vprintfa(string_t *str, const char *fmt, va_list args)\n\tATTR_FORMAT(2, 0);\n\nstatic inline void str_insert(string_t *str, size_t pos, const char *cstr)\n{\n\tbuffer_insert(str, pos, cstr, strlen(cstr));\n}\n\nstatic inline void str_delete(string_t *str, size_t pos, size_t len)\n{\n\tbuffer_delete(str, pos, len);\n}\n\nstatic inline void str_replace(string_t *str, size_t pos, size_t len,\n\t\t\t       const char *cstr)\n{\n\tbuffer_replace(str, pos, len, cstr, strlen(cstr));\n}\n\n/* Truncate the string to specified length. If it's already smaller,\n   do nothing. */\nstatic inline void str_truncate(string_t *str, size_t len)\n{\n\tif (str_len(str) > len)\n\t\tbuffer_set_used_size(str, len);\n}\n\n/* Truncate the string to specified length, but also make sure the truncation\n   doesn't happen in the middle of an UTF-8 character sequence. In that case,\n   the string will end up being up to a few bytes smaller than len. If it's\n   already smaller to begin with, do nothing. */\nvoid str_truncate_utf8(string_t *str, size_t len);\n\n#endif\n"}, "45": {"id": 45, "path": "/usr/local/include/dovecot/strfuncs.h", "content": "#ifndef STRFUNC_H\n#define STRFUNC_H\n\n/* Maximum number of bytes needed for the largest uintmax_t or the lowest\n   intmax_t number in base 10. This value includes the trailing \\0. */\n#define MAX_INT_STRLEN ((sizeof(uintmax_t) * CHAR_BIT + 2) / 3 + 1)\n\nextern const unsigned char uchar_nul; /* (const unsigned char *)\"\" */\nextern const unsigned char *uchar_empty_ptr; /* non-NULL pointer that shouldn't be dereferenced. */\n\n/* Returns -1 if dest wasn't large enough, 0 if not. */\nint i_snprintf(char *dest, size_t max_chars, const char *format, ...)\n\tATTR_FORMAT(3, 4);\n\nchar *p_strdup(pool_t pool, const char *str) ATTR_MALLOC;\nvoid *p_memdup(pool_t pool, const void *data, size_t size) ATTR_MALLOC;\n/* return NULL if str = \"\" */\nchar *p_strdup_empty(pool_t pool, const char *str) ATTR_MALLOC;\n/* *end isn't included */\nchar *p_strdup_until(pool_t pool, const void *start, const void *end)\n\tATTR_MALLOC ATTR_RETURNS_NONNULL;\nchar *p_strndup(pool_t pool, const void *str, size_t max_chars) ATTR_MALLOC;\nchar *p_strdup_printf(pool_t pool, const char *format, ...)\n\tATTR_FORMAT(2, 3) ATTR_MALLOC ATTR_RETURNS_NONNULL;\nchar *p_strdup_vprintf(pool_t pool, const char *format, va_list args)\n\tATTR_FORMAT(2, 0) ATTR_MALLOC ATTR_RETURNS_NONNULL;\nchar *p_strconcat(pool_t pool, const char *str1, ...)\n\tATTR_SENTINEL ATTR_MALLOC;\n\n/* same with temporary memory allocations: */\nconst char *t_strdup(const char *str) ATTR_MALLOC;\nchar *t_strdup_noconst(const char *str) ATTR_MALLOC;\n/* return NULL if str = \"\" */\nconst char *t_strdup_empty(const char *str) ATTR_MALLOC;\n/* *end isn't included */\nconst char *t_strdup_until(const void *start, const void *end)\n\tATTR_MALLOC ATTR_RETURNS_NONNULL;\nconst char *t_strndup(const void *str, size_t max_chars) ATTR_MALLOC;\nconst char *t_strdup_printf(const char *format, ...)\n\tATTR_FORMAT(1, 2) ATTR_MALLOC ATTR_RETURNS_NONNULL;\nconst char *t_strdup_vprintf(const char *format, va_list args)\n\tATTR_FORMAT(1, 0) ATTR_MALLOC ATTR_RETURNS_NONNULL;\nconst char *t_strconcat(const char *str1, ...)\n\tATTR_SENTINEL ATTR_MALLOC;\n\n/* Like t_strdup(), but stop at cutchar. */\nconst char *t_strcut(const char *str, char cutchar);\n/* Replace all from->to chars in the string. */\nconst char *t_str_replace(const char *str, char from, char to);\n/* Put the string on a single line by replacing all newlines with spaces and\n   dropping any carriage returns. Sequences of several newlines are merged into\n   one space and newlines at the beginning and end of the string are dropped. */\nconst char *t_str_oneline(const char *str);\n\n/* Like strlcpy(), but return -1 if buffer was overflown, 0 if not. */\nint i_strocpy(char *dest, const char *src, size_t dstsize);\n\nchar *str_ucase(char *str);\nchar *str_lcase(char *str);\nconst char *t_str_lcase(const char *str);\nconst char *t_str_ucase(const char *str);\n\n/* Return pointer to first matching needle */\nconst char *i_strstr_arr(const char *haystack, const char *const *needles);\n\n/* Trim matching chars from either side of the string */\nconst char *t_str_trim(const char *str, const char *chars);\nconst char *p_str_trim(pool_t pool, const char *str, const char *chars);\nconst char *str_ltrim(const char *str, const char *chars);\nconst char *t_str_ltrim(const char *str, const char *chars);\nconst char *p_str_ltrim(pool_t pool, const char *str, const char *chars);\nconst char *t_str_rtrim(const char *str, const char *chars);\nconst char *p_str_rtrim(pool_t pool, const char *str, const char *chars);\n\nint null_strcmp(const char *s1, const char *s2) ATTR_PURE;\nint null_strcasecmp(const char *s1, const char *s2) ATTR_PURE;\nint i_memcasecmp(const void *p1, const void *p2, size_t size) ATTR_PURE;\nint i_strcmp_p(const char *const *p1, const char *const *p2) ATTR_PURE;\nint i_strcasecmp_p(const char *const *p1, const char *const *p2) ATTR_PURE;\n/* Returns TRUE if the two memory areas are equal. This function is safe\n   against timing attacks, so it compares all the bytes every time. */\nbool mem_equals_timing_safe(const void *p1, const void *p2, size_t size);\n/* Returns TRUE if the two strings are equal. Similar to\n   mem_equals_timing_safe() this function is safe against timing attacks when\n   the string lengths are the same. If not, the length of the secret string may\n   be leaked, but otherwise the contents won't be. */\nbool str_equals_timing_almost_safe(const char *s1, const char *s2);\n\nsize_t str_match(const char *p1, const char *p2) ATTR_PURE;\nstatic inline ATTR_PURE bool str_begins(const char *haystack, const char *needle)\n{\n\treturn needle[str_match(haystack, needle)] == '\\0';\n}\n#if defined(__GNUC__) && (__GNUC__ >= 2)\n/* GCC (and Clang) are known to have a compile-time strlen(\"literal\") shortcut, and\n   an optimised strncmp(), so use that by default. Macro is multi-evaluation safe. */\n# define str_begins(h, n) (__builtin_constant_p(n) ? strncmp((h), (n), strlen(n))==0 : (str_begins)((h), (n)))\n#endif\n\nstatic inline char *i_strchr_to_next(const char *str, char chr)\n{\n\tchar *tmp = (char *)strchr(str, chr);\n\treturn tmp == NULL ? NULL : tmp+1;\n}\n\n/* separators is an array of separator characters, not a separator string.\n   an empty data string results in an array containing only NULL. */\nchar **p_strsplit(pool_t pool, const char *data, const char *separators)\n\tATTR_MALLOC ATTR_RETURNS_NONNULL;\nconst char **t_strsplit(const char *data, const char *separators)\n\tATTR_MALLOC ATTR_RETURNS_NONNULL;\n/* like p_strsplit(), but treats multiple adjacent separators as a single\n   separator. separators at the beginning or at the end of the string are also\n   ignored, so it's not possible for the result to have any empty strings. */\nchar **p_strsplit_spaces(pool_t pool, const char *data, const char *separators)\n\tATTR_MALLOC ATTR_RETURNS_NONNULL;\nconst char **t_strsplit_spaces(const char *data, const char *separators)\n\tATTR_MALLOC ATTR_RETURNS_NONNULL;\nvoid p_strsplit_free(pool_t pool, char **arr);\n\nconst char *dec2str(uintmax_t number);\n/* Use the given buffer to write out the number. Returns pointer to the\n   written number in the buffer. Note that this isn't the same as the beginning\n   of the buffer. */\nchar *dec2str_buf(char buffer[STATIC_ARRAY MAX_INT_STRLEN], uintmax_t number);\n\n/* Return length of NULL-terminated list string array */\nunsigned int str_array_length(const char *const *arr) ATTR_PURE;\n/* Return all strings from array joined into one string. */\nconst char *t_strarray_join(const char *const *arr, const char *separator)\n\tATTR_MALLOC ATTR_RETURNS_NONNULL;\n/* Removes a value from NULL-terminated string array. Returns TRUE if found. */\nbool str_array_remove(const char **arr, const char *value);\n/* Returns TRUE if value exists in NULL-terminated string array. */\nbool str_array_find(const char *const *arr, const char *value);\n/* Like str_array_find(), but use strcasecmp(). */\nbool str_array_icase_find(const char *const *arr, const char *value);\n/* Duplicate array of strings. The memory can be freed by freeing the\n   return value. */\nconst char **p_strarray_dup(pool_t pool, const char *const *arr)\n\tATTR_MALLOC ATTR_RETURNS_NONNULL;\n\n/* Join ARRAY_TYPE(const_string) to a string, similar to t_strarray_join() */\nchar *p_array_const_string_join(pool_t pool, const ARRAY_TYPE(const_string) *arr,\n\t\t\t\tconst char *separator);\n#define t_array_const_string_join(arr, separator) \\\n\t((const char *)p_array_const_string_join(unsafe_data_stack_pool, arr, separator))\n\n/* INTERNAL */\nchar *t_noalloc_strdup_vprintf(const char *format, va_list args,\n\t\t\t       unsigned int *size_r)\n\tATTR_FORMAT(1, 0) ATTR_RETURNS_NONNULL;\nchar *vstrconcat(const char *str1, va_list args, size_t *ret_len) ATTR_MALLOC;\n\n#endif\n"}, "46": {"id": 46, "path": "/usr/local/include/dovecot/strnum.h", "content": "#ifndef STRNUM_H\n#define STRNUM_H\n\n/* str_to_*() functions return 0 if string is nothing more than a valid number\n   in valid range. Otherwise -1 is returned and num_r is left untouched\n\n   str_parse_*() helpers do not require the number to be the entire string\n   and pass back the pointer just past a valid parsed integer in endp_r if\n   it is non-NULL. What is written to endp_r in error cases is undefined.\n*/\n\n/*\n * Unsigned decimal\n */\n\nint str_to_uint(const char *str, unsigned int *num_r)\n\tATTR_WARN_UNUSED_RESULT;\nint str_parse_uint(const char *str, unsigned int *num_r,\n\tconst char **endp_r) ATTR_WARN_UNUSED_RESULT ATTR_NULL(3);\n\nint str_to_ulong(const char *str, unsigned long *num_r)\n\tATTR_WARN_UNUSED_RESULT;\nint str_parse_ulong(const char *str, unsigned long *num_r,\n\tconst char **endp_r) ATTR_WARN_UNUSED_RESULT ATTR_NULL(3);\n\nint str_to_ullong(const char *str, unsigned long long *num_r)\n\tATTR_WARN_UNUSED_RESULT;\nint str_parse_ullong(const char *str, unsigned long long *num_r,\n\tconst char **endp_r) ATTR_WARN_UNUSED_RESULT ATTR_NULL(3);\n\nint str_to_uint32(const char *str, uint32_t *num_r)\n\tATTR_WARN_UNUSED_RESULT;\nint str_parse_uint32(const char *str, uint32_t *num_r,\n\tconst char **endp_r) ATTR_WARN_UNUSED_RESULT ATTR_NULL(3);\n\nint str_to_uint64(const char *str, uint64_t *num_r)\n\tATTR_WARN_UNUSED_RESULT;\nint str_parse_uint64(const char *str, uint64_t *num_r,\n\tconst char **endp_r) ATTR_WARN_UNUSED_RESULT ATTR_NULL(3);\n\nint str_to_uintmax(const char *str, uintmax_t *num_r)\n\tATTR_WARN_UNUSED_RESULT;\nint str_parse_uintmax(const char *str, uintmax_t *num_r,\n\tconst char **endp_r) ATTR_WARN_UNUSED_RESULT ATTR_NULL(3);\n\n/* Returns TRUE if str is a valid unsigned number that equals to num. */\nbool str_uint_equals(const char *str, uintmax_t num);\n\n/*\n * Unsigned hexadecimal\n */\n\nint str_to_uint_hex(const char *str, unsigned int *num_r)\n\tATTR_WARN_UNUSED_RESULT;\nint str_parse_uint_hex(const char *str, unsigned int *num_r,\n\tconst char **endp_r) ATTR_WARN_UNUSED_RESULT ATTR_NULL(3);\n\nint str_to_ulong_hex(const char *str, unsigned long *num_r)\n\tATTR_WARN_UNUSED_RESULT;\nint str_parse_ulong_hex(const char *str, unsigned long *num_r,\n\tconst char **endp_r) ATTR_WARN_UNUSED_RESULT ATTR_NULL(3);\n\nint str_to_ullong_hex(const char *str, unsigned long long *num_r)\n\tATTR_WARN_UNUSED_RESULT;\nint str_parse_ullong_hex(const char *str, unsigned long long *num_r,\n\tconst char **endp_r) ATTR_WARN_UNUSED_RESULT ATTR_NULL(3);\n\nint str_to_uint32_hex(const char *str, uint32_t *num_r)\n\tATTR_WARN_UNUSED_RESULT;\nint str_parse_uint32_hex(const char *str, uint32_t *num_r,\n\tconst char **endp_r) ATTR_WARN_UNUSED_RESULT ATTR_NULL(3);\n\nint str_to_uint64_hex(const char *str, uint64_t *num_r)\n\tATTR_WARN_UNUSED_RESULT;\nint str_parse_uint64_hex(const char *str, uint64_t *num_r,\n\tconst char **endp_r) ATTR_WARN_UNUSED_RESULT ATTR_NULL(3);\n\nint str_to_uintmax_hex(const char *str, uintmax_t *num_r)\n\tATTR_WARN_UNUSED_RESULT;\nint str_parse_uintmax_hex(const char *str, uintmax_t *num_r,\n\tconst char **endp_r) ATTR_WARN_UNUSED_RESULT ATTR_NULL(3);\n\n/*\n * Unsigned octal\n */\n\nint str_to_uint_oct(const char *str, unsigned int *num_r)\n\tATTR_WARN_UNUSED_RESULT;\nint str_parse_uint_oct(const char *str, unsigned int *num_r,\n\tconst char **endp_r) ATTR_WARN_UNUSED_RESULT ATTR_NULL(3);\n\nint str_to_ulong_oct(const char *str, unsigned long *num_r)\n\tATTR_WARN_UNUSED_RESULT;\nint str_parse_ulong_oct(const char *str, unsigned long *num_r,\n\tconst char **endp_r) ATTR_WARN_UNUSED_RESULT ATTR_NULL(3);\n\nint str_to_ullong_oct(const char *str, unsigned long long *num_r)\n\tATTR_WARN_UNUSED_RESULT;\nint str_parse_ullong_oct(const char *str, unsigned long long *num_r,\n\tconst char **endp_r) ATTR_WARN_UNUSED_RESULT ATTR_NULL(3);\n\nint str_to_uint32_oct(const char *str, uint32_t *num_r)\n\tATTR_WARN_UNUSED_RESULT;\nint str_parse_uint32_oct(const char *str, uint32_t *num_r,\n\tconst char **endp_r) ATTR_WARN_UNUSED_RESULT ATTR_NULL(3);\n\nint str_to_uint64_oct(const char *str, uint64_t *num_r)\n\tATTR_WARN_UNUSED_RESULT;\nint str_parse_uint64_oct(const char *str, uint64_t *num_r,\n\tconst char **endp_r) ATTR_WARN_UNUSED_RESULT ATTR_NULL(3);\n\nint str_to_uintmax_oct(const char *str, uintmax_t *num_r)\n\tATTR_WARN_UNUSED_RESULT;\nint str_parse_uintmax_oct(const char *str, uintmax_t *num_r,\n\tconst char **endp_r) ATTR_WARN_UNUSED_RESULT ATTR_NULL(3);\n\n/*\n * Signed\n */\n\nint str_to_int(const char *str, int *num_r)\n\tATTR_WARN_UNUSED_RESULT;\nint str_parse_int(const char *str, int *num_r,\n\tconst char **endp_r) ATTR_WARN_UNUSED_RESULT ATTR_NULL(3);\n\nint str_to_long(const char *str, long *num_r)\n\tATTR_WARN_UNUSED_RESULT;\nint str_parse_long(const char *str, long *num_r,\n\tconst char **endp_r) ATTR_WARN_UNUSED_RESULT ATTR_NULL(3);\n\nint str_to_llong(const char *str, long long *num_r)\n\tATTR_WARN_UNUSED_RESULT;\nint str_parse_llong(const char *str, long long *num_r,\n\tconst char **endp_r) ATTR_WARN_UNUSED_RESULT ATTR_NULL(3);\n\nint str_to_int32(const char *str, int32_t *num_r)\n\tATTR_WARN_UNUSED_RESULT;\nint str_parse_int32(const char *str, int32_t *num_r,\n\tconst char **endp_r) ATTR_WARN_UNUSED_RESULT ATTR_NULL(3);\n\nint str_to_int64(const char *str, int64_t *num_r)\n\tATTR_WARN_UNUSED_RESULT;\nint str_parse_int64(const char *str, int64_t *num_r,\n\tconst char **endp_r) ATTR_WARN_UNUSED_RESULT ATTR_NULL(3);\n\nint str_to_intmax(const char *str, intmax_t *num_r)\n\tATTR_WARN_UNUSED_RESULT;\nint str_parse_intmax(const char *str, intmax_t *num_r,\n\tconst char **endp_r) ATTR_WARN_UNUSED_RESULT ATTR_NULL(3);\n\n/*\n * Special numeric types\n */\n\nint str_to_uid(const char *str, uid_t *num_r)\n\tATTR_WARN_UNUSED_RESULT;\n\nint str_to_gid(const char *str, gid_t *num_r)\n\tATTR_WARN_UNUSED_RESULT;\n\nint str_to_pid(const char *str, pid_t *num_r)\n\tATTR_WARN_UNUSED_RESULT;\n\nint str_to_ino(const char *str, ino_t *num_r)\n\tATTR_WARN_UNUSED_RESULT;\n\nint str_to_uoff(const char *str, uoff_t *num_r)\n\tATTR_WARN_UNUSED_RESULT;\nint str_parse_uoff(const char *str, uoff_t *num_r,\n\tconst char **endp_r) ATTR_WARN_UNUSED_RESULT ATTR_NULL(3);\n\nint str_to_time(const char *str, time_t *num_r)\n\tATTR_WARN_UNUSED_RESULT;\n\n/*\n * Utility\n */\n\n/* Return TRUE if all characters in string are numbers.\n   Stop when `end_char' is found from string. */\nbool str_is_numeric(const char *str, char end_char) ATTR_PURE;\n\n/* Return TRUE when string has one or more numbers, followed\n   with zero or one dot, followed with at least one number. */\nbool str_is_float(const char *str, char end_char) ATTR_PURE;\n\n/* Returns human readable string about what is wrong with the string.\n   This function assumes that str_to_*() had already returned -1 for the\n   string. */\nconst char *str_num_error(const char *str);\n\n#endif\n"}}, "reports": [{"events": [{"location": {"col": 1, "file": 0, "line": 1}, "message": "header is missing header guard"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/pigeonhole-config.h", "reportHash": "a7d6408616868b17fe1475f2e9660b96", "checkerName": "llvm-header-guard", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 9, "file": 1, "line": 1}, "message": "_HOME_RUNNER_WORK_TESTCC_TESTCC_RETDEC_PIGEONHOLE_VERSION_H (fixit)"}, {"location": {"col": 9, "file": 1, "line": 1}, "message": "header guard does not follow preferred style"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/pigeonhole-version.h", "reportHash": "9a4fa842eddcddf0af1925f679d9eecc", "checkerName": "llvm-header-guard", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 10, "file": 2, "line": 7}, "message": "\"sieve-code.h\" (fixit)"}, {"location": {"col": 1, "file": 2, "line": 7}, "message": "#includes are not sorted properly"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/src/lib-sieve/plugins/ihave/cmd-error.c", "reportHash": "de89614da2024a1aa893d0beae732bf9", "checkerName": "llvm-include-order", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 10, "file": 2, "line": 11}, "message": "\"sieve-binary.h\" (fixit)"}, {"location": {"col": 1, "file": 2, "line": 11}, "message": "#includes are not sorted properly"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/src/lib-sieve/plugins/ihave/cmd-error.c", "reportHash": "2679d5c507429540ef1ee2459d55b4a9", "checkerName": "llvm-include-order", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 13, "file": 2, "line": 80}, "message": "the definition seen here"}, {"location": {"col": 13, "file": 2, "line": 28}, "message": "differing parameters are named here: ('ctx'), in definition: ('cmd')"}, {"location": {"col": 13, "file": 2, "line": 28}, "message": "function 'cmd_error_generate' has a definition with different parameter names"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/src/lib-sieve/plugins/ihave/cmd-error.c", "reportHash": "d436cca97112d6f7809211760f991f2e", "checkerName": "readability-inconsistent-declaration-parameter-name", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 34, "file": 2, "line": 51}, "message": "initializing non-local variable with non-const expression depending on uninitialized non-local variable 'ihave_extension'"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/src/lib-sieve/plugins/ihave/cmd-error.c", "reportHash": "cf1756f9d1d22c366718ddcd46665423", "checkerName": "cppcoreguidelines-interfaces-global-init", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 85, "file": 2, "line": 118}, "message": "{ (fixit)"}, {"location": {"col": 77, "file": 2, "line": 118}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/src/lib-sieve/plugins/ihave/cmd-error.c", "reportHash": "f7f172df52a59525328723ed6e381340", "checkerName": "google-readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 9, "file": 3, "line": 1}, "message": "_HOME_RUNNER_WORK_TESTCC_TESTCC_RETDEC_SRC_LIB_SIEVE_PLUGINS_IHAVE_EXT_IHAVE_COMMON_H (fixit)"}, {"location": {"col": 9, "file": 3, "line": 1}, "message": "header guard does not follow preferred style"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/src/lib-sieve/plugins/ihave/ext-ihave-common.h", "reportHash": "2985b9f8a3e45adfe668d1feea1f1b54", "checkerName": "llvm-header-guard", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 9, "file": 4, "line": 1}, "message": "_HOME_RUNNER_WORK_TESTCC_TESTCC_RETDEC_SRC_LIB_SIEVE_SIEVE_ADDRESS_SOURCE_H (fixit)"}, {"location": {"col": 9, "file": 4, "line": 1}, "message": "header guard does not follow preferred style"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/src/lib-sieve/sieve-address-source.h", "reportHash": "5074435fca5ecf127190bf0390d27d7c", "checkerName": "llvm-header-guard", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 9, "file": 5, "line": 1}, "message": "_HOME_RUNNER_WORK_TESTCC_TESTCC_RETDEC_SRC_LIB_SIEVE_SIEVE_AST_H (fixit)"}, {"location": {"col": 9, "file": 5, "line": 1}, "message": "header guard does not follow preferred style"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/src/lib-sieve/sieve-ast.h", "reportHash": "4046413d6922a464c5a6381492d0ccc5", "checkerName": "llvm-header-guard", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 9, "file": 6, "line": 1}, "message": "_HOME_RUNNER_WORK_TESTCC_TESTCC_RETDEC_SRC_LIB_SIEVE_SIEVE_BINARY_DUMPER_H (fixit)"}, {"location": {"col": 9, "file": 6, "line": 1}, "message": "header guard does not follow preferred style"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/src/lib-sieve/sieve-binary-dumper.h", "reportHash": "65389818a545568ae5b1cdd65c55484c", "checkerName": "llvm-header-guard", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 9, "file": 7, "line": 1}, "message": "_HOME_RUNNER_WORK_TESTCC_TESTCC_RETDEC_SRC_LIB_SIEVE_SIEVE_BINARY_H (fixit)"}, {"location": {"col": 9, "file": 7, "line": 1}, "message": "header guard does not follow preferred style"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/src/lib-sieve/sieve-binary.h", "reportHash": "2398bc4869597f640c3d34878638ab50", "checkerName": "llvm-header-guard", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 68, "file": 7, "line": 225}, "message": "{ (fixit)"}, {"location": {"col": 60, "file": 7, "line": 225}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/src/lib-sieve/sieve-binary.h", "reportHash": "b6512a07047c995b37fc3aa531f37204", "checkerName": "readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 30, "file": 7, "line": 227}, "message": "{ (fixit)"}, {"location": {"col": 22, "file": 7, "line": 227}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/src/lib-sieve/sieve-binary.h", "reportHash": "c3bd5357c232db6c5b52558277adf5cc", "checkerName": "google-readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 9, "file": 8, "line": 1}, "message": "_HOME_RUNNER_WORK_TESTCC_TESTCC_RETDEC_SRC_LIB_SIEVE_SIEVE_CODE_DUMPER_H (fixit)"}, {"location": {"col": 9, "file": 8, "line": 1}, "message": "header guard does not follow preferred style"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/src/lib-sieve/sieve-code-dumper.h", "reportHash": "d6bd794c9ed25a8f2839c1def8b4765e", "checkerName": "llvm-header-guard", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 9, "file": 9, "line": 1}, "message": "_HOME_RUNNER_WORK_TESTCC_TESTCC_RETDEC_SRC_LIB_SIEVE_SIEVE_CODE_H (fixit)"}, {"location": {"col": 9, "file": 9, "line": 1}, "message": "header guard does not follow preferred style"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/src/lib-sieve/sieve-code.h", "reportHash": "ff177232b1ae0dd6c14cecf11962d155", "checkerName": "llvm-header-guard", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 10, "file": 9, "line": 4}, "message": "\"array.h\" (fixit)"}, {"location": {"col": 1, "file": 9, "line": 4}, "message": "#includes are not sorted properly"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/src/lib-sieve/sieve-code.h", "reportHash": "f64ad9db98a7ed20a0157875de769dcd", "checkerName": "llvm-include-order", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 10, "file": 9, "line": 10}, "message": "\"sieve-dump.h\" (fixit)"}, {"location": {"col": 1, "file": 9, "line": 10}, "message": "#includes are not sorted properly"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/src/lib-sieve/sieve-code.h", "reportHash": "660ed2d3dbeab2372ca47c27857cf0e8", "checkerName": "llvm-include-order", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 84, "file": 9, "line": 78}, "message": "{ (fixit)"}, {"location": {"col": 76, "file": 9, "line": 78}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/src/lib-sieve/sieve-code.h", "reportHash": "c3d2f8b2dc9dbf62e5fc20fbc21546e1", "checkerName": "hicpp-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 83, "file": 9, "line": 91}, "message": "{ (fixit)"}, {"location": {"col": 75, "file": 9, "line": 91}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/src/lib-sieve/sieve-code.h", "reportHash": "bda69c89b3f5cdf3b22b8d1739e89bb1", "checkerName": "google-readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 9, "file": 10, "line": 1}, "message": "_HOME_RUNNER_WORK_TESTCC_TESTCC_RETDEC_SRC_LIB_SIEVE_SIEVE_COMMANDS_H (fixit)"}, {"location": {"col": 9, "file": 10, "line": 1}, "message": "header guard does not follow preferred style"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/src/lib-sieve/sieve-commands.h", "reportHash": "163442712568238b3f34f44327920737", "checkerName": "llvm-header-guard", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 10, "file": 10, "line": 6}, "message": "\"sieve-ast.h\" (fixit)"}, {"location": {"col": 1, "file": 10, "line": 6}, "message": "#includes are not sorted properly"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/src/lib-sieve/sieve-commands.h", "reportHash": "5d9bf92c860ab0f2dd7f013e1322ebc7", "checkerName": "llvm-include-order", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 34, "file": 10, "line": 15}, "message": "use of a signed integer operand with a binary bitwise operator"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/src/lib-sieve/sieve-commands.h", "reportHash": "23bc3178eed739dd704aa90d337fbf7a", "checkerName": "hicpp-signed-bitwise", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 9, "file": 11, "line": 1}, "message": "_HOME_RUNNER_WORK_TESTCC_TESTCC_RETDEC_SRC_LIB_SIEVE_SIEVE_COMMON_H (fixit)"}, {"location": {"col": 9, "file": 11, "line": 1}, "message": "header guard does not follow preferred style"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/src/lib-sieve/sieve-common.h", "reportHash": "9fddbb442979f2c54130baeca3f0a712", "checkerName": "llvm-header-guard", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 9, "file": 12, "line": 1}, "message": "_HOME_RUNNER_WORK_TESTCC_TESTCC_RETDEC_SRC_LIB_SIEVE_SIEVE_CONFIG_H (fixit)"}, {"location": {"col": 9, "file": 12, "line": 1}, "message": "header guard does not follow preferred style"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/src/lib-sieve/sieve-config.h", "reportHash": "edef28166152daf5926a38cc6bbc0a8d", "checkerName": "llvm-header-guard", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 9, "file": 13, "line": 1}, "message": "_HOME_RUNNER_WORK_TESTCC_TESTCC_RETDEC_SRC_LIB_SIEVE_SIEVE_DUMP_H (fixit)"}, {"location": {"col": 9, "file": 13, "line": 1}, "message": "header guard does not follow preferred style"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/src/lib-sieve/sieve-dump.h", "reportHash": "8f772e03dbfbf55c1e7949f0bbbac8d8", "checkerName": "llvm-header-guard", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 10, "file": 13, "line": 4}, "message": "\"sieve-binary-dumper.h\" (fixit)"}, {"location": {"col": 1, "file": 13, "line": 4}, "message": "#includes are not sorted properly"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/src/lib-sieve/sieve-dump.h", "reportHash": "e167245abad206f42937731d1bc125c1", "checkerName": "llvm-include-order", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 9, "file": 14, "line": 1}, "message": "_HOME_RUNNER_WORK_TESTCC_TESTCC_RETDEC_SRC_LIB_SIEVE_SIEVE_ERROR_H (fixit)"}, {"location": {"col": 9, "file": 14, "line": 1}, "message": "header guard does not follow preferred style"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/src/lib-sieve/sieve-error.h", "reportHash": "a5d8721669ed9855c294d1ec92bfb288", "checkerName": "llvm-header-guard", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 10, "file": 14, "line": 4}, "message": "\"compat.h\" (fixit)"}, {"location": {"col": 1, "file": 14, "line": 4}, "message": "#includes are not sorted properly"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/src/lib-sieve/sieve-error.h", "reportHash": "22eb97f4d8733cc0cfb781554815e8a1", "checkerName": "llvm-include-order", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 29, "file": 14, "line": 24}, "message": "use of a signed integer operand with a binary bitwise operator"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/src/lib-sieve/sieve-error.h", "reportHash": "94f2817c1c8f2ae6250eb78ffc0fa684", "checkerName": "hicpp-signed-bitwise", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 38, "file": 14, "line": 25}, "message": "use of a signed integer operand with a binary bitwise operator"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/src/lib-sieve/sieve-error.h", "reportHash": "9f6368165777762cb136c57caabd74c6", "checkerName": "hicpp-signed-bitwise", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 9, "file": 15, "line": 1}, "message": "_HOME_RUNNER_WORK_TESTCC_TESTCC_RETDEC_SRC_LIB_SIEVE_SIEVE_EXECUTE_H (fixit)"}, {"location": {"col": 9, "file": 15, "line": 1}, "message": "header guard does not follow preferred style"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/src/lib-sieve/sieve-execute.h", "reportHash": "10f5e1bbe30c91e163acd260f78ec340", "checkerName": "llvm-header-guard", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 9, "file": 16, "line": 1}, "message": "_HOME_RUNNER_WORK_TESTCC_TESTCC_RETDEC_SRC_LIB_SIEVE_SIEVE_EXTENSIONS_H (fixit)"}, {"location": {"col": 9, "file": 16, "line": 1}, "message": "header guard does not follow preferred style"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/src/lib-sieve/sieve-extensions.h", "reportHash": "b3d5dafb7682b7bbeffb720cc2f0e48f", "checkerName": "llvm-header-guard", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 12, "file": 16, "line": 58}, "message": "() (fixit)"}, {"location": {"col": 5, "file": 16, "line": 58}, "message": "macro argument should be enclosed in parentheses"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/src/lib-sieve/sieve-extensions.h", "reportHash": "9bca2183b618fa6935670c4470505de6", "checkerName": "misc-macro-parentheses", "reviewStatus": null, "severity": "MEDIUM"}, {"events": [{"location": {"col": 9, "file": 17, "line": 1}, "message": "_HOME_RUNNER_WORK_TESTCC_TESTCC_RETDEC_SRC_LIB_SIEVE_SIEVE_GENERATOR_H (fixit)"}, {"location": {"col": 9, "file": 17, "line": 1}, "message": "header guard does not follow preferred style"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/src/lib-sieve/sieve-generator.h", "reportHash": "50d212c2762776ce5ec58f2198906e07", "checkerName": "llvm-header-guard", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 9, "file": 18, "line": 1}, "message": "_HOME_RUNNER_WORK_TESTCC_TESTCC_RETDEC_SRC_LIB_SIEVE_SIEVE_INTERPRETER_H (fixit)"}, {"location": {"col": 9, "file": 18, "line": 1}, "message": "header guard does not follow preferred style"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/src/lib-sieve/sieve-interpreter.h", "reportHash": "cf6e84892c5b526b8844259ae44b2730", "checkerName": "llvm-header-guard", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 10, "file": 18, "line": 4}, "message": "\"array.h\" (fixit)"}, {"location": {"col": 1, "file": 18, "line": 4}, "message": "#includes are not sorted properly"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/src/lib-sieve/sieve-interpreter.h", "reportHash": "0bde2d3befda56954735ca5b0b5ad81e", "checkerName": "llvm-include-order", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 9, "file": 19, "line": 1}, "message": "_HOME_RUNNER_WORK_TESTCC_TESTCC_RETDEC_SRC_LIB_SIEVE_SIEVE_RUNTIME_TRACE_H (fixit)"}, {"location": {"col": 9, "file": 19, "line": 1}, "message": "header guard does not follow preferred style"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/src/lib-sieve/sieve-runtime-trace.h", "reportHash": "59c8afadbfda4c897c2e87a615c8ca87", "checkerName": "llvm-header-guard", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 36, "file": 19, "line": 36}, "message": "{ (fixit)"}, {"location": {"col": 28, "file": 19, "line": 36}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/src/lib-sieve/sieve-runtime-trace.h", "reportHash": "06358382ac23db4a940570bf690d635a", "checkerName": "readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 36, "file": 19, "line": 42}, "message": "{ (fixit)"}, {"location": {"col": 28, "file": 19, "line": 42}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/src/lib-sieve/sieve-runtime-trace.h", "reportHash": "df7c2b2883dd64283a3b6f59c37184a6", "checkerName": "readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 36, "file": 19, "line": 48}, "message": "{ (fixit)"}, {"location": {"col": 28, "file": 19, "line": 48}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/src/lib-sieve/sieve-runtime-trace.h", "reportHash": "58f34afe736fb848baa477e7f254d2f1", "checkerName": "hicpp-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 36, "file": 19, "line": 75}, "message": "{ (fixit)"}, {"location": {"col": 28, "file": 19, "line": 75}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/src/lib-sieve/sieve-runtime-trace.h", "reportHash": "a5d0d7f3e864f04b8b39f84fdcb2aa9a", "checkerName": "readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 36, "file": 19, "line": 87}, "message": "{ (fixit)"}, {"location": {"col": 28, "file": 19, "line": 87}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/src/lib-sieve/sieve-runtime-trace.h", "reportHash": "a5d0d7f3e864f04b8b39f84fdcb2aa9a", "checkerName": "readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 36, "file": 19, "line": 164}, "message": "{ (fixit)"}, {"location": {"col": 28, "file": 19, "line": 164}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/src/lib-sieve/sieve-runtime-trace.h", "reportHash": "a5d0d7f3e864f04b8b39f84fdcb2aa9a", "checkerName": "readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 36, "file": 19, "line": 171}, "message": "{ (fixit)"}, {"location": {"col": 28, "file": 19, "line": 171}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/src/lib-sieve/sieve-runtime-trace.h", "reportHash": "a5d0d7f3e864f04b8b39f84fdcb2aa9a", "checkerName": "readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 36, "file": 19, "line": 178}, "message": "{ (fixit)"}, {"location": {"col": 28, "file": 19, "line": 178}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/src/lib-sieve/sieve-runtime-trace.h", "reportHash": "a5d0d7f3e864f04b8b39f84fdcb2aa9a", "checkerName": "readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 9, "file": 20, "line": 1}, "message": "_HOME_RUNNER_WORK_TESTCC_TESTCC_RETDEC_SRC_LIB_SIEVE_SIEVE_RUNTIME_H (fixit)"}, {"location": {"col": 9, "file": 20, "line": 1}, "message": "header guard does not follow preferred style"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/src/lib-sieve/sieve-runtime.h", "reportHash": "0a6097eb82ffeb3708fbe54b8d8dd47b", "checkerName": "llvm-header-guard", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 9, "file": 21, "line": 1}, "message": "_HOME_RUNNER_WORK_TESTCC_TESTCC_RETDEC_SRC_LIB_SIEVE_SIEVE_TYPES_H (fixit)"}, {"location": {"col": 9, "file": 21, "line": 1}, "message": "header guard does not follow preferred style"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/src/lib-sieve/sieve-types.h", "reportHash": "f9c4df7ebe4c9c5b5f4a81168ae5eb18", "checkerName": "llvm-header-guard", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 30, "file": 21, "line": 33}, "message": "use of a signed integer operand with a binary bitwise operator"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/src/lib-sieve/sieve-types.h", "reportHash": "256c7f1f04b2aa73394dd5097e449780", "checkerName": "hicpp-signed-bitwise", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 33, "file": 21, "line": 118}, "message": "use of a signed integer operand with a binary bitwise operator"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/src/lib-sieve/sieve-types.h", "reportHash": "54a94d81bb2eab958394b4308081a043", "checkerName": "hicpp-signed-bitwise", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 33, "file": 21, "line": 120}, "message": "use of a signed integer operand with a binary bitwise operator"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/src/lib-sieve/sieve-types.h", "reportHash": "c12ce82fe1e81e85a647494f91a8157b", "checkerName": "hicpp-signed-bitwise", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 34, "file": 21, "line": 122}, "message": "use of a signed integer operand with a binary bitwise operator"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/src/lib-sieve/sieve-types.h", "reportHash": "ce9e742db6bd74ad21ec24773e222d32", "checkerName": "hicpp-signed-bitwise", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 36, "file": 21, "line": 124}, "message": "use of a signed integer operand with a binary bitwise operator"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/src/lib-sieve/sieve-types.h", "reportHash": "94efab75c1220d8b2db6f85cf7117d64", "checkerName": "hicpp-signed-bitwise", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 33, "file": 21, "line": 156}, "message": "use of a signed integer operand with a binary bitwise operator"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/src/lib-sieve/sieve-types.h", "reportHash": "8319d58be18dbcc9b68a8c4ef9c15932", "checkerName": "hicpp-signed-bitwise", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 35, "file": 21, "line": 158}, "message": "use of a signed integer operand with a binary bitwise operator"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/src/lib-sieve/sieve-types.h", "reportHash": "c166c66a0fe15f5f2e00b473b1e0401f", "checkerName": "hicpp-signed-bitwise", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 36, "file": 21, "line": 160}, "message": "use of a signed integer operand with a binary bitwise operator"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/src/lib-sieve/sieve-types.h", "reportHash": "d7e46b4cc5cd72bff5270c585428a1ac", "checkerName": "hicpp-signed-bitwise", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 39, "file": 21, "line": 162}, "message": "use of a signed integer operand with a binary bitwise operator"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/src/lib-sieve/sieve-types.h", "reportHash": "5bf5fcfd9c95fb0cf90bb99180d24507", "checkerName": "hicpp-signed-bitwise", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 35, "file": 21, "line": 164}, "message": "use of a signed integer operand with a binary bitwise operator"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/src/lib-sieve/sieve-types.h", "reportHash": "14bc3e72258949a18d24edb7eeb459bc", "checkerName": "hicpp-signed-bitwise", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 23, "file": 21, "line": 180}, "message": "use of a signed integer operand with a binary bitwise operator"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/src/lib-sieve/sieve-types.h", "reportHash": "226d1b72430fde364e1f2294fbd11c03", "checkerName": "hicpp-signed-bitwise", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 27, "file": 21, "line": 181}, "message": "use of a signed integer operand with a binary bitwise operator"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/src/lib-sieve/sieve-types.h", "reportHash": "4ff28640706cf661a4cb907aa8769340", "checkerName": "hicpp-signed-bitwise", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 10, "file": 21, "line": 257}, "message": "() (fixit)"}, {"location": {"col": 3, "file": 21, "line": 257}, "message": "macro argument should be enclosed in parentheses"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/src/lib-sieve/sieve-types.h", "reportHash": "2471415d0d7174d81834e97d642559b9", "checkerName": "misc-macro-parentheses", "reviewStatus": null, "severity": "MEDIUM"}, {"events": [{"location": {"col": 52, "file": 21, "line": 257}, "message": "() (fixit)"}, {"location": {"col": 45, "file": 21, "line": 257}, "message": "macro argument should be enclosed in parentheses"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/src/lib-sieve/sieve-types.h", "reportHash": "d0e92044e5bacd774a5e7355e28da0e0", "checkerName": "misc-macro-parentheses", "reviewStatus": null, "severity": "MEDIUM"}, {"events": [{"location": {"col": 9, "file": 22, "line": 1}, "message": "_HOME_RUNNER_WORK_TESTCC_TESTCC_RETDEC_SRC_LIB_SIEVE_SIEVE_VALIDATOR_H (fixit)"}, {"location": {"col": 9, "file": 22, "line": 1}, "message": "header guard does not follow preferred style"}], "macros": [], "notes": [], "path": "/home/runner/work/testcc/testcc/retdec/src/lib-sieve/sieve-validator.h", "reportHash": "5b0cd1cf2a814f6d5c1cae287c315a3a", "checkerName": "llvm-header-guard", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 9, "file": 23, "line": 1}, "message": "DOVECOT_ARRAY_DECL_H (fixit)"}, {"location": {"col": 9, "file": 23, "line": 1}, "message": "header guard does not follow preferred style"}], "macros": [], "notes": [], "path": "/usr/local/include/dovecot/array-decl.h", "reportHash": "4467a78ded624e0bccb814a7290d9a6b", "checkerName": "llvm-header-guard", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 81, "file": 23, "line": 4}, "message": "() (fixit)"}, {"location": {"col": 81, "file": 23, "line": 4}, "message": "macro argument should be enclosed in parentheses"}], "macros": [], "notes": [], "path": "/usr/local/include/dovecot/array-decl.h", "reportHash": "605fd2ad1633ffa5d0c558773dacd428", "checkerName": "misc-macro-parentheses", "reviewStatus": null, "severity": "MEDIUM"}, {"events": [{"location": {"col": 83, "file": 23, "line": 8}, "message": "() (fixit)"}, {"location": {"col": 76, "file": 23, "line": 8}, "message": "macro argument should be enclosed in parentheses"}], "macros": [], "notes": [], "path": "/usr/local/include/dovecot/array-decl.h", "reportHash": "ad631b96de3e3219610a33009395360f", "checkerName": "misc-macro-parentheses", "reviewStatus": null, "severity": "MEDIUM"}, {"events": [{"location": {"col": 9, "file": 24, "line": 1}, "message": "DOVECOT_ARRAY_H (fixit)"}, {"location": {"col": 9, "file": 24, "line": 1}, "message": "header guard does not follow preferred style"}], "macros": [], "notes": [], "path": "/usr/local/include/dovecot/array.h", "reportHash": "2f52adfb242a0dc61f1449730b8b107e", "checkerName": "llvm-header-guard", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 32, "file": 24, "line": 73}, "message": "() (fixit)"}, {"location": {"col": 18, "file": 24, "line": 73}, "message": "macro argument should be enclosed in parentheses"}], "macros": [], "notes": [], "path": "/usr/local/include/dovecot/array.h", "reportHash": "f191a2ca6d9fa0d70b60744c2d9933e4", "checkerName": "misc-macro-parentheses", "reviewStatus": null, "severity": "MEDIUM"}, {"events": [{"location": {"col": 14, "file": 24, "line": 74}, "message": "() (fixit)"}, {"location": {"col": 7, "file": 24, "line": 74}, "message": "macro argument should be enclosed in parentheses"}], "macros": [], "notes": [], "path": "/usr/local/include/dovecot/array.h", "reportHash": "2f72f697dd2a6d8091c7ae6efc8d71cb", "checkerName": "misc-macro-parentheses", "reviewStatus": null, "severity": "MEDIUM"}, {"events": [{"location": {"col": 32, "file": 24, "line": 77}, "message": "() (fixit)"}, {"location": {"col": 18, "file": 24, "line": 77}, "message": "macro argument should be enclosed in parentheses"}], "macros": [], "notes": [], "path": "/usr/local/include/dovecot/array.h", "reportHash": "02bb02787a5a34cd63331ae69b74272c", "checkerName": "misc-macro-parentheses", "reviewStatus": null, "severity": "MEDIUM"}, {"events": [{"location": {"col": 14, "file": 24, "line": 80}, "message": "() (fixit)"}, {"location": {"col": 7, "file": 24, "line": 80}, "message": "macro argument should be enclosed in parentheses"}], "macros": [], "notes": [], "path": "/usr/local/include/dovecot/array.h", "reportHash": "72f3f0472f1afa5aecd30558cb03de83", "checkerName": "misc-macro-parentheses", "reviewStatus": null, "severity": "MEDIUM"}, {"events": [{"location": {"col": 70, "file": 24, "line": 87}, "message": "() (fixit)"}, {"location": {"col": 63, "file": 24, "line": 87}, "message": "macro argument should be enclosed in parentheses"}], "macros": [], "notes": [], "path": "/usr/local/include/dovecot/array.h", "reportHash": "5295b260eea1ea357994c22c8e817ae9", "checkerName": "misc-macro-parentheses", "reviewStatus": null, "severity": "MEDIUM"}, {"events": [{"location": {"col": 23, "file": 24, "line": 91}, "message": "() (fixit)"}, {"location": {"col": 16, "file": 24, "line": 91}, "message": "macro argument should be enclosed in parentheses"}], "macros": [], "notes": [], "path": "/usr/local/include/dovecot/array.h", "reportHash": "881af9f07240b0073343ad653141faa2", "checkerName": "misc-macro-parentheses", "reviewStatus": null, "severity": "MEDIUM"}, {"events": [{"location": {"col": 61, "file": 24, "line": 352}, "message": "() (fixit)"}, {"location": {"col": 47, "file": 24, "line": 352}, "message": "macro argument should be enclosed in parentheses"}], "macros": [], "notes": [], "path": "/usr/local/include/dovecot/array.h", "reportHash": "a9e6510efde3f8eae11fa26ea3ad1e88", "checkerName": "misc-macro-parentheses", "reviewStatus": null, "severity": "MEDIUM"}, {"events": [{"location": {"col": 76, "file": 24, "line": 367}, "message": "() (fixit)"}, {"location": {"col": 27, "file": 24, "line": 367}, "message": "macro argument should be enclosed in parentheses"}], "macros": [], "notes": [], "path": "/usr/local/include/dovecot/array.h", "reportHash": "837ac8cec3fe56c383880425e9b0c3f6", "checkerName": "misc-macro-parentheses", "reviewStatus": null, "severity": "MEDIUM"}, {"events": [{"location": {"col": 81, "file": 24, "line": 368}, "message": "() (fixit)"}, {"location": {"col": 60, "file": 24, "line": 368}, "message": "macro argument should be enclosed in parentheses"}], "macros": [], "notes": [], "path": "/usr/local/include/dovecot/array.h", "reportHash": "4f6e50e0d75b961d68e2dc9c8fa6df81", "checkerName": "misc-macro-parentheses", "reviewStatus": null, "severity": "MEDIUM"}, {"events": [{"location": {"col": 54, "file": 24, "line": 380}, "message": "() (fixit)"}, {"location": {"col": 40, "file": 24, "line": 380}, "message": "macro argument should be enclosed in parentheses"}], "macros": [], "notes": [], "path": "/usr/local/include/dovecot/array.h", "reportHash": "9faa4f8e38e10f6bf099297bbaca8d59", "checkerName": "misc-macro-parentheses", "reviewStatus": null, "severity": "MEDIUM"}, {"events": [{"location": {"col": 70, "file": 24, "line": 386}, "message": "() (fixit)"}, {"location": {"col": 56, "file": 24, "line": 386}, "message": "macro argument should be enclosed in parentheses"}], "macros": [], "notes": [], "path": "/usr/local/include/dovecot/array.h", "reportHash": "e3fc5e53db5ce5357aee51609817c600", "checkerName": "misc-macro-parentheses", "reviewStatus": null, "severity": "MEDIUM"}, {"events": [{"location": {"col": 31, "file": 24, "line": 388}, "message": "() (fixit)"}, {"location": {"col": 17, "file": 24, "line": 388}, "message": "macro argument should be enclosed in parentheses"}], "macros": [], "notes": [], "path": "/usr/local/include/dovecot/array.h", "reportHash": "e2ee3fb7bc545417dc984e225be7eaeb", "checkerName": "misc-macro-parentheses", "reviewStatus": null, "severity": "MEDIUM"}, {"events": [{"location": {"col": 73, "file": 24, "line": 388}, "message": "() (fixit)"}, {"location": {"col": 59, "file": 24, "line": 388}, "message": "macro argument should be enclosed in parentheses"}], "macros": [], "notes": [], "path": "/usr/local/include/dovecot/array.h", "reportHash": "1aa2fb304de211201126481811416b26", "checkerName": "misc-macro-parentheses", "reviewStatus": null, "severity": "MEDIUM"}, {"events": [{"location": {"col": 70, "file": 24, "line": 401}, "message": "() (fixit)"}, {"location": {"col": 56, "file": 24, "line": 401}, "message": "macro argument should be enclosed in parentheses"}], "macros": [], "notes": [], "path": "/usr/local/include/dovecot/array.h", "reportHash": "e3fc5e53db5ce5357aee51609817c600", "checkerName": "misc-macro-parentheses", "reviewStatus": null, "severity": "MEDIUM"}, {"events": [{"location": {"col": 31, "file": 24, "line": 403}, "message": "() (fixit)"}, {"location": {"col": 17, "file": 24, "line": 403}, "message": "macro argument should be enclosed in parentheses"}], "macros": [], "notes": [], "path": "/usr/local/include/dovecot/array.h", "reportHash": "e6e64f562767af3721ca080c283ef861", "checkerName": "misc-macro-parentheses", "reviewStatus": null, "severity": "MEDIUM"}, {"events": [{"location": {"col": 54, "file": 24, "line": 404}, "message": "() (fixit)"}, {"location": {"col": 40, "file": 24, "line": 404}, "message": "macro argument should be enclosed in parentheses"}], "macros": [], "notes": [], "path": "/usr/local/include/dovecot/array.h", "reportHash": "9faa4f8e38e10f6bf099297bbaca8d59", "checkerName": "misc-macro-parentheses", "reviewStatus": null, "severity": "MEDIUM"}, {"events": [{"location": {"col": 9, "file": 25, "line": 1}, "message": "DOVECOT_BITS_H (fixit)"}, {"location": {"col": 9, "file": 25, "line": 1}, "message": "header guard does not follow preferred style"}], "macros": [], "notes": [], "path": "/usr/local/include/dovecot/bits.h", "reportHash": "699a6d955856fba302e1f8f779a4c642", "checkerName": "llvm-header-guard", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 10, "file": 25, "line": 5}, "message": "() (fixit)"}, {"location": {"col": 3, "file": 25, "line": 5}, "message": "macro argument should be enclosed in parentheses"}], "macros": [], "notes": [], "path": "/usr/local/include/dovecot/bits.h", "reportHash": "e062f46b230d7ea3b75458a498615130", "checkerName": "misc-macro-parentheses", "reviewStatus": null, "severity": "MEDIUM"}, {"events": [{"location": {"col": 29, "file": 25, "line": 5}, "message": "() (fixit)"}, {"location": {"col": 22, "file": 25, "line": 5}, "message": "macro argument should be enclosed in parentheses"}], "macros": [], "notes": [], "path": "/usr/local/include/dovecot/bits.h", "reportHash": "11ec497e01440afefb6f5d908d2a816c", "checkerName": "misc-macro-parentheses", "reviewStatus": null, "severity": "MEDIUM"}, {"events": [{"location": {"col": 35, "file": 25, "line": 124}, "message": "{ (fixit)"}, {"location": {"col": 27, "file": 25, "line": 124}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "/usr/local/include/dovecot/bits.h", "reportHash": "382394cf84f1ea365c9db606ac78a16a", "checkerName": "readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 27, "file": 25, "line": 137}, "message": "{ (fixit)"}, {"location": {"col": 19, "file": 25, "line": 137}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "/usr/local/include/dovecot/bits.h", "reportHash": "72d9571808a56c31505e4fe68a955aa8", "checkerName": "readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 28, "file": 25, "line": 139}, "message": "{ (fixit)"}, {"location": {"col": 20, "file": 25, "line": 139}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "/usr/local/include/dovecot/bits.h", "reportHash": "1e4745e4caa375586f34713c1d5300f4", "checkerName": "readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 27, "file": 25, "line": 150}, "message": "{ (fixit)"}, {"location": {"col": 19, "file": 25, "line": 150}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "/usr/local/include/dovecot/bits.h", "reportHash": "26b459ba6004d549745ed4ad4c768da4", "checkerName": "google-readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 28, "file": 25, "line": 152}, "message": "{ (fixit)"}, {"location": {"col": 20, "file": 25, "line": 152}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "/usr/local/include/dovecot/bits.h", "reportHash": "9fff798b8fe6f973a8daec570413d358", "checkerName": "google-readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 9, "file": 26, "line": 1}, "message": "DOVECOT_BUFFER_H (fixit)"}, {"location": {"col": 9, "file": 26, "line": 1}, "message": "header guard does not follow preferred style"}], "macros": [], "notes": [], "path": "/usr/local/include/dovecot/buffer.h", "reportHash": "795182b5835cd0e77d52abf09e9197b1", "checkerName": "llvm-header-guard", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 34, "file": 26, "line": 122}, "message": "{ (fixit)"}, {"location": {"col": 26, "file": 26, "line": 122}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "/usr/local/include/dovecot/buffer.h", "reportHash": "c1972442ff7eb8951ecc4ea96224f2e4", "checkerName": "readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 9, "file": 27, "line": 23}, "message": "DOVECOT_BYTEORDER_H (fixit)"}, {"location": {"col": 9, "file": 27, "line": 23}, "message": "header guard does not follow preferred style"}], "macros": [], "notes": [], "path": "/usr/local/include/dovecot/byteorder.h", "reportHash": "7a5b70cb8155cc5a6f8d67b152d5394c", "checkerName": "llvm-header-guard", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 45, "file": 27, "line": 66}, "message": "x (fixit)"}, {"location": {"col": 1, "file": 27, "line": 259}, "message": "the definition seen here"}, {"location": {"col": 2, "file": 27, "line": 254}, "message": "expanded from macro 'GEN'"}, {"location": {"col": 39, "file": 27, "line": 250}, "message": "expanded from macro '__GEN'"}, {"location": {"col": 30, "file": 27, "line": 242}, "message": "expanded from macro '___GEN'"}, {"location": {"col": 24, "file": 27, "line": 66}, "message": "function 'be64_to_cpu' has a definition with different parameter names"}], "macros": [], "notes": [], "path": "/usr/local/include/dovecot/byteorder.h", "reportHash": "efac8061ced8f7aafdb8dcdec1abff4e", "checkerName": "readability-inconsistent-declaration-parameter-name", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 45, "file": 27, "line": 67}, "message": "x (fixit)"}, {"location": {"col": 1, "file": 27, "line": 260}, "message": "the definition seen here"}, {"location": {"col": 2, "file": 27, "line": 254}, "message": "expanded from macro 'GEN'"}, {"location": {"col": 39, "file": 27, "line": 250}, "message": "expanded from macro '__GEN'"}, {"location": {"col": 30, "file": 27, "line": 242}, "message": "expanded from macro '___GEN'"}, {"location": {"col": 24, "file": 27, "line": 67}, "message": "function 'be32_to_cpu' has a definition with different parameter names"}], "macros": [], "notes": [], "path": "/usr/local/include/dovecot/byteorder.h", "reportHash": "bb3e424e6746c15087badfdbc2567c45", "checkerName": "readability-inconsistent-declaration-parameter-name", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 45, "file": 27, "line": 68}, "message": "x (fixit)"}, {"location": {"col": 1, "file": 27, "line": 261}, "message": "the definition seen here"}, {"location": {"col": 2, "file": 27, "line": 254}, "message": "expanded from macro 'GEN'"}, {"location": {"col": 39, "file": 27, "line": 250}, "message": "expanded from macro '__GEN'"}, {"location": {"col": 30, "file": 27, "line": 242}, "message": "expanded from macro '___GEN'"}, {"location": {"col": 24, "file": 27, "line": 68}, "message": "function 'be16_to_cpu' has a definition with different parameter names"}], "macros": [], "notes": [], "path": "/usr/local/include/dovecot/byteorder.h", "reportHash": "d5a1ca2beac3fb29d6ffeaa4b3aee352", "checkerName": "readability-inconsistent-declaration-parameter-name", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 42, "file": 27, "line": 69}, "message": "x (fixit)"}, {"location": {"col": 1, "file": 27, "line": 262}, "message": "the definition seen here"}, {"location": {"col": 2, "file": 27, "line": 254}, "message": "expanded from macro 'GEN'"}, {"location": {"col": 39, "file": 27, "line": 250}, "message": "expanded from macro '__GEN'"}, {"location": {"col": 30, "file": 27, "line": 242}, "message": "expanded from macro '___GEN'"}, {"location": {"col": 23, "file": 27, "line": 69}, "message": "function 'be8_to_cpu' has a definition with different parameter names"}], "macros": [], "notes": [], "path": "/usr/local/include/dovecot/byteorder.h", "reportHash": "10fd7082f860a01cf7a8a4ebd13f8a11", "checkerName": "readability-inconsistent-declaration-parameter-name", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 45, "file": 27, "line": 72}, "message": "x (fixit)"}, {"location": {"col": 1, "file": 27, "line": 259}, "message": "the definition seen here"}, {"location": {"col": 2, "file": 27, "line": 255}, "message": "expanded from macro 'GEN'"}, {"location": {"col": 39, "file": 27, "line": 250}, "message": "expanded from macro '__GEN'"}, {"location": {"col": 30, "file": 27, "line": 242}, "message": "expanded from macro '___GEN'"}, {"location": {"col": 24, "file": 27, "line": 72}, "message": "function 'cpu64_to_be' has a definition with different parameter names"}], "macros": [], "notes": [], "path": "/usr/local/include/dovecot/byteorder.h", "reportHash": "6610d5dc75d9e632ff933be4cc39f07b", "checkerName": "readability-inconsistent-declaration-parameter-name", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 45, "file": 27, "line": 73}, "message": "x (fixit)"}, {"location": {"col": 1, "file": 27, "line": 260}, "message": "the definition seen here"}, {"location": {"col": 2, "file": 27, "line": 255}, "message": "expanded from macro 'GEN'"}, {"location": {"col": 39, "file": 27, "line": 250}, "message": "expanded from macro '__GEN'"}, {"location": {"col": 30, "file": 27, "line": 242}, "message": "expanded from macro '___GEN'"}, {"location": {"col": 24, "file": 27, "line": 73}, "message": "function 'cpu32_to_be' has a definition with different parameter names"}], "macros": [], "notes": [], "path": "/usr/local/include/dovecot/byteorder.h", "reportHash": "a15b8d14bec238b86c3a8fce61c3c10c", "checkerName": "readability-inconsistent-declaration-parameter-name", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 45, "file": 27, "line": 74}, "message": "x (fixit)"}, {"location": {"col": 1, "file": 27, "line": 261}, "message": "the definition seen here"}, {"location": {"col": 2, "file": 27, "line": 255}, "message": "expanded from macro 'GEN'"}, {"location": {"col": 39, "file": 27, "line": 250}, "message": "expanded from macro '__GEN'"}, {"location": {"col": 30, "file": 27, "line": 242}, "message": "expanded from macro '___GEN'"}, {"location": {"col": 24, "file": 27, "line": 74}, "message": "function 'cpu16_to_be' has a definition with different parameter names"}], "macros": [], "notes": [], "path": "/usr/local/include/dovecot/byteorder.h", "reportHash": "2df796bb1981183cadbac9e84c46152b", "checkerName": "readability-inconsistent-declaration-parameter-name", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 42, "file": 27, "line": 75}, "message": "x (fixit)"}, {"location": {"col": 1, "file": 27, "line": 262}, "message": "the definition seen here"}, {"location": {"col": 2, "file": 27, "line": 255}, "message": "expanded from macro 'GEN'"}, {"location": {"col": 39, "file": 27, "line": 250}, "message": "expanded from macro '__GEN'"}, {"location": {"col": 30, "file": 27, "line": 242}, "message": "expanded from macro '___GEN'"}, {"location": {"col": 23, "file": 27, "line": 75}, "message": "function 'cpu8_to_be' has a definition with different parameter names"}], "macros": [], "notes": [], "path": "/usr/local/include/dovecot/byteorder.h", "reportHash": "afb05a7dcb56c3ee5410eb9528b5aac1", "checkerName": "readability-inconsistent-declaration-parameter-name", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 45, "file": 27, "line": 78}, "message": "x (fixit)"}, {"location": {"col": 1, "file": 27, "line": 259}, "message": "the definition seen here"}, {"location": {"col": 2, "file": 27, "line": 256}, "message": "expanded from macro 'GEN'"}, {"location": {"col": 39, "file": 27, "line": 250}, "message": "expanded from macro '__GEN'"}, {"location": {"col": 30, "file": 27, "line": 242}, "message": "expanded from macro '___GEN'"}, {"location": {"col": 24, "file": 27, "line": 78}, "message": "function 'le64_to_cpu' has a definition with different parameter names"}], "macros": [], "notes": [], "path": "/usr/local/include/dovecot/byteorder.h", "reportHash": "500af05672cd3454990a340b25bbdd5a", "checkerName": "readability-inconsistent-declaration-parameter-name", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 45, "file": 27, "line": 79}, "message": "x (fixit)"}, {"location": {"col": 1, "file": 27, "line": 260}, "message": "the definition seen here"}, {"location": {"col": 2, "file": 27, "line": 256}, "message": "expanded from macro 'GEN'"}, {"location": {"col": 39, "file": 27, "line": 250}, "message": "expanded from macro '__GEN'"}, {"location": {"col": 30, "file": 27, "line": 242}, "message": "expanded from macro '___GEN'"}, {"location": {"col": 24, "file": 27, "line": 79}, "message": "function 'le32_to_cpu' has a definition with different parameter names"}], "macros": [], "notes": [], "path": "/usr/local/include/dovecot/byteorder.h", "reportHash": "d8bbd11d295b44d23bca9073b372eaa9", "checkerName": "readability-inconsistent-declaration-parameter-name", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 45, "file": 27, "line": 80}, "message": "x (fixit)"}, {"location": {"col": 1, "file": 27, "line": 261}, "message": "the definition seen here"}, {"location": {"col": 2, "file": 27, "line": 256}, "message": "expanded from macro 'GEN'"}, {"location": {"col": 39, "file": 27, "line": 250}, "message": "expanded from macro '__GEN'"}, {"location": {"col": 30, "file": 27, "line": 242}, "message": "expanded from macro '___GEN'"}, {"location": {"col": 24, "file": 27, "line": 80}, "message": "function 'le16_to_cpu' has a definition with different parameter names"}], "macros": [], "notes": [], "path": "/usr/local/include/dovecot/byteorder.h", "reportHash": "fcbbd80f81cf976b4a043bee6818157a", "checkerName": "readability-inconsistent-declaration-parameter-name", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 42, "file": 27, "line": 81}, "message": "x (fixit)"}, {"location": {"col": 1, "file": 27, "line": 262}, "message": "the definition seen here"}, {"location": {"col": 2, "file": 27, "line": 256}, "message": "expanded from macro 'GEN'"}, {"location": {"col": 39, "file": 27, "line": 250}, "message": "expanded from macro '__GEN'"}, {"location": {"col": 30, "file": 27, "line": 242}, "message": "expanded from macro '___GEN'"}, {"location": {"col": 23, "file": 27, "line": 81}, "message": "function 'le8_to_cpu' has a definition with different parameter names"}], "macros": [], "notes": [], "path": "/usr/local/include/dovecot/byteorder.h", "reportHash": "9153333ac764d9d792912422e97ee33b", "checkerName": "readability-inconsistent-declaration-parameter-name", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 45, "file": 27, "line": 84}, "message": "x (fixit)"}, {"location": {"col": 1, "file": 27, "line": 259}, "message": "the definition seen here"}, {"location": {"col": 2, "file": 27, "line": 257}, "message": "expanded from macro 'GEN'"}, {"location": {"col": 39, "file": 27, "line": 250}, "message": "expanded from macro '__GEN'"}, {"location": {"col": 30, "file": 27, "line": 242}, "message": "expanded from macro '___GEN'"}, {"location": {"col": 24, "file": 27, "line": 84}, "message": "function 'cpu64_to_le' has a definition with different parameter names"}], "macros": [], "notes": [], "path": "/usr/local/include/dovecot/byteorder.h", "reportHash": "bc8cb5e7a41c9c001cd5205d1d02ad70", "checkerName": "readability-inconsistent-declaration-parameter-name", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 45, "file": 27, "line": 85}, "message": "x (fixit)"}, {"location": {"col": 1, "file": 27, "line": 260}, "message": "the definition seen here"}, {"location": {"col": 2, "file": 27, "line": 257}, "message": "expanded from macro 'GEN'"}, {"location": {"col": 39, "file": 27, "line": 250}, "message": "expanded from macro '__GEN'"}, {"location": {"col": 30, "file": 27, "line": 242}, "message": "expanded from macro '___GEN'"}, {"location": {"col": 24, "file": 27, "line": 85}, "message": "function 'cpu32_to_le' has a definition with different parameter names"}], "macros": [], "notes": [], "path": "/usr/local/include/dovecot/byteorder.h", "reportHash": "f67c40b0c0b2efb73e2b9d34c94b630c", "checkerName": "readability-inconsistent-declaration-parameter-name", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 45, "file": 27, "line": 86}, "message": "x (fixit)"}, {"location": {"col": 1, "file": 27, "line": 261}, "message": "the definition seen here"}, {"location": {"col": 2, "file": 27, "line": 257}, "message": "expanded from macro 'GEN'"}, {"location": {"col": 39, "file": 27, "line": 250}, "message": "expanded from macro '__GEN'"}, {"location": {"col": 30, "file": 27, "line": 242}, "message": "expanded from macro '___GEN'"}, {"location": {"col": 24, "file": 27, "line": 86}, "message": "function 'cpu16_to_le' has a definition with different parameter names"}], "macros": [], "notes": [], "path": "/usr/local/include/dovecot/byteorder.h", "reportHash": "d67653c7a128df32ccba9756438f34c1", "checkerName": "readability-inconsistent-declaration-parameter-name", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 42, "file": 27, "line": 87}, "message": "x (fixit)"}, {"location": {"col": 1, "file": 27, "line": 262}, "message": "the definition seen here"}, {"location": {"col": 2, "file": 27, "line": 257}, "message": "expanded from macro 'GEN'"}, {"location": {"col": 39, "file": 27, "line": 250}, "message": "expanded from macro '__GEN'"}, {"location": {"col": 30, "file": 27, "line": 242}, "message": "expanded from macro '___GEN'"}, {"location": {"col": 23, "file": 27, "line": 87}, "message": "function 'cpu8_to_le' has a definition with different parameter names"}], "macros": [], "notes": [], "path": "/usr/local/include/dovecot/byteorder.h", "reportHash": "e1939d639dd3eff51283066d8717b341", "checkerName": "readability-inconsistent-declaration-parameter-name", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 10, "file": 27, "line": 94}, "message": "use of a signed integer operand with a binary bitwise operator"}], "macros": [], "notes": [], "path": "/usr/local/include/dovecot/byteorder.h", "reportHash": "e6f1c96b894e55e15699a70881b185ac", "checkerName": "hicpp-signed-bitwise", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 10, "file": 27, "line": 95}, "message": "use of a signed integer operand with a binary bitwise operator"}], "macros": [], "notes": [], "path": "/usr/local/include/dovecot/byteorder.h", "reportHash": "f850598094c16c1e2166b88b54e7aa03", "checkerName": "hicpp-signed-bitwise", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 10, "file": 27, "line": 96}, "message": "use of a signed integer operand with a binary bitwise operator"}], "macros": [], "notes": [], "path": "/usr/local/include/dovecot/byteorder.h", "reportHash": "db5e50c464843c5323f37da30381c10a", "checkerName": "hicpp-signed-bitwise", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 10, "file": 27, "line": 97}, "message": "use of a signed integer operand with a binary bitwise operator"}], "macros": [], "notes": [], "path": "/usr/local/include/dovecot/byteorder.h", "reportHash": "32ca44037999e10bbc506fab12b490a1", "checkerName": "hicpp-signed-bitwise", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 10, "file": 27, "line": 98}, "message": "use of a signed integer operand with a binary bitwise operator"}], "macros": [], "notes": [], "path": "/usr/local/include/dovecot/byteorder.h", "reportHash": "43aeb24db93af7ffafe35fa915ed2ba5", "checkerName": "hicpp-signed-bitwise", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 10, "file": 27, "line": 99}, "message": "use of a signed integer operand with a binary bitwise operator"}], "macros": [], "notes": [], "path": "/usr/local/include/dovecot/byteorder.h", "reportHash": "70801f343487f8b380bd01ea17ea9a22", "checkerName": "hicpp-signed-bitwise", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 10, "file": 27, "line": 100}, "message": "use of a signed integer operand with a binary bitwise operator"}], "macros": [], "notes": [], "path": "/usr/local/include/dovecot/byteorder.h", "reportHash": "df1fee67040390739d3cfd6c1b0dc604", "checkerName": "hicpp-signed-bitwise", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 10, "file": 27, "line": 101}, "message": "use of a signed integer operand with a binary bitwise operator"}], "macros": [], "notes": [], "path": "/usr/local/include/dovecot/byteorder.h", "reportHash": "9987dc3858b67b52bc3f56443e6017bb", "checkerName": "hicpp-signed-bitwise", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 10, "file": 27, "line": 106}, "message": "use of a signed integer operand with a binary bitwise operator"}], "macros": [], "notes": [], "path": "/usr/local/include/dovecot/byteorder.h", "reportHash": "609254a252bcc6446d4686f426df1de5", "checkerName": "hicpp-signed-bitwise", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 10, "file": 27, "line": 107}, "message": "use of a signed integer operand with a binary bitwise operator"}], "macros": [], "notes": [], "path": "/usr/local/include/dovecot/byteorder.h", "reportHash": "f99f92936bd0070a5ceaf89e9c17ef4e", "checkerName": "hicpp-signed-bitwise", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 11, "file": 27, "line": 107}, "message": "use of a signed integer operand with a binary bitwise operator"}], "macros": [], "notes": [], "path": "/usr/local/include/dovecot/byteorder.h", "reportHash": "2250f6421fe46437bbf7bb5ad1863c6a", "checkerName": "hicpp-signed-bitwise", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 10, "file": 27, "line": 108}, "message": "use of a signed integer operand with a binary bitwise operator"}], "macros": [], "notes": [], "path": "/usr/local/include/dovecot/byteorder.h", "reportHash": "38b94833c25798df6ebe2da81e3b1632", "checkerName": "hicpp-signed-bitwise", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 11, "file": 27, "line": 108}, "message": "use of a signed integer operand with a binary bitwise operator"}], "macros": [], "notes": [], "path": "/usr/local/include/dovecot/byteorder.h", "reportHash": "e93bf689e80f76a8a6273f80fd4e2f12", "checkerName": "hicpp-signed-bitwise", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 10, "file": 27, "line": 109}, "message": "use of a signed integer operand with a binary bitwise operator"}], "macros": [], "notes": [], "path": "/usr/local/include/dovecot/byteorder.h", "reportHash": "fdb53ce0707461fbf7188c7caa4b5b74", "checkerName": "hicpp-signed-bitwise", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 11, "file": 27, "line": 109}, "message": "use of a signed integer operand with a binary bitwise operator"}], "macros": [], "notes": [], "path": "/usr/local/include/dovecot/byteorder.h", "reportHash": "a3359c4b2e5ea2664b130e1a145b1b54", "checkerName": "hicpp-signed-bitwise", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 9, "file": 27, "line": 114}, "message": "use of a signed integer operand with a binary bitwise operator"}], "macros": [], "notes": [], "path": "/usr/local/include/dovecot/byteorder.h", "reportHash": "a2f9e8670ee448d77f744ee6056a73d1", "checkerName": "hicpp-signed-bitwise", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 10, "file": 27, "line": 114}, "message": "use of a signed integer operand with a binary bitwise operator"}], "macros": [], "notes": [], "path": "/usr/local/include/dovecot/byteorder.h", "reportHash": "b943a4a06db0ab4d2b6bc85277665be1", "checkerName": "hicpp-signed-bitwise", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 11, "file": 27, "line": 114}, "message": "use of a signed integer operand with a binary bitwise operator"}], "macros": [], "notes": [], "path": "/usr/local/include/dovecot/byteorder.h", "reportHash": "9ba9907d621be0725492ebdfaf837cfc", "checkerName": "hicpp-signed-bitwise", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 10, "file": 27, "line": 115}, "message": "use of a signed integer operand with a binary bitwise operator"}], "macros": [], "notes": [], "path": "/usr/local/include/dovecot/byteorder.h", "reportHash": "0e013521076f7696d2a860ff4c580b70", "checkerName": "hicpp-signed-bitwise", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 11, "file": 27, "line": 115}, "message": "use of a signed integer operand with a binary bitwise operator"}], "macros": [], "notes": [], "path": "/usr/local/include/dovecot/byteorder.h", "reportHash": "0d57b1bc07ead1b9229a65578e46225c", "checkerName": "hicpp-signed-bitwise", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 10, "file": 27, "line": 120}, "message": "use of a signed integer operand with a binary bitwise operator"}], "macros": [], "notes": [], "path": "/usr/local/include/dovecot/byteorder.h", "reportHash": "360cf1c47399072ccb3d98f4ca8116ef", "checkerName": "hicpp-signed-bitwise", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 11, "file": 27, "line": 130}, "message": "use of a signed integer operand with a binary bitwise operator"}], "macros": [], "notes": [], "path": "/usr/local/include/dovecot/byteorder.h", "reportHash": "00298319e51bffeb00ce618549625dc3", "checkerName": "hicpp-signed-bitwise", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 4, "file": 27, "line": 131}, "message": "use of a signed integer operand with a binary bitwise operator"}], "macros": [], "notes": [], "path": "/usr/local/include/dovecot/byteorder.h", "reportHash": "2ca566a1c1a791ab72cfb525cbd0b5a8", "checkerName": "hicpp-signed-bitwise", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 4, "file": 27, "line": 132}, "message": "use of a signed integer operand with a binary bitwise operator"}], "macros": [], "notes": [], "path": "/usr/local/include/dovecot/byteorder.h", "reportHash": "87eb8c71b724724b9fc59055efdfde4e", "checkerName": "hicpp-signed-bitwise", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 4, "file": 27, "line": 133}, "message": "use of a signed integer operand with a binary bitwise operator"}], "macros": [], "notes": [], "path": "/usr/local/include/dovecot/byteorder.h", "reportHash": "a4c61c0ebb9ea0e4b43335af14980cfa", "checkerName": "hicpp-signed-bitwise", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 4, "file": 27, "line": 134}, "message": "use of a signed integer operand with a binary bitwise operator"}], "macros": [], "notes": [], "path": "/usr/local/include/dovecot/byteorder.h", "reportHash": "d9a70234c6ff3340abe7f69e8a8a24bf", "checkerName": "hicpp-signed-bitwise", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 4, "file": 27, "line": 135}, "message": "use of a signed integer operand with a binary bitwise operator"}], "macros": [], "notes": [], "path": "/usr/local/include/dovecot/byteorder.h", "reportHash": "cc6b34e1bbc614ac1ab0afb5fbdab307", "checkerName": "hicpp-signed-bitwise", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 4, "file": 27, "line": 136}, "message": "use of a signed integer operand with a binary bitwise operator"}], "macros": [], "notes": [], "path": "/usr/local/include/dovecot/byteorder.h", "reportHash": "282a3b2a5f342a6cc96cd358948a095b", "checkerName": "hicpp-signed-bitwise", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 9, "file": 27, "line": 144}, "message": "use of a signed integer operand with a binary bitwise operator"}], "macros": [], "notes": [], "path": "/usr/local/include/dovecot/byteorder.h", "reportHash": "fbb12e26d30b24937777cad8ebed7bc4", "checkerName": "hicpp-signed-bitwise", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 10, "file": 27, "line": 144}, "message": "use of a signed integer operand with a binary bitwise operator"}], "macros": [], "notes": [], "path": "/usr/local/include/dovecot/byteorder.h", "reportHash": "08f8c9d6369064bfd263d80181f25106", "checkerName": "hicpp-signed-bitwise", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 9, "file": 27, "line": 145}, "message": "use of a signed integer operand with a binary bitwise operator"}], "macros": [], "notes": [], "path": "/usr/local/include/dovecot/byteorder.h", "reportHash": "b63c5111434d175e19e4341f08c685ec", "checkerName": "hicpp-signed-bitwise", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 10, "file": 27, "line": 145}, "message": "use of a signed integer operand with a binary bitwise operator"}], "macros": [], "notes": [], "path": "/usr/local/include/dovecot/byteorder.h", "reportHash": "3d3291da47f0695031d008e57d4bfa88", "checkerName": "hicpp-signed-bitwise", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 9, "file": 27, "line": 146}, "message": "use of a signed integer operand with a binary bitwise operator"}], "macros": [], "notes": [], "path": "/usr/local/include/dovecot/byteorder.h", "reportHash": "e806689189ed16e74eeb47a833b07bf3", "checkerName": "hicpp-signed-bitwise", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 10, "file": 27, "line": 146}, "message": "use of a signed integer operand with a binary bitwise operator"}], "macros": [], "notes": [], "path": "/usr/local/include/dovecot/byteorder.h", "reportHash": "3ff2df53b9a1afc3e5ac042b5b53a215", "checkerName": "hicpp-signed-bitwise", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 9, "file": 27, "line": 147}, "message": "use of a signed integer operand with a binary bitwise operator"}], "macros": [], "notes": [], "path": "/usr/local/include/dovecot/byteorder.h", "reportHash": "2af071988f02bf73a494cb930cb6b35a", "checkerName": "hicpp-signed-bitwise", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 10, "file": 27, "line": 147}, "message": "use of a signed integer operand with a binary bitwise operator"}], "macros": [], "notes": [], "path": "/usr/local/include/dovecot/byteorder.h", "reportHash": "c962886c31eb02cff5d2a66104e8093b", "checkerName": "hicpp-signed-bitwise", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 9, "file": 27, "line": 148}, "message": "use of a signed integer operand with a binary bitwise operator"}], "macros": [], "notes": [], "path": "/usr/local/include/dovecot/byteorder.h", "reportHash": "a65e26c570168dff02aee9c3a453e4cf", "checkerName": "hicpp-signed-bitwise", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 10, "file": 27, "line": 148}, "message": "use of a signed integer operand with a binary bitwise operator"}], "macros": [], "notes": [], "path": "/usr/local/include/dovecot/byteorder.h", "reportHash": "d86064c3ff16926915af670f55b620e7", "checkerName": "hicpp-signed-bitwise", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 9, "file": 27, "line": 149}, "message": "use of a signed integer operand with a binary bitwise operator"}], "macros": [], "notes": [], "path": "/usr/local/include/dovecot/byteorder.h", "reportHash": "6ce8695ae3e59295fa8b1485b1043030", "checkerName": "hicpp-signed-bitwise", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 10, "file": 27, "line": 149}, "message": "use of a signed integer operand with a binary bitwise operator"}], "macros": [], "notes": [], "path": "/usr/local/include/dovecot/byteorder.h", "reportHash": "ea7f77494c7b26d183c10a1a10560b77", "checkerName": "hicpp-signed-bitwise", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 9, "file": 27, "line": 150}, "message": "use of a signed integer operand with a binary bitwise operator"}], "macros": [], "notes": [], "path": "/usr/local/include/dovecot/byteorder.h", "reportHash": "0791a5ce61c99bfd8ebb28c828bb6c8a", "checkerName": "hicpp-signed-bitwise", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 10, "file": 27, "line": 150}, "message": "use of a signed integer operand with a binary bitwise operator"}], "macros": [], "notes": [], "path": "/usr/local/include/dovecot/byteorder.h", "reportHash": "3c144f85203cbc5fd3605c671189ba62", "checkerName": "hicpp-signed-bitwise", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 9, "file": 27, "line": 151}, "message": "use of a signed integer operand with a binary bitwise operator"}], "macros": [], "notes": [], "path": "/usr/local/include/dovecot/byteorder.h", "reportHash": "f1d1b1312f891d1c96b2daa103463d11", "checkerName": "hicpp-signed-bitwise", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 11, "file": 27, "line": 158}, "message": "use of a signed integer operand with a binary bitwise operator"}], "macros": [], "notes": [], "path": "/usr/local/include/dovecot/byteorder.h", "reportHash": "56df2f70449c1ea2a50cf95ab59f10a1", "checkerName": "hicpp-signed-bitwise", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 4, "file": 27, "line": 159}, "message": "use of a signed integer operand with a binary bitwise operator"}], "macros": [], "notes": [], "path": "/usr/local/include/dovecot/byteorder.h", "reportHash": "a4013dad66931f3e085253731adff0e0", "checkerName": "hicpp-signed-bitwise", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 4, "file": 27, "line": 160}, "message": "use of a signed integer operand with a binary bitwise operator"}], "macros": [], "notes": [], "path": "/usr/local/include/dovecot/byteorder.h", "reportHash": "89cfa133724d11e86d036c30facc2267", "checkerName": "hicpp-signed-bitwise", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 9, "file": 27, "line": 168}, "message": "use of a signed integer operand with a binary bitwise operator"}], "macros": [], "notes": [], "path": "/usr/local/include/dovecot/byteorder.h", "reportHash": "32d244e7dd6d71cb4ca6d1b47ffb7d7b", "checkerName": "hicpp-signed-bitwise", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 10, "file": 27, "line": 168}, "message": "use of a signed integer operand with a binary bitwise operator"}], "macros": [], "notes": [], "path": "/usr/local/include/dovecot/byteorder.h", "reportHash": "350b670bf40c276ba61acabea46a63f1", "checkerName": "hicpp-signed-bitwise", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 9, "file": 27, "line": 169}, "message": "use of a signed integer operand with a binary bitwise operator"}], "macros": [], "notes": [], "path": "/usr/local/include/dovecot/byteorder.h", "reportHash": "a22e0ba776476f1e9cee935a022ba60e", "checkerName": "hicpp-signed-bitwise", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 10, "file": 27, "line": 169}, "message": "use of a signed integer operand with a binary bitwise operator"}], "macros": [], "notes": [], "path": "/usr/local/include/dovecot/byteorder.h", "reportHash": "a26c1ed8358735573f13789752235d7f", "checkerName": "hicpp-signed-bitwise", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 9, "file": 27, "line": 170}, "message": "use of a signed integer operand with a binary bitwise operator"}], "macros": [], "notes": [], "path": "/usr/local/include/dovecot/byteorder.h", "reportHash": "1b9a296def4d5bacd5ab991c2e778aff", "checkerName": "hicpp-signed-bitwise", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 10, "file": 27, "line": 170}, "message": "use of a signed integer operand with a binary bitwise operator"}], "macros": [], "notes": [], "path": "/usr/local/include/dovecot/byteorder.h", "reportHash": "0c37310e7597e504ca1bff93c07a3169", "checkerName": "hicpp-signed-bitwise", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 9, "file": 27, "line": 171}, "message": "use of a signed integer operand with a binary bitwise operator"}], "macros": [], "notes": [], "path": "/usr/local/include/dovecot/byteorder.h", "reportHash": "072b0c0bc3c504704993f44b8ba55069", "checkerName": "hicpp-signed-bitwise", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 10, "file": 27, "line": 178}, "message": "use of a signed integer operand with a binary bitwise operator"}], "macros": [], "notes": [], "path": "/usr/local/include/dovecot/byteorder.h", "reportHash": "affcbbe089dfd9f860fd8c73f3516bc2", "checkerName": "hicpp-signed-bitwise", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 11, "file": 27, "line": 178}, "message": "use of a signed integer operand with a binary bitwise operator"}], "macros": [], "notes": [], "path": "/usr/local/include/dovecot/byteorder.h", "reportHash": "24edcef8c0721084e77f2ac6d664c167", "checkerName": "hicpp-signed-bitwise", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 9, "file": 27, "line": 186}, "message": "use of a signed integer operand with a binary bitwise operator"}], "macros": [], "notes": [], "path": "/usr/local/include/dovecot/byteorder.h", "reportHash": "dadd486f3c9d4615f76564f60641aa70", "checkerName": "hicpp-signed-bitwise", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 10, "file": 27, "line": 186}, "message": "use of a signed integer operand with a binary bitwise operator"}], "macros": [], "notes": [], "path": "/usr/local/include/dovecot/byteorder.h", "reportHash": "844cd29788ba84d55bd47a31c0ed3bff", "checkerName": "hicpp-signed-bitwise", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 9, "file": 27, "line": 187}, "message": "use of a signed integer operand with a binary bitwise operator"}], "macros": [], "notes": [], "path": "/usr/local/include/dovecot/byteorder.h", "reportHash": "9fb965bf9606009e222db3eb9428da26", "checkerName": "hicpp-signed-bitwise", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 9, "file": 28, "line": 1}, "message": "DOVECOT_COMPAT_H (fixit)"}, {"location": {"col": 9, "file": 28, "line": 1}, "message": "header guard does not follow preferred style"}], "macros": [], "notes": [], "path": "/usr/local/include/dovecot/compat.h", "reportHash": "5345ac4cf0369227f3f216c6ae78d8a4", "checkerName": "llvm-header-guard", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 12, "file": 29, "line": 453}, "message": "previously declared here"}, {"location": {"col": 5, "file": 28, "line": 47}, "message": "redundant 'rand' declaration"}], "macros": [], "notes": [], "path": "/usr/local/include/dovecot/compat.h", "reportHash": "8f0ec306c2e858f6bb74584c52eb381a", "checkerName": "readability-redundant-declaration", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 12, "file": 29, "line": 459}, "message": "previously declared here"}, {"location": {"col": 5, "file": 28, "line": 48}, "message": "redundant 'rand_r' declaration"}], "macros": [], "notes": [], "path": "/usr/local/include/dovecot/compat.h", "reportHash": "3a79bafca76e2fa5cc174b3f16df9f52", "checkerName": "readability-redundant-declaration", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 1, "file": 30, "line": 1}, "message": "header is missing header guard"}], "macros": [], "notes": [], "path": "/usr/local/include/dovecot/config.h", "reportHash": "562bc09508681098cb0c0aa40f3642db", "checkerName": "llvm-header-guard", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 9, "file": 31, "line": 1}, "message": "DOVECOT_DATA_STACK_H (fixit)"}, {"location": {"col": 9, "file": 31, "line": 1}, "message": "header guard does not follow preferred style"}], "macros": [], "notes": [], "path": "/usr/local/include/dovecot/data-stack.h", "reportHash": "2af644d600b91bde37acc4825777407c", "checkerName": "llvm-header-guard", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 9, "file": 32, "line": 1}, "message": "DOVECOT_EVENT_LOG_H (fixit)"}, {"location": {"col": 9, "file": 32, "line": 1}, "message": "header guard does not follow preferred style"}], "macros": [], "notes": [], "path": "/usr/local/include/dovecot/event-log.h", "reportHash": "470ebf2e08bb62d68b78afee6f252124", "checkerName": "llvm-header-guard", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 9, "file": 33, "line": 1}, "message": "DOVECOT_FAILURES_H (fixit)"}, {"location": {"col": 9, "file": 33, "line": 1}, "message": "header guard does not follow preferred style"}], "macros": [], "notes": [], "path": "/usr/local/include/dovecot/failures.h", "reportHash": "1cdf2fbab194eea0fc3338de66f0bfa6", "checkerName": "llvm-header-guard", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 36, "file": 33, "line": 116}, "message": "parameter 'callback' is const-qualified in the function declaration; const-qualification of parameters only has an effect in function definitions"}], "macros": [], "notes": [], "path": "/usr/local/include/dovecot/failures.h", "reportHash": "c635b1052826da3612688486027f530f", "checkerName": "readability-avoid-const-params-in-decls", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 9, "file": 34, "line": 1}, "message": "DOVECOT_FD_UTIL_H (fixit)"}, {"location": {"col": 9, "file": 34, "line": 1}, "message": "header guard does not follow preferred style"}], "macros": [], "notes": [], "path": "/usr/local/include/dovecot/fd-util.h", "reportHash": "f46d4ce1c7320e78c926a74c73e174d9", "checkerName": "llvm-header-guard", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 9, "file": 35, "line": 1}, "message": "DOVECOT_HASH_DECL_H (fixit)"}, {"location": {"col": 9, "file": 35, "line": 1}, "message": "header guard does not follow preferred style"}], "macros": [], "notes": [], "path": "/usr/local/include/dovecot/hash-decl.h", "reportHash": "23f3c3376f9b14b9e9db42685f7d270b", "checkerName": "llvm-header-guard", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 17, "file": 35, "line": 7}, "message": "() (fixit)"}, {"location": {"col": 3, "file": 35, "line": 7}, "message": "macro argument should be enclosed in parentheses"}], "macros": [], "notes": [], "path": "/usr/local/include/dovecot/hash-decl.h", "reportHash": "fbd613a690c78cac5282884730ad6941", "checkerName": "misc-macro-parentheses", "reviewStatus": null, "severity": "MEDIUM"}, {"events": [{"location": {"col": 17, "file": 35, "line": 10}, "message": "() (fixit)"}, {"location": {"col": 3, "file": 35, "line": 10}, "message": "macro argument should be enclosed in parentheses"}], "macros": [], "notes": [], "path": "/usr/local/include/dovecot/hash-decl.h", "reportHash": "a4f3c94d8e57352a284d1338832e79df", "checkerName": "misc-macro-parentheses", "reviewStatus": null, "severity": "MEDIUM"}, {"events": [{"location": {"col": 9, "file": 36, "line": 1}, "message": "DOVECOT_IMEM_H (fixit)"}, {"location": {"col": 9, "file": 36, "line": 1}, "message": "header guard does not follow preferred style"}], "macros": [], "notes": [], "path": "/usr/local/include/dovecot/imem.h", "reportHash": "047beae7712fa48d93f541d12a9af7ea", "checkerName": "llvm-header-guard", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 9, "file": 37, "line": 1}, "message": "DOVECOT_LIB_EVENT_H (fixit)"}, {"location": {"col": 9, "file": 37, "line": 1}, "message": "header guard does not follow preferred style"}], "macros": [], "notes": [], "path": "/usr/local/include/dovecot/lib-event.h", "reportHash": "e5752ec77b4e02f62b6ef4e43848ec57", "checkerName": "llvm-header-guard", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 47, "file": 37, "line": 209}, "message": "() (fixit)"}, {"location": {"col": 33, "file": 37, "line": 209}, "message": "macro argument should be enclosed in parentheses"}], "macros": [], "notes": [], "path": "/usr/local/include/dovecot/lib-event.h", "reportHash": "3fdc33dfb1c9fbb83b315341db267c64", "checkerName": "misc-macro-parentheses", "reviewStatus": null, "severity": "MEDIUM"}, {"events": [{"location": {"col": 64, "file": 37, "line": 209}, "message": "() (fixit)"}, {"location": {"col": 50, "file": 37, "line": 209}, "message": "macro argument should be enclosed in parentheses"}], "macros": [], "notes": [], "path": "/usr/local/include/dovecot/lib-event.h", "reportHash": "85135aa8641dd292315f1010ba319812", "checkerName": "misc-macro-parentheses", "reviewStatus": null, "severity": "MEDIUM"}, {"events": [{"location": {"col": 48, "file": 37, "line": 218}, "message": "() (fixit)"}, {"location": {"col": 34, "file": 37, "line": 218}, "message": "macro argument should be enclosed in parentheses"}], "macros": [], "notes": [], "path": "/usr/local/include/dovecot/lib-event.h", "reportHash": "6e04bd5ba0f1919796e283112da08a59", "checkerName": "misc-macro-parentheses", "reviewStatus": null, "severity": "MEDIUM"}, {"events": [{"location": {"col": 65, "file": 37, "line": 218}, "message": "() (fixit)"}, {"location": {"col": 51, "file": 37, "line": 218}, "message": "macro argument should be enclosed in parentheses"}], "macros": [], "notes": [], "path": "/usr/local/include/dovecot/lib-event.h", "reportHash": "7874e3801bc6ad80420e646d1a386d68", "checkerName": "misc-macro-parentheses", "reviewStatus": null, "severity": "MEDIUM"}, {"events": [{"location": {"col": 9, "file": 38, "line": 1}, "message": "DOVECOT_LIB_H (fixit)"}, {"location": {"col": 9, "file": 38, "line": 1}, "message": "header guard does not follow preferred style"}], "macros": [], "notes": [], "path": "/usr/local/include/dovecot/lib.h", "reportHash": "668f8e0631abd0883b9e52af91c0bdbd", "checkerName": "llvm-header-guard", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 10, "file": 38, "line": 16}, "message": "<errno.h> /* error checking is good */ (fixit)"}, {"location": {"col": 1, "file": 38, "line": 16}, "message": "#includes are not sorted properly"}], "macros": [], "notes": [], "path": "/usr/local/include/dovecot/lib.h", "reportHash": "395a4d2a5c5bbae4246da09bc0b483b3", "checkerName": "llvm-include-order", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 10, "file": 38, "line": 27}, "message": "\"failures.h\" (fixit)"}, {"location": {"col": 1, "file": 38, "line": 27}, "message": "#includes are not sorted properly"}], "macros": [], "notes": [], "path": "/usr/local/include/dovecot/lib.h", "reportHash": "de39a5f8ae00defcbe2acebf48b6ef36", "checkerName": "llvm-include-order", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 10, "file": 38, "line": 30}, "message": "\"byteorder.h\" (fixit)"}, {"location": {"col": 1, "file": 38, "line": 30}, "message": "#includes are not sorted properly"}], "macros": [], "notes": [], "path": "/usr/local/include/dovecot/lib.h", "reportHash": "790d0a8df7c3ba0aa5cc0e6a2f0a42de", "checkerName": "llvm-include-order", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 10, "file": 38, "line": 47}, "message": "\"event-log.h\" (fixit)"}, {"location": {"col": 1, "file": 38, "line": 47}, "message": "#includes are not sorted properly"}], "macros": [], "notes": [], "path": "/usr/local/include/dovecot/lib.h", "reportHash": "efb3c1b0443da3dfe369ebd813719c9d", "checkerName": "llvm-include-order", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 34, "file": 38, "line": 52}, "message": "(  ) (fixit)"}, {"location": {"col": 34, "file": 38, "line": 52}, "message": "macro replacement list should be enclosed in parentheses"}], "macros": [], "notes": [], "path": "/usr/local/include/dovecot/lib.h", "reportHash": "0badabeaeb3032460ff758f1e161e1af", "checkerName": "misc-macro-parentheses", "reviewStatus": null, "severity": "MEDIUM"}, {"events": [{"location": {"col": 9, "file": 39, "line": 1}, "message": "DOVECOT_MACROS_H (fixit)"}, {"location": {"col": 9, "file": 39, "line": 1}, "message": "header guard does not follow preferred style"}], "macros": [], "notes": [], "path": "/usr/local/include/dovecot/macros.h", "reportHash": "65711be3588bc07fbab954721d30ed94", "checkerName": "llvm-header-guard", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 25, "file": 39, "line": 163}, "message": "() (fixit)"}, {"location": {"col": 11, "file": 39, "line": 163}, "message": "macro argument should be enclosed in parentheses"}], "macros": [], "notes": [], "path": "/usr/local/include/dovecot/macros.h", "reportHash": "c68612e73f83c24309e2b0762f34527a", "checkerName": "misc-macro-parentheses", "reviewStatus": null, "severity": "MEDIUM"}, {"events": [{"location": {"col": 9, "file": 40, "line": 1}, "message": "DOVECOT_MALLOC_OVERFLOW_H (fixit)"}, {"location": {"col": 9, "file": 40, "line": 1}, "message": "header guard does not follow preferred style"}], "macros": [], "notes": [], "path": "/usr/local/include/dovecot/malloc-overflow.h", "reportHash": "f9837ba0fd3062af3f92c9d99f41dd0c", "checkerName": "llvm-header-guard", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 9, "file": 41, "line": 1}, "message": "DOVECOT_MEMPOOL_H (fixit)"}, {"location": {"col": 9, "file": 41, "line": 1}, "message": "header guard does not follow preferred style"}], "macros": [], "notes": [], "path": "/usr/local/include/dovecot/mempool.h", "reportHash": "3f48db8b66a8c11009bca668f06d6186", "checkerName": "llvm-header-guard", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 64, "file": 41, "line": 104}, "message": "{ (fixit)"}, {"location": {"col": 56, "file": 41, "line": 104}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "/usr/local/include/dovecot/mempool.h", "reportHash": "102f394771be5e939b8752174e4f5864", "checkerName": "google-readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 72, "file": 41, "line": 113}, "message": "{ (fixit)"}, {"location": {"col": 64, "file": 41, "line": 113}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "/usr/local/include/dovecot/mempool.h", "reportHash": "b34b89e890fe958145741e55cf90131b", "checkerName": "google-readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 26, "file": 41, "line": 117}, "message": "{ (fixit)"}, {"location": {"col": 18, "file": 41, "line": 117}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "/usr/local/include/dovecot/mempool.h", "reportHash": "35d2a639d5c93609ace2e00fd7c36a9d", "checkerName": "google-readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 26, "file": 41, "line": 134}, "message": "{ (fixit)"}, {"location": {"col": 18, "file": 41, "line": 134}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "/usr/local/include/dovecot/mempool.h", "reportHash": "73ccd3ed31f823432dc752b3451c14c2", "checkerName": "google-readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 28, "file": 41, "line": 160}, "message": "{ (fixit)"}, {"location": {"col": 20, "file": 41, "line": 160}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "/usr/local/include/dovecot/mempool.h", "reportHash": "1fb4791884190a4c1a3c2068f545463f", "checkerName": "google-readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 9, "file": 42, "line": 1}, "message": "DOVECOT_SMTP_ADDRESS_H (fixit)"}, {"location": {"col": 9, "file": 42, "line": 1}, "message": "header guard does not follow preferred style"}], "macros": [], "notes": [], "path": "/usr/local/include/dovecot/smtp-address.h", "reportHash": "363c78e657e803079bdf49d3ceb0c5f4", "checkerName": "llvm-header-guard", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 17, "file": 25, "line": 7}, "message": "expanded from macro 'BIT'"}, {"location": {"col": 48, "file": 42, "line": 10}, "message": "use of a signed integer operand with a binary bitwise operator"}], "macros": [], "notes": [], "path": "/usr/local/include/dovecot/smtp-address.h", "reportHash": "2f45a21e918de8becb3b6fdf6d85337b", "checkerName": "hicpp-signed-bitwise", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 17, "file": 25, "line": 7}, "message": "expanded from macro 'BIT'"}, {"location": {"col": 48, "file": 42, "line": 12}, "message": "use of a signed integer operand with a binary bitwise operator"}], "macros": [], "notes": [], "path": "/usr/local/include/dovecot/smtp-address.h", "reportHash": "56f91ae3d2b8fd16f267b2f888d8c216", "checkerName": "hicpp-signed-bitwise", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 17, "file": 25, "line": 7}, "message": "expanded from macro 'BIT'"}, {"location": {"col": 48, "file": 42, "line": 14}, "message": "use of a signed integer operand with a binary bitwise operator"}], "macros": [], "notes": [], "path": "/usr/local/include/dovecot/smtp-address.h", "reportHash": "6f9791f01f5507660042335f1c0782b2", "checkerName": "hicpp-signed-bitwise", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 17, "file": 25, "line": 7}, "message": "expanded from macro 'BIT'"}, {"location": {"col": 48, "file": 42, "line": 17}, "message": "use of a signed integer operand with a binary bitwise operator"}], "macros": [], "notes": [], "path": "/usr/local/include/dovecot/smtp-address.h", "reportHash": "b353501e19012cb1b41d3708c3279c06", "checkerName": "hicpp-signed-bitwise", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 17, "file": 25, "line": 7}, "message": "expanded from macro 'BIT'"}, {"location": {"col": 48, "file": 42, "line": 24}, "message": "use of a signed integer operand with a binary bitwise operator"}], "macros": [], "notes": [], "path": "/usr/local/include/dovecot/smtp-address.h", "reportHash": "6fcf53d319f2c58605e476ea6e06749d", "checkerName": "hicpp-signed-bitwise", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 17, "file": 25, "line": 7}, "message": "expanded from macro 'BIT'"}, {"location": {"col": 48, "file": 42, "line": 29}, "message": "use of a signed integer operand with a binary bitwise operator"}], "macros": [], "notes": [], "path": "/usr/local/include/dovecot/smtp-address.h", "reportHash": "33e61e8af4e76b3281482a24ce8b021c", "checkerName": "hicpp-signed-bitwise", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 17, "file": 25, "line": 7}, "message": "expanded from macro 'BIT'"}, {"location": {"col": 48, "file": 42, "line": 37}, "message": "use of a signed integer operand with a binary bitwise operator"}], "macros": [], "notes": [], "path": "/usr/local/include/dovecot/smtp-address.h", "reportHash": "37446780cc360d031572199b966fa575", "checkerName": "hicpp-signed-bitwise", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 9, "file": 43, "line": 1}, "message": "DOVECOT_STR_SANITIZE_H (fixit)"}, {"location": {"col": 9, "file": 43, "line": 1}, "message": "header guard does not follow preferred style"}], "macros": [], "notes": [], "path": "/usr/local/include/dovecot/str-sanitize.h", "reportHash": "f28852c1e89e80144b7b269dc5372b44", "checkerName": "llvm-header-guard", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 9, "file": 44, "line": 1}, "message": "DOVECOT_STR_H (fixit)"}, {"location": {"col": 9, "file": 44, "line": 1}, "message": "header guard does not follow preferred style"}], "macros": [], "notes": [], "path": "/usr/local/include/dovecot/str.h", "reportHash": "ede4eaeb7160eeda249d3f220d6b5ecd", "checkerName": "llvm-header-guard", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 33, "file": 44, "line": 78}, "message": "{ (fixit)"}, {"location": {"col": 25, "file": 44, "line": 78}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "/usr/local/include/dovecot/str.h", "reportHash": "ba7d0417a75f3d89c96677a72f40c18e", "checkerName": "google-readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 9, "file": 45, "line": 1}, "message": "DOVECOT_STRFUNCS_H (fixit)"}, {"location": {"col": 9, "file": 45, "line": 1}, "message": "header guard does not follow preferred style"}], "macros": [], "notes": [], "path": "/usr/local/include/dovecot/strfuncs.h", "reportHash": "65e3c8522598dcead28a7482f5fbf407", "checkerName": "llvm-header-guard", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 14, "file": 45, "line": 102}, "message": "redundant cast to the same type"}], "macros": [], "notes": [], "path": "/usr/local/include/dovecot/strfuncs.h", "reportHash": "50855db3f0c52806834ea48f16c78f97", "checkerName": "google-readability-casting", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 9, "file": 46, "line": 1}, "message": "DOVECOT_STRNUM_H (fixit)"}, {"location": {"col": 9, "file": 46, "line": 1}, "message": "header guard does not follow preferred style"}], "macros": [], "notes": [], "path": "/usr/local/include/dovecot/strnum.h", "reportHash": "c2f2fcf18b96a90d3f81b81c173754d0", "checkerName": "llvm-header-guard", "reviewStatus": null, "severity": "LOW"}]};
      window.onload = function() {
        if (!browserCompatible) {
          setNonCompatibleBrowserMessage();
        } else {
          BugViewer.init(data.files, data.reports);
          BugViewer.create();
          BugViewer.initByUrl();
        }
      };
    </script>
  </head>
  <body>
  <div class="container">
    <div id="content">
      <div id="side-bar">
        <div class="header">
          <a href="index.html" class="button">&#8249; Return to List</a>
        </div>
        <div id="report-nav">
          <div class="header">Reports</div>
        </div>
      </div>
      <div id="editor-wrapper">
        <div class="header">
          <div id="file">
            <span class="label">File:</span>
            <span id="file-path"></span>
          </div>
          <div id="checker">
            <span class="label">Checker name:</span>
            <span id="checker-name"></span>
          </div>
          <div id="review-status-wrapper">
            <span class="label">Review status:</span>
            <span id="review-status"></span>
          </div>
        </div>
        <div id="editor"></div>
      </div>
    </div>
  </div>
  </body>
</html>
